<html>
<head>
<title>Why Data Scientists Should Learn Dynamic Programming</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么数据科学家应该学习动态编程</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/why-data-scientists-should-learn-dynamic-programming-e50dfe62a5c7?source=collection_archive---------10-----------------------#2021-07-16">https://towardsdatascience.com/why-data-scientists-should-learn-dynamic-programming-e50dfe62a5c7?source=collection_archive---------10-----------------------#2021-07-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="dc5a" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">数据结构和算法</h2><div class=""/><div class=""><h2 id="4fb4" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">数据科学家的基本算法</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/9a625a11fd5cab4ffa39405cca1a705d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gNAtbkgd-PqRl8VYnxkQHQ.jpeg"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">Birger Strahl 在<a class="ae lh" href="https://unsplash.com/s/photos/dynamic?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h1 id="25aa" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">介绍</h1><p id="a114" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">在当今的就业市场中，数据科学不再是一个纯粹的分析领域，而是需要编程和工程方面的丰富实践经验。除了模型开发和数据分析等正常职责之外，数据科学家正在与工程团队合作构建基础设施管道。对编程的深刻理解加快了生产进度，减少了摩擦。</p><p id="f0f1" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">Python广泛应用于数据科学和软件工程社区。就是这样一种通用的编程语言，提供了各种数据结构和算法，包括<a class="ae lh" href="https://www.w3schools.com/python/python_arrays.asp" rel="noopener ugc nofollow" target="_blank">数组</a>、<a class="ae lh" href="https://www.w3schools.com/python/python_sets.asp" rel="noopener ugc nofollow" target="_blank">集合</a>、<a class="ae lh" rel="noopener" target="_blank" href="/how-to-solve-python-coding-questions-using-stack-94571f31af3f?sk=82ce6f24681521226a4619d3d660dda9">堆栈</a>、<a class="ae lh" rel="noopener" target="_blank" href="/python-string-manipulation-for-data-scientists-in-2021-c5b9526347f4?sk=01b9defd7130d5e3f518d3503cc3bbf1">字符串</a>、<a class="ae lh" rel="noopener" target="_blank" href="/master-python-dictionary-for-beginners-in-2021-1cdbaa17ec45?sk=1e841ed0bc3eed23b07b80260a925938">字典</a> ( <a class="ae lh" rel="noopener" target="_blank" href="/master-python-dictionary-for-beginners-in-2021-1cdbaa17ec45?sk=1e841ed0bc3eed23b07b80260a925938">第一部分</a>和<a class="ae lh" rel="noopener" target="_blank" href="/master-data-type-dictionary-in-python-from-zero-to-hero-part-2-6513aad883de?sk=23264e4e8bb82db4229918f28a34a0c8">第二部分</a>)、<a class="ae lh" href="https://www.geeksforgeeks.org/heap-queue-or-heapq-in-python/" rel="noopener ugc nofollow" target="_blank">堆</a>、<a class="ae lh" rel="noopener" target="_blank" href="/binary-search-in-python-the-programming-algorithm-8b8fa039eaa?sk=cee7c5d7c49b43d2be5b8e50446ffc64">二分搜索法</a>等。</p><p id="71fc" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">在这篇博客文章中，我们将学习另一种流行的算法，称为<strong class="mc jd">动态编程</strong>，并了解为什么它的性能优于其他方法，如迭代和递归。</p></div><div class="ab cl nb nc hx nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="im in io ip iq"><h1 id="5994" class="li lj it bd lk ll ni ln lo lp nj lr ls ki nk kj lu kl nl km lw ko nm kp ly lz bi translated">什么是动态编程？</h1><p id="0e56" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">DP是一种算法，它将问题分解成子问题，并存储和重用之前计算的结果。</p><p id="baa5" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">我们将在DP之前介绍什么是递归。</p><p id="a211" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">递归函数是相对于自身定义的函数，这意味着函数将继续调用自身，直到满足某些条件。递归包含两个部分:基本情况和递归情况。该函数将不断迭代递归情况，并计算子问题的结果，直到满足基本情况。</p><p id="c179" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated"><a class="ae lh" href="https://www.w3schools.com/python/gloss_python_function_recursion.asp" rel="noopener ugc nofollow" target="_blank">递归</a>函数调用自身，反复重新计算子问题的结果，效率低下。</p><blockquote class="no"><p id="bdbc" class="np nq it bd nr ns nt nu nv nw nx mv dk translated">有什么解决办法吗？</p><p id="56f2" class="np nq it bd nr ns nt nu nv nw nx mv dk translated">记忆化！</p></blockquote><p id="5761" class="pw-post-body-paragraph ma mb it mc b md ny kd mf mg nz kg mi mj oa ml mm mn ob mp mq mr oc mt mu mv im bi translated">也就是说，我们缓存之前已经计算过的答案，并将结果存储在字典或列表中，这个过程叫做<strong class="mc jd">记忆化</strong>，显著提高了算法效率。</p><p id="2f58" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">我们将使用以下三个真实的面试问题来帮助我们更好地理解算法。首先，我们将浏览每个问题的思考过程，并讨论我们如何提出解决方案。然后，我们用Python编写代码，讨论它们的时间和空间复杂性。</p><p id="eb5a" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">这里，时间复杂度的大O符号是合适的。可以直观的查看各种算法的速度。例如，黄色区域中的线性时间O(n)比红色危险区域中的O(n)好得多。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi od"><img src="../Images/3fbac0508534ae7ed03ee657bf8c9796.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FrQtViX84Qcd4Gueic1V0Q.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated"><a class="ae lh" href="https://www.bigocheatsheet.com" rel="noopener ugc nofollow" target="_blank">https://www.bigocheatsheet.com</a></p></figure></div><div class="ab cl nb nc hx nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="im in io ip iq"><p id="4297" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated"><em class="nn">完整的Python代码请参考我的</em><a class="ae lh" href="https://github.com/LeihuaYe/Python_LeetCode_Coding" rel="noopener ugc nofollow" target="_blank"><em class="nn">Github</em></a><em class="nn">。</em></p></div><div class="ab cl nb nc hx nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="im in io ip iq"><h1 id="2423" class="li lj it bd lk ll ni ln lo lp nj lr ls ki nk kj lu kl nl km lw ko nm kp ly lz bi translated">问题1:阶乘</h1><blockquote class="oe of og"><p id="82f0" class="ma mb nn mc b md mw kd mf mg mx kg mi oh my ml mm oi mz mp mq oj na mt mu mv im bi translated">-一个数的阶乘，N是所有小于等于N的正整数的乘积，记为N！。</p><p id="e699" class="ma mb nn mc b md mw kd mf mg mx kg mi oh my ml mm oi mz mp mq oj na mt mu mv im bi translated">-比如3的阶乘是3！= 3*2*1 = 6.</p><p id="5d6c" class="ma mb nn mc b md mw kd mf mg mx kg mi oh my ml mm oi mz mp mq oj na mt mu mv im bi translated">-给定一个正数N，计算它的阶乘。</p></blockquote><h2 id="d13e" class="ok lj it bd lk ol om dn lo on oo dp ls mj op oq lu mn or os lw mr ot ou ly iz bi translated">走过我的思考</h2><p id="ec42" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">我的第一反应是应用迭代方法，将n范围内的元素相乘。</p><blockquote class="oe of og"><p id="e1b0" class="ma mb nn mc b md mw kd mf mg mx kg mi oh my ml mm oi mz mp mq oj na mt mu mv im bi translated">首先，我们定义一个名为<strong class="mc jd"> result </strong>的对象，并将其设置为1。</p><p id="cf2f" class="ma mb nn mc b md mw kd mf mg mx kg mi oh my ml mm oi mz mp mq oj na mt mu mv im bi translated">其次，迭代这些数字直到n+1并返回结果，如下所示。</p></blockquote><pre class="ks kt ku kv gt ov ow ox oy aw oz bi"><span id="73ee" class="ok lj it ow b gy pa pb l pc pd"># solution 1: for loop <br/>def factorial_1(n):<br/>    result = 1<br/>    for i in range(1,n+1):<br/>        result*=i<br/>    return result</span></pre><p id="f11f" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">迭代方法是线性的，因为for循环的迭代次数等于数的大小，直到n+1，aka。，线性时间复杂度。该算法包含线性空间复杂度，因为它存储从1到n+1的数。</p><p id="3fad" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">迭代方法具有以下特征:</p><pre class="ks kt ku kv gt ov ow ox oy aw oz bi"><span id="0d79" class="ok lj it ow b gy pa pb l pc pd">Time complexity: O(n)<br/>Space complexity: O(n)</span></pre><p id="0599" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">让我们试试递归。基本条件是当n等于1时，对于递归条件，我们递归地调用同一个函数。</p><pre class="ks kt ku kv gt ov ow ox oy aw oz bi"><span id="96c3" class="ok lj it ow b gy pa pb l pc pd"># solution 2: recursion<br/>def factorial_2(n):<br/>    if n==1:<br/>        return 1<br/> <br/>    else:<br/>        n *= factorial_2(n-1)<br/>    <br/> return n</span></pre><p id="0303" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">递归阶乘方法具有线性时间复杂度，因为它为每个数字调用一次自身。因此，迭代轮次与数目n成正比，即其时间复杂度为O(n)。此外，空间复杂度也是线性的，因为没有占用额外的空间。</p><p id="b959" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">递归方法具有以下特征:</p><pre class="ks kt ku kv gt ov ow ox oy aw oz bi"><span id="4383" class="ok lj it ow b gy pa pb l pc pd">Time complexity: O(n)</span><span id="0b30" class="ok lj it ow b gy pe pb l pc pd">Space complexity: O(n)</span></pre><p id="5ef1" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">如上所述，递归方法会多次计算相同的值。例如，我们已经计算了3的阶乘(即3*2*1 = 6)，但必须再次计算4的阶乘(即4*3*2*1)，这是低效的。</p><p id="5db2" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">当递归堆栈堆积时，递归迭代会显著降低速度。事实上，如果递归堆栈达到上限，递归方法可能无法运行。</p><p id="b7f7" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">为了解决重复计算的问题，我们可以通过存储先前的结果来应用动态编程方法。</p><h2 id="5655" class="ok lj it bd lk ol om dn lo on oo dp ls mj op oq lu mn or os lw mr ot ou ly iz bi translated">解决方案:动态编程</h2><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pf pg l"/></div></figure><pre class="ks kt ku kv gt ov ow ox oy aw oz bi"><span id="af57" class="ok lj it ow b gy pa pb l pc pd">3628800</span></pre><p id="d644" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">动态规划方法具有以下特点:</p><pre class="ks kt ku kv gt ov ow ox oy aw oz bi"><span id="267d" class="ok lj it ow b gy pa pb l pc pd">Time complexity: O(n)</span><span id="0983" class="ok lj it ow b gy pe pb l pc pd">Space complexity: O(n)</span></pre><p id="4ea5" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">方法2和3具有相同的时间和空间复杂度。那么，为什么我们认为动态规划方法更好呢？让我们来看看问题2的答案。</p></div><div class="ab cl nb nc hx nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="im in io ip iq"><h1 id="3d21" class="li lj it bd lk ll ni ln lo lp nj lr ls ki nk kj lu kl nl km lw ko nm kp ly lz bi translated">问题2:斐波那契数，被大家</h1><div class="ph pi gp gr pj pk"><a href="https://leetcode.com/problems/fibonacci-number/" rel="noopener  ugc nofollow" target="_blank"><div class="pl ab fo"><div class="pm ab pn cl cj po"><h2 class="bd jd gy z fp pp fr fs pq fu fw jc bi translated">斐波那契数— LeetCode</h2><div class="pr l"><h3 class="bd b gy z fp pp fr fs pq fu fw dk translated">提高你的编码技能，迅速找到工作。这是扩展你的知识和做好准备的最好地方…</h3></div><div class="ps l"><p class="bd b dl z fp pp fr fs pq fu fw dk translated">leetcode.com</p></div></div><div class="pt l"><div class="pu l pv pw px pt py lb pk"/></div></div></a></div><blockquote class="oe of og"><p id="5047" class="ma mb nn mc b md mw kd mf mg mx kg mi oh my ml mm oi mz mp mq oj na mt mu mv im bi translated">通常表示为<code class="fe pz qa qb ow b"><em class="it">F(n)</em></code>的<strong class="mc jd">斐波纳契数列</strong>形成了一个序列，称为<strong class="mc jd">斐波纳契数列</strong>，这样，从<code class="fe pz qa qb ow b"><em class="it">0</em></code>和<code class="fe pz qa qb ow b"><em class="it">1</em></code>开始，每个数字都是前两个数字的和。也就是说，</p><p id="b6b6" class="ma mb nn mc b md mw kd mf mg mx kg mi oh my ml mm oi mz mp mq oj na mt mu mv im bi translated">F(0) = 0，F(1) = 1 <br/> F(n) = F(n — 1) + F(n — 2)，对于n &gt; 1。</p><p id="292e" class="ma mb nn mc b md mw kd mf mg mx kg mi oh my ml mm oi mz mp mq oj na mt mu mv im bi translated">给定<code class="fe pz qa qb ow b"><em class="it">n</em></code>，计算<code class="fe pz qa qb ow b"><em class="it">F(n)</em></code>。</p></blockquote><h2 id="1ad7" class="ok lj it bd lk ol om dn lo on oo dp ls mj op oq lu mn or os lw mr ot ou ly iz bi translated">走过我的思考</h2><p id="42db" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">这是一个几乎每个大型科技公司都会问求职者的普遍问题。按照问题1中的相同步骤，我们可以比较迭代、递归和DP方法。</p><p id="86b3" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated"><strong class="mc jd"> #解决方案1:迭代方法</strong></p><p id="c4cd" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">简单地说，我们在for循环中不断更新三个项目的值:current、n1和n2。查看Python代码的解决方案。</p><p id="ad2d" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">迭代方法具有以下特征:</p><pre class="ks kt ku kv gt ov ow ox oy aw oz bi"><span id="d7c1" class="ok lj it ow b gy pa pb l pc pd">Time complexity: O(n)</span><span id="1b86" class="ok lj it ow b gy pe pb l pc pd">Space complexity: O(1)</span></pre><p id="7e56" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated"><strong class="mc jd"> #解决方案2:递归方法</strong></p><p id="d876" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">有两个条件:</p><ol class=""><li id="f210" class="qc qd it mc b md mw mg mx mj qe mn qf mr qg mv qh qi qj qk bi translated"><em class="nn">基本条件:0号位和1号位怎么办？</em></li><li id="cae9" class="qc qd it mc b md ql mg qm mj qn mn qo mr qp mv qh qi qj qk bi translated"><em class="nn">递归条件:位置2及以上怎么办？</em></li></ol><p id="60d5" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">我们从0和1开始，对每个位置的前两个函数求和，并对其他位置调用自身的函数，这是典型的递归设置！查看Python代码的解决方案。</p><p id="4a46" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">递归方法具有以下特征:</p><pre class="ks kt ku kv gt ov ow ox oy aw oz bi"><span id="7b96" class="ok lj it ow b gy pa pb l pc pd">Time Complexity: O(2^n)</span><span id="7fb8" class="ok lj it ow b gy pe pb l pc pd">Space Complexity: O(n)</span></pre><p id="67b8" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated"><strong class="mc jd"> #解决方案3: DP </strong></p><p id="0e78" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">与问题1类似，我们将之前的结果缓存在一个字典中，并在被调用时返回它们。回想一下，由于多次计算，递归方法具有O(2^n的时间复杂度。</p><p id="7500" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">得益于<strong class="mc jd">记忆化</strong>过程，DP方法将时间复杂度从O(2^n降低到O(n)，这对于算法性能是一个显著的改进。查看Big-O复杂性图表(如上)进行比较。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qq"><img src="../Images/52aa01940a447f15c275402442bd18d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uyf8VrxTt4WfKBVLBMmd9Q.png"/></div></div></figure><p id="d92f" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">让我们比较一下计算20的斐波那契数的这两种方法的运行时间。递归方法需要3.42毫秒(<em class="nn">毫秒，1/1000秒</em>，但是DP方法只需要215微秒(<em class="nn">微秒，1/1000000秒</em>)，几乎相差16倍。</p><p id="7c1b" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">迭代方法的时间复杂度与它在每一步中需要的调用次数成正比。因此，如果迭代需要多次调用自己，运行时间可能会很快增加。如果发生这种情况，DP方法就派上了用场，并为我们节省了大量时间。</p><p id="f5b2" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">动态规划方法具有以下特点:</p><pre class="ks kt ku kv gt ov ow ox oy aw oz bi"><span id="31e1" class="ok lj it ow b gy pa pb l pc pd">Time Complexity: O(n)</span><span id="82eb" class="ok lj it ow b gy pe pb l pc pd">Space Complexity: O(n)</span></pre></div><div class="ab cl nb nc hx nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="im in io ip iq"><h2 id="fea1" class="ok lj it bd lk ol om dn lo on oo dp ls mj op oq lu mn or os lw mr ot ou ly iz bi translated">解决办法</h2><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pf pg l"/></div></figure><pre class="ks kt ku kv gt ov ow ox oy aw oz bi"><span id="34dd" class="ok lj it ow b gy pa pb l pc pd">5</span></pre></div><div class="ab cl nb nc hx nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="im in io ip iq"><h1 id="2c04" class="li lj it bd lk ll ni ln lo lp nj lr ls ki nk kj lu kl nl km lw ko nm kp ly lz bi translated">问题3:最长的增长子序列</h1><div class="ph pi gp gr pj pk"><a href="https://leetcode.com/problems/longest-increasing-subsequence/" rel="noopener  ugc nofollow" target="_blank"><div class="pl ab fo"><div class="pm ab pn cl cj po"><h2 class="bd jd gy z fp pp fr fs pq fu fw jc bi translated">最长递增子序列— LeetCode</h2><div class="pr l"><h3 class="bd b gy z fp pp fr fs pq fu fw dk translated">给定整数数组nums，返回最长严格递增子序列的长度。子序列是一个…</h3></div><div class="ps l"><p class="bd b dl z fp pp fr fs pq fu fw dk translated">leetcode.com</p></div></div><div class="pt l"><div class="qr l pv pw px pt py lb pk"/></div></div></a></div><blockquote class="oe of og"><p id="5585" class="ma mb nn mc b md mw kd mf mg mx kg mi oh my ml mm oi mz mp mq oj na mt mu mv im bi translated">给定一个整数数组<code class="fe pz qa qb ow b"><em class="it">nums</em></code>，返回最长严格递增子序列的长度。</p><p id="eb9c" class="ma mb nn mc b md mw kd mf mg mx kg mi oh my ml mm oi mz mp mq oj na mt mu mv im bi translated"><strong class="mc jd">子序列</strong>是可以通过删除一些元素或不删除元素而不改变剩余元素的顺序来从数组中导出的序列。例如，<code class="fe pz qa qb ow b"><em class="it">[3,6,2,7]</em></code>是数组<code class="fe pz qa qb ow b"><em class="it">[0,3,1,6,2,2,7]</em></code>的子序列。</p></blockquote><h2 id="9b3b" class="ok lj it bd lk ol om dn lo on oo dp ls mj op oq lu mn or os lw mr ot ou ly iz bi translated">走过我的思考</h2><p id="0bab" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">该问题要求最长的长度，该长度取决于当前位置I和其先前位置i-1之间的相对值。然后，我们可以创建一个新的列表，<strong class="mc jd"> <em class="nn"> new_list </em> </strong>，其长度与nums相同，并将所有元素设置为1。换句话说，<strong class="mc jd"> <em class="nn"> new_list[i] </em> </strong>表示目前为止最长的递增子序列的长度。</p><p id="4898" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">然后，我们计算一个for循环中有多少元素小于<strong class="mc jd"><em class="nn">new _ list【I】</em></strong>。如果是，则向<strong class="mc jd"><em class="nn">new _ list【I】</em></strong>加1，并更新位置I处的较大值，aka。<strong class="mc jd"><em class="nn">【new _ list[I]= max(new _ list[I]，new_list[i]+1) </em> </strong>。</p><p id="9847" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">最后，从列表中返回最大值。</p><p id="8d67" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">由于嵌套的for循环和常数空间，该算法具有指数时间复杂度。</p><p id="2912" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">动态规划方法具有以下特点:</p><pre class="ks kt ku kv gt ov ow ox oy aw oz bi"><span id="0e35" class="ok lj it ow b gy pa pb l pc pd">Time complexity: O(N²)</span><span id="ff3c" class="ok lj it ow b gy pe pb l pc pd">Space complexity: O(N)</span></pre><h2 id="3c55" class="ok lj it bd lk ol om dn lo on oo dp ls mj op oq lu mn or os lw mr ot ou ly iz bi translated">解决办法</h2><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pf pg l"/></div></figure><pre class="ks kt ku kv gt ov ow ox oy aw oz bi"><span id="157d" class="ok lj it ow b gy pa pb l pc pd">4</span></pre></div><div class="ab cl nb nc hx nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="im in io ip iq"><p id="ddac" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated"><em class="nn">完整的Python代码请参考我的</em><a class="ae lh" href="https://github.com/LeihuaYe/Python_LeetCode_Coding" rel="noopener ugc nofollow" target="_blank"><em class="nn">Github</em></a><em class="nn">。</em></p></div><div class="ab cl nb nc hx nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="im in io ip iq"><h1 id="6c97" class="li lj it bd lk ll ni ln lo lp nj lr ls ki nk kj lu kl nl km lw ko nm kp ly lz bi translated">外卖食品</h1><ul class=""><li id="45af" class="qc qd it mc b md me mg mh mj qs mn qt mr qu mv qv qi qj qk bi translated">理解什么是递归，它的整个过程，优点和缺点。</li><li id="c5ae" class="qc qd it mc b md ql mg qm mj qn mn qo mr qp mv qv qi qj qk bi translated">记忆化可以通过存储以前的结果来提高算法性能。</li><li id="d153" class="qc qd it mc b md ql mg qm mj qn mn qo mr qp mv qv qi qj qk bi translated">DP在递归方法必须在每一步中多次调用自己的场景中表现出色。</li></ul></div><div class="ab cl nb nc hx nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="im in io ip iq"><p id="b905" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated"><em class="nn"> Medium最近进化出了自己的</em> <a class="ae lh" href="https://blog.medium.com/evolving-the-partner-program-2613708f9f3c" rel="noopener"> <em class="nn">作家伙伴计划</em> </a> <em class="nn">，支持像我这样的普通作家。如果你还不是订户，通过下面的链接注册，我会收到一部分会员费。</em></p><div class="ph pi gp gr pj pk"><a href="https://leihua-ye.medium.com/membership" rel="noopener follow" target="_blank"><div class="pl ab fo"><div class="pm ab pn cl cj po"><h2 class="bd jd gy z fp pp fr fs pq fu fw jc bi translated">阅读叶雷华博士研究员(以及其他成千上万的媒体作家)的每一个故事</h2><div class="pr l"><h3 class="bd b gy z fp pp fr fs pq fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="ps l"><p class="bd b dl z fp pp fr fs pq fu fw dk translated">leihua-ye.medium.com</p></div></div><div class="pt l"><div class="qw l pv pw px pt py lb pk"/></div></div></a></div></div><div class="ab cl nb nc hx nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="im in io ip iq"><h1 id="45d1" class="li lj it bd lk ll ni ln lo lp nj lr ls ki nk kj lu kl nl km lw ko nm kp ly lz bi translated">我的数据科学面试顺序:</h1><div class="ph pi gp gr pj pk"><a rel="noopener follow" target="_blank" href="/crack-data-science-interviews-five-sql-skills-for-data-scientists-cc6b32df1987"><div class="pl ab fo"><div class="pm ab pn cl cj po"><h2 class="bd jd gy z fp pp fr fs pq fu fw jc bi translated">破解数据科学访谈:数据科学家的五项SQL技能</h2><div class="pr l"><h3 class="bd b gy z fp pp fr fs pq fu fw dk translated">Leetcode助你获得高薪数据职位</h3></div><div class="ps l"><p class="bd b dl z fp pp fr fs pq fu fw dk translated">towardsdatascience.com</p></div></div><div class="pt l"><div class="qx l pv pw px pt py lb pk"/></div></div></a></div><div class="ph pi gp gr pj pk"><a rel="noopener follow" target="_blank" href="/5-python-coding-questions-asked-at-faang-59e6cf5ba2a0"><div class="pl ab fo"><div class="pm ab pn cl cj po"><h2 class="bd jd gy z fp pp fr fs pq fu fw jc bi translated">FAANG在2021年提出这5个Python问题</h2><div class="pr l"><h3 class="bd b gy z fp pp fr fs pq fu fw dk translated">数据科学家和数据工程师的必读！</h3></div><div class="ps l"><p class="bd b dl z fp pp fr fs pq fu fw dk translated">towardsdatascience.com</p></div></div><div class="pt l"><div class="qy l pv pw px pt py lb pk"/></div></div></a></div><div class="ph pi gp gr pj pk"><a rel="noopener follow" target="_blank" href="/6-python-questions-you-should-practice-before-coding-interviews-f958af55ad13"><div class="pl ab fo"><div class="pm ab pn cl cj po"><h2 class="bd jd gy z fp pp fr fs pq fu fw jc bi translated">2021年6个Python数据科学面试问题</h2><div class="pr l"><h3 class="bd b gy z fp pp fr fs pq fu fw dk translated">数据科学家/工程师的数据操作和字符串提取</h3></div><div class="ps l"><p class="bd b dl z fp pp fr fs pq fu fw dk translated">towardsdatascience.com</p></div></div><div class="pt l"><div class="qz l pv pw px pt py lb pk"/></div></div></a></div></div><div class="ab cl nb nc hx nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="im in io ip iq"><h1 id="a0cb" class="li lj it bd lk ll ni ln lo lp nj lr ls ki nk kj lu kl nl km lw ko nm kp ly lz bi translated">喜欢读这本书吗？</h1><blockquote class="oe of og"><p id="99b8" class="ma mb nn mc b md mw kd mf mg mx kg mi oh my ml mm oi mz mp mq oj na mt mu mv im bi translated">请在<a class="ae lh" href="https://www.linkedin.com/in/leihuaye/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>和<a class="ae lh" href="https://www.youtube.com/channel/UCBBu2nqs6iZPyNSgMjXUGPg" rel="noopener ugc nofollow" target="_blank"> Youtube </a>上找到我。</p><p id="83cd" class="ma mb nn mc b md mw kd mf mg mx kg mi oh my ml mm oi mz mp mq oj na mt mu mv im bi translated">还有，看看我其他关于人工智能和机器学习的帖子。</p></blockquote></div></div>    
</body>
</html>