<html>
<head>
<title>5 Advanced Tips on Python Sequences</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python序列的5个高级技巧</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/5-advanced-tips-on-python-sequences-5b0e09a21a83?source=collection_archive---------11-----------------------#2021-09-14">https://towardsdatascience.com/5-advanced-tips-on-python-sequences-5b0e09a21a83?source=collection_archive---------11-----------------------#2021-09-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="e50d" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">卢西亚诺·拉马尔霍的《流畅的Python》笔记。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/c9b7285d840a4f435c7bb87eed883fe6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ipZBsu6IcWP_6JM7"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@nasa?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> NASA </a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><blockquote class="kw"><p id="6f2d" class="kx ky iq bd kz la lb lc ld le lf lg dk translated">“66%的数据科学家每天都在应用Python。”— <a class="ae kv" href="https://www.dasca.org/world-of-big-data/article/top-6-programming-languages-for-data-science-in-2021" rel="noopener ugc nofollow" target="_blank"> src </a></p></blockquote><p id="83f1" class="pw-post-body-paragraph lh li iq lj b lk ll jr lm ln lo ju lp lq lr ls lt lu lv lw lx ly lz ma mb lg ij bi translated">如果你属于那66%，这篇文章就是为你写的。</p><p id="c2f0" class="pw-post-body-paragraph lh li iq lj b lk mc jr lm ln md ju lp lq me ls lt lu mf lw lx ly mg ma mb lg ij bi translated">我们将讨论卢西亚诺·拉马尔霍的<a class="ae kv" href="https://amzn.to/3KTnNfB" rel="noopener ugc nofollow" target="_blank"> Fluent Python第二章的主要内容，其中包括<strong class="lj ir">序列</strong>例如列表、元组等。</a></p><h1 id="cf0b" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">1-列表与元组</h1><p id="8954" class="pw-post-body-paragraph lh li iq lj b lk mz jr lm ln na ju lp lq nb ls lt lu nc lw lx ly nd ma mb lg ij bi translated">提示:列表应该保存相同种类的信息，而元组可以保存不同种类的信息。</p><p id="1a53" class="pw-post-body-paragraph lh li iq lj b lk mc jr lm ln md ju lp lq me ls lt lu mf lw lx ly mg ma mb lg ij bi translated">从基础开始，让我们讨论列表和元组之间的主要区别。下面我们可以看到一个例子——列表被方括号<code class="fe ne nf ng nh b">[]</code>包围，元组被圆括号<code class="fe ne nf ng nh b">()</code>包围。</p><pre class="kg kh ki kj gt ni nh nj nk aw nl bi"><span id="bb8f" class="nm mi iq nh b gy nn no l np nq">my_tuple = (1,'a',False)<br/>my_list =  [1,'a',False]</span></pre><p id="1c98" class="pw-post-body-paragraph lh li iq lj b lk mc jr lm ln md ju lp lq me ls lt lu mf lw lx ly mg ma mb lg ij bi translated">在后端，<strong class="lj ir">列表是可变的，但是元组不是</strong>。不可变变量通常需要较少的内存，所以尽可能使用元组。</p><p id="05aa" class="pw-post-body-paragraph lh li iq lj b lk mc jr lm ln md ju lp lq me ls lt lu mf lw lx ly mg ma mb lg ij bi translated">但是，在Fluent Python中有一个更深层次的注释。</p><p id="4abd" class="pw-post-body-paragraph lh li iq lj b lk mc jr lm ln md ju lp lq me ls lt lu mf lw lx ly mg ma mb lg ij bi translated">从语义上来说，最佳实践是在一个元组中存储不同种类的数据，而在一个列表中存储相同种类的数据。注意，元组和列表都支持在同一个变量中使用多种python数据类型，但是我们是在概念上讨论变量的类型。</p><p id="09e1" class="pw-post-body-paragraph lh li iq lj b lk mc jr lm ln md ju lp lq me ls lt lu mf lw lx ly mg ma mb lg ij bi translated">例如，一个元组可以用来存储以下信息:<code class="fe ne nf ng nh b">(latitude, longitude, city_name)</code>。不仅这些不同的数据类型<code class="fe ne nf ng nh b">(float, float, str)</code>，而且它们在概念上也是不同的。另一方面，列表应该只存储纬度、经度、城市名或三者的元组。</p><pre class="kg kh ki kj gt ni nh nj nk aw nl bi"><span id="16d5" class="nm mi iq nh b gy nn no l np nq"># list of [float, float, str]<br/>bad_practice_list = [[39.9526, 75.1652, 'Philadelphia'], <br/>                     [6.2476, 75.5658m 'Medellín']]</span><span id="9fae" class="nm mi iq nh b gy ns no l np nq"># list of tuples<br/>good_practice_list = [(39.9526, 75.1652, 'Philadelphia'), <br/>                      (6.2476, 75.5658m 'Medellín')]</span></pre><p id="cf89" class="pw-post-body-paragraph lh li iq lj b lk mc jr lm ln md ju lp lq me ls lt lu mf lw lx ly mg ma mb lg ij bi translated">为了改进python代码的组织，应该始终将同类信息保存在一个列表中。元组用于结构，列表用于序列。</p><h1 id="ec5c" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">2 —解包项目</h1><p id="abec" class="pw-post-body-paragraph lh li iq lj b lk mz jr lm ln na ju lp lq nb ls lt lu nc lw lx ly nd ma mb lg ij bi translated"><strong class="lj ir">提示:使用</strong> <code class="fe ne nf ng nh b"><strong class="lj ir">*</strong></code> <strong class="lj ir">和</strong> <code class="fe ne nf ng nh b"><strong class="lj ir">_</strong></code> <strong class="lj ir">来改善你的拆包。</strong></p><p id="5670" class="pw-post-body-paragraph lh li iq lj b lk mc jr lm ln md ju lp lq me ls lt lu mf lw lx ly mg ma mb lg ij bi translated">解包是访问iterable内部值的一种非常流畅和易读的方式。它们在循环、列表理解和函数调用中很常见。</p><p id="6397" class="pw-post-body-paragraph lh li iq lj b lk mc jr lm ln md ju lp lq me ls lt lu mf lw lx ly mg ma mb lg ij bi translated">解包是通过给逗号分隔的变量名分配一个类似序列的数据类型来完成的，例如…</p><pre class="kg kh ki kj gt ni nh nj nk aw nl bi"><span id="64d9" class="nm mi iq nh b gy nn no l np nq">x, y, z = (1,2,3)</span></pre><p id="4933" class="pw-post-body-paragraph lh li iq lj b lk mc jr lm ln md ju lp lq me ls lt lu mf lw lx ly mg ma mb lg ij bi translated">然而，Fluent Python进入了一些花哨的解包方法。一个例子是你可以使用<code class="fe ne nf ng nh b">*</code>来解包一个长的可重复项中的“其余”项。当你有一些感兴趣的项目和其他不太重要的项目时，使用星号符号是很常见的。</p><pre class="kg kh ki kj gt ni nh nj nk aw nl bi"><span id="0523" class="nm mi iq nh b gy nn no l np nq">x, *y, z = [1,2,3,4,5,6,7]<br/>x #1<br/>y #[2,3,4,5,6]<br/>z #7</span></pre><p id="4df0" class="pw-post-body-paragraph lh li iq lj b lk mc jr lm ln md ju lp lq me ls lt lu mf lw lx ly mg ma mb lg ij bi translated">如您所见，<code class="fe ne nf ng nh b">*</code>操作符可以出现在一组变量的中间，python会将所有未考虑的值赋给该变量。</p><p id="630d" class="pw-post-body-paragraph lh li iq lj b lk mc jr lm ln md ju lp lq me ls lt lu mf lw lx ly mg ma mb lg ij bi translated">但是，我们可以进一步使用星号拆包操作符。您可以使用<code class="fe ne nf ng nh b">_</code>来解包，并且<strong class="lj ir">不保存值</strong>。当您想要解包一些东西时，这种约定很方便，但是不像上面的例子，您不需要所有的变量。</p><pre class="kg kh ki kj gt ni nh nj nk aw nl bi"><span id="00cb" class="nm mi iq nh b gy nn no l np nq">x, _ = (1,2)<br/>x #1</span></pre><p id="f7f0" class="pw-post-body-paragraph lh li iq lj b lk mc jr lm ln md ju lp lq me ls lt lu mf lw lx ly mg ma mb lg ij bi translated">下划线<code class="fe ne nf ng nh b">_</code>解包操作符的一个用例是如果您正在使用返回多个值的字典或内置方法。</p><p id="0a49" class="pw-post-body-paragraph lh li iq lj b lk mc jr lm ln md ju lp lq me ls lt lu mf lw lx ly mg ma mb lg ij bi translated">最后，对于顶部的cherry，我们可以结合两种方法来<strong class="lj ir">解包并且不存储“其余”的值。</strong></p><pre class="kg kh ki kj gt ni nh nj nk aw nl bi"><span id="8734" class="nm mi iq nh b gy nn no l np nq">x, *_ = (1,2,3,5,6)<br/>x #1</span></pre><h1 id="0696" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">3-函数是否返回None？</h1><p id="6fee" class="pw-post-body-paragraph lh li iq lj b lk mz jr lm ln na ju lp lq nb ls lt lu nc lw lx ly nd ma mb lg ij bi translated"><strong class="lj ir">提示:如果函数返回</strong> <code class="fe ne nf ng nh b"><strong class="lj ir">None</strong></code> <strong class="lj ir">，则执行就地操作。</strong></p><p id="642a" class="pw-post-body-paragraph lh li iq lj b lk mc jr lm ln md ju lp lq me ls lt lu mf lw lx ly mg ma mb lg ij bi translated">很多python数据类型都有同一个函数的两个版本，比如下面显示的<code class="fe ne nf ng nh b">x.sort()</code>和<code class="fe ne nf ng nh b">sorted(x)</code>。</p><pre class="kg kh ki kj gt ni nh nj nk aw nl bi"><span id="7263" class="nm mi iq nh b gy nn no l np nq">x = [3,1,5,2]<br/>x.sort()<br/>x # [1,2,3,5]</span><span id="efd3" class="nm mi iq nh b gy ns no l np nq">x = [3,1,5,2]<br/>y = sorted(x)<br/>x # [3,1,5,2]<br/>y # [1,2,3,5]</span></pre><p id="68a2" class="pw-post-body-paragraph lh li iq lj b lk mc jr lm ln md ju lp lq me ls lt lu mf lw lx ly mg ma mb lg ij bi translated">在第一个使用<code class="fe ne nf ng nh b">x.sort()</code>的例子中，我们执行了一个就地排序，这个排序更有效，需要的内存更少。但是，在使用<code class="fe ne nf ng nh b">sorted(x)</code>的第二个例子中，我们能够保留列表的原始顺序。</p><p id="e850" class="pw-post-body-paragraph lh li iq lj b lk mc jr lm ln md ju lp lq me ls lt lu mf lw lx ly mg ma mb lg ij bi translated">一般来说，Python保留了这种符号。<a class="ae kv" href="https://www.askpython.com/python/built-in-methods/dot-notation" rel="noopener ugc nofollow" target="_blank">像<code class="fe ne nf ng nh b">x.sort()</code>这样的点运算符</a>经常返回<code class="fe ne nf ng nh b">None</code>并执行就地突变。像<code class="fe ne nf ng nh b">sorted(x)</code>这样将变量作为参数的函数返回变异变量的一个<strong class="lj ir">副本</strong>，但是保持原始变量不变。</p><h1 id="1250" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">4 — GenExps与ListComps</h1><p id="c2cf" class="pw-post-body-paragraph lh li iq lj b lk mz jr lm ln na ju lp lq nb ls lt lu nc lw lx ly nd ma mb lg ij bi translated">提示:如果你只访问一次变量，就使用生成器表达式。如果没有，使用列表理解。</p><p id="05d6" class="pw-post-body-paragraph lh li iq lj b lk mc jr lm ln md ju lp lq me ls lt lu mf lw lx ly mg ma mb lg ij bi translated"><a class="ae kv" href="https://www.w3schools.com/python/python_lists_comprehension.asp" rel="noopener ugc nofollow" target="_blank">列表理解</a> (listcomps)和<a class="ae kv" href="https://www.python.org/dev/peps/pep-0289/" rel="noopener ugc nofollow" target="_blank">生成器表达式</a> (genexps)是实例化序列数据类型的不同方式。</p><pre class="kg kh ki kj gt ni nh nj nk aw nl bi"><span id="03c8" class="nm mi iq nh b gy nn no l np nq">list_comp = [x for x in range(5)]<br/>gen_exp = (x for x in range(5))</span></pre><p id="2388" class="pw-post-body-paragraph lh li iq lj b lk mc jr lm ln md ju lp lq me ls lt lu mf lw lx ly mg ma mb lg ij bi translated">如上所示，list comps和gene XP之间唯一的语法差异是括号类型——括号<code class="fe ne nf ng nh b">()</code>用于gene XP，方括号<code class="fe ne nf ng nh b">[]</code>用于list comps。</p><p id="bae0" class="pw-post-body-paragraph lh li iq lj b lk mc jr lm ln md ju lp lq me ls lt lu mf lw lx ly mg ma mb lg ij bi translated"><strong class="lj ir">列表组件被实例化，这意味着它们被评估并保存在内存中。基因XP不是。</strong>每当程序需要一个genexp时，它将执行计算以评估该表达式。</p><p id="a32b" class="pw-post-body-paragraph lh li iq lj b lk mc jr lm ln md ju lp lq me ls lt lu mf lw lx ly mg ma mb lg ij bi translated">这就是为什么如果你只使用一次变量，生成器表达式会更好——它们实际上从来没有存储在内存中，所以效率更高。但是，如果您重复访问一个序列或者需要特定于列表的方法，最好将它存储在内存中。</p><p id="8563" class="pw-post-body-paragraph lh li iq lj b lk mc jr lm ln md ju lp lq me ls lt lu mf lw lx ly mg ma mb lg ij bi translated">有趣的旁注—你也可以使用列表理解语法创建字典…</p><pre class="kg kh ki kj gt ni nh nj nk aw nl bi"><span id="a2a2" class="nm mi iq nh b gy nn no l np nq">my_dict = {k:v for k,v in zip(['a','b'], [1,2])}</span></pre><h1 id="f1bf" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">5-切片</h1><p id="2682" class="pw-post-body-paragraph lh li iq lj b lk mz jr lm ln na ju lp lq nb ls lt lu nc lw lx ly nd ma mb lg ij bi translated">最后，让我们以切片的快速注释来结束。与解包不同，有时我们希望使用索引来访问iterable中的值。切片允许我们通过使用下面的格式来做到这一点:<code class="fe ne nf ng nh b">my_list[start:stop:step]</code></p><p id="d5fb" class="pw-post-body-paragraph lh li iq lj b lk mc jr lm ln md ju lp lq me ls lt lu mf lw lx ly mg ma mb lg ij bi translated">对于那些知道<code class="fe ne nf ng nh b">my_list[::-1]</code>颠倒一个列表顺序却不知道为什么的人(比如我自己)，这就是为什么。通过传递一个<code class="fe ne nf ng nh b">-1</code>作为我们的步骤参数，我们反向遍历列表。</p><p id="7271" class="pw-post-body-paragraph lh li iq lj b lk mc jr lm ln md ju lp lq me ls lt lu mf lw lx ly mg ma mb lg ij bi translated">现在大多数python包都遵循<code class="fe ne nf ng nh b">[start:stop:index]</code>语法。熊猫和熊猫是一些显著的例子。让我们依次看看每个参数…</p><ul class=""><li id="197f" class="nt nu iq lj b lk mc ln md lq nv lu nw ly nx lg ny nz oa ob bi translated"><code class="fe ne nf ng nh b">start</code>:切片中的起始索引</li><li id="4688" class="nt nu iq lj b lk oc ln od lq oe lu of ly og lg ny nz oa ob bi translated"><code class="fe ne nf ng nh b">end</code>:切片中不包含的结束索引</li><li id="6b17" class="nt nu iq lj b lk oc ln od lq oe lu of ly og lg ny nz oa ob bi translated"><code class="fe ne nf ng nh b">step</code>:您的<code class="fe ne nf ng nh b">start</code>和<code class="fe ne nf ng nh b">stop</code>步进内的步长(和方向)</li></ul><p id="352f" class="pw-post-body-paragraph lh li iq lj b lk mc jr lm ln md ju lp lq me ls lt lu mf lw lx ly mg ma mb lg ij bi translated">因此，因为这些值都是可选的，我们可以做各种各样的酷切片…</p><pre class="kg kh ki kj gt ni nh nj nk aw nl bi"><span id="d6fd" class="nm mi iq nh b gy nn no l np nq">x = [1,2,3,4]</span><span id="f9ab" class="nm mi iq nh b gy ns no l np nq">x[1:3]                   # [2,3]<br/>x[2:0:-1]                # [3,2]</span><span id="aab7" class="nm mi iq nh b gy ns no l np nq">last = [-1::]            # 4<br/>all_but_last = x[:-1:]   # [1,2,3]<br/>reversed = x[::-1]       # [4,3,2,1]</span></pre><p id="5880" class="pw-post-body-paragraph lh li iq lj b lk mc jr lm ln md ju lp lq me ls lt lu mf lw lx ly mg ma mb lg ij bi translated">现在你知道了！流利Python第二章的5个主要技巧。只剩一节了…</p><h1 id="08d7" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">数据科学家的有用笔记</h1><p id="dd1a" class="pw-post-body-paragraph lh li iq lj b lk mz jr lm ln na ju lp lq nb ls lt lu nc lw lx ly nd ma mb lg ij bi translated">免责声明，我不是超级有资格把我的观点加到这一块的。然而，这些笔记应该非常直观。如果你不同意，请告诉我。</p><ol class=""><li id="9695" class="nt nu iq lj b lk mc ln md lq nv lu nw ly nx lg oh nz oa ob bi translated">列表理解应该总是取代循环。如果循环体很复杂，你可以创建一个函数来完成这些操作。通过将用户定义的函数与列表理解语法相结合，您可以得到可读且高效的代码。如果你需要迭代多个变量，使用<code class="fe ne nf ng nh b"><a class="ae kv" href="https://realpython.com/python-enumerate/" rel="noopener ugc nofollow" target="_blank">enumerate()</a></code>或<code class="fe ne nf ng nh b"><a class="ae kv" href="https://www.w3schools.com/python/ref_func_zip.asp" rel="noopener ugc nofollow" target="_blank">zip()</a></code>。</li><li id="b3b3" class="nt nu iq lj b lk oc ln od lq oe lu of ly og lg oh nz oa ob bi translated"><strong class="lj ir">在python中“最优”并不重要。如果您正在编写生产级代码，可能会有所不同。但是，实际上，在列表上使用元组时，您不会看到大的性能提升。99%的工作是确保您的数据操作步骤合乎逻辑且高效。如果1%很重要，那么你可以开始担心元组和列表。此外，如果你真的从事高效代码的工作，你可能不会使用python。</strong></li><li id="ea79" class="nt nu iq lj b lk oc ln od lq oe lu of ly og lg oh nz oa ob bi translated"><strong class="lj ir">最后切片超级爽。</strong>我早就知道<code class="fe ne nf ng nh b">x[::-1]</code>会反转列表，但直到读了这一章流畅的Python才知道为什么。它对熊猫和熊猫都有效！</li></ol></div><div class="ab cl oi oj hu ok" role="separator"><span class="ol bw bk om on oo"/><span class="ol bw bk om on oo"/><span class="ol bw bk om on"/></div><div class="ij ik il im in"><p id="79fe" class="pw-post-body-paragraph lh li iq lj b lk mc jr lm ln md ju lp lq me ls lt lu mf lw lx ly mg ma mb lg ij bi translated"><em class="nr">感谢阅读！我会再写35篇文章，把学术研究带到DS行业。查看我的评论，链接到这篇文章的主要来源和一些有用的资源。</em></p></div></div>    
</body>
</html>