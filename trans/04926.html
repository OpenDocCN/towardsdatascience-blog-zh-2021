<html>
<head>
<title>End-to-end Computer Vision Pipeline in 5 Minutes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">5分钟内完成端到端计算机视觉管道</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/end-to-end-computer-vision-pipeline-in-5-minutes-e43e47a9c04a?source=collection_archive---------12-----------------------#2021-04-29">https://towardsdatascience.com/end-to-end-computer-vision-pipeline-in-5-minutes-e43e47a9c04a?source=collection_archive---------12-----------------------#2021-04-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5cd0" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何使用TorchVision在不到5分钟的时间内编写一个完整的计算机视觉管道</h2></div><p id="26c2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">编写一个完整而快速的计算机视觉管道，用于产品原型制作或作为构建更复杂系统的构件，正变得越来越重要。在这里，我们将讨论如何使用流行的TorchVision库在5分钟或更短的时间内做到这一点。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi le"><img src="../Images/13b479eb36833cfd48efda56443bb1a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*TgES_MBzUpObBAwy"/></div></div><p class="lq lr gj gh gi ls lt bd b be z dk translated">里卡多·安南达尔在<a class="ae lu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h1 id="3020" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">目录</h1><ol class=""><li id="8c8e" class="mn mo it kk b kl mp ko mq kr mr kv ms kz mt ld mu mv mw mx bi translated">做好准备</li><li id="6e6e" class="mn mo it kk b kl my ko mz kr na kv nb kz nc ld mu mv mw mx bi translated">数据集准备</li><li id="4136" class="mn mo it kk b kl my ko mz kr na kv nb kz nc ld mu mv mw mx bi translated">模型构建</li><li id="5af7" class="mn mo it kk b kl my ko mz kr na kv nb kz nc ld mu mv mw mx bi translated">模型评估</li><li id="db75" class="mn mo it kk b kl my ko mz kr na kv nb kz nc ld mu mv mw mx bi translated">结论</li></ol><h1 id="8c64" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">做好准备</h1><p id="38c0" class="pw-post-body-paragraph ki kj it kk b kl mp ju kn ko mq jx kq kr nd kt ku kv ne kx ky kz nf lb lc ld im bi translated">首先，您应该安装PyTorch和TorchVision库。建议您在<em class="ng">康达</em>虚拟环境中进行。</p><ol class=""><li id="3fed" class="mn mo it kk b kl km ko kp kr nh kv ni kz nj ld mu mv mw mx bi translated">进入<a class="ae lu" href="https://pytorch.org/get-started/locally/" rel="noopener ugc nofollow" target="_blank"> PyTorch </a>安装页面，将写好的命令行复制粘贴到您的终端，例如:</li></ol><pre class="lf lg lh li gt nk nl nm nn aw no bi"><span id="1f75" class="np lw it nl b gy nq nr l ns nt">conda install pytorch torchvision torchaudio -c pytorch</span></pre><p id="36a1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">2.通过在终端中运行以下命令，确保安装已经完成。如果没有输出，那么你已经完成了这一部分！</p><pre class="lf lg lh li gt nk nl nm nn aw no bi"><span id="1b1e" class="np lw it nl b gy nq nr l ns nt">python -c "import torch"<br/>python -c "import torchvision"</span></pre><h1 id="c35f" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">数据集准备</h1><p id="8f86" class="pw-post-body-paragraph ki kj it kk b kl mp ju kn ko mq jx kq kr nd kt ku kv ne kx ky kz nf lb lc ld im bi translated">对于本教程，我们将使用一个更受欢迎的数据集<strong class="kk iu"> MNIST </strong>(从0到9的数字图像集合)。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi nu"><img src="../Images/7e7978dca338c5437bc7b2966a814220.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*yYZCyhpXbSO8WE3i.png"/></div></div><p class="lq lr gj gh gi ls lt bd b be z dk translated">tensorflow.org MNIST数据集(资料来源)</p></figure><p id="7d84" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先，我们将对数据集进行转换，以便它们能够很好地适应我们即将推出的AlexNet模型(即<strong class="kk iu">将</strong>输入图像调整为224，<strong class="kk iu">将</strong>MNIST图像转换为张量格式)。</p><pre class="lf lg lh li gt nk nl nm nn aw no bi"><span id="457d" class="np lw it nl b gy nq nr l ns nt">import torch<br/>from torchvision import datasets, transforms, models<br/>from torch.autograd import Variable</span><span id="13bf" class="np lw it nl b gy nv nr l ns nt">transform = transforms.Compose(<br/>    [<br/>        transforms.Resize(224),<br/>        transforms.ToTensor(),<br/>    ])</span></pre><p id="c010" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，我们通过传递上面的transform对象来下载训练集和测试集。</p><pre class="lf lg lh li gt nk nl nm nn aw no bi"><span id="c99b" class="np lw it nl b gy nq nr l ns nt">mnist_trainset = datasets.MNIST(root='./data', train=True, download=True, transform=transform)</span><span id="01dd" class="np lw it nl b gy nv nr l ns nt">mnist_testset = datasets.MNIST(root='./data', train=False, download=True, transform=transform)</span></pre><p id="224c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">其中<em class="ng">根</em>表示下载和存储数据的目录。</p><p id="5d11" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">通过找出数据集的大小来检查您的下载是否完成。</p><pre class="lf lg lh li gt nk nl nm nn aw no bi"><span id="a5d8" class="np lw it nl b gy nq nr l ns nt">len(mnist_trainset)<br/>&gt;&gt;&gt; 60000 </span><span id="18a3" class="np lw it nl b gy nv nr l ns nt">len(mnist_testset)<br/>&gt;&gt;&gt; 10000</span></pre><p id="9c69" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，我们需要创建用于批处理目的的dataloader。</p><pre class="lf lg lh li gt nk nl nm nn aw no bi"><span id="3ada" class="np lw it nl b gy nq nr l ns nt">train_loader = torch.utils.data.DataLoader(mnist_trainset,<br/>                                          batch_size=4,<br/>                                          shuffle=True)</span><span id="9f24" class="np lw it nl b gy nv nr l ns nt">test_loader = torch.utils.data.DataLoader(mnist_testset,<br/>                                          batch_size=4,<br/>                                          shuffle=True)</span></pre><h1 id="0103" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">模型构建</h1><p id="8b61" class="pw-post-body-paragraph ki kj it kk b kl mp ju kn ko mq jx kq kr nd kt ku kv ne kx ky kz nf lb lc ld im bi translated">初始化模型也很容易。为了便于讨论，我们将使用带有预训练权重的<a class="ae lu" href="https://arxiv.org/abs/1404.5997" rel="noopener ugc nofollow" target="_blank"> AlexNet </a>(您可以选择使用随机权重初始化模型，并使用上述基准数据集或使用您自己的预定义数据集重新训练它)。你可以在这里找到火炬视觉<a class="ae lu" href="https://pytorch.org/vision/stable/models.html" rel="noopener ugc nofollow" target="_blank">支持的模型集合。</a></p><pre class="lf lg lh li gt nk nl nm nn aw no bi"><span id="7cb7" class="np lw it nl b gy nq nr l ns nt">alexnet = models.alexnet(pretrained= True)</span></pre><p id="cedc" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在那里您可以通过运行</p><pre class="lf lg lh li gt nk nl nm nn aw no bi"><span id="b853" class="np lw it nl b gy nq nr l ns nt">alexnet</span></pre><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi nw"><img src="../Images/a3711eec22c7396baf221b46b72903b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZtC8fqAjS4TTWF7MstVmNg.png"/></div></div><p class="lq lr gj gh gi ls lt bd b be z dk translated">AlexNet模型摘要</p></figure><p id="a5b7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面的第一行表示(<em class="ng">功能</em>)块中的<em class="ng"> Conv2d </em>层的输入通道大小为3 (RGB)，而我们的MNIST数据集只有一个颜色通道:</p><pre class="lf lg lh li gt nk nl nm nn aw no bi"><span id="d38e" class="np lw it nl b gy nq nr l ns nt">alexnet.features[0] = torch.nn.Conv2d(<strong class="nl iu">1</strong>,64, kernel_size=(11,11), stride=(4,4), padding=(2,2))</span></pre><p id="f9d5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">进一步的修改也可以像这样容易地完成！</p><h1 id="d955" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">模型评估</h1><p id="4b52" class="pw-post-body-paragraph ki kj it kk b kl mp ju kn ko mq jx kq kr nd kt ku kv ne kx ky kz nf lb lc ld im bi translated">现在，我们准备训练我们的模型。</p><ol class=""><li id="3e2e" class="mn mo it kk b kl km ko kp kr nh kv ni kz nj ld mu mv mw mx bi translated"><strong class="kk iu">定义损失函数和优化器</strong></li></ol><p id="8a7a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于这种情况，我们分别使用交叉熵和随机梯度下降(SGD)。</p><pre class="lf lg lh li gt nk nl nm nn aw no bi"><span id="2f17" class="np lw it nl b gy nq nr l ns nt">criterion=torch.nn.CrossEntropyLoss()<br/>optimizer=torch.optim.SGD(alexnet.parameters(),lr=0.01,momentum=0.9)</span></pre><p id="40bf" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">2.<strong class="kk iu">训练和验证</strong></p><pre class="lf lg lh li gt nk nl nm nn aw no bi"><span id="8ef8" class="np lw it nl b gy nq nr l ns nt">print ("Training begins...")<br/>num_of_epochs = 3</span><span id="612c" class="np lw it nl b gy nv nr l ns nt">for epoch in range(num_of_epochs):<br/>    running_loss=0<br/>    for i, data in enumerate(train_loader, 0):<br/>        image, label = data<br/> <br/>        image = Variable(image)<br/>        label = Variable(label)<br/>        optimizer.zero_grad()<br/> <br/>        outputs = alexnet(image)<br/>        loss = criterion(outputs, label)<br/> <br/>        loss.backward()<br/>        optimizer.step()<br/> <br/>        running_loss += loss.data<br/> <br/>        if i%100==99:<br/>            print (f'[epoch {epoch + 1}, imgs {i + 1}] loss:  {running_loss/100}')<br/>            running_loss = 0</span><span id="73c6" class="np lw it nl b gy nv nr l ns nt">print("Training finishes...")</span></pre><p id="87aa" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上述训练和验证子程序是标准的(即涉及zero_grad()、backward()和step()函数)。当然，你可以修改超参数，包括训练时期，学习率等，以达到最优化。</p><p id="12cb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">3.<strong class="kk iu">推论</strong></p><p id="2cf0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">与训练类似，我们可以通过以下方式进行推断:</p><pre class="lf lg lh li gt nk nl nm nn aw no bi"><span id="40c3" class="np lw it nl b gy nq nr l ns nt">alexnet.eval()<br/>correct=0<br/>total=0</span><span id="9288" class="np lw it nl b gy nv nr l ns nt">for data in test_loader:<br/>    images, labels = data<br/>    outputs = alexnet(Variable(images))<br/>    _ , predicted = torch.max(outputs, 1)<br/>    total += labels.size(0)</span></pre><h1 id="6c05" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">结论</h1><p id="9f75" class="pw-post-body-paragraph ki kj it kk b kl mp ju kn ko mq jx kq kr nd kt ku kv ne kx ky kz nf lb lc ld im bi translated">您刚刚构建了一个端到端的CV管道，从数据获取、转换、模型构建、培训、验证到推理，全部在五分钟之内完成！我还演示了如何轻松地修改您的模型以适应您自己的数据集。可以在整个模型中进行类似的调整。</p></div><div class="ab cl nx ny hx nz" role="separator"><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc"/></div><div class="im in io ip iq"><p id="cf86" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> <em class="ng">做订阅我的邮件简讯:</em></strong><a class="ae lu" href="https://tinyurl.com/2npw2fnz" rel="noopener ugc nofollow" target="_blank"><em class="ng">https://tinyurl.com/2npw2fnz</em></a><em class="ng"/><strong class="kk iu"><em class="ng">在那里我定期用通俗易懂的语言和漂亮的可视化方式总结AI研究论文。</em> </strong></p></div></div>    
</body>
</html>