<html>
<head>
<title>Executing Jupyter Notebooks on serverless GCP products</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在无服务器GCP产品上运行Jupyter笔记本</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/executing-jupyter-notebooks-on-serverless-gcp-products-23d1e35eb150?source=collection_archive---------22-----------------------#2021-05-13">https://towardsdatascience.com/executing-jupyter-notebooks-on-serverless-gcp-products-23d1e35eb150?source=collection_archive---------22-----------------------#2021-05-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/68e1916737410d9e2337c111fadac5c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*FX26nPhoJP1vxtnc"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">亚历杭德罗·埃斯卡米拉在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="ba70" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Jupyter笔记本是数据科学和分析的绝佳工具。它们是在Jupyter笔记本服务器上开发的，这些服务器可以在本地安装和运行以进行开发。它通常始于探索、开发、制作原型、摆弄数据。例如，探索Covid数据加载为CSV文件，来自<a class="ae kc" href="https://ourworldindata.org/coronavirus-source-data" rel="noopener ugc nofollow" target="_blank">我们的世界数据</a>。您会看到这里有全世界的统计数据，您希望跟踪这些数据，并每天将其写入BigQuery表:)这样的笔记本看起来像这样:</p><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="lf lg l"/></div></figure><p id="88fc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">好了，您已经完成了开发，您已经进行了测试，它运行正常，所以现在您要设置一些日常任务来每天运行它。由于这不是一个关于计算消费的复杂任务，它可以部署在一些无服务器的服务上，如云运行或云功能，因为这些产品有按使用付费的计费和慷慨的免费层，所以我们无论如何都不会为此付费。我们将使用库<a class="ae kc" href="https://papermill.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank"> Papermill </a>，它支持Jupyter笔记本的执行以及输入参数的支持。</p><p id="bcb7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">完整的Github库在这里是<a class="ae kc" href="https://github.com/zdenulo/gcp-serverless-jupyter-notebook" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="6009" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">设置这一点需要几个步骤:</p><h2 id="7aca" class="lh li iq bd lj lk ll dn lm ln lo dp lp ko lq lr ls ks lt lu lv kw lw lx ly lz bi translated">1.在web应用程序中包装执行</h2><p id="e0b6" class="pw-post-body-paragraph kd ke iq kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">Jupyter Notebook将在一个HTTP请求中执行，所以我添加Flask作为轻量级web框架来包装执行。使用Papermill执行笔记本也很简单。由于“日期”是将被更改并在笔记本中用作输入变量的东西，因此需要在“参数”变量中传递它。输入日期可以作为请求中的参数传递，如果没有输入日期，则使用“昨天”的日期。此类web应用程序的代码如下所示:</p><pre class="lb lc ld le gt mf mg mh mi aw mj bi"><span id="9d7d" class="lh li iq mg b gy mk ml l mm mn">import datetime<br/>import logging<br/><br/>from flask import Flask<br/>import papermill as pm<br/><br/>app = Flask(__name__)<br/><br/><br/>@app.route('/')<br/>def main(request=None):<br/>    logging.info("starting job")<br/>    input_date = ''<br/>    if request:<br/>        input_date = request.args.get('input_date', '')<br/>    if not input_date:<br/>        input_date = (datetime.datetime.now() - datetime.timedelta(days=1)).strftime('%Y-%m-%d')<br/><br/>    parameters = {<br/>        'date': input_date<br/>    }<br/>    pm.execute_notebook(<br/>        'covid_stats.ipynb',<br/>        '/tmp/covid_stats_out.ipynb',<br/>        parameters=parameters<br/>    )<br/>    logging.info("job completed")<br/>    return 'ok'<br/><br/><br/>if __name__ == '__main__':<br/>    import os<br/><br/>    port = os.environ.get('PORT', '8080')<br/>    app.run(port=port)</span></pre><p id="620b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">paper mill<strong class="kf ir">execute _ notebook</strong>函数的输入参数为输入输出笔记本以及笔记本“参数”。我将输出笔记本保存到“/tmp”文件夹中，因为在谷歌云无服务器产品中，“/tmp”通常是唯一可以写文件的地方。</p><h2 id="f393" class="lh li iq bd lj lk ll dn lm ln lo dp lp ko lq lr ls ks lt lu lv kw lw lx ly lz bi translated">2.在笔记本中设置参数</h2><p id="de4c" class="pw-post-body-paragraph kd ke iq kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">为了让Papermill识别笔记本中的输入参数，需要创建一个包含参数的特殊单元格。需要做的第二件重要的事情是为这个单元格添加标签“参数”。根据您使用的是Jupyter还是JupyterLab，这可以通过多种方式实现:</p><p id="8f39" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，选择带有输入变量的单元格</p><p id="e24f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果使用<strong class="kf ir"> Jupyter，</strong>点击<strong class="kf ir">视图- &gt;单元格工具栏- &gt;标签。</strong>你会看到在单元格顶部的右角文本字段中你可以输入一个标签或者在单元格左上角现有的标签。</p><figure class="lb lc ld le gt jr gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/b718715fd47034f71344896e377e03c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/format:webp/0*HanrEjSf_4aC0tJq.png"/></div></figure><p id="749e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你正在使用<strong class="kf ir"> JupyterLab </strong>，点击右上角的设置，</p><figure class="lb lc ld le gt jr gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/92b913da27b99147ff233974c5d501d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/format:webp/0*uJ7LMiV3uAxbV83v.png"/></div></figure><p id="f7aa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后点击添加标签按钮，并输入“参数”。另一种方法是以JSON格式直接写入单元格元数据。</p><figure class="lb lc ld le gt jr gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/22dc19d76f2b5f20188316a0552cf3e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/format:webp/0*ry-dCuT9jtHFLYoS.png"/></div></figure><h2 id="2c89" class="lh li iq bd lj lk ll dn lm ln lo dp lp ko lq lr ls ks lt lu lv kw lw lx ly lz bi translated">3.部署</h2><p id="72c1" class="pw-post-body-paragraph kd ke iq kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">正如我在开始时提到的，有几个选项可以部署这些代码。由于这是一个简单的、不需要太多时间和资源消耗的任务，我们可以在Google Cloud上部署基本上任何无服务器的计算产品。</p><h2 id="3fa9" class="lh li iq bd lj lk ll dn lm ln lo dp lp ko lq lr ls ks lt lu lv kw lw lx ly lz bi translated">云函数</h2><p id="f33c" class="pw-post-body-paragraph kd ke iq kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">用于部署的bash脚本可能如下所示:</p><pre class="lb lc ld le gt mf mg mh mi aw mj bi"><span id="08ae" class="lh li iq mg b gy mk ml l mm mn">#!/bin/bash<br/><br/># set GCP_PROJECT (env) variable<br/>CLOUD_FUNCTION_NAME=cf-jn<br/><br/>gcloud functions deploy $CLOUD_FUNCTION_NAME \<br/>  --project $GCP_PROJECT \<br/>  --entry-point main \<br/>  --runtime python37 \<br/>  --trigger-http \<br/>  --memory 512Mi \<br/>  --timeout 180 \<br/>  --allow-unauthenticated</span></pre><h2 id="2afb" class="lh li iq bd lj lk ll dn lm ln lo dp lp ko lq lr ls ks lt lu lv kw lw lx ly lz bi translated">云运行</h2><p id="d8c0" class="pw-post-body-paragraph kd ke iq kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">部署脚本</p><pre class="lb lc ld le gt mf mg mh mi aw mj bi"><span id="1a04" class="lh li iq mg b gy mk ml l mm mn">#!/bin/bash<br/><br/># set GCP_PROJECT (env) variable<br/>CLOUD_RUN_NAME=cr-jn<br/><br/>gcloud beta run deploy $CLOUD_RUN_NAME \<br/>  --project $GCP_PROJECT \<br/>  --memory 512Mi \<br/>  --source . \<br/>  --platform managed \<br/>  --allow-unauthenticated</span></pre><p id="9f44" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我省略了<a class="ae kc" href="https://cloud.google.com/appengine" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">应用引擎</strong> </a>，因为它需要一个额外的配置文件:)但是部署命令是类似的。我在两个部署中都设置了未经认证的访问，这意味着它们可以从整个互联网上访问，当然在现实生活中，只允许某些帐户访问是件好事。</p><h2 id="65da" class="lh li iq bd lj lk ll dn lm ln lo dp lp ko lq lr ls ks lt lu lv kw lw lx ly lz bi translated">结论</h2><p id="5f61" class="pw-post-body-paragraph kd ke iq kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">Jupyter笔记本通常用于处理大型数据集，因此需要大量的RAM内存和CPU资源，并为此需要专用的虚拟机。另一方面，有些情况并非如此，因此在一些Google Cloud无服务器计算产品上部署和执行它们非常有意义，因为它隐藏了资源供应，提供了简单的部署，并且节省了资金。</p><p id="6466" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，在Google Cloud上，<a class="ae kc" href="https://cloud.google.com/scheduler" rel="noopener ugc nofollow" target="_blank"> Cloud Scheduler </a>可用于定期(每天)调用带有HTTP请求的已部署web应用程序。</p></div></div>    
</body>
</html>