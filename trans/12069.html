<html>
<head>
<title>Search Algorithm: Dijkstra’s Algorithm and Uniform-Cost Search, with Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">搜索算法:Dijkstra 算法和统一成本搜索，使用 Python</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/search-algorithm-dijkstras-algorithm-uniform-cost-search-with-python-ccbee250ba9?source=collection_archive---------6-----------------------#2021-12-06">https://towardsdatascience.com/search-algorithm-dijkstras-algorithm-uniform-cost-search-with-python-ccbee250ba9?source=collection_archive---------6-----------------------#2021-12-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ba81" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">介绍一种称为 Dijkstra 算法的基本搜索算法及其变体，即统一成本搜索(UCS)</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/9e00cc32910e802292f5f212ef859291.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Lx4-GeKanLfUK19qtcIPwA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">弗兰克·麦肯纳在<a class="ae ky" href="https://unsplash.com/" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h1 id="bd54" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated"><strong class="ak">定义</strong></h1><p id="fdbf" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">搜索算法是一种检索存储在某种数据结构中的信息的算法，或者是在问题域的搜索空间中计算的信息[1]。与深度优先搜索(DFS)和宽度优先搜索(BFS)不同，Dijkstra 的算法和统一成本搜索(UCS)考虑了到目标的路径成本。例如，在道路网络中，路径成本可以是行驶的总距离或花费的总时间。<strong class="lt iu"> Dijkstra 算法</strong>是一种寻找图中从一个节点到每隔一个节点的<strong class="lt iu">最短路径的算法，而<strong class="lt iu"> UCS </strong>寻找两个节点</strong>之间的<strong class="lt iu">最短路径。[2]现在，让我们更详细地解释 UCS 算法，它是 Dijkstra 算法的变体。</strong></p><h2 id="a0c6" class="mn la it bd lb mo mp dn lf mq mr dp lj ma ms mt ll me mu mv ln mi mw mx lp my bi translated">统一成本搜索</h2><p id="7977" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">UCS <strong class="lt iu">扩展到目前为止路径代价 g 最小的节点</strong>。UCS 是 BFS 的改型。它不使用先进先出队列，而是使用一个具有路径成本 g(n) 的<strong class="lt iu">优先级队列</strong> <strong class="lt iu">对节点进行排序。[3]让我们通过下面的有向图来看一个示例，开始节点 a 和结束节点 d 用蓝色突出显示:</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mz"><img src="../Images/4625cc385f810cc86a6fa32229d395be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P4kB277P4AQ1FHTD_yS7ig.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">通过 UCS 的示例图形。图片作者。</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi na"><img src="../Images/6b54006016b3f42dd9e0ef731917726b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*saAvCDVvlPxwCzrxJrWhCQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">UCS 或者 Dijkstra 的算法，逐步展开。图片作者。</p></figure><p id="c9b9" class="pw-post-body-paragraph lr ls it lt b lu nb ju lw lx nc jx lz ma nd mc md me ne mg mh mi nf mk ml mm im bi translated">从这一步一步的扩展中，我们可以看到<strong class="lt iu">路径代价被考虑到</strong>，它<strong class="lt iu">扩展路径代价最小的节点</strong>。例如，从步骤 2 到步骤 3，它扩展了到目前为止路径开销最小的节点 c。此外，在步骤 3 中，即使它在扩展后到达目的节点 d 的总开销为 11，由于节点 b 的当前开销为 6 &lt; 11，所以它将继续扩展节点 b。在步骤 4 中扩展节点 b 后，它也到达目的节点 d 的总开销为 8，并且现在没有更多节点要扩展。所以，从 a 到 d 的最短路径= [a → b → d]，总成本= 8。</p><p id="1fb2" class="pw-post-body-paragraph lr ls it lt b lu nb ju lw lx nc jx lz ma nd mc md me ne mg mh mi nf mk ml mm im bi translated">在了解了 UCS 的工作原理后，Dijkstra 的算法只是一种寻找到每一点的最短路径而不是单点的算法。</p><p id="9498" class="pw-post-body-paragraph lr ls it lt b lu nb ju lw lx nc jx lz ma nd mc md me ne mg mh mi nf mk ml mm im bi translated">现在，让我们来评估这个算法:</p><ol class=""><li id="51fa" class="ng nh it lt b lu nb lx nc ma ni me nj mi nk mm nl nm nn no bi translated">时间复杂性:找到解决方案需要多长时间？<br/>路径成本 g =最优解成本的节点数<br/> -相当于从优先级队列中跳出的节点数</li><li id="c0a4" class="ng nh it lt b lu np lx nq ma nr me ns mi nt mm nl nm nn no bi translated">空间复杂度:内存中最大节点数<br/>路径代价为 g 的节点数=最优解的代价</li><li id="74d6" class="ng nh it lt b lu np lx nq ma nr me ns mi nt mm nl nm nn no bi translated">完整性:如果存在的话，它是否总能找到解决方案？<br/>是的</li><li id="f341" class="ng nh it lt b lu np lx nq ma nr me ns mi nt mm nl nm nn no bi translated">最优性:它总能找到最佳(最低成本)的解决方案吗？<br/>是的</li></ol></div><div class="ab cl nu nv hx nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="im in io ip iq"><h1 id="a72b" class="kz la it bd lb lc ob le lf lg oc li lj jz od ka ll kc oe kd ln kf of kg lp lq bi translated">代码实现</h1><p id="4ca2" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">让我们用上面的例子用 Python 实现 Dijkstra 和 UCS 算法。</p><p id="a23b" class="pw-post-body-paragraph lr ls it lt b lu nb ju lw lx nc jx lz ma nd mc md me ne mg mh mi nf mk ml mm im bi translated">该图是具有顶点 V={a，b，c，d，e}，E={{a，b，6}，{a，c，3}，{b，c，1}，{c，b，4}，{b，d，2}，{c，d，8}，{c，E，2}，{d，E，9}，{e，d，7}}的图形的示意图</p><ol class=""><li id="3d05" class="ng nh it lt b lu nb lx nc ma ni me nj mi nk mm nl nm nn no bi translated">创建接受图的加权边的函数，该函数输出有向加权图</li></ol><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/248ed62844d2ce13fadbb746fa91a248.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ah4iPf6Pj7chgP4Yf-g4Rg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码的输出。图片作者。</p></figure><p id="d235" class="pw-post-body-paragraph lr ls it lt b lu nb ju lw lx nc jx lz ma nd mc md me ne mg mh mi nf mk ml mm im bi translated">2.创建接受有向加权图和起始顶点的函数，该函数输出从起始顶点到图中所有其他节点的最短路径及其前身字典(Dijkstra 算法)</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/8717227d055160a97314427c4dcbb0dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5eVRd209XIH8x5YiOsu9Jw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码的输出。图片作者。</p></figure><p id="1278" class="pw-post-body-paragraph lr ls it lt b lu nb ju lw lx nc jx lz ma nd mc md me ne mg mh mi nf mk ml mm im bi translated">我们举一个例子，解释一下<strong class="lt iu"> </strong>的前身词典是什么意思。例如，目前从<strong class="lt iu">的 shortest_path_cost </strong>的输出中，我们知道从节点 a 到节点 d 的 shortest_path_cost = 8，如何准确地到达成本为 8 的节点 d 可以从它的<strong class="lt iu">前体字典</strong>中得知。我们可以从目的节点 d 开始查找前任字典，其前任是<strong class="lt iu"> </strong>节点 c .按照相同的逻辑:节点 c 的前任→节点 a .因此，从节点 a 到节点 d 的最短路径是从节点 a →节点 c →节点 d。</p><p id="734d" class="pw-post-body-paragraph lr ls it lt b lu nb ju lw lx nc jx lz ma nd mc md me ne mg mh mi nf mk ml mm im bi translated">3.实际上，我们可以使用 Dijkstra 算法的输出来获得 UCS 从<strong class="lt iu">节点 a </strong> <strong class="lt iu">到</strong> <strong class="lt iu">节点 d </strong>的输出，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ok"><img src="../Images/fe732a8ad999241c1ec86ce38ee21a93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7E1tBDWOMFScuv-biIxziQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码的输出。图片作者。</p></figure><h1 id="f820" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">结论</h1><p id="61e6" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">本文介绍了 Dijkstra 算法和均匀代价搜索算法。两种算法都在寻找成本最低的最短路径，即 Dijkstra 算法:寻找从图中一个节点到所有其他节点的最短路径，UCS:寻找两个节点之间的最短路径。它们是基本的搜索算法，对于解决更复杂的路由问题非常有用，如物流规划、运输和网络通信等。</p></div><div class="ab cl nu nv hx nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="im in io ip iq"><h1 id="e6cd" class="kz la it bd lb lc ob le lf lg oc li lj jz od ka ll kc oe kd ln kf of kg lp lq bi translated">推荐阅读</h1><div class="ol om gp gr on oo"><a rel="noopener follow" target="_blank" href="/search-algorithm-depth-first-search-with-python-1f10da161980"><div class="op ab fo"><div class="oq ab or cl cj os"><h2 class="bd iu gy z fp ot fr fs ou fu fw is bi translated">搜索算法-深度优先搜索，使用 Python</h2><div class="ov l"><h3 class="bd b gy z fp ot fr fs ou fu fw dk translated">从头开始 Python 实现</h3></div><div class="ow l"><p class="bd b dl z fp ot fr fs ou fu fw dk translated">towardsdatascience.com</p></div></div><div class="ox l"><div class="oy l oz pa pb ox pc ks oo"/></div></div></a></div><div class="ol om gp gr on oo"><a rel="noopener follow" target="_blank" href="/search-algorithm-breadth-first-search-with-python-50571a9bb85e"><div class="op ab fo"><div class="oq ab or cl cj os"><h2 class="bd iu gy z fp ot fr fs ou fu fw is bi translated">搜索算法-广度优先搜索，使用 Python</h2><div class="ov l"><h3 class="bd b gy z fp ot fr fs ou fu fw dk translated">从头开始 Python 实现</h3></div><div class="ow l"><p class="bd b dl z fp ot fr fs ou fu fw dk translated">towardsdatascience.com</p></div></div><div class="ox l"><div class="pd l oz pa pb ox pc ks oo"/></div></div></a></div><h1 id="bdf5" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">参考</h1><p id="0976" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">[1] <a class="ae ky" href="https://en.wikipedia.org/wiki/Search_algorithm" rel="noopener ugc nofollow" target="_blank">搜索算法—维基百科</a></p><p id="9479" class="pw-post-body-paragraph lr ls it lt b lu nb ju lw lx nc jx lz ma nd mc md me ne mg mh mi nf mk ml mm im bi translated">[2] <a class="ae ky" href="https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm#Practical_optimizations_and_infinite_graphs" rel="noopener ugc nofollow" target="_blank">迪杰斯特拉算法—维基百科</a></p><p id="8603" class="pw-post-body-paragraph lr ls it lt b lu nb ju lw lx nc jx lz ma nd mc md me ne mg mh mi nf mk ml mm im bi translated">[3] <a class="ae ky" href="https://en.wikipedia.org/?title=Uniform-cost_search&amp;redirect=no" rel="noopener ugc nofollow" target="_blank">统一成本搜索—维基百科</a></p></div></div>    
</body>
</html>