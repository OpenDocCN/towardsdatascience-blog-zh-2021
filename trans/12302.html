<html>
<head>
<title>LeetCode Longest Substring Without Repetition Solution in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中无重复的LeetCode最长子串解决方案</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/leetcode-problem-3-python-3ec4ae0ae13?source=collection_archive---------25-----------------------#2021-12-14">https://towardsdatascience.com/leetcode-problem-3-python-3ec4ae0ae13?source=collection_archive---------25-----------------------#2021-12-14</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><h2 id="10b5" class="is it iu bd b dl iv iw ix iy iz ja dk jb translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/interview-questions" rel="noopener" target="_blank">面试问题</a></h2><div class=""/><div class=""><h2 id="9305" class="pw-subtitle-paragraph ka jd iu bd b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr dk translated">LeetCode中问题3的最优解</h2></div><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj ks"><img src="../Images/e2ff30472c46fedd7b879fe780a4f794.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UOnzwa83UdC7ai_yQi8GFQ.jpeg"/></div></div><p class="le lf gk gi gj lg lh bd b be z dk translated">马库斯·温克勒在<a class="ae li" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><h2 id="d553" class="lj lk iu bd ll lm ln dn lo lp lq dp lr ls lt lu lv lw lx ly lz ma mb mc md ja bi translated">介绍</h2><p id="26a7" class="pw-post-body-paragraph me mf iu mg b mh mi ke mj mk ml kh mm ls mn mo mp lw mq mr ms ma mt mu mv mw in bi translated">LeetCode是一个平台，它提供了许多编码问题，这些问题通常会在谷歌、Meta和亚马逊等科技巨头的工程和机器学习职位的技术面试中被问到。</p><p id="8b7e" class="pw-post-body-paragraph me mf iu mg b mh mx ke mj mk my kh mm ls mz mo mp lw na mr ms ma nb mu mv mw in bi translated">在今天的文章中，我们将探讨LeetCode问题的第三个问题的几种方法，这个问题的难度为<strong class="mg je">中等</strong>级，称为<em class="nc">“无重复的最长子串”。</em></p></div><div class="ab cl nd ne hy nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="in io ip iq ir"><h2 id="0e27" class="lj lk iu bd ll lm ln dn lo lp lq dp lr ls lt lu lv lw lx ly lz ma mb mc md ja bi translated">问题是</h2><blockquote class="nk"><p id="50d5" class="nl nm iu bd nn no np nq nr ns nt mw dk translated">给定一个字符串<code class="fe nu nv nw nx b">s</code>，找出不含重复字符的<strong class="ak">最长子串</strong>的长度。</p></blockquote><p id="b097" class="pw-post-body-paragraph me mf iu mg b mh ny ke mj mk nz kh mm ls oa mo mp lw ob mr ms ma oc mu mv mw in bi translated"><strong class="mg je">例1: </strong></p><pre class="kt ku kv kw gu od nx oe of aw og bi"><span id="d6b8" class="lj lk iu nx b gz oh oi l oj ok"><strong class="nx je">Input:</strong> s = "abcabcbb"<br/><strong class="nx je">Output:</strong> 3<br/><strong class="nx je">Explanation:</strong> The answer is "abc", with the length of 3.</span></pre><p id="ab59" class="pw-post-body-paragraph me mf iu mg b mh mx ke mj mk my kh mm ls mz mo mp lw na mr ms ma nb mu mv mw in bi translated"><strong class="mg je">例2: </strong></p><pre class="kt ku kv kw gu od nx oe of aw og bi"><span id="bd73" class="lj lk iu nx b gz oh oi l oj ok"><strong class="nx je">Input:</strong> s = "bbbbb"<br/><strong class="nx je">Output:</strong> 1<br/><strong class="nx je">Explanation:</strong> The answer is "b", with the length of 1.</span></pre><p id="2343" class="pw-post-body-paragraph me mf iu mg b mh mx ke mj mk my kh mm ls mz mo mp lw na mr ms ma nb mu mv mw in bi translated"><strong class="mg je">例3: </strong></p><pre class="kt ku kv kw gu od nx oe of aw og bi"><span id="b124" class="lj lk iu nx b gz oh oi l oj ok"><strong class="nx je">Input:</strong> s = "pwwkew"<br/><strong class="nx je">Output:</strong> 3<br/><strong class="nx je">Explanation:</strong> The answer is "wke", with the length of 3.<br/>Notice that the answer must be a substring, "pwke" is a subsequence and not a substring.</span></pre><p id="1920" class="pw-post-body-paragraph me mf iu mg b mh mx ke mj mk my kh mm ls mz mo mp lw na mr ms ma nb mu mv mw in bi translated"><strong class="mg je">例4: </strong></p><pre class="kt ku kv kw gu od nx oe of aw og bi"><span id="9823" class="lj lk iu nx b gz oh oi l oj ok"><strong class="nx je">Input:</strong> s = ""<br/><strong class="nx je">Output:</strong> 0</span></pre><p id="e175" class="pw-post-body-paragraph me mf iu mg b mh mx ke mj mk my kh mm ls mz mo mp lw na mr ms ma nb mu mv mw in bi translated"><strong class="mg je">约束:</strong></p><ul class=""><li id="82cc" class="ol om iu mg b mh mx mk my ls on lw oo ma op mw oq or os ot bi translated"><code class="fe nu nv nw nx b">0 &lt;= s.length &lt;= 5 * 104</code></li><li id="88bc" class="ol om iu mg b mh ou mk ov ls ow lw ox ma oy mw oq or os ot bi translated"><code class="fe nu nv nw nx b">s</code>由英文字母、数字、符号和空格组成。</li></ul><blockquote class="oz pa pb"><p id="34b0" class="me mf nc mg b mh mx ke mj mk my kh mm pc mz mo mp pd na mr ms pe nb mu mv mw in bi translated">来源:<a class="ae li" href="https://leetcode.com/problems/longest-substring-without-repeating-characters/" rel="noopener ugc nofollow" target="_blank"> LeetCode </a></p></blockquote></div><div class="ab cl nd ne hy nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="in io ip iq ir"><h2 id="93a7" class="lj lk iu bd ll lm ln dn lo lp lq dp lr ls lt lu lv lw lx ly lz ma mb mc md ja bi translated">粗暴的方法</h2><p id="4c2b" class="pw-post-body-paragraph me mf iu mg b mh mi ke mj mk ml kh mm ls mn mo mp lw mq mr ms ma mt mu mv mw in bi translated">解决这个问题最直观的方法是使用两个嵌套循环执行强力搜索。</p><pre class="kt ku kv kw gu od nx oe of aw og bi"><span id="d74a" class="lj lk iu nx b gz oh oi l oj ok">class Solution:<br/>    def lengthOfLongestSubstring(self, s: str) -&gt; int:<br/>        <br/>        longest_str = ""<br/>        for i, c in enumerate(s):<br/>            canditate_str = str(c)<br/>            for j in range(i + 1, len(s)):<br/>                if s[j] not in canditate_str:<br/>                    canditate_str += str(s[j])<br/>                else:<br/>                    break<br/>            if len(canditate_str) &gt; len(longest_str):<br/>                longest_str = canditate_str</span><span id="d20e" class="lj lk iu nx b gz pf oi l oj ok">            if len(s) - i &lt;= len(longest_str):<br/>                break   </span><span id="4ec8" class="lj lk iu nx b gz pf oi l oj ok">        return len(longest_str)</span></pre><p id="22ff" class="pw-post-body-paragraph me mf iu mg b mh mx ke mj mk my kh mm ls mz mo mp lw na mr ms ma nb mu mv mw in bi translated">尽管上述算法可以解决问题，但时间复杂度——在本例中是<strong class="mg je">O(n)</strong>——是一个问题，因为我们肯定可以做得比这更好。</p></div><div class="ab cl nd ne hy nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="in io ip iq ir"><h2 id="cbe4" class="lj lk iu bd ll lm ln dn lo lp lq dp lr ls lt lu lv lw lx ly lz ma mb mc md ja bi translated">通过一个更好的方法</h2><p id="c8c7" class="pw-post-body-paragraph me mf iu mg b mh mi ke mj mk ml kh mm ls mn mo mp lw mq mr ms ma mt mu mv mw in bi translated">现在，为了改进前面的答案，我们需要以某种方式对包含字符的字符串进行一次遍历。可以帮助我们做到这一点的一种方法是所谓的<strong class="mg je">滑动窗口</strong>。</p><p id="3aa0" class="pw-post-body-paragraph me mf iu mg b mh mx ke mj mk my kh mm ls mz mo mp lw na mr ms ma nb mu mv mw in bi translated">为了阐明我所说的滑动窗口的含义，让我们考虑下面的字符串(在顶部我们显示了每个单独字符的索引):</p><pre class="kt ku kv kw gu od nx oe of aw og bi"><span id="b9e5" class="lj lk iu nx b gz oh oi l oj ok">#               0 1 2 3 4 5 6 7   <br/>#               a b c a b c b b</span></pre><p id="042c" class="pw-post-body-paragraph me mf iu mg b mh mx ke mj mk my kh mm ls mz mo mp lw na mr ms ma nb mu mv mw in bi translated">滑动窗口具有开始和结束索引:</p><pre class="kt ku kv kw gu od nx oe of aw og bi"><span id="2b67" class="lj lk iu nx b gz oh oi l oj ok">#               0 1 2 3 4 5 6 7   <br/>#               a b c a b c b b<br/># start         |<br/># end           |</span></pre><p id="6242" class="pw-post-body-paragraph me mf iu mg b mh mx ke mj mk my kh mm ls mz mo mp lw na mr ms ma nb mu mv mw in bi translated">根据不同的算法，起始和结束索引将相应地移动。在我们的例子中，我们希望创建滑动窗口并向前移动，如下图所示。</p><pre class="kt ku kv kw gu od nx oe of aw og bi"><span id="9ebc" class="lj lk iu nx b gz oh oi l oj ok">#               0 1 2 3 4 5 6 7   <br/>#               a b c a b c b b<br/># start         |<br/># end             |</span><span id="4ef8" class="lj lk iu nx b gz pf oi l oj ok">#               0 1 2 3 4 5 6 7   <br/>#               a b c a b c b b<br/># start         |<br/># end               |</span><span id="99e7" class="lj lk iu nx b gz pf oi l oj ok">#               0 1 2 3 4 5 6 7   <br/>#               a b c a b c b b<br/># start         |<br/># end                 |</span><span id="c1b3" class="lj lk iu nx b gz pf oi l oj ok">#               0 1 2 3 4 5 6 7   <br/>#               a b c a b c b b<br/># start           |<br/># end                 |</span><span id="a813" class="lj lk iu nx b gz pf oi l oj ok">#               0 1 2 3 4 5 6 7   <br/>#               a b c a b c b b<br/># start           |<br/># end                   |</span><span id="3168" class="lj lk iu nx b gz pf oi l oj ok">#               0 1 2 3 4 5 6 7   <br/>#               a b c a b c b b<br/># start             |<br/># end                   |</span><span id="88df" class="lj lk iu nx b gz pf oi l oj ok">#               0 1 2 3 4 5 6 7   <br/>#               a b c a b c b b<br/># start             |<br/># end                     |</span><span id="805f" class="lj lk iu nx b gz pf oi l oj ok">#               0 1 2 3 4 5 6 7   <br/>#               a b c a b c b b<br/># start               |<br/># end                     |</span><span id="b596" class="lj lk iu nx b gz pf oi l oj ok">#               0 1 2 3 4 5 6 7   <br/>#               a b c a b c b b<br/># start               |<br/># end                       |</span><span id="643d" class="lj lk iu nx b gz pf oi l oj ok">#               0 1 2 3 4 5 6 7   <br/>#               a b c a b c b b<br/># start                   |<br/># end                       |</span><span id="7b86" class="lj lk iu nx b gz pf oi l oj ok">#               0 1 2 3 4 5 6 7   <br/>#               a b c a b c b b<br/># start                   |<br/># end                         |</span><span id="4d59" class="lj lk iu nx b gz pf oi l oj ok">#               0 1 2 3 4 5 6 7   <br/>#               a b c a b c b b<br/># start                       |<br/># end                         |</span></pre><p id="d730" class="pw-post-body-paragraph me mf iu mg b mh mx ke mj mk my kh mm ls mz mo mp lw na mr ms ma nb mu mv mw in bi translated">可以反映下图/代码中描述的逻辑的算法如下所示。我们使用哈希映射(即Python字典)，其中键对应到目前为止看到的字符，值对应到这个特定字符最后被看到的索引。</p><pre class="kt ku kv kw gu od nx oe of aw og bi"><span id="9821" class="lj lk iu nx b gz oh oi l oj ok">class Solution:<br/>    def lengthOfLongestSubstring(self, s: str) -&gt; int:<br/>        chars = {}<br/>        start = 0<br/>        max_length = 0<br/>            <br/>        for end, c in enumerate(s):<br/>            if c in chars:<br/>                start = max(start, chars[c] + 1)<br/>            <br/>            max_length = max(max_length, end - start + 1)<br/>            chars[c] = end</span><span id="b226" class="lj lk iu nx b gz pf oi l oj ok">        return max_length</span></pre><p id="69cb" class="pw-post-body-paragraph me mf iu mg b mh mx ke mj mk my kh mm ls mz mo mp lw na mr ms ma nb mu mv mw in bi translated">现在，就复杂性而言，与强力方法相比，我们取得了显著的改进，因为现在我们只对字符串迭代一次，因此我们的解决方案的时间复杂性为O(n) 。</p></div><div class="ab cl nd ne hy nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="in io ip iq ir"><h2 id="78f3" class="lj lk iu bd ll lm ln dn lo lp lq dp lr ls lt lu lv lw lx ly lz ma mb mc md ja bi translated">最后的想法</h2><p id="f311" class="pw-post-body-paragraph me mf iu mg b mh mi ke mj mk ml kh mm ls mn mo mp lw mq mr ms ma mt mu mv mw in bi translated">在今天的文章中，我们介绍了LeetCode平台上第三个问题的几个潜在解决方案，这个问题叫做<em class="nc">“无重复的最长子串”</em>。</p><p id="0f70" class="pw-post-body-paragraph me mf iu mg b mh mx ke mj mk my kh mm ls mz mo mp lw na mr ms ma nb mu mv mw in bi translated">我们最初创建了一个次优的解决方案，通过创建两个嵌套循环来确定输入字符串中哪个子字符串是最长的，这涉及到暴力。</p><p id="3ed9" class="pw-post-body-paragraph me mf iu mg b mh mx ke mj mk my kh mm ls mz mo mp lw na mr ms ma nb mu mv mw in bi translated">最后，我们通过使用滑动窗口和哈希映射(即Python字典)来优化算法，这样我们只需要对字符串进行一次遍历，就可以在O(n)时间内解决问题。</p></div><div class="ab cl nd ne hy nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="in io ip iq ir"><p id="1b77" class="pw-post-body-paragraph me mf iu mg b mh mx ke mj mk my kh mm ls mz mo mp lw na mr ms ma nb mu mv mw in bi translated"><a class="ae li" href="https://gmyrianthous.medium.com/membership" rel="noopener"> <strong class="mg je">成为会员</strong> </a> <strong class="mg je">阅读媒介上的每一个故事。你的会员费直接支持我和你看的其他作家。你也可以在媒体上看到所有的故事。</strong></p><div class="pg ph gq gs pi pj"><a href="https://gmyrianthous.medium.com/membership" rel="noopener follow" target="_blank"><div class="pk ab fp"><div class="pl ab pm cl cj pn"><h2 class="bd je gz z fq po fs ft pp fv fx jd bi translated">通过我的推荐链接加入Medium-Giorgos Myrianthous</h2><div class="pq l"><h3 class="bd b gz z fq po fs ft pp fv fx dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="pr l"><p class="bd b dl z fq po fs ft pp fv fx dk translated">gmyrianthous.medium.com</p></div></div><div class="ps l"><div class="pt l pu pv pw ps px lc pj"/></div></div></a></div></div><div class="ab cl nd ne hy nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="in io ip iq ir"><p id="676e" class="pw-post-body-paragraph me mf iu mg b mh mx ke mj mk my kh mm ls mz mo mp lw na mr ms ma nb mu mv mw in bi translated"><strong class="mg je">你可能也会喜欢</strong></p><div class="pg ph gq gs pi pj"><a rel="noopener follow" target="_blank" href="/leetcode-problem-1-python-ec6cba23c20f"><div class="pk ab fp"><div class="pl ab pm cl cj pn"><h2 class="bd je gz z fq po fs ft pp fv fx jd bi translated">Python中的LeetCode问题1解决方案</h2><div class="pq l"><h3 class="bd b gz z fq po fs ft pp fv fx dk translated">讨论了LeetCode中两个和问题的最优解的方法</h3></div><div class="pr l"><p class="bd b dl z fq po fs ft pp fv fx dk translated">towardsdatascience.com</p></div></div><div class="ps l"><div class="py l pu pv pw ps px lc pj"/></div></div></a></div></div><div class="ab cl nd ne hy nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="in io ip iq ir"><div class="kt ku kv kw gu pj"><a rel="noopener follow" target="_blank" href="/leetcode-problem-2-python-1c59efdf3367"><div class="pk ab fp"><div class="pl ab pm cl cj pn"><h2 class="bd je gz z fq po fs ft pp fv fx jd bi translated">LeetCode问题2:用Python添加两个数的解决方案</h2><div class="pq l"><h3 class="bd b gz z fq po fs ft pp fv fx dk translated">理解如何用Python中的链表高效地解决两个数相加问题</h3></div><div class="pr l"><p class="bd b dl z fq po fs ft pp fv fx dk translated">towardsdatascience.com</p></div></div><div class="ps l"><div class="pz l pu pv pw ps px lc pj"/></div></div></a></div></div></div>    
</body>
</html>