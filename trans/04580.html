<html>
<head>
<title>Item-Based Collaborative Filtering in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中基于项目的协同过滤</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/item-based-collaborative-filtering-in-python-91f747200fab?source=collection_archive---------0-----------------------#2021-04-20">https://towardsdatascience.com/item-based-collaborative-filtering-in-python-91f747200fab?source=collection_archive---------0-----------------------#2021-04-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="1209" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">用python实现基于项目的协同过滤的实践。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/a51571488eeec2283ff74f5984392918.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*u83mi2nvteEs13-0"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@cardmapr?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> CardMapr.nl </a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="a2f2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">基于项目的协同过滤</strong>是利用用户评分，利用项目间相似性的推荐系统。在本文中，我解释了它的基本概念，并实践了如何使用Python制作基于项目的协同过滤。</p><h1 id="2a63" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">基本概念</h1><p id="d312" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">这种方法的基本假设是<strong class="ky ir">用户对相似的电影给出相似的评级</strong>。考虑下面的电影分级表。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mp"><img src="../Images/ed4a120c91837b1c599d673ab36e37a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eO-BbYWl8X6nsnQymhMbAQ.png"/></div></div></figure><p id="c656" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本例中，<code class="fe mq mr ms mt b"><strong class="ky ir"> User_1</strong></code>对<code class="fe mq mr ms mt b"><strong class="ky ir">Movie_1</strong></code>的评级为空。让我们使用基于项目的协同过滤来预测这个评级。</p><ul class=""><li id="6096" class="mu mv iq ky b kz la lc ld lf mw lj mx ln my lr mz na nb nc bi translated"><strong class="ky ir">步骤1:找到与你想要预测分级的电影最相似(最接近)的电影。</strong></li></ul><p id="f717" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有多种方法可以找到最近的电影。在这里，我使用了<a class="ae kv" href="https://en.wikipedia.org/wiki/Cosine_similarity" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"/></a>余弦相似度。在使用余弦相似度时，替换为0的缺失值。看下图。<em class="nd"> x轴</em>代表<code class="fe mq mr ms mt b"><strong class="ky ir">User_0</strong></code>的等级，<em class="nd"> y轴</em>代表<code class="fe mq mr ms mt b"><strong class="ky ir">User_1</strong></code>的等级。然后，我们可以为空间中的每部电影找到点。例如，<code class="fe mq mr ms mt b"><strong class="ky ir">Movie_3</strong></code>对应于空间中的点(5，2)。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ne"><img src="../Images/bd083320f932719b14e77572313f297b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s276E7Ovzjs54QSTHo0M2w.png"/></div></div></figure><p id="27e3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">余弦相似度用<strong class="ky ir"> cos(θ) </strong>来衡量两个向量之间的距离。随着θ增大，cos(θ)减小(θ= 0°时cos(θ) = 1，θ= 90°时cos(θ) = 0)。因此，θ值越小，这两个向量就越接近(相似性越大)。由于θ1最小，θ3最大，<code class="fe mq mr ms mt b"><strong class="ky ir">Movie_3</strong></code>离<code class="fe mq mr ms mt b"><strong class="ky ir">Movie_1</strong></code> <strong class="ky ir">，</strong>，<code class="fe mq mr ms mt b"><strong class="ky ir">Movie_2</strong></code>最远。</p><p id="f618" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">这里值得注意的是，电影之间的相似度是由所有用户决定的。</strong>例如，<code class="fe mq mr ms mt b"><strong class="ky ir">Movie_1</strong></code>和<code class="fe mq mr ms mt b"><strong class="ky ir">Movie_3</strong></code>之间的相似度是使用<code class="fe mq mr ms mt b"><strong class="ky ir">User_0</strong></code>和<code class="fe mq mr ms mt b"><strong class="ky ir">User_1</strong></code>的评分来计算的。</p><ul class=""><li id="c007" class="mu mv iq ky b kz la lc ld lf mw lj mx ln my lr mz na nb nc bi translated"><strong class="ky ir">第二步:计算用户对最相似电影的评分加权平均值。</strong></li></ul><p id="ddc8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">用户对相似的电影给出相似的评级。因此，当我们预测用户对电影的评级时，使用用户对类似电影的评级的平均值是合理的。将最近邻的数量设置为2。然后我们使用<code class="fe mq mr ms mt b"><strong class="ky ir">Movie_3</strong></code>和<code class="fe mq mr ms mt b"><strong class="ky ir">Movie_0</strong></code>来预测<code class="fe mq mr ms mt b"><strong class="ky ir">User_1</strong></code>对<code class="fe mq mr ms mt b"><strong class="ky ir">Movie_0</strong></code>的评分。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nf"><img src="../Images/7450bf714e607321f837a9e29423cfe1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F6uZ-1y0YFY30a6DGAAfVA.png"/></div></div></figure><p id="0f07" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mq mr ms mt b"><strong class="ky ir">User_1</strong></code> <strong class="ky ir"> </strong>对<code class="fe mq mr ms mt b"><strong class="ky ir">Movie_3</strong></code>的评分为<strong class="ky ir"> </strong> 2，<code class="fe mq mr ms mt b"><strong class="ky ir">User_1</strong></code>对<code class="fe mq mr ms mt b"><strong class="ky ir">Movie_0</strong></code>的评分为3。如果<code class="fe mq mr ms mt b"><strong class="ky ir">Movie_3</strong></code>和<code class="fe mq mr ms mt b"><strong class="ky ir">Movie_0</strong></code>与<code class="fe mq mr ms mt b"><strong class="ky ir">Movie_1</strong></code>距离相同，我们可以通过<code class="fe mq mr ms mt b"><strong class="ky ir">User_1</strong></code>估算出<code class="fe mq mr ms mt b"><strong class="ky ir">Movie_1</strong></code>的等级为2.5。但是，如果认为<code class="fe mq mr ms mt b"><strong class="ky ir">Movie_3</strong></code>更靠近<code class="fe mq mr ms mt b"><strong class="ky ir">Movie_1</strong></code>，则<code class="fe mq mr ms mt b"><strong class="ky ir">Movie_3</strong></code>的重量应该大于<code class="fe mq mr ms mt b"><strong class="ky ir">Movie_0</strong></code>的重量。因此，如下图所示，<code class="fe mq mr ms mt b"><strong class="ky ir">Movie_1</strong></code>的预测评级将更接近于<code class="fe mq mr ms mt b"><strong class="ky ir">Movie_3</strong></code>的评级。使用余弦相似度作为权重，预测评分为2.374。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ng"><img src="../Images/f833cd9d3b0706d623c602828ae2e827.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qIusj_RQs7Q9rKBOZ4OA4Q.png"/></div></div></figure><h1 id="03be" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">制作电影推荐器</h1><p id="382c" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">为了更好地理解，这里使用了具有10部电影和10个用户的数据集。(数字是随机抽取的。)</p><pre class="kg kh ki kj gt nh mt ni nj aw nk bi"><span id="acb0" class="nl lt iq mt b gy nm nn l no np"><strong class="mt ir">df</strong></span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/33b28727d33c145a4f4d2a4b0848ee67.png" data-original-src="https://miro.medium.com/v2/resize:fit:1382/format:webp/1*2OjZYuAbHxmKRL95zC9PDA.png"/></div></figure><ul class=""><li id="b1fc" class="mu mv iq ky b kz la lc ld lf mw lj mx ln my lr mz na nb nc bi translated">10部电影和10个用户</li><li id="9a5a" class="mu mv iq ky b kz nr lc ns lf nt lj nu ln nv lr mz na nb nc bi translated">0表示缺少值。</li><li id="5e49" class="mu mv iq ky b kz nr lc ns lf nt lj nu ln nv lr mz na nb nc bi translated">用户给电影评分的百分比是50%(只给50分)。在真实的电影数据集中，这个百分比变得小于10%。</li></ul><p id="9b6c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果用户没有对电影进行评级，我假设用户没有观看电影。</p><h2 id="1130" class="nl lt iq bd lu nw nx dn ly ny nz dp mc lf oa ob me lj oc od mg ln oe of mi og bi translated">计算最近的邻居</h2><p id="2062" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated"><code class="fe mq mr ms mt b"><strong class="ky ir">sklearn.neighbors</strong></code>库中的<strong class="ky ir"> </strong> <code class="fe mq mr ms mt b"><strong class="ky ir">NearestNeighbors()</strong></code>可用于使用<strong class="ky ir">余弦相似度</strong>计算电影之间的距离，并为每部电影找到最近的邻居。</p><pre class="kg kh ki kj gt nh mt ni nj aw nk bi"><span id="8315" class="nl lt iq mt b gy nm nn l no np">from sklearn.neighbors import NearestNeighbors</span><span id="9250" class="nl lt iq mt b gy oh nn l no np">knn = NearestNeighbors(metric='cosine', algorithm='brute')<br/>knn.fit(df.values)<br/>distances, indices = knn.kneighbors(df.values, <strong class="mt ir">n_neighbors=3</strong>)</span></pre><p id="9206" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最近邻居(<code class="fe mq mr ms mt b"><strong class="ky ir">n_neighbors</strong></code>)的数量被设置为3。由于这包括电影本身，通常它会找到除电影本身之外的两个最近的电影。</p><pre class="kg kh ki kj gt nh mt ni nj aw nk bi"><span id="8ddf" class="nl lt iq mt b gy nm nn l no np">indices</span><span id="2af1" class="nl lt iq mt b gy oh nn l no np"><strong class="mt ir">[Out] array([[0, 7, 5],<br/>             [1, 3, 7],<br/>             [2, 1, 6],<br/>              ....<br/>             [9, 0, 7]])</strong></span></pre><p id="8b6e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mq mr ms mt b"><strong class="ky ir">indices</strong></code>显示每部电影的最近邻居的指数。每一行对应于<code class="fe mq mr ms mt b"><strong class="ky ir">df</strong></code>中的一行。一行中的第一个元素是最相似(最近)的电影。一般是电影本身。第二个元素是第二个最近的，第三个是第三个最近的。比如第一行<code class="fe mq mr ms mt b"><strong class="ky ir">[0,7,5]</strong></code>，离<code class="fe mq mr ms mt b"><strong class="ky ir">movie_0</strong></code>最近的电影是自己，第二个最近的电影是<code class="fe mq mr ms mt b"><strong class="ky ir">movie_7</strong></code>，第三个是<code class="fe mq mr ms mt b"><strong class="ky ir">movie_5</strong></code>。</p><pre class="kg kh ki kj gt nh mt ni nj aw nk bi"><span id="a9d6" class="nl lt iq mt b gy nm nn l no np">distances</span><span id="c17a" class="nl lt iq mt b gy oh nn l no np"><strong class="mt ir">[Out] array([[0.00000000e+00, 3.19586183e-01, 4.03404722e-01],        [4.44089210e-16, 3.68421053e-01, 3.95436458e-01],        [0.00000000e+00, 5.20766162e-01, 5.24329288e-01],<br/> ....<br/>[1.11022302e-16, 4.22649731e-01, 4.81455027e-01]])</strong></span></pre><p id="cd57" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mq mr ms mt b"><strong class="ky ir">distances</strong></code>显示电影之间的距离。数字越小，表示电影越近。该数组中的每个数字对应于<strong class="ky ir">索引</strong>数组中的数字。</p><h2 id="d014" class="nl lt iq bd lu nw nx dn ly ny nz dp mc lf oa ob me lj oc od mg ln oe of mi og bi translated">示例:预测用户对电影的评级</h2><p id="8803" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">预测用户对电影的评价相当于计算用户对相似电影的评价的加权平均值。</p><p id="eff6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">实际上，通过<code class="fe mq mr ms mt b"><strong class="ky ir">user_7</strong></code>预测<code class="fe mq mr ms mt b"><strong class="ky ir">movie_0</strong></code>的评级。首先，使用<code class="fe mq mr ms mt b"><strong class="ky ir">NearestNeighbors()</strong></code>找到<code class="fe mq mr ms mt b"><strong class="ky ir">movie_0</strong></code>的最近邻居。</p><pre class="kg kh ki kj gt nh mt ni nj aw nk bi"><span id="0d3b" class="nl lt iq mt b gy nm nn l no np"><strong class="mt ir"># get the index for 'movie_0'</strong><br/>index_for_movie = df.index.tolist().index('<strong class="mt ir">movie_0</strong>')</span><span id="ac85" class="nl lt iq mt b gy oh nn l no np"><strong class="mt ir"># find the indices for the similar movies<br/></strong>sim_movies = indices[index_for_movie].tolist()</span><span id="3ba7" class="nl lt iq mt b gy oh nn l no np"><strong class="mt ir"># distances between 'movie_0' and the similar movies<br/></strong>movie_distances = distances[index_for_movie].tolist()</span><span id="a20c" class="nl lt iq mt b gy oh nn l no np"><strong class="mt ir"># the position of 'movie_0' in the list sim_movies<br/></strong>id_movie = sim_movies.index(index_for_movie)</span><span id="fd4c" class="nl lt iq mt b gy oh nn l no np"><strong class="mt ir"># remove 'movie_0' from the list sim_movies<br/></strong>sim_movies.remove(index_for_movie)</span><span id="cd2f" class="nl lt iq mt b gy oh nn l no np"><strong class="mt ir"># remove 'movie_0' from the list movie_distances<br/></strong>movie_distances.pop(id_movie)</span><span id="655d" class="nl lt iq mt b gy oh nn l no np">print('The Nearest Movies to <strong class="mt ir">movie_0</strong>:', sim_movies)<br/>print('The Distance from <strong class="mt ir">movie_0</strong>:', movie_distances)</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/ca8951bb9d25384f0b7efbc6ea6835b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1082/format:webp/1*tGe9s4GKMVu8DJgRCYfG1A.png"/></div></figure><p id="2bff" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">与<code class="fe mq mr ms mt b"><strong class="ky ir">movie_0</strong></code>最相似的电影是<code class="fe mq mr ms mt b"><strong class="ky ir">movie_7</strong></code>和<code class="fe mq mr ms mt b"><strong class="ky ir">movie_5</strong></code>，与<code class="fe mq mr ms mt b"><strong class="ky ir">movie_0</strong></code>的距离分别为0.3196和0.4034。</p><p id="05e8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">计算预测评级的公式如下:</p><p id="c806" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"><em class="nd">【r(m，u) = </em> { <em class="nd"> ∑ ⱼ S(m，j)R(j，u) </em> } <em class="nd"> / ∑ ⱼ S(m，j) </em> </strong></p><ul class=""><li id="5375" class="mu mv iq ky b kz la lc ld lf mw lj mx ln my lr mz na nb nc bi translated"><strong class="ky ir"> <em class="nd"> R(m，u) </em> </strong>:用户<strong class="ky ir"><em class="nd"/></strong>对电影<strong class="ky ir"> <em class="nd"> m </em> </strong>的评分</li><li id="61c0" class="mu mv iq ky b kz nr lc ns lf nt lj nu ln nv lr mz na nb nc bi translated"><strong class="ky ir"> <em class="nd"> S(m，j) </em> </strong>:电影<strong class="ky ir"> <em class="nd"> m </em> </strong>与电影<strong class="ky ir"> <em class="nd"> j </em> </strong>的相似性</li><li id="0bfe" class="mu mv iq ky b kz nr lc ns lf nt lj nu ln nv lr mz na nb nc bi translated"><strong class="ky ir"> <em class="nd"> j ∈ J </em> </strong>其中<strong class="ky ir"> <em class="nd"> J </em> </strong>是与电影<strong class="ky ir"> <em class="nd"> m </em> </strong>相似的电影的集合</li></ul><p id="01d9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个公式简单地暗示了用户<strong class="ky ir"><em class="nd"/></strong>对电影<strong class="ky ir"><em class="nd"/></strong>的预测评级是用户<strong class="ky ir"><em class="nd"/></strong>对类似电影的评级的加权平均值。当电影<strong class="ky ir"> <em class="nd"> m </em> </strong>和电影<strong class="ky ir"> <em class="nd"> k </em> </strong>越接近时，每个评价的权重越大。该项的分母使所有权重之和等于1。</p><p id="9820" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们用<code class="fe mq mr ms mt b"><strong class="ky ir">user_7</strong></code>，<strong class="ky ir"> R(0，7): </strong>来预测<code class="fe mq mr ms mt b"><strong class="ky ir">movie_0</strong></code>的评分</p><p id="5f91" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> R(0，7)=[S(0，5)÷R(5，7)+S(0，7)÷R(7，7)]/[S(0，5)+S(0，7)] </strong></p><p id="512f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于<code class="fe mq mr ms mt b"><strong class="ky ir">movie_0</strong></code>和<code class="fe mq mr ms mt b"><strong class="ky ir">movie_5</strong></code>以及<code class="fe mq mr ms mt b"><strong class="ky ir">movie_0</strong></code>和<code class="fe mq mr ms mt b"><strong class="ky ir">movie_7</strong></code>之间的距离分别为0.4034和0.3196，相似性为</p><ul class=""><li id="35ea" class="mu mv iq ky b kz la lc ld lf mw lj mx ln my lr mz na nb nc bi translated">S(0，5)  = (1-0.4034)</li><li id="eb5d" class="mu mv iq ky b kz nr lc ns lf nt lj nu ln nv lr mz na nb nc bi translated"><strong class="ky ir"> S(0，7) </strong> = (1-0.3196)。</li></ul><p id="3965" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为<strong class="ky ir"> R(5，7) </strong> = 2、<strong class="ky ir"> R(7，7) </strong> = 3，所以预测的<strong class="ky ir"> R(0，7) </strong>为2.5328。</p><h2 id="b3e9" class="nl lt iq bd lu nw nx dn ly ny nz dp mc lf oa ob me lj oc od mg ln oe of mi og bi translated">建立一个推荐者</h2><p id="35bc" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">下面的代码预测了所有没有看过的电影的收视率。(<code class="fe mq mr ms mt b"><strong class="ky ir">n_neighbors = 3</strong></code>)</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="3f11" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">原始数据集<code class="fe mq mr ms mt b"><strong class="ky ir">df1</strong></code>的副本更新了<code class="fe mq mr ms mt b"><strong class="ky ir">user_4</strong></code>的所有预测评级。以下代码是使用更新的数据集为选定用户显示推荐电影的函数。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="46aa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，让我们为<code class="fe mq mr ms mt b"><strong class="ky ir">user_4</strong></code>推荐5部电影。</p><pre class="kg kh ki kj gt nh mt ni nj aw nk bi"><span id="45cf" class="nl lt iq mt b gy nm nn l no np">recommend_movies('user_4', 5)</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/1256120e2f0086ff4e0d6dfd753dbe4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:778/format:webp/1*bh4KpNt6B3d46GsLr5KZgQ.png"/></div></figure><p id="1480" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">输出显示用户已经观看的电影列表和推荐的电影列表。<code class="fe mq mr ms mt b"><strong class="ky ir">movie_2</strong></code>对<code class="fe mq mr ms mt b"><strong class="ky ir">user_4</strong></code>的预测评分最高。</p><p id="fd8b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个项目的目标是建立一个推荐器，为选定的用户推荐电影。如果我们在推荐器中输入一个用户名，推荐器应该返回具有最高预测评级的推荐电影列表。结合上面的代码，我们可以为任何选定的用户构建电影推荐器。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="e3b9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面用<code class="fe mq mr ms mt b">n_neighbors = 3</code>和<code class="fe mq mr ms mt b">the number of recommended movies = 4</code>为<code class="fe mq mr ms mt b">user_4</code>推荐电影。</p><pre class="kg kh ki kj gt nh mt ni nj aw nk bi"><span id="b42d" class="nl lt iq mt b gy nm nn l no np">movie_recommender('user_4', 3, 4)</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi om"><img src="../Images/7aa70f69e3c66ff620754d07ec978d4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:758/format:webp/1*dwXAfEAQKaqN9mTTAKlHBA.png"/></div></figure><p id="78ea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，我简要解释了基于项目的协同过滤的基本概念，并展示了如何使用这种方法构建推荐引擎。</p><p id="7580" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">本练习的附加代码和电影数据集可以在<a class="ae kv" href="https://github.com/yjeong5126/movie_recommender/tree/master/item_based_collaborative_filtering" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p></div></div>    
</body>
</html>