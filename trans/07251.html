<html>
<head>
<title>Build Robust Google BigQuery Pipelines with Python: Part II</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Python构建健壮的Google BigQuery管道:第二部分</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/build-robust-google-bigquery-pipelines-with-python-part-ii-2883423a1c8a?source=collection_archive---------26-----------------------#2021-07-01">https://towardsdatascience.com/build-robust-google-bigquery-pipelines-with-python-part-ii-2883423a1c8a?source=collection_archive---------26-----------------------#2021-07-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="b0b2" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph">谷歌云平台</h2><div class=""/><div class=""><h2 id="65dd" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">Python中的BigQuery <code class="fe ko kp kq kr b">STRUCT</code></h2></div><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi ks"><img src="../Images/51197f92bdb296fd0edf1a9d353e9a2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*v3aCa7TkaWu5RcDD"/></div></div><p class="le lf gj gh gi lg lh bd b be z dk translated">由<a class="ae li" href="https://unsplash.com/@jbcreate_?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Joseph Barrientos </a>在<a class="ae li" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="e8ef" class="pw-post-body-paragraph lj lk iq ll b lm ln ka lo lp lq kd lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">这是关于在Python中与BigQuery交互以构建数据管道的三篇文章系列的第二部分。</p><ul class=""><li id="2a66" class="mf mg iq ll b lm ln lp lq ls mh lw mi ma mj me mk ml mm mn bi translated"><a class="ae li" rel="noopener" target="_blank" href="/build-robust-google-bigquery-pipelines-with-python-part-i-1ac8ca11391a">第一部分:Apache Beam与Google BigQuery API </a></li><li id="4b32" class="mf mg iq ll b lm mo lp mp ls mq lw mr ma ms me mk ml mm mn bi translated">第二部分。Python中的BigQuery <code class="fe ko kp kq kr b">STRUCT</code></li><li id="44e4" class="mf mg iq ll b lm mo lp mp ls mq lw mr ma ms me mk ml mm mn bi translated">第三部分。BigQuery和Google Sheet:隐藏的复杂性</li></ul></div><div class="ab cl mt mu hu mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="ij ik il im in"><h1 id="6ec8" class="na nb iq bd nc nd ne nf ng nh ni nj nk kf nl kg nm ki nn kj no kl np km nq nr bi translated">什么是STRUCT？</h1><blockquote class="ns nt nu"><p id="8303" class="lj lk nv ll b lm ln ka lo lp lq kd lr nw lt lu lv nx lx ly lz ny mb mc md me ij bi translated"><code class="fe ko kp kq kr b">STRUCT</code>是有序字段的容器，每个字段都有一个类型(必需的)和字段名称(可选的)。—谷歌云</p></blockquote><p id="f639" class="pw-post-body-paragraph lj lk iq ll b lm ln ka lo lp lq kd lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">在BigQuery中，一个<code class="fe ko kp kq kr b">STRUCT</code>就像一个数据帧，因此它可以包含多个具有不同列名和数据类型的子列。相比之下，一个<code class="fe ko kp kq kr b">ARRAY</code>就像Python中的一个<code class="fe ko kp kq kr b">LIST</code>，你可以在一个<code class="fe ko kp kq kr b">ARRAY</code>中嵌套一个<code class="fe ko kp kq kr b">STRUCT</code>，也可以在一个<code class="fe ko kp kq kr b">STRUCT</code>中嵌套一个<code class="fe ko kp kq kr b">ARRAY</code>。</p><p id="a240" class="pw-post-body-paragraph lj lk iq ll b lm ln ka lo lp lq kd lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated"><code class="fe ko kp kq kr b">STRUCT</code>使用尖括号(<code class="fe ko kp kq kr b">&lt;</code>和<code class="fe ko kp kq kr b">&gt;</code>)声明类型。<code class="fe ko kp kq kr b">STRUCT</code>的元素类型为<strong class="ll ja">所需的</strong>，可以任意复杂。字段名<strong class="ll ja">可选</strong>，允许重复字段名。当缺少字段名时，该字段被认为是匿名的。</p><p id="eb68" class="pw-post-body-paragraph lj lk iq ll b lm ln ka lo lp lq kd lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">使用<code class="fe ko kp kq kr b">STRUCT</code>的好处是在连接表时减少了重复的麻烦。然而，它确实增加了访问的难度——特别是对于那些不太懂技术的用户。</p><p id="4c55" class="pw-post-body-paragraph lj lk iq ll b lm ln ka lo lp lq kd lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">要阅读更多关于构建<code class="fe ko kp kq kr b">STRUCT</code>的内容，Google Cloud有一个非常好的关于这个主题的<a class="ae li" href="https://cloud.google.com/bigquery/docs/reference/standard-sql/data-types#struct_type" rel="noopener ugc nofollow" target="_blank">文档</a>。</p><h1 id="c351" class="na nb iq bd nc nd nz nf ng nh oa nj nk kf ob kg nm ki oc kj no kl od km nq nr bi translated">查询结构</h1><p id="8db2" class="pw-post-body-paragraph lj lk iq ll b lm oe ka lo lp of kd lr ls og lu lv lw oh ly lz ma oi mc md me ij bi translated"><code class="fe ko kp kq kr b">DOT</code>注释将允许您查询包含在<code class="fe ko kp kq kr b">STRUCT</code>中的项目。<code class="fe ko kp kq kr b">UNNEST</code>是在需要展平嵌套结构时使用的函数，例如BigQuery中的<code class="fe ko kp kq kr b">STRUCT</code>或<code class="fe ko kp kq kr b">ARRAY</code>。</p><pre class="kt ku kv kw gt oj kr ok ol aw om bi"><span id="d957" class="on nb iq kr b gy oo op l oq or">SELECT<br/>  user.user_id, -- ARRAY<br/>  user.gender, -- STRING<br/>  user.is_active, -- BOOLEAN<br/>FROM<br/>  `my-project.my_dataset.user_info`,<br/>  UNNEST(user) user</span></pre><p id="2b1e" class="pw-post-body-paragraph lj lk iq ll b lm ln ka lo lp lq kd lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">值得一提的几个怪癖:</p><ul class=""><li id="4ef5" class="mf mg iq ll b lm ln lp lq ls mh lw mi ma mj me mk ml mm mn bi translated">当字段是嵌套在<code class="fe ko kp kq kr b">STRUCT</code>中的<code class="fe ko kp kq kr b">ARRAY</code>时，<code class="fe ko kp kq kr b">NOT NULL</code>功能不起作用(即<code class="fe ko kp kq kr b">WHERE user.user_id IS NOT NULL</code>)。<code class="fe ko kp kq kr b">NULL</code>仍将返回值行。在<code class="fe ko kp kq kr b">WHERE</code>子句中使用<code class="fe ko kp kq kr b">LENGTH(user.user_id) &gt; 0</code>——这将达到目的！</li><li id="61dc" class="mf mg iq ll b lm mo lp mp ls mq lw mr ma ms me mk ml mm mn bi translated">有时<code class="fe ko kp kq kr b">UNNEST</code>函数会导致重复行。这是因为<code class="fe ko kp kq kr b">UNNEST</code>正在对表中的所有字段执行<code class="fe ko kp kq kr b">CROSS JOIN</code>。为了避免这种情况，可以考虑在<code class="fe ko kp kq kr b">STRUCT</code>中创建一个<code class="fe ko kp kq kr b">ARRAY</code>，或者仅对子查询中需要的字段使用<code class="fe ko kp kq kr b">UNNEST</code>。</li></ul><h1 id="bf75" class="na nb iq bd nc nd nz nf ng nh oa nj nk kf ob kg nm ki oc kj no kl od km nq nr bi translated">用Python下载<code class="fe ko kp kq kr b">STRUCT</code></h1><p id="593b" class="pw-post-body-paragraph lj lk iq ll b lm oe ka lo lp of kd lr ls og lu lv lw oh ly lz ma oi mc md me ij bi translated">当一个<code class="fe ko kp kq kr b">STRUCT</code>在Python中没有任何<code class="fe ko kp kq kr b">UNNEST</code>被下载时，它将在<code class="fe ko kp kq kr b">DataFrame</code>中被呈现为<code class="fe ko kp kq kr b">DICTIONARY</code>的一个<code class="fe ko kp kq kr b">LIST</code>。</p><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi os"><img src="../Images/1e152217bf3236f89b5fea1b78f2dc6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fFU2RsSvSaZStbR9dQGowQ.png"/></div></div><p class="le lf gj gh gi lg lh bd b be z dk translated">将结构下载到数据帧中</p></figure><h1 id="60f8" class="na nb iq bd nc nd nz nf ng nh oa nj nk kf ob kg nm ki oc kj no kl od km nq nr bi translated">用Python将结构上传到BigQuery</h1><p id="3848" class="pw-post-body-paragraph lj lk iq ll b lm oe ka lo lp of kd lr ls og lu lv lw oh ly lz ma oi mc md me ij bi translated">由于<code class="fe ko kp kq kr b">Pyarrow</code>中的序列化限制，BigQuery I/O不支持将<code class="fe ko kp kq kr b">STRUCT</code>结构上传到Pandas <code class="fe ko kp kq kr b">DataFrame</code>中的BQ。据我所知，在<code class="fe ko kp kq kr b">Pyarrow 2.0</code>发布后，这仍然是一个正在进行的问题(见这个<a class="ae li" href="https://github.com/googleapis/python-bigquery/issues/19" rel="noopener ugc nofollow" target="_blank">线程</a>)。但我建议定期检查这个问题，因为这个问题是由谷歌云工程师提出的，看起来他们正在解决这个问题。</p><p id="c83e" class="pw-post-body-paragraph lj lk iq ll b lm ln ka lo lp lq kd lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">解决方法是将表转换成基于行的数据结构，比如<code class="fe ko kp kq kr b">JSON</code>或Python <code class="fe ko kp kq kr b">DICTIONARY</code>。我可以使用<code class="fe ko kp kq kr b">JSON</code>上传带有<code class="fe ko kp kq kr b">STRUCT</code>的表格。如果您想将一个数据类型为<code class="fe ko kp kq kr b">STRUCT</code>的表上传到BigQuery，这里有一个例子，希望对您有所帮助。</p><h2 id="c692" class="on nb iq bd nc ot ou dn ng ov ow dp nk ls ox oy nm lw oz pa no ma pb pc nq iw bi translated">导入包</h2><pre class="kt ku kv kw gt oj kr ok ol aw om bi"><span id="97f8" class="on nb iq kr b gy oo op l oq or">from google.cloud import bigquery<br/>import pandas as pd</span></pre><h2 id="6cf9" class="on nb iq bd nc ot ou dn ng ov ow dp nk ls ox oy nm lw oz pa no ma pb pc nq iw bi translated">数据结构</h2><p id="4dbe" class="pw-post-body-paragraph lj lk iq ll b lm oe ka lo lp of kd lr ls og lu lv lw oh ly lz ma oi mc md me ij bi translated">为了上传一个<code class="fe ko kp kq kr b">STRUCT</code>到BigQuery，该列的数据结构需要是<code class="fe ko kp kq kr b">DICTIONARY</code>的<code class="fe ko kp kq kr b">LIST</code>。想象一下，你正在建造一个<code class="fe ko kp kq kr b">DICTIONARY</code>的<code class="fe ko kp kq kr b">LIST</code>来转换成一个<code class="fe ko kp kq kr b">DataFrame</code>。</p><pre class="kt ku kv kw gt oj kr ok ol aw om bi"><span id="e4a8" class="on nb iq kr b gy oo op l oq or">data = pd.DataFrame([<br/>{‘item’: ‘album’, <br/> ‘user’: [{‘user_id’: [‘50’, ‘25’], ‘gender’: ‘M’, ‘is_active’: True},]<br/>},</span><span id="5409" class="on nb iq kr b gy pd op l oq or"> {‘item’: ‘jacket’,<br/> ‘user’: [{‘user_id’:[‘20’, ‘30’, ‘35’], ‘gender’: ‘F’, ‘is_active’: False}]<br/>},</span><span id="a2f5" class="on nb iq kr b gy pd op l oq or">])</span><span id="1669" class="on nb iq kr b gy pd op l oq or"># convert DataFrame to the list of dict format<br/>data_json = data.to_dict('records')</span></pre><p id="b166" class="pw-post-body-paragraph lj lk iq ll b lm ln ka lo lp lq kd lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">一旦您准备好了<code class="fe ko kp kq kr b">DataFrame</code>，这里有一个<code class="fe ko kp kq kr b">STRUCT</code>的模式示例:</p><pre class="kt ku kv kw gt oj kr ok ol aw om bi"><span id="02d7" class="on nb iq kr b gy oo op l oq or">schema = [<br/>    bigquery.SchemaField(name="item", field_type="STRING", description="an item user purchased"),<br/>    <br/>    bigquery.SchemaField(<br/>        "user",<br/>        "STRUCT",<br/>        fields=[<br/>            bigquery.SchemaField("user_id", "STRING", mode="REPEATED", description="User's internal user_id; users can have e multiple ids"),<br/>            bigquery.SchemaField("gender", "STRING", mode="NULLABLE", description="User's gender"),    <br/>            bigquery.SchemaField("is_active", "BOOLEAN", mode="NULLABLE", description="User's active status.  True if user logged in in the past 7 days, else False"),    <br/>        ],<br/>        mode="REPEATED",),<br/>]</span></pre><p id="4051" class="pw-post-body-paragraph lj lk iq ll b lm ln ka lo lp lq kd lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">在BigQuery控制台上，你会看到a <code class="fe ko kp kq kr b">STRUCT</code>有<strong class="ll ja">类型</strong> ' <code class="fe ko kp kq kr b">RECORD</code>'，而a<code class="fe ko kp kq kr b">ARRAY</code>有<strong class="ll ja">模式</strong> ' <code class="fe ko kp kq kr b">REPEATED</code>'。</p><p id="13dc" class="pw-post-body-paragraph lj lk iq ll b lm ln ka lo lp lq kd lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">如果<code class="fe ko kp kq kr b">STRUCT</code>中有类型为<code class="fe ko kp kq kr b">ARRAY</code>的字段，则将<code class="fe ko kp kq kr b">STRUCT</code>的模式标记为<code class="fe ko kp kq kr b">REPEATED</code>。如果没有，您可以将模式保留为“<code class="fe ko kp kq kr b">NULLABLE</code>”。</p><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi pe"><img src="../Images/8863e60041299a56d9c20876f644bd84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xF3SJl2D-GFOqHglclSDtg.png"/></div></div><p class="le lf gj gh gi lg lh bd b be z dk translated">BQ控制台上的结构模式</p></figure><p id="3bb2" class="pw-post-body-paragraph lj lk iq ll b lm ln ka lo lp lq kd lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">现在我们已经准备好了模式，我们可以通过使用来自<code class="fe ko kp kq kr b">client</code>对象的<code class="fe ko kp kq kr b">load_table_from_json</code>函数来上传表。</p><pre class="kt ku kv kw gt oj kr ok ol aw om bi"><span id="a6cc" class="on nb iq kr b gy oo op l oq or">client = bigquery.Client(project=your_project_name)<br/><br/>job_config = bigquery.LoadJobConfig(<br/>    schema=your_schema,     <br/>    destination_table_description=your_table_description, <br/>    write_disposition='WRITE_TRUNCATE'<br/>)</span><span id="7d89" class="on nb iq kr b gy pd op l oq or">job = client.load_table_from_json(<br/>    data_json, table_id, job_config=job_config<br/>)</span><span id="d8c7" class="on nb iq kr b gy pd op l oq or">job.result()</span></pre><p id="4fa3" class="pw-post-body-paragraph lj lk iq ll b lm ln ka lo lp lq kd lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">这是表上传到BigQuery后的样子。</p><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi gj"><img src="../Images/581a70ce2c1cdb06bbe0bd37457bd061.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xMWnvq9PhVXn9rHdty8Dbg.png"/></div></div><p class="le lf gj gh gi lg lh bd b be z dk translated">具有嵌套数组的结构示例</p></figure><p id="a1a7" class="pw-post-body-paragraph lj lk iq ll b lm ln ka lo lp lq kd lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">希望这个关于使用BigQuery <code class="fe ko kp kq kr b">STRUCT</code>的简单例子对您有所帮助。如果您有任何问题，请随时评论或联系我:)</p><p id="8a20" class="pw-post-body-paragraph lj lk iq ll b lm ln ka lo lp lq kd lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">参考:</p><ol class=""><li id="79de" class="mf mg iq ll b lm ln lp lq ls mh lw mi ma mj me pf ml mm mn bi translated"><a class="ae li" href="https://cloud.google.com/bigquery/docs/nested-repeated" rel="noopener ugc nofollow" target="_blank">在表模式中指定嵌套和重复的列</a></li><li id="20b2" class="mf mg iq ll b lm mo lp mp ls mq lw mr ma ms me pf ml mm mn bi translated"><a class="ae li" href="https://cloud.google.com/bigquery/docs/reference/standard-sql/data-types#struct_type" rel="noopener ugc nofollow" target="_blank">数据类型— </a> <code class="fe ko kp kq kr b"><a class="ae li" href="https://cloud.google.com/bigquery/docs/reference/standard-sql/data-types#struct_type" rel="noopener ugc nofollow" target="_blank">STRUCT</a></code></li></ol></div></div>    
</body>
</html>