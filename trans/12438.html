<html>
<head>
<title>How to Implement a Linked List in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在 Python 中实现链表</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/python-linked-lists-c3622205da81?source=collection_archive---------2-----------------------#2021-12-20">https://towardsdatascience.com/python-linked-lists-c3622205da81?source=collection_archive---------2-----------------------#2021-12-20</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="b963" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">探索如何使用 Python 从头开始编写链表和节点对象</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/15a2bb24202cddc0f7688065bb8cf25f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XV1Kypqw2-S4ztGjFSU43Q.jpeg"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">照片由<a class="ae kz" href="https://unsplash.com/@mael_balland?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Mael BALLAND </a>在<a class="ae kz" href="https://unsplash.com/s/photos/chain?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><h2 id="e58d" class="la lb iu bd lc ld le dn lf lg lh dp li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">介绍</h2><p id="26a7" class="pw-post-body-paragraph lw lx iu ly b lz ma jv mb mc md jy me lj mf mg mh ln mi mj mk lr ml mm mn mo in bi translated">链表是最基本的数据结构之一，<strong class="ly iv">表示一系列节点</strong>。序列的第一个元素称为链表的头<strong class="ly iv">和尾</strong>，最后一个元素对应于尾<strong class="ly iv">和尾</strong>。</p><p id="85e7" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">序列中的每个节点都有一个指向下一个元素的指针，也可以有一个指向上一个元素的指针。在<strong class="ly iv">单链表</strong>中，每个节点只指向下一个节点。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj mu"><img src="../Images/ae3d48bbe57e93b3bfd6745e4bcc992b.png" data-original-src="https://miro.medium.com/v2/resize:fit:742/format:webp/1*Nu0NAvwd507FKkucwbiLQg.png"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">单链表—来源:<a class="ae kz" href="https://gmyrianthous.medium.com/" rel="noopener">作者</a></p></figure><p id="fab2" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">另一方面，在<strong class="ly iv">双向链表</strong>中，每个节点既指向前一个节点，也指向下一个节点。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj mu"><img src="../Images/0d81d91e19345cc26013cf6b5ff76117.png" data-original-src="https://miro.medium.com/v2/resize:fit:742/format:webp/1*tbMMwBUYe8whmuL_7cbEXA.png"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">双向链表——来源:<a class="ae kz" href="https://gmyrianthous.medium.com/" rel="noopener">作者</a></p></figure><p id="1d9b" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">链表在各种场景中都非常有用。在以下情况下，它们通常优于标准阵列</p><ul class=""><li id="96cc" class="mv mw iu ly b lz mp mc mq lj mx ln my lr mz mo na nb nc nd bi translated">在序列中添加或删除元素时，您需要一个恒定的时间</li><li id="674e" class="mv mw iu ly b lz ne mc nf lj ng ln nh lr ni mo na nb nc nd bi translated">更有效地管理内存，尤其是当元素的数量未知时(如果是数组，您可能必须不断地缩小或增大它们。注意，填充数组通常比链表占用更少的内存。</li><li id="550a" class="mv mw iu ly b lz ne mc nf lj ng ln nh lr ni mo na nb nc nd bi translated">您希望更有效地在中间点插入项目</li></ul><p id="f36c" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">与其他通用语言不同，Python 的标准库中没有内置的链表实现。在今天的文章中，我们将探索如何使用 Python 实现一个用户定义的链表类。</p></div><div class="ab cl nj nk hy nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="in io ip iq ir"><h2 id="8b04" class="la lb iu bd lc ld le dn lf lg lh dp li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">在 Python 中实现用户定义的链接类</h2><p id="37d9" class="pw-post-body-paragraph lw lx iu ly b lz ma jv mb mc md jy me lj mf mg mh ln mi mj mk lr ml mm mn mo in bi translated">首先，让我们为链表中的单个节点<strong class="ly iv">创建一个用户定义的类。这个类既适用于单链表，也适用于双向链表。因此，这个类的实例应该能够存储节点的值，下一个和上一个节点的值。</strong></p><pre class="kk kl km kn gu nq nr ns nt aw nu bi"><span id="79f3" class="la lb iu nr b gz nv nw l nx ny">class Node:<br/>    def __init__(self, value, next_node=None, prev_node=None):<br/>        self.value = value<br/>        self.next = next_node<br/>        self.prev = prev_node<br/><br/>    def __str__(self):<br/>        return str(self.value)</span></pre><p id="db90" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">请注意，当一个<code class="fe nz oa ob nr b">Node</code>的实例将<code class="fe nz oa ob nr b">next</code>设置为<code class="fe nz oa ob nr b">None</code>时，这意味着它本质上是链表的尾部(单个或两个)。类似地，在双向链表中，当一个节点的<code class="fe nz oa ob nr b">prev</code>被设置为<code class="fe nz oa ob nr b">None</code>时，这表明该节点是链表的头。</p><p id="3c1e" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">既然我们已经为节点创建了一个类，现在我们可以为链表本身创建类了。如前所述，链表有一个<code class="fe nz oa ob nr b">head</code>、一个<code class="fe nz oa ob nr b">tail</code>和指向彼此的节点。</p><pre class="kk kl km kn gu nq nr ns nt aw nu bi"><span id="8b10" class="la lb iu nr b gz nv nw l nx ny">class LinkedList:<br/>    def __init__(self, values=None):<br/>        self.head = None<br/>        self.tail = None</span><span id="906f" class="la lb iu nr b gz oc nw l nx ny">        if values is not None:<br/>            self.add_multiple_nodes(values)</span></pre><p id="7400" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">现在，为了将构造函数中提供的值作为节点添加到链表中，我们需要定义两个额外的方法。</p><p id="ec31" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">第一个方法叫做<code class="fe nz oa ob nr b"><strong class="ly iv">add_node</strong></code>,用于向链表中添加一个节点。</p><pre class="kk kl km kn gu nq nr ns nt aw nu bi"><span id="572a" class="la lb iu nr b gz nv nw l nx ny">def add_node(self, value):<br/>    if self.head is None:<br/>        self.tail = self.head = Node(value)<br/>    else:<br/>        self.tail.next = Node(value)<br/>        self.tail = self.tail.next<br/>    return self.tail</span></pre><p id="4408" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">现在让我们快速浏览一下这个方法的逻辑。如果链表没有头，那么这意味着它是空的，因此要添加的节点将是链表的头和尾。如果头部不为空，那么我们添加新创建的<code class="fe nz oa ob nr b">Node</code>作为当前<code class="fe nz oa ob nr b">tail</code>的<code class="fe nz oa ob nr b">next</code>元素，最后移动尾部指向新创建的<code class="fe nz oa ob nr b">Node</code>。</p><p id="270f" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">第二个方法叫做<code class="fe nz oa ob nr b"><strong class="ly iv">add_multiple_nodes</strong></code>，它在构造函数中被调用，并且简单地调用我们之前定义的<code class="fe nz oa ob nr b">add_node</code>方法，以便在链表实例中添加多个值作为节点。</p><pre class="kk kl km kn gu nq nr ns nt aw nu bi"><span id="21ac" class="la lb iu nr b gz nv nw l nx ny">def add_multiple_nodes(self, values):<br/>    for value in values:<br/>        self.add_node(value)</span></pre><p id="7c6b" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">到目前为止，我们的链表类如下所示:</p><pre class="kk kl km kn gu nq nr ns nt aw nu bi"><span id="a7e2" class="la lb iu nr b gz nv nw l nx ny">class LinkedList:<br/>    def __init__(self, values=None):<br/>        self.head = None<br/>        self.tail = None</span><span id="16a8" class="la lb iu nr b gz oc nw l nx ny">        if values is not None:<br/>            self.add_multiple_nodes(values)</span><span id="d5b7" class="la lb iu nr b gz oc nw l nx ny">    def add_node(self, value):<br/>        if self.head is None:<br/>            self.tail = self.head = Node(value)<br/>        else:<br/>            self.tail.next = Node(value)<br/>            self.tail = self.tail.next<br/>        return self.tail</span><span id="9d19" class="la lb iu nr b gz oc nw l nx ny">    def add_multiple_nodes(self, values):<br/>        for value in values:<br/>            self.add_node(value)</span></pre><p id="0695" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">现在让我们创建一个额外的方法，它能够插入一个新元素，但是这次是在链表的开始，也就是作为一个头。</p><pre class="kk kl km kn gu nq nr ns nt aw nu bi"><span id="1485" class="la lb iu nr b gz nv nw l nx ny">def add_node_as_head(self, value):<br/>    if self.head is None:<br/>        self.tail = self.head = Node(value)<br/>    else:<br/>        self.head = Node(value, self.head)<br/>    return self.head</span></pre><p id="eaad" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">现在让我们在类中重写一些可能有用的特殊方法。首先，让我们实现<code class="fe nz oa ob nr b">__str__</code>方法，以便链表对象的字符串表示是人类可读的。例如，当打印出一个带有节点<code class="fe nz oa ob nr b">a, b, c, d</code>的链表时，输出将是<code class="fe nz oa ob nr b">a -&gt; b -&gt; c -&gt; d</code>。</p><pre class="kk kl km kn gu nq nr ns nt aw nu bi"><span id="56da" class="la lb iu nr b gz nv nw l nx ny">def __str__(self):<br/>    return ' -&gt; '.join([str(node) for node in self])</span></pre><p id="a2fe" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">其次，让我们也实现<code class="fe nz oa ob nr b">__len__</code>方法，它将返回我们的用户定义类的长度，本质上是序列中包含的节点数。我们需要做的就是遍历序列的每个节点，直到到达链表的尾部。</p><pre class="kk kl km kn gu nq nr ns nt aw nu bi"><span id="cb56" class="la lb iu nr b gz nv nw l nx ny">def __len__(self):<br/>    count = 0<br/>    node = self.head<br/>    while node:<br/>        count += 1<br/>        node = node.next<br/>    return count</span></pre><p id="0c03" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">最后，让我们通过实现<code class="fe nz oa ob nr b">__iter__</code>方法来确保<code class="fe nz oa ob nr b">LinkedList</code>类是可迭代的。</p><pre class="kk kl km kn gu nq nr ns nt aw nu bi"><span id="0e17" class="la lb iu nr b gz nv nw l nx ny">def __iter__(self):<br/>    current = self.head<br/>    while current:<br/>        yield current<br/>        current = current.next</span></pre><p id="5e1a" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">此外，我们还可以创建一个名为<code class="fe nz oa ob nr b">values</code>的属性，这样我们就可以访问序列中所有节点的值。</p><pre class="kk kl km kn gu nq nr ns nt aw nu bi"><span id="bce3" class="la lb iu nr b gz nv nw l nx ny">@property<br/>def values(self):<br/>    return [node.value for node in self]</span></pre><p id="640d" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">最终的类如下所示:</p><pre class="kk kl km kn gu nq nr ns nt aw nu bi"><span id="aca8" class="la lb iu nr b gz nv nw l nx ny">class LinkedList:<br/>    def __init__(self, values=None):<br/>        self.head = None<br/>        self.tail = None</span><span id="74c4" class="la lb iu nr b gz oc nw l nx ny">        if values is not None:<br/>            self.add_multiple_nodes(values)</span><span id="d257" class="la lb iu nr b gz oc nw l nx ny">    def __str__(self):<br/>        return ' -&gt; '.join([str(node) for node in self])</span><span id="0a2d" class="la lb iu nr b gz oc nw l nx ny">    def __len__(self):<br/>        count = 0<br/>        node = self.head<br/>        while node:<br/>            count += 1<br/>            node = node.next<br/>        return count</span><span id="5eff" class="la lb iu nr b gz oc nw l nx ny">    def __iter__(self):<br/>        current = self.head<br/>        while current:<br/>            yield current<br/>            current = current.next</span><span id="a0f0" class="la lb iu nr b gz oc nw l nx ny">    @property<br/>    def values(self):<br/>        return [node.value for node in self]</span><span id="e6ad" class="la lb iu nr b gz oc nw l nx ny">    def add_node(self, value):<br/>        if self.head is None:<br/>            self.tail = self.head = Node(value)<br/>        else:<br/>            self.tail.next = Node(value)<br/>            self.tail = self.tail.next<br/>        return self.tail</span><span id="1521" class="la lb iu nr b gz oc nw l nx ny">    def add_multiple_nodes(self, values):<br/>        for value in values:<br/>            self.add_node(value)</span><span id="8b1e" class="la lb iu nr b gz oc nw l nx ny">    def add_node_as_head(self, value):<br/>        if self.head is None:<br/>            self.tail = self.head = Node(value)<br/>        else:<br/>            self.head = Node(value, self.head)<br/>        return self.head</span></pre><p id="0f9a" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">现在，即使我们的<code class="fe nz oa ob nr b">Node</code>类可以表示包含在单向或双向链表中的节点，我们定义的<code class="fe nz oa ob nr b">LinkedList</code>类只能支持单向链表。这是因为在添加节点时，我们没有指定前一个节点。</p><p id="a0f6" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">为了处理双向链表，我们可以简单地创建一个额外的类，它继承自<code class="fe nz oa ob nr b">LinkedList</code>类并覆盖<code class="fe nz oa ob nr b">add_node</code>和<code class="fe nz oa ob nr b">add_node_as_head</code>方法:</p><pre class="kk kl km kn gu nq nr ns nt aw nu bi"><span id="bcef" class="la lb iu nr b gz nv nw l nx ny">class DoublyLinkedList(LinkedList):<br/>    def add_node(self, value):<br/>        if self.head is None:<br/>            self.tail = self.head = Node(value)<br/>        else:<br/>            self.tail.next = Node(value, None, self.tail)<br/>            self.tail = self.tail.next<br/>        return self</span><span id="4c9c" class="la lb iu nr b gz oc nw l nx ny">    def add_node_as_head(self, value):<br/>        if self.head is None:<br/>            self.tail = self.head = Node(value)<br/>        else:<br/>            current_head = self.head<br/>            self.head = Node(value, current_head)<br/>            current_head.prev = self.head<br/>        return self.head</span></pre></div><div class="ab cl nj nk hy nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="in io ip iq ir"><h2 id="5311" class="la lb iu bd lc ld le dn lf lg lh dp li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">Python 中用户自定义链表的完整代码</h2><p id="8c7d" class="pw-post-body-paragraph lw lx iu ly b lz ma jv mb mc md jy me lj mf mg mh ln mi mj mk lr ml mm mn mo in bi translated">包含我们在今天的教程中创建的三个类的完整代码作为 GitHub 要点在下面给出。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="od oe l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">包含 Node、LinkedList 和 DoublyLinkedList Python 类的完整代码——来源:<a class="ae kz" href="https://gmyrianthous.medium.com/" rel="noopener">作者</a></p></figure></div><div class="ab cl nj nk hy nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="in io ip iq ir"><h2 id="78f3" class="la lb iu bd lc ld le dn lf lg lh dp li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">最后的想法</h2><p id="f311" class="pw-post-body-paragraph lw lx iu ly b lz ma jv mb mc md jy me lj mf mg mh ln mi mj mk lr ml mm mn mo in bi translated">在今天的指南中，我们讨论了最基本的数据结构之一，即链表。鉴于 Python 的标准库不包含这种特定数据结构的任何实现，我们探索了如何从头实现用户定义的链表类。</p></div><div class="ab cl nj nk hy nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="in io ip iq ir"><p id="1b77" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated"><a class="ae kz" href="https://gmyrianthous.medium.com/membership" rel="noopener"> <strong class="ly iv">成为会员</strong> </a> <strong class="ly iv">阅读介质上的每一个故事。你的会员费直接支持我和你看的其他作家。你也可以在媒体上看到所有的故事。</strong></p><div class="of og gq gs oh oi"><a href="https://gmyrianthous.medium.com/membership" rel="noopener follow" target="_blank"><div class="oj ab fp"><div class="ok ab ol cl cj om"><h2 class="bd iv gz z fq on fs ft oo fv fx it bi translated">通过我的推荐链接加入 Medium-Giorgos Myrianthous</h2><div class="op l"><h3 class="bd b gz z fq on fs ft oo fv fx dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="oq l"><p class="bd b dl z fq on fs ft oo fv fx dk translated">gmyrianthous.medium.com</p></div></div><div class="or l"><div class="os l ot ou ov or ow kt oi"/></div></div></a></div></div><div class="ab cl nj nk hy nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="in io ip iq ir"><p id="676e" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated"><strong class="ly iv">你可能也会喜欢</strong></p><div class="of og gq gs oh oi"><a rel="noopener follow" target="_blank" href="/leetcode-problem-2-python-1c59efdf3367"><div class="oj ab fp"><div class="ok ab ol cl cj om"><h2 class="bd iv gz z fq on fs ft oo fv fx it bi translated">LeetCode 问题 2:用 Python 添加两个数的解决方案</h2><div class="op l"><h3 class="bd b gz z fq on fs ft oo fv fx dk translated">理解如何用 Python 中的链表高效地解决两个数相加问题</h3></div><div class="oq l"><p class="bd b dl z fq on fs ft oo fv fx dk translated">towardsdatascience.com</p></div></div><div class="or l"><div class="ox l ot ou ov or ow kt oi"/></div></div></a></div></div><div class="ab cl nj nk hy nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="in io ip iq ir"><div class="kk kl km kn gu oi"><a rel="noopener follow" target="_blank" href="/augmented-assignments-python-caa4990811a0"><div class="oj ab fp"><div class="ok ab ol cl cj om"><h2 class="bd iv gz z fq on fs ft oo fv fx it bi translated">Python 中的扩充赋值</h2><div class="op l"><h3 class="bd b gz z fq on fs ft oo fv fx dk translated">了解增强赋值表达式在 Python 中的工作方式，以及为什么在使用它们时要小心…</h3></div><div class="oq l"><p class="bd b dl z fq on fs ft oo fv fx dk translated">towardsdatascience.com</p></div></div><div class="or l"><div class="oy l ot ou ov or ow kt oi"/></div></div></a></div></div></div>    
</body>
</html>