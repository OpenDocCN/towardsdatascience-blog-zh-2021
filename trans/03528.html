<html>
<head>
<title>XGBoost for Time Series extrapolation: You’re Gonna Need a Bigger Boat</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">时间序列推断的XGBoost:你需要一艘更大的船</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/xgboost-for-time-series-youre-gonna-need-a-bigger-boat-9d329efa6814?source=collection_archive---------8-----------------------#2021-03-22">https://towardsdatascience.com/xgboost-for-time-series-youre-gonna-need-a-bigger-boat-9d329efa6814?source=collection_archive---------8-----------------------#2021-03-22</a></blockquote><div><div class="fc ij ik il im in"/><div class="io ip iq ir is"><div class=""/><figure class="gl gn jt ju jv jw gh gi paragraph-image"><div role="button" tabindex="0" class="jx jy di jz bf ka"><div class="gh gi js"><img src="../Images/165c1d5707c7f346f840f054e921bdd9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*tK0JwuS-nKAQcVls"/></div></div><p class="kd ke gj gh gi kf kg bd b be z dk translated">罗伯特·H在<a class="ae kh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure></div><div class="ab cl ki kj hz kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="io ip iq ir is"><blockquote class="kp kq kr"><p id="dca3" class="ks kt ku kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq io bi translated"><strong class="kv iw">更新</strong>:发现我关于渐变提升的新书<a class="ae kh" href="https://amzn.to/3GCBtNF" rel="noopener ugc nofollow" target="_blank">实用渐变提升</a>。这是用python中的许多例子对渐变增强的深入探究。</p></blockquote><div class="lr ls gp gr lt lu"><a href="https://amzn.to/3GCBtNF" rel="noopener  ugc nofollow" target="_blank"><div class="lv ab fo"><div class="lw ab lx cl cj ly"><h2 class="bd iw gy z fp lz fr fs ma fu fw iu bi translated">实用的渐变增强:深入探究Python中的渐变增强</h2><div class="mb l"><h3 class="bd b gy z fp lz fr fs ma fu fw dk translated">这本书的梯度推进方法是为学生，学者，工程师和数据科学家谁希望…</h3></div></div><div class="mc l"><div class="md l me mf mg mc mh kb lu"/></div></div></a></div><p id="0a23" class="pw-post-body-paragraph ks kt iv kv b kw kx ky kz la lb lc ld mi lf lg lh mj lj lk ll mk ln lo lp lq io bi translated"><strong class="kv iw">更新</strong>:发现我在这个问题上的后续，用线性树很好地解决了这个问题:</p><div class="lr ls gp gr lt lu"><a rel="noopener follow" target="_blank" href="/xgboost-for-timeseries-lightgbm-is-a-bigger-boat-197864013e88"><div class="lv ab fo"><div class="lw ab lx cl cj ly"><h2 class="bd iw gy z fp lz fr fs ma fu fw iu bi translated">XGBoost for time series: lightGBM是更大的船！</h2><div class="mb l"><h3 class="bd b gy z fp lz fr fs ma fu fw dk translated">XGBoost无法进行外推。这是时间序列建模的一个硬限制。LightGBM提供了…</h3></div><div class="ml l"><p class="bd b dl z fp lz fr fs ma fu fw dk translated">towardsdatascience.com</p></div></div><div class="mc l"><div class="mm l me mf mg mc mh kb lu"/></div></div></a></div></div><div class="ab cl ki kj hz kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="io ip iq ir is"><p id="121e" class="pw-post-body-paragraph ks kt iv kv b kw kx ky kz la lb lc ld mi lf lg lh mj lj lk ll mk ln lo lp lq io bi translated">XGBoost是一个非常强大和通用的模型。它的应用范围很广，已经成功地应用于许多最大似然分类和回归问题。这里用代码<a class="ae kh" rel="noopener" target="_blank" href="/diy-xgboost-library-in-less-than-200-lines-of-python-69b6bf25e7d9">解释了基本的数学原理</a>。</p><p id="5853" class="pw-post-body-paragraph ks kt iv kv b kw kx ky kz la lb lc ld mi lf lg lh mj lj lk ll mk ln lo lp lq io bi translated">尽管它最初不是为处理时间序列而设计的，但许多数据科学家仍然在这种情况下使用它。他们这样做对吗？让我们看看数学告诉了我们这个用例什么。</p></div><div class="ab cl ki kj hz kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="io ip iq ir is"><h1 id="ae25" class="mn mo iv bd mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni nj nk bi translated">时间序列的XGBoost</h1><p id="23a4" class="pw-post-body-paragraph ks kt iv kv b kw nl ky kz la nm lc ld mi nn lg lh mj no lk ll mk np lo lp lq io bi translated">例如，XGBoost甚至被用于预测时间序列<a class="ae kh" href="https://machinelearningmastery.com/xgboost-for-time-series-forecasting/" rel="noopener ugc nofollow" target="_blank">这里的</a>和<a class="ae kh" rel="noopener" target="_blank" href="/using-gradient-boosting-for-time-series-prediction-tasks-600fac66a5fc">这里的</a>。秘诀是输入与时间相关的特征:滞后、频率、小波系数、周期…</p><p id="8fae" class="pw-post-body-paragraph ks kt iv kv b kw kx ky kz la lb lc ld mi lf lg lh mj lj lk ll mk ln lo lp lq io bi translated">由于XGBoost非常擅长识别数据中的模式，如果您有足够的时态特征来描述您的数据集，它将提供非常不错的预测。</p><p id="2b8d" class="pw-post-body-paragraph ks kt iv kv b kw kx ky kz la lb lc ld mi lf lg lh mj lj lk ll mk ln lo lp lq io bi translated">但是，XGBoost缺少一个对时间序列绝对关键的基本特性。让我们分析一下这个模型背后的数学原理，以理解XGBoost要成为一个好的时间序列预测模型还缺少什么。</p><h1 id="2656" class="mn mo iv bd mp mq nq ms mt mu nr mw mx my ns na nb nc nt ne nf ng nu ni nj nk bi translated">XGBoost的数学基础</h1><p id="73d7" class="pw-post-body-paragraph ks kt iv kv b kw nl ky kz la nm lc ld mi nn lg lh mj no lk ll mk np lo lp lq io bi translated">在XGBoost文档中，有一篇非常说教的<a class="ae kh" href="https://xgboost.readthedocs.io/en/latest/tutorials/model.html" rel="noopener ugc nofollow" target="_blank">文章</a>详细解释了XGBoost模型是如何从数学公式中推导出来的。我强烈建议通读这篇论文，因为这对于真正理解超参数(如γ、α等)的作用至关重要</p><p id="e0aa" class="pw-post-body-paragraph ks kt iv kv b kw kx ky kz la lb lc ld mi lf lg lh mj lj lk ll mk ln lo lp lq io bi translated">我还写了一篇解释性的<a class="ae kh" rel="noopener" target="_blank" href="/diy-xgboost-library-in-less-than-200-lines-of-python-69b6bf25e7d9">文章</a>，用200行代码重建了一个基本的XGBoost库。</p><p id="0cf4" class="pw-post-body-paragraph ks kt iv kv b kw kx ky kz la lb lc ld mi lf lg lh mj lj lk ll mk ln lo lp lq io bi translated">众所周知，XGBoost是一个基于树的模型。它可以堆叠任意多的树，每一棵额外的树都试图减少之前的树的误差。总体思路是将许多简单、弱的预测器结合起来，建立一个强预测器。</p><p id="b47d" class="pw-post-body-paragraph ks kt iv kv b kw kx ky kz la lb lc ld mi lf lg lh mj lj lk ll mk ln lo lp lq io bi translated">但是让我们关注XGBoost文档中最重要的公式:预测是如何计算的。这是一个非常简单的公式:</p><figure class="nw nx ny nz gt jw gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/742b116958bab6c83fec551ad093a443.png" data-original-src="https://miro.medium.com/v2/resize:fit:856/format:webp/1*9poDXkzBQQ8znK9S0dDI7g.png"/></div><p class="kd ke gj gh gi kf kg bd b be z dk translated">摘录自XGBoost <a class="ae kh" href="https://xgboost.readthedocs.io/en/latest/tutorials/model.html" rel="noopener ugc nofollow" target="_blank">文档</a>。</p></figure><p id="838b" class="pw-post-body-paragraph ks kt iv kv b kw kx ky kz la lb lc ld mi lf lg lh mj lj lk ll mk ln lo lp lq io bi translated">其中估计<strong class="kv iw"> <em class="ku"> y_i </em> </strong> <em class="ku"> </em>是预测，<strong class="kv iw"> <em class="ku"> x_i </em> </strong>是特征向量，<strong class="kv iw"> <em class="ku"> f_k(x_i) </em> </strong>是为每棵树计算的值，<strong class="kv iw"> <em class="ku"> K </em> </strong>是树的总数。</p><p id="d05e" class="pw-post-body-paragraph ks kt iv kv b kw kx ky kz la lb lc ld mi lf lg lh mj lj lk ll mk ln lo lp lq io bi translated">正如您所看到的，XGBoost模型本质上是一个关于每棵树的附加模型。让我们看一下<strong class="kv iw"> <em class="ku"> f_k </em> </strong>来了解树的分数是如何计算的，看看我们这里说的是什么样的函数。</p><p id="2111" class="pw-post-body-paragraph ks kt iv kv b kw kx ky kz la lb lc ld mi lf lg lh mj lj lk ll mk ln lo lp lq io bi translated">XGBoost文档再一次给了我们答案，这也很容易理解:</p><figure class="nw nx ny nz gt jw gh gi paragraph-image"><div role="button" tabindex="0" class="jx jy di jz bf ka"><div class="gh gi oa"><img src="../Images/df186dbb3902c1b201627a5b35f14834.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Nk4auf2jOwJInPhxG9eI0Q.png"/></div></div><p class="kd ke gj gh gi kf kg bd b be z dk translated">摘自XGBoost <a class="ae kh" href="https://xgboost.readthedocs.io/en/latest/tutorials/model.html" rel="noopener ugc nofollow" target="_blank">文档</a>。</p></figure><p id="5947" class="pw-post-body-paragraph ks kt iv kv b kw kx ky kz la lb lc ld mi lf lg lh mj lj lk ll mk ln lo lp lq io bi translated"><strong class="kv iw"> <em class="ku"> q(x) </em> </strong>是将特征<strong class="kv iw"> <em class="ku"> x </em> </strong>归属于当前树<strong class="kv iw"> <em class="ku"> t </em> </strong>的特定叶子的函数。<strong class="kv iw"> <em class="ku"> w_q(x) </em> </strong>则是当前树的叶分数<strong class="kv iw"><em class="ku"/></strong>和当前特征<strong class="kv iw"> <em class="ku"> x </em> </strong>。</p><p id="f58f" class="pw-post-body-paragraph ks kt iv kv b kw kx ky kz la lb lc ld mi lf lg lh mj lj lk ll mk ln lo lp lq io bi translated">总的来说，一旦你训练了你的模型，这是问题中最难的部分，预测简单地归结为根据特征为每棵树确定正确的叶子，并总结每个叶子的值。</p><p id="2ab0" class="pw-post-body-paragraph ks kt iv kv b kw kx ky kz la lb lc ld mi lf lg lh mj lj lk ll mk ln lo lp lq io bi translated">现在让我们看看这种模型的具体结果是什么，以及对时间序列预测有什么影响。</p><h1 id="d62d" class="mn mo iv bd mp mq nq ms mt mu nr mw mx my ns na nb nc nt ne nf ng nu ni nj nk bi translated">XGBoost无法外推！！！</h1><p id="ae81" class="pw-post-body-paragraph ks kt iv kv b kw nl ky kz la nm lc ld mi nn lg lh mj no lk ll mk np lo lp lq io bi translated">同样，XGBoost是一个非常强大和高效的分类和回归工具，但是它缺少一个非常关键的特性:它不能外推！或者至少，它不能推断出比简单常数更复杂的东西。线性、二次或三次插值是不可能的。</p><p id="440b" class="pw-post-body-paragraph ks kt iv kv b kw kx ky kz la lb lc ld mi lf lg lh mj lj lk ll mk ln lo lp lq io bi translated">正如我们在前面的公式中所看到的，XGBoost预测只是基于树叶值的总和。这些值没有应用任何变换:没有缩放、没有对数、没有指数，什么都没有。</p><p id="73bf" class="pw-post-body-paragraph ks kt iv kv b kw kx ky kz la lb lc ld mi lf lg lh mj lj lk ll mk ln lo lp lq io bi translated">这意味着XGBoost只能对以前在训练历史中遇到的情况做出很好的预测。它不会捕捉趋势！</p><p id="d1b5" class="pw-post-body-paragraph ks kt iv kv b kw kx ky kz la lb lc ld mi lf lg lh mj lj lk ll mk ln lo lp lq io bi translated">下面的几行代码非常有说服力，应该足以说明这种局限性，并让您相信XGBoost无法进行外推:</p><figure class="nw nx ny nz gt jw"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="9a41" class="pw-post-body-paragraph ks kt iv kv b kw kx ky kz la lb lc ld mi lf lg lh mj lj lk ll mk ln lo lp lq io bi translated">这几行代码使用XGBoost模型来预测一个非常基本的纯线性系统的值，该系统的输出与时间成正比。如下图所示，XGBoost在插值时非常出色，正如您可以看到的对0到10之间的<strong class="kv iw"> <em class="ku"> t </em> </strong>的预测。</p><figure class="nw nx ny nz gt jw gh gi paragraph-image"><div class="gh gi od"><img src="../Images/26809b1361edc52fcb9fcc479f955389.png" data-original-src="https://miro.medium.com/v2/resize:fit:750/format:webp/1*0_R06v-QD9Nc0DDTh7SAPQ.png"/></div><p class="kd ke gj gh gi kf kg bd b be z dk translated">作者创造的情节。</p></figure><p id="bdf3" class="pw-post-body-paragraph ks kt iv kv b kw kx ky kz la lb lc ld mi lf lg lh mj lj lk ll mk ln lo lp lq io bi translated">但是当我们分析了潜在的数学模型后，在试图推断时，它完全失败了。事实上，如上所述，XGBoost模型不能预测没有出现在它的训练中的事件。</p><h1 id="bc2a" class="mn mo iv bd mp mq nq ms mt mu nr mw mx my ns na nb nc nt ne nf ng nu ni nj nk bi translated">你为什么要为插值而烦恼呢？</h1><p id="1188" class="pw-post-body-paragraph ks kt iv kv b kw nl ky kz la nm lc ld mi nn lg lh mj no lk ll mk np lo lp lq io bi translated">不幸的是，时间序列，或者至少是那些值得关注的时间序列，通常是非平稳的。这意味着它们的统计特征——平均值、方差和标准差——会随着时间而变化。</p><p id="69a9" class="pw-post-body-paragraph ks kt iv kv b kw kx ky kz la lb lc ld mi lf lg lh mj lj lk ll mk ln lo lp lq io bi translated">准确预测这种时间序列需要模型不仅能捕捉时间的变化，还能进行外推。</p><p id="ddf2" class="pw-post-body-paragraph ks kt iv kv b kw kx ky kz la lb lc ld mi lf lg lh mj lj lk ll mk ln lo lp lq io bi translated">我们可以研究两个例子来说明这一点。在第一个例子中，我们想估计在一个天空从不多云的特定地点每平方米接收到的太阳能数量，而不管是哪一天。有了几年的数据，XGboost将能够做出非常合理的估计，因为接收到的能量数量本质上是一个几何问题，而且地球围绕太阳的运动几乎是完全周期性的。我们面对的是一个静止的系统。</p><p id="118c" class="pw-post-body-paragraph ks kt iv kv b kw kx ky kz la lb lc ld mi lf lg lh mj lj lk ll mk ln lo lp lq io bi translated">另一方面，假设我们不再想预测太阳辐照度，而是想预测温度。像我们现在这样(都？)意识到，由于人类活动，地球正在经历全球变暖，一个多世纪以来，地球的平均温度一直在上升。见下图:</p><figure class="nw nx ny nz gt jw gh gi paragraph-image"><div role="button" tabindex="0" class="jx jy di jz bf ka"><div class="gh gi oe"><img src="../Images/b1d46055201b99a93107d1dd78a2e00f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2H8TkniTIt10in9OWiEhhg.png"/></div></div><p class="kd ke gj gh gi kf kg bd b be z dk translated">全球平均气温正在上升。摘自<a class="ae kh" href="http://berkeleyearth.org/wp-content/uploads/2020/01/2019_Time_Series.png" rel="noopener ugc nofollow" target="_blank">伯克利地球</a></p></figure><p id="12b0" class="pw-post-body-paragraph ks kt iv kv b kw kx ky kz la lb lc ld mi lf lg lh mj lj lk ll mk ln lo lp lq io bi translated">即使对于一个给定的位置，我们观察到季节性的影响，平均温度在时间上是不稳定的。构建一个XGBoost模型，拥有尽可能多的气象或气候特征，永远不会对未来产生好的估计。</p><h1 id="41c7" class="mn mo iv bd mp mq nq ms mt mu nr mw mx my ns na nb nc nt ne nf ng nu ni nj nk bi translated">我们能黑掉XGBoost来克服这个吗？</h1><p id="d601" class="pw-post-body-paragraph ks kt iv kv b kw nl ky kz la nm lc ld mi nn lg lh mj no lk ll mk np lo lp lq io bi translated">对于某些模型，有时可以破解底层数学来扩展它们的应用范围。这篇<a class="ae kh" rel="noopener" target="_blank" href="/confidence-intervals-for-xgboost-cac2955a8fde">文章</a>举例说明了如何使用自定义目标来计算置信区间。</p><p id="f462" class="pw-post-body-paragraph ks kt iv kv b kw kx ky kz la lb lc ld mi lf lg lh mj lj lk ll mk ln lo lp lq io bi translated">例如，您可以使用简单的线性回归模型对非线性系统进行建模和预测，只需向它们提供非线性特征。因此，通过向线性模型提供风速的7次方，可以实现风力涡轮机发电的良好性能。</p><p id="58ca" class="pw-post-body-paragraph ks kt iv kv b kw kx ky kz la lb lc ld mi lf lg lh mj lj lk ll mk ln lo lp lq io bi translated">不幸的是，不可能调整XGBoost模型中用于预测的公式来引入外推支持。</p><p id="f94f" class="pw-post-body-paragraph ks kt iv kv b kw kx ky kz la lb lc ld mi lf lg lh mj lj lk ll mk ln lo lp lq io bi translated">将XGBoost强大的模式识别与外推法结合起来的一个选择是用一个负责这个的边模型来扩充XGBoost。</p><p id="27c4" class="pw-post-body-paragraph ks kt iv kv b kw kx ky kz la lb lc ld mi lf lg lh mj lj lk ll mk ln lo lp lq io bi translated">另一种方法是对数据进行归一化处理，以消除不稳定的影响，回到稳定的情况。</p></div><div class="ab cl ki kj hz kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="io ip iq ir is"><h1 id="ed1e" class="mn mo iv bd mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni nj nk bi translated">结论</h1><p id="63f2" class="pw-post-body-paragraph ks kt iv kv b kw nl ky kz la nm lc ld mi nn lg lh mj no lk ll mk np lo lp lq io bi translated">XGBoost和任何其他基于树的模型都不能在数学上执行任何大于0阶的外推。也就是说，它们只能外推一个常量值。当试图将这种模型应用于非平稳时间序列时，这是一个需要考虑的巨大限制。</p><p id="5500" class="pw-post-body-paragraph ks kt iv kv b kw kx ky kz la lb lc ld mi lf lg lh mj lj lk ll mk ln lo lp lq io bi translated">然而，XGBoost仍然是一个非常有吸引力的工具，可以在具有许多特性的复杂数据中显示结构。用它来预测时间序列可能是一个不错的选择，只要你的目标是固定的。如果不是这样，那么您需要预处理您的数据以确保它是正确的，或者考虑将XGBoost与另一个负责处理趋势的模型结合起来。</p></div></div>    
</body>
</html>