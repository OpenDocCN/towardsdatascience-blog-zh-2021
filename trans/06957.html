<html>
<head>
<title>Let’s build a simple distributed computing system, for modern cloud</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让我们为现代云构建一个简单的分布式计算系统</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/lets-build-a-simple-distributed-computing-system-for-modern-cloud-part-one-e2b745126211?source=collection_archive---------6-----------------------#2021-06-24">https://towardsdatascience.com/lets-build-a-simple-distributed-computing-system-for-modern-cloud-part-one-e2b745126211?source=collection_archive---------6-----------------------#2021-06-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9580" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">从头开始设计、开发和测试全新的分布式计算框架，同时注重简单、现代和可扩展</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/4c70423eef15a94be21529d43e78c8d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KkTJ1oI2BbPYg08OCatDuw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">“创造新事物的快乐”——https://unsplash.com/photos/nGwyaWKFRVI?utm_source=unsplash UTM _ medium = referral&amp;UTM _ content = creditShareLink</p></figure><p id="d9ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在写软件的方式已经大不一样了。成为云原生的是几乎所有软件系统架构的关键目标之一。</p><p id="844d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将探索如何构建一个<strong class="lb iu">简单</strong>和<strong class="lb iu">可扩展</strong>的分布式计算框架，为<strong class="lb iu">现代云</strong>量身定制。我们将从头开始设计、构建和测试一个全新的框架，同时讨论关键的设计决策。</p><p id="cbed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本文为理解分布式系统如何工作，以及实现针对现代云基础设施的可扩展系统提供了很好的指导。</p><h2 id="5fc2" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">好了，这是我们的分布式计算系统。</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mo"><img src="../Images/ca95ce8d7fda58901be3879284597e70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E0xlPpS4MQPkCv5nyOl6ZQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">高层建筑</p></figure><p id="aeae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">概括地说，这个系统有三个主要组件。</p><ol class=""><li id="dd0b" class="mp mq it lb b lc ld lf lg li mr lm ms lq mt lu mu mv mw mx bi translated"><strong class="lb iu">客户端</strong> — <em class="my">提交作业的实际用户或用户代理</em></li><li id="f955" class="mp mq it lb b lc mz lf na li nb lm nc lq nd lu mu mv mw mx bi translated"><strong class="lb iu"> Master </strong> — <em class="my">接受客户的作业，协调系统并执行作业，最后将预期结果返回给客户</em></li><li id="0cea" class="mp mq it lb b lc mz lf na li nb lm nc lq nd lu mu mv mw mx bi translated"><strong class="lb iu">工人</strong> — <em class="my">接受一项工作，执行它，并提供预期的结果。</em></li></ol><p id="2340" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">总的来说，客户机向主任务提交任务，主任务调度并让可用的工人执行这些任务，最后将任务结果返回给客户机。</p><h2 id="64bd" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">深入系统设计之前的三个关键因素</h2><p id="6c1f" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">我们正在以社区优先的方式为现代云开发这个系统。因此，在整个设计过程中，我们将始终遵循以下三点。</p><ol class=""><li id="f93e" class="mp mq it lb b lc ld lf lg li mr lm ms lq mt lu mu mv mw mx bi translated">简单的——简单的系统易于实施和诊断</li><li id="4b8f" class="mp mq it lb b lc mz lf na li nb lm nc lq nd lu mu mv mw mx bi translated">现代——运行在最新基础设施上的系统利用最新的技术，通常更快、更高效，而且显然是最新的。</li><li id="282d" class="mp mq it lb b lc mz lf na li nb lm nc lq nd lu mu mv mw mx bi translated"><strong class="lb iu">可扩展的</strong> —可扩展的系统对于社区来说至关重要，因为不同用例的需求是不同的，因此允许开发人员避免实现通用组件，重用和实现最少实现的用例。</li></ol><h2 id="ddd5" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">系统结构</h2><p id="e3c4" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">这是分布式计算框架的系统架构。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nj"><img src="../Images/47d5417e13564a9a7121a853b5f0e476.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7LPBOLJWXZwUknAOKT493g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">我们的分布式计算框架的系统架构</p></figure><p id="20b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的图像是不言自明的。为了解释它的一些关键元素，</p><ul class=""><li id="3093" class="mp mq it lb b lc ld lf lg li mr lm ms lq mt lu nk mv mw mx bi translated"><strong class="lb iu">职工微服务</strong></li></ul><p id="0ed8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个工人有一个自我隔离的工作空间，这允许他被封闭起来并独立行动。此外，系统期望所有工人在资源能力方面都是相同的。即固定的CPU功率、RAM、存储等。换句话说，工人没有规模。</p><p id="f51f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这使得工人变得简单，从而更容易管理。根据默认实现，Workers实际上是gRPC服务器。但是它也是<strong class="lb iu">可扩展的</strong>，因此可以用任何框架实现，甚至从头开始。</p><p id="a58f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">默认的<strong class="lb iu"> gRPC </strong>实现确保主-工人通信通过RPC(远程过程调用)进行。与另一种流行的方法RESTful APIs相比，这消除了所有的复杂性。此外，gRPC还是可伸缩的、代码友好的、快速的(比RESTful APIs快7倍)。</p><ul class=""><li id="0ce9" class="mp mq it lb b lc ld lf lg li mr lm ms lq mt lu nk mv mw mx bi translated"><strong class="lb iu">主微服务</strong></li></ul><p id="c94b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">主人与客户交谈，与工人谈判。它充当工作人员的gRPC客户机，以及为客户机提供RESTful APIs的服务器。RESTful APIs构建在<strong class="lb iu"> Spring Boot框架</strong> + <strong class="lb iu">开放API 3代码生成器</strong>之上，采用<strong class="lb iu"> API优先开发</strong>的方式。</p><p id="f2ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">RESTful APIs对人类更加友好，因此更适合主客户端通信。此外，这些API调用不需要非常快，因为它们并不频繁。</p><p id="55a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">预计Master还将在自己的自隔离环境中运行，因此非常适合集装箱运输。</p><p id="5af7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">主服务器由几个松散耦合的组件组成。这些组件中的每一个都有自己的职责，并且就它们所做的工作而言是独立的。这使得主控本身更容易理解。此外，每个组件都是可扩展的，这使得主组件的行为可以在更细粒度的级别上进行修改和扩展。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nl"><img src="../Images/f531cb217e400e40ed7ba4a041bdb88f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9jxUSbmAoXQ4Jwnbqe9IWA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">系统的内部组件和数据流方案。这个框架被命名为猎户座。</p></figure><ol class=""><li id="2f82" class="mp mq it lb b lc ld lf lg li mr lm ms lq mt lu mu mv mw mx bi translated">任务管理器 —协调组件之间的数据流。它包括一个定期运行的任务，该任务检查和复制来自工人服务的已完成的作业，并随后分派计划的作业。</li><li id="7f61" class="mp mq it lb b lc mz lf na li nb lm nc lq nd lu mu mv mw mx bi translated">任务调度器(Task Scheduler)—将任务保留在优先级队列中，直到它们被分派给工作人员。</li><li id="3dd6" class="mp mq it lb b lc mz lf na li nb lm nc lq nd lu mu mv mw mx bi translated"><strong class="lb iu">任务优先级</strong> —根据工作的不同属性，如截止日期等，分配优先级值。默认实现实现了“最早截止日期优先”的方法。</li><li id="0754" class="mp mq it lb b lc mz lf na li nb lm nc lq nd lu mu mv mw mx bi translated"><strong class="lb iu">任务分配器</strong> —与工人池通信，并将任务分派给自由工人。如果没有空闲的工作线程，那么它会将任务重新调度。</li><li id="7c18" class="mp mq it lb b lc mz lf na li nb lm nc lq nd lu mu mv mw mx bi translated"><strong class="lb iu">工人池管理</strong>r——管理与工人服务的通信。</li><li id="fd33" class="mp mq it lb b lc mz lf na li nb lm nc lq nd lu mu mv mw mx bi translated"><strong class="lb iu">中央存储</strong> —存储作业数据，直到它们完成，并被客户端获取。默认实现使用基于本地存储的存储，其中任务存储在给定隔离工作区中创建的文件夹中。</li></ol><p id="f221" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如前所述，任何人都可以插入他们自己的上述任何组件的实现，从而通过设计使系统<strong class="lb iu">可扩展</strong>。</p><h2 id="8d4f" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">履行</h2><p id="0ead" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">在我们开始之前，我们到目前为止讨论的系统的完整实现可以在下面的链接中找到。它是在Apache 2.0许可下发布的开源项目。</p><div class="nm nn gp gr no np"><a href="https://github.com/crunchycookie/orion" rel="noopener  ugc nofollow" target="_blank"><div class="nq ab fo"><div class="nr ab ns cl cj nt"><h2 class="bd iu gy z fp nu fr fs nv fu fw is bi translated">crunchy cookie/猎户座</h2><div class="nw l"><h3 class="bd b gy z fp nu fr fs nv fu fw dk translated">Permalink无法加载最新的提交信息。为测试平台部署编写单一脚本，并提供全面的…</h3></div><div class="nx l"><p class="bd b dl z fp nu fr fs nv fu fw dk translated">github.com</p></div></div><div class="ny l"><div class="nz l oa ob oc ny od ks np"/></div></div></a></div><p id="12ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们刚刚设计的系统，被命名为<strong class="lb iu">猎户座</strong>。这个项目有四个主要部分。</p><ul class=""><li id="8b6c" class="mp mq it lb b lc ld lf lg li mr lm ms lq mt lu nk mv mw mx bi translated"><strong class="lb iu"> Master </strong> —包含基于<strong class="lb iu"> </strong>实现Master微服务的<strong class="lb iu">Spring boot</strong>+<strong class="lb iu">Open API 3</strong>+<strong class="lb iu">gRPC客户端代码</strong>。这是一个纯粹的<strong class="lb iu"> JAVA </strong>模块。</li><li id="a0a2" class="mp mq it lb b lc mz lf na li nb lm nc lq nd lu nk mv mw mx bi translated"><strong class="lb iu"> Worker </strong> —包含基于<strong class="lb iu"> gRPC服务器</strong>的Worker微服务实现。这也是一个纯粹的JAVA模块。</li><li id="6649" class="mp mq it lb b lc mz lf na li nb lm nc lq nd lu nk mv mw mx bi translated"><strong class="lb iu"> Monitor App </strong> —包含基于ORION monitoring SPA(单页应用程序)的<strong class="lb iu">React</strong>+<strong class="lb iu">Material UI</strong>。这是一个纯粹的<strong class="lb iu"> JavaScript </strong>模块。</li><li id="8388" class="mp mq it lb b lc mz lf na li nb lm nc lq nd lu nk mv mw mx bi translated"><strong class="lb iu">集成</strong> —包含测试脚本，以及配置测试环境的测试资源。脚本是<strong class="lb iu">邮差测试集合</strong>，测试资源包括执行集合所需的数据。</li></ul><p id="3f4d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">配置和运行测试套件</strong></p><p id="9272" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将使用ORION 的v0.1版本进行我们的测试场景。</p><ul class=""><li id="6f6d" class="mp mq it lb b lc ld lf lg li mr lm ms lq mt lu nk mv mw mx bi translated">下载<strong class="lb iu"> v0.1 </strong>发布工件并解压两个压缩文件。</li><li id="fb29" class="mp mq it lb b lc mz lf na li nb lm nc lq nd lu nk mv mw mx bi translated">为测试工作区创建一个空文件夹。姑且称之为<code class="fe oe of og oh b">workspace</code>。</li><li id="1610" class="mp mq it lb b lc mz lf na li nb lm nc lq nd lu nk mv mw mx bi translated">打开以下文件，</li></ul><pre class="kj kk kl km gt oi oh oj ok aw ol bi"><span id="d4de" class="lv lw it oh b gy om on l oo op">&lt;downloaded-artifacts&gt;/integration/environment/init-setup.sh</span></pre><p id="5bac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用正确的文件路径编辑以下变量。</p><pre class="kj kk kl km gt oi oh oj ok aw ol bi"><span id="c8f2" class="lv lw it oh b gy om on l oo op">WORKER_JAR_PATH=&lt;path to the orion-v0.1-worker.jar file&gt;</span><span id="1645" class="lv lw it oh b gy oq on l oo op">MASTER_JAR_PATH=&lt;path to the orion-v0.1-master.jar file&gt;</span><span id="b81d" class="lv lw it oh b gy oq on l oo op">WORKSPACE=&lt;path to the workspace directory&gt;</span></pre><p id="ae25" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">保存更改。</p><ul class=""><li id="13b3" class="mp mq it lb b lc ld lf lg li mr lm ms lq mt lu nk mv mw mx bi translated">打开以下文件。</li></ul><pre class="kj kk kl km gt oi oh oj ok aw ol bi"><span id="a5f0" class="lv lw it oh b gy om on l oo op">&lt;downloaded-artifacts&gt;/integration/environment/stop-setup.sh</span></pre><p id="c25a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用正确的文件路径编辑以下变量。</p><pre class="kj kk kl km gt oi oh oj ok aw ol bi"><span id="c6e1" class="lv lw it oh b gy om on l oo op">WORKSPACE=&lt;path to the workspace directory&gt;</span></pre><p id="e0fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">保存更改。</p><ul class=""><li id="4e34" class="mp mq it lb b lc ld lf lg li mr lm ms lq mt lu nk mv mw mx bi translated">现在我们准备启动猎户座系统。打开一个终端窗口，执行以下命令来运行<strong class="lb iu"> init-setup.sh </strong>脚本。</li></ul><pre class="kj kk kl km gt oi oh oj ok aw ol bi"><span id="6285" class="lv lw it oh b gy om on l oo op">cd &lt;downloaded-artifacts&gt;/integration/environment<br/>sh init-setup.sh</span></pre><p id="7f08" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这会将相关文件复制到工作区目录，并为主服务器和两个工作服务器启动三个微服务。</p><p id="1fba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果观察工作区目录，会创建以下文件夹。</p><ul class=""><li id="32cd" class="mp mq it lb b lc ld lf lg li mr lm ms lq mt lu nk mv mw mx bi translated"><strong class="lb iu">主动进程</strong> —三个服务的PID。</li><li id="84e6" class="mp mq it lb b lc mz lf na li nb lm nc lq nd lu nk mv mw mx bi translated"><strong class="lb iu">日志</strong> —来自三个服务的日志文件。</li><li id="fdfe" class="mp mq it lb b lc mz lf na li nb lm nc lq nd lu nk mv mw mx bi translated"><strong class="lb iu">主</strong> —与主服务相关的工件。</li><li id="a517" class="mp mq it lb b lc mz lf na li nb lm nc lq nd lu nk mv mw mx bi translated"><strong class="lb iu"> worker-1 </strong> —与第一个worker服务相关的工件。</li><li id="d149" class="mp mq it lb b lc mz lf na li nb lm nc lq nd lu nk mv mw mx bi translated"><strong class="lb iu"> worker-2 </strong> —与第二个worker服务相关的工件。</li></ul><p id="8f9d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">执行以下命令来观察主日志。</p><pre class="kj kk kl km gt oi oh oj ok aw ol bi"><span id="5eec" class="lv lw it oh b gy om on l oo op">tail -f &lt;workspace&gt;/logs/master.log</span></pre><p id="f399" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果服务成功启动，应该会出现以下跟踪日志。</p><pre class="kj kk kl km gt oi oh oj ok aw ol bi"><span id="0a4d" class="lv lw it oh b gy om on l oo op">...</span><span id="ceb0" class="lv lw it oh b gy oq on l oo op">2021-06-25 02:14:22.022  INFO 10125 --- [           main] o.c.orion.master.RESTfulEndpoint         : Started RESTfulEndpoint in 1.194 seconds (JVM running for 1.658)</span></pre><p id="fd19" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，可以使用相同文件夹中的正确文件名，以相同的方式跟踪工作服务的日志。</p><ul class=""><li id="ffd2" class="mp mq it lb b lc ld lf lg li mr lm ms lq mt lu nk mv mw mx bi translated">现在启动Postman并导入下面的测试脚本集合。</li></ul><pre class="kj kk kl km gt oi oh oj ok aw ol bi"><span id="0140" class="lv lw it oh b gy om on l oo op">&lt;downloaded-artifacts&gt;/integration/test-scripts/ORION Test Suit - Executing heavy tasks.postman_collection</span></pre><p id="123b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个集合中有四个任务提交API调用。您需要为它们中的每一个设置可执行的shell脚本和输入文本文件(这些文件作为多部分表单数据提交)。相关的工件可以在相应的文件夹中找到。</p><pre class="kj kk kl km gt oi oh oj ok aw ol bi"><span id="924f" class="lv lw it oh b gy om on l oo op">&lt;downloaded-artifacts&gt;/integration/test-scripts/task-files/task-&lt;number&gt;</span></pre><p id="1f00" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们在这个测试中使用的任务只不过是一个shell脚本和一个输入文件。以下是其中一个脚本。</p><pre class="kj kk kl km gt oi oh oj ok aw ol bi"><span id="7969" class="lv lw it oh b gy om on l oo op">...<br/>sleep 50</span><span id="80d4" class="lv lw it oh b gy oq on l oo op">cat in.txt &gt; out.txt 2&gt;&amp;1</span></pre><p id="1565" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它等待一段时间，然后创建一个名为<strong class="lb iu"> out.txt </strong>的新文件，并将所有内容从<strong class="lb iu"> in.txt </strong>复制到<strong class="lb iu"> out.txt </strong>。这是为了模拟一个需要一些时间来处理的任务，包括输入和输出文件。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi or"><img src="../Images/fb9af02a5ddd6ba4705e75c5d6c83bd6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zAUhbTCTQqVlCTVxbbhH_A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Postman测试套件API集合</p></figure><ul class=""><li id="e335" class="mp mq it lb b lc ld lf lg li mr lm ms lq mt lu nk mv mw mx bi translated">我们现在几乎准备好执行测试套装了。但在此之前，让我们启动监控应用程序。</li></ul><p id="1d5e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在终端中执行以下命令(此时需要安装npm)。</p><pre class="kj kk kl km gt oi oh oj ok aw ol bi"><span id="21da" class="lv lw it oh b gy om on l oo op">cd &lt;downloaded-artifacts&gt;/sd<br/>npm i<br/>npm start</span></pre><p id="2a37" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这应该会启动监控应用程序。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi os"><img src="../Images/48ecb2555ee96ff685fa05bd1563353f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8rb3LSVLGxBtiGqzGUsXYg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">监控应用的初始外观</p></figure><p id="5eb0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦任务被提交，这将显示它们如何首先被插入到队列中，发送给工作人员执行，并最终在完成时存储在中央存储中。</p><ul class=""><li id="c432" class="mp mq it lb b lc ld lf lg li mr lm ms lq mt lu nk mv mw mx bi translated">让我们开始测试。在postman集合中，提交所有四个任务。您应该会收到以下响应，说明每个任务都在ORION中执行。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ot"><img src="../Images/d57357ab4f3c78958af904dcd485c255.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PeINED83M3SXfccAZ8EbFA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">提交响应</p></figure><p id="c2d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在打开监控应用程序窗口，观察已提交作业的生命周期！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ou"><img src="../Images/ab1b8766bb87f16b5945ffc8f54f450f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*Ta-ICccjCgN8O961jdpygg.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">提交任务并通过monitor应用程序对其进行监控</p></figure><p id="b934" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于每项任务，进度及其唯一的id都会显示出来。</p><ul class=""><li id="d2b2" class="mp mq it lb b lc ld lf lg li mr lm ms lq mt lu nk mv mw mx bi translated">最后，通过执行以下命令来停止ORION系统。</li></ul><pre class="kj kk kl km gt oi oh oj ok aw ol bi"><span id="d229" class="lv lw it oh b gy om on l oo op">cd &lt;downloaded-artifacts&gt;/integration/environment<br/>sh stop-setup.sh</span></pre><h2 id="08d5" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">总结我们的工作…</h2><p id="27eb" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">在本文中，我们逐步开发了一个为现代云量身定制的分布式计算系统。我们开始设计架构，重点是简单、现代、可扩展和可扩展。然后我们开始测试实现的系统，并成功运行了测试套件，观察提交的任务是如何处理的。</p><p id="74c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">谢谢你一直呆到这篇文章结束。非常感谢您对这项工作的想法、建议和问题。</p></div></div>    
</body>
</html>