<html>
<head>
<title>Python Polymorphism with Registers | Python Patterns</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带寄存器的Python多态性| Python模式</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/python-polymorphism-with-class-discovery-28908ac6456f?source=collection_archive---------4-----------------------#2021-08-29">https://towardsdatascience.com/python-polymorphism-with-class-discovery-28908ac6456f?source=collection_archive---------4-----------------------#2021-08-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="bf92" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">学习一种模式来隔离包，同时扩展Python代码的功能。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/b27a81cf9f28d862709af9b3e59b67d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*GEpm7rXlhlk2ttSo"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@ellladee?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> N. </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="39d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">动态多态是面向对象编程最强大的特性，它允许我们针对那些实际行为只在运行时定义的抽象进行编程。根据Robert C. Martin的说法，这也是真正<a class="ae ky" href="https://blog.cleancoder.com/uncle-bob/2014/11/24/FPvsOO.html" rel="noopener ugc nofollow" target="_blank">定义OOP </a>的唯一特性。</p><p id="1629" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">多态性由两部分组成:具有类型相关实现的方法和类型不可知的方法调用。在python代码中:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="37f4" class="ma mb it lw b gy mc md l me mf">class TypeA:<br/>  def speak(self):<br/>    print("Hello, this is an object of type TypeA")</span><span id="8433" class="ma mb it lw b gy mg md l me mf">class TypeB:<br/>  def speak(self):<br/>    print("Greetings from type TypeB")</span><span id="8ed7" class="ma mb it lw b gy mg md l me mf">def agnostic_speak(speaker):<br/>  speaker.speak()</span><span id="f3f0" class="ma mb it lw b gy mg md l me mf">agnostic_speak(TypeA())<br/>agnostic_speak(TypeB())</span><span id="beea" class="ma mb it lw b gy mg md l me mf">&gt;&gt; Hello, this is an object of type TypeA<br/>   Greetings from type TypeB</span></pre><p id="1ba4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个简单的例子展示了多态方法speak()和调用它的通用函数，而不知道调用该方法的对象的实际类型。</p><p id="58b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于这样一个简单的例子，一个基于参数类型的条件语句(if/else)可以完成这个任务，但是它也有缺点。首先，条件代码使得函数更难阅读。在这个版本中，我们立即看到它做了什么，它让一个对象<em class="mh">说话</em>，而对于条件代码，我们需要首先理解不同的分支做什么。此外，如果将来我们想要添加更多的说话方式，我们将需要返回到这个函数并修改它以添加新的分支。反过来，新的分支将使代码越来越不可读。</p><p id="ac44" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们有一个文本分类应用程序，它在输入中接收一行文本，并输出一个代表其主题的标签。像任何好的机器学习项目一样，我们在不同的模型上执行许多迭代，我们希望我们的代码使用它们。当然，我们不希望一个大的switch语句(if-elif-elif-…-else)带有运行任何单一模型的逻辑！</p><p id="874c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">出于示例的原因，所有模型共享相同的输入/输出词汇表，即相同的映射word-&gt;input index和output index-&gt;label。唯一的区别在于底层模型所执行的操作。</p><p id="217d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们代码的第一个版本中，我们只有两个模型架构:一个前馈网络和一个LSTM网络，它们提供多态的<em class="mh"> forward() </em>方法来封装每个模型的逻辑:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="dcd3" class="ma mb it lw b gy mc md l me mf"># main.py<br/>from models import FfModel, LstmModel</span><span id="938d" class="ma mb it lw b gy mg md l me mf">def main(args):<br/>  model_type = args.model_type<br/>  model_path = args.model_path<br/>  if model_type == "ff":<br/>    model = FfModel(model_path)<br/>  elif model_type == "lstm":<br/>    model = LstmModel(model_path)<br/>  else:<br/>    raise NotImplementedError("Unrecognizer type %s" % model_type)</span><span id="2185" class="ma mb it lw b gy mg md l me mf">  outputs = []</span><span id="debb" class="ma mb it lw b gy mg md l me mf">  with open(args.input_text, 'r') as fid:<br/>    for line in fid:<br/>      word_ids = convert_to_id(tokenize(line)) <br/>      output = model.forward(word_ids)<br/>      outputs.append(convert_to_labels(output))</span><span id="1997" class="ma mb it lw b gy mg md l me mf">  show_results(outputs)</span></pre><p id="5f95" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该代码包含许多未定义的函数，以便让我们专注于本文的相关部分。在这个片段中，我们可以看到模型类型是由用户提供的参数。它用于选择哪种模型类型，由一个类表示，应该用来加载和使用我们保存的模型。注意，这两个类都被导入到主文件中。在代码片段的后半部分，我们有对<em class="mh"> forward </em>的多态调用，它根据深度学习模型的类型正确地执行深度学习模型操作。最后，我们有在文本和不依赖于模型的神经网络格式之间转换输入和输出的函数。</p><p id="4977" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这段代码片段成功地提供了多态行为，但它显然打破了软件设计的<a class="ae ky" href="https://en.wikipedia.org/wiki/SOLID" rel="noopener ugc nofollow" target="_blank">坚实</a>原则之一的<a class="ae ky" href="https://en.wikipedia.org/wiki/Open%E2%80%93closed_principle" rel="noopener ugc nofollow" target="_blank">开/闭原则</a>。这个原则规定我们的程序应该<em class="mh">对扩展开放，但对修改</em>关闭。</p><p id="b3a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在实践中，这意味着每当我们想在程序中添加一个新的模型类型时，我们必须为该类型创建一个新的类，然后将其导入main.py，最后在if/else语句中为其添加一个新的分支。我们的程序对扩展开放，但也对修改开放。如果我们想将允许的类型添加到我们的软件帮助中，这样用户就可以很容易地发现它们。每当我们添加一个新的类型时，我们也应该把它的名字添加到允许的类型列表中，否则会给用户带来很大的困扰。</p><p id="aaea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">改进上述代码的第一种方法是用一个函数替换条件分支，该函数将模型类型及其路径作为输入，并返回构建的对象(类似于<a class="ae ky" href="https://en.wikipedia.org/wiki/Factory_method_pattern" rel="noopener ugc nofollow" target="_blank">工厂方法</a>)。上面的代码将变成:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="a3cf" class="ma mb it lw b gy mc md l me mf"># main.py<br/>from models import model_factory</span><span id="6c9e" class="ma mb it lw b gy mg md l me mf">def main(args):<br/>  model_type = args.model_type<br/>  model_path = args.model_path</span><span id="f700" class="ma mb it lw b gy mg md l me mf">  model = model_factory(model_type, model_path)<br/> <br/>  outputs = []</span><span id="02fb" class="ma mb it lw b gy mg md l me mf">  with open(args.input_text, 'r') as fid:<br/>    for line in fid:<br/>      word_ids = convert_to_id(tokenize(line)) <br/>      output = model.forward(word_ids)<br/>      outputs.append(convert_to_labels(output))</span><span id="9610" class="ma mb it lw b gy mg md l me mf">  show_results(outputs)</span></pre><p id="d06d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在模型选择被移动到__init__。模型包的py文件，在这里我们还用对字典的调用替换了条件代码:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="e0bc" class="ma mb it lw b gy mc md l me mf"># models.__init__.py<br/>__all__ = ["factory_method"]</span><span id="f5fe" class="ma mb it lw b gy mg md l me mf">from .ff_model import FfModel<br/>from .lstm_model import LstmModel</span><span id="f02c" class="ma mb it lw b gy mg md l me mf">__MODEL_DICT__ = {<br/>  "ff": FfModel,<br/>  "lstm": LstmModel<br/>}</span><span id="9547" class="ma mb it lw b gy mg md l me mf">def factory_method(model_type, model_path):<br/>  return __MODEL_DICT__[model_type](model_path)</span></pre><p id="1c48" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我们只导出factory_method，它从字典中选择正确的类型名(在python中是用于创建该类型对象的工厂),构建一个对象并将其返回给调用者。字典是将条件代码简化为线性流的简单有效的方法。</p><p id="42d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了这段代码，我们的主文件就可以忽略现有的模型类型，我们可以添加或删除类，而根本不用修改主文件。然而，我们只是将开放修改代码从<em class="mh"> main.py </em>移到了这个新的__init.py文件中。我们通过将主文件与可能的模型修改隔离开来，实现了改进，但是__init__中的代码。出于同样的原因，py仍然可以修改。</p><p id="34c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们能做得比这更好吗？当我们添加一个新的模型类型时，我们可以用这样的方式编写代码吗？我们只需添加新的类和一个名称来标识它，这样就足以将它添加到__MODEL_DICT__字典中了。</p><p id="35ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事实证明，这不仅在python中是可能的，而且只需要一堆代码就可以实现。该机制由两部分组成:</p><ol class=""><li id="5e6e" class="mi mj it lb b lc ld lf lg li mk lm ml lq mm lu mn mo mp mq bi translated"><strong class="lb iu">类发现:</strong>一种无需为类编写显式导入语句即可导入类的算法。</li><li id="6bc9" class="mi mj it lb b lc mr lf ms li mt lm mu lq mv lu mn mo mp mq bi translated"><strong class="lb iu">注册:</strong>被发现的类自动调用的函数，被添加到字典中，如__MODEL_DICT__</li></ol><p id="4017" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们轮流看他们。</p><h1 id="ffe6" class="mw mb it bd mx my mz na nb nc nd ne nf jz ng ka nh kc ni kd nj kf nk kg nl nm bi translated">自动发现</h1><p id="0644" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">我们如何导入类而不为它们或者甚至包含它们的文件(模块)写一个显式的导入呢？或者更根本地说，在给定这些约束的情况下，我们如何让Python解释器在运行时知道它们？</p><p id="3591" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个解决方案是通过<a class="ae ky" href="https://docs.python.org/3/library/importlib.html" rel="noopener ugc nofollow" target="_blank"> importlib </a>包中的<a class="ae ky" href="https://docs.python.org/3/library/importlib.html#importlib.import_module" rel="noopener ugc nofollow" target="_blank"> import_module </a>函数实现的。来自importlib官方文档:</p><blockquote class="ns nt nu"><p id="8a24" class="kz la mh lb b lc ld ju le lf lg jx lh nv lj lk ll nw ln lo lp nx lr ls lt lu im bi translated">[…]实现<code class="fe ny nz oa lw b"><a class="ae ky" href="https://docs.python.org/3/reference/simple_stmts.html#import" rel="noopener ugc nofollow" target="_blank">import</a></code>的组件在这个包中公开，使得用户更容易创建他们自己的定制对象(一般称为<a class="ae ky" href="https://docs.python.org/3/glossary.html#term-importer" rel="noopener ugc nofollow" target="_blank">导入器</a>)来参与导入过程。</p></blockquote><p id="8d41" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正是我们需要的！让我们看看可以添加到__init__中的代码。py使它成为我们模型类的自定义导入器:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="8cca" class="ma mb it lw b gy mc md l me mf"># Iterate all files in the same directory<br/>for file in os.listdir(os.path.dirname(__file__)):                                 <br/>  # Exclude __init__.py and other non-python files<br/>  if file.endswith('.py') and not file.startswith('_'):<br/>    # Remove the .py extension  <br/>    module_name = file[:-len('.py')]     <br/>    # Assume src to be the name of the source root directory                              <br/>    importlib.import_module('models.' + module_name)</span></pre><p id="1794" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过这四行代码，我们的软件自动导入模型包中的所有模块。当一个模块被导入时，它的代码被执行，所以我们的下一步是实现一个机制，让我们的类把它们自己添加到我们的__MODEL_DICT__。</p><h1 id="d3ff" class="mw mb it bd mx my mz na nb nc nd ne nf jz ng ka nh kc ni kd nj kf nk kg nl nm bi translated">子类注册</h1><p id="8b43" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">第一种方法修改了初始化子类的Python机制。幸运的是，Python公开了在第一次执行类定义时调用的方法__init_sub_class__。每个类都自动调用父类的__init_sub_class__并将其类型作为参数。因此，我们可以在父类中集中注册新类的逻辑:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="0ccd" class="ma mb it lw b gy mc md l me mf"># models.model.py</span><span id="5748" class="ma mb it lw b gy mg md l me mf">__MODEL_DICT__ = dict()</span><span id="6b64" class="ma mb it lw b gy mg md l me mf">class Model:<br/>  def __init_sub_class__(cls, **kwargs):<br/>    assert "name" in kwargs<br/>    super().__init_sub_class__()<br/>    if kwargs["name"] in __MODEL_DICT__:<br/>      raise ValueError("Name %s already registered!" % name)<br/>    __MODEL_DICT__[kwargs["name"]] = cls</span></pre><p id="455e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">__init_sub_class__接受一个名为cls的参数作为输入，这是类类型参数的Python约定，以及存储在kwargs附加库中的任意数量的键值对。我们首先检查<em class="mh"> "name" </em>是否作为一个键存在于附加参数中，因为如果我们不知道用哪个名字注册一个类，我们就不能在字典中注册它。然后，如果以前没有注册过具有该名称的类，只需将它添加到字典中，否则程序会退出并显示一个错误，通知用户存在重复。</p><p id="5aea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们只需要每个子类将其名称作为附加参数传递给__init_sub_class__。这不是通过直接调用函数来完成的，而是在定义父类时完成的:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="39f0" class="ma mb it lw b gy mc md l me mf"># models.ff_model.py<br/>from .model import Model</span><span id="2dfd" class="ma mb it lw b gy mg md l me mf">class FfModel(Model, name="ff"):<br/>  def __init__(self, *args, **kwargs):<br/>    # Construct object</span><span id="dd30" class="ma mb it lw b gy mg md l me mf">  def forward(self, x):<br/>    # Operations for computing output probabilities of x</span></pre><p id="37cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">类实现不知道注册过程，它只通过父类名旁边的赋值name="ff "出现。该赋值以及您可能愿意添加的任何其他赋值将构成模型__init_sub_class__的**kwargs。</p><p id="8613" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，对于LstmModel:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="0659" class="ma mb it lw b gy mc md l me mf"># models.lstm_model.py<br/>from .model import Model</span><span id="3309" class="ma mb it lw b gy mg md l me mf">class LstmModel(Model, name="lstm"):<br/>  def __init__(self, *args, **kwargs):<br/>    # Construct object</span><span id="0a6e" class="ma mb it lw b gy mg md l me mf">def forward(self, x):<br/>    # Operations for computing output probabilities of x</span></pre><p id="85ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在__init__时。py我们需要执行发现代码并公开一个工厂方法来访问字典</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="c3d6" class="ma mb it lw b gy mc md l me mf"># __init__.py<br/>__all__ == ["factory_method"]</span><span id="e66b" class="ma mb it lw b gy mg md l me mf"><br/>import os<br/>import importlib</span><span id="1063" class="ma mb it lw b gy mg md l me mf">from models.model import Model, __MODEL_DICT__</span><span id="c473" class="ma mb it lw b gy mg md l me mf"><br/>def factory_method(name, path):<br/>    return __MODEL_DICT__[name](path)<br/><br/><br/>for file in os.listdir(os.path.dirname(__file__)):<br/>    if file.endswith('.py') and not file.startswith('_'):<br/>        module_name = file[:file.find('.py')]<br/>        module = importlib.import_module('models.' + module_name)</span></pre><h1 id="eeec" class="mw mb it bd mx my mz na nb nc nd ne nf jz ng ka nh kc ni kd nj kf nk kg nl nm bi translated">寄存器功能</h1><p id="f7c8" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">第二种方法是定义一个包装我们的类的“注册”函数。register函数的内部工作有点复杂，所以请原谅我。当包含由我们的注册函数包装的类的模块第一次被执行时，它用它的参数运行包装函数。包装函数定义了一个内部函数，该函数将一个类<strong class="lb iu">类型</strong>作为输入，并对其进行处理。此外，内部函数可以访问包装函数中的变量，因为它是一个<a class="ae ky" href="https://betterprogramming.pub/5-essential-aspects-of-python-closures-494a04e7b65e" rel="noopener ugc nofollow" target="_blank">闭包</a>。register函数简单地返回它的内部函数，这个内部函数又以包装的类类型作为它的输入被立即执行。内部函数是实际注册类的函数，然后返回将由python解释器添加到当前名称空间的类类型。</p><p id="ea8a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个过程在__init__之间再次拆分。py文件和包含实际类的模块文件。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="00e4" class="ma mb it lw b gy mc md l me mf"># models.__init__.py<br/>__all__ = ["factory_method"]<br/><br/><br/>import os<br/>import importlib<br/><br/>from .model import Model<br/><br/><br/>def factory_method(name):<br/>    return __MODEL_DICT__[name]<br/><br/><br/>__MODEL_DICT__ = dict()<br/><br/><br/>def register_function(name):<br/>    <br/>    def register_function_fn(cls):<br/>        if name in __MODEL_DICT__:<br/>            raise ValueError("Name %s already registered!" % name)<br/>        if not issubclass(cls, Model):<br/>            raise ValueError("Class %s is not a subclass of %s" % (cls, Model))<br/>        __MODEL_DICT__[name] = cls<br/>        return cls<br/><br/>    return register_function_fn<br/><br/><br/>for file in os.listdir(os.path.dirname(__file__)):<br/>    if file.endswith('.py') and not file.startswith('_'):<br/>        module_name = file[:file.find('.py')]<br/>        module = importlib.import_module('models.' + module_name)</span></pre><p id="e02d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，<em class="mh"> factory_method </em>是我们的main调用的函数，它基本上是我们字典的包装器。请注意，在我们的内部register_function_fn中，我们可以执行我们通常可以在任何函数中执行的任何操作，因此我们额外检查了给定的类是Model的子类。这是保持基于层次结构的多态性所必需的，因为我们不能保证register类确实是一个模型。</p><p id="a6ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一种可能的检查可以基于<a class="ae ky" href="https://en.wikipedia.org/wiki/Duck_typing" rel="noopener ugc nofollow" target="_blank">鸭类型</a>，并且将检查类中是否存在<em class="mh">转发</em>方法，而不是检查其类型。python的动态性也允许我们不执行任何检查，但是当我们使用buggy模型时，这种勇敢会导致令人讨厌的错误出现。相比之下，在我们的注册机制中插入检查将在每次运行程序时检查所有模型的一致性。在静态类型语言中，这种检查是由类型检查器执行的，而Python为我们提供了更多的动态性，但也为我们清理自己的混乱提供了更多的责任。</p><p id="ccf1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们只需要使用register_function作为我们的类的<a class="ae ky" href="https://gist.github.com/Zearin/2f40b7b9cfc51132851a" rel="noopener ugc nofollow" target="_blank">装饰器</a>，以使它的功能如上所述:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="a0a0" class="ma mb it lw b gy mc md l me mf"># models.ff_model.py<br/>from models.model import Model</span><span id="9e83" class="ma mb it lw b gy mg md l me mf"><br/>@register_function("ff")<br/>class FfModel(Model):<br/>  def __init__(self, *args, **kwargs):<br/>    # Construct object</span><span id="0fff" class="ma mb it lw b gy mg md l me mf">  def forward(self, x):<br/>    # Operations for computing output probabilities of x</span></pre><p id="64a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过使用register_function作为装饰器，注册机制在类的外部，因此它可以完成它的工作，然后模型类不需要任何关于注册的代码。</p><p id="98bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该示例的工作方式如下:</p><ul class=""><li id="ca55" class="mi mj it lb b lc ld lf lg li mk lm ml lq mm lu ob mo mp mq bi translated"><em class="mh"> register_function </em>以<em class="mh">“ff”</em>作为唯一参数被调用</li><li id="6012" class="mi mj it lb b lc mr lf ms li mt lm mu lq mv lu ob mo mp mq bi translated">它返回<em class="mh"> register_function_fn </em>封闭绑定<em class="mh"> name="ff" </em></li><li id="15f7" class="mi mj it lb b lc mr lf ms li mt lm mu lq mv lu ob mo mp mq bi translated"><em class="mh">用<em class="mh"> cls=FfModel </em>调用寄存器_函数_fn </em></li><li id="68ed" class="mi mj it lb b lc mr lf ms li mt lm mu lq mv lu ob mo mp mq bi translated"><em class="mh"> register_function_fn </em>在我们的<em class="mh"> __MODEL_DICT__ </em>中注册键值对<em class="mh">“ff”= FfModel</em>，并将ff MODEL返回给解释器</li><li id="8701" class="mi mj it lb b lc mr lf ms li mt lm mu lq mv lu ob mo mp mq bi translated">现在可以通过函数<em class="mh"> factory_method() </em>在应用程序中使用FfModel，并且不需要显式导出。</li></ul><p id="0089" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一次很难掌握像这样的注册功能的工作原理，主要是因为所有的操作都是在启动阶段执行的。然而，如果你能遵循上面的解释，你将最终掌握一个强大的工具，它的应用远远超出了这个例子。</p><p id="070b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与前面的解决方案相比，register函数的难度为我们带来了更多的灵活性，因为它没有将我们限制在类的层次结构中，也可以用于函数而不是类。此外，从<a class="ae ky" href="https://en.wikipedia.org/wiki/Single-responsibility_principle" rel="noopener ugc nofollow" target="_blank">单一责任原则</a> (SRP)的角度来看，这段代码更好，因为注册子类的责任被交给了一个只负责注册子类的函数，而不是父模型类。</p><h1 id="2885" class="mw mb it bd mx my mz na nb nc nd ne nf jz ng ka nh kc ni kd nj kf nk kg nl nm bi translated">结论</h1><p id="8351" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">类发现是一个强大的工具，它通过Python项目的两个组件之间的抽象接口提供多态行为。</p><p id="a760" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最终的设计在不同的包之间有更少的显式依赖，而在同一个包内有更多的依赖。然后，它强制不同包及其内部内聚性的解耦。</p><p id="ce26" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，我们还看到了这种模式是如何产生更加尊重可靠原则的代码的。</p><p id="50e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当一个包主要由相同层次结构中的类组成时，我推荐使用它，这样就可以用不同的实现达到相同的目的。只有在定义代码的地方才需要修改代码，这让我们在开发的时候心情愉快。</p><h1 id="967f" class="mw mb it bd mx my mz na nb nc nd ne nf jz ng ka nh kc ni kd nj kf nk kg nl nm bi translated">承认</h1><p id="9308" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">我从脸书的FAIRseq开源项目中学会了如何使用注册函数。你可以在这里找到他们当前的实现<a class="ae ky" href="https://github.com/pytorch/fairseq/blob/master/fairseq/models/__init__.py" rel="noopener ugc nofollow" target="_blank"/>或者从我的<a class="ae ky" href="https://github.com/mattiadg/FBK-Fairseq-ST/blob/f30e2b57659f1efb0ab95a35e44025d75a70af05/fairseq/models/__init__.py#L36-L62" rel="noopener ugc nofollow" target="_blank">老叉</a>找到一个更简单的版本。</p><p id="f374" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">__init_sub_class__方法的一个很好的解释可以在<a class="ae ky" href="https://stackoverflow.com/a/50099920" rel="noopener ugc nofollow" target="_blank">堆栈溢出</a>中找到。</p></div></div>    
</body>
</html>