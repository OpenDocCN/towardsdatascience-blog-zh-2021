<html>
<head>
<title>Working With SQL Versus Pandas (Part 2) Plus Practice Problems</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用SQL与熊猫(第2部分)以及练习题</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/working-with-sql-versus-pandas-part-2-plus-practice-problems-ae1c19aab114?source=collection_archive---------19-----------------------#2021-04-24">https://towardsdatascience.com/working-with-sql-versus-pandas-part-2-plus-practice-problems-ae1c19aab114?source=collection_archive---------19-----------------------#2021-04-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4dce" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">聚合和分组数据</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/0a4636dfba02632e31bbd3705a6916c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ca4vF5qaDSR7NEhO"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">塞尔吉奥·卡普齐马蒂在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="24f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是系列文章的第二部分。你可以在这里找到第一部分:</p><div class="lv lw gp gr lx ly"><a rel="noopener follow" target="_blank" href="/working-with-sql-versus-pandas-part-1-plus-practice-problems-c23934c41e3"><div class="lz ab fo"><div class="ma ab mb cl cj mc"><h2 class="bd iu gy z fp md fr fs me fu fw is bi translated">使用SQL与熊猫(第1部分)以及练习题</h2><div class="mf l"><h3 class="bd b gy z fp md fr fs me fu fw dk translated">选择、过滤和排序数据</h3></div><div class="mg l"><p class="bd b dl z fp md fr fs me fu fw dk translated">towardsdatascience.com</p></div></div><div class="mh l"><div class="mi l mj mk ml mh mm ks ly"/></div></div></a></div><h1 id="e45d" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">介绍</h1><p id="18e2" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">在本系列中，我将Python Pandas与SQL进行比较。这两个都是流行的数据操作工具，在功能上有很多重叠。在本文中，我们将讨论数据的聚合和分组。对于本文中的示例，我们将再次使用可以在Kaggle 上找到的<a class="ae ky" href="https://www.kaggle.com/c/titanic" rel="noopener ugc nofollow" target="_blank"> Titanic数据集。我鼓励你下载它，并遵循最大保留。另外，不要忘记在最后尝试一下练习题。好吧，我们开始吧！</a></p><h1 id="7c82" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">聚合函数</h1><p id="8211" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">假设我们对找出一些数据的统计感兴趣，比如支付的最高和最低票价，乘客的平均年龄，以及有多少人幸存。</p><h2 id="b899" class="nk mo it bd mp nl nm dn mt nn no dp mx li np nq mz lm nr ns nb lq nt nu nd nv bi translated">结构化查询语言</h2><p id="1db4" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">要在SQL中执行聚合函数，您可以将<code class="fe nw nx ny nz b">AVG()</code>、<code class="fe nw nx ny nz b">COUNT()</code>、<code class="fe nw nx ny nz b">MIN()</code>、<code class="fe nw nx ny nz b">MAX()</code>和<code class="fe nw nx ny nz b">SUM()</code>用于您想要在括号中应用函数的列。需要注意的是，这些聚合函数会忽略空值。这是我们设置的问题的样子。</p><pre class="kj kk kl km gt oa nz ob oc aw od bi"><span id="1520" class="nk mo it nz b gy oe of l og oh">SELECT MAX(fare), MIN(fare), AVG(age), SUM(survived)<br/>FROM titanic</span></pre><p id="778e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请记住，幸存的列用1表示幸存的列，用0表示未幸存的列。这就是为什么<code class="fe nw nx ny nz b">SUM()</code>函数能够给出幸存者的总数。</p><p id="4d6f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于这些聚合函数，您可能会发现使用<code class="fe nw nx ny nz b">ROUND()</code>可以获得更漂亮的结果。例如，如果我们想将平均年龄列的结果四舍五入到小数点后一位，结果应该是这样的:<code class="fe nw nx ny nz b">ROUND(AVG(age), 1)</code>。如果我们想要四舍五入到最接近的整数，那么它将是这样的:<code class="fe nw nx ny nz b">ROUND(AVG(age))</code>。</p><p id="e083" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">SQL的一个缺点是前面列出的聚合函数是唯一的标准函数。没有如此简单、直接的方法来计算一列的中值或标准差。我相信SQL的某些特定版本可能有更多的聚合函数选项，所以我建议对您正在使用的版本做一些研究。</p><h2 id="1d27" class="nk mo it bd mp nl nm dn mt nn no dp mx li np nq mz lm nr ns nb lq nt nu nd nv bi translated">熊猫</h2><p id="9721" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">pandas中有几个集合函数选项。Pandas默认忽略空值，但是如果你真的想的话，有一些参数可以包含它们。为了在某些列上完成特定的聚合函数，我们可以单独计算每个函数。这就是它的样子。</p><pre class="kj kk kl km gt oa nz ob oc aw od bi"><span id="1b60" class="nk mo it nz b gy oe of l og oh">titanic.fare.agg(['max','min'])<br/>titanic.age.mean()<br/>titanic.survived.sum()</span></pre><p id="9966" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里让我们列出一个清单。因为我们想要找到fare列的最大值和最小值，所以我们可以使用<code class="fe nw nx ny nz b">agg()</code>方法将其合并到一行代码中。</p><p id="51ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如在SQL示例中提到的，您可能想要舍入以获得更好的结果。你可以在一个<code class="fe nw nx ny nz b">round()</code>上链这样做。第一个参数是小数位数，默认值为0。例如，平均年龄四舍五入到小数点后一位就是<code class="fe nw nx ny nz b">titanic.age.mean().round(1)</code>。</p><p id="eb74" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Pandas真正了不起的地方是<code class="fe nw nx ny nz b">describe()</code>方法，它返回数字列的汇总表。代码<code class="fe nw nx ny nz b">titanic.describe()</code>返回下表。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/d58b56e7b1c0bb2b935aa75a3d6b3eb8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1028/format:webp/1*0hEM-RkQUsz01RSCZso3vg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者创造的形象</p></figure><p id="f691" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这比技术上要求的信息要多，但是仍然非常有用，并且只需要一行非常简单的代码。您还可以通过<code class="fe nw nx ny nz b">titanic.describe(include=”O”)</code>获得一些关于“object”数据类型列的信息。下面是返回的内容。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/9d55aabddb99514616b8ee833801c63f.png" data-original-src="https://miro.medium.com/v2/resize:fit:418/format:webp/1*-xeEQ6lw-qzPcna_yFn40w.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者创造的形象</p></figure><p id="1b8e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Pandas拥有比SQL更多的聚合函数，如median ( <code class="fe nw nx ny nz b">median()</code>)、standard deviation ( <code class="fe nw nx ny nz b">std()</code>)和variance ( <code class="fe nw nx ny nz b">var()</code>)。<code class="fe nw nx ny nz b">agg()</code>方法还允许更大的灵活性，如果你愿意，你可以基于一个定制的函数进行聚合。</p><h1 id="385a" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">分组依据</h1><p id="04a7" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">比方说，我们希望找到每个班级的男性和女性的一些汇总数据。让我们找出每个班级中男性和女性的数量、平均年龄和存活人数。</p><h2 id="0a68" class="nk mo it bd mp nl nm dn mt nn no dp mx li np nq mz lm nr ns nb lq nt nu nd nv bi translated">结构化查询语言</h2><p id="b5c5" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">在SQL中，<code class="fe nw nx ny nz b">GROUP BY</code>子句用于此目的。这是它看起来的样子。</p><pre class="kj kk kl km gt oa nz ob oc aw od bi"><span id="f647" class="nk mo it nz b gy oe of l og oh">SELECT sex, pclass, COUNT(*), SUM(survived), AVG(age)<br/>FROM titanic<br/>GROUP BY sex, pclass</span></pre><p id="d5df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本例中，由于我们返回的列不是聚合值(sex，pclass)，如果没有GROUP BY子句，代码将无法运行，因为SQL不知道如何处理没有GROUP BY子句的这些列。在按性别和阶级分组时，将为性别和阶级的每个组合单独计算汇总列(女性在一等，男性在一等，女性在二等，等等)。)</p><h2 id="7d8b" class="nk mo it bd mp nl nm dn mt nn no dp mx li np nq mz lm nr ns nb lq nt nu nd nv bi translated">熊猫</h2><p id="d72a" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">在熊猫身上，我们有获得我们想要的结果的方法。和以前一样，我们可以运行代码来获得我们想要的每一个片段，或者我们可以运行包含比我们需要的更多信息的代码。这是把信息分成几部分的样子。</p><pre class="kj kk kl km gt oa nz ob oc aw od bi"><span id="7f08" class="nk mo it nz b gy oe of l og oh">titanic.groupby(['sex', 'pclass']).survived.agg(['count', 'sum'])<br/>titanic.groupby(['sex', 'pclass']).age.mean()</span></pre><p id="5dde" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们也可以生成一个包含我们想要的信息的表，但是它包含的信息比我们要求的要多。这就是它的样子。</p><pre class="kj kk kl km gt oa nz ob oc aw od bi"><span id="d2ba" class="nk mo it nz b gy oe of l og oh">new_df = titanic.groupby(['sex', 'pclass'])[['survived', 'age']]<br/>new_df.agg(['count', 'sum', 'mean'])</span></pre><p id="1b6d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个例子中，我创建了一个新的变量来拆分代码行，这样更容易查看，但是您可以在一行中完成所有这些。首先我们应用groupby，然后对我们需要的列进行切片，然后对这些列应用聚合函数。下面是生成的表格。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/2048e7947596cea1736d157f08475e97.png" data-original-src="https://miro.medium.com/v2/resize:fit:860/format:webp/1*jGNKNxnSdf_ynyq518y6SA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者创造的形象</p></figure><p id="7be4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在某些情况下，这些额外的信息可能是额外的兴趣，在其他情况下，它可能只会引起更多的混乱。例如,“存活”和“年龄”列的计数不同。这是因为age列中有空值，所以survived列中的计数是我们关心的真实计数，因为没有空值。但是这会导致不必要的混乱。另一方面，存活列中的平均值告诉我们每个组中存活者的百分比，这是增加分析价值的有趣信息。</p><h1 id="a124" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">练习题</h1><ol class=""><li id="9eaf" class="ol om it lb b lc nf lf ng li on lm oo lq op lu oq or os ot bi translated">查找平均票价和按上船港口和舱位分类的乘客人数。</li><li id="285a" class="ol om it lb b lc ou lf ov li ow lm ox lq oy lu oq or os ot bi translated">找出按等级和存活率分组的乘客的最小、最大和平均年龄。</li><li id="06ef" class="ol om it lb b lc ou lf ov li ow lm ox lq oy lu oq or os ot bi translated">查找按生存分组的乘客的平均票价、最小年龄和最大年龄。</li></ol><h1 id="0b04" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">停止—下面的答案</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oz"><img src="../Images/bd516fc8b64c01faba877af564c41b02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ewBJsxXwd4_cA_eA"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">约翰·马特丘克在Unsplash<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">拍摄的照片</a></p></figure><p id="edce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在偷看答案之前，你有没有尝试过每个问题？请记住，您的答案可能会与我的略有不同，因为通常有多种解决方法。</p><ol class=""><li id="902a" class="ol om it lb b lc ld lf lg li pa lm pb lq pc lu oq or os ot bi translated"><strong class="lb iu">查找平均票价和按上船港口和舱位分组的乘客人数。</strong></li></ol><p id="bfe9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">SQL:</p><pre class="kj kk kl km gt oa nz ob oc aw od bi"><span id="adfa" class="nk mo it nz b gy oe of l og oh">SELECT embarked, pclass, COUNT(*), AVG(fare)<br/>FROM titanic<br/>GROUP BY embarked, pclass</span></pre><p id="9d3a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">熊猫:</p><pre class="kj kk kl km gt oa nz ob oc aw od bi"><span id="1e63" class="nk mo it nz b gy oe of l og oh">titanic.groupby(['embarked', 'pclass']).fare.mean()<br/>titanic.groupby(['embarked', 'pclass']).embarked.count()</span></pre><p id="2837" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> 2。找出按等级和存活率分组的乘客的最小、最大和平均年龄。</strong></p><p id="0bf1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">SQL:</p><pre class="kj kk kl km gt oa nz ob oc aw od bi"><span id="6172" class="nk mo it nz b gy oe of l og oh">SELECT pclass, survived, MIN(age), MAX(age), AVG(age)<br/>FROM titanic<br/>GROUP BY pclass, survived</span></pre><p id="18c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">熊猫:</p><pre class="kj kk kl km gt oa nz ob oc aw od bi"><span id="880a" class="nk mo it nz b gy oe of l og oh">titanic.groupby(['pclass','survived']).age.agg(['min','max','mean'])</span></pre><p id="23ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> 3。查找按生存分组的乘客的平均票价、最小年龄和最大年龄。</strong></p><p id="09ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">SQL:</p><pre class="kj kk kl km gt oa nz ob oc aw od bi"><span id="ab12" class="nk mo it nz b gy oe of l og oh">SELECT survived, AVG(fare), MIN(age), MAX(age)<br/>FROM titanic<br/>GROUP BY survived</span></pre><p id="62a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">熊猫:</p><pre class="kj kk kl km gt oa nz ob oc aw od bi"><span id="eefb" class="nk mo it nz b gy oe of l og oh">titanic.groupby('survived').age.agg(['min', 'max'])<br/>titanic.groupby('survived').fare.mean()</span></pre><h1 id="4cfd" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">结论</h1><p id="5302" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">我希望您喜欢关于聚合函数和分组的讨论。我想让这些文章足够短，容易消化，这也是我决定就此打住的原因。我期待着与您一起继续这篇文章系列的旅程，所以请务必参加我的下一部分！</p></div></div>    
</body>
</html>