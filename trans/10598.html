<html>
<head>
<title>Crime Location Analysis and Prediction Using Python and Machine Learning</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Python和机器学习进行犯罪地点分析和预测</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/crime-location-analysis-and-prediction-using-python-and-machine-learning-1d8db9c8b6e6?source=collection_archive---------5-----------------------#2021-10-11">https://towardsdatascience.com/crime-location-analysis-and-prediction-using-python-and-machine-learning-1d8db9c8b6e6?source=collection_archive---------5-----------------------#2021-10-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3640" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用Python、Folium和ScyPy，可以构建模型来说明犯罪事件，计算安全事件资源分配的最佳位置，并在非常规事件期间突出显示我们社区中安全关注的关键领域</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ab7bbbba4e7a9b0bc315cb5015fa17ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zV4UI6sJok7NdrVV_t-QeA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者拍摄的摩根敦照片</p></figure><p id="fabf" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这篇文章的作者是一位自豪的西弗吉尼亚大学登山运动员，在西弗吉尼亚的摩根敦度过了四年。摩根敦是山州的一座美丽城市，WVU的校园非常安全。也就是说，像所有城市一样，安全事故确实会发生，大学警察局每天都会在<a class="ae lu" href="https://police.wvu.edu/clery-act/campus-safety/crime-log" rel="noopener ugc nofollow" target="_blank">犯罪日志</a>中报告这些事件。通过Python中的编码包进行分析，可以在地理上更好地可视化这些事件，以评估位置趋势、事件类型、基于一天中时间的事件可能性，以及非常规事件(如足球周末，城镇人口暂时翻倍)期间的趋势。</p><p id="cd6f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在2019年底，作者详细分析了前一个秋季学期的安全事件日志，并在JSON schema中创建了前四个月的数据集，如下所示。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="a592" class="ma mb it lw b gy mc md l me mf">{</span><span id="04d2" class="ma mb it lw b gy mg md l me mf">"case": casenumber (Integer),</span><span id="d2bd" class="ma mb it lw b gy mg md l me mf">"crime": text (String),</span><span id="b809" class="ma mb it lw b gy mg md l me mf">"occurred": date and time (String),</span><span id="6def" class="ma mb it lw b gy mg md l me mf">"comments": text (String),</span><span id="8eae" class="ma mb it lw b gy mg md l me mf">"building": place (String),</span><span id="a48a" class="ma mb it lw b gy mg md l me mf">"address": place (String),</span><span id="bf6a" class="ma mb it lw b gy mg md l me mf">"disposition": disposition (String),</span><span id="62e1" class="ma mb it lw b gy mg md l me mf">},</span></pre><p id="2b1c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在此期间，总共发生了大约1500个独特的事件，这些事件保存在一个JSON文件中。</p><p id="711b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">开始我们的项目，我们首先需要导入下面的包。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="0519" class="ma mb it lw b gy mc md l me mf"># Basic Analysis and Visualization<br/>import pandas as pd<br/>import numpy as np<br/>import matplotlib as mpl<br/>import matplotlib.pyplot as plt<br/>import math<br/>from datetime import timedelta</span><span id="335f" class="ma mb it lw b gy mg md l me mf"># Mapping<br/>import geopandas<br/>import geopy<br/>from geopy.geocoders import Nominatim<br/>import folium<br/>from geopy.extra.rate_limiter import RateLimiter<br/>from folium import plugins<br/>from folium.plugins import MarkerCluster</span><span id="d68a" class="ma mb it lw b gy mg md l me mf"># Statistical OLS Regression Analysis<br/>%matplotlib inline<br/>import statsmodels.api as sm<br/>from statsmodels.compat import lzip<br/>from statsmodels.formula.api import ols</span><span id="0a6d" class="ma mb it lw b gy mg md l me mf">#Scipy sklearn Predictions<br/>from sklearn.ensemble import GradientBoostingRegressor</span></pre><p id="b14a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">接下来，我们将所有事件从文件导入到程序中。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="4a18" class="ma mb it lw b gy mc md l me mf"># Pull in JSON and set index as case number (unique key)<br/>df = pd.read_json("MC.json",orient="records")<br/>df = df.set_index("case")<br/>df</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mh"><img src="../Images/481af91e067616b2a774e8d76d2d5f28.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z0VYFVpCMM3CyKfNlFEFRQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">生成的熊猫数据框</p></figure><p id="829b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们还应该转换我们的occurrence列，以使新的日期、时间和星期几列符合日期-时间模式。我们还应该从数据集中删除任何没有根据的事件。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="1b74" class="ma mb it lw b gy mc md l me mf"># Convert time objects<br/>df['occurred'] = pd.to_datetime(df['occurred'])<br/>df['date'] = [d.date() for d in df['occurred']]<br/>df['time'] = [d.time() for d in df['occurred']]<br/>df['day'] = df['occurred'].dt.day_name()<br/># Find Fractions of Day<br/>df['timeint'] = (df['occurred']-df['occurred'].dt.normalize()).dt.total_seconds()/timedelta(days=1).total_seconds()</span><span id="bd4e" class="ma mb it lw b gy mg md l me mf"># Remove unfounded events<br/>df = df[df['disposition'] != 'Unfounded']</span></pre><p id="685a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在让我们也为数据集获取地理数据。<a class="mi mj ep" href="https://medium.com/u/d4284ce02aec?source=post_page-----1d8db9c8b6e6--------------------------------" rel="noopener" target="_blank"> Abdishakur </a>有一篇很棒的文章<a class="ae lu" rel="noopener" target="_blank" href="/geocode-with-python-161ec1e62b89">在这里</a>我们可以跟随收集这些数据，实现如下。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="d011" class="ma mb it lw b gy mc md l me mf">locator = Nominatim(user_agent='myGeocoder')<br/>location = locator.geocode('Morgantown, West Virginia')</span><span id="cebe" class="ma mb it lw b gy mg md l me mf"># 1 - conveneint function to delay between geocoding calls<br/>geocode = RateLimiter(locator.geocode, min_delay_seconds=0.5)<br/># 2- - create location column<br/>df['location'] = df['address'].apply(geocode)<br/># 3 - create longitude, latitude and altitude from location column (returns tuple)<br/>df['point'] = df['location'].apply(lambda loc: tuple(loc.point) if loc else None)<br/># 4 - split point column into latitude, longitude and altitude columns and remove empty points<br/>df = df[df['point'].notnull()]<br/>df[['latitude', 'longitude', 'altitude']] = pd.DataFrame(df['point'].tolist(), index=df.index)<br/>df.head()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mh"><img src="../Images/fa25826890a28d6914bbf9ba0b7e7c76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vcVuP_-VA_3uiO6BaJx2Aw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">生成的熊猫数据框</p></figure></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><p id="90e0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">评估我们现在完整的数据集，我们可以开始注意到一些趋势。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="a2cf" class="ma mb it lw b gy mc md l me mf">df.groupby("crime")["crime"].count().sort_values()</span></pre><p id="85b9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里记录的大多数事件都是在酒精影响下做出错误决策的结果，在宿舍破坏大学财产，或在非法停车区如保留区停车。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="f187" class="ma mb it lw b gy mc md l me mf">VEHICLE ACCIDENT           28<br/>ALARM CONDITION            30<br/>LARCENY                    32<br/>FIRE ALARM                 43<br/>DESTRUCTION OF PROPERTY    55<br/>DRUG INCIDENT              69<br/>TALK WITH OFFICER          74<br/>ABCC VIOLATION             84<br/>ASSIST EMS POLICE          86<br/>BACK TICKET TOW            99</span></pre><p id="b68f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这些事件最常发生的地点也反映了向成熟和成年过渡的挑战，大多数发生在宿舍内。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="4249" class="ma mb it lw b gy mc md l me mf">df.groupby("building")["building"].count().sort_values()</span><span id="6134" class="ma mb it lw b gy mg md l me mf">BLUE LOT                                     21<br/>WVU MOUNTAINLAIR                             23<br/>WVU BOREMAN SOUTH                            23<br/>COLLEGE PARK                                 23<br/>WVU SENECA HALL                              25<br/>WVU POLICE DEPARTMENT                        28<br/>WVU SUMMIT HALL                              28<br/>WVU BROOKE TOWER                             29<br/>HEALTH SCIENCE CENTER                        55<br/>WVU DADISMAN HALL                            56</span></pre><p id="b639" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后，我们还可以注意到，一些报道的安全事件最多的日子也是非常规事件发生的日子，例如足球比赛日。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="487b" class="ma mb it lw b gy mc md l me mf">df.groupby("date")["date"].count().sort_values()</span><span id="061a" class="ma mb it lw b gy mg md l me mf">2019-11-01    21 # WVU vs Baylor<br/>2019-10-05    27 # WVU vs Texas<br/>2019-11-09    31 # WVU vs Texas Tech</span></pre></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><p id="f9eb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">分析完数据框后，现在让我们使用Folium在地图上可视化数据。以下代码在开放街道地图上绘制点，并带有发生事件类型的指示器。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="5aac" class="ma mb it lw b gy mc md l me mf"># Mark events with names on map<br/>m = folium.Map([39.645,-79.96], zoom_start=14)<br/>for index, row in df.iterrows():<br/>    folium.CircleMarker([row['latitude'], row['longitude']],<br/>                        radius=3,<br/>                        popup=row['crime'],<br/>                        fill_color="#3db7e4", # divvy color<br/>                       ).add_to(m)<br/>m</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mr"><img src="../Images/077fd8460249b6f91219a9ddffe67e08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QreCjWufTOuHGeLnK215hw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">生成的树叶地图</p></figure><p id="80bc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">虽然这些指标很有用，并且我们可以放大地图以查看它们的详细信息，但额外的热图将提高多个指标可能重叠的高频区域的可见性。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="bb04" class="ma mb it lw b gy mc md l me mf"># convert to (n, 2) nd-array format for heatmap<br/>dfmatrix = df[['latitude', 'longitude']].values</span><span id="eba1" class="ma mb it lw b gy mg md l me mf"># plot heatmap<br/>m.add_child(plugins.HeatMap(dfmatrix, radius=15))<br/>m</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ms"><img src="../Images/213ab1b1592030ce6e38f66ece7e83f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vNO5lpYXFV5AE0abF5vZKg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">突出显示高频区域的渲染热图</p></figure><p id="73cb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">从安全事件的渲染热图中，我们可以看到埃文斯代尔校园中靠近人口稠密的塔楼宿舍和足球场的高频率区域，以及靠近Frat Row和高街的市中心校园，那里有很多夜生活，这对于一个大学城来说并不奇怪。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><p id="8b9c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">早些时候，我们注意到安全事故最多的日子恰好是足球比赛日。我们的数据可以帮助评估最佳位置，为未来的游戏日提供紧急服务。最活跃的比赛是2019年11月9日对阵德州理工的比赛。我们可以用下面的代码过滤一天的数据集。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="9327" class="ma mb it lw b gy mc md l me mf">incidents_on_nov09 = df[df['date'] == pd.datetime(2019,11,9).date()]</span></pre><p id="575c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在让我们通过重用之前的脚本来可视化这些过滤后的事件。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="3f5a" class="ma mb it lw b gy mc md l me mf"># Map points of events<br/>m2 = folium.Map([39.645,-79.96], zoom_start=14)<br/>for index, row in incidents_on_nov09.iterrows():<br/>    folium.CircleMarker([row['latitude'], row['longitude']],<br/>                        radius=5,<br/>                        popup=row['crime'],<br/>                        fill_color="#3db7e4", # divvy color<br/>                       ).add_to(m2)<br/># convert to (n, 2) nd-array format for heatmap<br/>dfmatrix = incidents_on_nov09[['latitude', 'longitude']].values</span><span id="e7f0" class="ma mb it lw b gy mg md l me mf"># plot heatmap<br/>m2.add_child(plugins.HeatMap(dfmatrix, radius=15))<br/>m2</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mt"><img src="../Images/f7786905075fc5add4398beaf2e67ad4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8JT-gBzVvtyiZs_XFza6RQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">11月9日安全事件的渲染热图</p></figure><p id="e688" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以看到事件发生在整个城镇。使用这些事件的纬度和经度，我们可以找到最优资源分配的质心。如果我们有一辆救护车，为了最快的平均响应时间，将它放置在全天待命的频率加权的每个点的中间将是最有效的。我们可以用这个代码找到质心。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="7f25" class="ma mb it lw b gy mc md l me mf">lat = []<br/>long = []<br/>for index, row in incidents_on_nov09.iterrows():<br/>  lat.append(row["latitude"])<br/>  long.append(row["longitude"])</span><span id="c125" class="ma mb it lw b gy mg md l me mf">lat1=sum(lat)/len(lat)<br/>lat2=sum(long)/len(long)<br/>folium.CircleMarker([lat1,lat2],<br/>                        radius=5,<br/>                        popup="CENTER LOCATION",<br/>                        color='black',<br/>                        fill_color="#3db7e4", # divvy color<br/>                       ).add_to(m2)<br/>m2</span></pre><div class="kj kk kl km gt ab cb"><figure class="mu kn mv mw mx my mz paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/c2dfcace9f5de621f1462ecea6e83dfb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*9FOsPeGjhN6F4onlNWLsfw.png"/></div></figure><figure class="mu kn mv mw mx my mz paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/ede47c74d3d8cf8af55dec02839f138b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*jjbED-AC21QDGk9tCH-qXQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk na di nb nc translated">注意地图上的黑色圆圈——事件的质心</p></figure></div><p id="d342" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">上面地图中的黑色圆圈显示了11月9日的质心。如果我们要在未来的比赛日推出紧急服务，为了最快的平均响应速度，在Univeristy Avenue和Jones Avenue之间推出是值得的。</p><p id="05a4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我们想改变我们的时间框架呢？比赛结束后，比赛当天晚上的质心是多少？</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="dfe2" class="ma mb it lw b gy mc md l me mf">after9PM = incidents_on_nov09[incidents_on_nov09['time'] &gt;= pd.datetime(2019,11,9,21,0,0).time()]</span><span id="ce95" class="ma mb it lw b gy mg md l me mf">lat = []<br/>long = []<br/>for index, row in after9PM.iterrows():<br/>  lat.append(row["latitude"])<br/>  long.append(row["longitude"])</span><span id="9a7c" class="ma mb it lw b gy mg md l me mf">lat1=sum(lat)/len(lat)<br/>lat2=sum(long)/len(long)<br/>folium.CircleMarker([lat1,lat2],<br/>                        radius=5,<br/>                        popup="LATE HOURS LOCATION",<br/>                        color='red',<br/>                        fill_color="#3db7e4", # divvy color<br/>                       ).add_to(m2)<br/>m2</span></pre><div class="kj kk kl km gt ab cb"><figure class="mu kn mv mw mx my mz paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/9a10aeee7e808c2aa4c23061d6e45cd8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*CR-YuaEasNhYKd6DgxpUUw.png"/></div></figure><figure class="mu kn mv mw mx my mz paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/0facfba0eda1ca52ac470e00dd1ecd4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*Q8qkd4v6ZY9zppFI23Tbag.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk na di nb nc translated">红色圆圈是11月9日晚9点以后事件的重心</p></figure></div><p id="187c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请注意，现在最佳集结地转移到了更远的市中心，朝着第一街和生命科学大楼。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><p id="fee6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以使用时间序列数据和机器学习来预测下一次事件的位置吗？为了进一步研究这个问题，我们需要配置两个预测模型——一个用于纬度，一个用于经度。我们将使用“timeint”列，或时间间隔或一天中的一部分，以及scikit来使用梯度推进回归进行预测。下面的代码受到这个<a class="ae lu" href="https://scikit-learn.org/stable/auto_examples/ensemble/plot_gradient_boosting_quantile.html#sphx-glr-auto-examples-ensemble-plot-gradient-boosting-quantile-py" rel="noopener ugc nofollow" target="_blank">例子</a>的启发，它正在根据我们的数据开发一个预测模型。本教程并不打算完美地解释我们预测背后的数学，scikitlearn在这方面做得很好，但重要的是，我们正在使用数据集创建一个从均方误差得出的90%置信区间的函数。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="83e9" class="ma mb it lw b gy mc md l me mf">#----------------------------------------------------------------------<br/>#  First the noiseless case<br/>X = np.atleast_2d(df['timeint'].values).T</span><span id="540a" class="ma mb it lw b gy mg md l me mf"># Observations<br/>y = np.atleast_2d(df['latitude'].values).T</span><span id="2f7f" class="ma mb it lw b gy mg md l me mf"># Mesh the input space for evaluations of the real function, the prediction and<br/># its MSE<br/>xx = np.atleast_2d(np.linspace(0, 1, 913)).T<br/>xx = xx.astype(np.float32)</span><span id="d4bc" class="ma mb it lw b gy mg md l me mf">alpha = 0.95</span><span id="0376" class="ma mb it lw b gy mg md l me mf">clf = GradientBoostingRegressor(loss='quantile', alpha=alpha,<br/>                                n_estimators=250, max_depth=3,<br/>                                learning_rate=.1, min_samples_leaf=9,<br/>                                min_samples_split=9)</span><span id="1336" class="ma mb it lw b gy mg md l me mf">clf.fit(X, y)</span><span id="c654" class="ma mb it lw b gy mg md l me mf"># Make the prediction on the meshed x-axis<br/>y_upper = clf.predict(xx)</span><span id="b90e" class="ma mb it lw b gy mg md l me mf">clf.set_params(alpha=1.0 - alpha)<br/>clf.fit(X, y)</span><span id="400f" class="ma mb it lw b gy mg md l me mf"># Make the prediction on the meshed x-axis<br/>y_lower = clf.predict(xx)</span><span id="717b" class="ma mb it lw b gy mg md l me mf">clf.set_params(loss='ls')<br/>clf.fit(X, y)</span><span id="5fcf" class="ma mb it lw b gy mg md l me mf"># Make the prediction on the meshed x-axis<br/>y_pred = clf.predict(xx)</span><span id="c8ce" class="ma mb it lw b gy mg md l me mf"># Plot the function, the prediction and the 90% confidence interval based on<br/># the MSE<br/>fig = plt.figure()<br/>plt.figure(figsize=(20,10))<br/>plt.plot(X, y, 'b.', markersize=10, label=u'Observations')<br/>plt.plot(xx, y_pred, 'r-', label=u'Prediction')<br/>plt.plot(xx, y_upper, 'k-')<br/>plt.plot(xx, y_lower, 'k-')<br/>plt.fill(np.concatenate([xx, xx[::-1]]),<br/>         np.concatenate([y_upper, y_lower[::-1]]),<br/>         alpha=.5, fc='b', ec='None', label='90% prediction interval')<br/>plt.xlabel('$Time of Day by Fraction$')<br/>plt.ylabel('$Latitude$')<br/>plt.ylim(39.6, 39.7)<br/>plt.legend(loc='upper right')<br/>plt.show()</span><span id="53f6" class="ma mb it lw b gy mg md l me mf">ypred2 = y_pred</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nd"><img src="../Images/07d08c7131f6a9407a033e1717562b74.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8sKIef-lvzEE-J4ape3iHg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">上述模型的预测结果</p></figure><p id="1d66" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以看到，我们的数据在纬度轴上几乎是双峰的，一天中的时间并不能很好地预测南北方向的变化。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="f7eb" class="ma mb it lw b gy mc md l me mf">#----------------------------------------------------------------------<br/>#  First the noiseless case<br/>X = np.atleast_2d(df['timeint'].values).T</span><span id="90e3" class="ma mb it lw b gy mg md l me mf"># Observations<br/>y = np.atleast_2d(df['longitude'].values).T</span><span id="61cc" class="ma mb it lw b gy mg md l me mf"># Mesh the input space for evaluations of the real function, the prediction and<br/># its MSE<br/>xx = np.atleast_2d(np.linspace(0, 1, 913)).T<br/>xx = xx.astype(np.float32)</span><span id="2a21" class="ma mb it lw b gy mg md l me mf">alpha = 0.95</span><span id="fa35" class="ma mb it lw b gy mg md l me mf">clf = GradientBoostingRegressor(loss='quantile', alpha=alpha,<br/>                                n_estimators=250, max_depth=3,<br/>                                learning_rate=.1, min_samples_leaf=9,<br/>                                min_samples_split=9)</span><span id="cbe3" class="ma mb it lw b gy mg md l me mf">clf.fit(X, y)</span><span id="d620" class="ma mb it lw b gy mg md l me mf"># Make the prediction on the meshed x-axis<br/>y_upper = clf.predict(xx)</span><span id="7aae" class="ma mb it lw b gy mg md l me mf">clf.set_params(alpha=1.0 - alpha)<br/>clf.fit(X, y)</span><span id="4410" class="ma mb it lw b gy mg md l me mf"># Make the prediction on the meshed x-axis<br/>y_lower = clf.predict(xx)</span><span id="8cc1" class="ma mb it lw b gy mg md l me mf">clf.set_params(loss='ls')<br/>clf.fit(X, y)</span><span id="eb9e" class="ma mb it lw b gy mg md l me mf"># Make the prediction on the meshed x-axis<br/>y_pred = clf.predict(xx)</span><span id="3df3" class="ma mb it lw b gy mg md l me mf"># Plot the function, the prediction and the 90% confidence interval based on<br/># the MSE<br/>fig = plt.figure()<br/>plt.figure(figsize=(20,10))<br/>plt.plot(X, y, 'b.', markersize=10, label=u'Observations')<br/>plt.plot(xx, y_pred, 'r-', label=u'Prediction')<br/>plt.plot(xx, y_upper, 'k-')<br/>plt.plot(xx, y_lower, 'k-')<br/>plt.fill(np.concatenate([xx, xx[::-1]]),<br/>         np.concatenate([y_upper, y_lower[::-1]]),<br/>         alpha=.5, fc='b', ec='None', label='90% prediction interval')<br/>plt.xlabel('$Time of Day by Fraction$')<br/>plt.ylabel('$Longitude$')<br/>plt.ylim(-80, -79.9)<br/>plt.legend(loc='upper right')<br/>plt.show()</span><span id="9720" class="ma mb it lw b gy mg md l me mf">ypred1 = y_pred</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nd"><img src="../Images/113292766a4de35d730d35f013400534.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LtBYL70LKGa4SBACdiUhQw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">上述模型的预测结果</p></figure><p id="5aed" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">类似地，我们可以看到东经和西经的趋势几乎不存在，但是数据几乎没有分裂，并且具有更均匀分布的点。如果我们试图预测一天结束时的后续事件，我们也会期望注意到趋势的缺乏，并期望预测质心附近的安全事件，或经度和纬度的平均值。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="655a" class="ma mb it lw b gy mc md l me mf"># Map points of events<br/>m5 = folium.Map([39.645,-79.96], zoom_start=14)<br/>for i in range(len(ypred1)):<br/>    folium.CircleMarker([ypred2[i], ypred1[i]],<br/>                        radius=4,<br/>                        popup=str(i),<br/>                        fill_color="#3db7e4", # divvy color<br/>                       ).add_to(m5)<br/>m5</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ne"><img src="../Images/c150576d07d85eea9ab5d363c8cb3222.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Jsdy9ScKGuGhlv4nxtrJRg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">所有事件质心附近的预测事件</p></figure></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><p id="c20c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">评估我们数据的“预测”时间序列，除了证实安全事故发生时间与城镇平均位置之间缺乏因果关系之外，没有给出明确的结论。虽然这可能每天都有变化，或者在特殊情况下，我们确实注意到我们在纬度上的趋势显示双峰，或者南北摩根敦之间的部分区别。如果我们分别评估这两个区域，也许我们可以收集新的资源分配重点区域，例如北部备用位置和南部备用位置。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="6684" class="ma mb it lw b gy mc md l me mf">dfDowntown = df[df['latitude']&lt;=39.6425]</span></pre><p id="fefe" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以首先从上一个数据集中分离出近似函数线上的数据。然后，我们将仅根据市中心的数据再次完成我们的模型回归。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="50e5" class="ma mb it lw b gy mc md l me mf">#----------------------------------------------------------------------<br/>#  First the noiseless case<br/>X = np.atleast_2d(dfDowntown['timeint'].values).T</span><span id="b249" class="ma mb it lw b gy mg md l me mf"># Observations<br/>y = np.atleast_2d(dfDowntown['latitude'].values).T</span><span id="4a9d" class="ma mb it lw b gy mg md l me mf"># Mesh the input space for evaluations of the real function, the prediction and<br/># its MSE</span><span id="ce7f" class="ma mb it lw b gy mg md l me mf">xx = np.atleast_2d(np.linspace(0, 1, 535)).T<br/>xx = xx.astype(np.float32)</span><span id="7f42" class="ma mb it lw b gy mg md l me mf">alpha = 0.95</span><span id="51ba" class="ma mb it lw b gy mg md l me mf">clf = GradientBoostingRegressor(loss='quantile', alpha=alpha,<br/>                                n_estimators=250, max_depth=3,<br/>                                learning_rate=.1, min_samples_leaf=9,<br/>                                min_samples_split=9)</span><span id="5fe5" class="ma mb it lw b gy mg md l me mf">clf.fit(X, y)</span><span id="da58" class="ma mb it lw b gy mg md l me mf"># Make the prediction on the meshed x-axis<br/>y_upper = clf.predict(xx)</span><span id="9c63" class="ma mb it lw b gy mg md l me mf">clf.set_params(alpha=1.0 - alpha)<br/>clf.fit(X, y)</span><span id="d9e4" class="ma mb it lw b gy mg md l me mf"># Make the prediction on the meshed x-axis<br/>y_lower = clf.predict(xx)</span><span id="fcd0" class="ma mb it lw b gy mg md l me mf">clf.set_params(loss='ls')<br/>clf.fit(X, y)</span><span id="1eef" class="ma mb it lw b gy mg md l me mf"># Make the prediction on the meshed x-axis<br/>y_pred = clf.predict(xx)</span><span id="3073" class="ma mb it lw b gy mg md l me mf"># Plot the function, the prediction and the 90% confidence interval based on<br/># the MSE<br/>fig = plt.figure()<br/>plt.figure(figsize=(20,10))<br/>plt.plot(X, y, 'b.', markersize=10, label=u'Observations')<br/>plt.plot(xx, y_pred, 'r-', label=u'Prediction')<br/>plt.plot(xx, y_upper, 'k-')<br/>plt.plot(xx, y_lower, 'k-')<br/>plt.fill(np.concatenate([xx, xx[::-1]]),<br/>         np.concatenate([y_upper, y_lower[::-1]]),<br/>         alpha=.5, fc='b', ec='None', label='90% prediction interval')<br/>plt.xlabel('$Time of Day by Fraction$')<br/>plt.ylabel('$Latitude$')<br/>plt.ylim(39.6, 39.7)<br/>plt.legend(loc='upper right')<br/>plt.show()</span><span id="c308" class="ma mb it lw b gy mg md l me mf">ypred2 = y_pred</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nf"><img src="../Images/0a573404f0d3e94e2a704a93562caaa1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*82Guhzs2RFfj24O7L58sTA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">结果预测区间</p></figure><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="5863" class="ma mb it lw b gy mc md l me mf">#----------------------------------------------------------------------<br/>#  First the noiseless case<br/>X = np.atleast_2d(dfDowntown['timeint'].values).T</span><span id="9381" class="ma mb it lw b gy mg md l me mf"># Observations<br/>y = np.atleast_2d(dfDowntown['longitude'].values).T</span><span id="4278" class="ma mb it lw b gy mg md l me mf"># Mesh the input space for evaluations of the real function, the prediction and<br/># its MSE<br/>xx = np.atleast_2d(np.linspace(0, 1, 535)).T<br/>xx = xx.astype(np.float32)</span><span id="9089" class="ma mb it lw b gy mg md l me mf">alpha = 0.95</span><span id="5962" class="ma mb it lw b gy mg md l me mf">clf = GradientBoostingRegressor(loss='quantile', alpha=alpha,<br/>                                n_estimators=250, max_depth=3,<br/>                                learning_rate=.1, min_samples_leaf=9,<br/>                                min_samples_split=9)</span><span id="3b75" class="ma mb it lw b gy mg md l me mf">clf.fit(X, y)</span><span id="365d" class="ma mb it lw b gy mg md l me mf"># Make the prediction on the meshed x-axis<br/>y_upper = clf.predict(xx)</span><span id="4317" class="ma mb it lw b gy mg md l me mf">clf.set_params(alpha=1.0 - alpha)<br/>clf.fit(X, y)</span><span id="bfec" class="ma mb it lw b gy mg md l me mf"># Make the prediction on the meshed x-axis<br/>y_lower = clf.predict(xx)</span><span id="e393" class="ma mb it lw b gy mg md l me mf">clf.set_params(loss='ls')<br/>clf.fit(X, y)</span><span id="d2a4" class="ma mb it lw b gy mg md l me mf"># Make the prediction on the meshed x-axis<br/>y_pred = clf.predict(xx)</span><span id="e456" class="ma mb it lw b gy mg md l me mf"># Plot the function, the prediction and the 90% confidence interval based on<br/># the MSE<br/>fig = plt.figure()<br/>plt.figure(figsize=(20,10))<br/>plt.plot(X, y, 'b.', markersize=10, label=u'Observations')<br/>plt.plot(xx, y_pred, 'r-', label=u'Prediction')<br/>plt.plot(xx, y_upper, 'k-')<br/>plt.plot(xx, y_lower, 'k-')<br/>plt.fill(np.concatenate([xx, xx[::-1]]),<br/>         np.concatenate([y_upper, y_lower[::-1]]),<br/>         alpha=.5, fc='b', ec='None', label='90% prediction interval')<br/>plt.xlabel('$Time of Day by Fraction$')<br/>plt.ylabel('$Longitude$')<br/>plt.ylim(-80, -79.9)<br/>plt.legend(loc='upper right')<br/>plt.show()</span><span id="d128" class="ma mb it lw b gy mg md l me mf">ypred1 = y_pred</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nf"><img src="../Images/ec9b547fb37a7a60623aae5072bc8bb2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J1QSC6Q3uIRnBLoN4CbzFg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">结果预测区间</p></figure><p id="e219" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们现在可以注意到一个更紧密、更灵敏的预测和预测区间。绘制完成后，我们还可以看到我们可能希望评估安全响应可用性的重点领域。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="c765" class="ma mb it lw b gy mc md l me mf"># Map points of events<br/>m7 = folium.Map([39.645,-79.96], zoom_start=14)<br/>for i in range(len(ypred2)):<br/>    folium.CircleMarker([ypred2[i], ypred1[i]],<br/>                        radius=4,<br/>                        popup=str(i),<br/>                        fill_color="#3db7e4", # divvy color<br/>                       ).add_to(m7)<br/># convert to (n, 2) nd-array format for heatmap<br/>matrix = np.column_stack((ypred2,ypred1))</span><span id="dae3" class="ma mb it lw b gy mg md l me mf"># plot heatmap<br/>m7.add_child(plugins.HeatMap(matrix, radius=15))<br/>m7</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/e715555b8aef4c377f13fff3efa8c596.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V97rX3lLqi9wQHyKUsmh0Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">预测的安全服务需求</p></figure><p id="5cf3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在同样的事情也可以在埃文斯代尔发生。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="5585" class="ma mb it lw b gy mc md l me mf">dfEvansdale = df[df['latitude']&gt;39.6425]</span></pre><div class="kj kk kl km gt ab cb"><figure class="mu kn mv mw mx my mz paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/47e5785fec2dd33f70d27625e6991d30.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*QkyoQb8jvvb5MghMQo88bA.png"/></div></figure><figure class="mu kn mv mw mx my mz paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/458811407f00be9980ac3c7aedb70b59.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*347xxDTTL4dhyK1FgSseHw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk na di nb nc translated">埃文斯代尔纬度和经度的预测</p></figure></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nh"><img src="../Images/07c2b7bf5ea5bd4466d36663a1906809.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S13tsv5C1XpyMHeH8i4C2Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">埃文斯代尔校区及其附近的预测位置</p></figure><p id="346b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">从这些数据中，我们可以看到在埃文斯代尔园区提供安全服务的一个很好的位置是靠近塔楼宿舍和足球场附近的娱乐中心。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><p id="a1d9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">基于时间序列数据对机器学习进行建模可能非常具有挑战性，而在因果关系明确的情况下，实现起来要容易得多。这个项目未来的步骤可能是寻找更多的因果关系指标或进一步过滤数据，例如在比赛日或周末，甚至按事件的性质。这些数据的目的不是完美地预测接近随机的事件将在何时何地发生，而是为了更好地了解如何为事件做准备，并找到举办事件快速服务的良好位置。该应用程序还可以应用于多个其他来源，例如其他大学甚至城市的事件数据(如果API或数据报告可用的话)。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><p id="cdc1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如需进一步了解，请查看<a class="ae lu" href="https://medium.com/@willkeefe" rel="noopener">我的一些其他文章</a>和金融数据预测工具！请跟我来，让我知道你的想法！</p></div></div>    
</body>
</html>