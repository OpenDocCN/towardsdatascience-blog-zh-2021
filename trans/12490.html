<html>
<head>
<title>Fast Data Quality Framework on Great Expectations</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于远大期望的快速数据质量框架</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/fast-data-quality-framework-on-great-expectations-8921331a08c2?source=collection_archive---------19-----------------------#2021-12-21">https://towardsdatascience.com/fast-data-quality-framework-on-great-expectations-8921331a08c2?source=collection_archive---------19-----------------------#2021-12-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/010b123b699708688a0ed70d757c7bad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6r1MpAU9clOi1mcKm_6Cew.png"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">图片由<a class="ae kc" href="https://www.freepik.com/yourphoto" rel="noopener ugc nofollow" target="_blank"> your_photo </a>来自<a class="ae kc" href="https://www.freepik.com" rel="noopener ugc nofollow" target="_blank"> freepik </a></p></figure><p id="10c7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi lb translated"><span class="l lc ld le bm lf lg lh li lj di">在</span>我之前的<a class="ae kc" rel="noopener" target="_blank" href="/monitoring-data-quality-in-a-data-lake-using-great-expectations-and-allure-built-serverless-47fa1791af6a">文章</a>中，我解释了如何使用 Great Expectations (GE)和 Allure Serverless 在数据湖中构建和实现数据质量监控。虽然我描述的过程非常简单明了，但是手动实现需要大量的时间和资源，这就是为什么我提供了一种更快的方法来提高新环境中的数据质量。在本文中，我将讨论前一种方法的限制，并提供规避它们的方法。</p></div><div class="ab cl lk ll hu lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="ij ik il im in"><h1 id="4846" class="lr ls iq bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">这部作品的要点</h1><p id="26ff" class="pw-post-body-paragraph kd ke iq kf b kg mp ki kj kk mq km kn ko mr kq kr ks ms ku kv kw mt ky kz la ij bi translated">在整理这个简短的指南时，我的目标是让您能够减少重复的手工工作，并加速和简化诸如创建 AWS 资源、生成和上传必要的配置文件以及编写<a class="ae kc" href="https://provectus.com/data-quality-assurance/" rel="noopener ugc nofollow" target="_blank">数据 QA </a>测试等任务。</p><p id="68aa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了实现这一点，我们将选择不使用无服务器框架。相反，我们将应用 Terraform 脚本，并使用 Pandas Profiling 来基于分析报告生成数据测试。您所需要做的就是在 config 中设置变量并运行脚本。部署后，使用要检查数据质量的文件运行 Step 函数管道。</p><p id="2d74" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请记住，您的输入数据很重要。我们在亚马逊 S3 使用一个数据湖，每周安排和运行数据检查。我们不使用历史数据和筛选数据，只使用当前 DAG 中正在处理的数据。</p><h1 id="4e5e" class="lr ls iq bd lt lu mu lw lx ly mv ma mb mc mw me mf mg mx mi mj mk my mm mn mo bi translated">分析和生成测试</h1><p id="d333" class="pw-post-body-paragraph kd ke iq kf b kg mp ki kj kk mq km kn ko mr kq kr ks ms ku kv kw mt ky kz la ij bi translated">在我们之前的实现中，我们使用 Pandas Profiling 进行分析，并对测试寄予厚望，如下所示:</p><blockquote class="mz na nb"><p id="0d1e" class="kd ke nc kf b kg kh ki kj kk kl km kn nd kp kq kr ne kt ku kv nf kx ky kz la ij bi translated"><em class="iq">并行运行 AWS Lambda，对每个数据集使用 Pandas Profiling 和 GE 测试套件，并将每个数据集存储/服务为静态 S3 网站。</em></p></blockquote><p id="96aa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">阶跃函数是这样工作的:</p><figure class="nh ni nj nk gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ng"><img src="../Images/ae5cc0d80a02e5d59b9d9c78cca47a9a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*F0wVVHeGszjz63th"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">作者图片</p></figure><p id="dc97" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，我们将把概要分析和测试分解成单独的步骤。首先，让我们检查配置文件数据集。</p><figure class="nh ni nj nk gt jr"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="1397" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们需要基于分析结果生成一个测试套件。因为 Pandas Profiling 默认情况下保存没有失败预期的套件，所以我们将无法配置。让我们通过添加以下内容来覆盖期望类:</p><figure class="nh ni nj nk gt jr"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="2628" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">之后，您将能够为飞行测试生成器配置您自己的预期:</p><figure class="nh ni nj nk gt jr"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="ac74" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">确保使用新的期望处理器，这样套件就可以保存在亚马逊 S3 上:</p><figure class="nh ni nj nk gt jr"><div class="bz fp l di"><div class="nl nm l"/></div></figure><h1 id="213d" class="lr ls iq bd lt lu mu lw lx ly mv ma mb mc mw me mf mg mx mi mj mk my mm mn mo bi translated">运行数据质量保证测试</h1><p id="e9ac" class="pw-post-body-paragraph kd ke iq kf b kg mp ki kj kk mq km kn ko mr kq kr ks ms ku kv kw mt ky kz la ij bi translated">接下来，让我们弄清楚如何用 GE 引擎开始运行测试。</p><figure class="nh ni nj nk gt jr"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="fdd9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来的两步类似于我在<a class="ae kc" rel="noopener" target="_blank" href="/monitoring-data-quality-in-a-data-lake-using-great-expectations-and-allure-built-serverless-47fa1791af6a">之前的解决方案</a>中描述的步骤:在 Allure Report 中创建一个报表，并将一个数据透视表推送到 Amazon DynamoDB。如果省略这些步骤，为每个数据源创建并行迭代的 StepFunctions 管道将如下所示:</p><figure class="nh ni nj nk gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nn"><img src="../Images/b1d32fc2c84a26a7e709063524b85cdb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*BIvWDGSj64fGqug_"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">作者图片</p></figure><p id="98d3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要运行管道，需要使用这个模板:<em class="nc"> file_path </em>和<em class="nc">new _ expectation</em>bool value，默认为“true”——它会为每次运行创建一个新的期望套件。您也可以运行它一次，并将其设置为“false”来开始使用这个测试套件。</p><figure class="nh ni nj nk gt jr"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="ee67" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这只是一个大概的概念。现在，让我们谈谈使用 Terraform 和部署我们的解决方案。为了解释这一部分，我将火炬传递给普罗维特斯的开发人员<a class="ae kc" href="https://www.linkedin.com/in/yegor-gorodov-33556368/" rel="noopener ugc nofollow" target="_blank">叶戈尔·格罗多夫</a>。</p></div><div class="ab cl lk ll hu lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="ij ik il im in"><h1 id="b856" class="lr ls iq bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">DevOps 支持</h1><h2 id="ea29" class="no ls iq bd lt np nq dn lx nr ns dp mb ko nt nu mf ks nv nw mj kw nx ny mn nz bi translated">部署</h2><p id="389a" class="pw-post-body-paragraph kd ke iq kf b kg mp ki kj kk mq km kn ko mr kq kr ks ms ku kv kw mt ky kz la ij bi translated">我们选择使用 AWS 作为平台来运行我们的快速数据质量保证解决方案。它为我们提供了构建可扩展基础设施和以不同方式管理基础设施的所有必要服务。这里我们有两个选择:</p><ol class=""><li id="2a02" class="oa ob iq kf b kg kh kk kl ko oc ks od kw oe la of og oh oi bi translated">云的形成</li><li id="8b23" class="oa ob iq kf b kg oj kk ok ko ol ks om kw on la of og oh oi bi translated">将（行星）地球化（以适合人类居住）</li></ol><p id="31d6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">目前，我们使用 Terraform 作为主要工具来构建和管理可再生的基础设施。当然，使用它有好处也有坏处，但它非常适合快速数据 QA。</p><h2 id="dae6" class="no ls iq bd lt np nq dn lx nr ns dp mb ko nt nu mf ks nv nw mj kw nx ny mn nz bi translated">第 1 步—又名“手持”</h2><p id="cbd3" class="pw-post-body-paragraph kd ke iq kf b kg mp ki kj kk mq km kn ko mr kq kr ks ms ku kv kw mt ky kz la ij bi translated">至此，我们在 AWS 的教育账号中已经有了一个运行快速的数据 QA MVP。我们应该能够在我们的主账户/独立账户中复制它。为此，我们将检查基础设施的哪些部分需要使用 Terraform 来描述。在我们的案例中，它们是:</p><ul class=""><li id="e210" class="oa ob iq kf b kg kh kk kl ko oc ks od kw oe la oo og oh oi bi translated">S3 配置的桶</li><li id="8b8f" class="oa ob iq kf b kg oj kk ok ko ol ks om kw on la oo og oh oi bi translated">DynamoDB 表</li><li id="1f6b" class="oa ob iq kf b kg oj kk ok ko ol ks om kw on la oo og oh oi bi translated">ECR(三个回购，每个 lambda 一个)</li><li id="2d58" class="oa ob iq kf b kg oj kk ok ko ol ks om kw on la oo og oh oi bi translated">Lambdas(每步一个，总共三个)</li><li id="4690" class="oa ob iq kf b kg oj kk ok ko ol ks om kw on la oo og oh oi bi translated">阶跃函数</li><li id="cf94" class="oa ob iq kf b kg oj kk ok ko ol ks om kw on la oo og oh oi bi translated">SSM 参数存储</li></ul><p id="bde0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦我们理解了我们需要描述哪些资源，就该创建一个新的 Terraform 项目了。在常规的“terraform init”之前，我们需要添加一个 AWS 提供者。​</p><p id="baa7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在 AWS 中，每个资源都有自己的标识符。它可以是“名称”、“id”、“arn”或任何类似的标识符。我们有标识符的键和标识符本身；此外，我们需要在 Terraform 脚本中正确命名“resource ”,以便我们可以命令:“Terraform，请将名为‘my resource’的资源导入到‘terra form _ resource’。my resource’。”之后，我们可以简单地将导入的状态复制到 Terraform 脚本中，瞧！这一资源现在由 Terraform 管理。</p><h2 id="c25d" class="no ls iq bd lt np nq dn lx nr ns dp mb ko nt nu mf ks nv nw mj kw nx ny mn nz bi translated">步骤 2 —参数化</h2><p id="bfa6" class="pw-post-body-paragraph kd ke iq kf b kg mp ki kj kk mq km kn ko mr kq kr ks ms ku kv kw mt ky kz la ij bi translated">一旦我们导入了 AWS 资源并且它们由 Terraform 管理，我们需要在运行之前配置 GreatExpectation 库。GE 的常规方法是将配置和插件文件存储在特定的 S3 键下。所以，让我们参数化和模板化它们。</p><p id="2136" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi">​</p><p id="eefe" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先是“great _ expecations.yml”文件。这里我们只需要模板化一个参数—“bucket _ name”，如下所示:</p><figure class="nh ni nj nk gt jr"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="7c83" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们有一组 GreatExpectation 文件，如“插件”和“自定义样式”。我们应该照原样复制它们，但把它们存放在一个结构僵硬的 S3 桶里。最好的方法是在 Terraform 目录中复制一个所需的文件结构，然后使用带有模板化密钥路径的“aws_s3_bucket_object”。</p><figure class="nh ni nj nk gt jr"><div class="bz fp l di"><div class="nl nm l"/></div></figure><h2 id="85c1" class="no ls iq bd lt np nq dn lx nr ns dp mb ko nt nu mf ks nv nw mj kw nx ny mn nz bi translated">第 3 步— CI</h2><p id="9456" class="pw-post-body-paragraph kd ke iq kf b kg mp ki kj kk mq km kn ko mr kq kr ks ms ku kv kw mt ky kz la ij bi translated">我们使用 Git 作为版本控制系统。我们将代码库存储在我们自己的 GitLab 服务器上。</p><p id="4c45" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为我们有三个 lambdas，每个都需要自己的 docker 映像，所以我们需要一个地方来创建这些 docker 并将其推送到 ECR。为此，我们将使用 Gitlab CI Runner。有几个基于 Terraform 的开源解决方案，但它们都提供了我们不需要的功能。相反，我们决定建立一个简单的“项目内”地形模块，包括:</p><ul class=""><li id="3874" class="oa ob iq kf b kg kh kk kl ko oc ks od kw oe la oo og oh oi bi translated">VPC 和网络详细信息</li><li id="9ed4" class="oa ob iq kf b kg oj kk ok ko ol ks om kw on la oo og oh oi bi translated">带有“launch_template”的 AWS 自动缩放组</li><li id="4ded" class="oa ob iq kf b kg oj kk ok ko ol ks om kw on la oo og oh oi bi translated">仅允许 ECR 操作的 CI 用户和 IAM 角色</li></ul><p id="b00e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> VPC </strong></p><p id="2ede" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们只需要一个基本的 VPC，带有“aws_internet_gateway”，公共的“aws_subnet”，“aws_route_table”，“aws_route”，“aws_route_table_association”，以及带有 egress 的安全组。</p><figure class="nh ni nj nk gt jr"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="5d29" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">带“launch_template”的 AWS 自动缩放组</strong></p><p id="9ea6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">由于我们不打算使用 Ansible 这样的供应工具，我们决定将“aws_launch_template”与“aws_autoscaling_group”和一个简单的<em class="nc"> sh 模板</em>一起使用，该模板由 Terraform 模板化并在启动时运行。这个脚本安装 docker、docker-machine、gitlab-runner 二进制文件，并运行这个 bin 在 gitlab 服务器上注册 runner。</p><figure class="nh ni nj nk gt jr"><div class="bz fp l di"><div class="nl nm l"/></div></figure><h1 id="208b" class="lr ls iq bd lt lu mu lw lx ly mv ma mb mc mw me mf mg mx mi mj mk my mm mn mo bi translated">GitLab Runner</h1><ul class=""><li id="30bc" class="oa ob iq kf b kg mp kk mq ko op ks oq kw or la oo og oh oi bi translated">安装转轮</li></ul><figure class="nh ni nj nk gt jr"><div class="bz fp l di"><div class="nl nm l"/></div></figure><ul class=""><li id="c327" class="oa ob iq kf b kg kh kk kl ko oc ks od kw oe la oo og oh oi bi translated">登记赛跑者</li></ul><figure class="nh ni nj nk gt jr"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="853f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在应用了一个 GitLab-CI 模块后，我们可以在 GitLab UI 中看到一个注册的 runner，我们准备创建一个“gitlab_ci.yml”文件，该文件带有构建 docker 映像并将其推送到 ECR 的指令。此外，我们需要向 CI 管道传递额外的 env 变量，以参数化管道的每个阶段。为此，使用以下 Terraform 代码:</p><figure class="nh ni nj nk gt jr"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="ab64" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">仅允许 ECR 操作的 CI 用户和 IAM 角色</strong></p><p id="3f99" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们不想给那些只使用管道 CI 部分的用户太多的访问权限。为了限制访问，我们只需要创建一个具有 ECR 策略的 AWS 用户:</p><figure class="nh ni nj nk gt jr"><div class="bz fp l di"><div class="nl nm l"/></div></figure><h2 id="7b37" class="no ls iq bd lt np nq dn lx nr ns dp mb ko nt nu mf ks nv nw mj kw nx ny mn nz bi translated">第四步——总结</h2><p id="95b4" class="pw-post-body-paragraph kd ke iq kf b kg mp ki kj kk mq km kn ko mr kq kr ks ms ku kv kw mt ky kz la ij bi translated">现在，我们有:</p><ul class=""><li id="e9a3" class="oa ob iq kf b kg kh kk kl ko oc ks od kw oe la oo og oh oi bi translated">Gitlab CI 模块</li><li id="5284" class="oa ob iq kf b kg oj kk ok ko ol ks om kw on la oo og oh oi bi translated">带有 lambdas 等的主模块。</li><li id="982b" class="oa ob iq kf b kg oj kk ok ko ol ks om kw on la oo og oh oi bi translated">根模块具有上述两个模块，一个管理远程状态，以及模块和提供者的变量</li></ul><p id="0696" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">以上所有内容都允许我们执行以下用例:</p><ol class=""><li id="7c7a" class="oa ob iq kf b kg kh kk kl ko oc ks od kw oe la of og oh oi bi translated">向 GreatExpectation 测试套件添加元素或对其进行更改</li><li id="5406" class="oa ob iq kf b kg oj kk ok ko ol ks om kw on la of og oh oi bi translated">合并对特定 Git 分支的更改</li><li id="b1d4" class="oa ob iq kf b kg oj kk ok ko ol ks om kw on la of og oh oi bi translated">Gitlab CI 运行一个管道，打包一个新的 Docker 映像并将其推送到 AWS ECR</li><li id="7737" class="oa ob iq kf b kg oj kk ok ko ol ks om kw on la of og oh oi bi translated">更改 Terraform 中的 docker_image 变量</li><li id="2771" class="oa ob iq kf b kg oj kk ok ko ol ks om kw on la of og oh oi bi translated">应用地形</li></ol><h1 id="df07" class="lr ls iq bd lt lu mu lw lx ly mv ma mb mc mw me mf mg mx mi mj mk my mm mn mo bi translated">结论</h1><figure class="nh ni nj nk gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi os"><img src="../Images/c17f3ae62bd91163efd77929018039c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*KHcPr0mmUFMd2uQM"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">作者图片</p></figure><p id="6f86" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最终的结果是，我们得到了一个点击式的 Terraform 脚本，可以很容易地为新项目进行配置。一旦我们运行它，我们将有一个基于 Lambda/Step 函数的现成的数据质量管道，可以与任何 BI 仪表板工具一起使用。</p><h2 id="997c" class="no ls iq bd lt np nq dn lx nr ns dp mb ko nt nu mf ks nv nw mj kw nx ny mn nz bi translated">要了解更多关于 Provectus 数据质量保证实践的信息，请访问<a class="ae kc" href="https://provectus.com/data-quality-assurance/" rel="noopener ugc nofollow" target="_blank">网页</a></h2></div></div>    
</body>
</html>