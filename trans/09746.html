<html>
<head>
<title>Three Mysterious Behaviours of Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python的三个神秘行为</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/three-mysterious-behaviours-of-python-95c9dffa88fe?source=collection_archive---------12-----------------------#2021-09-12">https://towardsdatascience.com/three-mysterious-behaviours-of-python-95c9dffa88fe?source=collection_archive---------12-----------------------#2021-09-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/1226b4487e79a5bca44020815c35be11.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*neRHnOeJh9qCCYL_TfBqwA.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">图片来自<a class="ae jg" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=931706" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>的<a class="ae jg" href="https://pixabay.com/photos/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=931706" rel="noopener ugc nofollow" target="_blank">免费照片</a></p></figure><div class=""/><div class=""><h2 id="7ce1" class="pw-subtitle-paragraph kg ji jj bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dk translated">字典、Try Except和For-Loop的意外运行结果</h2></div><p id="bbc4" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我最喜欢的休闲活动之一是在Stack Overflow上闲逛。那边有很多关于Python的有趣问题。的确，有些问题我们可能一辈子都不会遇到。但是背后的知识还是挺有意思的，甚至比问题本身更有意思。</p><p id="cc68" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在本文中，我将挑选Python中的三种“神秘”行为，并尝试解释它们。希望这些知识能在一些“神秘”的方面帮助到某人:)</p><h1 id="4444" class="lu lv jj bd lw lx ly lz ma mb mc md me kp mf kq mg ks mh kt mi kv mj kw mk ml bi translated">1.神秘的字典键</h1><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/4ccdf8f5efcd1eb8f56f792a2f1585a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gQzap3xFnX_H3ePvWOy8Pg.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">图片由<a class="ae jg" href="https://pixabay.com/users/pixel2013-2364555/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=1809653" rel="noopener ugc nofollow" target="_blank">s . Hermann&amp;f . Richter</a>来自<a class="ae jg" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=1809653" rel="noopener ugc nofollow" target="_blank"> Pixabay </a></p></figure><p id="9f4e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你知道Python字典可以使用任何可散列的对象作为键吗？是的，这意味着我们甚至可以用数字作为密钥。有人可能认为这是一个“好”主意，因为我们可以使用括号中的表达式。不，请不要。我带你去看。</p><p id="76ab" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们定义一个使用integer、float和string作为键的字典。按意思都是“1”。</p><pre class="mm mn mo mp gt mu mt mv mw aw mx bi"><span id="f0e8" class="my lv jj mt b gy mz na l nb nc">my_dict = {<br/>    1: 'one (integar)',<br/>    '1': 'one (string)',<br/>    1.0: 'one point zero (float)'<br/>}</span></pre><p id="58fa" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，让我们尝试使用键来获取值。</p><pre class="mm mn mo mp gt mu mt mv mw aw mx bi"><span id="69c8" class="my lv jj mt b gy mz na l nb nc">my_dict[1]<br/>my_dict['1']<br/>my_dict[1.0]</span></pre><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/873915f39de7939dd392822c3fbd57c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:782/format:webp/1*sZfSUuGYqmCvBJ0hkSlQDg.png"/></div></figure><p id="cc6c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">等等，第一个不对。看来<code class="fe mq mr ms mt b">my_dict[1]</code>的值已经被<code class="fe mq mr ms mt b">my_dict[1.0]</code>覆盖了。让我们尝试不同的顺序来验证它。</p><pre class="mm mn mo mp gt mu mt mv mw aw mx bi"><span id="a2eb" class="my lv jj mt b gy mz na l nb nc">my_dict = {<br/>    1.0: 'one point zero (float)',<br/>    1: 'one (integar)',<br/>    '1': 'one (string)'<br/>}</span></pre><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/15cc0455d682e9b25471007c9cc4e153.png" data-original-src="https://miro.medium.com/v2/resize:fit:770/format:webp/1*p7YeFT128wvaysvKqc3TAg.png"/></div></figure><p id="d1f3" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这一次，<code class="fe mq mr ms mt b">my_dict[1]</code>的值覆盖了<code class="fe mq mr ms mt b">my_dict[1.0]</code>。所以后面谁定义谁就会覆盖前面的。这意味着键<code class="fe mq mr ms mt b">1</code>和<code class="fe mq mr ms mt b">1.0</code>是相同的。</p><h2 id="f327" class="my lv jj bd lw nf ng dn ma nh ni dp me lh nj nk mg ll nl nm mi lp nn no mk np bi translated">背后的原因</h2><p id="b42a" class="pw-post-body-paragraph ky kz jj la b lb nq kk ld le nr kn lg lh ns lj lk ll nt ln lo lp nu lr ls lt im bi translated">我们先来看看Python官方文档:</p><blockquote class="nv nw nx"><p id="18fe" class="ky kz ny la b lb lc kk ld le lf kn lg nz li lj lk oa lm ln lo ob lq lr ls lt im bi translated"><code class="fe mq mr ms mt b"><strong class="la jk">hash</strong></code>(对象)</p><p id="19fa" class="ky kz ny la b lb lc kk ld le lf kn lg nz li lj lk oa lm ln lo ob lq lr ls lt im bi translated">返回对象的哈希值(如果有的话)。哈希值是整数。它们用于在字典查找过程中快速比较字典键。<strong class="la jk">比较相等的数值具有相同的哈希值(即使它们是不同的类型，如1和1.0的情况)。</strong></p></blockquote><p id="5433" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">它基本上已经说明了原因。为了便于比较，我们传入的字典的键将被散列，不幸的是，一定数量的不同类型的散列值是相同的。我们可以证实这一点。</p><pre class="mm mn mo mp gt mu mt mv mw aw mx bi"><span id="e6d7" class="my lv jj mt b gy mz na l nb nc">print(hash(1))<br/>print(hash(1.0))<br/>print(hash('1'))</span></pre><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/283541917bcb10595d6e4bb282ab5a56.png" data-original-src="https://miro.medium.com/v2/resize:fit:482/format:webp/1*XPjEeUeI6HLUcwjc43_1iQ.png"/></div></figure><p id="fa32" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">事实上，这并不是Python独有的，在Java中也是如此。如果你实现了<code class="fe mq mr ms mt b">hashCode</code>，那么为了让事情正常工作，你必须确保<code class="fe mq mr ms mt b">x.equals(y)</code>隐含了<code class="fe mq mr ms mt b">x.hashCode() == y.hashCode()</code>。</p><p id="6cc7" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">回到Python，<code class="fe mq mr ms mt b">1.0 == 1</code>在Python中是真的。因此，必须实现哈希函数来确保<code class="fe mq mr ms mt b">hash(1.0) == hash(1)</code>。字典键的神秘行为是它的“副作用”。</p><h2 id="d1f9" class="my lv jj bd lw nf ng dn ma nh ni dp me lh nj nk mg ll nl nm mi lp nn no mk np bi translated">另一个问题</h2><p id="93e3" class="pw-post-body-paragraph ky kz jj la b lb nq kk ld le nr kn lg lh ns lj lk ll nt ln lo lp nu lr ls lt im bi translated">基于以上事实，你还认为使用表达式作为字典键可以吗？不，这还是个坏主意。让我们看看下面的例子。</p><pre class="mm mn mo mp gt mu mt mv mw aw mx bi"><span id="d44e" class="my lv jj mt b gy mz na l nb nc">print(hash(10.0 - 9.2))<br/>print(hash(0.8))</span></pre><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div class="gh gi od"><img src="../Images/2765dcf97314f91a5c49bb79532f8828.png" data-original-src="https://miro.medium.com/v2/resize:fit:546/format:webp/1*_BmW45Xess4zMxZYHVhhUw.png"/></div></figure><p id="9d48" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，可以预见，下面的例子将不会工作。</p><pre class="mm mn mo mp gt mu mt mv mw aw mx bi"><span id="190d" class="my lv jj mt b gy mz na l nb nc">my_dict = {0.8: 'zero point eight'}<br/>my_dict[10.0 - 9.2]</span></pre><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oe"><img src="../Images/b56d71e5d82d0c8b9f13a0a7855d97d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1376/format:webp/1*IghVOh0VJ0EUgEHnexOMDg.png"/></div></div></figure><p id="4be1" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这一次，这两个散列函数的值是不同的。为什么？他们不是同一个数字0.8吗？号<code class="fe mq mr ms mt b">10.0 — 9.2</code>其实不完全是<code class="fe mq mr ms mt b">0.8</code>。这是所有平台上典型的二进制浮点运算问题。Python给出了以下文档来澄清这个问题。<a class="ae jg" href="https://docs.python.org/3/tutorial/floatingpoint.html" rel="noopener ugc nofollow" target="_blank">https://docs.python.org/3/tutorial/floatingpoint.html</a></p><p id="9e11" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，请不要使用数字作为字典键。</p><h1 id="99d8" class="lu lv jj bd lw lx ly lz ma mb mc md me kp mf kq mg ks mh kt mi kv mj kw mk ml bi translated">2.Try Except块中的神秘返回</h1><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/0eed3cc25849dc3a1749d746975e5f02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*318GS8Zm-I5olEHbdEIqMQ.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">图片来自<a class="ae jg" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=6124033" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>的<a class="ae jg" href="https://pixabay.com/users/fotomek-7986133/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=6124033" rel="noopener ugc nofollow" target="_blank"> Thomas Malyska </a></p></figure><p id="88d2" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我打赌你知道Python中的Try Except块。在大多数编程语言中，处理异常是很常见的。在Try和Except之后，我们还可以放一个可选的Finally块。</p><p id="411d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们知道，无论Try块中是否发生了错误，Finally块都会被执行。但是，如果我们在Try块中有一个return语句，并且在Finally块中添加了另一个return语句，该怎么办呢？</p><p id="cede" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">直观上来说，如果Try块中的代码没有问题，并且到达了return语句，那么这个函数就应该执行完了，对吗？但是，让我们看看下面的例子。</p><pre class="mm mn mo mp gt mu mt mv mw aw mx bi"><span id="e099" class="my lv jj mt b gy mz na l nb nc">def my_func():<br/>    try:<br/>        return 'in try'<br/>    finally:<br/>        return 'in finally'</span><span id="ec36" class="my lv jj mt b gy of na l nb nc">my_func()</span></pre><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div class="gh gi og"><img src="../Images/a422bbc64d7a29b36ef71c386b511056.png" data-original-src="https://miro.medium.com/v2/resize:fit:582/format:webp/1*aXYZgZfB1ZtAjt-1G5bo3g.png"/></div></figure><p id="e3c1" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">它显示返回“in finally”而不是“in try”。所以，已经证明，即使Try块中有return语句，Finally块中的return语句仍然会被执行。也许下面的例子会是一个更好的例子。</p><pre class="mm mn mo mp gt mu mt mv mw aw mx bi"><span id="4b70" class="my lv jj mt b gy mz na l nb nc">my_string = '123'</span><span id="b752" class="my lv jj mt b gy of na l nb nc">def my_func():<br/>    global my_string<br/>    try:<br/>        return 'in try'<br/>    finally:<br/>        my_string = 'abc'</span><span id="83be" class="my lv jj mt b gy of na l nb nc">print(my_func())<br/>print(my_string)</span></pre><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/9e6c30d89790949ecf616b7cdf4c4f15.png" data-original-src="https://miro.medium.com/v2/resize:fit:588/format:webp/1*w-ylEUTIKu8Eg4JYmVfhcg.png"/></div></figure><p id="2d68" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这个例子中，我们在Try块中有一个return语句，但是在Finally块中没有return语句。相反，我们在Finally块中重新分配一个全局字符串变量。然后，可以看到Try块中的return语句已经被正确执行。同时，Finally块中的代码也被执行。</p><p id="e688" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请注意，无论发生什么情况，Finally块中的代码都将被执行。</p><h1 id="34cf" class="lu lv jj bd lw lx ly lz ma mb mc md me kp mf kq mg ks mh kt mi kv mj kw mk ml bi translated">3.神秘的For循环赋值</h1><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/6c1ff6fd78f5e19c7e19472a7f699b5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3KU8CzS4nzTeS3CG25mwOw.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">图片来自<a class="ae jg" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=2278471" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>的<a class="ae jg" href="https://pixabay.com/users/csliaw-5258730/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=2278471" rel="noopener ugc nofollow" target="_blank">史蒂文廖</a></p></figure><p id="b0f4" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在Python中，没有什么比For循环更常见的了。在Python中，无论你是数据科学家还是软件工程师，我们到处都使用For-Loop。</p><p id="1488" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你知道如何循环一个字符串来逐个打印字符吗？解决方法之一是使用<code class="fe mq mr ms mt b">enumerate()</code>功能。它会将字符串转换成带有索引的字符列表。</p><pre class="mm mn mo mp gt mu mt mv mw aw mx bi"><span id="e81a" class="my lv jj mt b gy mz na l nb nc">my_string = 'Chris'</span><span id="2330" class="my lv jj mt b gy of na l nb nc">for i, value in enumerate(my_string):<br/>    print(i, value)</span></pre><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/5072aeea571118a193fc7b1816f55e42.png" data-original-src="https://miro.medium.com/v2/resize:fit:740/format:webp/1*jNFI8NrSq5G5YhY57rX2Dg.png"/></div></figure><p id="1b2f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是，你知道For循环有一个非常特别的用法吗？看看下面的例子。</p><pre class="mm mn mo mp gt mu mt mv mw aw mx bi"><span id="ac22" class="my lv jj mt b gy mz na l nb nc">my_dict = {}</span><span id="10f8" class="my lv jj mt b gy of na l nb nc">for i, my_dict[i] in enumerate(my_string):<br/>    pass</span></pre><p id="dcc0" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你认为它会做什么？这段代码会抛出错误吗？直觉上，<code class="fe mq mr ms mt b">my_dict[i]</code>尚未初始化，因此可能会出现“KeyError”。但是让我们来看看执行结果。</p><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/a2ae8c8f158c688990700298b0381135.png" data-original-src="https://miro.medium.com/v2/resize:fit:842/format:webp/1*dELMrId6S1cwCPuIax43tg.png"/></div></figure><p id="dfcd" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">没有错误，我们的字典已经被赋予了字符串中的字符！怎么会这样</p><p id="8410" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">事实上，我们放在<code class="fe mq mr ms mt b">for ... in</code>之间的变量在Python语法中被称为“目标”。对于每次迭代，它将被赋予来自iterables的值。所以上面的For-Loop相当于做了下面的<strong class="la jk"> <em class="ny">(下面的代码是伪代码出于说明目的，不能执行)</em> </strong>。</p><pre class="mm mn mo mp gt mu mt mv mw aw mx bi"><span id="80d1" class="my lv jj mt b gy mz na l nb nc">For each iteration:<br/>i = next(enumerate(my_string)).index<br/>my_dict[i] = next(enumerate(my_string)).value</span></pre><p id="ad67" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，字典<code class="fe mq mr ms mt b">my_dict</code>由For循环填充，即使我们在For循环中什么也没做。</p><h1 id="e0db" class="lu lv jj bd lw lx ly lz ma mb mc md me kp mf kq mg ks mh kt mi kv mj kw mk ml bi translated">摘要</h1><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/3ff35f1b5e6d07cf8d9d5389d74b7003.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5lYODjq8UGDAmChmy0uoZA.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">图片来自<a class="ae jg" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=6603726" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>的<a class="ae jg" href="https://pixabay.com/users/tekhnika-23276062/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=6603726" rel="noopener ugc nofollow" target="_blank">автошкола</a></p></figure><p id="2e50" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在本文中，我介绍了Python中的3种意外行为。希望这些有意思。如果这些知识在某些方面对你有帮助，那就太好了！</p><p id="aeba" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你觉得这篇文章中的例子很有趣，我会在以后找到更多这样的例子和技巧！</p><div class="is it gp gr iu ok"><a href="https://medium.com/@qiuyujx/membership" rel="noopener follow" target="_blank"><div class="ol ab fo"><div class="om ab on cl cj oo"><h2 class="bd jk gy z fp op fr fs oq fu fw ji bi translated">通过我的推荐链接加入灵媒-陶</h2><div class="or l"><h3 class="bd b gy z fp op fr fs oq fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="os l"><p class="bd b dl z fp op fr fs oq fu fw dk translated">medium.com</p></div></div><div class="ot l"><div class="ou l ov ow ox ot oy ja ok"/></div></div></a></div><p id="8543" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">如果你觉得我的文章有帮助，请考虑加入灵媒会员来支持我和成千上万的其他作家！(点击上面的链接)</strong></p></div></div>    
</body>
</html>