<html>
<head>
<title>Build Your First Neural Network and Learn Deep Learning Terminologies</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建您的第一个神经网络，并学习深度学习术语</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/demystify-deep-learning-terminologies-and-build-your-first-neural-network-c408d2456df2?source=collection_archive---------27-----------------------#2021-03-26">https://towardsdatascience.com/demystify-deep-learning-terminologies-and-build-your-first-neural-network-c408d2456df2?source=collection_archive---------27-----------------------#2021-03-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5d24" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">深度学习、神经网络、Tensorflow和Keras的初学者入门，包括实际操作</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/157c10034e25a2c1a700a62496d53a9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UGemxMoj7FiqbvRrNlqX3A.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由<a class="ae ky" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=63527" rel="noopener ugc nofollow" target="_blank">皮克斯拜</a>的Gerd Altmann 提供</p></figure><p id="afdc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">深度学习是<a class="ae ky" href="https://en.wikipedia.org/wiki/Machine_learning" rel="noopener ugc nofollow" target="_blank">机器学习</a>的一个分支，通过它，你向机器输入<strong class="lb iu">数据</strong>和<strong class="lb iu">答案</strong>，机器计算出<strong class="lb iu">规则</strong>，并由此得出答案。答案是数据代表的<em class="lv">标签</em>，例如关于房价的数据，<em class="lv">标签是价格</em>，数据是影响价格的房子的各个<em class="lv">方面。另一个例子是关于猫和狗的图像数据，标签<em class="lv">是动物是猫还是狗。</em></em></p><h2 id="8a7b" class="lw lx it bd ly lz ma dn mb mc md dp me li mf mg mh lm mi mj mk lq ml mm mn mo bi translated">定义关键术语</h2><p id="93db" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">人工神经网络，或称ann，是深度学习的基石。人工神经网络于1943年首次推出，由于大量的大数据、计算能力的大幅提高以及大量的关注和资金投入，它们的应用最近已经起飞。</p><p id="d5d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">神经网络的组成部分</strong></p><p id="9a56" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下图是神经网络的基本表示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mu"><img src="../Images/cd066ff935ddfefbe312150b762cacf9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*krfuRNl82PZ8k2rYTWoNjg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来自<a class="ae ky" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=3637503" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>的<a class="ae ky" href="https://pixabay.com/users/ahmedgad-9403351/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=3637503" rel="noopener ugc nofollow" target="_blank"> Ahmed Gad </a></p></figure><p id="95fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">神经元</strong>—<a class="ae ky" href="https://en.wikipedia.org/wiki/Artificial_neural_network" rel="noopener ugc nofollow" target="_blank">人工神经元</a>是具有一个或多个输入和一个输出的单元或节点。每个输入都有一个相关的权重，可以在训练过程中进行修改。上面的<em class="lv">笑脸圈</em>各代表一个<strong class="lb iu">神经元。</strong></p><p id="3830" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">层</strong>——这是指在神经网络中特定深度一起工作的神经元的集合。在上图中，每一列代表一个<strong class="lb iu">层</strong>，网络有3层；第一层(输入层)有3个神经元，第二层(隐藏层)有2个神经元，第三层(输出层)有1个神经元。</p><p id="fcd4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">密集层</strong> —这是指一组完全连接的神经元，其中<em class="lv">层中的每个神经元</em>都与下一层中的每个神经元连接<em class="lv">。密集层是最常见的<a class="ae ky" href="https://deeplizard.com/learn/video/FK77zZxaBoI" rel="noopener ugc nofollow" target="_blank">类型的层</a>。</em></p><p id="bf46" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">深层神经网络(DNN)——</strong>这是指一个神经网络包含一个隐藏层的<em class="lv">深层堆栈</em>(中间的几列)。<a class="ae ky" href="https://en.wikipedia.org/wiki/Deep_learning" rel="noopener ugc nofollow" target="_blank">深度学习</a>因此是一个研究包含深度计算堆栈的模型的领域。</p><p id="7a7a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://www.tensorflow.org/" rel="noopener ugc nofollow" target="_blank"><strong class="lb iu">tensor flow</strong></a>——这是一个开源平台，包含了很多机器学习所需的常用算法。在这里，您可以创建和使用机器学习模型，而不必学习幕后进行的所有底层数学和逻辑。</p><p id="e354" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://keras.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu"> Keras </strong> </a> —这是一个简单灵活的高级深度学习API，用于构建、训练、评估和运行神经网络。Tensorflow捆绑了自己的Keras实现<code class="fe mv mw mx my b">tf.keras</code>。</p><p id="8741" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://deepai.org/machine-learning-glossary-and-terms/loss-function" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">损失函数</strong> </a> —通过比较期望输出(y)和网络实际输出(ŷ)来测量网络的输出误差，并返回误差。<a class="ae ky" href="https://keras.io/api/losses/" rel="noopener ugc nofollow" target="_blank">损失函数的例子</a>是<a class="ae ky" href="https://en.wikipedia.org/wiki/Mean_squared_error" rel="noopener ugc nofollow" target="_blank">均方误差</a>和交叉熵。</p><p id="a463" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://www.kdnuggets.com/2020/12/optimization-algorithms-neural-networks.html" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">优化器</strong> </a> <strong class="lb iu"> </strong> —这是一种修改神经网络属性的技术，如<em class="lv">权值</em>和<em class="lv">学习率</em>以减少损失。<a class="ae ky" href="https://www.kdnuggets.com/2020/12/optimization-algorithms-neural-networks.html" rel="noopener ugc nofollow" target="_blank">示例</a>是随机梯度下降和Adam。</p><p id="e8c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">训练一个模型</strong></p><p id="e44c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，机器使用一套算法从一组给定的数据中学习输入，并可以识别区分它们的底层模式。让我们举一个简单的例子，数据有2列x和y，6行，x和y之间的关系是y=2x+1。因此，x是输入数据，y是标签。</p><p id="617c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，神经网络做一个胡乱的猜测，也许是y=9x+9，通过计算<strong class="lb iu">损失函数</strong>(如均方误差)将Y的实际输出与猜测进行比较。然后<strong class="lb iu">优化器函数</strong>(比如随机梯度下降)通过最小化损失来进行另一个猜测，可能会得出类似y=4x+4的结果。然后，它将重复给定数量的时期(重复上述过程)。我们将在下面的代码中实现这一点。</p><h2 id="04b2" class="lw lx it bd ly lz ma dn mb mc md dp me li mf mg mh lm mi mj mk lq ml mm mn mo bi translated">神经网络的简单实现</h2><p id="ebaf" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated"><strong class="lb iu">数据</strong></p><p id="6868" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下表显示了上述数据。我们有两列，x和y，这两个集合之间有一个关系，即对于任何给定的行，y的值=2x+1。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/24535897d143c0532dcdf52dfd8e4af9.png" data-original-src="https://miro.medium.com/v2/resize:fit:306/format:webp/1*pe5FvD4maNm8dg3Tw3eRsw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">按作者分类的表格</p></figure><p id="8e2e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将向我们的神经网络提供数据，并让它确定这两个集合之间的关系。x是输入数据(或输入要素), y是标注。因此，我们在这里向神经网络提供<strong class="lb iu">数据</strong> (x)和<strong class="lb iu">答案</strong> (y)，它的任务是识别将x映射到y的<strong class="lb iu">规则</strong>(公式)，以便它能够在给定x值之前预测y值。</p><p id="29fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">安装软件包</strong></p><p id="25c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于Keras捆绑了Tensorflow 2.0及以上版本，我们只需安装Tensorflow即可。如果您的机器上安装了<a class="ae ky" href="https://realpython.com/installing-python/" rel="noopener ugc nofollow" target="_blank"> python环境</a>，您可以使用下面的代码行安装CPU版本。省略<code class="fe mv mw mx my b">-cpu</code>会安装GPU版本。</p><p id="6a81" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mv mw mx my b">pip install tensorflow-cpu</code></p><p id="18c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">按照<a class="ae ky" rel="noopener" target="_blank" href="/https-medium-com-ekapope-v-install-tensorflow-and-keras-using-anaconda-navigator-without-command-line-b0bc41dbd038">这个</a>教程在<a class="ae ky" href="https://www.anaconda.com/products/individual" rel="noopener ugc nofollow" target="_blank"> anaconda </a>上安装Tensorflow和Keras。</p><p id="eb58" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一个很好的入门选项是在<a class="ae ky" href="https://colab.research.google.com/notebooks/intro.ipynb" rel="noopener ugc nofollow" target="_blank"> Google colab </a>上编写和运行代码，这是一个基于浏览器的免费Jupyter笔记本，运行在云上，不需要任何设置，因为包括Tensorflow在内的大多数软件包都是预装的。</p><p id="2928" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">导入库</strong></p><p id="ce22" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来是导入项目所需的库。</p><pre class="kj kk kl km gt na my nb nc aw nd bi"><span id="7cc1" class="lw lx it my b gy ne nf l ng nh">import tensorflow as tf<br/>import numpy as np<br/>from tensorflow import keras</span></pre><p id="c2f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">定义模型</strong></p><p id="6fd0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了定义我们的模型，我们调用<strong class="lb iu">顺序</strong>构造函数。<a class="ae ky" href="https://www.tensorflow.org/api_docs/python/tf/keras/Sequential" rel="noopener ugc nofollow" target="_blank">顺序</a>将层的线性堆栈分组，并指定每个层的外观。在一个顺序构造函数中，可以有多个密集层作为一个列表。</p><pre class="kj kk kl km gt na my nb nc aw nd bi"><span id="14af" class="lw lx it my b gy ne nf l ng nh">model = tf.keras.Sequential([<br/>keras.layers.Dense(units=1, input_shape=[1])<br/>])</span></pre><p id="bc2c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的代码构造了一个非常简单的神经网络，它只有一个密集层，只有一个神经元，由于这是第一层，我们必须包括输入数据的形状。在这种情况下，对于每个实例(行)，x是一个值，因此是<code class="fe mv mw mx my b">input-shape=[1]</code>。</p><p id="d10b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在此步骤中包含输入形状非常重要，因为Keras中的所有图层都需要知道其输入的形状来创建权重。没有包含<code class="fe mv mw mx my b">input-shape</code>会导致模型构建时没有权重，只有当模型第一次看到一些输入数据时才会初始化权重。在这之后，模型被构建，您可以调用<code class="fe mv mw mx my b">model.get_weights()</code>和<code class="fe mv mw mx my b">model.summary()</code>方法来显示它的内容。</p><p id="2eab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">编译模型</strong></p><p id="af52" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下一步是编译神经网络，这里我们提供了两个函数；一个<code class="fe mv mw mx my b">loss</code>功能和一个<code class="fe mv mw mx my b">optimizer</code>。损失函数通过模型预测的好坏来评估权重集，而优化器修改权重以减少损失。<code class="fe mv mw mx my b">‘sgd’</code>下图代表随机梯度下降。</p><pre class="kj kk kl km gt na my nb nc aw nd bi"><span id="eec6" class="lw lx it my b gy ne nf l ng nh">model.compile(optimizer='sgd', loss='mean_squared_error')</span></pre><p id="df86" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这一行基本上定义了在下面的步骤中训练模型时将在后端发生的数学计算的类型。</p><p id="1e49" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">根据数据训练模型</strong></p><p id="fb75" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是模型学习X和y之间关系的地方。</p><pre class="kj kk kl km gt na my nb nc aw nd bi"><span id="faa6" class="lw lx it my b gy ne nf l ng nh">x = np.array([-1.0,0.0,1.0,2.0,3.0,4.0,5.0],dtype=float)<br/>y = np.array([-1.0,1.0,3.0,5.0,7.0,9.0,11.0],dtype=float)</span><span id="f846" class="lw lx it my b gy ni nf l ng nh">model.fit(x,y,epochs=500)</span></pre><p id="67b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们称之为<code class="fe mv mw mx my b">model.fit(x,y,epochs=500)</code>来训练模型。查看<a class="ae ky" href="https://keras.io/api/models/model_training_apis/" rel="noopener ugc nofollow" target="_blank">该Keras文档</a>了解其他可选参数。我们提供x和y作为模型所期望的Numpy数组。x是输入数据，y是标签。时期定义迭代的次数。猜测、减少损失以及使用优化器做出下一个最佳猜测的过程就发生在这一步。下面是在Jupyter笔记本中训练模型时显示的输出截图。注意损失是如何随着时代接近500/500而减少的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/4d80170a03cacc67e0f193a7e8b43a8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1136/format:webp/1*hK2kp7WX_-WafdHdp7QbyQ.png"/></div></figure><p id="dd14" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">做预测</strong></p><p id="4444" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">既然已经根据我们提供的数据训练了一个模型，我们现在可以通过调用<code class="fe mv mw mx my b">model.evaluate([value])</code>方法来预测给定的x的<code class="fe mv mw mx my b">value</code>的y。该值被括在方括号中，因为预期的参数是一个数组。</p><pre class="kj kk kl km gt na my nb nc aw nd bi"><span id="d0f2" class="lw lx it my b gy ne nf l ng nh">print(model.predict([10.0]))</span><span id="90d1" class="lw lx it my b gy ni nf l ng nh">###Results<br/>[[21.006134]]</span></pre><p id="3015" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们从y=2x+1关系中知道答案应该是21，但是这里我们看到结果与预期值略有不同。这是因为该模型是在只有6行的小数据集上训练的，也因为损失不完全是0。注意<em class="lv">您的</em>值可能会因为模型的初始随机权重而有所不同。</p><p id="32ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">模型概要</strong></p><p id="6bd1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">模型中的每个神经元学习一个权重和一个偏差。我们上面的模型只有一个单个神经元，因此它将学习关系为<code class="fe mv mw mx my b">y = Wx + b</code>的<em class="lv">权重</em>和<em class="lv">偏差</em>，其中<em class="lv"> W是权重</em>，而<em class="lv"> b是偏差</em>。使用Tensorflow，这些是模型学习的值，可以通过调用<code class="fe mv mw mx my b">model.get_weights()</code>来查看它们。</p><pre class="kj kk kl km gt na my nb nc aw nd bi"><span id="7f9a" class="lw lx it my b gy ne nf l ng nh">model.get_weights()</span><span id="0943" class="lw lx it my b gy ni nf l ng nh">###Results<br/>[array([[<strong class="my iu">2.000743</strong>]], dtype=float32), array([<strong class="my iu">0.9972024</strong>], dtype=float32)]</span></pre><p id="43f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这返回包含权重<strong class="lb iu"> </strong>的两个数组，使得学习到的关系是y = 2.000743 x + 0.9972024，这非常接近y=2x+1的真实关系。</p></div><div class="ab cl nk nl hx nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="im in io ip iq"><h2 id="5aa4" class="lw lx it bd ly lz ma dn mb mc md dp me li mf mg mh lm mi mj mk lq ml mm mn mo bi translated">总结</h2><p id="6857" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">这是对深度学习、Tensorflow和Keras的基本介绍，其中我们使用神经网络来确定两组值之间的线性关系。虽然这看起来可能是一个非常简单的问题，但我们学到的概念和工作流对于处理深度学习中更有趣和复杂的问题是必不可少的。查看下面的参考资料，我发现这些资料对刚进入这个领域的初学者非常有用。</p><p id="77ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">参考文献</strong></p><p id="bfa8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">吴恩达在YouTube上发表的《神经网络和深度学习》。</p><p id="2090" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="http://introtodeeplearning.com/" rel="noopener ugc nofollow" target="_blank">麻省理工学院深度学习入门6。S191 </a></p><p id="626d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://www.amazon.com/Hands-Machine-Learning-Scikit-Learn-TensorFlow-ebook-dp-B07XGF2G87/dp/B07XGF2G87/ref=mt_other?_encoding=UTF8&amp;me=&amp;qid=" rel="noopener ugc nofollow" target="_blank">使用Scikit-Learn、Keras和TensorFlow进行机器实践学习:第二版</a></p><p id="0ec5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://www.amazon.com/Hands-Machine-Learning-Scikit-Learn-TensorFlow-ebook-dp-B07XGF2G87/dp/B07XGF2G87/ref=mt_other?_encoding=UTF8&amp;me=&amp;qid=" rel="noopener ugc nofollow" target="_blank">程序员的人工智能和机器学习:人工智能程序员指南第一版，作者劳伦斯·莫罗尼</a></p></div></div>    
</body>
</html>