<html>
<head>
<title>Using pandas categories properly is tricky, here’s why…</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">正确使用熊猫类别是很棘手的，原因如下…</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/staying-sane-while-adopting-pandas-categorical-datatypes-78dbd19dcd8a?source=collection_archive---------2-----------------------#2021-03-28">https://towardsdatascience.com/staying-sane-while-adopting-pandas-categorical-datatypes-78dbd19dcd8a?source=collection_archive---------2-----------------------#2021-03-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="32f7" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">了解常见的陷阱和意想不到的行为，如何避免让猫抓你</h2></div><p id="5713" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在pandas中，分类数据类型经常被吹捧为减少数据帧内存使用的简单方法，它们确实是一个有用的工具。然而，如果你想象你可以在代码的开头加上一个<code class="fe lb lc ld le b">.astype("category")</code>,其他的都一样(但是更有效)，你可能会失望。</p><p id="943c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">本文主要关注在pandas中使用分类数据类型时可能会遇到的一些现实问题；要么调整您现有的思维模式，使用类别编写新代码，要么尝试使用类别列将现有管道迁移到流中。</p><p id="c153" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lf">本文中描述的行为是截止到</em><code class="fe lb lc ld le b"><em class="lf">pandas==1.2.3</em></code><em class="lf">(2021年3月发布)的当前行为，但是如果您在更晚的日期阅读本文，请不要担心，所描述的行为不太可能在未来的版本中有重大改变——但是如果有，请留下评论！</em></p><h2 id="b67b" class="lg lh iq bd li lj lk dn ll lm ln dp lo ko lp lq lr ks ls lt lu kw lv lw lx ly bi translated">为什么在pandas中使用分类数据类型？</h2><p id="c692" class="pw-post-body-paragraph kf kg iq kh b ki lz jr kk kl ma ju kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">如果分类数据是一种痛苦，那么为什么不干脆完全避免它呢？嗯，使用类别可以带来一些显著的好处:</p><ul class=""><li id="9cb6" class="me mf iq kh b ki kj kl km ko mg ks mh kw mi la mj mk ml mm bi translated"><strong class="kh ir">内存使用</strong> —对于有许多重复值的字符串列，类别可以大大减少在内存中存储数据所需的内存量</li><li id="71d4" class="me mf iq kh b ki mn kl mo ko mp ks mq kw mr la mj mk ml mm bi translated"><strong class="kh ir">运行时性能</strong> —有一些优化可以提高某些操作的执行速度</li><li id="7113" class="me mf iq kh b ki mn kl mo ko mp ks mq kw mr la mj mk ml mm bi translated"><strong class="kh ir">库集成</strong> —在某些情况下，库对分类列有特殊的功能，例如<code class="fe lb lc ld le b">lightgbm</code>在构建模型时以不同的方式处理分类列</li></ul><h2 id="b4ea" class="lg lh iq bd li lj lk dn ll lm ln dp lo ko lp lq lr ks ls lt lu kw lv lw lx ly bi translated">快乐之路</h2><p id="1e8d" class="pw-post-body-paragraph kf kg iq kh b ki lz jr kk kl ma ju kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">让我们做一个强制性的“快乐之路”的例子。这是在一个简单的世界里，每个人都互相微笑的样子:</p><pre class="ms mt mu mv gt mw le mx my aw mz bi"><span id="1153" class="lg lh iq le b gy na nb l nc nd">df_size = 100_000<br/>df1 = pd.DataFrame(<br/>    {<br/>        "float_1": np.random.rand(df_size),<br/>        "species": np.random.choice(["cat", "dog", "ape", "gorilla"], size=df_size),<br/>    }<br/>)<br/>df1_cat = df1.astype({"species": "category"})</span></pre><p id="c3b8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里我们创建了两个数据帧，<code class="fe lb lc ld le b">df1</code>包含作为对象列的<code class="fe lb lc ld le b">species</code>和<code class="fe lb lc ld le b">df1_cat</code>，后者是相同数据帧的副本，但是使用<code class="fe lb lc ld le b">species</code>作为分类数据类型。</p><pre class="ms mt mu mv gt mw le mx my aw mz bi"><span id="42d0" class="lg lh iq le b gy na nb l nc nd">&gt;&gt; df1.memory_usage(deep=True)</span><span id="3bd3" class="lg lh iq le b gy ne nb l nc nd">Index          128<br/>float_1     800000<br/>species    6100448<br/>dtype: int64</span></pre><p id="b695" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以在这里看到，根据我们的内存使用情况，保存一个包含字符串的列是多么昂贵——这里的字符串列占用大约6MB，如果这些字符串更长，它会占用更多；与之相比，float列占用了0.8MB。我们可以用一个字符串列的价格购买近8个<code class="fe lb lc ld le b">float64</code>列……很贵。</p><pre class="ms mt mu mv gt mw le mx my aw mz bi"><span id="ca57" class="lg lh iq le b gy na nb l nc nd">&gt;&gt; df1_cat.memory_usage(deep=True)</span><span id="7594" class="lg lh iq le b gy ne nb l nc nd">Index         128<br/>float_1    800000<br/>species    100416<br/>dtype: int64</span></pre><p id="e1e0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在转换到一个类别后，查看内存使用情况，我们看到了一个相当大的改进，内存使用量减少了60倍，非常好。现在，我们可以用一个<code class="fe lb lc ld le b">float64</code>列的价格购买8个这样的字符串列，哦，形势发生了多么大的变化。</p><p id="710a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这很酷，但是，只有我们能保持这种状态才是真正的酷…</p><h1 id="52bd" class="nf lh iq bd li ng nh ni ll nj nk nl lo jw nm jx lr jz nn ka lu kc no kd lx np bi translated">分类列是脆弱的东西</h1><p id="2e2a" class="pw-post-body-paragraph kf kg iq kh b ki lz jr kk kl ma ju kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">听起来很奇怪吗？嗯……处理类别很像玩那些摇摇晃晃的洋娃娃，当你把它们推过来时，它们又会弹回来；如果您不密切关注使用分类列的每个操作，它们将很容易返回到<code class="fe lb lc ld le b">object</code>中。</p><p id="94a1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在最好的情况下，这是令人讨厌的，在最坏的情况下，它会降低您的性能(因为转换类型很昂贵)，和/或耗尽您的内存(因为您只能将这些数据作为一个类别存储到您的内存中)。</p><h1 id="ab3b" class="nf lh iq bd li ng nh ni ll nj nk nl lo jw nm jx lr jz nn ka lu kc no kd lx np bi translated">对分类列进行操作</h1><figure class="ms mt mu mv gt nr gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/09724694fb31df9def9597b215c0d348.png" data-original-src="https://miro.medium.com/v2/resize:fit:894/format:webp/1*SoU1yKDKYR-xWiPhwoOo5w.png"/></div><p class="nu nv gj gh gi nw nx bd b be z dk translated">这是我对猫手术的描述。我知道通常情况下，人类会给猫做手术，但是现实比小说更奇怪:我们有熊猫给猫做手术！</p></figure><p id="c8e0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">很可能在某个时候，你会想对你的分类列做些什么，其中之一可能是一个转换。这是第一个我们必须表现出勤奋的地方…</p><p id="c749" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">由于分类列通常是基于文本的列，让我们来看一个使用字符串操作的例子，我们可以像通常对基于文本的<code class="fe lb lc ld le b">object</code>列那样对分类列进行操作；通过使用<code class="fe lb lc ld le b">.str</code>访问器。</p><p id="cc31" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">非分类字符串系列:</strong></p><pre class="ms mt mu mv gt mw le mx my aw mz bi"><span id="01a4" class="lg lh iq le b gy na nb l nc nd">&gt;&gt; %timeit df1["species"].str.upper()</span><span id="4355" class="lg lh iq le b gy ne nb l nc nd">25.6 ms ± 2.07 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)</span></pre><p id="2d50" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">关于分类字符串系列:</strong></p><pre class="ms mt mu mv gt mw le mx my aw mz bi"><span id="bf9f" class="lg lh iq le b gy na nb l nc nd">&gt;&gt; %timeit df1_cat["species"].str.upper()</span><span id="1907" class="lg lh iq le b gy ne nb l nc nd">1.85 ms ± 41.1 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)</span></pre><p id="2ddf" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">分类版本在性能上是明显的赢家，在这种情况下大约快了14倍(这是因为内部优化意味着<code class="fe lb lc ld le b">.str.upper()</code>只对唯一的类别值调用一次，然后从结果中构造一个序列，而不是对序列中的每个值调用一次)。然而，这是我们遇到的第一个主要问题…</p><pre class="ms mt mu mv gt mw le mx my aw mz bi"><span id="9f8b" class="lg lh iq le b gy na nb l nc nd">&gt;&gt; df1_cat["species"].str.upper().memory_usage(deep=True)</span><span id="d85c" class="lg lh iq le b gy ne nb l nc nd">6100576</span></pre><p id="75ea" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们已经丢失了我们的分类类型，结果是一个<code class="fe lb lc ld le b">object</code>类型的列，数据压缩也消失了；结果现在又是6MB大小。在此之后，我们可以重铸回一个类别，但这需要在类型之间来回转换，这会使我们的代码更加混乱，并且不会降低我们的内存使用峰值。</p><h2 id="ff3e" class="lg lh iq bd li lj lk dn ll lm ln dp lo ko lp lq lr ks ls lt lu kw lv lw lx ly bi translated">有效的替代方案</h2><p id="3bc8" class="pw-post-body-paragraph kf kg iq kh b ki lz jr kk kl ma ju kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">通常，一种有效的替代方法是重写操作分类列的代码，直接对类别本身进行操作，而不是对它们的值序列进行操作。这需要在思维模式(和实现)上做一点改变，你可以认为它只是对列中的每个唯一的<strong class="kh ir">值做一次操作，而不是对列中的每个实例。如果在100，000行的类别中只有2个唯一值的列，那么只需执行2次操作，而不是100，000次。</strong></p><p id="9dd9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，在上述情况下，我们可以执行以下操作:</p><pre class="ms mt mu mv gt mw le mx my aw mz bi"><span id="990b" class="lg lh iq le b gy na nb l nc nd">%timeit df1_cat["species"].cat.rename_categories(str.upper)</span><span id="d39e" class="lg lh iq le b gy ne nb l nc nd">239 µs ± 13.9 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)</span></pre><p id="0b49" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这比前面的任何一个选项都快10倍，主要的好处是我们从不将分类系列转换成昂贵的中间<code class="fe lb lc ld le b">object</code>列状态，所以我们保持了很好的内存效率。</p><p id="78dd" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是一个玩具示例，但原则适用于更复杂的示例，如果没有特定的<code class="fe lb lc ld le b">.cat</code>访问器方法来帮助您的特定情况，请考虑对包含唯一分类值的<code class="fe lb lc ld le b">df1_cat[“species”].dtype.categories</code>进行操作，而不是对整个系列进行操作。</p><h1 id="5920" class="nf lh iq bd li ng nh ni ll nj nk nl lo jw nm jx lr jz nn ka lu kc no kd lx np bi translated">与分类列合并</h1><figure class="ms mt mu mv gt nr gh gi paragraph-image"><div role="button" tabindex="0" class="nz oa di ob bf oc"><div class="gh gi ny"><img src="../Images/baec4fa2eeeec1bc07a8c280e7fc7cfc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Rqpxdq3h3ztltENF1ht8fA.png"/></div></div><p class="nu nv gj gh gi nw nx bd b be z dk translated">描绘一些合并的猫确实是一个巨大的尝试。</p></figure><p id="f360" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在除了最简单的用例之外的所有用例中，我们可能不只有一个数据帧，而是有多个数据帧，我们可能希望在某个时候将它们粘在一起。例如，我们将收集一个小型“参考”数据集，其中包含第一个数据集的物种栖息地:</p><pre class="ms mt mu mv gt mw le mx my aw mz bi"><span id="862b" class="lg lh iq le b gy na nb l nc nd">df2 = pd.DataFrame(<br/>    {<br/>        "species": ["cat", "dog", "ape", "gorilla", "snake"],<br/>        "habitat": ["house", "house", "jungle", "jungle", "jungle"],<br/>    }<br/>)<br/>df2_cat = df2.astype({"species": "category", "habitat": "category"})</span></pre><p id="e753" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">和以前一样，我们已经创建了这个数据集的一个分类版本，以及一个带有<code class="fe lb lc ld le b">object</code>字符串的版本。这里需要注意的一点是，我们有一个额外的物种(<code class="fe lb lc ld le b">snake</code>)，这是我们将与之合并的数据帧<code class="fe lb lc ld le b">df1</code>中没有的，这在以后会很重要(但不要担心不会有测试)。</p><p id="00d0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我不会展示将两个<code class="fe lb lc ld le b">object</code>列合并在一起的例子，因为你们都知道会发生什么，<code class="fe lb lc ld le b">object</code> + <code class="fe lb lc ld le b">object</code> = <code class="fe lb lc ld le b">object</code>，没有魔法，这只是一个合并。</p><h2 id="19b8" class="lg lh iq bd li lj lk dn ll lm ln dp lo ko lp lq lr ks ls lt lu kw lv lw lx ly bi translated">在分类列上合并对象列</h2><p id="d350" class="pw-post-body-paragraph kf kg iq kh b ki lz jr kk kl ma ju kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">在这个小测试中，我们将选取一个分类数据帧，并将其与另一个数据帧上的对象类型列合并。</p><pre class="ms mt mu mv gt mw le mx my aw mz bi"><span id="86f1" class="lg lh iq le b gy na nb l nc nd">&gt;&gt; df1.merge(df2_cat, on="species").dtypes</span><span id="ed5f" class="lg lh iq le b gy ne nb l nc nd">float_1     float64<br/>species      object<br/>habitat    category<br/>dtype: object</span></pre><p id="52f2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以这里我们有左边的物种<code class="fe lb lc ld le b">object</code>和右边的物种<code class="fe lb lc ld le b">category</code>。我们可以看到，当我们进行合并时，我们得到了结果数据帧中合并列的<code class="fe lb lc ld le b">category</code> + <code class="fe lb lc ld le b">object</code> = <code class="fe lb lc ld le b">object</code>。如此等等等等，当我们回到<code class="fe lb lc ld le b">object</code> s时，这又一次在记忆中击中了我们。这并不令人惊讶，但同样，这是在处理类别时需要注意的事情。</p><h2 id="d231" class="lg lh iq bd li lj lk dn ll lm ln dp lo ko lp lq lr ks ls lt lu kw lv lw lx ly bi translated">合并两个分类列</h2><p id="29de" class="pw-post-body-paragraph kf kg iq kh b ki lz jr kk kl ma ju kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">希望我已经让你认为我正在走向<code class="fe lb lc ld le b">category</code> + <code class="fe lb lc ld le b">category</code> = <code class="fe lb lc ld le b">category</code>。让我们来看看:</p><pre class="ms mt mu mv gt mw le mx my aw mz bi"><span id="1616" class="lg lh iq le b gy na nb l nc nd">&gt;&gt; df1_cat.merge(df2_cat, on="species").dtypes</span><span id="838c" class="lg lh iq le b gy ne nb l nc nd">float_1     float64<br/>species      object<br/>habitat    category<br/>dtype: object</span></pre><p id="16c3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">报警，我被骗了… <code class="fe lb lc ld le b">category</code> + <code class="fe lb lc ld le b">category</code> = <code class="fe lb lc ld le b">object</code>。</p><p id="d83d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么尾巴上的刺是什么？在合并中，为了保留分类类型，两个分类类型必须完全相同。与pandas中的其他数据类型不同(例如，所有的<code class="fe lb lc ld le b">float64</code>列都具有相同的数据类型)，当我们谈论分类数据类型时，数据类型实际上是由特定类别中存在的一组值来描述的，因此您可以想象包含<code class="fe lb lc ld le b">["cat", "dog", "mouse"]</code>的类别与包含<code class="fe lb lc ld le b">[“cheese”, “milk”, “eggs”]</code>的类别是不同的类型。虽然在我们的例子中，它们看起来非常相似(一个是另一个的子集)，但在<code class="fe lb lc ld le b">df2</code>中，我们有一个物种在<code class="fe lb lc ld le b">df1</code>中不存在(狡猾的<code class="fe lb lc ld le b">snake</code>)。</p><p id="0cd6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以这样看待合并列的行为:</p><p id="b064" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">category1</code> + <code class="fe lb lc ld le b">category2</code> = <code class="fe lb lc ld le b">object</code></p><p id="8f12" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">category1</code> + <code class="fe lb lc ld le b">category1</code> = <code class="fe lb lc ld le b">category1</code></p><p id="b59f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，采用前面的例子，我们可以得到我们想要的和预期的结果:</p><pre class="ms mt mu mv gt mw le mx my aw mz bi"><span id="4517" class="lg lh iq le b gy na nb l nc nd">&gt;&gt; df1_cat.astype({"species": df2_cat["species"].dtype}).merge(<br/>       df2_cat, on="species"<br/>   ).dtypes</span><span id="d60f" class="lg lh iq le b gy ne nb l nc nd"><br/>float_1     float64<br/>species    category<br/>habitat    category<br/>dtype: object</span></pre><p id="0a42" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从上面可以看出，设置分类类型进行匹配，然后进行合并，得到了我们想要的结果……最后。</p><h1 id="76e3" class="nf lh iq bd li ng nh ni ll nj nk nl lo jw nm jx lr jz nn ka lu kc no kd lx np bi translated">使用分类列分组</h1><figure class="ms mt mu mv gt nr gh gi paragraph-image"><div role="button" tabindex="0" class="nz oa di ob bf oc"><div class="gh gi od"><img src="../Images/f896fd8233927a87b4582d3d37337ebc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iITbfs1oA23FhL17iIRCRw.png"/></div></div><p class="nu nv gj gh gi nw nx bd b be z dk translated">我不是一个爱猫的人，我不清楚如何最好地对猫进行分类(我想它们中的很多会下地狱)</p></figure><p id="4435" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在修改代码以处理分类数据类型时，用类别分组曾经让我自己伤透了脑筋。一次导致行为意外改变，给出一个充满空值的数据帧，另一次导致操作无限期挂起(尽管以前使用<code class="fe lb lc ld le b">object</code>数据类型只需要几秒钟)。</p><p id="4877" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir"> <em class="lf">当您对分类数据类型进行分组时，默认情况下，您会对该数据类型中的每个值进行分组，即使它不在数据本身中。</em> </strong></p><p id="b70f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那是什么意思？最好用一个例子来说明。</p><pre class="ms mt mu mv gt mw le mx my aw mz bi"><span id="b8e1" class="lg lh iq le b gy na nb l nc nd">habitat_df = (<br/>    df1_cat.astype({"species": df2_cat["species"].dtype})<br/>           .merge(df2_cat, on="species")<br/>)</span><span id="a19f" class="lg lh iq le b gy ne nb l nc nd">house_animals_df = habitat_df.loc[habitat_df["habitat"] == "house"]</span></pre><p id="eb77" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以这里的<code class="fe lb lc ld le b">habitat_df</code>是上一节的合并示例(其中<code class="fe lb lc ld le b">species</code>和<code class="fe lb lc ld le b">habitat</code>最终都是分类的)，而<code class="fe lb lc ld le b">house_animals_df</code>只包含住在房子里的动物，在我们的例子中是<code class="fe lb lc ld le b">cat</code>和<code class="fe lb lc ld le b">dog</code>。让我们试着找出这些<code class="fe lb lc ld le b">species</code>的平均值<code class="fe lb lc ld le b">float_1</code>。</p><pre class="ms mt mu mv gt mw le mx my aw mz bi"><span id="eb24" class="lg lh iq le b gy na nb l nc nd">&gt;&gt; house_animals_df.groupby("species")["float_1"].mean()</span><span id="6877" class="lg lh iq le b gy ne nb l nc nd">species<br/>ape             NaN<br/>cat        0.501507<br/>dog        0.501023<br/>gorilla         NaN<br/>snake           NaN<br/>Name: float_1, dtype: float64</span></pre><p id="9de5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有些事情看起来有点不对劲，我们现在在groupby中得到一堆空值。默认情况下，当对分类列进行分组时，pandas会为类别中的每个值返回一个结果，即使这些值不在数据中。这可能很烦人(因为这是行为上的意外变化)，如果数据类型包含许多相关数据帧中不存在的组，尤其是在多个不同的分类列上分组时，这可能会影响性能。</p><p id="443d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了得到我们想要的结果，我们可以将<code class="fe lb lc ld le b">observed=True</code>传递给groupby调用，这样可以确保我们只得到数据中值的分组。</p><pre class="ms mt mu mv gt mw le mx my aw mz bi"><span id="e29f" class="lg lh iq le b gy na nb l nc nd">&gt;&gt; house_animals_df.groupby("species", observed=True)["float_1"].mean()</span><span id="c4b3" class="lg lh iq le b gy ne nb l nc nd">species<br/>cat    0.501507<br/>dog    0.501023<br/>Name: float_1, dtype: float64</span></pre><p id="447f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">是的，但这又是一个让我们保持警觉的陷阱。</p><h1 id="0138" class="nf lh iq bd li ng nh ni ll nj nk nl lo jw nm jx lr jz nn ka lu kc no kd lx np bi translated">分类列索引</h1><figure class="ms mt mu mv gt nr gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/ee7a2f21e6d09451512f0ae4292572d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1008/format:webp/1*t4oup7WjUS17mlEcvM1Ffw.png"/></div><p class="nu nv gj gh gi nw nx bd b be z dk translated">这是一个猫专栏，你明白吗？</p></figure><p id="fd57" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个例子稍微有点小众，但它为你有时会遇到的意外问题增加了一点色彩，如果你在使用范畴时没有保持头脑的话。有些情况下，您可能会将行值移动到列中，例如，<code class="fe lb lc ld le b">groupby-unstack</code>组合有点像职业玩家的移动。</p><pre class="ms mt mu mv gt mw le mx my aw mz bi"><span id="8528" class="lg lh iq le b gy na nb l nc nd">&gt;&gt; species_df = habitat_df.groupby(["habitat", "species"], observed=True)["float_1"].mean().unstack()<br/>&gt;&gt; species_df</span><span id="c0f1" class="lg lh iq le b gy ne nb l nc nd"><br/>species       cat       ape       dog   gorilla<br/>habitat                                        <br/>house    0.501507       NaN  0.501023       NaN<br/>jungle        NaN  0.501284       NaN  0.501108</span></pre><p id="5de2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们有了一个数据框架，列中有物种，到目前为止一切正常，让我们添加另一列，看看会发生什么。</p><pre class="ms mt mu mv gt mw le mx my aw mz bi"><span id="5a0a" class="lg lh iq le b gy na nb l nc nd">&gt;&gt; species_df["new_col"] = 1<br/></span><span id="ea53" class="lg lh iq le b gy ne nb l nc nd">TypeError: 'fill_value=new_col' is not present in this Categorical's categories</span></pre><p id="5649" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通常这段代码完全没问题，我们只是试图添加一个名为<code class="fe lb lc ld le b">new_col</code>的新列，它的值总是1。只是看了一眼数据帧，看起来没有任何错误，错误似乎有点令人困惑，它在谈论哪个<code class="fe lb lc ld le b">Categorical</code>，我们只是试图添加一个新列？</p><p id="d05a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所发生的是<code class="fe lb lc ld le b">.unstack()</code>(对于外行来说，它将索引翻转到列中，就像一个支点)将分类索引移动到列索引中。不可能将条目添加到不属于分类数据类型的分类索引中，因此会出现错误。虽然这并不是立即显而易见的，但如果你最终来到这里，挠头也是情有可原的。</p><p id="8835" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">可能不存在拥有分类列索引的强有力的例子，但是如果意外地拥有了一个分类列索引和/或您开始看到类似这样的奇怪错误，那么检查您正在处理的所有事物的数据类型并确保没有任何奇怪和分类的事情发生可能是值得的。</p><h1 id="e31d" class="nf lh iq bd li ng nh ni ll nj nk nl lo jw nm jx lr jz nn ka lu kc no kd lx np bi translated">结论</h1><p id="2507" class="pw-post-body-paragraph kf kg iq kh b ki lz jr kk kl ma ju kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">Pandas categorical dtypes很酷，并且有一些好的性能优势。当采用分类数据类型时，了解数据类型在不同的常见情况下如何表现是很重要的，尤其是对<strong class="kh ir">来说，确保分类在整个程序流程中保持分类</strong>，而不是返回到<code class="fe lb lc ld le b">object</code>。</p><p id="976c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">以下是一些需要注意的事项的高度概括:</p><ul class=""><li id="63f3" class="me mf iq kh b ki kj kl km ko mg ks mh kw mi la mj mk ml mm bi translated"><strong class="kh ir">对分类列进行操作时，</strong>选择对数据类型中的类别进行操作的选项，而不是对包含该数据类型的系列中的值进行操作的选项。这应该允许您保留分类的性质，同时提高性能。</li><li id="d67b" class="me mf iq kh b ki mn kl mo ko mp ks mq kw mr la mj mk ml mm bi translated"><strong class="kh ir">在分类列上进行合并时，</strong>请注意，为了保持分类性质，每个数据帧的合并列中的分类类型必须完全匹配。</li><li id="a040" class="me mf iq kh b ki mn kl mo ko mp ks mq kw mr la mj mk ml mm bi translated"><strong class="kh ir">当对分类列进行分组时，</strong>默认情况下，您将获得数据类型中每个值的结果，即使它不在数据中，您也可以使用<code class="fe lb lc ld le b">.groupby</code>中的<code class="fe lb lc ld le b">observed=True</code>来更改它。</li><li id="2187" class="me mf iq kh b ki mn kl mo ko mp ks mq kw mr la mj mk ml mm bi translated"><strong class="kh ir">当你期望工作的事情出乎意料地停止工作时，</strong>考虑是否有一种与范畴的奇怪互动在起作用</li></ul><p id="5919" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">祝你好运，并祝你快乐！</p></div></div>    
</body>
</html>