<html>
<head>
<title>Towards building a unified framework for feature selection with ranking functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">利用排序函数构建统一的特征选择框架</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/towards-building-a-unified-framework-for-feature-selection-with-ranking-functions-5605ef665f26?source=collection_archive---------38-----------------------#2021-04-07">https://towardsdatascience.com/towards-building-a-unified-framework-for-feature-selection-with-ranking-functions-5605ef665f26?source=collection_archive---------38-----------------------#2021-04-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="e217" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/thoughts-and-theory" rel="noopener" target="_blank">思想和理论</a></h2><div class=""/><div class=""><h2 id="47a6" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">一个代码来统治他们。一个代码实现所有这些，并在同一个框架中绑定它们。</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/1b749a75c3e854f015d19564b726a6f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*aPJ36sAJgyfrwkuF"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">由<a class="ae le" href="https://unsplash.com/@davidpisnoy?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">大卫·皮斯诺伊</a>在<a class="ae le" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="5e1e" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">在任何数据相关项目的特征工程中，我们经常必须手动过滤我们将用于训练我们的模型的列；这种过滤通常依赖于我们对数据的洞察力，也依赖于许多可以帮助我们区分有价值的属性和冗余或无意义的属性的标准，这个过程被称为<strong class="lh ja">特征选择</strong>。</p><p id="b49a" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">它们是选择属性的许多不同方式；我们今天看到的这个就是所谓的排名特征选择。这是最基本的方法。它用一个函数评估每个属性，对它们进行排序，并保留最好的属性。</p><p id="6ede" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">虽然这种排序可以用各种方法来完成，但我们将探索这些方法的分类，看看这种分类如何帮助我们将它们组织成一个可靠的、可扩展的框架，并使用这个框架来测试和比较它们的行为。</p><h1 id="3e5d" class="mb mc iq bd md me mf mg mh mi mj mk ml kf mm kg mn ki mo kj mp kl mq km mr ms bi translated">特征选择排序方法</h1><p id="2c2f" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">在特征选择中，我们可以根据Dash】和Liu 的分类，将属性的质量度量分为五类。</p><ul class=""><li id="85e2" class="my mz iq lh b li lj ll lm lo na ls nb lw nc ma nd ne nf ng bi translated"><strong class="lh ja">距离度量</strong>:量化属性和标签之间的相关性。</li><li id="54d9" class="my mz iq lh b li nh ll ni lo nj ls nk lw nl ma nd ne nf ng bi translated"><strong class="lh ja">信息度量:</strong>这些信息理论度量在根据一个特征的值分割它们之后，对标签的熵感兴趣。</li><li id="2fb5" class="my mz iq lh b li nh ll ni lo nj ls nk lw nl ma nd ne nf ng bi translated"><strong class="lh ja">一致性度量:</strong>如果相同的值不与类的不同值相关联，则特征是一致的。</li><li id="ea05" class="my mz iq lh b li nh ll ni lo nj ls nk lw nl ma nd ne nf ng bi translated"><strong class="lh ja">依赖度量:</strong>如果取一个特定值的概率不受另一个值的信息的影响，则称两个变量是独立的，因此这些度量通过量化类对属性的依赖来工作。</li><li id="e14c" class="my mz iq lh b li nh ll ni lo nj ls nk lw nl ma nd ne nf ng bi translated"><strong class="lh ja">分类措施:</strong>这些措施耗时；他们在获取特定属性时评估分类质量。</li></ul><p id="c5a0" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">当然，在介绍我将考虑的措施时，我将回到每一类。</p><h1 id="4438" class="mb mc iq bd md me mf mg mh mi mj mk ml kf mm kg mn ki mo kj mp kl mq km mr ms bi translated"><strong class="ak">受孕基线</strong></h1><p id="5e02" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">在定义我们的功能之前，我们需要设置一个清晰的、可伸缩的基线，以指导进一步的开发。</p><p id="bd7c" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">要使用它，我们需要隔离构建框架所需的不同组件；我提议的模型化基于三个关键概念:</p><ul class=""><li id="01e2" class="my mz iq lh b li lj ll lm lo na ls nb lw nc ma nd ne nf ng bi translated"><strong class="lh ja">测度:</strong>测度量化两个向量之间的关系；这种关系可以与依赖性、独立性或它们之间的相关性相关。特征选择排序方法</li><li id="a8bf" class="my mz iq lh b li nh ll ni lo nj ls nk lw nl ma nd ne nf ng bi translated"><strong class="lh ja">评价函数:</strong>评价函数通过使用度量来评价特征的重要性；对于互信息评估或相关性评估，评估可以被限制到单个测量，或者可以根据我们考虑的分类器调整到分类测量的不同测量。</li><li id="c556" class="my mz iq lh b li nh ll ni lo nj ls nk lw nl ma nd ne nf ng bi translated"><strong class="lh ja">特征选择函数:</strong>特征选择函数获取整个数据集，并通过对数据集的特征进行排序并取百分比或通过进行增量选择来执行特征选择，我们将在后面看到。</li></ul><p id="ad26" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">现在，让我们列举每一类组件的主要功能，因为这将为我们提供我们必须放在架构顶部的内容:</p><ul class=""><li id="a20a" class="my mz iq lh b li lj ll lm lo na ls nb lw nc ma nd ne nf ng bi translated"><strong class="lh ja">度量:</strong>函数可以对度量进行建模，因为它不需要对数据进行预处理；它只是计算一个值，这个值将被高层组件解释和使用。</li><li id="8790" class="my mz iq lh b li nh ll ni lo nj ls nk lw nl ma nd ne nf ng bi translated"><strong class="lh ja">评估函数:</strong>这里我们可能有一个预处理，因为我们必须考虑到一些评估函数需要分类特征，然后这类组件将根据它们对离散化函数的需要分成两类，其中一部分，每个评估函数的主要用途是评估关于该类的特征的重要性。</li><li id="3614" class="my mz iq lh b li nh ll ni lo nj ls nk lw nl ma nd ne nf ng bi translated"><strong class="lh ja">特性选择功能:</strong>这将是一个抽象接口，为最终用户提供对“选择”方法的访问，该方法选择给定数量的特性，并且将由许多子类实现，这取决于您想要用于选择的方法。</li></ul><p id="8bbd" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我们现在要做的就是从上到下开发我们的架构，并将其与我们的度量联系起来；这给了我下面的架构。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nm"><img src="../Images/9d367313889d5bbfae29cfc8d308bfb1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fc0eqbcjC9OXSZEe6gr5mw.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">作者图片</p></figure><h1 id="b8d2" class="mb mc iq bd md me mf mg mh mi mj mk ml kf mm kg mn ki mo kj mp kl mq km mr ms bi translated">可靠性测试</h1><p id="acb0" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">为了评估我们的框架的可靠性，特别是当添加一个新的度量时，我们必须考虑在每次添加一个评估函数时运行一个完整性测试；这个测试必须尽可能的通用，为了做到这一点，我们将采用一个约定，从现在开始每个评估函数类的名字中都必须包含“函数”这个词。</p><p id="8e8d" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">通过这样做，我们可以精心制作一个简单的测试，运行如下:对于它在文件“evaluation_functions.py”中找到的每个评估函数类，它将尝试对随机数据集的特征进行排序，以验证所有的评估函数都编写得很好。</p><p id="4d66" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">当然，这很简单，只要我们有一种方法来检查脚本并动态实例化包含类的对象，我们可以通过使用inspect模块来完成。</p><pre class="kp kq kr ks gt nn no np nq aw nr bi"><span id="5ffd" class="ns mc iq no b gy nt nu l nv nw">from inspect import getmembers, isclass<br/>from sklearn.datasets import make_classification<br/>from core.Feature_Selection import Evaluation_Function<br/>from core.Feature_Selection.Ranking_Function import Ranking_Selection<br/>X,y = make_classification(n_samples=1000, n_features=10, n_classes=2)<br/>for i, j in (getmembers(Evaluation_Function, isclass)):<br/>    if("Function" in i and not "CAT" in i):<br/>        print("Testing: ",i, end=" ")<br/>        EF = j()<br/>        R = Ranking_Selection(j())<br/>        c = R.fit(X, y)<br/>        print("✓")</span></pre><p id="da28" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">这几行代码将创建一个包含10个特征和1000个样本的数据集，get_member方法将检查Evaluation_Function脚本，对于其中每个名称中带有“Function”的类，我们将执行一个排名选择，并在完成后打印一个勾号。</p><h1 id="ee40" class="mb mc iq bd md me mf mg mh mi mj mk ml kf mm kg mn ki mo kj mp kl mq km mr ms bi translated">使用的措施</h1><p id="047e" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">使用框架的主要优势是它的广泛性，但是现在，我链接了以下函数；我不会深入每项措施的细节；我将只精确地描述他们的类以及他们如何评估特性:</p><ul class=""><li id="cdbd" class="my mz iq lh b li lj ll lm lo na ls nb lw nc ma nd ne nf ng bi translated"><a class="ae le" href="https://numpy.org/doc/stable/reference/generated/numpy.corrcoef.html" rel="noopener ugc nofollow" target="_blank"> <strong class="lh ja">皮尔逊相关系数</strong> </a>(来自NumPy)是一种距离测度，可以通过计算两个变量的协方差之比来得到。</li><li id="85d3" class="my mz iq lh b li nh ll ni lo nj ls nk lw nl ma nd ne nf ng bi translated"><a class="ae le" href="https://numpy.org/doc/stable/reference/generated/numpy.correlate.html" rel="noopener ugc nofollow" target="_blank"> <strong class="lh ja">基于信号的相关性</strong> </a> <strong class="lh ja"> </strong>(来自NumPy)这是在NumPy中实现的另一种相关性度量。</li><li id="9ab4" class="my mz iq lh b li nh ll ni lo nj ls nk lw nl ma nd ne nf ng bi translated"><a class="ae le" href="https://scikit-learn.org/stable/modules/generated/sklearn.feature_selection.mutual_info_classif.html" rel="noopener ugc nofollow" target="_blank"> <strong class="lh ja">互信息</strong> </a> <strong class="lh ja"> </strong>(来自Scikit-learn)这是一种信息度量，通过测量类中熵的减少来评估属性，如果我们相对于他的值分割它。</li><li id="0f8d" class="my mz iq lh b li nh ll ni lo nj ls nk lw nl ma nd ne nf ng bi translated"><a class="ae le" href="https://scikit-learn.org/stable/modules/generated/sklearn.feature_selection.chi2.html" rel="noopener ugc nofollow" target="_blank"> <strong class="lh ja"> Chi2独立性检验</strong> </a> <strong class="lh ja"> </strong>(来自Scikit-learn)两个变量是独立的如果<em class="nx">P(X = X；Y=y) = P(X=x)。P(Y=y) </em>，通过对属性和类之间的假设进行Chi2检验，我们可以量化它的重要性。</li><li id="bf14" class="my mz iq lh b li nh ll ni lo nj ls nk lw nl ma nd ne nf ng bi translated"><strong class="lh ja">分类度量</strong>:作为一种分类度量，为了评估每个属性，我用局限于这个特定属性的数据集训练了一个分类器，然后测量它的准确性；因为分类器是作为一个参数给出的，所以我用决策树分类器尝试了这个方法，然后我还添加了一个逻辑回归分类器。</li></ul><p id="4fcb" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">请记住，这篇博客的重点不是实现这些方法，所以我采取了已经实现的质量措施。</p><h1 id="de5e" class="mb mc iq bd md me mf mg mh mi mj mk ml kf mm kg mn ki mo kj mp kl mq km mr ms bi translated">特性试验</h1><p id="f9b2" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">每当我们实现一个新的评估功能时，我们不仅仅关心它是否符合框架。我们也要评估它的效率；</p><p id="508b" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">所以在完整性测试之后，我们将设计两个简单的性能测试；第一项测试包括以下内容:</p><ul class=""><li id="da8a" class="my mz iq lh b li lj ll lm lo na ls nb lw nc ma nd ne nf ng bi translated">我们创建一个虚拟数据集，其中包含<em class="nx"> k </em>个相关特征。</li><li id="6c10" class="my mz iq lh b li nh ll ni lo nj ls nk lw nl ma nd ne nf ng bi translated">我们用整个数据集训练一个分类器，并评估它的准确性。</li><li id="208a" class="my mz iq lh b li nh ll ni lo nj ls nk lw nl ma nd ne nf ng bi translated">对于每个函数，我们选择<em class="nx"> k </em>个特征，用局限于所选特征的数据集训练分类器，并用k倍验证评估分类器的准确性。</li></ul><p id="2ced" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">第二个非常相似，但我们不是生成完全随机的数据集，而是获取iris数据集，并向其中添加随机采样的列。</p><p id="7809" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">每个测试做10次，并且测量每个评估函数的时间。</p><p id="2a31" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">对于具有20个属性和仅5个信息属性的第一个测试，我们在SVM分类器上获得了以下结果:</p><pre class="kp kq kr ks gt nn no np nq aw nr bi"><span id="e1ad" class="ns mc iq no b gy nt nu l nv nw">base :  0.8974500000000001   Time:  0.0<br/>CHI2_Function :  0.52885   Time:  0.017551565170288087<br/>CorrelationSP_Function :  0.7693999999999999   Time:  0.00019888877868652345<br/>Correlation_Function :  0.8606   Time:  0.0020094394683837892<br/>DTClassification_Function :  0.6241   Time:  0.09251418113708496<br/>MI_Function :  0.89475   Time:  0.1389768123626709</span></pre><p id="10d3" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">基数表示通过保留所有属性获得的精度。我们可以注意到，通过减少80%的属性数量，我们保持了几乎相同的互信息性能；我们还注意到CHI2函数几乎没有用，但这可能是因为它被我使用的简单二进制化改变了，它只是简单地将数据范围划分为等间距的间隔。</p><p id="b68a" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">让我们考虑另一个具有完全随机数据集的示例，这次我们将采用200个特征(仅2000个样本)和50个信息性特征，我们获得以下结果:</p><pre class="kp kq kr ks gt nn no np nq aw nr bi"><span id="bcdf" class="ns mc iq no b gy nt nu l nv nw">base :  0.7943999999999999   Time:  0.0<br/>CHI2_Function :  0.46049999999999996   Time:  0.171110200881958<br/>Correlation_Function :  0.8112499999999998   Time:  0.019919610023498534<br/>DTClassification_Function :  0.60955   Time:  0.9978075504302979<br/>MI_Function :  0.8505000000000001   Time:  1.4385223627090453</span></pre><p id="db3a" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">同样，我们可以看到互信息保留了非常相关的属性，以至于它甚至击败了所有变量的分类。</p><p id="7770" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">现在让我们看看第二个测试，</p><pre class="kp kq kr ks gt nn no np nq aw nr bi"><span id="e79c" class="ns mc iq no b gy nt nu l nv nw">base :  0.9086666666666667   Time:  0.0<br/>CHI2_Function :  0.946   Time:  0.01797773838043213<br/>CorrelationSP_Function :  0.9740000000000001   Time:  0.00014123916625976562<br/>Correlation_Function :  0.9693333333333334   Time:  0.0030328035354614258<br/>DTClassification_Function :  0.3539999999999999   Time:  0.020097732543945312<br/>MI_Function :  0.9493333333333334   Time:  0.091739821434021</span></pre><p id="c8fc" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">这一次，作为分类度量一部分的所有度量都比基本度量表现得更好，这证实了排名度量的效率与数据集的结构密切相关。</p><h1 id="ea04" class="mb mc iq bd md me mf mg mh mi mj mk ml kf mm kg mn ki mo kj mp kl mq km mr ms bi translated">比较排名方法的更可靠的方法</h1><p id="7f6e" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">因为排序方法的主要优点是它们不耗费时间，所以我们可以生成排序，然后评估通过从排序的顶部到底部连续添加特征而获得的子集。</p><p id="76df" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我们通过使用Seaborn和添加了无用列的数据集IRIS获得了下面的图。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/2170436c7fb0f2964c10a5ff4aeb5fab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*6MWv0Z-KzpS9os3DWBwemA.png"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">作者图片</p></figure><p id="8c3f" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">这证实了:</p><ul class=""><li id="874d" class="my mz iq lh b li lj ll lm lo na ls nb lw nc ma nd ne nf ng bi translated">决策树分类不是此数据集的有效分级方法。</li><li id="5120" class="my mz iq lh b li nh ll ni lo nj ls nk lw nl ma nd ne nf ng bi translated">有用特征的数量似乎是4，因为所有的排序方法对于大约4个特征给出了它们更高的性能。</li></ul><h1 id="406c" class="mb mc iq bd md me mf mg mh mi mj mk ml kf mm kg mn ki mo kj mp kl mq km mr ms bi translated">结论:</h1><p id="73ee" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">因为一个排序方法并不(通常)耗费时间，如果我们有一个可靠的框架，我们可以使用许多排序方法来更好地洞察我们的特性质量。</p><p id="601f" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">这个框架还允许我们尝试新的评估功能或新的选择机制，我鼓励你通过分叉我的GitHub <a class="ae le" href="https://github.com/MoohShadox/LOF" rel="noopener ugc nofollow" target="_blank"> repo </a>来这样做。</p><h1 id="af22" class="mb mc iq bd md me mf mg mh mi mj mk ml kf mm kg mn ki mo kj mp kl mq km mr ms bi translated">开放式问题:</h1><p id="713a" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">这个框架提出了一个新的问题:我们能利用我们有许多特性排名的事实吗？我对答案有一点想法；保持联系，早日发现:)</p><p id="9244" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">如果你想讨论这个话题，欢迎通过邮件(ouaguenouni.hachemi@gmail.com或LinkedIn加入我的讨论。</p></div></div>    
</body>
</html>