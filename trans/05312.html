<html>
<head>
<title>Build a One Instruction Set Computer (OISC) on a Spreadsheet</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在电子表格上建立一台单指令集计算机(OISC)</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/excel-fun-bd5a1a8992b8?source=collection_archive---------31-----------------------#2021-05-10">https://towardsdatascience.com/excel-fun-bd5a1a8992b8?source=collection_archive---------31-----------------------#2021-05-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="aaf1" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">Excel的乐趣:让我们看看一个电子表格如何在指令集层面上模拟一台完整的计算机</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/986802bbf6cd09f090e0af14c1d13525.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_cpG3sN2_3iSicTU"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/@pineapple?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">菠萝供应公司</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="6989" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在数据科学中，我们经常使用电子表格来分析数据和原型算法，但是电子表格还能做什么呢？让我们看看电子表格是如何在指令集层面上模拟整个计算机的。</p><p id="5d2c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们必须支持多少条指令？嗯，Intel x86芯片(大多数PC用的)理解1500条指令。ARM芯片(用于大多数手机、平板电脑和新MAC电脑)将这一数字减少到50左右。然而，一台可行的计算机只需要一条叫做SUBLEQ的指令就可以制造出来。我们将使用Excel来看看这是如何工作的。(这里是OneDrive 上的<a class="ae kv" href="https://1drv.ms/x/s!AkoPP4cC5J64wv1TlM2xFFzdXSEDiw?e=aSSCKF" rel="noopener ugc nofollow" target="_blank">完整电子表格。)</a></p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><p id="d4c7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">典型的计算机芯片提供指令来</p><ul class=""><li id="ca7f" class="lz ma iq ky b kz la lc ld lf mb lj mc ln md lr me mf mg mh bi translated">加载和复制内存位置中的值</li><li id="2236" class="lz ma iq ky b kz mi lc mj lf mk lj ml ln mm lr me mf mg mh bi translated">比较两个存储单元中的值，</li><li id="f92b" class="lz ma iq ky b kz mi lc mj lf mk lj ml ln mm lr me mf mg mh bi translated">跳转到内存的新部分，并开始评估那里的指令。</li><li id="d0db" class="lz ma iq ky b kz mi lc mj lf mk lj ml ln mm lr me mf mg mh bi translated">对整数、浮点数，有时甚至是数字数组进行加法和乘法等数学运算</li></ul><p id="a9a5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一些计算机芯片提供指令来做更多的事情，例如，与人工智能、3D图形、密码学相关的指令。</p><p id="4452" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是，如果我们不添加更多的指令，而是删除指令呢？我们能逃脱多少指令？包括奥列格·马宗卡和亚历克斯·科洛金在内的计算机科学家说，答案是一个。马宗卡和科洛金建议选择SUBLEQ作为一个指令，因为它</p><blockquote class="mn mo mp"><p id="8b56" class="kw kx mq ky b kz la jr lb lc ld ju le mr lg lh li ms lk ll lm mt lo lp lq lr ij bi translated">“是最古老、最流行、也可以说是最高效的[单指令集计算机]”[<a class="ae kv" href="https://arxiv.org/ftp/arxiv/papers/1106/1106.2593.pdf" rel="noopener ugc nofollow" target="_blank">基于sub leq(arxiv.org)的简单多处理器计算机</a></p></blockquote><h1 id="2027" class="mu mv iq bd mw mx my mz na nb nc nd ne jw nf jx ng jz nh ka ni kc nj kd nk nl bi translated">SUBLEQ</h1><p id="63ba" class="pw-post-body-paragraph kw kx iq ky b kz nm jr lb lc nn ju le lf no lh li lj np ll lm ln nq lp lq lr ij bi translated">SUBLEQ指令包含三个部分:</p><ul class=""><li id="78d0" class="lz ma iq ky b kz la lc ld lf mb lj mc ln md lr me mf mg mh bi translated"><code class="fe nr ns nt nu b">A</code>的存储位置，要减去的值</li><li id="f14e" class="lz ma iq ky b kz mi lc mj lf mk lj ml ln mm lr me mf mg mh bi translated"><code class="fe nr ns nt nu b">B</code>的存储位置，从中减去<code class="fe nr ns nt nu b">A</code>的值</li><li id="5694" class="lz ma iq ky b kz mi lc mj lf mk lj ml ln mm lr me mf mg mh bi translated">如果<code class="fe nr ns nt nu b">B</code>小于或等于0，跳转到的内存位置。如果<code class="fe nr ns nt nu b">B</code>是正的，我们向前跳3个记忆位置。</li></ul><p id="fd45" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们来看一个基于<a class="ae kv" href="https://esolangs.org/wiki/Subleq" rel="noopener ugc nofollow" target="_blank">sub leq—Esolang(esolangs.org)</a>的Excel示例。我们把数字3，5，6，7，7，7，3，4，0存入内存。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/04f6422601bf432d6bdba1705fc5115f.png" data-original-src="https://miro.medium.com/v2/resize:fit:458/format:webp/1*gLplKef1jJV9f9M1NoV2_g.jpeg"/></div></figure><p id="ab1f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">计算机的指令指针指向下一条要执行的指令的存储位置。假设我们的指令指针指向内存位置0，那么计算机查看三个值，从内存位置0开始，即3、4和6。这意味着3是<code class="fe nr ns nt nu b">A</code>的存储位置，要减去的值是7。而且，4是<code class="fe nr ns nt nu b">B</code>的存储位置，是要从中减去a的值。该值从7开始，但减去<code class="fe nr ns nt nu b">A</code>后将变为0。最后，如果<code class="fe nr ns nt nu b">B</code>变为0或更小，6是要跳转到的存储器位置，因此指令指针将变为6。</p><h1 id="28c5" class="mu mv iq bd mw mx my mz na nb nc nd ne jw nf jx ng jz nh ka ni kc nj kd nk nl bi translated">设置Excel</h1><p id="9ce8" class="pw-post-body-paragraph kw kx iq ky b kz nm jr lb lc nn ju le lf no lh li lj np ll lm ln nq lp lq lr ij bi translated">在Excel中，我们添加以下内容:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/eb6cfba8dfd38f67f3643b2b0d7ce2fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:544/format:webp/1*Nwf7VUo2SIfzhC19DbUSYw.jpeg"/></div></figure><p id="741c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们希望能够将指令指针设置到任何内存位置，并让Excel填充该表的其余部分。这怎么可能呢？以下是我对<code class="fe nr ns nt nu b">part1</code>使用的公式:</p><pre class="kg kh ki kj gt nx nu ny nz aw oa bi"><span id="02de" class="ob mv iq nu b gy oc od l oe of">=INDIRECT(ADDRESS(ROW(D19)+D9,COLUMN(D19)))</span></pre><p id="dee1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">其中<code class="fe nr ns nt nu b">D9</code>是<code class="fe nr ns nt nu b">Instruction Pointer</code>的单元，而<code class="fe nr ns nt nu b">D19</code>是存储单元0的单元。该公式要求从内存开始向下查找值<code class="fe nr ns nt nu b">Instruction Pointer</code>。由于<code class="fe nr ns nt nu b">Instruction Pointer</code>为0，这将找到包含值3的内存位置0。<code class="fe nr ns nt nu b">part2</code>的公式是一样的，只是我们在行中加了1。对于<code class="fe nr ns nt nu b">part3</code>我们加2。<code class="fe nr ns nt nu b">A</code>的公式几乎相同，即:</p><pre class="kg kh ki kj gt nx nu ny nz aw oa bi"><span id="1e5e" class="ob mv iq nu b gy oc od l oe of">=INDIRECT(ADDRESS(ROW(D19)+D10,COLUMN(D19)))</span></pre><p id="e2b2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">其中<code class="fe nr ns nt nu b">D10</code>是<code class="fe nr ns nt nu b">part1</code>的单元格。所以，这表示从内存的开始向下查找值<code class="fe nr ns nt nu b">part1</code>。那是内存位置3，包含7。对于<code class="fe nr ns nt nu b">B</code>，我们使用<code class="fe nr ns nt nu b">A</code>公式，但用<code class="fe nr ns nt nu b">D11</code>代替<code class="fe nr ns nt nu b"> D10</code>。最后，当然，<code class="fe nr ns nt nu b">B-A</code>单元格的值就是<code class="fe nr ns nt nu b">B</code>单元格的值减去<code class="fe nr ns nt nu b">A</code>单元格的值。</p><h1 id="549f" class="mu mv iq bd mw mx my mz na nb nc nd ne jw nf jx ng jz nh ka ni kc nj kd nk nl bi translated">走向</h1><p id="ecff" class="pw-post-body-paragraph kw kx iq ky b kz nm jr lb lc nn ju le lf no lh li lj np ll lm ln nq lp lq lr ij bi translated">下一个问题是我们如何用它们的新值更新<code class="fe nr ns nt nu b">Instruction Pointer</code>和<code class="fe nr ns nt nu b">B</code>？我们可以想象关闭Excel的Recalc设置，就地更改它们的值，然后使用F9键将程序向前推进。我没那么做。相反，我为程序的下一步创建了一个新的专栏。我把程序的原步骤称为“0步”，下一步称为“1步”。</p><p id="536e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">电子表格看起来像这样。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi og"><img src="../Images/f21085e3c094eea256f4bf48064a4e40.png" data-original-src="https://miro.medium.com/v2/resize:fit:664/format:webp/1*lRXTeP905i2qH4BcLQ2tIg.jpeg"/></div></figure><p id="c287" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">黄色显示用户输入(原始存储值和<code class="fe nr ns nt nu b">Instruction Pointer</code>)。注意，在步骤1中，<code class="fe nr ns nt nu b">Instruction Pointer</code>的变化和存储器位置4中的值(显示为红色)。<code class="fe nr ns nt nu b">Instruction Pointer</code>的新值的公式是:</p><pre class="kg kh ki kj gt nx nu ny nz aw oa bi"><span id="4fa2" class="ob mv iq nu b gy oc od l oe of">=IF(D9&lt;0,D9,IF(D15&lt;=0,D12,D9+3))</span></pre><p id="7882" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">其中<code class="fe nr ns nt nu b">D9</code>是<code class="fe nr ns nt nu b">Instruction Pointer</code>的旧值，<code class="fe nr ns nt nu b">D15</code>是<code class="fe nr ns nt nu b">B-A</code>的值，<code class="fe nr ns nt nu b">D12</code>是前一条指令的<code class="fe nr ns nt nu b">part3</code>。上面写着:</p><ul class=""><li id="9b11" class="lz ma iq ky b kz la lc ld lf mb lj mc ln md lr me mf mg mh bi translated">如果<code class="fe nr ns nt nu b">instruction pointer</code>为负，保持不变(表示程序完成)。</li><li id="e472" class="lz ma iq ky b kz mi lc mj lf mk lj ml ln mm lr me mf mg mh bi translated">否则，如果<code class="fe nr ns nt nu b">B-A</code>小于或等于0，则将<code class="fe nr ns nt nu b">Instruction Pointer</code>设置为<code class="fe nr ns nt nu b">part3</code>。</li><li id="fe7f" class="lz ma iq ky b kz mi lc mj lf mk lj ml ln mm lr me mf mg mh bi translated">否则，将<code class="fe nr ns nt nu b">Instruction Pointer</code>增加3。</li></ul><p id="a708" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">存储单元4的新值的公式为</p><pre class="kg kh ki kj gt nx nu ny nz aw oa bi"><span id="a35b" class="ob mv iq nu b gy oc od l oe of">=IF($C23=D$11,D$15,D23)</span></pre><p id="851c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">其中<code class="fe nr ns nt nu b">C23</code>是包含位置号的单元格，即4。单元格<code class="fe nr ns nt nu b">D11</code>是<code class="fe nr ns nt nu b">part2</code>。单元格<code class="fe nr ns nt nu b"> D15</code>是<code class="fe nr ns nt nu b">B-A</code>。单元格<code class="fe nr ns nt nu b">D23</code>是该存储单元中的前一个值。所以，这表示:如果这个内存位置是前一步的<code class="fe nr ns nt nu b">B</code>，那么将其值设置为<code class="fe nr ns nt nu b">B-A</code>，否则保持值不变。所有的存储单元都有一个类似的公式。</p><p id="026e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以将步骤1的列复制到右边，以获得任意数量的未来步骤的列(最多到Excel的限制，大约16，000)。我们可以向下复制最后一个内存行，以获得任意数量内存的位置(最多可达Excel的1，000，000个内存的限制)。</p><h1 id="8a5e" class="mu mv iq bd mw mx my mz na nb nc nd ne jw nf jx ng jz nh ka ni kc nj kd nk nl bi translated">你好世界！</h1><p id="3063" class="pw-post-body-paragraph kw kx iq ky b kz nm jr lb lc nn ju le lf no lh li lj np ll lm ln nq lp lq lr ij bi translated">最后一个大问题仍然存在:我们如何输出任何东西？按照惯例，SUBLEQ通过向特殊内存地址-1写入一个数字来创建输出。我们可以将该数字解释为ASCII字符。下面是一个来自<a class="ae kv" href="https://esolangs.org/wiki/Subleq" rel="noopener ugc nofollow" target="_blank">sub leq—Esolang(esolangs.org)</a>的输出“Hi”的示例:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/6e902444cf03710725470538bf154526.png" data-original-src="https://miro.medium.com/v2/resize:fit:934/format:webp/1*Ml6lPtwhfTUDYbNlvAATtA.jpeg"/></div></figure><p id="8d6a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在第0步，<code class="fe nr ns nt nu b">Instruction Pointer</code>表示从内存位置0开始，这给了我们<code class="fe nr ns nt nu b">9, -1, 3</code>。因为第二个数字是-1，这意味着输出存储单元9的值，即72，然后将<code class="fe nr ns nt nu b">Instruction Pointer</code>设置为3。ASCII 72是字符“H”。</p><p id="1d19" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在步骤1中，<code class="fe nr ns nt nu b">Instruction Pointer</code>表示从内存位置3开始，这给了我们<code class="fe nr ns nt nu b">10, -1, 6</code>。这意味着输出存储单元10的值，即105 (ASCII表示“I”)，并将指令指针设置为6。</p><p id="1092" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在第2步，<code class="fe nr ns nt nu b">Instruction Pointer</code>告诉我们从内存位置6开始，这给了我们<code class="fe nr ns nt nu b">0, 0, -1</code>。这意味着从自身减去内存位置0(即9)的值，并将<code class="fe nr ns nt nu b">Instruction Pointer</code>设置为-1。</p><p id="2b68" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在步骤3，<code class="fe nr ns nt nu b">Instruction Pointer</code>表示从-1开始，这是一个负数，所以程序完成。</p><p id="2050" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了支持输出，我对电子表格做了以下更改:</p><ul class=""><li id="4fda" class="lz ma iq ky b kz la lc ld lf mb lj mc ln md lr me mf mg mh bi translated">添加了存储位置“-1”。第一步的公式是<code class="fe nr ns nt nu b">=IF(D11=-1,D13,””)</code>，如果<code class="fe nr ns nt nu b">part2</code>为-1，则输出<code class="fe nr ns nt nu b">A</code>，否则为空。</li><li id="6d11" class="lz ma iq ky b kz mi lc mj lf mk lj ml ln mm lr me mf mg mh bi translated">在<code class="fe nr ns nt nu b">B-A</code>下方增加了一行<code class="fe nr ns nt nu b">Output</code>。它只是存储单元-1的ASCII版本。其步骤1的公式为<code class="fe nr ns nt nu b">=IF(E18&lt;&gt;””,CHAR(E18),””)</code>，表示如果内存位置-1不为空，则显示其ASCII值，否则为空。</li><li id="1aed" class="lz ma iq ky b kz mi lc mj lf mk lj ml ln mm lr me mf mg mh bi translated">将<code class="fe nr ns nt nu b">B-A</code>的公式改为<code class="fe nr ns nt nu b">=IF(E9&lt;0,”HALT”,IF(E11&gt;=0,E14-E13,E13)) </code>，公式为:1)如果<code class="fe nr ns nt nu b">Instruction Pointer</code>小于0，显示“HALT”，2)如果<code class="fe nr ns nt nu b">A</code>的存储位置至少为0，从<code class="fe nr ns nt nu b">B</code>中减去<code class="fe nr ns nt nu b">A</code>，3)否则为<code class="fe nr ns nt nu b">B</code>。我还更改了<code class="fe nr ns nt nu b">part1</code>、<code class="fe nr ns nt nu b">part2</code>、<code class="fe nr ns nt nu b">part3</code>、<code class="fe nr ns nt nu b">A</code>和<code class="fe nr ns nt nu b">B </code>的公式，以便在指令指针为负时显示“暂停”。</li></ul><p id="3b87" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有了这个，我们可以运行更多有趣的SUBLEQ程序。例如，“你好，世界！”<a class="ae kv" href="https://esolangs.org/wiki/Subleq" rel="noopener ugc nofollow" target="_blank"> Subleq示例—Esolang(esolangs.org)</a>使用循环将所需字符串复制到输出，并在到达字符串末尾时停止。这是电子表格的顶角。您可以在输出行中看到“H”和“e”。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oi"><img src="../Images/5ad5d4af1e3b92bc90664d4d1dd786b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DPt3VTiewZdX7CwlKf0wPQ.png"/></div></div></figure><p id="1077" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在OneDrive 上找到<a class="ae kv" href="https://1drv.ms/x/s!AkoPP4cC5J64wv1TlM2xFFzdXSEDiw?e=aSSCKF" rel="noopener ugc nofollow" target="_blank">完整的电子表格。在网上或下载后，你可以玩电子表格。你也可以放入你自己的SUBLEQ程序，或者看看如果你改变初始的<code class="fe nr ns nt nu b">Instruction Pointer</code>值会发生什么。</a></p><h1 id="09bc" class="mu mv iq bd mw mx my mz na nb nc nd ne jw nf jx ng jz nh ka ni kc nj kd nk nl bi translated">讨论</h1><p id="d1f5" class="pw-post-body-paragraph kw kx iq ky b kz nm jr lb lc nn ju le lf no lh li lj np ll lm ln nq lp lq lr ij bi translated">在电子表格上实现SUBLEQ让我们看到如何只用一条指令就能设计出计算机芯片。用更传统的语言(比如Python)演示SUBLEQ会更容易，但是电子表格提供了两个好处:</p><ul class=""><li id="7606" class="lz ma iq ky b kz la lc ld lf mb lj mc ln md lr me mf mg mh bi translated">首先，把计算的每一步放入它自己的列，让我们以一种新的方式来看一个程序。我们不再把程序和计算机看作是随时间变化的一维向量，而是把程序的整个历史看作是一个二维数组。</li><li id="2e09" class="lz ma iq ky b kz mi lc mj lf mk lj ml ln mm lr me mf mg mh bi translated">其次，我们可以更改单个输入单元格，Excel将只有效地更新那些需要更改的单元格。例如，在完整的“Hello World！”例如，将初始的<code class="fe nr ns nt nu b">Instruction Pointer</code>从0改为1。令人惊讶的是，该程序仍然有效。把它改成3，你会发现程序不仅还能工作，甚至运行得更快了。</li></ul></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><p id="1a2f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你想要更多的Excel乐趣，请参阅我的文章<a class="ae kv" href="https://www.microsoft.com/en-us/microsoft-365/blog/2015/02/18/excel-fun-build-3d-graphics-spreadsheet/" rel="noopener ugc nofollow" target="_blank"> Excel乐趣——从电子表格构建3D图形——微软365博客</a>。我展示了如何实现和理解3D图形。您可以通过更改电子表格值来交互式旋转正方形和立方体。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oj"><img src="../Images/832e8a7b2dca8f139b69d31b6b2d605d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*daXiDvkpCygGiSKUIUXXFQ.jpeg"/></div></div></figure></div></div>    
</body>
</html>