<html>
<head>
<title>How to derive summary statistics using PostgreSQL</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用PostgreSQL导出汇总统计数据</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-derive-summary-statistics-using-postgresql-742f3cdc0f44?source=collection_archive---------2-----------------------#2021-10-06">https://towardsdatascience.com/how-to-derive-summary-statistics-using-postgresql-742f3cdc0f44?source=collection_archive---------2-----------------------#2021-10-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="cffa" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用PostgreSQL导出数值和分类字段的汇总统计数据</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/78f4bc029030ee0fdda213038b5d30f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OyeNmhElsADd237nBkeoMQ.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/@campaign_creators?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">活动发起人</a>在<a class="ae kv" href="https://unsplash.com/s/photos/database?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="5db7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，我们将讨论如何使用SQL获得数字和分类列/字段的汇总统计数据。我们将使用从<strong class="ky ir"> Tableau公共样本数据集下载的<strong class="ky ir">网飞电影和电视节目</strong>数据集(</strong><a class="ae kv" href="https://public.tableau.com/en-us/s/resources" rel="noopener ugc nofollow" target="_blank">https://public.tableau.com/en-us/s/resources</a>并转到样本数据<strong class="ky ir">)。</strong>该数据集由截至2019年网飞可用的电视节目和电影组成，由Tableau从<a class="ae kv" href="https://www.kaggle.com/shivamb/netflix-shows" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> Kaggle </strong> </a>获取，数据集的更新版本可在Kaggle上找到。然而，对于本文，我们将使用在<strong class="ky ir"> Tableau样本数据集</strong>中可用的旧版本，并将其导入到<strong class="ky ir"> Postgres </strong>中。本文假设读者对SQL查询和统计有基本的了解。下面是我们将在整篇文章中使用的<strong class="ky ir"> <em class="ls">网飞_titles </em> </strong>的快照。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi lt"><img src="../Images/1066df15d02c709900497db080e6ebd9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lYAN_nPiFadylMguvB9ihA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">网飞_标题表(图片由作者提供)</p></figure><h1 id="919e" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">数字变量的汇总统计</h1><p id="8057" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">常用的数字变量汇总统计有均值、中值、最小值、最大值、范围、标准差、方差、Q1、Q3、IQR和偏度。</p><h2 id="e164" class="mr lv iq bd lw ms mt dn ma mu mv dp me lf mw mx mg lj my mz mi ln na nb mk nc bi translated"><strong class="ak">的意思是</strong></h2><p id="6ee2" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">在PostgreSQL中，使用<strong class="ky ir"> AVG() </strong>函数计算数值字段/列的平均值。我们将计算<strong class="ky ir"> <em class="ls">持续时间_分钟</em> </strong>字段的平均值，如下所示。</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="6bcd" class="mr lv iq ne b gy ni nj l nk nl"><strong class="ne ir">SELECT</strong> <br/> <strong class="ne ir">AVG</strong>(duration_minutes) <strong class="ne ir">AS</strong> mean<br/>  <strong class="ne ir">FROM</strong> netflix_titles;</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/d16080a42d126fbba9b6470a206d9eba.png" data-original-src="https://miro.medium.com/v2/resize:fit:374/format:webp/1*7dgBbVWqXYMtE_c9L0Y5Lw.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><h2 id="4c4f" class="mr lv iq bd lw ms mt dn ma mu mv dp me lf mw mx mg lj my mz mi ln na nb mk nc bi translated"><strong class="ak">中间值</strong></h2><p id="a740" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">在PostgreSQL中，没有直接计算数值字段/列的中值的函数。然而，由于中位数是第50个百分位数，我们可以用它来代替中位数。使用<strong class="ky ir"> PERCENTILE_CONT() </strong>函数计算数值变量的百分比。我们将计算<strong class="ky ir"> <em class="ls">持续时间_分钟</em> </strong>字段的中值，如下所示。</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="8ed4" class="mr lv iq ne b gy ni nj l nk nl"><strong class="ne ir">SELECT <br/> PERCENTILE_CONT</strong>(0.5) <strong class="ne ir">WITHIN GROUP</strong> (<strong class="ne ir">ORDER BY</strong> duration_minutes) <strong class="ne ir">AS</strong> median<br/>  <strong class="ne ir">FROM</strong> netflix_titles;</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/c9bac943e0b59112849b3a997ca5d910.png" data-original-src="https://miro.medium.com/v2/resize:fit:306/format:webp/1*xotHffQ8mJzMeH0k6uaEPA.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="68f8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> WITHIN GROUP </strong>子句创建可用于执行聚合的有序数据子集。<strong class="ky ir"> PERCENTILE_CONT </strong>将所需的百分位作为参数，本例中为0.5，即第50个百分位。</p><h2 id="8fba" class="mr lv iq bd lw ms mt dn ma mu mv dp me lf mw mx mg lj my mz mi ln na nb mk nc bi translated"><strong class="ak">最小值</strong></h2><p id="29c6" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">在PostgreSQL中，使用<strong class="ky ir"> MIN() </strong>函数找到数值字段/列的最小值。我们将找到<strong class="ky ir"><em class="ls">duration _ minutes</em></strong>字段的最小值，如下所示。</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="ba03" class="mr lv iq ne b gy ni nj l nk nl"><strong class="ne ir">SELECT </strong><br/> <strong class="ne ir">MIN</strong>(duration_minutes) <strong class="ne ir">AS</strong> min <br/>  <strong class="ne ir">FROM</strong> netflix_titles;</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi no"><img src="../Images/58fbc57989c66a94c0c237e5aec11473.png" data-original-src="https://miro.medium.com/v2/resize:fit:172/format:webp/1*pEMwwPRJq-307lYLPrbOhg.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><h2 id="242d" class="mr lv iq bd lw ms mt dn ma mu mv dp me lf mw mx mg lj my mz mi ln na nb mk nc bi translated"><strong class="ak">最大值</strong></h2><p id="93f9" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">在PostgreSQL中，使用<strong class="ky ir"> MAX() </strong>函数找到数值字段/列的最大值。我们将找到<strong class="ky ir"><em class="ls">duration _ minutes</em></strong>字段的最大值，如下所示。</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="0ab1" class="mr lv iq ne b gy ni nj l nk nl"><strong class="ne ir">SELECT </strong><br/> <strong class="ne ir">MAX</strong>(duration_minutes) <strong class="ne ir">AS</strong> max <br/>  <strong class="ne ir">FROM</strong> netflix_titles;</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi np"><img src="../Images/66bd90fe5ec2c913eedab771bce598f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:164/format:webp/1*OZuHHrkjGAD09aqlLU4fwQ.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><h2 id="1e11" class="mr lv iq bd lw ms mt dn ma mu mv dp me lf mw mx mg lj my mz mi ln na nb mk nc bi translated">范围</h2><p id="e934" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">在PostgreSQL中，没有直接计算数值字段/列范围的函数。然而，由于范围是最大值和最小值之间的差值，我们可以用它作为范围的代理。</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="7d89" class="mr lv iq ne b gy ni nj l nk nl"><strong class="ne ir">SELECT </strong><br/> <strong class="ne ir">MAX</strong>(duration_minutes) - <strong class="ne ir">MIN</strong>(duration_minutes) <strong class="ne ir">AS</strong> range<br/>    <strong class="ne ir">FROM</strong> netflix_titles;</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/16da32375b312ffb80ca3a261cd0b1e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:170/format:webp/1*FRd2Q-qFS1i9ttsEDg2gjg.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><h2 id="f345" class="mr lv iq bd lw ms mt dn ma mu mv dp me lf mw mx mg lj my mz mi ln na nb mk nc bi translated">标准偏差</h2><p id="d255" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">在PostgreSQL中，使用<strong class="ky ir"> STDDEV() </strong>函数计算数值字段/列的标准偏差。我们将计算<strong class="ky ir"> <em class="ls">持续时间_分钟</em> </strong>字段的标准偏差，如下所示。</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="38ea" class="mr lv iq ne b gy ni nj l nk nl"><strong class="ne ir">SELECT</strong> <br/> <strong class="ne ir">ROUND</strong>(<strong class="ne ir">STDDEV</strong>(duration_minutes), 2) <strong class="ne ir">AS</strong> standard_deviation<br/>    <strong class="ne ir">FROM</strong> netflix_titles;</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/162f715dda68cbfd60c922c78ec1019e.png" data-original-src="https://miro.medium.com/v2/resize:fit:344/format:webp/1*CVrRH4E4C58qzfXKofOI-A.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="658e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">或</strong></p><p id="1066" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们还可以将标准差计算为方差的平方根，如下所示。</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="a886" class="mr lv iq ne b gy ni nj l nk nl"><strong class="ne ir">SELECT </strong><br/> <strong class="ne ir">ROUND</strong>(<strong class="ne ir">SQRT</strong>(<strong class="ne ir">VARIANCE</strong>(duration_minutes)), 2) <strong class="ne ir">AS</strong> stddev_using_variance<br/>    <strong class="ne ir">FROM</strong> netflix_titles;</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/777419d644c497099de38f87272d342d.png" data-original-src="https://miro.medium.com/v2/resize:fit:392/format:webp/1*Ifk845plNEBHZA2oIeSMZg.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><h2 id="9af5" class="mr lv iq bd lw ms mt dn ma mu mv dp me lf mw mx mg lj my mz mi ln na nb mk nc bi translated">差异</h2><p id="ea92" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">在PostgreSQL中，使用<strong class="ky ir"> VARIANCE() </strong>函数计算数值字段/列的方差。我们将计算<strong class="ky ir"> <em class="ls">持续时间_分钟</em> </strong>字段的方差，如下所示。</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="5815" class="mr lv iq ne b gy ni nj l nk nl"><strong class="ne ir">SELECT </strong><br/> <strong class="ne ir">ROUND</strong>(<strong class="ne ir">VARIANCE</strong>(duration_minutes), 2) <strong class="ne ir">AS</strong> variance<br/>    <strong class="ne ir">FROM</strong> netflix_titles;</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/812f8867c6f729fc9c4ce135444fabba.png" data-original-src="https://miro.medium.com/v2/resize:fit:204/format:webp/1*EbZx4D4mWVJR56v1BoUrYA.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="a359" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">或</strong></p><p id="2315" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们也可以将方差计算为标准差的平方，如下所示。</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="84e5" class="mr lv iq ne b gy ni nj l nk nl"><strong class="ne ir">SELECT </strong><br/> <strong class="ne ir">ROUND</strong>(<strong class="ne ir">POWER</strong>(<strong class="ne ir">STDDEV</strong>(duration_minutes), 2), 2) <strong class="ne ir">AS</strong> variance_using_stddev<br/>    <strong class="ne ir">FROM</strong> netflix_titles;</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/dd2c4236dcce15c922cc7f01cb169e79.png" data-original-src="https://miro.medium.com/v2/resize:fit:390/format:webp/1*xiYBV1iL1ucruvqHQd-Mfg.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><h2 id="dcac" class="mr lv iq bd lw ms mt dn ma mu mv dp me lf mw mx mg lj my mz mi ln na nb mk nc bi translated"><strong class="ak"> Q1 </strong></h2><p id="3004" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">在PostgreSQL中，没有直接计算数值字段/列的第一个四分位数(Q1)的函数。然而，由于Q1是第25个百分点，我们可以用它来代表Q1。我们将计算<strong class="ky ir"> <em class="ls">持续时间_分钟</em> </strong>字段的Q1，如下所示。</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="4699" class="mr lv iq ne b gy ni nj l nk nl"><strong class="ne ir">SELECT</strong><br/> <strong class="ne ir">PERCENTILE_CONT</strong>(0.25) <strong class="ne ir">WITHIN GROUP</strong> (<strong class="ne ir">ORDER BY</strong> duration_minutes) <strong class="ne ir">AS</strong> q1<br/>    <strong class="ne ir">FROM</strong> netflix_titles;</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/b64f290ab5570b17426ba7310df4ea80.png" data-original-src="https://miro.medium.com/v2/resize:fit:314/format:webp/1*wRNBzUJnr6rrHR1dl_mzWA.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><h2 id="825a" class="mr lv iq bd lw ms mt dn ma mu mv dp me lf mw mx mg lj my mz mi ln na nb mk nc bi translated">Q3</h2><p id="4dd7" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">在PostgreSQL中，没有直接计算数值字段/列的第三个四分位数(Q3)的函数。但是，由于第3季度是第75个百分点，我们可以用它来代替第3季度。我们将计算<strong class="ky ir"> <em class="ls">持续时间_分钟</em> </strong>字段的Q3，如下所示。</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="a7a8" class="mr lv iq ne b gy ni nj l nk nl"><strong class="ne ir">SELECT</strong><br/> <strong class="ne ir">PERCENTILE_CONT</strong>(0.75) <strong class="ne ir">WITHIN GROUP</strong> (<strong class="ne ir">ORDER BY</strong> duration_minutes) <strong class="ne ir">AS</strong> q3<br/>    <strong class="ne ir">FROM</strong> netflix_titles;</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/a5f4423384a34a68caa734c3407f5a78.png" data-original-src="https://miro.medium.com/v2/resize:fit:306/format:webp/1*QidaVm9tBTKbnIunhLsFKw.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><h2 id="4bc6" class="mr lv iq bd lw ms mt dn ma mu mv dp me lf mw mx mg lj my mz mi ln na nb mk nc bi translated">IQR</h2><p id="c4c1" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">在PostgreSQL中，没有直接计算数值字段/列的四分位间距(IQR)的函数。然而，由于IQR是第三季度和Q1之间的差异，我们可以用它作为IQR的代理。我们将计算<strong class="ky ir"> <em class="ls">持续时间_分钟</em> </strong>字段的IQR，如下所示。</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="d349" class="mr lv iq ne b gy ni nj l nk nl"><strong class="ne ir">SELECT</strong><br/> <strong class="ne ir">PERCENTILE_CONT</strong>(0.75) <strong class="ne ir">WITHIN GROUP</strong> (<strong class="ne ir">ORDER BY</strong> duration_minutes) -<br/> <strong class="ne ir">PERCENTILE_CONT</strong>(0.25) <strong class="ne ir">WITHIN GROUP</strong> (<strong class="ne ir">ORDER BY</strong> duration_minutes) <strong class="ne ir">AS</strong> iqr<br/>     <strong class="ne ir">FROM</strong> netflix_titles;</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/3c584291517cc215d2d471d8b5128d1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:306/format:webp/1*Wi5WFJst9aAQ4Z-AOUP8XA.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><h2 id="8bfd" class="mr lv iq bd lw ms mt dn ma mu mv dp me lf mw mx mg lj my mz mi ln na nb mk nc bi translated">歪斜</h2><p id="6a7f" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">在PostgreSQL中，没有直接计算数值字段/列的偏斜度的函数。然而，由于偏斜度是<strong class="ky ir"> 3 *(均值-中值)/标准差</strong>，我们可以用它来代替偏斜度。我们将计算<strong class="ky ir"> <em class="ls">持续时间_分钟</em> </strong>字段的偏斜度，如下所示。为了让代码更具可读性，我们将使用CTE来计算平均值、中值和标准差。</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="de1d" class="mr lv iq ne b gy ni nj l nk nl"><strong class="ne ir">WITH</strong> mean_median_sd <strong class="ne ir">AS</strong><br/>(<br/> <strong class="ne ir">SELECT</strong> <br/>  <strong class="ne ir">AVG</strong>(duration_minutes) <strong class="ne ir">AS</strong> mean,<br/>  <strong class="ne ir">PERCENTILE_CONT</strong>(0.5) <strong class="ne ir">WITHIN GROUP</strong> (<strong class="ne ir">ORDER BY</strong> duration_minutes) <strong class="ne ir">AS</strong> median,<br/>  <strong class="ne ir">STDDEV</strong>(duration_minutes) <strong class="ne ir">AS</strong> stddev<br/>   <strong class="ne ir">FROM</strong> netflix_titles<br/>)</span><span id="95a1" class="mr lv iq ne b gy nw nj l nk nl"><strong class="ne ir">SELECT</strong> <br/> <strong class="ne ir">ROUND</strong>(3 * (mean - median)<strong class="ne ir">::NUMERIC</strong> / stddev, 2) <strong class="ne ir">AS</strong> skewness<br/>  <strong class="ne ir">FROM</strong> mean_median_sd;</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/cac9a1edee1ebf2bd98cdb372f84f631.png" data-original-src="https://miro.medium.com/v2/resize:fit:224/format:webp/1*q0zjJEkVgxiV1Phc_6ZPHQ.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><h2 id="faf2" class="mr lv iq bd lw ms mt dn ma mu mv dp me lf mw mx mg lj my mz mi ln na nb mk nc bi translated"><strong class="ak">将所有这些放在一起</strong></h2><p id="4855" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">我们将把前面讨论的所有函数放在一起，并在一个表中返回它们。在下面的查询中，我们将创建两个cte，即<strong class="ky ir"> <em class="ls"> summary_stats </em> </strong>(每列返回一个前面讨论过的统计信息)和<strong class="ky ir"><em class="ls">row _ summary _ stats</em></strong>(每行返回一个统计信息)。</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="a0a0" class="mr lv iq ne b gy ni nj l nk nl"><strong class="ne ir">WITH RECURSIVE</strong><br/>summary_stats <strong class="ne ir">AS</strong><br/>(<br/> <strong class="ne ir">SELECT</strong> <br/>  <strong class="ne ir">ROUND</strong>(<strong class="ne ir">AVG</strong>(duration_minutes), 2) <strong class="ne ir">AS</strong> mean,<br/>  <strong class="ne ir">PERCENTILE_CONT</strong>(0.5) <strong class="ne ir">WITHIN GROUP</strong> (<strong class="ne ir">ORDER BY</strong> duration_minutes) <strong class="ne ir">AS</strong> median,<br/>  <strong class="ne ir">MIN</strong>(duration_minutes) <strong class="ne ir">AS</strong> min,<br/>  <strong class="ne ir">MAX</strong>(duration_minutes) <strong class="ne ir">AS</strong> max,<br/>  <strong class="ne ir">MAX</strong>(duration_minutes) - <strong class="ne ir">MIN</strong>(duration_minutes) <strong class="ne ir">AS</strong> range,<br/>  <strong class="ne ir">ROUND</strong>(<strong class="ne ir">STDDEV</strong>(duration_minutes), 2) <strong class="ne ir">AS</strong> standard_deviation,<br/>  <strong class="ne ir">ROUND</strong>(<strong class="ne ir">VARIANCE</strong>(duration_minutes), 2) <strong class="ne ir">AS</strong> variance,<br/>  <strong class="ne ir">PERCENTILE_CONT</strong>(0.25) <strong class="ne ir">WITHIN GROUP</strong> (<strong class="ne ir">ORDER BY</strong> duration_minutes) <strong class="ne ir">AS</strong> q1,<br/>  <strong class="ne ir">PERCENTILE_CONT</strong>(0.75) <strong class="ne ir">WITHIN GROUP</strong> (<strong class="ne ir">ORDER BY</strong> duration_minutes) <strong class="ne ir">AS</strong> q3<br/>   <strong class="ne ir">FROM</strong> netflix_titles<br/>),</span><span id="26aa" class="mr lv iq ne b gy nw nj l nk nl">row_summary_stats <strong class="ne ir">AS</strong><br/>(<br/><strong class="ne ir">SELECT</strong> <br/> 1 <strong class="ne ir">AS</strong> sno, <br/> 'mean' <strong class="ne ir">AS</strong> statistic, <br/> mean <strong class="ne ir">AS</strong> value <br/>  <strong class="ne ir">FROM</strong> summary_stats<br/><strong class="ne ir">UNION<br/>SELECT</strong> <br/> 2, <br/> 'median', <br/> median <br/>  <strong class="ne ir">FROM</strong> summary_stats<br/><strong class="ne ir">UNION<br/>SELECT</strong> <br/> 3, <br/> 'minimum', <br/> min <br/>  <strong class="ne ir">FROM</strong> summary_stats<br/><strong class="ne ir">UNION<br/>SELECT <br/></strong> 4, <br/> 'maximum', <br/> max <br/>  <strong class="ne ir">FROM</strong> summary_stats<br/><strong class="ne ir">UNION<br/>SELECT</strong> <br/> 5, <br/> 'range', <br/> range <br/>  <strong class="ne ir">FROM</strong> summary_stats<br/><strong class="ne ir">UNION<br/>SELECT <br/></strong> 6, <br/> 'standard deviation', <br/> standard_deviation <br/>  <strong class="ne ir">FROM</strong> summary_stats<br/><strong class="ne ir">UNION<br/>SELECT <br/></strong> 7, <br/> 'variance', <br/> variance <br/>  <strong class="ne ir">FROM</strong> summary_stats<br/><strong class="ne ir">UNION<br/>SELECT <br/></strong> 9, <br/> 'Q1', <br/> q1 <br/>  <strong class="ne ir">FROM</strong> summary_stats<br/><strong class="ne ir">UNION<br/>SELECT <br/></strong> 10, <br/> 'Q3', <br/> q3 <br/>  <strong class="ne ir">FROM</strong> summary_stats<br/><strong class="ne ir">UNION<br/>SELECT <br/></strong> 11, <br/> 'IQR', <br/> (q3 - q1) <br/>  <strong class="ne ir">FROM</strong> summary_stats<br/><strong class="ne ir">UNION<br/>SELECT <br/></strong> 12, <br/> 'skewness', <br/> <strong class="ne ir">ROUND</strong>(3 * (mean - median)<strong class="ne ir">::NUMERIC</strong> / standard_deviation, 2) <strong class="ne ir">AS</strong> skewness <br/>  <strong class="ne ir">FROM</strong> summary_stats<br/>)</span><span id="bce3" class="mr lv iq ne b gy nw nj l nk nl"><strong class="ne ir">SELECT</strong> * <br/> <strong class="ne ir">FROM</strong> row_summary_stats<br/>  <strong class="ne ir">ORDER BY</strong> sno;</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/c24673f2e707aebdfb9ecf31195a357a.png" data-original-src="https://miro.medium.com/v2/resize:fit:790/format:webp/1*iqTAURv7XpGGTzJmREmiFA.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><h1 id="db06" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">分类变量的汇总统计</h1><p id="dfda" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">分类变量常用的汇总统计数据有模式、基数(唯一类别的数量)、频率和相对频率。</p><h2 id="e710" class="mr lv iq bd lw ms mt dn ma mu mv dp me lf mw mx mg lj my mz mi ln na nb mk nc bi translated">方式</h2><p id="f3b1" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">在PostgreSQL中，使用<strong class="ky ir"> MODE() </strong>函数计算分类字段/列的模式。我们将计算<strong class="ky ir"> <em class="ls">评级</em> </strong>字段的模式，如下所示。</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="17f1" class="mr lv iq ne b gy ni nj l nk nl"><strong class="ne ir">SELECT </strong><br/> <strong class="ne ir">MODE</strong>() <strong class="ne ir">WITHIN GROUP</strong> (<strong class="ne ir">ORDER BY</strong> rating) <strong class="ne ir">AS</strong> mode<br/>  <strong class="ne ir">FROM</strong> netflix_titles;</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi np"><img src="../Images/a9a681d3bda3f7cfb2f2cae050e96c21.png" data-original-src="https://miro.medium.com/v2/resize:fit:164/format:webp/1*9E1lTHJBW6iBh4wZUPhL_A.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><h2 id="2ea7" class="mr lv iq bd lw ms mt dn ma mu mv dp me lf mw mx mg lj my mz mi ln na nb mk nc bi translated">基数</h2><p id="bd47" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">在PostgreSQL中，没有直接计算分类字段/列的唯一值数量的函数。但是，我们可以计算变量的不同值，如下所示。</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="0990" class="mr lv iq ne b gy ni nj l nk nl"><strong class="ne ir">SELECT</strong> <br/> <strong class="ne ir">COUNT</strong>(<strong class="ne ir">DISTINCT</strong> rating) <strong class="ne ir">AS</strong> cardinality<br/>  <strong class="ne ir">FROM</strong> netflix_titles;</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/940f231dce4c374bdf7108c6374895b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:226/format:webp/1*QhsWyKrJO1zB5PKK-vr4hQ.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><h2 id="2332" class="mr lv iq bd lw ms mt dn ma mu mv dp me lf mw mx mg lj my mz mi ln na nb mk nc bi translated">频率和相对频率</h2><p id="4d55" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">在Postgres中，我们可以使用<strong class="ky ir"> GROUP BY </strong>和<strong class="ky ir"> COUNT </strong>来计算类别变量中类别的出现频率。对于相对频率，我们将使用CTE来计算评级字段中值的总数，并使用它来计算相对频率。因为，不是所有的数据库都支持窗口函数，我们将使用CTE。我们还将讨论如何使用窗口函数计算相对频率。</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="cb25" class="mr lv iq ne b gy ni nj l nk nl"><strong class="ne ir">WITH</strong> total_count <strong class="ne ir">AS</strong><br/>(<br/><strong class="ne ir">SELECT</strong><br/> <strong class="ne ir">COUNT</strong>(rating) <strong class="ne ir">AS</strong> total_cnt<br/>  <strong class="ne ir">FROM</strong> netflix_titles<br/>)</span><span id="880b" class="mr lv iq ne b gy nw nj l nk nl"><strong class="ne ir">SELECT</strong> <br/> rating,<br/> <strong class="ne ir">COUNT</strong>(rating) <strong class="ne ir">AS</strong> frequency,<br/> <strong class="ne ir">ROUND</strong>(<strong class="ne ir">COUNT</strong>(rating)<strong class="ne ir">::NUMERIC</strong> / <br/>    (<strong class="ne ir">SELECT</strong> total_cnt <strong class="ne ir">FROM</strong> total_count), 4) <strong class="ne ir">AS</strong> relative_frequency<br/>    <strong class="ne ir">FROM</strong> netflix_titles<br/>     <strong class="ne ir">GROUP BY</strong> rating<br/>   <strong class="ne ir">ORDER BY </strong>frequency <strong class="ne ir">DESC</strong>;</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/6b8f043cfc95d734b05ac3e50f61a46c.png" data-original-src="https://miro.medium.com/v2/resize:fit:744/format:webp/1*WRcftJVu02B-T_R--ACfBQ.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="01d9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上面的例子中，我们已经创建了一个CTE来捕获<strong class="ky ir"> <em class="ls"> rating </em> </strong>字段中的值的计数。然后，我们使用它来计算<strong class="ky ir"> <em class="ls">评级</em> </strong>字段中每个类别的百分比/相对频率。由于Postgres支持窗口函数，我们将看到一种使用窗口函数计算相对频率的更简单的方法。我们将使用<strong class="ky ir"> OVER() </strong>来计算每组评分的总数，这也就是<strong class="ky ir"> <em class="ls">评分</em> </strong>字段中值的总数。</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="53bd" class="mr lv iq ne b gy ni nj l nk nl"><strong class="ne ir">SELECT</strong> <br/> rating,<br/> <strong class="ne ir">COUNT</strong>(rating) <strong class="ne ir">AS</strong> frequency,<br/> <strong class="ne ir">ROUND</strong>(<strong class="ne ir">COUNT</strong>(rating)<strong class="ne ir">::NUMERIC</strong> / <strong class="ne ir">SUM</strong>(<strong class="ne ir">COUNT</strong>(rating)) <strong class="ne ir">OVER()</strong>, 4) <strong class="ne ir">AS</strong> relative_frequency<br/>    <strong class="ne ir">FROM</strong> netflix_titles<br/>     <strong class="ne ir">GROUP BY</strong> rating<br/>      <strong class="ne ir">ORDER BY</strong> frequency <strong class="ne ir">DESC</strong>;</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/cba7a07af0b0310ae8ffe62ae3ab4c68.png" data-original-src="https://miro.medium.com/v2/resize:fit:766/format:webp/1*75AGq-iX0jsOqvdZ339CSQ.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="21f3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">文章到此结束。我们已经讨论了计算常用数值字段汇总统计数据的各种函数，如均值、中值、最小值、最大值、Q1、Q2、IQR等。以及基数、频率等分类字段。汇总统计可用于了解数据分布，也有助于识别潜在的异常值。</p></div></div>    
</body>
</html>