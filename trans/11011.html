<html>
<head>
<title>Dask DataFrame is not Pandas</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Dask DataFrame 不是熊猫</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/dask-dataframe-is-not-pandas-6764da1291b1?source=collection_archive---------43-----------------------#2021-10-26">https://towardsdatascience.com/dask-dataframe-is-not-pandas-6764da1291b1?source=collection_archive---------43-----------------------#2021-10-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="5c61" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">在 Dask 中重用熊猫代码的最可靠方法</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/8cdd54dbeeb8e0b03993d61a43a64146.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u8sPzcQIb-aewxw7vwG70A.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由 CHUTTERSNAP 在 Unsplash 上拍摄</p></figure><p id="9ff1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">本文是关于实践中使用 Dask 的系列文章的第二篇。本系列的每一篇文章对初学者来说都足够简单，但是为实际工作提供了有用的提示。本系列的下一篇文章是关于循环的 <a class="ae ls" href="https://saturncloud.io/blog/dask-for-beginners/" rel="noopener ugc nofollow" target="_blank"> <em class="lr">并行化，以及其他令人尴尬的使用 dask.delayed </em> </a>的并行操作</p><h1 id="f64e" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">诱惑</h1><p id="5994" class="pw-post-body-paragraph kv kw iq kx b ky ml jr la lb mm ju ld le mn lg lh li mo lk ll lm mp lo lp lq ij bi translated">您从中等大小的数据集开始。熊猫做得很好。然后数据集变得更大，因此您可以扩展到更大的机器。但是最终，您会耗尽机器上的内存，或者您需要找到一种方法来利用更多的内核，因为您的代码运行缓慢。此时，用 Dask 数据帧替换 Pandas 数据帧对象。</p><p id="5e64" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">不幸的是，这通常不会很顺利，会导致很大的痛苦。要么是你在 Pandas 中依赖的一些方法，在 Dask DataFrame 中没有实现(我看着你呢，MultiIndex)，方法的行为略有不同，要么是对应的 Dask 操作失败，内存耗尽，崩溃(我以为不应该这样！)</p><p id="f251" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">Pandas 是一个为单个 Python 进程设计的库。分布式算法和数据结构是根本不同的。在 Dask 数据帧方面可以做一些工作来使它变得更好，但是单个进程和机器集群总是具有非常不同的性能特征。你不应该试图对抗这个基本的真理。</p><p id="499f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">Dask 是扩展你的熊猫代码的好方法。天真地把你的熊猫数据帧转换成 Dask 数据帧不是正确的做法。根本的转变不应该是用 Dask 替换 Pandas，而是重用您为单个 Python 进程编写的算法、代码和方法。这是本文的核心。一旦你重构了你的思维，剩下的就不是火箭科学了。</p><p id="8a38" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">有 3 种主要的方法来利用 Dask 的熊猫代码</strong></p><ul class=""><li id="ac81" class="mq mr iq kx b ky kz lb lc le ms li mt lm mu lq mv mw mx my bi translated">把你的大问题分解成许多小问题</li><li id="d5db" class="mq mr iq kx b ky mz lb na le nb li nc lm nd lq mv mw mx my bi translated">使用分组依据和聚合</li><li id="fdfc" class="mq mr iq kx b ky mz lb na le nb li nc lm nd lq mv mw mx my bi translated">使用 dask 数据帧作为其他分布式算法的容器。</li></ul><h1 id="f84d" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">把你的大问题分解成许多小问题</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/cdb396587a3b8dc2ff4061eece4b81fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:928/format:webp/0*J4qdAgObBKaHhiod.jpeg"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由杰克逊在 Unsplash 煨</p></figure><p id="6eaf" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">一个 Dask 数据帧由许多熊猫数据帧组成。它非常擅长从那些熊猫数据帧中移动行，这样你就可以在你自己的函数中使用它们。这里的一般方法是用拆分-应用-组合的模式来表达你的问题。</p><ul class=""><li id="5a08" class="mq mr iq kx b ky kz lb lc le ms li mt lm mu lq mv mw mx my bi translated">将您的大数据集(Dask 数据框架)分割成较小的数据集(Pandas 数据框架)</li><li id="51c3" class="mq mr iq kx b ky mz lb na le nb li nc lm nd lq mv mw mx my bi translated">对这些较小的数据集应用函数(Pandas 函数，而不是 Dask 函数)</li><li id="0d41" class="mq mr iq kx b ky mz lb na le nb li nc lm nd lq mv mw mx my bi translated">将结果组合回一个大数据集(Dask DataFrame)</li></ul><p id="bd7e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">分割数据有两种主要方法:</p><p id="c439" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe nf ng nh ni b">set_index</code>将使 Dask 数据帧的一列成为索引，并根据该索引对数据进行排序。默认情况下，它会估计该列的数据分布，以便最终得到大小均匀的分区(Pandas DataFrames)。</p><p id="49e0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe nf ng nh ni b">shuffle</code>将把行组合在一起，这样具有相同 shuffle 列值的行就在同一个分区中。这与 set_index 不同，它没有对结果进行排序的保证，但是您可以按多个列进行分组。</p><p id="72b6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">一旦你的数据被分割，<code class="fe nf ng nh ni b">map_partitions</code>是一个很好的方法来应用一个函数到每一个熊猫数据帧，然后把结果组合回一个 Dask 数据帧。</p><h2 id="a06c" class="nj lu iq bd lv nk nl dn lz nm nn dp md le no np mf li nq nr mh lm ns nt mj nu bi translated">但是我有不止一个数据框架</h2><p id="d65d" class="pw-post-body-paragraph kv kw iq kx b ky ml jr la lb mm ju ld le mn lg lh li mo lk ll lm mp lo lp lq ij bi translated">没问题！只要你能以同样的方式分割计算中使用的所有 Dask 数据帧，你就可以开始了。</p><h1 id="65a8" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">具体的例子</h1><p id="2a23" class="pw-post-body-paragraph kv kw iq kx b ky ml jr la lb mm ju ld le mn lg lh li mo lk ll lm mp lo lp lq ij bi translated">我不打算在这里写代码。我们的目标是在这个理论描述的基础上放一个具体的例子，以获得一些关于这个看起来像什么的直觉。想象一下，我有一个股票价格的 Dask 数据框架，和另一个分析师对相同股票估计的 Dask 数据框架，我想知道分析师是否正确。</p><ol class=""><li id="a6f8" class="mq mr iq kx b ky kz lb lc le ms li mt lm mu lq nv mw mx my bi translated">编写一个函数，获取一只股票的价格，分析师对同一只股票的估计，并计算它们是否正确。</li><li id="4cbf" class="mq mr iq kx b ky mz lb na le nb li nc lm nd lq nv mw mx my bi translated">调用股票价格上的<code class="fe nf ng nh ni b">set_index</code>,按股票行情自动收录器排序。你得到的数据帧的<code class="fe nf ng nh ni b">index</code>将会有一个<code class="fe nf ng nh ni b">divisions</code>属性，描述哪个滚动条在哪个分区。(B 之前的所有内容都在第一分区中，B 和 D 之间的所有内容都在第二分区中，依此类推..).使用股票价格<code class="fe nf ng nh ni b">divisions</code>调用分析师估计的 Dask 数据框架上的<code class="fe nf ng nh ni b">set_index</code>。</li><li id="de34" class="mq mr iq kx b ky mz lb na le nb li nc lm nd lq nv mw mx my bi translated">使用<code class="fe nf ng nh ni b">map_partitions</code>将函数应用于两个 Dask 数据帧的分区。该函数将查看每个数据帧中的分笔成交点，然后应用您的函数。</li></ol><h1 id="2770" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">使用按聚合分组</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nw"><img src="../Images/a38d45226619e82cfbe9a5fab9b1f764.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*EgUubA5tXzGZ0ygf.jpg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图表由 Hugo Shi 绘制</p></figure><p id="248d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">Dask 拥有 Pandas <a class="ae ls" href="https://saturncloud.io/docs/reference/dask_groupby_aggregations/" rel="noopener ugc nofollow" target="_blank"> GroupBy 聚合算法</a>的优秀实现。实际的算法相当复杂，但是我们在<a class="ae ls" href="https://saturncloud.io/docs/reference/dask_groupby_aggregations/" rel="noopener ugc nofollow" target="_blank">文档</a>中有详细的描述。如果你的问题符合这种模式，你就有好医生了。Dask 在 GroupBy 聚合的实现中使用了树缩减。您可能需要调整两个参数，<code class="fe nf ng nh ni b">split_out</code>控制您的结果在多少个分区中结束，<code class="fe nf ng nh ni b">split_every</code>帮助 dask 计算树中有多少层。这两个参数都可以根据数据的大小进行调整，以确保不会耗尽内存。</p><h1 id="e173" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">使用 Dask 作为其他算法的容器</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nx"><img src="../Images/9c8ae764003de64828a7ccdbddf41523.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*_hdsIr7DFNVl_40F.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由 Rinson Chory 在 Unsplash 上拍摄</p></figure><p id="fc0f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">许多库都内置了 Dask 集成。<code class="fe nf ng nh ni b">dask-ml</code>与<code class="fe nf ng nh ni b">scikit-learn</code>融合。<code class="fe nf ng nh ni b">cuML</code>有很多常见 ML 算法的多节点多 GPU 实现。<code class="fe nf ng nh ni b">tsfresh</code>用于时间序列。<code class="fe nf ng nh ni b">scanpy</code>用于单细胞分析。<code class="fe nf ng nh ni b">xgboost</code>和<code class="fe nf ng nh ni b">lightgbm</code>都有启用 Dask 的并行算法。</p><h1 id="1142" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">结论</h1><p id="35a0" class="pw-post-body-paragraph kv kw iq kx b ky ml jr la lb mm ju ld le mn lg lh li mo lk ll lm mp lo lp lq ij bi translated">Dask 是扩展熊猫代码的好方法。天真地把你的熊猫数据帧转换成 Dask 数据帧不是正确的做法。但是 Dask 让你很容易将大数据集分解成小部分，并利用现有的 Pandas 代码。</p></div><div class="ab cl ny nz hu oa" role="separator"><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od"/></div><div class="ij ik il im in"><p id="9f8f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="lr">最初发布于 2021 年 10 月 26 日</em><a class="ae ls" href="https://saturncloud.io/blog/dask-is-not-pandas/" rel="noopener ugc nofollow" target="_blank"><em class="lr">https://Saturn cloud . io</em></a><em class="lr">。</em></p></div></div>    
</body>
</html>