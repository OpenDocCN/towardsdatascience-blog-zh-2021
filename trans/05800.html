<html>
<head>
<title>Engineering essentials for data science</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数据科学工程基础</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/engineering-essentials-for-data-science-4a7a92a1ff3e?source=collection_archive---------16-----------------------#2021-05-24">https://towardsdatascience.com/engineering-essentials-for-data-science-4a7a92a1ff3e?source=collection_archive---------16-----------------------#2021-05-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="184f" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/tips-and-tricks" rel="noopener" target="_blank"> <em class="jb">小窍门</em> </a></h2><div class=""/><div class=""><h2 id="7166" class="pw-subtitle-paragraph ka jd it bd b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr dk translated">你的代码周围的代码</h2></div><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi ks"><img src="../Images/3be876563d6598573e831f1fb2ea402d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*4jyej2qwvWHr_gBQ"/></div></div><p class="le lf gj gh gi lg lh bd b be z dk translated">照片由<a class="ae li" href="https://unsplash.com/@nathangwaters?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">内森·沃特斯</a>在<a class="ae li" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="eaa8" class="pw-post-body-paragraph lj lk it ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">“<a class="ae li" rel="noopener" target="_blank" href="/analytics-essentials-for-data-science-25da994f4bed">数据科学分析基础”帖子</a>中的编程概念涵盖了当数据摆在你面前时如何处理数据。如果您的工作流看起来像是从Google Drive下载一个CSV文件到您的笔记本电脑上，分析数据，然后将PDF文件附加到报告中，那么这些概念就足够了。</p><p id="d371" class="pw-post-body-paragraph lj lk it ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">然而，当您开始一个需要组合来自数百个CSV的数据的项目时，会发生什么呢？点击和拖动只能让你到此为止——即使你有耐心，你的经理可能没有！在你不得不通过一个没有好的用户界面的API来访问数据之前，这也只是一个时间问题。</p><p id="6b3e" class="pw-post-body-paragraph lj lk it ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">类似地，也许你被分配到一个项目，该项目有一个现有的代码库，程序员希望在处理代码时有最佳实践。虽然一次性的脚本可能在学校期间就已经停止了，但是[1] <a class="ae li" href="https://en.wikipedia.org/wiki/Technical_debt" rel="noopener ugc nofollow" target="_blank">如果你不能以一种易于阅读、重用和被他人修改的方式来组织你的代码，你就活在借来的时间里</a>。</p><p id="131b" class="pw-post-body-paragraph lj lk it ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">这就是分析数据之外的编程技能的用武之地。在本帖中，我们将涵盖以下软件工程概念:</p><ul class=""><li id="5a1b" class="mg mh it ll b lm ln lp lq ls mi lw mj ma mk me ml mm mn mo bi translated">访问数据</li><li id="0d7d" class="mg mh it ll b lm mp lp mq ls mr lw ms ma mt me ml mm mn mo bi translated">版本控制</li><li id="b753" class="mg mh it ll b lm mp lp mq ls mr lw ms ma mt me ml mm mn mo bi translated">面向对象编程</li><li id="9e22" class="mg mh it ll b lm mp lp mq ls mr lw ms ma mt me ml mm mn mo bi translated">虚拟环境</li><li id="48eb" class="mg mh it ll b lm mp lp mq ls mr lw ms ma mt me ml mm mn mo bi translated">写作测试</li></ul><h1 id="5422" class="mu mv it bd mw mx my mz na nb nc nd ne kj nf kk ng km nh kn ni kp nj kq nk nl bi translated">访问数据</h1><p id="8c72" class="pw-post-body-paragraph lj lk it ll b lm nm ke lo lp nn kh lr ls no lu lv lw np ly lz ma nq mc md me im bi translated">在这一节，我们将介绍<strong class="ll je"> <em class="mf">如何使用代码来访问数据。</em> </strong>这是一项跨越整个<a class="ae li" rel="noopener" target="_blank" href="/the-analytics-engineering-spectrum-of-data-science-jobs-3cf05c5f2d0b">分析-工程领域的技能</a>，但我认为与其说是一项分析技能，不如说是一项“工程”技能。</p><p id="934e" class="pw-post-body-paragraph lj lk it ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">作为一名数据科学家，你很少会通过Google Drive或Dropbox的点击式<a class="ae li" href="https://www.computerhope.com/jargon/g/gui.htm" rel="noopener ugc nofollow" target="_blank">图形用户界面</a>来访问数据。相反，您将访问的大部分数据将驻留在<strong class="ll je"> SQL </strong>(结构化查询语言)数据库或<strong class="ll je">API</strong>(应用程序编程接口)之后。也有可能你需要使用<strong class="ll je">网络抓取</strong>来访问不提供API的网站上的数据。本节将介绍这三种访问数据的方式。</p><h2 id="2aad" class="nr mv it bd mw ns nt dn na nu nv dp ne ls nw nx ng lw ny nz ni ma oa ob nk iz bi translated">结构化查询语言</h2><p id="926f" class="pw-post-body-paragraph lj lk it ll b lm nm ke lo lp nn kh lr ls no lu lv lw np ly lz ma nq mc md me im bi translated">除非你的公司很小，否则它的数据会比一两个硬盘所能容纳的还要多。随着数据量的增长，以最小化<a class="ae li" href="http://www.databasedev.co.uk/data-redundancy.html" rel="noopener ugc nofollow" target="_blank">冗余</a>和<a class="ae li" href="https://use-the-index-luke.com/sql/testing-scalability/data-volume" rel="noopener ugc nofollow" target="_blank">检索时间</a>的方式组织数据至关重要；优化<a class="ae li" href="https://looker.com/definitions/database-security#exit-popup" rel="noopener ugc nofollow" target="_blank">安全性和可靠性</a>；正式陈述<a class="ae li" href="https://www.ibm.com/cloud/learn/relational-databases" rel="noopener ugc nofollow" target="_blank">数据的不同部分如何相互关联</a>；并让多个用户同时读取(和写入)数据。</p><p id="d40b" class="pw-post-body-paragraph lj lk it ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">实现这一点的主要方法是使用关系数据库<a class="ae li" href="https://en.wikipedia.org/wiki/Relational_database" rel="noopener ugc nofollow" target="_blank"/>，您可以使用SQL对其进行查询。[2]关系数据库本质上是一组表，表之间有定义的关系。</p><p id="eaf5" class="pw-post-body-paragraph lj lk it ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">例如，如果你拥有一家网上商店，你不需要在顾客订购的每件商品旁边保存顾客的每一个细节；您可以将客户信息分离到一个表中(<code class="fe oc od oe of b">customers</code>)，将订单信息分离到另一个表中(<code class="fe oc od oe of b">orders</code>)，只需用<code class="fe oc od oe of b">orders</code>中的一个名为<code class="fe oc od oe of b">customer_id</code>的列将订单与客户相关联。使用SQL，您可以轻松快速地从两个表中提取相关数据，即使表增长到数千万或数亿行。[3]</p><p id="9694" class="pw-post-body-paragraph lj lk it ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">在您的角色中，您可能会非常频繁地使用SQL，可能每天都在使用，所以我强烈建议您花时间来完善这项技能。幸运的是，SQL不是一种庞大的语言，你可能只需要从数据库中<em class="mf">查询</em>数据，而不是<em class="mf">创建</em>数据库或表格，这更属于<a class="ae li" href="https://www.xplenty.com/blog/data-engineering-what-does-a-data-engineer-do-how-do-i-become-one/" rel="noopener ugc nofollow" target="_blank">数据工程师</a>的领域。在这篇文章中，我们将关注简单到中级的查询。</p><p id="989f" class="pw-post-body-paragraph lj lk it ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">下面是一个用主流SQL语言之一的Postgres编写的简单查询。我们从表<code class="fe oc od oe of b">students</code>中选择<code class="fe oc od oe of b">name</code>和<code class="fe oc od oe of b">animal</code>列，使用<code class="fe oc od oe of b">AS</code>关键字为返回的表中的列创建<a class="ae li" href="https://www.tutorialspoint.com/sql/sql-alias-syntax.htm" rel="noopener ugc nofollow" target="_blank">别名</a>或临时名称。最终结果经过过滤，因此返回的行中只有学生最喜欢的动物是海象的行。[4]</p><figure class="kt ku kv kw gt kx"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="eaba" class="pw-post-body-paragraph lj lk it ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">我们也可以为表格使用别名，下面我们将为<code class="fe oc od oe of b">users</code>、<code class="fe oc od oe of b">sql_pros</code>和<code class="fe oc od oe of b">transactions</code>使用别名。在这个例子中，我们以两种方式连接表；在第一个查询中，我们使用了一个<code class="fe oc od oe of b">LEFT JOIN</code>，它保留了<code class="fe oc od oe of b">users</code>中的所有行，但是删除了<code class="fe oc od oe of b">sql_pros</code>中没有ID的行。在第二个查询中，我们执行了一个<code class="fe oc od oe of b">FULL JOIN</code>，它保留了<code class="fe oc od oe of b">users</code>和<code class="fe oc od oe of b">transactions</code>中的所有行。</p><figure class="kt ku kv kw gt kx"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="5d29" class="pw-post-body-paragraph lj lk it ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">对于各种连接，要记住的主要事情是连接后要保留的行:只保留在两个表中匹配的行(<code class="fe oc od oe of b">INNER</code>)、全部在左(<code class="fe oc od oe of b">LEFT</code>)或右(<code class="fe oc od oe of b">RIGHT</code>)或全部在两个表中(<code class="fe oc od oe of b">FULL</code>)。</p><p id="e7c9" class="pw-post-body-paragraph lj lk it ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">聚合数据是另一个关键的SQL技能。下面，我们创建一个包含学生姓名和平均成绩的表格。因为在这个例子中,<code class="fe oc od oe of b">name</code>列与<code class="fe oc od oe of b">grades</code>在不同的表中，所以我们在聚合后连接这些表。</p><figure class="kt ku kv kw gt kx"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="8e50" class="pw-post-body-paragraph lj lk it ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">对于更复杂的查询，我喜欢引入<code class="fe oc od oe of b">WITH {tab} AS</code>结构，它允许您编写基于其他查询输出的查询。在下面的查询中，我们执行以下步骤:</p><ol class=""><li id="b786" class="mg mh it ll b lm ln lp lq ls mi lw mj ma mk me oi mm mn mo bi translated">为每个用户创建一个带有平均值和标准偏差<code class="fe oc od oe of b">price</code> <em class="mf">的查找表</em></li><li id="15b9" class="mg mh it ll b lm mp lp mq ls mr lw ms ma mt me oi mm mn mo bi translated">加入我们对原始<code class="fe oc od oe of b">orders</code>表的查找</li><li id="77a3" class="mg mh it ll b lm mp lp mq ls mr lw ms ma mt me oi mm mn mo bi translated">使用我们的查找来过滤掉不在每个用户的平均订单价格的三个标准差范围内的任何行</li></ol><p id="fa02" class="pw-post-body-paragraph lj lk it ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">这个查询方便地返回离群值，我们可以更仔细地检查。注意，这是一个查询，但是由于使用了<code class="fe oc od oe of b">WITH</code>语法，我们可以在逻辑上将它视为两个查询。</p><figure class="kt ku kv kw gt kx"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="bc13" class="pw-post-body-paragraph lj lk it ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">最后，我们快速提一下<em class="mf">写</em>到一个数据库。写入数据库，尤其是生产环境中的数据库，很可能会受到软件工程团队的严格监督——一个好的团队会有适当的程序来<a class="ae li" href="https://stackoverflow.com/questions/14051672/how-to-verify-datatype-before-entering-into-the-table/14051929" rel="noopener ugc nofollow" target="_blank">验证写入的数据与表模式</a>、<a class="ae li" href="https://www.acunetix.com/websitesecurity/sql-injection/" rel="noopener ugc nofollow" target="_blank">防止SQL注入攻击</a>，以及<a class="ae li" href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/WhatIsCloudWatchLogs.html" rel="noopener ugc nofollow" target="_blank">确保所有写入都被记录</a>。但是如果您<em class="mf">对您想要写入的数据库拥有完全控制权，下面是添加行的基本语法:</em></p><figure class="kt ku kv kw gt kx"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="180a" class="pw-post-body-paragraph lj lk it ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">这是更新和删除的语法。非常确定你知道你在做什么，因为没有“撤销”命令！[5]</p><figure class="kt ku kv kw gt kx"><div class="bz fp l di"><div class="og oh l"/></div></figure><h2 id="0010" class="nr mv it bd mw ns nt dn na nu nv dp ne ls nw nx ng lw ny nz ni ma oa ob nk iz bi translated">与API交互</h2><p id="322a" class="pw-post-body-paragraph lj lk it ll b lm nm ke lo lp nn kh lr ls no lu lv lw np ly lz ma nq mc md me im bi translated">除了SQL，你访问数据的另一个主要方式是通过API或者应用编程接口。[6]</p><p id="8b5b" class="pw-post-body-paragraph lj lk it ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">API就像银行的入口:这是(希望)访问银行内容的唯一方式，你必须遵循一定的规则才能进入:你不能携带武器，你必须步行进入，如果你没有穿衬衫，你会被拒之门外，等等。另一种方式认为它就像一个电源插座——除非你的和弦插头形状正确，否则你无法通电。</p><p id="a413" class="pw-post-body-paragraph lj lk it ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated"><code class="fe oc od oe of b">requests</code>库让我们直接从Python中查询API。对于没有任何安全需求的API来说，这个过程很简单:你只需要API在互联网上的位置，也就是它们的<a class="ae li" href="https://en.wikipedia.org/wiki/URL" rel="noopener ugc nofollow" target="_blank"> URL </a>，或者通用资源定位器。我们所做的就是向URL提出一个<a class="ae li" href="https://developer.mozilla.org/en-US/docs/Web/HTTP" rel="noopener ugc nofollow" target="_blank"> HTTP </a> <code class="fe oc od oe of b">GET</code>请求，然后解码从服务API的服务器返回的<a class="ae li" href="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/JSON" rel="noopener ugc nofollow" target="_blank"> JSON </a>。</p><figure class="kt ku kv kw gt kx"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="fa46" class="pw-post-body-paragraph lj lk it ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">但是有时我们需要一些额外的步骤来访问数据。在访问公司的专有数据时，有(或者应该有！)严格限制谁被授权与数据交互。在下面的例子中，我们使用<code class="fe oc od oe of b">boto3</code>来访问<a class="ae li" href="https://aws.amazon.com/s3/" rel="noopener ugc nofollow" target="_blank">亚马逊网络服务S3 </a>、云存储市场领导者中的一个文件。注意，当我们与S3建立连接时，我们需要传递安全凭证(存储在<code class="fe oc od oe of b">os.environ</code>对象中)。</p><figure class="kt ku kv kw gt kx"><div class="bz fp l di"><div class="og oh l"/></div></figure><h2 id="17b8" class="nr mv it bd mw ns nt dn na nu nv dp ne ls nw nx ng lw ny nz ni ma oa ob nk iz bi translated">网页抓取</h2><p id="2eea" class="pw-post-body-paragraph lj lk it ll b lm nm ke lo lp nn kh lr ls no lu lv lw np ly lz ma nq mc md me im bi translated">如果你想从一个没有提供方便的API的外部网站上收集数据怎么办？为此，我们求助于<a class="ae li" href="https://www.scrapinghub.com/what-is-web-scraping/" rel="noopener ugc nofollow" target="_blank">网页抓取</a>。网页抓取的基本前提是编写代码，遍历网页的<a class="ae li" href="https://developer.mozilla.org/en-US/docs/Learn/Getting_started_with_the_web/HTML_basics" rel="noopener ugc nofollow" target="_blank"> HTML </a>，找到指定的<a class="ae li" href="https://eastmanreference.com/complete-list-of-html-tags" rel="noopener ugc nofollow" target="_blank">标签</a>(例如标题、表格、图片)并记录它们的信息。抓取对于自动化来说是理想的，因为HTML具有高度规则的、基于树的结构，所有元素都有清晰的标识符。</p><p id="868a" class="pw-post-body-paragraph lj lk it ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">虽然抓取听起来很复杂，但实际上相当简单。我们首先通过<em class="mf">用<code class="fe oc od oe of b">requests.get</code>从一个网站请求</em>HTML来模仿一个网络浏览器(例如Firefox，Chrome)。(然后，我们的浏览器实际上呈现内容，但我们将坚持HTML作为一个很长的字符串。)</p><p id="253d" class="pw-post-body-paragraph lj lk it ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">然后，我们使用Python的<a class="ae li" href="https://www.crummy.com/software/BeautifulSoup/bs4/doc/" rel="noopener ugc nofollow" target="_blank"> Beautiful Soup </a>库将HTML组织成一个大型嵌套字典。然后，通过指定我们感兴趣的HTML标签，我们可以从这个对象中提取我们想要的信息。下面，我们打印出维基百科网页抓取页面的所有标题。</p><figure class="kt ku kv kw gt kx"><div class="bz fp l di"><div class="og oh l"/></div></figure><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi oj"><img src="../Images/3eeca145539379122d6248e4cd8792af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3QdOtf47XnUwhGxY"/></div></div><p class="le lf gj gh gi lg lh bd b be z dk translated">照片由<a class="ae li" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae li" href="https://unsplash.com/@altumcode?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> AltumCode </a>拍摄</p></figure><h1 id="d2f6" class="mu mv it bd mw mx my mz na nb nc nd ne kj nf kk ng km nh kn ni kp nj kq nk nl bi translated">版本控制</h1><p id="2701" class="pw-post-body-paragraph lj lk it ll b lm nm ke lo lp nn kh lr ls no lu lv lw np ly lz ma nq mc md me im bi translated">当你做一个不能在几分钟内完成的项目时，你需要检查点来保存你的进度。即使项目已经完成，也许你会对一个额外的特性有一个很好的想法，或者你会找到一种方法来改进一段代码。</p><p id="53a8" class="pw-post-body-paragraph lj lk it ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">除非变化很小，<strong class="ll je">你不会想要修改<em class="mf">工作的版本</em>，而是想要一个<em class="mf">副本</em> </strong>，在那里你可以进行修改并与原始版本进行比较。类似地，对于更大的项目来说，如果新的变更破坏了代码，能够回滚到旧的检查点是至关重要的。如果有多人在处理同一个文件，这一点尤其重要！</p><p id="8f30" class="pw-post-body-paragraph lj lk it ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">这就是像<a class="ae li" href="https://git-scm.com/" rel="noopener ugc nofollow" target="_blank"> Git </a>这样的版本控制系统发挥作用的地方。相比之下，有几十个文件称为<code class="fe oc od oe of b">my_project.py</code>、<code class="fe oc od oe of b">my_project_final.py</code>、<code class="fe oc od oe of b">my_project_final_REAL.py</code>等。相反，你有一个树状的项目时间表,漂浮在你电脑的一个文件夹里。代码有一个“主”<strong class="ll je">分支</strong>，你只能修改<em class="mf">副本</em>。</p><p id="8957" class="pw-post-body-paragraph lj lk it ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">每当您<a class="ae li" href="https://www.atlassian.com/git/tutorials/saving-changes/git-commit" rel="noopener ugc nofollow" target="_blank">更新一个分支</a>时，所有的变更都会被自动标记，并且对主分支的<a class="ae li" href="https://docs.github.com/en/free-pro-team@latest/github/collaborating-with-issues-and-pull-requests/about-pull-requests" rel="noopener ugc nofollow" target="_blank">变更需要至少一个其他人的审核</a>。(从技术上来说，他们不会，但实际上在任何职业环境中都是如此。)</p><p id="3a00" class="pw-post-body-paragraph lj lk it ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">随着时间的推移，您的项目结构可能看起来像这样。</p><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi ok"><img src="../Images/1f89fdd363209177141681c4e4a147ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*81A-_98WXkeKcdSdFyiobA.png"/></div></div><p class="le lf gj gh gi lg lh bd b be z dk translated">来源:<a class="ae li" href="https://stackoverflow.com/questions/1057564/pretty-git-branch-graphs" rel="noopener ugc nofollow" target="_blank">堆栈溢出</a></p></figure><p id="5f42" class="pw-post-body-paragraph lj lk it ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">灰色的线是<code class="fe oc od oe of b">master</code>分支(现在称为<code class="fe oc od oe of b">main </code>【7】)，蓝色和黄色的线是在不同点分支的副本(<code class="fe oc od oe of b">develop</code>和<code class="fe oc od oe of b">myfeature</code>)，经过修改，然后合并回<code class="fe oc od oe of b">master</code>。<strong class="ll je">在更大的公司，你可以有几十个分支并行运行</strong>，这对于让开发团队同时在同一个代码库上工作是必不可少的。然而，客户看到的唯一分支是<code class="fe oc od oe of b">main</code>。</p><p id="5b39" class="pw-post-body-paragraph lj lk it ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">使用Git的实际代码很简单。下面是Mac终端中<a class="ae li" href="https://opensource.com/resources/what-bash" rel="noopener ugc nofollow" target="_blank"> bash </a>中的一些命令，在这里我们:</p><ol class=""><li id="ed46" class="mg mh it ll b lm ln lp lq ls mi lw mj ma mk me oi mm mn mo bi translated">从我们所在的分支切换到<code class="fe oc od oe of b">main</code>分支</li><li id="4482" class="mg mh it ll b lm mp lp mq ls mr lw ms ma mt me oi mm mn mo bi translated">创建一个新的分支，<code class="fe oc od oe of b">DS-123-Add-outlier-check</code><a class="ae li" href="http://localhost:4000/DS-transition-4/#8-version-control" rel="noopener ugc nofollow" target="_blank">【8】</a>，那是<code class="fe oc od oe of b">main</code>的一个副本</li><li id="d28c" class="mg mh it ll b lm mp lp mq ls mr lw ms ma mt me oi mm mn mo bi translated">将分支从我们的本地计算机推到<a class="ae li" href="https://techcrunch.com/2012/07/14/what-exactly-is-github-anyway/" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上</li></ol><pre class="kt ku kv kw gt ol of om on aw oo bi"><span id="2556" class="nr mv it of b gy op oq l or os">git checkout main<br/>git checkout -b DS-123-Add-outlier-check<br/>git push --set-upstream origin DS-123-Add-outlier-check</span></pre><p id="66ff" class="pw-post-body-paragraph lj lk it ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">现在，在我们的新分支上，我们可以自由地对代码进行我们想要的任何更改。假设我们通过添加一个移除异常值的步骤来修改<code class="fe oc od oe of b">preprocessor.py</code>。当我们想要保存我们的更改时，我们在终端中键入以下内容。</p><pre class="kt ku kv kw gt ol of om on aw oo bi"><span id="6b43" class="nr mv it of b gy op oq l or os">git add preprocessor.py<br/>git commit -m "Add outlier check"<br/>git push</span></pre><p id="1e68" class="pw-post-body-paragraph lj lk it ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">这些步骤只体现在<code class="fe oc od oe of b">DS-123-Add-outlier-check</code>上，不体现在<code class="fe oc od oe of b">main</code>上。这让我们准备代码，直到它准备好被推送到<code class="fe oc od oe of b">main</code>。</p><p id="892d" class="pw-post-body-paragraph lj lk it ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">如果我们破坏了一些东西，想恢复到以前的状态呢？我们使用提交的<a class="ae li" href="https://www.mikestreety.co.uk/blog/the-git-commit-hash" rel="noopener ugc nofollow" target="_blank">散列</a>检查提交，告诉Git忽略有错误的提交，然后将我们的更改推送到分支。</p><pre class="kt ku kv kw gt ol of om on aw oo bi"><span id="c2be" class="nr mv it of b gy op oq l or os">git checkout abc123  # go to old checkpoint<br/>git revert bad456    # "delete" the bad checkpoint<br/>git push             # update the branch</span></pre><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi ot"><img src="../Images/c63befa060ed581b3d9766c09ad65744.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*rux8lGWM7dSuBBa0"/></div></div><p class="le lf gj gh gi lg lh bd b be z dk translated">Neil和Zulma Scott在Unsplash上的照片</p></figure><h1 id="a612" class="mu mv it bd mw mx my mz na nb nc nd ne kj nf kk ng km nh kn ni kp nj kq nk nl bi translated">面向对象编程</h1><p id="e26b" class="pw-post-body-paragraph lj lk it ll b lm nm ke lo lp nn kh lr ls no lu lv lw np ly lz ma nq mc md me im bi translated">随着项目中代码数量的增长，它通常遵循这种增长组织的模式:</p><ol class=""><li id="0bb9" class="mg mh it ll b lm ln lp lq ls mi lw mj ma mk me oi mm mn mo bi translated">带有一个接一个原始命令的脚本</li><li id="c884" class="mg mh it ll b lm mp lp mq ls mr lw ms ma mt me oi mm mn mo bi translated">归入<strong class="ll je">功能</strong>的命令</li><li id="f978" class="mg mh it ll b lm mp lp mq ls mr lw ms ma mt me oi mm mn mo bi translated">功能归入<a class="ae li" href="https://www.programiz.com/python-programming/class" rel="noopener ugc nofollow" target="_blank">类<strong class="ll je">类</strong>类</a>类</li><li id="6fa9" class="mg mh it ll b lm mp lp mq ls mr lw ms ma mt me oi mm mn mo bi translated">分类归入<a class="ae li" href="https://www.learnpython.org/en/Modules_and_Packages" rel="noopener ugc nofollow" target="_blank">模块<strong class="ll je">模块</strong>模块</a></li></ol><p id="a061" class="pw-post-body-paragraph lj lk it ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">生产级Python最适合组织的第四级，在这一级可以轻松地跨上下文添加、修改和重用代码。一个团队的代码通常会根据公司产品(例如“数据质量警报”、“价格预测”、“客户流失预测”)组织成<strong class="ll je">模块</strong>，这些模块又包含<strong class="ll je">类</strong>，这些类包含协同工作的功能集合。下面是一个名为<code class="fe oc od oe of b">Student</code>的类的简单例子。</p><figure class="kt ku kv kw gt kx"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="7d91" class="pw-post-body-paragraph lj lk it ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">类别可以存储在具有相同名称的<code class="fe oc od oe of b">.py</code>文件中，分组到具有相似类别的文件夹中。模块是包含所有文件夹的目录。我们可以有一个<code class="fe oc od oe of b">data_processing</code>模块，例如，具有这样的目录结构[9]:</p><pre class="kt ku kv kw gt ol of om on aw oo bi"><span id="d793" class="nr mv it of b gy op oq l or os">data_processing<br/>|   init.py<br/>|   cleaners<br/>|   |   init.py<br/>|   |   data_cleaner.py<br/>|   visualizers<br/>|   |   init.py<br/>|   |   error_logger.py<br/>|   |   dashboarder.py<br/>|   services<br/>|   |   init.py<br/>|   |   data_loader.py<br/>|   |   database_writer.py</span></pre><p id="44c9" class="pw-post-body-paragraph lj lk it ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">在<code class="fe oc od oe of b">cleaners</code>子目录中，<code class="fe oc od oe of b">data_cleaner.py</code>包含了一个<code class="fe oc od oe of b">DataCleaner</code>类，其中包含了清理数据的方法。<code class="fe oc od oe of b">data_cleaner.py</code>的前60行可能如下所示:</p><figure class="kt ku kv kw gt kx"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="46e1" class="pw-post-body-paragraph lj lk it ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">这个代码块比其他代码块长很多，它甚至不包括帮助函数<code class="fe oc od oe of b">_find_outliers</code>或调用<code class="fe oc od oe of b">DataLoader</code>的代码。对于生产级编码，<strong class="ll je">你需要围绕你的核心功能</strong>构建更多的架构来确保你的代码:</p><ol class=""><li id="8f2a" class="mg mh it ll b lm ln lp lq ls mi lw mj ma mk me oi mm mn mo bi translated">可以被其他人阅读和修改，而不仅仅是你</li><li id="b7c2" class="mg mh it ll b lm mp lp mq ls mr lw ms ma mt me oi mm mn mo bi translated">是否足够模块化以用于管道和多种环境</li><li id="a38e" class="mg mh it ll b lm mp lp mq ls mr lw ms ma mt me oi mm mn mo bi translated">如果它收到一些意外的输入，不会使这些管道停止工作</li></ol><p id="010b" class="pw-post-body-paragraph lj lk it ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">上面的代码有一个详细的<a class="ae li" href="https://www.programiz.com/python-programming/docstrings" rel="noopener ugc nofollow" target="_blank">文档字符串</a>、<a class="ae li" href="http://veekaybee.github.io/2019/07/08/python-type-hints/" rel="noopener ugc nofollow" target="_blank">类型提示</a>、<a class="ae li" href="https://www.geeksforgeeks.org/default-arguments-in-python/" rel="noopener ugc nofollow" target="_blank">参数默认值</a>设置为文件顶部的<a class="ae li" href="https://www.programiz.com/python-programming/global-local-nonlocal-variables" rel="noopener ugc nofollow" target="_blank">全局变量</a>，以及一个针对意外行为的<a class="ae li" href="https://www.toptal.com/python/in-depth-python-logging" rel="noopener ugc nofollow" target="_blank">警告日志</a>。</p><p id="6519" class="pw-post-body-paragraph lj lk it ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">这些附加组件有助于解释我们的代码对其他开发人员以及我们自己有什么作用！作为进一步的预防措施，我们可以加入<a class="ae li" href="https://wiki.python.org/moin/HandlingExceptions" rel="noopener ugc nofollow" target="_blank">错误处理</a>来处理错误数据类型的参数，否则会导致脚本失败。</p><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi ou"><img src="../Images/13b6e988b3c9e1d84a9366dcca29b677.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*K-btTtcbXF1lpLkj"/></div></div><p class="le lf gj gh gi lg lh bd b be z dk translated">瑞安·赫顿在<a class="ae li" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h1 id="5318" class="mu mv it bd mw mx my mz na nb nc nd ne kj nf kk ng km nh kn ni kp nj kq nk nl bi translated">虚拟环境</h1><p id="32eb" class="pw-post-body-paragraph lj lk it ll b lm nm ke lo lp nn kh lr ls no lu lv lw np ly lz ma nq mc md me im bi translated">除非我们的代码非常简单，否则我们需要导入外部库(比如<code class="fe oc od oe of b">pandas</code>和<code class="fe oc od oe of b">numpy</code>)。正如比尔·索鲁尔所说的，这些外部依赖“是魔鬼”代码是不断进化的，有时你一年前写的脚本在使用它的依赖项的最新版本时不再有效。 Python 3与Python 2 的<a class="ae li" href="https://docs.python.org/release/3.0.1/whatsnew/3.0.html" rel="noopener ugc nofollow" target="_blank">向后不兼容是出了名的，比如<code class="fe oc od oe of b">pandas</code> v1.0 </a><a class="ae li" href="https://www.infoworld.com/article/3513440/pandas-10-brings-big-breaking-changes.html" rel="noopener ugc nofollow" target="_blank">弃用或移除了</a>几个<code class="fe oc od oe of b">Series</code>和<code class="fe oc od oe of b">DataFrame</code>操作。</p><p id="e13b" class="pw-post-body-paragraph lj lk it ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">防止改变依赖关系的一种方法是拍摄项目外部库的“快照”以及它们的确切版本号。然后我们可以创建一个<strong class="ll je">虚拟环境</strong>，让我们重现当你创建你的项目并且一切正常运行时“外部代码世界”的样子。</p><p id="e42d" class="pw-post-body-paragraph lj lk it ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">在终端中，我们可以使用Python内置的<code class="fe oc od oe of b">virtualenv</code>模块来创建虚拟环境。在这里，我们创建一个名为<code class="fe oc od oe of b">venv</code>的。</p><pre class="kt ku kv kw gt ol of om on aw oo bi"><span id="556f" class="nr mv it of b gy op oq l or os">python -m virtualenv venv</span></pre><p id="1168" class="pw-post-body-paragraph lj lk it ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">然后，我们可以通过键入以下代码进入这个虚拟环境:</p><pre class="kt ku kv kw gt ol of om on aw oo bi"><span id="e137" class="nr mv it of b gy op oq l or os">source venv/bin/activate</span></pre><p id="eee4" class="pw-post-body-paragraph lj lk it ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">我们的新环境没有我们的全球环境所拥有的外部库。例如，即使您在创建虚拟环境之前安装了<code class="fe oc od oe of b">scikit-learn</code>，在<code class="fe oc od oe of b">venv</code>中也不存在<code class="fe oc od oe of b">scikit-learn</code>。每当我们创造一个新的环境时，我们都是从一张白纸开始！</p><p id="559e" class="pw-post-body-paragraph lj lk it ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">因此，我们需要在<code class="fe oc od oe of b">venv</code>内部安装我们项目所需的每个库。如果需要，我们可以使用<code class="fe oc od oe of b">&lt;package&gt;==&lt;version&gt;</code>语法指定版本号。</p><pre class="kt ku kv kw gt ol of om on aw oo bi"><span id="4476" class="nr mv it of b gy op oq l or os">pip install pymongo<br/>pip install scikit-learn==0.24</span></pre><p id="3669" class="pw-post-body-paragraph lj lk it ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">一旦我们的虚拟环境下载了所有软件包，并且您验证了您的应用程序的工作情况，我们就可以使用以下命令将所有软件包及其版本号保存到文件<code class="fe oc od oe of b">requirements.txt</code>中。<code class="fe oc od oe of b">pip freeze</code>返回所有下载的库，并且<code class="fe oc od oe of b">&gt;</code>操作员将输出导入文件，而不是在屏幕上打印。</p><pre class="kt ku kv kw gt ol of om on aw oo bi"><span id="bc14" class="nr mv it of b gy op oq l or os">pip freeze &gt; requirements.txt</span></pre><p id="8033" class="pw-post-body-paragraph lj lk it ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">将来，为了确保我们的项目如预期的那样工作，我们可以创建一个新的虚拟环境，并安装所有依赖关系的精确版本<code class="fe oc od oe of b">pip install -r requirements.txt</code>。这对于相对小规模的工作来说非常有用，但是如果您正在部署一个包，例如<a class="ae li" href="https://realpython.com/pypi-publish-python-package/" rel="noopener ugc nofollow" target="_blank">到PyPI本身</a>以便其他人下载，<a class="ae li" href="https://setuptools.readthedocs.io/en/latest/setuptools.html#declaring-dependencies" rel="noopener ugc nofollow" target="_blank">您会想要深入更高级的</a> <code class="fe oc od oe of b"><a class="ae li" href="https://setuptools.readthedocs.io/en/latest/setuptools.html#declaring-dependencies" rel="noopener ugc nofollow" target="_blank">setuptools</a></code> <a class="ae li" href="https://setuptools.readthedocs.io/en/latest/setuptools.html#declaring-dependencies" rel="noopener ugc nofollow" target="_blank">方法</a>。</p><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi ov"><img src="../Images/3f9563b627a6e55ce04b7d5c4ff7f3ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*FN7r2Kd46ppBhRSC"/></div></div><p class="le lf gj gh gi lg lh bd b be z dk translated"><a class="ae li" href="https://unsplash.com/@joshuaearle?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">约书亚·厄尔</a>在<a class="ae li" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">未塑</a>上的照片</p></figure><h1 id="2210" class="mu mv it bd mw mx my mz na nb nc nd ne kj nf kk ng km nh kn ni kp nj kq nk nl bi translated">写作测试</h1><p id="8878" class="pw-post-body-paragraph lj lk it ll b lm nm ke lo lp nn kh lr ls no lu lv lw np ly lz ma nq mc md me im bi translated">当我们编写一个函数时，代码应该按照我们希望它做的去做。但是更进一步，我们的代码也应该<em class="mf">不做其他任何事情</em>。虽然这看起来很明显，但是这个额外的步骤需要我们的代码中有很多额外的架构。这里有一个简单的例子:</p><figure class="kt ku kv kw gt kx"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="b26a" class="pw-post-body-paragraph lj lk it ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">当得到非数字输入时，我们的<code class="fe oc od oe of b">multiply</code>函数转向字符串和列表连接。这可能不是我们想要的！</p><p id="1b05" class="pw-post-body-paragraph lj lk it ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">人们很容易认为这些例子无关紧要，但如果<code class="fe oc od oe of b">multiply</code>在管道深处，接收前一个函数的输出，而前一个函数接收前一个函数的输出，这种情况很容易发生。例如，我们可以有一个<code class="fe oc od oe of b">find_anomalies</code>函数，如果没有异常就返回<code class="fe oc od oe of b">0</code>，如果有<em class="mf">异常就返回一个值列表。<em class="mf">(不要这样做——尝试总是从函数返回相同的数据类型。)</em>如果<code class="fe oc od oe of b">multiply</code>接受<code class="fe oc od oe of b">find_anomalies</code>的输出，我们将根据<code class="fe oc od oe of b">find_anomalies</code>返回的结果得到截然不同的结果，这可能会破坏我们的管道。</em></p><figure class="kt ku kv kw gt kx"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="7b7d" class="pw-post-body-paragraph lj lk it ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">捕捉这些问题并学习如何编写更好的代码的方法是编写<strong class="ll je">测试。测试基本上就像它听起来的那样:对于一些输入有一个“正确的答案”输出，你检查你的代码是否产生正确的输出。测试在检查多少代码上有所不同:你可以为整个应用程序编写测试，为组件的子集编写测试，或者为单个功能编写测试。下面我将简要介绍最后一种类型，<strong class="ll je">单元测试</strong>。</strong></p><p id="af21" class="pw-post-body-paragraph lj lk it ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated"><strong class="ll je">一套好的功能单元测试将涵盖三种类型的输入:<em class="mf">好的</em>、<em class="mf">特殊的</em>和<em class="mf">坏的</em>。</strong>一个<em class="mf">好的</em>输入就像它听起来的那样:这个函数打算接收的输入，就像我们的<code class="fe oc od oe of b">multiply</code>函数的整数或浮点数。一个<em class="mf">特殊的</em>输入是一种“边缘情况”，可能是触发内部逻辑产生不同输出的某种情况。最后，一个<em class="mf">坏的</em>输入是我们的函数无法处理的——我们的函数<em class="mf">应该失败</em>。</p><p id="5308" class="pw-post-body-paragraph lj lk it ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">让我们重写<code class="fe oc od oe of b">multiply </code> [10]，然后写一些测试。第8-12行，大约是我们函数的83%,现在完全致力于确保<code class="fe oc od oe of b">multiply</code>不会中断。这些代码行真的做到了——我们最终不需要为错误的输入编写测试，因为我们不能向<code class="fe oc od oe of b">multiply</code>扔任何东西导致它中断。相信我，我试过了。</p><figure class="kt ku kv kw gt kx"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="7b12" class="pw-post-body-paragraph lj lk it ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">然后我们可以使用<code class="fe oc od oe of b">pytest</code>库来编写我们的测试。第一步是明确定义我们的输入类型及其预期输出。我喜欢使用嵌套字典，其中顶层是我们的测试用例(例如，<code class="fe oc od oe of b">int-int</code>，意味着<code class="fe oc od oe of b">a</code>和<code class="fe oc od oe of b">b</code>都是整数)，内层是我们的参数名及其值的字典。然后我们可以使用<a class="ae li" href="https://www.geeksforgeeks.org/args-kwargs-python/" rel="noopener ugc nofollow" target="_blank"> **kwarg符号</a>将字典解包到我们正在测试的函数中。[11]</p><figure class="kt ku kv kw gt kx"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="dbf1" class="pw-post-body-paragraph lj lk it ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">实际的测试发生在<code class="fe oc od oe of b">assert</code>语句中，如果第一个参数返回<code class="fe oc od oe of b">True</code>，这些语句将保持沉默，如果第二个参数返回<code class="fe oc od oe of b">False</code>，这些语句将引发一个<code class="fe oc od oe of b">AssertionError</code>。如果测试失败，最好在断言字符串中详细说明，因为这将帮助您查明错误。</p><p id="1582" class="pw-post-body-paragraph lj lk it ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">我建议将您的测试组织在一个目录中，该目录反映了您的存储库的结构，如下所示。</p><pre class="kt ku kv kw gt ol of om on aw oo bi"><span id="e8c1" class="nr mv it of b gy op oq l or os">src<br/>|   custom_math<br/>|   |   easy<br/>|   |   |   add.py<br/>|   |   |   subtract.py<br/>|   |   hard<br/>|   |   |   multiply.py<br/>|   |   |   divide.py<br/>|   tests<br/>|   |   test_easy<br/>|   |   |   test_add.py<br/>|   |   |   test_subtract.py<br/>|   |   test_hard<br/>|   |   |   test_multiply.py<br/>|   |   |   test_divide.py</span></pre><p id="8cc1" class="pw-post-body-paragraph lj lk it ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">然后，您可以导航到您的项目的根文件夹(上面的<code class="fe oc od oe of b">src</code>，然后只需键入<code class="fe oc od oe of b">pytest tests</code>来运行所有的测试。请注意，函数、类和文件名需要以<code class="fe oc od oe of b">test</code>开头或结尾，以便<code class="fe oc od oe of b">pytest</code>将它们识别为测试。</p><p id="11e9" class="pw-post-body-paragraph lj lk it ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">一旦你做到了这一点，通过<a class="ae li" href="https://changhsinlee.com/pytest-mock/" rel="noopener ugc nofollow" target="_blank">模仿依赖函数</a>和<a class="ae li" href="https://docs.pytest.org/en/reorganize-docs/new-docs/user/pytest_raises.html" rel="noopener ugc nofollow" target="_blank">断言异常</a>，让你的测试更上一层楼。</p><h1 id="3e38" class="mu mv it bd mw mx my mz na nb nc nd ne kj nf kk ng km nh kn ni kp nj kq nk nl bi translated">总结想法</h1><p id="07da" class="pw-post-body-paragraph lj lk it ll b lm nm ke lo lp nn kh lr ls no lu lv lw np ly lz ma nq mc md me im bi translated">正如<a class="ae li" rel="noopener" target="_blank" href="/stats-essentials-for-data-science-cfcdee17af68">“数据科学统计要点”</a>的帖子一样，当谈到数据科学的有用软件工程实践时，很难不写一本教科书。当我开始转向数据科学时，我最大的知识缺口是工程。在部署模型时，除了实际的分析之外，还有很多东西。你如何创建一个<em class="mf">应用</em>而不是一个一次性的脚本？你如何可持续地编写成千上万行代码，或者与其他人一起开发潜在的数百万行代码？</p><p id="6e98" class="pw-post-body-paragraph lj lk it ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">这篇文章中的概念，从管理依赖性到编写弹性代码，应该有助于填补这一知识空白。如果你渴望更多，看看<a class="ae li" href="https://realpython.com/primer-on-python-decorators/" rel="noopener ugc nofollow" target="_blank"> Python decorators </a>，<a class="ae li" href="https://flask.palletsprojects.com/en/1.1.x/" rel="noopener ugc nofollow" target="_blank">创建自己的API端点</a>，<a class="ae li" href="https://docs.docker.com/get-started/overview/" rel="noopener ugc nofollow" target="_blank"> Docker容器化</a>，以及像<a class="ae li" href="https://www.heroku.com/" rel="noopener ugc nofollow" target="_blank"> Heroku </a>这样的应用托管服务。如果你对这篇文章感兴趣，可以看看我写的关于数据科学工程的其他文章，告诉我你想知道更多的内容。</p><p id="0de3" class="pw-post-body-paragraph lj lk it ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">最好，<br/>马特</p><h1 id="e367" class="mu mv it bd mw mx my mz na nb nc nd ne kj nf kk ng km nh kn ni kp nj kq nk nl bi translated">进一步阅读</h1><div class="ow ox gp gr oy oz"><a rel="noopener follow" target="_blank" href="/stats-essentials-for-data-science-cfcdee17af68"><div class="pa ab fo"><div class="pb ab pc cl cj pd"><h2 class="bd je gy z fp pe fr fs pf fu fw jd bi translated">数据科学统计基础</h2><div class="pg l"><p class="bd b dl z fp pe fr fs pf fu fw dk translated">towardsdatascience.com</p></div></div><div class="ph l"><div class="pi l pj pk pl ph pm lc oz"/></div></div></a></div><div class="ow ox gp gr oy oz"><a rel="noopener follow" target="_blank" href="/analytics-essentials-for-data-science-25da994f4bed"><div class="pa ab fo"><div class="pb ab pc cl cj pd"><h2 class="bd je gy z fp pe fr fs pf fu fw jd bi translated">数据科学的分析基础</h2><div class="pg l"><p class="bd b dl z fp pe fr fs pf fu fw dk translated">towardsdatascience.com</p></div></div><div class="ph l"><div class="pn l pj pk pl ph pm lc oz"/></div></div></a></div><div class="ow ox gp gr oy oz"><a href="https://betterprogramming.pub/how-to-efficiently-validate-input-types-in-python-functions-1f662f45c24c" rel="noopener  ugc nofollow" target="_blank"><div class="pa ab fo"><div class="pb ab pc cl cj pd"><h2 class="bd je gy z fp pe fr fs pf fu fw jd bi translated">如何在Python函数中有效地验证输入类型</h2><div class="po l"><h3 class="bd b gy z fp pe fr fs pf fu fw dk translated">油漆工来拯救</h3></div><div class="pg l"><p class="bd b dl z fp pe fr fs pf fu fw dk translated">better编程. pub</p></div></div><div class="ph l"><div class="pp l pj pk pl ph pm lc oz"/></div></div></a></div><div class="ow ox gp gr oy oz"><a rel="noopener follow" target="_blank" href="/3-levels-of-technical-abstraction-when-sharing-your-code-50ddc6e73946"><div class="pa ab fo"><div class="pb ab pc cl cj pd"><h2 class="bd je gy z fp pe fr fs pf fu fw jd bi translated">共享代码时的3个技术抽象层次</h2><div class="po l"><h3 class="bd b gy z fp pe fr fs pf fu fw dk translated">探索GitHub、Docker和Heroku</h3></div><div class="pg l"><p class="bd b dl z fp pe fr fs pf fu fw dk translated">towardsdatascience.com</p></div></div><div class="ph l"><div class="pq l pj pk pl ph pm lc oz"/></div></div></a></div><h1 id="dfdb" class="mu mv it bd mw mx my mz na nb nc nd ne kj nf kk ng km nh kn ni kp nj kq nk nl bi translated">脚注</h1><h2 id="cee0" class="nr mv it bd mw ns nt dn na nu nv dp ne ls nw nx ng lw ny nz ni ma oa ob nk iz bi translated">1.你的代码周围的代码</h2><p id="1d35" class="pw-post-body-paragraph lj lk it ll b lm nm ke lo lp nn kh lr ls no lu lv lw np ly lz ma nq mc md me im bi translated">这一针既是针对我的，也是针对其他人的。在研究生院，我有数百行长的R脚本，重新运行它们以不同的方式处理数据总感觉像在做手术。不应该是那样的！回过头来看，如果有一些基本的软件工程和项目管理最佳实践，博士学位会变得容易得多。也许为了下一个博士学位…</p><h2 id="e22f" class="nr mv it bd mw ns nt dn na nu nv dp ne ls nw nx ng lw ny nz ni ma oa ob nk iz bi translated">2.结构化查询语言</h2><p id="f7c7" class="pw-post-body-paragraph lj lk it ll b lm nm ke lo lp nn kh lr ls no lu lv lw np ly lz ma nq mc md me im bi translated">关系数据库的一个流行的替代品是NoSQL，或者非关系数据库(也称为“不仅仅是SQL”))与具有严格定义的关系的表相比，像<a class="ae li" href="https://www.mongodb.com/" rel="noopener ugc nofollow" target="_blank"> MongoDB </a>这样的NoSQL数据库在如何存储数据方面允许更大的灵活性。查看我在这篇文章中对SQL和NoSQL数据库的深入研究。</p><div class="ow ox gp gr oy oz"><a rel="noopener follow" target="_blank" href="/a-hands-on-demo-of-sql-vs-nosql-databases-in-python-eeb955bba4aa"><div class="pa ab fo"><div class="pb ab pc cl cj pd"><h2 class="bd je gy z fp pe fr fs pf fu fw jd bi translated">Python中SQL与NoSQL数据库的实践演示</h2><div class="po l"><h3 class="bd b gy z fp pe fr fs pf fu fw dk translated">用SQLAlchemy和PyMongo打动你的朋友</h3></div><div class="pg l"><p class="bd b dl z fp pe fr fs pf fu fw dk translated">towardsdatascience.com</p></div></div><div class="ph l"><div class="pr l pj pk pl ph pm lc oz"/></div></div></a></div><h2 id="3863" class="nr mv it bd mw ns nt dn na nu nv dp ne ls nw nx ng lw ny nz ni ma oa ob nk iz bi translated">3.结构化查询语言</h2><p id="33f0" class="pw-post-body-paragraph lj lk it ll b lm nm ke lo lp nn kh lr ls no lu lv lw np ly lz ma nq mc md me im bi translated">在索引正确的数据库<a class="ae li" href="https://cs.stackexchange.com/questions/59453/why-is-b-tree-search-olog-n" rel="noopener ugc nofollow" target="_blank">中搜索、插入和删除记录的规模预计为<em class="mf"> O </em>(日志<em class="mf"> n </em> ) </a>。这意味着<em class="mf">对于每一个数量级</em>，遍历数据只需要<em class="mf">一个额外的步骤！我觉得这令人难以置信。</em></p><h2 id="9e82" class="nr mv it bd mw ns nt dn na nu nv dp ne ls nw nx ng lw ny nz ni ma oa ob nk iz bi translated">4.结构化查询语言</h2><p id="9847" class="pw-post-body-paragraph lj lk it ll b lm nm ke lo lp nn kh lr ls no lu lv lw np ly lz ma nq mc md me im bi translated">在这篇文章的研究中，我偶然发现了这个(有点争议的)<a class="ae li" href="https://www.sqlstyle.guide/" rel="noopener ugc nofollow" target="_blank"> SQL风格指南</a>。这是一篇有趣的文章，我决定采用这篇文章中SQL示例的一些布局技巧。我学到的主要东西是在代码中间有一条空白的“河”, SQL关键字在左边，代码的其余部分在右边——这使得快速浏览查询正在做什么变得非常容易。但是，如果我找不到一种简单的方法来自动格式化代码，我怀疑我是否会坚持使用它来进行快速分析。</p><h2 id="cf36" class="nr mv it bd mw ns nt dn na nu nv dp ne ls nw nx ng lw ny nz ni ma oa ob nk iz bi translated">5.结构化查询语言</h2><p id="51e5" class="pw-post-body-paragraph lj lk it ll b lm nm ke lo lp nn kh lr ls no lu lv lw np ly lz ma nq mc md me im bi translated">如果这真的发生在你身上，希望你公司的工程团队定期备份数据库，并且能够<a class="ae li" href="https://www.codeproject.com/Questions/389399/how-to-do-undo-a-sql-query" rel="noopener ugc nofollow" target="_blank">回滚到更早的版本</a>。如果他们没有，而你不小心删除了你公司的所有数据，那么<a class="ae li" href="https://www.quora.com/What-would-you-do-if-you-accidentally-deleted-all-data-of-a-production-MySQL-database-at-the-first-day-as-a-backend-developer" rel="noopener ugc nofollow" target="_blank"> Quora建议你辞职</a>，找一家工程实践更好的公司！</p><h2 id="5da0" class="nr mv it bd mw ns nt dn na nu nv dp ne ls nw nx ng lw ny nz ni ma oa ob nk iz bi translated">6.与API交互</h2><p id="3c1f" class="pw-post-body-paragraph lj lk it ll b lm nm ke lo lp nn kh lr ls no lu lv lw np ly lz ma nq mc md me im bi translated">事实上，API和SQL是携手并进的。当您从API请求数据时，您的请求很可能被转换成SQL查询，然后在数据库上执行。</p><h2 id="7e52" class="nr mv it bd mw ns nt dn na nu nv dp ne ls nw nx ng lw ny nz ni ma oa ob nk iz bi translated">7.版本控制</h2><p id="454f" class="pw-post-body-paragraph lj lk it ll b lm nm ke lo lp nn kh lr ls no lu lv lw np ly lz ma nq mc md me im bi translated">2020年10月，<a class="ae li" href="https://www.zdnet.com/article/github-to-replace-master-with-main-starting-next-month/" rel="noopener ugc nofollow" target="_blank"> GitHub将默认分支</a>从<code class="fe oc od oe of b">master</code>重命名为<code class="fe oc od oe of b">main</code>，删除了对奴隶制不必要的引用。</p><h2 id="eaaa" class="nr mv it bd mw ns nt dn na nu nv dp ne ls nw nx ng lw ny nz ni ma oa ob nk iz bi translated">8.版本控制</h2><p id="700c" class="pw-post-body-paragraph lj lk it ll b lm nm ke lo lp nn kh lr ls no lu lv lw np ly lz ma nq mc md me im bi translated">Git分支的最佳命名惯例是通过它们的<a class="ae li" href="https://www.atlassian.com/software/jira" rel="noopener ugc nofollow" target="_blank"> JIRA </a>票据ID来引用它们。如果您的公司将Git与JIRA集成在一起，其他开发人员将会看到该分支是否正在开发中，是否有一个活跃的拉请求，或者是否已经被合并到<code class="fe oc od oe of b">main</code>。一个更好的(“最好的”-呃？)做法是在分支名称中包含是否是<a class="ae li" href="https://en.wikipedia.org/wiki/Hotfix" rel="noopener ugc nofollow" target="_blank">热修复</a>，支持请求，部分<a class="ae li" href="https://roadmunk.com/roadmap-templates/software-roadmap" rel="noopener ugc nofollow" target="_blank">路线图</a>等。</p><h2 id="a8c3" class="nr mv it bd mw ns nt dn na nu nv dp ne ls nw nx ng lw ny nz ni ma oa ob nk iz bi translated">9.面向对象编程</h2><p id="2b70" class="pw-post-body-paragraph lj lk it ll b lm nm ke lo lp nn kh lr ls no lu lv lw np ly lz ma nq mc md me im bi translated"><code class="fe oc od oe of b">init.py</code>文件允许从目录外导入类。这使得下一个代码块中的<code class="fe oc od oe of b">from ..services import DataLoader</code>能够工作。类似地，<a class="ae li" href="https://realpython.com/python-wheels/" rel="noopener ugc nofollow" target="_blank">如果你已经安装了</a> <code class="fe oc od oe of b"><a class="ae li" href="https://realpython.com/python-wheels/" rel="noopener ugc nofollow" target="_blank">data_processing</a></code> <a class="ae li" href="https://realpython.com/python-wheels/" rel="noopener ugc nofollow" target="_blank">模块</a>，你可以在任何脚本中通过输入:</p><pre class="kt ku kv kw gt ol of om on aw oo bi"><span id="e2e5" class="nr mv it of b gy op oq l or os"># With init files<br/>from data_processing import DataLoader</span></pre><p id="38fa" class="pw-post-body-paragraph lj lk it ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">如果没有init文件，您需要键入:</p><pre class="kt ku kv kw gt ol of om on aw oo bi"><span id="b13b" class="nr mv it of b gy op oq l or os"># Without init files<br/>from data_processing.services.data_loader import DataLoader</span></pre><p id="2001" class="pw-post-body-paragraph lj lk it ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">这不仅不太方便，而且如果您决定重新排列<code class="fe oc od oe of b">data_processing</code>模块中的目录，还会有外部脚本崩溃的风险。你可以在这里阅读更多关于init.py文件<a class="ae li" href="https://stackoverflow.com/questions/448271/what-is-init-py-for" rel="noopener ugc nofollow" target="_blank">的内容。</a></p><h2 id="77c9" class="nr mv it bd mw ns nt dn na nu nv dp ne ls nw nx ng lw ny nz ni ma oa ob nk iz bi translated">10.写作测试</h2><p id="952e" class="pw-post-body-paragraph lj lk it ll b lm nm ke lo lp nn kh lr ls no lu lv lw np ly lz ma nq mc md me im bi translated">如果我们真的想彻底，我们应该创建一个助手函数来检查<code class="fe oc od oe of b">multiply</code>的输入。这使得我们的功能集中在尽可能少的任务上，使得编写测试和调试更加容易。这看起来是这样的:</p><figure class="kt ku kv kw gt kx"><div class="bz fp l di"><div class="og oh l"/></div></figure><h2 id="eb46" class="nr mv it bd mw ns nt dn na nu nv dp ne ls nw nx ng lw ny nz ni ma oa ob nk iz bi translated">11.写作测试</h2><p id="35ac" class="pw-post-body-paragraph lj lk it ll b lm nm ke lo lp nn kh lr ls no lu lv lw np ly lz ma nq mc md me im bi translated">我发现解包元组和字典让编写测试变得有趣多了。这里是拆包和不拆包的符号。</p><figure class="kt ku kv kw gt kx"><div class="bz fp l di"><div class="og oh l"/></div></figure></div></div>    
</body>
</html>