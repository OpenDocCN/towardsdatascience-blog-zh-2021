<html>
<head>
<title>Leveling Up Your Machine Learning Projects</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">提升你的机器学习项目</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/leveling-up-your-machine-learning-projects-317da9c787fe?source=collection_archive---------27-----------------------#2021-12-29">https://towardsdatascience.com/leveling-up-your-machine-learning-projects-317da9c787fe?source=collection_archive---------27-----------------------#2021-12-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="02af" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何构建机器学习项目的实用指南</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d569257e89d8e73d7a02e8ccd6835965.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*dTKTM932A8tb0w3b"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@clark_fransa?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">阿诺·弗朗西斯卡</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="b7d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从数据科学开始，笔记本是你的朋友。它们是可视化和探索数据的多用途工具，但随着项目变得越来越复杂，它们并不是最好的。</p><p id="eb05" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于这样的项目，我们希望代码更加结构化和可伸缩，以便与不同类型的架构和数据集一起工作。</p><p id="fbc7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇博文中，我将分享一个简单通用的项目模板，可以用于你的深度学习项目。我们将看到如何为 PyTorch 项目编写良好的可重用代码，以及如何更好地构建我们的 Python 项目！</p><p id="8a8b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">遵循下面的代码！</p><div class="lv lw gp gr lx ly"><a href="https://github.com/reoneo97/pytorch-project-template" rel="noopener  ugc nofollow" target="_blank"><div class="lz ab fo"><div class="ma ab mb cl cj mc"><h2 class="bd iu gy z fp md fr fs me fu fw is bi translated">GitHub-reoneo 97/py torch-project-template:py torch 深度学习的生产就绪模板…</h2><div class="mf l"><h3 class="bd b gy z fp md fr fs me fu fw dk translated">PyTorch 深度学习项目的生产就绪模板-GitHub-reoneo 97/py torch-project-template…</h3></div><div class="mg l"><p class="bd b dl z fp md fr fs me fu fw dk translated">github.com</p></div></div><div class="mh l"><div class="mi l mj mk ml mh mm ks ly"/></div></div></a></div><h2 id="3471" class="mn mo it bd mp mq mr dn ms mt mu dp mv li mw mx my lm mz na nb lq nc nd ne nf bi translated"><strong class="ak">我们的兵工厂</strong></h2><p id="4a84" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">在进入项目的结构之前，让我们看一下我们将使用的 Python 包。</p><ol class=""><li id="94e4" class="nl nm it lb b lc ld lf lg li nn lm no lq np lu nq nr ns nt bi translated">由脸书开发的 PyTorch 一直是我深度学习项目的首选库。我真正喜欢 PyTorch 的是它的灵活性和模块化。使用<code class="fe nu nv nw nx b">nn.Module</code>类构建模型，使用<code class="fe nu nv nw nx b">forward</code>函数可以很容易地将许多不同的组件拼凑在一起。</li><li id="5dae" class="nl nm it lb b lc ny lf nz li oa lm ob lq oc lu nq nr ns nt bi translated">PyTorch Lightning 解决了 PyTorch 最大的缺点，那就是需要大量的样板代码。这里我们使用<strong class="lb iu"> PyTorch 闪电来训练我们的香草 PyTorch 模型</strong>。我们通过使用<code class="fe nu nv nw nx b">pl.LightningModule</code>抽象掉大部分丑陋的代码来做到这一点。</li><li id="d77c" class="nl nm it lb b lc ny lf nz li oa lm ob lq oc lu nq nr ns nt bi translated">随着你的机器学习项目的增长，超参数的数量也会增长。大多数项目将使用 YAML 配置文件来指定所有这些细节。这就是 Pydantic 的用武之地！Pydantic 为配置文件提供了类型验证，这有助于确保项目中的一切顺利进行</li></ol><h1 id="5e3a" class="od mo it bd mp oe of og ms oh oi oj mv jz ok ka my kc ol kd nb kf om kg ne on bi translated"><strong class="ak">项目结构</strong></h1><p id="9aaa" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">在这个项目中，我们将建立一个简单的 CIFAR 10 图像分类器，但我们将像 Python 包一样构造它，而不是使用笔记本。</p><pre class="kj kk kl km gt oo nx op oq aw or bi"><span id="7104" class="mn mo it nx b gy os ot l ou ov">|-- project<br/>|   |-- __init__.py<br/>|   |-- config.py<br/>|   |-- datasets<br/>|   |   |-- __init__.py<br/>|   |   `-- dataset.py<br/>|   |-- experiment.py<br/>|   `-- models<br/>|       |-- __init__.py<br/>|       `-- conv.py<br/>|-- requirements.txt<br/>|-- config.yml<br/>`-- main.py</span></pre><p id="48e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将根包命名为<code class="fe nu nv nw nx b">project</code>。在这个产品包中，我们有 3 个重要组件</p><p id="60cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">1.这个目录将存放用于创建 ML 模型的 PyTorch 模块。</p><p id="e219" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">2.<code class="fe nu nv nw nx b">datasets/</code>-包含用于训练模型的数据集和数据加载器类</p><p id="eeed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">3.<code class="fe nu nv nw nx b">config.py</code> —包含加载、解析和验证配置文件的代码</p><h2 id="03f0" class="mn mo it bd mp mq mr dn ms mt mu dp mv li mw mx my lm mz na nb lq nc nd ne nf bi translated"><strong class="ak">型号</strong></h2><p id="f845" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">使用<code class="fe nu nv nw nx b">nn.Module</code>类在 PyTorch 中实例化神经网络，这个目录将包含所有的类文件</p><p id="039b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于这个项目，我们希望代码是通用的，并允许架构的动态构建。代码应该接受像层数、层大小、卷积大小等参数。，并在此基础上建立模型。让我们来看一个这样的例子。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ow ox l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">基本卷积模型</p></figure><p id="0722" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在代码中，我们将一个维度大小列表传入模型，它将基于该大小列表生成卷积层。</p><p id="26f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以这种方式编写代码，我们只需更改模型中的参数，就可以更快地进行实验，而不需要进入代码本身。</p><p id="9aeb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">既然模型代码已经写好了，让我们来看看如何构建它。</p><h2 id="a8d4" class="mn mo it bd mp mq mr dn ms mt mu dp mv li mw mx my lm mz na nb lq nc nd ne nf bi translated"><strong class="ak"> __init__ </strong>。巴拉圭</h2><p id="2037" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated"><code class="fe nu nv nw nx b">__init__.py</code>文件用于将目录实例化为一个 python 包，但我们为它添加了额外的功能，以使我们的工作流程更加顺畅。</p><p id="81a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在文件中，我们可以指定可以导入的特定类/函数，而不必访问单个 Python 文件。这通过定义一个<code class="fe nu nv nw nx b">__all__</code>列表并指定要导入的不同类/函数来完成。示例<a class="ae ky" href="https://github.com/scikit-learn/scikit-learn/blob/main/sklearn/linear_model/__init__.py" rel="noopener ugc nofollow" target="_blank">此处</a></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ow ox l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">__init__ 文件和模型字典</p></figure><p id="93ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的例子中，我们希望我们的<code class="fe nu nv nw nx b">__init__</code>文件略有不同。我们正在寻找的是一种使用字符串来定义模型架构类型的方法。</p><p id="abb9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这可以通过创建一个字典来存储每个 PyTorch 模块，用一个字符串作为键(<code class="fe nu nv nw nx b">Dict[str:nn.Module]</code>)来实现。这允许我们使用配置文件中的字符串来索引字典，并选择我们想要使用的模型。稍后我们可以将这个字典导入到主脚本中。</p><blockquote class="oy oz pa"><p id="8448" class="kz la pb lb b lc ld ju le lf lg jx lh pc lj lk ll pd ln lo lp pe lr ls lt lu im bi translated"><code class="fe nu nv nw nx b">StackModel</code>是另一个具有 ResNet 层的卷积网络，查看源代码了解更多信息！</p></blockquote></div><div class="ab cl pf pg hx ph" role="separator"><span class="pi bw bk pj pk pl"/><span class="pi bw bk pj pk pl"/><span class="pi bw bk pj pk"/></div><div class="im in io ip iq"><h2 id="2f33" class="mn mo it bd mp mq mr dn ms mt mu dp mv li mw mx my lm mz na nb lq nc nd ne nf bi translated">数据集</h2><p id="51b6" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">在这个目录中，我们将放置为模型加载不同数据集所需的所有代码。对于我们的项目，我们将使用 PyTorch 的 CIFAR10 数据集，但在某些情况下，可能需要构建我们自己的数据集类。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ow ox l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">加载数据的功能</p></figure><p id="67b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于我们的例子，我们编写了一个简单的函数，通过传入两个参数返回一个<code class="fe nu nv nw nx b">DataLoader</code>,即数据的路径和批量大小。这个函数将在我们编写训练代码时用到</p></div><div class="ab cl pf pg hx ph" role="separator"><span class="pi bw bk pj pk pl"/><span class="pi bw bk pj pk pl"/><span class="pi bw bk pj pk"/></div><div class="im in io ip iq"><h2 id="5a7f" class="mn mo it bd mp mq mr dn ms mt mu dp mv li mw mx my lm mz na nb lq nc nd ne nf bi translated"><strong class="ak">项目配置</strong></h2><p id="889c" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">为机器学习编写好代码的一个重要目标是在不改变任何代码的情况下改变模型。这就是为什么我们需要一个配置文件，在一个地方存储重要的参数和变量，让我们可以快速修改它们。</p><p id="8ebf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有许多不同的方式来编写配置文件，但作为个人偏好，我喜欢使用 YAML 文件。YAML 文件本质上是将变量编码为键值对，这可以被 Python 解析并作为字典加载。</p><p id="a39e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后这个字典将被转换成 Pydantic 对象。本质上，Pydantic 帮助我们用一组特定的类型化变量来定义类。这有助于我们验证输入到模型中的超参数，确保所有需要的超参数都存在，并且是正确的类型。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ow ox l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Pydantic 类的示例</p></figure><p id="428c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">定义任何 Pydantic 对象都很简单，我们只需要继承<code class="fe nu nv nw nx b">BaseModel </code>类并定义模型内部的变量。对于每个被定义的变量，我们还需要提供该变量的类型，Pydantic 将帮助进行必要的转换/验证。我们也可以使用<code class="fe nu nv nw nx b">Optional</code>类型来指定具有默认值的参数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ow ox l"/></div></figure><p id="bd8b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了执行类型验证，Pydantic 还允许我们编写简单的验证测试来确保输入到模型中的超参数是有效的。一个简单的例子是确保决定架构的值是非负的。</p><p id="4779" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于这个项目，我们还希望将配置分成 3 个不同的部分:</p><ol class=""><li id="a137" class="nl nm it lb b lc ld lf lg li nn lm no lq np lu nq nr ns nt bi translated">模型配置</li><li id="3f7d" class="nl nm it lb b lc ny lf nz li oa lm ob lq oc lu nq nr ns nt bi translated">培训配置</li><li id="c281" class="nl nm it lb b lc ny lf nz li oa lm ob lq oc lu nq nr ns nt bi translated">实验配置</li></ol><p id="d7e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这有助于更好地构建配置文件，并帮助我们更容易地找到超参数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ow ox l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">解析 config.yml 并转换为 Pydantic 对象</p></figure><p id="a90e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦创建了 Pydantic 基本模型，我们需要做的就是创建一个函数来加载配置文件，读取它，然后将它转换成 Pydantic 对象。</p><p id="3f8b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个 Pydantic 对象稍后将被导入到我们的<code class="fe nu nv nw nx b">main.py</code>文件中，参数用于开始我们的训练</p><h2 id="d329" class="mn mo it bd mp mq mr dn ms mt mu dp mv li mw mx my lm mz na nb lq nc nd ne nf bi translated"><strong class="ak"> PyTorch 闪电</strong></h2><p id="05bb" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">一旦所有这些组件都完成了，我们就可以开始编写 PyTorch Lightning 代码了，它将使所有的组件一起工作。</p><p id="7d16" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">PyTorch lightning 是一个在 vanilla PyTorch 基础上有用的包，它允许在不使用大量常用样板代码的情况下构建模型。</p><p id="2e4a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">而不是编写用于训练/加载等的样板代码。，我们编写类方法，如返回损失的<code class="fe nu nv nw nx b">training_step</code>，返回数据加载器的<code class="fe nu nv nw nx b">train_dataloader</code>，PyTorch lightning 完成其余工作。我们的 PyTorch lightning 模型只需要模型(PyTorch 模块)和几个参数，它将执行训练模型所需的梯度下降步骤。</p><p id="4b97" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想要更深入的介绍，可以看看我在这方面的博文</p><div class="lv lw gp gr lx ly"><a rel="noopener follow" target="_blank" href="/beginner-guide-to-variational-autoencoders-vae-with-pytorch-lightning-part-2-6b79ad697c79"><div class="lz ab fo"><div class="ma ab mb cl cj mc"><h2 class="bd iu gy z fp md fr fs me fu fw is bi translated">使用 PyTorch Lightning 的可变自动编码器(VAE)初学者指南(第 2 部分)</h2><div class="mg l"><p class="bd b dl z fp md fr fs me fu fw dk translated">towardsdatascience.com</p></div></div><div class="mh l"><div class="pm l mj mk ml mh mm ks ly"/></div></div></a></div><p id="6ae4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来看看<code class="fe nu nv nw nx b">training_step</code>功能。该函数接受一批训练数据作为输入，并返回该批数据的损失。PyTorch lightning 将在幕后进行反向传播和优化，以训练模型。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ow ox l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">PyTorch 闪电代码</p></figure><p id="1475" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们将输入传递到模型中。如果您还记得，<code class="fe nu nv nw nx b">model</code>是作为一个类变量传入的，我们将在 forward 函数中使用它。这可以通过使用<code class="fe nu nv nw nx b">out = self.model(input)</code>简单地完成。接下来，我们使用该输出来计算损失函数，在这种情况下，我们使用<code class="fe nu nv nw nx b">CrossEntropyLoss</code>。剩下的就是归还损失，我们就完事了！</p><h2 id="310c" class="mn mo it bd mp mq mr dn ms mt mu dp mv li mw mx my lm mz na nb lq nc nd ne nf bi translated"><strong class="ak">最终剧本</strong></h2><p id="f34a" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">一旦一切都完成了，我们需要的最后一个文件就是运行一切的 python 脚本。</p><p id="c1d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个脚本唯一要做的就是从<code class="fe nu nv nw nx b">project</code>包中导入类并运行训练代码。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ow ox l"/></div></figure><p id="b306" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在代码的第一部分，我们正在构建将被训练的模型。我们首先使用“models”字典，并从配置文件中索引我们想要使用的模型。然后我们基于<code class="fe nu nv nw nx b">model_config</code>实例化模型。这是通过将 Pydantic 对象转换为字典并使用<strong class="lb iu">关键字参数解包</strong> <code class="fe nu nv nw nx b">**config.dict()</code>来创建对象来完成的。</p><p id="9166" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下一部分是训练模型。我们首先以类似于模型的方式创建<code class="fe nu nv nw nx b">Experiment </code>类和<code class="fe nu nv nw nx b">Trainer</code>类。然后我们用训练器来拟合模型就这样！大部分繁重的工作已经在前面的部分完成，我们可以有一个非常清晰的<code class="fe nu nv nw nx b">main.py</code>培训脚本。</p></div><div class="ab cl pf pg hx ph" role="separator"><span class="pi bw bk pj pk pl"/><span class="pi bw bk pj pk pl"/><span class="pi bw bk pj pk"/></div><div class="im in io ip iq"><p id="29d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样，项目就完成了！项目模板具有训练良好模型的所有必要组件，同时还具有足够的灵活性，可以轻松地适应不同的场景。</p><p id="78ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然这个模板对于示例项目来说有点大材小用，但它是一块垫脚石，可以随着项目复杂性的增加而扩展。适当地组织你的代码是一个很好的实践，这将有助于提高它的可读性和可用性，尤其是在专业环境中。</p><h1 id="47b6" class="od mo it bd mp oe of og ms oh oi oj mv jz ok ka my kc ol kd nb kf om kg ne on bi translated">走向</h1><p id="dbd6" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">这个模板只是冰山一角，还有很多其他方法可以改进它，使它对您的工作流程有用。以下是一些建议:</p><p id="a556" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> 1。阅读代码</strong></p><p id="cedc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">写好代码的最好方法是阅读好代码。为此，我建议阅读 scikit-learn 的源代码。Scikit-Learn 提供了大量不同的模型、功能变压器和实用功能，但一切都被整齐地打包在一起，易于使用。</p><div class="lv lw gp gr lx ly"><a href="https://github.com/scikit-learn/scikit-learn" rel="noopener  ugc nofollow" target="_blank"><div class="lz ab fo"><div class="ma ab mb cl cj mc"><h2 class="bd iu gy z fp md fr fs me fu fw is bi translated">GitHub-sci kit-learn/sci kit-learn:sci kit-learn:Python 中的机器学习</h2><div class="mf l"><h3 class="bd b gy z fp md fr fs me fu fw dk translated">scikit-learn 是一个基于 SciPy 构建的用于机器学习的 Python 模块，在 3-Clause BSD…</h3></div><div class="mg l"><p class="bd b dl z fp md fr fs me fu fw dk translated">github.com</p></div></div><div class="mh l"><div class="pn l mj mk ml mh mm ks ly"/></div></div></a></div><p id="7388" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> 2。部署机器学习模型课程</strong></p><p id="113e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你有兴趣让你的 ML 工程技能更上一层楼，我绝对推荐这门课。它教我如何使用 Pydantic 进行配置验证，还有很多内容，比如编写单元测试以及如何在 API 中部署模型。</p><p id="4099" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://www.udemy.com/course/deployment-of-machine-learning-models/" rel="noopener ugc nofollow" target="_blank">https://www . udemy . com/course/deployment-of-machine-learning-models/</a></p></div><div class="ab cl pf pg hx ph" role="separator"><span class="pi bw bk pj pk pl"/><span class="pi bw bk pj pk pl"/><span class="pi bw bk pj pk"/></div><div class="im in io ip iq"><p id="596a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你喜欢这篇文章，请在 Medium 上关注我！<br/>在 LinkedIn 上连接:<a class="ae ky" href="https://www.linkedin.com/in/reo-neo/" rel="noopener ugc nofollow" target="_blank">https://www.linkedin.com/in/reo-neo/</a></p></div></div>    
</body>
</html>