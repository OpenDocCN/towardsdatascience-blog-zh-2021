<html>
<head>
<title>Integrate Neo4j with KarateClub node embedding package</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将Neo4j与KarateClub节点嵌入包集成</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/integrate-neo4j-with-karateclub-node-embedding-package-99715d73250a?source=collection_archive---------30-----------------------#2021-07-21">https://towardsdatascience.com/integrate-neo4j-with-karateclub-node-embedding-package-99715d73250a?source=collection_archive---------30-----------------------#2021-07-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="7c71" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">了解如何将KarateClub库与Neo4j集成，以计算各种节点和图形嵌入</h2></div><p id="2286" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最近，我一直在寻求尽可能多地学习节点嵌入技术。节点嵌入的目标是<strong class="kh ir">对节点</strong>进行编码，使得嵌入空间中的相似性近似于原始网络中的相似性。通俗地说，我们把每个节点编码成一个固定大小的向量，这个向量保持了原始网络的相似性。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi lb"><img src="../Images/c4f1598bf2e06da0158113c7307f5012.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nUlVDhwlafhbQscxVUpZKg.png"/></div></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">图形嵌入——网络上的表征学习，snap.stanford.edu/proj/embeddings-www</p></figure><p id="76f8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当您想要以固定大小的向量捕获网络信息并在下游机器学习工作流中使用它时，节点嵌入非常有用。</p><p id="52d1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我在寻找各种节点嵌入模型的实现时，遇到过空手道俱乐部包。我将让作者<a class="ae lr" href="https://www.linkedin.com/in/benedekrozemberczki/" rel="noopener ugc nofollow" target="_blank"> Benedek Rozemberczki </a>解释它的目的是什么:</p><blockquote class="ls lt lu"><p id="735a" class="kf kg lv kh b ki kj jr kk kl km ju kn lw kp kq kr lx kt ku kv ly kx ky kz la ij bi translated"><em class="iq">空手道俱乐部</em>由最先进的方法组成，对图形结构数据进行无监督学习。简单来说就是小规模图挖掘研究的瑞士军刀。首先，它提供了节点和图级别的网络嵌入技术。第二，它包括多种重叠和非重叠社区检测方法。实现的方法涵盖了广泛的网络科学(<a class="ae lr" href="https://netscisociety.net/home" rel="noopener ugc nofollow" target="_blank"> NetSci </a>、<a class="ae lr" href="https://complenet.weebly.com/" rel="noopener ugc nofollow" target="_blank"> Complenet </a>)、数据挖掘(<a class="ae lr" href="http://icdm2019.bigke.org/" rel="noopener ugc nofollow" target="_blank"> ICDM </a>、<a class="ae lr" href="http://www.cikm2019.net/" rel="noopener ugc nofollow" target="_blank"> CIKM </a>、<a class="ae lr" href="https://www.kdd.org/kdd2020/" rel="noopener ugc nofollow" target="_blank"> KDD </a>)、人工智能(<a class="ae lr" href="http://www.aaai.org/Conferences/conferences.php" rel="noopener ugc nofollow" target="_blank"> AAAI </a>、<a class="ae lr" href="https://www.ijcai.org/" rel="noopener ugc nofollow" target="_blank"> IJCAI </a>)和机器学习(<a class="ae lr" href="https://nips.cc/" rel="noopener ugc nofollow" target="_blank"> NeurIPS </a>、<a class="ae lr" href="https://icml.cc/" rel="noopener ugc nofollow" target="_blank"> ICML </a>、<a class="ae lr" href="https://iclr.cc/" rel="noopener ugc nofollow" target="_blank"> ICLR </a>)会议</p></blockquote><p id="de69" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">空手道俱乐部项目的特点是:</p><ul class=""><li id="1c55" class="lz ma iq kh b ki kj kl km ko mb ks mc kw md la me mf mg mh bi translated">10多个社区检测模型</li><li id="9b33" class="lz ma iq kh b ki mi kl mj ko mk ks ml kw mm la me mf mg mh bi translated">25个以上的节点嵌入模型</li><li id="cf74" class="lz ma iq kh b ki mi kl mj ko mk ks ml kw mm la me mf mg mh bi translated">10+图形嵌入模型</li></ul><p id="580b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你可能知道，我喜欢将我的网络信息存储在<a class="ae lr" href="https://neo4j.com/" rel="noopener ugc nofollow" target="_blank"> Neo4j </a>中。在这篇博文中，我将演示如何从Neo4j中提取网络信息，并将其作为空手道俱乐部API的输入。这是一个简单的转变。我们必须将Neo4j图转换为NetworkX图模型，因为空手道俱乐部使用NetworkX结构，我们可以开始了。和往常一样，我准备了一个<a class="ae lr" href="https://github.com/tomasonjo/blogs/blob/master/harry_potter/Harry_Potter_Karate_Club_integration.ipynb" rel="noopener ugc nofollow" target="_blank">谷歌Colab笔记本</a>，如果你想跟随。</p><h2 id="9e21" class="mn mo iq bd mp mq mr dn ms mt mu dp mv ko mw mx my ks mz na nb kw nc nd ne nf bi translated">数据模型</h2><p id="4940" class="pw-post-body-paragraph kf kg iq kh b ki ng jr kk kl nh ju kn ko ni kq kr ks nj ku kv kw nk ky kz la ij bi translated">我们将使用一个简单的哈利波特宇宙玩具图，这是我在<a class="ae lr" href="https://medium.com/neo4j/turn-a-harry-potter-book-into-a-knowledge-graph-ffc1c45afcc8" rel="noopener">之前的博客文章</a>中创建的。我准备了一个带网络结构的CSV文件，不用自己完成NLP流程。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi nl"><img src="../Images/2b6b24d91a862bc149e9966ca659dc72.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9ib38j7Z44SUYaFZDBmphQ.png"/></div></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">哈利波特互动网。图片由作者提供。</p></figure><p id="8581" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该网络是基于哈利波特与魔法石的书。节点代表书中的角色，交互关系代表文本中角色之间的共现。要导入此网络，请执行以下Cypher查询:</p><p id="03da" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">P.s .如果你跟随Colab笔记本，我建议你打开一个空白的<a class="ae lr" href="https://neo4j.com/sandbox/" rel="noopener ugc nofollow" target="_blank"> Neo4j沙盒项目</a>。</p><pre class="lc ld le lf gt nm nn no np aw nq bi"><span id="63c5" class="mn mo iq nn b gy nr ns l nt nu">LOAD CSV WITH HEADERS FROM "https://raw.githubusercontent.com/tomasonjo/blog-datasets/main/HP/hp_1.csv" as row<br/>MERGE (s:Character{name:row.source})<br/>MERGE (t:Character{name:row.target})<br/>MERGE (s)-[r:INTERACTS]-(t)<br/>SET r.weight = row.weight<br/>RETURN distinct 'import successful' as result</span></pre><p id="4653" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们已经导入了我们的网络，我们可以在空手道俱乐部包的帮助下检查社区结构并计算节点嵌入。</p><h2 id="3a6e" class="mn mo iq bd mp mq mr dn ms mt mu dp mv ko mw mx my ks mz na nb kw nc nd ne nf bi translated">社区检测</h2><p id="22cc" class="pw-post-body-paragraph kf kg iq kh b ki ng jr kk kl nh ju kn ko ni kq kr ks nj ku kv kw nk ky kz la ij bi translated">对于那些对Neo4j完全陌生的人，我必须让你们知道<a class="ae lr" href="https://neo4j.com/docs/graph-data-science/current/" rel="noopener ugc nofollow" target="_blank"> Neo4j图形数据科学</a>插件提供了一些现成的社区检测算法。我将在GDS图书馆快速演示如何使用卢万算法。</p><pre class="lc ld le lf gt nm nn no np aw nq bi"><span id="5ece" class="mn mo iq nn b gy nr ns l nt nu">CALL gds.louvain.write({<br/> nodeProjection:'Character',<br/>    relationshipProjection:{INTERACTS:{orientation:'UNDIRECTED'}},<br/>    writeProperty:'louvain'<br/>})</span></pre><p id="a560" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">网络分析的一个关键细节是角色之间的互动网络是无向的。我将使用<a class="ae lr" href="https://neo4j.com/developer/graph-data-science/neuler-no-code-graph-algorithms/" rel="noopener ugc nofollow" target="_blank"> NEuler </a>可视化Louvain算法的结果。NEuler是一个Neo4j图形数据科学游乐场应用程序，可帮助您执行图形算法并可视化其结果。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi nv"><img src="../Images/1c91c3a10f3fe6cbac1d915ac15fe01b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CdO0ZuSv02uovm7v05oJDQ.png"/></div></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">用NEuler可视化Louvain算法的结果。图片由作者提供。</p></figure><p id="f740" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我不会深入算法的理论或它们的优缺点。这篇博文的目的纯粹是帮助你开始整合空手道俱乐部和Neo4j。算法的想法和区别可能会在另一篇博客文章中出现。现在让我们在KC中运行一些算法。KC只在图中的节点有连续的id时起作用。我不知道这个选择背后的原因；事情就是这样。我们可以很容易地创建到连续id的映射，并将其存储在Neo4j中。</p><pre class="lc ld le lf gt nm nn no np aw nq bi"><span id="98fc" class="mn mo iq nn b gy nr ns l nt nu">MATCH (c:Character)<br/>WITH count(*) as number, collect(c) as nodes<br/>UNWIND range(0, number - 1) as index<br/>WITH nodes[index] as node, index<br/>SET node.index = index</span></pre><p id="f7d4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，我们必须导出相关的网络数据，并从中构建一个NetworkX图模型。只需提供边列表就可以构造NetworkX图。边缘列表的语法是:</p><pre class="lc ld le lf gt nm nn no np aw nq bi"><span id="9d5a" class="mn mo iq nn b gy nr ns l nt nu">["1 2 {'weight': 3}", "2 3 {'weight': 27}", "3 4 {'weight': 3.0}"]</span></pre><p id="9de7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这里，我们有三种关系。每个关系都包含有关源节点和目标节点的信息，以及任何可选的关系属性。这个语法可以很容易地用Cypher创建。首先，我定义了一个函数，它读取一个Cypher查询的结果，并将其转换成一个Pandas数据帧:</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="a09a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，我们可以继续构建一个哈利波特宇宙的网络x图模型。</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="97aa" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">特别注意<strong class="kh ir"> create_using </strong>参数。在这种情况下，我想定义一个无向图，所以我使用了<strong class="kh ir"> nx。图形</strong>选项。如果你正在处理一个有向图甚至是多重图，选择相应的<strong class="kh ir"> create_using </strong>参数。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/a8d35d343931155c5f18e85e45979331.png" data-original-src="https://miro.medium.com/v2/resize:fit:1258/format:webp/1*UquhIKLC8Gzzwq-VUMkXVw.png"/></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">可用的NetworkX图形模型列表。摘自<a class="ae lr" href="https://networkx.org/documentation/stable/reference/classes/index.html#which-graph-class-should-i-use" rel="noopener ugc nofollow" target="_blank">官方文档</a>。</p></figure><p id="8ed1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们已经构建了NetworkX图，我们可以继续测试KC算法。我们将从社区检测算法<a class="ae lr" href="http://infolab.stanford.edu/~crucis/pubs/paper-nmfagm.pdf" rel="noopener ugc nofollow" target="_blank"> BigClam </a>开始。我们将计算社区结构，并将结果写回Neo4j。</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="f00c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">KC API使用起来非常简单。您只需定义所需的图形算法，并在<strong class="kh ir"> fit </strong>方法中输入NetworkX图形模型即可。再简单不过了。我添加了一些额外的代码，然后将结果存储到Neo4j中。让我们用NEuler再次可视化结果。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi nz"><img src="../Images/736e4c78e37042da07eb7630063fa883.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LUJ1vY__3-478QYhm04XsQ.png"/></div></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">用NEuler可视化BigClam算法的结果。图片由作者提供。</p></figure><p id="973d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">只需扫一眼，我们就可以观察到社区结构与我们使用Louvain算法时略有不同。您可以测试其他十种社区检测算法，如果您发现有趣的东西，请告诉我。</p><h2 id="1f4c" class="mn mo iq bd mp mq mr dn ms mt mu dp mv ko mw mx my ks mz na nb kw nc nd ne nf bi translated">节点嵌入</h2><p id="350d" class="pw-post-body-paragraph kf kg iq kh b ki ng jr kk kl nh ju kn ko ni kq kr ks nj ku kv kw nk ky kz la ij bi translated">同样，Neo4j GDS库提供了节点嵌入算法，如FastRP、node2vec和GraphSAGE。我将展示FastRP算法的语法，但同样不会深入研究超参数优化。</p><pre class="lc ld le lf gt nm nn no np aw nq bi"><span id="070f" class="mn mo iq nn b gy nr ns l nt nu">CALL gds.fastRP.write({<br/>  nodeProjection: 'Character',<br/>  relationshipProjection: {<br/>    INTERACTS: {<br/>      orientation: 'UNDIRECTED'<br/>    }<br/>  },<br/>  embeddingDimension: 64,<br/>  writeProperty: 'fastrp'})</span></pre><p id="2262" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir"> embeddingDimension </strong>参数是强制性的，它定义了每个节点的嵌入向量的大小。除此之外，我们再次将交互网络定义为无向的。最后，为了比较节点嵌入模型的结果，我们将可视化嵌入的t-SNE散点图。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi oa"><img src="../Images/80eda3e5219089cceab526baebd654eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nRbaRZsn7pS-fG2XlK2dzg.png"/></div></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">FastRP嵌入的t-SNE图。用纽勒可视化。图片由作者提供。</p></figure><p id="776b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在让我们尝试一下KC包中的一些节点嵌入算法。首先，我们将定义一个绘制嵌入结果的t-SNE散点图的函数。</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="1f26" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将从<a class="ae lr" href="https://keg.cs.tsinghua.edu.cn/jietang/publications/WSDM18-Qiu-et-al-NetMF-network-embedding.pdf" rel="noopener ugc nofollow" target="_blank"> NetMF </a>算法开始。NetMF算法属于基于社区的节点嵌入范畴。如果您想了解更多的技术细节，请阅读原文或检查代码。</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="6898" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这一次，我使用了<a class="ae lr" href="https://seaborn.pydata.org/" rel="noopener ugc nofollow" target="_blank"> Seaborn </a>散点图来可视化嵌入的t-SNE结果。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi ob"><img src="../Images/82fd577c306d73b60d33a7ebd591182b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DcnczejEmjHilVXOlyH6-g.png"/></div></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">NetMF嵌入的t-SNE图。用Seaborn可视化。图片由作者提供。</p></figure><p id="d844" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">节点嵌入似乎与我们使用FastRP算法时有很大不同。KC库还具有<a class="ae lr" href="https://www.ijcai.org/Proceedings/2017/0544.pdf" rel="noopener ugc nofollow" target="_blank"> NEU算法</a> m。该过程使用任意嵌入，并使用递归元学习算法通过更高阶近似对其进行扩充。</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="23c4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">并且嵌入的t-SNE结果是:</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi oa"><img src="../Images/f36903eb1a1a76e5cce8691bcb259198.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yWFO_boL_x_6gbRINgWJOw.png"/></div></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">NEU嵌入的t-SNE图。用Seaborn可视化。图片由作者提供。</p></figure><p id="55df" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">算法的另一个节点嵌入类别是结构角色嵌入类别。我们不是捕获网络中靠近的节点(邻居)之间的相似性，而是希望捕获具有相似结构角色的节点之间的相似性。一个这样的算法是<a class="ae lr" href="https://arxiv.org/abs/1802.02896" rel="noopener ugc nofollow" target="_blank"> Role2Vec算法</a>。</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="ca8b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">默认<strong class="kh ir"> walk_length </strong>为80。假设我们的示例图只有100多个节点，我决定使用一个更小的<strong class="kh ir"> walk_length </strong>值。除此之外，还有更多超参数调整的空间。由此产生的t-SNE图是:</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi oc"><img src="../Images/06543fea9d6bcffcd1d5766fa7d2c125.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yQaS7V_2Kq_qlvBvA3Xc0A.png"/></div></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">role2vec嵌入的t-SNE图。用Seaborn可视化。图片由作者提供。</p></figure><p id="4f0f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">基于节点角色相似度计算节点嵌入是一个令人兴奋的领域。我们不是比较网络中节点的紧密程度，而是要捕捉节点之间的结构角色相似性。然后，我们可以使用结构化角色嵌入来推断kNN网络，并运行社区检测算法来尝试基于节点的网络角色来分割节点。首先，我们必须将Role2vec结果存储回Neo4j。</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="31de" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">kNN算法是GDS图书馆的特色。K-最近邻算法计算图中所有节点对的距离值，并在每个节点与其K个最近邻之间创建新的关系。距离是根据节点属性计算的。</p><p id="1348" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将利用图表目录功能，因为我们将依次运行两个图表算法。首先，我们使用以下语法将网络的投影存储为命名图:</p><pre class="lc ld le lf gt nm nn no np aw nq bi"><span id="c2b3" class="mn mo iq nn b gy nr ns l nt nu">CALL gds.graph.create('role2vec', 'Character', '*', {nodeProperties:['role2vec']})</span></pre><p id="1b8d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们不关心无向交互关系，因为我们不会使用它们。重要的是，我们在投影中嵌入了role2vec节点。现在，我们可以继续改变kNN算法。使用<strong class="kh ir">突变</strong>方法，我们将算法结果存储回投影命名图，而不是Neo4j存储图。这样，我们可以使用kNN算法的结果作为社区检测算法的输入。</p><pre class="lc ld le lf gt nm nn no np aw nq bi"><span id="437a" class="mn mo iq nn b gy nr ns l nt nu">CALL gds.beta.knn.mutate('role2vec', <br/>  {topK: 5, <br/>   nodeWeightProperty:'role2vec', <br/>   mutateProperty:'weight', <br/>   mutateRelationshipType:'SIMILAR_ROLE'})</span></pre><p id="5f29" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将在SIMILAR_ROLE类型下存储结果关系。其中一个参数是<strong class="kh ir"> topK </strong>，它定义了每个节点要查找的邻居数量。返回K个最近邻。最后，我们可以通过使用Louvain算法来检查所得到的相似性网络的社区结构。</p><pre class="lc ld le lf gt nm nn no np aw nq bi"><span id="cca5" class="mn mo iq nn b gy nr ns l nt nu">CALL gds.louvain.write('role2vec', <br/>  {relationshipTypes:['SIMILAR_ROLE'],<br/>   writeProperty:'louvain_role'})</span></pre><p id="e082" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当然，剩下要做的明显的事情是可视化产生的相似性网络及其社区结构。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi od"><img src="../Images/4f7303624b991fa8733912a154ce4fd6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GO6AzPOX1Km5r-3tIsXgTg.png"/></div></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">推断相似网络的社区结构的网络可视化。图片由作者提供。</p></figure><p id="8cad" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这个例子中，我首先计算了结构角色嵌入，然后用kNN算法推断了一个相似性网络，这个例子可以被认为是网络的第一个派生。我们检查节点的结构角色分割，而不是使用社区检测算法来检查原始网络结构。这在各种网络项目中非常方便。</p><h2 id="d2af" class="mn mo iq bd mp mq mr dn ms mt mu dp mv ko mw mx my ks mz na nb kw nc nd ne nf bi translated">结论</h2><p id="3201" class="pw-post-body-paragraph kf kg iq kh b ki ng jr kk kl nh ju kn ko ni kq kr ks nj ku kv kw nk ky kz la ij bi translated">空手道俱乐部包包括节点嵌入模型，也考虑了节点属性。不幸的是，在我们简单的哈利波特网络中没有任何节点属性，所以我跳过了它们。尽管如此，节点嵌入研究领域还是很吸引人的，而且有很多方法可以确定你想从网络中提取什么类型的信息。希望Neo4j和空手道俱乐部项目的简单集成将帮助您使用最适合您的节点嵌入模型。我鼓励你打开一个<a class="ae lr" href="https://neo4j.com/sandbox/" rel="noopener ugc nofollow" target="_blank"> Neo4j沙箱</a>实例，测试各种方法。如果有什么有趣的事情发生，请告诉我。</p><p id="d4e2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">和往常一样，代码可以在<a class="ae lr" href="https://github.com/tomasonjo/blogs/blob/master/harry_potter/Harry_Potter_Karate_Club_integration.ipynb" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上获得。</p></div></div>    
</body>
</html>