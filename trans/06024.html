<html>
<head>
<title>5 Easy Ways To Speed Up Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">加速Python的5种简单方法</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/5-easy-ways-to-speed-up-python-963c86535eef?source=collection_archive---------8-----------------------#2021-05-30">https://towardsdatascience.com/5-easy-ways-to-speed-up-python-963c86535eef?source=collection_archive---------8-----------------------#2021-05-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c6bc" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用这5种不同的技术加速你的python！</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/a0c52c7393ede8cb820bd0c5d2819e0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fr9P5zw58NG6ip_Xo-a5FQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(src =<a class="ae ky" href="https://pixabay.com/images/id-2025863/" rel="noopener ugc nofollow" target="_blank">https://pixabay.com/images/id-2025863/</a></p></figure><h1 id="b9ca" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">介绍</h1><p id="488e" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">Python很快发现自己是世界上最受欢迎的编程语言之一，在T2 TIOBE指数T3上徘徊在第一名和第二名之间。在全球范围内，Python被用于数据科学和机器学习、脚本编写、软件工程，甚至web开发。造成这种情况的原因有很多。首先，Python是一种非常高级的脚本语言。这使得Python非常容易学习。</p><p id="4c25" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">另一件应该提到的事情是Python奇妙的生态系统。大多数其他类似语言的包生态系统通常注册了不到五万个包，而Python有大约二十万个。这些软件包也跨越了各种不同的学科。这意味着Python很可能是当今使用的最通用的语言之一。然而，不管Python有多么强大的生态系统，不管它是一种多么好的语言，没有一种语言没有它的问题。</p><p id="6ad7" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">鉴于Python的高级语法和声明性编程特性，可以假设Python很可能是一种脚本语言。这意味着它不是被编译，而是被编译的编程语言主动读取，在这个例子中是C编程语言。幸运的是，C是底层迭代编程的标准。这意味着Python通常能与许多其他使用C语言的语言以及C语言本身相处融洽。其实可以从c写Python。</p><p id="1b67" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">然而，对于任何一种解释型编程语言来说，速度总是一个问题，Python也不例外。虽然与其他类似的语言相比，Python是一种非常快速的语言，但它的速度仍然比不上一些编译后的低级解决方案，如C或C++。速度往往是Python的致命弱点。虽然这种语言有许多优点，但解释的速度通常被认为是它最大的弱点。然而，有一些简单的技术可以用来非常有效地提高Python的速度。</p></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h1 id="fe80" class="kz la it bd lb lc mz le lf lg na li lj jz nb ka ll kc nc kd ln kf nd kg lp lq bi translated">№1:迭代工具</h1><p id="4fb0" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">迭代是一件会显著降低计算速度的事情。当然，任何循环都是如此，尤其是在Python这样的语言中。虽然Python确实支持多线程，但一般来说，控制线程和进程的语法过于声明性，无法像在其他编程语言中那样有效地控制它们。因为Python本质上是相当单线程的，所以当它在循环中工作时，迭代经常会使整个应用程序停止。</p><p id="f6b0" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">Python的标准库中也包含了一个很好的模块来加速这些循环技术，它就是Itertools。Itertools模块附带了一些工具，可以通过其他包而不是Python.h提供的替代C实现快速循环。这些函数通常会导致更快的迭代。我有一整篇文章更详细地介绍了使用itertools加速一些算法的例子，你可以在这里阅读:</p><div class="ne nf gp gr ng nh"><a rel="noopener follow" target="_blank" href="/wicked-fast-python-with-itertools-55c77443f84c"><div class="ni ab fo"><div class="nj ab nk cl cj nl"><h2 class="bd iu gy z fp nm fr fs nn fu fw is bi translated">使用Itertools的超快速Python</h2><div class="no l"><h3 class="bd b gy z fp nm fr fs nn fu fw dk translated">快速浏览一种简单的方法，通过使用itertools让Python更快、更有效地进行机器学习…</h3></div><div class="np l"><p class="bd b dl z fp nm fr fs nn fu fw dk translated">towardsdatascience.com</p></div></div><div class="nq l"><div class="nr l ns nt nu nq nv ks nh"/></div></div></a></div><h1 id="c917" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">№2:线程</h1><p id="d2d1" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">另一种提高Python速度的标准库方法是使用多线程。Python是作为单线程的高级编程语言而构建的，所以在很多方面，当用Python实现多线程时，它会变得更加困难。然而，在大多数例子中，创建一个新流程只是一个简单的调用。</p><p id="4472" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我发现在Python中使用线程的最大问题是进程是未命名的，并且不可管理。这意味着您可以在做其他事情时创建进程来处理循环和算术，但很难回调这些线程并管理它们正在做的事情。当然，在大多数情况下，这是不必要的，所以这对于一般的Python程序员来说肯定是很方便的。我们可以通过首先从Python的标准库中导入线程模块来使用线程:</p><pre class="kj kk kl km gt nw nx ny nz aw oa bi"><span id="027d" class="ob la it nx b gy oc od l oe of">import threading</span></pre><p id="7b4a" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">接下来，我们需要为新线程编写一个函数:</p><pre class="kj kk kl km gt nw nx ny nz aw oa bi"><span id="385b" class="ob la it nx b gy oc od l oe of">import time as ti<br/>def sleeper():<br/>    ti.sleep(5)<br/>    print("Hello")</span></pre><p id="ae6d" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">现在我们可以通过初始化线程来构造一个新的对象。线程类别:</p><pre class="kj kk kl km gt nw nx ny nz aw oa bi"><span id="c615" class="ob la it nx b gy oc od l oe of">x = threading.Thread(target = sleeper)</span></pre><p id="c36f" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们可以使用目标函数的关键字参数来设定我们的目标。如果我们的函数需要提供参数，那么我们可以添加args关键字参数。我还会举一个例子:</p><pre class="kj kk kl km gt nw nx ny nz aw oa bi"><span id="d2b4" class="ob la it nx b gy oc od l oe of">import time as ti<br/>def sleeper(n):<br/>    ti.sleep(n)<br/>    print("Hello")</span><span id="266a" class="ob la it nx b gy og od l oe of">x = threading.Thread(target = sleeper, args = (5))</span></pre><p id="7422" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">然后我们可以用Thread.start()启动我们的线程:</p><pre class="kj kk kl km gt nw nx ny nz aw oa bi"><span id="a6a7" class="ob la it nx b gy oc od l oe of">x.start()</span></pre><p id="e4eb" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">不用说，在加速代码的时候，同时做两件事是非常有效的。尽管Python中的线程实现不是世界上最好的，但它确实值得了解和使用！</p><h1 id="4565" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">№3:数字巴</h1><p id="0244" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">即时编译(Just In Time compilation)或JIT编译是一种编译技术，它使解释的代码同时被编译、执行和编译。每当我们编译Python应用程序时，都要考虑到一定的开销，因为代码中的所有数据都需要注册和分配数据。这是为了每当调用这些对象时，Python在每个作用域中都有一个对此的引用。JIT编译可以用来减少这种开销。</p><p id="a2d4" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">使用JIT编译，我们不是在运行应用程序之前分配所有这些数据，而是在应用程序运行时进行。这减少了编译到执行的开始时间，就像在线程中一次做多件事一样，在编译时一次做多件事也可以显著加快代码的速度。</p><p id="2238" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">Python中通常使用的包是一个名为Numba的包。Numba实现的伟大之处在于它非常容易使用！Numba使用一个简单的装饰器让Python在某些函数和类上激活JIT。我写了一篇关于Numba的文章，如果你想了解更多，可以看看:</p><div class="ne nf gp gr ng nh"><a rel="noopener follow" target="_blank" href="/numba-jit-compilation-but-for-python-373fc2f848d6"><div class="ni ab fo"><div class="nj ab nk cl cj nl"><h2 class="bd iu gy z fp nm fr fs nn fu fw is bi translated">Numba: JIT编译，但是用于Python</h2><div class="no l"><h3 class="bd b gy z fp nm fr fs nn fu fw dk translated">快速浏览一下2020年让Python变得更好的神奇工具。</h3></div><div class="np l"><p class="bd b dl z fp nm fr fs nn fu fw dk translated">towardsdatascience.com</p></div></div><div class="nq l"><div class="oh l ns nt nu nq nv ks nh"/></div></div></a></div><h1 id="3580" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">№4: Cython</h1><p id="251d" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">另一个加速Python的流行选择是Cython。Cython是一种你可以利用C语言速度的方法，甚至不需要了解或编写C语言。虽然它当然没有使用C语言那么快，但这是坚持使用Python的一个很好的方法，同时也加快了速度。</p><p id="f413" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">许多程序员将Cython视为Python速度的可靠解决方案，但我认为这是一个错误。Cython并不适用于Python中的所有内容。在很多情况下，Python无法正确地执行Cythonize，虽然这种情况不太常见，但总是有可能的。使用Cython处理依赖关系也可能是一场噩梦，如果计划在您的技术堆栈中使用它，这是一件需要考虑的重要事情。我们可以从Cython中导入cythonize函数。从Cython包中构建模块。当然，这个模块不在标准库中，所以您需要自己添加。您还需要从标准库工具setuptools创建一个设置，因此我将导入这两个工具:</p><pre class="kj kk kl km gt nw nx ny nz aw oa bi"><span id="3fec" class="ob la it nx b gy oc od l oe of"><strong class="nx iu">from</strong> <strong class="nx iu">setuptools</strong> <strong class="nx iu">import</strong> setup<br/><strong class="nx iu">from</strong> <strong class="nx iu">Cython.Build</strong> <strong class="nx iu">import</strong> cythonize</span></pre><p id="d999" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们需要构建一个Cython构建文件，通常称为setup.py</p><pre class="kj kk kl km gt nw nx ny nz aw oa bi"><span id="dfa8" class="ob la it nx b gy oc od l oe of">setup(<br/>    ext_modules = cythonize("example.pyx")<br/>)</span></pre><p id="4352" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">您还需要将正在使用的任何Python模块命名为. pyx文件，而不是. py文件。最后，为了构建我们的Cython，我们将使用Python命令行界面，如下所示:</p><pre class="kj kk kl km gt nw nx ny nz aw oa bi"><span id="3a6b" class="ob la it nx b gy oc od l oe of">python setup.py build_ext --inplace</span></pre><p id="b3ae" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这将创建一个示例。所以，这个文件现在是一个编译后的二进制文件，我们可以从Python中使用它，我们可以简单地导入它，并像您可能期望的那样在Python代码中使用它。</p><h1 id="3f66" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">№6:并行计算</h1><p id="cbdf" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">您可以选择利用的另一个解决方案是并行计算。并行计算结合了图形卡的能力和计算机处理器的能力。在我们使用并行计算之前，我们应该总是考虑图形处理器实际上做什么。图形处理器是一种专门的设备，擅长特定的任务，而不擅长其他任务。换句话说，没有APU的处理器将是一个糟糕的图形处理器。同样，中央处理器将是一个可怕的图形处理器。</p><p id="e708" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">考虑到这一点，我们应该考虑到图形处理器非常擅长处理大量的数字。这意味着当应用于机器学习中的统计计算时，它们是很棒的，所以在许多数据科学的情况下，并行计算确实可以显著提高速度。前面我们谈到了使用Numba的JIT编译来加速代码，但是Numba包也提供了用于CUDA编程的工具。当然这是针对Nvidia卡的。</p><pre class="kj kk kl km gt nw nx ny nz aw oa bi"><span id="f613" class="ob la it nx b gy oc od l oe of">from numba import cuda</span></pre><p id="6638" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">为了使用CUDA，您还需要导出一个环境变量。我个人的~/里就有这个。当然，如果您不希望在Bash的每次使用中都声明这个变量，那么您可以简单地将它放入一个终端会话中:</p><pre class="kj kk kl km gt nw nx ny nz aw oa bi"><span id="93c5" class="ob la it nx b gy oc od l oe of">export NUMBA_ENABLE_CUDASIM=1</span></pre><p id="92bd" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">像Numba的JIT一样，我们简单地使用一个装饰器来决定一个函数是否要使用CUDA，这非常简单！更酷的是，我们可以将CUDA和JIT结合起来，获得令人难以置信的快速结果！</p><pre class="kj kk kl km gt nw nx ny nz aw oa bi"><span id="e4c5" class="ob la it nx b gy oc od l oe of">from numba import cuda<br/><br/>@cuda.jit<br/>def example(io_array):<br/>    print(io_array)</span></pre><p id="b844" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">现在我们知道了并行计算，我们应该考虑到这种语言的实现肯定不是世界上最好的。Python有缺点，并行计算无疑是其中之一。与其他语言相比，在Python中使用CUDA总是更加困难，因为它的基础从来没有考虑到并行计算。这是Julia的一个优点，它是在并行计算开始流行的时候建立的。我有一篇文章详细介绍了如何使用它的CUDA实现，对于那些对Julia感兴趣的人，你可以在这里阅读:</p><div class="ne nf gp gr ng nh"><a rel="noopener follow" target="_blank" href="/julias-fantastic-cuda-implementation-and-why-it-is-better-than-python-s-ca76e575c526"><div class="ni ab fo"><div class="nj ab nk cl cj nl"><h2 class="bd iu gy z fp nm fr fs nn fu fw is bi translated">Julia神奇的CUDA实现</h2><div class="no l"><h3 class="bd b gy z fp nm fr fs nn fu fw dk translated">使用CUDA.jl包探索简单并行计算的真正力量。</h3></div><div class="np l"><p class="bd b dl z fp nm fr fs nn fu fw dk translated">towardsdatascience.com</p></div></div><div class="nq l"><div class="oi l ns nt nu nq nv ks nh"/></div></div></a></div><p id="1c24" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">另一个巨大的负面影响是，为了实际使用并行计算，你需要一个图形处理单元。图形卡是计算机中最昂贵的硬件之一，所以获得一个能够帮助你的代码快速运行的图形卡是非常困难的，这是这种技术的一个很大的缺点。此外，如果你像我一样喜欢笔记本电脑的便利性，很可能你不会找到一款内置图形处理器的非常轻的笔记本电脑。就个人而言，我喜欢11-13英寸的笔记本电脑，但我通常会选择体积庞大的15英寸笔记本电脑，这不是我对电脑的偏好。</p><h1 id="8411" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">№7:功能工具</h1><p id="e11b" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">另一个非常容易使用的解决方案是FuncTools。这个模块在标准库中，它是如此的通用，以至于很难涵盖其中的所有内容。这个包提供了许多装饰器，可以真正加速你的代码，或者只是让你的语法更加用户友好。我认为Functools肯定是一个值得了解的包。</p><p id="9870" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">正如我提到的，FuncTools有很多能力。例如，这个包可以让Python使用单分派，这改变了类型和函数一起使用的方式。这个模块本身非常棒，在很多情况下非常有用，没有理由不使用它。该模块还提供了一个缓存装饰器，允许您缓存Python中的值以备后用，这对于代码中经常使用的函数非常有用。</p><h1 id="8741" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">№8: C</h1><p id="b089" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">如果这些解决方案似乎都不适合你，你可以时不时地使用C语言。Python最大的特点之一就是它是用C语言构建的，所以在需要速度的时候，C语言通常可以作为语言的后备。您也不需要用C编写所有代码，并且可以从Python中调用它。当然，这将是这个列表中其他解决方案的一个巨大转变。c是一门伟大的语言，但是它的命令式本质确实使得它需要花费更多的时间来编写。</p></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h1 id="e632" class="kz la it bd lb lc mz le lf lg na li lj jz nb ka ll kc nc kd ln kf nd kg lp lq bi translated">结论</h1><p id="52c0" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">Python是一门伟大的语言。由于各种原因，这种语言最近变得如此流行，当涉及到机器学习应用程序时，它是一个很好的选择。然而，机器学习在硬件上可能很难，与C和C++等编译语言相比，Python往往会停滞不前。然而，使用这些技术，您可以非常容易地大幅提高Python的速度，并使其在某些问题上的应用实际上非常接近c语言的速度。感谢您阅读我的文章，祝您编程愉快！</p></div></div>    
</body>
</html>