<html>
<head>
<title>UNION in SQL: A Must-Know Clause</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SQL中的UNION:一个必须知道的子句</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/union-in-sql-a-must-know-clause-1e5a4d7f7bde?source=collection_archive---------19-----------------------#2021-09-19">https://towardsdatascience.com/union-in-sql-a-must-know-clause-1e5a4d7f7bde?source=collection_archive---------19-----------------------#2021-09-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="814a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">分析多个表的结果</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c4eb9022be2cc5a35343b4f17dec154c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qXfBJmcdhTQnRqcjmWspEw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来源:图片来自<a class="ae ky" href="https://pixabay.com/photos/hands-teamwork-team-spirit-cheer-up-1939895/" rel="noopener ugc nofollow" target="_blank"> Pixabay </a></p></figure><p id="b652" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们在SQL中学习的许多常见查询(如GROUP BY)通常用于孤立地分析一个表。在将两个表连接在一起并将它们视为一个表时，也经常使用JOIN子句。</p><p id="c752" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，经常会有需要跨多个表分析结果的情况。使用UNION子句可以做到这一点，本文将举例说明该子句如何工作。</p><h1 id="bbec" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">UNION vs UNION ALL vs INTERSECT</h1><p id="f883" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">考虑以下两个表:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="9a79" class="mx lw it mt b gy my mz l na nb">houses=# select * from onebedroom;<br/>   city   | price <br/>----------+-------<br/> Paris    |  1000<br/> Munich   |   850<br/> Rome     |   930<br/> Helsinki |  1200<br/>(4 rows)</span><span id="7519" class="mx lw it mt b gy nc mz l na nb">houses=# select * from onebedroom_v2;<br/>   city    | price <br/>-----------+-------<br/> Helsinki  |  1200<br/> Berlin    |   750<br/> Prague    |   500<br/> Amsterdam |  1400<br/>(4 rows)</span></pre><p id="87d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这两个表格显示了欧洲主要城市一居室公寓的价格(数值是假设的，由作者虚构)。</p><p id="5884" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">UNION、UNION ALL和INTERSECT如何组合这两个表的结果？</p><p id="57ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这两个表中，我们可以看到城市赫尔辛基有一个重复的值(价格为€每月1200)。让我们看看这个值在三个子句中是如何处理的。</p><h2 id="57c8" class="mx lw it bd lx nd ne dn mb nf ng dp mf li nh ni mh lm nj nk mj lq nl nm ml nn bi translated">联盟</h2><p id="7c38" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">当用UNION组合这两个表时，我们可以看到只保留了Helsinki条目的一个实例——删除了重复的条目。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="2b89" class="mx lw it mt b gy my mz l na nb">houses=# select * from onebedroom union select * from onebedroom_v2;<br/>   city    | price <br/>-----------+-------<br/> Paris     |  1000<br/> Prague    |   500<br/> Helsinki  |  1200<br/> Berlin    |   750<br/> Amsterdam |  1400<br/> Rome      |   930<br/> Munich    |   850<br/>(7 rows)</span></pre><p id="d8fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">UNION ALL怎么样？</p><h2 id="d28a" class="mx lw it bd lx nd ne dn mb nf ng dp mf li nh ni mh lm nj nk mj lq nl nm ml nn bi translated">联合所有</h2><p id="4e47" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">当使用UNION ALL子句时，我们可以看到赫尔辛基的两个条目保留在表中，没有删除重复的条目。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="1825" class="mx lw it mt b gy my mz l na nb">houses=# select * from onebedroom union all select * from onebedroom_v2;<br/>   city    | price <br/>-----------+-------<br/> Paris     |  1000<br/> Munich    |   850<br/> Rome      |   930<br/> Helsinki  |  1200<br/> Helsinki  |  1200<br/> Berlin    |   750<br/> Prague    |   500<br/> Amsterdam |  1400<br/>(8 rows)</span></pre><h2 id="6ec1" class="mx lw it bd lx nd ne dn mb nf ng dp mf li nh ni mh lm nj nk mj lq nl nm ml nn bi translated">横断</h2><p id="010d" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">INTERSECT子句与UNION子句的工作方式不同，因为该子句只标识两个表共有的条目，并维护该条目—所有其他条目都被删除。</p><p id="6813" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个例子中，我们可以看到赫尔辛基条目被返回，因为这个条目对两个表都是公共的——所有其他条目都不存在。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="dc5f" class="mx lw it mt b gy my mz l na nb">houses=# select * from onebedroom intersect select * from onebedroom_v2;<br/>   city   | price <br/>----------+-------<br/> Helsinki |  1200<br/>(1 row)</span></pre><h1 id="1f86" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">对表格中的值求和并求平均值</h1><p id="e0e4" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">现在，让我们考虑下面的表(同样，值是假设的，由作者编造)。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="dfa8" class="mx lw it mt b gy my mz l na nb">houses=# select * from onebedroom;<br/>  city  | price <br/>--------+-------<br/> Paris  |  1000<br/> Munich |   850<br/> Rome   |   930<br/>(3 rows)</span><span id="5f9b" class="mx lw it mt b gy nc mz l na nb">houses=# select * from twobedroom;<br/>  city  | price <br/>--------+-------<br/> Paris  |  1400<br/> Munich |  1300<br/> Rome   |  1500<br/>(3 rows)</span><span id="5ce6" class="mx lw it mt b gy nc mz l na nb">houses=# select * from threebedroom;<br/>  city  | price <br/>--------+-------<br/> Paris  |  2800<br/> Munich |  2200<br/> Rome   |  2000<br/>(3 rows)</span></pre><p id="891a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在巴黎、慕尼黑和罗马，我们希望:</p><ol class=""><li id="54bd" class="no np it lb b lc ld lf lg li nq lm nr lq ns lu nt nu nv nw bi translated">对每个城市的值求和</li><li id="2899" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated">平均每个城市的值</li></ol><p id="bef0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看如何在第一个实例中对值求和。我们将从前两个表开始。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="c88f" class="mx lw it mt b gy my mz l na nb">houses=# select city,sum(price) total<br/>houses-# from<br/>houses-# (<br/>houses(#     select city,price<br/>houses(#     from onebedroom<br/>houses(#     union all<br/>houses(#     select city,price<br/>houses(#     from twobedroom<br/>houses(# ) t<br/>houses-# group by city;<br/>  city  | total <br/>--------+-------<br/> Rome   |  2430<br/> Paris  |  2400<br/> Munich |  2150<br/>(3 rows)</span></pre><p id="4ef1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的脚本中，我们可以看到UNION ALL子句被用来组合两个表的结果，并且价格的总和(<em class="oc"> sum(price) </em>)被定义为一个总值。</p><p id="24f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要对三个表中的值求和，只需使用两个UNION ALL子句:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="d1dc" class="mx lw it mt b gy my mz l na nb">houses=# select city,sum(price) total<br/>houses-# from<br/>houses-# (<br/>houses(#     select city,price<br/>houses(#     from onebedroom<br/>houses(#     union all<br/>houses(#     select city,price<br/>houses(#     from twobedroom<br/>houses(#     union all<br/>houses(#     select city,price<br/>houses(#     from threebedroom<br/>houses(# ) t<br/>houses-# group by city;<br/>  city  | total <br/>--------+-------<br/> Rome   |  4430<br/> Paris  |  5200<br/> Munich |  4350<br/>(3 rows)</span></pre><p id="8650" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于平均值，该条款实际上保持不变。这一次，我们只是要求价格的平均值，而不是总和。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="f411" class="mx lw it mt b gy my mz l na nb">houses=# select city,avg(price) total<br/>houses-# from<br/>houses-# (<br/>houses(#     select city,price<br/>houses(#     from onebedroom<br/>houses(#     union all<br/>houses(#     select city,price<br/>houses(#     from twobedroom<br/>houses(#     union all<br/>houses(#     select city,price<br/>houses(#     from threebedroom<br/>houses(# ) t<br/>houses-# group by city;<br/>   city   |         total         <br/>----------+-----------------------<br/> Rome     | 1476.6666666666666667<br/> Helsinki | 1200.0000000000000000<br/> Paris    | 1733.3333333333333333<br/> Munich   | 1450.0000000000000000<br/>(4 rows)</span></pre><p id="3379" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上述子句中还可以使用其他聚合函数，如MIN、MAX等。</p><h1 id="d74d" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">结论</h1><p id="3654" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在本文中，您已经看到:</p><ul class=""><li id="4ee6" class="no np it lb b lc ld lf lg li nq lm nr lq ns lu od nu nv nw bi translated">工会条款如何运作</li><li id="382f" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu od nu nv nw bi translated">UNION、UNION ALL和INTERSECT之间的区别</li><li id="d04a" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu od nu nv nw bi translated">如何计算多个表格中数值的总和及平均值</li></ul><p id="0a16" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">非常感谢您的宝贵时间，非常感谢您的任何问题或反馈。</p><h1 id="a0e1" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">参考</h1><ul class=""><li id="b970" class="no np it lb b lc mn lf mo li oe lm of lq og lu od nu nv nw bi translated"><a class="ae ky" href="https://stackoverflow.com/questions/19436895/sql-how-to-to-sum-two-values-from-different-tables" rel="noopener ugc nofollow" target="_blank">堆栈溢出- SQL:如何对不同表中的两个值求和</a></li><li id="3f74" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu od nu nv nw bi translated">斯蒂芬斯、琼斯、普勒(2016)。24小时内SamsTeachYourself SQL</li></ul><p id="1931" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="oc">免责声明:本文是在“原样”的基础上编写的，没有担保。它旨在提供数据科学概念的概述，不应被解释为专业建议。本文中的发现和解释是作者的发现和解释，不被本文中提到的任何第三方认可或隶属于任何第三方。作者与本文提及的任何第三方无任何关系。</em></p></div></div>    
</body>
</html>