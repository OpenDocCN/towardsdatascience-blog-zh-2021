<html>
<head>
<title>Custom Layers in Tensorflow</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Tensorflow中的自定义图层</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/custom-layers-in-tensorflow-4dbd7c194b6e?source=collection_archive---------23-----------------------#2021-07-17">https://towardsdatascience.com/custom-layers-in-tensorflow-4dbd7c194b6e?source=collection_archive---------23-----------------------#2021-07-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f99a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">增强Tensorflow体验创建您自己的层</h2></div><figure class="ki kj kk kl gt km"><div class="bz fp l di"><div class="kn ko l"/></div></figure><p id="ce06" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">在我对<em class="ll">人工智能算法</em>的研究中，除了陡峭的初始学习曲线之外，考虑到<strong class="kr iu">开源</strong>和免费资源的巨大可用性，我对这些算法可以被有技能的人开发和使用的即时性感到震惊。特别是，<strong class="kr iu"> TensorFlow </strong>使得以非常实用和简单的方式开发复杂的算法成为可能，即使是有经验的程序员也需要几个月的时间来实现，以获得模糊的可比结果。</p><p id="6481" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">丰富的文档使人们很容易理解如何应用众多的<strong class="kr iu">预实现模型</strong>，正如详细的<strong class="kr iu">教程</strong>使以实用的方式解决各种问题成为可能(自然语言处理、图像分类、监督和监督无监督学习……)。</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="gh gi lm"><img src="../Images/bbd4149025180b214592ea222e50da19.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*An4ewFfn6ep8LS8j"/></div></div><p class="lt lu gj gh gi lv lw bd b be z dk translated">詹姆斯·哈里森在<a class="ae lx" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="5254" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">就像科学学习的各个领域一样，总有一天，为了取得越来越好的结果，有必要对所涉及的主题进行更深入的研究。</p><p id="7574" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">为此，Keras函数API的使用，结合Tensorflow的热切执行和生成<em class="ll">完全定制的层、损失函数、模型、指标和回调</em>的可能性，使得以更深入和更详细<strong class="kr iu">的</strong>方式处理人工智能问题成为可能。此外，应用张量、变量、常数的基本概念和梯度带的应用可以赋予完全原创的算法以生命并适应特定的需要，以期<strong class="kr iu"><em class="ll"/></strong>【定制训练】。</p><h2 id="9278" class="ly lz it bd ma mb mc dn md me mf dp mg ky mh mi mj lc mk ml mm lg mn mo mp mq bi translated">为什么要看这篇文章？</h2><p id="6711" class="pw-post-body-paragraph kp kq it kr b ks mr ju ku kv ms jx kx ky mt la lb lc mu le lf lg mv li lj lk im bi translated">在本文中，我们将使用一个<strong class="kr iu">自定义层</strong>，它是通过在Tensorflow中子类化layer对象而开发的。我们将开发一个<strong class="kr iu">二次层</strong>，与传统的致密层相反，后者的特点是线性预激活+激活函数的应用(通常是非线性的)。我们将使用Keras的功能API创建一个非常基本的神经网络模型，并将在一个复杂工程问题的代表性数据集上测试我们的模型，从而获得良好的结果。</p><h2 id="bd5e" class="ly lz it bd ma mb mc dn md me mf dp mg ky mh mi mj lc mk ml mm lg mn mo mp mq bi translated">数据集</h2><p id="8fd9" class="pw-post-body-paragraph kp kq it kr b ks mr ju ku kv ms jx kx ky mt la lb lc mu le lf lg mv li lj lk im bi translated">翼型产生的噪声是航空航天工业的一个重要环境参数。机体总噪声的很大一部分是<strong class="kr iu"> <em class="ll">翼型自噪声</em> </strong>，与翼型本身及其边界层产生的湍流效应的相互作用有关。<a class="ae lx" href="https://archive.ics.uci.edu/ml/datasets/airfoil+self-noise" rel="noopener ugc nofollow" target="_blank">自噪声数据集</a>由NASA开发。<em class="ll">它是在消声风洞中以不同的风洞速度和攻角对二维和三维翼型叶片段进行的一系列空气动力学和声学测试中获得的。</em></p><p id="f0aa" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated"><strong class="kr iu">车型特点:</strong></p><ul class=""><li id="8332" class="mw mx it kr b ks kt kv kw ky my lc mz lg na lk nb nc nd ne bi translated">频率[赫兹]</li><li id="5382" class="mw mx it kr b ks nf kv ng ky nh lc ni lg nj lk nb nc nd ne bi translated">攻角[度]</li><li id="4dc8" class="mw mx it kr b ks nf kv ng ky nh lc ni lg nj lk nb nc nd ne bi translated">弦长[米]</li><li id="acf0" class="mw mx it kr b ks nf kv ng ky nh lc ni lg nj lk nb nc nd ne bi translated">自由流速度[米/秒]</li><li id="ea22" class="mw mx it kr b ks nf kv ng ky nh lc ni lg nj lk nb nc nd ne bi translated">吸入侧位移厚度[m]</li></ul><p id="0b31" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated"><strong class="kr iu">型号标签:</strong></p><ul class=""><li id="c676" class="mw mx it kr b ks kt kv kw ky my lc mz lg na lk nb nc nd ne bi translated">标度声压级[dB]</li></ul><p id="27cd" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">我做了一个视频，是为了面对这个空气动力学问题生成一个基本的稠密神经网络，有兴趣的话来看看。你也可以在这里找到完整的代码<a class="ae lx" href="https://github.com/GitMarco27/TMML/blob/d927a80934486c68b4b8b711ae7ad5322aa6d27b/Notebooks/007_Airfoil_Self_Noise.ipynb" rel="noopener ugc nofollow" target="_blank"/>。</p><figure class="ki kj kk kl gt km"><div class="bz fp l di"><div class="kn ko l"/></div></figure><h2 id="bcd4" class="ly lz it bd ma mb mc dn md me mf dp mg ky mh mi mj lc mk ml mm lg mn mo mp mq bi translated">二次层</h2><p id="5b9e" class="pw-post-body-paragraph kp kq it kr b ks mr ju ku kv ms jx kx ky mt la lb lc mu le lf lg mv li lj lk im bi translated">现在让我们看看如何生成一个<strong class="kr iu">二次层</strong>。要了解整个问题是如何解决的，您可以在这里找到完整的代码<a class="ae lx" href="https://github.com/GitMarco27/TMML/blob/5727dc3f4f87885d1e05863427cbe4ae6b6ea1fe/Notebooks/008_Custom_Layer.ipynb" rel="noopener ugc nofollow" target="_blank"/>，或者您可以观看本文开头的视频。要理解一个<strong class="kr iu">标准密集层</strong>的工作原理，我们可以从感知器函数的概念说起。这种人工智能的基本模型包括执行神经元本身中的一组输入参数和相对权重的乘积之和，生成预激活值。一旦计算出预激活，就有必要对其应用激活函数，以将非线性分配给所生成的替代模型的输出。</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="gh gi nk"><img src="../Images/56900842f27c1f9efa37b7573bec2b85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LjhFPsHxV6aiphW00WK6gw.png"/></div></div><p class="lt lu gj gh gi lv lw bd b be z dk translated">感知器功能—作者图片</p></figure><p id="5b44" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">基于这些概念，密集层将由“N”个工作原理相同的神经元组成。在我们的应用案例中，我们生成一个<strong class="kr iu">定制的</strong>层，其输入和神经元本身的预激活之间的关系是<strong class="kr iu">二次</strong>，而不是线性的。</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="gh gi nk"><img src="../Images/68d01cc0bda3963b89d8fef8ba4e1257.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ie9MEs3m95OaaBW4PI1ZMg.png"/></div></div><p class="lt lu gj gh gi lv lw bd b be z dk translated">感知器二次函数—作者图片</p></figure><p id="fe63" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">为了在Tensorflow工作环境中生成我们的层，我们继承层对象的属性，然后初始化它的属性。我们定义了两个新的属性:层中神经元的数量和激活函数。</p><figure class="ki kj kk kl gt km"><div class="bz fp l di"><div class="nl ko l"/></div></figure><p id="23d5" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">在<strong class="kr iu"> <em class="ll">构建</em> </strong>方法中，我们定义了我们层的可训练参数。我们需要指定每个张量的大小，数据格式，因此这些参数实际上是<strong class="kr iu">可训练的</strong>。前两个参数被<strong class="kr iu">随机</strong>初始化，而偏置项被初始化为<strong class="kr iu">零</strong>。<strong class="kr iu"> <em class="ll">调用</em> </strong>方法允许我们在前向传播阶段评估我们层的响应:我们实现上面的二次表达式。</p><figure class="ki kj kk kl gt km"><div class="bz fp l di"><div class="nl ko l"/></div></figure><p id="9231" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">我们生成简单的模型，只有一个隐藏层:我们创建的自定义层。</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/e8ff8f408237e0cd6fc29247ba0e5d34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1128/format:webp/1*QhQDdcFtRbgMCGd-RLp-tg.png"/></div><p class="lt lu gj gh gi lv lw bd b be z dk translated">带有自定义图层的模型—作者提供的图像</p></figure><h2 id="96da" class="ly lz it bd ma mb mc dn md me mf dp mg ky mh mi mj lc mk ml mm lg mn mo mp mq bi translated">结果</h2><p id="15fa" class="pw-post-body-paragraph kp kq it kr b ks mr ju ku kv ms jx kx ky mt la lb lc mu le lf lg mv li lj lk im bi translated">我们编译我们的模型，定义损失函数，并选择亚当作为优化器。然后，我们训练模型500个时期，并检查结果。在我们的脚本中，我们还显示了训练前后自定义层的参数值之间的比较，以检查它是否正常工作。</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/239c4ee417811868d1fe64858b9deeeb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1008/format:webp/1*0_akKe5FKl0DFv_LJ_mOKQ.png"/></div><p class="lt lu gj gh gi lv lw bd b be z dk translated">跨时代的损失函数-按作者分类的图像</p></figure><p id="cead" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">然后，我们运行验证图来验证模型在训练和验证集上的性能。考虑到模型是如此简单，并且没有对其超参数进行优化，结果是离散的。然而，这证实了我们的定制层的正确运行。</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="gh gi no"><img src="../Images/8af661d2c7258076aff2678f5b85ce8f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nIAeunBDi8fJLuDo6gSvJw.png"/></div></div><p class="lt lu gj gh gi lv lw bd b be z dk translated">验证图-按作者分类的图像</p></figure><p id="bbd0" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">让我们检查一些数字结果:</p><pre class="ki kj kk kl gt np nq nr ns aw nt bi"><span id="6ac6" class="ly lz it nq b gy nu nv l nw nx">Y0 - mae-train - 0.05067<br/>Y0 - mse-train - 0.00441<br/>Y0 - r2-train - 0.87064<br/>Y0 - pearson-train - 0.93566<br/>Y0 - mae-test - 0.04748<br/>Y0 - mse-test - 0.00402<br/>Y0 - r2-test - 0.87471<br/>Y0 - pearson-test - 0.93871</span></pre><h2 id="6a5e" class="ly lz it bd ma mb mc dn md me mf dp mg ky mh mi mj lc mk ml mm lg mn mo mp mq bi translated">结论</h2><p id="a654" class="pw-post-body-paragraph kp kq it kr b ks mr ju ku kv ms jx kx ky mt la lb lc mu le lf lg mv li lj lk im bi translated">我们已经看到了如何使用Colab、Tensorflow和Python，用相对简单的模型处理复杂的空气动力学问题。我们创建了一个只有一个隐藏层的模型，使用我们自己构建的层，而不是Tensorflow环境中预实现的层。我们检查了它的正确功能并核实了结果。我希望你喜欢这篇文章，欢迎任何反馈。</p><p id="af7a" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated"><br/>下次见，马尔科</p><h1 id="8850" class="ny lz it bd ma nz oa ob md oc od oe mg jz of ka mj kc og kd mm kf oh kg mp oi bi translated">3分钟机器学习</h1><p id="5f4d" class="pw-post-body-paragraph kp kq it kr b ks mr ju ku kv ms jx kx ky mt la lb lc mu le lf lg mv li lj lk im bi translated">3分钟机器学习是一系列与人工智能、深度学习和数据科学相关的教程、视频和文章。你可以在YouTube 上找到完整的视频集。GitHub <a class="ae lx" href="https://github.com/GitMarco27/TMML" rel="noopener ugc nofollow" target="_blank">存储库</a>包含了文章和视频中显示的所有Google Colab笔记本。我希望这些内容对你有用，或者只是你感兴趣。欢迎任何反馈。</p><p id="c87a" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">查看其他剧集:</p><ul class=""><li id="65d6" class="mw mx it kr b ks kt kv kw ky my lc mz lg na lk nb nc nd ne bi translated"><a class="ae lx" rel="noopener" target="_blank" href="/images-generation-with-neural-style-transfer-and-tensorflow-a823b0353b06">使用神经类型转移和张量流生成图像</a></li><li id="64c1" class="mw mx it kr b ks nf kv ng ky nh lc ni lg nj lk nb nc nd ne bi translated"><a class="ae lx" rel="noopener" target="_blank" href="/cats-vs-dogs-convolutional-classifier-44ec04c8eb7a">猫VS狗卷积分类器</a></li><li id="dd10" class="mw mx it kr b ks nf kv ng ky nh lc ni lg nj lk nb nc nd ne bi translated"><a class="ae lx" rel="noopener" target="_blank" href="/plot-a-tensorflow-model-with-keras-functional-api-f2db639dbbd8">使用Keras Functional API绘制张量流模型</a></li><li id="39ac" class="mw mx it kr b ks nf kv ng ky nh lc ni lg nj lk nb nc nd ne bi translated"><a class="ae lx" rel="noopener" target="_blank" href="/neural-network-for-predicting-the-energy-performance-of-a-building-5c2bf5820ebe">预测建筑物能源性能的神经网络</a></li></ul></div></div>    
</body>
</html>