<html>
<head>
<title>Python Tricks: Generators Explained</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python技巧:生成器解释</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/python-tricks-generators-explained-4b4ba00402e4?source=collection_archive---------29-----------------------#2021-07-15">https://towardsdatascience.com/python-tricks-generators-explained-4b4ba00402e4?source=collection_archive---------29-----------------------#2021-07-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/30d5b31f8c1e2050a810a8f54765d7ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2ni3d-j3Nz3SAO_B"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">照片由<a class="ae jg" href="https://unsplash.com/@davidcarboni?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">大卫·卡尔波尼</a>在<a class="ae jg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><div class=""/><div class=""><h2 id="9db8" class="pw-subtitle-paragraph kg ji jj bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dk translated">Python中的生成器是如何工作的？</h2></div><p id="c27f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">欢迎阅读一系列短文，每篇短文都有方便的Python技巧，可以帮助你成为更好的Python程序员。在这篇博客中，我们将研究发电机。</p><h2 id="2280" class="lu lv jj bd lw lx ly dn lz ma mb dp mc lh md me mf ll mg mh mi lp mj mk ml mm bi translated">介绍</h2><p id="a40d" class="pw-post-body-paragraph ky kz jj la b lb mn kk ld le mo kn lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">生成器是iterable的子类。</p><p id="9fee" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了理解生成器是如何工作的，我们需要首先修改iterables是如何工作的。</p><h2 id="e6ad" class="lu lv jj bd lw lx ly dn lz ma mb dp mc lh md me mf ll mg mh mi lp mj mk ml mm bi translated">可重复的</h2><p id="ac48" class="pw-post-body-paragraph ky kz jj la b lb mn kk ld le mo kn lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">iterable是可以迭代的对象。</p><p id="1561" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当我们写for循环时，它以一个<code class="fe ms mt mu mv b">for x in y:</code>语句开始。<code class="fe ms mt mu mv b">for</code>语句正在迭代表达式<code class="fe ms mt mu mv b">y</code>。因此，<code class="fe ms mt mu mv b">y</code>是可迭代的。</p><p id="f970" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一些非常常见的可重复项有:列表、元组、字符串等</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="adab" class="lu lv jj mv b gy ne nf l ng nh">for i in [0, 1, 2]:<br/>    print(i)</span><span id="01e9" class="lu lv jj mv b gy ni nf l ng nh">for i in (0, 1, 2):<br/>    print(i)</span><span id="107e" class="lu lv jj mv b gy ni nf l ng nh">for i in "012":<br/>    print(i)</span></pre><p id="b431" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Iterables将值存储在内存中，并允许使用<code class="fe ms mt mu mv b">__iter__</code>和<code class="fe ms mt mu mv b">__next__</code>方法进行迭代。以上面的例子为例，在使用<code class="fe ms mt mu mv b">__iter__</code>进行迭代之前，首先创建一个值为<code class="fe ms mt mu mv b">"012"</code>的字符串并存储在内存中。因此，iterables的一个主要优点是它们可以被访问和迭代任意多次。同时，作为将它存储在内存中的折衷，当你的iterables变长时，它将占用更多的内存。</p><h2 id="2d60" class="lu lv jj bd lw lx ly dn lz ma mb dp mc lh md me mf ll mg mh mi lp mj mk ml mm bi translated">发电机</h2><p id="b575" class="pw-post-body-paragraph ky kz jj la b lb mn kk ld le mo kn lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">生成器是只能迭代一次的iterable的子类。</p><p id="69aa" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">本质上，生成器生成(产出)一个值，忘记它，并生成下一个值，直到满足结束条件。</p><p id="c393" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在选择使用生成器还是迭代器时，有几个关键因素值得考虑:</p><ol class=""><li id="08df" class="nj nk jj la b lb lc le lf lh nl ll nm lp nn lt no np nq nr bi translated">你需要内存中的全部结果吗？</li><li id="a595" class="nj nk jj la b lb ns le nt lh nu ll nv lp nw lt no np nq nr bi translated">您需要按原样重用原始结果吗？</li><li id="f859" class="nj nk jj la b lb ns le nt lh nu ll nv lp nw lt no np nq nr bi translated">你的结果是否足够小，可以放入内存？</li><li id="a7d6" class="nj nk jj la b lb ns le nt lh nu ll nv lp nw lt no np nq nr bi translated">是否要在获得所有结果后处理结果？</li></ol><p id="1d6d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果以上都是肯定的，那么迭代器就足够了。否则，您可能想考虑使用一个生成器来从延迟执行和动态让步中获益。</p><p id="870c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您可以通过两种方式创建发生器:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="f5e5" class="lu lv jj mv b gy ne nf l ng nh"><strong class="mv jk"># 1. list comprehension but with parenthesis</strong></span><span id="f374" class="lu lv jj mv b gy ni nf l ng nh">g = (i ** 2 for i in range(10))<br/>type(g)</span><span id="e467" class="lu lv jj mv b gy ni nf l ng nh"># generator</span><span id="ba24" class="lu lv jj mv b gy ni nf l ng nh"><strong class="mv jk"># 2. use yield</strong></span><span id="508c" class="lu lv jj mv b gy ni nf l ng nh">def create_generator(i):<br/>    for i in range(i):<br/>        yield i ** 2</span><span id="a71b" class="lu lv jj mv b gy ni nf l ng nh">type(create_generator(10))<br/># generator</span></pre><p id="b70b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">假设你有一个生成器，你想把值存储在一个列表中。由于生成器会动态地生成值，因此需要对其进行迭代，以获取用于创建列表的值。由于生成器只能迭代一次，因此之后生成器将为空。如果我们迭代并中途停止，情况也是如此:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="67c1" class="lu lv jj mv b gy ne nf l ng nh">g = (i for i in range(5))</span><span id="8eb4" class="lu lv jj mv b gy ni nf l ng nh"><strong class="mv jk"># Cast the generator to a list for the first time</strong><br/>l = list(g)<br/>l</span><span id="c082" class="lu lv jj mv b gy ni nf l ng nh"># [0, 1, 2, 3, 4]</span><span id="b661" class="lu lv jj mv b gy ni nf l ng nh"><strong class="mv jk"># Cast the generator to a list for the second time</strong><br/>l = list(g)<br/>l</span><span id="e6d1" class="lu lv jj mv b gy ni nf l ng nh"># []</span><span id="46c5" class="lu lv jj mv b gy ni nf l ng nh">g = (i for i in range(5))</span><span id="b71b" class="lu lv jj mv b gy ni nf l ng nh"><strong class="mv jk"># Iterate the generator and stop halfway through</strong><br/>for i in g:<br/>    if i == 2:<br/>        break</span><span id="9648" class="lu lv jj mv b gy ni nf l ng nh">list(g)</span><span id="d111" class="lu lv jj mv b gy ni nf l ng nh"># [3, 4]</span></pre><h2 id="dbbb" class="lu lv jj bd lw lx ly dn lz ma mb dp mc lh md me mf ll mg mh mi lp mj mk ml mm bi translated">收益陈述&amp;发电机是如何工作的？</h2><p id="8987" class="pw-post-body-paragraph ky kz jj la b lb mn kk ld le mo kn lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">现在我们已经介绍了生成器的基本机制，让我们通过下面的例子来看看生成器实际上是如何工作的:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="dc64" class="lu lv jj mv b gy ne nf l ng nh">import numpy as np<br/>import time</span><span id="de1c" class="lu lv jj mv b gy ni nf l ng nh">def create_generator(n):<br/>    """ A generator that generate n arrays of 10^n random number<br/>    between 0 and 1. """</span><span id="1611" class="lu lv jj mv b gy ni nf l ng nh">    length = 10 ** n<br/>    print(f"length: {length}")</span><span id="65d4" class="lu lv jj mv b gy ni nf l ng nh">    for _ in range(n):<br/>        time.sleep(_)<br/>        print(_)<br/>        yield np.random.rand(length)<br/>        print("After yielding")</span><span id="2460" class="lu lv jj mv b gy ni nf l ng nh">    print("End of generator")</span></pre><p id="f7ed" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">收益率报表是更现实的生成器的核心。</p><p id="f4b8" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一个普通的函数在被调用时将被执行，并使用一个<code class="fe ms mt mu mv b">return</code>语句返回结果(如果没有语句，则返回<code class="fe ms mt mu mv b">None</code>)。</p><p id="ff0a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一个生成器函数<strong class="la jk">在被调用时不会被执行</strong>，而是只会返回一个生成器对象。</p><p id="32c4" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">好吧，但那是什么意思？</p><p id="300e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">假设我们有一个使用生成器的for循环:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="36aa" class="lu lv jj mv b gy ne nf l ng nh">g = create_generator(3)<br/>print(type(g))<br/>print("Before For Loop")</span><span id="5ba8" class="lu lv jj mv b gy ni nf l ng nh">for i in g:<br/>    print("Got something!")</span><span id="1b13" class="lu lv jj mv b gy ni nf l ng nh">print("After For Loop")</span></pre><p id="3eb3" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们将从片段中得到的是:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="887b" class="lu lv jj mv b gy ne nf l ng nh">&lt;class 'generator'&gt;<br/>Before For Loop<br/>length: 1000<br/>0<br/>Got something!<br/>After yielding<br/>1<br/>Got something!<br/>After yielding<br/>2<br/>Got something!<br/>After yielding<br/>End of generator<br/>After For Loop</span></pre><p id="6c15" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">发电机的工作方式是:</p><ol class=""><li id="75fe" class="nj nk jj la b lb lc le lf lh nl ll nm lp nn lt no np nq nr bi translated">代码在创建时不会被执行，而是返回一个生成器对象</li><li id="98b6" class="nj nk jj la b lb ns le nt lh nu ll nv lp nw lt no np nq nr bi translated">当<code class="fe ms mt mu mv b">for</code>语句第一次使用生成器时，生成器代码将一直执行到<code class="fe ms mt mu mv b">yield</code>语句</li><li id="4556" class="nj nk jj la b lb ns le nt lh nu ll nv lp nw lt no np nq nr bi translated">发电机的任何后续使用将恢复进度并运行，直到它再次到达<code class="fe ms mt mu mv b">yield</code>语句</li><li id="8459" class="nj nk jj la b lb ns le nt lh nu ll nv lp nw lt no np nq nr bi translated">一旦生成器到达末尾，它将运行剩余的代码</li></ol></div><div class="ab cl nx ny hx nz" role="separator"><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc"/></div><div class="im in io ip iq"><p id="d67f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这篇博文就讲到这里吧！我希望你已经发现这是有用的。如果你对其他Python技巧感兴趣，我为你整理了一份简短博客列表:</p><ul class=""><li id="9c42" class="nj nk jj la b lb lc le lf lh nl ll nm lp nn lt oe np nq nr bi translated"><a class="ae jg" rel="noopener" target="_blank" href="/python-tricks-flattening-lists-75aeb1102337"> Python技巧:扁平化列表</a></li><li id="7460" class="nj nk jj la b lb ns le nt lh nu ll nv lp nw lt oe np nq nr bi translated"><a class="ae jg" rel="noopener" target="_blank" href="/python-tricks-how-to-check-table-merging-with-pandas-cae6b9b1d540"> Python技巧:如何检查与熊猫的表格合并</a></li><li id="84b0" class="nj nk jj la b lb ns le nt lh nu ll nv lp nw lt oe np nq nr bi translated"><a class="ae jg" rel="noopener" target="_blank" href="/python-tricks-simplifying-if-statements-boolean-evaluation-4e10cc7c1e71"> Python技巧:简化If语句&amp;布尔求值</a></li><li id="5387" class="nj nk jj la b lb ns le nt lh nu ll nv lp nw lt oe np nq nr bi translated"><a class="ae jg" rel="noopener" target="_blank" href="/python-tricks-check-multiple-variables-against-single-value-18a4d98d79f4"> Python技巧:对照单个值检查多个变量</a></li></ul><p id="be3f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你想了解更多关于Python、数据科学或机器学习的知识，你可能想看看这些帖子:</p><ul class=""><li id="b678" class="nj nk jj la b lb lc le lf lh nl ll nm lp nn lt oe np nq nr bi translated"><a class="ae jg" rel="noopener" target="_blank" href="/7-easy-ways-for-improving-your-data-science-workflow-b2da81ea3b2">改进数据科学工作流程的7种简单方法</a></li><li id="3bcd" class="nj nk jj la b lb ns le nt lh nu ll nv lp nw lt oe np nq nr bi translated"><a class="ae jg" rel="noopener" target="_blank" href="/efficient-implementation-of-conditional-logic-on-pandas-dataframes-4afa61eb7fce">熊猫数据帧上的高效条件逻辑</a></li><li id="7179" class="nj nk jj la b lb ns le nt lh nu ll nv lp nw lt oe np nq nr bi translated"><a class="ae jg" rel="noopener" target="_blank" href="/memory-efficiency-of-common-python-data-structures-88f0f720421">常见Python数据结构的内存效率</a></li><li id="4da3" class="nj nk jj la b lb ns le nt lh nu ll nv lp nw lt oe np nq nr bi translated"><a class="ae jg" rel="noopener" target="_blank" href="/parallelism-with-python-part-1-196f0458ca14">与Python并行</a></li><li id="979b" class="nj nk jj la b lb ns le nt lh nu ll nv lp nw lt oe np nq nr bi translated"><a class="ae jg" rel="noopener" target="_blank" href="/cookiecutter-plugin-for-jupyter-easily-organise-your-data-science-environment-a56f83140f72">为数据科学设置必要的Jupyter扩展</a></li><li id="7dd8" class="nj nk jj la b lb ns le nt lh nu ll nv lp nw lt oe np nq nr bi translated"><a class="ae jg" rel="noopener" target="_blank" href="/mastering-root-searching-algorithms-in-python-7120c335a2a8">Python中高效的根搜索算法</a></li></ul><p id="2dff" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你想了解更多关于如何将机器学习应用于交易和投资的信息，这里有一些你可能感兴趣的帖子:</p><ul class=""><li id="9753" class="nj nk jj la b lb lc le lf lh nl ll nm lp nn lt oe np nq nr bi translated"><a class="ae jg" href="https://pub.towardsai.net/genetic-algorithm-for-trading-strategy-optimization-in-python-614eb660990d" rel="noopener ugc nofollow" target="_blank">Python中交易策略优化的遗传算法</a></li><li id="ef50" class="nj nk jj la b lb ns le nt lh nu ll nv lp nw lt oe np nq nr bi translated"><a class="ae jg" href="https://medium.com/towards-artificial-intelligence/genetic-algorithm-stop-overfitting-trading-strategies-5df671d5cde1" rel="noopener">遗传算法——停止过度拟合交易策略</a></li><li id="f205" class="nj nk jj la b lb ns le nt lh nu ll nv lp nw lt oe np nq nr bi translated"><a class="ae jg" href="https://pub.towardsai.net/ann-recommendation-system-for-stock-selection-c9751a3a0520" rel="noopener ugc nofollow" target="_blank">人工神经网络选股推荐系统</a></li></ul><div class="is it gp gr iu of"><a href="https://www.linkedin.com/in/louis-chan-b55b9287" rel="noopener  ugc nofollow" target="_blank"><div class="og ab fo"><div class="oh ab oi cl cj oj"><h2 class="bd jk gy z fp ok fr fs ol fu fw ji bi translated">Louis Chan—FTI Consulting | LinkedIn数据科学总监</h2><div class="om l"><h3 class="bd b gy z fp ok fr fs ol fu fw dk translated">雄心勃勃的，好奇的和有创造力的个人，对分支知识和知识之间的相互联系有强烈的信念</h3></div><div class="on l"><p class="bd b dl z fp ok fr fs ol fu fw dk translated">www.linkedin.com</p></div></div><div class="oo l"><div class="op l oq or os oo ot ja of"/></div></div></a></div></div></div>    
</body>
</html>