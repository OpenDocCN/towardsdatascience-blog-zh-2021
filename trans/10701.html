<html>
<head>
<title>Julia Tutorial for 3D Data Science</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">朱莉娅三维数据科学教程</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/julia-tutorial-for-3d-data-science-bf62aa004b0c?source=collection_archive---------15-----------------------#2021-10-14">https://towardsdatascience.com/julia-tutorial-for-3d-data-science-bf62aa004b0c?source=collection_archive---------15-----------------------#2021-10-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="408f" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">实践教程、3D数据</h2><div class=""/><div class=""><h2 id="3106" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">通过用于3D点云和网格处理的6步工作流程，探索Python、Matlab、R、Perl、Ruby和C的全能替代方案。</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/1c7c87a5360aa791bc29c1fa0f536c27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*POC-yHxF40JyvWZQOp9gYw.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">库的3D点云被自动分割，然后在Julia中可视化。弗洛伦特·普克斯</p></figure><p id="4276" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">如果你总是在寻找伟大的想法和新的“工具”，使它们更容易实现，那么你可能听说过朱莉娅。不到十年的非常年轻的语言👶，这是进入快速脚本/编码以快速实现工作想法的一个超级酷的方式🌼。</p><p id="80ca" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">假设你对科学计算、机器学习、数据挖掘、3D数据科学、大规模线性代数、分布式和并行计算感兴趣，我认为这是值得跟进的实践教程，与Julia一起开始做有趣的3D东西！</p><p id="0c7d" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在本新手教程中，我将直接切入主题，为您提供一个激光聚焦的6步工作流程，让您在接下来的十分钟内开始使用3D数据！准备好了吗？</p><h1 id="65e7" class="md me it bd mf mg mh mi mj mk ml mm mn ki mo kj mp kl mq km mr ko ms kp mt mu bi translated">一点历史？</h1><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi mv"><img src="../Images/ac17b4a7f643d57d37d3e8bdb4503e39.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RNQuqoX7rsdOqQ1F0cnvFQ.png"/></div></div></figure><p id="67f4" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">哈，不过在此之前，我想强调一下《朱丽亚》的创作者们的野心。朱莉娅的创造者，即杰夫·贝赞森、斯特凡·卡尔平斯基、维尔拉·b·沙阿和艾伦·埃德尔曼。他们在2012年的博客中讲述了他们的抱负，以及他们发起朱莉娅运动的根本原因:</p><blockquote class="mx my mz"><p id="6088" class="lh li na lj b lk ll kd lm ln lo kg lp nb lr ls lt nc lv lw lx nd lz ma mb mc im bi translated">我们想要一种开源的语言，有一个自由的许可证。我们想要C的速度和Ruby的活力。我们想要一种同形异义的语言，既有像Lisp那样的真正的宏，又有像Matlab那样明显、熟悉的数学符号。我们想要像Python一样可用于一般编程，像R一样易于统计，像Perl一样自然用于字符串处理，像Matlab一样强大用于线性代数，像shell一样善于将程序粘合在一起。这种东西学习起来非常简单，却能让最严肃的黑客感到高兴。我们希望它是交互式的，我们希望它是编译过的。应该和c一样快。</p></blockquote><p id="9359" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">但是这些主张成立吗🤔？这是一种“我都想要”的语言吗？好吧，我第一次发现朱莉娅是在2019年初，当时我正在德国亚琛工业大学(RWTH Aachen University)视觉计算研究所(计算机图形学)做研究访问。</p><div class="ne nf gp gr ng nh"><a href="https://www.vci.rwth-aachen.de/publication/03321/" rel="noopener  ugc nofollow" target="_blank"><div class="ni ab fo"><div class="nj ab nk cl cj nl"><h2 class="bd jd gy z fp nm fr fs nn fu fw jc bi translated">室内三维点云的无监督分割:应用于基于对象的分类</h2><div class="no l"><h3 class="bd b gy z fp nm fr fs nn fu fw dk translated">弗洛伦特·普克斯、克里斯蒂安·马特斯、叶小开·科贝尔特3D GeoInfo会议2020年室内场景的点云数据主要是…</h3></div><div class="np l"><p class="bd b dl z fp nm fr fs nn fu fw dk translated">www.vci.rwth-aachen.de</p></div></div></div></a></div><p id="8015" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">从那以后，我基本上是通过朱莉娅发誓的！这来自于Pythonista/C“程序员”的思维模式。它超级清晰，拿起来毫不费力，超级快，而且你可以在里面循环python脚本，直接调用你喜欢的库，纯Julia会执行的疯狂快！的确，朱丽亚是编译出来的，不是解读出来的。为了获得更快的运行时性能，Julia使用LLVM编译器框架进行实时(JIT)编译。在最好的情况下，Julia可以接近或匹配C语言的速度，这太棒了🚀！用三个字来说，我会说Julia是<strong class="lj jd">快速</strong>、<strong class="lj jd">动态</strong>和<strong class="lj jd">可再生环境。</strong></p><p id="44ba" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">⚠️警告说，虽然在写作的时候，文档和教程仍然很少，而且与你使用Python时所习惯的相比，社区也很小。但是，嘿，我打算改变一下。我们开始吧。</p><h1 id="9372" class="md me it bd mf mg mh mi mj mk ml mm mn ki mo kj mp kl mq km mr ko ms kp mt mu bi translated">步骤1:下载并安装Julia</h1><p id="ce6b" class="pw-post-body-paragraph lh li it lj b lk nq kd lm ln nr kg lp lq ns ls lt lu nt lw lx ly nu ma mb mc im bi translated">好了，现在你有了你的咖啡☕或茶杯🍵在你旁边，准备好寻找我们进入雾中的路，让我们潜水吧！首先，我们需要从官网下载茱莉亚:<a class="ae mw" href="https://julialang.org/downloads/" rel="noopener ugc nofollow" target="_blank">https://julialang.org/downloads/</a></p><p id="9b64" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><strong class="lj jd">注</strong> : <em class="na">本教程是用Julia版本1.6.2，64bits使用windows制作的，但是你可以用任何稳定版，应该可以(原则上</em>😉<em class="na">)。</em></p><p id="e538" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">一旦可执行文件被下载，就安装漂亮的东西，直到你漂亮的手准备好闪亮的“软件”为止！</p><h1 id="ad77" class="md me it bd mf mg mh mi mj mk ml mm mn ki mo kj mp kl mq km mr ko ms kp mt mu bi translated">步骤2:设置您的Julia开发环境</h1><p id="047b" class="pw-post-body-paragraph lh li it lj b lk nq kd lm ln nr kg lp lq ns ls lt lu nt lw lx ly nu ma mb mc im bi translated">Julia支持各种编辑器，如<a class="ae mw" href="https://www.julia-vscode.org/" rel="noopener ugc nofollow" target="_blank"> VSCode </a>、<a class="ae mw" href="https://junolab.org/" rel="noopener ugc nofollow" target="_blank"> Atom </a>、<a class="ae mw" href="https://github.com/JuliaEditorSupport/julia-emacs" rel="noopener ugc nofollow" target="_blank"> Emacs </a>、<a class="ae mw" href="https://github.com/JuliaEditorSupport/Julia-sublime" rel="noopener ugc nofollow" target="_blank"> Sublime </a>、<a class="ae mw" href="https://github.com/JuliaEditorSupport/julia-vim" rel="noopener ugc nofollow" target="_blank"> Vim </a>、<a class="ae mw" href="https://github.com/JuliaEditorSupport/julia-NotepadPlusPlus" rel="noopener ugc nofollow" target="_blank"> Notepad++ </a>，以及ide如<a class="ae mw" href="https://github.com/JuliaEditorSupport/julia-intellij" rel="noopener ugc nofollow" target="_blank"> IntelliJ </a>。如果你喜欢Jupyter笔记本，也可以直接和Julia一起用。对于本教程，我将向您展示我最喜欢的三个选择。</p><h2 id="38f8" class="nv me it bd mf nw nx dn mj ny nz dp mn lq oa ob mp lu oc od mr ly oe of mt iz bi translated">茱莉亚拿着朱庇特笔记本</h2><p id="f785" class="pw-post-body-paragraph lh li it lj b lk nq kd lm ln nr kg lp lq ns ls lt lu nt lw lx ly nu ma mb mc im bi translated">如果你想用powerpoint风格的方式演示你的项目，或者你想做的更多的是探索性的数据分析，这将是第一选择。最简单的方法是，启动新安装的Julia可执行文件，然后会弹出如下窗口。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi og"><img src="../Images/282f6ed79f71243a450f41933bc64940.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FB0aIFpuF3Nn_EVe6s9SyQ.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">Julia.exe让这个小窗口出现，它充当了你工作的REPL。弗洛伦特·普克斯</p></figure><p id="8de9" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">从那里，你所要做的就是键入命令<code class="fe oh oi oj ok b">using Pkg</code>，然后按下<code class="fe oh oi oj ok b">Enter</code>，接着是命令<code class="fe oh oi oj ok b">Pkg.add("IJulia")</code>和<code class="fe oh oi oj ok b">Enter</code>。在Jupyter笔记本中安装使用Julia所需的<code class="fe oh oi oj ok b">IJulia</code>包的过程大约需要1分钟。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi og"><img src="../Images/437b5da84db54465c28abbb37c95d3b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LTWRvCQE-AaSUARYCaZANQ.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">使用Pkg.add()命令添加软件包会导致Julia更新注册表，然后获取必要的元素以在当前环境中安装软件包。弗洛伦特·普克斯</p></figure><p id="7f49" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">然后，您可以在您选择的环境中从哪个Jupyter笔记本启动<a class="ae mw" href="https://www.anaconda.com/" rel="noopener ugc nofollow" target="_blank"> Anaconda Navigator </a>(带GUI)。</p><p id="ee7a" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><strong class="lj jd"> <em class="na">注</em> </strong> <em class="na"> : </em>如果你没有安装Anaconda，可以按照下面的教程进行操作:</p><div class="ne nf gp gr ng nh"><a rel="noopener follow" target="_blank" href="/discover-3d-point-cloud-processing-with-python-6112d9ee38e7"><div class="ni ab fo"><div class="nj ab nk cl cj nl"><h2 class="bd jd gy z fp nm fr fs nn fu fw jc bi translated">使用Python探索3D点云处理</h2><div class="no l"><h3 class="bd b gy z fp nm fr fs nn fu fw dk translated">教程简单地设置python环境，开始处理和可视化3D点云数据。</h3></div><div class="np l"><p class="bd b dl z fp nm fr fs nn fu fw dk translated">towardsdatascience.com</p></div></div><div class="ol l"><div class="om l on oo op ol oq lb nh"/></div></div></a></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi or"><img src="../Images/ad4f82ae613e967432958a549898a9da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TaqN4vcDX_0B0RFFOvpeXQ.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">一旦GUI出现，您就可以直接启动Jupyter。弗洛伦特·普克斯</p></figure><p id="70e8" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">一旦打开，你可以用Julia作为编程语言创建一个新的笔记本</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi os"><img src="../Images/37fbb8a94ba00eb4968ba73b4bf1f3b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3Tbu2R4kqURjLfnztrUGDQ.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">一旦进入Jupyter，你可以点击new，选择Julia 1。创建一个新的基于Julia的笔记本。F. Poux</p></figure><h2 id="c98e" class="nv me it bd mf nw nx dn mj ny nz dp mn lq oa ob mp lu oc od mr ly oe of mt iz bi translated">朱莉娅与原子IDE和朱诺</h2><p id="b6a6" class="pw-post-body-paragraph lh li it lj b lk nq kd lm ln nr kg lp lq ns ls lt lu nt lw lx ly nu ma mb mc im bi translated">我倾向于支持Atom+Juno组合，它允许您从交互式REPL模式中受益，就像您习惯的Spyder一样。如果您选择遵循这些步骤，您首先需要按照在<a class="ae mw" href="https://atom.io/" rel="noopener ugc nofollow" target="_blank">https://atom.io/</a>给出的说明在您的系统中安装Atom。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/b9a9062fab9389b7611cc25ce6d70031.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0trYIpYgfGSELELihEjv9Q.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">ATOM中GUI的快照。它使得创建成熟软件的过程变得更加容易。弗洛伦特·普克斯</p></figure><p id="6532" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">然后，您可以启动Atom并通过Packages&gt;Settings view&gt;Open或快捷方式<code class="fe oh oi oj ok b">Ctrl+,</code>进入包安装设置。在那里搜索<code class="fe oh oi oj ok b">juno</code>，然后点击<code class="fe oh oi oj ok b">uber-juno</code>的安装按钮，如果没有安装<code class="fe oh oi oj ok b">juno-client</code>。一旦安装了Juno，你可以尝试用<code class="fe oh oi oj ok b">Juno &gt; Open REPL</code>或<code class="fe oh oi oj ok b">Ctrl+J Ctrl+O</code>(MAC OS上的<code class="fe oh oi oj ok b">Cmd+J Cmd+O</code>)打开REPL，然后在REPL中按<code class="fe oh oi oj ok b">Enter</code>来启动Julia会话。就是这样！我们准备编码了！</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ot"><img src="../Images/b70154636654dedbcb5650e47645e19f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ItxEAHAqtNMm-PgpGIS8JA.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">在酒吧搜索Juno时，我会寻找有用的必要软件包，其中包括uber-juno和juno-client。F. Poux</p></figure><p id="3942" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><strong class="lj jd">注意</strong> : <em class="na">如果REPL没有</em> <strong class="lj jd"> <em class="na">而不是</em> </strong> <em class="na">正确启动，并且没有显示Julia徽标，请从软件包菜单转至Juno客户端设置，并验证tour Julia可执行文件的路径。</em></p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/e7402bab15c9b5f4853783c06f02a3e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1008/format:webp/1*vFk6AIvaO3M1C1QmptRfFw.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">我的Julia可执行文件的路径。弗洛伦特·普克斯</p></figure><h2 id="300f" class="nv me it bd mf nw nx dn mj ny nz dp mn lq oa ob mp lu oc od mr ly oe of mt iz bi translated">额外奖励:茱莉亚和谷歌实验室</h2><p id="2223" class="pw-post-body-paragraph lh li it lj b lk nq kd lm ln nr kg lp lq ns ls lt lu nt lw lx ly nu ma mb mc im bi translated">您也可以使用google Colab环境，但是这需要一个特定代码块来使用Julia而不是Python。为此，您将在<a class="ae mw" href="https://colab.research.google.com/drive/1JntKGssOxWxBpmy7IaWdYL1tzVTKnseW?usp=sharing" rel="noopener ugc nofollow" target="_blank">找到这个链接</a>一个模板，它使得直接在Colab中工作成为可能。它还包含本教程的主要代码。</p><p id="c1b9" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><strong class="lj jd">注意</strong> : <em class="na">每次你想在Google Cloud上使用Julia，都需要运行第一个块，刷新页面，直接继续到第二个块，不需要重新运行第一个，直到每个元素都为你准备好。</em></p><h1 id="3382" class="md me it bd mf mg mh mi mj mk ml mm mn ki mo kj mp kl mq km mr ko ms kp mt mu bi translated">步骤3:加载数据集</h1><p id="8a67" class="pw-post-body-paragraph lh li it lj b lk nq kd lm ln nr kg lp lq ns ls lt lu nt lw lx ly nu ma mb mc im bi translated">太好了，那么现在我们准备好朱丽亚代码了。首先，让我们使用命令<code class="fe oh oi oj ok b">pwd()</code>来发现我们正在哪里工作，也就是我们当前的工作目录。嗯，看起来我们是在基本目录中，所以让我们把它改成一个项目目录，你可以用<code class="fe oh oi oj ok b">cd(“C://DEV/JULIA/TUTORIALS/3D_PROJECT_1”)</code>创建这个目录来存储你的大部分项目(数据、结果等等)，然后用<code class="fe oh oi oj ok b">pwd()</code>检查新的路径。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ov"><img src="../Images/01cd2563d46211aa4b16e432be7bfc99.png" data-original-src="https://miro.medium.com/v2/resize:fit:790/format:webp/1*SuQOH88wOdHJowE7qtU0Ew.png"/></div></figure><p id="c906" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">好的，我们都准备好了。首先，让我们下载一个数据集，一个小的噪声点云。为此，非常方便的是，可以使用以下命令:</p><pre class="ks kt ku kv gt ow ok ox oy aw oz bi"><span id="4503" class="nv me it ok b gy pa pb l pc pd">download("https://raw.githubusercontent.com/florentPoux/3D-small-datasets/main/tree_sample.csv","point_cloud_sample.csv")</span></pre><p id="f4ba" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><strong class="lj jd">注意</strong>:<em class="na"/><code class="fe oh oi oj ok b"><em class="na">download()</em></code><em class="na">命令首先获取你想要下载的数据的链接，我把它放到了我的GitHub账号上，然后在下载后在本地指定它的名称。</em></p><p id="6237" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">很好，我们现在在工作目录中有了用<code class="fe oh oi oj ok b">cd()</code>命令指定的数据的本地版本。现在，我们如何在脚本中加载它？嗯，我们将使用一个名为<code class="fe oh oi oj ok b">DelimitedFiles</code>的<strong class="lj jd">包</strong>。</p><p id="a2fd" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><strong class="lj jd">注</strong> <em class="na">:包是一组方便的函数、方法、类等等，它允许你在现有代码的基础上构建，而不需要从头开始编写任何东西。</em> <code class="fe oh oi oj ok b"><em class="na">DelimitedFiles</em></code> <em class="na">包允许操作(例如，读和写)定界文件，就像我们手头的当前点云</em>。</p><p id="9639" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">要使用一个包，我们首先必须通过键入<code class="fe oh oi oj ok b">using Pkg</code>来加载<strong class="lj jd">包管理器实用程序</strong>。要添加一个新的包，非常简单；我们只需编写<code class="fe oh oi oj ok b">Pkg.add(“DelimitedFiles”)</code>，等待下载+需求检查完成。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pe"><img src="../Images/cf3b3b07ac713201e5155ef6afc309e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1228/format:webp/1*V0dzKK3c6csQtfuv73l40Q.png"/></div></figure><p id="928a" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">最棒的是，你不必担心依赖关系(当前需要的其他包),因为一切都为你处理好了！很酷吧。最重要的是，我们可以轻松地创建优秀的包，以确保结果的可重复性，例如，和独立的环境，但这是另一个教程😉。</p><p id="52d3" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><strong class="lj jd">注意</strong> <em class="na"> : </em> <em class="na">管理软件包非常简单，我们有一堆函数来更新软件包，了解它们的当前状态，如果它们之间有任何冲突(很少)，或者加载其他志同道合的编码者未注册的软件包，甚至是你未来的本地软件包</em>😉。我通常使用REPL来管理它们，并在正确的环境中使用命令 <code class="fe oh oi oj ok b"><em class="na">]</em></code> <em class="na">进入包管理器。要退出软件包管理器，只需要做</em> <code class="fe oh oi oj ok b"><em class="na">Ctrl+C</em></code> <em class="na">。</em></p><p id="083e" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">好了，现在包已经安装好了(您只需要在每个环境中运行一次)。您可以通过键入<code class="fe oh oi oj ok b">using DelimitedFiles</code>在您当前的项目中使用它，并且，如果没有函数名的冲突，您不需要编写函数来自哪个包。读取分隔文件<code class="fe oh oi oj ok b">DelimitedFiles.readdlm()</code>等同于<code class="fe oh oi oj ok b">readdlm()</code>。</p><p id="8873" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">从那里，让我们读取手边的点云并将数据存储在变量<code class="fe oh oi oj ok b">pointlist</code>中:</p><pre class="ks kt ku kv gt ow ok ox oy aw oz bi"><span id="2bff" class="nv me it ok b gy pa pb l pc pd">pointlist=readdlm(“point_cloud_sample.csv”,’;’)</span></pre><p id="9473" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">第一行应该如下所示。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pf"><img src="../Images/39aa51ea41c68fdf3688c953bd53d7ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:896/format:webp/1*iNGalzUdQ2mFKkWg0TvIkw.png"/></div></figure><h1 id="fce6" class="md me it bd mf mg mh mi mj mk ml mm mn ki mo kj mp kl mq km mr ko ms kp mt mu bi translated">步骤4:第一步预处理操作</h1><p id="1ebe" class="pw-post-body-paragraph lh li it lj b lk nq kd lm ln nr kg lp lq ns ls lt lu nt lw lx ly nu ma mb mc im bi translated">好吧，到现在都很酷，嗯？现在，让我们看看第一个真正的惊喜，如果你习惯于其他编程语言的话:<strong class="lj jd">索引</strong>。您可以尝试执行<code class="fe oh oi oj ok b">pointlist[0]</code>来检索第一个元素。我们得到了什么？一个<em class="na">边界错误</em>。</p><p id="6264" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">哈哈，在Julia中，<strong class="lj jd">索引从1 </strong>开始，所以如果你想检索第一个元素(第一个点的X坐标)，你只需输入返回<code class="fe oh oi oj ok b">41.61793137</code>的<code class="fe oh oi oj ok b">pointlist[1]</code>。起初有点令人困惑，但至少从科学的角度来看，它非常方便且符合逻辑😅。所以现在，如果您想要检索第一个点，那么您需要知道索引首先作用于第一个轴(行)，然后是第二个轴(列)，依此类推。因此，要检索第一个点(第一行和每一列):</p><pre class="ks kt ku kv gt ow ok ox oy aw oz bi"><span id="e704" class="nv me it ok b gy pa pb l pc pd">pointlist[1,:]</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pg"><img src="../Images/e4e5fe5f2ecb222cfd64c8d75d77aca8.png" data-original-src="https://miro.medium.com/v2/resize:fit:880/format:webp/1*MIkFPReGDpb8QOjEehQwVw.png"/></div></figure><p id="387d" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">非常酷，现在，为了更进一步，如果我们想在<code class="fe oh oi oj ok b">points</code>变量中存储坐标，在<code class="fe oh oi oj ok b">normals</code>变量中存储法线，我们只需要:</p><pre class="ks kt ku kv gt ow ok ox oy aw oz bi"><span id="12cb" class="nv me it ok b gy pa pb l pc pd">points  = pointlist[:,1:3]<br/>normals = pointlist[:,4:6]</span></pre><p id="5b35" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><strong class="lj jd">注意</strong> <em class="na"> : </em> <em class="na">如果你想知道一个变量的类型，</em> <code class="fe oh oi oj ok b"><em class="na">typeof()</em></code> <em class="na">就是你要找的。</em> <code class="fe oh oi oj ok b"><em class="na">typeof(points)</em></code> <em class="na">会显示我们处理的是矩阵，是二维数组的别名。还有</em> <code class="fe oh oi oj ok b"><em class="na">Float64</em></code> <em class="na">是计算机数字格式，通常在计算机内存中占用64位；它通过使用浮点表示宽动态范围的数值。当单精度(</em> <code class="fe oh oi oj ok b"><em class="na">Float32</em></code> <em class="na">)的范围或精度不够时，可以选择双精度。</em></p><p id="e66c" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">最后一个简单的预处理步骤是知道如何快速采样变量，比如说，每十分之一行。为此，我们可以这样做(有点像Python，但我们需要放上单词<code class="fe oh oi oj ok b">end</code>来处理total变量):</p><pre class="ks kt ku kv gt ow ok ox oy aw oz bi"><span id="d95a" class="nv me it ok b gy pa pb l pc pd">points_sampled=points[1:10:end,:] </span></pre><p id="7fc1" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们首先处理行，每十分之一取一行，对于每一行，我们保留所有列，在<code class="fe oh oi oj ok b">,</code>之后是<code class="fe oh oi oj ok b">:</code>。</p><p id="0810" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><strong class="lj jd">提示</strong>这种方式执行起来非常快速和简单；因此，它通常在不使用太多记忆的情况下获得第一视觉结果来知道我们正在处理什么。如果你想更深入，我建议你按照下面的教程。对朱莉娅的改编应该不会有太大问题😉。</p><div class="ne nf gp gr ng nh"><a rel="noopener follow" target="_blank" href="/how-to-automate-lidar-point-cloud-processing-with-python-a027454a536c"><div class="ni ab fo"><div class="nj ab nk cl cj nl"><h2 class="bd jd gy z fp nm fr fs nn fu fw jc bi translated">如何使用Python自动处理激光雷达点云</h2><div class="no l"><h3 class="bd b gy z fp nm fr fs nn fu fw dk translated">使用Python从头开始点云子采样的终极指南。它涵盖了激光雷达输入/输出，三维体素网格处理…</h3></div><div class="np l"><p class="bd b dl z fp nm fr fs nn fu fw dk translated">towardsdatascience.com</p></div></div><div class="ol l"><div class="ph l on oo op ol oq lb nh"/></div></div></a></div><h1 id="7594" class="md me it bd mf mg mh mi mj mk ml mm mn ki mo kj mp kl mq km mr ko ms kp mt mu bi translated">步骤5: 3D数据可视化</h1><p id="a90e" class="pw-post-body-paragraph lh li it lj b lk nq kd lm ln nr kg lp lq ns ls lt lu nt lw lx ly nu ma mb mc im bi translated">我们现在准备处理3D数据可视化，这是掌握我们正在处理的东西的关键一步！这里，一个库是首选的解决方案:<code class="fe oh oi oj ok b">Makie</code>。因为我们还没有使用它，我们首先需要导入这个包，以及其他两个“后端”，这取决于您的范例(webGL可视化或OpenGL可视化)，即<code class="fe oh oi oj ok b">WGLMakie </code>和<code class="fe oh oi oj ok b">GLMakie</code>。没有比这更简单的了，我们只需运行下面三行代码一次:</p><pre class="ks kt ku kv gt ow ok ox oy aw oz bi"><span id="25e1" class="nv me it ok b gy pa pb l pc pd">Pkg.add(“Makie”)<br/>Pkg.add(“WGLMakie”)<br/>Pkg.add(“GLMakie”)</span></pre><p id="7b6a" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><strong class="lj jd">注意</strong> <em class="na">:一旦执行，如果您想随时浏览您当前环境中已经安装的软件包，您可以使用</em> <code class="fe oh oi oj ok b"><em class="na">Pkg.installed()</em></code> <em class="na">命令。</em></p><p id="bde9" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">一旦安装了所需的包，为了使它们在您的工作会话中可用，您可以添加行<code class="fe oh oi oj ok b">using Makie, GLMakie</code>(或者<code class="fe oh oi oj ok b">using Makie, WGLMakie</code>，如果您想要在web上与Colab或Jupyter交互的话)，很像Python中的<code class="fe oh oi oj ok b">import matplotlib</code>。</p><p id="16d8" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">很好，现在，在可视化之前，让我们为无色点准备一点颜色，这取决于它们的z值。我们将创建一个颜色向量，其大小为采样点云的大小，范围从0到1，取决于它与最大值的接近程度，通过划分每个点:</p><pre class="ks kt ku kv gt ow ok ox oy aw oz bi"><span id="e8d4" class="nv me it ok b gy pa pb l pc pd">zcoloring_scale=points_sampled[:,3]/maximum(points_sampled[:,3])</span></pre><p id="78d9" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><strong class="lj jd">提示</strong> <em class="na"> : Julia自动理解你想用</em> <code class="fe oh oi oj ok b">maximum()</code> <em class="na">将</em> <code class="fe oh oi oj ok b"><em class="na">points_sampled[:,3]</em></code> <em class="na">中的每个元素除以最大值。得心应手吧。但它是</em> <strong class="lj jd"> <em class="na">播</em> </strong> <em class="na">的特例，在Julia中，你只要在你的函数或数学符号前输入一个</em> <code class="fe oh oi oj ok b"><em class="na">.</em></code> <em class="na">就可以了。如果在这里做</em> <code class="fe oh oi oj ok b"><em class="na">./</em></code> <em class="na">，也会得到同样的结果。</em></p><p id="420e" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">好了，现在，我们要做的就是把我们的结果绘制成三维的散乱点云。为此，我们使用来自<code class="fe oh oi oj ok b">Makie</code>的<code class="fe oh oi oj ok b">scatter</code>函数，我们传递点的坐标(<code class="fe oh oi oj ok b">points_sampled</code>)、颜色向量<code class="fe oh oi oj ok b">zcoloring_scale</code>以及一些参数，如每个点的大小和<code class="fe oh oi oj ok b">markersize</code>，以及我们是否想要显示轴。</p><pre class="ks kt ku kv gt ow ok ox oy aw oz bi"><span id="6e8c" class="nv me it ok b gy pa pb l pc pd">scatter(points_sampled, color=zcoloring_scale, markersize=100, show_axis=true)</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pi"><img src="../Images/d11799735a2006712d60b0e6b45c5909.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tuyg2gLjHdx966dhv8A19w.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">左边是使用散点函数的图。右边是使用meshscatter函数的图。在这两种情况下，我们现在可以掌握我们正在处理点云的类型。弗洛伦特·普克斯</p></figure><p id="6b80" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">你也可以绘制一个<code class="fe oh oi oj ok b">meshscatter</code>图，为每个点生成一个小球体(就像上面右边的图片)</p><pre class="ks kt ku kv gt ow ok ox oy aw oz bi"><span id="4183" class="nv me it ok b gy pa pb l pc pd">scene_1 = meshscatter(points_sampled, color=zcoloring_scale, markersize=0.2, show_axis=true)</span></pre><p id="1d72" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">多么酷啊！如果你想在网络上有一些交互性，你应该确保使用<code class="fe oh oi oj ok b">WGLMakie</code>而不是<code class="fe oh oi oj ok b">GLMakie</code>，它只会给你一个固定的后端来生成一个视图。</p><p id="f6bc" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><strong class="lj jd">提示</strong> <em class="na">:如果你想将你的图形打印到一个文件中，一个简单的方法是首先使用</em> <code class="fe oh oi oj ok b"><em class="na">Pkg.add(“FileIO”)</em></code> <em class="na">和</em> <code class="fe oh oi oj ok b"><em class="na">using FileIO</em></code> <em class="na">安装</em> <code class="fe oh oi oj ok b"><em class="na">FileIO</em></code> <em class="na">软件包，该软件包包含了处理大量文件格式(包括网格、图像、矢量等)所必需的方法和功能，一旦在你的运行会话中可用，一个简单的</em> <code class="fe oh oi oj ok b"><em class="na">save(“scatter.png”, scene_1)</em></code> <em class="na">就会将图形保存到你的工作目录中的图像中。</em></p><h2 id="4012" class="nv me it bd mf nw nx dn mj ny nz dp mn lq oa ob mp lu oc od mr ly oe of mt iz bi translated">[附加功能] 3D网格输入/输出</h2><p id="4f8a" class="pw-post-body-paragraph lh li it lj b lk nq kd lm ln nr kg lp lq ns ls lt lu nt lw lx ly nu ma mb mc im bi translated">一种显示网格的简单方法是使用FileIO，就像上面暗示的那样。用两行简单的代码，你可以显示你的网格。以我的GitHub上可用的点云为例:</p><pre class="ks kt ku kv gt ow ok ox oy aw oz bi"><span id="0562" class="nv me it ok b gy pa pb l pc pd">download("https://raw.githubusercontent.com/florentPoux/3D-small-datasets/main/hippo_1k.obj","hippo_1k.obj")</span></pre><p id="8ba8" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">然后，您可以将它存储在obj变量中:</p><pre class="ks kt ku kv gt ow ok ox oy aw oz bi"><span id="8de7" class="nv me it ok b gy pa pb l pc pd">obj = load(“hippo_1k.obj”)</span></pre><p id="e537" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">你传递给<code class="fe oh oi oj ok b">Makie.mesh()</code>函数，简称为<code class="fe oh oi oj ok b">mesh()</code>来显示你的3D模型。</p><pre class="ks kt ku kv gt ow ok ox oy aw oz bi"><span id="9f57" class="nv me it ok b gy pa pb l pc pd">mesh(obj, color=”honeydew2”, show_axis=false)</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pj"><img src="../Images/a8b009770b64501bb5c38b40cb6874d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oCYsN3jYGBF5uzKPJYoJfA.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">使用Makie的3D网格可视化工具的结果。弗洛伦特·普克斯</p></figure><p id="b6fe" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">如果这不是优化代码清晰，我不知道它是什么😆！</p><p id="1572" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><strong class="lj jd">提示</strong>🙃。</p><h1 id="c36f" class="md me it bd mf mg mh mi mj mk ml mm mn ki mo kj mp kl mq km mr ko ms kp mt mu bi translated">步骤6: 3D数据分析</h1><p id="ffeb" class="pw-post-body-paragraph lh li it lj b lk nq kd lm ln nr kg lp lq ns ls lt lu nt lw lx ly nu ma mb mc im bi translated">现在我们可以研究一些数据，并使用一些函数。首先要知道如何访问3D点云数据集的特定部分。在我们的例子中，我们希望找到并(或多或少)将地面与其余部分分开。首先，我们将通过可视化找到地面较高的z，然后使用它作为阈值。让我们绘制数据集的2D投影:</p><pre class="ks kt ku kv gt ow ok ox oy aw oz bi"><span id="720a" class="nv me it ok b gy pa pb l pc pd">scatter(points_sampled[:,2:3], color=zcoloring_scale, markersize=100, show_axis=true)</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pk"><img src="../Images/675998032001e41ef8a85a7fcc421dee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Urh8iiHa3qJ1oPaX_S8gPA.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">点云在y轴上的2D投影，以尝试并抓住潜在的阈值线来分离我们的3D点云数据集。</p></figure><p id="6761" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们可以确定在大约3米(红线)处有一个阈值。让我们直接用它来做实验。</p><p id="1259" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><strong class="lj jd">提示</strong>😀。</p><p id="2d66" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">现在，我们希望找到低于和高于视觉定义的阈值的所有点，并将它们存储在一个单独的变量中。我们将使用<code class="fe oh oi oj ok b">findall</code>函数返回满足括号中条件的点的索引。让我们只关注<code class="fe oh oi oj ok b">points[:,3]</code>，因为我们只需要研究它并检索索引，我们稍后可以使用这些索引来过滤我们的完整点云。多酷啊😆？</p><pre class="ks kt ku kv gt ow ok ox oy aw oz bi"><span id="f303" class="nv me it ok b gy pa pb l pc pd">indexes_ground=findall(x-&gt;x &lt; 3, points[:,3])<br/>indexes_tree=findall(x-&gt;x&gt;=3, points[:,3])</span></pre><p id="9c31" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">非常好！现在，如果我们想要获得对应于这些索引列表的点，我们只需在points变量中传递<code class="fe oh oi oj ok b">indexes_ground</code>或<code class="fe oh oi oj ok b">indexes_tree</code>作为行选择器，例如，用于获得属于地面的所有点和所有其他点。如果我们想画这个，我们可以这样做:</p><pre class="ks kt ku kv gt ow ok ox oy aw oz bi"><span id="8ffc" class="nv me it ok b gy pa pb l pc pd">meshscatter(points[indexes_ground,:], color=”navajowhite4”, markersize=0.3, show_axis=false)<br/>meshscatter!(points[indexes_tree,:], color=”honeydew3”, markersize=0.3, show_axis=false)<br/>current_figure()<br/></span></pre><p id="b580" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">厉害！我们刚刚做了一个手动实例分割步骤，其中我们有一个基础元素和一个树元素，并且使用了一种新的语言；干得好！</p><h1 id="902a" class="md me it bd mf mg mh mi mj mk ml mm mn ki mo kj mp kl mq km mr ko ms kp mt mu bi translated">结论</h1><p id="a987" class="pw-post-body-paragraph lh li it lj b lk nq kd lm ln nr kg lp lq ns ls lt lu nt lw lx ly nu ma mb mc im bi translated">在Julia中，您刚刚学习了如何导入、子采样、导出和可视化由数十万个点组成的点云！干得好！但是这条路并没有到此为止，未来的文章将会深入探讨点云空间分析、文件格式、数据结构、可视化、动画和网格划分。我们将特别关注如何管理大点云数据，如下面的文章中所定义的。</p><div class="ne nf gp gr ng nh"><a rel="noopener follow" target="_blank" href="/the-future-of-3d-point-clouds-a-new-perspective-125b35b558b9"><div class="ni ab fo"><div class="nj ab nk cl cj nl"><h2 class="bd jd gy z fp nm fr fs nn fu fw jc bi translated">三维点云的未来:一个新的视角</h2><div class="no l"><h3 class="bd b gy z fp nm fr fs nn fu fw dk translated">被称为点云的离散空间数据集通常为决策应用奠定基础。但是他们能不能…</h3></div><div class="np l"><p class="bd b dl z fp nm fr fs nn fu fw dk translated">towardsdatascience.com</p></div></div><div class="ol l"><div class="pl l on oo op ol oq lb nh"/></div></div></a></div><div class="ne nf gp gr ng nh"><a rel="noopener follow" target="_blank" href="/how-to-automate-3d-point-cloud-segmentation-and-clustering-with-python-343c9039e4f5"><div class="ni ab fo"><div class="nj ab nk cl cj nl"><h2 class="bd jd gy z fp nm fr fs nn fu fw jc bi translated">如何使用Python实现3D点云分割和聚类的自动化</h2><div class="np l"><p class="bd b dl z fp nm fr fs nn fu fw dk translated">towardsdatascience.com</p></div></div><div class="ol l"><div class="pm l on oo op ol oq lb nh"/></div></div></a></div><p id="061d" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我的贡献旨在浓缩可操作的信息，以便您可以从零开始为您的项目构建3D自动化系统。您可以通过参加<a class="ae mw" href="https://learngeodata.eu/" rel="noopener ugc nofollow" target="_blank">地理数据学院</a>的在线课程立即开始。</p><div class="ne nf gp gr ng nh"><a href="https://learngeodata.eu/point-cloud-processor-formation/" rel="noopener  ugc nofollow" target="_blank"><div class="ni ab fo"><div class="nj ab nk cl cj nl"><h2 class="bd jd gy z fp nm fr fs nn fu fw jc bi translated">点云处理在线课程- 3D地理数据学院</h2><div class="no l"><h3 class="bd b gy z fp nm fr fs nn fu fw dk translated">编队学习先进的点云处理和三维自动化。开发新的python地理数据技能和开源…</h3></div><div class="np l"><p class="bd b dl z fp nm fr fs nn fu fw dk translated">learngeodata.eu</p></div></div><div class="ol l"><div class="pn l on oo op ol oq lb nh"/></div></div></a></div><p id="f9c3" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">如果你刚接触媒体，你可以通过下面的链接来支持我的工作:</p><div class="ne nf gp gr ng nh"><a href="https://medium.com/@florentpoux/membership" rel="noopener follow" target="_blank"><div class="ni ab fo"><div class="nj ab nk cl cj nl"><h2 class="bd jd gy z fp nm fr fs nn fu fw jc bi translated">通过我的推荐链接加入Medium-Florent Poux博士</h2><div class="no l"><h3 class="bd b gy z fp nm fr fs nn fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="np l"><p class="bd b dl z fp nm fr fs nn fu fw dk translated">medium.com</p></div></div><div class="ol l"><div class="po l on oo op ol oq lb nh"/></div></div></a></div></div></div>    
</body>
</html>