<html>
<head>
<title>Object-Oriented Programming (OOP) in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的面向对象编程(OOP)</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/object-oriented-programming-oop-in-python-56b1f3229c0f?source=collection_archive---------15-----------------------#2021-07-19">https://towardsdatascience.com/object-oriented-programming-oop-in-python-56b1f3229c0f?source=collection_archive---------15-----------------------#2021-07-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="8969" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">编程；编排</h2><div class=""/><div class=""><h2 id="97eb" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">揭开类、对象、继承等等的神秘面纱</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/d86cd1b62cbf3fe00659ca231ccef962.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jcFRMD3bvm2zvGUH1oMGCw.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">来源:<a class="ae lh" href="http://Undraw.co" rel="noopener ugc nofollow" target="_blank">Undraw.co</a></p></figure><h1 id="9623" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">OOP是什么？</h1><p id="aad6" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">面向对象编程是一种通过将相关的属性和行为分组到单个对象中来组织程序的方法。OOP的基本构建模块是<strong class="mc jd">对象</strong>和<strong class="mc jd">类</strong>。</p><p id="248d" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">一个<strong class="mc jd">类</strong>是一个创建对象的代码模板，我们可以把它想象成一个蓝图。它描述了某种类型的每个对象可能具有的状态和行为。例如，如果我们说“每个雇员都有名字和薪水，并且可以加薪”，那么我们就定义了一个类！</p><p id="998a" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated"><strong class="mc jd">对象</strong>是存储关于某个实体的状态和行为的信息的数据结构，并且是一个类的实例。例如，一个代表雇员的对象可以有一些相关的属性，比如薪水和职位，以及加薪等行为。</p><blockquote class="nb"><p id="62fc" class="nc nd it bd ne nf ng nh ni nj nk mv dk translated">对象=状态+行为</p></blockquote><p id="a47a" class="pw-post-body-paragraph ma mb it mc b md nl kd mf mg nm kg mi mj nn ml mm mn no mp mq mr np mt mu mv im bi translated">关于对象状态的信息包含在<strong class="mc jd">属性</strong>中，行为信息包含在<strong class="mc jd">方法</strong>中。此外，对象属性或状态由变量表示，如数字、字符串或元组。而对象方法或行为由函数来表示。</p><p id="9358" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">OOP的显著特征是状态和行为捆绑在一起。这意味着，例如，我们不是将雇员数据与雇员行为分开考虑，而是将它们视为一个代表雇员的单元。这被称为<strong class="mc jd">封装</strong>，是面向对象编程的核心原则之一。</p><h1 id="93e8" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">定义类别</h1><p id="374d" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">如前所述，类是创建对象的蓝图。现在，让我们把我们的第一个蓝图变成现实。</p><pre class="ks kt ku kv gt nq nr ns nt aw nu bi"><span id="07fc" class="nv lj it nr b gy nw nx l ny nz">class Employee:<br/>   pass</span></pre><p id="55c7" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated"><code class="fe oa ob oc nr b">Employee</code>类现在没有太多的功能。我们将从添加所有<code class="fe oa ob oc nr b">Employee</code>对象应该具有的一些属性开始。为了简单起见，我们只添加姓名和薪水属性。</p><h2 id="38d8" class="nv lj it bd lk od oe dn lo of og dp ls mj oh oi lu mn oj ok lw mr ol om ly iz bi translated">将属性分配给类</h2><p id="91df" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">所有<code class="fe oa ob oc nr b">Employee</code>对象必须具有的属性在一个名为<code class="fe oa ob oc nr b">.__init__()</code>的方法中定义，或者在<strong class="mc jd">构造器方法</strong>中定义。每次创建一个新的<code class="fe oa ob oc nr b">Employee</code>对象时，构造函数方法都会被自动调用。</p><p id="25a8" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">让我们用一个创建<code class="fe oa ob oc nr b">.name</code>和<code class="fe oa ob oc nr b">.salary</code>属性的<code class="fe oa ob oc nr b">.__init__()</code>方法来更新<code class="fe oa ob oc nr b">Employee</code>类:</p><pre class="ks kt ku kv gt nq nr ns nt aw nu bi"><span id="2835" class="nv lj it nr b gy nw nx l ny nz">class <!-- -->Employee<!-- -->:<br/>    def __init__(self, name, salary=0):<br/>        self.name = name<br/>        self.salary = salary</span></pre><p id="b1e8" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">注意<code class="fe oa ob oc nr b">self</code>在任何方法定义中都被用作第一个参数，包括我们的构造函数方法。另外，<code class="fe oa ob oc nr b">self.name = name</code>创建了一个名为<code class="fe oa ob oc nr b">name</code>的属性，并给它分配了参数<code class="fe oa ob oc nr b">name</code>的值。对于salary属性也是如此，只是我们将默认的salary设置为0。</p><h2 id="f4fc" class="nv lj it bd lk od oe dn lo of og dp ls mj oh oi lu mn oj ok lw mr ol om ly iz bi translated">实例属性与类属性</h2><p id="9284" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">在<code class="fe oa ob oc nr b">.__init__()</code>中创建的属性被称为<strong class="mc jd">实例属性</strong>。实例属性的值特定于类的特定实例。所有的<code class="fe oa ob oc nr b">Employee</code>对象都有一个名字和一份薪水，但是<code class="fe oa ob oc nr b">name</code>和<code class="fe oa ob oc nr b">salary</code>属性的值会根据<code class="fe oa ob oc nr b">Employee</code>实例的不同而不同。</p><p id="492d" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">另一方面，<strong class="mc jd">类属性</strong>是对所有类实例具有相同值的属性。您可以通过在<code class="fe oa ob oc nr b">.__init__()</code>之外给变量名赋值来定义一个类属性，如下所示:</p><pre class="ks kt ku kv gt nq nr ns nt aw nu bi"><span id="331b" class="nv lj it nr b gy nw nx l ny nz">class <!-- -->Employee<!-- -->:<br/>   #Class attribute<br/>   organization = "xxx"</span><span id="908b" class="nv lj it nr b gy on nx l ny nz">    def __init__(self, name, salary=0):<br/>        self.name = name<br/>        self.salary = salary</span></pre><p id="6978" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">总而言之，类属性用于定义每个类实例应该具有相同值的特征，而实例属性用于定义不同实例的不同属性。</p><h1 id="8822" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">将方法分配给类</h1><h2 id="cfa5" class="nv lj it bd lk od oe dn lo of og dp ls mj oh oi lu mn oj ok lw mr ol om ly iz bi translated"><strong class="ak">实例方法</strong></h2><p id="d3a9" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">这些函数是在类内部定义的，只能从该类的实例中调用。就像构造函数方法一样，实例方法的第一个参数总是<code class="fe oa ob oc nr b">self</code>。让我们演示如何通过构建前面的<code class="fe oa ob oc nr b">Employee</code>类示例来编写实例方法。</p><pre class="ks kt ku kv gt nq nr ns nt aw nu bi"><span id="e8ea" class="nv lj it nr b gy nw nx l ny nz">class <!-- -->Employee<!-- -->:<br/>   organization = "xxx"</span><span id="240a" class="nv lj it nr b gy on nx l ny nz">   def __init__(self, name, salary=0):<br/>        self.name = name<br/>        self.salary = salary</span><span id="7946" class="nv lj it nr b gy on nx l ny nz">    #Instance method<br/>    def give_raise(self, amount):<br/>        <!-- -->self.salary += amount<br/>        <!-- -->return f"{self.name} has been given a {amount} raise"</span></pre><p id="380c" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">如您所见，实例方法类似于常规函数，不同之处在于将<code class="fe oa ob oc nr b">self</code>作为第一个参数。</p><h2 id="8fde" class="nv lj it bd lk od oe dn lo of og dp ls mj oh oi lu mn oj ok lw mr ol om ly iz bi translated">类方法</h2><p id="122e" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">类方法是绑定到类的方法，而不是类的对象。它们可以访问类的状态，因为它接受一个类参数，而不是典型的<code class="fe oa ob oc nr b">self</code>，它指向类而不是对象实例。</p><p id="dca5" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">要定义一个类方法，首先要有一个class method装饰器，然后是一个方法定义。唯一的区别是，现在第一个参数不是<code class="fe oa ob oc nr b">self</code>，而是<code class="fe oa ob oc nr b">cls</code>，引用类，就像self参数引用特定的实例一样。然后你把它写成任何其他函数，记住你不能在那个方法中引用任何实例属性。</p><p id="44c4" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">因为类方法只能访问这个<code class="fe oa ob oc nr b">cls</code>参数，所以它不能修改对象实例状态。这需要访问<code class="fe oa ob oc nr b">self</code>。但是，类方法仍然可以修改应用于该类所有实例的类状态。</p><pre class="ks kt ku kv gt nq nr ns nt aw nu bi"><span id="5cea" class="nv lj it nr b gy nw nx l ny nz">class MyClass:</span><span id="71a9" class="nv lj it nr b gy on nx l ny nz">   # instance method <br/>   def method(self):<br/>        return 'instance method called', self<br/><br/>    @classmethod<br/>    def classmethod(cls):<br/>        return 'class method called', cls</span></pre><p id="bb40" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">class方法的思想与instance方法非常相似，唯一的区别是，我们现在不是将实例作为第一个参数传递，而是将类本身作为第一个参数传递。因为我们只向方法传递一个类，所以不涉及实例。这意味着我们根本不需要实例，我们调用类方法就像调用静态函数一样:</p><pre class="ks kt ku kv gt nq nr ns nt aw nu bi"><span id="57ad" class="nv lj it nr b gy nw nx l ny nz">MyClass.classmethod()</span></pre><p id="bb0d" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">然而，如果我们想调用实例方法，我们必须先实例化一个对象，然后调用函数，如下所示:</p><pre class="ks kt ku kv gt nq nr ns nt aw nu bi"><span id="d3d2" class="nv lj it nr b gy nw nx l ny nz">object = MyClass()</span><span id="4980" class="nv lj it nr b gy on nx l ny nz">object.method()</span></pre><p id="dc07" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">如果您不确定实例化一个对象意味着什么，我们将在接下来讨论这个问题。</p><h1 id="0f5b" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">实例化一个对象</h1><p id="fbac" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">从一个类创建一个新对象叫做<strong class="mc jd">实例化</strong>一个对象。我们可以用如下属性实例化新的<code class="fe oa ob oc nr b">Employee</code>对象:</p><pre class="ks kt ku kv gt nq nr ns nt aw nu bi"><span id="0ff9" class="nv lj it nr b gy nw nx l ny nz">e1 = Employee("yyy", 5000)<br/>e2 = Employee("zzz", 8000)</span></pre><p id="4211" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">您可以使用点符号访问属性，如下所示:</p><pre class="ks kt ku kv gt nq nr ns nt aw nu bi"><span id="58cb" class="nv lj it nr b gy nw nx l ny nz"># access first employee's name attribute<br/>e1.name</span><span id="579a" class="nv lj it nr b gy on nx l ny nz"># access second employee's salary attribute<br/>e2.salary</span></pre><h1 id="4cbe" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">类继承</h1><p id="7f58" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">类继承是一个类继承另一个类的属性和方法的机制。新形成的类称为<strong class="mc jd">子类</strong>，子类派生的类称为<strong class="mc jd">父类</strong>。子类拥有所有的父数据。</p><p id="563e" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">父类的属性和方法可以被子类覆盖或扩展。换句话说，子类继承其父类的所有属性和方法，但是它们也可以定义自己的属性和方法。</p><p id="0d93" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">声明一个继承自父类的子类非常简单。</p><pre class="ks kt ku kv gt nq nr ns nt aw nu bi"><span id="444a" class="nv lj it nr b gy nw nx l ny nz">class Manager(Employee):<br/>   pass</span></pre><p id="1739" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">现在，即使我们没有定义构造函数，我们也可以创建一个<code class="fe oa ob oc nr b">Manager</code>对象。</p><pre class="ks kt ku kv gt nq nr ns nt aw nu bi"><span id="ed10" class="nv lj it nr b gy nw nx l ny nz">m1 = Manager("aaa", 13000)</span></pre><h2 id="1635" class="nv lj it bd lk od oe dn lo of og dp ls mj oh oi lu mn oj ok lw mr ol om ly iz bi translated">通过继承定制功能</h2><p id="9994" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">假设我们想给子类添加额外的属性。通过专门为我们的子类定制构造函数并调用父类的构造函数，我们可以很容易地做到这一点。</p><pre class="ks kt ku kv gt nq nr ns nt aw nu bi"><span id="71b2" class="nv lj it nr b gy nw nx l ny nz">class <!-- -->Manager(Employee)<!-- -->:</span><span id="407b" class="nv lj it nr b gy on nx l ny nz">   def __init__(self, name, salary=0, department):<br/>        Employee.__init__(self, name, salary=0)<br/>        self.department = department</span></pre><h1 id="8143" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">最佳实践</h1><p id="68b0" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">在使用类和对象时，有一些准则需要记住。</p><ul class=""><li id="e9c1" class="oo op it mc b md mw mg mx mj oq mn or mr os mv ot ou ov ow bi translated">要命名你的类，使用camel case，这意味着如果你的类名包含几个单词，它们应该没有分隔符，每个单词应该以大写字母开头。</li><li id="766e" class="oo op it mc b md ox mg oy mj oz mn pa mr pb mv ot ou ov ow bi translated">对于方法和属性，情况正好相反——单词应该用下划线隔开，并以小写字母开头。</li><li id="b8a2" class="oo op it mc b md ox mg oy mj oz mn pa mr pb mv ot ou ov ow bi translated">“自我”这个名字是约定俗成的。你实际上可以为一个方法的第一个变量使用任何名字，不管怎样，它总是被当作对象引用。尽管如此，最好还是坚持使用<code class="fe oa ob oc nr b">self</code>。</li><li id="22cf" class="oo op it mc b md ox mg oy mj oz mn pa mr pb mv ot ou ov ow bi translated">不要忘记为你的类编写docstrings，这样你的代码对潜在的合作者和未来的你来说更容易理解。</li></ul><h1 id="5412" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">结论</h1><p id="07f6" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">总之，我们讨论了什么是OOP、类和对象。我们还讨论了实例方法和类方法之间的区别，对于实例属性和类属性也是如此。我们还简要介绍了什么是类继承，以及使用类时的一些最佳实践。</p><p id="b1d8" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">就这样，我们找到了我们的向导。我希望你觉得这篇文章很有见地！如果你有，那么你可能会发现这些也很有趣。一如既往，我很乐意听到您的任何意见或问题。快乐学习！</p><div class="pc pd gp gr pe pf"><a rel="noopener follow" target="_blank" href="/working-with-datetime-in-python-e032b8d2f512"><div class="pg ab fo"><div class="ph ab pi cl cj pj"><h2 class="bd jd gy z fp pk fr fs pl fu fw jc bi translated">在Python中使用日期时间</h2><div class="pm l"><h3 class="bd b gy z fp pk fr fs pl fu fw dk translated">立刻成为日期和时间的主人</h3></div><div class="pn l"><p class="bd b dl z fp pk fr fs pl fu fw dk translated">towardsdatascience.com</p></div></div><div class="po l"><div class="pp l pq pr ps po pt lb pf"/></div></div></a></div><div class="pc pd gp gr pe pf"><a rel="noopener follow" target="_blank" href="/a-machine-learning-approach-to-credit-risk-assessment-ba8eda1cd11f"><div class="pg ab fo"><div class="ph ab pi cl cj pj"><h2 class="bd jd gy z fp pk fr fs pl fu fw jc bi translated">信用风险评估的机器学习方法</h2><div class="pm l"><h3 class="bd b gy z fp pk fr fs pl fu fw dk translated">预测贷款违约及其概率</h3></div><div class="pn l"><p class="bd b dl z fp pk fr fs pl fu fw dk translated">towardsdatascience.com</p></div></div><div class="po l"><div class="pu l pq pr ps po pt lb pf"/></div></div></a></div></div></div>    
</body>
</html>