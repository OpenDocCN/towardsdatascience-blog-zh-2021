<html>
<head>
<title>Avoid Debuggers with Functional Programming</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">避免使用函数式编程的调试器</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/avoid-debuggers-with-functional-programming-43ea379605dd?source=collection_archive---------30-----------------------#2021-03-23">https://towardsdatascience.com/avoid-debuggers-with-functional-programming-43ea379605dd?source=collection_archive---------30-----------------------#2021-03-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="142b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用纯函数和跟踪器调试你的代码</h2></div><p id="c4b2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">作者:<a class="ae le" href="https://www.linkedin.com/in/edkrueger/" rel="noopener ugc nofollow" target="_blank">爱德华·克鲁格</a>和<a class="ae le" href="https://www.linkedin.com/in/dougaf/" rel="noopener ugc nofollow" target="_blank">道格拉斯·富兰克林</a>。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi lf"><img src="../Images/d84269bd5bac686744601006e895c9ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hvBjjIqcStcVesSQqGj4YA.jpeg"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">照片由Fotis Fotopoulos在Unsplash上拍摄</p></figure><h1 id="d6c0" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">介绍</h1><p id="be69" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">我们的目标是有一个纯函数的代码库，我们可以用一个tracer来修饰它。通过将这个装饰器应用到纯函数，我们可以在不使用笨重的调试器的情况下调试代码。这减少了开发人员的痛苦，因为调试器通常是乏味且难以使用的。</p><h1 id="bdea" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">什么是纯函数？</h1><p id="6465" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">严格地说，在一个<strong class="kk iu">函数式编程</strong>范例中，所有函数都是<strong class="kk iu">纯函数</strong>。它们是什么，我们如何编码它们，它们为什么有用？</p><p id="38e4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在此之前，让我们回顾一下数学函数。</p><h1 id="bd6a" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">数学函数</h1><p id="45b5" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">数学函数，如<code class="fe ms mt mu mv b">cos(x),</code>返回单个值。给它一个<code class="fe ms mt mu mv b">x</code>，它返回<code class="fe ms mt mu mv b">x</code>的余弦值。相同的<code class="fe ms mt mu mv b">x</code>值将总是返回相同的结果。</p><p id="0798" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Python函数不同于数学函数。Python函数不仅仅计算值；它可以改变程序的状态。</p><p id="43e2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Python函数可以设置影响不同函数结果的全局变量。例如，一个函数可以改变另一个函数使用的列表。这种突变是该功能的副作用。</p><p id="9c47" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">副作用使得编程和调试更加困难。你不需要仅仅考虑一个特定的功能在做什么；您还必须考虑其他函数之前可能做了什么，这会影响程序的状态。</p><p id="83b1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">纯函数消除了一些意想不到的副作用。</p><h2 id="5fbe" class="mw lw it bd lx mx my dn mb mz na dp mf kr nb nc mh kv nd ne mj kz nf ng ml nh bi translated">纯函数</h2><p id="ac93" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">纯函数是数学函数的计算模拟。这意味着当你传递一个值给一个函数时，它将总是产生相同的结果，没有任何副作用。</p><p id="cc37" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们用一个非纯计数器和一个纯计数器来说明这个概念。这个计数器是迷信的，所以它将跳过13。</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="ni nj l"/></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">带测试的不纯计数器</p></figure><p id="9ee3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于非纯函数——为了测试13的条件跳过，我们必须注意<code class="fe ms mt mu mv b">count .</code>的全局状态。为了检查这种行为，我们必须运行计数器13次，看看它是否工作。每次我们调用<code class="fe ms mt mu mv b">increment_counter()</code>都会有将<code class="fe ms mt mu mv b">count</code>增加1的副作用。因此，我们必须运行<code class="fe ms mt mu mv b">increment_counter()</code> 12次，让它进入一种状态，在这种状态下<code class="fe ms mt mu mv b">count = 13</code>触发我们正在测试的条件行为。</p><p id="4b8d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注意，我们将在本文后面的第20行讨论调试器代码<code class="fe ms mt mu mv b">breakpoint()</code>。</p><p id="4f5d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当我们将计数器实现为一个纯函数时，测试我们的计数器是否跳过13要简单得多。</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="ni nj l"/></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">带测试的纯计数器</p></figure><p id="06b3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于纯计数器，我们需要做的就是检查我们的条件情况，看看计数器是否跳过13。不存在需要留意的全球状态，也不存在需要担心的副作用。</p><p id="53d1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您只使用纯函数编写项目代码，计算将通过嵌套或组合函数调用进行，而不会改变状态或可变数据。这将允许更容易的调试。此外，因为纯函数对于相同的参数有相同的返回值，所以它们非常适合<strong class="kk iu">单元测试。</strong></p><h1 id="5988" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">什么是调试器？他们很差劲吗？</h1><p id="8cd8" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">调试器的目标是在受控条件下运行目标程序，允许程序员跟踪正在进行的操作并监控变化。</p><p id="54a2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面我使用Python调试器pdb运行了非纯计数器代码。第20行上的<code class="fe ms mt mu mv b">breakpoint()</code>触发程序暂停，并向我们显示下一行的代码。我调用<code class="fe ms mt mu mv b">count</code>来查看这个全局变量的状态，并使用<code class="fe ms mt mu mv b">n</code>来运行下一行代码。在这种情况下，我们可以看到每次调用<code class="fe ms mt mu mv b">increment_counter</code>时<code class="fe ms mt mu mv b">count </code>都会增加。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi nk"><img src="../Images/1d82224e72ffe67b815381b88b474e60.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JGbtCcy6OfYe0vJgfdKWYA.png"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">使用调试器检查上述非纯计数器的状态</p></figure><p id="eff2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以看到<code class="fe ms mt mu mv b">count</code>比我们的下一个断言落后了一个，这是意料之中的。此外，我们可以观察到计数从12跳到14。注意计数状态是如何随着每次断言测试而增加的。这看起来像是好的软件设计吗？</p><p id="ef63" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">像这样一行一行地遍历程序是很慢的。使用调试器重新创建一个状态来测试某个行为可能会很痛苦。</p><h2 id="93ac" class="mw lw it bd lx mx my dn mb mz na dp mf kr nb nc mh kv nd ne mj kz nf ng ml nh bi translated">传统的调试器在几个方面都很糟糕。</h2><ul class=""><li id="d5cb" class="nl nm it kk b kl mn ko mo kr nn kv no kz np ld nq nr ns nt bi translated">你花了很多时间试图在本地重现错误，这样你就可以附加你的调试器。</li><li id="d967" class="nl nm it kk b kl nu ko nv kr nw kv nx kz ny ld nq nr ns nt bi translated">当您反复缩小原因范围时，您必须多次重现问题。</li><li id="120b" class="nl nm it kk b kl nu ko nv kr nw kv nx kz ny ld nq nr ns nt bi translated">人工调试环境将创建一个与错误最初出现时不同的状态。</li><li id="9364" class="nl nm it kk b kl nu ko nv kr nw kv nx kz ny ld nq nr ns nt bi translated">调试器不跟踪数据或控制流，也不记得过去发生了什么。</li></ul><p id="fe0a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">开发人员有时会发现自己在为调试器编写代码来解决特定的问题。应该为手边的应用程序编写代码，而不是为正在其上使用的调试器编写代码！</p><p id="c95d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">各地的软件开发人员都应该对此感到不安。有更好的调试方法。如果您没有使用调试器，那么您可能通过添加日志记录代码并重新运行程序来进行调试。</p><p id="d8a7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这类似于我们的解决方案，使用带有跟踪器的纯函数，以获得更优雅和可重用的调试方法。</p><p id="1371" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">纯函数结合跟踪器对于生产中的日志记录非常有用，因为您可以确切地看到什么输入值产生了错误。对于纯函数，如果我们知道我们的输入和输出，我们就知道修复代码中的错误所需要的一切。</p><h1 id="797f" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">使用追踪器调试你的软件</h1><p id="4069" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">应用跟踪装饰器，而不是使用调试器。</p><h2 id="a380" class="mw lw it bd lx mx my dn mb mz na dp mf kr nb nc mh kv nd ne mj kz nf ng ml nh bi translated">为什么要追踪？</h2><p id="c6e2" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated"><strong class="kk iu">跟踪</strong>是模拟程序的执行，一行一行地遍历程序，显示变量是如何变化的。有经验的程序员使用跟踪来调试程序，通常作为调试器的替代品。</p><blockquote class="nz"><p id="556e" class="oa ob it bd oc od oe of og oh oi ld dk translated"><em class="oj">“干杯，爱！骑兵来了！”—示踪器</em></p></blockquote><p id="3332" class="pw-post-body-paragraph ki kj it kk b kl ok ju kn ko ol jx kq kr om kt ku kv on kx ky kz oo lb lc ld im bi translated">当您知道一个纯函数的输入和输出时，您就知道了调试所需的一切。</p><h1 id="6c5b" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">跟踪装饰者:@tracefunc</h1><p id="b05d" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">这是作为装饰器编写的跟踪程序，我们将把它应用于我们感兴趣的函数。</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="ni nj l"/></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">tracer.py</p></figure><p id="e413" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个装饰器打印出传递给<code class="fe ms mt mu mv b">tracefunc()</code>的函数的轨迹。在第10行，<code class="fe ms mt mu mv b">result </code>存储了<code class="fe ms mt mu mv b">func(*args, **kwargs).</code>的值，之后生成一个打印语句。此语句报告<code class="fe ms mt mu mv b">func.__name__</code>，args和kwargs。</p><p id="b0f4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个装饰器将允许我们看到我们装饰的函数的名字和它的参数，kwargs和result。</p><p id="a467" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">通过用<code class="fe ms mt mu mv b">tracefunc </code>修饰我们的纯函数，我们生成了调试程序所需的所有日志信息。</p><h1 id="6bb4" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">对纯函数应用tracefunc</h1><p id="423a" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">让我们用我们的tracer来装饰这个纯计数器，看看输出。</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="ni nj l"/></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">用tracefunc装饰的纯计数器</p></figure><p id="a3e2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们在第3行使用<code class="fe ms mt mu mv b">@</code>语法将<code class="fe ms mt mu mv b">tracefunc </code>应用到<code class="fe ms mt mu mv b">increment_counter</code>。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi op"><img src="../Images/cd4585f7a5e96ddf01df5dd972b21b65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eoVAontLZUJ-O65JPBeH4A.png"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">增量_计数器_纯的跟踪</p></figure><p id="3e9f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，当我们运行这个文件时，我们在第11行的测试生成了上面的输出。我们可以看到<code class="fe ms mt mu mv b">func.__name__</code>，12作为自变量，14作为结果。</p><p id="5e06" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">通过对这个纯函数应用追踪器，我们生成了我们想要测试的行为的清晰日志。专柜确实很迷信。</p><h1 id="f746" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">结论</h1><p id="7e00" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">通过用追踪器装饰纯函数，您获得了一个优雅的、可重用的模式来调试您的程序。装饰是增强功能行为的有力工具。有了好的代码(纯函数)和跟踪器，您可以避免使用调试器和管理状态来调试程序的痛苦。</p><p id="d893" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">请随意将<code class="fe ms mt mu mv b">tracefunc</code>复制到您的代码库中，或者您可以尝试编写自己的跟踪装饰器！</p></div></div>    
</body>
</html>