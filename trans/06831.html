<html>
<head>
<title>Big Sales Mart Regression Revisited: Enter the tidymodels</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">大型销售市场回归再探:进入潮流模型</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/big-sales-mart-regression-revisited-enter-the-tidymodels-a6a432be58d4?source=collection_archive---------22-----------------------#2021-06-20">https://towardsdatascience.com/big-sales-mart-regression-revisited-enter-the-tidymodels-a6a432be58d4?source=collection_archive---------22-----------------------#2021-06-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="a5bb" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用Tidymodels的介绍性机器学习回归项目</h2></div><p id="8200" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Tidymodels是一个元包，很像tidyverse，它将一组有用的tidy包加载到您的会话中。不同之处在于它加载了一系列在机器学习模型开发过程中使用的包。</p><p id="5694" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们使用它们时，我将介绍每一个，并提供实际的使用案例。Tidymodels由Max Kuhn开发，他是RStudio的成员，开发了一种生成机器学习模型的整洁友好的方法。库恩之前最著名的作品是《脱颖而出》,是《下雨了》<strong class="kh ir">Ca</strong>tegorical<strong class="kh ir">Re</strong>gression<strong class="kh ir">T</strong>raining。Caret本身已经是一个非常强大的包，可以与Python的Scikit-Learn相媲美。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi lb"><img src="../Images/1d4775907d165da30ed0a6c9a2212843.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*neaTU-hZ0ZP8toEq"/></div></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">照片由<a class="ae lr" href="https://unsplash.com/@claybanks?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">粘土堤</a>在<a class="ae lr" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="6a5d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是，每个模型类型都有其特定的包、输入要求、规格和训练方法。Tidymodels试图通过简化工作流程和创建生成机器学习模型所需的统一语法来解决这个问题。</p><p id="7ceb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">大销售市场数据集可通过分析Vidhya和他们向成员提供的免费项目之一获得。</p><p id="7103" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae lr" href="https://courses.analyticsvidhya.com/courses/big-mart-sales-prediction-using-r" rel="noopener ugc nofollow" target="_blank">https://courses . analyticsvidhya . com/courses/big-mart-sales-prediction-using-r</a></p><p id="b137" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该项目的目的是开发和评估一系列回归模型，根据一些输入变量预测商品经销店销售额。</p><p id="c432" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我亲自完成这个项目时，许多方面都是用base R编写的，并不像它应该的那样直观，也没有利用tidyverse包提供的易用性。因此，我看到了一个真正的机会，将这个项目转化为“整洁”的思维方式，并展示tidymodels。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><p id="6199" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">探索性数据分析</strong></p><pre class="lc ld le lf gt lz ma mb mc aw md bi"><span id="1fc2" class="me mf iq ma b gy mg mh l mi mj">#Load Packages<br/>library(tidymodels)<br/>library(magrittr) #Tidy pipes<br/>library(patchwork) #Visualisation grids<br/>library(stringr) #String Manipulation<br/>library(forcats) #Working with Factors<br/>library(corrr) #Develop tidy Correlation Plots<br/>library(vip) #Most important feature visualisations</span></pre><p id="f947" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">加载一系列包，最重要的是tidymodels元包。与tidyverse非常相似，它实现了一系列较小的包，这些包有不同的用途，并在模型开发过程中发挥作用，还有dplyr、ggplot2、purrr、tibble等。随着模型开发的进展，我们将介绍每个包。</p><pre class="lc ld le lf gt lz ma mb mc aw md bi"><span id="bb6f" class="me mf iq ma b gy mg mh l mi mj">#Load Data<br/>train = read_csv("train.csv")<br/>skim(train)</span></pre><p id="1c42" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">数据被加载到项目中，我们使用skimr包中方便的skim函数检查结构。有12个变量(7个字符和5个数字)和8，523行数据。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi mk"><img src="../Images/1e90444bea8cc346b4c65ab75c6043be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NzDy9xUhQ6S1BN2CxNzjWA.png"/></div></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">skim输出的屏幕截图(图片由作者提供)</p></figure><p id="e4ea" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从这里开始，我们需要用一些丢失值的变量来整理数据集。我们通过可视化数据集中的每个变量来进一步研究。</p><p id="a3ad" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我编写这个函数是为了使我的数据科学项目的初始EDA步骤非常简单，并通过purrr的map2()创建一个图列表，并传递给patchwork的wrap_plots()以生成一个图网格。</p><pre class="lc ld le lf gt lz ma mb mc aw md bi"><span id="e06e" class="me mf iq ma b gy mg mh l mi mj">viz_by_dtype &lt;- function (x,y) {<br/>  title &lt;- str_replace_all(y,"_"," ") %&gt;% <br/>           str_to_title()<br/>  if ("factor" %in% class(x)) {<br/>    ggplot(combi, aes(x, fill = x)) +<br/>      geom_bar() +<br/>      theme(legend.position = "none",<br/>            axis.text.x = element_text(angle = 45, hjust = 1),<br/>            axis.text = element_text(size = 8)) +<br/>      theme_minimal() +<br/>      scale_fill_viridis_d()+<br/>      labs(title = title, y = "", x = "")<br/>  }<br/>  else if ("numeric" %in% class(x)) {<br/>    ggplot(combi, aes(x)) +<br/>      geom_histogram()  +<br/>      theme_minimal() +<br/>      scale_fill_viridis_d()+<br/>      labs(title = title, y = "", x = "")<br/>  } <br/>  else if ("integer" %in% class(x)) {<br/>    ggplot(combi, aes(x)) +<br/>      geom_histogram() +<br/>      theme_minimal() +<br/>      scale_fill_viridis_d()+<br/>      labs(title = title, y = "", x = "")<br/>  }<br/>  else if ("character" %in% class(x)) {<br/>    ggplot(combi, aes(x, fill = x)) +<br/>      geom_bar() +<br/>      theme_minimal() +<br/>      scale_fill_viridis_d()+<br/>      theme(legend.position = "none",<br/>            axis.text.x = element_text(angle = 45, hjust = 1),<br/>            axis.text = element_text(size = 8)) +<br/>      labs(title = title, y  ="", x= "")<br/>  }<br/>}<br/>variable_list &lt;- colnames(train) %&gt;% as.list()<br/>variable_plot &lt;- map2(train, variable_list, viz_by_dtype) %&gt;%<br/>  wrap_plots(               <br/>    ncol = 3,<br/>    nrow = 4,<br/>    heights = 150,<br/>    widths = 150<br/>  )</span></pre><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi ml"><img src="../Images/bd1bcac978c7386a90609d5bd5310d85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QZrDqeaZtOHOpvcPb-Av4Q.png"/></div></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">通过数据类型适当的可视化简化EDA(图片由作者提供)</p></figure><p id="7e38" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">由此我们注意到:</p><ul class=""><li id="8fe2" class="mm mn iq kh b ki kj kl km ko mo ks mp kw mq la mr ms mt mu bi translated">项目标识符有1559个单独的值，为了简化模型，我们将删除这个变量</li><li id="8c56" class="mm mn iq kh b ki mv kl mw ko mx ks my kw mz la mr ms mt mu bi translated">项目重量没有明显的分布</li><li id="90c9" class="mm mn iq kh b ki mv kl mw ko mx ks my kw mz la mr ms mt mu bi translated">项目脂肪含量标签不一致</li><li id="83ad" class="mm mn iq kh b ki mv kl mw ko mx ks my kw mz la mr ms mt mu bi translated">项目可见性是右偏的</li><li id="dfe7" class="mm mn iq kh b ki mv kl mw ko mx ks my kw mz la mr ms mt mu bi translated">项目类型有多种标签</li><li id="dc3b" class="mm mn iq kh b ki mv kl mw ko mx ks my kw mz la mr ms mt mu bi translated">物料MRP有四个主要组</li><li id="b7d9" class="mm mn iq kh b ki mv kl mw ko mx ks my kw mz la mr ms mt mu bi translated">插座标识符有10个独特的标签</li><li id="c8d9" class="mm mn iq kh b ki mv kl mw ko mx ks my kw mz la mr ms mt mu bi translated">奥特莱斯建立的年份是多种多样的，许多商店从90年代中期开始</li><li id="ceb6" class="mm mn iq kh b ki mv kl mw ko mx ks my kw mz la mr ms mt mu bi translated">插座尺寸标签不一致</li><li id="03fd" class="mm mn iq kh b ki mv kl mw ko mx ks my kw mz la mr ms mt mu bi translated">插座位置类型有三个标签</li><li id="ee25" class="mm mn iq kh b ki mv kl mw ko mx ks my kw mz la mr ms mt mu bi translated">出口类型有四个标签</li><li id="8608" class="mm mn iq kh b ki mv kl mw ko mx ks my kw mz la mr ms mt mu bi translated">商品出口销售是右偏的</li></ul><p id="2dea" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，让我们研究一下Item_Outlet_Sales和其他数字变量之间是否存在有趣的关系。使用GGally的ggscatmat()，我们生成了一个简洁的双变量分析，沿对角线进行了高斯平滑，并为每个变量对生成了皮尔逊相关性。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi na"><img src="../Images/dc41f2d27d58f6d7bfc12e70c7baa233.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BmAxcbGgAAw2PE85sP4lNQ.png"/></div></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">连续变量的二元分析(图片由作者提供)</p></figure><p id="d379" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们发现，把数字变量和目标变量对应起来，有三种不同的观察结果。</p><ul class=""><li id="e550" class="mm mn iq kh b ki kj kl km ko mo ks mp kw mq la mr ms mt mu bi translated">物品销售在物品重量的整个范围内分布良好，没有任何明显的模式</li><li id="a1b3" class="mm mn iq kh b ki mv kl mw ko mx ks my kw mz la mr ms mt mu bi translated">Item_Visibility与Item_Outlet_Sales没有关系</li><li id="9a96" class="mm mn iq kh b ki mv kl mw ko mx ks my kw mz la mr ms mt mu bi translated">Item_MRP有四个不同的级别，并与Item_Outlet_Sales适度相关，我们将在稍后的特性工程中利用这一点。</li></ul><p id="6b7c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">数据角力</strong></p><p id="db7b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如前所述，我们需要修正一些变量输出。</p><pre class="lc ld le lf gt lz ma mb mc aw md bi"><span id="7ad4" class="me mf iq ma b gy mg mh l mi mj">#Correct mislabeled Item_Fat_Content</span><span id="4ea1" class="me mf iq ma b gy nb mh l mi mj">train %&lt;&gt;% mutate(Item_Fat_Content = if_else(Item_Fat_Content %in% c("reg", "Regular"), "Regular", "Low Fat"))</span><span id="f35a" class="me mf iq ma b gy nb mh l mi mj">#Outlet Size is missing a label</span><span id="949e" class="me mf iq ma b gy nb mh l mi mj">train %&lt;&gt;% mutate(Outlet_Size = if_else(is.na(Outlet_Size),"Small",Outlet_Size))</span></pre><p id="707b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">经销店规模是根据与小型经销店具有非常相似的Item_Outlet_Sales分布的NA标签估算的。</p><p id="d576" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">模型开发:引入tidymodels </strong></p><p id="42cf" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">到目前为止，我们已经使用了一系列tidyverse包来争论和可视化数据，现在让我们来看看使用tidymodels元包开发机器学习管道的过程。</p><p id="7e24" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">数据拆分— rsamples </strong></p><p id="80d2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">很像sci-kit学习测试训练分割模块，rsamples initial_split完成类似的操作。在下面的示例中，使用intial_split函数生成mc_split对象mart_split，传递我们的训练数据帧，将比例设置为75%，并按Item_Outlet_Sales变量分层。</p><p id="f36c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这有效地创建了两个数据帧的列表，由training()或test()调用。我们将使用测试数据框架来判断我们的模型在看不见的数据上表现如何。</p><pre class="lc ld le lf gt lz ma mb mc aw md bi"><span id="6c4e" class="me mf iq ma b gy mg mh l mi mj">set.seed(55)<br/>mart_split &lt;- initial_split(train, prop = 0.75, strata = Item_Outlet_Sales</span><span id="17c9" class="me mf iq ma b gy nb mh l mi mj">mart_train &lt;- training(mart_split)<br/>mart_test &lt;- testing(mart_split)</span></pre><p id="ac84" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">特征工程—配方</strong></p><p id="e83b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">recipes包提供了大量用于处理变量的函数，并使它们对机器学习友好。配方包的三个主要功能是</p><ul class=""><li id="6f14" class="mm mn iq kh b ki kj kl km ko mo ks mp kw mq la mr ms mt mu bi translated">recipe() —定义一系列连续的预处理步骤(或者收集并列出我的配料以及我将如何准备它们)</li><li id="1967" class="mm mn iq kh b ki mv kl mw ko mx ks my kw mz la mr ms mt mu bi translated">prep() —计算所需的统计变换(或者准备我的烹饪原料)</li><li id="fccc" class="mm mn iq kh b ki mv kl mw ko mx ks my kw mz la mr ms mt mu bi translated">bake() —将预处理步骤应用于数据集(或烹饪我准备好的菜肴)</li></ul><p id="7e3f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">recipe函数的构造类似于其他模型outcome ~ predictor，在这里，我们通过使用波浪符号(~)指出我们想要使用所有其他变量作为模型的预测变量。).</p><p id="f32c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们已经使用配方生成了一个新的变量Price_Per_Unit，它是Item_MRP和Item_Weight的商，然后通过应用Box-Cox变换并求Item_Visibility的平方根来寻求降低Price_Per_Unit的偏斜度。<br/>在生成虚拟变量之前，名义/字符变量被转换为二进制列，表示该行是否属于某个特定的组(1 =真，0 =假)，我们可以使用reshape2::dcast()，然而，配方的强大之处在于，它能够通过管道传输一条简单的指令，使用step_dummy为所有名义变量创建一个虚拟变量。为了简单起见，我决定不为Item_Identifier创建虚拟变量，此外，这样会创建5000多列，可能会使模型过于复杂。</p><pre class="lc ld le lf gt lz ma mb mc aw md bi"><span id="89dc" class="me mf iq ma b gy mg mh l mi mj">mart_recipe &lt;- <br/>  training(mart_split) %&gt;% <br/>  recipe(Item_Outlet_Sales ~ .) %&gt;% <br/>  step_rm(Item_Identifier) %&gt;%<br/>  step_impute_bag(Item_Weight) %&gt;% <br/>  step_impute_knn(Item_Visibility) %&gt;% <br/>  step_mutate(Price_Per_Unit = Item_MRP/Item_Weight) %&gt;% <br/>  step_sqrt(Item_Visibility) %&gt;%<br/>  step_log(Price_Per_Unit, offset = 1) %&gt;% <br/>  step_discretize(Item_MRP,num_breaks = 4) %&gt;%<br/>  step_normalize(all_numeric_predictors()) %&gt;%<br/>  step_dummy(all_nominal())</span><span id="0c58" class="me mf iq ma b gy nb mh l mi mj">mart_recipe_prepped &lt;- prep(mart_recipe)</span></pre><p id="6ffd" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，配方对象通过prep()函数传递，也生成一个配方对象，但是已经进行了转换，因此数据已经被“准备”了。</p><p id="33e9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">将prep(ed) recipe对象传递给bake执行转换，因为已经创建了许多虚拟变量，所以我们现在有54列。</p><pre class="lc ld le lf gt lz ma mb mc aw md bi"><span id="133c" class="me mf iq ma b gy mg mh l mi mj">mart_train &lt;- bake(mart_recipe_prepped, new_data = mart_train)<br/>dim(mart_train)<br/>[1] 6391 54</span></pre><p id="7e88" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">由于准备好的配方实际上是一个转换管道，我们可以在测试数据集上调用这些相同的转换。</p><pre class="lc ld le lf gt lz ma mb mc aw md bi"><span id="1e23" class="me mf iq ma b gy mg mh l mi mj">mart_test &lt;- mart_recipe_prepped %&gt;% <br/>             bake(testing(mart_split))<br/>dim(mart_test)<br/>[1] 2132 54</span></pre><p id="e81c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">瞧，完全处理的训练和测试数据集。</p><p id="95f1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">相关图— corrr </strong></p><p id="1143" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">相关图对于理解哪些预测因子与结果变量相关非常有趣和重要。要创建相关图，需要将数据转换为相关数据框(cor_df)。<br/>我们采用mart_train，选择所有数字变量并传递给corr::correlate，corr::correlate生成cor_df，给出变量对之间的pearson或rho值。</p><p id="3514" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">cor_df对象被传递给rplot()，就像对待其他ggplot对象一样，我们可以通过使用theme()和配色方案来定制它的外观。</p><pre class="lc ld le lf gt lz ma mb mc aw md bi"><span id="a033" class="me mf iq ma b gy mg mh l mi mj">corr_df &lt;- mart_train %&gt;% select(is.numeric) %&gt;% <br/>              correlate() %&gt;%<br/>              rearrange() %&gt;% <br/>              shave()<br/>rplot(corr_df,) +<br/> theme_minimal() +<br/> theme(axis.text.x = element_text(angle = 90)) +<br/> scale_colour_viridis_c()</span></pre><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi nc"><img src="../Images/c1e428a8cde33838693728feb0334383.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bmz1vsp6_DP_BaYQbmrmmQ.png"/></div></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">预处理(烘焙)数据的相关图(图片由作者提供)</p></figure><p id="81c9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">给聪明人的一句话，你可能不打算“通常”使用这么多变量的相关图，正如我写的，如果没有更大的监视器，这很难阅读。但是，请注意创建这样一个情节的代码是多么优雅。</p><p id="cfae" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这种情况下，人们可能会决定继续完成主成分分析，并根据重要性减少变量的数量。我将把那个留给另一个时间。</p><p id="d486" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">模型开发—防风草</strong></p><p id="c5e8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">RStudio的团队，尤其是Max Kuhn，有一种非常邪恶的幽默感。在命名这个包时，他们不能称之为caret2，所以他们选择了parsnip。</p><p id="e474" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">由于我们试图创建一个预测Item_Outlet_Sales的回归模型，为了便于演示，我们将开发两个模型，并使用均方根误差(RMSE)作为评估指标。</p><ul class=""><li id="fc7f" class="mm mn iq kh b ki kj kl km ko mo ks mp kw mq la mr ms mt mu bi translated">线性回归</li><li id="f88c" class="mm mn iq kh b ki mv kl mw ko mx ks my kw mz la mr ms mt mu bi translated">随机森林</li></ul><p id="7443" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用parsnip生成模型是非常优雅的。从我们要评估的第一个模型开始，线性回归，我们声明一个模型规范，然后是用于拟合模型的计算引擎。在这个实例中，parsnip模型将使用stats:lm()函数。</p><pre class="lc ld le lf gt lz ma mb mc aw md bi"><span id="7251" class="me mf iq ma b gy mg mh l mi mj">lm_model &lt;- linear_reg() %&gt;% <br/>            set_engine("lm")</span><span id="c306" class="me mf iq ma b gy nb mh l mi mj">lm_mart_fit &lt;- <br/>  lm_model %&gt;%<br/>  fit(Item_Outlet_Sales ~ ., data = mart_train)</span></pre><p id="ae5d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">调用parsnip模型对象将生成类似于调用stats:lm()对象时的输出，即每个输入变量的公式和系数列表。</p><pre class="lc ld le lf gt lz ma mb mc aw md bi"><span id="56a2" class="me mf iq ma b gy mg mh l mi mj">lm_mart_res &lt;- <br/>  predict(lm_mart_fit, new_data = mart_test) %&gt;% <br/>  bind_cols(mart_test %&gt;% select(Item_Outlet_Sales))</span><span id="a9d2" class="me mf iq ma b gy nb mh l mi mj">lm_mart_res %&gt;%<br/>  ggplot(aes(x = Item_Outlet_Sales, y = .pred)) +<br/>  geom_abline() +<br/>  geom_point(alpha = 0.5) +<br/>  theme_minimal() +<br/>  labs(x = "Item Outlet Sales", y = "Predicted Item Outlet Sales")</span></pre><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi nd"><img src="../Images/e109128ab944250c6cef7c2694a85a27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G7R4UjlyaK8UTglX-kl96w.png"/></div></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">mart_test的线性回归模型预测与期望值的散点图(图片由作者提供)</p></figure><p id="59b2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">衡量绩效——衡量标准</strong></p><p id="b291" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在mart_test上使用我们的回归模型的输出，我们可以评估模型使用标尺包的准确性。标尺包为评估模型性能提供了一个有效的整洁的方式。</p><pre class="lc ld le lf gt lz ma mb mc aw md bi"><span id="dfec" class="me mf iq ma b gy mg mh l mi mj">metrics &lt;- metric_set(rmse, rsq, mae)</span><span id="6e5e" class="me mf iq ma b gy nb mh l mi mj">metrics(lm_mart_res, truth = Item_Outlet_Sales, estimate = .pred)</span></pre><p id="a647" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为指定的误差度量创建一个包装函数。在我们的例子中，我们规定了均方根误差(RMSE)、R和平均绝对误差(MAE)。</p><p id="798e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">调用指标，指定tible、实际和预测度量，生成一个包含每个错误度量和输出的tible。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/f54279e10984a8f1a46520839d52d802.png" data-original-src="https://miro.medium.com/v2/resize:fit:828/format:webp/1*0y8yWrFaZaXsYkILE_yRgA.png"/></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">指标包装函数的输出(作者图片)</p></figure><p id="8733" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">将模型的误差与测试集的预测误差进行比较，我们发现RMSE(测试)= 1141.8，RMSE(模型)= 1144.3。差别很小，我们可以说该模型很好地适用于测试数据。</p><p id="8690" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是，回归模型预测了许多值的负值，因此不适用于此上下文，因为我们不能有负销售额。</p><p id="8675" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">生成ML管道—工作流程</strong></p><p id="3e03" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如上所述，为了生成基本的线性模型，我们采取了许多精细的步骤，workflows包提供了一种优雅的方法来处理这些步骤。我们现在将通过生成一个随机森林模型来演示工作流有多有用。</p><p id="4e3c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">随机森林模型</p><p id="9817" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">随机森林算法是决策树的集成方法，通常通过bagging方法训练。RF算法在随机特征子集中搜索最佳特征。这导致更大的树多样性，用更高的偏差换取更低的方差和更好的整体模型。</p><pre class="lc ld le lf gt lz ma mb mc aw md bi"><span id="5efe" class="me mf iq ma b gy mg mh l mi mj">rf_workflow &lt;- <br/>  workflow() %&gt;% <br/>  add_recipe(mart_recipe) %&gt;% #Pre-processing Steps<br/>  add_model(rand_forest(mode = "regression") %&gt;% #Specify Model<br/>              set_engine("ranger"))</span></pre><p id="341d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在四行代码中，我们生成了一个ML工作流，现在可以用作模型对象。</p><pre class="lc ld le lf gt lz ma mb mc aw md bi"><span id="7186" class="me mf iq ma b gy mg mh l mi mj">rf_mart_res &lt;- <br/>  rf_workflow %&gt;% <br/>  fit(training(mart_split)) %&gt;% <br/>  predict(new_data = testing(mart_split)) %&gt;%<br/>  bind_cols(mart_test %&gt;% select(Item_Outlet_Sales))</span><span id="ea2e" class="me mf iq ma b gy nb mh l mi mj">rf_mart_res %&gt;% <br/>  ggplot(aes(x= Item_Outlet_Sales, y = .pred)) +<br/>   geom_abline(lty = 2)+<br/>   geom_point(alpha = 0.5)+<br/>   theme_minimal()+<br/>   labs(x="Item Outlet Sales", y= "Predicted Item Outlet Sales", title = "pRandom Forest Regression")</span></pre><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi nd"><img src="../Images/83594ac2da2177978eccd04509b21554.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RocR92m_EzwVI7G0RGE7Ig.png"/></div></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">来自未调整随机森林模型的预测与实际商品销售散点图(图片由作者提供)</p></figure><p id="73a4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里我们发现RMSE(训练)= 1110.446，RMSE(测试)= 1126.359。随机森林模型确实有过度拟合的趋势，我们可以通过训练超参数来进一步改进模型，这也可以使用工作流和dials包来完成。</p><p id="d45c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">表盘—精炼模型开发</strong></p><p id="a001" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通过调整超参数来调整模型是模型开发的一个重要方面。</p><p id="dfc5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">进入dials包和函数grid_regular()，该函数用需要调优的超参数的每种可能组合建立一个tibble。dials::grid_regular的工作方式类似于dplyr::expand_grid。</p><p id="c3e4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面，我们重新建立一个随机森林模型规范，这次将trees设置为500，mtry和min_n设置为tune()。Mtry是每次分裂时采样的预测值数量，min_n是分裂节点的最小观测值数量。</p><p id="3706" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如前面一样，我们通过管道传输模型和配方规范，从而生成一个调整工作流。</p><p id="a0e5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们创建了一个4重交叉验证对象(vfold_cv)。</p><p id="b075" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，我们通过初始化tune_grid()(网格搜索)生成一个tune_results对象，它遍历rf_grid中的每个组合，tune_wf使用4重交叉验证。</p><pre class="lc ld le lf gt lz ma mb mc aw md bi"><span id="1104" class="me mf iq ma b gy mg mh l mi mj">set.seed(256)<br/>rf_mod &lt;- <br/>  rand_forest(trees = 500,<br/>              mtry = tune(),<br/>              min_n = tune()) %&gt;% <br/>  set_engine("ranger", importance = "impurity", num.threads = 12) %&gt;% <br/>  set_mode("regression")</span><span id="f21c" class="me mf iq ma b gy nb mh l mi mj">#Establish Model Flow<br/>tune_wf &lt;- workflow() %&gt;%<br/>  add_recipe(mart_recipe) %&gt;%<br/>  add_model(rf_mod)</span><span id="48a8" class="me mf iq ma b gy nb mh l mi mj">#Generate grid to perform grid search for hyperparameter optimisation<br/>  <br/>rf_grid &lt;- grid_regular(mtry(range = c(6,10)), <br/>                        min_n(range = c(14,20)), <br/>                        levels = c(10,9))</span><span id="e5e1" class="me mf iq ma b gy nb mh l mi mj"># 4-fold Cross Validation Stratified by Item_Outlet_Sales<br/>folds &lt;- vfold_cv(train, v = 4, strata = Item_Outlet_Sales)</span><span id="efa4" class="me mf iq ma b gy nb mh l mi mj">#Train and evaluate all combinations of hyperparameters specified in rf_grid</span><span id="c368" class="me mf iq ma b gy nb mh l mi mj">doParallel::registerDoParallel(cores = 12)<br/>rf_grid_search &lt;- tune_grid(<br/>  tune_wf,<br/>  resamples = folds,<br/>  grid = rf_grid)</span></pre><p id="31da" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请注意，我们已经利用并行处理来使用更多的工作站计算能力，因为网格搜索可能需要大量计算。</p><p id="0cd5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以可视化这种计算的结果，并直观地看到哪个超参数组合提供最低的RMSE。</p><pre class="lc ld le lf gt lz ma mb mc aw md bi"><span id="aaf8" class="me mf iq ma b gy mg mh l mi mj">rf_grid_search %&gt;%<br/>  collect_metrics() %&gt;% <br/>  filter(.metric == "rmse") %&gt;%<br/>  select(mean, min_n, mtry) %&gt;%<br/>  filter(mtry &gt; 4) %&gt;% <br/>  ggplot(aes(min_n, mean, color = as_factor(mtry))) +<br/>  geom_point()+<br/>  geom_line()+<br/>  scale_color_viridis_d() +<br/>  theme_minimal()+<br/>  scale_x_continuous(breaks = pretty_breaks())+<br/>  theme(legend.position = "bottom") +<br/>  labs(x = "Minimum Number of Observations to Split Node", y = "RMSE", title = "Grid Search Results for Random Forest", color = "Number of Predictors Sampled at Each Split")</span></pre><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi nd"><img src="../Images/484a99e01fde07082eac4cae9076b375.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GA4vpQw1HaUqiKgMjxW_Lg.png"/></div></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">随机森林的网格搜索结果(图片由作者提供)</p></figure><p id="0988" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">调用show_best()提供了关于网格搜索结果的更多细节</p><pre class="lc ld le lf gt lz ma mb mc aw md bi"><span id="a69e" class="me mf iq ma b gy mg mh l mi mj">rf_grid_search %&gt;% show_best()</span></pre><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi nf"><img src="../Images/d406b4d2bdc11c3ec42f518aa5c4c717.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kzpRzKvW_KPic0hEk7Nsjg.png"/></div></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">show_best()的输出打印前5个结果(图片由作者提供)</p></figure><p id="8c7a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以使用网格搜索的结果来更新随机森林模型规范。</p><pre class="lc ld le lf gt lz ma mb mc aw md bi"><span id="b6f4" class="me mf iq ma b gy mg mh l mi mj">rf_best_rmse &lt;- select_best(rf_grid_search, "rmse")<br/>final_rf &lt;- finalize_model(<br/>  rf_mod,<br/>  rf_best_rmse<br/>)</span><span id="1dd7" class="me mf iq ma b gy nb mh l mi mj">final_rf</span></pre><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi ng"><img src="../Images/b40946a2473482e92ba25ba4db26b248.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SItmm_gO0L83kiudoxBefA.png"/></div></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">网格搜索后的最终随机森林模型规格(图片由作者提供)</p></figure><p id="8cde" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用vip包，我们可以适应final_rf并突出显示前10个最重要的功能。</p><pre class="lc ld le lf gt lz ma mb mc aw md bi"><span id="fedf" class="me mf iq ma b gy mg mh l mi mj">final_rf %&gt;%<br/>  fit(Item_Outlet_Sales ~., data = bake(prep(mart_recipe),training(mart_split))) %&gt;% <br/>  vip(geom=c("col"), num_features = 10) +<br/>  theme_minimal()</span></pre><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi nd"><img src="../Images/6509822f8eaaefcd76695bb14732e0d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZfGAJOohibSmfuNaXlklKg.png"/></div></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">rf_final模型的十个最重要的特性(图片由作者提供)</p></figure><p id="7548" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这真正突出了特征工程的重要性，其中一些是在我们清理数据或通过配方生成时创建的。</p><p id="a8f6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后让我们评估一下final_rf</p><pre class="lc ld le lf gt lz ma mb mc aw md bi"><span id="940f" class="me mf iq ma b gy mg mh l mi mj">final_wf &lt;- <br/>  workflow() %&gt;% <br/>  add_recipe(mart_recipe) %&gt;% <br/>  add_model(final_rf)</span><span id="d8b4" class="me mf iq ma b gy nb mh l mi mj">final_rf_res &lt;- <br/>  fit(final_wf, training(mart_split)) %&gt;% <br/>  predict(new_data = testing(mart_split)) %&gt;% <br/>  bind_cols(mart_test %&gt;% select(Item_Outlet_Sales))</span><span id="387d" class="me mf iq ma b gy nb mh l mi mj">final_rf_res %&gt;% ggplot(aes(x= Item_Outlet_Sales, y = .pred)) +<br/>                  geom_abline(lty = 2)+<br/>                  geom_point(alpha = 0.5)+<br/>                  theme_minimal()+<br/>                  labs(x="Item Outlet Sales", y= "Predicted Item Outlet Sales", title = "Tuned Random Forest Regression")</span></pre><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi nd"><img src="../Images/62b54ddfc0664e130b11a20679daf646.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CrOTE9zFmtpHLxXYnvP8eA.png"/></div></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">rf_final的实际和预测产品销售散点图(图片由作者提供)</p></figure><pre class="lc ld le lf gt lz ma mb mc aw md bi"><span id="492d" class="me mf iq ma b gy mg mh l mi mj">metrics(final_rf_res, truth = Item_Outlet_Sales, estimate = .pred)</span></pre><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi nh"><img src="../Images/0cd516f3d1e8412604c5d4187d7e46d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eilu2nih_5BfPUFFyPaVFw.png"/></div></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">度量函数的误差度量(图片由作者提供)</p></figure><p id="124a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">将RMSE(测试)= 1120.365与RMSE(训练)= 1106.629进行比较，我们将过拟合略微降低了2个RMSE单位，并在超参数调整后产生了略微更好的模型。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><p id="2a28" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">结论</strong></p><p id="5c8f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该项目试图举例说明tidymodels元包的易用性，通过使每个步骤可管道化，拟合两种模型类型并根据测试集评估它们的性能，可以使用它来生成机器学习工作流。如果您想更进一步，训练XGBoost模型是非常容易的，为了简洁起见，我没有包括这一点。</p><p id="e13e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">将tidymodels与sci-kit learn进行比较的一个关键要点是，tidymodels过程中的每一步都需要tibble数据帧，并且不需要将数据帧转换为矩阵。此外，鉴于一切都通过tibbles工作，正如我所演示的，这使得模型性能和超参数训练的可视化诊断更容易理解。</p><p id="317f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我强烈推荐那些有兴趣了解更多关于tidymodels的人去寻找神奇的朱莉娅·斯利格@<a class="ae lr" href="https://juliasilge.com/" rel="noopener ugc nofollow" target="_blank">https://juliasilge.com/</a>，以及她与马克斯·库恩在备受期待的Tidy Modeling with R上的合作(你可以在这里预览一下<a class="ae lr" href="https://www.tmwr.org/" rel="noopener ugc nofollow" target="_blank">https://www.tmwr.org/</a></p></div></div>    
</body>
</html>