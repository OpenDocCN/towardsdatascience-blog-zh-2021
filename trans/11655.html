<html>
<head>
<title>Don’t assume NumPy.vectorize is faster</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">不要认为NumPy.vectorize更快</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/dont-assume-numpy-vectorize-is-faster-dd7e455dba2?source=collection_archive---------12-----------------------#2021-11-18">https://towardsdatascience.com/dont-assume-numpy-vectorize-is-faster-dd7e455dba2?source=collection_archive---------12-----------------------#2021-11-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="2b1a" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">用不同的向量化函数解决生日悖论</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/281b4dcf8fef11aad7feaf11ed246832.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*VFbjFM9rPc-TiPYK"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@adigold1?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Adi Goldstein </a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="3c36" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">循环是您在编程中学习的第一个构造之一，但是对数组中的每个元素执行操作时，循环可能是一种过于冗长的方式。NumPy提供了一个叫做<code class="fe ls lt lu lv b">vectorize</code>的便捷方法，用<strong class="ky ir">更少的代码行</strong>对数组执行操作。许多人认为这个函数也能提高性能。在本文中，我将向您展示如何使用<code class="fe ls lt lu lv b">vectorize</code>(这部分很简单)，以及它是否能提高性能。我将通过使用两个非常不同的Python函数解决一个常见的统计学问题(生日悖论)来实现这一点。</p><p id="1604" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我进入实现之前，解决争议是很重要的。同样，一些人观察到<code class="fe ls lt lu lv b">vectorize</code>比普通的<code class="fe ls lt lu lv b">for</code>循环要快，但是甚至NumPy <a class="ae kv" href="https://numpy.org/doc/stable/reference/generated/numpy.vectorize.html" rel="noopener ugc nofollow" target="_blank">文档</a>也声明:</p><blockquote class="lw"><p id="2918" class="lx ly iq bd lz ma mb mc md me mf lr dk translated">“<code class="fe ls lt lu lv b"><strong class="ak">vectorize</strong></code>功能主要是为了方便，而不是为了性能。该实现本质上是一个for循环。</p></blockquote><p id="1d46" class="pw-post-body-paragraph kw kx iq ky b kz mg jr lb lc mh ju le lf mi lh li lj mj ll lm ln mk lp lq lr ij bi translated">文档是否正确？我将向你介绍我的实验。在本文的最后，我将发布Jupyter笔记本，其中包含为本文执行的所有代码和测试，因此您可以复制我的发现。在讨论发现之前，我先解释一下这个例子中用到的问题:生日悖论。</p></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><h1 id="062d" class="ms mt iq bd mu mv mw mx my mz na nb nc jw nd jx ne jz nf ka ng kc nh kd ni nj bi translated">生日悖论解释</h1><p id="111a" class="pw-post-body-paragraph kw kx iq ky b kz nk jr lb lc nl ju le lf nm lh li lj nn ll lm ln no lp lq lr ij bi translated">在一群人中，两个或两个以上的人同一天生日的概率是多少？当小组由两个人组成时，它是相当小的(大约百分之一的四分之一)，如果小组由366人组成，它就变成100%(忽略闰年)。2到366人之间的概率是什么样子的？这就是生日悖论，有时被称为生日问题。</p><p id="f85a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">悖论检验了“两个或更多”人同一天生日的概率。这当然意味着三个人可能有同一天生日，如下图所示。或者四个人…</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nq"><img src="../Images/44cf10b052b7a537373660c62aee6e54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ln4dc2sO_AKplEWjS33VGA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">同一天生日的三个人——作者图片</p></figure><p id="3721" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">或者两个<em class="np">集合</em>的人可能有相同的生日，而集合本身彼此不同，如下所示。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nr"><img src="../Images/bfbb5565c0035822af891fcedf788556.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uUAN5ciS-5tFdPpnThbDYQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">两组相同的生日——作者图片</p></figure><p id="41de" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">两个<em class="np"/><strong class="ky ir"><em class="np">或更多</em> </strong>的人可能有很多相同的生日，因此更容易计算出<strong class="ky ir">的补数</strong>，或<em class="np">没有人</em>有相同生日的概率。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/5250c19582198b1e628242243191cdf9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1278/format:webp/1*a6mcigY0NJ4M_V9HbCTSOQ.png"/></div></figure><p id="1d20" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我不打算深入讨论得出数学解的细节，因为《走向数据科学》的撰稿人Cassie Kozyrkov已经在本文<a class="ae kv" rel="noopener" target="_blank" href="/using-the-birthday-paradox-to-teach-probability-fundamentals-c08bbcb351d1">中介绍过了。我将直接跳到解决方案(数学方程和相应的Python)。</a></p><h2 id="9a7a" class="nt mt iq bd mu nu nv dn my nw nx dp nc lf ny nz ne lj oa ob ng ln oc od ni oe bi translated">解决方案1:科学的方法</h2><p id="a9de" class="pw-post-body-paragraph kw kx iq ky b kz nk jr lb lc nl ju le lf nm lh li lj nn ll lm ln no lp lq lr ij bi translated">第一种解决方案使用一种不寻常的符号(下标在<em class="np"> P </em>的两侧)来表示排列。读作“365选<em class="np"> k </em>”</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi of"><img src="../Images/5896cb7002338d891111f861cc973cab.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/1*c842b4V-Ohw9pfWY9ICfDg.png"/></div></figure><p id="ada9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">好消息是Python <code class="fe ls lt lu lv b">scipy</code>库有一个排列函数，可以产生答案！Python代码远没有上面的等式那么可怕。还有什么比一行函数更简单的呢？</p><pre class="kg kh ki kj gt og lv oh oi aw oj bi"><span id="7e39" class="nt mt iq lv b gy ok ol l om on">import scipy.special as spp</span><span id="c51a" class="nt mt iq lv b gy oo ol l om on">def bday_scipy(k):<br/>    return 1 - spp.perm(365,k) / 365**k</span></pre><h2 id="a1f4" class="nt mt iq bd mu nu nv dn my nw nx dp nc lf ny nz ne lj oa ob ng ln oc od ni oe bi translated">解决方案2:“基本”方法</h2><p id="3b07" class="pw-post-body-paragraph kw kx iq ky b kz nk jr lb lc nl ju le lf nm lh li lj nn ll lm ln no lp lq lr ij bi translated">第二种解决方案是一种基本的暴力方法。它由随着组大小(<em class="np"> k </em>)的增加而重复相乘的分数组成。缩小的分数表明，随着群体规模的增加，没有人同一天生日的概率降低(因此两个或更多人同一天生日的机会增加)。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi op"><img src="../Images/a6b403734b8422f15c0c429d5702ed7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1206/format:webp/1*mUIW7Lw-lzPyLhrTOqPCoQ.png"/></div></figure><p id="5064" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个解决方案的Python表示比第一个解决方案要长，但是很容易理解。</p><pre class="kg kh ki kj gt og lv oh oi aw oj bi"><span id="4b27" class="nt mt iq lv b gy ok ol l om on">def bday_basic(k):<br/>    p = 1.<br/>    for idx in range(1,k):<br/>        p *= (365-idx) / 365<br/>    return 1-p</span></pre><h2 id="dd3f" class="nt mt iq bd mu nu nv dn my nw nx dp nc lf ny nz ne lj oa ob ng ln oc od ni oe bi translated">比较两种解决方案</h2><p id="b35a" class="pw-post-body-paragraph kw kx iq ky b kz nk jr lb lc nl ju le lf nm lh li lj nn ll lm ln no lp lq lr ij bi translated">我上面提出的两个方程在数学上是相同的。这些术语被不同地分组以突出不同的模式，但是它们是相同的。如果这是杰拉尔德·兰博教授的课，我会用数学方法证明。相反，我将用图表证明它。</p><p id="0108" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下图显示两个函数产生相同的结果。我还比较了这些图表中的值，发现差异在零和<code class="fe ls lt lu lv b">2.22e-16</code>(本质上是零)之间。换句话说，这两个函数<strong class="ky ir">产生</strong> <strong class="ky ir">同样的结果</strong>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/b67e22e5c927bfc207c22714cba68f21.png" data-original-src="https://miro.medium.com/v2/resize:fit:1054/format:webp/1*8hvusGLoat0pykdhh4wQ6w.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">同一个问题的两种解决方案会产生相同的结果——作者图片</p></figure><blockquote class="lw"><p id="9165" class="lx ly iq bd lz ma or os ot ou ov lr dk translated">这两种方法在数学上是相同的，但是有不同的Python实现。这正是我想要的，以便比较性能。</p></blockquote></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><h1 id="9ac5" class="ms mt iq bd mu mv mw mx my mz na nb nc jw nd jx ne jz nf ka ng kc nh kd ni nj bi translated">用NumPy向量化生日悖论</h1><p id="db76" class="pw-post-body-paragraph kw kx iq ky b kz nk jr lb lc nl ju le lf nm lh li lj nn ll lm ln no lp lq lr ij bi translated">同样，我对同一个问题有两种不同的方法:</p><pre class="kg kh ki kj gt og lv oh oi aw oj bi"><span id="6e06" class="nt mt iq lv b gy ok ol l om on">import scipy.special as spp</span><span id="3de9" class="nt mt iq lv b gy oo ol l om on">def bday_scipy(k):<br/>    return 1 - spp.perm(365,k) / 365**k</span><span id="508d" class="nt mt iq lv b gy oo ol l om on">def bday_basic(k):<br/>    p = 1.<br/>    for idx in range(1,k):<br/>        p *= (365-idx) / 365<br/>    return 1-p</span></pre><p id="6985" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在使用上述函数的矢量化版本之前，我必须创建矢量化版本。这很简单:</p><pre class="kg kh ki kj gt og lv oh oi aw oj bi"><span id="5073" class="nt mt iq lv b gy ok ol l om on">import numpy as np<br/>scipy_vect = np.vectorize(bday_scipy)<br/>basic_vect = np.vectorize(bday_basic)</span></pre><p id="c01c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我有了两个“普通的”Python函数和它们的向量等价物。这些向量可以应用于NumPy数组<em class="np">而无需循环</em>。下面的代码创建一个表示组大小的整数数组，并计算该组中两个或更多人同一天生日的概率。这里没有<code class="fe ls lt lu lv b">for</code>循环！</p><pre class="kg kh ki kj gt og lv oh oi aw oj bi"><span id="9a55" class="nt mt iq lv b gy ok ol l om on">group_size = np.arange(2,60,dtype='uint')</span><span id="8cab" class="nt mt iq lv b gy oo ol l om on"># calculate probability for the entire range of group sizes<br/>scipy_probability = scipy_vect(group_size)</span></pre><p id="645f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">和</p><pre class="kg kh ki kj gt og lv oh oi aw oj bi"><span id="0daa" class="nt mt iq lv b gy ok ol l om on">basic_probability = basic_vect(group_size)</span></pre><p id="6bcb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是<code class="fe ls lt lu lv b">basic_probability</code>的样子:</p><pre class="kg kh ki kj gt og lv oh oi aw oj bi"><span id="014c" class="nt mt iq lv b gy ok ol l om on">array([0.00273973, 0.00820417, 0.01635591, 0.02713557, 0.04046248,<br/>       0.0562357 , 0.07433529, 0.09462383, 0.11694818, 0.14114138,<br/>       0.16702479, 0.19441028, 0.22310251, 0.25290132, 0.28360401,<br/>       0.31500767, 0.34691142, 0.37911853, 0.41143838, 0.44368834,<br/>       0.47569531, 0.50729723, 0.53834426, 0.5686997 , 0.59824082,<br/>       0.62685928, 0.65446147, 0.68096854, 0.70631624, 0.73045463,<br/>       0.75334753, 0.77497185, 0.79531686, 0.81438324, 0.83218211,<br/>       0.84873401, 0.86406782, 0.87821966, 0.89123181, 0.90315161,<br/>       0.91403047, 0.92392286, 0.93288537, 0.9409759 , 0.94825284,<br/>       0.9547744 , 0.96059797, 0.96577961, 0.97037358, 0.97443199,<br/>       0.97800451, 0.98113811, 0.98387696, 0.98626229, 0.98833235,<br/>       0.99012246, 0.99166498, 0.99298945])</span></pre><p id="bf93" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从编码的角度来看，NumPy <code class="fe ls lt lu lv b">vectorize</code>很方便，因为它非常简洁。但是它的表现如何呢？矢量化的函数比非矢量化的快吗？或者NumPy文档是否正确？</p></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><h1 id="86d9" class="ms mt iq bd mu mv mw mx my mz na nb nc jw nd jx ne jz nf ka ng kc nh kd ni nj bi translated">比较向量化和非向量化函数的性能</h1><p id="9f08" class="pw-post-body-paragraph kw kx iq ky b kz nk jr lb lc nl ju le lf nm lh li lj nn ll lm ln no lp lq lr ij bi translated">对于本文前面定义的生日悖论，我有两个解决方案:</p><ul class=""><li id="b3e6" class="ow ox iq ky b kz la lc ld lf oy lj oz ln pa lr pb pc pd pe bi translated"><code class="fe ls lt lu lv b">bday_scipy</code></li><li id="f446" class="ow ox iq ky b kz pf lc pg lf ph lj pi ln pj lr pb pc pd pe bi translated"><code class="fe ls lt lu lv b">bday_basic</code></li></ul><p id="5f4f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我还创建了每个的NumPy矢量化版本:</p><ul class=""><li id="0857" class="ow ox iq ky b kz la lc ld lf oy lj oz ln pa lr pb pc pd pe bi translated"><code class="fe ls lt lu lv b">scipy_vect</code></li><li id="7f51" class="ow ox iq ky b kz pf lc pg lf ph lj pi ln pj lr pb pc pd pe bi translated"><code class="fe ls lt lu lv b">basic_vect</code></li></ul><p id="d797" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">他们如何比较？什么更快？在上一节中，我向您展示了如何使用矢量化函数。您已经知道如何将“普通”(非矢量化)Python函数放入一个<code class="fe ls lt lu lv b">for</code>循环中:</p><pre class="kg kh ki kj gt og lv oh oi aw oj bi"><span id="5c6d" class="nt mt iq lv b gy ok ol l om on">probability = []<br/>for k in group_size:<br/>    probability.append(bday_scipy(k))</span></pre><p id="cce8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">和</p><pre class="kg kh ki kj gt og lv oh oi aw oj bi"><span id="2846" class="nt mt iq lv b gy ok ol l om on">probability = []<br/>for k in group_size:<br/>    probability.append(bday_basic(k))</span></pre><p id="d14e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了比较性能，我将<code class="fe ls lt lu lv b">group_size</code>定义为一个数组长度为100，000的NumPy随机整数数组，并使用Python的<code class="fe ls lt lu lv b">timeit</code>多次执行四种方法中的每一种，以绘制平均性能图。</p><p id="8601" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请参考下图了解结果。我发现<code class="fe ls lt lu lv b">scipy</code>矢量化函数比非矢量化函数稍微快<strong class="ky ir">一点</strong>，如下图中橄榄色条所示。重点是轻微的。在下图所示的试验中，矢量化函数的速度提高了4%。它并不像其他人有时声称的那样快2倍或100倍。</p><p id="379b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我发现<code class="fe ls lt lu lv b">basic</code>矢量化的函数比非矢量化的函数稍慢<strong class="ky ir"/>，如上图中紫色条所示。实际上慢了6%!同样，这些差异是轻微的(不是两倍慢)。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pk"><img src="../Images/e1b9be4bbfcd7235a13d9eee1cafd12e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xEP8xzE9ptTJPzFTVd_iPQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">性能结果—按作者分类的图片</p></figure><p id="0118" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我多次执行这些测试，矢量化和非矢量化函数之间的差异并不大，但是测试之间的关系都与上图相似。</p><p id="fcd0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请注意，紫色条的高度都是橄榄色条的一半。换句话说，两个版本的“基本”解决方案都比两个版本的“科学”解决方案快一倍！</p><h1 id="4a7d" class="ms mt iq bd mu mv pl mx my mz pm nb nc jw pn jx ne jz po ka ng kc pp kd ni nj bi translated">结论</h1><p id="e4cd" class="pw-post-body-paragraph kw kx iq ky b kz nk jr lb lc nl ju le lf nm lh li lj nn ll lm ln no lp lq lr ij bi translated">这个精心设计的实验的结果留给我一个相当沉闷的结论，即NumPy文档是正确的。</p><blockquote class="lw"><p id="a7a5" class="lx ly iq bd lz ma mb mc md me mf lr dk translated">“<code class="fe ls lt lu lv b">vectorize</code>功能主要是为了方便，而不是为了性能。该实现本质上是一个for循环。</p></blockquote><p id="016a" class="pw-post-body-paragraph kw kx iq ky b kz mg jr lb lc mh ju le lf mi lh li lj mj ll lm ln mk lp lq lr ij bi translated">我同意Chelsea Troy在<a class="ae kv" href="https://chelseatroy.com/2018/11/07/code-mechanic-numpy-vectorization/" rel="noopener ugc nofollow" target="_blank">这篇非常透彻的博客</a>中的观点，NumPy本身使用了一些针对C语言高度优化的循环结构，但是NumPy <code class="fe ls lt lu lv b">vectorize</code>函数显然没有<strong class="ky ir">而不是</strong>使用并行化。</p><p id="0bd6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这两种算法之间的性能差异要比函数的矢量化版本和非矢量化版本之间的性能差异大得多。“基本”解决方案每次完成的时间不到“科学”解决方案的一半。这突出了选择正确的算法可能对性能有最大的影响。</p><p id="908c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您关心性能，请投入时间寻找合适的算法。如果你关心代码的优雅，使用<code class="fe ls lt lu lv b">numpy.vectorize</code>。我个人喜欢两样都做！</p><p id="c764" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如所承诺的，这里是本文使用的所有代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pq pr l"/></div></figure></div></div>    
</body>
</html>