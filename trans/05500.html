<html>
<head>
<title>How to set up a production-grade flask application using Application Factory Pattern and Celery</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用Application Factory模式和Celery建立生产级的烧瓶应用程序</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-set-up-a-production-grade-flask-application-using-application-factory-pattern-and-celery-90281349fb7a?source=collection_archive---------3-----------------------#2021-05-16">https://towardsdatascience.com/how-to-set-up-a-production-grade-flask-application-using-application-factory-pattern-and-celery-90281349fb7a?source=collection_archive---------3-----------------------#2021-05-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="5796" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用flask blueprints、application factory模式和Celery构建和配置生产级flask应用程序的高适应性和可伸缩性工作流。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi kf"><img src="../Images/22a703aa6083d17b006f47d3019a2567.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*uAseTz8wDJhMcwMzXW7MHA.jpeg"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">照片由<a class="ae kr" href="https://unsplash.com/@will0629?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">威尔·波拉达</a>在<a class="ae kr" href="https://unsplash.com/s/photos/workflow?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="4684" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><strong class="ku ir">免责声明</strong></p><p id="16ff" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">这不是初学者教程。假设读者已经熟悉flask web应用程序框架、其常用的库和celery。</p></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><h1 id="eeab" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">基础</h1><ol class=""><li id="fe84" class="mn mo iq ku b kv mp ky mq lb mr lf ms lj mt ln mu mv mw mx bi translated">为您的项目创建一个github存储库，并使用README和python对其进行初始化。gitignore文件。</li><li id="a9ad" class="mn mo iq ku b kv my ky mz lb na lf nb lj nc ln mu mv mw mx bi translated">将git repo克隆到您的本地机器上</li></ol><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="5caf" class="ni lw iq ne b gy nj nk l nl nm">$ git clone &lt;repo link&gt;</span></pre><p id="1865" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">3.创建一个虚拟环境，并安装flask和您需要的任何其他库</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="b27e" class="ni lw iq ne b gy nj nk l nl nm">$ python -m venv env<br/>$ env/Scripts/activate<br/>$ pip install flask python-dotenv flask-mail celery redis<br/>$ pip freeze &gt; requirements.txt</span></pre></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><h1 id="4a76" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">项目结构:烧瓶蓝图</h1><h2 id="4182" class="ni lw iq bd lx nn no dn mb np nq dp mf lb nr ns mh lf nt nu mj lj nv nw ml nx bi translated">什么是蓝图？</h2><p id="3100" class="pw-post-body-paragraph ks kt iq ku b kv mp jr kx ky mq ju la lb ny ld le lf nz lh li lj oa ll lm ln ij bi translated">Flask是一个非常灵活的web开发框架。作为开发人员，您可以完全自主地决定如何构建您的web应用程序。如果您正在构建一个小项目，将所有代码放在一个模块中没有坏处。然而，大型项目普遍接受的模式是使用Flask Blueprints将您的项目分成多个包。</p><p id="9569" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">一个模块是一个单独的<code class="fe ob oc od ne b">.py</code> python文件。包是包含一个或多个模块以及一个<code class="fe ob oc od ne b">__init__.py</code>文件的文件夹。<code class="fe ob oc od ne b">__init__.py</code>文件是区分包和标准文件夹的地方:如果它存在于一个文件夹中，那么这个文件夹就是一个包；如果不存在，则该文件夹只是一个普通的存储文件夹。</p><p id="7700" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">蓝图是封装了应用程序中某个特定功能的包。您应该将使用蓝图构建的flask应用程序视为几个关键的功能块，它们协同工作来交付完整的web应用程序。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="of og di oh bf oi"><div class="gh gi oe"><img src="../Images/908ef10dd078179bb8ffda257fa35207.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7Ur8uACX_tmBADSfYvOmRA.png"/></div></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">flask应用程序由蓝图(作者自己的)组成</p></figure><p id="6676" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">在开始编写项目代码之前，最好先考虑一下可以将应用程序分成哪些蓝图。我个人的做法是用两个蓝图，<code class="fe ob oc od ne b">auth</code>和<code class="fe ob oc od ne b">main</code>。<code class="fe ob oc od ne b">auth</code>蓝图处理所有与用户相关的功能——注册、登录、注销、密码重置和账户确认。<code class="fe ob oc od ne b">main</code>蓝图处理应用程序特有的功能和特性。您还可以添加第三个蓝图<code class="fe ob oc od ne b">api</code>，用于处理对web应用程序资源的编程访问。</p><p id="b9bf" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">您应该为具有两个蓝图的项目创建以下项目结构:</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="caa2" class="ni lw iq ne b gy nj nk l nl nm">|-application.py<br/>|-config.py<br/>|-.env<br/>|-.gitignore<br/>|-readme.md<br/>|-requirements.txt<br/>|-celery_worker.py<br/>|-Dockerfile<br/>|-docker-compose.yml<br/>|-pytest.ini<br/>|-env/<br/>|-tests/<br/>    |-conftest.py<br/>    |-test_main.py<br/>    |-test_auth.py<br/>    |-test_models.py<br/>|-app/<br/>    |-__init__.py<br/>    |-models.py<br/>    |-forms.py<br/>    |-tasks.py<br/>    |-static/<br/>    |-templates/<br/>        |-base.html<br/>        |-400.html<br/>        |-403.html<br/>        |-404.html<br/>        |-405.html<br/>        |-500.html<br/>    |-auth/<br/>        |-__init__.py<br/>        |-views.py<br/>        |-forms.py<br/>        |-templates/auth<br/>            |-register.html<br/>    |-main/<br/>        |-__init__.py<br/>        |-views.py<br/>        |-forms.py<br/>        |-templates/mai<br/>            |-index.html</span></pre><p id="75dc" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">下表给出了各种组件的概要:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="of og di oh bf oi"><div class="gh gi oj"><img src="../Images/4d55f296bbeb7effe2da0d1a6e9f2236.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T9p3YFUvHKYoAh2BpvCVbg.png"/></div></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">flask应用程序中的公共文件(作者自己的)</p></figure><p id="94c3" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">当您使用蓝图时，处理请求的视图函数不会都在一个文件中；它们将被拆分到不同的文件中。每个蓝图都有自己的<code class="fe ob oc od ne b">views.py</code>文件，包含属于它的代码。这些路径没有一个<code class="fe ob oc od ne b">@app</code>装饰器，而是用它们所属的蓝图名称来装饰，例如<code class="fe ob oc od ne b">@auth_blueprint.route('/login')</code>。</p><p id="ae9e" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">一旦你将你的项目组织成蓝图，而不是服务器将请求传递给flask应用实例来处理，请求被推送到适当的蓝图，蓝图处理它们。为了让flask应用程序实例知道项目中的蓝图和属于它的路线，蓝图必须向flask应用程序实例“注册”。</p></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><h1 id="f552" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">结构管理</h1><p id="f981" class="pw-post-body-paragraph ks kt iq ku b kv mp jr kx ky mq ju la lb ny ld le lf nz lh li lj oa ll lm ln ij bi translated">配置flask应用程序是指定关键参数值的过程，这些参数用于控制flask应用程序实例及其扩展的行为。关于这个主题的官方flask文档提供了一个很好的列表，列出了所有内置的flask变量，可以根据需要进行配置。</p><h2 id="c3eb" class="ni lw iq bd lx nn no dn mb np nq dp mf lb nr ns mh lf nt nu mj lj nv nw ml nx bi translated">配置方法</h2><p id="1705" class="pw-post-body-paragraph ks kt iq ku b kv mp jr kx ky mq ju la lb ny ld le lf nz lh li lj oa ll lm ln ij bi translated">Flask提供了4种配置flask应用程序的主要方式:环境变量、flask应用程序实例的config属性、CFG文件和对象。</p><p id="f7bb" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><strong class="ku ir">*环境变量</strong></p><p id="ca10" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">当您想要设置一两个配置参数时，使用环境变量是最简单的配置方法。要设置参数，您可以运行<code class="fe ob oc od ne b">set</code>(对于Windows)或<code class="fe ob oc od ne b">export</code>(对于Linux)命令。Flask建议您使用此方法设置<code class="fe ob oc od ne b">FLASK_APP</code>和<code class="fe ob oc od ne b">FLASK_ENV</code>环境变量，以便能够使用<code class="fe ob oc od ne b">flask run</code>命令在调试模式下启动flask development server。</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="3d23" class="ni lw iq ne b gy nj nk l nl nm">$set FLASK_APP = app.py<br/>$set FLASK_ENV = development</span></pre><p id="bd40" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">使用环境变量来配置关键参数很简单，但是当您有许多参数或者当您想要使用具有不同配置设置的多个环境时，就不能很好地扩展。</p><p id="4f02" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><strong class="ku ir">* flask app实例的配置属性</strong></p><p id="7ca8" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">flask应用程序实例公开了一个类似字典的对象，称为“config ”,通过点符号访问，它允许您将配置变量设置为所需的值，就像您设置字典键的值一样。当使用这个对象时，所有的配置代码都在flask对象实例化后立即编写。这是因为配置设置需要在flask应用程序实例化时可用，以便它可以在运行之前正确配置。</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="2cb3" class="ni lw iq ne b gy nj nk l nl nm">app = Flask(__name__)<br/>app.config['SECRET_KEY'] = 'hard to guess<br/>app.config<strong class="ne ir">[</strong>'TESTING'<strong class="ne ir">]</strong> = True<strong class="ne ir"><br/></strong>app.config['MAIL_SERVER'] = 'smtp.googlemail.com'<br/>app.config['MAIL_PORT'] = 465<br/>app.config['MAIL_USE_TLS'] = True<br/>app.config['MAIL_USERNAME'] = os.environ.get('MAIL_USERNAME')<br/>app.config['MAIL_PASSWORD'] = os.environ.get('MAIL_PASSWORD')</span></pre><p id="2840" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">尽管在实例化flask对象的脚本中包含所有配置代码并不灵活。当flask对象被实例化时，它会立即根据这些设置进行配置，并且在实例化之后，无法更改flask实例的配置。</p><p id="0460" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">当您希望基于您正在做的事情拥有不同的应用程序“版本”时，这就成了一个问题。也就是说，当您处于开发阶段时，您需要一个配置用于开发的flask应用程序；当您想要进行测试时，您需要一个配置用于测试的flask应用程序；当您准备好进行部署时，您需要一个配置用于生产的flask应用程序。</p><p id="bd1a" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">也许您在开发过程中使用了SQLite，但在生产中想要使用postgreSQL数据库。或者，您希望使用不同的SQLite数据库文件进行开发、测试和生产，以便将事情分开，使它们不会相互干扰。能够为不同的环境配置不同的flask应用程序是实现这一点的唯一方法。</p><p id="642b" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><strong class="ku ir">*一个CFG文件</strong></p><p id="4a10" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">不要把所有的配置代码都放在实例化flask对象的脚本中，可以把它写在一个单独的配置文件中，然后告诉config对象使用它公开的<code class="fe ob oc od ne b">from_pyfile()</code>方法从那个文件中提取配置设置。此方法采用的参数是文件的路径，它可以是相对于项目根目录的路径，也可以是文件的绝对路径。这种方法扩展性很好，但是不允许为不同的环境指定不同的配置设置。</p><p id="b0e5" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">名为<strong class="ku ir"> config.cfg </strong>的配置文件的内容示例如下:</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="fc57" class="ni lw iq ne b gy nj nk l nl nm">DEBUG = <strong class="ne ir">False</strong><br/>SECRET_KEY = 'a bad secret key'</span></pre><p id="d33e" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">使用存储在根项目目录中的<strong class="ku ir"> config.cfg </strong>文件配置flask应用程序:</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="50b1" class="ni lw iq ne b gy nj nk l nl nm">app = Flask(__name__)<br/>app.config.from_pyfile('config.cfg')</span></pre><p id="f4a1" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><strong class="ku ir">*一个物体</strong></p><p id="5870" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">配置flask应用程序的方法是在一组python类中定义配置设置，该应用程序既具有良好的可伸缩性，又允许您为不同的环境指定不同的配置设置。</p><p id="b696" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">在位于项目根目录<strong class="ku ir">、</strong>的名为<strong class="ku ir"> settings.py </strong>或<strong class="ku ir"> config.py </strong>的python脚本文件中，您定义了4个类:</p><ul class=""><li id="dadd" class="mn mo iq ku b kv kw ky kz lb ok lf ol lj om ln on mv mw mx bi translated">class Config(object)，它是基本配置类，包含适用于所有环境的配置设置。其他3个类都继承了这个类。</li><li id="e745" class="mn mo iq ku b kv my ky mz lb na lf nb lj nc ln on mv mw mx bi translated">类DevelopmentConfig(Config)，它包含开发环境的配置设置。</li><li id="e831" class="mn mo iq ku b kv my ky mz lb na lf nb lj nc ln on mv mw mx bi translated">类TestingConfig(Config)，它包含测试环境的配置设置。</li><li id="9b60" class="mn mo iq ku b kv my ky mz lb na lf nb lj nc ln on mv mw mx bi translated">class ProductionConfig(Config)，它包含生产环境的配置设置。</li></ul><p id="7d79" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">要使用config.py/ settings . py文件配置flask应用程序实例，您可以使用config对象公开的<code class="fe ob oc od ne b">from_object()</code>方法。此方法采用的参数指示配置脚本的名称和应该从中加载配置数据的类。假设您的配置脚本名为config.py，在开发阶段，您可能希望从DevelopmentConfig类加载配置数据。完成此操作的方法如下所示:</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="2471" class="ni lw iq ne b gy nj nk l nl nm">app = Flask(__name__)<br/>app.config.from_object('config.DevelopmentConfig')</span></pre><h2 id="ce99" class="ni lw iq bd lx nn no dn mb np nq dp mf lb nr ns mh lf nt nu mj lj nv nw ml nx bi translated">生产级烧瓶应用程序的配置方式</h2><p id="41fb" class="pw-post-body-paragraph ks kt iq ku b kv mp jr kx ky mq ju la lb ny ld le lf nz lh li lj oa ll lm ln ij bi translated">实际上，有一些参数，比如密钥、邮件服务器用户名和密码，以及许多其他参数的值，出于安全原因，您不希望在config.py文件中显式地硬编码。</p><p id="a9e1" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">最终发生的是flask应用程序使用环境变量方法和对象方法的组合进行配置。使用环境变量方法在环境中设置敏感参数，然后使用<code class="fe ob oc od ne b">os.environ.get()</code>方法将其导入config.py文件。如果环境没有为参数提供值，则会提供默认值。非敏感参数在config.py文件中显式定义。</p><p id="b914" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">如果您不想像前面解释的那样使用终端设置环境变量，有一个漂亮的小python包叫做<code class="fe ob oc od ne b">python-dotenv</code>。一旦安装了这个包，您就可以在项目根目录下创建一个<code class="fe ob oc od ne b">.env</code>文件，并在其中定义所有的环境变量。然后，通过调用<code class="fe ob oc od ne b">load_dotenv()</code>方法，告诉config.py文件从<code class="fe ob oc od ne b">.env</code>文件加载环境配置设置。如果你使用这种方法，你需要记住将<code class="fe ob oc od ne b">.env</code>文件添加到<code class="fe ob oc od ne b">.gitignore</code>文件中。</p><p id="c2f0" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">在您的<code class="fe ob oc od ne b">.env</code>文件中:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="26b7" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">在您的<code class="fe ob oc od ne b">config.py</code>文件中:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oo op l"/></div></figure></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><h1 id="f326" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">定义你的蓝图</h1><p id="36ae" class="pw-post-body-paragraph ks kt iq ku b kv mp jr kx ky mq ju la lb ny ld le lf nz lh li lj oa ll lm ln ij bi translated">每个蓝图必须有一个<code class="fe ob oc od ne b">__init__.py</code>文件。在这个文件中，通过实例化blueprint类的一个实例来定义Blueprint。传递给类构造函数的参数是蓝图的名称和包含属于蓝图的模板的文件夹的名称。然后，您需要导入与该蓝图相关联的路由，这些路由写在与<code class="fe ob oc od ne b">__init__.py</code>模块位于同一目录的<code class="fe ob oc od ne b">views.py</code>中。</p><p id="c321" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">在<code class="fe ob oc od ne b">app/auth/__init__.py</code>中:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="40b4" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">在<code class="fe ob oc od ne b">app/main/__init__.py</code>中:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="ecf6" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">出于测试目的，您需要编写一些初始代码，以确保一切设置正确。</p><p id="773a" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">使用蓝图时:</p><ul class=""><li id="6d76" class="mn mo iq ku b kv kw ky kz lb ok lf ol lj om ln on mv mw mx bi translated">确保用于定义任何路由的装饰器使用blueprint对象。</li><li id="b077" class="mn mo iq ku b kv my ky mz lb na lf nb lj nc ln on mv mw mx bi translated">确保<code class="fe ob oc od ne b">render_template()</code>函数参数采用<code class="fe ob oc od ne b">blueprint_name/template_name.html</code>的形式。这样做是为了反映一个事实，即一个蓝图只能呈现属于它的模板。</li><li id="0bab" class="mn mo iq ku b kv my ky mz lb na lf nb lj nc ln on mv mw mx bi translated">确保<code class="fe ob oc od ne b">url_for()</code>功能引用了与视图功能相关的蓝图。这样做是为了反映视图功能属于特定蓝图的事实。<code class="fe ob oc od ne b">url_for(auth.login)</code>。</li><li id="a417" class="mn mo iq ku b kv my ky mz lb na lf nb lj nc ln on mv mw mx bi translated">您对<code class="fe ob oc od ne b">app</code>对象的任何引用都需要由<code class="fe ob oc od ne b">current_app</code>对象替换。这是因为当您使用蓝图时，您不再能够直接访问flask应用程序实例。你只能通过它的代理人<code class="fe ob oc od ne b">current_app</code>来访问它。</li><li id="9107" class="mn mo iq ku b kv my ky mz lb na lf nb lj nc ln on mv mw mx bi translated">如果您在蓝图注册中为蓝图指定了一个前缀，那么视图函数decorator中的route不会得到那个前缀(也就是说，decorator不是您所想的<code class="fe ob oc od ne b">@auth_blueprint.route('/users/login')</code>)。但是，从客户端收到的路由请求必须包含前缀，否则服务器将返回404错误。</li><li id="84b3" class="mn mo iq ku b kv my ky mz lb na lf nb lj nc ln on mv mw mx bi translated">在蓝图的目录中，您需要创建一个templates文件夹，然后在该templates文件夹中创建另一个以蓝图命名的文件夹。与蓝图关联的模板存储在以蓝图命名的目录中。<a class="ae kr" href="https://flask.palletsprojects.com/en/1.1.x/blueprints/" rel="noopener ugc nofollow" target="_blank">这种方法是存储与蓝图</a>视图功能相关的模板的建议方式。</li></ul><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="7201" class="ni lw iq ne b gy nj nk l nl nm">|project  <br/>    |-auth<br/>        |-templates<br/>            |-auth</span></pre><p id="ef10" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">在<code class="fe ob oc od ne b">app/auth/views.py</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="eb82" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">在<code class="fe ob oc od ne b">app/auth/templates/auth/register.html</code>中:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="a55c" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">在<code class="fe ob oc od ne b">app/main/views.py</code>中:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="eb7d" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">在<code class="fe ob oc od ne b">app/main/templates/main/index.html</code>中:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oo op l"/></div></figure></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><h1 id="81e5" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">应用程序工厂模式</h1><p id="9c6d" class="pw-post-body-paragraph ks kt iq ku b kv mp jr kx ky mq ju la lb ny ld le lf nz lh li lj oa ll lm ln ij bi translated">通常，flask应用程序是用全局范围实例化的。这意味着当您运行flask应用程序脚本时，flask应用程序会立即被实例化和配置。不幸的是，一旦它开始运行，就没有办法改变它的配置设置。</p><p id="a6d3" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">这不是理想的行为。您希望能够创建针对不同环境(开发、测试或生产)配置的同一flask应用程序的不同版本。</p><p id="1149" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">一种解决方案是将flask应用程序的实例化和配置转移到一个函数中。使用应用程序工厂函数，然后在想要创建flask应用程序实例时调用它的方法实际上是一种众所周知的设计模式，称为工厂方法模式。使用配置flask应用程序的应用程序工厂模式方法使您能够在实例化flask应用程序之前定义它的配置。基本上，您需要为flask应用程序设置的所有内容都在应用程序工厂函数中定义，这样它会返回一个完全按照您的喜好设置和配置的flask应用程序实例。</p><p id="ddcf" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">定义flask app实例化的函数称为应用工厂函数(因为它在文学上用于生产许多flask应用程序，就像一个工厂用于生产许多产品一样)。它是在项目包的<code class="fe ob oc od ne b">app/__init__.py</code>模块中定义的。然后它在项目的<code class="fe ob oc od ne b">application.py</code>模块中被实例化。</p><p id="0324" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><strong class="ku ir">应用程序工厂函数中定义的所有内容的摘要:</strong></p><ol class=""><li id="7f51" class="mn mo iq ku b kv kw ky kz lb ok lf ol lj om ln mu mv mw mx bi translated">Flask应用实例化</li><li id="b7ab" class="mn mo iq ku b kv my ky mz lb na lf nb lj nc ln mu mv mw mx bi translated">烧瓶应用配置</li><li id="143d" class="mn mo iq ku b kv my ky mz lb na lf nb lj nc ln mu mv mw mx bi translated">烧瓶扩展实例化和初始化</li><li id="ef88" class="mn mo iq ku b kv my ky mz lb na lf nb lj nc ln mu mv mw mx bi translated">蓝图的注册</li><li id="a5de" class="mn mo iq ku b kv my ky mz lb na lf nb lj nc ln mu mv mw mx bi translated">请求回调的注册</li><li id="e95b" class="mn mo iq ku b kv my ky mz lb na lf nb lj nc ln mu mv mw mx bi translated">应用程序范围错误处理程序的注册</li><li id="e09d" class="mn mo iq ku b kv my ky mz lb na lf nb lj nc ln mu mv mw mx bi translated">日志记录配置</li></ol><h2 id="8e08" class="ni lw iq bd lx nn no dn mb np nq dp mf lb nr ns mh lf nt nu mj lj nv nw ml nx bi translated">登记蓝图</h2><p id="8c8c" class="pw-post-body-paragraph ks kt iq ku b kv mp jr kx ky mq ju la lb ny ld le lf nz lh li lj oa ll lm ln ij bi translated">蓝图是通过将蓝图对象传递给flask应用程序实例公开的<code class="fe ob oc od ne b">register_blueprint()</code>方法来注册的。该方法接受第二个可选参数，这是一个前缀，所有与蓝图相关联的URL都应该以它开头。在下面的例子中，授权蓝图的前缀是<code class="fe ob oc od ne b">/users</code>。这意味着，例如，要访问登录页面，用户必须请求<code class="fe ob oc od ne b">/users/login</code>路线。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="7fb4" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">在<code class="fe ob oc od ne b">app/__init__.py</code>中:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="dc51" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">在<code class="fe ob oc od ne b">application.py</code>中:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="21e4" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">要测试一切以确保蓝图设置正确，请在终端中运行以下命令:</p><p id="f925" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><code class="fe ob oc od ne b">$ flask run</code></p><p id="711f" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">当您导航到<a class="ae kr" href="http://127.0.0.1:5000/" rel="noopener ugc nofollow" target="_blank"> http://127.0.0.1:5000/ </a>时，您应该会看到“Hello world from the main blue！”</p><p id="0f00" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">当您导航到<a class="ae kr" href="http://127.0.0.1:5000/users/register/11anguwa@gmail.com" rel="noopener ugc nofollow" target="_blank">http://127 . 0 . 0 . 1:5000/users/register/you-email-address @ Gmail . com</a>时，您应该会看到“您好，您的电子邮件地址<a class="ae kr" href="mailto:11anguwa@gmail.com" rel="noopener ugc nofollow" target="_blank"> @gmail.com </a>，来自认证蓝图！”</p></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><h1 id="c755" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">记录</h1><h2 id="0b30" class="ni lw iq bd lx nn no dn mb np nq dp mf lb nr ns mh lf nt nu mj lj nv nw ml nx bi translated">什么是日志记录，为什么它很重要？</h2><p id="9375" class="pw-post-body-paragraph ks kt iq ku b kv mp jr kx ky mq ju la lb ny ld le lf nz lh li lj oa ll lm ln ij bi translated">日志记录是记录应用程序信息的过程。它用于在事件发生时记录事件，是调试任何问题和深入了解应用程序如何工作的绝佳工具。</p><p id="1b9c" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">您应该记录的内容包括:</p><ul class=""><li id="eafd" class="mn mo iq ku b kv kw ky kz lb ok lf ol lj om ln on mv mw mx bi translated">与用户相关的事件，如注册、登录、注销、不正确的密码尝试</li><li id="0c88" class="mn mo iq ku b kv my ky mz lb na lf nb lj nc ln on mv mw mx bi translated">特定于应用程序功能的事件(例如，对于一个博客，它可以发布一个新的博客或添加一个评论)</li><li id="4592" class="mn mo iq ku b kv my ky mz lb na lf nb lj nc ln on mv mw mx bi translated">错误，包括特定于应用程序的错误以及数据库操作错误。</li></ul><p id="0b6c" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">您不应该在日志中存储任何敏感数据，因为它们通常存储为文本文件，因此不安全。</p><h2 id="84c3" class="ni lw iq bd lx nn no dn mb np nq dp mf lb nr ns mh lf nt nu mj lj nv nw ml nx bi translated">日志模块</h2><p id="60f2" class="pw-post-body-paragraph ks kt iq ku b kv mp jr kx ky mq ju la lb ny ld le lf nz lh li lj oa ll lm ln ij bi translated">Flask使用标准的python日志模块。日志模块有4个子模块，可以通过点符号访问:记录器、处理程序、过滤器和格式化程序。</p><p id="e8d9" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><strong class="ku ir">记录器</strong>是创建日志消息的对象。创建日志消息时，必须使用与重要程度级别相关的函数来指定其重要程度。关键级别(又名日志级别)、其数字表示以及与其相关的功能如下:</p><ul class=""><li id="c4b4" class="mn mo iq ku b kv kw ky kz lb ok lf ol lj om ln on mv mw mx bi translated">调试→ 10 →调试()</li><li id="a328" class="mn mo iq ku b kv my ky mz lb na lf nb lj nc ln on mv mw mx bi translated">信息→ 20 →信息()</li><li id="fad2" class="mn mo iq ku b kv my ky mz lb na lf nb lj nc ln on mv mw mx bi translated">警告→ 30 →警告()</li><li id="0035" class="mn mo iq ku b kv my ky mz lb na lf nb lj nc ln on mv mw mx bi translated">错误→ 40 →错误()</li><li id="69de" class="mn mo iq ku b kv my ky mz lb na lf nb lj nc ln on mv mw mx bi translated">临界→ 50 →临界()</li></ul><p id="d6a9" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">有一个默认的logger对象，无需任何配置就可以访问和使用它。每个flask实例通过<code class="fe ob oc od ne b">app.logger</code>对象公开它。如果您正在使用蓝图，那么您必须通过<code class="fe ob oc od ne b">current_app</code>对象来访问它，这个对象是flask应用程序实例的代理。</p><p id="a8f7" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">在你的<code class="fe ob oc od ne b">app/main/views.py</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="7ab6" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">不幸的是，默认记录器只打印到控制台。因此，如果您想记录到一个文件，您需要配置一个新的记录器实例。默认记录器仍将继续记录，但您可以选择禁用它:</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="8988" class="ni lw iq ne b gy nj nk l nl nm">from flask.logging import default_handler</span><span id="92b9" class="ni lw iq ne b gy oq nk l nl nm">app.logger.removeHandler(default_handler)</span></pre><p id="1201" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">当您配置新的记录器实例时，您可以指定应该记录的消息的最低重要级别。所有重要程度为该值或更高的日志消息都将被记录，任何重要程度值低于该值的日志消息都不会被记录。这在您希望减少日志消息的数量而不从源代码中删除日志调用的情况下非常有用。您可以增加要写入日志的消息的最低日志级别，例如:错误消息及以上。</p><p id="5559" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><strong class="ku ir">处理程序</strong>是将日志消息指向正确目的地的对象。默认的处理程序称为流处理程序，它向终端发送日志消息。您可以创建不同的处理程序对象来将日志消息路由到不同的目的地。</p><ul class=""><li id="09b3" class="mn mo iq ku b kv kw ky kz lb ok lf ol lj om ln on mv mw mx bi translated">要记录到一个文件中，你需要使用一个文件处理程序。要将日志消息作为电子邮件发送，您可以使用SMTPHandler。</li><li id="9920" class="mn mo iq ku b kv my ky mz lb na lf nb lj nc ln on mv mw mx bi translated">FileHandler方法接受要写入的日志文件的路径，包括其名称，并实例化一个FileHandler对象，该对象将向该文件发送日志消息。</li><li id="b5c9" class="mn mo iq ku b kv my ky mz lb na lf nb lj nc ln on mv mw mx bi translated">实例文件夹通常用于存储运行时运行的文件(日志和数据库文件)。此文件夹需要添加到您的。gitignore文件，这样它就不会被版本控制跟踪。</li></ul><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="3e03" class="ni lw iq ne b gy nj nk l nl nm">file_handler = logging.FileHandler('instance/my-app-log.log')</span><span id="69fc" class="ni lw iq ne b gy oq nk l nl nm">app.logger.addHandler(file_handler)</span></pre><ul class=""><li id="6262" class="mn mo iq ku b kv kw ky kz lb ok lf ol lj om ln on mv mw mx bi translated">FileHandler对象将日志消息写入单个日志文件。这可能会导致日志文件很快变大。更好的方法是使用RotatingFileHandler对象。它还将日志消息写入文件，但是每当当前日志文件超过指定的文件大小(maxBytes)时，它都会创建一个新的日志文件。在开始覆盖现有文件之前，它将创建一个达到指定文件数(backupCount)的新文件。</li></ul><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="ab1d" class="ni lw iq ne b gy nj nk l nl nm">from logging.handlers import RotatingFileHandler</span><span id="1a17" class="ni lw iq ne b gy oq nk l nl nm">file_handler = RotatingFileHandler('instance/scrub-my-list.log', maxBytes=16384, backupCount=20)</span></pre><p id="04d5" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><strong class="ku ir">过滤器</strong>用于向日志消息添加上下文信息。例如，在记录请求时，您可以创建一个过滤器，添加请求来自的远程IP地址。</p><p id="752e" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><strong class="ku ir">日志格式器</strong>用于指定日志消息的格式。每个日志消息都是一个LogRecord对象。日志格式化程序用于指定要显示日志记录的哪些属性以及它们应该显示的顺序。</p><p id="f8a7" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">日志记录的常见属性包括:</p><ul class=""><li id="1cd8" class="mn mo iq ku b kv kw ky kz lb ok lf ol lj om ln on mv mw mx bi translated"><code class="fe ob oc od ne b">%(asctime)s</code> -创建日志记录的日期时间</li><li id="8882" class="mn mo iq ku b kv my ky mz lb na lf nb lj nc ln on mv mw mx bi translated"><code class="fe ob oc od ne b">%(filename)s</code> -路径名的文件名部分</li><li id="55c9" class="mn mo iq ku b kv my ky mz lb na lf nb lj nc ln on mv mw mx bi translated"><code class="fe ob oc od ne b">%(funcName)s</code> -包含日志调用的函数名</li><li id="aab8" class="mn mo iq ku b kv my ky mz lb na lf nb lj nc ln on mv mw mx bi translated"><code class="fe ob oc od ne b">%(levelname)s</code> -消息的记录级别</li><li id="92bf" class="mn mo iq ku b kv my ky mz lb na lf nb lj nc ln on mv mw mx bi translated"><code class="fe ob oc od ne b">%(lineno)d</code> -发出日志记录调用的源代码的行号(如果可用)</li><li id="e6b5" class="mn mo iq ku b kv my ky mz lb na lf nb lj nc ln on mv mw mx bi translated"><code class="fe ob oc od ne b">%(message)s</code> -记录的消息</li><li id="b463" class="mn mo iq ku b kv my ky mz lb na lf nb lj nc ln on mv mw mx bi translated"><code class="fe ob oc od ne b">%(module)s</code> -发出记录调用的模块</li></ul><h2 id="8266" class="ni lw iq bd lx nn no dn mb np nq dp mf lb nr ns mh lf nt nu mj lj nv nw ml nx bi translated">如何配置日志记录</h2><p id="ad51" class="pw-post-body-paragraph ks kt iq ku b kv mp jr kx ky mq ju la lb ny ld le lf nz lh li lj oa ll lm ln ij bi translated">您应该在创建flask应用程序实例之前配置日志记录，否则它将使用默认的处理程序将日志消息写入控制台。这就是在应用程序工厂函数中配置日志记录的原因。</p><p id="dc6c" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">配置日志记录所需的步骤:</p><ol class=""><li id="f51d" class="mn mo iq ku b kv kw ky kz lb ok lf ol lj om ln mu mv mw mx bi translated">导入日志库。可选:从<code class="fe ob oc od ne b">logging.handlers</code>导入<code class="fe ob oc od ne b">default_handler</code></li><li id="186c" class="mn mo iq ku b kv my ky mz lb na lf nb lj nc ln mu mv mw mx bi translated">实例化一个处理程序对象。</li><li id="165e" class="mn mo iq ku b kv my ky mz lb na lf nb lj nc ln mu mv mw mx bi translated">使用handler对象公开的<code class="fe ob oc od ne b">setLevel()</code>方法设置其日志记录级别。</li><li id="9200" class="mn mo iq ku b kv my ky mz lb na lf nb lj nc ln mu mv mw mx bi translated">实例化一个格式化程序对象。</li><li id="06ca" class="mn mo iq ku b kv my ky mz lb na lf nb lj nc ln mu mv mw mx bi translated">使用handler对象公开的<code class="fe ob oc od ne b">setFormatter()</code>方法将Formatter对象添加到handler对象。</li><li id="b7a8" class="mn mo iq ku b kv my ky mz lb na lf nb lj nc ln mu mv mw mx bi translated">使用logger公开的<code class="fe ob oc od ne b">addHandler()</code>方法将handler对象添加到logger。</li><li id="29b3" class="mn mo iq ku b kv my ky mz lb na lf nb lj nc ln mu mv mw mx bi translated">停用默认处理程序</li></ol><p id="f6d5" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">在<code class="fe ob oc od ne b">app/__init__.py</code>中:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="5d7a" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">重新启动flask development服务器并导航到索引页面。</p><p id="6b03" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">应该在顶层项目目录中创建一个新文件<code class="fe ob oc od ne b">flaskapp.log</code>。如果打开它，您应该会看到以下日志消息:</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="244a" class="ni lw iq ne b gy nj nk l nl nm">2021-05-14 16:14:31,910 INFO: Index page loading [in views.py: 6]</span></pre></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><h1 id="fda9" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">自定义错误处理</h1><h2 id="793d" class="ni lw iq bd lx nn no dn mb np nq dp mf lb nr ns mh lf nt nu mj lj nv nw ml nx bi translated">HTTP状态代码</h2><p id="ed9b" class="pw-post-body-paragraph ks kt iq ku b kv mp jr kx ky mq ju la lb ny ld le lf nz lh li lj oa ll lm ln ij bi translated">当客户端向web服务器发出请求时，响应消息包含HTTP状态代码。这是一个3位数，表示处理请求的结果。状态代码根据第一个数字分为5个类别，每个类别代表一种响应类型:</p><ol class=""><li id="dd32" class="mn mo iq ku b kv kw ky kz lb ok lf ol lj om ln mu mv mw mx bi translated">1xx —信息响应</li><li id="fb4c" class="mn mo iq ku b kv my ky mz lb na lf nb lj nc ln mu mv mw mx bi translated">2xx —成功的eg</li></ol><ul class=""><li id="2c52" class="mn mo iq ku b kv kw ky kz lb ok lf ol lj om ln on mv mw mx bi translated">200 (OK)，用于成功处理请求</li></ul><p id="e493" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">3.3xx —重定向</p><ul class=""><li id="d298" class="mn mo iq ku b kv kw ky kz lb ok lf ol lj om ln on mv mw mx bi translated">302(找到)，成功地将客户端重定向到一个新的URL</li></ul><p id="5131" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">4.4xx —客户端错误</p><ul class=""><li id="d82b" class="mn mo iq ku b kv kw ky kz lb ok lf ol lj om ln on mv mw mx bi translated">400(坏请求):当客户端提出服务器无法理解或不允许的请求时。</li><li id="ed86" class="mn mo iq ku b kv my ky mz lb na lf nb lj nc ln on mv mw mx bi translated">403(禁止):当客户端试图访问受限制的资源，但没有这样做的授权。</li><li id="70f7" class="mn mo iq ku b kv my ky mz lb na lf nb lj nc ln on mv mw mx bi translated">404(未找到):当客户端请求服务器无法识别的URL时。给出的错误消息应该是这样的:“对不起，您要找的东西不在这里！”。</li><li id="5e3e" class="mn mo iq ku b kv my ky mz lb na lf nb lj nc ln on mv mw mx bi translated">405(不允许方法):当处理给定路由请求的视图函数不接受请求方法时。给出的错误消息应该类似于“对不起，该资源不支持所请求的方法！”。</li></ul><p id="8a48" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">5.5xx —服务器错误</p><ul class=""><li id="13a4" class="mn mo iq ku b kv kw ky kz lb ok lf ol lj om ln on mv mw mx bi translated">500(内部服务器错误):通常由于编程错误或服务器过载而发生。</li></ul><h2 id="cb15" class="ni lw iq bd lx nn no dn mb np nq dp mf lb nr ns mh lf nt nu mj lj nv nw ml nx bi translated">如何创建自定义错误页面</h2><p id="a69e" class="pw-post-body-paragraph ks kt iq ku b kv mp jr kx ky mq ju la lb ny ld le lf nz lh li lj oa ll lm ln ij bi translated">您通常希望为403、404、405和500错误定义自己的自定义错误页面，以便:</p><ul class=""><li id="b1bb" class="mn mo iq ku b kv kw ky kz lb ok lf ol lj om ln on mv mw mx bi translated">错误页面可以与web应用程序的其余部分具有相同的外观。通过使用一个扩展base.html的模板，错误页面将拥有和其他网页一样的导航栏和页脚。</li><li id="2583" class="mn mo iq ku b kv my ky mz lb na lf nb lj nc ln on mv mw mx bi translated">您可以提供导航链接，使用户更容易导航回应用程序。</li></ul><p id="3a07" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><strong class="ku ir">步骤1:为错误代码定义一个模板文件，并将其保存在保存base.html文件的templates文件夹中。</strong></p><p id="ef91" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">未找到页面的自定义错误模板示例如下所示。您需要为400、403、404、405和500定义自定义错误处理程序模板。</p><p id="7fa8" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">在您的<code class="fe ob oc od ne b">app/templates/base.html</code>文件中:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="585e" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">在您的<code class="fe ob oc od ne b">app/templates/404.html</code>文件中:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="a699" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><strong class="ku ir">第二步:为每个错误代码定义一个错误处理程序。</strong></p><p id="650b" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">错误处理程序是在错误发生时呈现错误模板的函数。你可以给它起任何你想要的名字，它必须用<code class="fe ob oc od ne b">@app.errorhandler()</code>装饰。这个装饰器将它必须处理的错误的状态代码作为参数。</p><p id="cedb" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">自定义错误处理程序的语法如下所示:</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="fccb" class="ni lw iq ne b gy nj nk l nl nm">@app.errorhandler(status_code)<br/>def function_name(error):<br/>    # You can log the error or send an email here<br/>    return render_template("status_code.html"), status_code</span></pre><p id="9f2a" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">当您使用应用程序工厂方法时，所有的错误处理函数都在一个帮助函数<code class="fe ob oc od ne b">register_error_pages()</code>中定义。这个函数在应用程序工厂函数中被调用，并一次注册所有的错误处理程序。在<code class="fe ob oc od ne b">create_app()</code>函数之外定义错误处理程序很有用，这样可以保持干净，但仍然能够让flask应用程序实例知道错误处理程序。</p><p id="a46d" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">在你的<code class="fe ob oc od ne b">app/__init__.py</code>文件中:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="9476" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">这个设置向flask应用程序实例注册了自定义错误处理程序。蓝图也支持<code class="fe ob oc od ne b">errorhandler()</code>装饰器，这意味着您可以用蓝图注册错误处理程序。然而，不建议使用这种注册自定义错误处理程序的方式，因为它不能被其他蓝图使用。最好向应用程序实例注册错误处理程序，以便它们可以查看所有蓝图中所有视图功能使用的视图。</p><p id="5bcb" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">为了测试定制的错误处理程序，Flask提供了一个<code class="fe ob oc od ne b">abort()</code>函数，可以用来手动抛出错误。它将您想要抛出的错误的状态代码作为参数。将显示该错误的默认错误页面，但这很简单。</p><p id="8ad4" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">在你的<code class="fe ob oc od ne b">app/main/views.py</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="7cfb" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">如果已经注册了该错误的错误处理程序，将调用它来显示自定义错误页，而不是默认页。</p><p id="74ed" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">重新启动flask开发服务器。导航到<a class="ae kr" href="http://127.0.0.1:5000/admin" rel="noopener ugc nofollow" target="_blank">http://127 . 0 . 0 . 1:5000/admin</a>，您应该会看到定制的错误消息。将<code class="fe ob oc od ne b">abort()</code>函数的参数改为403、404、405，最后改为500，以确保所有自定义错误页面都被正确呈现。</p></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><h1 id="1b8b" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">芹菜</h1><h2 id="3df3" class="ni lw iq bd lx nn no dn mb np nq dp mf lb nr ns mh lf nt nu mj lj nv nw ml nx bi translated">芹菜是什么？</h2><p id="9a7d" class="pw-post-body-paragraph ks kt iq ku b kv mp jr kx ky mq ju la lb ny ld le lf nz lh li lj oa ll lm ln ij bi translated">Celery是一个基于分布式消息传递的开源异步任务队列。尽管它支持调度，但它最常用于异步任务处理。当您的应用程序有长时间运行的任务(如处理数据、生成报告或发送电子邮件等网络相关任务)时，您最好在后台运行这些任务，而不是在与请求相同的流程中运行它们。</p><p id="fcee" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">分布式消息传递系统有三个组件:</p><ul class=""><li id="27cb" class="mn mo iq ku b kv kw ky kz lb ok lf ol lj om ln on mv mw mx bi translated">发布后台作业的发布者(芹菜客户端。celery客户端运行flask应用程序)</li><li id="bcd2" class="mn mo iq ku b kv my ky mz lb na lf nb lj nc ln on mv mw mx bi translated">消息代理/队列(通常是Redis或Rabbit MQ)</li><li id="1280" class="mn mo iq ku b kv my ky mz lb na lf nb lj nc ln on mv mw mx bi translated">订阅者(celery workers是执行后台任务的独立进程)</li></ul><p id="fc59" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">分布式消息传递基本上意味着Celery依靠一个称为broker的中间人来充当它和任务生产者之间的中介。为了启动任务，客户端向消息队列发送消息。然后，消息队列将消息传递给工作线程，并执行所需的任何操作。worker通过消息代理将作业的状态或结果返回给客户机。在任何时候，客户和员工都不会直接交流。实际上，他们甚至没有意识到对方。它们各自只处理消息队列。</p><p id="00fc" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">使用分布式消息传递体系结构的主要优点是:</p><ol class=""><li id="b324" class="mn mo iq ku b kv kw ky kz lb ok lf ol lj om ln mu mv mw mx bi translated">可伸缩性:每个组件都可以根据需要独立伸缩，而不会影响其他组件</li><li id="401b" class="mn mo iq ku b kv my ky mz lb na lf nb lj nc ln mu mv mw mx bi translated">松散耦合:工作者只关心它接收到的消息，而不关心是谁产生了它</li><li id="3867" class="mn mo iq ku b kv my ky mz lb na lf nb lj nc ln mu mv mw mx bi translated">消息队列向工作人员提供实时消息。工作者不需要不断地轮询队列来查看是否有消息</li></ol><h2 id="8013" class="ni lw iq bd lx nn no dn mb np nq dp mf lb nr ns mh lf nt nu mj lj nv nw ml nx bi translated">用芹菜</h2><p id="cde7" class="pw-post-body-paragraph ks kt iq ku b kv mp jr kx ky mq ju la lb ny ld le lf nz lh li lj oa ll lm ln ij bi translated"><strong class="ku ir">安装</strong></p><p id="104b" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">如果您还没有这样做，安装celery和您选择的消息代理的包。我选择了使用Redis。</p><p id="ca48" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><code class="fe ob oc od ne b">$ pip install celery redis</code></p><p id="846a" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><strong class="ku ir">配置</strong></p><p id="0cbd" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">要配置Celery，您需要定义两个参数，<code class="fe ob oc od ne b">CELERY_BROKER_URL</code>和<code class="fe ob oc od ne b">RESULT_BACKEND</code>。这些参数的值是您选择的代理的URL。它实际上告诉Celery代理在哪里运行，这样Celery就能够连接到它。我将在本地机器的端口6379上运行一个redis docker容器。</p><p id="e59b" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><code class="fe ob oc od ne b">RESULT_BACKEND</code>参数定义了当您运行一个返回某些东西的任务时，任务结果存储在哪里。如果您正在运行不返回结果或状态的后台任务，那么您不需要取消定义此参数。如果您确实想返回结果，您的消息代理也可以作为您的结果后端。这就是为什么我给了他们相同的网址。</p><p id="2c0e" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">1.在<code class="fe ob oc od ne b">.env</code>文件中定义redis客户端的URL:</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="5c7d" class="ni lw iq ne b gy nj nk l nl nm">CELERY_BROKER_URL = redis://localhost:6379</span><span id="5c74" class="ni lw iq ne b gy oq nk l nl nm">RESULT_BACKEND = redis://localhost:6379</span></pre><p id="6be4" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">2.在<code class="fe ob oc od ne b">config.py</code>中配置<code class="fe ob oc od ne b">Config</code>类芹菜:</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="f901" class="ni lw iq ne b gy nj nk l nl nm">CELERY_BROKER_URL = os.getenv('CELERY_BROKER_URL ')</span><span id="ed7f" class="ni lw iq ne b gy oq nk l nl nm">RESULT_BACKEND = os.getenv('RESULT_BACKEND')</span></pre><p id="2915" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><strong class="ku ir">芹菜设置</strong></p><ol class=""><li id="1316" class="mn mo iq ku b kv kw ky kz lb ok lf ol lj om ln mu mv mw mx bi translated">在<code class="fe ob oc od ne b">app/__init__.py</code>中实例化一个芹菜对象:</li></ol><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="af8f" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">在上面的代码中，我们通过调用Celery类对象实例化了一个新的Celery对象。它期望的参数是:</p><ul class=""><li id="8510" class="mn mo iq ku b kv kw ky kz lb ok lf ol lj om ln on mv mw mx bi translated">正在实例化芹菜对象的模块的名称</li><li id="0436" class="mn mo iq ku b kv my ky mz lb na lf nb lj nc ln on mv mw mx bi translated">代理的URL，它告诉celert代理服务正在哪里运行</li><li id="7e4f" class="mn mo iq ku b kv my ky mz lb na lf nb lj nc ln on mv mw mx bi translated">结果后端的URL</li></ul><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="5b68" class="ni lw iq ne b gy nj nk l nl nm">from celery import Celery  # NEW!!!!!<br/>from config import Config  # NEW!!!!!</span><span id="1cab" class="ni lw iq ne b gy oq nk l nl nm">celery = Celery(__name__, broker=Config.CELERY_BROKER_URL, result_backend=Config.RESULT_BACKEND)</span></pre><p id="4cd2" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">芹菜的任何其他配置都从应用程序工厂函数内的flask应用程序配置传递给芹菜对象:</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="4ea1" class="ni lw iq ne b gy nj nk l nl nm">celery.conf.update(app.config)</span></pre><p id="eec2" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">2.定义要在后台运行的任务</p><p id="b46d" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">对于这个例子，我们将设置Celery在后台发送电子邮件。</p><p id="04b6" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">已经配置了<code class="fe ob oc od ne b">flask-mail</code>扩展。</p><p id="168a" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">后台任务被定义为函数。每个函数都需要用<code class="fe ob oc od ne b">@celery.task</code>装饰器来装饰。在一个单独的模块中定义所有的任务是一个好主意。</p><p id="6edd" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">在<code class="fe ob oc od ne b">app/tasks.py</code>创建一个发送邮件的任务:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="9da0" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">在<code class="fe ob oc od ne b">app/auth/views.py</code>中，调用任务:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="d5f3" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">为了调用任务，我使用了<code class="fe ob oc od ne b">apply_async()</code>方法，并使用<code class="fe ob oc od ne b">args</code>关键字传递任务函数需要的参数。</p><p id="6944" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">3.编写启动芹菜工的脚本。</p><p id="3a9c" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">在<code class="fe ob oc od ne b">celery_worker.py</code>中:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="33ab" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">上面的代码创建了一个flask应用程序，然后使用它为celery实例的运行建立了一个应用程序上下文。Celery需要应用程序上下文才能访问任何flask扩展对象，以便执行后台任务。它将在celery worker进程运行的整个生命周期内保持设置。</p><p id="c5c9" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">有必要导入celery实例，因为Celery将需要它来执行后台任务。</p><p id="0667" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><strong class="ku ir">测试所有东西</strong></p><ol class=""><li id="6073" class="mn mo iq ku b kv kw ky kz lb ok lf ol lj om ln mu mv mw mx bi translated">打开docker并运行Redis容器。</li></ol><p id="c966" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><code class="fe ob oc od ne b">$ docker run -d -p 6379:6379 redis</code></p><p id="51e7" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">2.打开一个新的终端窗口，激活虚拟环境并启动一个芹菜客户端:</p><p id="11d6" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><code class="fe ob oc od ne b">$ celery -A celery_worker.celery worker --pool=solo --loglevel=info</code></p><p id="9a67" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">您应该会看到clery客户端启动。它将向您显示它已经连接到redis客户机，还向您显示为Celery创建的在后台运行的任务。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="of og di oh bf oi"><div class="gh gi or"><img src="../Images/2c6974bc466a97767de9e265a06ec5e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ds9judMcaXq6bbris5J8xQ.png"/></div></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">芹菜客户端输出(作者自己的)</p></figure><p id="3a2f" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">如果您遇到任何问题，请卸载并重新安装celery，然后重试。还可以尝试不同的<a class="ae kr" href="https://www.distributedpython.com/2018/10/26/celery-execution-pool/" rel="noopener ugc nofollow" target="_blank">执行池</a>,因为我发现这也有所不同。</p><p id="e2ff" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">3.在主终端窗口中，重新启动flask development服务器。导航至<a class="ae kr" href="http://127.0.0.1:5000/users/register/11anguwa@gmail.com" rel="noopener ugc nofollow" target="_blank">http://127 . 0 . 0 . 1:5000/users/register/your-email-address @ Gmail . com</a></p><p id="bd71" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">如果您检查运行Celery客户端的终端，您应该看到以下内容，以了解任务已经成功执行:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="of og di oh bf oi"><div class="gh gi os"><img src="../Images/b46413ddd73f9e289dc75e17add91d2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mzPu_3EJPSYEcE4q_8X-HQ.png"/></div></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">芹菜执行电子邮件发送后台任务(作者自己的)</p></figure><p id="7291" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">输出的最后一行:</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="2066" class="ni lw iq ne b gy nj nk l nl nm">[2021-05-15 19:36:39,651: INFO/MainProcess] Task app.tasks.send_celery_email[59e09990-ed19-4209-8afb-3bdd87ec80c6] succeeded in 3.1569999999919673s: None</span></pre><p id="6cb6" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">您应该会从邮件传递子系统收到一封电子邮件，说明无法找到<code class="fe ob oc od ne b">your-email-address@gmail.com</code>地址。</p><p id="a2d4" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">将URL的<code class="fe ob oc od ne b">your-email-address</code>部分替换为有效的电子邮件地址，您应该会收到一封主题和正文都在<code class="fe ob oc od ne b">app/views.py</code>中定义的电子邮件。</p><p id="6d3b" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">请记住，要让flask应用程序代表您使用google SMTP服务器发送电子邮件，您需要允许不太安全的应用程序访问。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/e6993c66faae472ced24b104b529b09b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1184/format:webp/1*HzLWeLJHIoYCJsn_EkHccQ.png"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">允许不太安全的应用程序(作者自己的)</p></figure></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><h1 id="8db7" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">结论</h1><p id="9f41" class="pw-post-body-paragraph ks kt iq ku b kv mp jr kx ky mq ju la lb ny ld le lf nz lh li lj oa ll lm ln ij bi translated">就是这样！安装完成后，您可以继续开发您的web应用程序。</p><p id="acea" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">你可以在我的<a class="ae kr" href="https://github.com/angeuwase/production-flask-app-setup" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到这个回购。非常欢迎您使用repo，并将其作为完全设置和配置flask web应用程序的起点。如果你这样做，记得添加一个<code class="fe ob oc od ne b">.env</code>文件将你所有的环境变量，因为该文件不会上传到Github。</p></div></div>    
</body>
</html>