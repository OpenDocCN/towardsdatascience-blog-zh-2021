<html>
<head>
<title>Why Multiple Dispatch Is My Favorite Way To Program</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么多重分派是我最喜欢的编程方式</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/why-multiple-dispatch-is-my-favorite-way-to-program-786bf78f4878?source=collection_archive---------10-----------------------#2021-04-03">https://towardsdatascience.com/why-multiple-dispatch-is-my-favorite-way-to-program-786bf78f4878?source=collection_archive---------10-----------------------#2021-04-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e98c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">多种调度的优势概述，以及我为什么这么喜欢它。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/663a26d8c35f1c3060b59fcc55b4cfa8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*36dlC0RllA3g3eV9PpR6ig.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(<a class="ae ky" href="https://unsplash.com/photos/cvBBO4PzWPg" rel="noopener ugc nofollow" target="_blank">https://unsplash.com/photos/cvBBO4PzWPg</a></p></figure><h1 id="e30c" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">简介—一些历史</h1><p id="5b77" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">Julia语言是一项令人难以置信的技术壮举，自2008年以来一直在进行中，并在过去几年中真正取得了进展。这种语言以其独特的范式和编程风格令人兴奋、面向科学，并且使用起来很有趣。要理解Julia编程语言，您需要理解多重分派。</p><p id="f3a5" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">多重分派是一个基于参数多态性的通用编程概念。一般来说，多态性有趣的地方在于，它通常是声明式和函数式编程的一种品质，但是这种品质本身似乎在其他编程范例中有更好的描述。多重分派是Julia编程语言的支柱，但这肯定不是编程概念的起源。多重分派的编程概念实际上最早是在48年前的1973年提出的！第一个实现是用一种叫做ML的小语言实现的，这种语言是由爱丁堡大学的Robert Milner和其他同事发明的。</p><p id="8d9e" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这种语言与我们今天使用的许多高级编程和脚本语言非常相似。ML和许多更具声明性的现代语言之间的最大区别是ML也是一种非常命令式的语言，当你考虑到这种语言也是函数式的时，这似乎有点奇怪。从70年代中期开始，许多语言实际上都遵循这种语调，我认为这是一个有趣的观察。我们总是称赞C++真正发明了泛型的概念，但是在70年代出现了如此多的多范例语言，以至于几乎不可能跟踪它们。</p><h1 id="faa9" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">什么是多重派遣？</h1><p id="dcf4" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">多重分派是一个编程概念，它允许程序员多次编写一个函数来处理不同的类型。许多程序员倾向于远离函数式编程范式，因为它具有全局范围。这是可以理解的，让一切全球化，尤其是像Julia这样的出口，可能会很成问题。这主要是因为命名。实际上，很久以前我写过一篇关于Julia语言中的名称空间的文章，在那里我讨论了为什么一个类似于C++的名称空间的实现可以减轻这个问题。我认为这是一个有趣的阅读，如果你想看看你可以在这里:</p><div class="ms mt gp gr mu mv"><a rel="noopener follow" target="_blank" href="/julias-big-problem-with-namespace-996d2e9ed71e"><div class="mw ab fo"><div class="mx ab my cl cj mz"><h2 class="bd iu gy z fp na fr fs nb fu fw is bi translated">Julia关于名称空间的大问题</h2><div class="nc l"><h3 class="bd b gy z fp na fr fs nb fu fw dk translated">作为一名Julia开发者，这是一个可能会影响你的重大问题。</h3></div><div class="nd l"><p class="bd b dl z fp na fr fs nb fu fw dk translated">towardsdatascience.com</p></div></div><div class="ne l"><div class="nf l ng nh ni ne nj ks mv"/></div></div></a></div><p id="a339" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这个问题在函数中尤其普遍。这是因为Julia不是一种面向对象的语言，因此没有一个真正的类作用域，我们可以使用它来使函数私有，以便处理特定的类型，我们只是编写方法来将我们的类型放入全局作用域中。这意味着很多时候我们可能有名字完全不同的方法，却做着完全相同的事情。当然，在朱丽亚身上完全不是这样，之所以不是这样，是因为多次派遣。</p><p id="c85f" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">多重分派是一种我们可以将函数调用作为类型属性来应用的方式。换句话说，我们可以一次又一次地重新定义同一个函数，但只是计划不同的类型通过它，以便从本质上重新创建方法来处理新的类型。考虑下面的例子。</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="1191" class="np la it nl b gy nq nr l ns nt">x = [1, 2, 3, 4, 5]<br/>y = 5<br/>function add_5(x)<br/>    x + 5</span><span id="aec7" class="np la it nl b gy nu nr l ns nt">end</span></pre><p id="22cd" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">上面的函数给作为x传递的参数加了5，对于这个例子，我们只能通过这个函数传递y。如果我们试图通过这个函数传递x，我们会很快意识到没有匹配+(Array，Int64)的方法。这当然是因为我们没有办法把一个整数加到数组中。我们也不想草率地用另一个名字写另一个函数，就像这样:</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="fea7" class="np la it nl b gy nq nr l ns nt">function add_5_array(x)<br/>     [x += 5 for x in array]<br/>end</span></pre><p id="d7ec" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">那太荒谬了。幸运的是，多重分派正是为了解决这个问题而产生的。使用dispatch，我们可以将一个类型转换为这两个函数的参数，当该类型通过函数传递时，只有该特定类型的函数才会运行。</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="08cb" class="np la it nl b gy nq nr l ns nt">function add_5(x::Array)<br/>     [x += 5 for x in array]<br/>end</span><span id="44d9" class="np la it nl b gy nu nr l ns nt">function add_5(x::Int64)<br/>    x + 5</span><span id="c33d" class="np la it nl b gy nu nr l ns nt">end</span></pre><p id="1469" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">现在我们可以毫无顾虑地让x和y通过这里。</p><h1 id="4a3e" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">朱莉娅的现代调度</h1><p id="8a43" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">multiple的Julian实现类似于典型的multiple dispatch，但是使用了类固醇。我们不仅获得了能够在一行中非常快速地调用多个分派的额外好处，就像我们在用Python编写lambda表达式一样，我们还可以选择以两种方式交替编写函数。此外，朱莉娅有更多的锦囊妙计，使多重调度更好。</p><p id="29bf" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">给Julia的调度增加美感的第一件事是创建子类型的能力。在Julia中，大多数类型都属于一种叫做超类型层次结构的东西。超类型层次结构只允许我们跨具有相似类型的方法创建继承，并且可以由这些函数以相同的方式处理。例如，假设我们有一个可以接受无理数、整数或浮点数的函数。我们可以通过简单地从我们的函数中分派实类型来限制这将到达树的哪一部分。</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="255a" class="np la it nl b gy nq nr l ns nt">add5(x::Real) = x + 5</span></pre><p id="2cdc" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们也可以在这个函数的使用中包括复杂类型，取而代之的是沿着树向上并调用所有的数字:</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="6447" class="np la it nl b gy nq nr l ns nt">add5(x::Number) = x + 5</span></pre><p id="bd6e" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这意味着我们不仅可以分派我们的类型，还可以让其他类型继承我们分派给抽象类型的那些函数。如果你想了解更多关于我刚刚提到的数字层级的知识，我有一整篇文章，你可以在这里阅读:</p><div class="ms mt gp gr mu mv"><a rel="noopener follow" target="_blank" href="/julia-and-imaginary-numbers-the-numerical-hierarchy-694aef87a7ce"><div class="mw ab fo"><div class="mx ab my cl cj mz"><h2 class="bd iu gy z fp na fr fs nb fu fw is bi translated">朱莉娅和虚数:数字等级</h2><div class="nc l"><h3 class="bd b gy z fp na fr fs nb fu fw dk translated">对朱莉娅如何处理数字的深入探究。</h3></div><div class="nd l"><p class="bd b dl z fp na fr fs nb fu fw dk translated">towardsdatascience.com</p></div></div><div class="ne l"><div class="nv l ng nh ni ne nj ks mv"/></div></div></a></div><p id="7ee0" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">Julia令人敬畏的内部构造函数为dispatch增添了美感。内部构造函数允许您创建多个输入来实现相同的输出。这些基本上是初始化函数，可以接受任意数量的参数，然后从提供的参数中构造应用它们的类型。真正酷的是，dispatch会注意是否有人在调用内部或外部构造函数，所以您仍然可以使用普通参数创建类型，但您也可以使用新参数创建它。考虑下面的例子:</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="24e4" class="np la it nl b gy nq nr l ns nt">mutable struct broken_array<br/>    dim1<br/>    dim2<br/>end</span></pre><p id="a36d" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这里我们有一个新的类型叫做broken_array。为了从两元素数组中构造这种类型，我们需要填充dim1和dim2数据值。我们当然可以这样做:</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="5120" class="np la it nl b gy nq nr l ns nt">array = [5, 2]<br/>broken = broken_array(array[1], array[2])</span></pre><p id="f3df" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">然而，这对于终端用户来说有些不方便。我们可以用内部构造函数来解决这个问题，就像这样:</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="dbc2" class="np la it nl b gy nq nr l ns nt">mutable struct broken_array<br/>    dim1::Int64<br/>    dim2::Int64</span><span id="a490" class="np la it nl b gy nu nr l ns nt">    function broken_array(x::Array)<br/>        new(x[1], x[2])</span><span id="9870" class="np la it nl b gy nu nr l ns nt">    end<br/>end</span></pre><p id="910e" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们之前执行的旧调用仍然会被调度来通过调用外部构造函数直接创建类型，但是现在我们有了扩展的功能，可以像这样用我们的数组调用内部构造函数。</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="fefc" class="np la it nl b gy nq nr l ns nt">broken = broken_array(array)</span></pre><blockquote class="nw"><p id="0be0" class="nx ny it bd nz oa ob oc od oe of mm dk translated">很酷，对吧？</p></blockquote><p id="f502" class="pw-post-body-paragraph lr ls it lt b lu og ju lw lx oh jx lz ma oi mc md me oj mg mh mi ok mk ml mm im bi translated">另一个很棒的事情是，它还使得语言中的所有类型和方法都具有难以置信的可扩展性。我们可以从任何包中取出任何类型或任何方法，直接导入，并扩展它做我们想做的任何事情。类型的内部构造函数甚至也不需要在构造函数中，所以我们可以真正利用和编写函数来创建其他包中已经存在的类型，并在任何地方使用它们。此外，我们甚至可以用自己的类型扩展其他方法。一个非常酷的结果是，Julia中的所有包经常使用相同的一组基方法，而你可能习惯于使用完全不同的类型。</p></div><div class="ab cl ol om hx on" role="separator"><span class="oo bw bk op oq or"/><span class="oo bw bk op oq or"/><span class="oo bw bk op oq"/></div><div class="im in io ip iq"><h1 id="1e2e" class="kz la it bd lb lc os le lf lg ot li lj jz ou ka ll kc ov kd ln kf ow kg lp lq bi translated">结论</h1><p id="33b1" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在我工作和涉足的所有编程语言中，Julia很容易成为我最喜欢的编程语言。这是多次调度的直接结果。Julia语言中的多重分派概念不仅允许一些非常激进和富于表现力的编程，而且允许对该语言中使用的任何方法或类型进行扩展。不用说，这是一个非常强大的概念。此外，这也是科学编程的一个好方法，因为方法调用和函数定义经常看起来就像在论文中一样。非常感谢您阅读我的文章，并希望它可能会使您倾向于检查出美妙的礼物是多派遣！</p></div></div>    
</body>
</html>