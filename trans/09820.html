<html>
<head>
<title>The Basics of Hash Table</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">哈希表的基础</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/the-basics-of-hash-table-87d759bb0e36?source=collection_archive---------24-----------------------#2021-09-14">https://towardsdatascience.com/the-basics-of-hash-table-87d759bb0e36?source=collection_archive---------24-----------------------#2021-09-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a426" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">哈希表基本上是一种提供快速插入、查找和删除的数据结构</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/23d12d4f94a56706b731f14e0ae7af69.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*WFeQnRWMqFYNo3r5"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@rssemfam?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">拉斯沃德</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="4f62" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们这些活得够长的人一定知道或者至少看过黄页。没错。你说得对。它是一本厚厚的黄皮书，里面有企业名录和它们的电话号码。这使我们能够寻找销售我们所需商品的商家，并与他们联系。</p><p id="bd2b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">(我不认为Z世代和之后的几代人会知道这本厚厚的黄皮书。😆)</p><p id="5518" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">电话号码簿通常是按字母顺序排列的，所以我们知道从哪里开始查找。一旦我们找到我们想要的企业名称，我们就可以拿到电话号码并给他们打电话。你明白了。💡</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mc"><img src="../Images/646458265f12696a7cc80c0cbaee15b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*re1cjGr2Ds_91VQ_"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@fotosushi?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Foto Sushi </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><h1 id="e4a2" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">哈希表</h1><p id="8d8f" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">如果我告诉你黄页或者电话簿是哈希表的一种实现呢？你打赌！🐴</p><p id="7205" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">哈希表本质上是一个与哈希函数耦合的数组。它通常用于以无序的方式存储键值数据，例如，企业及其电话号码、学生及其成绩、项目及其价格等等。</p><p id="eb7a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每个键必须是唯一的，并映射到数组中的特定索引，其值存储在该位置。🔑 ➡🚪注意，正因为如此，插入、搜索和删除操作都是⚡️速度。事实上，哈希表的插入、搜索和删除操作的平均时间复杂度是常数时间或<code class="fe na nb nc nd b">O(1)</code>。</p><p id="b196" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，当您需要一个提供快速插入、查找和删除的数据结构时，哈希表是首选之一。当您有大量的关系键值数据时，这非常有用，例如在数据科学和/或机器学习算法中。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="ee81" class="md me it bd mf mg ne mi mj mk nf mm mn jz ng ka mp kc nh kd mr kf ni kg mt mu bi translated">散列函数</h1><p id="ffa4" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">哈希函数使得哈希表成为一种强大而有用的数据结构。哈希函数接受一段数据，或者通常称为一个键，并返回一个哈希代码作为输出。这个散列码是一个整数，然后被映射到数组中的一个索引，该值将存储在数组中。</p><p id="6048" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">哈希代码不直接与数组中的索引相关联的原因之一是因为哈希代码的值可能非常大，例如<code class="fe na nb nc nd b">10000000</code>，而我们想要存储的键值数据量(或者构成哈希表的数组的大小)可能不一定那么大。</p><p id="7d2f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将散列码映射到数组中的索引的一种简单方法是根据散列表的大小应用模运算。</p><pre class="kj kk kl km gt nj nd nk nl aw nm bi"><span id="74f4" class="nn me it nd b gy no np l nq nr">index = hashCode(String key) % length(array)</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="dfbb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来看一个散列函数的例子。</p><pre class="kj kk kl km gt nj nd nk nl aw nm bi"><span id="1362" class="nn me it nd b gy no np l nq nr"><em class="ns">function int hashCode(String s) {<br/>  return s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]<br/>}</em></span></pre><p id="2cdb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是Java <code class="fe na nb nc nd b">String</code>对象使用的哈希函数，其中<code class="fe na nb nc nd b">s</code>是<code class="fe na nb nc nd b">String</code>对象的字符数组，例如<code class="fe na nb nc nd b">s[0]</code>是第一个字符，<code class="fe na nb nc nd b">n</code>是<code class="fe na nb nc nd b">String</code>对象的长度。让我们看看它的实际效果。</p><pre class="kj kk kl km gt nj nd nk nl aw nm bi"><span id="8cf5" class="nn me it nd b gy no np l nq nr">hashCode("Apple") // 63476538<br/>hashCode("Costco") // 2024204569<br/>hashCode("Ikea") // 2280798<br/>hashCode("Snowflake") // 1973786418</span></pre><p id="d35f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从☝️的几个例子中可以注意到，散列函数为每个<code class="fe na nb nc nd b">String</code>对象输出不同的散列码值。如前所述，每个键都应该是唯一的，因此哈希函数也应该为每个键生成唯一的哈希代码。这将为键值数据在哈希表中均匀分布提供更好的机会。</p><p id="187d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，让我们将散列码映射到数组中的索引。</p><pre class="kj kk kl km gt nj nd nk nl aw nm bi"><span id="c896" class="nn me it nd b gy no np l nq nr">function int mapToIndex(int hashCode, int arraySize) {<br/>  return abs(hashCode % arraySize)<br/>}</span><span id="df6e" class="nn me it nd b gy nt np l nq nr">// Let's assume the size of our hash table or the length of the array is 500</span><span id="2e30" class="nn me it nd b gy nt np l nq nr">hashTable = Array(500)</span><span id="c8c4" class="nn me it nd b gy nt np l nq nr">mapToIndex(hashCode("Apple"), size(hashTable)) // 38<br/>mapToIndex(hashCode("Costco"), size(hashTable)) // 69<br/>mapToIndex(hashCode("Ikea"), size(hashTable)) // 298<br/>mapToIndex(hashCode("Snowflake"), size(hashTable)) // 418</span></pre><p id="e2b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">按照☝️的说法，苹果的数据将位于索引38，好事多的数据位于索引69，宜家的数据位于索引298，雪花的数据位于索引418。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nu"><img src="../Images/f61d93534cfcce5ed4071d4e10cea184.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*--29Ih5TO-Rj2dk-"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@soberanes?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">乌列尔·索伯兰斯</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><h1 id="aae2" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">碰撞</h1><p id="dda7" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">在上一节中，我们看了一个如何使用hash函数来确定特定键值数据在哈希表中的位置的示例。现在，让我们看看另一个散列函数的例子。</p><pre class="kj kk kl km gt nj nd nk nl aw nm bi"><span id="dd1e" class="nn me it nd b gy no np l nq nr"><em class="ns">function int hashCode(int i) {<br/>  return i % 5<br/>}</em></span></pre><p id="2655" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个哈希函数将一个整数作为输入，并应用模运算来输出哈希代码。现在，让我们用几个整数输入来测试一下。</p><pre class="kj kk kl km gt nj nd nk nl aw nm bi"><span id="78ba" class="nn me it nd b gy no np l nq nr">hashCode(1) // 1<br/>hashCode(5) // 0<br/>hashCode(11) // 1</span></pre><p id="55a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">等一下。散列码不是应该对每个键都不同吗？在这种情况下，我们选择的散列函数对于我们可能拥有的可能的键来说可能并不理想。它为不同的输入值生成相同的哈希码，即输入值1和11将返回哈希码1，这意味着它们将被映射到数组中的相同位置。这种现象叫做<strong class="lb iu">碰撞</strong>。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nv"><img src="../Images/ba687e1f2ef89e5991f5a12e356b0b69.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*E0GiOGjV17lVlY7p"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@barnimages?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">谷仓图片</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><h1 id="5458" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">处理冲突的两种方法</h1><p id="3e83" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">有两种常见的方法用于处理哈希表中的冲突:</p><ul class=""><li id="ca17" class="nw nx it lb b lc ld lf lg li ny lm nz lq oa lu ob oc od oe bi translated">线性探测</li><li id="dee2" class="nw nx it lb b lc of lf og li oh lm oi lq oj lu ob oc od oe bi translated">单独链接</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ok"><img src="../Images/311626b130f1d838931c4aef44395e08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*JMvs3VKuJ38KCm3u"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Clark Van Der Beken 在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h2 id="a0a1" class="nn me it bd mf ol om dn mj on oo dp mn li op oq mp lm or os mr lq ot ou mt ov bi translated">线性探测</h2><p id="7daf" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">在线性探测中，我们通过在由哈希函数确定的假定位置之后搜索数组中最近的可用空间来处理哈希表中的冲突。让我们使用上一节中的冲突示例来想象一下，输入值1和11会产生相同的哈希代码。</p><p id="a5c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们将1-Apple的键值数据插入到哈希表中。哈希函数返回哈希代码1，我们假设它映射到数组中的索引1。现在，数组中的索引1包含1-Apple的键值数据。</p><p id="fd84" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们要将11-Orange的键值数据添加到哈希表中。哈希函数返回哈希代码1，它也映射到索引1，但是，此时，数组的索引1中的块已经被键值数据1-Apple占用。</p><p id="7821" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，线性探测将在数组中寻找最近的空闲位置，并在那里存储键值数据11-Orange。当我们希望从键等于11的哈希表中检索数据时，情况也是如此。线性探测将首先找到键值数据1-Apple，然后继续在相邻位置搜索，直到在数组中找到与键11匹配的块或空块，这表明键11不存在。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ow"><img src="../Images/6343b95f265ae57891e654b79c78dce6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*RIOjwvwCRuZJ87BT"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@kar111?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">郭佳欣·阿维蒂西安</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><h2 id="5a8d" class="nn me it bd mf ol om dn mj on oo dp mn li op oq mp lm or os mr lq ot ou mt ov bi translated">单独链接</h2><p id="6f75" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">当使用分离链接方法时，哈希表将在链表中存储键值数据。这意味着数组中的每个块都包含一个链表，而不仅仅是一个键值数据。</p><p id="bd67" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，在发生冲突时，不是像线性探测那样寻找数组中的下一个空闲块，而是将键值数据添加到链表中。</p><p id="b2ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，以上一节中的冲突示例为例，单独链接将在数组的索引1处的链表中存储1-Apple和11-Orange键-值对，其中链表的头将是1-Apple，因为它被添加在11-Orange之前。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="b011" class="md me it bd mf mg ne mi mj mk nf mm mn jz ng ka mp kc nh kd mr kf ni kg mt mu bi translated">好的散列函数的特征</h1><p id="cdb8" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">基于我们到目前为止所了解的，我们可以推断出一个好的散列函数应该具有以下特性。</p><h2 id="f4c5" class="nn me it bd mf ol om dn mj on oo dp mn li op oq mp lm or os mr lq ot ou mt ov bi translated">利用数据中的每一条信息</h2><p id="f003" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">好的散列函数应该利用数据的每个元素，以便增加可能的散列码的数量。</p><p id="92bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看下面的例子。</p><pre class="kj kk kl km gt nj nd nk nl aw nm bi"><span id="3778" class="nn me it nd b gy no np l nq nr"><em class="ns">function int hashCode(String k) {<br/>  String s = k.substring(start=0, end=2)</em></span><span id="8b99" class="nn me it nd b gy nt np l nq nr"><em class="ns">  return s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]<br/>}</em></span></pre><p id="db62" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个散列函数接受一个类型为<code class="fe na nb nc nd b">String</code>的输入数据，取前3个字符并应用Java <code class="fe na nb nc nd b">String</code>对象使用的散列函数。您可以想象，对于前三个字符相同的数据，例如apple和application，会发生冲突。</p><p id="6723" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，并不是所有的信息都用来生成散列码。如您所见，冲突的可能性更大，因为可用的哈希代码更少。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="06fd" class="nn me it bd mf ol om dn mj on oo dp mn li op oq mp lm or os mr lq ot ou mt ov bi translated">非常快的计算</h2><p id="554d" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">我们使用哈希表的原因之一是它的插入、查找和删除速度。每个操作都依赖哈希函数来获得哈希代码，从而获得数据在数组中的位置。</p><p id="83c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我们要确保我们的哈希函数超级快，以便提供我们在哈希表中寻找的速度。</p><p id="80d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这意味着我们应该避免使用复杂或缓慢操作的散列函数，并致力于快速、简单而有效的操作。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="42b2" class="nn me it bd mf ol om dn mj on oo dp mn li op oq mp lm or os mr lq ot ou mt ov bi translated">在表中均匀分布数据</h2><p id="d9a5" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">对于我们的哈希函数来说，最理想的情况是将数据均匀地分布在哈希表中。如果散列函数没有均匀地分布数据，那么发生冲突的可能性就更大。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ox"><img src="../Images/bfbf602172b73a8c80fca5a876aeb435.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*OI_iDVm_3ci0Tg9w"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@englr?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">阿尔文·恩格勒</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h1 id="6da6" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">摘要</h1><p id="4388" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">我们已经学习了哈希表的基础知识，包括它的结构，哈希函数是什么和做什么，冲突以及处理冲突的方法。下次当你面临一个需要快速查找、插入和删除的问题时，哈希表可能是你解决它的最佳选择。😺</p></div></div>    
</body>
</html>