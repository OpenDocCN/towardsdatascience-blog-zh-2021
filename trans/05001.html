<html>
<head>
<title>Simple Physics Animations Using VPython</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用VPython的简单物理动画</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/simple-physics-animations-using-vpython-1fce0284606?source=collection_archive---------11-----------------------#2021-05-02">https://towardsdatascience.com/simple-physics-animations-using-vpython-1fce0284606?source=collection_archive---------11-----------------------#2021-05-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="510b" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/hands-on-tutorials" rel="noopener" target="_blank">实践教程</a></h2><div class=""/><div class=""><h2 id="c4e5" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">使用Python和GlowScript创建3D物理模拟，以模拟带电粒子在磁场中的螺旋运动</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/e607fcda9531444b8626a5e459d6d8ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*XCghEtYAh9AASmmG"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">摄影:<a class="ae le" href="https://unsplash.com/@flyd2069?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">飞:D </a>上<a class="ae le" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></p></figure><p id="2a5f" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">在现实生活中，进行物理实验可能具有挑战性，通常涉及昂贵而又嘈杂的设备。随着今天的实验变得越来越复杂，模拟和建模已经成为产生和解释数据的一个有吸引力的新领域。本文旨在让您开始使用VPython——一种用于模拟的3D Python环境——对物理系统建模。</p><h2 id="534c" class="mb mc iq bd md me mf dn mg mh mi dp mj lo mk ml mm ls mn mo mp lw mq mr ms iw bi translated">模拟带电粒子在磁场中的运动</h2><p id="3a77" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">今天，我们要看看带电粒子是如何在磁场中运动的。电磁学是对电场和磁场如何相互作用的研究。当带电粒子以垂直于外部磁场的速度运动时，它执行圆周运动，因为恒定垂直于速度的磁力充当圆周运动的向心力。</p><p id="8605" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">如果速度不完全垂直于磁场呢？这意味着垂直于磁场的速度分量将继续为带电粒子做圆周运动提供向心的力。另一方面，平行于磁场的速度分量既不会经历任何向心加速度，也不会经历任何方向变化。因此，我们将观察到如下所示的螺旋路径。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi my"><img src="../Images/939d4865161f45249b405a13f2d571d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:280/format:webp/1*uyaQVdop98g523c5iHqmMA.png"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">带电粒子在磁场中的螺旋运动(图片由作者提供)</p></figure><h2 id="c339" class="mb mc iq bd md me mf dn mg mh mi dp mj lo mk ml mm ls mn mo mp lw mq mr ms iw bi translated">VPython简介</h2><p id="9d87" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">我们将使用VPython来重现这一物理现象。VPython允许我们对这一现象进行3D可视化。我们将使用GlowScript，这是一个用于VPython的在线代码编辑器。您可以在此处访问它:</p><div class="mz na gp gr nb nc"><a href="https://glowscript.org/" rel="noopener  ugc nofollow" target="_blank"><div class="nd ab fo"><div class="ne ab nf cl cj ng"><h2 class="bd ja gy z fp nh fr fs ni fu fw iz bi translated">GlowScript IDE</h2><div class="nj l"><h3 class="bd b gy z fp nh fr fs ni fu fw dk translated">GlowScript是一个易于使用、功能强大的环境，用于创建3D动画并将其发布到web上。在这里…</h3></div><div class="nk l"><p class="bd b dl z fp nh fr fs ni fu fw dk translated">glowscript.org</p></div></div><div class="nl l"><div class="nm l nn no np nl nq ky nc"/></div></div></a></div><p id="5f1c" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">点击链接后，点击“登录”并使用您的Google帐户登录。然后在GlowScript页面点击“此处”按钮，再点击“创建新程序”即可开始！或者，您可能希望在本地运行VPython，在这种情况下，您必须导入VPython模块。完整的VPython / Glowscript文档可以在<a class="ae le" href="https://www.glowscript.org/docs/VPythonDocs/index.html" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><h2 id="ea50" class="mb mc iq bd md me mf dn mg mh mi dp mj lo mk ml mm ls mn mo mp lw mq mr ms iw bi translated">创造环境</h2><p id="c484" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">在我们开始处理任何运动的粒子之前，我们首先要定义我们的工作空间。下面的代码展示了我们如何通过定义画布的大小在VPython中创建场景。</p><pre class="kp kq kr ks gt nr ns nt nu aw nv bi"><span id="5e34" class="mb mc iq ns b gy nw nx l ny nz">scene = display(width=1500, height=600)</span></pre><p id="e5e1" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">首先，我们要开始定义我们实验的边界。我们将在一个封闭的容器中进行实验，这个容器由一个立方体的各个侧面组成。换句话说，我们将绘制自己的容器。</p><pre class="kp kq kr ks gt nr ns nt nu aw nv bi"><span id="bcde" class="mb mc iq ns b gy nw nx l ny nz">xlen, ylen , zlen = 100, 100, 100<br/>boundaries = [<br/>    box(pos = vector(0,-ylen/2,0), size = vector(xlen, .2, zlen)),<br/>    box(pos = vector(0,ylen/2,0), size = vector(xlen, .2, zlen)),<br/>    box(pos = vector(-xlen/2,0,0), size = vector(.2, ylen, zlen)),<br/>    box(pos = vector(xlen/2,0,0), size = vector(.2, ylen, zlen)),<br/>    box(pos = vector(0,0,-zlen/2), size = vector(xlen, ylen, .2))<br/>    ]</span></pre><p id="2382" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">这里，我们将立方体容器的长度标准化为100个单位。我们还定义了一系列盒子(即长方体)来构成我们的容器的侧面。让我们来看看“盒子”中的每个参数是做什么的:</p><ul class=""><li id="362f" class="oa ob iq lh b li lj ll lm lo oc ls od lw oe ma of og oh oi bi translated"><em class="oj"> pos </em>参数接受一个向量，它表示盒子中心的位置向量。</li><li id="4a6d" class="oa ob iq lh b li ok ll ol lo om ls on lw oo ma of og oh oi bi translated"><em class="oj">大小</em>参数接受另一个向量，它接受3个值，分别是盒子在x、y和z轴上的长度。请注意，对于每个盒子，其中一个轴的边长为0.2个单位，这表示我们容器的厚度。</li></ul><p id="0550" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">万岁！现在我们有了一个容器来进行实验。在我们开始实际创建对象之前，让我们定义几个物理常数。这些常量背后的含义将在后面的章节中详细阐述，但是在这一点上对这些值的作用有一个粗略的概念就足够了。</p><pre class="kp kq kr ks gt nr ns nt nu aw nv bi"><span id="01f9" class="mb mc iq ns b gy nw nx l ny nz">dt = .001 #time step<br/>Bfield = 5 #strength of magnetic field<br/>v_mag = 20 # magnitude of velocity of proton<br/>Q = 0.5 #charge of proton in arbitrary units<br/>theta = pi/4 #angle of launch of proton<br/>v = vector(v_mag*cos(theta), v_mag*sin(theta), 0) #velocity vector<br/>B = vector(0,-Bfield,0) #vector of magnetic field<br/>starting_point = vector(0,-ylen/2 + 1,0) #starting position vector of proton </span></pre><h2 id="a1a9" class="mb mc iq bd md me mf dn mg mh mi dp mj lo mk ml mm ls mn mo mp lw mq mr ms iw bi translated">使用Python类定义对象</h2><p id="2a16" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">在下一部分，我们将使用Python类来表示质子在磁场中的运动。</p><pre class="kp kq kr ks gt nr ns nt nu aw nv bi"><span id="30b2" class="mb mc iq ns b gy nw nx l ny nz">class create_proton:<br/>    def __init__(self, v): #v is a vector representing velocity<br/>        self.v = v<br/>        self.proton = sphere(pos = starting_point, color = color.red, radius = 1, make_trail=True, trail_type="curve")<br/>        self.a = vector(0,0,0)<br/>    <br/>    def move(self): #moves proton by small step<br/>        self.a = Q * cross(self.v, B) # F = ma = q v x B<br/>        self.v += self.a * dt #a = dv/dt<br/>        self.proton.pos += self.v * dt #v = dx/dt<br/>    <br/>    def reset_proton(self): #resets proton position and path<br/>        self.proton.pos = starting_point <br/>        self.v = v<br/>        self.proton.clear_trail()<br/>        self.a = vector(0,0,0)<br/>        <br/>    def check_collision(self): #checks for boundaries<br/>        if self.proton.pos.y &lt; ylen / 2 and self.proton.pos.x &lt; xlen/2 and self.proton.pos.y &gt; -ylen/2 and self.proton.pos.x &gt; -xlen/2 and self.proton.pos.z &gt; -zlen/2 and self.proton.pos.z &lt; zlen/2:<br/>            return True<br/>        else:<br/>            return False</span><span id="7d2d" class="mb mc iq ns b gy op nx l ny nz">proton = create_proton(v) #creates the variable 'proton'</span></pre><p id="d063" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">在上面的create_proton类中有4个函数。以下是它们的功能:</p><ul class=""><li id="355d" class="oa ob iq lh b li lj ll lm lo oc ls od lw oe ma of og oh oi bi translated"><em class="oj"> __init__ </em></li></ul><p id="5d00" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">这个函数将在创建类时被调用。这将质子的默认速度向量设置为self.v。我们还创建了质子，它在VPython中建模为球体。我们定义了质子的半径，并打开了在质子路径后面绘制轨迹的设置。</p><ul class=""><li id="4429" class="oa ob iq lh b li lj ll lm lo oc ls od lw oe ma of og oh oi bi translated"><em class="oj">移动</em></li></ul><p id="f1ec" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">这个函数在特定的时间点以小的增量移动质子。加速度(self.a)是根据洛伦兹力定律计算出来的，该定律表述为<em class="oj">F</em>=<em class="oj">Q</em>(<strong class="lh ja"><em class="oj">v</em></strong>x<strong class="lh ja"><em class="oj">B</em></strong>)。因此，我们使用矢量<strong class="lh ja"> <em class="oj"> v </em> </strong>和<strong class="lh ja"> <em class="oj"> B </em> </strong>的叉积来计算合成加速度及其方向。不需要分解速度的单个分量。这也是我们的时间步长发挥作用的地方，因为我们每次移动质子一小步，我们逐渐更新速度和位移。因此，我们将小时间步长<em class="oj"> dt </em>乘以质子的位移和速度。</p><p id="7e11" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">基于上面定义的矢量<strong class="lh ja"> <em class="oj"> B </em> </strong>，假设磁场指向下方。初速度<strong class="lh ja"> v </strong>也由之前定义的角度<em class="oj">θ</em>(θ)决定。</p><ul class=""><li id="4177" class="oa ob iq lh b li lj ll lm lo oc ls od lw oe ma of og oh oi bi translated"><em class="oj">复位_质子</em></li></ul><p id="cea5" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">该函数重置所有参数，以便我们可以在以后多次运行该实验。</p><ul class=""><li id="204b" class="oa ob iq lh b li lj ll lm lo oc ls od lw oe ma of og oh oi bi translated"><em class="oj">检查_碰撞</em></li></ul><p id="3f8d" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">如果与容器壁没有碰撞，函数返回True。如果不是，则返回False，程序终止。</p><p id="8e60" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">此时，如果您点击“运行此程序”，您将看到以下布局:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/6d5a1dc9bdb8461981467bc0e74774b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1124/format:webp/1*4P8tOM5UEhrEhkElZJ1JBQ.png"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">底部有红色球体质子的3D盒子(图片由作者提供)</p></figure><p id="1aa9" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">你可以按住鼠标右键拖动盒子。</p><h2 id="24e1" class="mb mc iq bd md me mf dn mg mh mi dp mj lo mk ml mm ls mn mo mp lw mq mr ms iw bi translated">启动功能</h2><p id="054b" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">下面我们定义主启动函数，它执行我们实验的一个实例。首先，我们重置系统中的所有变量，当质子不与容器的任何壁碰撞时，我们在等待每个小的时间步长dt后移动质子。时间步长的设置是为了提高算法的效率。</p><pre class="kp kq kr ks gt nr ns nt nu aw nv bi"><span id="080b" class="mb mc iq ns b gy nw nx l ny nz">def launch():<br/>    proton.reset_proton()<br/>    while proton.check_collision():<br/>        rate(1/dt) #basically a delay function<br/>        proton.move()</span></pre><p id="b62b" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">之后，我们创建一个启动按钮，这样我们就可以按下它来开始实验。该按钮的代码如下:</p><pre class="kp kq kr ks gt nr ns nt nu aw nv bi"><span id="d99c" class="mb mc iq ns b gy nw nx l ny nz">button(text="Launch!", bind=launch) #link the button and function</span></pre><h2 id="d67d" class="mb mc iq bd md me mf dn mg mh mi dp mj lo mk ml mm ls mn mo mp lw mq mr ms iw bi translated">使用滑块调整参数</h2><p id="85f6" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">在任何实验中，当我们这样做时，我们希望能够改变我们的参数来观察趋势。滑块在实现这一功能时非常有用。比如下面是调整磁场强度的代码(<strong class="lh ja"> <em class="oj"> B </em> </strong>)。</p><pre class="kp kq kr ks gt nr ns nt nu aw nv bi"><span id="73e5" class="mb mc iq ns b gy nw nx l ny nz">scene.append_to_caption("\n\n") #newlines for aesthetics<br/>def adjustBfield():<br/>    global Bfield #to update global value<br/>    Bfield = BfieldSlider.value<br/>    B = (0,-Bfield,0) #B directed downwards<br/>    BfieldSliderReadout.text = BfieldSlider.value + " Tesla"</span><span id="5869" class="mb mc iq ns b gy op nx l ny nz">BfieldSlider = slider(min=0, max=10, step=.5, value=5,<br/>bind=adjustBfield)<br/>scene.append_to_caption(" B-field Strength = ")<br/>BfieldSliderReadout = wtext(text="5 Tesla")</span></pre><p id="8315" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">该函数接收滑块的输入，并更新代码中的磁场强度值。当滑块被调整时，函数<em class="oj">adjust field</em>将被调用，代码中的所有值将被更新。屏幕上显示的<strong class="lh ja"> B </strong>的值也会更新。创建滑块时，还可以指定滑块的范围和间隔。如果你想改变这些参数，你可以参考滑块的文档:<a class="ae le" href="https://www.glowscript.org/docs/VPythonDocs/controls.html" rel="noopener ugc nofollow" target="_blank">https://www.glowscript.org/docs/VPythonDocs/controls.html</a>。</p><p id="5d81" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">类似的滑块可以用于充电量(<em class="oj"> Q </em>)和发射角度(<em class="oj"> θ </em>)，下面已经提供了相关的代码。</p><pre class="kp kq kr ks gt nr ns nt nu aw nv bi"><span id="b30f" class="mb mc iq ns b gy nw nx l ny nz">#Adjust charge Q<br/>scene.append_to_caption("\n\n")<br/>def adjustQ():<br/>    global Q<br/>    Q = QSlider.value<br/>    QSliderReadout.text = QSlider.value + " Coulumbs"</span><span id="44c8" class="mb mc iq ns b gy op nx l ny nz">QSlider = slider(min=0, max=1, step=.1, value=.5,<br/>bind=adjustQ)<br/>scene.append_to_caption(" Q = ")<br/>QSliderReadout = wtext(text="0.5 Coulumbs")</span><span id="fc87" class="mb mc iq ns b gy op nx l ny nz">#Adjust angle theta<br/>scene.append_to_caption("\n\n")<br/>def adjustAngle():<br/>    global theta<br/>    theta = angleSlider.value * pi / 180 #degree - radian conversion<br/>    angleSliderReadout.text = angleSlider.value + " degrees"<br/>    proton.v = vector(v_mag*cos(theta), v_mag*sin(theta), 0)<br/>    <br/><br/>angleSlider = slider(min=0, max=90, step=1, value=45,<br/>bind=adjustAngle)<br/>scene.append_to_caption(" Angle = ")<br/>angleSliderReadout = wtext(text="45 degrees")</span></pre><p id="c1e1" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">构建滑块后，它们应该出现在画布下方，如下所示:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi or"><img src="../Images/88f71f6e3366dacc741757129f8cb13e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1194/format:webp/1*Ug02Vqt6iiD5N6Tra8B6nQ.png"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">启动按钮和滑块来调整实验参数(图片由作者提供)</p></figure><p id="73e1" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">您可以拖动滑块来修改参数，以改变质子的路径。</p><h2 id="e1cb" class="mb mc iq bd md me mf dn mg mh mi dp mj lo mk ml mm ls mn mo mp lw mq mr ms iw bi translated">运行模拟</h2><p id="db54" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">现在，你可以发射质子了！单击“运行该程序”,然后单击您创建的启动按钮。你会注意到质子以螺旋路径运行，就像我们之前学过的一样！</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi os"><img src="../Images/e6d0a96984c2c3927cb94876285a20c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1088/format:webp/1*cHeBYgwJAe3B_yTr5M0INg.png"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">质子的螺旋路径(图片由作者提供)</p></figure><p id="9eda" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">您甚至可以使用滑块试验不同的值，并创建不同半径和螺距的螺旋！要尝试模拟，点击<a class="ae le" href="https://glowscript.org/#/user/jzh/folder/PublicFolder/program/HelicalPath" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><div class="kp kq kr ks gt ab cb"><figure class="ot kt ou ov ow ox oy paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><img src="../Images/6b13bcbfa6dc3ab80d6368d336f68b52.png" data-original-src="https://miro.medium.com/v2/resize:fit:1002/format:webp/1*th6KnAVtqWfYnfDYn5zovg.png"/></div></figure><figure class="ot kt oz ov ow ox oy paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><img src="../Images/a629caec0d4b0362ad6a3f719214f7f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*ZF6AVRGm1yH5EO4jQxqWrw.png"/></div><p class="la lb gj gh gi lc ld bd b be z dk pa di pb pc translated">左图:大螺距大半径螺旋路径；右图:螺距和半径较小的螺旋路径(图片由作者提供)</p></figure></div><h2 id="a476" class="mb mc iq bd md me mf dn mg mh mi dp mj lo mk ml mm ls mn mo mp lw mq mr ms iw bi translated">结论</h2><p id="6d16" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">暂时就这样吧！VPython的3D界面允许我们做各种很酷的实验和动画，并广泛用于物理模拟。VPython有许多令人兴奋的应用，这只是其中之一。</p><p id="8682" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">接下来，你可以阅读更多关于如何使用VPython(【https://www.glowscript.org/docs/VPythonDocs/graph.html】)绘制图表的内容，这对生成数据和观察实验趋势非常有用。</p></div></div>    
</body>
</html>