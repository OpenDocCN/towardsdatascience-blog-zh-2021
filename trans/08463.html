<html>
<head>
<title>Automated Machine Learning with Sklearn Pipelines</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Sklearn管道的自动机器学习</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/automated-machine-learning-with-sklearn-pipelines-a2be2a0a6e1?source=collection_archive---------23-----------------------#2021-08-04">https://towardsdatascience.com/automated-machine-learning-with-sklearn-pipelines-a2be2a0a6e1?source=collection_archive---------23-----------------------#2021-08-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ba27" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">一条管道来统治他们。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/2521eee626331fc5de6fa5631268b55e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ntAfxx4Fk5aLKnFZ"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@jjying?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> JJ英</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></p></figure><p id="61e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi lv translated">P  ipelines提供了自动化训练和测试模型的结构。它们可以包含列转换、缩放、插补、特征选择和超参数搜索。</p><p id="4ad3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过将所有这些步骤组合成管道，可以抽象出单独的步骤。</p><blockquote class="me"><p id="a37e" class="mf mg it bd mh mi mj mk ml mm mn lu dk translated">这篇文章展示了如何创建一个包含Sklearn中每个函数的管道。</p><p id="ef8b" class="mf mg it bd mh mi mj mk ml mm mn lu dk translated">**请随意将此页面加入书签以供将来使用* *</p></blockquote><p id="0568" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">使用这个管道，定义您的数据，根据需要更新超参数，然后点击run。</p><p id="b21d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将这些步骤中的每一步抽象成一个管道，使得构建有效模型的整个过程更具可伸缩性。</p><p id="2d62" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，根据构建和测试管道的方式，您可以快速迭代许多不同的估计器、特征选择方法和其他可能提高模型整体性能的方法。</p><p id="13f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当开始一个数据科学项目时，需要管理许多不同的任务。例如，如果不进行大量测试，就不可能知道哪种模型最适合您的问题。</p><p id="b72f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一种常见的方法是从一个简单的模型开始，以提供一个基线性能。我在这篇文章中讨论了应该首先使用什么模型，以及为什么更简单的模型更好:</p><div class="mt mu gp gr mv mw"><a rel="noopener follow" target="_blank" href="/how-to-select-an-initial-model-for-your-data-science-problem-77f7b811bd0"><div class="mx ab fo"><div class="my ab mz cl cj na"><h2 class="bd iu gy z fp nb fr fs nc fu fw is bi translated">如何为您的数据科学问题选择初始模型</h2><div class="nd l"><h3 class="bd b gy z fp nb fr fs nc fu fw dk translated">为自己节省一些时间和麻烦，从简单开始。</h3></div><div class="ne l"><p class="bd b dl z fp nb fr fs nc fu fw dk translated">towardsdatascience.com</p></div></div><div class="nf l"><div class="ng l nh ni nj nf nk ks mw"/></div></div></a></div></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><h1 id="c379" class="ns nt it bd nu nv nw nx ny nz oa ob oc jz od ka oe kc of kd og kf oh kg oi oj bi translated"><strong class="ak">设置</strong></h1><p id="f162" class="pw-post-body-paragraph kz la it lb b lc ok ju le lf ol jx lh li om lk ll lm on lo lp lq oo ls lt lu im bi translated">在这篇文章中，我使用了乳腺癌数据集。但是，管道还将展示列转换功能。因此，数据集用一个用于转换的虚拟分类变量来扩展。</p><p id="6c73" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种改变是通过添加一个随机分类列来完成的。</p><pre class="kj kk kl km gt op oq or os aw ot bi"><span id="b8b8" class="ou nt it oq b gy ov ow l ox oy">import pandas as pd<br/>from scipy.stats import uniform, geom, loguniform, randint, expon<br/>from sklearn import ensemble, neighbors, tree, linear_model, svm, naive_bayes, gaussian_process, feature_selection, preprocessing, impute, metrics, decomposition, compose<br/>from sklearn.model_selection import train_test_split, RandomizedSearchCV<br/>from sklearn.metrics import roc_auc_score<br/>from sklearn.pipeline import make_pipeline, Pipeline as Pipeline<br/>from sklearn.datasets import load_breast_cancer<br/>import itertools<br/>import random<br/>import pickle</span><span id="7534" class="ou nt it oq b gy oz ow l ox oy">TEST_SIZE = 0.1<br/>RANDOM_STATE = 10<br/>data = load_breast_cancer()<br/>df = pd.DataFrame(data.data, columns=data.feature_names)<br/>df['target'] = data.target<br/>X = df.drop(['target'], axis=1)<br/>X['categorical'] = random.choices(['one', 'two', 'three'], k=len(X))<br/>y = df['target'].astype(float)<br/>X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=TEST_SIZE, random_state=RANDOM_STATE, stratify=y)</span></pre><p id="31f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本文中生成的管道是为二进制分类问题而创建的。然而，管道也支持回归问题。</p><p id="5f13" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了针对回归问题调整管道，更新输入的数据、测试中使用的模型和评分标准。然后，管道的其余部分可以保持不变。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pa"><img src="../Images/95a7151d804556288937ab6b918502ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mlrhmmv_Ue1JldGBldqv3A.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">带有随机分类变量的乳腺癌数据集(图片由作者提供)</p></figure><h1 id="de76" class="ns nt it bd nu nv pb nx ny nz pc ob oc jz pd ka oe kc pe kd og kf pf kg oi oj bi translated"><strong class="ak">管道设置</strong></h1><p id="dd5d" class="pw-post-body-paragraph kz la it lb b lc ok ju le lf ol jx lh li om lk ll lm on lo lp lq oo ls lt lu im bi translated">本节旨在从头到尾建立一个完整的管道，涵盖sklearn必须为监督学习提供的每种类型的功能。</p><p id="2c6a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不幸的是，sklearn中的一些函数本质上有无限的可能性。例如，以一个简单的逻辑回归函数为例。理论上，正则化参数是一个连续变量，它使得可能的流水线的数量是无限的。</p><p id="e204" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为sklearn函数本质上有无限的排列，最终的管道将展示监督学习管道中每种类型的至少一个函数。</p><p id="8a70" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，由于最终管道将测试多个模型、特征选择技术、插补方法、缩放器和变换，因此管道的设置与其他示例所示略有不同。</p><p id="29e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，这种设置被设计成易于遵循和根据需要改变组件。</p></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><h1 id="b9b0" class="ns nt it bd nu nv nw nx ny nz oa ob oc jz od ka oe kc of kd og kf oh kg oi oj bi translated"><strong class="ak">元参数</strong></h1><pre class="kj kk kl km gt op oq or os aw ot bi"><span id="20cf" class="ou nt it oq b gy ov ow l ox oy">N_ITER = 1<br/>N_JOBS = 1<br/>K_FOLDS = 10<br/>VERBOSE = 0<br/>SCORING_METRIC = 'roc_auc'<br/>SCORING_FUNCTION = metrics.roc_auc_score<br/>MAX_ITER = 10000<br/>LOGISTIC_REGRESSION_SOLVER = 'sag'<br/>OPTIMAL_MODEL_FILENAME = 'optimal_model.pickle'<br/>categorical_feature_names = ['categorical']<br/>best_score = 0</span></pre><p id="a2e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与超参数相比，元参数控制如何设置问题、如何执行计算以及如何跟踪结果。</p><p id="6f26" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我提供几个选项。</p><ul class=""><li id="3f45" class="pg ph it lb b lc ld lf lg li pi lm pj lq pk lu pl pm pn po bi translated">要改变超参数优化中执行的迭代次数，调整<strong class="lb iu"> N_ITER </strong>。</li><li id="6ea2" class="pg ph it lb b lc pp lf pq li pr lm ps lq pt lu pl pm pn po bi translated">为了改变具有额外计算能力的模型的作业数量，调整<strong class="lb iu"> N_JOBS </strong>。</li><li id="c1cb" class="pg ph it lb b lc pp lf pq li pr lm ps lq pt lu pl pm pn po bi translated">要调整验证的折叠数，请调整<strong class="lb iu"> K_FOLDS </strong>。</li><li id="7297" class="pg ph it lb b lc pp lf pq li pr lm ps lq pt lu pl pm pn po bi translated"><strong class="lb iu"> SCORING_METRIC </strong>是被监督问题的评估指标</li><li id="fae4" class="pg ph it lb b lc pp lf pq li pr lm ps lq pt lu pl pm pn po bi translated"><strong class="lb iu">计分函数</strong>是计分指标的函数。由于管道设置，函数和名称都是必需的。</li><li id="3ca2" class="pg ph it lb b lc pp lf pq li pr lm ps lq pt lu pl pm pn po bi translated"><strong class="lb iu">最大ITER </strong>和<strong class="lb iu">逻辑回归求解器</strong>支持逻辑回归和支持向量机模型的收敛。其他解算器和这些模型的收敛性存在一些问题。这些参数缓解了这些问题。</li><li id="9824" class="pg ph it lb b lc pp lf pq li pr lm ps lq pt lu pl pm pn po bi translated"><strong class="lb iu"> OPTIMAL_MODEL_FILENAME </strong>，存储所有模型类型的最优模型的名称。基于评分标准的最佳分数</li><li id="2a5e" class="pg ph it lb b lc pp lf pq li pr lm ps lq pt lu pl pm pn po bi translated"><strong class="lb iu">分类特征名称</strong>，转换为二元变量的分类特征列表。</li><li id="533b" class="pg ph it lb b lc pp lf pq li pr lm ps lq pt lu pl pm pn po bi translated"><strong class="lb iu"> best_score </strong>，一个跟踪流水线优化的最佳分数的变量。</li></ul></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><h1 id="b6ba" class="ns nt it bd nu nv nw nx ny nz oa ob oc jz od ka oe kc of kd og kf oh kg oi oj bi translated"><strong class="ak">型号</strong></h1><p id="0310" class="pw-post-body-paragraph kz la it lb b lc ok ju le lf ol jx lh li om lk ll lm on lo lp lq oo ls lt lu im bi translated">例如，要测试的模型定义如下。元组列表，其中元组的第一个元素是模型(回归或分类器)，第二个元素是超参数优化期间使用的参数网格。元组的第三个元素是超参数优化期间模型的迭代次数。</p><p id="5b58" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为每个模型的超参数的数量不同，所以为每个模型指定迭代的次数。例如，对于一个随机森林分类，大约有一打不同的超参数。然而，对于逻辑回归，只有几个超参数。因此，寻找最佳模型需要较少的迭代。</p><pre class="kj kk kl km gt op oq or os aw ot bi"><span id="99f0" class="ou nt it oq b gy ov ow l ox oy">models = [<br/>    (ensemble.RandomForestClassifier(),{<br/>    'model__n_estimators': randint(50,500),<br/>    'model__max_depth': randint(3,10),<br/>    'model__max_features': ['sqrt'],<br/>    'model__min_samples_split': randint(2,20),<br/>    'model__min_samples_leaf': randint(1,10),<br/>    'model__criterion': ['gini', 'entropy'],<br/>    'model__ccp_alpha': loguniform(0.1e-5, 0.1e-0)<br/>    }, 1),<br/>    <br/>    (neighbors.KNeighborsClassifier(),{<br/>    'model__n_neighbors': randint(3,20),<br/>    'model__weights': ['uniform', 'distance'],<br/>    'model__algorithm': ['auto', 'ball_tree', 'kd_tree', 'brute']<br/>    }, 1),<br/>    <br/>    (svm.SVC(probability=True, max_iter=MAX_ITER),{<br/>    'model__C': loguniform(3e-4, 3e-1),<br/>    'model__kernel': ['linear', 'poly', 'rbf', 'sigmoid']<br/>    }, 1),</span><span id="9015" class="ou nt it oq b gy oz ow l ox oy">    (linear_model.LogisticRegression(solver=LOGISTIC_REGRESSION_SOLVER,<br/>    max_iter=MAX_ITER),{<br/>    'model__C': loguniform(3e-4, 3e-1),<br/>    'model__penalty': ['none', 'l2'],<br/>    'model__class_weight': ['balanced', None]<br/>    }, 1),<br/>   <br/>    (naive_bayes.GaussianNB(),{}, 1),<br/>]</span><span id="f066" class="ou nt it oq b gy oz ow l ox oy">feature_selectors = [<br/>    (feature_selection.SelectFromModel(linear_model.LogisticRegression()),{<br/>    'feature_selection__estimator__penalty': ['l2'],}),<br/>    (decomposition.PCA(),{'feature_selection__n_components': randint(2, 5),}),<br/>]</span><span id="8e6a" class="ou nt it oq b gy oz ow l ox oy">scalers = [<br/>    (preprocessing.MinMaxScaler(),{}),<br/>    (preprocessing.RobustScaler(),{'scaler__quantile_range': [(25.0, 75.0),<br/>    (10.0, 90.0)] })<br/>]</span><span id="b5ac" class="ou nt it oq b gy oz ow l ox oy">imputation = [<br/>    (impute.SimpleImputer(),<br/>    {'imputer__strategy': ['mean', 'median']})<br/>]</span><span id="2ed7" class="ou nt it oq b gy oz ow l ox oy">transformers = [<br/>    (preprocessing.OneHotEncoder(),<br/>    {'column_transformer__transformer__drop': ['first', 'if_binary', None]})<br/>]</span><span id="0c05" class="ou nt it oq b gy oz ow l ox oy">hyparameters = list(<br/>    itertools.product(<br/>    transformers, imputation, scalers, feature_selectors, models<br/>))</span></pre><p id="4f50" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">设置每组的参数以支持超参数优化中使用的随机网格搜索。对于连续变量，参数期望分布。这些是使用scipy库定义的，该库允许预先指定发行版。当超参数是分类的时，超参数可以简单地固定为一个列表。</p><p id="a06d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用itertools包建立完整的超参数网格。该包中的产品功能在每个参数网格之间创建所有可能的配置。</p><p id="7d80" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过以这种方式设置超参数，迭代处于单个循环中。</p><p id="ed3e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个相同的过程可以使用多个循环来完成。然而，为了便于阅读，itertools将这些众多的列表压缩成一个列表。</p><p id="2071" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意每个超参数的命名。参数的前缀与管道中使用的名称相匹配。sklearn知道什么参数去哪里的方式是基于参数的名称。</p><p id="fa34" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当管道中有链接的函数时，名称会稍有变化。例如，“feature_selection _ _ estimator _ _ penalty”对应于管道中的“feature _ selection”命名步骤，对于此选项，它是SelectionFromModel特征选择方法。“估计值”部分对应于SelectionFromModel中的估计值参数。最后，“惩罚”部分对应于SelectionFromModel中使用的估计量的惩罚参数，它是为逻辑回归而设置的。</p><p id="0fce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">双下划线“__”指定一个函数何时在另一个函数中使用，以控制哪个函数转到管道步骤中的不同函数。</p></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><h1 id="8955" class="ns nt it bd nu nv nw nx ny nz oa ob oc jz od ka oe kc of kd og kf oh kg oi oj bi translated"><strong class="ak">迭代</strong></h1><p id="51d7" class="pw-post-body-paragraph kz la it lb b lc ok ju le lf ol jx lh li om lk ll lm on lo lp lq oo ls lt lu im bi translated">下面的循环遍历每个参数组合，并为每个配置优化一个模型。</p><pre class="kj kk kl km gt op oq or os aw ot bi"><span id="f829" class="ou nt it oq b gy ov ow l ox oy">for transformer_params, imputer_params, scaler_params, feature_selection_params, model_params in hyparameters:<br/>    hyperparameter_dict = {<br/>        **transformer_params[1],<br/>        **imputer_params[1],<br/>        **scaler_params[1],<br/>        **feature_selection_params[1],<br/>        **model_params[1]<br/>    }<br/>    column_transformer = compose.ColumnTransformer(<br/>        [('transformer', transformer_params[0],categorical_feature_names)],<br/>        remainder="passthrough"<br/>    )</span><span id="a3fe" class="ou nt it oq b gy oz ow l ox oy">    pipe = Pipeline(steps=[<br/>        ('column_transformer', column_transformer),<br/>        ('scaler', scaler_params[0]),<br/>        ('imputer', imputer_params[0]),<br/>        ('feature_selection', feature_selection_params[0]),<br/>        ('model', model_params[0])<br/>    ])<br/>    optimal_model = RandomizedSearchCV(<br/>        pipe, hyperparameter_dict,<br/>        n_iter = model_params[2], cv=K_FOLDS,<br/>        scoring=SCORING_METRIC, n_jobs = N_JOBS,<br/>        return_train_score=True, verbose = VERBOSE<br/>    )<br/>    optimal_model.fit(X_train, y_train)<br/>    <br/>    y_pred = optimal_model.best_estimator_.predict(X_train)<br/>    y_pred_prob = optimal_model.best_estimator_.predict_proba(X_train)[:,1]<br/>    y_pred_test = optimal_model.best_estimator_.predict_proba(X_test)[:,1]<br/>    score = SCORING_FUNCTION(y_test, y_pred_test)</span><span id="2973" class="ou nt it oq b gy oz ow l ox oy">    print(<br/>        'Optimal Training Score: ', optimal_model.cv_results_['mean_train_score'][optimal_model.best_index_],<br/>        '\Optimal Test Score: ', optimal_model.best_score_,<br/>        '\nHold Out Test Score: ', score<br/>    )<br/>    if score &gt; best_score:<br/>        best_score = score<br/>        pickle.dump(optimal_model, open(OPTIMAL_MODEL_FILENAME, 'wb'))</span></pre><p id="e258" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">分解每个组件:</p><ul class=""><li id="b37d" class="pg ph it lb b lc ld lf lg li pi lm pj lq pk lu pl pm pn po bi translated">通过组合来自流水线中每个步骤的超参数来创建单个字典。</li><li id="e9f1" class="pg ph it lb b lc pp lf pq li pr lm ps lq pt lu pl pm pn po bi translated">列转换器是在管道之前单独创建的。此转换器为特征转换启用了单独的路径。</li><li id="5d49" class="pg ph it lb b lc pp lf pq li pr lm ps lq pt lu pl pm pn po bi translated">管道“管道”已创建。步骤是一个元组列表，其中第一个元素是步骤的名称。(此名称匹配与步骤相关的超参数的前缀)。第二个要素是该步骤的函数，无论是缩放、插补还是预测。</li><li id="8ab4" class="pg ph it lb b lc pp lf pq li pr lm ps lq pt lu pl pm pn po bi translated">使用随机超参数搜索来确定最佳模型。这种搜索从超参数空间采样，用于每个模型所需的几次迭代。</li><li id="6b97" class="pg ph it lb b lc pp lf pq li pr lm ps lq pt lu pl pm pn po bi translated">使用评分功能评估培训、测试和坚持测试的结果。</li><li id="efd1" class="pg ph it lb b lc pp lf pq li pr lm ps lq pt lu pl pm pn po bi translated">如果模型的得分比当前的最佳模型好，则使用pickle存储该模型。</li></ul><p id="6eda" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注:这里使用随机搜索，因为它比网格搜索更有可能找到最佳模型。有关不同超参数搜索方法的详细信息以及随机搜索优于网格搜索的原因，请阅读以下帖子:</p><div class="mt mu gp gr mv mw"><a rel="noopener follow" target="_blank" href="/hyperparameter-tuning-always-tune-your-models-7db7aeaf47e9"><div class="mx ab fo"><div class="my ab mz cl cj na"><h2 class="bd iu gy z fp nb fr fs nc fu fw is bi translated">超参数调整—始终调整您的模型</h2><div class="nd l"><h3 class="bd b gy z fp nb fr fs nc fu fw dk translated">不要放弃免费的性能提升。</h3></div><div class="ne l"><p class="bd b dl z fp nb fr fs nc fu fw dk translated">towardsdatascience.com</p></div></div><div class="nf l"><div class="pu l nh ni nj nf nk ks mw"/></div></div></a></div></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><h1 id="7b06" class="ns nt it bd nu nv nw nx ny nz oa ob oc jz od ka oe kc of kd og kf oh kg oi oj bi translated"><strong class="ak">结论</strong></h1><p id="4162" class="pw-post-body-paragraph kz la it lb b lc ok ju le lf ol jx lh li om lk ll lm on lo lp lq oo ls lt lu im bi translated">Sklearn管道提供了很大的灵活性。然而，他们可能会面临挑战。</p><p id="1479" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通常，在构建管道时，可用的示例仅显示了管道的特定部分。因此，将这些碎片放在一起并不总是简单的。</p><p id="49bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该代码允许sklearn中的大多数可用功能自动使用或稍加调整即可使用。希望这条管道能让你的发展流动起来。</p></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><p id="4f2b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="pv">如果你有兴趣阅读关于新颖的数据科学工具和理解机器学习算法的文章，可以考虑在Medium上关注我。</em></p><p id="4f22" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="pv">如果你对我的写作感兴趣，想直接支持我，请通过以下链接订阅。这个链接确保我会收到你的会员费的一部分。</em></p><div class="mt mu gp gr mv mw"><a href="https://zjwarnes.medium.com/membership" rel="noopener follow" target="_blank"><div class="mx ab fo"><div class="my ab mz cl cj na"><h2 class="bd iu gy z fp nb fr fs nc fu fw is bi translated">通过我的推荐链接加入Medium-Zachary Warnes</h2><div class="nd l"><h3 class="bd b gy z fp nb fr fs nc fu fw dk translated">阅读扎卡里·沃恩斯(以及媒体上成千上万的其他作家)的每一个故事。您的会员费直接支持…</h3></div><div class="ne l"><p class="bd b dl z fp nb fr fs nc fu fw dk translated">zjwarnes.medium.com</p></div></div><div class="nf l"><div class="pw l nh ni nj nf nk ks mw"/></div></div></a></div></div></div>    
</body>
</html>