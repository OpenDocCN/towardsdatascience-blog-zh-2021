<html>
<head>
<title>How to Track Hazardous Asteroids with Composition of Iterators in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用Python中迭代器的组合追踪危险的小行星</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-track-hazardous-asteroids-with-composition-of-iterators-in-python-3945cf8e8f84?source=collection_archive---------31-----------------------#2021-05-11">https://towardsdatascience.com/how-to-track-hazardous-asteroids-with-composition-of-iterators-in-python-3945cf8e8f84?source=collection_archive---------31-----------------------#2021-05-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="3dab" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph">去锈蟒</h2><div class=""/><div class=""><h2 id="cd1c" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">应用函数组合创建迭代器管道</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/7b45f4ce102928906ee268e331f87078.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*bUgNLpsPG_UPn6oW"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">由<a class="ae le" href="https://unsplash.com/@spacex?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> SpaceX </a>在<a class="ae le" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="8748" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated"><strong class="lh ja">功能性</strong>和<strong class="lh ja">面向对象的</strong>编程经常被认为是相反的。将Python的迭代器对象组合成一个管道就是它们完美互补的例子。我将使用NASA的一个开放API来展示这种模式。</p><h1 id="2685" class="mb mc iq bd md me mf mg mh mi mj mk ml kf mm kg mn ki mo kj mp kl mq km mr ms bi translated">显示优点的东西</h1><p id="a7df" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">API小行星——NeoWs是一个RESTful的近地小行星信息网络服务。它允许搜索离地球最近的小行星。</p><p id="4ed4" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">你可以在<a class="ae le" href="https://api.nasa.gov/" rel="noopener ugc nofollow" target="_blank"> NASA API门户</a>上找到。</p><p id="41da" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">它包含一些奇怪的数据——最大物体直径、最近接近距离、接近日期等等。在这些数据中，每个物体都有一个字段显示该物体对地球有潜在的危险。</p><p id="3fb6" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">让我们考虑这样一种情况，当我们想要获取小行星数据，然后按日期将其写入文件，并找到一个潜在危险的小行星。</p><p id="7d88" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">通常，我从编写代码开始，我希望如何与不存在的高级类或函数进行交互。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="f749" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">这段代码混合了两种范式<strong class="lh ja">功能性</strong>和<strong class="lh ja">面向对象</strong>编程。</p><p id="4fd7" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated"><strong class="lh ja">函数式编程</strong>擅长数据处理任务，例如对数据进行顺序操作和改变。<strong class="lh ja">对象</strong>允许将相关的行为耦合到一个实体中，并存储一个状态。结合两种范例使代码更具声明性。</p></div><div class="ab cl na nb hu nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="ij ik il im in"><h1 id="fe48" class="mb mc iq bd md me nh mg mh mi ni mk ml kf nj kg mn ki nk kj mp kl nl km mr ms bi translated">配置</h1><p id="ff56" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">我们将从隔离每个步骤开始，以分离对象。我们将创建存储每个步骤配置的基本类，稍后将添加所需的实现。</p><p id="0cd5" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我们需要一个从<strong class="lh ja"> URL加载数据的步骤。</strong></p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="f5b2" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">接下来，我们添加一个步骤，它将按日期将加载的小行星数据写入文件。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="246a" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">最后一步将负责寻找危险的小行星。我们将存储一个负责该属性的字段。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="my mz l"/></div></figure></div><div class="ab cl na nb hu nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="ij ik il im in"><h1 id="0033" class="mb mc iq bd md me nh mg mh mi ni mk ml kf nj kg mn ki nk kj mp kl nl km mr ms bi translated">功能组成</h1><p id="e555" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated"><strong class="lh ja">函数组合</strong>是函数式编程的主要模式之一。</p><p id="a659" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">直观地说，组合函数是一个链接过程，函数<code class="fe nm nn no np b"><em class="nq">f</em></code>的输出馈入函数<code class="fe nm nn no np b"><em class="nq">g</em></code>的输入。</p><p id="3336" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">在Python中，我们可以如下实现它。</p><pre class="kp kq kr ks gt nr np ns nt aw nu bi"><span id="a719" class="nv mc iq np b gy nw nx l ny nz">def compose2(f, g):<br/>    return lambda *args: g(f(*args))</span></pre><p id="bebc" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">注意，我们希望在从左到右读取函数时执行它们，我们使用了<code class="fe nm nn no np b">g(f(x))</code>。</p><p id="a3db" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">例如，考虑两个函数。</p><pre class="kp kq kr ks gt nr np ns nt aw nu bi"><span id="361c" class="nv mc iq np b gy nw nx l ny nz">def square(x):<br/>    return x*x</span><span id="2f08" class="nv mc iq np b gy oa nx l ny nz">def format(x):<br/>    return f"x*x = {x}"</span></pre><p id="41ca" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我们可以应用<code class="fe nm nn no np b">compose2()</code>函数制作一个新的。</p><pre class="kp kq kr ks gt nr np ns nt aw nu bi"><span id="b812" class="nv mc iq np b gy nw nx l ny nz">&gt;&gt;&gt; square_and_format = compose2(square, format)<br/>&gt;&gt;&gt; print(square_and_format(2))<br/>x*x = 4</span></pre></div><div class="ab cl na nb hu nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="ij ik il im in"><h1 id="3f76" class="mb mc iq bd md me nh mg mh mi ni mk ml kf nj kg mn ki nk kj mp kl nl km mr ms bi translated">减少</h1><p id="c8a0" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">另一种常用的功能模式是<strong class="lh ja">折叠</strong>或<strong class="lh ja">减少</strong>功能。<code class="fe nm nn no np b">reduce()</code>方法将数组累加成一个值。<code class="fe nm nn no np b">reduce()</code>方法为数组的每个值执行一个提供的函数(从左到右)。</p><p id="8c99" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">顺便说一句，吉多·范·罗苏姆不喜欢它。</p><blockquote class="ob oc od"><p id="261a" class="lf lg nq lh b li lj ka lk ll lm kd ln oe lp lq lr of lt lu lv og lx ly lz ma ij bi translated">所以现在减少()。这实际上是我最讨厌的一个，因为除了几个涉及+或*的例子之外，几乎每次我看到带有重要函数参数的reduce()调用时，我都需要拿起笔和纸，在我理解reduce()应该做什么之前，画出实际输入到该函数中的内容。因此，在我看来，reduce()的适用性仅限于关联操作符，在所有其他情况下，最好显式写出累加循环。<br/><strong class="lh ja">——吉多·范·罗苏姆</strong>，<a class="ae le" href="https://www.artima.com/weblogs/viewpost.jsp?thread=98196" rel="noopener ugc nofollow" target="_blank"> <strong class="lh ja">命运的减少(Python 3000中的</strong> </a></p></blockquote><p id="d5f0" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">幸运的是，它被藏在了<code class="fe nm nn no np b">functools</code>模块里。所以我们可以将我们的<code class="fe nm nn no np b">compose2</code>函数应用到函数列表中。</p><pre class="kp kq kr ks gt nr np ns nt aw nu bi"><span id="88bf" class="nv mc iq np b gy nw nx l ny nz">from functools import reduce</span><span id="4bfd" class="nv mc iq np b gy oa nx l ny nz">def compose(*functions):<br/>    return reduce(compose2, functions)</span></pre><p id="6a04" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">现在，我们能够为函数列表应用<strong class="lh ja">组合</strong>。</p></div><div class="ab cl na nb hu nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="ij ik il im in"><h1 id="a5af" class="mb mc iq bd md me nh mg mh mi ni mk ml kf nj kg mn ki nk kj mp kl nl km mr ms bi translated">请求即付的</h1><p id="6f1d" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">为了能够对我们的对象应用函数组合和归约，我们需要使我们的类可调用。</p><p id="87e2" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">在Python中，如果我们想让一个对象可调用，我们需要实现神奇的方法<code class="fe nm nn no np b">__call__</code>。</p><p id="ef23" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">对于<code class="fe nm nn no np b">Load</code>类，这将是请求数据的简单返回。</p><pre class="kp kq kr ks gt nr np ns nt aw nu bi"><span id="34b6" class="nv mc iq np b gy nw nx l ny nz">class Load:<br/>    ...</span><span id="bbb4" class="nv mc iq np b gy oa nx l ny nz">    def __call__(self):<br/>        return requests.get(self.url)</span></pre><p id="fdd1" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">对于<code class="fe nm nn no np b">Write</code>对象来说，就有点棘手了。我们将迭代器作为参数，保存它，并返回对象本身。稍后我们将实现迭代接口，它将允许我们组合这样的对象。</p><pre class="kp kq kr ks gt nr np ns nt aw nu bi"><span id="d8cb" class="nv mc iq np b gy nw nx l ny nz">class Write:<br/>    ...</span><span id="6f70" class="nv mc iq np b gy oa nx l ny nz">    def __call__(self, iterator):<br/>        self.iterator = iterator<br/>        return self</span></pre><p id="c61e" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">对于<code class="fe nm nn no np b">Find</code>，它看起来与<code class="fe nm nn no np b">Write</code>一样。</p><pre class="kp kq kr ks gt nr np ns nt aw nu bi"><span id="d3fc" class="nv mc iq np b gy nw nx l ny nz">class Find:<br/>    ...</span><span id="e941" class="nv mc iq np b gy oa nx l ny nz">    def __call__(self, iterator):<br/>        self.iterator = iterator<br/>        return self</span></pre></div><div class="ab cl na nb hu nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="ij ik il im in"><h1 id="1314" class="mb mc iq bd md me nh mg mh mi ni mk ml kf nj kg mn ki nk kj mp kl nl km mr ms bi translated">迭代程序</h1><p id="8bbb" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">最后，我们必须为对象实现一个迭代器接口。从技术上讲，一个Python <strong class="lh ja">对象</strong>必须实现<code class="fe nm nn no np b">__iter__</code>方法来提供迭代支持。</p><p id="7966" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">在我们的例子中，迭代也将保持数据处理的主要逻辑。</p><p id="70e6" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我们不需要为<code class="fe nm nn no np b">Load</code>类实现迭代。它以列表的形式返回数据，默认情况下可以迭代。</p><p id="43e1" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">对于类<code class="fe nm nn no np b">Write</code>，处理和保存数据到文件的逻辑将在这个方法中实现。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="41a8" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">对于<code class="fe nm nn no np b">Find</code>类，在迭代过程中，我们将过滤满足我们条件的对象。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="my mz l"/></div></figure></div><div class="ab cl na nb hu nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="ij ik il im in"><h1 id="031e" class="mb mc iq bd md me nh mg mh mi ni mk ml kf nj kg mn ki nk kj mp kl nl km mr ms bi translated">决赛成绩</h1><p id="ec03" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">这就是了。我们实现了几个类，这些类可以通过配置启动，并组成一个管道，如下所示。</p><pre class="kp kq kr ks gt nr np ns nt aw nu bi"><span id="8022" class="nv mc iq np b gy nw nx l ny nz">pipe = pipeline.compose(<br/>    pipeline.Load(<br/>        url=API_URL, api_key="DEMO_KEY", start_date="2021-05-09"<br/>    ),<br/>    pipeline.Write(to_path="/tmp"),<br/>    pipeline.Find(field="is_potentially_hazardous_asteroid"),<br/>)</span><span id="4f04" class="nv mc iq np b gy oa nx l ny nz">for each in pipe():<br/>    print(each)</span></pre><p id="0dc9" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">完整的示例源代码请看我的GitHub repo。</p><div class="oh oi gp gr oj ok"><a href="https://github.com/pavel-fokin/iterators-composition" rel="noopener  ugc nofollow" target="_blank"><div class="ol ab fo"><div class="om ab on cl cj oo"><h2 class="bd ja gy z fp op fr fs oq fu fw iz bi translated">Pavel-fokin/迭代器-合成</h2><div class="or l"><h3 class="bd b gy z fp op fr fs oq fu fw dk translated">这是一篇文章“迭代器的合成”的例子</h3></div><div class="os l"><p class="bd b dl z fp op fr fs oq fu fw dk translated">github.com</p></div></div><div class="ot l"><div class="ou l ov ow ox ot oy ky ok"/></div></div></a></div><p id="f8b6" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">看起来不错！你怎么想呢?</p><p id="f465" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated"><strong class="lh ja"> <em class="nq">与我分享你对</em></strong><a class="ae le" href="https://www.linkedin.com/in/pavel-fokin/" rel="noopener ugc nofollow" target="_blank"><strong class="lh ja"><em class="nq">LinkedIn</em></strong></a><strong class="lh ja"><em class="nq">和</em></strong><a class="ae le" href="https://twitter.com/pavelfokin_" rel="noopener ugc nofollow" target="_blank"><strong class="lh ja"><em class="nq">Twitter</em></strong></a><strong class="lh ja"><em class="nq">。</em>T25】</strong></p><h1 id="909b" class="mb mc iq bd md me mf mg mh mi mj mk ml kf mm kg mn ki mo kj mp kl mq km mr ms bi translated">结论</h1><p id="567d" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">这种模式有几个优点，我们举几个例子。</p><p id="8846" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated"><strong class="lh ja">优点</strong></p><ul class=""><li id="4850" class="oz pa iq lh b li lj ll lm lo pb ls pc lw pd ma pe pf pg ph bi translated">关注点分离。每一步都有其独立的作用。</li><li id="5c4d" class="oz pa iq lh b li pi ll pj lo pk ls pl lw pm ma pe pf pg ph bi translated">算法的更多声明性符号。</li><li id="71e6" class="oz pa iq lh b li pi ll pj lo pk ls pl lw pm ma pe pf pg ph bi translated">每一步都可以单独测试。</li></ul><p id="3086" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">但是和其他模式一样，它不应该被过度使用。如果逻辑变得太复杂或者步骤太多，最好重新考虑这个方法。</p><h1 id="7f7a" class="mb mc iq bd md me mf mg mh mi mj mk ml kf mm kg mn ki mo kj mp kl mq km mr ms bi translated">更多阅读</h1><p id="68bd" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">如果你喜欢这篇文章，你可以对以下内容感兴趣。</p><p id="2168" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">不用OOP用Python解释<strong class="lh ja">依赖倒置原理</strong>。</p><div class="oh oi gp gr oj ok"><a href="https://levelup.gitconnected.com/tenet-of-inversion-with-python-9759ef73dbcf" rel="noopener  ugc nofollow" target="_blank"><div class="ol ab fo"><div class="om ab on cl cj oo"><h2 class="bd ja gy z fp op fr fs oq fu fw iz bi translated">Python中的反转原则</h2><div class="or l"><h3 class="bd b gy z fp op fr fs oq fu fw dk translated">打破依赖倒置原则。</h3></div><div class="os l"><p class="bd b dl z fp op fr fs oq fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="ot l"><div class="pn l ov ow ox ot oy ky ok"/></div></div></a></div><p id="8590" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">仔细观察Python中<strong class="lh ja">多态性</strong>的类型。</p><div class="oh oi gp gr oj ok"><a href="https://levelup.gitconnected.com/hidden-power-of-polymorphism-in-python-c9e2539c1633" rel="noopener  ugc nofollow" target="_blank"><div class="ol ab fo"><div class="om ab on cl cj oo"><h2 class="bd ja gy z fp op fr fs oq fu fw iz bi translated">Python中多态隐藏的力量</h2><div class="or l"><h3 class="bd b gy z fp op fr fs oq fu fw dk translated">如何在应用程序中实现多态接口？</h3></div><div class="os l"><p class="bd b dl z fp op fr fs oq fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="ot l"><div class="po l ov ow ox ot oy ky ok"/></div></div></a></div><p id="1712" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated"><strong class="lh ja"> <em class="nq">感谢阅读！与我分享你对</em></strong><a class="ae le" href="https://www.linkedin.com/in/pavel-fokin/" rel="noopener ugc nofollow" target="_blank"><strong class="lh ja"><em class="nq">LinkedIn</em></strong></a><strong class="lh ja"><em class="nq">和</em></strong><a class="ae le" href="https://twitter.com/pavelfokin_" rel="noopener ugc nofollow" target="_blank"><strong class="lh ja"><em class="nq">Twitter</em></strong></a><strong class="lh ja"><em class="nq">的想法。如果你喜欢这个故事，请关注</em></strong><a class="ae le" href="https://medium.com/@pavelfokin" rel="noopener"><strong class="lh ja"><em class="nq">me</em></strong></a><strong class="lh ja"><em class="nq">获取更多关于编程的精彩文章。</em> </strong></p></div></div>    
</body>
</html>