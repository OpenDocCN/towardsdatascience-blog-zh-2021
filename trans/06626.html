<html>
<head>
<title>Are you still using 0.5 as a threshold?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你还用0.5做门槛吗？</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/are-you-still-using-0-5-as-a-threshold-c5728aa98583?source=collection_archive---------31-----------------------#2021-06-14">https://towardsdatascience.com/are-you-still-using-0-5-as-a-threshold-c5728aa98583?source=collection_archive---------31-----------------------#2021-06-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9507" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">二元分类问题中调整阈值的一些方法</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/74388ed11cc1522b3167be235a429efe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3_brBNq3DjTOXaMN"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">凯文·Ku在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="836c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在二元分类问题中，我们通常将模型给出的分数转换为应用阈值的预测类。如果分数大于阈值，我们预测1，否则，我们预测0。这个阈值通常设置为0.5，但是正确吗？</p><h1 id="f9db" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">0.5背后的原因</h1><p id="992e" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在二元分类中，当模型给我们一个分数而不是预测本身时，我们通常需要将这个分数转换为应用阈值的预测。因为分数的意义是根据我们的模型给我们一个1的感知概率，所以使用0.5作为阈值是显而易见的。事实上，如果有1的概率大于有0的概率，那么将预测转换为1是很自然的。0.5是确保给定的1概率大于0概率的自然阈值。这就是为什么当我们调用估算器实例的<em class="ms">预测</em>方法时，它是Python的scikit-learn库中使用的默认阈值。</p><p id="9252" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么，为什么0.5可能不是一个好主意呢？很简单，因为这是一个假设，而我们作为数据科学家，必须根据数据而不是假设做出决策。有时候0.5不是完成我们目标的合适门槛。例如，它可能不会给我们高精度，或者可能导致混淆矩阵中的高错误值。因此，我们必须根据某个性能指标的优化过程来调整阈值。这种度量标准的选择取决于我们的问题。</p><h1 id="bb7e" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">Python中调整阈值的示例</h1><p id="295b" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">现在让我们看看如何调整将分数转换为预测值的阈值，并使用Python来实现。你可以在我的<a class="ae ky" href="https://github.com/gianlucamalato/machinelearning/blob/master/Threshold.ipynb" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>中找到全部作品。</p><p id="7ccb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，让我们导入波士顿数据集和逻辑回归，加上一些指标，如平衡准确度和ROC曲线。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="577a" class="my lw it mu b gy mz na l nb nc">import numpy as np <br/>import matplotlib.pyplot as plt <br/>from sklearn.datasets import load_boston <br/>from sklearn.linear_model import LogisticRegression <br/>from sklearn.preprocessing import StandardScaler <br/>from sklearn.pipeline import make_pipeline <br/>from sklearn.model_selection import train_test_split,cross_val_score<br/>from sklearn.metrics import roc_curve,plot_roc_curve, balanced_accuracy_score</span></pre><p id="a2c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们可以将波士顿数据集转换为二进制分类问题，创建一个新的目标，如果原始目标值大于平均值，则该目标值为1，否则为0。最后，我们将数据集分成训练集和测试集。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="9472" class="my lw it mu b gy mz na l nb nc">X,y = load_boston(return_X_y=True) <br/>y = (y &gt; y.mean()).astype(int) <br/>X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.33, random_state=42)</span></pre><p id="9a59" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以创建我们的逻辑回归管道(用一个标准的定标器)并对其进行拟合。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="cc99" class="my lw it mu b gy mz na l nb nc">model = make_pipeline(StandardScaler(),LogisticRegression())<br/>model.fit(X_train,y_train)</span></pre><p id="7448" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们看看我们可以使用的一些调优方法。</p><h1 id="2e61" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">基于ROC曲线的调谐</h1><p id="c396" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">让我们绘制在训练集中计算的ROC曲线。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="43b1" class="my lw it mu b gy mz na l nb nc">plot_roc_curve(model,X_train,y_train)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/8da1a687ec149292c17fc5fe58bf5a24.png" data-original-src="https://miro.medium.com/v2/resize:fit:1050/format:webp/0*EiIaioD4SmJJh4Wn.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="44c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用ROC曲线来调整阈值的想法是，确定为我们提供曲线左上角的阈值。从数学上讲，满足以下等式的阈值<em class="ms"> p </em>:</p><p id="4992" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">相当于求真正率等于真负率(为1-FPR)的<em class="ms"> p </em>的值。</p><p id="afb8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一种调整阈值的通用方法，经常出现在学术论文中，并被一些数据科学家使用。</p><p id="c959" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">更一般地，我们希望找到满足以下条件的阈值:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/549e9ada232c274efea7026c95852c4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1098/format:webp/1*5D1q35gSjz5MuOz1JOheIw.png"/></div></figure><p id="b7d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一种非常常见的方法，因为我们将求根问题转化为优化问题。</p><p id="990c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">实际上，我们可以计算我们的模型生成的所有分数，并找到最小化上述论点的分数。</p><p id="91d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以使用下面的代码很容易地计算出我们需要的所有对象:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="7e98" class="my lw it mu b gy mz na l nb nc">fpr, tpr, thresholds = roc_curve(y_train,model.predict_proba(X_train)[:,1], drop_intermediate=False)</span></pre><p id="7d75" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以画出关于阈值的目标函数，看看它的最小值在哪里。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="725c" class="my lw it mu b gy mz na l nb nc">plt.scatter(thresholds,np.abs(fpr+tpr-1)) plt.xlabel("Threshold")<br/>plt.ylabel("|FPR + TPR - 1|") plt.show()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/62b96f03c5a56146400fb2c8fea5fa31.png" data-original-src="https://miro.medium.com/v2/resize:fit:1070/format:webp/0*8suIAFLKclSLbNMD.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="d949" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如你所见，我们在0.5之前有一个最小值。正确的值是:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="8adb" class="my lw it mu b gy mz na l nb nc">thresholds[np.argmin(np.abs(fpr+tpr-1))] <br/># 0.44625685602433796</span></pre><p id="841a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以，这就是我们要找的门槛。</p><h1 id="c886" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">最大限度提高准确性</h1><p id="7de6" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我们可以遵循的另一种方法是找到使精度最大化的阈值。对于这个例子，我更喜欢使用平衡精度，因为它考虑到了可能的不平衡数据集。</p><p id="9d60" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们首先遍历所有的分数，并将精确度存储在一个列表中。然后我们绘制它们。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="0f74" class="my lw it mu b gy mz na l nb nc">threshold = [] <br/>accuracy = [] <br/>for p in np.unique(model.predict_proba(X_train)[:,1]):       <br/> threshold.append(p) <br/> y_pred = (model.predict_proba(X_train)[:,1] &gt;= p).astype(int) <br/> accuracy.append(balanced_accuracy_score(y_train,y_pred))</span></pre><p id="4e52" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">情节是这样的:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="e155" class="my lw it mu b gy mz na l nb nc">plt.scatter(threshold,accuracy) plt.xlabel("Threshold")<br/>plt.ylabel("Balanced accuracy") plt.show()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/c3e4663914a9439ff30b9b5ccc3d94f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1092/format:webp/0*sl0RQBQFj8cpLKRD.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="a11d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在0.4和0.6之间有一个明显的最大值。它的确切值是:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="5ab3" class="my lw it mu b gy mz na l nb nc">threshold[np.argmax(accuracy)] <br/># 0.5602892029098923</span></pre><h1 id="a171" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">结论</h1><p id="55f9" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在本文中，我们看到了两种优化二元分类问题阈值的可能方法。还有其他方法可以使用，但这是两种常见的方法，可以很容易地推广以适应项目的所有需求。永远不要忘记只优化训练数据集，而不要优化测试数据集。优化阈值相当于优化管道的超参数，因此我们只在训练数据集上进行优化。</p></div><div class="ab cl nh ni hx nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="im in io ip iq"><p id="d263" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="ms">原载于2021年6月14日https://www.yourdatateacher.com</em><a class="ae ky" href="https://www.yourdatateacher.com/2021/06/14/are-you-still-using-0-5-as-a-threshold/" rel="noopener ugc nofollow" target="_blank"><em class="ms"/></a><em class="ms">。</em></p></div></div>    
</body>
</html>