<html>
<head>
<title>Credit Card Fraud Detection Using Machine Learning &amp; Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用机器学习和Python进行信用卡欺诈检测</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/credit-card-fraud-detection-using-machine-learning-python-5b098d4a8edc?source=collection_archive---------1-----------------------#2021-08-13">https://towardsdatascience.com/credit-card-fraud-detection-using-machine-learning-python-5b098d4a8edc?source=collection_archive---------1-----------------------#2021-08-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4740" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">逐步指导构建、培训和评估</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ffd433501516811ca6c5e4960994c779.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*yfEWGyhd7vKEJDga"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@freestocks?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">自由股票</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="f9e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">随着我们迈向数字世界，网络安全正成为我们生活中至关重要的一部分。当我们谈论数字生活中的安全性时，主要的挑战是发现异常活动。</p><p id="1e94" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们在网上购买任何产品进行交易时，很多人更喜欢信用卡。信用卡的信用额度有时帮助我们购物，即使我们当时没有足够的钱。但是，另一方面，这些功能被网络攻击者滥用。</p><p id="275e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了解决这个问题，我们需要一个系统，如果它发现可疑，可以中止交易。</p><p id="2e4b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就需要一个系统来跟踪所有交易的模式，如果有任何模式异常，就应该中止交易。</p><p id="d8a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">今天，我们有许多机器学习算法可以帮助我们对异常交易进行分类。唯一的要求就是过去的数据和合适的算法，能够以更好的形式拟合我们的数据。</p><p id="8e8d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我将在完整的端到端模型训练过程中为您提供帮助—最终，您将获得能够将事务分类为正常和异常类型的最佳模型。</p><h1 id="eb1b" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">关于数据</h1><p id="44ab" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">这篇文章的数据可以在<a class="ae ky" href="https://www.kaggle.com/mlg-ulb/creditcardfraud" rel="noopener ugc nofollow" target="_blank">这里</a>找到。该数据集包含欧洲持卡人在2013年进行的真实银行交易。出于安全考虑，实际变量没有共享，但它们是PCA的转换版本。结果，我们可以找到29个特性列和1个最终类列。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ms"><img src="../Images/715addf29e84cc4945792870cc75e3c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O3iUQ-USvcsxssYZw0cKkg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">数据快照</p></figure><h1 id="e18a" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">导入必要的库</h1><p id="ebf3" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在一个地方导入所有必要的库是一个好的做法，这样我们可以快速修改它们。</p><p id="e015" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于此信用卡数据，数据集中的特征是PCA的转换版本，因此我们不需要再次执行特征选择。否则，建议使用RFE、RFECV、选择最佳和VIF评分来查找您的模型的最佳功能。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure></div><div class="ab cl mv mw hx mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="im in io ip iq"><blockquote class="nc"><p id="c27a" class="nd ne it bd nf ng nh ni nj nk nl lu dk translated">直接从行业专家那里获得Python和数据科学的优质内容——使用我的推荐链接成为中级会员以解锁内容:<a class="ae ky" href="https://pranjalai.medium.com/membership" rel="noopener">https://pranjalai.medium.com/membership</a></p></blockquote></div><div class="ab cl mv mw hx mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="im in io ip iq"><h1 id="a071" class="lv lw it bd lx ly nm ma mb mc nn me mf jz no ka mh kc np kd mj kf nq kg ml mm bi translated">导入数据集</h1><p id="b3eb" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">导入数据集非常简单。可以用python中的熊猫模块导入。</p><p id="bbb1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运行以下命令导入您的数据。</p><pre class="kj kk kl km gt nr ns nt nu aw nv bi"><span id="eb2b" class="nw lw it ns b gy nx ny l nz oa">data=pd.read_csv("creditcard.csv")</span></pre><h1 id="42f0" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">数据处理和理解</h1><p id="16c9" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">关于这些数据，您会注意到的一个主要问题是，数据集对某个要素不平衡。这似乎对这类数据非常有效。因为今天许多银行已经采用了不同的安全机制，所以黑客更难做出这样的举动。</p><p id="81c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管如此，有时当系统中存在一些漏洞时，此类活动的机会会增加。</p><p id="8444" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是为什么我们可以看到大多数属于我们数据集的交易是正常的，只有少数交易是欺诈性的。</p><p id="42cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们检查一下交易分布。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/d4f10cb72e66f763b895a257cdcf7b7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:838/format:webp/1*RiZkT25DNE8o1-Mo3gtAuw.png"/></div></figure><p id="1753" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">只有0.17%的交易是欺诈性的。</p><p id="d7c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还可以使用下面一行代码来检查空值。</p><pre class="kj kk kl km gt nr ns nt nu aw nv bi"><span id="a3cd" class="nw lw it ns b gy nx ny l nz oa">data.info()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/614a3a28055c4f4cf6ac5991e7faf3d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:840/format:webp/1*i_SqwP4tT2FqwQo4PRZhmA.png"/></div></figure><p id="31d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据每列的计数，我们没有空值。此外，功能选择不是这个用例的情况。无论如何，你可以尝试应用特征选择机制来检查结果是否被优化。</p><p id="8eea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我在我们的数据中观察到28个特征是PCA的转换版本，但是数量是原始的。而且，当检查最小值和最大值时，我发现差异很大，可能会偏离我们的结果。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/1e30d0f3cf21f7f7a9a800a3eec2a887.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pIj7D7VshTqrlGHuOK2ncw.png"/></div></div></figure><p id="7364" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，调整这个变量是一个很好的做法。我们可以用一个标准的定标器来固定它。</p><pre class="kj kk kl km gt nr ns nt nu aw nv bi"><span id="56f3" class="nw lw it ns b gy nx ny l nz oa">sc = StandardScaler()<br/>amount = data['Amount'].values<br/>data['Amount'] = sc.fit_transform(amount.reshape(-1, 1))</span></pre><p id="72e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还有一个变量是时间，它可能是一个外部决定因素，但在我们的建模过程中，我们可以放弃它。</p><pre class="kj kk kl km gt nr ns nt nu aw nv bi"><span id="3285" class="nw lw it ns b gy nx ny l nz oa">data.drop(['Time'], axis=1, inplace=True)</span></pre><p id="0386" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还可以检查任何重复的交易。在删除任何重复的事务之前，我们的数据中有284807个事务。让我们删除重复，并观察变化。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/69b86b84ad67d9aa0ab46c92b0c7c3b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P62tlPWH6WsnjHROXE-nFg.png"/></div></div></figure><p id="16f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运行下面一行代码来删除任何重复的内容。</p><pre class="kj kk kl km gt nr ns nt nu aw nv bi"><span id="ea85" class="nw lw it ns b gy nx ny l nz oa">data.drop_duplicates(inplace=True)</span></pre><p id="b069" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们再次检查计数。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/0cf77917eccdd5b703caffbe487e61bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*62b2GINY3fOeuCGmk2WQ5A.png"/></div></div></figure><p id="33a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我们有大约9000个重复交易。</p><p id="96cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">开始了。！我们现在已经有了正确的数据，没有重复，没有遗漏。现在让我们为我们的模型建设分裂它。</p><h1 id="d7a8" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">训练和测试分割</h1><p id="f964" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在分割训练和测试之前，我们需要定义因变量和自变量。因变量也被称为<strong class="lb iu"> X </strong>，自变量被称为<strong class="lb iu"> y. </strong></p><pre class="kj kk kl km gt nr ns nt nu aw nv bi"><span id="f2f3" class="nw lw it ns b gy nx ny l nz oa">X = data.drop('Class', axis = 1).values<br/>y = data['Class'].values</span></pre><p id="738d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们分开训练和测试数据。</p><pre class="kj kk kl km gt nr ns nt nu aw nv bi"><span id="9389" class="nw lw it ns b gy nx ny l nz oa">X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 0.25, random_state = 1)</span></pre><p id="33ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就是这样。我们现在有两个不同的数据集—训练数据将用于训练我们的模型，而不可见的数据将用于测试。</p><h1 id="38ad" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">模型结构</h1><p id="b5af" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我们将逐一尝试不同的机器学习模型。定义模型要容易得多。一行代码就可以定义我们的模型。同样地，一行代码就可以使模型符合我们的数据。</p><p id="dc83" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还可以通过选择不同的优化参数来调整这些模型。但是，如果精度更高，即使参数调整更少，也没必要让它变得复杂。</p><blockquote class="og oh oi"><p id="8c75" class="kz la oj lb b lc ld ju le lf lg jx lh ok lj lk ll ol ln lo lp om lr ls lt lu im bi translated">决策图表</p></blockquote><pre class="kj kk kl km gt nr ns nt nu aw nv bi"><span id="3903" class="nw lw it ns b gy nx ny l nz oa">DT = DecisionTreeClassifier(max_depth = 4, criterion = 'entropy')<br/>DT.fit(X_train, y_train)<br/>dt_yhat = DT.predict(X_test)</span></pre><p id="2d16" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们检查一下决策树模型的准确性。</p><pre class="kj kk kl km gt nr ns nt nu aw nv bi"><span id="7d1c" class="nw lw it ns b gy nx ny l nz oa">print('Accuracy score of the Decision Tree model is {}'.format(accuracy_score(y_test, tree_yhat)))</span><span id="78ce" class="nw lw it ns b gy on ny l nz oa"><strong class="ns iu">Accuracy score of the Decision Tree model is 0.999288989494457</strong></span></pre><p id="c33d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">检查决策树模型的F1分数。</p><pre class="kj kk kl km gt nr ns nt nu aw nv bi"><span id="ef0c" class="nw lw it ns b gy nx ny l nz oa">print('F1 score of the Decision Tree model is {}'.format(f1_score(y_test, tree_yhat)))</span><span id="1316" class="nw lw it ns b gy on ny l nz oa"><strong class="ns iu">F1 score of the Decision Tree model is 0.776255707762557</strong></span></pre><p id="d6ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">检查混淆矩阵:</p><pre class="kj kk kl km gt nr ns nt nu aw nv bi"><span id="3988" class="nw lw it ns b gy nx ny l nz oa">confusion_matrix(y_test, tree_yhat, labels = [0, 1])</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/2ee90da70e6fdc78c671800e151ee0fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1340/format:webp/1*Y4jRartZZMjQAhWBJIySZQ.png"/></div></figure><p id="4d7a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，第一行代表正，第二行代表负。因此，我们有68782个是真阳性，18个是假阳性。也就是说，在68782+18=68800笔交易中，我们有68782笔成功归类为正常交易，18笔被错误归类为正常交易，但它们是欺诈交易。</p><p id="d495" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们尝试不同的模型，并检查它们的性能。</p><blockquote class="og oh oi"><p id="07fb" class="kz la oj lb b lc ld ju le lf lg jx lh ok lj lk ll ol ln lo lp om lr ls lt lu im bi translated">k-最近邻</p></blockquote><pre class="kj kk kl km gt nr ns nt nu aw nv bi"><span id="774f" class="nw lw it ns b gy nx ny l nz oa">n = 7<br/>KNN = KNeighborsClassifier(n_neighbors = n)<br/>KNN.fit(X_train, y_train)<br/>knn_yhat = KNN.predict(X_test)</span></pre><p id="b29d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们检查一下K近邻模型的准确性。</p><pre class="kj kk kl km gt nr ns nt nu aw nv bi"><span id="7160" class="nw lw it ns b gy nx ny l nz oa">print('Accuracy score of the K-Nearest Neighbors model is {}'.format(accuracy_score(y_test, knn_yhat)))</span><span id="ac2f" class="nw lw it ns b gy on ny l nz oa"><strong class="ns iu">Accuracy score of the K-Nearest Neighbors model is 0.999506645771664</strong></span></pre><p id="93ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">检查K-最近邻模型的F1值。</p><pre class="kj kk kl km gt nr ns nt nu aw nv bi"><span id="caee" class="nw lw it ns b gy nx ny l nz oa">print('F1 score of the K-Nearest Neighbors model is {}'.format(f1_score(y_test, knn_yhat)))</span><span id="d3d0" class="nw lw it ns b gy on ny l nz oa"><strong class="ns iu">F1 score of the K-Nearest Neighbors model is 0.8365384615384616</strong></span></pre><blockquote class="og oh oi"><p id="636c" class="kz la oj lb b lc ld ju le lf lg jx lh ok lj lk ll ol ln lo lp om lr ls lt lu im bi translated">逻辑回归</p></blockquote><pre class="kj kk kl km gt nr ns nt nu aw nv bi"><span id="088f" class="nw lw it ns b gy nx ny l nz oa">lr = LogisticRegression()<br/>lr.fit(X_train, y_train)<br/>lr_yhat = lr.predict(X_test)</span></pre><p id="b3cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们检查我们的逻辑回归模型的准确性。</p><pre class="kj kk kl km gt nr ns nt nu aw nv bi"><span id="7a7a" class="nw lw it ns b gy nx ny l nz oa">print('Accuracy score of the Logistic Regression model is {}'.format(accuracy_score(y_test, lr_yhat)))</span><span id="e062" class="nw lw it ns b gy on ny l nz oa"><strong class="ns iu">Accuracy score of the Logistic Regression model is 0.9991148644726914</strong></span></pre><p id="88fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">检查逻辑回归模型的F1分数。</p><pre class="kj kk kl km gt nr ns nt nu aw nv bi"><span id="4095" class="nw lw it ns b gy nx ny l nz oa">print('F1 score of the Logistic Regression model is {}'.format(f1_score(y_test, lr_yhat)))</span><span id="e704" class="nw lw it ns b gy on ny l nz oa"><strong class="ns iu">F1 score of the Logistic Regression model is 0.6934673366834171</strong></span></pre><blockquote class="og oh oi"><p id="ef42" class="kz la oj lb b lc ld ju le lf lg jx lh ok lj lk ll ol ln lo lp om lr ls lt lu im bi translated">支持向量机</p></blockquote><pre class="kj kk kl km gt nr ns nt nu aw nv bi"><span id="3ae8" class="nw lw it ns b gy nx ny l nz oa">svm = SVC()<br/>svm.fit(X_train, y_train)<br/>svm_yhat = svm.predict(X_test)</span></pre><p id="2f18" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们检查我们的支持向量机模型的准确性。</p><pre class="kj kk kl km gt nr ns nt nu aw nv bi"><span id="f481" class="nw lw it ns b gy nx ny l nz oa">print('Accuracy score of the Support Vector Machines model is {}'.format(accuracy_score(y_test, svm_yhat)))</span><span id="e225" class="nw lw it ns b gy on ny l nz oa"><strong class="ns iu">Accuracy score of the Support Vector Machines model is 0.9993615415868594</strong></span></pre><p id="cd40" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">检查支持向量机模型的F1分数。</p><pre class="kj kk kl km gt nr ns nt nu aw nv bi"><span id="9c5c" class="nw lw it ns b gy nx ny l nz oa">print('F1 score of the Support Vector Machines model is {}'.format(f1_score(y_test, svm_yhat)))</span><span id="66c5" class="nw lw it ns b gy on ny l nz oa"><strong class="ns iu">F1 score of the Support Vector Machines model is 0.7777777777777779</strong></span></pre><blockquote class="og oh oi"><p id="d9c4" class="kz la oj lb b lc ld ju le lf lg jx lh ok lj lk ll ol ln lo lp om lr ls lt lu im bi translated">随机森林</p></blockquote><pre class="kj kk kl km gt nr ns nt nu aw nv bi"><span id="dbcf" class="nw lw it ns b gy nx ny l nz oa">rf = RandomForestClassifier(max_depth = 4)<br/>rf.fit(X_train, y_train)<br/>rf_yhat = rf.predict(X_test)</span></pre><p id="f8f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们检查一下随机森林模型的准确性。</p><pre class="kj kk kl km gt nr ns nt nu aw nv bi"><span id="c687" class="nw lw it ns b gy nx ny l nz oa">print('Accuracy score of the Random Forest model is {}'.format(accuracy_score(y_test, rf_yhat)))</span><span id="d057" class="nw lw it ns b gy on ny l nz oa"><strong class="ns iu">Accuracy score of the Random Forest model is 0.9993615415868594</strong></span></pre><p id="dfa9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">检查随机森林模型的F1分数。</p><pre class="kj kk kl km gt nr ns nt nu aw nv bi"><span id="2b43" class="nw lw it ns b gy nx ny l nz oa">print('F1 score of the Random Forest model is {}'.format(f1_score(y_test, rf_yhat)))</span><span id="72b5" class="nw lw it ns b gy on ny l nz oa"><strong class="ns iu">F1 score of the Random Forest model is 0.7843137254901961</strong></span></pre><blockquote class="og oh oi"><p id="4152" class="kz la oj lb b lc ld ju le lf lg jx lh ok lj lk ll ol ln lo lp om lr ls lt lu im bi translated">XGBoost</p></blockquote><pre class="kj kk kl km gt nr ns nt nu aw nv bi"><span id="691a" class="nw lw it ns b gy nx ny l nz oa">xgb = XGBClassifier(max_depth = 4)<br/>xgb.fit(X_train, y_train)<br/>xgb_yhat = xgb.predict(X_test)</span></pre><p id="d6f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们检查一下XGBoost模型的准确性。</p><pre class="kj kk kl km gt nr ns nt nu aw nv bi"><span id="050e" class="nw lw it ns b gy nx ny l nz oa">print('Accuracy score of the XGBoost model is {}'.format(accuracy_score(y_test, xgb_yhat)))</span><span id="057a" class="nw lw it ns b gy on ny l nz oa"><strong class="ns iu">Accuracy score of the XGBoost model is 0.9995211561901445</strong></span></pre><p id="ac97" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">检查XGBoost模型的F1分数。</p><pre class="kj kk kl km gt nr ns nt nu aw nv bi"><span id="3060" class="nw lw it ns b gy nx ny l nz oa">print('F1 score of the XGBoost model is {}'.format(f1_score(y_test, xgb_yhat)))</span><span id="de43" class="nw lw it ns b gy on ny l nz oa"><strong class="ns iu">F1 score of the XGBoost model is 0.8421052631578947</strong></span></pre><h1 id="4a52" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">结论</h1><p id="e6dd" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">恭喜你。！我们刚刚获得了99.95%的信用卡欺诈检测准确率。这个数字并不令人惊讶，因为我们的数据偏向一个类别。我们从混淆矩阵中注意到的好事情是——我们的模型没有过度拟合。</p><p id="d676" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，根据我们的准确度得分，XGBoost 在我们的案例中胜出。这里唯一的问题是我们收到的用于模型训练的数据。数据特征是PCA的变换版本。如果实际特征遵循相似的模式，那么我们做得很好！！</p></div><div class="ab cl mv mw hx mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="im in io ip iq"><blockquote class="og oh oi"><p id="e524" class="kz la oj lb b lc ld ju le lf lg jx lh ok lj lk ll ol ln lo lp om lr ls lt lu im bi translated"><em class="it">在你走之前……</em></p></blockquote><p id="cd7c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你喜欢这篇文章，并希望<strong class="lb iu">继续关注更多关于<strong class="lb iu"> Python &amp;数据科学</strong>的<strong class="lb iu">精彩文章</strong>——请点击这里<a class="ae ky" href="https://pranjalai.medium.com/membership" rel="noopener">https://pranjalai.medium.com/membership</a>考虑成为中级会员。</strong></p><p id="5913" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请考虑使用<a class="ae ky" href="https://pranjalai.medium.com/membership" rel="noopener">我的推荐链接</a>注册。通过这种方式，会员费的一部分归我，这激励我写更多关于Python和数据科学的令人兴奋的东西。</p><p id="4d25" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还有，可以随时订阅我的免费简讯:<a class="ae ky" href="https://pranjalai.medium.com/subscribe" rel="noopener"> <strong class="lb iu"> Pranjal的简讯</strong> </a>。</p></div></div>    
</body>
</html>