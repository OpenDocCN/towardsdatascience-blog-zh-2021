<html>
<head>
<title>A Look Inside the Bayesian Keyboard</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">看看贝叶斯键盘的内部</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/a-look-inside-the-bayesian-keyboard-c10c53e6d5a?source=collection_archive---------16-----------------------#2021-07-31">https://towardsdatascience.com/a-look-inside-the-bayesian-keyboard-c10c53e6d5a?source=collection_archive---------16-----------------------#2021-07-31</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="b940" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">让现代智能手机键盘变得智能的数据驱动功能的视觉之旅</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/858fe75dbc98bd5d733796b2059e2bf9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zoUFfNVEOPTn7fEqXzxqxQ.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">个性化的概率智能手机键盘，具有各种可视化功能:触摸分布、键区、不确定性/熵测量。(作者本人<em class="kv">法师)</em></p></figure><p id="8c32" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你输入的就是你得到的？没有现代触摸键盘。这篇文章直观地解释了smarpthone键盘的四个核心功能——包括个性化、自动纠错和单词预测。基于我为“智能用户界面”讲座创建的材料，我们检查了这些功能在我们日常打字中的内部工作，并以启发、评估和批判性反思数据驱动和“智能”用户界面的要点作为结论。</p><h1 id="98a5" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">特点1:调整关键领域</h1><p id="2da5" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">现代智能手机键盘对分配给每个按键的屏幕区域进行了个性化设置。这通常不会显示在图形用户界面中，以避免混淆和不良的共同适应——但我们可以在这里揭示它。</p><h2 id="2ef2" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated">触摸数据</h2><p id="9836" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">当用户打字时，键盘收集背景中的触摸位置(2D点:x，y)。该图显示了几天来收集的两个人的触摸数据。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nb"><img src="../Images/56f368a10e2dbe990c4f0f2f0eb49612.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UZeZFKPK04aYLbg5QBxgvg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">触摸两个用户的智能手机键盘。(作者本人<em class="kv">法师)</em></p></figure><h2 id="5647" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated">触摸键盘模型</h2><p id="2def" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">使用这些触摸，我们可以为每个用户创建个性化的按键:这些按键模型可以捕捉每个用户在键盘上的手指放置行为。例如，对Anna来说，字母“x”最好放在与Bob稍有不同的位置。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nb"><img src="../Images/714e06a4f8cd8a06f819275436f52aaa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9yHS7oZMozDGYBdKdwFhSA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">适用于两个用户的个性化键盘型号，安装在上图所示的触摸屏上。(我作者<em class="kv">法师)</em></p></figure><p id="c1dd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如图所示，我们为个性化键盘建模，每个键<em class="nc"> k </em>具有正态分布<em class="nc"> p(t|k) </em>，安装在该键的触摸位置上。形式上:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nb"><img src="../Images/21c0bb7551f1a785cdf747a18b1a8161.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fRWZ1ndAZ_-o43Oj-kNFFg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">每个键k被建模为正态分布，以该键的平均触摸位置为中心。该图示出了“c”键的例子。(本人<em class="kv">作者法师)</em></p></figure><p id="4229" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于每个键<em class="nc"> k </em>，模型因此存储对于该键观察到的触摸的平均位置<em class="nc">(x，y) </em>，以及<em class="nc">协方差矩阵</em>(可以直观地认为其描述了键的大小和形状)。视觉上，圆圈显示了这些分布的两个和三个标准偏差。</p><p id="55bd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们在<strong class="ky ir"> 3D </strong>中也可以这样看:每个键都是一座“小山”，高度对应的是触摸可能性<em class="nc"> p(t|k) </em>。图中显示了“c”键的示例。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nb"><img src="../Images/02acafb780426d898ef3cd174306c7f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X_oqaBZ02DVMeQ_HAm9X-w.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">“c”键触摸可能性的3D图。(我作者<em class="kv">法师)</em></p></figure><h2 id="90ac" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated">用户按了哪个键？解码触摸</h2><p id="d3ab" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">这种键盘模型可以用来解码触摸。“解码”仅仅意味着计算出用户想要按哪个键。</p><p id="485f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">结果显示在这些图中，其中颜色表示每个触摸位置(即像素)最可能的按键。我们已经推出了个性化键盘，根据每个用户的触摸行为进行像素到按键的分配。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nd"><img src="../Images/8fa509a65aae5452d90bbc0acf5fd123.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mFSS1_j8dNLURds3OUv37A.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">两个用户的像素到按键分配，揭示了手指在按键上放置的差异，键盘可以解释这种个性化。(作者本人<em class="kv">法师)</em></p></figure><p id="680b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">形式上，为了得到这些图，我们评估<em class="nc"> p(k|t)，</em>，即，给定触摸位置<em class="nc"> t </em>的按键<em class="nc"> k </em>的可能性。键盘模型产生了<em class="nc"> p(t|k) </em>，我们用<a class="ae ne" href="https://en.wikipedia.org/wiki/Bayes%27_theorem" rel="noopener ugc nofollow" target="_blank">贝叶斯法则</a>将其翻转为<em class="nc"> p(k|t) </em>。这产生了最可能的键<em class="nc">k’</em>:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nf"><img src="../Images/a0a181451610b0d5ae9650979bba584e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k_clg6oD3HotTNY3Qd9huQ.png"/></div></div></figure><blockquote class="ng nh ni"><p id="9c7c" class="kw kx nc ky b kz la jr lb lc ld ju le nj lg lh li nk lk ll lm nl lo lp lq lr ij bi translated">注意事项:</p><p id="ab11" class="kw kx nc ky b kz la jr lb lc ld ju le nj lg lh li nk lk ll lm nl lo lp lq lr ij bi translated"><em class="iq"> p(k) </em>是按键<em class="iq"> k </em>上的<strong class="ky ir">先验</strong>分布，描述了一般按键的可能性，不考虑触摸位置。简单的先验是一致的(即所有的关键字都有相同的可能性)。一个更好的先验使用语言环境，我们将在后面讨论。</p><p id="f460" class="kw kx nc ky b kz la jr lb lc ld ju le nj lg lh li nk lk ll lm nl lo lp lq lr ij bi translated"><em class="iq"> p(t|k) </em>是假设键为<em class="iq"> k </em>时触摸<em class="iq"> t </em>的<strong class="ky ir">可能性</strong>。这就是上面描述的<strong class="ky ir">高斯关键模型</strong>。</p></blockquote><h2 id="ba95" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated">不确定</h2><p id="3f8c" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">既然这是一个概率模型，那么我们可以看看键盘的<strong class="ky ir">不确定性</strong>。后验<em class="nc"> p(k|t) </em> <strong class="ky ir"> </strong>的<a class="ae ne" href="https://en.wikipedia.org/wiki/Entropy_(information_theory)" rel="noopener ugc nofollow" target="_blank">熵</a>就是这样一种不确定性的度量。直觉上，如果许多按键<em class="nc"> k </em>对于触摸位置<em class="nc"> t </em>的可能性相等，则该值为高。相反，如果一个特定的键被认为是唯一可能的键，则它是低的。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nd"><img src="../Images/197da6119de5e292a9b9508618f4d63c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2RfuJU7ZGOsStRjDP2xl3w.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">键盘像素上模型后验的不确定性(熵)。(我作者<em class="kv">法师)</em></p></figure><p id="6be5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面的图显示了这种熵:不确定性在不同像素-键分配之间的“边界”处最高。这符合我们的直觉，即靠近按键边缘的触摸是“草率的”，或者换句话说，比击中按键死点的触摸更难以理解。</p><h1 id="7567" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">特点二:整合语言语境</h1><p id="76eb" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">这种个性化键盘可以通过整合语言环境来进一步改进。为了说明，我们在这里使用一个简单的<strong class="ky ir">二元语言模型</strong>。二元组是一对字母(例如“th”)。这很容易建立:简单地计算大量文本中的字母对，并计算它们的相对频率。</p><p id="677a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在形式上，这个二元模型语言模型是给定前一个键的下一个键的可能性。将此作为解码等式中的先验，我们得到:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/845d9f7b28d2683be5199646a8ca85b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1284/format:webp/1*VGpO9rIZtYzqX3MY2vrBaQ.png"/></div></figure><p id="5a62" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以通过比较前一个字母是“q”的例子和前一个字母是“t”的例子来检验语言模型的影响。考虑到英语中这些字母的常见配对，我们期望“u”在“q”之后获得屏幕空间，“h”在“t”之后获得屏幕空间。事实上，该图揭示了这一变化。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nn"><img src="../Images/db61f86de3c9e64e482910314ee1a43d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cs8n5QsczXJF6QDcC2wBaQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">(简单)语言模型影响的例子:根据前一个字母是“q”还是“t”来改变按键分配。这些关键区域大小的变化符合我们的直觉，即英语中“q”后面经常跟着“u”，“t”后面经常跟着“h”。(作者本人<em class="kv">法师)</em></p></figure><p id="5b54" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了进一步检验这一结果，我们接下来比较了两种语言环境下模型不确定性的<strong class="ky ir">差异</strong>。这显示了由于变化的上下文，每个像素的确定性的增益(或损失)。</p><p id="9c65" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于我们从“q”切换到“t”的例子，如前一个字母，我们期望“u”周围的像素失去确定性，而“h”周围的像素获得确定性。这是因为:</p><ul class=""><li id="6ccb" class="no np iq ky b kz la lc ld lf nq lj nr ln ns lr nt nu nv nw bi translated">许多字母很可能跟在“t”后面——这与“q”形成对比，因为“q”后面除了“u”之外很少跟别的字母。</li><li id="7f8a" class="no np iq ky b kz nx lc ny lf nz lj oa ln ob lr nt nu nv nw bi translated">反过来，“th”很常见，增加了模型在“t”之后“h”的确定性。</li></ul><p id="caeb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">事实上，该图揭示了这种影响。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nn"><img src="../Images/c0f7947a55a6e4f6a04ba9d231980004.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*voHS-RCDvkW8dPPdFH0fyw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">键盘不确定性(后验熵)的变化取决于前一个字母是“q”还是“t”。(我作者<em class="kv">法师)</em></p></figure><h1 id="bca7" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">特点三:解码全词</h1><p id="619f" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">到目前为止，我们一次解码一个触摸，这相当于关键区域个性化。打字由许多连续的触摸组成。因此，我们也可以研究如何将触摸序列解码成单词，包括语言环境。这可以用来实现“自动校正”。</p><h2 id="7e49" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated">推广到序列</h2><p id="23ef" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">我们现在寻求找到最可能的字母序列<em class="nc"> s </em>，给定一个观察到的触摸位置序列<em class="nc"> o </em>。那就是:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/67a80bc0ac2e8a920764fbaa65d9a7ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1022/format:webp/1*X34ckDC5fv_02rhrFMD77A.png"/></div></figure><p id="b3a6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该等式与单次触摸的等式相同，并且原理保持不变。为了解码单词，我们只需要将其组成部分归纳为按键/触摸序列。为简单起见，假设<em class="nc"> n </em>触摸长度为<em class="nc"> n </em>的字<em class="nc"> ( </em>即<em class="nc"> </em>无遗漏或虚假触摸)，这可以形式化为:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi od"><img src="../Images/9688a92133176aeacd0e052e567bc838.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gxsb7sSjCAU1kYUH1B8gEQ.png"/></div></div></figure><blockquote class="ng nh ni"><p id="1102" class="kw kx nc ky b kz la jr lb lc ld ju le nj lg lh li nk lk ll lm nl lo lp lq lr ij bi translated">注意事项:</p><p id="b7cf" class="kw kx nc ky b kz la jr lb lc ld ju le nj lg lh li nk lk ll lm nl lo lp lq lr ij bi translated"><em class="iq"> p(s) </em>是一个先于的<strong class="ky ir">字母序列。为了说明，我们重用我们的<strong class="ky ir">二元模型</strong>。也就是说，<em class="iq"> n </em>个字母(例如一个单词)的序列的联合概率是其键到键转换(即二元模型)的产物。</strong></p><p id="df9c" class="kw kx nc ky b kz la jr lb lc ld ju le nj lg lh li nk lk ll lm nl lo lp lq lr ij bi translated"><em class="iq"> p(o|s) </em>是假设字母序列为<em class="iq"> s </em>时，触摸观察值<em class="iq"> o </em>的<strong class="ky ir">可能性</strong>。这里我们重用我们的<strong class="ky ir">高斯键模型</strong>，它为每次触摸产生<em class="iq"> p(t|k) </em>。我们通过乘法在序列上将其聚合为联合概率。</p></blockquote><h2 id="75fd" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated">用令牌传递算法寻找最可能的单词</h2><p id="8ac2" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">尝试所有可能的字母序列<em class="nc"> s </em>长度<em class="nc"> n </em>以找到最有可能的一个是极其昂贵的(指数)。我们需要做出妥协。具体地说，这里我们使用一个带有波束修剪的令牌传递算法。</p><p id="085f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">简而言之，该算法将一组部分序列作为“标记”来跟踪，这些部分序列可以被分割(即路径中的“分叉”:探索当前序列的多个延续)或被丢弃(即“死胡同”:由标记表示的序列变得太不可能)。</p><p id="889f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面显示了一个具体的例子:一个用户想要输入“hello”(左图)。该算法在假设空间中探索了两条路径(右图):“hello”和“helli”。如线条粗细所示，“你好”的可能性较大；解码发现正确的单词是最可能的单词(红色路径)。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oe"><img src="../Images/8aa0bff19ed1087a316d5c60b4f4bb07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Tya65bjW2jKuWZoHYtk6eg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">通过令牌传递解码预期输入“hello”的触摸序列(左图)。右边的图显示了算法通过假设空间的探索路径；从上到下阅读(垂直:触摸1-5，水平:红色探索字母，线条粗细表示可能性，红色路径最有可能)。(作者本人<em class="kv">法师)</em></p></figure><h2 id="fb04" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated">波束搜索宽度</h2><p id="f231" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">直观地说，波束宽度决定了我们希望允许多少探索。更多的探索可能会增加找到正确单词的机会，但也会增加计算时间。</p><p id="f2d0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过比较不同波束宽度的探索假设，波束宽度的影响变得可见，如下所示:在右侧，算法另外探索了“jello”，然而它认为这比正确的“hello”更不可能(参见与“he”相比以“je”开始的更细的路径)。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oe"><img src="../Images/e94e5ed7ae9eeeef473a41059cba52d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TF0mY8sWPfAZ6KOFM53kuQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">增加波束宽度导致探索假设空间中的更多部分(这里将“jello”添加到候选单词列表中)。(作者本人<em class="kv">法师)</em></p></figure><h2 id="4525" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated">插入和删除</h2><p id="4a3d" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">令牌传递算法<strong class="ky ir"> </strong>的扩展引入了插入(产生一个字母而不处理下一个触摸)和删除(处理下一个触摸而不产生字母)。这些解决了两个常见的用户错误:虚假(误)触摸和意外跳过的按键。</p><p id="8963" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然我们在这里不涉及技术细节，但是接下来的两个图用具体的例子说明了插入和删除的解码。</p><p id="1d95" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于<strong class="ky ir">插入</strong>，我们看例子“hllo”(不小心跳过了“e”)。下图中的插入解码器正确地找到“hello”作为最可能的单词:直观地说，插入“e”比简单地跟随触摸证据产生更高的总体可能性，因为“he”在英语中比“hl”更可能。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oe"><img src="../Images/9288210f12067d2d0453a37cc5738fa9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3IWYDBka0oA_-miryv5eow.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">用可以插入额外字母的解码器解码“hllo”(用户不小心跳过了“e”)。(作者本人<em class="kv">法师)</em></p></figure><p id="668d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请注意，本例中的解码器还通过在开头插入“t”来探索“thllo”，因为“th”在英语中的可能性很高。</p></div><div class="ab cl of og hu oh" role="separator"><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok"/></div><div class="ij ik il im in"><p id="0a98" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">补充一下，对于<strong class="ky ir">删除</strong>，我们看“hqello”(偶然的“q”)的例子。解码器正确地发现“hello”是最有可能的假设:虽然“hq”很可能被触摸，但“qe”不太可能通过“ε”(空)跳过“q”而取“he”。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oe"><img src="../Images/ed0b3ff449aebc035fcb90d655ee29a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BcfuSp-vsTRa6dFodZpWMA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">用可以删除触摸(ε)而不是产生字母的解码器解码“hqello”(注意伪“q”)。(作者本人<em class="kv">法师)</em></p></figure><h1 id="d744" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">功能4:建议下一个单词</h1><p id="360c" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">到目前为止，所有功能都假设用户已经触摸了按键。相比之下，如果我们没有接触，我们只能依靠语言环境。这产生了“单词建议”的特征。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi om"><img src="../Images/0e305286f9aa83733c2220b7e884af8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*CMPkJhcIvGdjHJPBokosCA.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">智能手机键盘上的单词建议，在键入“Hello”后显示。(我作者<em class="kv">法师)</em></p></figure><p id="cd04" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，我们可以查看最后的n-1个字来预测下一个字:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi on"><img src="../Images/571951f7737b28518988fbfc2d05e1a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:712/format:webp/1*NDQGmzTV-c-pj1o-852mNg.png"/></div></figure><p id="f518" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是一个简单的单词级的<em class="nc">n</em>gram模型，可以通过统计大型文本语料库中的单词序列来训练。最近，深度学习语言模型也被用于这项任务。它们提供了一些优势，比如能够包含更长的上下文。</p><h1 id="23a0" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">讨论和要点</h1><p id="185d" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在深入你的键盘之后，这一切意味着什么？这里有三个观点可能会影响未来“智能”用户界面的设计，分别是:1)构思，2)评估，3)超越交互的批判性思考。</p><h2 id="2112" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated"><strong class="ak"> <em class="kv">你的数据驱动键盘的幕后正在进行很多事情</em> </strong></h2><p id="ead0" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">回到一个键盘应用程序，例如五到十年前。我最近这样做是为了好玩，但感觉不太对劲:我觉得奇怪地笨拙和缓慢——可能是因为旧键盘还没有关于我的触摸数据，当然也没有我已经习惯的语言建模和解码的质量。</p><p id="bd55" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">→ <em class="nc">构思:</em>为了激发“智能”ui的新想法，我们可能会问，如何将成功的数据驱动和概率概念从键盘更普遍地转移到GUI上(也见最后的建议阅读)。</p><h2 id="cbc9" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated"><strong class="ak"> <em class="kv"> UX不止是UI，尤其是具有“智能”的UI</em></strong></h2><p id="f834" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">如上所述，旧键盘看起来和我最新的键盘应用几乎一样，但是我的用户体验要差很多。今天的键盘是一个交互系统的主要例子，在这个系统中，UX不能从视觉UI中辨别出来，这不能揭示潜在的算法质量。</p><p id="eee5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">→ <em class="nc">评估:</em>经验评估对于自适应ui的设计至关重要。可以预期，未来的进展将受益于来自人机交互和人工智能的知识和方法。</p><h2 id="c22c" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated"><strong class="ak"> <em class="kv">数据驱动的ui中的数据是如何使用的？</em> </strong></h2><p id="64bb" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">我们已经每天与数据驱动的用户界面交互，这些用户界面收集我们的数据。键盘是极少数交互系统之一，至少在原则上，这些系统只收集输入数据来改进输入法<em class="nc">本身</em>。</p><p id="97a5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">→ <em class="nc">反思:</em>我们可以通过调查用户数据在原位(即交互中)与非原位(即超出使用范围)的使用情况，来批判性地检验数据驱动的用户界面。</p><h2 id="e089" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated">回顾和思考要点</h2><p id="ac6a" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">为了激发进一步的讨论和见解，我们可以将今天的触摸键盘视为:</p><ul class=""><li id="a2aa" class="no np iq ky b kz la lc ld lf nq lj nr ln ns lr nt nu nv nw bi translated"><em class="nc">数据驱动的ui:</em>键盘使用触摸数据和语言数据来改善你的打字体验和效率。</li><li id="996d" class="no np iq ky b kz nx lc ny lf nz lj oa ln ob lr nt nu nv nw bi translated"><em class="nc">概率ui:</em>键盘在解释你的输入时会考虑到不确定性。</li><li id="6cab" class="no np iq ky b kz nx lc ny lf nz lj oa ln ob lr nt nu nv nw bi translated"><em class="nc">动态和自适应的用户界面:</em>集成一个语言模型并不是脱离输入的“魔法”,而是导致像素到键分配的动态变化。</li><li id="26fc" class="no np iq ky b kz nx lc ny lf nz lj oa ln ob lr nt nu nv nw bi translated"><em class="nc">生物识别用户界面:</em>为了适应按键，键盘会学习你个人触摸行为的表现，这因用户而异，就像行为指纹一样。</li><li id="46ca" class="no np iq ky b kz nx lc ny lf nz lj oa ln ob lr nt nu nv nw bi translated"><em class="nc">欺骗性用户界面:</em>键盘内部使用不同的像素到按键的分配，而不是屏幕上显示的按键(出于好意:避免混淆和恶化的协同适应)。</li><li id="4d7a" class="no np iq ky b kz nx lc ny lf nz lj oa ln ob lr nt nu nv nw bi translated"><em class="nc">搜索者:</em>键盘搜索一个巨大的假设空间，将你的输入触摸“解码”成单词和句子。</li></ul><h1 id="d09e" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">结论</h1><p id="519c" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">我们已经获得了使今天的智能手机键盘智能的核心功能，并通过基于具体触摸和语言数据的可视化来探索它们的效果和中心参数。</p><p id="8d69" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">至关重要的是，这里解释的四个核心特征都来自一个概率框架(贝叶斯规则)，通过用不同的具体组件填充它的槽。以下是总结:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oo"><img src="../Images/4ca3a3f2ded188f91acf09ffb143490c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CiXo6hCwHluL-xgTEAVc2w.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">贝叶斯键盘概述。(我作者<em class="kv">法师)</em></p></figure><p id="3e6a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">总之，移动触摸键盘已经成为“智能”、数据驱动和概率用户界面的一个普遍的日常例子。</p><p id="6b7d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">延伸阅读:</p><ul class=""><li id="ca0c" class="no np iq ky b kz la lc ld lf nq lj nr ln ns lr nt nu nv nw bi translated"><a class="ae ne" href="https://uxdesign.cc/what-if-gui-elements-were-not-limited-to-boxes-2f73a9ff9ec4" rel="noopener" target="_blank">键盘以外的其他触摸图形用户界面的概率概念</a></li><li id="2fe4" class="no np iq ky b kz nx lc ny lf nz lj oa ln ob lr nt nu nv nw bi translated"><a class="ae ne" href="https://oxford.universitypressscholarship.com/view/10.1093/oso/9780198799603.001.0001/oso-9780198799603" rel="noopener ugc nofollow" target="_blank">关于令牌传递和输入解码的更多信息</a></li><li id="5245" class="no np iq ky b kz nx lc ny lf nz lj oa ln ob lr nt nu nv nw bi translated">寻找幻灯片，代码等。？这是基于我在德国拜罗伊特大学的“智能用户界面”讲座上创作的材料。与他人共同教授的开放版本，可在此获得:【https://iui-lecture.org/】T4(包括重现剧情的Python笔记本)。</li></ul></div></div>    
</body>
</html>