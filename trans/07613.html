<html>
<head>
<title>C++ Basics: Understanding Exception Handling</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">C++基础:理解异常处理</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/c-basics-understanding-exception-handling-b2a8271433a7?source=collection_archive---------22-----------------------#2021-07-12">https://towardsdatascience.com/c-basics-understanding-exception-handling-b2a8271433a7?source=collection_archive---------22-----------------------#2021-07-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="08d7" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">为什么它是处理错误的更好方法？它是如何在引擎盖下工作的？让我们后退一步，看看它到底提供了什么。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f19b9a46eaa1c1db1d88234549933e12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wRb-OtRz5B8YKRt0"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">凯文·Ku在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><h1 id="9308" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">什么是异常处理？</h1><p id="b25d" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">软件中的异常是指阻止软件执行常规路径的错误情况。这些错误可能是软件本身可以控制的，如错误的参数或超出其控制范围。例如，打开文件、套接字、分配内存块等系统调用返回的错误。</p><p id="1eac" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">异常处理提供了一种更好的机制来检测和处理错误。为了理解为什么它更好，现在让我们看看在没有异常处理的情况下，我们如何检测和处理错误，比如在像c这样的编程语言中。</p><h2 id="12c5" class="ms la it bd lb mt mu dn lf mv mw dp lj ma mx my ll me mz na ln mi nb nc lp nd bi translated">检测和处理错误的传统方法</h2><p id="e0ad" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我们通常将程序分解成多个函数或子程序，使其模块化，更容易理解。这意味着我们的程序将有多个链接的函数调用。每个函数都可以返回一些信息供调用者使用。</p><p id="753f" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">让我们看一个简单的程序，将两个必须小于100的整数相加。我们可以这样写程序:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">错误传播1(作者编写的代码)</p></figure><p id="2929" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">所有涉及的函数都返回一个整数，当我们遇到错误时，我们返回<strong class="lt iu"> <em class="ng"> -1 </em> </strong>。但是我们这里遗漏了一些东西，<strong class="lt iu"> <em class="ng"> -1 </em> </strong>可能是加法的结果。我们可能想要添加一个检查来确保参数不小于<strong class="lt iu"> <em class="ng"> 0 </em> </strong>。但是现在，在主函数中，当我们收到一个错误时，我们不知道它是哪一个，是<em class="ng"> &lt; 0 </em>还是<em class="ng"> &gt; 100 </em>。我们需要添加一个全局变量<strong class="lt iu">。</strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">错误传播2(作者编写的代码)</p></figure><p id="bb87" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">所以现在我们有了一个检测错误和处理错误的机制。根据您的程序，函数调用可能会更长。</p><p id="74c4" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这是我们以传统方式处理错误的方式，例如当我们想用C编程语言打开一个文件时:</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="cd39" class="ms la it ni b gy nm nn l no np">FILE *fp;<br/>fp = fopen ("file.txt", "w+");</span></pre><p id="f90d" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">如果<strong class="lt iu"> fp == NULL </strong>，则操作失败，全局变量<strong class="lt iu"> errno </strong>被更新。</p><h2 id="b33b" class="ms la it bd lb mt mu dn lf mv mw dp lj ma mx my ll me mz na ln mi nb nc lp nd bi translated">传统方法的一些问题</h2><p id="a57f" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">上述传统方法存在一些问题。这些是其中的一些:</p><ul class=""><li id="12a1" class="nq nr it lt b lu mn lx mo ma ns me nt mi nu mm nv nw nx ny bi translated">所有涉及的函数必须返回相同的类型，例如integer来传播错误状态。这些函数调用可能相当长，并且它们被强制返回相同的类型。</li><li id="16cd" class="nq nr it lt b lu nz lx oa ma ob me oc mi od mm nv nw nx ny bi translated">在处理程序的函数调用返回后，必须立即检查全局变量，或者缓存全局变量。因为当随后发生另一个错误时，它可能被更新。</li><li id="86cc" class="nq nr it lt b lu nz lx oa ma ob me oc mi od mm nv nw nx ny bi translated">是否处理错误取决于调用者。如果不处理它，可能会导致程序稍后崩溃或程序异常继续。</li></ul><h2 id="ae7f" class="ms la it bd lb mt mu dn lf mv mw dp lj ma mx my ll me mz na ln mi nb nc lp nd bi translated">用异常处理来处理错误</h2><p id="f4ff" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">异常处理如何改进传统方法？</p><p id="784b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">对于初学者来说，它在<strong class="lt iu">知道错误</strong>的代码和<strong class="lt iu">知道如何处理错误</strong>的代码之间提供了一个<strong class="lt iu">清晰的分隔</strong>，并且中间的所有代码都可以安全地<strong class="lt iu">忽略错误</strong>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">带异常处理(由作者编写的代码)</p></figure><p id="377a" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">有了异常处理，我们的代码现在看起来不同了。中间的函数<strong class="lt iu"> <em class="ng"> add_wrapper() </em> </strong>不一定要返回<strong class="lt iu"> integer </strong>类型。它不需要知道错误。当抛出一个错误时，将在捕获该错误的<strong class="lt iu"> <em class="ng"> main() </em> </strong>函数中进行处理。现在，无论您在错误检测器和错误处理程序之间添加多少函数，它们都可以忽略它们不应该关心的错误。</p><p id="503e" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们可以去掉全局变量。</p><p id="a542" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">关于最后一点，如果没有处理异常，程序将会终止，因为C++运行时将调用std::terminate。</p><p id="16f8" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">如果我们删除代码中的try-catch并执行它，我们会得到以下结果:</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="f502" class="ms la it ni b gy nm nn l no np">terminate called after throwing an instance of 'std::invalid_argument'<br/>  what():  parameters must be &gt;= 0<br/>Aborted (core dumped)</span></pre><p id="d32b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">所以它是更安全的，从某种意义上说，程序不会继续运行，我们会得到一些关于发生了什么的信息。</p><p id="6ffc" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">现在我们已经看到了异常处理提供了什么，让我们深入了解更多的细节。</p><h1 id="4c87" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">C++中的异常处理</h1><p id="3790" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">上面我们已经看到了如何用C++编写异常处理，它由两部分组成:</p><ul class=""><li id="986a" class="nq nr it lt b lu mn lx mo ma ns me nt mi nu mm nv nw nx ny bi translated">错误检测器:我们调用throw语句的地方</li><li id="c87d" class="nq nr it lt b lu nz lx oa ma ob me oc mi od mm nv nw nx ny bi translated">错误处理程序:我们编写try-catch语句的地方</li></ul><h2 id="6314" class="ms la it bd lb mt mu dn lf mv mw dp lj ma mx my ll me mz na ln mi nb nc lp nd bi translated">异常作用于函数</h2><p id="e9b9" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">异常通过在所有相关函数中添加额外的信息和代码来工作。所涉及的功能不仅包括<strong class="lt iu">探测器和处理器</strong>还包括<strong class="lt iu">在</strong>之间的所有功能。</p><p id="6285" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">现在你可以看到这不是魔术，所有涉及的功能必须仍然做一些事情来实现这个错误报告。</p><p id="9562" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">不同的是，所有这些工作都是由编译器 为我们完成的<strong class="lt iu"> <em class="ng">，所以从我们的代码中是看不到的。这就是为什么我们需要理解这个概念，因为仅仅看代码是不明显的。</em></strong></p><p id="6e16" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">添加到参与异常的所有函数中的额外信息和代码都被添加到相关函数代码的末尾，位于称为LSDA(语言特定数据区)的区域。</p><p id="e094" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">LSDA包含函数是否能捕获异常、异常的类型以及如何清理函数的信息。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/ab74acc4140c3bea95b09baecc8ad1e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:962/format:webp/1*HKGjB939VHDQnWweHixMYw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">无一例外的函数代码(图片由作者提供)</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi of"><img src="../Images/d6062bd342e99d37a084af0e01033d8f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1282/format:webp/1*Mt9Z5pCsScEZIT5zwSi7kw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">异常的函数代码(图片由作者提供)</p></figure><p id="5e67" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">如上所示，当我们使用异常时，编译器会为我们生成额外的代码。</p><p id="045d" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">实现细节是特定于语言和编译器的，通常通过一个名为<strong class="lt iu"> <em class="ng">的函数来实现个性函数</em> </strong> <em class="ng"> </em>，它使用C++运行时的元数据(见上图)来:</p><ul class=""><li id="fa66" class="nq nr it lt b lu mn lx mo ma ns me nt mi nu mm nv nw nx ny bi translated">搜索可以处理所引发的异常类型的处理程序</li><li id="3de6" class="nq nr it lt b lu nz lx oa ma ob me oc mi od mm nv nw nx ny bi translated">执行清理程序，如销毁物品</li></ul><p id="03d9" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">当调用<em class="ng"> throw </em>语句时，C++运行时将搜索处理程序，并在一个称为堆栈展开的过程中执行清理例程。根据编译器的不同，这可能是一次通过或两次通过的过程。</p><p id="1c1e" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在一次通过过程中，每次展开返回一个功能时，搜索之后是清除过程，直到找到<em class="ng"> try-catch </em>。</p><p id="1d81" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在两遍过程中，搜索在没有清理的情况下完成，只有在第二遍中找到处理程序时才执行清理例程。</p><h2 id="365a" class="ms la it bd lb mt mu dn lf mv mw dp lj ma mx my ll me mz na ln mi nb nc lp nd bi translated">安全设计</h2><p id="8cd1" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在C++中有一些我们需要知道的细节，以确保我们的代码是安全编写的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">内存泄漏(作者代码)</p></figure><p id="ce41" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">如果<strong class="lt iu"> <em class="ng"> add() </em> </strong>抛出异常，上面的代码可能会导致内存泄漏。因为最后两行没有执行。编译器不能为这个函数生成cleanup例程，它能做的就是生成cleanup来调用析构函数，但是<strong class="lt iu"> <em class="ng"> temp </em> </strong>不是对象。</p><blockquote class="og oh oi"><p id="2edf" class="lr ls ng lt b lu mn ju lw lx mo jx lz oj mp mc md ok mq mg mh ol mr mk ml mm im bi translated">记住这一点的最简单的方法是不要在所有涉及的函数中使用指针。</p></blockquote><p id="13e7" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">另一个细节是构造函数中引发的异常。如果在构造函数中引发异常，编译器不会生成清理例程。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">ctor中的异常(作者代码)</p></figure><p id="f610" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在上面的代码中，我们有一个内存泄漏，因为没有进行适当的清理。编译器不会为<strong class="lt iu"><em class="ng">error propagator()</em></strong>函数生成清理例程。我相信是因为物体被认为是部分创造的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/838f760efd02f6ff56a9b3d344ae805a.png" data-original-src="https://miro.medium.com/v2/resize:fit:962/format:webp/1*IznyezBL6L_jrAs9J3pPGw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">没有清理的异常(图片由作者提供)</p></figure><p id="2156" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">为了解决这个问题，我们应该避免在构造函数中使用原始指针，而是使用包装器。并且，我们所有的对象都应该实现<a class="ae ky" href="https://en.cppreference.com/w/cpp/language/raii#:~:text=Resource%20Acquisition%20Is%20Initialization%20or,in%20limited%20supply)%20to%20the" rel="noopener ugc nofollow" target="_blank"> RAII(资源分配是初始化)习语</a>，以确保所有的对象都被清理。</p><p id="449b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这是因为清理例程是为构造函数生成的。下面我们来看看正确的版本。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">正确清除的ctor中的异常(由作者编写的代码)</p></figure><p id="f86c" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这样，我们就为构造函数生成了一个清理例程。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi of"><img src="../Images/e5ad640fce3f2ceffc7b52ab00b13a33.png" data-original-src="https://miro.medium.com/v2/resize:fit:1282/format:webp/1*KgWlE3bowtt7SYD8_J0UYw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">清理时出现异常(图片由作者提供)</p></figure><h2 id="a013" class="ms la it bd lb mt mu dn lf mv mw dp lj ma mx my ll me mz na ln mi nb nc lp nd bi translated">没有例外——打破链条</h2><p id="dc0a" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">有些情况下，我们不想捕捉或传播异常。C++通过在函数名末尾添加一个<strong class="lt iu"> <em class="ng"> noexcept </em> </strong>关键字提供了一种方法。如果我们通过向<strong class="lt iu"><em class="ng">error propagator()</em></strong>函数添加一个<em class="ng"> noexcept </em>关键字来修改上面的代码，则不会生成元数据，并且对错误处理程序的搜索将会失败，这将导致C++运行时调用std::terminate。</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="848b" class="ms la it ni b gy nm nn l no np">void ErrorPropagator() noexcept<br/>{<br/>    Error error;<br/>    error.Test();<br/>}</span></pre><p id="48f9" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">结果是:</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="f0df" class="ms la it ni b gy nm nn l no np">terminate called after throwing an instance of 'std::invalid_argument'<br/>  what():  wrong error parameter<br/>Aborted (core dumped)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi of"><img src="../Images/73fb5ecc7238c19e9a76491eb7e7b8b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1282/format:webp/1*XgDfVoxvCMA25mawXkfGog.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">除了错误传播器(图片由作者提供)</p></figure><h1 id="d635" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">摘要和参考文献</h1><p id="5af5" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我们现在知道了异常处理可以解决什么问题，它是如何工作的——编译器添加了额外的代码，以及我们在编写C++代码时需要注意什么。</p><p id="6834" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">理解这个概念有助于我们写出更好的C++代码。</p><h2 id="94f1" class="ms la it bd lb mt mu dn lf mv mw dp lj ma mx my ll me mz na ln mi nb nc lp nd bi translated">一些好的参考</h2><div class="om on gp gr oo op"><a href="https://docs.microsoft.com/en-us/cpp/cpp/exception-handling-in-visual-cpp?view=msvc-160" rel="noopener  ugc nofollow" target="_blank"><div class="oq ab fo"><div class="or ab os cl cj ot"><h2 class="bd iu gy z fp ou fr fs ov fu fw is bi translated">MSVC的异常处理</h2><div class="ow l"><h3 class="bd b gy z fp ou fr fs ov fu fw dk translated">异常是一种错误情况，可能在程序的控制之外，阻止程序继续运行…</h3></div><div class="ox l"><p class="bd b dl z fp ou fr fs ov fu fw dk translated">docs.microsoft.com</p></div></div><div class="oy l"><div class="oz l pa pb pc oy pd ks op"/></div></div></a></div><div class="om on gp gr oo op"><a href="http://systemtbe.blogspot.com/2017/02/notes-on-c-exception-handling-and-stack.html" rel="noopener  ugc nofollow" target="_blank"><div class="oq ab fo"><div class="or ab os cl cj ot"><h2 class="bd iu gy z fp ou fr fs ov fu fw is bi translated">关于C++异常处理和堆栈展开的注释</h2><div class="ow l"><h3 class="bd b gy z fp ou fr fs ov fu fw dk translated">如果您看一下LLVM文档，您可能会惊讶地发现不同的处理器架构有…</h3></div><div class="ox l"><p class="bd b dl z fp ou fr fs ov fu fw dk translated">systemtbe.blogspot.com</p></div></div><div class="oy l"><div class="pe l pa pb pc oy pd ks op"/></div></div></a></div><div class="om on gp gr oo op"><a href="https://www.codeproject.com/Articles/2126/How-a-C-compiler-implements-exception-handling" rel="noopener  ugc nofollow" target="_blank"><div class="oq ab fo"><div class="or ab os cl cj ot"><h2 class="bd iu gy z fp ou fr fs ov fu fw is bi translated">C++编译器如何实现异常处理</h2><div class="ow l"><h3 class="bd b gy z fp ou fr fs ov fu fw dk translated">C++相对于传统语言的革命性特征之一是它对异常处理的支持。它提供了…</h3></div><div class="ox l"><p class="bd b dl z fp ou fr fs ov fu fw dk translated">www.codeproject.com</p></div></div><div class="oy l"><div class="pf l pa pb pc oy pd ks op"/></div></div></a></div></div></div>    
</body>
</html>