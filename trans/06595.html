<html>
<head>
<title>How to improve the accuracy of a Regression Model</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何提高回归模型的准确性</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-improve-the-accuracy-of-a-regression-model-3517accf8604?source=collection_archive---------0-----------------------#2021-06-14">https://towardsdatascience.com/how-to-improve-the-accuracy-of-a-regression-model-3517accf8604?source=collection_archive---------0-----------------------#2021-06-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="7a7c" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">提高模型精度的提示和技巧</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/b51a3098ecd4e5ac65e2ff9e6d03ea23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ml2LIpSMEdgWF__NSLoEdQ.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">马克A在<a class="ae kv" href="https://unsplash.com/@grvault?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="e57a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这篇文章中，我们将看到如何处理回归问题，以及如何通过使用特征转换、特征工程、聚类、boosting算法等概念来提高机器学习模型的准确性。</p><p id="ac99" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">数据科学是一个迭代的过程，只有经过反复实验，我们才能获得满足我们需求的最佳模型/解决方案。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ls"><img src="../Images/c328375d0d3c9a1519572b1f8454e247.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*_zcVnX2xGxMVgjkN7tlRMQ.gif"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">数据科学流程图-作者图片</p></figure><p id="047a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们通过一个例子来关注上面的每个阶段。我有一个健康保险<a class="ae kv" href="https://github.com/sacharya225/data-expts/blob/master/Health%20Insurance%20Cost%20Prediction/insurance.csv" rel="noopener ugc nofollow" target="_blank">数据集</a> (CSV文件)，里面有保险费用、年龄、性别、身体质量指数等客户信息。我们必须根据数据集中的这些参数来预测保险费用。这是一个回归问题，因为我们的目标变量——费用/保险成本——是数字。</p><p id="ecd0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们从加载数据集和探索属性(EDA探索性数据分析)开始</p><pre class="kg kh ki kj gt lt lu lv lw aw lx bi"><span id="c256" class="ly lz iq lu b gy ma mb l mc md">#Load csv into a dataframe<br/>df=pd.read_csv('insurance_data.csv')<br/>df.head(3)</span><span id="4d1e" class="ly lz iq lu b gy me mb l mc md">#Get the number of rows and columns<br/>print(f'Dataset size: {df.shape}')<br/><strong class="lu ir">(1338,7)</strong></span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mf"><img src="../Images/dd0120435ef461406c14393daae87226.png" data-original-src="https://miro.medium.com/v2/resize:fit:1358/format:webp/1*6GK__BZhQgrZBnhwtaTHuQ.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">健康保险数据框架—作者图片</p></figure><p id="4482" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">数据集有1338条记录和6个特征。吸烟者、性别和地区是分类变量，而年龄、身体质量指数和儿童是数字变量。</p><p id="8757" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">处理空值/缺失值</strong></p><p id="0ca9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们检查数据集中缺失值的比例:</p><pre class="kg kh ki kj gt lt lu lv lw aw lx bi"><span id="e8e4" class="ly lz iq lu b gy ma mb l mc md">df.isnull().sum().sort_values(ascending=False)/df.shape[0]</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mg"><img src="../Images/17b824eecd0b38d1ad6e934fad074c6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:516/format:webp/1*qcLRTIY6zlw8ILHcthwjOQ.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">列中空值的百分比-按作者排序的图像</p></figure><p id="9eb8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">年龄和身体质量指数有一些空值——尽管很少。我们将处理这些丢失的数据，然后开始我们的数据分析。Sklearn的<a class="ae kv" href="https://scikit-learn.org/stable/modules/generated/sklearn.impute.SimpleImputer.html" rel="noopener ugc nofollow" target="_blank">simple imputr</a>允许您根据相应列中的平均值/中值/最频繁值替换缺失值。在这个例子中，我使用中间值来填充空值。</p><pre class="kg kh ki kj gt lt lu lv lw aw lx bi"><span id="b197" class="ly lz iq lu b gy ma mb l mc md">#Instantiate SimpleImputer <br/>si=SimpleImputer(missing_values = np.nan, strategy="median")<br/>si.fit(df[[’age’, 'bmi’]])<br/>  <br/>#Filling missing data with median<br/>df[[’age’, 'bmi’]] = si.transform(df[[’age’, 'bmi’]])</span></pre><p id="6502" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">数据可视化</strong></p><p id="af18" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">既然我们的数据是干净的，我们将通过可视化和地图来分析数据。一个简单的seaborn <a class="ae kv" href="https://seaborn.pydata.org/generated/seaborn.pairplot.html" rel="noopener ugc nofollow" target="_blank"> pairplot </a>可以给我们很多见解！</p><pre class="kg kh ki kj gt lt lu lv lw aw lx bi"><span id="cbe3" class="ly lz iq lu b gy ma mb l mc md">sns.pairplot(data=df, diag_kind='kde')</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/e618abbe6431cfad20b1e110f21c0de6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1312/format:webp/1*yOnrEiwJos4ozjDahusjqQ.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Seaborn Pairplot —作者图片</p></figure><p id="9970" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们看到了什么..？</p><ol class=""><li id="3e46" class="mi mj iq ky b kz la lc ld lf mk lj ml ln mm lr mn mo mp mq bi translated">收费和孩子是倾斜的。</li><li id="4811" class="mi mj iq ky b kz mr lc ms lf mt lj mu ln mv lr mn mo mp mq bi translated">年龄与电荷呈正相关。</li><li id="ff46" class="mi mj iq ky b kz mr lc ms lf mt lj mu ln mv lr mn mo mp mq bi translated">身体质量指数服从正态分布！😎</li></ol><p id="3358" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Seaborn的<a class="ae kv" href="https://seaborn.pydata.org/generated/seaborn.boxplot.html" rel="noopener ugc nofollow" target="_blank">箱线图</a>和计数图可用于显示分类变量对电荷的影响。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mw"><img src="../Images/b11a7142ad7851789547ceb167dcfba6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Go4G9EyPVhFLGOI2fHkoPQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">分类变量的seaborn计数图—作者图片</p></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mx"><img src="../Images/c6415198b8b50a16ec39723196f5e36f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4H8Qgge8QrEKEodc9HRS9A.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="b41d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">基于上述图的观察结果:</p><ol class=""><li id="ef07" class="mi mj iq ky b kz la lc ld lf mk lj ml ln mm lr mn mo mp mq bi translated">男性和女性在数量上<strong class="ky ir">几乎相等</strong>，平均而言，男性和女性的平均收费也相同，但<strong class="ky ir">男性的收费范围更大。</strong></li><li id="fe28" class="mi mj iq ky b kz mr lc ms lf mt lj mu ln mv lr mn mo mp mq bi translated">吸烟者的保险费相对较高。</li><li id="ec42" class="mi mj iq ky b kz mr lc ms lf mt lj mu ln mv lr mn mo mp mq bi translated">有两到三个孩子的人收费最高</li><li id="c339" class="mi mj iq ky b kz mr lc ms lf mt lj mu ln mv lr mn mo mp mq bi translated">客户几乎<strong class="ky ir">平均分布</strong>在四个地区，所有的<strong class="ky ir"> </strong>都有几乎<strong class="ky ir">相同的费用</strong>。</li><li id="a86a" class="mi mj iq ky b kz mr lc ms lf mt lj mu ln mv lr mn mo mp mq bi translated">女性吸烟者的百分比低于男性吸烟者的百分比。</li></ol><p id="c3a7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，我们可以得出结论，“吸烟者”对保险费有相当大的影响，而性别的影响最小。</p><p id="9d6f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们创建一个热图来了解费用和数字特征(年龄、身体质量指数和儿童)之间的关联强度。</p><pre class="kg kh ki kj gt lt lu lv lw aw lx bi"><span id="2d5d" class="ly lz iq lu b gy ma mb l mc md">sns.heatmap(df[['age', 'bmi', 'children', 'charges']].corr(), cmap='Blues', annot=True)<br/>plt.show()</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi my"><img src="../Images/15fe5c3a507316b01f27f4245f449763.png" data-original-src="https://miro.medium.com/v2/resize:fit:788/format:webp/1*-SGJqW0dyTCz0f_C3D9Wpw.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">相关图-作者提供的图片</p></figure><p id="fd8a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们看到年龄和身体质量指数与电荷有平均+ve的相关性。</p><p id="3351" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我们将逐一介绍模型准备和模型开发的步骤。</p><ol class=""><li id="5366" class="mi mj iq ky b kz la lc ld lf mk lj ml ln mm lr mn mo mp mq bi translated"><strong class="ky ir">特征编码</strong></li></ol><p id="1c93" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这一步中，我们将分类变量——吸烟者、性别和地区——转换为数字格式(0、1、2、3等)。)因为大多数算法不能处理非数值数据。这个过程称为编码，有许多方法可以做到这一点:</p><ol class=""><li id="d757" class="mi mj iq ky b kz la lc ld lf mk lj ml ln mm lr mn mo mp mq bi translated">LabelEncoding将分类值表示为数字(例如，值为意大利、印度、美国、英国的区域可以表示为1、2、3、4)</li><li id="48fd" class="mi mj iq ky b kz mr lc ms lf mt lj mu ln mv lr mn mo mp mq bi translated">OrdinalEncoding用于将基于等级的分类数据值表示为数字。(例如用1，2，3表示高、中、低)</li><li id="21f0" class="mi mj iq ky b kz mr lc ms lf mt lj mu ln mv lr mn mo mp mq bi translated">一键编码-将分类数据表示为二进制值-仅限0和1。如果分类特征中没有很多唯一值，我更喜欢使用一次性编码而不是标签编码。在这里，我在Region上使用了pandas的一个热编码函数(<a class="ae kv" href="https://pandas.pydata.org/docs/reference/api/pandas.get_dummies.html" rel="noopener ugc nofollow" target="_blank"> get_dummies </a>)，并将它分成4列——location _ NE、location_SE、location_NW和location_SW。你也可以为这个专栏使用<a class="ae kv" href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.LabelEncoder.html" rel="noopener ugc nofollow" target="_blank">标签编码</a>，然而，一个热门编码给了我一个更好的结果。</li></ol><pre class="kg kh ki kj gt lt lu lv lw aw lx bi"><span id="d18d" class="ly lz iq lu b gy ma mb l mc md">#One hot encoding<br/>region=pd.get_dummies(df.region, prefix='location')<br/>df = pd.concat([df,region],axis=1)<br/>df.drop(columns='region', inplace=True)</span><span id="83ab" class="ly lz iq lu b gy me mb l mc md">df.sex.replace(to_replace=['male','female'],value=[1,0], inplace=True)<br/>df.smoker.replace(to_replace=['yes', 'no'], value=[1,0], inplace=True)</span></pre><p id="8996" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> 2。特征选择和缩放</strong></p><p id="cc1b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，我们将选择对“费用”影响最大的功能。我选择了除性别之外的所有特征，因为它对“电荷”的影响很小(从上面的viz图表得出的结论)。这些特征将形成我们的“X”变量，而电荷将成为我们的“y”变量。如果有许多功能，我建议您使用scikit-learn的<a class="ae kv" href="https://scikit-learn.org/stable/modules/generated/sklearn.feature_selection.SelectKBest.html" rel="noopener ugc nofollow" target="_blank"> SelectKBest </a>进行功能选择，以获得顶级功能。</p><pre class="kg kh ki kj gt lt lu lv lw aw lx bi"><span id="fb09" class="ly lz iq lu b gy ma mb l mc md">#Feature Selection <br/>y=df.charges.values<br/>X=df[['age', 'bmi', 'smoker', 'children', 'location_northeast', 'location_northwest', 'location_southeast', 'location_southwest']]</span><span id="2a06" class="ly lz iq lu b gy me mb l mc md">#Split data into test and train<br/>X_train, X_test, y_train, y_test=train_test_split(X,y, test_size=0.2, random_state=42)</span></pre><p id="c671" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦我们选择了我们的特征，我们需要“标准化”的数字——年龄，身体质量指数，儿童。标准化过程将数据转换为0到1范围内的较小值，以便所有数据都位于相同的范围内，并且一个不会超过另一个。我这里用的是<a class="ae kv" href="http://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.StandardScaler.html" rel="noopener ugc nofollow" target="_blank">标准定标器</a>。</p><pre class="kg kh ki kj gt lt lu lv lw aw lx bi"><span id="90f5" class="ly lz iq lu b gy ma mb l mc md">#Scaling numeric features using sklearn StandardScalar<br/>numeric=['age', 'bmi', 'children']<br/>sc=StandardScalar()<br/>X_train[numeric]=sc.fit_transform(X_train[numeric])<br/>X_test[numeric]=sc.transform(X_test[numeric])</span></pre><p id="6842" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我们已经准备好创建我们的第一个基本模型😀 .我们将尝试线性回归和<a class="ae kv" href="https://scikit-learn.org/stable/modules/generated/sklearn.tree.DecisionTreeClassifier.html" rel="noopener ugc nofollow" target="_blank">决策树</a>来预测保险费用</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mz na l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/2c5139a6617a65f84331d58594e5b259.png" data-original-src="https://miro.medium.com/v2/resize:fit:922/format:webp/1*8QWyPyjcnNaQAt1amlmg7Q.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">模型分数-按作者分类的图片</p></figure><p id="df05" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">平均绝对误差(<a class="ae kv" rel="noopener" target="_blank" href="/what-are-rmse-and-mae-e405ce230383"> MAE </a>)和均方根误差(<a class="ae kv" rel="noopener" target="_blank" href="/what-are-rmse-and-mae-e405ce230383"> RMSE </a>)是用于评估回归模型的指标。你可以在这里阅读更多关于它的<a class="ae kv" rel="noopener" target="_blank" href="/what-are-rmse-and-mae-e405ce230383">。我们的基准模型给出了超过76%的分数。在两者之间，决策树给出了更好的MAE 2780。不错..！</a></p><p id="5301" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们看看如何使我们的模型更好。</p><p id="c255" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> 3A。特征工程</strong></p><p id="ac83" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以通过操纵数据集中的一些特征来提高我们的模型得分。经过几次尝试后，我发现以下项目可以提高准确性:</p><ol class=""><li id="b4be" class="mi mj iq ky b kz la lc ld lf mk lj ml ln mm lr mn mo mp mq bi translated">使用KMeans将相似的客户分组。</li><li id="8412" class="mi mj iq ky b kz mr lc ms lf mt lj mu ln mv lr mn mo mp mq bi translated">在区域列中，将东北和西北区域分为“北”，将东南和西南区域分为“南”。</li><li id="1a5b" class="mi mj iq ky b kz mr lc ms lf mt lj mu ln mv lr mn mo mp mq bi translated">将“children”转换为名为“more_than_one_child”的分类特征，如果孩子的数量大于1，则为“Yes”</li></ol><pre class="kg kh ki kj gt lt lu lv lw aw lx bi"><span id="58e6" class="ly lz iq lu b gy ma mb l mc md">from sklearn.cluster import KMeans<br/>features=['age', 'bmi', 'smoker', 'children', 'location_northeast', 'location_northwest', 'location_southeast', 'location_southwest']<br/>kmeans = KMeans(n_clusters=2)<br/>kmeans.fit(df[features])</span><span id="8c59" class="ly lz iq lu b gy me mb l mc md">df['cust_type'] = kmeans.predict(df[features])</span><span id="5aca" class="ly lz iq lu b gy me mb l mc md">df['location_north']=df.apply(lambda x: get_north(x['location_northeast'], x['location_northwest']), axis=1)</span><span id="ae23" class="ly lz iq lu b gy me mb l mc md">df['location_south']=df.apply(lambda x: get_south(x['location_southwest'], x['location_southeast']), axis=1)</span><span id="d3cb" class="ly lz iq lu b gy me mb l mc md">df['more_than_1_child']=df.children.apply(lambda x:1 if x&gt;1 else 0)</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nc"><img src="../Images/32358d335a7b706fd6ba978cb2b4935b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zyoxBlfl5xz0TQnhG-PCNA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">所有功能-按作者分类的图像</p></figure><p id="0155" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> 3B。特征转换</strong></p><p id="612d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从我们的EDA中，我们知道“电荷”(Y)的分布是高度偏斜的，因此我们将应用scikit-learn的目标转换器— <a class="ae kv" href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.QuantileTransformer.html" rel="noopener ugc nofollow" target="_blank"> QuantileTransformer </a>来使这种行为正常化。</p><pre class="kg kh ki kj gt lt lu lv lw aw lx bi"><span id="6f14" class="ly lz iq lu b gy ma mb l mc md">X=df[['age', 'bmi', 'smoker', 'more_than_1_child', 'cust_type', 'location_north', 'location_south']]</span><span id="69ec" class="ly lz iq lu b gy me mb l mc md">#Split test and train data<br/>X_train, X_test, y_train, y_test=train_test_split(X,y, test_size=0.2, random_state=42)</span><span id="d78c" class="ly lz iq lu b gy me mb l mc md">model = DecisionTreeRegressor()<br/>regr_trans = TransformedTargetRegressor(regressor=model, transformer=QuantileTransformer(output_distribution='normal'))<br/>regr_trans.fit(X_train, y_train)<br/>yhat = regr_trans.predict(X_test)<br/>round(r2_score(y_test, yhat), 3), round(mean_absolute_error(y_test, yhat), 2), round(np.sqrt(mean_squared_error(y_test, yhat)),2)</span><span id="d04f" class="ly lz iq lu b gy me mb l mc md"><strong class="lu ir">&gt;&gt;0.843, 2189.28, 4931.96</strong></span></pre><p id="1aa8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">哇…高达84%…而MAE已经减少到2189了！</p><p id="4361" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> 4。使用集成和增强算法</strong></p><p id="1965" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们将在基于系综的RandomForest、GradientBoosting、LightGBM和XGBoost上使用这些特性。如果你是一个初学者，不知道助推和装袋方法，你可以在这里阅读更多关于它们的内容。</p><pre class="kg kh ki kj gt lt lu lv lw aw lx bi"><span id="3204" class="ly lz iq lu b gy ma mb l mc md">X=df[['age', 'bmi', 'smoker', 'more_than_1_child', 'cust_type', 'location_north', 'location_south']]</span><span id="38e9" class="ly lz iq lu b gy me mb l mc md">model = RandomForestRegressor()<br/>#transforming target variable through quantile transformer<br/>ttr = TransformedTargetRegressor(regressor=model, transformer=QuantileTransformer(output_distribution='normal'))<br/>ttr.fit(X_train, y_train)<br/>yhat = ttr.predict(X_test)</span><span id="ec59" class="ly lz iq lu b gy me mb l mc md">r2_score(y_test, yhat), mean_absolute_error(y_test, yhat), np.sqrt(mean_squared_error(y_test, yhat))</span><span id="53f2" class="ly lz iq lu b gy me mb l mc md"><strong class="lu ir">&gt;&gt;0.8802, 2078, 4312</strong></span></pre><p id="8bb0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">是啊！我们的随机森林模型确实表现不错——2078年的<a class="ae kv" rel="noopener" target="_blank" href="/what-are-rmse-and-mae-e405ce230383">梅</a>👍。现在，我们将尝试一些增强算法，如梯度增强、LightGBM和XGBoost。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mz na l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/85243cf22144860a6a0a29b8ea118646.png" data-original-src="https://miro.medium.com/v2/resize:fit:1074/format:webp/1*NOM1AW6OlDiQx7ALPylKvg.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">模型分数-按作者分类的图像</p></figure><p id="d2a4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">好像都表现不错:)</p><p id="5afa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> 5。超参数调谐</strong></p><p id="89f5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们调整一些算法参数，如树深度、估计器、学习率等，并检查模型的准确性。手动尝试不同的参数值组合非常耗时。Scikit-learn的<a class="ae kv" href="https://scikit-learn.org/stable/modules/generated/sklearn.model_selection.GridSearchCV.html" rel="noopener ugc nofollow" target="_blank"> GridSearchCV </a>自动完成这一过程，并计算这些参数的优化值。我已经将GridSearch应用到上述3个算法中。下面是XGBoost的例子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mz na l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/481c746f9e01b90656eb109a52201373.png" data-original-src="https://miro.medium.com/v2/resize:fit:1370/format:webp/1*l87AUTmd2gxN16djljZHkw.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">GridSearchCV中参数的最佳值—按作者排序的图像</p></figure><p id="a12a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦我们有了参数的最佳值，我们将用这些值再次运行所有3个模型。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/8e1e6f1cd700cb9b531a27cdc86da1e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:994/format:webp/1*570QV_HlRyGkWhew4n3wQA.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">模型分数-按作者分类的图像</p></figure><p id="2302" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这样看起来好多了！我们已经能够提高我们的准确性——XGBoost给出了88.6%的分数，错误相对较少👏👏</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ng"><img src="../Images/d809f736177dd822a69bd86aeb22d174.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8oiQPa1l6ckBF3rSzOl1pA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">1.费用预测值和实际值的分布图；2.剩余情节—作者提供的图像</p></figure><p id="809b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" rel="noopener" target="_blank" href="/what-are-rmse-and-mae-e405ce230383">分布图和残差图</a>证实预测费用和实际费用之间有很好的重叠。然而，有一些预测值远远超出了x轴，这使得我们的<a class="ae kv" rel="noopener" target="_blank" href="/what-are-rmse-and-mae-e405ce230383"> RMSE </a>更高。这可以通过增加我们的数据点来减少，即收集更多的数据。</p><p id="5d85" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们现在准备将该模型部署到生产中，并在未知数据上进行测试。干得好的👍</p><p id="f95a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">简而言之，提高我的模型准确性的几点</p><ol class=""><li id="ff00" class="mi mj iq ky b kz la lc ld lf mk lj ml ln mm lr mn mo mp mq bi translated">创建简单的新功能</li><li id="e7b0" class="mi mj iq ky b kz mr lc ms lf mt lj mu ln mv lr mn mo mp mq bi translated">转换目标变量</li><li id="2a60" class="mi mj iq ky b kz mr lc ms lf mt lj mu ln mv lr mn mo mp mq bi translated">聚类公共数据点</li><li id="963e" class="mi mj iq ky b kz mr lc ms lf mt lj mu ln mv lr mn mo mp mq bi translated">升压算法的使用</li><li id="0eb2" class="mi mj iq ky b kz mr lc ms lf mt lj mu ln mv lr mn mo mp mq bi translated">超参数调谐</li></ol><p id="6165" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可以访问我的笔记本<a class="ae kv" href="https://github.com/sacharya225/data-expts/tree/master/Health%20Insurance%20Cost%20Prediction" rel="noopener ugc nofollow" target="_blank">这里</a>。并不是所有的方法都适用于你的模型。挑选最适合您的场景的方案:)</p></div></div>    
</body>
</html>