<html>
<head>
<title>The "Frequently Bought Together" Recommendation System</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">“经常一起买”推荐系统</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/the-frequently-bought-together-recommendation-system-b4ed076b24e5?source=collection_archive---------5-----------------------#2021-10-05">https://towardsdatascience.com/the-frequently-bought-together-recommendation-system-b4ed076b24e5?source=collection_archive---------5-----------------------#2021-10-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="dd5e" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/hands-on-tutorials" rel="noopener" target="_blank">实践教程</a></h2><div class=""/><div class=""><h2 id="d189" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">使用Apriori和FP增长算法以及<code class="fe kr ks kt ku b">mlxtend</code>库的python演练</h2></div><figure class="kw kx ky kz gt la gh gi paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="gh gi kv"><img src="../Images/618fb4c7f27eea754072159f954cacae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*mWpmMqH1V3-TjWkq"/></div></div><p class="lh li gj gh gi lj lk bd b be z dk translated"><a class="ae ll" href="https://unsplash.com/@markkoenig?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">马克·柯尼希</a>在<a class="ae ll" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="674f" class="pw-post-body-paragraph lm ln it lo b lp lq kd lr ls lt kg lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">不是所有的推荐系统都需要机器学习；有些只是需要一点数据挖掘。</p><p id="1e0f" class="pw-post-body-paragraph lm ln it lo b lp lq kd lr ls lt kg lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">本文将介绍一个相对简单的<em class="mi">经常一起购买(</em>又名<em class="mi">经常一起购买)</em>推荐系统的实现。这种推荐系统的一个显著优点是，除了用户正在查看哪个项目之外，它不需要我们知道关于用户的任何信息。这很重要，因为今天大多数电子商务网站的大部分流量直接来自脸书、Twitter或谷歌广告的产品页面。如果他们希望在这种流量上进行销售，他们不能要求新用户登录或选择他们喜欢的项目来帮助推动他们的推荐。</p><p id="6753" class="pw-post-body-paragraph lm ln it lo b lp lq kd lr ls lt kg lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">这种方法只依赖于在商店以相同的订单一起购买的商品的历史记录。它确实要求商店有足够长的交易历史来进行关联。一旦这一点得到满足，我们就可以向网站访问者推荐他们经常购买的商品以及他们正在查看的商品。</p><p id="00a7" class="pw-post-body-paragraph lm ln it lo b lp lq kd lr ls lt kg lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">让我们开始吃吧。</p><h1 id="52ab" class="mj mk it bd ml mm mn mo mp mq mr ms mt ki mu kj mv kl mw km mx ko my kp mz na bi translated">数据</h1><p id="bfaf" class="pw-post-body-paragraph lm ln it lo b lp nb kd lr ls nc kg lu lv nd lx ly lz ne mb mc md nf mf mg mh im bi translated">对于这个例子，我们将使用来自UCI <a class="ae ll" href="https://archive.ics.uci.edu/ml/index.php" rel="noopener ugc nofollow" target="_blank">机器学习库</a>的<a class="ae ll" href="https://archive.ics.uci.edu/ml/datasets/online+retail" rel="noopener ugc nofollow" target="_blank">在线零售数据集</a>。描述如下:</p><blockquote class="ng nh ni"><p id="cd04" class="lm ln mi lo b lp lq kd lr ls lt kg lu nj lw lx ly nk ma mb mc nl me mf mg mh im bi translated"><em class="it">这是一个跨国数据集，包含2010年1月12日和2011年9月12日之间发生的所有英国注册无店铺在线零售交易。该公司主要销售独特的适合各种场合的礼品。这家公司的许多客户都是批发商。</em></p></blockquote><p id="a88d" class="pw-post-body-paragraph lm ln it lo b lp lq kd lr ls lt kg lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">该数据集在知识共享署名4.0国际许可(CC BY 4.0)下可用，该许可允许出于任何目的共享和改编数据集，前提是给予适当的信用。</p><p id="a8cc" class="pw-post-body-paragraph lm ln it lo b lp lq kd lr ls lt kg lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">我不知道“无店铺在线零售”是什么意思，但需要注意的是，许多客户是批发商，这可能会影响我们看到的推荐类型。</p><p id="7715" class="pw-post-body-paragraph lm ln it lo b lp lq kd lr ls lt kg lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">像大多数数据集一样，这个数据集相当混乱，我们必须做一些清理工作，以使数据可用。如果你想直接进入主题，请随意跳过。</p><h1 id="667c" class="mj mk it bd ml mm mn mo mp mq mr ms mt ki mu kj mv kl mw km mx ko my kp mz na bi translated">数据清理</h1><p id="40d3" class="pw-post-body-paragraph lm ln it lo b lp nb kd lr ls nc kg lu lv nd lx ly lz ne mb mc md nf mf mg mh im bi translated">1)我们将首先加载数据集并查看它:</p><pre class="kw kx ky kz gt nm ku nn no aw np bi"><span id="a912" class="nq mk it ku b gy nr ns l nt nu">import pandas as pd</span><span id="ca73" class="nq mk it ku b gy nv ns l nt nu"># read the dataset in from the excel file<br/>df = pd.read_excel('Online Retail.xlsx')</span><span id="df62" class="nq mk it ku b gy nv ns l nt nu"># show the first few rows<br/>df.head()</span></pre><figure class="kw kx ky kz gt la gh gi paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="gh gi nw"><img src="../Images/d283e0b54480cc3f7ce1a34464831387.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ElQVWfM9dRVJ605b.png"/></div></div><p class="lh li gj gh gi lj lk bd b be z dk translated">作者图片</p></figure><p id="8b5c" class="pw-post-body-paragraph lm ln it lo b lp lq kd lr ls lt kg lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">2)我们会面临的一个问题是，<code class="fe kr ks kt ku b">StockCode</code>的值有的是整数，有的是字符串。稍后，当我们将这些转换成一个列表并通过我们的算法运行它们时，我们会得到一个错误。让我们在StockCode前面加上一个字符，以确保它总是被解释为一个字符串。当然，还有其他方法可以做到这一点，但这很简单，而且可以节省以后的代码行。</p><pre class="kw kx ky kz gt nm ku nn no aw np bi"><span id="2f8f" class="nq mk it ku b gy nr ns l nt nu"># Prepend '_' to StockCode<br/>df['StockCode'] = df['StockCode'].apply(lambda x: '_'+str(x))</span></pre><p id="a957" class="pw-post-body-paragraph lm ln it lo b lp lq kd lr ls lt kg lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">3)然后，我们将数据分成两个数据帧，一个用于计算关联规则(<em class="mi"> the what？不要担心，我们一分钟后会谈到这个问题</em>，另一个问题是查找要在我们的推荐中显示的描述。</p><p id="b981" class="pw-post-body-paragraph lm ln it lo b lp lq kd lr ls lt kg lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">注意，对于<code class="fe kr ks kt ku b">products</code>数据帧，我们创建了一个副本。这是为了避免未来的<code class="fe kr ks kt ku b">A value is trying to be set on a copy of a slice from a DataFrame</code>警告。</p><pre class="kw kx ky kz gt nm ku nn no aw np bi"><span id="82cd" class="nq mk it ku b gy nr ns l nt nu"># DataFrame for building the recommendation system<br/>orders = df[['InvoiceNo', 'StockCode']]</span><span id="2c1b" class="nq mk it ku b gy nv ns l nt nu"># DataFrame for retrieving product descriptions<br/>products = df[['StockCode', 'Description']].copy()</span></pre><p id="b44f" class="pw-post-body-paragraph lm ln it lo b lp lq kd lr ls lt kg lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">4)股票代码的字符大小写不一致。我们通过将所有股票代码全部大写来解决这个问题。</p><pre class="kw kx ky kz gt nm ku nn no aw np bi"><span id="a3b5" class="nq mk it ku b gy nr ns l nt nu"># Convert StockCode to uppercase<br/>products['StockCode'] = products['StockCode'].str.upper()</span></pre><p id="1372" class="pw-post-body-paragraph lm ln it lo b lp lq kd lr ls lt kg lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">5)我们需要从产品数据框架中删除重复的行。</p><pre class="kw kx ky kz gt nm ku nn no aw np bi"><span id="268b" class="nq mk it ku b gy nr ns l nt nu"># Drop duplicated products<br/>products = products[~products.duplicated()]</span></pre><p id="9f24" class="pw-post-body-paragraph lm ln it lo b lp lq kd lr ls lt kg lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">5)一些股票代码仍然有多种描述，如下所示:</p><figure class="kw kx ky kz gt la gh gi paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="gh gi nx"><img src="../Images/faafc916e88273f6f65f29c1512aca07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*sIt8Wa73MbhddZNz.png"/></div></div></figure><p id="b4d3" class="pw-post-body-paragraph lm ln it lo b lp lq kd lr ls lt kg lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">原来显示项目名称的描述都是大写的。我们将删除<code class="fe kr ks kt ku b">Description</code>列中的值不是大写的所有行。</p><pre class="kw kx ky kz gt nm ku nn no aw np bi"><span id="8cfe" class="nq mk it ku b gy nr ns l nt nu"># Drop descriptions that are not uppercase<br/>products = products[<br/>    products['Description'].str.upper() == products['Description']<br/>]</span></pre><p id="6ad1" class="pw-post-body-paragraph lm ln it lo b lp lq kd lr ls lt kg lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">6)让我们像这样去掉其余的重复的<code class="fe kr ks kt ku b">StockCode</code>:</p><figure class="kw kx ky kz gt la gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/312209427958895d595e48de88e35eaf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1328/format:webp/0*4I_9bA_tYK1ZLYGj.png"/></div></figure><pre class="kw kx ky kz gt nm ku nn no aw np bi"><span id="c6b6" class="nq mk it ku b gy nr ns l nt nu"># Keep only the first Description of each product<br/>products = products[~products.duplicated(subset=['StockCode'])]</span></pre><p id="b155" class="pw-post-body-paragraph lm ln it lo b lp lq kd lr ls lt kg lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">7)最后，我们将设置StockCode作为索引，并将我们的数据帧转换为Pandas系列，这样我们以后就可以很容易地查找描述了。</p><pre class="kw kx ky kz gt nm ku nn no aw np bi"><span id="9224" class="nq mk it ku b gy nr ns l nt nu"># Set the index to StockCode<br/>products = products.set_index('StockCode')# Convert to Series for eve easier lookups<br/>products = products['Description']</span></pre><h1 id="4c2b" class="mj mk it bd ml mm mn mo mp mq mr ms mt ki mu kj mv kl mw km mx ko my kp mz na bi translated">术语</h1><p id="9541" class="pw-post-body-paragraph lm ln it lo b lp nb kd lr ls nc kg lu lv nd lx ly lz ne mb mc md nf mf mg mh im bi translated">这里有许多关于数据科学的优秀文章，深入解释了我们正在使用的算法。看一看<a class="ae ll" rel="noopener" target="_blank" href="/product-placement-pricing-and-promotion-strategies-with-association-rule-learning-d37f2b70d29e">这里</a>，这里<a class="ae ll" rel="noopener" target="_blank" href="/fp-growth-frequent-pattern-generation-in-data-mining-with-python-implementation-244e561ab1c3">这里</a>，这里<a class="ae ll" rel="noopener" target="_blank" href="/understand-and-build-fp-growth-algorithm-in-python-d8b989bab342">这里</a>。我也发现这个<a class="ae ll" href="https://www.youtube.com/watch?v=yCbankIouUU" rel="noopener ugc nofollow" target="_blank"> youtube视频</a>特别有用。我的目标是向您展示一个使用Apriori和JP增长算法的推荐系统的实际实现。我们将<strong class="lo jd">而不是</strong>从头开始编写算法。不过，有些事情你需要知道。</p><h1 id="1323" class="mj mk it bd ml mm mn mo mp mq mr ms mt ki mu kj mv kl mw km mx ko my kp mz na bi translated">条款</h1><ul class=""><li id="754d" class="nz oa it lo b lp nb ls nc lv ob lz oc md od mh oe of og oh bi translated"><strong class="lo jd">商品:</strong>根据与其他商品的关联度，我们试图推荐的商品或事物。在杂货店，这些可能是产品，如牛奶，尿布和啤酒。</li><li id="1f64" class="nz oa it lo b lp oi ls oj lv ok lz ol md om mh oe of og oh bi translated"><strong class="lo jd">项目集:</strong>一起购买的一个或多个项目。</li><li id="5092" class="nz oa it lo b lp oi ls oj lv ok lz ol md om mh oe of og oh bi translated"><strong class="lo jd">关联规则:</strong>我们将根据项目集计算的规则来确定推荐。一旦我们有了关联规则，我们就可以使用它们来推荐经常购买的商品以及客户正在查看的商品。</li></ul><h1 id="dd7a" class="mj mk it bd ml mm mn mo mp mq mr ms mt ki mu kj mv kl mw km mx ko my kp mz na bi translated">韵律学</h1><ul class=""><li id="64dd" class="nz oa it lo b lp nb ls nc lv ob lz oc md od mh oe of og oh bi translated"><strong class="lo jd">支持度:</strong>以任意给定顺序找到一个项集的概率。这是包含特定项目集的订单的百分比。</li></ul><figure class="kw kx ky kz gt la gh gi paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="gh gi on"><img src="../Images/1f27ab70761b8d513d7d3542b0f58d2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*BMLZt0MxWtxFQKRZ.png"/></div></div><p class="lh li gj gh gi lj lk bd b be z dk translated">作者图片</p></figure><ul class=""><li id="7408" class="nz oa it lo b lp lq ls lt lv oo lz op md oq mh oe of og oh bi translated"><strong class="lo jd">置信度:</strong>给定商品1在订单中，在订单中找到商品2的概率。这告诉我们一个商品与另一个特定商品一起被购买的可能性有多大。</li></ul><figure class="kw kx ky kz gt la gh gi paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="gh gi on"><img src="../Images/f3c74da4b52a3095cb2ac8b58bdf40d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*_pFmX9XrgzQSdouv.png"/></div></div><p class="lh li gj gh gi lj lk bd b be z dk translated">作者图片</p></figure><ul class=""><li id="7ebe" class="nz oa it lo b lp lq ls lt lv oo lz op md oq mh oe of og oh bi translated"><strong class="lo jd"> Lift: </strong>一个项集中两个项的支持度与每个项独立时出现的期望概率之间的关系。关于lift需要知道的重要事情是，<strong class="lo jd"> 1的值意味着两个项目是独立的，</strong>大于1的值<strong class="lo jd">意味着这些项目比它们独立时更有可能一起出现</strong>，小于1的值表示这些项目比它们独立时更不可能一起出现。</li></ul><figure class="kw kx ky kz gt la gh gi paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="gh gi on"><img src="../Images/241f51220261745193aaca6f3ac3b73b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*vXYIYhfxlTVvqjc3.png"/></div></div><p class="lh li gj gh gi lj lk bd b be z dk translated">作者图片</p></figure><h1 id="d604" class="mj mk it bd ml mm mn mo mp mq mr ms mt ki mu kj mv kl mw km mx ko my kp mz na bi translated">算法</h1><ul class=""><li id="1960" class="nz oa it lo b lp nb ls nc lv ob lz oc md od mh oe of og oh bi translated"><strong class="lo jd"> Apriori: </strong>可能是数据挖掘关联规则最著名的算法，因为它的简单性。对大型数据集进行计算可能需要很长时间，因为它的时间复杂度为O(n)或更低，具体取决于实现。</li><li id="7fce" class="nz oa it lo b lp oi ls oj lv ok lz ol md om mh oe of og oh bi translated"><strong class="lo jd"> JP Growth: </strong>一种<strong class="lo jd">快得多的</strong>算法，使用基于树的方法，将数据读取限制在两遍。这导致线性时间复杂度O(n)，随着数据集的增长节省了大量计算资源。查看此视频以获得关于JP增长算法如何工作的详细描述。</li></ul><h1 id="6f7c" class="mj mk it bd ml mm mn mo mp mq mr ms mt ki mu kj mv kl mw km mx ko my kp mz na bi translated">履行</h1><p id="57e8" class="pw-post-body-paragraph lm ln it lo b lp nb kd lr ls nc kg lu lv nd lx ly lz ne mb mc md nf mf mg mh im bi translated">既然我们已经解决了所有这些问题，我们就来看最简单的部分:实现推荐系统。</p><p id="b376" class="pw-post-body-paragraph lm ln it lo b lp lq kd lr ls lt kg lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">这很容易，因为像所有流行的算法一样，python库已经为我们处理了繁重的工作。我们将使用<code class="fe kr ks kt ku b">mlxtend</code>库，在其<a class="ae ll" href="https://rasbt.github.io/mlxtend/" rel="noopener ugc nofollow" target="_blank">网站</a>上将其描述为“用于日常数据科学任务的有用工具的Python库”</p><p id="98da" class="pw-post-body-paragraph lm ln it lo b lp lq kd lr ls lt kg lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated"><strong class="lo jd">转换数据</strong></p><p id="5746" class="pw-post-body-paragraph lm ln it lo b lp lq kd lr ls lt kg lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">我们用来计算项目集的两种方法都需要一个一次性编码的Pandas数据框架，其中产品作为列，订单作为行。幸运的是，<code class="fe kr ks kt ku b">mlxtend</code>还提供了一个方便的TransactionEncoder，它负责从我们当前的数据帧到所需格式的大部分转换。</p><pre class="kw kx ky kz gt nm ku nn no aw np bi"><span id="cf47" class="nq mk it ku b gy nr ns l nt nu">from mlxtend.preprocessing import TransactionEncoder</span><span id="4d40" class="nq mk it ku b gy nv ns l nt nu"># fit the TransactionEncoder<br/>te.fit(orders['StockCode'])</span><span id="9f14" class="nq mk it ku b gy nv ns l nt nu"># do the transformation<br/>orders_1hot = transform(orders['StockCode'])</span></pre><p id="78d9" class="pw-post-body-paragraph lm ln it lo b lp lq kd lr ls lt kg lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated"><code class="fe kr ks kt ku b">orders_1hot</code>是一个NumPy数组。mlxtend函数需要pandas数据帧。我们可以很容易地将NumPy数组转换成DataFrame，如下所示:</p><pre class="kw kx ky kz gt nm ku nn no aw np bi"><span id="436c" class="nq mk it ku b gy nr ns l nt nu"># convert orders_1hot to a DataFrame<br/>orders_1hot = pd.DataFrame(orders_1hot, columns =te.columns_)</span><span id="8bc0" class="nq mk it ku b gy nv ns l nt nu"># Inspect the first 5 rows of the DataFrame<br/>orders_1hot.head()</span></pre><figure class="kw kx ky kz gt la gh gi paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="gh gi on"><img src="../Images/efe9a2a57d57655c08533fe7da27c441.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*YTPhQBKA1qtI4kyv.png"/></div></div><p class="lh li gj gh gi lj lk bd b be z dk translated">作者图片</p></figure><h2 id="eedb" class="nq mk it bd ml or os dn mp ot ou dp mt lv ov ow mv lz ox oy mx md oz pa mz iz bi translated">先验模型</h2><p id="f9e8" class="pw-post-body-paragraph lm ln it lo b lp nb kd lr ls nc kg lu lv nd lx ly lz ne mb mc md nf mf mg mh im bi translated">我们可以对我们的数据运行Apriori模型，用一行神奇的代码来挖掘<em class="mi">项集。但是在我们这样做之前，我们需要决定一个最小的<em class="mi">支持</em>(还记得术语部分的<em class="mi">支持</em>吗？).这个最小<em class="mi">支持</em>值使我们不会只考虑订单中很小一部分一起购买的商品。这些关联是没有帮助的，会大大增加我们的计算开销。最小<em class="mi">支撑</em>因应用而异。我们将使用0.01，这意味着模型返回的任何<em class="mi">项集</em>将在商店中至少1%的订单中出现。</em></p><p id="c1c4" class="pw-post-body-paragraph lm ln it lo b lp lq kd lr ls lt kg lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">我们还将使用可选参数<code class="fe kr ks kt ku b">use_colnames</code>返回由<em class="mi">股票代码</em>标识的<em class="mi">项目集</em>，而不是列索引。这将有助于我们稍后解释我们的结果。</p><p id="1fc5" class="pw-post-body-paragraph lm ln it lo b lp lq kd lr ls lt kg lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated"><code class="fe kr ks kt ku b">max_len</code>将<em class="mi">项集</em>的大小限制为1。因为我们只希望根据站点访问者查看的特定项目推荐单个项目的列表，所以我们只需要关注最多2个产品的<em class="mi">项目集</em>。</p><p id="9ad9" class="pw-post-body-paragraph lm ln it lo b lp lq kd lr ls lt kg lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">准备好了…</p><pre class="kw kx ky kz gt nm ku nn no aw np bi"><span id="29f9" class="nq mk it ku b gy nr ns l nt nu">from mlxtend.frequent_patterns import apriori</span><span id="aadb" class="nq mk it ku b gy nv ns l nt nu"># the moment we have all been waiting for<br/>ar_ap = apriori(df_ary, min_support=0.01, max_len=2,<br/>                use_colnames=True)</span></pre><p id="e5f7" class="pw-post-body-paragraph lm ln it lo b lp lq kd lr ls lt kg lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">哒哒！</p><p id="2ae4" class="pw-post-body-paragraph lm ln it lo b lp lq kd lr ls lt kg lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">你可能注意到这并不快。然而，在这个数据集上，它也不是无休止的。我笔记本电脑的运行时间是2分15秒。请记住，这只是一年半的交易。如果我们有更多的事务，并且考虑到Apriori模型的时间复杂性，这将花费相当长的时间。</p><p id="12d6" class="pw-post-body-paragraph lm ln it lo b lp lq kd lr ls lt kg lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">让我们来看看结果。</p><figure class="kw kx ky kz gt la gh gi paragraph-image"><div class="gh gi pb"><img src="../Images/7b0d48bf0efebd895a2cd9b2419368c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:684/format:webp/0*bk1OPlpN6QsfqH4D.png"/></div><p class="lh li gj gh gi lj lk bd b be z dk translated">作者图片</p></figure><p id="8fa8" class="pw-post-body-paragraph lm ln it lo b lp lq kd lr ls lt kg lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">这是一个包含每个<em class="mi">项目集</em>及其<em class="mi">支持</em>的表格。完美，这正是我们最终计算<em class="mi">关联规则</em>所需要的。</p><h1 id="3098" class="mj mk it bd ml mm mn mo mp mq mr ms mt ki mu kj mv kl mw km mx ko my kp mz na bi translated">FP增长</h1><p id="d13c" class="pw-post-body-paragraph lm ln it lo b lp nb kd lr ls nc kg lu lv nd lx ly lz ne mb mc md nf mf mg mh im bi translated">FP增长算法(<code class="fe kr ks kt ku b">fpgrowth</code>)的<em class="mi"> mlxtend </em>实现是<code class="fe kr ks kt ku b">apriori</code>的替代。要查看它的运行情况，我们将执行以下操作。</p><pre class="kw kx ky kz gt nm ku nn no aw np bi"><span id="3e4e" class="nq mk it ku b gy nr ns l nt nu">from mlxtend.frequent_patterns import fprowth</span><span id="651c" class="nq mk it ku b gy nv ns l nt nu"># the moment we have all been waiting for (again)<br/>ar_fp = fprowth(df_ary, min_support=0.01, max_len=2,<br/>                use_colnames=True)</span></pre><p id="e933" class="pw-post-body-paragraph lm ln it lo b lp lq kd lr ls lt kg lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">这给了我们一个数据帧，其中的项目与<code class="fe kr ks kt ku b">apriori</code>算法相同(顺序不同),但耗时5.2秒！在我们的数据集上，Apriori算法的计算时间是FP Growth算法的33倍以上。它的时间复杂度是线性的，所以当我们的商店变大时，这种差异会更加明显。</p><blockquote class="ng nh ni"><p id="3970" class="lm ln mi lo b lp lq kd lr ls lt kg lu nj lw lx ly nk ma mb mc nl me mf mg mh im bi translated"><em class="it">注意:itemsets列中的值是frozensets。这与用于实现Apriori算法的方法有关，并且它被带到FP增长，以便</em> <code class="fe kr ks kt ku b"><em class="it">fpgrowth</em></code> <em class="it">可以是对</em> <code class="fe kr ks kt ku b"><em class="it">apriori</em></code> <em class="it">的替换。这使得比较数据帧变得困难。然而，如果你想看到它们包含相同信息的证据，看看下面链接的与本文相关的笔记本。</em></p></blockquote><div class="pc pd gp gr pe pf"><a href="https://github.com/benbogart/frequently_bought_together" rel="noopener  ugc nofollow" target="_blank"><div class="pg ab fo"><div class="ph ab pi cl cj pj"><h2 class="bd jd gy z fp pk fr fs pl fu fw jc bi translated">GitHub-benbogart/经常一起购买</h2><div class="pm l"><h3 class="bd b gy z fp pk fr fs pl fu fw dk translated">在GitHub上创建一个帐户，为benbogart/frequency _ buy _ together开发做贡献。</h3></div><div class="pn l"><p class="bd b dl z fp pk fr fs pl fu fw dk translated">github.com</p></div></div><div class="po l"><div class="pp l pq pr ps po pt lf pf"/></div></div></a></div><h1 id="f609" class="mj mk it bd ml mm mn mo mp mq mr ms mt ki mu kj mv kl mw km mx ko my kp mz na bi translated">计算关联规则</h1><p id="189e" class="pw-post-body-paragraph lm ln it lo b lp nb kd lr ls nc kg lu lv nd lx ly lz ne mb mc md nf mf mg mh im bi translated">有了这些<em class="mi">项集，</em>我们现在可以很容易地计算出<em class="mi">关联规则</em>。同样，我们必须设置一个度量的最小阈值。我们可以从<em class="mi">支持、信心</em>、<em class="mi">提升</em>或其他几个我们没有讨论过的指标中进行选择。这里的目的是限制不太可能高度相关的结果。您设置的阈值将取决于您的应用。例如，如果您想在大多数时间显示一个推荐，而不管质量如何，您可以将<code class="fe kr ks kt ku b">min_threshold</code>设置得很低。如果你只对向你的访问者展示高度相关的推荐感兴趣，你应该提高门槛来消除弱关联。</p><p id="7dc4" class="pw-post-body-paragraph lm ln it lo b lp lq kd lr ls lt kg lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">我们将使用<em class="mi">提升</em>，因为<em class="mi">提升</em>是两个项目之间关联的度量。如果<em class="mi"> lift </em>大于1，它告诉我们<em class="mi">项目集</em>中的项目被一起购买的次数比随机购买的次数多，这似乎是一个常见的选择。</p><pre class="kw kx ky kz gt nm ku nn no aw np bi"><span id="55df" class="nq mk it ku b gy nr ns l nt nu">from mlxtend.frequent_patterns import association_rules</span><span id="954d" class="nq mk it ku b gy nv ns l nt nu">ar = association_rules(is_fp, <br/>                       metric="lift", <br/>                       min_threshold=10)</span></pre><p id="8cc2" class="pw-post-body-paragraph lm ln it lo b lp lq kd lr ls lt kg lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">这给了我们一个808行9列的数据帧。</p><figure class="kw kx ky kz gt la gh gi paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="gh gi pu"><img src="../Images/5e906f682368c753972d1acde07e7a86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*vLN4PiRE0ctWOzJY.png"/></div></div><p class="lh li gj gh gi lj lk bd b be z dk translated">作者图片</p></figure><p id="8b95" class="pw-post-body-paragraph lm ln it lo b lp lq kd lr ls lt kg lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">这是我们的<em class="mi">关联规则</em>表，其中包含为我们计算的所有指标！大部分栏目都很清楚，但是让我们看看前两个。</p><ul class=""><li id="d635" class="nz oa it lo b lp lq ls lt lv oo lz op md oq mh oe of og oh bi translated">前情:我们推荐的产品。</li><li id="1973" class="nz oa it lo b lp oi ls oj lv ok lz ol md om mh oe of og oh bi translated"><strong class="lo jd">结果:</strong>我们根据<em class="mi">前因</em>推荐的产品。</li></ul><h1 id="4186" class="mj mk it bd ml mm mn mo mp mq mr ms mt ki mu kj mv kl mw km mx ko my kp mz na bi translated">提出建议</h1><p id="9b51" class="pw-post-body-paragraph lm ln it lo b lp nb kd lr ls nc kg lu lv nd lx ly lz ne mb mc md nf mf mg mh im bi translated">现在我们有了关联规则，我们只需从数据框架中提取正确的规则，返回一个<em class="mi">经常一起购买的</em>推荐。</p><p id="dc2e" class="pw-post-body-paragraph lm ln it lo b lp lq kd lr ls lt kg lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">我们将使用一个简短的函数来完成这项工作。我们将股票代码作为python <em class="mi">集合</em>传入(关键字是<em class="mi"> frozensets，</em>但是<em class="mi"> frozensets </em>和<em class="mi">集合</em>可以成功比较)。</p><p id="1c94" class="pw-post-body-paragraph lm ln it lo b lp lq kd lr ls lt kg lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">predict函数中有一个技巧值得解释。不能对<em class="mi"> frozenset </em>进行索引，也不能用<code class="fe kr ks kt ku b">pop</code>方法(或任何其他方式)从<em class="mi"> frozenset </em>中移除项目。)要将<code class="fe kr ks kt ku b">frozenset</code>转换成一个字符串，我们首先用<code class="fe kr ks kt ku b">iter</code>将<code class="fe kr ks kt ku b">frozenset</code>转换成一个<em class="mi">可迭代的</em>，然后用<code class="fe kr ks kt ku b">next</code>从其中取出第一个也是唯一的元素。</p><p id="1ac9" class="pw-post-body-paragraph lm ln it lo b lp lq kd lr ls lt kg lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">规则已经按照我们在计算关联规则时选择的度量进行了排序，所以我们不需要再次排序。</p><pre class="kw kx ky kz gt nm ku nn no aw np bi"><span id="80dc" class="nq mk it ku b gy nr ns l nt nu">def predict(antecedent, rules, max_results= 6):<br/>    <br/>    # get the rules for this antecedent<br/>    preds = rules[rules['antecedents'] == antecedent]<br/>    <br/>    # a way to convert a frozen set with one element to string<br/>    preds = preds['consequents'].apply(iter).apply(next)<br/>    <br/>    return preds[:max_results]</span></pre><p id="92f3" class="pw-post-body-paragraph lm ln it lo b lp lq kd lr ls lt kg lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">让我们试一试</p><pre class="kw kx ky kz gt nm ku nn no aw np bi"><span id="a537" class="nq mk it ku b gy nr ns l nt nu">preds = predict({'_20712'}, rules)<br/>preds</span></pre><figure class="kw kx ky kz gt la gh gi paragraph-image"><div class="gh gi pv"><img src="../Images/56ced0a71e000170773c7f8548f2f1a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*VRpgbl871UUQkr2g.png"/></div><p class="lh li gj gh gi lj lk bd b be z dk translated">作者图片</p></figure><p id="bdda" class="pw-post-body-paragraph lm ln it lo b lp lq kd lr ls lt kg lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">我们做到了！</p><p id="2fbc" class="pw-post-body-paragraph lm ln it lo b lp lq kd lr ls lt kg lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">但是我们怎么知道我们做到了呢？让我们看看这些预测代表了什么。</p><p id="734d" class="pw-post-body-paragraph lm ln it lo b lp lq kd lr ls lt kg lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">首先，让我们找出<em class="mi">股票代码</em> <code class="fe kr ks kt ku b">_20727</code>指的是哪种产品。这将是我们的<em class="mi">前因。</em></p><pre class="kw kx ky kz gt nm ku nn no aw np bi"><span id="4f90" class="nq mk it ku b gy nr ns l nt nu">print(products['_20712'])</span></pre><figure class="kw kx ky kz gt la gh gi paragraph-image"><div class="gh gi pv"><img src="../Images/52bec4af24da7306da6984de0fd73d54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*kydXIPGXIYF0NFua.png"/></div><p class="lh li gj gh gi lj lk bd b be z dk translated">作者图片</p></figure><p id="1330" class="pw-post-body-paragraph lm ln it lo b lp lq kd lr ls lt kg lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">现在我们来看看推荐产品或者<em class="mi">后果</em>的描述。</p><pre class="kw kx ky kz gt nm ku nn no aw np bi"><span id="0603" class="nq mk it ku b gy nr ns l nt nu">for stockid in preds:  <br/>    print(products[stockid])</span></pre><figure class="kw kx ky kz gt la gh gi paragraph-image"><div class="gh gi pv"><img src="../Images/7e0530d9f2c2311ee69edcfd7aab4e53.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*lFumYD01A_YQjoVu.png"/></div><p class="lh li gj gh gi lj lk bd b be z dk translated">作者图片</p></figure><p id="3413" class="pw-post-body-paragraph lm ln it lo b lp lq kd lr ls lt kg lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">一堆袋子。这是有道理的，考虑到我们是在和批发商打交道。</p><p id="261a" class="pw-post-body-paragraph lm ln it lo b lp lq kd lr ls lt kg lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">我们再试试另外一个:<em class="mi">股票代码</em> <code class="fe kr ks kt ku b">_20719</code>。</p><pre class="kw kx ky kz gt nm ku nn no aw np bi"><span id="c592" class="nq mk it ku b gy nr ns l nt nu">print(products['_22112'])</span></pre><figure class="kw kx ky kz gt la gh gi paragraph-image"><div class="gh gi pv"><img src="../Images/d63860f1f1ff95a821b3c59c483b2cb5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*fs1A-Bqw8kJi0mZc.png"/></div><p class="lh li gj gh gi lj lk bd b be z dk translated">作者图片</p></figure><pre class="kw kx ky kz gt nm ku nn no aw np bi"><span id="be45" class="nq mk it ku b gy nr ns l nt nu"># get the predictions<br/>preds = predict({'_22112'}, rules)</span><span id="9496" class="nq mk it ku b gy nv ns l nt nu"># Display the descriptions of the predictions<br/>for stockid in preds:  <br/>    print(products[stockid])</span></pre><figure class="kw kx ky kz gt la gh gi paragraph-image"><div class="gh gi pv"><img src="../Images/0a86634b62bc8dfe54389977f51bfcc8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*56WORhhQqnGIGl5y.png"/></div><p class="lh li gj gh gi lj lk bd b be z dk translated">作者图片</p></figure><p id="da73" class="pw-post-body-paragraph lm ln it lo b lp lq kd lr ls lt kg lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">耶！水瓶！由于许多顾客是批发商，他们一起购买各种水瓶是有道理的。看起来我们成功了。</p><h1 id="417d" class="mj mk it bd ml mm mn mo mp mq mr ms mt ki mu kj mv kl mw km mx ko my kp mz na bi translated">结论</h1><p id="e2b4" class="pw-post-body-paragraph lm ln it lo b lp nb kd lr ls nc kg lu lv nd lx ly lz ne mb mc md nf mf mg mh im bi translated">当创建一个经常一起购买的推荐系统时，有相当多的东西需要理解。我们只是触及了表面，但重要的是，经常一起购买的推荐系统是基于创建一个静态表，称为关联规则。最后的推荐只是一个查找。这很棒，因为它很简单。但是这些关联规则需要定期重新计算。</p><p id="e223" class="pw-post-body-paragraph lm ln it lo b lp lq kd lr ls lt kg lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">有了python和<code class="fe kr ks kt ku b">mlxtnd</code>库，为经常一起购买的<em class="mi">推荐系统生成关联规则只需要很少的代码。</em></p><p id="83e7" class="pw-post-body-paragraph lm ln it lo b lp lq kd lr ls lt kg lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">去做点好事吧。</p><h1 id="4e93" class="mj mk it bd ml mm mn mo mp mq mr ms mt ki mu kj mv kl mw km mx ko my kp mz na bi translated">资源</h1><p id="e61b" class="pw-post-body-paragraph lm ln it lo b lp nb kd lr ls nc kg lu lv nd lx ly lz ne mb mc md nf mf mg mh im bi translated">这里有一些我发现对本文写作有帮助的资源。</p><h1 id="7d7b" class="mj mk it bd ml mm mn mo mp mq mr ms mt ki mu kj mv kl mw km mx ko my kp mz na bi translated">书</h1><ul class=""><li id="8abb" class="nz oa it lo b lp nb ls nc lv ob lz oc md od mh oe of og oh bi translated"><a class="ae ll" href="https://www.amazon.com/gp/product/1617292702/ref=as_li_tl?ie=UTF8&amp;camp=1789&amp;creative=9325&amp;creativeASIN=1617292702&amp;linkCode=as2&amp;tag=benbogart09-20&amp;linkId=55f10672ca8a8e24ce93f00cf9f41592" rel="noopener ugc nofollow" target="_blank"> <em class="mi">实用推荐系统</em> </a>作者金·福克<br/>(这是附属链接。我得到一小笔钱，如果你通过这个链接购买，支持更多像这样的文章)</li></ul><h1 id="dade" class="mj mk it bd ml mm mn mo mp mq mr ms mt ki mu kj mv kl mw km mx ko my kp mz na bi translated">文章和网页</h1><ul class=""><li id="bdc5" class="nz oa it lo b lp nb ls nc lv ob lz oc md od mh oe of og oh bi translated"><code class="fe kr ks kt ku b">mlxtend</code>文件:<a class="ae ll" href="https://rasbt.github.io/mlxtend/" rel="noopener ugc nofollow" target="_blank">https://rasbt.github.io/mlxtend/</a></li><li id="bc65" class="nz oa it lo b lp oi ls oj lv ok lz ol md om mh oe of og oh bi translated"><a class="ae ll" rel="noopener" target="_blank" href="/association-rules-2-aa9a77241654">关联规则完整指南(1/2) </a>作者<a class="ae ll" href="https://medium.com/@anishagarg?source=post_page-----aa9a77241654--------------------------------" rel="noopener"> Anisha Garg </a></li><li id="b273" class="nz oa it lo b lp oi ls oj lv ok lz ol md om mh oe of og oh bi translated"><a class="ae ll" rel="noopener" target="_blank" href="/understand-and-build-fp-growth-algorithm-in-python-d8b989bab342">通过<a class="ae ll" href="https://andrewngai9255.medium.com/?source=post_page-----d8b989bab342--------------------------------" rel="noopener">和</a>理解并构建Python中的FP-Growth算法</a></li></ul><h1 id="95b7" class="mj mk it bd ml mm mn mo mp mq mr ms mt ki mu kj mv kl mw km mx ko my kp mz na bi translated">录像</h1><ul class=""><li id="744f" class="nz oa it lo b lp nb ls nc lv ob lz oc md od mh oe of og oh bi translated"><a class="ae ll" href="https://www.youtube.com/watch?v=yCbankIouUU" rel="noopener ugc nofollow" target="_blank">关联规则挖掘的频繁模式(FP)增长算法</a></li></ul><h1 id="2569" class="mj mk it bd ml mm mn mo mp mq mr ms mt ki mu kj mv kl mw km mx ko my kp mz na bi translated">GitHub知识库</h1><div class="pc pd gp gr pe pf"><a href="https://github.com/benbogart/frequently_bought_together" rel="noopener  ugc nofollow" target="_blank"><div class="pg ab fo"><div class="ph ab pi cl cj pj"><h2 class="bd jd gy z fp pk fr fs pl fu fw jc bi translated">GitHub-benbogart/经常一起购买</h2><div class="pm l"><h3 class="bd b gy z fp pk fr fs pl fu fw dk translated">在GitHub上创建一个帐户，为benbogart/frequency _ buy _ together开发做贡献。</h3></div><div class="pn l"><p class="bd b dl z fp pk fr fs pl fu fw dk translated">github.com</p></div></div><div class="po l"><div class="pp l pq pr ps po pt lf pf"/></div></div></a></div></div><div class="ab cl pw px hx py" role="separator"><span class="pz bw bk qa qb qc"/><span class="pz bw bk qa qb qc"/><span class="pz bw bk qa qb"/></div><div class="im in io ip iq"><p id="1060" class="pw-post-body-paragraph lm ln it lo b lp lq kd lr ls lt kg lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">[1]陈大庆、赛梁赛恩和郭昆，“在线零售业的数据挖掘:使用数据挖掘进行基于RFM模型的客户细分的案例研究”，《数据库营销和客户战略管理杂志》，第19卷第3期，第197-208页，2012年(印刷前在线出版:2012年8月27日)。doi: 10.1057/dbm.2012.17)。</p><p id="d219" class="pw-post-body-paragraph lm ln it lo b lp lq kd lr ls lt kg lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">[2]<a class="ae ll" href="https://archive-beta.ics.uci.edu/ml/donation-policy" rel="noopener ugc nofollow" target="_blank">https://archive-beta.ics.uci.edu/ml/donation-policy</a>(在撰写本文时，许可证声明网站测试版的ssl认证是无效的。)</p></div></div>    
</body>
</html>