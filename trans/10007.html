<html>
<head>
<title>Power BI and Synapse, Part 3— Serverless SQL: How much will it cost me?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Power BI和Synapse，第3部分—无服务器SQL:我要花多少钱？</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/power-bi-and-synapse-part-3-serverless-sql-how-much-will-it-cost-me-46db281ee9f5?source=collection_archive---------13-----------------------#2021-09-21">https://towardsdatascience.com/power-bi-and-synapse-part-3-serverless-sql-how-much-will-it-cost-me-46db281ee9f5?source=collection_archive---------13-----------------------#2021-09-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5863" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如果您将Power BI与Synapse Analytics结合使用，您会支付多少费用？在本系列的最后一部分，我对Power BI &amp; Synapse Analytics无服务器SQL池进行了终极基准测试，结果如下！</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/8ea90bcbc3f83671ba8a53f7ee392671.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5MMVdsXuVuYFAHryvWaiYA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/photos/ij5_qCBpIVY" rel="noopener ugc nofollow" target="_blank">图片由Kolleen Gladden在Unsplash上拍摄</a></p></figure><p id="128a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">通过在2019年底推出Azure Synapse Analytics，在数据处理方面开创了一个全新的视角。一些核心概念，如传统的数据仓库，受到了更多的审查，而在数据爱好者意识到Synapse带来的新功能后，各种新方法开始涌现。</em></p><p id="ab47" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">【Synapse不仅对数据接收、转换和存储选项产生了巨大影响，它还为数据服务和可视化提供了全新的可能性！</p><p id="f54d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，在这一系列博文中，我将尝试探索Power BI如何与新平台协同工作。作为Power BI开发人员，我们在使用Synapse时有哪些选择？在哪些数据分析场景中，Synapse将发挥优势，帮助您实现(im)可能性？什么时候您想利用Synapse中的创新解决方案，什么时候您会更好地坚持使用更传统的方法？使用Power BI — Synapse combo的最佳实践是什么，在最终决定采用哪种方法之前，您应该评估哪些参数。</p><p id="38eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">完成后，我相信您应该会更好地理解Power BI和Synapse之间集成时每个可用选项的“优缺点”。</em></p><ul class=""><li id="91ba" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated"><a class="ae ky" rel="noopener" target="_blank" href="/power-bi-synapse-part-1-the-art-of-im-possible-b2bdb4d7c866"><em class="lv">Power BI&amp;Synapse Part 1—(im)可能的艺术！</em>T13】</a></li><li id="6995" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated"><a class="ae ky" rel="noopener" target="_blank" href="/power-bi-and-synapse-part-1-the-art-of-the-im-possible-b561bb8f82ce"><em class="lv">Power BI&amp;Synapse Part 2——Synapse带来了什么？</em> </a></li></ul><p id="6f0d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不要误解我的意思——这个理论很好，你绝对应该花时间尝试吸收新技术、工具或特性的基本架构概念。因为，如果你不明白某样东西是如何在引擎盖下工作的，那么很有可能你不会最大限度地利用它。</p><p id="e08a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，将这些理论知识应用于实践测试才是最有趣的部分！至少对我来说是这样:)…这让我想起了汽车生产过程:他们制造一切，你读了说明书，印象深刻！特征，设备…然而，这些都无关紧要，直到他们把车进行碰撞测试，并得到适当的现实检查。</p><p id="010a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，这篇文章就像是对Synapse Analytics中无服务器SQL池的碰撞测试——许多不同的场景、测试、演示、测量等。</p><h1 id="218e" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">无服务器SQL池—下一件大事</h1><p id="b571" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">我已经写了<a class="ae ky" rel="noopener" target="_blank" href="/power-bi-synapse-part-1-the-art-of-im-possible-b2bdb4d7c866">关于无服务器SQL池</a>，我坚信它是处理大量半结构化或非结构化数据的下一件大事。</p><p id="2b07" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">无服务器SQL池的最大优势在于，您可以直接从存储在Azure数据湖中的CSV、parquet或JSON文件中查询数据，而无需传输数据！甚至，您可以编写普通的T-SQL来直接从文件中检索数据！但是，让我们看看这在各种实际使用案例中是如何工作的，最重要的是，<strong class="lb iu"> <em class="lv">每个解决方案将花费您多少钱！</em> </strong></p><p id="fcd7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在使用Synapse Serverless SQL pool时，仍有一些东西微软不会向您收取数据处理费用，例如:</p><ul class=""><li id="dfd4" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated">服务器级元数据(登录名、角色和服务器级凭据)</li><li id="dead" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">您在端点中创建的数据库。这些数据库只包含元数据(用户、角色、模式、视图、内联表值函数、存储过程、外部数据源、外部文件格式和外部表)</li><li id="2f30" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">DDL语句，但CREATE STATISTICS语句除外，因为它根据指定的样本百分比处理存储中的数据</li><li id="c877" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">仅元数据查询</li></ul><h1 id="608d" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">方案</h1><p id="01d2" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">场景是这样的:我有两个与<a class="ae ky" href="https://www1.nyc.gov/site/tlc/about/tlc-trip-record-data.page" rel="noopener ugc nofollow" target="_blank">纽约出租车数据集</a>相关的<strong class="lb iu"> <em class="lv"> CSV </em> </strong>文件，我已经在前面的一个演示中使用过<a class="ae ky" rel="noopener" target="_blank" href="/power-bi-synapse-part-1-the-art-of-im-possible-b2bdb4d7c866">。一个包含2019年1月以来所有黄色出租车乘坐的数据(650 MB)，另一个包含2019年2月以来的数据(620 MB)。</a></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/ec573282f7b08cc2f38bbd9ebd6b64de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yKaVls73m7P7xj7jAK2ABQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="765f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我为每个月的数据创建了两个单独的视图。这个想法是为了检查当我们在多种不同条件下查询Power BI的数据时会发生什么。</p><p id="e8f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是在一个月内创建视图的T-SQL:</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="b511" class="nn ml it nj b gy no np l nq nr">DROP VIEW IF EXISTS taxi201902csv;<br/>GO</span><span id="6c75" class="nn ml it nj b gy ns np l nq nr">CREATE VIEW taxi201902csv AS<br/>SELECT <br/>    VendorID<br/>    ,cast(tpep_pickup_datetime as DATE) tpep_pickup_datetime<br/>    ,cast(tpep_dropoff_datetime as DATE) tpep_dropoff_datetime<br/>    ,passenger_count<br/>    ,trip_distance <br/>    ,RateCodeID <br/>    ,store_and_fwd_flag <br/>    ,PULocationID<br/>    ,DOLocationID<br/>    ,payment_type <br/>    ,fare_amount<br/>    ,extra<br/>    ,mta_tax <br/>    ,tip_amount <br/>    ,tolls_amount <br/>    ,improvement_surcharge<br/>    ,total_amount <br/>    ,congestion_surcharge<br/>FROM<br/>    OPENROWSET(<br/>        BULK N'https://nikola.dfs.core.windows.net/nikola/Data/yellow_tripdata_2019-02.csv',<br/>        FORMAT = 'CSV',<br/>        PARSER_VERSION='2.0',<br/>        HEADER_ROW = TRUE<br/>    ) <br/>    WITH(<br/>        VendorID INT,<br/>        tpep_pickup_datetime DATETIME2,<br/>        tpep_dropoff_datetime DATETIME2,<br/>        passenger_count INT,<br/>        trip_distance DECIMAL(10,2),<br/>        RateCodeID INT,<br/>        store_and_fwd_flag VARCHAR(10),<br/>        PULocationID INT,<br/>        DOLocationID INT,<br/>        payment_type INT,<br/>        fare_amount DECIMAL(10,2),<br/>        extra DECIMAL(10,2),<br/>        mta_tax DECIMAL(10,2),<br/>        tip_amount DECIMAL(10,2),<br/>        tolls_amount DECIMAL(10,2),<br/>        improvement_surcharge DECIMAL(10,2),<br/>        total_amount DECIMAL(10,2),<br/>        congestion_surcharge DECIMAL(10,2)<br/>    )<br/>    AS [taxi201902csv]</span></pre><p id="4ca4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我使用WITH block来显式定义数据类型，如果不这样做，所有的字符列将自动设置为VARCHAR(8000 ),因此会占用更多的内存。</p><p id="8858" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如您所注意到的，我已经从CSV文件中重命名了我的通用列名，因此它们现在看起来更具可读性。我还将DateTime列强制转换为Date类型，因为我不需要这个演示的时间部分。这样，我们<a class="ae ky" rel="noopener" target="_blank" href="/how-to-reduce-your-power-bi-model-size-by-90-76d7c4377f2d">减少了基数和整个数据模型的大小</a>。让我们检查一下每个文件包含多少条记录:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/b00ad8db9b66409c9f371fbe1ff1e8fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jIGTOjI3fiT4oNqifzocbA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="7c86" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一月包含大约760万条记录，而二月包含大约700万条记录。</p><p id="a4ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，我还应用了相同的逻辑，对来自<strong class="lb iu"> <em class="lv">拼花</em> </strong>文件的完全相同的数据部分构建了两个视图。因此，我们可以比较CSV和拼花文件之间的指标。</p><p id="1cfb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用于拼花文件的视图构建略有不同，使用FILENAME()和FILEPATH()函数来消除不必要的分区:</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="ba1b" class="nn ml it nj b gy no np l nq nr">DROP VIEW IF EXISTS taxi201901parquet;<br/>GO</span><span id="6c1a" class="nn ml it nj b gy ns np l nq nr">CREATE VIEW taxi201901parquet AS<br/>SELECT<br/>        VendorID<br/>        ,CAST(TpepPickupDatetime AS DATE) TpepPickupDatetime<br/>        ,CAST(TpepDropoffDatetime AS DATE) TpepDropoffDatetime<br/>        ,PassengerCount<br/>        ,TripDistance<br/>        ,PuLocationId<br/>        ,DoLocationId<br/>        ,StartLon<br/>        ,StartLat<br/>        ,EndLon<br/>        ,EndLat<br/>        ,RateCodeId<br/>        ,StoreAndFwdFlag<br/>        ,PaymentType<br/>        ,FareAmount<br/>        ,Extra<br/>        ,MtaTax<br/>        ,ImprovementSurcharge<br/>        ,TipAmount<br/>        ,TollsAmount<br/>        ,TotalAmount<br/>FROM  <br/>    OPENROWSET(<br/>        BULK 'puYear=*/puMonth=*/*.snappy.parquet',<br/>        DATA_SOURCE = 'YellowTaxi',<br/>        FORMAT='PARQUET'<br/>    ) nyc<br/>WHERE<br/>    nyc.filepath(1) = 2019<br/>    AND nyc.filepath(2) IN (1)<br/>    AND tpepPickupDateTime BETWEEN CAST('1/1/2019' AS datetime) AND CAST('1/31/2019' AS datetime)</span></pre><p id="e66d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如在Synapse 中使用无服务器SQL池的<a class="ae ky" href="https://docs.microsoft.com/en-us/azure/synapse-analytics/sql/best-practices-sql-on-demand#use-filename-and-filepath-functions-to-target-specific-partitions" rel="noopener ugc nofollow" target="_blank">最佳实践中所指定的，我们明确指示我们的查询只针对2019年和一月份！这将减少扫描和处理的数据量。对于我们的CSV文件，我们不必这样做，因为它们已经按月分区并保存了。</a></p><p id="c09f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">一个重要的免责声明</em>:由于无服务器SQL池的使用是按处理的数据量收费的(目前的价格是每TB处理的数据5美元起)，我不会用速度来衡量性能。我想只关注对处理的数据量和通过检查不同场景产生的成本的分析。</p><h1 id="36e4" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">CSV vs拼花——我需要知道什么？</h1><p id="17e9" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">在我们继续测试之前，再讲一点理论…我计划比较CSV和Parquet文件之间的数据处理，我认为我们应该了解这两种类型之间的主要区别:</p><ul class=""><li id="c377" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated">在拼花文件中，数据以更优化的方式压缩。您可能还记得上面的一个截图，与包含相同数据部分的CSV文件相比，parquet文件大约消耗1/3的内存</li><li id="47e8" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">Parquet文件支持列存储格式——也就是说，Parquet文件中的列是物理分离的，这意味着如果您只需要几列中的数据，就不需要扫描整个文件！相反，当你查询一个CSV文件时，每次你发送查询，它将扫描整个文件，即使你需要一列的数据</li><li id="ec59" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">对于那些来自传统SQL世界的人，你可以想到CSV与Parquet，例如<a class="ae ky" rel="noopener" target="_blank" href="/rows-or-columns-where-should-i-put-my-index-on-65d429692dee">行存储与列数据库</a></li></ul><h1 id="ba8c" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">用例1 —将CSV数据导入Power BI</h1><p id="1715" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">让我们从最明显和最理想的场景开始——使用导入模式将所有数据接收到Power BI中，并执行数据刷新以检查这将花费我们多少成本。</p><p id="2c6c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们动手之前，还有最后一件事——在Synapse Analytics中，仍然没有一个功能可以衡量特定查询的成本。您可以检查每天、每周或每月处理的数据量。此外，如果您愿意，您可以在每个时间粒度级别上设置限制——在本文的<a class="ae ky" href="https://docs.microsoft.com/en-us/azure/synapse-analytics/sql/data-processed" rel="noopener ugc nofollow" target="_blank">中有更多相关内容。</a></p><p id="2d36" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个特性也是相对较新的，所以我很高兴看到Synapse在提供完全成本透明的有希望的方式上取得了永久性的进展。</p><p id="f450" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于我们无法测量每个查询的确切成本，我将使用下面的T-SQL，通过在主数据库中查询DMV来尝试计算这些数字:</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="732f" class="nn ml it nj b gy no np l nq nr">SELECT * FROM sys.dm_external_data_processed<br/>WHERE type = 'daily'</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/517a222de0c86dc49ddf0444ceec2910.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5YChBjyQPyIVqfrC2ckdiQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="0294" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我今天的起点大约是29.7 GB，我将在每次定位无服务器SQL池以获取数据时计算差异。</p><p id="2a18" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好了，回到第一个场景，我将把这两个月的数据从CSV文件导入Power BI:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nh"><img src="../Images/96a56a2b550f59e028626653cee395cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3m45WZfybu91k1wN4eJ7lw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="40e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最令人着迷的是，我正在编写普通的T-SQL，所以我的用户甚至不知道他们是直接从CSV文件中获取数据的！我使用UNION ALL，因为我确信在我的两个视图中没有相同的记录，理论上，它应该比UNION运行得更快，但是我也可以使用相同的T-SQL语句创建一个单独的视图，然后在Power BI中使用该联合视图。</p><p id="d0a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我需要一个<a class="ae ky" rel="noopener" target="_blank" href="/tiq-part-3-ultimate-guide-to-date-dimension-creation-98b951ffa68c">合适的日期维度表</a>来测试不同的场景，我将使用Power Query创建它。该日期表在所有场景中都将处于导入模式，因此它不会影响来自无服务器SQL池的已处理数据量。以下是日期表的M代码:</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="1a7b" class="nn ml it nj b gy no np l nq nr">let<br/>    StartDate = #date(StartYear,1,1),<br/>    EndDate = #date(EndYear,12,31),<br/>    NumberOfDays = Duration.Days( EndDate - StartDate ),<br/>    Dates = List.Dates(StartDate, NumberOfDays+1, #duration(1,0,0,0)),<br/>    #"Converted to Table" = Table.FromList(Dates, Splitter.SplitByNothing(), null, null, ExtraValues.Error),<br/>    #"Renamed Columns" = Table.RenameColumns(#"Converted to Table",{{"Column1", "FullDateAlternateKey"}}),<br/>    #"Changed Type" = Table.TransformColumnTypes(#"Renamed Columns",{{"FullDateAlternateKey", type date}}),<br/>    #"Inserted Year" = Table.AddColumn(#"Changed Type", "Year", each Date.Year([FullDateAlternateKey]), type number),<br/>    #"Inserted Month" = Table.AddColumn(#"Inserted Year", "Month", each Date.Month([FullDateAlternateKey]), type number),<br/>    #"Inserted Month Name" = Table.AddColumn(#"Inserted Month", "Month Name", each Date.MonthName([FullDateAlternateKey]), type text),<br/>    #"Inserted Quarter" = Table.AddColumn(#"Inserted Month Name", "Quarter", each Date.QuarterOfYear([FullDateAlternateKey]), type number),<br/>    #"Inserted Week of Year" = Table.AddColumn(#"Inserted Quarter", "Week of Year", each Date.WeekOfYear([FullDateAlternateKey]), type number),<br/>    #"Inserted Week of Month" = Table.AddColumn(#"Inserted Week of Year", "Week of Month", each Date.WeekOfMonth([FullDateAlternateKey]), type number),<br/>    #"Inserted Day" = Table.AddColumn(#"Inserted Week of Month", "Day", each Date.Day([FullDateAlternateKey]), type number),<br/>    #"Inserted Day of Week" = Table.AddColumn(#"Inserted Day", "Day of Week", each Date.DayOfWeek([FullDateAlternateKey]), type number),<br/>    #"Inserted Day of Year" = Table.AddColumn(#"Inserted Day of Week", "Day of Year", each Date.DayOfYear([FullDateAlternateKey]), type number),<br/>    #"Inserted Day Name" = Table.AddColumn(#"Inserted Day of Year", "Day Name", each Date.DayOfWeekName([FullDateAlternateKey]), type text)<br/>in<br/>    #"Inserted Day Name"</span></pre><p id="6ffd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将数据加载到Power BI桌面需要一些时间，现在让我们检查一些关键指标。</p><ul class=""><li id="1285" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated">我的表有大约1470万行</li><li id="a602" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">我的整个数据模型大小约为92 MB，因为数据在Power BI Desktop中进行了优化压缩(我们已经降低了DateTime列的基数)</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nh"><img src="../Images/89ab5c2a965280303dfa00a6de5f83e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gXjDLGKtRXCoEDirVM9yig.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="0e03" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦我创建了表可视化，显示每个日期的总记录，我每天处理的数据量大约是33.3 GB。让我们刷新数据模型，看看它有多贵。因此，Power BI Desktop现在将转到一个无服务器SQL池，从我的两个视图中查询数据，但不要忘记在后台有两个CSV文件作为我们数据的最终来源！</p><p id="2d22" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">刷新后，我的每日值增加到了大约36.9 GB，这意味着这次刷新花费了大约3.6 GB。钱的话，大概是<strong class="lb iu"><em class="lv">0.018 $</em></strong>(0.0036 TB x 5 USD)。</p><p id="f0ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在此使用案例中，只有当我的Power BI模型被更新时，我才会花钱！简单地说，如果我每天刷新一次数据模型，这个报告每月将花费我54美分。</p><h1 id="8ffc" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">用例CSV文件上的DirectQuery</h1><p id="7a41" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">现在让我们来看看如果使用完全相同的查询会发生什么，但是我们将使用DirectQuery选项，而不是将数据导入Power BI Desktop。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/c3fa622cb9bac1780804b313ddf4460a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1398/format:webp/1*rmx_55S3Ax-ab5HUsUW-SA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="c081" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们首先与日期切片器交互，这样我们可以检查这将花费我们多少。我的测量起点是大约87.7 GB，这是我的报告的样子:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nh"><img src="../Images/ea154712fa60fe7c9f8891a5c8a08382.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kQHZ6MvkzZRvGeI7BR3ing.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="3869" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">刷新整个查询烧掉了~2.8 GB，也就是<strong class="lb iu"> <em class="lv"> ~0.014$ </em> </strong>。现在，这是为了页面上的一个单独的视觉效果！请记住，当您使用DirectQuery时，每个visual将生成一个对底层数据源的单独查询。让我们看看当我在页面上添加另一个视觉效果时会发生什么:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nh"><img src="../Images/cb34cb33182560fb3765f0ff428fe538.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2J9UunUChXPGIpPflZ2opQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="ee7b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，这个查询花费了我~4 GB，也就是<strong class="lb iu"> <em class="lv"> 0.02$ </em> </strong>。正如您可以得出的结论，增加报表画布上的视觉效果也会增加成本。</p><p id="b778" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还有一点要记住:<strong class="lb iu"> <em class="lv">这些成本是每个用户</em> </strong>！因此，如果您有10个用户并行运行这个相同的报告，您应该将成本乘以10，因为将为每个视图和每个用户生成一个新的查询。</p><h1 id="dbbb" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">用例3 —在DirectQuery模式下使用日期切片器</h1><p id="275a" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">现在，我想检查如果我在切片器中选择一个特定的日期范围，例如1月1日和1月13日之间，会发生什么情况:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nh"><img src="../Images/f3137c3891d173f52f4d9d27296f06d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n3PPH5FrTGdee064nXUNWQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="781f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我注意到的第一件事是查询花费了我完全一样的钱！奇怪的是，如果我查看为检索数据而生成的SQL查询，我可以看到引擎非常聪明地在WHERE子句中应用了日期过滤器:</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="4f4d" class="nn ml it nj b gy no np l nq nr">/*Query 1*/<br/>SELECT <br/>TOP (1000001) [semijoin1].[c1],SUM([a0])<br/> AS [a0]<br/>FROM <br/>(<br/>(<br/>SELECT [t1].[tpep_pickup_datetime] AS [c14],[t1].[total_amount] AS [a0]<br/>FROM <br/>(<br/>(SELECT * FROM dbo.taxi201901csv<br/>UNION ALL<br/>SELECT * FROM dbo.taxi201902csv<br/>)<br/>)<br/> AS [t1]<br/>)<br/> AS [basetable0]<br/> INNER JOIN <br/>(<br/>(SELECT 3 AS [c1],CAST( '20190101 00:00:00' AS datetime) AS [c14] )  UNION ALL <br/>(SELECT 4 AS [c1],CAST( '20190102 00:00:00' AS datetime) AS [c14] )  UNION ALL <br/>(SELECT 5 AS [c1],CAST( '20190103 00:00:00' AS datetime) AS [c14] )  UNION ALL <br/>(SELECT 6 AS [c1],CAST( '20190104 00:00:00' AS datetime) AS [c14] )  UNION ALL <br/>(SELECT 7 AS [c1],CAST( '20190105 00:00:00' AS datetime) AS [c14] )  UNION ALL <br/>(SELECT 8 AS [c1],CAST( '20190106 00:00:00' AS datetime) AS [c14] )  UNION ALL <br/>(SELECT 9 AS [c1],CAST( '20190107 00:00:00' AS datetime) AS [c14] )  UNION ALL <br/>(SELECT 10 AS [c1],CAST( '20190108 00:00:00' AS datetime) AS [c14] )  UNION ALL <br/>(SELECT 11 AS [c1],CAST( '20190109 00:00:00' AS datetime) AS [c14] )  UNION ALL <br/>(SELECT 12 AS [c1],CAST( '20190110 00:00:00' AS datetime) AS [c14] )  UNION ALL <br/>(SELECT 13 AS [c1],CAST( '20190111 00:00:00' AS datetime) AS [c14] )  UNION ALL <br/>(SELECT 14 AS [c1],CAST( '20190112 00:00:00' AS datetime) AS [c14] )  UNION ALL <br/>(SELECT 15 AS [c1],CAST( '20190113 00:00:00' AS datetime) AS [c14] ) <br/>)<br/> AS [semijoin1] on <br/>(<br/>([semijoin1].[c14] = [basetable0].[c14])<br/>)<br/>)<br/>GROUP BY [semijoin1].[c1] </span><span id="f33f" class="nn ml it nj b gy ns np l nq nr">/*Query 2*/<br/>SELECT SUM([t1].[total_amount])<br/> AS [a0]<br/>FROM <br/>(<br/>(SELECT * FROM dbo.taxi201901csv<br/>UNION ALL<br/>SELECT * FROM dbo.taxi201902csv)<br/>)<br/> AS [t1]<br/>WHERE <br/>(<br/>([t1].[tpep_pickup_datetime] IN (CAST( '20190112 00:00:00' AS datetime),CAST( '20190113 00:00:00' AS datetime),CAST( '20190101 00:00:00' AS datetime),CAST( '20190102 00:00:00' AS datetime),CAST( '20190103 00:00:00' AS datetime),CAST( '20190104 00:00:00' AS datetime),CAST( '20190105 00:00:00' AS datetime),CAST( '20190106 00:00:00' AS datetime),CAST( '20190107 00:00:00' AS datetime),CAST( '20190108 00:00:00' AS datetime),CAST( '20190109 00:00:00' AS datetime),CAST( '20190110 00:00:00' AS datetime),CAST( '20190111 00:00:00' AS datetime)))<br/>)</span></pre><p id="389b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，底层视图似乎扫描了CSV文件中的整个数据块！因此，如果您使用日期切片器来限制数据量，在节省方面没有任何好处，因为在任何情况下都会扫描整个CSV文件…</p><h1 id="77fe" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">用例DirectQuery模式下的聚合表</h1><p id="55e9" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">下一个测试将向我们展示如果我们<a class="ae ky" href="https://docs.microsoft.com/en-us/power-bi/transform-model/desktop-aggregations" rel="noopener ugc nofollow" target="_blank">创建一个聚集表</a>并以DirectQuery模式将其存储在Power BI中会发生什么。这是一个非常简单的汇总表，由总量和取件时间列组成。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/65b338fc81e4c1b89854e2bee9298684.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BGh074a6FQVotu1bzJbDwQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="f653" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我的查询命中了聚合表，但是在总查询成本方面没有任何变化，因为它与前面的用例完全相同:<strong class="lb iu"> <em class="lv"> ~0.02$ </em> </strong>！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nh"><img src="../Images/4b602110b9fb3b561de6432095f943f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EexykTsC57MfasUrEt5Q2Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><h1 id="120c" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">用例5 —导入模式下的聚合表</h1><p id="cf1b" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">之后，我想检查一下如果我将一个先前聚合的表导入到Power BI中会发生什么。我相信计算会更快，但让我们看看它会如何影响查询成本。</p><p id="d3a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如所料，这非常快，聚合表被命中，因此我们只需支付数据刷新的代价，如我们的用例#1: <strong class="lb iu"> <em class="lv"> 0.018$ </em> </strong>！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nh"><img src="../Images/c9f09a13190ed8a8e01e96b65866a7fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Abp43ZDsr_GawW9El22eCg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><h1 id="83d0" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">用例6 —无服务器SQL池中的聚合数据</h1><p id="812f" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">我想检查的最后一件事是，如果我知道我的分析工作负载，并且可以使用无服务器SQL池提前准备一些最频繁的查询，会发生什么情况。</p><p id="62c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我将创建一个视图，像上一个案例一样在Power BI Desktop中聚合数据，但这次是在无服务器SQL池中:</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="34f2" class="nn ml it nj b gy no np l nq nr">DROP VIEW IF EXISTS taxi201901_02_agg;<br/>GO</span><span id="29a0" class="nn ml it nj b gy ns np l nq nr">CREATE VIEW taxi201901_02_agg AS<br/>  SELECT  CAST(C2 AS DATE) AS tpep_pickup_datetime,<br/>        SUM(CAST(C17 AS DECIMAL(10,2))) AS total_amount<br/>FROM<br/>    OPENROWSET(<br/>        BULK N'https://nikola.dfs.core.windows.net/nikola/Data/yellow_tripdata_2019-01.csv',<br/>        FORMAT = 'CSV',<br/>        PARSER_VERSION='2.0',<br/>        HEADER_ROW = TRUE<br/>    ) <br/>    AS [taxi201901_02_agg]<br/>    GROUP BY CAST(C2 AS DATE)</span></pre><p id="3baa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">基本上，我们在源端聚合数据，这显然会有所帮助。所以，让我们来看看结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nh"><img src="../Images/e8e8a69a6ed73c11588232839d33c195.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JlIfzgyZjVyeKdgoZiJp3w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="e5d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它返回请求的数字更快，但是处理的数据量还是一样的！这个查询又花费了我<strong class="lb iu"> <em class="lv"> ~0.02$ </em> </strong>！</p><p id="0061" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这使我得出一个结论:<strong class="lb iu"> <em class="lv">无论您在CSV文件之上的无服务器SQL池中执行什么，它们都将在数据准备过程的最低级别被完全扫描！</em>T11】</strong></p><p id="29bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">我假设当您处理较大的数据集(几TB)时，成本差异会明显得多。因此，请记住，在无服务器SQL池中预先聚合数据可以节省流数据量，这也意味着您的总体成本将会降低！你可以在这里找到所有的细节。</strong></p><h1 id="0e30" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">用例#7 —导入拼花文件</h1><p id="97a5" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">现在，让我们评估一下，如果我们使用来自Parquet文件的数据，而不是CSV，是否会发生一些变化。</p><p id="e365" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一个用例是导入拼花文件。不出所料，由于它们比CSV文件压缩得更好，成本几乎降低了一倍:<strong class="lb iu"> <em class="lv"> ~0.01$ </em> </strong>！</p><h1 id="c125" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">用例8——对拼花文件进行直接查询</h1><p id="4f5c" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">最后，如果我们在Power BI中使用DirectQuery模式直接从Synapse的无服务器SQL池中的Parquet文件中查询数据，让我们来看看这些数字。</p><p id="a5ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">出乎我意料的是，这个查询处理了大约26 GB的数据，相当于<strong class="lb iu"> <em class="lv"> ~0.13$ </em> </strong>！</p><p id="122e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于这看起来非常奇怪，我开始调查并发现高成本的罪魁祸首是使用M！在后台调试由Power BI生成并发送到SQL引擎的SQL查询时，我注意到已经创建了极其复杂的查询，对日期维度中的每个值执行连接和联合操作:</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="7053" class="nn ml it nj b gy no np l nq nr">SELECT <br/>TOP (1000001) [semijoin1].[c1],SUM([a0])<br/> AS [a0]<br/>FROM <br/>(<br/>(<br/>SELECT [t1].[TpepPickupDatetime] AS [c13],[t1].[TotalAmount] AS [a0]<br/>FROM <br/>(<br/>(SELECT *<br/>FROM taxi201901parquet<br/>UNION ALL<br/>SELECT *<br/>FROM taxi201902parquet)<br/>)<br/> AS [t1]<br/>)<br/> AS [basetable0]<br/> INNER JOIN <br/>(<br/>(SELECT 3 AS [c1],CAST( '20190101 00:00:00' AS datetime) AS [c13] )  UNION ALL <br/>(SELECT 4 AS [c1],CAST( '20190102 00:00:00' AS datetime) AS [c13] )  UNION ALL <br/>(SELECT 5 AS [c1],CAST( '20190103 00:00:00' AS datetime) AS [c13] )  UNION ALL <br/>(SELECT 6 AS [c1],CAST( '20190104 00:00:00' AS datetime) AS [c13] )  UNION ALL <br/>(SELECT 7 AS [c1],CAST( '20190105 00:00:00' AS datetime) AS [c13] )  UNION ALL <br/>(SELECT 8 AS [c1],CAST( '20190106 00:00:00' AS datetime) AS [c13] )  UNION ALL <br/>(SELECT 9 AS [c1],CAST( '20190107 00:00:00' AS datetime) AS [c13] )  UNION ALL <br/>(SELECT 10 AS [c1],CAST( '20190108 00:00:00' AS datetime) AS [c13] )  UNION ALL <br/>(SELECT 11 AS [c1],CAST( '20190109 00:00:00' AS datetime) AS [c13] )  UNION ALL<br/>…..</span></pre><p id="82d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这只是生成的查询的摘录，为了可读性，我已经删除了其余的代码。</p><p id="e7ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦我从计算中排除了我的日期维度，成本预计会降低到400 MBs以下！！！因此，现在处理的数据量约为400MB，而不是日期维的26GB！</p><p id="98d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">总之，这些使用复合模型的场景需要仔细的评估和测试。</p><h1 id="8101" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">用例9 —无服务器SQL池中的聚合数据</h1><p id="1a33" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">那是我们的引爆点！这就是奇迹发生的地方！通过能够存储物理上分离的列，在这种情况下，Parquet优于所有以前的用例——当我说这种情况时，我指的是当您能够减少必要的列的数量时(只包括那些您需要从Power BI报告中查询的列)。</p><p id="cb66" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我在无服务器SQL池中创建了一个包含预聚合数据的视图后，只处理了400 MB的数据！与之前的所有测试相比，这是一个巨大的差异。基本上，这意味着这次查询的成本:<strong class="lb iu"> <em class="lv"> 0.002$ </em> </strong>！为了便于计算，我可以用1美元运行500次！</p><h1 id="17d3" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">定论</h1><p id="e9a7" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">下表列出了我所研究的每一个用例的成本:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/e27b8571930485f75afad5ec4c1419be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TjYzjwh7szYja9vklkVDCw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="de95" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">查看表格，并考虑我们在上面检查的不同使用案例，可以得出以下结论:</p><ul class=""><li id="857b" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated"><strong class="lb iu"> <em class="lv">尽可能使用拼花文件，而不是CSV </em> </strong></li><li id="e2c4" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated"><strong class="lb iu"> <em class="lv">尽可能将数据导入Power BI </em> </strong> —这意味着您只需在刷新数据快照时付费，而不是为报告中的每个查询付费</li><li id="54bb" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">如果您正在处理<strong class="lb iu"> <em class="lv"> Parquet </em> </strong>文件，只要有可能，<strong class="lb iu"> <em class="lv">就会在Synapse的无服务器SQL池</em> </strong>中创建预聚合数据(视图)</li><li id="37fd" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">由于无服务器SQL pool仍然<strong class="lb iu"> <em class="lv">不支持ResultSet缓存</em> </strong>(据我所知，微软的团队正在研究)，请记住，每次运行查询(即使您返回的是相同的结果集)，都会生成查询，您需要为此付费！</li><li id="5e4b" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">如果您的分析工作负载需要对大型数据集进行大量查询(如此之大，以至于无法选择导入模式)，也许您应该<strong class="lb iu"> <em class="lv">考虑将数据存储在专用的SQL池</em> </strong>中，因为您将支付固定的存储成本，而不是每次查询数据时的数据处理成本。这里，为了从使用这个场景中获得额外的好处，您应该在将中间结果导入到专用的SQL池之前，使用外部表对它们进行<a class="ae ky" href="https://docs.microsoft.com/en-us/azure/synapse-analytics/sql/create-external-table-as-select" rel="noopener ugc nofollow" target="_blank">具体化！这样，您的查询将读取已经准备好的数据，而不是原始数据</a></li><li id="a3b2" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">在Synapse Analytics中使用无服务器SQL池时，坚持使用<a class="ae ky" href="https://docs.microsoft.com/en-us/azure/synapse-analytics/sql/best-practices-sql-on-demand" rel="noopener ugc nofollow" target="_blank">通用最佳实践</a></li></ul><h1 id="98ed" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">结论</h1><p id="26fa" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">在本文中，我们深入测试了在Synapse Analytics中将Power BI与无服务器SQL池结合使用时的不同场景和多个用例。</p><p id="6294" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我看来，尽管Synapse还有很长的路要走，以微调无服务器SQL池中的所有功能和产品，但毫无疑问，它正朝着正确的方向前进。通过不断改进产品，并定期添加酷的新功能，Synapse可以真正成为您所有数据工作负载的一站式商店。</p><p id="00fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个博客系列的最后一部分，我们将检查Power BI如何与Azure的NoSQL解决方案(Cosmos DB)集成，以及无服务器SQL池如何在Azure Synapse Link for Cosmos DB的帮助下帮助优化分析工作负载。</p><p id="e4df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读！</p><p id="3eef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://datamozart.medium.com/membership" rel="noopener">成为会员，阅读Medium上的每一个故事！</a></p></div></div>    
</body>
</html>