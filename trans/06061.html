<html>
<head>
<title>How to test multiple machine learning pipelines with just a few lines of Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用几行Python测试多个机器学习管道</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-test-multiple-machine-learning-pipelines-with-just-a-few-lines-of-python-1a16cb4686d?source=collection_archive---------13-----------------------#2021-05-31">https://towardsdatascience.com/how-to-test-multiple-machine-learning-pipelines-with-just-a-few-lines-of-python-1a16cb4686d?source=collection_archive---------13-----------------------#2021-05-31</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/e32d58143fedd42bedb35fe535f84a54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*VVwtF88XK3Fqd4tI"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">昆腾·德格拉夫在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><h1 id="e612" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">介绍</h1><p id="e624" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">在项目的探索阶段，数据科学家试图为他的特定用例找到最佳的管道。因为几乎不可能预先知道哪种转换将对模型的结果最有益，所以这个过程通常包括尝试不同的方法。例如，如果我们正在处理一个不平衡的数据集，我们应该对少数类进行过采样还是对多数类进行欠采样？在这个故事中，我将解释如何使用<a class="ae kc" href="https://github.com/tvdboom/ATOM" rel="noopener ugc nofollow" target="_blank"> ATOM </a>包来快速帮助您评估在不同管道上训练的模型的性能。ATOM是一个开源的Python包，旨在帮助数据科学家加快机器学习管道的探索。如果你想对图书馆有一个温和的介绍，请阅读这个故事。</p></div><div class="ab cl lz ma hu mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="ij ik il im in"><h1 id="ed79" class="kd ke iq bd kf kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la bi translated">管理管道</h1><p id="5226" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">解释如何管理多个管道的最简单的方法是通过一个例子。在本例中，我们将:</p><ol class=""><li id="1b41" class="ml mm iq ld b le mn li mo lm mp lq mq lu mr ly ms mt mu mv bi translated">创建一个不平衡的数据集，并将其提供给atom</li></ol><p id="087b" class="pw-post-body-paragraph lb lc iq ld b le mn lg lh li mo lk ll lm mw lo lp lq mx ls lt lu my lw lx ly ij bi translated">2.使用<a class="ae kc" href="https://scikit-learn.org/stable/modules/generated/sklearn.feature_selection.RFE.html" rel="noopener ugc nofollow" target="_blank">递归特征消除</a>减少特征数量(RFE)</p><p id="04f5" class="pw-post-body-paragraph lb lc iq ld b le mn lg lh li mo lk ll lm mw lo lp lq mx ls lt lu my lw lx ly ij bi translated">3.训练三个<a class="ae kc" href="https://scikit-learn.org/stable/modules/generated/sklearn.ensemble.RandomForestClassifier.html" rel="noopener ugc nofollow" target="_blank">随机森林</a>(射频)模型:</p><ul class=""><li id="974b" class="ml mm iq ld b le mn li mo lm mp lq mq lu mr ly mz mt mu mv bi translated">一个直接在不平衡数据集上训练</li><li id="822f" class="ml mm iq ld b le na li nb lm nc lq nd lu ne ly mz mt mu mv bi translated">在应用<a class="ae kc" href="https://en.wikipedia.org/wiki/Oversampling_and_undersampling_in_data_analysis" rel="noopener ugc nofollow" target="_blank">过采样</a>后对数据集进行训练</li><li id="9938" class="ml mm iq ld b le na li nb lm nc lq nd lu ne ly mz mt mu mv bi translated">一个在应用<a class="ae kc" href="https://en.wikipedia.org/wiki/Oversampling_and_undersampling_in_data_analysis" rel="noopener ugc nofollow" target="_blank">欠采样</a>后在数据集上训练</li></ul><p id="2ef4" class="pw-post-body-paragraph lb lc iq ld b le mn lg lh li mo lk ll lm mw lo lp lq mx ls lt lu my lw lx ly ij bi translated">4.比较结果</p><p id="32a0" class="pw-post-body-paragraph lb lc iq ld b le mn lg lh li mo lk ll lm mw lo lp lq mx ls lt lu my lw lx ly ij bi translated">我们将用不到20行代码完成所有这些工作！让我们开始吧。</p><p id="eba6" class="pw-post-body-paragraph lb lc iq ld b le mn lg lh li mo lk ll lm mw lo lp lq mx ls lt lu my lw lx ly ij bi translated"><strong class="ld ir">创建数据集</strong></p><p id="aafa" class="pw-post-body-paragraph lb lc iq ld b le mn lg lh li mo lk ll lm mw lo lp lq mx ls lt lu my lw lx ly ij bi translated">我们开始创建一个模拟二进制分类数据集，将0.95–0.05比例的样本分配给每个类。然后，数据被输入到atom。</p><pre class="nf ng nh ni gt nj nk nl nm aw nn bi"><span id="7bda" class="no ke iq nk b gy np nq l nr ns">from atom import ATOMClassifier<br/>from sklearn.datasets import make_classification</span><span id="d567" class="no ke iq nk b gy nt nq l nr ns"># Create an imbalanced dataset<br/>X, y = make_classification(<br/>    n_samples=5000,<br/>    n_features=30,<br/>    n_informative=20,<br/>    weights=(0.95,),<br/>)</span><span id="f609" class="no ke iq nk b gy nt nq l nr ns"># Load the dataset into atom<br/>atom = ATOMClassifier(X, y, test_size=0.2, verbose=2)</span></pre><p id="3492" class="pw-post-body-paragraph lb lc iq ld b le mn lg lh li mo lk ll lm mw lo lp lq mx ls lt lu my lw lx ly ij bi translated">数据集被自动分为训练集和测试集。输出如下所示。</p><pre class="nf ng nh ni gt nj nk nl nm aw nn bi"><span id="96d4" class="no ke iq nk b gy np nq l nr ns">&lt;&lt; ================== ATOM ================== &gt;&gt;<br/>Algorithm task: binary classification.<br/><br/>Dataset stats ====================== &gt;&gt;<br/>Shape: (5000, 31)<br/>Scaled: False<br/>Outlier values: 582 (0.5%)<br/>---------------------------------------<br/>Train set size: 4000<br/>Test set size: 1000<br/>---------------------------------------<br/>|    | dataset     | train       | test       |<br/>|---:|:------------|:------------|:-----------|<br/>|  0 | 4731 (17.6) | 3777 (16.9) | 954 (20.7) |<br/>|  1 | 269 (1.0)   | 223 (1.0)   | 46 (1.0)   |</span></pre><p id="07b0" class="pw-post-body-paragraph lb lc iq ld b le mn lg lh li mo lk ll lm mw lo lp lq mx ls lt lu my lw lx ly ij bi translated">我们可以立即看到数据集是不平衡的，因为它包含的0比1多18倍。我们来看一下数据。注意，由于输入不是dataframe，atom为列指定了默认名称。</p><p id="65f6" class="pw-post-body-paragraph lb lc iq ld b le mn lg lh li mo lk ll lm mw lo lp lq mx ls lt lu my lw lx ly ij bi translated"><code class="fe nu nv nw nk b">atom.dataset.head()</code></p><figure class="nf ng nh ni gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nx"><img src="../Images/56e90bc6a191b4e7677aaacc685d707e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GYRFIAawMYfAKbk77-DUqA.png"/></div></div></figure><p id="4ec9" class="pw-post-body-paragraph lb lc iq ld b le mn lg lh li mo lk ll lm mw lo lp lq mx ls lt lu my lw lx ly ij bi translated"><strong class="ld ir">执行特征选择</strong></p><p id="a182" class="pw-post-body-paragraph lb lc iq ld b le mn lg lh li mo lk ll lm mw lo lp lq mx ls lt lu my lw lx ly ij bi translated">出于解释的目的，我们将从一个数据转换步骤开始，我们希望在我们将要测试的所有管道中共享这个步骤。通常，这类似于特征缩放或缺失值的插补。在这种情况下，我们将数据的维度从30个特征减少到12个特征。有了atom，就像这样简单。</p><p id="d80e" class="pw-post-body-paragraph lb lc iq ld b le mn lg lh li mo lk ll lm mw lo lp lq mx ls lt lu my lw lx ly ij bi translated"><code class="fe nu nv nw nk b">atom.feature_selection("RFE", solver="RF", n_features=12)</code></p><p id="70f6" class="pw-post-body-paragraph lb lc iq ld b le mn lg lh li mo lk ll lm mw lo lp lq mx ls lt lu my lw lx ly ij bi translated">此命令使用随机森林作为估计器来运行RFE。剩余的数据集包含最有希望的要素。</p><pre class="nf ng nh ni gt nj nk nl nm aw nn bi"><span id="976e" class="no ke iq nk b gy np nq l nr ns">Fitting FeatureSelector...<br/>Performing feature selection...<br/> --&gt; The RFE selected 12 features from the dataset.<br/>   &gt;&gt;&gt; Dropping feature Feature 2 (rank 3).<br/>   &gt;&gt;&gt; Dropping feature Feature 3 (rank 8).<br/>   &gt;&gt;&gt; Dropping feature Feature 5 (rank 10).<br/>   &gt;&gt;&gt; Dropping feature Feature 7 (rank 17).<br/>   &gt;&gt;&gt; Dropping feature Feature 8 (rank 12).<br/>   &gt;&gt;&gt; Dropping feature Feature 11 (rank 19).<br/>   &gt;&gt;&gt; Dropping feature Feature 13 (rank 13).<br/>   &gt;&gt;&gt; Dropping feature Feature 14 (rank 11).<br/>   &gt;&gt;&gt; Dropping feature Feature 15 (rank 15).<br/>   &gt;&gt;&gt; Dropping feature Feature 17 (rank 4).<br/>   &gt;&gt;&gt; Dropping feature Feature 19 (rank 16).<br/>   &gt;&gt;&gt; Dropping feature Feature 20 (rank 2).<br/>   &gt;&gt;&gt; Dropping feature Feature 21 (rank 6).<br/>   &gt;&gt;&gt; Dropping feature Feature 23 (rank 5).<br/>   &gt;&gt;&gt; Dropping feature Feature 24 (rank 9).<br/>   &gt;&gt;&gt; Dropping feature Feature 25 (rank 18).<br/>   &gt;&gt;&gt; Dropping feature Feature 26 (rank 7).<br/>   &gt;&gt;&gt; Dropping feature Feature 27 (rank 14).</span></pre><p id="fdb7" class="pw-post-body-paragraph lb lc iq ld b le mn lg lh li mo lk ll lm mw lo lp lq mx ls lt lu my lw lx ly ij bi translated">现在，我们直接在不平衡数据集上训练我们的第一个模型。使用<code class="fe nu nv nw nk b">run</code>方法，我们在训练集上拟合一个随机森林，并在测试集上对其进行评估。</p><p id="5c55" class="pw-post-body-paragraph lb lc iq ld b le mn lg lh li mo lk ll lm mw lo lp lq mx ls lt lu my lw lx ly ij bi translated"><code class="fe nu nv nw nk b">atom.run(models="RF", metric="balanced_accuracy")</code></p><pre class="nf ng nh ni gt nj nk nl nm aw nn bi"><span id="262c" class="no ke iq nk b gy np nq l nr ns">Training ===================================== &gt;&gt;<br/>Models: RF<br/>Metric: balanced_accuracy<br/><br/><br/>Results for Random Forest:         <br/>Fit ---------------------------------------------<br/>Train evaluation --&gt; balanced_accuracy: 1.0<br/>Test evaluation --&gt; balanced_accuracy: 0.5326<br/>Time elapsed: 0.733s<br/>-------------------------------------------------<br/>Total time: 0.733s<br/><br/><br/>Final results ========================= &gt;&gt;<br/>Duration: 0.733s<br/>------------------------------------------<br/>Random Forest --&gt; balanced_accuracy: 0.5326</span></pre><p id="a513" class="pw-post-body-paragraph lb lc iq ld b le mn lg lh li mo lk ll lm mw lo lp lq mx ls lt lu my lw lx ly ij bi translated"><strong class="ld ir">分支系统</strong></p><p id="88fd" class="pw-post-body-paragraph lb lc iq ld b le mn lg lh li mo lk ll lm mw lo lp lq mx ls lt lu my lw lx ly ij bi translated">在继续之前，是时候解释一下ATOM的分支系统了。分支系统允许您在同一个atom实例中管理多个管道。每个管道都存储在一个单独的分支中，可以通过<code class="fe nu nv nw nk b">branch</code>属性进行访问。分支包含数据集的副本，以及适合该特定数据集的所有转换器和模型。从atom调用的方法总是使用当前分支中的数据集，以及<code class="fe nu nv nw nk b">atom.dataset</code>等数据属性。默认情况下，atom从一个名为<code class="fe nu nv nw nk b">master</code>的分支开始。致电分支机构，了解其包含的变压器和型号的概况。</p><p id="dd65" class="pw-post-body-paragraph lb lc iq ld b le mn lg lh li mo lk ll lm mw lo lp lq mx ls lt lu my lw lx ly ij bi translated"><code class="fe nu nv nw nk b">atom.branch</code></p><pre class="nf ng nh ni gt nj nk nl nm aw nn bi"><span id="9c85" class="no ke iq nk b gy np nq l nr ns">Branch: master<br/> --&gt; Pipeline: <br/>   &gt;&gt;&gt; FeatureSelector<br/>     --&gt; strategy: RFE<br/>     --&gt; solver: RandomForestClassifier(n_jobs=1, random_state=1)<br/>     --&gt; n_features: 12<br/>     --&gt; max_frac_repeated: 1.0<br/>     --&gt; max_correlation: 1.0<br/>     --&gt; kwargs: {}<br/> --&gt; Models: RF</span></pre><p id="849b" class="pw-post-body-paragraph lb lc iq ld b le mn lg lh li mo lk ll lm mw lo lp lq mx ls lt lu my lw lx ly ij bi translated">当前分支包含我们之前调用的用于特征选择的类，以及我们刚刚训练的模型。</p><p id="d9cf" class="pw-post-body-paragraph lb lc iq ld b le mn lg lh li mo lk ll lm mw lo lp lq mx ls lt lu my lw lx ly ij bi translated"><strong class="ld ir">过采样</strong></p><p id="4b5c" class="pw-post-body-paragraph lb lc iq ld b le mn lg lh li mo lk ll lm mw lo lp lq mx ls lt lu my lw lx ly ij bi translated">现在是时候测试模型在对数据集进行过采样后的表现了。在这里，我们创建一个名为<code class="fe nu nv nw nk b">oversample</code>的新分支。</p><p id="4580" class="pw-post-body-paragraph lb lc iq ld b le mn lg lh li mo lk ll lm mw lo lp lq mx ls lt lu my lw lx ly ij bi translated"><code class="fe nu nv nw nk b">atom.branch = "oversample"</code></p><pre class="nf ng nh ni gt nj nk nl nm aw nn bi"><span id="4be0" class="no ke iq nk b gy np nq l nr ns">New branch oversample successfully created!</span></pre><p id="c820" class="pw-post-body-paragraph lb lc iq ld b le mn lg lh li mo lk ll lm mw lo lp lq mx ls lt lu my lw lx ly ij bi translated"><strong class="ld ir">注意:</strong>创建新分支会自动将当前分支更改为新分支。要在现有分支之间切换，只需输入所需分支的名称，例如<code class="fe nu nv nw nk b">atom.branch = "master"</code>即可返回主分支。</p><p id="02f6" class="pw-post-body-paragraph lb lc iq ld b le mn lg lh li mo lk ll lm mw lo lp lq mx ls lt lu my lw lx ly ij bi translated">过采样分支从当前分支(主分支)中分离出来，采用其数据集和转换器。这意味着特性选择转换器现在也是过采样流水线中的一个步骤。像这样分割分支可以避免重新计算之前的转换。</p><p id="2194" class="pw-post-body-paragraph lb lc iq ld b le mn lg lh li mo lk ll lm mw lo lp lq mx ls lt lu my lw lx ly ij bi translated">使用<a class="ae kc" href="https://imbalanced-learn.org/stable/references/generated/imblearn.over_sampling.SMOTE.html" rel="noopener ugc nofollow" target="_blank"> SMOTE </a>调用<code class="fe nu nv nw nk b">balance</code>方法对数据集进行过采样。</p><p id="ce7f" class="pw-post-body-paragraph lb lc iq ld b le mn lg lh li mo lk ll lm mw lo lp lq mx ls lt lu my lw lx ly ij bi translated"><code class="fe nu nv nw nk b">atom.balance(strategy="smote")</code></p><pre class="nf ng nh ni gt nj nk nl nm aw nn bi"><span id="fa17" class="no ke iq nk b gy np nq l nr ns">Oversampling with SMOTE...<br/> --&gt; Adding 7102 samples to class: 1.</span></pre><p id="c900" class="pw-post-body-paragraph lb lc iq ld b le mn lg lh li mo lk ll lm mw lo lp lq mx ls lt lu my lw lx ly ij bi translated">请记住，该方法仅转换当前分支中的数据集。主分支中的数据集保持不变。快速检查转换是否有效。</p><p id="49b0" class="pw-post-body-paragraph lb lc iq ld b le mn lg lh li mo lk ll lm mw lo lp lq mx ls lt lu my lw lx ly ij bi translated"><code class="fe nu nv nw nk b">atom.classes</code></p><figure class="nf ng nh ni gt jr gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/af61dcc43b27799716bd3e81ef54b98d.png" data-original-src="https://miro.medium.com/v2/resize:fit:478/format:webp/1*O9KweKrKa0LgoFercDSF_A.png"/></div></figure><p id="f18b" class="pw-post-body-paragraph lb lc iq ld b le mn lg lh li mo lk ll lm mw lo lp lq mx ls lt lu my lw lx ly ij bi translated">请注意，只有训练集是平衡的，因为我们希望在测试集中保留原始的类分布。</p><p id="ac50" class="pw-post-body-paragraph lb lc iq ld b le mn lg lh li mo lk ll lm mw lo lp lq mx ls lt lu my lw lx ly ij bi translated">现在，我们可以在过采样数据集上训练一个随机森林模型。为了将这个模型与我们训练的第一个模型区分开来，我们在模型的缩写后面添加了一个标记(os表示过采样)。</p><p id="3c12" class="pw-post-body-paragraph lb lc iq ld b le mn lg lh li mo lk ll lm mw lo lp lq mx ls lt lu my lw lx ly ij bi translated"><code class="fe nu nv nw nk b">atom.run(models="RF_os", metric="balanced_accuracy")</code></p><pre class="nf ng nh ni gt nj nk nl nm aw nn bi"><span id="de65" class="no ke iq nk b gy np nq l nr ns">Training ===================================== &gt;&gt;<br/>Models: RF_os<br/>Metric: balanced_accuracy<br/><br/><br/>Results for Random Forest:         <br/>Fit ---------------------------------------------<br/>Train evaluation --&gt; balanced_accuracy: 1.0<br/>Test evaluation --&gt; balanced_accuracy: 0.7737<br/>Time elapsed: 1.325s<br/>-------------------------------------------------<br/>Total time: 1.325s<br/><br/><br/>Final results ========================= &gt;&gt;<br/>Duration: 1.341s<br/>------------------------------------------<br/>Random Forest --&gt; balanced_accuracy: 0.7737</span></pre><p id="b7e0" class="pw-post-body-paragraph lb lc iq ld b le mn lg lh li mo lk ll lm mw lo lp lq mx ls lt lu my lw lx ly ij bi translated"><strong class="ld ir">欠采样</strong></p><p id="41e9" class="pw-post-body-paragraph lb lc iq ld b le mn lg lh li mo lk ll lm mw lo lp lq mx ls lt lu my lw lx ly ij bi translated">需要一个新的分支来对数据进行欠采样。由于当前分支包含过采样数据集，我们必须将新分支从仅包含RFE变换器的主分支中分离出来。</p><p id="9c55" class="pw-post-body-paragraph lb lc iq ld b le mn lg lh li mo lk ll lm mw lo lp lq mx ls lt lu my lw lx ly ij bi translated"><code class="fe nu nv nw nk b">atom.branch = "undersample_from_master"</code></p><pre class="nf ng nh ni gt nj nk nl nm aw nn bi"><span id="e572" class="no ke iq nk b gy np nq l nr ns">New branch undersample successfully created!</span></pre><p id="9628" class="pw-post-body-paragraph lb lc iq ld b le mn lg lh li mo lk ll lm mw lo lp lq mx ls lt lu my lw lx ly ij bi translated">在新分支和现有分支之间添加<code class="fe nu nv nw nk b">_from_</code>，将其从现有分支而不是当前分支中分离出来。检查欠采样分支中的数据集是否仍然不平衡。</p><p id="ca67" class="pw-post-body-paragraph lb lc iq ld b le mn lg lh li mo lk ll lm mw lo lp lq mx ls lt lu my lw lx ly ij bi translated"><code class="fe nu nv nw nk b">atom.classes</code></p><figure class="nf ng nh ni gt jr gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/197cccface67c584c4f537268824cf4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:478/format:webp/1*IrHP8Cm_iCDQENKCZa-AbA.png"/></div></figure><p id="25fb" class="pw-post-body-paragraph lb lc iq ld b le mn lg lh li mo lk ll lm mw lo lp lq mx ls lt lu my lw lx ly ij bi translated">再次调用<code class="fe nu nv nw nk b">balance</code>方法，使用<a class="ae kc" href="https://imbalanced-learn.org/dev/references/generated/imblearn.under_sampling.NearMiss.html" rel="noopener ugc nofollow" target="_blank"> NearMiss </a>对数据进行欠采样。</p><p id="39ff" class="pw-post-body-paragraph lb lc iq ld b le mn lg lh li mo lk ll lm mw lo lp lq mx ls lt lu my lw lx ly ij bi translated"><code class="fe nu nv nw nk b">atom.balance(strategy="NearMiss")</code></p><pre class="nf ng nh ni gt nj nk nl nm aw nn bi"><span id="b006" class="no ke iq nk b gy np nq l nr ns">Undersampling with NearMiss...<br/> --&gt; Removing 7102 samples from class: 0.</span></pre><p id="0fa5" class="pw-post-body-paragraph lb lc iq ld b le mn lg lh li mo lk ll lm mw lo lp lq mx ls lt lu my lw lx ly ij bi translated">并使用新标签(us表示欠采样)拟合随机森林。</p><p id="bcca" class="pw-post-body-paragraph lb lc iq ld b le mn lg lh li mo lk ll lm mw lo lp lq mx ls lt lu my lw lx ly ij bi translated"><code class="fe nu nv nw nk b">atom.run(models="RF_us", metric="balanced_accuracy")</code></p><pre class="nf ng nh ni gt nj nk nl nm aw nn bi"><span id="bd81" class="no ke iq nk b gy np nq l nr ns">Training ===================================== &gt;&gt;<br/>Models: RF_us<br/>Metric: balanced_accuracy<br/><br/><br/>Results for Random Forest:         <br/>Fit ---------------------------------------------<br/>Train evaluation --&gt; balanced_accuracy: 1.0<br/>Test evaluation --&gt; balanced_accuracy: 0.6888<br/>Time elapsed: 0.189s<br/>-------------------------------------------------<br/>Total time: 0.189s<br/><br/><br/>Final results ========================= &gt;&gt;<br/>Duration: 0.189s<br/>------------------------------------------<br/>Random Forest --&gt; balanced_accuracy: 0.6888</span></pre><p id="0d2c" class="pw-post-body-paragraph lb lc iq ld b le mn lg lh li mo lk ll lm mw lo lp lq mx ls lt lu my lw lx ly ij bi translated">如果我们现在查看我们的分支，我们会看到管道只包含我们想要的两个转换。</p><p id="91dc" class="pw-post-body-paragraph lb lc iq ld b le mn lg lh li mo lk ll lm mw lo lp lq mx ls lt lu my lw lx ly ij bi translated"><code class="fe nu nv nw nk b">atom.branch</code></p><pre class="nf ng nh ni gt nj nk nl nm aw nn bi"><span id="bdd8" class="no ke iq nk b gy np nq l nr ns">Branch: undersample<br/> --&gt; Pipeline: <br/>   &gt;&gt;&gt; FeatureSelector<br/>     --&gt; strategy: RFE<br/>     --&gt; solver: RandomForestClassifier(n_jobs=1, random_state=1)<br/>     --&gt; n_features: 12<br/>     --&gt; max_frac_repeated: 1.0<br/>     --&gt; max_correlation: 1.0<br/>     --&gt; kwargs: {}<br/>   &gt;&gt;&gt; Balancer<br/>     --&gt; strategy: NearMiss<br/>     --&gt; kwargs: {}<br/> --&gt; Models: RF_us</span></pre><p id="f2cf" class="pw-post-body-paragraph lb lc iq ld b le mn lg lh li mo lk ll lm mw lo lp lq mx ls lt lu my lw lx ly ij bi translated"><strong class="ld ir">分析结果</strong></p><p id="8ac6" class="pw-post-body-paragraph lb lc iq ld b le mn lg lh li mo lk ll lm mw lo lp lq mx ls lt lu my lw lx ly ij bi translated">我们最终在atom实例中获得了我们想要的三个模型。分支系统现在看起来如下。</p><figure class="nf ng nh ni gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nz"><img src="../Images/78b398ce689f28097dc0a412f06b9e33.png" data-original-src="https://miro.medium.com/v2/resize:fit:1212/format:webp/1*nNZ_kdusUqU9ukWODzjdRA.png"/></div></div></figure><p id="e6cf" class="pw-post-body-paragraph lb lc iq ld b le mn lg lh li mo lk ll lm mw lo lp lq mx ls lt lu my lw lx ly ij bi translated">RFE变换在三个分支之间共享，但是之后，每个分支遵循不同的路径。主分支没有其他变压器，而其他两个分支各自应用不同的平衡算法。所有三个分支都包含一个随机森林模型，每个都在不同的数据集上进行训练。剩下的就是比较结果了。</p><p id="8554" class="pw-post-body-paragraph lb lc iq ld b le mn lg lh li mo lk ll lm mw lo lp lq mx ls lt lu my lw lx ly ij bi translated"><code class="fe nu nv nw nk b">atom.evaluate()</code></p><figure class="nf ng nh ni gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oa"><img src="../Images/c8c8550a53ede90d389e817990f000ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jQAdSC6f9KQZYpn-MZ8MXA.png"/></div></div></figure><p id="bb3b" class="pw-post-body-paragraph lb lc iq ld b le mn lg lh li mo lk ll lm mw lo lp lq mx ls lt lu my lw lx ly ij bi translated"><code class="fe nu nv nw nk b">atom.plot_prc()</code></p><figure class="nf ng nh ni gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ob"><img src="../Images/9a196dc64419e1134f5a999bc0313d78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nnwXGoFbgvERlx0Y5K8MDw.png"/></div></div></figure></div><div class="ab cl lz ma hu mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="ij ik il im in"><h1 id="08e3" class="kd ke iq bd kf kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la bi translated">结论</h1><p id="9ec7" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">我们已经了解了如何使用ATOM包轻松比较多个机器学习管道。将所有管道(以及模型)放在同一个atom实例中有几个优点:</p><ul class=""><li id="9629" class="ml mm iq ld b le mn li mo lm mp lq mq lu mr ly mz mt mu mv bi translated">代码更短，这使得笔记本不那么杂乱，并且更容易维护概览</li><li id="2cf7" class="ml mm iq ld b le na li nb lm nc lq nd lu ne ly mz mt mu mv bi translated">跨管道共享的转换不需要重新计算</li><li id="c1b8" class="ml mm iq ld b le na li nb lm nc lq nd lu ne ly mz mt mu mv bi translated">使用atom的绘图方法可以更容易地比较结果</li></ul><p id="868e" class="pw-post-body-paragraph lb lc iq ld b le mn lg lh li mo lk ll lm mw lo lp lq mx ls lt lu my lw lx ly ij bi translated">我们所经历的例子非常简单，但是ATOM可以做得更多！要了解更多信息，请查看<a class="ae kc" rel="noopener" target="_blank" href="/atom-a-python-package-for-fast-exploration-of-machine-learning-pipelines-653956a16e7b">这个相关的故事</a>或者看看软件包的<a class="ae kc" href="https://tvdboom.github.io/ATOM/" rel="noopener ugc nofollow" target="_blank">文档</a>。对于bug或功能需求，请不要犹豫，在<a class="ae kc" href="https://github.com/tvdboom/ATOM" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上发帖或给我发邮件。</p></div></div>    
</body>
</html>