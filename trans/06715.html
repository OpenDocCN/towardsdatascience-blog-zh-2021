<html>
<head>
<title>Don’t Be a Basic Coder And Use 5 Possibilities to Avoid The Bad Switch Case</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">不要成为一个基本的编码者，使用5种可能性来避免糟糕的切换情况</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/dont-be-a-basic-coder-and-use-5-possibilities-to-avoid-the-bad-switch-case-c92402f4061?source=collection_archive---------3-----------------------#2021-06-17">https://towardsdatascience.com/dont-be-a-basic-coder-and-use-5-possibilities-to-avoid-the-bad-switch-case-c92402f4061?source=collection_archive---------3-----------------------#2021-06-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3a8c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">您编写真正灵活和可伸缩代码的方法</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f54e32d32ce49a97b9bc9853299d2ef6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mFQ2CAwrlIMbJX1rsze3JA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由<a class="ae ky" href="https://www.udemy.com/user/arnold-abraham-3/" rel="noopener ugc nofollow" target="_blank">作者</a></p></figure><p id="07bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您想到的第一个问题是:为什么要避免switch-case结构？</p><p id="99ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">想象你正在做你梦想中的项目，一切都很好。你不断地实现特性。但是你突然想到:</p><p id="20c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">为什么我会不断地向任何开关盒添加新盒？</em></p><p id="3d6a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">为什么我要不断修改以前运行良好的代码？</em></p><p id="974e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">阅读本文几个月后，您将真正能够构建健壮的、可伸缩的应用程序。代码写一次，重复使用，直到调用树烧毁。在不改变旧代码的情况下添加新功能。甚至一个可理解的git历史也得到保证，一个项目/游戏/应用也进化了，而不是突变了。</p><p id="4a68" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="lv">而这一切都是因为你已经学会了</em> </strong> <a class="ae ky" href="https://bit.ly/3vuZxsk" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu"> <em class="lv">避免使用switch——case</em></strong></a><strong class="lb iu"><em class="lv">。</em> </strong></p><h1 id="b7f2" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">背后的原因</h1><p id="4cb8" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">你可能理解开关的情况，因为他们有一个低的学习曲线，并导致相当舒适的使用。它是初级和中级程序员的默认工具集。但是使用它们也有一些缺点。</p><p id="76ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它们在创建初始用例集的过程中工作得很好，但是一旦你必须扩展它们，它们就会变得不方便并使你的代码膨胀。</p><p id="fb02" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，当您想要映射复杂的场景时，switch-case是一团乱麻。</p><p id="0c66" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我多年的C#开发中，我大量使用了切换用例，并多次遇到切换用例的缺点:</p><ul class=""><li id="71d0" class="mt mu it lb b lc ld lf lg li mv lm mw lq mx lu my mz na nb bi translated">不使用变量意味着更少的灵活性和硬编码情况</li><li id="e0c2" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated">在多种情况下不使用同一个常量意味着运行时灵活性降低</li><li id="6e1b" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated">没有使用关系表达式(==，！=，&lt;= etc.)</li><li id="1b8d" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated">No usage of float or constants</li><li id="8026" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated">Not expandable by redefining the environment, need to redefine switch-case</li></ul><h1 id="3048" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">The Fundamental Problem of Switch-Case</h1><p id="0ac1" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">Let’s imagine we want to make a trading card game, and we are about to realize a fundamental part of the game.</p><p id="af89" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">在一个回合中从一副牌中抽牌。</em></p><p id="f9d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我们需要<code class="fe nh ni nj nk b">CardDeck</code>的类，以便以后从中抽牌。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="3699" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nh ni nj nk b">CardDeck</code>是一个类，并且有一个字段<code class="fe nh ni nj nk b">amountOfCards</code>用于表示剩余要抽的牌的数量。</p></div><div class="ab cl nn no hx np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="im in io ip iq"><h1 id="d2cf" class="lw lx it bd ly lz nu mb mc md nv mf mg jz nw ka mi kc nx kd mk kf ny kg mm mn bi translated">使用开关盒进行操作</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/03c4b4e25c5b60ec94219d96dfb599cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ciiKTIuGJOwYmTDg.jpg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来自Pinterest上的<a class="ae ky" href="https://in.pinterest.com/sachmon1000/coding-meme/" rel="noopener ugc nofollow" target="_blank">编码迷因</a></p></figure><p id="f28d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要从一个初级程序员起步，我们必须首先像一个初级程序员一样思考。</p><p id="b387" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，第一种方法旨在使用开关盒。</p><p id="5abd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nh ni nj nk b">Draw()</code>函数将检查该事实，并接受牌组和牌的类型作为参数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="019f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每张抽牌都要告诉我们抽到了什么样的牌。将有4个选项:</p><ol class=""><li id="d24b" class="mt mu it lb b lc ld lf lg li mv lm mw lq mx lu oa mz na nb bi translated">怪物卡</li><li id="0fe0" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu oa mz na nb bi translated">魔法卡片</li><li id="2ad9" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu oa mz na nb bi translated">陷阱卡</li><li id="3675" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu oa mz na nb bi translated">土地卡</li></ol><p id="b481" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果至少还有1张牌，我们将随机得到一个进入开关盒的条目<code class="fe nh ni nj nk b">cardTypes</code>。无论画了什么，调用<code class="fe nh ni nj nk b">PutCardToHand()</code>都会打印出类型。</p><p id="1a84" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在<code class="fe nh ni nj nk b">Main</code>函数调用这段代码。我们首先将这个draw函数放在一个公共类<code class="fe nh ni nj nk b">SwitchCaseUser</code>中，意思是实例化:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="ca90" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另外，<code class="fe nh ni nj nk b">cardTypes</code>在这里被定义为一个字符串数组。这段代码会导致</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/679aa1d6bfe0f1f1f376119b5147945a.png" data-original-src="https://miro.medium.com/v2/resize:fit:412/format:webp/1*9OupcjJ1_shd47fDVCoUkg.png"/></div></figure><p id="9fde" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然这款电源线工作正常，也达到了设计目的，但我们面临着3个关键问题:</p><ol class=""><li id="3c5b" class="mt mu it lb b lc ld lf lg li mv lm mw lq mx lu oa mz na nb bi translated"><strong class="lb iu">switch-case是硬编码的</strong>:定义要在外部绘制的类型将使这个函数与这个外部世界紧密耦合。这个函数哪里知道自己在抽什么牌？外部空间的变化将改变该函数内部的情况。</li><li id="cd50" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu oa mz na nb bi translated"><strong class="lb iu">定义可以在该函数中绘制的卡片类型</strong>会导致同样的问题，因为现在该函数明确地知道可以绘制什么。但是为什么绘图函数必须知道这些呢？绘制函数应该绘制，不管它在绘制什么。在这种情况下，卡类型的改变也意味着开关外壳的改变。</li><li id="6607" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu oa mz na nb bi translated"><strong class="lb iu">扩展这个行为很笨重，代码也不灵活</strong>。因为一旦我们有了一个完整的功能类，它准确地做了它应该做的事情，并且做得很好，它应该永远保持原样。我们应该以有效的代码方式编程，并且应该一直有效。如果外部行为改变，不要再触摸它。这意味着传递所有需要的引用来实现这个结果，并且独立于已经传递的内容。</li></ol><p id="e0ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="lv">避免开关盒将有助于消除所有提到的缺点。</em> </strong></p></div><div class="ab cl nn no hx np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="im in io ip iq"><h1 id="f116" class="lw lx it bd ly lz nu mb mc md nv mf mg jz nw ka mi kc nx kd mk kf ny kg mm mn bi translated">避免开关盒— 5种可能性</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/70742a3975290aa1e2e41c65ff0c151f.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/0*20cLd1woO0KzoK8t.jpg"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由<a class="ae ky" href="https://memegenerator.net/instance/67304044/dr-evil-meme-best-practice" rel="noopener ugc nofollow" target="_blank">memegenerator.net</a></p></figure><p id="dd3f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，我们将卡片组和卡片类型交给我们的<code class="fe nh ni nj nk b">Draw()</code>函数，但是这次我们不使用开关盒。相反，我们使用<strong class="lb iu">五种不同的方法</strong>来避免切换情况。</p><p id="b1fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于所有五种方法，函数的每个头和每个第一部分都是相同的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="7396" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">if语句中有可互换的部分:</p><p id="b8df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一个和第二个选项在避免切换的情况下保持原来的字符串数组<code class="fe nh ni nj nk b">cardTypes</code>。所有其他的例子都基于到一个<code class="fe nh ni nj nk b">List&lt;string&gt;</code>的转换。</p><blockquote class="od oe of"><p id="bd27" class="kz la lv lb b lc ld ju le lf lg jx lh og lj lk ll oh ln lo lp oi lr ls lt lu im bi translated">这只是对开关情况的有意义替换的简短比较。如果您想要对每种技术有更深入的解释，您可以在Robert C. Martin的《干净的代码》一书中找到它们。</p></blockquote></div><div class="ab cl nn no hx np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="im in io ip iq"><h2 id="c640" class="oj lx it bd ly ok ol dn mc om on dp mg li oo op mi lm oq or mk lq os ot mm ou bi translated">#1 For循环/ ForEach循环</h2><p id="39b4" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">for循环遍历数组，将<code class="fe nh ni nj nk b">cardType</code>与来自<code class="fe nh ni nj nk b">cardTypes</code>的所有条目进行比较，并将匹配传递给<code class="fe nh ni nj nk b">PutCardToHand</code>函数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure></div><div class="ab cl nn no hx np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="im in io ip iq"><h2 id="bf3e" class="oj lx it bd ly ok ol dn mc om on dp mg li oo op mi lm oq or mk lq os ot mm ou bi translated">#2本地功能</h2><p id="8218" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">局部函数的功能与for循环几乎相同，但它使用forEach循环将其封装到一个局部函数中。</p><p id="41c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一些恶意的人可能会说这只是像#1一样的一种复杂的方式，但是这是一个展示，本地函数在更高级的用例中变得有趣。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure></div><div class="ab cl nn no hx np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="im in io ip iq"><h2 id="e3ad" class="oj lx it bd ly ok ol dn mc om on dp mg li oo op mi lm oq or mk lq os ot mm ou bi translated">#3索引方法</h2><p id="3398" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">现在将<code class="fe nh ni nj nk b">array</code>转换为<code class="fe nh ni nj nk b">list</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="a88e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为有一个列表可供我们使用，所以我们可以使用一些先验函数来聚集它们。</p><p id="4e80" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的<code class="fe nh ni nj nk b">cardTypesList</code>现在可以访问一组功能(微软文档中的完整指南<a class="ae ky" href="https://docs.microsoft.com/de-de/dotnet/api/system.collections.generic.list-1?view=netframework-4.8" rel="noopener ugc nofollow" target="_blank">)。一个是<code class="fe nh ni nj nk b">indexOf</code>方法，它返回匹配我们输入的条目的索引。</a></p><p id="e878" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将这个传递给我们的函数<code class="fe nh ni nj nk b">PutCardToHand</code>将会得到想要的行为。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure></div><div class="ab cl nn no hx np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="im in io ip iq"><h2 id="392f" class="oj lx it bd ly ok ol dn mc om on dp mg li oo op mi lm oq or mk lq os ot mm ou bi translated">#4匿名方法</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ov"><img src="../Images/c348b151cd7d4938a2b10e2ca54875f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1308/format:webp/0*Td5q1gT31uRYOyg0.jpg"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来自<a class="ae ky" href="https://www.filmstarts.de/nachrichten/18520774.html" rel="noopener ugc nofollow" target="_blank"> Filmstarts.de </a></p></figure><p id="7d49" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">匿名的方法就像是Wile E. Coyote和他那晦涩的武器去抓走鹃。Meep Meep。</p><p id="9285" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们必须处理定义开销。</p><p id="0862" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">命名函数中的匿名函数作为参数会导致函数定义的双重麻烦。</p><p id="c8e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一种相当沉重的编码方式，因此，以后也不容易理解。要注意！</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><pre class="kj kk kl km gt ow nk ox oy aw oz bi"><span id="96ea" class="oj lx it nk b gy pa pb l pc pd">((Func&lt;string (inputParameter1), List&lt;string&gt; (inputParameter2), string (return parameter)&gt;) anonymousFunction(inputParameter1, inputParameter2, returnParameter)<br/>{<br/>  Lambda Expression returning cardType</span><span id="c7d8" class="oj lx it nk b gy pe pb l pc pd">}(passingParameter1, passingParameter2) &lt;- Instant Invokation</span></pre><p id="93d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个匿名函数的典型用法是当有一个大型数据集传入时，我们只需要在代码的这个特定部分聚合属性的子集，或者另一个典型用法是当您只需要在此时此地对数据做一次事情时。</p><p id="419e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，定义一个命名函数并污染你的类空间是没有必要的。</p><p id="84b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">更容易理解的方法是将匿名函数存储在委托中，然后像这样调用它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="f0e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管如此，匿名函数应该保持简短。</p></div><div class="ab cl nn no hx np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="im in io ip iq"><h2 id="292c" class="oj lx it bd ly ok ol dn mc om on dp mg li oo op mi lm oq or mk lq os ot mm ou bi translated"># 5λ-表达式</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pf"><img src="../Images/a6c2294e31185ba4c34734fcd4a6811d.png" data-original-src="https://miro.medium.com/v2/resize:fit:898/0*0yeEtwF_KrFGdUd3"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由<a class="ae ky" href="http://www.darkwatersyndicate.com/archives/redefining-bronchitis-aint-nobody-got-time-for-that" rel="noopener ugc nofollow" target="_blank">dark waters syndicate</a></p></figure><p id="f478" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，匿名函数既长又过分。我掩护你。因此，对于这类问题，lambda表达式是简单而正确的。</p><p id="cc7b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看看你能多短多快得到结果。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="484e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个简单的oneliner，使用列表的<code class="fe nh ni nj nk b">Find()</code>方法。</p><p id="7c34" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关于匿名函数有效的东西在这里也是有效的，因为Lambda表达式是一个增强的匿名函数。</p></div><div class="ab cl nn no hx np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="im in io ip iq"><h1 id="9f11" class="lw lx it bd ly lz nu mb mc md nv mf mg jz nw ka mi kc nx kd mk kf ny kg mm mn bi translated">Main中的调用—避免切换案例结尾</h1><p id="c8b8" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">因为这是为了避免切换的情况，所以我将所有的选择打包到了<code class="fe nh ni nj nk b">SwitchCaseAvoider</code>类中。</p><p id="db54" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在main中，我们把它叫做，就像另一个一样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="57ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">会导致</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/679aa1d6bfe0f1f1f376119b5147945a.png" data-original-src="https://miro.medium.com/v2/resize:fit:412/format:webp/1*9OupcjJ1_shd47fDVCoUkg.png"/></div></figure></div><div class="ab cl nn no hx np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="im in io ip iq"><h1 id="fac7" class="lw lx it bd ly lz nu mb mc md nv mf mg jz nw ka mi kc nx kd mk kf ny kg mm mn bi translated">结论</h1><p id="c8b2" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">并非所有这些都是处理这种特定情况的最佳方式。</p><p id="b83f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您试图在大型数据集中使用它们来获得一个匹配，其中一些(如for循环或forEach循环)会变得计算密集型。此外，还有内置功能(例如，用于集合)。</p><p id="86cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">他们的共同点是:</p><p id="5b87" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">它们可以通过重新定义环境来扩展，而不是功能本身。</strong></p><p id="f7ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，有一个比处理特定问题的最佳方法更重要的原则要实现。</p><p id="d9ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你的程序不能解决特定的问题；他们总能解决一个或多个复杂的问题。履行总体原则，比如在Unity中用我的SOLID系列创作游戏更为重要。</p></div><div class="ab cl nn no hx np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="im in io ip iq"><p id="5e7d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="lv">感谢您的阅读，如果您想要更多优秀的经过处理的编程内容，</em> </strong> <a class="ae ky" href="https://www.udemy.com/user/arnold-abraham-3/" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu"> <em class="lv">请访问我在Udemy上的奇遇</em> </strong> </a> <strong class="lb iu"> <em class="lv">关于C#和SQL。</em> </strong></p><h1 id="1f46" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">预选套装物品</h1><div class="pg ph gp gr pi pj"><a href="https://medium.com/geekculture/how-net-5-breaks-your-c-coding-project-with-the-data-type-string-be41ea48f0a2" rel="noopener follow" target="_blank"><div class="pk ab fo"><div class="pl ab pm cl cj pn"><h2 class="bd iu gy z fp po fr fs pp fu fw is bi translated">之后如何修复C#中的字符串操作？NET 5更新</h2><div class="pq l"><h3 class="bd b gy z fp po fr fs pp fu fw dk translated">中修复此问题的步骤。NET框架和。网络核心</h3></div><div class="pr l"><p class="bd b dl z fp po fr fs pp fu fw dk translated">medium.com</p></div></div><div class="ps l"><div class="pt l pu pv pw ps px ks pj"/></div></div></a></div><div class="pg ph gp gr pi pj"><a href="https://medium.com/nerd-for-tech/the-reasons-not-to-migrate-from-javascript-to-typescript-89b587ed9ac9" rel="noopener follow" target="_blank"><div class="pk ab fo"><div class="pl ab pm cl cj pn"><h2 class="bd iu gy z fp po fr fs pp fu fw is bi translated">不从JavaScript迁移到TypeScript的原因！</h2><div class="pq l"><h3 class="bd b gy z fp po fr fs pp fu fw dk translated">如何为媒体找到我的声音</h3></div><div class="pr l"><p class="bd b dl z fp po fr fs pp fu fw dk translated">medium.com</p></div></div><div class="ps l"><div class="py l pu pv pw ps px ks pj"/></div></div></a></div><div class="pg ph gp gr pi pj"><a href="https://medium.com/front-end-weekly/how-naming-ruins-your-code-6f3a53a380b9" rel="noopener follow" target="_blank"><div class="pk ab fo"><div class="pl ab pm cl cj pn"><h2 class="bd iu gy z fp po fr fs pp fu fw is bi translated">命名是如何毁掉你的代码的！</h2><div class="pq l"><h3 class="bd b gy z fp po fr fs pp fu fw dk translated">伟大的代码始于你，终于有更多的时间为你的爱人编码！</h3></div><div class="pr l"><p class="bd b dl z fp po fr fs pp fu fw dk translated">medium.com</p></div></div><div class="ps l"><div class="pz l pu pv pw ps px ks pj"/></div></div></a></div></div></div>    
</body>
</html>