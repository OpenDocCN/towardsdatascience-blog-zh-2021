<html>
<head>
<title>How to Perform Multitasking in Flask and Tornado</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Flask和Tornado中执行多任务处理</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-perform-multitasking-in-flask-and-tornado-3f00945f4510?source=collection_archive---------2-----------------------#2021-08-09">https://towardsdatascience.com/how-to-perform-multitasking-in-flask-and-tornado-3f00945f4510?source=collection_archive---------2-----------------------#2021-08-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f10a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">提高阻塞和非阻塞web服务器的性能</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e1a120f9b8de37f2ec3b7efe36e95c59.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*pmxn8T5Wc8OkQLQU"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">马文·迈耶在<a class="ae ky" href="https://unsplash.com/" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="7553" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi lv translated"><span class="l lw lx ly bm lz ma mb mc md di"> M </span>多任务处理是指(几乎)同时执行多个任务或流程的能力。像Flask、Django和Tornado这样的现代web服务器都能够同时处理多个请求。由于多种解释，多任务的概念实际上非常模糊。您可以使用多重处理、多线程或异步来执行多任务处理。在本文中，我将解释这些概念之间的区别，以及如何在Flask和Tornado中执行多任务处理。如果你有使用这两个框架的经验，请告诉我们你什么时候更愿意使用其中一个。我挺好奇的:)</p><h2 id="e3b4" class="me mf it bd mg mh mi dn mj mk ml dp mm li mn mo mp lm mq mr ms lq mt mu mv mw bi translated"><strong class="ak">抢占式多任务vs .协作式多任务</strong></h2><p id="dbde" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">一个操作系统有两种多任务选择:抢占式和协作式。在抢占式多任务处理中，应用程序可以共享操作系统(OS)及其底层资源。换句话说，允许操作系统停止当前正在运行的进程，并切换到不受应用程序控制的另一个进程。这意味着操作系统必须优雅地切换上下文。进程的隔离确保了一个进程的无限循环不会阻塞其他进程，但是，当涉及到与其他进程交换数据时，它会带来更多的复杂性。</p><p id="352f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一方面，在协同多任务中，一个应用只使用一个主机进程，应用中的任务共享这个单个主机进程的资源。当每个任务不再需要资源时，它必须将控制权让给宿主进程。因此，操作系统对应用程序的控制较少，因为它不允许执行上下文切换。这种方法在某种程度上获得了大部分CPU，易于扩展，并且易于与其他任务交换数据。但是如果任何一个任务停滞不前(不放弃控制权)，整个应用程序也会停滞不前。这就是asyncio的基本工作原理，我们将在后面详细讨论。</p><p id="bebf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这张图表直观地显示了这两种类型之间的区别。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nc"><img src="../Images/c07e433f5c51161fc2d3d03584e2f034.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BZ4x8NufsqJy0xBEd6dbCQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">合作多任务vs .抢先多任务，由<a class="nd ne ep" href="https://medium.com/u/2adc5a07e772?source=post_page-----3f00945f4510--------------------------------" rel="noopener" target="_blank">高</a>创造</p></figure><h2 id="cada" class="me mf it bd mg mh mi dn mj mk ml dp mm li mn mo mp lm mq mr ms lq mt mu mv mw bi translated"><strong class="ak">并行性与</strong>并发性</h2><p id="f0d7" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">多任务处理是在同一时间内运行几项任务的能力。这并不一定意味着这些任务必须在完全相同的时刻开始。这两种场景有不同的名称:并行和并发。</p><p id="e833" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">并行是指任务实际上同时开始。这可能发生在多核处理器或多线程处理器上，其中每个核/线程可以独立地启动一个任务。并发是指任务在重叠的时间段内开始、运行和完成，这可能发生在单核服务器上。如果你熟悉Python中的全局解释器锁(GIL)，你一定知道Python在一个进程中只允许一个线程控制解释器，也就是说<a class="ae ky" href="https://leimao.github.io/blog/Python-Concurrency-High-Level/" rel="noopener ugc nofollow" target="_blank">一个单进程多线程程序最多可以达到100%的CPU利用率</a>。真正的Python已经给出了关于GIL的很好的教程。</p><div class="nf ng gp gr nh ni"><a href="https://realpython.com/python-gil/" rel="noopener  ugc nofollow" target="_blank"><div class="nj ab fo"><div class="nk ab nl cl cj nm"><h2 class="bd iu gy z fp nn fr fs no fu fw is bi translated">什么是Python全局解释器锁(GIL)？-真正的蟒蛇</h2><div class="np l"><h3 class="bd b gy z fp nn fr fs no fu fw dk translated">Python的全局解释器锁或GIL，简单来说就是一个互斥体(或锁)，只允许一个线程持有…</h3></div><div class="nq l"><p class="bd b dl z fp nn fr fs no fu fw dk translated">realpython.com</p></div></div><div class="nr l"><div class="ns l nt nu nv nr nw ks ni"/></div></div></a></div><p id="a679" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我看来，并行性相当于抢先式多任务处理，并发性相当于协作式多任务处理。</p><h2 id="1dec" class="me mf it bd mg mh mi dn mj mk ml dp mm li mn mo mp lm mq mr ms lq mt mu mv mw bi translated">多重处理vs .多线程vs .异步</h2><p id="a323" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">Python中的多任务问题一般可以使用这些库之一来解决:<code class="fe nx ny nz oa b">multiprocessing</code>、<code class="fe nx ny nz oa b">threading</code>和<code class="fe nx ny nz oa b">asyncio</code>。就使用哪个库而言，取决于用例，用例可以分为CPU受限或I/O受限。</p><p id="6eca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">CPU绑定问题是指性能由CPU的能力决定的情况。CPU越快或者CPU的内核越多，程序的性能就越高。例如处理图像、进行计算等。</p><p id="8eea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">I/O受限问题是指性能由输入/输出操作完成的等待时间决定的情况。I/O越快，我们获得的性能就越高。例如发出HTTP请求、读取文件等。</p><p id="ce2a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个简单的规则是，<code class="fe nx ny nz oa b">multiprocessing</code>适合CPU受限的问题，<code class="fe nx ny nz oa b">threading</code>和<code class="fe nx ny nz oa b">asyncio</code>适合I/O受限的问题。但是<code class="fe nx ny nz oa b">threading</code>和<code class="fe nx ny nz oa b">asyncio</code>有什么不同呢？如果用我们目前掌握的知识，<code class="fe nx ny nz oa b">threading</code>解决抢占式多任务，<code class="fe nx ny nz oa b">asyncio</code>解决协作式多任务。Python维护一个线程池，当需要时，可以从池中检索新的线程。应该注意的是，所有线程共享相同的内存，因此需要锁定来确保一次只有一个线程可以写入内存中的相同对象。</p><p id="6cce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe nx ny nz oa b">asyncio</code>中你不用担心这个，因为它在单个进程中使用单线程。但是，<code class="fe nx ny nz oa b">asyncio</code>的缺点是你应该记得把控制权还给事件循环(通过<code class="fe nx ny nz oa b">yield</code>)，否则程序会被阻塞。此外，一旦你使用了<code class="fe nx ny nz oa b">asyncio</code>，所有的内部函数/库也应该支持异步。这需要在编码方面付出更多的努力。</p><p id="8953" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想深入研究<code class="fe nx ny nz oa b">threading</code>和<code class="fe nx ny nz oa b">asyncio</code>，我也推荐以下来自《真实的Python》的优秀文章。</p><div class="nf ng gp gr nh ni"><a href="https://realpython.com/intro-to-python-threading/" rel="noopener  ugc nofollow" target="_blank"><div class="nj ab fo"><div class="nk ab nl cl cj nm"><h2 class="bd iu gy z fp nn fr fs no fu fw is bi translated">Python线程介绍——真正的Python</h2><div class="np l"><h3 class="bd b gy z fp nn fr fs no fu fw dk translated">立即观看本教程有一个由真正的Python团队创建的相关视频课程。和书面的一起看…</h3></div><div class="nq l"><p class="bd b dl z fp nn fr fs no fu fw dk translated">realpython.com</p></div></div><div class="nr l"><div class="ob l nt nu nv nr nw ks ni"/></div></div></a></div><div class="nf ng gp gr nh ni"><a href="https://realpython.com/async-io-python/" rel="noopener  ugc nofollow" target="_blank"><div class="nj ab fo"><div class="nk ab nl cl cj nm"><h2 class="bd iu gy z fp nn fr fs no fu fw is bi translated">Python中的异步IO:完整的演练-真实的Python</h2><div class="np l"><h3 class="bd b gy z fp nn fr fs no fu fw dk translated">以下是您将涉及的内容:您需要Python 3.7或更高版本来完整地阅读本文，以及…</h3></div><div class="nq l"><p class="bd b dl z fp nn fr fs no fu fw dk translated">realpython.com</p></div></div><div class="nr l"><div class="oc l nt nu nv nr nw ks ni"/></div></div></a></div><p id="3260" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我花了相当多的时间介绍多任务处理的问题和理论，我认为在进入代码之前了解这些是非常重要的。我希望你现在已经打好了基础。让我们进入有趣的部分吧！</p><h2 id="ab05" class="me mf it bd mg mh mi dn mj mk ml dp mm li mn mo mp lm mq mr ms lq mt mu mv mw bi translated">烧瓶vs .龙卷风</h2><p id="9941" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">Flask和Tornado都是Python世界中流行的web框架，目的不同。Flask是一个基于WSGI的轻量级web框架，Tornado是一个web框架，也是一个异步网络库。</p><p id="9020" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="od">如何处理并发请求？</em>T11】</strong></p><p id="49b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种不同的设置也意味着它们将以不同的方式处理并发请求。从Flask 1.0开始，默认情况下flask server是多线程的。每个新请求都在一个新线程中处理。</p><p id="c568" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个使用默认设置的简单烧瓶应用程序。出于演示目的，我在返回响应之前放置了<code class="fe nx ny nz oa b">sleep(1)</code>。它能够在大约2秒钟内处理10个并发请求。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">带螺纹的烧瓶应用程序=True</p></figure><p id="1029" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我禁用线程模式，您可以看到性能的巨大差异。是因为这个同步服务器现在只有一个线程，所以每个请求都是在前一个完成之后开始的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">带螺纹的烧瓶应用程序=假</p></figure><p id="14c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们来看看龙卷风。这也是一个响应中带有<code class="fe nx ny nz oa b">sleep(1)</code>的简单例子。然而，处理10个并发请求需要10秒钟。嗯，这里出了什么问题？</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">带同步代码的Tornado应用</p></figure><p id="a497" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">原因是Tornado是一个只有一个线程的异步服务器。这个例子实际上与第二个烧瓶例子的情况相同。为了使用异步服务器，阻塞代码<code class="fe nx ny nz oa b">time.sleep(1)</code>(实际上是您可能有的所有阻塞代码)必须被非阻塞代码替换。这就是为什么我之前说过，我们需要更多地了解异步中的编码部分，因为任何隐藏的阻塞代码都可能阻塞整个应用程序，而且我们大多数人更习惯于编写同步代码而不是异步代码。</p><p id="f240" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">解决方案之一是使用异步版本的<code class="fe nx ny nz oa b">sleep</code>，即<code class="fe nx ny nz oa b">tornado.gen.sleep</code>。结果与第一个烧瓶示例相同。此外，完整功能与<code class="fe nx ny nz oa b">async/await</code>关键字异步。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">带有异步代码的Tornado应用程序</p></figure><p id="59c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="od">如何在请求过程中进行多任务处理？</em>T13】</strong></p><p id="a829" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们讨论了如何在Flask和Tornado中处理并发任务，这是多任务处理的一种。另一种类型的多任务发生在请求的处理过程中。例如，在返回响应之前，服务器需要从5个不同的端点收集数据。如果服务器逐个执行请求，将会对性能产生巨大影响。</p><p id="4fb9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种背景下，我们不需要太依赖框架本身。这是如何在同步和异步应用程序中处理并发web请求的问题。由于是I/O操作，<code class="fe nx ny nz oa b">threading</code>和<code class="fe nx ny nz oa b">asyncio</code>比<code class="fe nx ny nz oa b">multiprocessing</code>要好。</p><p id="9b87" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是<code class="fe nx ny nz oa b">ThreadPoolExecutor</code>在Flask中的实现。性能和前面的例子一样高。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Flask中的并发请求</p></figure><p id="b879" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是你在龙卷风中可以做到的。请记住，在异步应用程序中，一切都应该是异步的。出于演示的目的，我使用了一个模拟函数，但是实际上，您应该使用一个类似于<code class="fe nx ny nz oa b">aiohttp</code>的异步HTTP库。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Tornado中的并发请求</p></figure><p id="bacd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="od">如何运行后台任务？</em> </strong></p><p id="ee96" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后但同样重要的是，我想向您展示如何在Flask和Tornado应用程序中运行后台任务。如果您想要调度作业或让某些东西连续运行而不干扰主进程，后台任务会非常有用。</p><p id="c1ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一般来说，Tornado更支持后台任务，但您也可以在Flask中实现这一点。</p><p id="3c33" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就像前两个场景一样，我们可以再次使用<code class="fe nx ny nz oa b">threading</code>在Flask中实现这一点。需要注意的是，后台作业的启动要在Flask app启动之前完成。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">烧瓶中的后台任务</p></figure><p id="b7a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">查看<a class="ae ky" href="https://smirnov-am.github.io/background-jobs-with-flask/" rel="noopener ugc nofollow" target="_blank">这个博客</a>，看看如何使用uWSGI在Flask中进行后台作业。</p><p id="2235" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，Tornado有两种不同的方式使用其本机功能来实现这一点:<code class="fe nx ny nz oa b"><a class="ae ky" href="https://www.tornadoweb.org/en/stable/ioloop.html#tornado.ioloop.IOLoop.spawn_callback" rel="noopener ugc nofollow" target="_blank">spawn_callback</a></code>和<code class="fe nx ny nz oa b"><a class="ae ky" href="https://www.tornadoweb.org/en/stable/ioloop.html#tornado.ioloop.PeriodicCallback" rel="noopener ugc nofollow" target="_blank">PeriodicCallback</a></code>。它们的主要区别在于，<code class="fe nx ny nz oa b">spawn_callback</code>是一个“一劳永逸”的功能，在启动作业后你没有任何控制权，而<code class="fe nx ny nz oa b">PeriodicCallback</code>返回给你一个任务实例，你可以在以后启动和停止。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在龙卷风中使用spawn_callback</p></figure><p id="bf29" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个周而复始的例子。在启动web服务器之前，不要忘记启动该任务。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在Tornado中使用PeriodicCallback</p></figure><h2 id="764d" class="me mf it bd mg mh mi dn mj mk ml dp mm li mn mo mp lm mq mr ms lq mt mu mv mw bi translated">结论</h2><p id="478c" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">在本文中，我们从3个不同的角度讨论了如何在Flask和Tornado中执行多任务。在此之前，我们详细介绍了两种多任务模式以及多处理、多线程和异步之间的区别。</p><p id="90fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">希望这篇文章对你有帮助！如果你有任何想法，请在下面留下你的评论。</p><h2 id="ebe5" class="me mf it bd mg mh mi dn mj mk ml dp mm li mn mo mp lm mq mr ms lq mt mu mv mw bi translated">参考</h2><div class="nf ng gp gr nh ni"><a href="https://leimao.github.io/blog/Python-Concurrency-High-Level/" rel="noopener  ugc nofollow" target="_blank"><div class="nj ab fo"><div class="nk ab nl cl cj nm"><h2 class="bd iu gy z fp nn fr fs no fu fw is bi translated">Python中的多处理VS线程VS异步</h2><div class="np l"><h3 class="bd b gy z fp nn fr fs no fu fw dk translated">在现代计算机编程中，经常需要并发来加速解决问题。在Python编程中…</h3></div><div class="nq l"><p class="bd b dl z fp nn fr fs no fu fw dk translated">雷猫. github.i</p></div></div><div class="nr l"><div class="og l nt nu nv nr nw ks ni"/></div></div></a></div></div></div>    
</body>
</html>