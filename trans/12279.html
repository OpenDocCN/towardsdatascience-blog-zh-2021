<html>
<head>
<title>Hyperparameter Tuning of Neural Networks with Optuna and PyTorch</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于Optuna和PyTorch的神经网络超参数调整</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/hyperparameter-tuning-of-neural-networks-with-optuna-and-pytorch-22e179efc837?source=collection_archive---------2-----------------------#2021-12-14">https://towardsdatascience.com/hyperparameter-tuning-of-neural-networks-with-optuna-and-pytorch-22e179efc837?source=collection_archive---------2-----------------------#2021-12-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8116" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何在Optuna帮助下为我们的用例找到完美的神经网络模型</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d351336d439457398df34047a8158170.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UlRC7tEvxiPU2CNW6E5Kig.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/s/photos/knob?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae ky" href="https://unsplash.com/@feelfarbig?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Feelfarbig杂志</a>拍摄的照片</p></figure><p id="1685" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">开发正确的神经网络模型可能非常耗时。</p><p id="2e80" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可能知道，神经网络模型中有许多超参数，我们需要调整它们来获得完美的拟合模型，例如学习率、优化器、批量大小、层中的单元数量、激活函数、辍学率，等等。</p><p id="a7f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">问题是，我们事先不知道最适合我们模型的超参数值的组合。</p><p id="cbf7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，我们可以使用任何超参数的默认值，然后查看模型的性能有多好，然后逐一迭代调整每个超参数的值，以找到最佳组合。</p><p id="8410" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，由于以下原因，这显然非常耗时，并且不是非常有效的方法:</p><ul class=""><li id="fbd8" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">您需要监控并记录您已经手动尝试过的超参数组合。</li><li id="14ae" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">随着搜索空间的扩大，你很有可能需要进行数百甚至数千次试验，才能得出最佳模型。</li></ul><p id="e618" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了解决这些问题，我们可以用Optuna调整神经网络模型的超参数。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="5ae7" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">什么是Optuna？</h1><p id="aab5" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">Optuna是一个python库，它使我们能够自动调整我们的机器学习模型。</p><p id="0334" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你基本上可以将Optuna与几乎所有可用的机器学习框架一起使用:TensorFlow、PyTorch、LightGBM、XGBoost、CatBoost、sklearn、FastAI等。</p><p id="21e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，有很多Python库可以帮助我们自动调整机器学习模型的超参数。然而，有几个特性使Optuna从其他超参数调优库中脱颖而出，我们将在后面讨论。</p><p id="790d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将使用Optuna来调整PyTorch中神经网络模型的超参数。因此，让我们先简单介绍一下我们将在本文中使用的数据集以及获取该数据集的代码。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="23f6" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">关于数据集</h1><p id="990a" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">如果你想跟进，你可以下载我们将在这篇关于Kaggle的文章中使用的数据集。这个数据集是根据开放数据库许可证(ODbL)许可的，这意味着只要我们引用官方数据源，我们就可以将数据用于我们的目的。</p><div class="nn no gp gr np nq"><a href="https://www.kaggle.com/fedesoriano/heart-failure-prediction" rel="noopener  ugc nofollow" target="_blank"><div class="nr ab fo"><div class="ns ab nt cl cj nu"><h2 class="bd iu gy z fp nv fr fs nw fu fw is bi translated">心力衰竭预测数据集</h2><div class="nx l"><h3 class="bd b gy z fp nv fr fs nw fu fw dk translated">预测心脏病事件的11个临床特征。</h3></div><div class="ny l"><p class="bd b dl z fp nv fr fs nw fu fw dk translated">www.kaggle.com</p></div></div><div class="nz l"><div class="oa l ob oc od nz oe ks nq"/></div></div></a></div><p id="34b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的机器学习模型的目标是在考虑每个患者的年龄、性别、胆固醇水平等的情况下，预测患者是否患有心脏病。</p><p id="13ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">数据集本身结合了连续特征和分类特征。我们需要将所有分类特征转换成它们的独热编码表示。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="0ea3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，让我们用PyTorch创建一个简单的数据生成器类，在模型训练期间批量获取这个数据集作为神经网络模型的输入。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="34c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">既然我们已经定义了生成数据的代码，我们就可以用Optuna来调优神经网络模型了！作为第一步，让我们了解一下如何使用Optuna。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="6853" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">Optuna入门</h1><p id="8ccb" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">要使用Optuna，请确保首先通过pip安装它:</p><pre class="kj kk kl km gt oh oi oj ok aw ol bi"><span id="c5ce" class="om mr it oi b gy on oo l op oq">pip install optuna</span></pre><p id="629e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每个Optuna超参数调整会话称为研究。我们通过调用<code class="fe or os ot oi b">create_study</code>方法来实例化一个学习会话。我们可以将几个重要的参数传递给这个方法，如下所示。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="d347" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如你所见，我们将变量<code class="fe or os ot oi b">direction</code>和<code class="fe or os ot oi b">sampler</code>作为参数传递给<code class="fe or os ot oi b">create_study</code>方法。</p><h2 id="e68c" class="om mr it bd ms ou ov dn mw ow ox dp na li oy oz nc lm pa pb ne lq pc pd ng pe bi translated">方向</h2><p id="1cb3" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated"><code class="fe or os ot oi b">direction</code>值可以设置为<code class="fe or os ot oi b">maximize</code>或<code class="fe or os ot oi b">minimize</code>，这取决于我们超参数调整的最终目标。</p><ul class=""><li id="dad5" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">如果目标是通过准确性、F1分数、精确度或召回率等指标来提高绩效，则将其设置为<code class="fe or os ot oi b">maximize</code>。</li><li id="8512" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">如果目标是减少损失函数，如对数损失、MSE、RMSE等，则将其设置为<code class="fe or os ot oi b">minimize</code>。</li></ul><h2 id="9284" class="om mr it bd ms ou ov dn mw ow ox dp na li oy oz nc lm pa pb ne lq pc pd ng pe bi translated">取样器</h2><p id="1f7b" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated"><code class="fe or os ot oi b">sampler</code> value表示您希望Optuna实现哪个采样器方法。有几个采样器选项可供您选择，例如:</p><ul class=""><li id="c482" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><code class="fe or os ot oi b">GridSampler</code>:基于定义的搜索空间中的每个组合来选择超参数值的集合。</li><li id="8493" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe or os ot oi b">RandomSampler</code>:超参数值的集合是从定义的搜索空间中随机选择的。</li><li id="6fb4" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe or os ot oi b">TPESampler</code>:这是我们使用Optuna时的默认<code class="fe or os ot oi b">sampler</code>。它基于贝叶斯超参数优化，这是一种有效的超参数调整方法。它将像随机采样器一样开始，但该采样器记录了一组超参数值的历史和来自过去试验的相应目标值。然后，它将基于具有来自过去试验的有希望的客观值的集合，为下一次试验建议一组超参数值。</li></ul><p id="801a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们可以在学习中调用<code class="fe or os ot oi b">optimize</code>方法，并将我们的<code class="fe or os ot oi b">objective</code>函数作为参数之一传递。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="18d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的<code class="fe or os ot oi b">n_trials</code>参数表示您希望Optuna执行的研究中的试验次数。</p><p id="8abf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">到目前为止，我们还没有创建<code class="fe or os ot oi b">objective </code>函数。因此，让我们通过首先定义搜索空间来创建我们的<code class="fe or os ot oi b">objective</code>函数。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="ee5e" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">搜索空间定义</h1><p id="7c1d" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">在每个超参数调优会话中，我们需要为采样器定义一个搜索空间。搜索空间是采样器从超参数中应该考虑的值的范围。</p><p id="edd0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，假设我们想要调整三个超参数:学习率、层的单元数和神经网络模型的优化器。然后，我们可以如下定义搜索空间:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="9d38" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe or os ot oi b">objective</code>函数中，我们传递一个名为<code class="fe or os ot oi b">trial</code>的参数，它来自Optuna的<code class="fe or os ot oi b">Trial</code>类。这个类使Optuna能够记录一组选定的超参数值，并记录我们的<code class="fe or os ot oi b">objective</code>函数在每次试验中的值(在我们的例子中是精度)。</p><p id="54e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从上面可以看到，我们将每个超参数的搜索空间定义为一个名为<code class="fe or os ot oi b">params</code>的字典。对于每个超参数，我们用<code class="fe or os ot oi b">suggest_*</code>方法定义搜索空间的范围(最小值和最大值)。</p><p id="6ec6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据超参数的数据类型，<code class="fe or os ot oi b">suggest_*</code>方法有几个扩展:</p><ul class=""><li id="99cd" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><code class="fe or os ot oi b">suggest_int</code>:如果您的超参数接受整数类型的数值范围。</li><li id="a6c0" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe or os ot oi b">suggest_categorical</code>:如果您的超参数接受分类值的选择。</li><li id="4ec9" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe or os ot oi b">suggest_uniform</code>:如果您的超参数接受一个数值范围，并且您希望对每个值进行均等采样。</li><li id="15b1" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe or os ot oi b">suggest_loguniform</code>:如果您的超参数接受一个数值范围，并且您希望在对数域中对每个值进行均等采样。</li><li id="37bd" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe or os ot oi b">suggest_discrete_uniform</code>:如果您的超参数接受特定区间内的数值范围，并且您希望对每个数值进行均等采样。</li><li id="ee3b" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe or os ot oi b">suggest_float</code>:如果您的超参数接受float类型的数值范围。这是<code class="fe or os ot oi b">suggest_uniform</code>、<code class="fe or os ot oi b">suggest_loguniform</code>和<code class="fe or os ot oi b">suggest_discrete_uniform</code>的包装方法</li></ul></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="41c4" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">建立PyTorch模型，训练循环，评估目标函数</h1><p id="95eb" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">现在我们可以使用保存在<code class="fe or os ot oi b">params</code>字典中的所选超参数值来构建PyTorch模型。接下来，我们将训练模型并评估我们的目标函数，在我们的情况下是准确性。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="09eb" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">运行超参数调整</h1><p id="2358" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">我们已经创建了我们的目标函数，我们已经定义了搜索空间，我们已经建立了模型和训练循环，现在我们准备使用Optuna运行超参数调优。</p><p id="8169" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要运行超参数调优，我们需要实例化一个<code class="fe or os ot oi b">study</code>会话，调用<code class="fe or os ot oi b">optimize</code>方法，并将我们的<code class="fe or os ot oi b">objective</code>函数作为参数传递。我们已经在上面的“<em class="pf">Optuna</em>入门”一节中看到了这段代码。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="b542" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">随着超参数优化过程的运行，您将获得以下输出:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pg"><img src="../Images/8d384954dc858f4d9693db54424731e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n3bYRIzQpFxcCraJMZG2Hw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="ca59" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">超参数调整过程完成后，我们可以通过访问<code class="fe or os ot oi b">best_trial</code>方法获取超参数的最佳组合，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="7f00" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是你开始用Optuna调优你的神经网络超参数所需要做的一切！</p><p id="5185" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，Optuna提供了更多的功能，使我们的超参数调整管道更加有效。让我们来看看其中的一些特性。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="180c" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">运行定义设计</h1><p id="12f7" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">大多数时候，每当我们构建一个神经网络时，我们不希望仅仅调整一层中的单元数量，还希望调整层本身的数量。为了达到最佳性能，我们应该在神经网络模型中构建多少层？一层够吗？两个？三个？我们永远不会提前知道。</p><p id="6a63" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于其模块化设计，Optuna允许我们调整层数。这意味着允许用户动态构建搜索空间。</p><p id="76be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，假设我们想要调整神经网络模型中的a)层数和b)每层的单元数。我们可以通过实现以下方法来做到这一点:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="b8bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，我们没有预先为我们的神经网络模型定义任何特定的层数，也没有定义一层中的单元数。</p><p id="b9d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">相反，算法会在每次试验中选取特定的层数，然后选取每层中的单元数，然后建立相应的神经网络。所有过程都是以动态的方式完成的。</p><p id="7c0c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以将这一概念应用于更高级的神经网络层，例如卷积层。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="a37b" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">修剪机制</h1><p id="851c" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">我们知道超参数调整是一个耗时的过程，尤其是当我们有大量的超参数选择和搜索空间时。为了节省我们的时间，Optuna提供了一个修剪机制特性。</p><p id="194b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种修剪所做的是，它将在训练过程的早期阶段终止没有希望的试验，这样我们就不需要浪费时间和资源。</p><p id="f98d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有几种修剪方法可用于Optuna，它们是:</p><ul class=""><li id="f411" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><code class="fe or os ot oi b">MedianPruner</code>:如果当前试验的中间值(在我们的例子中是准确度)比相同训练时期的先前试验的中间值差，这将修剪试验。</li><li id="7cfc" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe or os ot oi b">PercentilePruner</code>:如果当前试验的中间值在相同训练时期的试验的最低百分位数中，这将删除试验。</li><li id="2078" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe or os ot oi b">SuccessiveHalvingPruner</code>:这是一种基于<a class="ae ky" href="https://blog.ml.cmu.edu/2018/12/12/massively-parallel-hyperparameter-optimization/" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">中实现的逐次二等分算法(SHA)的剪枝策略。原理是，该算法通过将试验的数量减少到一半(通过修剪无希望的试验)，将更多的时期分配给有希望的试验。</strong></a></li><li id="438e" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe or os ot oi b">HyperbandPruner</code>:这是一个修剪策略，将使用不同数量的超参数值集运行几次连续减半。</li></ul><p id="be98" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将特定的修剪程序集成到我们的代码中非常简单。首先，我们需要添加<code class="fe or os ot oi b">pruner</code>变量作为参数，并在使用<code class="fe or os ot oi b">create_study</code>创建学习会话时使用我们首选的修剪方法对其赋值，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="3b93" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们通过在每个训练步骤结束时调用<code class="fe or os ot oi b">report</code>和<code class="fe or os ot oi b">should_prune</code>方法来激活修剪程序。对于PyTorch中的神经网络，在训练循环的每个时期后调用这些方法，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="fffe" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">通过运行定义设计和普鲁纳实现代码</h1><p id="ffa4" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">下面是在我们集成了修剪机制和运行定义设计来调整我们的神经网络中的层数之后，整个超参数调整过程的完整代码实现。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="ead5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在你运行这项研究后，你会注意到我们的神经网络的层数和每层的单元数在不同的试验中是不同的。此外，为了加速超参数调整过程，一些不被看好的试验被删除了。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ph"><img src="../Images/a772a51e2dbe02baff98c48baa55d61d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P7ieQn-XlBCoqUsVic8VTA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="085a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">和以前一样，我们可以用<code class="fe or os ot oi b">best_trial</code>方法访问最佳试验的超参数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="eaaf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Optuna还有一个非常有用的特性我们可以使用，那就是可视化特性。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="e4e6" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">调谐过程的可视化</h1><p id="ee3a" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">Optuna提供了一个特性，使我们能够在调优过程结束后可视化该过程的历史。我们现在将介绍其中一些。</p><p id="e547" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一个可视化是每个训练步骤中每个试验的目标函数(在我们的例子中是准确性)的图。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pi"><img src="../Images/a636b78518eda4f9e74a39e09fb9d6de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hFU3De3uAHsfJszkae4abg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="04a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从上面的可视化可以看出，几个没有希望的试验在第一步就被修剪掉了，因为它们的准确性非常低。</p><p id="8710" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您还可以按如下方式可视化优化历史:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pi"><img src="../Images/7430c32cd483e803f012ddb50bf9f8df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nEp_xDLSINP2x3ouSYBZUw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="939f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种可视化有助于了解哪个试验是最佳试验，以及其他试验的客观价值与最佳试验相比如何。由于修剪机制，在特定试验中会丢失几个数据点。</p><p id="d9aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们有平行坐标图:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pi"><img src="../Images/53c9315ce82511d951e5c4b58dfbe54b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vL1KXNwoxhfVojp-0bMQSg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="4b06" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您有大量的超参数和搜索空间，平行图可能很难看到和解释。然而，如果我们有合理数量的超参数和搜索空间，这个图将是有用的。我们可以在每一行中看到超参数的值组合以及它们在我们的目标函数上的表现。</p><p id="9a7f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Optuna还使我们能够绘制超参数重要性，如下图所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pi"><img src="../Images/2920f079c623b2dfae09a521a3372fb9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WLs9_cN_jD-G59deuGoY7w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="ac67" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该图向我们展示了每个超参数对提高目标函数得分的重要性。以上面的可视化为例，结果表明第一层中的单元数量是最重要的超参数，而层数是不太重要的超参数。</p><p id="83a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该图对于提高调优过程的效率非常有用，尤其是在有大量超参数可供选择的情况下。</p><p id="e8f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为第一项研究，您可以运行大约50次超参数调整，然后检查哪些超参数是最重要的。接下来，您可以在第二次研究中省略不太重要的超参数，这可以节省您的时间和资源。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="21d3" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">结论</h1><p id="8a3e" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">在这篇文章中，我们逐步讲解了如何使用Optuna和PyTorch来调整神经网络模型的超参数。</p><p id="b1d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们已经看到，运行定义设计、修剪机制和一些可视化选项是使用Optuna进行超参数调优的主要好处。</p><p id="fe87" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望这篇文章能帮助你开始使用Optuna，如果你想看这篇文章中的完整代码实现，你可以随时参考<a class="ae ky" href="https://github.com/marcellusruben/medium-resources/blob/main/Optuna/Optuna.ipynb" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">这本笔记本</strong> </a>。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="3559" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">数据集引用</h1><p id="779c" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">[1]费德索里亚诺。(2021年9月)。心力衰竭预测数据集。于2021年12月14日从https://www.kaggle.com/fedesoriano/heart-failure-prediction<a class="ae ky" href="https://www.kaggle.com/fedesoriano/heart-failure-prediction" rel="noopener ugc nofollow" target="_blank">取回。</a></p></div></div>    
</body>
</html>