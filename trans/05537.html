<html>
<head>
<title>The Easiest Way to Debug Kubernetes Workloads</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">调试Kubernetes工作负载的最简单方法</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/the-easiest-way-to-debug-kubernetes-workloads-ff2ff5e3cc75?source=collection_archive---------6-----------------------#2021-05-17">https://towardsdatascience.com/the-easiest-way-to-debug-kubernetes-workloads-ff2ff5e3cc75?source=collection_archive---------6-----------------------#2021-05-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="951e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">对Kubernetes上运行的任何应用程序进行调试和故障排除的最快最简单的方法</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/445b70fd9a4ea9a3861bb66efebe80e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9Tt9AwcQSqCmptr-q0LLRQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@jamie452?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">杰米街</a>在<a class="ae ky" href="/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="e290" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">调试容器化的工作负载和<em class="lv"> Pods </em>是每个使用Kubernetes的开发人员和DevOps工程师的日常任务。通常简单的<code class="fe lw lx ly lz b">kubectl logs</code>或<code class="fe lw lx ly lz b">kubectl describe pod</code>就足以找到某个问题的罪魁祸首，但是有些问题更难找到。在这种情况下，你可能会尝试使用<code class="fe lw lx ly lz b">kubectl exec</code>,但即使这样也可能不够，因为有些容器如<em class="lv">发行版</em>甚至不包含你可以SSH的shell。那么，如果以上所有方法都失败了，我们还剩下什么？...</p><h1 id="0553" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">可能会有更好的方法…</h1><p id="b769" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated">有时候，你需要拿一把更大的锤子或者使用更合适的工具来完成手头的任务。在Kubernetes上调试工作负载的情况下，合适的工具是<code class="fe lw lx ly lz b">kubectl debug</code>，这是不久前(1.18版)添加的一个新命令，允许您调试正在运行的pods。它将一种叫做<em class="lv">蜉蝣容器</em>的特殊类型的容器注入到有问题的容器中，允许你四处查看并排除故障。这对于简介中描述的情况或任何其他交互式调试更可取或更有效的情况非常有用。所以，<code class="fe lw lx ly lz b">kubectl debug</code>看起来是个不错的选择，但是要使用它，我们需要<em class="lv">短暂的容器</em>，那么这些容器到底是什么呢？</p><p id="7edf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">短暂容器是Pod中的一个子资源，类似于普通<code class="fe lw lx ly lz b">containers</code>。然而，与常规容器不同，临时容器不是用来构建应用程序的，而是用来检查应用程序的。我们不在创建Pod时定义它们，而是使用特殊的API将它们注入到正在运行的Pod中，以运行故障排除命令并检查Pod的环境。除了这些差异，临时容器还缺少一些基本容器的字段，比如<code class="fe lw lx ly lz b">ports</code>或<code class="fe lw lx ly lz b">resources</code>。</p><p id="1e22" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，我们为什么需要它们呢？我们不能只用基本的容器吗？嗯，您不能将容器添加到Pod，因为它们应该是一次性的(或者换句话说，可以随时删除和重新创建)，这使得很难排除需要检查Pod的重现错误。这就是为什么API中添加了临时容器——它们允许您将容器添加到现有的pod中，从而更容易检查正在运行的pod。</p><p id="a1e3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">考虑到短暂容器是Pod规范的一部分，而Pod规范是Kubernetes的核心，你(可能)还没有听说过它吗？这些大多是未知特性的原因是因为临时容器处于早期阶段，这意味着它们在默认情况下是不可用的。这个阶段的资源和特性可能会发生很大的变化，或者在Kubernetes的未来版本中被完全删除。因此，要使用它们，您必须使用<code class="fe lw lx ly lz b">kubelet</code>中的<em class="lv">特性门</em>明确启用它们。</p><h1 id="ad79" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">配置特征门</h1><p id="0bbe" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated">我们已经确定我们想要尝试一下<code class="fe lw lx ly lz b">kubectl debug</code>,那么我们如何启用短暂容器特性gate呢？这取决于您的集群设置。例如，如果您正在使用<code class="fe lw lx ly lz b">kubeadm</code>加速创建集群，那么您可以使用下面的<em class="lv">集群配置</em>来启用临时容器:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="dab0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是在下面的例子中，为了简单和测试的目的，我们将使用<em class="lv">KinD(Docker中的Kubernetes)</em>cluster，它也允许我们指定我们想要启用的特性门。因此，要创建我们的操场集群:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="16f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">随着集群的运行，我们应该验证它确实在工作。查看这种配置是否得到应用的最简单的方法是检查Pod API，它现在应该在通常的容器旁边包括ephemeralContainers部分:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="dfb2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这确认了我们拥有它，因此我们可以开始使用<code class="fe lw lx ly lz b">kubectl debug</code>。所以，让我们从一个简单的例子开始:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="ef76" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们首先启动一个名为<code class="fe lw lx ly lz b">some-app</code>的Pod，这样我们就有东西要<em class="lv">“调试”</em>。然后，我们对这个Pod运行<code class="fe lw lx ly lz b">kubectl debug</code>，将<code class="fe lw lx ly lz b">busybox</code>指定为临时容器的图像，以及原始容器的目标。此外，我们还包含了<code class="fe lw lx ly lz b">-it</code>参数，这样我们可以立即连接到容器并获得一个shell会话。</p><p id="f160" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码片段中，您还可以看到，如果我们在Pod上运行<code class="fe lw lx ly lz b">kubectl debug</code>后对其进行描述，那么它的描述将包括<em class="lv">临时容器</em>部分，其值是我们之前指定的命令选项。</p><h1 id="5ab9" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">进程命名空间共享</h1><p id="ef51" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated"><code class="fe lw lx ly lz b">kubectl debug</code>是一个非常强大的工具，但是有时向Pod添加另一个容器可能不足以获得关于在Pod的另一个容器中运行的应用程序的相关信息。当被诊断的容器不包括必要的调试工具甚至shell时，可能会出现这种情况。在这种情况下，我们可以使用<em class="lv">进程共享</em>来允许我们使用注入的临时容器检查Pod的原始容器。</p><p id="2f6e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是进程共享的一个问题是它不能应用于现有的pod，因此我们必须创建一个新的pod，将<code class="fe lw lx ly lz b">spec.shareProcessNamespace</code>设置为<code class="fe lw lx ly lz b">true</code>，并在其中注入一个临时容器。这样做会很麻烦，尤其是如果我们必须调试多个pod/container或者只是重复执行这个任务。幸运的是，<code class="fe lw lx ly lz b">kubectl debug</code>可以使用<code class="fe lw lx ly lz b">--share-processes</code>选项为我们做到这一点:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="c210" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的代码片段显示，通过进程共享，我们可以在一个Pod中看到另一个容器中的所有内容，包括它的进程和文件，这对于调试来说肯定非常方便。</p><p id="1432" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可能已经注意到，除了<code class="fe lw lx ly lz b">--share-processes</code>之外，我们还包含了<code class="fe lw lx ly lz b">--copy-to=new-pod-name</code>，因为——正如前面提到的——我们需要创建一个新的pod，其名称由这个标志指定。如果我们随后从另一个终端列出正在运行的pod，我们将看到以下内容:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="8db2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是我们在原有应用程序窗格中新增的调试窗格。与原始容器相比，它有两个容器，因为它还包括临时容器。</p><p id="5a48" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另外，如果您想在任何时候验证某个Pod中是否允许进程共享，那么您可以运行:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><h1 id="bd89" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">好好利用它</h1><p id="2cc4" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated">现在我们已经启用了特性门，并且知道了命令是如何工作的，让我们试着好好利用它并调试一些应用程序。让我们想象一下下面的场景——我们有一个行为不当的应用程序，我们需要对其容器中的网络相关问题进行故障诊断。该应用程序没有我们可以使用的必要的网络CLI工具。为了解决这个问题，我们可以以如下方式使用<code class="fe lw lx ly lz b">kubectl debug</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="de86" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">启动pod后，我们首先尝试将shell会话放入它的容器中，这看起来似乎可行，但是当我们尝试运行一些基本命令时，我们可以看到实际上什么也没有。因此，相反，我们使用包含类似<code class="fe lw lx ly lz b">curl</code>、<code class="fe lw lx ly lz b">ping</code>、<code class="fe lw lx ly lz b">telnet</code>等工具的<code class="fe lw lx ly lz b">praqma/network-multitool</code>映像将临时容器注入到pod中。现在，我们可以执行所有必要的故障排除。</p><p id="83ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的例子中，对于我们来说，Pod中有另一个容器就足够了。但是有时，您可能需要直接查看这个令人困扰的容器，却没有办法进入它的外壳。在这种情况下，我们可以像这样利用进程共享:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="d2de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我们再次运行了使用Distroless映像的容器。知道我们不能在它的外壳中做任何事情，我们用<code class="fe lw lx ly lz b">--share-processes --copy-to=...</code>运行<code class="fe lw lx ly lz b">kubectl debug</code>，这创建了一个新的Pod，它有一个额外的临时容器，可以访问所有的进程。当我们列出正在运行的进程时，我们可以看到我们的应用程序容器的进程具有PID 8，我们可以用它来探索它的文件和环境。为此，我们必须遍历<code class="fe lw lx ly lz b">/proc/&lt;PID&gt;/...</code>目录——在本例中是——<code class="fe lw lx ly lz b">/proc/8/root/app/...</code>。</p><p id="6571" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一种常见的情况是，应用程序在容器启动时不断崩溃，这使得调试变得困难，因为没有足够的时间将shell会话放入容器并运行一些故障排除命令。在这种情况下，解决方案是创建具有不同入口点/命令的容器，这将阻止应用程序立即崩溃，并允许我们执行调试:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><h1 id="287b" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">好处:调试集群节点</h1><p id="a382" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated">本文主要关注Pods及其容器的调试——但是任何集群管理员都知道——通常需要调试的是节点而不是Pods。幸运的是，<code class="fe lw lx ly lz b">kubectl debug</code>还允许通过创建Pod来调试节点，该Pod将在指定的节点上运行，节点的根文件系统安装在<code class="fe lw lx ly lz b">/root</code>目录中。考虑到我们甚至可以使用<code class="fe lw lx ly lz b">chroot</code>来访问主机二进制文件，这实际上充当了进入node的SSH连接:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="3e7b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码片段中，我们首先确定了要调试的节点，然后使用<code class="fe lw lx ly lz b">node/...</code>作为参数显式运行<code class="fe lw lx ly lz b">kubectl debug</code>,以访问集群的节点。之后，当我们连接到Pod时，我们使用<code class="fe lw lx ly lz b">chroot /host</code>来逃出<code class="fe lw lx ly lz b">chroot</code>监狱，并获得对主机的完全访问权。最后，为了验证我们真的可以看到主机上的一切，我们查看了部分<code class="fe lw lx ly lz b">kubeadm.conf</code>，其中我们可以看到我们在文章开始时配置的<code class="fe lw lx ly lz b">feature-gates: EphemeralContainers=true</code>。</p><h1 id="f609" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">结论</h1><p id="3bc1" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated">能够快速有效地调试应用程序和服务可以为您节省大量时间，但更重要的是，它可以极大地帮助您解决一些问题，如果不立即解决这些问题，最终可能会花费您很多钱。这就是为什么让像<code class="fe lw lx ly lz b">kubectl debug</code>这样的工具为您所用并启用非常重要，即使它们还没有正式发布或默认启用。</p><p id="5261" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果——不管出于什么原因——启用临时容器不是一个选项，那么尝试实践替代的调试方法可能是一个好主意，例如使用应用程序映像的调试版本，它将包括故障排除工具；或者临时改变Pod的容器的命令指令来阻止它崩溃。</p><p id="0166" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">也就是说，<code class="fe lw lx ly lz b">kubectl debug</code>和短命容器只是许多有用但鲜为人知的Kubernetes特性门中的一个，所以请关注后续文章，深入了解Kubernetes的其他隐藏特性。</p></div><div class="ab cl mz na hx nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="im in io ip iq"><p id="7daa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">本文原帖</em><a class="ae ky" href="https://martinheinz.dev/blog/49?utm_source=medium&amp;utm_medium=referral&amp;utm_campaign=blog_post_49" rel="noopener ugc nofollow" target="_blank"><em class="lv">martinheinz . dev</em></a></p><div class="ng nh gp gr ni nj"><a href="https://itnext.io/cloud-native-ci-cd-with-tekton-laying-the-foundation-a377a1b59ac0" rel="noopener  ugc nofollow" target="_blank"><div class="nk ab fo"><div class="nl ab nm cl cj nn"><h2 class="bd iu gy z fp no fr fs np fu fw is bi translated">使用Tekton的云原生CI/CD—奠定基础</h2><div class="nq l"><h3 class="bd b gy z fp no fr fs np fu fw dk translated">是时候通过Tekton Pipelines在Kubernetes上开始您的云原生CI/CD之旅了…</h3></div><div class="nr l"><p class="bd b dl z fp no fr fs np fu fw dk translated">itnext.io</p></div></div><div class="ns l"><div class="nt l nu nv nw ns nx ks nj"/></div></div></a></div><div class="ng nh gp gr ni nj"><a href="https://itnext.io/hardening-docker-and-kubernetes-with-seccomp-a88b1b4e2111" rel="noopener  ugc nofollow" target="_blank"><div class="nk ab fo"><div class="nl ab nm cl cj nn"><h2 class="bd iu gy z fp no fr fs np fu fw is bi translated">用seccomp强化Docker和Kubernetes</h2><div class="nq l"><h3 class="bd b gy z fp no fr fs np fu fw dk translated">您的容器可能不像您想象的那样安全，但是seccomp配置文件可以帮助您解决这个问题…</h3></div><div class="nr l"><p class="bd b dl z fp no fr fs np fu fw dk translated">itnext.io</p></div></div><div class="ns l"><div class="ny l nu nv nw ns nx ks nj"/></div></div></a></div><div class="ng nh gp gr ni nj"><a rel="noopener follow" target="_blank" href="/networking-tools-every-developer-needs-to-know-e17c9159b180"><div class="nk ab fo"><div class="nl ab nm cl cj nn"><h2 class="bd iu gy z fp no fr fs np fu fw is bi translated">每个开发人员都需要知道的网络工具</h2><div class="nq l"><h3 class="bd b gy z fp no fr fs np fu fw dk translated">让我们学习被忽视的网络技能，如检查DNS记录，扫描端口，排除连接故障…</h3></div><div class="nr l"><p class="bd b dl z fp no fr fs np fu fw dk translated">towardsdatascience.com</p></div></div><div class="ns l"><div class="nz l nu nv nw ns nx ks nj"/></div></div></a></div></div></div>    
</body>
</html>