<html>
<head>
<title>How to Speed up Your Python Code With Caching</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何通过缓存加速Python代码</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-speed-up-your-python-code-with-caching-c1ea979d0276?source=collection_archive---------1-----------------------#2021-09-11">https://towardsdatascience.com/how-to-speed-up-your-python-code-with-caching-c1ea979d0276?source=collection_archive---------1-----------------------#2021-09-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6b5c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用cachetools的快速指南</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/6d455e18140ebda71246409354f4cd68.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FLwsQJ_qLBgsJH6Fts6j9w.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://www.pexels.com/fr-fr/@anton-makarenko-109081?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">安东·马卡连柯</a>的图片来自<a class="ae ky" href="https://www.pexels.com/fr-fr/photo/chronometre-analogique-rond-argente-sur-panneau-en-bois-marron-1078057/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">派克斯</a></p></figure><p id="b482" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">几周前，我开始研究优化我的代码。我了解了常见的<a class="ae ky" rel="noopener" target="_blank" href="/18-common-python-anti-patterns-i-wish-i-had-known-before-44d983805f0f">反模式</a>和最坏的实践，查看了创建Python <a class="ae ky" rel="noopener" target="_blank" href="/whats-the-difference-between-is-and-in-python-dc26406c85ad">对象</a>时如何分配内存，并最终理解了多线程和多处理等概念以及<a class="ae ky" href="https://levelup.gitconnected.com/threading-and-multiprocessing-modules-in-python-14363c13fe9d" rel="noopener ugc nofollow" target="_blank">和</a>之间的区别。</p><p id="4baa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">今天，我将告诉你关于<strong class="lb iu">缓存</strong>:一种最小化不必要的计算并加速你的程序的机制。如果做对了，你会惊讶于这是多么有效。</p><blockquote class="lv lw lx"><p id="8ae4" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated"><strong class="lb iu"> <em class="it">在这篇文章中，我们将了解什么是缓存，什么时候与使用相关，以及我们如何使用</em> </strong> <code class="fe mc md me mf b"><strong class="lb iu"><em class="it">cachetools</em></strong></code> <strong class="lb iu"> <em class="it"> python包将其应用于各种用例。</em> </strong></p></blockquote><p id="0a9d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事不宜迟，我们来看看吧！🔎</p><h1 id="df64" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">什么是缓存？</h1><p id="eef9" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">缓存是一种优化技术，包括将最近(或经常)使用的数据保存在一个内存位置，该位置可以廉价快速地访问重复查询。</p><p id="6e58" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于多种原因，从原始源访问数据可能会很昂贵，缓存似乎是缓解这一问题的解决方案。</p><p id="125e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">👉<strong class="lb iu">让我们考虑一个经常使用缓存的应用</strong> : <strong class="lb iu"> web服务器。</strong></p><p id="06bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你正在建立一个小网站来分享你所在地区的本地新闻。</p><p id="4481" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当用户滚动新闻提要并点击一篇文章时，他被重定向到一个网页:浏览器在这一步所做的是查询远程服务器，接收页面源代码并以人类可读的格式呈现它。正如您所料，这个操作非常耗时，因为它涉及到下载远程文件(这是一个网络绑定的操作)和渲染它们。</p><p id="b871" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">⚠️每次用户点击这个链接时都重复同样的操作，这似乎是一个不必要的计算。我们已经知道第一次提取后的结果，为什么不重用它呢？</p><p id="8c84" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">✅:在这种情况下，你应该做的是在获取每篇文章后将内容存储在本地。下次用户打开同一篇文章时，应用程序将从本地副本中读取内容。这会快得多。</p><h1 id="acdc" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">您可能已经在不知不觉中实现了缓存</h1><p id="f3f6" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">让我们回到前面的例子，尝试提出一个简单的缓存实现。</p><p id="5557" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们想要的是将每篇文章的内容存储在本地内存中(例如RAM中的一个对象),如果用户以后请求相同的链接，就可以重用它。</p><p id="3d34" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这看起来像是字典的完美工作。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="23c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们试图用同一个url连续运行两次<code class="fe mc md me mf b">fetch_article</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nf"><img src="../Images/57963ad5defc37bc67e831a40f83d01d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JHX1a2evwvSKu3FfV8I6cQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者截图</p></figure><p id="0988" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们会注意到一个巨大的差异。</p><ul class=""><li id="1951" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu nl nm nn no bi translated">第一次:118毫秒</li><li id="9791" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">第二次:5.01秒</li></ul><p id="ee15" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">这是一个2360的惊人比例！</strong></p><p id="4094" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你会告诉我，118毫秒还是很快。但是想象一下，如果同一个用户每天多次执行这个操作。有很多时间可以节省。</p><h1 id="6b4f" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">使用cachetools和TTLCache实现相同的缓存机制</h1><p id="47e4" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated"><code class="fe mc md me mf b">cachetools</code>是一个提供各种记忆集合和装饰器的模块，包括Python标准库的<a class="ae ky" href="http://docs.python.org/3/library/functools.html#functools.lru_cache" rel="noopener ugc nofollow" target="_blank"> @lru_cache </a>函数装饰器的变体。</p><p id="bf14" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<code class="fe mc md me mf b">cachetools</code>添加缓存行为非常简单。我们只需添加几行:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="b26d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，我们不再需要处理缓存更新的<code class="fe mc md me mf b">fetch_article</code>函数。</p><p id="ff62" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在理解每个import语句的作用之前，先让代码替我们说话。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nu"><img src="../Images/f4bd6c1838d9e1ba2a42c6d1c72f8565.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E0Pvaiob9_qaPLIPOwD9Vg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者截图</p></figure><p id="7220" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运行之后，我们注意到，就像前面的例子一样，相同的时间差。</p><p id="2bc5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一行输入我们需要使用的<code class="fe mc md me mf b">cachetools</code>包。</p><pre class="kj kk kl km gt nv mf nw nx aw ny bi"><span id="81a6" class="nz mh it mf b gy oa ob l oc od"><strong class="mf iu">from cachetools import cached, TTLCache</strong></span></pre><p id="d61d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第二行是我们创建缓存对象的地方:第一个参数指定了我们存储在缓存中的对象的数量。我将它设置为100，但它可以根据您的使用情况而变化。</p><p id="8162" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第二个参数是生存时间的缩写，基本上是每个结果存储在缓存中的时间。过了这段时间，缓存的结果就过期了。</p><p id="fab0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我随意地将它设置为86400秒，这相当于一整天。</p><pre class="kj kk kl km gt nv mf nw nx aw ny bi"><span id="6af0" class="nz mh it mf b gy oa ob l oc od"><strong class="mf iu">cache = TTLCache(maxsize=100, ttl=86400)</strong></span></pre><p id="3356" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第三行是我们添加到每个我们想要使用缓存的函数之上的装饰器。</p><h1 id="f14e" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">其他缓存策略</h1><p id="4b5b" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">我们已经配置了一个TTL缓存，但是其他类型的缓存也是可用的。</p><p id="ee87" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用哪一个高看你的需求了。有:</p><ul class=""><li id="3f27" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu nl nm nn no bi translated">LFUCache(最少使用):记录检索项目的频率，并丢弃最少使用的项目</li><li id="64c1" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">LRUCache(最近最少使用):丢弃最近最少使用的项目</li><li id="488e" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">RRCache(随机替换):随机选择物品并丢弃</li></ul><h1 id="560a" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">感谢阅读🙏</h1><p id="d243" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">缓存是一种重要的优化技术，可以防止重复，提高应用程序的速度。</p><p id="a6c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">知道何时以及如何添加缓存是提高代码效率的实用技能。</p><p id="de0e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望这篇文章对你有用。今天就这些了。</p><p id="0f5c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下次见！👋</p><h1 id="b92b" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">资源</h1><p id="8639" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">您可以查看以下链接，了解更多关于Python中缓存的信息</p><ul class=""><li id="207e" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu nl nm nn no bi translated"><a class="ae ky" href="https://www.programcreek.com/python/example/104146/cachetools.TTLCache" rel="noopener ugc nofollow" target="_blank">https://www . program creek . com/python/example/104146/cache tools。TTLCache </a></li><li id="ff19" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">https://realpython.com/lru-cache-python/<a class="ae ky" href="https://realpython.com/lru-cache-python/" rel="noopener ugc nofollow" target="_blank"/></li><li id="cd9e" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">【https://dev.to/bhavaniravi/caching-in-python-2a2l T4】</li><li id="2080" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated"><a class="ae ky" href="https://levelup.gitconnected.com/faster-code-with-python-caching-8da6e8a92ae9" rel="noopener ugc nofollow" target="_blank">https://level up . git connected . com/faster-code-with-python-caching-8d a6 E8 a 92 AE 9</a></li><li id="7c5b" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated"><a class="ae ky" rel="noopener" target="_blank" href="/you-should-never-repeat-computing-in-python-b097d57cf661">https://towards data science . com/you-should-never-repeat-computing-in-python-b097d 57 cf 661</a></li></ul></div><div class="ab cl oe of hx og" role="separator"><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj"/></div><div class="im in io ip iq"><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ol"><img src="../Images/8cfe63d44c6066520f2038082580abf7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*91Sd39vJEwlZx7AH"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@karsten116?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">卡斯滕·怀恩吉尔特</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><h1 id="5cc4" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">新到中？您可以每月订阅5美元，并解锁无限的文章— <a class="ae ky" href="https://ahmedbesbes.medium.com/membership" rel="noopener">单击此处。</a></h1></div></div>    
</body>
</html>