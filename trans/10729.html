<html>
<head>
<title>Intro to Agent Based Modeling</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于代理的建模介绍</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/intro-to-agent-based-modeling-3eea6a070b72?source=collection_archive---------3-----------------------#2021-10-16">https://towardsdatascience.com/intro-to-agent-based-modeling-3eea6a070b72?source=collection_archive---------3-----------------------#2021-10-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a346" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Python中基于代理的建模如何帮助确定超市柜台数量的例子</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/7dfbfd515892e5753d4f5fe1e7b59967.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SoaWoM5IzH-Z7pWiaWnaDw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由<a class="ae ky" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=2457842" rel="noopener ugc nofollow" target="_blank">皮克斯拜</a>的Gerd Altmann 提供</p></figure><p id="41a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">目录:</strong></p><p id="b629" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">1-简介:为什么是基于代理的建模？</p><p id="78d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">2-我们的超市排队问题</p><p id="30f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">三模型设计</p><p id="11c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">4-模型执行</p><p id="6aec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">5-结论</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="825d" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated"><strong class="ak">简介</strong></h2><p id="23a0" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">基于代理的建模<strong class="lb iu"> </strong> (ABM)是一种<strong class="lb iu">自下而上的模拟</strong>技术，其中我们通过其<strong class="lb iu">个体代理</strong>相互<strong class="lb iu">交互</strong>来分析系统。</p><p id="e1df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们想预测特定地区的COVID病例数，我们可以创建代表该地区人民的代理。</p><p id="a8c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们模拟了几个代理人(人)的行为，其中一些人可能戴着口罩，而其他人没有，一些人接种了疫苗，一些人非常喜欢社交，而其他人没有，等等。然后，我们模拟它们之间的相互作用以及相关的COVID被传输的概率…</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi na"><img src="../Images/5a37c7f23d9ea19eae1861fe2e18f133.png" data-original-src="https://miro.medium.com/v2/resize:fit:400/1*eLeqluU9LqiE9lpPzXQtAA.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Gif由<a class="ae ky" href="https://statnet.org/nme/movie.gif" rel="noopener ugc nofollow" target="_blank"> statnet </a></p></figure><p id="3f86" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运行模拟后，我们能够更好地了解整个系统……我们可以看到人群中的感染人数、康复人数、传播率、是否达到群体免疫等。我们还可以分析系统的情况(感染、恢复等)。)如果我们实施强制接种疫苗等措施。</p><p id="b995" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">ABM的基石是理解微观行为中出现的宏观现象的能力。</p><p id="7bf9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的例子中，使用ABM的替代方法是直接查看宏观级别的统计数据，如感染和恢复的数量，并直接分析这些统计数据的趋势。相反，ABM强调个体代理的行为，这是一种更灵活、更精细的自下而上的方法，可以捕捉宏观模型无法捕捉的方面。</p><p id="d1f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">ABM在生物学、社会科学、交通管理和供应链管理以及许多其他学科中都有应用。</p><p id="0306" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些代理的行为应该尽可能地代表现实(我们可以验证这一点)，因此，例如，如果该地区75%的人戴面具，那么我们创建的代理中有75%被建模为戴面具的代理。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="2655" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">超市排队问题</h2><p id="378d" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">假设我们正在管理一家超市的员工成本。</p><p id="eff4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">问题:对于一个特定的小时，我们预计会有500名顾客出现，我们想确定在那个小时我们应该开多少个柜台。</p><p id="8ad5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">普通顾客价值10美元的毛利润，而操作一个柜台一小时的平均成本是300美元。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/89c637818a1691a6aea729ef6f16c7fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hFXkKW2WSc_0JpmhD6rbiA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">很不幸，此时此地由<a class="ae ky" href="https://pixabay.com/users/alexas_fotos-686414/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=1165437" rel="noopener ugc nofollow" target="_blank">拍摄的图片结束了我在</a><a class="ae ky" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=1165437" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>的旅程</p></figure><p id="5da8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与标准的排队理论模型(M/M/1，M/G/1，M/M/c等)不同。)，基于代理的建模可以更容易地捕捉这种多排队、多服务器环境中的行为方面。</p><p id="3043" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">常见的行为包括排队<strong class="lb iu">犹豫</strong>(客户因为排队太长而不加入)<strong class="lb iu">反悔</strong>(客户加入队列但等待太久后离开)<strong class="lb iu">哄抢</strong>(客户从较长的队列移到较短的队列)。</p><p id="c16a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将尝试使用反弹道导弹来解决这个问题。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="bb95" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">模型设计</h2><p id="6021" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">我们将基于以下假设构建一个简单的ABM模型:</p><blockquote class="nb nc nd"><p id="aea3" class="kz la ne lb b lc ld ju le lf lg jx lh nf lj lk ll ng ln lo lp nh lr ls lt lu im bi translated">1-我们正在优化这一小时的净利润。</p><p id="3d73" class="kz la ne lb b lc ld ju le lf lg jx lh nf lj lk ll ng ln lo lp nh lr ls lt lu im bi translated">在这一小时内，正好有500名顾客会到达超市。</p><p id="6fb2" class="kz la ne lb b lc ld ju le lf lg jx lh nf lj lk ll ng ln lo lp nh lr ls lt lu im bi translated">3-每个顾客价值10美元。</p><p id="2cef" class="kz la ne lb b lc ld ju le lf lg jx lh nf lj lk ll ng ln lo lp nh lr ls lt lu im bi translated">4-每个柜台的运营成本为300美元。</p><p id="fec0" class="kz la ne lb b lc ld ju le lf lg jx lh nf lj lk ll ng ln lo lp nh lr ls lt lu im bi translated">基于beta分布，顾客在一天中的不同时间到达超市排队，这样他们更有可能在一小时的中间到达。</p><p id="cbd8" class="kz la ne lb b lc ld ju le lf lg jx lh nf lj lk ll ng ln lo lp nh lr ls lt lu im bi translated">6-处理客户订单的平均时间为45秒，但处理时间因客户而异。它遵循泊松分布(为简单起见，并确保我们得到离散的非负数)，平均值为45。</p><p id="1fdd" class="kz la ne lb b lc ld ju le lf lg jx lh nf lj lk ll ng ln lo lp nh lr ls lt lu im bi translated">7-每个顾客都有一个犹豫的容忍度，即顾客愿意加入的排队人数。如果排队的人多了，顾客就不会排队，我们就失去了销售。顾客的拒绝容忍度服从泊松分布。平均容忍度为6，即如果队列中有6个或更多的其他顾客，大多数顾客会犹豫。</p><p id="bf18" class="kz la ne lb b lc ld ju le lf lg jx lh nf lj lk ll ng ln lo lp nh lr ls lt lu im bi translated">8-顾客选择排队最短的柜台。</p></blockquote><p id="2e51" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注意</strong>在实际应用中，我们根据可用数据验证假设(或将其作为待优化的参数)。同样，在这个介绍性的例子中，犹豫是我们考虑的唯一行为。</p><p id="7d9d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们运行ABM模拟3600步(滴答),代表一小时3600秒。下面是初始配置代码。</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="c282" class="mc md it nj b gy nn no l np nq"># Config<br/>ticks = 3600 # 3600 ticks = 3600 seconds = 1 hour<br/>no_customers = 500<br/>avg_service_time = 45 # ticks/seconds per customer<br/>gross_margin_per_customer = 10 # dollars<br/>cost_per_counter = 300 # dollars</span></pre><p id="92b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们使用python中的<a class="ae ky" href="https://mesa.readthedocs.io/en/stable/" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu"> Mesa </strong> </a>库来编码我们模型的其余部分。让我们从定义我们的客户类和所需的属性开始。客户类是我们将要打交道的两类代理之一，另一类是柜台。</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="9a4e" class="mc md it nj b gy nn no l np nq">from mesa import Agent</span><span id="5d78" class="mc md it nj b gy nr no l np nq">class Customer(Agent):<br/>    def __init__(self, unique_id, model):<br/>        super().__init__(unique_id, model)<br/>        # Time required to process the customer's transaction<br/>        self.service_time = ss.poisson(45).rvs()<br/>        # Time of arrival at queue<br/>        self.entry_time = np.int(ss.beta(3, 3).rvs() * ticks) + 1<br/>        self.balk_tolerance = ss.poisson(5).rvs() + 1<br/>        # Whether or not the customer has arrived at the queue<br/>        self._arrived = False<br/>        self._chosen_counter = None<br/>        self._q_entry = None<br/>        self._q_exit = None<br/>        # Start time when customer is being served<br/>        self._service_entry = None<br/>        # End time<br/>        self._service_exit = None</span></pre><p id="4adc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还需要为我们的客户创建一个“分步”方法，描述他们在模拟的每一步(滴答/秒)做什么。</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="c425" class="mc md it nj b gy nn no l np nq">class Customer(Agent):<br/>    def __init__(self, unique_id, model):<br/>        super().__init__(unique_id, model)<br/>        # Time required to process the customer's transaction<br/>        self.service_time = ss.poisson(45).rvs()<br/>        # Time of arrival at queue<br/>        self.entry_time = np.int(ss.beta(3, 3).rvs() * ticks) + 1<br/>        self.balk_tolerance = ss.poisson(5).rvs() + 1<br/>        # Whether or not the customer has arrived at the queue<br/>        self._arrived = False<br/>        self._chosen_counter = None<br/>        self._q_entry = None<br/>        self._q_exit = None<br/>        # Start time when customer is being served<br/>        self._service_entry = None<br/>        # End time<br/>        self._service_exit = None</span><span id="0b8a" class="mc md it nj b gy nr no l np nq">    def select_counter(self):<br/>        self._arrived = True<br/>        # Queue at shortest counter<br/>        self._chosen_counter_idx = np.argmin([<br/>            len(counter.queue) for counter in self.model.counters])<br/>        self._chosen_counter = self.model.counters[<br/>            self._chosen_counter_idx]<br/>        # Balk if there are too many people at the counter<br/>        if len(self._chosen_counter.queue) &lt; self.balk_tolerance:<br/>            self._chosen_counter.queue.append(self)<br/>            self._q_entry = self.model._current_tick</span><span id="6efd" class="mc md it nj b gy nr no l np nq">    def pay_n_leave(self):<br/>        self._service_exit = self.model._current_tick<br/>        self._chosen_counter.active_customer = None</span><span id="b32f" class="mc md it nj b gy nr no l np nq">    def step(self):<br/>        if (self._arrived == False) &amp; \<br/>        (self.model._current_tick &gt;= self.entry_time):<br/>            self.select_counter()<br/>        elif isinstance(self._service_entry, int):<br/>            if self.model._current_tick - self._service_entry \<br/>            == self.service_time:<br/>                self.pay_n_leave()</span></pre><p id="c89b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码中，在每个模拟步骤中，如果我们到达的模拟步骤/时间与客户的进入时间(他到达超市队列的时间)相匹配，那么我们运行select_counter方法，在该方法中，他选择具有最短队列的柜台，或者如果队列太长，他会停止。</p><p id="93c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果顾客已经在柜台接受服务，我们检查是否已经运行了足够的步骤到达他的服务时间(处理他的交易所需的时间),然后我们运行pay_n_leave方法。</p><p id="0e67" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，下面的代码用于第二类代理，计数器。</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="f328" class="mc md it nj b gy nn no l np nq">class Counter(Agent):<br/>    def __init__(self, unique_id, model):<br/>        super().__init__(unique_id, model)<br/>        self.queue = []<br/>        self.active_customer = None</span><span id="7261" class="mc md it nj b gy nr no l np nq">    def dequeue(self):<br/>        try:<br/>            self.active_customer = self.queue.pop(0)<br/>            self.active_customer._service_entry = self.model._current_tick<br/>            self.active_customer._q_exit = self.model._current_tick<br/>        except:<br/>            pass</span><span id="ca99" class="mc md it nj b gy nr no l np nq">    def step(self):<br/>        if self.active_customer is None:<br/>            self.dequeue()</span></pre><p id="8a0f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们创建一个QueueModel类，用于管理代理所属的整个模拟/系统。</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="4ddf" class="mc md it nj b gy nn no l np nq">from mesa import Model<br/>from mesa.time import RandomActivation</span><span id="664f" class="mc md it nj b gy nr no l np nq">class QueueModel(Model):<br/>    """Queueing model with customers and counters as two<br/>    types of agents that interact with each other<br/>    """</span><span id="f9bd" class="mc md it nj b gy nr no l np nq">    def __init__(self, no_customers, no_counters, ticks):<br/>        self.ticks = ticks<br/>        self._current_tick = 1<br/>        self.no_customers = no_customers<br/>        self.no_counters = no_counters<br/>        self.schedule = RandomActivation(self)<br/>        # Create agents<br/>        self.customers = []<br/>        self.counters = []<br/>        for i in range(self.no_customers):<br/>            customer = Customer(i, self)<br/>            self.schedule.add(customer)<br/>            self.customers.append(customer)<br/>        for i in range(self.no_counters):<br/>            counter = Counter(i + no_customers, self)<br/>            self.schedule.add(counter)<br/>            self.counters.append(counter)</span><span id="eaad" class="mc md it nj b gy nr no l np nq">    def step(self):<br/>        self.schedule.step()<br/>        self._current_tick += 1</span></pre><p id="13a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">QueueModel类可以用客户数量(在我们的示例中为500)、计数器数量(这是我们试图确定的)和节拍(模拟步骤的数量，3600代表一小时3600秒)来初始化。</p><p id="5c35" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们有一个“schedule”属性，其中描述了哪些代理将在何时被激活。我们使用随机激活，以随机的顺序激活所有的代理。您可以阅读不同设置的<a class="ae ky" href="https://mesa.readthedocs.io" rel="noopener ugc nofollow" target="_blank">台面文档</a>。</p><p id="df02" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在初始化时，有两个for循环，我们在其中创建客户和计数器代理。我们还将它们添加到模型的时间表中。</p><p id="0eb5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还有一个“step”方法，它协调运行模拟的一个步骤，还触发作为时间表一部分的代理的“step”方法。</p><p id="1e6d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在可以通过运行以下代码来运行模拟…</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="7d38" class="mc md it nj b gy nn no l np nq">model = QueueModel(ticks=ticks,<br/>    no_customers=no_customers, no_counters=no_counters)</span><span id="1ca1" class="mc md it nj b gy nr no l np nq">for i in range(ticks):<br/>    model.step()</span></pre><p id="1a0c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，我们也可以在QueueModel类中添加一个“数据收集器”,帮助我们跟踪感兴趣的指标。我们可以在模拟的每一步跟踪这些指标。</p><p id="8eb5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们跟踪8项指标:</p><blockquote class="nb nc nd"><p id="550d" class="kz la ne lb b lc ld ju le lf lg jx lh nf lj lk ll ng ln lo lp nh lr ls lt lu im bi translated">1-到达的顾客数量。在3600个模拟步骤(代表1小时)结束时，我们应该有500个客户。</p><p id="e115" class="kz la ne lb b lc ld ju le lf lg jx lh nf lj lk ll ng ln lo lp nh lr ls lt lu im bi translated">2-已经服务的客户数量。</p><p id="7ee4" class="kz la ne lb b lc ld ju le lf lg jx lh nf lj lk ll ng ln lo lp nh lr ls lt lu im bi translated">3-到达队列但犹豫不决的顾客人数。我们失去了那些顾客。</p><p id="39a1" class="kz la ne lb b lc ld ju le lf lg jx lh nf lj lk ll ng ln lo lp nh lr ls lt lu im bi translated">4-所有计数器的平均队列大小。</p><p id="9541" class="kz la ne lb b lc ld ju le lf lg jx lh nf lj lk ll ng ln lo lp nh lr ls lt lu im bi translated">5-顾客得到服务前的平均等待时间。</p><p id="5cb1" class="kz la ne lb b lc ld ju le lf lg jx lh nf lj lk ll ng ln lo lp nh lr ls lt lu im bi translated">6-毛利润=服务的客户数量x每位客户10美元</p><p id="13c7" class="kz la ne lb b lc ld ju le lf lg jx lh nf lj lk ll ng ln lo lp nh lr ls lt lu im bi translated">7-运营成本=柜台数量x 300美元</p><p id="e047" class="kz la ne lb b lc ld ju le lf lg jx lh nf lj lk ll ng ln lo lp nh lr ls lt lu im bi translated">8-利润总额=毛利率-运营成本</p></blockquote><p id="9949" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了将指标添加到我们的ABM模型中，我们首先将它们创建为以我们的队列模型作为参数的函数…</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="6176" class="mc md it nj b gy nn no l np nq">def get_customers_arrived(model):<br/>    customers_arrived = [<br/>        customer._arrived for customer in model.customers]<br/>    no_customers_arrived = np.sum(customers_arrived)<br/>    return no_customers_arrived</span><span id="f408" class="mc md it nj b gy nr no l np nq">def get_customers_served(model):<br/>    customers_served = [not(customer._service_exit is None)<br/>                        for customer in model.customers]<br/>    no_customers_served = np.sum(customers_served)<br/>    return no_customers_served</span><span id="fade" class="mc md it nj b gy nr no l np nq">def get_customers_balked(model):<br/>    customers_arrived = [<br/>        customer._arrived for customer in model.customers]<br/>    # Customers who never joined a queue<br/>    customers_no_q = np.array([<br/>        customer._q_entry is None for customer in model.customers])<br/>    no_customers_balked = np.sum(customers_arrived * customers_no_q)<br/>    return no_customers_balked</span><span id="683e" class="mc md it nj b gy nr no l np nq">def get_avg_queue_size(model):<br/>    queue_size = [len(counter.queue) for counter in model.counters]<br/>    avg_queue_size = np.mean(queue_size)<br/>    return avg_queue_size</span><span id="e379" class="mc md it nj b gy nr no l np nq">def get_avg_waiting_time(model):<br/>    customers_wait = [np.nan if customer._q_exit is None else<br/>                      customer._q_exit - customer._q_entry for customer in model.customers]<br/>    avg_customer_wait = np.nanmean(customers_wait)<br/>    return avg_customer_wait</span><span id="223b" class="mc md it nj b gy nr no l np nq">def get_gross_margin(model):<br/>    return gross_margin_per_customer * get_customers_served(model)</span><span id="6445" class="mc md it nj b gy nr no l np nq">def get_operating_costs(model):<br/>    return cost_per_counter * no_counters</span><span id="cde7" class="mc md it nj b gy nr no l np nq">def get_total_profit(model):<br/>    return get_gross_margin(model) - get_operating_costs(model)</span></pre><p id="b4b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们如下更新我们的QueueModel类…</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="384d" class="mc md it nj b gy nn no l np nq">from mesa.datacollection import DataCollector</span><span id="ce74" class="mc md it nj b gy nr no l np nq">class QueueModel(Model):<br/>    """Queueing model with customers and counters as two<br/>    types of agents that interact with each other<br/>    """</span><span id="90b5" class="mc md it nj b gy nr no l np nq">    def __init__(self, no_customers, no_counters, ticks):<br/>        self.ticks = ticks<br/>        self._current_tick = 1<br/>        self.no_customers = no_customers<br/>        self.no_counters = no_counters<br/>        self.schedule = RandomActivation(self)<br/>        # Create agents<br/>        self.customers = []<br/>        self.counters = []<br/>        for i in range(self.no_customers):<br/>            customer = Customer(i, self)<br/>            self.schedule.add(customer)<br/>            self.customers.append(customer)<br/>        for i in range(self.no_counters):<br/>            counter = Counter(i + no_customers, self)<br/>            self.schedule.add(counter)<br/>            self.counters.append(counter)<br/>        self.datacollector = DataCollector(<br/>            model_reporters={<br/>    'Customers Arrived': get_customers_arrived,                      <br/>    'Customers Served': get_customers_served,<br/>    'Customers Balked': get_customers_balked,<br/>    'Average Waiting Time': get_avg_waiting_time,<br/>    'Average Queue Size': get_avg_queue_size,<br/>    'Gross Margin': get_gross_margin,<br/>    'Operating Costs': get_operating_costs,<br/>    'Total Profit': get_total_profit})</span><span id="91e6" class="mc md it nj b gy nr no l np nq">    def step(self):<br/>        self.datacollector.collect(self)<br/>        self.schedule.step()<br/>        self._current_tick += 1</span></pre><p id="8730" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在准备运行我们的模型…</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="64e8" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">模型执行</h2><p id="46a7" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">让我们试着用5个计数器运行我们的模型…</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="e951" class="mc md it nj b gy nn no l np nq">no_counters = 5</span><span id="e551" class="mc md it nj b gy nr no l np nq">model = QueueModel(ticks=ticks,<br/>    no_customers=no_customers, no_counters=no_counters)</span><span id="96eb" class="mc md it nj b gy nr no l np nq">for i in range(ticks):<br/>    model.step()</span></pre><p id="0502" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是结果和用来产生它们的代码…</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="11d9" class="mc md it nj b gy nn no l np nq">run_stats = model.datacollector.get_model_vars_dataframe()</span><span id="afd6" class="mc md it nj b gy nr no l np nq">fig, (ax1, ax2, ax3, ax4) = plt.subplots(4, 1)<br/>fig.figure.set_figwidth(12)<br/>fig.figure.set_figheight(16)<br/>fig.suptitle(f'Simulations stats using {no_counters} counters', fontsize=20)</span><span id="006e" class="mc md it nj b gy nr no l np nq">ax1.plot(run_stats[['Customers Arrived',<br/>                'Customers Served',<br/>                'Customers Balked',<br/>               ]])<br/>ax1.legend(['Customers Arrived',<br/>            'Customers Served',<br/>            'Customers Balked',<br/>            ])<br/>ax1.set_ylabel('Customers')<br/>ax1.set_xlim(0)<br/>ax1.set_ylim(0)</span><span id="efd8" class="mc md it nj b gy nr no l np nq">ax2.plot(run_stats['Average Queue Size'], color='red')<br/>ax2.legend(['Average Queue Size'])<br/>ax2.set_ylabel('Customers')<br/>ax2.set_xlim(0)<br/>ax2.set_ylim(0)</span><span id="f171" class="mc md it nj b gy nr no l np nq">ax3.plot(run_stats['Average Waiting Time'], color='grey')<br/>ax3.legend(['Average Waiting Time (across full hour)'])<br/>ax3.set_ylabel('Seconds')<br/>ax3.set_xlim(0)<br/>ax3.set_ylim(0)</span><span id="b205" class="mc md it nj b gy nr no l np nq">ax4.plot(run_stats[['Gross Margin',<br/>                'Operating Costs',<br/>                'Total Profit'<br/>               ]])<br/>ax4.legend(['Gross Margin',<br/>            'Operating Costs',<br/>            'Total Profit'<br/>            ])<br/>ax4.set_ylabel('Dollars')<br/>ax4.set_xlim(0)</span><span id="e554" class="mc md it nj b gy nr no l np nq">fig.show()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ns"><img src="../Images/67b75b47848ff0dabe5924588364a9af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nOY1qFlvhAKLn0S_Iz2dqw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="d50d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">x轴代表我们正在模拟的1小时内的3600次滴答/秒。</p><p id="8565" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一个图表向我们展示了在大约1200秒(大约20分钟)后，由于太多的顾客到来，顾客开始犹豫。</p><p id="0db0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第二张图中，我们可以看到大约10分钟后，队列大小开始增加，并在一个小时的中间达到大约每个柜台6个客户的峰值。</p><p id="28a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第三张图向我们展示了平均等待时间(累积)是如何从一小时开始到一小时结束时增加的，因为许多客户在一小时中间到达，他们排着长队等待，从而推高了平均等待时间。</p><p id="be0b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，第四张图表显示了我们的财务状况，在这一小时结束时，我们积累了1500多美元。</p><p id="e5bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">基于以上所述，<strong class="lb iu"> 5个柜台似乎太低了</strong>，因为我们可以看到，不到200名客户<strong class="lb iu"> (40%)拒绝</strong>并流失。</p><p id="f51b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们尝试使用5–15个计数器运行模拟，以确定理想的计数器数量…</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="2d35" class="mc md it nj b gy nn no l np nq">full_stats = {}</span><span id="793a" class="mc md it nj b gy nr no l np nq">for no_counters in range (5, 16):<br/>    model = QueueModel(ticks=ticks,<br/>    no_customers=no_customers, no_counters=no_counters)<br/>    for i in range(ticks):<br/>        model.step()   <br/>    run_stats = model.datacollector.get_model_vars_dataframe()<br/>    full_stats[no_counters] = run_stats.iloc[-1]<br/>    <br/>pd.DataFrame(full_stats).transpose().astype(int)</span></pre><p id="c98b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码中，我们用5–15个计数器运行模拟，并在每个模拟结束时查看统计数据(不是模拟的每个步骤)。dataframe输出显示了不同计数器数量的结果…</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/8c207dad756dd46a1607f918056ffac4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hskWTSmhv6NaDhy1AcNDFA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="1da9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以看到<strong class="lb iu">的总利润在9个柜台</strong>的情况下最大化为2030美元。</p><p id="f308" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以根据任何感兴趣的指标进行优化…即时利润不一定是最佳指标。</p><p id="490e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用9个柜台的每个顾客的平均等待时间是94秒…通过增加一个额外的柜台，我们将等待时间减少了33秒，达到61秒，我们只损失了90美元(总利润是1940美元)。减少等待时间可能会创造更好的客户体验，从长远来看会带来更多利润。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="968f" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">结论</h2><p id="4746" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">上述示例的目标是介绍基于代理的建模主题及其独特的优势，包括轻松捕捉不同代理行为的能力。通常，有人认为我们基于有限理性做出决策。</p><p id="ae9e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，另一个主要好处是能够看到微观行为如何影响整个系统。例如，我们看到，个体的阻碍容忍度如何决定不同的平均排队等待时间和不同的累积利润。</p><p id="d113" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在随后的文章中，我们可以看看在根据可用数据和程式化事实进行验证之后，如何为模型选择最佳的模型假设和参数。</p></div></div>    
</body>
</html>