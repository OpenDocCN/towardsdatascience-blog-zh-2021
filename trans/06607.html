<html>
<head>
<title>Anomaly Detection in Manufacturing, Part 3: Visualize the Results</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">制造业中的异常检测，第3部分:可视化结果</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/anomaly-detection-in-manufacturing-part-3-visualize-the-results-a2afb5f61d2f?source=collection_archive---------12-----------------------#2021-06-14">https://towardsdatascience.com/anomaly-detection-in-manufacturing-part-3-visualize-the-results-a2afb5f61d2f?source=collection_archive---------12-----------------------#2021-06-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="9bb1" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/manf-ds-python" rel="noopener" target="_blank">用PYTHON制造数据科学</a></h2><div class=""/><div class=""><h2 id="77f4" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">创建漂亮的数据可视化，并查看异常检测模型的执行情况</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/45abaa08009f9c377129775d6c5e566f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JTsuv1tigbzexkFHeDtiSg.jpeg"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">照片由<a class="ae le" href="https://unsplash.com/@smudgern6?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">丹尼尔·史密斯</a>在<a class="ae le" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="4c79" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">在现代制造环境中，数据的可用性是巨大的，但是常常缺乏利用数据的能力。幸运的是，数据科学和机器学习的工具可以提供帮助，反过来，可以释放出难以置信的价值。在本系列中，我们一直在探索这些工具在金属加工过程中检测故障的应用。</p><p id="755a" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">在<a class="ae le" rel="noopener" target="_blank" href="/anomaly-detection-in-manufacturing-part-2-building-a-variational-autoencoder-248abce07349">之前的文章</a>中，我们构建并训练了可变自动编码器来重构铣床信号。下图中的步骤1和2显示了这一点。在本帖中，我们将通过检查一个经过训练的VAE模型的异常检测性能来演示随机搜索循环的最后一步(步骤3)——我们将看看我们的异常检测模型是否能够真正检测到磨损的工具。</p><p id="2b77" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">使用重建误差(输入空间异常检测)和测量样本之间的KL-散度差(潜在空间异常检测)来执行异常检测。我们将看到这是如何做到的，并通过一些漂亮的数据可视化来深入研究结果。最后，我将建议一些潜在的领域进行进一步的探索。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mb"><img src="../Images/1607a0d44e22ac66f87232f11af7d3be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1M2aDjHkT72DrOOepG-hLQ.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">随机搜索训练过程有三个步骤。首先，随机选择超参数。其次，用这些参数训练VAE。第三，检查经过训练的VAE的异常检测性能。在这篇文章中，我们将着眼于第三步。(图片由作者提供)</p></figure><h1 id="c235" class="mc md iq bd me mf mg mh mi mj mk ml mm kf mn kg mo ki mp kj mq kl mr km ms mt bi translated">背景</h1><h2 id="35a2" class="mu md iq bd me mv mw dn mi mx my dp mm lo mz na mo ls nb nc mq lw nd ne ms iw bi translated">输入空间异常检测</h2><p id="b575" class="pw-post-body-paragraph lf lg iq lh b li nf ka lk ll ng kd ln lo nh lq lr ls ni lu lv lw nj ly lz ma ij bi translated">我们的变型自动编码器已经过“健康”刀具磨损数据的培训。因此，如果我们向训练过的VAEs提供不健康的数据，或者仅仅是不正常的数据，我们将产生很大的重建误差。可以对该重建误差设置阈值，由此产生高于阈值的重建误差的数据被认为是异常。这是输入空间异常检测。</p><blockquote class="nk nl nm"><p id="1d18" class="lf lg nn lh b li lj ka lk ll lm kd ln no lp lq lr np lt lu lv nq lx ly lz ma ij bi translated">注意:为了简洁，我不会在这篇文章中涵盖所有代码——打开<a class="ae le" href="https://colab.research.google.com/github/tvhahn/Manufacturing-Data-Science-with-Python/blob/master/Metal%20Machining/1.C_anomaly-results.ipynb" rel="noopener ugc nofollow" target="_blank"> Colab笔记本</a>进行交互体验，并查看所有代码。</p></blockquote><p id="97db" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我们将使用均方误差(MSE)来测量重建误差。因为重构是对所有六个信号的重构，所以我们可以计算每个单独信号(<code class="fe nr ns nt nu b">mse</code>函数)以及所有六个组合信号(<code class="fe nr ns nt nu b">mse_total</code>函数)的MSE。这两个函数如下所示:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="2ca5" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">重建值(<code class="fe nr ns nt nu b">recon</code>)是通过将窗口切割信号(也称为子切割)输入到训练过的VAE中产生的，如下:<code class="fe nr ns nt nu b">recon = model.predict(X, batch_size=64).</code></p><p id="c654" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">重构概率是输入空间异常检测的另一种方法。).安和赵在他们2015年的论文中介绍了这种方法。[1]</p><p id="72a0" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我对重建概率方法不太熟悉，但是詹姆斯·麦卡弗里在他的博客<a class="ae le" href="https://jamesmccaffrey.wordpress.com/2021/03/11/anomaly-detection-using-variational-autoencoder-reconstruction-probability/" rel="noopener ugc nofollow" target="_blank">上有一个很好的解释(并且用PyTorch实现)。他说:“重建概率异常检测的想法是计算第二个概率分布，然后用它来计算输入项来自该分布的可能性。具有低重建概率的数据项不可能来自该分布，因此在某种程度上是异常的。”</a></p><p id="3317" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我们不会使用重建概率来进行异常检测，但实现起来会很有趣。也许你可以试一试？</p><h2 id="004f" class="mu md iq bd me mv mw dn mi mx my dp mm lo mz na mo ls nb nc mq lw nd ne ms iw bi translated">潜在空间异常检测</h2><p id="1377" class="pw-post-body-paragraph lf lg iq lh b li nf ka lk ll ng kd ln lo nh lq lr ls ni lu lv lw nj ly lz ma ij bi translated">异常检测也可以使用潜在空间中的均值和标准差编码来执行，这就是我们将要做的。下面是一般的方法:</p><ul class=""><li id="f362" class="nx ny iq lh b li lj ll lm lo nz ls oa lw ob ma oc od oe of bi translated">使用KL-divergence，测量数据样本之间熵的相对差异。可以在这个相对差异上设置阈值，指示数据样本何时异常。</li></ul><p id="b804" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">Adam Lineberry在他的博客上有一个用PyTorch实现的KL-divergence异常检测的很好的例子。下面是我们将使用的KL-divergence函数(通过Keras和TensorFlow实现):</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="6a24" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">其中<code class="fe nr ns nt nu b">mu</code>是平均值(<em class="nn"> </em>)，而<code class="fe nr ns nt nu b">log_var</code>是方差的对数(log σ)。方差的对数用于训练VAE，因为它比方差更稳定。</p><p id="d76a" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">为了生成KL-散度分数，我们使用以下函数:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nv nw l"/></div></figure><h2 id="3472" class="mu md iq bd me mv mw dn mi mx my dp mm lo mz na mo ls nb nc mq lw nd ne ms iw bi translated">评估指标</h2><p id="be56" class="pw-post-body-paragraph lf lg iq lh b li nf ka lk ll ng kd ln lo nh lq lr ls ni lu lv lw nj ly lz ma ij bi translated">在我们计算了重建误差或KL-divergence分数之后，我们准备设置一个决策阈值。任何高于阈值的值都将是异常的(可能是磨损的工具)，而任何低于阈值的值都将是正常的(健康的工具)。</p><p id="7be3" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">为了全面评估一个模型的性能，我们必须考虑一系列潜在的决策阈值。两种常见的方法是<a class="ae le" href="https://en.wikipedia.org/wiki/Receiver_operating_characteristic" rel="noopener ugc nofollow" target="_blank">接收器工作特性</a> (ROC)和<a class="ae le" href="https://en.wikipedia.org/wiki/Precision_and_recall" rel="noopener ugc nofollow" target="_blank">精确召回</a>曲线。ROC曲线描绘了真阳性率对假阳性率。精确度-召回曲线，顾名思义，描绘了精确度与召回率的关系。测量曲线下的面积提供了一个比较不同模型的好方法。</p><p id="c22b" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我们将使用精确召回曲线下面积(PR-AUC)来评估模型性能。与ROC-AUC相比，PR-AUC在不平衡数据上表现良好。[2，3]下图解释了什么是精确度和召回率，以及精确度-召回率曲线是如何构建的。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi og"><img src="../Images/8897453410889ded73ceae275dcdf156.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zNDohiAEvNqHoftoAKvnfQ.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">通过改变异常检测模型中的决策阈值来创建精确召回曲线。(图片由作者提供)</p></figure><p id="bef5" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">最终，模型性能的评估及其决策阈值的设置是特定于应用的。例如，制造商可能将预防工具故障置于频繁更换工具之上。因此，他们可以设置低阈值来检测更多的工具故障(更高的召回率)，但代价是有更多的假阳性(更低的精度)。</p><h1 id="1829" class="mc md iq bd me mf mg mh mi mj mk ml mm kf mn kg mo ki mp kj mq kl mr km ms mt bi translated">分析最佳模型</h1><p id="345f" class="pw-post-body-paragraph lf lg iq lh b li nf ka lk ll ng kd ln lo nh lq lr ls ni lu lv lw nj ly lz ma ij bi translated">现在，一些“背景”信息已经涵盖，我们可以开始分析训练好的VAE模型。您必须计算每个模型的性能指标(PR-AUC分数),看看哪一个是最好的。但是为了这个帖子，我已经训练了一堆模型，选出了最上面的一个(基于PR-AUC评分)。</p><p id="1f00" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">以下是顶配车型的参数:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/2b16aa3eda2f13082f610a59ff48118b.png" data-original-src="https://miro.medium.com/v2/resize:fit:426/format:webp/1*PEQg9tGK9sbmM8Gq8AzL2g.png"/></div></figure><h2 id="5949" class="mu md iq bd me mv mw dn mi mx my dp mm lo mz na mo ls nb nc mq lw nd ne ms iw bi translated">计算PR-AUC分数</h2><p id="80fe" class="pw-post-body-paragraph lf lg iq lh b li nf ka lk ll ng kd ln lo nh lq lr ls ni lu lv lw nj ly lz ma ij bi translated">让我们看看顶级模型在训练/验证/测试集上的PR-AUC分数。但是首先，我们需要加载数据和包。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="1fef" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated"><code class="fe nr ns nt nu b">get_results</code>函数接受一个模型，并给出该模型在训练、验证和测试集上的性能。它还返回给定迭代次数的精度、召回、真阳性和假阳性(称为<code class="fe nr ns nt nu b">grid_iterations</code>)。因为VAE的输出是部分随机的(random ),所以您也可以运行一些搜索(<code class="fe nr ns nt nu b">search_iterations</code>),然后取所有搜索的平均值。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="f8f1" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">最后，下面是我们得出的结果:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nv nw l"/></div></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/e086c2aabdb2a3fa69d6fdbcebb8be0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:716/format:webp/1*N0VO9GYEaV0fSOfbHWMQbw.png"/></div></figure><p id="9a3b" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">看上表:潜在空间异常检测优于输入空间异常检测。这并不奇怪。包含在潜在空间中的信息更具表现力，因此更有可能识别切割之间的差异。</p><h2 id="f0d5" class="mu md iq bd me mv mw dn mi mx my dp mm lo mz na mo ls nb nc mq lw nd ne ms iw bi translated">精确回忆曲线</h2><p id="ba5b" class="pw-post-body-paragraph lf lg iq lh b li nf ka lk ll ng kd ln lo nh lq lr ls ni lu lv lw nj ly lz ma ij bi translated">我们希望将模型的性能可视化。让我们为潜在空间中的异常检测模型绘制精确召回曲线和ROC曲线。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nv nw l"/></div></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oj"><img src="../Images/e5316eb5fb2d2cc17abb349efa401f05.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I1LtwmTE9UxOM8AvgmGUFg.png"/></div></div></figure><p id="d65e" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">上图中的虚线表示“无技能模型”在进行异常检测时将获得的结果，也就是说，如果模型为数据集中的每个子部分随机分配一个类别(正常或异常)。该随机模型由ROC图中的斜线和PR-AUC图中的水平线表示，设定精度为0.073(测试集中失败子切割的百分比)。</p><p id="a24e" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">比较精确-召回曲线和ROC曲线:ROC曲线给出了对模型性能更乐观的看法；这是0.883的曲线下面积。然而，精确召回曲线下面积没有那么高，值为0.450。</p><p id="c82f" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">为什么曲线下面积值不同？这是因为我们的数据严重失衡。这就是为什么您想要使用PR-AUC而不是ROC-AUC指标的确切原因。PR-AUC将在处理不平衡数据时提供模型性能的更真实视图。</p><h2 id="1b1a" class="mu md iq bd me mv mw dn mi mx my dp mm lo mz na mo ls nb nc mq lw nd ne ms iw bi translated">潜在空间的小提琴情节</h2><p id="23db" class="pw-post-body-paragraph lf lg iq lh b li nf ka lk ll ng kd ln lo nh lq lr ls ni lu lv lw nj ly lz ma ij bi translated">小提琴图是一种可视化决策边界和查看样本错误分类的有效方法。你说，什么是小提琴的情节？我们来造一个吧！</p><p id="ca14" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">这是will将用来创建情节的<code class="fe nr ns nt nu b">violin_plot</code>函数。它需要经过训练的编码器、子切割(<code class="fe nr ns nt nu b">X</code>)、标签(<code class="fe nr ns nt nu b">y</code>)和一个示例阈值。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="71f2" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我们需要加载编码器。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="1b89" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">…还有剧情！</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nv nw l"/></div></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ok"><img src="../Images/4009211a501d144002e3efb0f5242ca1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G1Ii9zoTls9JxPWNjQCOjQ.png"/></div></div></figure><p id="9c77" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">不错吧。您可以在violin图中看到不同的阈值会如何错误分类不同数量的数据点。想象红色虚线，代表决策阈值，在图上向左或向右移动。这是异常检测的固有问题——从异常中分离噪声。</p><h2 id="e6aa" class="mu md iq bd me mv mw dn mi mx my dp mm lo mz na mo ls nb nc mq lw nd ne ms iw bi translated">比较不同切割参数的结果</h2><p id="8fd6" class="pw-post-body-paragraph lf lg iq lh b li nf ka lk ll ng kd ln lo nh lq lr ls ni lu lv lw nj ly lz ma ij bi translated">铣削数据集中有六个切削参数:</p><ul class=""><li id="c8fb" class="nx ny iq lh b li lj ll lm lo nz ls oa lw ob ma oc od oe of bi translated">金属类型(铸铁或钢)</li><li id="c613" class="nx ny iq lh b li ol ll om lo on ls oo lw op ma oc od oe of bi translated">切割深度(0.75毫米或1.5毫米)</li><li id="80ec" class="nx ny iq lh b li ol ll om lo on ls oo lw op ma oc od oe of bi translated">进给速度(0.25毫米/转或0.5毫米/转)</li></ul><p id="0458" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我们可以看到我们选择的异常检测模型是否在一组参数上比另一组参数更好地检测失败的工具。我们将通过一次向模型中输入一种类型的参数并观察结果来做到这一点。例如，我们将进给用铸铁制成的切口。那我们就转向钢铁。等等。等等。</p><p id="6f77" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我已经跳过了一个好的代码块(见<a class="ae le" href="https://colab.research.google.com/github/tvhahn/Manufacturing-Data-Science-with-Python/blob/master/Metal%20Machining/1.C_anomaly-results.ipynb" rel="noopener ugc nofollow" target="_blank"> Jupyter笔记本</a>),因为它是重复的。但是，一旦我们为每个独特的切削参数创建了结果数据帧，我们就可以将它们组合成一个简洁的条形图。</p><p id="819d" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">下面是组合每组结果的代码:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nv nw l"/></div></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/de99e1218f4f808cad8a9d1554569334.png" data-original-src="https://miro.medium.com/v2/resize:fit:530/format:webp/1*BmF8K38V6KelgGUtktGFJw.png"/></div></figure><p id="52c9" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">现在我们可以制作漂亮的条形图了。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nv nw l"/></div></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi or"><img src="../Images/c6a2dfe96525254eb2b9ac627d7afdb8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4o7LJFCORoLt_GCkaLUgIA.png"/></div></div></figure><p id="017b" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">显然，这个“最佳”模型发现一些切削参数比其他参数更有用。某些切削参数可以产生携带更多信息和/或具有更高信噪比的信号。</p><p id="90f5" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">在训练过程中，该模型还可以对某些参数产生优于其他参数的偏好。偏好可以是模型构建方式(例如，β参数或编码大小)以及模型训练方式的函数。</p><p id="e9b5" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我怀疑可能存在具有不同参数偏好的模型配置，例如铸铁而不是钢。一组<a class="ae le" href="https://en.wikipedia.org/wiki/Ensemble_learning" rel="noopener ugc nofollow" target="_blank">模型</a>可能会产生更好的结果。这将是进一步研究的一个有趣的领域！</p><h2 id="1b4a" class="mu md iq bd me mv mw dn mi mx my dp mm lo mz na mo ls nb nc mq lw nd ne ms iw bi translated">趋势KL-Divergence分数</h2><p id="9f02" class="pw-post-body-paragraph lf lg iq lh b li nf ka lk ll ng kd ln lo nh lq lr ls ni lu lv lw nj ly lz ma ij bi translated">KL-divergence分数可以按顺序进行趋势分析，以了解我们的异常检测模型是如何工作的。这是我最喜欢的图表——它很漂亮，给人很好的洞察力。</p><p id="7cd9" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">注意:您也可以对输入空间重构误差进行趋势分析，但我们不会在这里这样做。</p><p id="dc3d" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">让我们快速探索一下，看看这些趋势会是什么样子。我们需要一个函数来对子切割进行顺序排序:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="d778" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">现在做一个趋势图。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nv nw l"/></div></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi os"><img src="../Images/210fba779f7f4a011adc4f7e19363aab.png" data-original-src="https://miro.medium.com/v2/resize:fit:762/format:webp/1*pnIvhXjHdhwu_DYUU8U6dw.png"/></div></figure><p id="5ca2" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我们现在有了创建KL-divergence分数随时间变化趋势图所需的所有信息。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="0565" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我们将趋势案例13，这是在钢上进行，速度很慢，是一个浅切口。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nv nw l"/></div></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ot"><img src="../Images/54b5c6291b901b48d71671ea4202f6fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AQB8QFtnlZ1pU2M_EoiaVA.png"/></div></div></figure><p id="c3f6" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">看起来不错！这个模型产生了一个清晰的趋势。然而，正如我们在上一节中所看到的，我们的异常检测模型在某些切削条件下识别刀具异常(失效/不健康/磨损)时确实有些困难。</p><p id="7936" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">让我们看看另一个例子——案例11。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nv nw l"/></div></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ot"><img src="../Images/2d0599cd947d882375d96788ba706603.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E7lOQnu3_qLh7wNJ4GoCqg.png"/></div></div></figure><p id="1fa6" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">通过“降级”区域，您可以看到趋势是如何增加的，但是当它到达红色的“失败”区域时，趋势会迅速下降。为什么？呃，我也不知道具体是什么。趋势末端的样本可能更类似于健康样本…我很想听听你的想法。</p><p id="9e12" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">还有更多的分析可以做…我会留给你。如果你发现什么有趣的东西，请告诉我！</p><h1 id="4d5d" class="mc md iq bd me mf mg mh mi mj mk ml mm kf mn kg mo ki mp kj mq kl mr km ms mt bi translated">进一步的想法</h1><p id="fb9b" class="pw-post-body-paragraph lf lg iq lh b li nf ka lk ll ng kd ln lo nh lq lr ls ni lu lv lw nj ly lz ma ij bi translated">在这个由三部分组成的系列中，我们所做的是使用VAE在工业数据集上构建一种异常检测方法。我毫不怀疑这些方法可以大大改进，其他有趣的领域也可以探索。</p><p id="fe3b" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我希望一些勤奋的研究人员或学生可以利用这项工作作为跳板，或灵感，做一些真正有趣的事情！以下是我有兴趣进一步做的一些事情:</p><ul class=""><li id="667b" class="nx ny iq lh b li lj ll lm lo nz ls oa lw ob ma oc od oe of bi translated">正如我上面提到的，模型集合可能会产生更好的结果。</li><li id="3020" class="nx ny iq lh b li ol ll om lo on ls oo lw op ma oc od oe of bi translated">VAE中的β使它成为一个不纠缠的变分自动编码器。看看编码如何随不同的切削参数而变化，以及编码是否代表独特的特征，这将是很有趣的。</li><li id="9fed" class="nx ny iq lh b li ol ll om lo on ls oo lw op ma oc od oe of bi translated">我在VAE中使用了TCN，但我认为一个常规的卷积神经网络，加上膨胀，也会工作得很好(这是我的直觉)。这将使模型训练更简单。</li><li id="c296" class="nx ny iq lh b li ol ll om lo on ls oo lw op ma oc od oe of bi translated">如果我要重新开始，我会整合更多的模型测试。这些模型测试(如单元测试)将对照不同的切割参数检查模型的性能。这将更容易发现哪些模型在切削参数上具有良好的通用性。</li></ul><h1 id="e70c" class="mc md iq bd me mf mg mh mi mj mk ml mm kf mn kg mo ki mp kj mq kl mr km ms mt bi translated">结论</h1><p id="64ec" class="pw-post-body-paragraph lf lg iq lh b li nf ka lk ll ng kd ln lo nh lq lr ls ni lu lv lw nj ly lz ma ij bi translated">在这篇文章中，我们通过几个可视化来探索我们训练过的VAE模型的性能。我们发现使用KL散度的潜在空间比输入空间的异常检测更有效。</p><p id="1f4a" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">在制造领域使用数据科学和机器学习工具有很强的商业案例。此外，这里演示的原则可以跨许多使用异常检测的领域使用。</p><p id="8c78" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我希望你喜欢这个系列，也许，学到了一些新的东西！</p><h1 id="c207" class="mc md iq bd me mf mg mh mi mj mk ml mm kf mn kg mo ki mp kj mq kl mr km ms mt bi translated">参考</h1><p id="6164" class="pw-post-body-paragraph lf lg iq lh b li nf ka lk ll ng kd ln lo nh lq lr ls ni lu lv lw nj ly lz ma ij bi translated">[1]安，j .，&amp;赵树声(2015)。<a class="ae le" href="http://dm.snu.ac.kr/static/docs/TR/SNUDM-TR-2015-03.pdf" rel="noopener ugc nofollow" target="_blank">使用重构概率的基于变分自动编码器的异常检测</a>。<em class="nn">工业工程专题讲座</em>，<em class="nn"> 2 </em> (1)，1–18。</p><p id="a16d" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">[2]j .戴维斯和m .戈德里奇(2006年6月)。<a class="ae le" href="https://dl.acm.org/doi/pdf/10.1145/1143844.1143874?casa_token=CSQzAhypHQ0AAAAA:WqAGJXokpttfPIStrcXb_2tXdufgXdDu085FVIBhtQA1hLgXZrJGVHThaTBx4tzGUky8KTRuMJqidg" rel="noopener ugc nofollow" target="_blank">精确召回与ROC曲线的关系</a>。在<em class="nn">第23届机器学习国际会议论文集</em>(第233–240页)。</p><p id="95f8" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">[3]t .斋藤和m .雷姆斯迈尔(2015年)。<a class="ae le" href="https://journals.plos.org/plosone/article?id=10.1371/journal.pone.0118432" rel="noopener ugc nofollow" target="_blank">在不平衡数据集上评估二元分类器时，精确召回图比ROC图提供的信息更多</a>。<em class="nn"> PloS one </em>，<em class="nn"> 10 </em> (3)，e0118432。</p></div><div class="ab cl ou ov hu ow" role="separator"><span class="ox bw bk oy oz pa"/><span class="ox bw bk oy oz pa"/><span class="ox bw bk oy oz"/></div><div class="ij ik il im in"><p id="c8d5" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated"><em class="nn">本文原载于</em><a class="ae le" href="https://www.tvhahn.com/posts/anomaly-results/" rel="noopener ugc nofollow" target="_blank"><em class="nn">【tvhahn.com】</em></a><em class="nn">。此外，这项工作是对发表在IJHM </em>  <em class="nn">的</em> <a class="ae le" href="https://www.researchgate.net/publication/350842309_Self-supervised_learning_for_tool_wear_monitoring_with_a_disentangled-variational-autoencoder" rel="noopener ugc nofollow" target="_blank"> <em class="nn">研究的补充。官方的GitHub回购是</em> </a><a class="ae le" href="https://github.com/tvhahn/ml-tool-wear" rel="noopener ugc nofollow" target="_blank"> <em class="nn">这里的</em> </a> <em class="nn">。</em></p><p id="be9d" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated"><em class="nn">除非另有说明，本帖及其内容由作者授权于</em><a class="ae le" href="https://creativecommons.org/licenses/by-sa/4.0/" rel="noopener ugc nofollow" target="_blank"><em class="nn">CC BY-SA 4.0</em></a><em class="nn">。</em></p></div></div>    
</body>
</html>