<html>
<head>
<title>Gallia: A Library for Data Transformation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Gallia:数据转换库</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/gallia-a-library-for-data-transformation-3fafaaa2d8b9?source=collection_archive---------27-----------------------#2021-12-06">https://towardsdatascience.com/gallia-a-library-for-data-transformation-3fafaaa2d8b9?source=collection_archive---------27-----------------------#2021-12-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="ac90" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">用于实际数据转换的模式感知Scala库:ETL、特性工程、HTTP响应等</h2></div><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi kg"><img src="../Images/c757eb59e9c37060da944f1b2627661a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*FbM8E3xGluQ6Vp3B"/></div></div><p class="ks kt gj gh gi ku kv bd b be z dk translated">由<a class="ae kw" href="https://unsplash.com/@sortino?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">约书亚·索蒂诺</a>在<a class="ae kw" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="43c7" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><a class="ae kw" href="https://github.com/galliaproject/gallia-core/blob/master/README.md" rel="noopener ugc nofollow" target="_blank"> Gallia </a>是一个用于通用数据转换的Scala库，重点关注<strong class="kz ir">实用性</strong>、<strong class="kz ir">可读性</strong>和<strong class="kz ir">可伸缩性</strong>(如果需要的话)。</p><p id="129a" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">这是一个个人项目，是我在对现有工具失望多年后开始的。它旨在帮助数据工程师完成工作，而不必在需要时放弃可伸缩性。它还旨在填补像<em class="lt"> pandas </em>这样的库(对于那些重视Scala这样的强大类型系统的人)和<em class="lt"> Spark SQL </em>这样的库(对于那些发现SQL很难理解特定查询复杂性的人)之间的空白。更一般地说，它是为应用程序中的大多数或所有数据转换需求提供一站式范例而创建的。</p><p id="f47b" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">它的执行发生在<strong class="kz ir">两个阶段</strong>，每个阶段遍历一个专用的执行<a class="ae kw" href="https://en.wikipedia.org/wiki/Directed_acyclic_graph" rel="noopener ugc nofollow" target="_blank">有向无环图(DAG) </a>:</p><ol class=""><li id="1135" class="lu lv iq kz b la lb ld le lg lw lk lx lo ly ls lz ma mb mc bi translated">初始的<strong class="kz ir">元</strong>阶段完全忽略数据，并确保转换步骤是一致的(模式方面)。</li><li id="f786" class="lu lv iq kz b la md ld me lg mf lk mg lo mh ls lz ma mb mc bi translated">随后的<strong class="kz ir">数据</strong>阶段，在此阶段数据被实际处理。</li></ol><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div class="gh gi mi"><img src="../Images/707ab08769a6b88387c240e4b25ec1a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:284/0*HLpNZD4B102UnmIU"/></div><p class="ks kt gj gh gi ku kv bd b be z dk translated">图片通过LogoGround授权给Anthony Cros。</p></figure><h1 id="9d78" class="mj mk iq bd ml mm mn mo mp mq mr ms mt jw mu jx mv jz mw ka mx kc my kd mz na bi translated">微不足道的例子</h1><p id="7606" class="pw-post-body-paragraph kx ky iq kz b la nb jr lc ld nc ju lf lg nd li lj lk ne lm ln lo nf lq lr ls ij bi translated">下面是一个非常基本的用法示例:</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="f9ff" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">这样就会成功打印:<em class="lt"> {" </em> <strong class="kz ir"> <em class="lt">姓名</em> </strong> <em class="lt">":"托尼】，</em> <strong class="kz ir"> <em class="lt">年龄</em> </strong> <em class="lt"> ":40} </em></p><p id="2d54" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">但是，由于Gallia支持模式，因此在实际处理任何数据之前，以下操作将会失败:</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="d77c" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">因为递增字符串(通常)是无意义的，初始的“元”阶段将返回一个错误，抱怨字符串不能递增。</p><p id="ac1c" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">注意事项:</p><ul class=""><li id="c212" class="lu lv iq kz b la lb ld le lg lw lk lx lo ly ls ni ma mb mc bi translated"><em class="lt"> JSON </em>因其作为对象符号无处不在而被用于所有示例，然而Gallia并不是<em class="lt"> JSON </em>特定的数据序列化或内存表示(见<a class="ae kw" href="http://github.com/galliaproject/gallia-docs/blob/master/json.md" rel="noopener ugc nofollow" target="_blank"> JSON缺陷</a></li><li id="b604" class="lu lv iq kz b la md ld me lg mf lk mg lo mh ls ni ma mb mc bi translated">这里实际上推断出了模式，这更简洁，但通常并不理想(参见<a class="ae kw" href="https://github.com/galliaproject/gallia-core/blob/master/README.md#schema-metadata" rel="noopener ugc nofollow" target="_blank">改为提供模式</a>)</li></ul><h1 id="7993" class="mj mk iq bd ml mm mn mo mp mq mr ms mt jw mu jx mv jz mw ka mx kc my kd mz na bi translated">更复杂的例子</h1><p id="6642" class="pw-post-body-paragraph kx ky iq kz b la nb jr lc ld nc ju lf lg nd li lj lk ne lm ln lo nf lq lr ls ij bi translated">让我们来看一个更复杂的用法例子。您的老板比尔向您提供了以下电子表格(优雅地被甩为TSV):</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="ng nh l"/></div><p class="ks kt gj gh gi ku kv bd b be z dk translated">雇员</p></figure><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="ng nh l"/></div><p class="ks kt gj gh gi ku kv bd b be z dk translated">项目</p></figure><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="ng nh l"/></div><p class="ks kt gj gh gi ku kv bd b be z dk translated">问题</p></figure><p id="7d51" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">他希望您为公司(<em class="lt"> Initech </em>)的每位员工创建一份报告，并基于以下模板对“W2K”和“W3K”进行项目设计:</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="ng nh l"/></div></figure><h1 id="8434" class="mj mk iq bd ml mm mn mo mp mq mr ms mt jw mu jx mv jz mw ka mx kc my kd mz na bi translated">代码和数据</h1><p id="00cc" class="pw-post-body-paragraph kx ky iq kz b la nb jr lc ld nc ju lf lg nd li lj lk ne lm ln lo nf lq lr ls ij bi translated">您可以使用Gallia和以下代码实现上述结果:</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="4273" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">这个例子的可运行代码可以在github 上找到<a class="ae kw" href="https://github.com/galliaproject/gallia-medium-article" rel="noopener ugc nofollow" target="_blank">。存储库还包含输入和输出数据，以及所有中间顶级模式/数据对的转储，这将有助于澄清任何不明确之处。例如，如果我们考虑上面的第31行(生成<em class="lt"> is_manager </em>字段)，我们可以找到所有的中间体文件，如下所示:</a></p><ul class=""><li id="e0ac" class="lu lv iq kz b la lb ld le lg lw lk lx lo ly ls ni ma mb mc bi translated"><strong class="kz ir">输入</strong>模式:<a class="ae kw" href="https://github.com/galliaproject/gallia-medium-article/blob/master/data/intermediate/30.meta.txt" rel="noopener ugc nofollow" target="_blank">。/data/intermediate/30 . meta . txt</a></li><li id="1f6a" class="lu lv iq kz b la md ld me lg mf lk mg lo mh ls ni ma mb mc bi translated"><strong class="kz ir">输入</strong>数据:<a class="ae kw" href="https://github.com/galliaproject/gallia-medium-article/blob/master/data/intermediate/30.data.json" rel="noopener ugc nofollow" target="_blank">。/data/intermediate/30 . data . JSON</a></li><li id="b267" class="lu lv iq kz b la md ld me lg mf lk mg lo mh ls ni ma mb mc bi translated"><strong class="kz ir">输出</strong>模式:<a class="ae kw" href="https://github.com/galliaproject/gallia-medium-article/blob/master/data/intermediate/31.meta.txt" rel="noopener ugc nofollow" target="_blank">。/data/intermediate/31 . meta . txt</a></li><li id="2629" class="lu lv iq kz b la md ld me lg mf lk mg lo mh ls ni ma mb mc bi translated"><strong class="kz ir">输出</strong>数据:<a class="ae kw" href="https://github.com/galliaproject/gallia-medium-article/blob/master/data/intermediate/31.data.json" rel="noopener ugc nofollow" target="_blank">。/data/intermediate/31 . data . JSON</a></li></ul><p id="edb7" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">请注意，这不是一个标准的Gallia特性，只是为了本文的方便而提供的。还要注意，每个步骤只提供第一个数据实体。</p><p id="38ab" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><strong class="kz ir"> EDIT: </strong>我还增加了一个<a class="ae kw" href="https://github.com/galliaproject/gallia-medium-article/blob/master/src/main/scala/galliamedium/initech/InitechManual.scala" rel="noopener ugc nofollow" target="_blank">手动对应物</a>，可以很容易的和<a class="ae kw" href="https://github.com/galliaproject/gallia-medium-article/blob/master/src/main/scala/galliamedium/initech/InitechGallia.scala" rel="noopener ugc nofollow" target="_blank"> Gallia加工</a>相比。手动对应物专门使用标准库。</p><h1 id="5a93" class="mj mk iq bd ml mm mn mo mp mq mr ms mt jw mu jx mv jz mw ka mx kc my kd mz na bi translated">游戏攻略</h1><p id="f052" class="pw-post-body-paragraph kx ky iq kz b la nb jr lc ld nc ju lf lg nd li lj lk ne lm ln lo nf lq lr ls ij bi translated">上面的转换步骤尽可能不言自明。例如,<code class="fe nj nk nl nm b">.remove(“Employee ID”)</code>就是这个意思:“雇员ID”字段将不再存在。</p><p id="ea09" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">相反，我们将在下面详述一些更复杂的操作。</p><h2 id="f4f7" class="nn mk iq bd ml no np dn mp nq nr dp mt lg ns nt mv lk nu nv mx lo nw nx mz ny bi translated">嵌套操作</h2><p id="26f7" class="pw-post-body-paragraph kx ky iq kz b la nb jr lc ld nc ju lf lg nd li lj lk ne lm ln lo nf lq lr ls ij bi translated">第一个嵌套操作很简单:</p><pre class="kh ki kj kk gt nz nm oa ob aw oc bi"><span id="58eb" class="nn mk iq nm b gy od oe l of og">.nest(“first”, “middle”, “last”).under(“name”)</span></pre><p id="f1d7" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">它基本上把一个实体:</p><p id="1fa0" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><em class="lt">{</em><strong class="kz ir"><em class="lt">【第一个</em> </strong> <em class="lt">”:【彼得】、</em> <strong class="kz ir"> <em class="lt">中间</em> </strong> <em class="lt">:【罗恩】、</em> <strong class="kz ir"> <em class="lt">最后</em> </strong> <em class="lt">:【长臂猿】、…} </em></p><p id="edf8" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">到…里面</p><p id="258e" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><em class="lt">{</em><strong class="kz ir"><em class="lt">姓名</em></strong><em class="lt">:{</em><strong class="kz ir"><em class="lt"/></strong><em class="lt">【彼得】，</em> <strong class="kz ir"> <em class="lt">中间</em> </strong> <em class="lt">【罗恩】，</em> <strong class="kz ir"> <em class="lt">最后</em> </strong> <em class="lt">【长臂猿】}，… } </em></p><p id="f06c" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">然而，第二个嵌套操作(有意地)更加复杂:</p><pre class="kh ki kj kk gt nz nm oa ob aw oc bi"><span id="949d" class="nn mk iq nm b gy od oe l of og">.renest{ <strong class="nm ir">_.filterKeys(_.startsWith(“Address”))</strong> }.usingSeparator(“ “)</span></pre><p id="aced" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">它利用了两种机制:</p><ul class=""><li id="a7d0" class="lu lv iq kz b la lb ld le lg lw lk lx lo ly ls ni ma mb mc bi translated">通过谓词选择一个键的子集，即这里的<code class="fe nj nk nl nm b">startsWith(“Address”)</code></li><li id="5eff" class="lu lv iq kz b la md ld me lg mf lk mg lo mh ls ni ma mb mc bi translated">使用一个普通的分隔符重新嵌套，即这里的空格字符</li></ul><p id="976e" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">目标选择集中在仅有的四个带有“地址”前缀的字段上。同时，重定机制使用提供的分隔符来重建隐含的嵌套:</p><p id="a529" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">因此我们从:</p><pre class="kh ki kj kk gt nz nm oa ob aw oc bi"><span id="7b5c" class="nn mk iq nm b gy od oe l of og">{<br/>  ...<br/>  "Address number":  9,<br/>  "Address street": "Channel Street",<br/>  "Address city"  : "Houston",<br/>  "Address zip"   :  77001,<br/>  ...<br/>}</span></pre><p id="302c" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">收件人:</p><pre class="kh ki kj kk gt nz nm oa ob aw oc bi"><span id="ac12" class="nn mk iq nm b gy od oe l of og">{<br/>  ...<br/>  "Address": {<br/>    "number":  9,<br/>    "street": "Channel Street",<br/>    "city"  : "Houston",<br/>    "zip"   :  77001<br/>  },<br/>  ...<br/>}</span></pre><p id="7d6d" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">请注意，这是处理已被“展平”以适合矩形格式的数据的典型方式。</p><p id="9fe7" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">更多关于Gallia重新嵌套的细节可以在<a class="ae kw" href="https://github.com/galliaproject/gallia-core/blob/master/README.md#renesting-tables" rel="noopener ugc nofollow" target="_blank">这里</a>找到</p><h2 id="bb3d" class="nn mk iq bd ml no np dn mp nq nr dp mt lg ns nt mv lk nu nv mx lo nw nx mz ny bi translated">进行操作</h2><pre class="kh ki kj kk gt nz nm oa ob aw oc bi"><span id="6704" class="nn mk iq nm b gy od oe l of og">issues.bring(projects, target = "Name", via = "Project ID" &lt;~&gt; "ID")</span></pre><p id="16d2" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">该语句可以用简单的英语理解为“通过匹配字段将字段<em class="lt">名称</em>从<em class="lt">项目</em>带入<em class="lt">问题</em>”。这里，我们必须显式地命名匹配的字段，因为它们的键不同(<em class="lt">"项目ID" </em> vs <em class="lt"> "ID" </em>)，否则它们可能会被猜到。</p><p id="cd6a" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">"<em class="lt">▲</em>"是一种特殊类型的左连接。当一个人只想用来自另一个数据源的几个字段来扩充数据时，可以方便地使用它。这与以下情况形成对比:</p><ul class=""><li id="e467" class="lu lv iq kz b la lb ld le lg lw lk lx lo ly ls ni ma mb mc bi translated">Gallia <em class="lt"> join，</em>对应于同名的<em class="lt"> SQL </em>操作，因此意味着潜在的反规范化。</li><li id="f81c" class="lu lv iq kz b la md ld me lg mf lk mg lo mh ls ni ma mb mc bi translated">A Gallia <em class="lt"> co-group </em>，对应于同名的<em class="lt"> Spark </em>操作:没有反规格化，但是分组的边分别嵌套在<em class="lt"> _left </em>和<em class="lt"> _right </em>字段下。</li></ul><h2 id="2bc7" class="nn mk iq bd ml no np dn mp nq nr dp mt lg ns nt mv lk nu nv mx lo nw nx mz ny bi translated">透视操作(嵌套)</h2><pre class="kh ki kj kk gt nz nm oa ob aw oc bi"><span id="c1e2" class="nn mk iq nm b gy od oe l of og">.transformObjects(“issues”).using {<br/>  _ .countBy(“Status”) // defaults to “_count”<br/>    .pivot(_count).column(“Status”)<br/>      .asNewKeys(“OPEN”, "IN_PROGRESS", “RESOLVED”) }</span></pre><p id="9971" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">这里要注意的第一件事是，我们将转换应用于嵌套元素，而不是每个实体根处的数据元素。下划线在Scala中有特殊的含义，因此对应于嵌套在<em class="lt"> issues </em>字段<em class="lt"> </em>下的每个实体(在前面的group-by Employee ID操作中，参见<a class="ae kw" href="https://github.com/galliaproject/gallia-medium-article/blob/master/data/intermediate/50.meta.txt" rel="noopener ugc nofollow" target="_blank">中间元数据</a>和<a class="ae kw" href="https://github.com/galliaproject/gallia-medium-article/blob/master/data/intermediate/50.data.json" rel="noopener ugc nofollow" target="_blank">数据</a>)。</p><p id="0255" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">从这里开始，对于所有这样的“发布”实体，我们按状态进行计数(<em class="lt">打开</em>、<em class="lt">进行中</em>或<em class="lt">已解决</em>)，然后对该计数进行透视。也就是说，如果这些是给定受让人的问题:</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="e887" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">那么计数操作导致:</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="e18c" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">该支点导致:</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="6667" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">应该注意的是，<code class="fe nj nk nl nm b">.asNewKeys(“OPEN”, “IN_PROGRESS”, “RESOLVED”</code>部分是必需的，因为——非常重要Gallia在整个转换过程中维护一个模式。在目前的情况下，<em class="lt">状态</em>的值只能在查看整个数据集后<strong class="kz ir">才能知道，因此必须提前提供。关于这个问题的更多细节也可以在文档的<a class="ae kw" href="https://github.com/galliaproject/gallia-core/blob/master/README.md#schema-metadata" rel="noopener ugc nofollow" target="_blank">模式</a>和【T21(DAG)】标题部分找到。</strong></p><h1 id="1205" class="mj mk iq bd ml mm mn mo mp mq mr ms mt jw mu jx mv jz mw ka mx kc my kd mz na bi translated">未来文章</h1><p id="73da" class="pw-post-body-paragraph kx ky iq kz b la nb jr lc ld nc ju lf lg nd li lj lk ne lm ln lo nf lq lr ls ij bi translated">在以后的文章中，我想讨论使用替代技术实现相同结果的方法，如<em class="lt"> SQL、Spark sql、pandas、</em>等(与<a class="ae kw" href="https://github.com/galliaproject/gallia-docs/blob/master/bounties.md" rel="noopener ugc nofollow" target="_blank">这个想法</a>相关)</p><p id="26f2" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我还想讨论如何使用内置Gallia的<em class="lt"> Spark RDDs </em>扩展上述转换(参见<a class="ae kw" href="https://github.com/galliaproject/gallia-core/blob/master/README.md#spark" rel="noopener ugc nofollow" target="_blank">文档</a>)。上面的例子是有意忽略的，但是如果数据包含数十亿行，代码将不能像现在这样处理它。</p><h1 id="4371" class="mj mk iq bd ml mm mn mo mp mq mr ms mt jw mu jx mv jz mw ka mx kc my kd mz na bi translated">结论</h1><p id="f62b" class="pw-post-body-paragraph kx ky iq kz b la nb jr lc ld nc ju lf lg nd li lj lk ne lm ln lo nf lq lr ls ij bi translated">对于现实生活中更复杂的例子，<a class="ae kw" href="https://github.com/galliaproject/gallia-dbnsfp" rel="noopener ugc nofollow" target="_blank">参见这个</a>知识库。另请参见<a class="ae kw" href="https://github.com/galliaproject/gallia-core/blob/master/README.md#examples" rel="noopener ugc nofollow" target="_blank">示例的完整列表</a>。</p><p id="3dfd" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">Gallia的主要<strong class="kz ir">优势</strong>可以总结如下:</p><ul class=""><li id="77fa" class="lu lv iq kz b la lb ld le lg lw lk lx lo ly ls ni ma mb mc bi translated">提供最常见/有用的数据操作，或者至少<a class="ae kw" href="https://github.com/galliaproject/gallia-docs/blob/master/tasks.md" rel="noopener ugc nofollow" target="_blank">预定</a>。</li><li id="9df3" class="lu lv iq kz b la md ld me lg mf lk mg lo mh ls ni ma mb mc bi translated">领域专家至少应该能够部分理解的可读DSL。</li><li id="144e" class="lu lv iq kz b la md ld me lg mf lk mg lo mh ls ni ma mb mc bi translated">扩展不是事后的想法，需要时可以利用<em class="lt">Spark rdd</em>。</li><li id="67bb" class="lu lv iq kz b la md ld me lg mf lk mg lo mh ls ni ma mb mc bi translated">元感知，意味着不一致的转换会尽可能地被拒绝(例如，不能使用已经被移除的字段)。</li><li id="d32e" class="lu lv iq kz b la md ld me lg mf lk mg lo mh ls ni ma mb mc bi translated">可以处理单个实体，而不仅仅是其集合；也就是说，没有必要创建一个实体的“虚拟”集合来操作那个实体。</li><li id="5028" class="lu lv iq kz b la md ld me lg mf lk mg lo mh ls ni ma mb mc bi translated">可以以自然的方式处理任何多重性的嵌套实体。</li><li id="9672" class="lu lv iq kz b la md ld me lg mf lk mg lo mh ls ni ma mb mc bi translated">宏<a class="ae kw" href="https://github.com/galliaproject/gallia-macros" rel="noopener ugc nofollow" target="_blank">可用于</a>与case类层次的平滑集成。</li><li id="4977" class="lu lv iq kz b la md ld me lg mf lk mg lo mh ls ni ma mb mc bi translated">提供灵活的目标选择，即作用于哪个(哪些)字段，范围从显式引用到实际查询，包括涉及嵌套时。</li><li id="c169" class="lu lv iq kz b la md ld me lg mf lk mg lo mh ls ni ma mb mc bi translated">执行DAG是充分抽象的，它的优化是一个很好分离的关注点(例如谓词下推、剪枝等)；但是请注意，目前很少有这样的优化。</li></ul><p id="913e" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">Gallia仍然是一个相当新的项目，因此我期待着它的任何反馈！主存储库可以在github 上找到<a class="ae kw" href="https://github.com/galliaproject/gallia-core" rel="noopener ugc nofollow" target="_blank">，而</a><a class="ae kw" href="https://github.com/galliaproject" rel="noopener ugc nofollow" target="_blank">父组织</a>包含了所有相关的存储库。</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div class="gh gi mi"><img src="../Images/707ab08769a6b88387c240e4b25ec1a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:284/0*HLpNZD4B102UnmIU"/></div><p class="ks kt gj gh gi ku kv bd b be z dk translated"><em class="kf">根据Anthony Cros的许可，图片来自LogoGround。</em></p></figure></div><div class="ab cl oh oi hu oj" role="separator"><span class="ok bw bk ol om on"/><span class="ok bw bk ol om on"/><span class="ok bw bk ol om"/></div><div class="ij ik il im in"><h1 id="cab3" class="mj mk iq bd ml mm oo mo mp mq op ms mt jw oq jx mv jz or ka mx kc os kd mz na bi translated">脚注</h1><p id="978d" class="pw-post-body-paragraph kx ky iq kz b la nb jr lc ld nc ju lf lg nd li lj lk ne lm ln lo nf lq lr ls ij bi translated">[1]:如果提供了类之间的关系(例如通过<em class="lt">隐含</em>)，则不会出现这种情况，参见两个相关任务:</p><ul class=""><li id="c38c" class="lu lv iq kz b la lb ld le lg lw lk lx lo ly ls ni ma mb mc bi translated"><a class="ae kw" href="https://github.com/galliaproject/gallia-docs/blob/master/tasks.md#t210426094707" rel="noopener ugc nofollow" target="_blank">提供关系(<em class="lt"> t210426094707 </em> ) </a></li><li id="c35f" class="lu lv iq kz b la md ld me lg mf lk mg lo mh ls ni ma mb mc bi translated">更一般的:<a class="ae kw" href="https://github.com/galliaproject/gallia-docs/blob/master/tasks.md#t210124100546" rel="noopener ugc nofollow" target="_blank">语义(<em class="lt"> t210124100546 </em> ) </a></li></ul><p id="49d5" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">还要注意的是，<em class="lt">带来</em> / <em class="lt">加入</em> / <em class="lt">协同组</em>对多个按键的操作还不可用:参见任务<a class="ae kw" href="https://github.com/galliaproject/gallia-docs/blob/master/tasks.md#t210304115501" rel="noopener ugc nofollow" target="_blank">多个按键(<em class="lt"> t210304115501 </em> ) </a>。解决方法是生成一个临时字段。</p><p id="7d9a" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">[2]: <em class="lt">左连接</em>和<em class="lt">左连接</em>功能相同，如果右侧没有多个匹配的话。</p><p id="f45a" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">[3]:如果该字段被显式设置为一个<em class="lt">枚举，</em>就可以避免这种情况，因为我们使用了模式推断。Gallia将来也可能提供“不透明物体”:参见相应的<a class="ae kw" href="https://github.com/galliaproject/gallia-docs/blob/master/tasks.md#t210202172304" rel="noopener ugc nofollow" target="_blank">任务(<em class="lt"> t210202172304 </em> ) </a></p></div></div>    
</body>
</html>