<html>
<head>
<title>BigQuery Stored Procedure for Permutation Test</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用于排列测试的BigQuery存储过程</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/bigquery-stored-procedure-for-permutation-test-35597d6379e4?source=collection_archive---------21-----------------------#2021-05-04">https://towardsdatascience.com/bigquery-stored-procedure-for-permutation-test-35597d6379e4?source=collection_archive---------21-----------------------#2021-05-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e607" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在Google BigQuery SQL中运行置换测试的简单方法</h2></div><p id="cb40" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi le translated">存储的过程允许我们执行打包成一个“函数”的多个<strong class="kk iu">Google biqquery SQL</strong>操作。了解<strong class="kk iu">如何使用存储过程快速有效地对任何数据集应用置换测试</strong>。</p><blockquote class="ln lo lp"><p id="6603" class="ki kj lq kk b kl km ju kn ko kp jx kq lr ks kt ku ls kw kx ky lt la lb lc ld im bi translated">只需要密码？从这里开始别忘了启动它！⭐️</p></blockquote><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="gh gi lv"><img src="../Images/c29c1a618da8e924ac3d51a221d5f03a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oknITwIDvVCDufD19ltzOA.jpeg"/></div></div><p class="mh mi gj gh gi mj mk bd b be z dk translated">向您的BigQuery SQL pantry添加另一罐技巧|照片由<a class="ae lu" href="https://unsplash.com/@luisabrimble?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Luisa Brimble </a>在<a class="ae lu" href="https://unsplash.com/s/photos/pantry?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上发布</p></figure></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><p id="fef1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我还有几个BigQuery教程:</p><div class="ms mt gp gr mu mv"><a rel="noopener follow" target="_blank" href="/advanced-random-sampling-in-bigquery-sql-7d4483b580bb"><div class="mw ab fo"><div class="mx ab my cl cj mz"><h2 class="bd iu gy z fp na fr fs nb fu fw is bi translated">BigQuery SQL中的高级随机采样</h2><div class="nc l"><h3 class="bd b gy z fp na fr fs nb fu fw dk translated">了解如何以可重现的方式对BigQuery表中的行进行采样</h3></div><div class="nd l"><p class="bd b dl z fp na fr fs nb fu fw dk translated">towardsdatascience.com</p></div></div><div class="ne l"><div class="nf l ng nh ni ne nj mf mv"/></div></div></a></div><div class="ms mt gp gr mu mv"><a rel="noopener follow" target="_blank" href="/loops-in-bigquery-db137e128d2d"><div class="mw ab fo"><div class="mx ab my cl cj mz"><h2 class="bd iu gy z fp na fr fs nb fu fw is bi translated">BigQuery中的循环</h2><div class="nc l"><h3 class="bd b gy z fp na fr fs nb fu fw dk translated">了解如何使用BigQuery脚本来计算斐波那契数</h3></div><div class="nd l"><p class="bd b dl z fp na fr fs nb fu fw dk translated">towardsdatascience.com</p></div></div><div class="ne l"><div class="nk l ng nh ni ne nj mf mv"/></div></div></a></div><div class="ms mt gp gr mu mv"><a rel="noopener follow" target="_blank" href="/load-files-faster-into-bigquery-94355c4c086a"><div class="mw ab fo"><div class="mx ab my cl cj mz"><h2 class="bd iu gy z fp na fr fs nb fu fw is bi translated">将文件更快地加载到BigQuery中</h2><div class="nc l"><h3 class="bd b gy z fp na fr fs nb fu fw dk translated">针对摄取的CSV、GZIP、AVRO和拼花文件类型进行基准测试</h3></div><div class="nd l"><p class="bd b dl z fp na fr fs nb fu fw dk translated">towardsdatascience.com</p></div></div><div class="ne l"><div class="nl l ng nh ni ne nj mf mv"/></div></div></a></div></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><blockquote class="nm"><p id="c5cc" class="nn no it bd np nq nr ns nt nu nv ld dk translated">要获得所有媒体文章的完整访问权限，包括我的文章，请考虑在此订阅<a class="ae lu" href="https://niczky12.medium.com/membership" rel="noopener"/>。</p></blockquote><h1 id="d309" class="nw nx it bd ny nz oa ob oc od oe of og jz oh ka oi kc oj kd ok kf ol kg om on bi translated">什么是存储过程？</h1><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="gh gi oo"><img src="../Images/032514fe6799bf37418572028161647d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nGc_6Vs0gAEs4BKQUtmKlQ.jpeg"/></div></div><p class="mh mi gj gh gi mj mk bd b be z dk translated">不，存储过程不存储在软盘上|照片由<a class="ae lu" href="https://unsplash.com/@thefredyjacob?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Fredy Jacob </a>在<a class="ae lu" href="https://unsplash.com/s/photos/memory?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="bb40" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在BigQuery中，可以编写自定义，<strong class="kk iu">用户自定义函数</strong>(UDF)。这些函数非常棒，因为您可以减少代码中的重复，使代码对其他人更具可读性。然而，你也可以在BQ 中编写<strong class="kk iu">脚本。这包括循环、if语句、变量声明等。不允许在函数中使用它，因为函数是作用于表元素的，而不是作用于脚本中的变量。</strong></p><p id="482c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这就是存储过程的用武之地。把它们看作是函数的等价物，但不是脚本的等价物。有了它们，您可以重复所有复杂的SQL逻辑，即使它们包括变量和for循环的赋值。</p><blockquote class="nm"><p id="47b8" class="nn no it bd np nq nr ns nt nu nv ld dk translated">这篇来自Google Cloud 的<a class="ae lu" href="https://cloud.google.com/blog/products/data-analytics/command-and-control-now-easier-in-bigquery-with-scripting-and-stored-procedures" rel="noopener ugc nofollow" target="_blank">文章介绍了存储过程的概念，如果你需要复习BigQuery脚本，</a><a class="ae lu" href="https://cloud.google.com/bigquery/docs/reference/standard-sql/scripting" rel="noopener ugc nofollow" target="_blank">这里有关于如何编写循环和条件的官方文档</a>。</p></blockquote><p id="9cb4" class="pw-post-body-paragraph ki kj it kk b kl op ju kn ko oq jx kq kr or kt ku kv os kx ky kz ot lb lc ld im bi translated">谈到存储过程，有几个问题。最大的问题是它们可以接受一个或多个输入，但是输出必须是声明的变量。例如，要运行文档中的示例，我们必须首先声明一个适当的变量来存储结果:</p><figure class="lw lx ly lz gt ma"><div class="bz fp l di"><div class="ou ov l"/></div><p class="mh mi gj gh gi mj mk bd b be z dk translated">这个例子摘自<a class="ae lu" href="https://cloud.google.com/blog/products/data-analytics/command-and-control-now-easier-in-bigquery-with-scripting-and-stored-procedures" rel="noopener ugc nofollow" target="_blank">官方公告</a>。</p></figure><blockquote class="ln lo lp"><p id="b67e" class="ki kj lq kk b kl km ju kn ko kp jx kq lr ks kt ku ls kw kx ky lt la lb lc ld im bi translated">如果你不知道上面的程序在做什么，也不用担心。我们稍后会在这里做一个例子。</p></blockquote><p id="a29a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一旦您用<code class="fe ow ox oy oz b">CREATE PROCEDURE</code>命令创建了您的过程，它将像BigQuery中的任何其他表一样显示，并且您将能够用通常的<code class="fe ow ox oy oz b">dataset.procedure()</code>符号调用它。</p><p id="bc5f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们看看这一切是如何工作的。</p><h1 id="927a" class="nw nx it bd ny nz oa ob oc od oe of og jz pa ka oi kc pb kd ok kf pc kg om on bi translated">带有存储过程的斐波那契数</h1><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="gh gi pd"><img src="../Images/2c417e54b39c42313d3e7df4b8c4957f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*91T1t_JUXmJKUS-DdU-jOQ.jpeg"/></div></div><p class="mh mi gj gh gi mj mk bd b be z dk translated">斐波那契无处不在|照片由<a class="ae lu" href="https://unsplash.com/@20ymn17?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Yair MeJA</a>在<a class="ae lu" href="https://unsplash.com/s/photos/sunflower?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="9c81" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我总是发现，如果例子中的逻辑很容易理解，那么例子是最好的。为此，我将创建一个存储过程，当调用时，<strong class="kk iu">计算第n个斐波纳契数</strong>。</p><p id="d522" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">作为复习，斐波纳契数列是一个自然数序列，其中第n个元素由<code class="fe ow ox oy oz b">F(n)</code>表示，并由<code class="fe ow ox oy oz b">F(n) = F(n-1) + F(n-2)</code>和<code class="fe ow ox oy oz b"> F(0) = 0</code>以及<code class="fe ow ox oy oz b">F(1) = 1</code>定义。所以你得到:0，1，1，2，3，5，8，13…</p><p id="4b73" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了做到这一点，我们将首先使用脚本来完成，然后将其包装在一个过程中。我们需要做的是:</p><ol class=""><li id="23d5" class="pe pf it kk b kl km ko kp kr pg kv ph kz pi ld pj pk pl pm bi translated"><strong class="kk iu">初始化我们的变量</strong>——我们需要记录我们已经计算了多少个数字，以及何时完成计算</li><li id="ca64" class="pe pf it kk b kl pn ko po kr pp kv pq kz pr ld pj pk pl pm bi translated">做一个<strong class="kk iu"> for循环</strong>，其中每一步我们<strong class="kk iu">更新我们当前跟踪的2个数字</strong></li><li id="753b" class="pe pf it kk b kl pn ko po kr pp kv pq kz pr ld pj pk pl pm bi translated"><strong class="kk iu">选择我们的答案</strong>并打印到控制台</li></ol><figure class="lw lx ly lz gt ma"><div class="bz fp l di"><div class="ou ov l"/></div></figure><p id="dec8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我在上面的脚本中添加了一堆注释，所以要确保你明白是怎么回事。</p><blockquote class="nm"><p id="d23b" class="nn no it bd np nq nr ns nt nu nv ld dk translated">我总是建议先写脚本，然后把它改成存储过程。您会发现这样调试容易多了。</p></blockquote><p id="023d" class="pw-post-body-paragraph ki kj it kk b kl op ju kn ko oq jx kq kr or kt ku kv os kx ky kz ot lb lc ld im bi translated">这些关键字执行以下操作:</p><ul class=""><li id="4649" class="pe pf it kk b kl km ko kp kr pg kv ph kz pi ld ps pk pl pm bi translated"><code class="fe ow ox oy oz b">DECLARE</code>创建一个具有特定类型的<strong class="kk iu">新变量，并将其设置为默认值</strong></li><li id="8efa" class="pe pf it kk b kl pn ko po kr pp kv pq kz pr ld ps pk pl pm bi translated"><code class="fe ow ox oy oz b">SET</code> <strong class="kk iu">将已经声明的变量</strong>更新为新值</li><li id="6ab9" class="pe pf it kk b kl pn ko po kr pp kv pq kz pr ld ps pk pl pm bi translated"><code class="fe ow ox oy oz b">WHILE &lt;cond&gt; DO</code>和<code class="fe ow ox oy oz b">END WHILE</code> <strong class="kk iu">缠绕我们的while循环</strong>。</li><li id="66f5" class="pe pf it kk b kl pn ko po kr pp kv pq kz pr ld ps pk pl pm bi translated"><code class="fe ow ox oy oz b">SELECT</code>是你的<strong class="kk iu">普通SQL语句</strong>打印到控制台的答案</li></ul><p id="91a3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们运行上面的代码，我们会将<code class="fe ow ox oy oz b">13</code>打印到控制台，这是第7个斐波那契数列的正确答案。通过更改代码的第一行并将<code class="fe ow ox oy oz b">i</code>设置为其他值来尝试其他数字。</p><p id="2c13" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在剩下要做的就是将上述内容包装在一个过程中，并将其存储在一个数据集中。我们是这样做的:</p><figure class="lw lx ly lz gt ma"><div class="bz fp l di"><div class="ou ov l"/></div></figure><p id="d6fc" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">变化不大，但有几件重要的事情需要注意:</p><ul class=""><li id="4bb4" class="pe pf it kk b kl km ko kp kr pg kv ph kz pi ld ps pk pl pm bi translated">我们<strong class="kk iu">通过<code class="fe ow ox oy oz b">CREATE PROCEDURE</code>声明我们的过程</strong>,后面是数据集和我们想要存储它的过程名。<em class="lq">确保您已经创建了数据集</em> <code class="fe ow ox oy oz b"><em class="lq">ds</em></code> <em class="lq">！</em></li><li id="1d35" class="pe pf it kk b kl pn ko po kr pp kv pq kz pr ld ps pk pl pm bi translated">我们必须<strong class="kk iu">声明我们的过程输入</strong>—<code class="fe ow ox oy oz b">i INT64</code>在过程的顶部。</li><li id="dc15" class="pe pf it kk b kl pn ko po kr pp kv pq kz pr ld ps pk pl pm bi translated">我们对它的输出做同样的事情:<code class="fe ow ox oy oz b">OUT answer INT64</code>。</li><li id="1808" class="pe pf it kk b kl pn ko po kr pp kv pq kz pr ld ps pk pl pm bi translated">输入和输出不再需要在过程内部声明，所以我们<code class="fe ow ox oy oz b">SET</code>将答案设为0，而不是使用默认值。</li><li id="58db" class="pe pf it kk b kl pn ko po kr pp kv pq kz pr ld ps pk pl pm bi translated">我们<strong class="kk iu">将整个脚本</strong>包装在<code class="fe ow ox oy oz b">BEGIN</code> <code class="fe ow ox oy oz b">END</code>语句中。</li></ul><p id="e726" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您运行上面的代码，您应该会得到类似于:<em class="lq">该语句创建了一个名为your-project-name.ds.fibonacci的新过程。</em></p><p id="43d6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了使用这个过程，我们需要声明一个整数变量和<code class="fe ow ox oy oz b">CALL</code>过程来填充它。</p><figure class="lw lx ly lz gt ma"><div class="bz fp l di"><div class="ou ov l"/></div></figure><p id="9d25" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你都做对了，你应该得到:55 (8+13 =21，13+21 = 34，21+34=55)。🎉</p><p id="4b05" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">仅此而已。您现在知道了如何使用BigQuery脚本编写存储过程。给自己一个读到这里的掌声吧！</p><figure class="lw lx ly lz gt ma"><div class="bz fp l di"><div class="pt ov l"/></div><p class="mh mi gj gh gi mj mk bd b be z dk translated">我想，即使是岩石也赞同BigQuery过程… | <a class="ae lu" href="https://media.giphy.com/media/ZU9QbQtuI4Xcc/giphy.gif" rel="noopener ugc nofollow" target="_blank">来源</a></p></figure><h1 id="5646" class="nw nx it bd ny nz oa ob oc od oe of og jz pa ka oi kc pb kd ok kf pc kg om on bi translated">什么是排列测试？</h1><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="gh gi pu"><img src="../Images/b943cae17bf6d5fb10e9be4945b4c9d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LhC_ILTms1ARBFl8xdW3Ew.jpeg"/></div></div><p class="mh mi gj gh gi mj mk bd b be z dk translated">由<a class="ae lu" href="https://unsplash.com/@carlos_ruizh?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">卡洛斯·鲁伊斯·华曼</a>在<a class="ae lu" href="https://unsplash.com/s/photos/alpaca?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="60d4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我听到你在说什么了。"<strong class="kk iu">这些都很酷，但为什么有用呢？</strong>”。好吧，如果我告诉你，你可以用SQL在一些巨大的数据集上运行一些超级的统计测试，而且很便宜，会怎么样呢？这正是我们在这里要做的😉！</p><p id="7ea2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我知道我不会很好地解释什么是排列测试，所以看看Jared Wilber的这个很棒的网站<a class="ae lu" href="https://www.jwilber.me/permutationtest/" rel="noopener ugc nofollow" target="_blank">,在那里你会读到一个羊驼洗发水的实验。</a></p><p id="968b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">简而言之，这就是排列测试:</p><ul class=""><li id="98b2" class="pe pf it kk b kl km ko kp kr pg kv ph kz pi ld ps pk pl pm bi translated">无效假设是两组的统计数据相同。</li><li id="fcf8" class="pe pf it kk b kl pn ko po kr pp kv pq kz pr ld ps pk pl pm bi translated">你用统计学来衡量差异(在我们的例子中是指)。</li><li id="ebf1" class="pe pf it kk b kl pn ko po kr pp kv pq kz pr ld ps pk pl pm bi translated">然后，假设零假设是真的，你在2组之间排列观察。这里的逻辑是，如果零假设确实是真的，那么你如何给你的实验对象贴上标签并不重要。</li><li id="e44d" class="pe pf it kk b kl pn ko po kr pp kv pq kz pr ld ps pk pl pm bi translated">然后你数一数有多少次你观察到排列的统计差异比正确标记的设置更极端。</li><li id="fc53" class="pe pf it kk b kl pn ko po kr pp kv pq kz pr ld ps pk pl pm bi translated">这一比率将给出您的p值，即我们由于随机运气观察到这样或更极端值的概率。</li><li id="3713" class="pe pf it kk b kl pn ko po kr pp kv pq kz pr ld ps pk pl pm bi translated">如果p值很低(例如&lt; 5%) then you reject the null hypothesis.</li></ul><p id="4784" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">But as I said, <a class="ae lu" href="https://www.jwilber.me/permutationtest/" rel="noopener ugc nofollow" target="_blank"> Jared的网站</a>做得更好，所以请去看看。</p><h1 id="154a" class="nw nx it bd ny nz oa ob oc od oe of og jz pa ka oi kc pb kd ok kf pc kg om on bi translated">使用BigQuery SQL进行排列测试</h1><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="gh gi pv"><img src="../Images/69c1743f527c7a37b57bd019ff0fc5e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4HQvy52rgcZ4URoZxOSVpw.jpeg"/></div></div><p class="mh mi gj gh gi mj mk bd b be z dk translated">使用BigQuery的强大功能，我们可以快速有效地调整数据集|图片来自<a class="ae lu" href="https://unsplash.com/@amoltyagi2?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Amol ty agi</a>on<a class="ae lu" href="https://unsplash.com/s/photos/shuffle?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></p></figure><p id="cd4f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我再次建议，在用程序把事情复杂化之前，先弄清楚你的脚本的<strong class="kk iu">逻辑。在我们做任何事情之前，我们需要设定一些要求。我们需要一个至少有两列的表:一列是我们要取平均值的值，另一列是我们的组标签的0和1。我们还假设我们的样本大小相等。这不是问题，因为我们将使用BigQuery中iris数据集的子集，其中Virginica和Versicolor物种都有50个观察值。</strong></p><p id="7af5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们准备好实施我们的计划了。这是我们要做的:</p><ol class=""><li id="1b58" class="pe pf it kk b kl km ko kp kr pg kv ph kz pi ld pj pk pl pm bi translated"><strong class="kk iu">将我们的表格列</strong>重命名为measurement and treatment(0和1 ),以使脚本的其余部分<strong class="kk iu">更加一致</strong>。</li><li id="4877" class="pe pf it kk b kl pn ko po kr pp kv pq kz pr ld pj pk pl pm bi translated">添加另一个<code class="fe ow ox oy oz b">row_id</code>列<strong class="kk iu">以确保我们能够以一种简单的方式对</strong>进行采样。我在这里解释了我们如何以及为什么要这样做<a class="ae lu" rel="noopener" target="_blank" href="/advanced-random-sampling-in-bigquery-sql-7d4483b580bb">。</a></li><li id="e225" class="pe pf it kk b kl pn ko po kr pp kv pq kz pr ld pj pk pl pm bi translated"><strong class="kk iu">用整数列表进行交叉连接</strong>——每个置换样本一个。</li><li id="38c3" class="pe pf it kk b kl pn ko po kr pp kv pq kz pr ld pj pk pl pm bi translated">记录原始表格的<strong class="kk iu">观察差异</strong>。</li><li id="e3c8" class="pe pf it kk b kl pn ko po kr pp kv pq kz pr ld pj pk pl pm bi translated">记录我们排列的<strong class="kk iu">平均差异</strong>。</li><li id="3ce9" class="pe pf it kk b kl pn ko po kr pp kv pq kz pr ld pj pk pl pm bi translated"><strong class="kk iu">计算我们得到的差高于或等于我们原始均值差的次数的比率</strong>。</li></ol><p id="9572" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是SQL的样子:</p><figure class="lw lx ly lz gt ma"><div class="bz fp l di"><div class="ou ov l"/></div></figure><p id="1fa5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以上只是普通的SQL，我一直建议你以这种方式开始。当我们想把它变成一个程序时，事情就变得复杂了…</p><p id="b84a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们希望我们的过程接受下面的<strong class="kk iu">输入</strong>:</p><ul class=""><li id="3e59" class="pe pf it kk b kl km ko kp kr pg kv ph kz pi ld ps pk pl pm bi translated">我们要对其应用测试的表的名称。</li><li id="7c37" class="pe pf it kk b kl pn ko po kr pp kv pq kz pr ld ps pk pl pm bi translated">包含测量值的列的名称。</li><li id="9113" class="pe pf it kk b kl pn ko po kr pp kv pq kz pr ld ps pk pl pm bi translated">包含我们的治疗标志的列的名称。</li><li id="1385" class="pe pf it kk b kl pn ko po kr pp kv pq kz pr ld ps pk pl pm bi translated">我们想要进行的排列的数量。</li></ul><p id="c5ee" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">据我所知，我们不能只是将表名粘贴到脚本中，所以我们将在BigQuery中使用可爱且非常强大的<code class="fe ow ox oy oz b">EXECUTE IMMEDIATE</code>命令来完成这项工作。这个家伙基本上运行一个字符串作为SQL语句，<strong class="kk iu">允许我们动态地编写SQL字符串，然后执行它</strong>。相当整洁！</p><figure class="lw lx ly lz gt ma"><div class="bz fp l di"><div class="pw ov l"/></div><p class="mh mi gj gh gi mj mk bd b be z dk translated">是的，立即执行就是那种强大的… | <a class="ae lu" href="https://media.giphy.com/media/MCZ39lz83o5lC/giphy.gif" rel="noopener ugc nofollow" target="_blank">来源</a></p></figure><p id="c420" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">由于我们的查询很长，我决定使用<code class="fe ow ox oy oz b">CONCAT</code>函数将多行字符串组合成一行。这对于调试来说非常烦人，所以我建议您<strong class="kk iu">运行您的函数的第一遍，将合成的SQL复制到一个新窗口中，并使用BigQuery UI在那里调试您的查询</strong>——相信我，您会看到许多遗漏的逗号和空格弄乱了您的查询😉，我当然做了。</p><figure class="lw lx ly lz gt ma"><div class="bz fp l di"><div class="ou ov l"/></div><p class="mh mi gj gh gi mj mk bd b be z dk translated">第15、16和19行是奇迹发生的地方。</p></figure><p id="cde7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这比我们之前的查询更难理解，但基本上是一样的。我只是在列名和表名中使用了字符串串联<code class="fe ow ox oy oz b">||</code>到<strong class="kk iu">粘贴</strong>以及我们在前2个表中要求的排列数。其余的不变——因此有了标准化的列名😃。</p><p id="792f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">运行以上程序来存储您的过程！然后我们准备准备我们的桌子。我们将使用经典的免费Iris数据集，它可以作为BigQuery表在<code class="fe ow ox oy oz b">bigquery-public-data:ml_datasets.iris</code>下获得。我们将扔掉<code class="fe ow ox oy oz b">setosa</code>品种，因为我们只需要2个，我们将询问海滨锦鸡儿花是否有更大的萼片宽度。如果你需要复习虹膜数据集，我<a class="ae lu" href="https://www.kaggle.com/benhamner/python-data-visualizations" rel="noopener ugc nofollow" target="_blank">推荐这款Kaggle笔记本</a>。</p><figure class="lw lx ly lz gt ma"><div class="bz fp l di"><div class="ou ov l"/></div><p class="mh mi gj gh gi mj mk bd b be z dk translated">我特意将所有的专栏都留在那里，以便您也可以对其他专栏尝试这个过程。</p></figure><p id="9db7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们有桌子和程序。是时候创建一个浮点变量并调用我们的排列测试了:</p><figure class="lw lx ly lz gt ma"><div class="bz fp l di"><div class="ou ov l"/></div></figure><p id="1012" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">运行上面的程序，我得到的p值是0.0008499，非常小。因此，我们得出结论，弗吉尼亚种的萼片宽度明显大于云芝种。</p><p id="199f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">BigQuery的美妙之处在于，我们<strong class="kk iu">为查询的字节</strong>付费，而不是为CPU时间付费。因此，我们可以将排列增加到100万，但仍然只为1.56KBs的查询付费。</p><p id="1557" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">🙏请<strong class="kk iu">在一些较大的数据集上尝试上述方法</strong>并评论一下它完成查询的速度，我很想知道你的结果。</p><h1 id="9543" class="nw nx it bd ny nz oa ob oc od oe of og jz pa ka oi kc pb kd ok kf pc kg om on bi translated">结论</h1><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="gh gi px"><img src="../Images/42897208739a7720db7618b4e9f58066.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6igzT0pQxZXt53DfcdpoqQ.jpeg"/></div></div><p class="mh mi gj gh gi mj mk bd b be z dk translated">照片由<a class="ae lu" href="https://unsplash.com/@sarti46?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Massimo Sartirana </a>在<a class="ae lu" href="https://unsplash.com/s/photos/finished?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="b64e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">希望您会发现以上内容对您的数据科学工作流程有用。现在，您不必将大型BigQuery数据集导出到磁盘，租用半TB的内存机器并在其上运行Python来做一些统计测试，<strong class="kk iu">您可以在BigQuery中便宜而有效地完成所有这些工作</strong>。</p><p id="46d6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果没有别的，请记住以下几点:</p><ul class=""><li id="f5ec" class="pe pf it kk b kl km ko kp kr pg kv ph kz pi ld ps pk pl pm bi translated">一个<strong class="kk iu">存储过程是一个可重用的BigQuery脚本</strong>(带有循环和变量)，它接受输入并产生一个输出变量。</li><li id="d656" class="pe pf it kk b kl pn ko po kr pp kv pq kz pr ld ps pk pl pm bi translated">程序以<code class="fe ow ox oy oz b">CREATE PROCEDURE dataset.procedure_name(inputs..., output) BEGIN</code>开始，以<code class="fe ow ox oy oz b">END</code>结束。</li><li id="c5b7" class="pe pf it kk b kl pn ko po kr pp kv pq kz pr ld ps pk pl pm bi translated">不要<code class="fe ow ox oy oz b">DECLARE</code>输入或输出变量。使用<code class="fe ow ox oy oz b">SET</code>改变变量值。</li><li id="e2a6" class="pe pf it kk b kl pn ko po kr pp kv pq kz pr ld ps pk pl pm bi translated"><code class="fe ow ox oy oz b">EXECUTE IMMEDIATE</code>可能是最强大的脚本关键字，允许您将任何字符串作为SQL语句执行。</li><li id="8b2d" class="pe pf it kk b kl pn ko po kr pp kv pq kz pr ld ps pk pl pm bi translated">用<code class="fe ow ox oy oz b">CONCAT</code>和<code class="fe ow ox oy oz b">||</code>将表名和变量名粘贴到SQL字符串中。</li><li id="23fd" class="pe pf it kk b kl pn ko po kr pp kv pq kz pr ld ps pk pl pm bi translated">总是首先在过程之外调试SQL脚本！</li></ul><p id="b5bb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="lq">感谢一路读到最后。我写了一些关于BigQuery、Julia和Python的文章，所以如果这些教程对你有帮助的话，请随时关注我。</em></p></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><p id="b03d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">想要更多BigQuery采样教程吗？<a class="ae lu" rel="noopener" target="_blank" href="/advanced-random-sampling-in-bigquery-sql-7d4483b580bb">看看这个</a>。</p></div></div>    
</body>
</html>