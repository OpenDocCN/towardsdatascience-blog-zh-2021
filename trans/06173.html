<html>
<head>
<title>Memoization with intervals in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中带区间的记忆</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/memoization-with-intervals-in-python-887ece304278?source=collection_archive---------28-----------------------#2021-06-02">https://towardsdatascience.com/memoization-with-intervals-in-python-887ece304278?source=collection_archive---------28-----------------------#2021-06-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="873a" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">应用于更快的时间序列处理</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/5233acf121fe217f741ba89448a45a19.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*72DOsCwCo6KfBVeRRRlLoA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure></div><div class="ab cl kv kw hu kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="ij ik il im in"><h1 id="1cca" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">动机</h1><p id="c396" class="pw-post-body-paragraph lu lv iq lw b lx ly jr lz ma mb ju mc md me mf mg mh mi mj mk ml mm mn mo mp ij bi translated">数据科学家面临的一个常见任务类型包括<br/>处理不断出现的信息。一个典型的例子是<br/>监控在交易台执行的交易或复杂系统生成的日志<br/>的后处理。</p><p id="f7ec" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">如果您发现自己一天中有很多次要等上三到五分钟，等待统计数据在您的完整数据集上运行，那么您可能会想到，经常会有相当多的时间花在重复的任务上，比如加载数据，无论是从数据库、REST兼容资源还是文件系统。如果您一直以天真的方式进行，您甚至会发现自己处于这样一种情况，即在更新信息和等待更新所花费的时间之间进行权衡，会使您在刷新系统状态时犹豫不决。</p><p id="5e44" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">更有效地解决这个问题的一个方法是注意，在典型的<br/>监视任务中，要处理的信息是先前处理的<br/>信息和新到达的信息的联合。简而言之，时间向前运行，并且在许多真实的实际情况下，过去的信息是不可变的(或者对于一个人的特定意图来说，相当接近不可变)。监控频率越高，<strong class="lw ir">新</strong>信息的数量越少(假设泊松过程)。因此，这一大类任务最好增量处理。</p><p id="f7c4" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">具体地说，从午夜到当前时刻加载日志相当于将从上次加载<br/>日志到存储的上次检索以来发生的日志列表连接起来。在处理<br/>不可变部分的操作主导实际的最终处理的情况下(与对这些数据执行<br/>聚合相比，从DB中检索数据通常是这种情况)，这种观点的转变导致了与以前情况相比的彻底的<br/>改进:刷新越多，等待越少。</p><p id="79f9" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">包含存储冗长的<br/>操作结果而不是再次执行它们的优化技术被称为惰性评估、缓存或<em class="mv">记忆化</em>。</p><p id="8d81" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">后者是一个60年代中期的美国词语，来源于拉丁语<br/> <em class="mv">备忘录</em>(动词<em class="mv"> memorari </em>:“被记住”)。用美国公司的行话来说，发表一份<em class="mv">备忘录</em>，即要记住的东西，后来被通俗地称为<em class="mv">备忘录化</em> /这个术语在计算机科学中有了自己的生命，用来表示让一个函数记住它自己的结果的行为。这可以帮助不熟悉的读者理解为什么<em class="mv">记忆</em>不是拼写错误。</p><p id="47c7" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">对惰性评估策略的一个不太粗略的描述是，接收相同参数的函数<br/>将计算一次结果，并以某种方式存储该结果。在以后的某个时间提供相同的参数，它将检索存储的结果并返回它。当然，这个描述中的几乎每一个单词都隐藏了许多情况、约束和设计选择。例如,“相同”需要明确定义。“存储”的含义以及在实践中是如何实现的，已经产生了许多不同的可能算法和实现策略。仅在Python中，就有几十个包部分或全部致力于这项技术的各个方面。</p><h1 id="e341" class="lc ld iq bd le lf mw lh li lj mx ll lm jw my jx lo jz mz ka lq kc na kd ls lt bi translated">时间序列的记忆化:比看上去的要多</h1><p id="a66e" class="pw-post-body-paragraph lu lv iq lw b lx ly jr lz ma mb ju mc md me mf mg mh mi mj mk ml mm mn mo mp ij bi translated">解决时间序列惰性评估的简单方法如下。给定时间序列的开始和结束，lazy评估已经请求的最长序列，其开始和结束时间戳包含在间隔[start，end]中，并且实际上只计算或检索这些时间戳之间的差。因此，以某种方式，在每次评估时保存开始和结束时间戳，并将它们与请求的开始和结束时间戳进行比较。</p><p id="9fc9" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">这个简单的任务可以通过直接实现来处理。现在，如果试图处理非连续请求的情况(从两小时前到一小时前和半小时前到10分钟前的时间序列已经被处理的情况)，问题出人意料地变得对普通人来说是难以处理的:如果比较日期的案例爆炸，那么<em class="mv">的数量。人们面临的是这些典型问题中的一个，它比最初看到的要复杂得多。</em></p><h1 id="38f0" class="lc ld iq bd le lf mw lh li lj mx ll lm jw my jx lo jz mz ka lq kc na kd ls lt bi translated">区间算术的拯救</h1><p id="6f1e" class="pw-post-body-paragraph lu lv iq lw b lx ly jr lz ma mb ju mc md me mf mg mh mi mj mk ml mm mn mo mp ij bi translated">通常在这种情况下，问题的答案需要在抽象上更进一步<br/>。幸运的是，这里不涉及抽象的步骤，它所需要的概念在文献中有很好的介绍。更重要的是，对这些概念执行基本操作的包是可用的，我们将在本文后面看到。</p><p id="fe36" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">在许多实际情况下，时间序列可以通过它的开始和结束时间戳来识别。以系统日志为例，生成的所有日志的时间序列由两个时间戳之间的所有日志明确给出。正如前面所建议的，我们不是看两个时间戳，而是想把时间序列看成是由一个单独的时间间隔定义的。这种看似平凡的视角转变最终成为优雅解决问题的关键。</p><p id="566d" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">首先，我们将关注一种情况——一种相当常见的情况——我们希望从文件系统中检索两个时间戳之间的所有日志，或者数据库中的所有传入记录，并显示它们的缩略版本。</p><p id="a28b" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">假设先前已经进行了一些调用来检索不同时间戳的相似数据<br/>。人们应该注意存储这些不同调用的结果<br/>，它们中的每一个都定义了一个原子时间间隔。一个<br/>原子时间间隔是人们想到一个间隔时自发召唤的图像:被考虑的空间/时间的连续部分。区间的这种自然定义可以推广到这种<br/>区间的并集。为了区分这两种类型，前者被指定为<em class="mv">原子</em>。</p><p id="2c92" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">假设新的调用定义了新的原子间隔，让我们考虑两个简单的情况:</p><ul class=""><li id="9f45" class="nb nc iq lw b lx mq ma mr md nd mh ne ml nf mp ng nh ni nj bi translated">原子间隔与先前记录的间隔相分离。这意味着用户从未检索过这些数据，因此需要调用底层函数。一旦这样做了，一个适时地存储结果，并记录时间间隔沿着以前的。<br/>该机制如下图所示。</li><li id="838a" class="nb nc iq lw b lx nk ma nl md nm mh nn ml no mp ng nh ni nj bi translated">新的原子间隔包含在先前记录的间隔之一中。在这种情况下，已经存储了所需结果的超集。人们检索存储的结果，然后应用过滤器。这自然假设过滤操作比查询数据更快，这是一个将进一步放宽的约束。下面的三个“完全重叠”图说明了该机制。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi np"><img src="../Images/a132d44fb81b827ee4089bc78ae8d127.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yvg0hdn3jyOpxfO2ln9IEg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">在析取情况下请求新的间隔。图片作者。</p></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi np"><img src="../Images/a172551d442c07be16a0f779bd609ec6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0Y-hxVAMzcXM893MR9k3ng.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">析取情况下的结果调用。图片作者。</p></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi np"><img src="../Images/c82f7333a8ff700ed0b53aa10582bde7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SveJOLCi5frzBFpPc0EOMA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">在分离情况下调用后间隔缓存的新状态。图片作者。</p></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi np"><img src="../Images/2127c75791d71959c14536fb133040bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-uqQuanwt4CcVrz0Oa3_hg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">在完全重叠的情况下请求新的间隔。图片作者。</p></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi np"><img src="../Images/a96a340f4063d3e4b4ca35ec0d8a6b99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3oPiNV_1oMJcS35_hDAtjA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">完全重叠情况下的结果调用。图片作者。</p></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi np"><img src="../Images/1e8cd3c454a034830e918a2429ac35fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CqE5mxofDc3AhnY6wWrOeg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">完全重叠情况下调用后缓存的新状态。图片作者。</p></figure><p id="c7d1" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">到目前为止，很容易。有了前两个例子，一般情况也不会更困难。一般来说，新间隔可以:</p><ul class=""><li id="53ac" class="nb nc iq lw b lx mq ma mr md nd mh ne ml nf mp ng nh ni nj bi translated">与所有以前的案例相分离(一个已经涉及的案例)</li><li id="50f6" class="nb nc iq lw b lx nk ma nl md nm mh nn ml no mp ng nh ni nj bi translated">或者重叠一个或几个间隔。</li></ul><p id="6c0d" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">为了处理第二种情况，我们只需要记住，如果一个区间与另一个区间重叠:</p><ul class=""><li id="a7b4" class="nb nc iq lw b lx mq ma mr md nd mh ne ml nf mp ng nh ni nj bi translated">他们的区别与后者是脱节的</li><li id="d56f" class="nb nc iq lw b lx nk ma nl md nm mh nn ml no mp ng nh ni nj bi translated">它们的交集包含在后者中</li><li id="95d3" class="nb nc iq lw b lx nk ma nl md nm mh nn ml no mp ng nh ni nj bi translated">差和交的并集就是整个区间。</li></ul><p id="5c65" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">下图对此进行了总结:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi np"><img src="../Images/83ccab858cd49929f104ef94af384176.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TPVSQ1EI3I6FrFNIgbI1Vg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">在原子重叠的情况下请求新的间隔。图片作者。</p></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi np"><img src="../Images/73e17603c44c71f8c430948966c3e3bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*keeHkI19vNfn5VHhw7YRhQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">原子重叠情况下的结果调用。图片作者。</p></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi np"><img src="../Images/056909d1871c901533407465b59b312b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PfN1-ZSkTchNvJQR1lLmGQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">原子重叠情况下调用后缓存的新状态。图片作者。</p></figure><p id="8643" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">现在，如果新请求的间隔与几个已经存储的间隔重叠，只需要对每个存储的间隔应用先前的方法。接下来的三幅图说明了这种一般情况:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi np"><img src="../Images/3d1ac642fe2c2359d67a55a6d7ac61c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bdF3m0BCoPdQsyz2FwWYWw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">在重叠情况下请求新的间隔。图片作者。</p></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi np"><img src="../Images/a07a56d1f7321c5075380b1b90d1f8c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bU9_r6-6eBEqWnTNoxp6HA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">重叠情况下的结果调用。图片作者。</p></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi np"><img src="../Images/b64c80819c7c657cf07318773b938e3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b4AST2eAlmZ7bSV2sBl2HA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">重叠情况下调用后缓存的新状态。图片作者。</p></figure><p id="375b" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">够抽象了！让我们来看一个实际的代码。有几个<br/>包来处理区间和区间算术。一个精心编写的<br/>一个是亚历山大·德坎的<a class="ae nq" href="https://github.com/AlexandreDecan/portion" rel="noopener ugc nofollow" target="_blank"> <em class="mv">部分</em> </a>。该软件包处理所有与区间算术相关的必要概念，这是我们利用的一个。</p><p id="f646" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">它特别包含了一个方便的<code class="fe nr ns nt nu b">IntervalDict</code>，这正是人们所期望的<br/>，并且完全符合间隔记录器<br/>的目的，同时考虑到了函数调用的思想。不过，这里有一个小的微妙之处，需要马上清除掉。乍一看，人们可能会奇怪为什么不使用一个广义的时间间隔来记录呼叫。嗯，区间是一个聪明的对象，它有一些属性，在处理区间算术时特别有用，但在当前的上下文中并不适用。例如，两个相邻的时间间隔将减少到一个原子时间间隔，这在函数的惰性计算环境中相当于忘记两个函数调用并注册一个从未发生的函数调用。</p><p id="3c05" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">所以事不宜迟，这里是第一个版本的<code class="fe nr ns nt nu b">RecordIntervals</code>对象:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="b431" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated"><code class="fe nr ns nt nu b">RecordIntervals</code>类的一个实例是一个可调用对象，当<br/>通过一个原子间隔时，它将返回一个要调用的列表，而<br/>将更新已经调用的内部列表。</p><p id="bc20" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">让我们看一个简单的例子。首先，让我们初始化一个空的<br/>记录器，并以区间[-2，0]进行第一次调用(在这些初始的简单例子中，我们将使用整数<br/>区间:我们可以添加一个时间单位(分钟、小时、天)以在时间序列上下文中将它们设置回来)。注意<code class="fe nr ns nt nu b">closed</code>是<em class="mv">部分</em>函数调用，用于创建一个原子间隔，其两端都包含在该间隔中。</p><pre class="kg kh ki kj gt nx nu ny nz aw oa bi"><span id="efd1" class="ob ld iq nu b gy oc od l oe of">itvals = RecordIntervals()<br/>calls = itvals(portion.closed(-2, 0))<br/>print_calls(calls)</span></pre><p id="e763" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">输出“[(-2，0)]”告诉我们需要调用带有参数<br/> (-2，0)的函数。因此，如果到目前为止还没有检索到任何数据，并且需要从两个小时到现在的数据，则需要查询DB(例如)两个小时的数据。</p><p id="1da4" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">在第一次检索之后，可以立即查询最后一个小时的数据。</p><pre class="kg kh ki kj gt nx nu ny nz aw oa bi"><span id="5901" class="ob ld iq nu b gy oc od l oe of">calls = itvals(portion.closed(-1, 0))<br/>print_calls(calls)</span></pre><p id="4269" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">输出“[(-2，0)]”反映了数据的超集已经被检索和存储的事实。因此，第二次调用该函数将只返回存储的数据(假设该函数已被记忆)。</p><p id="cf81" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">下一个案例稍微有趣一些:</p><pre class="kg kh ki kj gt nx nu ny nz aw oa bi"><span id="d9f7" class="ob ld iq nu b gy oc od l oe of">calls = itvals(portion.closed(-3, -1))<br/>print_calls(calls)</span></pre><p id="4572" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">输出“[(-3，-2)，(-2，0)]”表示需要发生一个调用，该调用导致从数据库中检索三小时到两小时前存储的数据<br/>，而第二个调用又是对存储结果的调用。那是动作间隔的记忆。我们只查询尚未存储的内容。</p><p id="bb45" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">最后，下面的代码:</p><pre class="kg kh ki kj gt nx nu ny nz aw oa bi"><span id="ba42" class="ob ld iq nu b gy oc od l oe of">calls = itvals(portion.closed(-5, -4))<br/>print_calls(calls)<br/>calls = itvals(portion.closed(-6, 0))<br/>print("should be broken in 5 intervals: -6-&gt;-5 | -5-&gt;-4 | -4-&gt;-3 | -3-&gt;-2 | -2-&gt;0")<br/>print_calls(calls)</span></pre><p id="ff42" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">产量:</p><pre class="kg kh ki kj gt nx nu ny nz aw oa bi"><span id="7096" class="ob ld iq nu b gy oc od l oe of">[(-5, -4)]<br/>should be broken in 5 intervals: -6-&gt;-5 | -5-&gt;-4 | -4-&gt;-3 | -3-&gt;-2 | -2-&gt;0<br/>[(-6, -5), (-5, -4), (-4, -3), (-3, -2), (-2, 0)]</span></pre><p id="31a6" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">好吧。我们现在有一个原始的机制，给定一个时间间隔，生成正确的参数来利用潜在的现有记忆。我们现在需要做的就是将这种原始机制与现有的记忆化实现相结合，以便能够对参数包含表示时间(或其他)间隔的类型的函数进行惰性求值。</p><p id="5678" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">不过，在这样做之前，可能有必要对记忆化本身，或者更具体地说，对Python中的记忆化做一些提醒。</p><h1 id="775c" class="lc ld iq bd le lf mw lh li lj mx ll lm jw my jx lo jz mz ka lq kc na kd ls lt bi translated">python中的记忆化:概述</h1><p id="d443" class="pw-post-body-paragraph lu lv iq lw b lx ly jr lz ma mb ju mc md me mf mg mh mi mj mk ml mm mn mo mp ij bi translated">最常用的内存化实现可能是<code class="fe nr ns nt nu b">functools</code>库中的<code class="fe nr ns nt nu b">cache</code>和<code class="fe nr ns nt nu b">lru_cache</code> ( <em class="mv"> LRU </em>代表<em class="mv">最近最少使用的</em>)。它们足以说明记忆化的许多不同方面。</p><h2 id="a7ba" class="ob ld iq bd le og oh dn li oi oj dp lm md ok ol lo mh om on lq ml oo op ls oq bi translated">示意图利用</h2><p id="8a4e" class="pw-post-body-paragraph lu lv iq lw b lx ly jr lz ma mb ju mc md me mf mg mh mi mj mk ml mm mn mo mp ij bi translated">惰性评估技术可以总结如下:</p><ul class=""><li id="a8cb" class="nb nc iq lw b lx mq ma mr md nd mh ne ml nf mp ng nh ni nj bi translated">创建一个调用字典，即<br/>一组组合的请求参数<br/> f(1，2，a=True，b='memo') - &gt; key = keymap(1，2，a=True，b='memo ')</li><li id="57de" class="nb nc iq lw b lx nk ma nl md nm mh nn ml no mp ng nh ni nj bi translated">在该集合中查找新调用方参数</li><li id="cbe1" class="nb nc iq lw b lx nk ma nl md nm mh nn ml no mp ng nh ni nj bi translated">如果键存在，从档案中检索相关的结果，否则调用函数。</li></ul><p id="d180" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">存档可以是:</p><ul class=""><li id="9fd3" class="nb nc iq lw b lx mq ma mr md nd mh ne ml nf mp ng nh ni nj bi translated">进程内存储器</li><li id="efc3" class="nb nc iq lw b lx nk ma nl md nm mh nn ml no mp ng nh ni nj bi translated">进程外存储器</li><li id="3d29" class="nb nc iq lw b lx nk ma nl md nm mh nn ml no mp ng nh ni nj bi translated">文件</li><li id="7ba8" class="nb nc iq lw b lx nk ma nl md nm mh nn ml no mp ng nh ni nj bi translated">一个组合</li></ul><p id="9c0f" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated"><code class="fe nr ns nt nu b">cache</code>和<code class="fe nr ns nt nu b">lru_cache</code>依赖于字典实现，对它们可以处理的键的类型和在RAM中存储结果有限制。</p><h2 id="9b60" class="ob ld iq bd le og oh dn li oi oj dp lm md ok ol lo mh om on lq ml oo op ls oq bi translated">特征</h2><p id="12af" class="pw-post-body-paragraph lu lv iq lw b lx ly jr lz ma mb ju mc md me mf mg mh mi mj mk ml mm mn mo mp ij bi translated">许多策略和实现设计都会影响缓存方法的行为和性能。其中包括:</p><ul class=""><li id="4b13" class="nb nc iq lw b lx mq ma mr md nd mh ne ml nf mp ng nh ni nj bi translated">内存空间的管理:例如，是否允许内存空间随着时间无限制地增长？默认情况下，<code class="fe nr ns nt nu b">lru_cache</code>将限制缓存空间，并且一旦达到该限制，将开始丢弃最近最少使用的<em class="mv">元素，以允许存储新元素。</em></li><li id="02a7" class="nb nc iq lw b lx nk ma nl md nm mh nn ml no mp ng nh ni nj bi translated">密钥生成机制:例如，通过字典的默认实现假设密钥是可散列的。</li></ul><h2 id="32d3" class="ob ld iq bd le og oh dn li oi oj dp lm md ok ol lo mh om on lq ml oo op ls oq bi translated">函数和字典</h2><p id="abf6" class="pw-post-body-paragraph lu lv iq lw b lx ly jr lz ma mb ju mc md me mf mg mh mi mj mk ml mm mn mo mp ij bi translated">根据官方Python文档，它是一个字典查找的包装器。字典是实现记忆标准方法。考虑到本文的其余部分，值得注意的是，字典和Python(确定性的)函数有很多共同之处。符号通常不同——圆括号和方括号——但两者都将参数映射到返回值。</p><p id="25ad" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">作为题外话，值得一提的是，在C++标准库<br/>中，相当于字典的东西被称为<em class="mv">映射</em>，并且在许多函数式语言中<em class="mv">映射</em>被用来指定一个高阶函数，该函数将一个函数应用于集合中的每个元素。这两个概念似乎又有内在联系。</p><h2 id="0e5a" class="ob ld iq bd le og oh dn li oi oj dp lm md ok ol lo mh om on lq ml oo op ls oq bi translated">可用的软件包</h2><p id="b413" class="pw-post-body-paragraph lu lv iq lw b lx ly jr lz ma mb ju mc md me mf mg mh mi mj mk ml mm mn mo mp ij bi translated">我们可以从本质上区分两类用于在Python中执行惰性评估的包。</p><p id="4dbf" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">第一类包括python客户机或非python实现的包装器，最著名的两个是:</p><ul class=""><li id="a7dc" class="nb nc iq lw b lx mq ma mr md nd mh ne ml nf mp ng nh ni nj bi translated">Memcached</li><li id="e83f" class="nb nc iq lw b lx nk ma nl md nm mh nn ml no mp ng nh ni nj bi translated">雷迪斯</li></ul><p id="de5a" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">另一类包含专用的python实现，其中包括:</p><ul class=""><li id="329c" class="nb nc iq lw b lx mq ma mr md nd mh ne ml nf mp ng nh ni nj bi translated"><a class="ae nq" href="https://pythonhosted.org/joblib/memory.htm" rel="noopener ugc nofollow" target="_blank">作业库</a></li><li id="3b59" class="nb nc iq lw b lx nk ma nl md nm mh nn ml no mp ng nh ni nj bi translated"><a class="ae nq" href="https://github.com/youknowone/ring" rel="noopener ugc nofollow" target="_blank">环</a> —优秀的文档</li><li id="03ed" class="nb nc iq lw b lx nk ma nl md nm mh nn ml no mp ng nh ni nj bi translated"><a class="ae nq" href="https://github.com/lonelyenvoy/python-memoization" rel="noopener ugc nofollow" target="_blank">记忆化</a> ](支持不可散列参数、生存时间策略……)</li><li id="3d95" class="nb nc iq lw b lx nk ma nl md nm mh nn ml no mp ng nh ni nj bi translated"><a class="ae nq" href="https://pypi.org/project/klepto/" rel="noopener ugc nofollow" target="_blank">窃</a>部分的<em class="mv">悲情</em>系统。</li></ul><h2 id="5460" class="ob ld iq bd le og oh dn li oi oj dp lm md ok ol lo mh om on lq ml oo op ls oq bi translated">装饰概念和语法</h2><p id="9dac" class="pw-post-body-paragraph lu lv iq lw b lx ly jr lz ma mb ju mc md me mf mg mh mi mj mk ml mm mn mo mp ij bi translated">缓存通常作为<em class="mv">装饰器</em>提供，因此如果<br/>原始函数是<code class="fe nr ns nt nu b">f</code>:</p><pre class="kg kh ki kj gt nx nu ny nz aw oa bi"><span id="fc80" class="ob ld iq nu b gy oc od l oe of"><a class="ae nq" href="http://twitter.com/cache" rel="noopener ugc nofollow" target="_blank">    @cache</a> <br/>    def f(i):<br/>      return i+1 <br/>    # the call below is now to a memoized version<br/>    # of the function f<br/>    f(3)</span></pre><p id="0e0c" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">来自<code class="fe nr ns nt nu b">@cache</code>的两行代码为函数<code class="fe nr ns nt nu b">f</code>添加了惰性求值。</p><p id="ae69" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">装饰器可以被认为并且实际上被实现为一个函数对象，它接受一个函数并返回一个函数。这意味着装饰器是一个python类，它公开了一个<code class="fe nr ns nt nu b">__call__</code>成员函数。我们通过注意到上述语法可以重写为:</p><pre class="kg kh ki kj gt nx nu ny nz aw oa bi"><span id="c77f" class="ob ld iq nu b gy oc od l oe of">def f(i):<br/>   # .... <br/>   g = cache(f)</span></pre><p id="2af3" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">其中<code class="fe nr ns nt nu b">g</code>这次是缓存增强功能。</p><h1 id="0f8e" class="lc ld iq bd le lf mw lh li lj mx ll lm jw my jx lo jz mz ka lq kc na kd ls lt bi translated">一个区间感知的记忆实现</h1><p id="c57b" class="pw-post-body-paragraph lu lv iq lw b lx ly jr lz ma mb ju mc md me mf mg mh mi mj mk ml mm mn mo mp ij bi translated">想出一个方便的软件组件来记忆取区间参数的函数需要一定量的元编程。我们选择只公开实现的一部分，这部分将揭示函数的实际使用。其他的可以在代码中找到，代码可以作为自由软件获得。</p><h2 id="40a6" class="ob ld iq bd le og oh dn li oi oj dp lm md ok ol lo mh om on lq ml oo op ls oq bi translated">概观</h2><p id="01f5" class="pw-post-body-paragraph lu lv iq lw b lx ly jr lz ma mb ju mc md me mf mg mh mi mj mk ml mm mn mo mp ij bi translated">主组件<code class="fe nr ns nt nu b">MemoizationWithIntervals</code>是作为一个函数对象提供的，通常被期望用作装饰器。<br/>以下是该组件的示例性用法:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><h2 id="edc0" class="ob ld iq bd le og oh dn li oi oj dp lm md ok ol lo mh om on lq ml oo op ls oq bi translated"><code class="fe nr ns nt nu b">MemoizationWithIntervals</code>构造函数</h2><p id="4d5b" class="pw-post-body-paragraph lu lv iq lw b lx ly jr lz ma mb ju mc md me mf mg mh mi mj mk ml mm mn mo mp ij bi translated">为了正确处理通用函数，需要由用户指定作为记忆候选的区间参数。</p><p id="5b7e" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">因此,<code class="fe nr ns nt nu b">MemoizationWithIntervals</code>构造函数的前两个参数是位置参数的索引和作为区间的关键字参数的名称。</p><p id="1a1c" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">在章节<strong class="lw ir"> Overview </strong>的例子中，唯一的间隔参数是<code class="fe nr ns nt nu b">interval</code>参数，并且在第一个构造函数参数中被指定。</p><p id="56f2" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">下面是一个带有一个位置间隔参数和一个关键字间隔参数的示例:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="1b11" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">构造函数中的其他参数将在下面的小节中详细介绍。</p><h2 id="515c" class="ob ld iq bd le og oh dn li oi oj dp lm md ok ol lo mh om on lq ml oo op ls oq bi translated">返回类型问题:指定聚合方法</h2><p id="bca4" class="pw-post-body-paragraph lu lv iq lw b lx ly jr lz ma mb ju mc md me mf mg mh mi mj mk ml mm mn mo mp ij bi translated">重要的是要注意，如前所述，任何涉及区间记忆的实现都与标准的惰性评估算法有着根本的不同。</p><p id="4aaa" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">在标准内存化中，除了速度之外，对缓存函数的调用将返回与对原始函数的调用无法区分的结果。特别是，对缓存函数的调用最多对应于对底层函数的一次调用。</p><p id="0fa2" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">前面几节中描述的算法可能涉及到对底层函数的多次调用。也就是说，结果类型不能先验地匹配初始函数的类型。在我们到目前为止给出的描述中，我们已经建议初始函数将返回一个结果列表。因此，间隔缓存函数将返回一个列表列表。我们已经暗示过，将这样一个列表转化为一个列表会涉及到连接和可能的过滤。</p><p id="4dae" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">尽管不需要如此。为了恰当地解释一般情况，用户需要灵活地指定一个<strong class="lw ir">聚合</strong>操作。这个聚集规范将是memoization <br/>类构造函数的一个参数。聚合函数将从不同的调用中获取结果列表，并返回一个类型与初始函数兼容的结果。</p><p id="9082" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">因此，这个聚合函数可以简单到<code class="fe nr ns nt nu b">aggregation=list</code>或<br/>等价地，对于熊猫数据帧，<code class="fe nr ns nt nu b">aggregation=pandas.concatenate</code>。在用户希望通过求和来聚集数值的情况下，将应用类似于<code class="fe nr ns nt nu b">aggregation=lambda listr: reduce(lambda x,y:x+y,listr)</code>的东西。</p><h2 id="aca5" class="ob ld iq bd le og oh dn li oi oj dp lm md ok ol lo mh om on lq ml oo op ls oq bi translated">记忆算法</h2><p id="6714" class="pw-post-body-paragraph lu lv iq lw b lx ly jr lz ma mb ju mc md me mf mg mh mi mj mk ml mm mn mo mp ij bi translated">本文中描述的包的唯一目的是对采用区间参数的函数进行预处理，以便惰性求值可以委托给用户选择的现有实现。因此，<code class="fe nr ns nt nu b">MemoizationWithIntervals</code>对象的构造器接受一个完全构造的memoization对象，它将执行惰性求值。</p><p id="0b5f" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">可以看出，我们选择了<code class="fe nr ns nt nu b">klepto</code>包作为默认实现。我们在该软件包中发现了引人注目的功能，并专门使用它。用户可能会发现其他实现更适合他们的需要，因此会更改默认设置。</p><p id="a271" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">所以通常使用<code class="fe nr ns nt nu b">functools cache</code>算法:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><h2 id="6374" class="ob ld iq bd le og oh dn li oi oj dp lm md ok ol lo mh om on lq ml oo op ls oq bi translated">处理其他间隔类型</h2><p id="f314" class="pw-post-body-paragraph lu lv iq lw b lx ly jr lz ma mb ju mc md me mf mg mh mi mj mk ml mm mn mo mp ij bi translated">Alexandre Decan的<em class="mv">部分</em>包是一个很棒的区间算术包。但是，对于interval对象本身，这可能不是最常见的实现。按理说，<em class="mv"/><code class="fe nr ns nt nu b">Interval</code>的熊猫可以称得上是冠军。但是一个人可能有自己的实现。使用具有特定间隔类型的<em class="mv"> CacheIntervals </em>需要创建一个特定类型的间隔记录器和一点包装，以允许在<em class="mv">部分的</em>本地间隔类型和用户的间隔类型之间进行双向转换。</p><p id="6ba2" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">包<em class="mv"> CacheIntervals </em>为<em class="mv"> Pandas的</em>间隔类型提供了这样一个包装的例子。实施该特定间隔的目的有两个。一方面，它是希望实现该覆盖的用户的模板。另一方面，<em class="mv">熊猫</em>’<code class="fe nr ns nt nu b">Interval</code>型，加上亚历山大·德坎的本土型应该能满足大部分需求。默认情况下，间隔记录器的类型是适应<em class="mv">熊猫</em>的间隔。要改变它，指定新的间隔<strong class="lw ir">记录器</strong>类型作为构造器的参数，例如:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><h1 id="f4a5" class="lc ld iq bd le lf mw lh li lj mx ll lm jw my jx lo jz mz ka lq kc na kd ls lt bi translated">机制概述</h1><p id="9775" class="pw-post-body-paragraph lu lv iq lw b lx ly jr lz ma mb ju mc md me mf mg mh mi mj mk ml mm mn mo mp ij bi translated">这一节更复杂，主要面向包开发人员。特别是，希望区间记忆可以直接嵌入到标准记忆包中，并随时可用。</p><p id="8c99" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">在这一节中，我们将深入探讨实现细节。更普通的读者可以放心地完全跳过它。</p><p id="c5dc" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">但是，这些解释中并没有假设Python的高深知识。因此，如果好奇发痒，请随意继续。</p><p id="bdfa" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">除了构造函数之外，<code class="fe nr ns nt nu b">MemoizationWithIntervals</code>类只有一个成员函数:函数<code class="fe nr ns nt nu b">__call__</code>。回想一下，正如在<br/>部分<strong class="lw ir">装饰概念和语法</strong>中解释的那样，<code class="fe nr ns nt nu b">MemoizationWithIntervals</code>对象是一个函数，它接受一个函数并返回这个函数的记忆版本。</p><p id="e80e" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">让我们看看代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="ad62" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">细节被主动省略，以便结构突出。从这个代码框架可以清楚地看出，<code class="fe nr ns nt nu b">__call__</code>函数所做的就是获取函数<code class="fe nr ns nt nu b">f</code>并返回函数<code class="fe nr ns nt nu b">wrapper</code>，函数本身在<code class="fe nr ns nt nu b">__call__</code>函数内部定义。</p><p id="87c4" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">从这段摘录中可以看出，<code class="fe nr ns nt nu b">wrapper</code>函数本身执行对<code class="fe nr ns nt nu b">f</code>、<code class="fe nr ns nt nu b">f_cached</code>的记忆版本的<br/>调用。</p><p id="7aeb" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">前两行设置一个对象来正确地解析调用参数，据我们所知，Python语言并没有直接提供这个功能。我们将跳过这部分代码，因为它与本文基本无关。</p><h2 id="aa85" class="ob ld iq bd le og oh dn li oi oj dp lm md ok ol lo mh om on lq ml oo op ls oq bi translated">两次利用记忆算法</h2><p id="4391" class="pw-post-body-paragraph lu lv iq lw b lx ly jr lz ma mb ju mc md me mf mg mh mi mj mk ml mm mn mo mp ij bi translated">区间惰性评估的一个直观但不正确的实现是将每个区间参数与其自己的区间记录器对象相关联。要了解为什么它通常不是我们想要的，让我们看一个简单的例子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="64e2" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">假设调用如下:</p><pre class="kg kh ki kj gt nx nu ny nz aw oa bi"><span id="3824" class="ob ld iq nu b gy oc od l oe of">print('==== First pass ===')<br/>print( f'Final result:\n{function_with_interval_param(2, interval=pd.Interval(-2, 0))}')<br/>print('==== Second pass ===')<br/>print(f'Final result: {function_with_interval_param(2, interval=pd.Interval(-3, 0))}')<br/>print('==== 3rd pass ===')<br/>print( f'Final result:\n {function_with_interval_param(3, interval=pd.Interval(-3, 0))}')</span></pre><p id="129f" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">输出将是:</p><pre class="kg kh ki kj gt nx nu ny nz aw oa bi"><span id="d837" class="ob ld iq nu b gy oc od l oe of">==== First pass ===<br/>((2, [-2,0]))<br/>==== Second pass ===<br/>((2, [-3,-2]), (2, [-2,0]))<br/>==== Third pass ===<br/>((3, [-3,-2]), (3, [-2,0]))</span></pre><p id="236e" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">细心的读者已经注意到第三遍的结果导致了低效率。当需要一个调用时，会生成两个调用。原因是第一个参数的每个值应该有一个记录器。</p><p id="5345" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">正确的算法需要以某种方式为每个非区间参数的组合保留一个记录器。人们可以通过例如字典来手动跟踪这些其他参数，但是人们会立即意识到:</p><ul class=""><li id="2905" class="nb nc iq lw b lx mq ma mr md nd mh ne ml nf mp ng nh ni nj bi translated">这是一项艰巨的任务，因为键映射并不像最初想象的那样简单</li><li id="4ca9" class="nb nc iq lw b lx nk ma nl md nm mh nn ml no mp ng nh ni nj bi translated">这正是记忆算法要解决的问题。</li></ul><p id="c991" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">因此，更巧妙的方法是利用用户提供的缓存<br/>算法来实现。这更适合于用户已经潜在地<br/>对他的设置指定了许多约束:使用的内存类型、持久性、内存管理和其他……为此，让我们回忆一下<strong class="lw ir">函数和字典</strong>部分的评论:字典和函数之间存在概念上的等价。</p><p id="128b" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">因此，我们的想法是两次利用缓存的函数实现:</p><ul class=""><li id="6a3f" class="nb nc iq lw b lx mq ma mr md nd mh ne ml nf mp ng nh ni nj bi translated">在对<br/>功能进行标准评估时，将会调用该函数。</li><li id="6bde" class="nb nc iq lw b lx nk ma nl md nm mh nn ml no mp ng nh ni nj bi translated">但是，除了这种标准用法之外，它还将用于存储适当的间隔记录器，就像我们使用字典一样。</li></ul><p id="39de" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">现在的问题是:我们如何区分标准呼叫和对记录器的请求？一种可能的方法是传递用户永远不会传递的参数。如果我们在任何地方检测到这样的参数，我们知道这不是对底层函数的调用，而是对记录器的请求。</p><p id="8bf8" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">这就是下面这个<code class="fe nr ns nt nu b">QueryRecorder</code>类的目的。在<br/> <code class="fe nr ns nt nu b">MemoizationWithIntervals</code>对象的构造函数中，变量<code class="fe nr ns nt nu b">self.query_recorder</code>被初始化为<code class="fe nr ns nt nu b">self.query_recorder=QueryRecorder()</code>，并在每次调用时用于解析<br/>记录器。</p><p id="8157" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">所以在下面的<code class="fe nr ns nt nu b">f_cached</code>函数中，有一个初步的机制来<br/>确定我们正在处理什么类型的调用。如果这是记录器的请求<br/>:</p><ul class=""><li id="2a7a" class="nb nc iq lw b lx mq ma mr md nd mh ne ml nf mp ng nh ni nj bi translated">第一次执行实际代码并创建记录器<br/>(由用户指定类型，例如<code class="fe nr ns nt nu b">RecorderInterval</code>、<br/> <code class="fe nr ns nt nu b">RecorderIntervalPandas</code>或某些用户的专用)。任何<code class="fe nr ns nt nu b">RecorderInterval</code>构造函数的特定参数都可以通过在<code class="fe nr ns nt nu b">MemoizationWithIntervals</code>对象的构造函数中将它们指定为<code class="fe nr ns nt nu b">kwargs</code>来传递。然后它们被存储到<code class="fe nr ns nt nu b">self.kwargsrecorder</code>成员变量中。</li><li id="5944" class="nb nc iq lw b lx nk ma nl md nm mh nn ml no mp ng nh ni nj bi translated">此后，记录器被缓存并将被重用。</li></ul><p id="4891" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">显然，这涉及到一个小的开销。这是否可以接受取决于用户的上下文。实际上，与内存化的好处相比，这种开销在大多数时候是可以忽略的。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="a1a3" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">下面是<code class="fe nr ns nt nu b">wrapper</code>功能代码的相应摘录。可以看出，当调用包装函数时，<br/> <code class="fe nr ns nt nu b">wrapper</code>的第一个任务是将每个区间自变量替换为对其对应记录器的请求。当记录器被解析后，<code class="fe nr ns nt nu b">wrapper</code> <br/>函数继续执行，从概念上讲，是对缓存函数的正常调用，实际上，是对所述函数的一系列(可能的)调用(此处未显示)。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><h2 id="383f" class="ob ld iq bd le og oh dn li oi oj dp lm md ok ol lo mh om on lq ml oo op ls oq bi translated">解决电话问题</h2><p id="8ffe" class="pw-post-body-paragraph lu lv iq lw b lx ly jr lz ma mb ju mc md me mf mg mh mi mj mk ml mm mn mo mp ij bi translated">从那以后，算法就相对容易了。从每个时间间隔记录器中，检索要发出的呼叫。最后一系列调用只是可能参数值的<br/>笛卡尔乘积，其中非区间参数只是单值。位置参数和关键字参数的分离给代码带来了一点复杂性，但这基本上就是最后一节的全部内容。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><h1 id="baef" class="lc ld iq bd le lf mw lh li lj mx ll lm jw my jx lo jz mz ka lq kc na kd ls lt bi translated">一些最后的细节</h1><h2 id="fa11" class="ob ld iq bd le og oh dn li oi oj dp lm md ok ol lo mh om on lq ml oo op ls oq bi translated">容忍</h2><p id="bdc9" class="pw-post-body-paragraph lu lv iq lw b lx ly jr lz ma mb ju mc md me mf mg mh mi mj mk ml mm mn mo mp ij bi translated">假设被查询数据的数据库是一个每15分钟更新一次的代理数据库。如果在很短的时间间隔后一个调用成功于前一个调用，则数据不太可能有明显的变化。另一方面，即使检索少量数据或者根本没有新数据，仍然需要通过网络进行交换，并在数据库本身上进行一些操作。当人们想到单个用户交互地发出请求时，这种情况可能看起来有些牵强，但是在多用户环境或更加自动化的设置中，这实际上可能是一种非常常见的情况。</p><p id="52dd" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">为了防止在快速连续的请求之后的不必要的事务，或者在更一般的情况下，如果新的查询间隔与原始间隔没有显著不同，可以决定，在容限阈值以下，不发出新的呼叫。这种方法在缓存算法中很常见，通常被称为<em class="mv">舍入</em>。</p><p id="9d50" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">事实证明，在我们的例子中，实现舍入非常简单。它只需要对<code class="fe nr ns nt nu b">RecordIntervals</code>类做一个小小的修改。构造函数现在接受一个<code class="fe nr ns nt nu b">rounding</code>参数，并且<code class="fe nr ns nt nu b">disjunct</code>成员函数将测试<br/>新请求的区间的边界是否低于阈值，在这种情况下，新的区间不会被添加。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="d091" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">这种外科手术式的改变是我们所需要的。这是如何使用的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><h2 id="f52d" class="ob ld iq bd le og oh dn li oi oj dp lm md ok ol lo mh om on lq ml oo op ls oq bi translated">关于聚合的更多信息</h2><p id="c4e3" class="pw-post-body-paragraph lu lv iq lw b lx ly jr lz ma mb ju mc md me mf mg mh mi mj mk ml mm mn mo mp ij bi translated">现在是时候透露我们在最初的<code class="fe nr ns nt nu b">RecordIntervals</code>中隐藏了一个细节，细心的读者可能会反对。当处理一个标准的聚合算法时，例如取一些列的累积值或它们的平均值，我们当前的策略将不会产生正确的结果。原因是在数据的超集上聚集不是我们所期望的。</p><p id="7e4e" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">因此，我们需要另一种算法。这个想法是，对新间隔的请求不能导致具有更宽间隔的呼叫。以下三幅图展示了新策略的表现。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi np"><img src="../Images/cc3ceec7c5deeb6b29508e990880de6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SdnIDE-sxUIvCQ-TmmbHbg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">在原子重叠的情况下请求新的间隔。图片作者。</p></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi np"><img src="../Images/e380c9316cc158e98a01bd0a88bb1220.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LvDfhjitYk4OZrLWdlHSVQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">导致调用帐户进行聚合。图片作者。</p></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi np"><img src="../Images/2f602aedf2ccd03cd4f0732697223891.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XXErHoSe0wzOrxwOHNQKug.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">在聚合策略的情况下，调用后缓存的新状态。图片作者。</p></figure><p id="75c2" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">这些数字可能会给人一种错觉，认为这种策略不会产生缓存。然而，事实并非如此:对于新请求的时间间隔中包含的所有已存储的时间间隔，都将进行缓存。</p><p id="cc3a" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">相应的算法如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><h1 id="707c" class="lc ld iq bd le lf mw lh li lj mx ll lm jw my jx lo jz mz ka lq kc na kd ls lt bi translated">结论</h1><p id="becd" class="pw-post-body-paragraph lu lv iq lw b lx ly jr lz ma mb ju mc md me mf mg mh mi mj mk ml mm mn mo mp ij bi translated"><em class="mv"> CacheIntervals </em>包可以避免很多容易出错的锅炉板<br/>代码。鉴于其应用程序无处不在的特性，它允许避免每次都重写代码。这不仅导致开发时间的改进，而且，最值得注意的是，在我们的经验中，有利于系统地使用惰性评估，这最终有利于应用程序的最终用户。</p><p id="7a69" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">作为临别笔记，一个小趣闻。这个算法是几天前从零开始写的。在设计算法的初步版本时，谷歌搜索引擎网站打开了一扇<em class="mv">复活节彩蛋</em>之门。它导致了一个斯巴达式的命令行界面和一些允许访问任务声明的类似Unix的命令。必须产生一个代码来帮助另一个星球上的奴才们整理一些任务分配。这个复活节彩蛋是一个随机事件还是之前在Google引擎上搜索请求的结果，这个问题的解决方案已经给出了答案:它是Python中涉及记忆化的三行代码！在规定的时间内成功提交了第一个挑战后，我得到了一张《黑客帝国》( Matrix-the-movie)动画像素化的图像——我适时地在屏幕上保留了几天。在这个阶段，我被提示输入我的证书以接受进一步的挑战，这被我的公司防火墙阻止了(这可能是最好的结果，因为我仍然可以幻想自己被这家著名的软件公司录用)。尽管如此，这种创新的招聘模式还是给我留下了深刻的印象。所以你看，致力于记忆可以带来意想不到的发现…</p><h1 id="490a" class="lc ld iq bd le lf mw lh li lj mx ll lm jw my jx lo jz mz ka lq kc na kd ls lt bi translated">参考</h1><p id="0fe8" class="pw-post-body-paragraph lu lv iq lw b lx ly jr lz ma mb ju mc md me mf mg mh mi mj mk ml mm mn mo mp ij bi translated"><em class="mv"> CacheIntervals </em>存储库位于GitHub上，地址如下:</p><div class="or os gp gr ot ou"><a href="https://github.com/cyrilgodart/CacheIntervals" rel="noopener  ugc nofollow" target="_blank"><div class="ov ab fo"><div class="ow ab ox cl cj oy"><h2 class="bd ir gy z fp oz fr fs pa fu fw ip bi translated">cyrilgodart/CacheIntervals</h2><div class="pb l"><h3 class="bd b gy z fp oz fr fs pa fu fw dk translated">带区间参数的内存化CacheIntervals允许对带区间参数的函数进行惰性求值…</h3></div><div class="pc l"><p class="bd b dl z fp oz fr fs pa fu fw dk translated">github.com</p></div></div><div class="pd l"><div class="pe l pf pg ph pd pi kp ou"/></div></div></a></div><p id="85b6" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">亚历山大·德坎的<em class="mv">部分</em>可以在这里找到:</p><div class="or os gp gr ot ou"><a href="https://github.com/AlexandreDecan/portion" rel="noopener  ugc nofollow" target="_blank"><div class="ov ab fo"><div class="ow ab ox cl cj oy"><h2 class="bd ir gy z fp oz fr fs pa fu fw ip bi translated">亚历山大扫描/部分</h2><div class="pb l"><h3 class="bd b gy z fp oz fr fs pa fu fw dk translated">部分库(以前作为python-intervals发布)提供了数据结构和区间操作…</h3></div><div class="pc l"><p class="bd b dl z fp oz fr fs pa fu fw dk translated">github.com</p></div></div><div class="pd l"><div class="pj l pf pg ph pd pi kp ou"/></div></div></a></div><p id="f6f4" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">窃贼来了:</p><div class="or os gp gr ot ou"><a href="https://github.com/uqfoundation/klepto" rel="noopener  ugc nofollow" target="_blank"><div class="ov ab fo"><div class="ow ab ox cl cj oy"><h2 class="bd ir gy z fp oz fr fs pa fu fw ip bi translated">uqfoundation/klepto</h2><div class="pb l"><h3 class="bd b gy z fp oz fr fs pa fu fw dk translated">内存、磁盘或数据库持久缓存扩展了python的lru_cache，以利用不同的键映射和…</h3></div><div class="pc l"><p class="bd b dl z fp oz fr fs pa fu fw dk translated">github.com</p></div></div><div class="pd l"><div class="pk l pf pg ph pd pi kp ou"/></div></div></a></div></div></div>    
</body>
</html>