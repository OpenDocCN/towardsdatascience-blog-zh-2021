<html>
<head>
<title>🚀 Introduction to Binary Classification with PyCaret</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">🚀PyCaret 二元分类简介</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/introduction-to-binary-classification-with-pycaret-a37b3e89ad8d?source=collection_archive---------4-----------------------#2021-11-24">https://towardsdatascience.com/introduction-to-binary-classification-with-pycaret-a37b3e89ad8d?source=collection_archive---------4-----------------------#2021-11-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="8572" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用 PyCaret 的 Python 二进制分类的循序渐进的初学者友好教程</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/0578627aa4cdc48224703e13bd058e92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*FwrC1Ei5zLvLT_TK"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae kv" href="https://unsplash.com/@roguewild?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">麦克 U </a>拍摄的照片</p></figure><h1 id="dd52" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">1.0 简介</h1><p id="c493" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated"><a class="ae kv" href="https://www.pycaret.org" rel="noopener ugc nofollow" target="_blank"> PyCaret </a>是一个用 Python 编写的开源、低代码的机器学习库，可以自动化机器学习工作流。这是一个端到端的机器学习和模型管理工具，可以成倍地加快实验周期，提高您的工作效率。</p><p id="5d42" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">与其他开源机器学习库相比，PyCaret 是一个替代的低代码库，可以用来用几行代码替换数百行代码。这使得实验快速有效。PyCaret 本质上是几个机器学习库和框架的 Python 包装器，比如 scikit-learn、XGBoost、LightGBM、CatBoost、spaCy、Optuna、Hyperopt、Ray 等等。</p><p id="0966" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">PyCaret 的设计和简单性受到了公民数据科学家这一新兴角色的启发，这是 Gartner 首先使用的术语。公民数据科学家是超级用户，他们可以执行简单和中等复杂的分析任务，这些任务在以前需要更多的技术专业知识。</p><p id="22aa" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">想了解更多关于 PyCaret 的信息，可以查看官方<a class="ae kv" href="https://www.pycaret.org/" rel="noopener ugc nofollow" target="_blank">网站</a>或者<a class="ae kv" href="https://www.github.com/pycaret/pycaret" rel="noopener ugc nofollow" target="_blank"> GitHub </a>。</p><h1 id="598b" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">2.0 教程目标</h1><p id="352c" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">在本教程中，我们将学习:</p><ul class=""><li id="4646" class="mp mq iq lq b lr mk lu ml lx mr mb ms mf mt mj mu mv mw mx bi translated"><strong class="lq ir">获取数据:</strong>如何从 PyCaret 存储库中导入数据</li><li id="f48d" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated"><strong class="lq ir">设置环境:</strong>如何在 PyCaret 中设置实验并开始构建分类模型</li><li id="1254" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated"><strong class="lq ir">创建模型:</strong>如何创建模型、执行分层交叉验证和评估分类指标</li><li id="9e15" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated"><strong class="lq ir">调整模型:</strong>如何自动调整分类模型的超参数</li><li id="c769" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated"><strong class="lq ir">绘图模型:</strong>如何使用各种绘图分析模型性能</li><li id="c702" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated"><strong class="lq ir">敲定模型:</strong>如何在实验结束时敲定最佳模型</li><li id="96b7" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated"><strong class="lq ir">预测模型:</strong>如何对看不见的数据进行预测</li><li id="7adf" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated"><strong class="lq ir">保存/加载模型:</strong>如何保存/加载模型以备将来使用</li></ul><h1 id="efac" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">3.0 安装 PyCaret</h1><p id="4570" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">安装很容易，只需几分钟。PyCaret 从 pip 的默认安装只安装在<a class="ae kv" href="https://github.com/pycaret/pycaret/blob/master/requirements.txt" rel="noopener ugc nofollow" target="_blank"> requirements.txt </a>文件中列出的硬依赖项。</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="f668" class="ni kx iq ne b gy nj nk l nl nm">pip install pycaret</span></pre><p id="3a29" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">要安装完整版:</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="b441" class="ni kx iq ne b gy nj nk l nl nm">pip install pycaret[full] </span></pre><h1 id="dc13" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">4.0 什么是二进制分类？</h1><p id="bee4" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">二元分类是一种受监督的机器学习技术，其目标是预测离散且无序的分类标签，例如通过/失败、肯定/否定、默认/非默认等。下面列出了一些分类的真实使用案例:</p><ul class=""><li id="a7f0" class="mp mq iq lq b lr mk lu ml lx mr mb ms mf mt mj mu mv mw mx bi translated">确定患者是否患有某种疾病的医学测试——分类属性是疾病的存在。</li><li id="dc65" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated">工厂中的“通过或失败”测试方法或质量控制，即决定是否符合规格——通过/不通过分类。</li><li id="4b9b" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated">信息检索，即决定一个页面或一篇文章是否应该出现在搜索结果集中——分类属性是文章的相关性或对用户的有用性。</li></ul><h1 id="0f59" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">5.0 py caret 中分类模块的概述</h1><p id="2238" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">PyCaret 的<a class="ae kv" href="https://pycaret.readthedocs.io/en/latest/api/classification.html" rel="noopener ugc nofollow" target="_blank">分类模块</a> ( <code class="fe nn no np ne b">pycaret.classification</code>)是一个受监督的机器学习模块，用于根据各种技术和算法将元素分类到二进制组中。分类问题的一些常见用例包括预测客户违约(是或否)、客户流失(客户将离开或留下)、发现疾病(阳性或阴性)。</p><p id="85b5" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">PyCaret 分类模块可用于二进制或多类分类问题。它有超过 18 个算法和 14 个图来分析模型的性能。无论是超参数调整、集成，还是堆叠等高级技术，PyCaret 的分类模块都具备。</p><h1 id="77a1" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">教程的 6.0 数据集</h1><p id="866d" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">对于本教程，我们将使用一个来自 UCI 的数据集，名为<a class="ae kv" href="https://archive.ics.uci.edu/ml/datasets/default+of+credit+card+clients" rel="noopener ugc nofollow" target="_blank"> <strong class="lq ir">信用卡客户数据集</strong> </a>的默认值。此数据集包含从 2005 年 4 月到 2005 年 9 月台湾信用卡客户的违约付款、人口统计因素、信用数据、付款历史和账单等信息。有 24，000 个样本和 25 个特征。每列的简短描述如下:</p><ul class=""><li id="f4be" class="mp mq iq lq b lr mk lu ml lx mr mb ms mf mt mj mu mv mw mx bi translated"><strong class="lq ir"> ID: </strong>每个客户端的 ID</li><li id="f000" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated"><strong class="lq ir"> LIMIT_BAL: </strong>以新台币为单位的给定额度(包括个人和家庭/补充额度)</li><li id="74c0" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated"><strong class="lq ir">性别:</strong>性别(1 =男性，2 =女性)</li><li id="3bfd" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated"><strong class="lq ir">学历:</strong>(1 =研究生院，2 =大学，3 =高中，4 =其他，5 =未知，6 =未知)</li><li id="ebcd" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated"><strong class="lq ir">婚姻:</strong>婚姻状况(1 =已婚，2 =单身，3 =其他)</li><li id="8e19" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated"><strong class="lq ir">年龄:</strong>以年为单位的年龄</li><li id="6449" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated"><strong class="lq ir"> PAY_0 至 PAY _ 6:</strong>n 个月前的还款状态(PAY_0 =上月… PAY_6 = 6 个月前)(标签:-1 =按时还款，1 =延迟一个月还款，2 =延迟两个月还款，…8 =延迟八个月还款，9 =延迟九个月及以上还款)</li><li id="2cad" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated"><strong class="lq ir"> BILL_AMT1 至 BILL _ AMT 6:</strong>n 个月前的对账单金额(BILL_AMT1 = last_month..BILL_AMT6 = 6 个月前)</li><li id="c7b4" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated"><strong class="lq ir">PAY _ am t1 to PAY _ AMT 6:</strong>n 个月前的付款金额(BILL_AMT1 = last_month..BILL_AMT6 = 6 个月前)</li><li id="b646" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated"><strong class="lq ir">违约:</strong>违约付款(1 =是，0 =否)<code class="fe nn no np ne b">Target Column</code></li></ul><h2 id="0194" class="ni kx iq bd ky nq nr dn lc ns nt dp lg lx nu nv li mb nw nx lk mf ny nz lm oa bi translated">数据集确认:</h2><p id="a4bf" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">利奇曼(2013 年)。UCI 机器学习知识库。加州欧文:加州大学信息与计算机科学学院。</p><h1 id="a413" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">7.0 获取数据</h1><p id="166d" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">您可以从这里找到的原始数据源<a class="ae kv" href="https://archive.ics.uci.edu/ml/datasets/default+of+credit+card+clients" rel="noopener ugc nofollow" target="_blank"><strong class="lq ir"/></a>下载数据，并使用 pandas <a class="ae kv" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.read_csv.html" rel="noopener ugc nofollow" target="_blank"> <strong class="lq ir">(了解如何使用)</strong> </a>加载数据，或者您可以使用 PyCaret 的数据存储库，使用<code class="fe nn no np ne b">get_data()</code>函数加载数据(这将需要互联网连接)。</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="215d" class="ni kx iq ne b gy nj nk l nl nm"><strong class="ne ir"># loading the dataset<br/></strong>from pycaret.datasets import get_data<br/>dataset = get_data('credit')</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="ab gu cl ob"><img src="../Images/9ceb0701258161240a1eef6c4568ed3e.png" data-original-src="https://miro.medium.com/v2/format:webp/1*gyuYixBHRczrmeus7vtTDA.png"/></div></figure><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="448c" class="ni kx iq ne b gy nj nk l nl nm"><strong class="ne ir"># check the shape of data<br/></strong>dataset.shape</span><span id="1148" class="ni kx iq ne b gy oc nk l nl nm">&gt;&gt;&gt; (24000, 24)</span></pre><p id="8abb" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">为了演示对看不见的数据使用<code class="fe nn no np ne b">predict_model</code>函数，从原始数据集中保留了 1200 条记录的样本(约 5%)，用于最终的预测。这不应该与训练-测试-分割相混淆，因为这种特定的分割是为了模拟真实场景而执行的。另一种思考方式是，在训练机器学习模型时，这 1200 个客户是不可用的。</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="2b82" class="ni kx iq ne b gy nj nk l nl nm"><strong class="ne ir"># sample 5% of data to be used as unseen data</strong><br/>data = dataset.sample(frac=0.95, random_state=786)<br/>data_unseen = dataset.drop(data.index)<br/>data.reset_index(inplace=True, drop=True)<br/>data_unseen.reset_index(inplace=True, drop=True)</span><span id="0345" class="ni kx iq ne b gy oc nk l nl nm"><strong class="ne ir"># print the revised shape<br/></strong>print('Data for Modeling: ' + str(data.shape))<br/>print('Unseen Data For Predictions: ' + str(data_unseen.shape))</span><span id="c848" class="ni kx iq ne b gy oc nk l nl nm">&gt;&gt;&gt; <!-- -->Data for Modeling: (22800, 24)<br/>&gt;&gt;&gt; Unseen Data For Predictions: (1200, 24)</span></pre><h1 id="ec60" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">8.0 在 PyCaret 中设置环境</h1><p id="dda3" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">PyCaret 中的<code class="fe nn no np ne b">setup</code>函数初始化环境，并为建模和部署创建转换管道。在 pycaret 中执行任何其他函数之前，必须调用<code class="fe nn no np ne b">setup</code>。它有两个强制参数:一个 pandas dataframe 和目标列的名称。所有其他参数都是可选的，可用于定制预处理管道。</p><p id="072d" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">当执行<code class="fe nn no np ne b">setup</code>时，PyCaret 的推理算法会根据某些属性自动推断出所有特性的数据类型。应该可以正确推断出数据类型，但情况并非总是如此。为了处理这个问题，一旦执行了<code class="fe nn no np ne b">setup</code>，PyCaret 就会显示一个提示，要求确认数据类型。如果所有数据类型都正确，您可以按 enter 键，或者键入<code class="fe nn no np ne b">quit</code>退出设置。</p><p id="0625" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">确保数据类型正确在 PyCaret 中非常重要，因为它会自动执行多个特定于类型的预处理任务，这些任务对于机器学习模型来说是必不可少的。</p><p id="8116" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">或者，您也可以使用<code class="fe nn no np ne b">setup</code>中的<code class="fe nn no np ne b">numeric_features</code>和<code class="fe nn no np ne b">categorical_features</code>参数来预定义数据类型。</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="2bb4" class="ni kx iq ne b gy nj nk l nl nm"><strong class="ne ir"># init setup<br/></strong>from pycaret.classification import *<br/>s = setup(data = data, target = 'default', session_id=123)</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="ab gu cl ob"><img src="../Images/c00234f1bb23556c3c5bce7556313b35.png" data-original-src="https://miro.medium.com/v2/format:webp/1*qn0vACbZbi3zhymGLG9X4A.png"/></div></figure><p id="6f8a" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">成功执行设置后，它会显示信息网格，其中包含一些关于实验的重要信息。大部分信息与执行<code class="fe nn no np ne b">setup</code>时构建的预处理流水线有关。这些特性的大部分超出了本教程的范围，但是，有一些重要的事情需要注意:</p><ul class=""><li id="c6cf" class="mp mq iq lq b lr mk lu ml lx mr mb ms mf mt mj mu mv mw mx bi translated"><strong class="lq ir"> session_id: </strong>在所有函数中作为种子分发的伪随机数，用于以后的可再现性。如果没有通过<code class="fe nn no np ne b">session_id</code>，则自动生成一个随机数，分配给所有函数。在本实验中，为了以后的再现性，将<code class="fe nn no np ne b">session_id</code>设置为<code class="fe nn no np ne b">123</code>。</li><li id="7110" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated"><strong class="lq ir">目标类型:</strong>二进制或多类。自动检测并显示目标类型。二元或多类问题的实验方式没有区别。所有功能都是相同的。</li><li id="afc5" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated"><strong class="lq ir">标签编码:</strong>当目标变量为字符串类型(即“是”或“否”)而不是 1 或 0 时，自动将标签编码为 1 和 0，并显示映射(0:否，1:是)以供参考。在这个实验中，不需要标签编码，因为目标变量是 numeric 类型。</li><li id="3856" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated"><strong class="lq ir">原始数据:</strong>显示数据集的原始形状。在这个实验中(22800，24)意味着包括目标列在内的 22800 个样本和 24 个特征。</li><li id="1768" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated"><strong class="lq ir">缺失值:</strong>当原始数据中存在缺失值时，将显示为真。对于这个实验，数据集中没有缺失值。</li><li id="f6e6" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated"><strong class="lq ir">数字特征:</strong>推断为数字的特征数量。在该数据集中，24 个要素中有 14 个被推断为数字。</li><li id="9ecc" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated"><strong class="lq ir">分类特征:</strong>被推断为分类的特征的数量。在该数据集中，24 个特征中有 9 个被推断为分类特征。</li><li id="00ae" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated"><strong class="lq ir">变换后的训练集:</strong>显示变换后的训练集的形状。注意，对于变换后的训练集,( 22800，24)的原始形状被变换为(15959，91 ),并且由于一次热编码，特征的数量从 24 增加到 91。</li><li id="c387" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated"><strong class="lq ir">转换后的测试集:</strong>显示转换后的测试/保持集的形状。测试/保留组中有 6841 个样本。该分割基于默认值 70/30，可使用设置中的<code class="fe nn no np ne b">train_size</code>参数进行更改。</li></ul><p id="7507" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">请注意，执行建模所必需的一些任务是如何自动处理的，例如缺失值插补(在这种情况下，训练数据中没有缺失值，但我们仍然需要用于未知数据的插补器)、分类编码等。<code class="fe nn no np ne b">setup</code>中的大多数参数是可选的，用于定制预处理流水线。这些参数超出了本教程的范围，但是我们将在以后的教程中介绍它们。</p><h1 id="3ba2" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">9.0 比较所有模型</h1><p id="e81c" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">一旦设置完成，比较所有模型以评估性能是建模的推荐起点(除非您确切地知道您需要哪种模型，而事实往往并非如此)。该函数训练模型库中的所有模型，并使用分层交叉验证对它们进行评分以进行指标评估。输出打印一个评分网格，显示平均准确度、AUC、召回率、精确度、F1、Kappa 和 MCC(默认为 10)以及训练时间。</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="d896" class="ni kx iq ne b gy nj nk l nl nm">best_model = compare_models()</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi od"><img src="../Images/c6522af9cbe20af3d23e86c74ccb2e17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bQANTgf0HZXAD3yFrBwLgQ.png"/></div></div></figure><p id="2d1d" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">上面打印的评分网格突出显示了最高绩效指标，仅供比较之用。默认情况下，网格使用<code class="fe nn no np ne b">Accuracy </code>(从最高到最低)排序，这可以通过传递<code class="fe nn no np ne b">sort</code>参数来更改。例如,<code class="fe nn no np ne b">compare_models(sort = 'Recall')</code>将通过回忆而不是准确性来对网格进行排序。</p><p id="5bb3" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">如果您想将折叠参数从默认值<code class="fe nn no np ne b">10</code>更改为不同的值，那么您可以使用<code class="fe nn no np ne b">fold</code>参数。例如<code class="fe nn no np ne b">compare_models(fold = 5)</code>将对所有模型进行 5 重交叉验证比较。减少折叠次数将改善训练时间。默认情况下，<code class="fe nn no np ne b">compare_models</code>根据默认的排序顺序返回性能最好的模型，但也可以通过使用<code class="fe nn no np ne b">n_select</code>参数返回前 N 个模型的列表。</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="7c37" class="ni kx iq ne b gy nj nk l nl nm">print(best_model)</span><span id="5d55" class="ni kx iq ne b gy oc nk l nl nm"><strong class="ne ir">&gt;&gt;&gt; OUTPUT</strong></span><span id="6bc9" class="ni kx iq ne b gy oc nk l nl nm">RidgeClassifier(alpha=1.0, class_weight=None, copy_X=True, fit_intercept=True,<br/>                max_iter=None, normalize=False, random_state=123, solver='auto',<br/>                tol=0.001)</span></pre><h1 id="0317" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">10.0 创建模型</h1><p id="c217" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated"><code class="fe nn no np ne b">create_model</code>是 PyCaret 中粒度最细的函数，通常是大多数 PyCaret 功能的基础。顾名思义，该函数使用交叉验证来训练和评估模型，交叉验证可以用<code class="fe nn no np ne b">fold</code>参数来设置。输出打印出一个得分网格，按倍数显示准确性、AUC、召回率、精确度、F1、Kappa 和 MCC。</p><p id="ae12" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">对于本教程的剩余部分，我们将使用下面的模型作为我们的候选模型。这些选择仅用于说明目的，并不意味着它们是此类数据的最佳选择或理想选择。</p><ul class=""><li id="1736" class="mp mq iq lq b lr mk lu ml lx mr mb ms mf mt mj mu mv mw mx bi translated">决策树分类器</li><li id="d217" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated">k 邻居分类器(“knn”)</li><li id="d392" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated">随机森林分类器(“rf”)</li></ul><p id="6931" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">PyCaret 的模型库中有 18 个可用的分类器。要查看所有分类器的列表，要么查看文档，要么使用<code class="fe nn no np ne b">models</code>功能查看库。</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="abe6" class="ni kx iq ne b gy nj nk l nl nm"><strong class="ne ir"># check available models<br/></strong>models()</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oe"><img src="../Images/26c8c6cf54eb6e93d5845de4c18c82df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g__fFq98P4PiIpQC0awYFw.png"/></div></div></figure><h2 id="6135" class="ni kx iq bd ky nq nr dn lc ns nt dp lg lx nu nv li mb nw nx lk mf ny nz lm oa bi translated">10.1 决策树分类器</h2><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="9795" class="ni kx iq ne b gy nj nk l nl nm">dt = create_model('dt')</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi of"><img src="../Images/ffe5540a02f5a72f879fd8864be9ace3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1126/format:webp/1*0vNHUKOMhPtowGcY_204zw.png"/></div></figure><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="b967" class="ni kx iq ne b gy nj nk l nl nm"><strong class="ne ir"># trained model object is stored in the variable 'dt'.</strong> <br/>print(dt)</span><span id="98e4" class="ni kx iq ne b gy oc nk l nl nm"><strong class="ne ir">&gt;&gt;&gt; OUTPUT</strong></span><span id="4feb" class="ni kx iq ne b gy oc nk l nl nm">DecisionTreeClassifier(ccp_alpha=0.0, class_weight=None, criterion='gini',<br/>                       max_depth=None, max_features=None, max_leaf_nodes=None,<br/>                       min_impurity_decrease=0.0, min_impurity_split=None,<br/>                       min_samples_leaf=1, min_samples_split=2,<br/>                       min_weight_fraction_leaf=0.0, presort='deprecated',<br/>                       random_state=123, splitter='best')</span></pre><h2 id="00f2" class="ni kx iq bd ky nq nr dn lc ns nt dp lg lx nu nv li mb nw nx lk mf ny nz lm oa bi translated">10.2 K 邻居分类器</h2><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="e31f" class="ni kx iq ne b gy nj nk l nl nm">knn = create_model('knn')</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi og"><img src="../Images/ac55509c03c49234ab12db323c045acd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1140/format:webp/1*hhWDsu0htd9VnTzGFtf4iw.png"/></div></figure><h2 id="7f50" class="ni kx iq bd ky nq nr dn lc ns nt dp lg lx nu nv li mb nw nx lk mf ny nz lm oa bi translated">10.3 随机森林分类器</h2><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="51e7" class="ni kx iq ne b gy nj nk l nl nm">rf = create_model('rf')</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/f340b1541214865156eb30b69aec4ffa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1114/format:webp/1*VAsaX2zSq_gzIyiRopR-Qw.png"/></div></figure><p id="815a" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">请注意，所有型号的平均分数与<code class="fe nn no np ne b">compare_models</code>中打印的分数相匹配。这是因为打印在<code class="fe nn no np ne b">compare_models</code>分数网格中的指标是所有简历折叠的平均分数。与<code class="fe nn no np ne b">compare_models</code>类似，如果您想将折叠参数从默认值 10 更改为不同的值，那么您可以使用<code class="fe nn no np ne b">fold</code>参数。例如:<code class="fe nn no np ne b">create_model('dt', fold = 5)</code>将使用 5 重分层 CV 创建一个决策树分类器。</p><h1 id="66f3" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">11.0 调整模型</h1><p id="9378" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">当使用<code class="fe nn no np ne b">create_model</code>功能创建模型时，它使用默认超参数来训练模型。为了调整超参数，使用<code class="fe nn no np ne b">tune_model</code>功能。该功能使用预定义搜索空间上的随机网格搜索自动调整模型的超参数。输出打印一个得分网格，显示最佳模型的准确度、AUC、召回率、精确度、F1、Kappa 和 MCC。要使用自定义搜索网格，您可以在<code class="fe nn no np ne b">tune_model</code>函数中传递<code class="fe nn no np ne b">custom_grid</code>参数(参见下面的 11.2 KNN 调谐)。</p><h2 id="d0ec" class="ni kx iq bd ky nq nr dn lc ns nt dp lg lx nu nv li mb nw nx lk mf ny nz lm oa bi translated">11.1 决策树分类器</h2><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="c38c" class="ni kx iq ne b gy nj nk l nl nm">tuned_dt = tune_model(dt)</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/9968c70243dbc625d76a84207542dd2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1116/format:webp/1*8v3NFwXDIJPQlieIfcx6PA.png"/></div></figure><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="fca5" class="ni kx iq ne b gy nj nk l nl nm"><strong class="ne ir"># tuned model object is stored in the variable 'tuned_dt'. <br/></strong>print(tuned_dt)</span><span id="8d86" class="ni kx iq ne b gy oc nk l nl nm"><strong class="ne ir">&gt;&gt;&gt; OUTPUT</strong></span><span id="2379" class="ni kx iq ne b gy oc nk l nl nm">DecisionTreeClassifier(ccp_alpha=0.0, class_weight=None, criterion='entropy',<br/>                       max_depth=6, max_features=1.0, max_leaf_nodes=None,<br/>                       min_impurity_decrease=0.002, min_impurity_split=None,<br/>                       min_samples_leaf=5, min_samples_split=5,<br/>                       min_weight_fraction_leaf=0.0, presort='deprecated',<br/>                       random_state=123, splitter='best')</span></pre><h2 id="22b6" class="ni kx iq bd ky nq nr dn lc ns nt dp lg lx nu nv li mb nw nx lk mf ny nz lm oa bi translated">11.2 K 邻居分类器</h2><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="7a75" class="ni kx iq ne b gy nj nk l nl nm">import numpy as np<br/>tuned_knn = tune_model(knn, custom_grid = {'n_neighbors' : np.arange(0,50,1)})</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi og"><img src="../Images/b37c57df4388a30879f86e6a6ba2a502.png" data-original-src="https://miro.medium.com/v2/resize:fit:1140/format:webp/1*X8Cf4zEbhfdO_FEWVYRAdA.png"/></div></figure><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="b940" class="ni kx iq ne b gy nj nk l nl nm">print(tuned_knn)</span><span id="17b5" class="ni kx iq ne b gy oc nk l nl nm"><strong class="ne ir">&gt;&gt;&gt; OUTPUT</strong></span><span id="b655" class="ni kx iq ne b gy oc nk l nl nm">KNeighborsClassifier(algorithm='auto', leaf_size=30, metric='minkowski',<br/>                     metric_params=None, n_jobs=-1, n_neighbors=42, p=2,<br/>                     weights='uniform')</span></pre><h2 id="e005" class="ni kx iq bd ky nq nr dn lc ns nt dp lg lx nu nv li mb nw nx lk mf ny nz lm oa bi translated">11.3 随机森林分类器</h2><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="5ee3" class="ni kx iq ne b gy nj nk l nl nm">tuned_rf = tune_model(rf)</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi og"><img src="../Images/a86e020869cedd06e003b01520b3416e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1140/format:webp/1*Rimlnm3zog36X4e94feqgQ.png"/></div></figure><p id="892d" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">默认情况下，<code class="fe nn no np ne b">tune_model</code>会优化<code class="fe nn no np ne b">Accuracy</code>，但这可以使用<code class="fe nn no np ne b">optimize</code>参数进行更改。例如:<code class="fe nn no np ne b">tune_model(dt, optimize = 'AUC')</code>将搜索产生最高<code class="fe nn no np ne b">AUC</code>而不是<code class="fe nn no np ne b">Accuracy</code>的决策树分类器的超参数。出于本例的目的，我们使用默认指标<code class="fe nn no np ne b">Accuracy</code>只是为了简单起见。一般来说，当数据集不平衡时(比如我们正在处理的信用数据集)，<code class="fe nn no np ne b">Accuracy</code>不是一个值得考虑的好指标。选择正确的度量来评估分类器的方法超出了本教程的范围，但是如果您想了解更多，您可以<a class="ae kv" href="https://medium.com/@MohammedS/performance-metrics-for-classification-problems-in-machine-learning-part-i-b085d432082b" rel="noopener"> <strong class="lq ir">单击此处</strong> </a>阅读关于如何选择正确的评估度量的文章。</p><p id="a61b" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在最终确定生产的最佳模型时，度量并不是您应该考虑的唯一标准。其他要考虑的因素包括训练时间、kfolds 的标准偏差等。随着教程系列的进展，我们将在中级和专家级别详细讨论这些因素。现在，让我们继续考虑调优的随机森林分类器<code class="fe nn no np ne b">tuned_rf</code>，作为本教程剩余部分的最佳模型。</p><h1 id="36e2" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">12.0 绘制模型</h1><p id="05b3" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">在模型最终确定之前，<code class="fe nn no np ne b">plot_model</code>函数可用于分析不同方面的性能，如 AUC、混淆矩阵、决策边界等。该函数接受一个经过训练的模型对象，并根据测试集返回一个图。</p><p id="5ae6" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">有 15 种不同的图可用，请参见<code class="fe nn no np ne b">plot_model</code>文档中的可用图列表。</p><h2 id="b34f" class="ni kx iq bd ky nq nr dn lc ns nt dp lg lx nu nv li mb nw nx lk mf ny nz lm oa bi translated">12.1 AUC 图</h2><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="3875" class="ni kx iq ne b gy nj nk l nl nm">plot_model(tuned_rf, plot = 'auc')</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="ab gu cl ob"><img src="../Images/80d6188642791975930410f0b2624a4d.png" data-original-src="https://miro.medium.com/v2/format:webp/1*CMa4VUkTdy8IOYdI92dAuA.png"/></div></figure><h2 id="3869" class="ni kx iq bd ky nq nr dn lc ns nt dp lg lx nu nv li mb nw nx lk mf ny nz lm oa bi translated">12.2 精确召回曲线</h2><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="9641" class="ni kx iq ne b gy nj nk l nl nm">plot_model(tuned_rf, plot = 'pr')</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="ab gu cl ob"><img src="../Images/62c533e0773b89926e0dddc876f55058.png" data-original-src="https://miro.medium.com/v2/format:webp/1*l2C9GcOMJzPqtH7-N2K06g.png"/></div></figure><h2 id="799e" class="ni kx iq bd ky nq nr dn lc ns nt dp lg lx nu nv li mb nw nx lk mf ny nz lm oa bi translated">12.3 特征重要性图</h2><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="431d" class="ni kx iq ne b gy nj nk l nl nm">plot_model(tuned_rf, plot='feature')</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="ab gu cl ob"><img src="../Images/d237df239d92780cbf78d015bee708e2.png" data-original-src="https://miro.medium.com/v2/format:webp/1*s_d57MZsX3oPLjNGHZLGpw.png"/></div></figure><h2 id="621d" class="ni kx iq bd ky nq nr dn lc ns nt dp lg lx nu nv li mb nw nx lk mf ny nz lm oa bi translated">12.4 混淆矩阵</h2><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="41b1" class="ni kx iq ne b gy nj nk l nl nm">plot_model(tuned_rf, plot = 'confusion_matrix')</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="ab gu cl ob"><img src="../Images/17a92b3a098a54153458857d5a7a8944.png" data-original-src="https://miro.medium.com/v2/format:webp/1*lv6USLe_NLrQtnUl7QY2Vw.png"/></div></figure><p id="806c" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><em class="oj">分析模型性能的另一种</em>方法是使用<code class="fe nn no np ne b">evaluate_model()</code>功能，该功能显示给定模型所有可用图的用户界面。它在内部使用<code class="fe nn no np ne b">plot_model()</code>功能。</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="78fa" class="ni kx iq ne b gy nj nk l nl nm">evaluate_model(tuned_rf)</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ok"><img src="../Images/f61449faca03752e56727ad583392c58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j-7vj82UeeVP6uxf_hGmdA.png"/></div></div></figure><h1 id="9fa1" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">13.0 预测测试/保留样品</h1><p id="c3b4" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">在最终确定模型之前，建议通过预测测试/坚持集和审查评估指标来执行最后的检查。如果您查看上面第 8 节中的信息网格，您将会看到 30% (6，841 个样本)的数据被分离出来作为测试/保留样本。我们上面看到的所有评估指标都是基于训练集(70%)的交叉验证结果。现在，使用我们存储在<code class="fe nn no np ne b">tuned_rf</code>中的最终训练模型，我们将预测测试/保留样本并评估指标，以查看它们是否与 CV 结果有实质性差异。</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="faeb" class="ni kx iq ne b gy nj nk l nl nm">predict_model(tuned_rf);</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ol"><img src="../Images/992aa600f7f81ebe0bf644d554984f0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dzdY9biiXl4enoAt3sqhMg.png"/></div></div></figure><p id="eacf" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">与在<code class="fe nn no np ne b">tuned_rf</code> CV 结果(见上文第 11.3 节)上获得的<code class="fe nn no np ne b"><strong class="lq ir">0.8203</strong></code>相比，测试/保持设置的精度为<code class="fe nn no np ne b"><strong class="lq ir">0.8116</strong></code>。这不是一个显著的差异。如果测试/保持和 CV 结果之间存在较大差异，则这通常表明过度拟合，但也可能是由于其他几个因素，需要进一步调查。在这种情况下，我们将继续最终确定模型，并根据看不见的数据进行预测(我们在开始时已经分离出来的、从未向 PyCaret 公开的 5%)。</p><p id="f78f" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">(提示:使用<code class="fe nn no np ne b">create_model</code>时，看看 CV 结果的标准差总是好的)</p><h1 id="585a" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">14.0 最终确定部署模型</h1><p id="689d" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">模型定型是实验的最后一步。PyCaret 中正常的机器学习工作流程从<code class="fe nn no np ne b">setup</code>开始，然后使用<code class="fe nn no np ne b">compare_models</code>比较所有模型，并列出几个候选模型(基于感兴趣的度量)来执行几种建模技术，如超参数调整、集成、堆叠等。这一工作流程最终将引导您找到用于对新的和未知的数据进行预测的最佳模型。<code class="fe nn no np ne b">finalize_model</code>函数将模型拟合到完整的数据集上，包括测试/保留样本(本例中为 30%)。此函数的目的是在将最终模型部署到生产中之前，在完整的数据集上对其进行训练。(这是可选的，您可以使用 finalize_model，也可以不使用)。</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="aa73" class="ni kx iq ne b gy nj nk l nl nm"><strong class="ne ir"># finalize rf model</strong><br/>final_rf = finalize_model(tuned_rf)</span><span id="78b1" class="ni kx iq ne b gy oc nk l nl nm"><strong class="ne ir"># print final model parameters</strong><br/>print(final_rf)</span><span id="5fb7" class="ni kx iq ne b gy oc nk l nl nm"><strong class="ne ir">&gt;&gt;&gt; OUTPUT</strong></span><span id="70ca" class="ni kx iq ne b gy oc nk l nl nm">RandomForestClassifier(bootstrap=False, ccp_alpha=0.0, class_weight={},<br/>                       criterion='entropy', max_depth=5, max_features=1.0,<br/>                       max_leaf_nodes=None, max_samples=None,<br/>                       min_impurity_decrease=0.0002, min_impurity_split=None,<br/>                       min_samples_leaf=5, min_samples_split=10,<br/>                       min_weight_fraction_leaf=0.0, n_estimators=150,<br/>                       n_jobs=-1, oob_score=False, random_state=123, verbose=0,<br/>                       warm_start=False)</span></pre><p id="60be" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">警告:最后一句警告。一旦模型最终确定，包括测试/拒绝集的整个数据集用于训练。因此，如果在使用<code class="fe nn no np ne b">finalize_model</code>后，该模型用于对拒绝集进行预测，打印的信息网格将会产生误导，因为您正试图对用于建模的相同数据进行预测。为了证明这一点，我们将使用<code class="fe nn no np ne b">predict_model</code>下的<code class="fe nn no np ne b">final_rf</code>来比较信息网格和上面第 13 节中的信息网格。</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="8363" class="ni kx iq ne b gy nj nk l nl nm">predict_model(final_rf);</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi om"><img src="../Images/07007349f939befd74bf187acb311cb0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ppFWgyUKpGJy202BBCSsKA.png"/></div></div></figure><p id="7219" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">请注意<code class="fe nn no np ne b">final_rf</code>中的 AUC 是如何从<code class="fe nn no np ne b"><strong class="lq ir">0.7407</strong></code>增加到<code class="fe nn no np ne b"><strong class="lq ir">0.7526</strong></code>的，尽管模型是相同的。这是因为<code class="fe nn no np ne b">final_rf</code>变量已经在包括测试/拒绝集的完整数据集上进行了训练。</p><h1 id="cfe1" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">15.0 根据看不见的数据进行预测</h1><p id="732f" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated"><code class="fe nn no np ne b">predict_model</code>函数也用于对未知数据集进行预测。与上面第 13 节唯一不同的是，这次我们将通过<code class="fe nn no np ne b">data_unseen</code>。它是在本教程开始时创建的变量，包含原始数据集的 5% (1200 个样本)，该数据集从未暴露给 PyCaret。(参见第 7 节的解释)</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="9640" class="ni kx iq ne b gy nj nk l nl nm">unseen_predictions = predict_model(final_rf, data=data_unseen)<br/>unseen_predictions.head()</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="ab gu cl ob"><img src="../Images/0d9497bbf61a5ebed2f572bd55bd41b9.png" data-original-src="https://miro.medium.com/v2/format:webp/1*y-XuhIFV4uSlN06lOrs8pw.png"/></div></figure><p id="5dfd" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><code class="fe nn no np ne b">Label</code>和<code class="fe nn no np ne b">Score</code>列被添加到<code class="fe nn no np ne b">data_unseen</code>组中。标签是预测，分数是预测的概率。请注意，当所有转换都在后台自动执行时，预测结果会连接到原始数据集。您还可以检查这方面的指标，因为您有一个实际的目标列<code class="fe nn no np ne b">default</code>可用。为此，我们将使用<code class="fe nn no np ne b">pycaret.utils</code>模块。请参见下面的示例:</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="019a" class="ni kx iq ne b gy nj nk l nl nm"><strong class="ne ir"># check metric on unseen data<br/></strong>from pycaret.utils import check_metric<br/>check_metric(unseen_predictions['default'], unseen_predictions['Label'], metric = 'Accuracy')</span><span id="32cd" class="ni kx iq ne b gy oc nk l nl nm"><strong class="ne ir">&gt;&gt;&gt; OUTPUT<br/></strong>0.8167</span></pre><h1 id="0a58" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">16.0 保存模型</h1><p id="61ec" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">我们现在已经通过最终确定<code class="fe nn no np ne b">tuned_rf</code>模型完成了实验，该模型现在存储在<code class="fe nn no np ne b">final_rf</code>变量中。我们还使用存储在<code class="fe nn no np ne b">final_rf</code>中的模型来预测<code class="fe nn no np ne b">data_unseen</code>。这使我们的实验接近尾声，但仍有一个问题要问:当你有更多的新数据要预测时，会发生什么？你必须再次经历整个实验吗？答案是否定的，PyCaret 的内置函数<code class="fe nn no np ne b">save_model()</code>允许您保存模型和整个转换管道以备后用。</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="f0f5" class="ni kx iq ne b gy nj nk l nl nm"><strong class="ne ir"># saving the final model<br/></strong>save_model(final_rf,'Final RF Model 11Nov2020')</span><span id="655a" class="ni kx iq ne b gy oc nk l nl nm">&gt;&gt;&gt; Transformation Pipeline and Model Successfully Saved</span></pre><h1 id="5bfb" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">17.0 加载保存的模型</h1><p id="4278" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">为了在将来的某一天在相同或不同的环境中加载已保存的模型，我们将使用 PyCaret 的<code class="fe nn no np ne b">load_model()</code>函数，然后轻松地将已保存的模型应用于新的未知数据进行预测。</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="cc89" class="ni kx iq ne b gy nj nk l nl nm"><strong class="ne ir"># loading the saved model</strong><br/>saved_final_rf = load_model('Final RF Model 11Nov2020')</span><span id="91a1" class="ni kx iq ne b gy oc nk l nl nm">&gt;&gt;&gt; Transformation Pipeline and Model Successfully Loaded</span></pre><p id="ac5f" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">一旦模型加载到环境中，您就可以使用相同的<code class="fe nn no np ne b">predict_model()</code>函数简单地使用它来预测任何新数据。下面我们应用加载模型来预测我们在上面第 13 节中使用的相同的<code class="fe nn no np ne b">data_unseen</code>。</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="6cf4" class="ni kx iq ne b gy nj nk l nl nm"><strong class="ne ir"># predict on new data<br/></strong>new_prediction = predict_model(saved_final_rf, data=data_unseen)<br/>new_prediction.head()</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="ab gu cl ob"><img src="../Images/0d9497bbf61a5ebed2f572bd55bd41b9.png" data-original-src="https://miro.medium.com/v2/format:webp/1*y-XuhIFV4uSlN06lOrs8pw.png"/></div></figure><p id="f5ee" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">注意<code class="fe nn no np ne b">unseen_predictions</code>和<code class="fe nn no np ne b">new_prediction</code>的结果是相同的。</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="ae2f" class="ni kx iq ne b gy nj nk l nl nm">from pycaret.utils import check_metric<br/>check_metric(new_prediction['default'], new_prediction['Label'], metric = 'Accuracy')</span><span id="b64a" class="ni kx iq ne b gy oc nk l nl nm">&gt;&gt;&gt; 0.8167</span></pre><h1 id="94a0" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">18.0 总结/后续步骤？</h1><p id="89c5" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">本教程涵盖了从数据摄取、预处理、训练模型、超参数调整、预测和保存模型以备后用的整个机器学习管道。我们已经在不到 10 个命令中完成了所有这些步骤，这些命令是自然构建的，记忆起来非常直观，例如<code class="fe nn no np ne b">create_model()</code>、<code class="fe nn no np ne b">tune_model()</code>、<code class="fe nn no np ne b">compare_models()</code>。在没有 PyCaret 的情况下，重新创建整个实验在大多数库中需要 100 多行代码。</p><p id="c2d4" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我们只讲述了<code class="fe nn no np ne b">pycaret.classification</code>的基础知识。在未来的教程中，我们将更深入地研究高级预处理、集成、广义堆叠和其他技术，这些技术允许您完全定制您的机器学习管道，并且是任何数据科学家都必须知道的。</p><p id="0ecd" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">感谢您阅读<a class="ae kv" href="https://emojipedia.org/folded-hands/" rel="noopener ugc nofollow" target="_blank">🙏</a></p></div><div class="ab cl on oo hu op" role="separator"><span class="oq bw bk or os ot"/><span class="oq bw bk or os ot"/><span class="oq bw bk or os"/></div><div class="ij ik il im in"><h1 id="c7df" class="kw kx iq bd ky kz ou lb lc ld ov lf lg jw ow jx li jz ox ka lk kc oy kd lm ln bi translated">重要链接</h1><p id="35e1" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">⭐ <a class="ae kv" href="https://github.com/pycaret/pycaret/tree/master/tutorials" rel="noopener ugc nofollow" target="_blank">教程</a>py caret 新手？查看我们的官方笔记本！<br/>📋<a class="ae kv" href="https://github.com/pycaret/pycaret/tree/master/examples" rel="noopener ugc nofollow" target="_blank">社区创建的示例笔记本</a>。<br/>📙<a class="ae kv" href="https://github.com/pycaret/pycaret/tree/master/resources" rel="noopener ugc nofollow" target="_blank">博客</a>投稿人的教程和文章。<br/>📚<a class="ae kv" href="https://pycaret.readthedocs.io/en/latest/index.html" rel="noopener ugc nofollow" target="_blank">文档</a>py caret 的详细 API 文档<br/>📺<a class="ae kv" href="https://www.youtube.com/channel/UCxA1YTYJ9BEeo50lxyI_B3g" rel="noopener ugc nofollow" target="_blank">视频教程</a>我们的视频教程来自各种赛事。<br/>📢<a class="ae kv" href="https://github.com/pycaret/pycaret/discussions" rel="noopener ugc nofollow" target="_blank">讨论</a>有疑问？与社区和贡献者互动。<br/> 🛠️ <a class="ae kv" href="https://github.com/pycaret/pycaret/blob/master/CHANGELOG.md" rel="noopener ugc nofollow" target="_blank">变更日志</a>变更和版本历史。<br/>🌳<a class="ae kv" href="https://github.com/pycaret/pycaret/issues/1756" rel="noopener ugc nofollow" target="_blank">路线图</a> PyCaret 的软件和社区开发计划。</p><h1 id="7ad2" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">作者:</h1><p id="146f" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">我写的是 PyCaret 及其在现实世界中的用例，如果你想自动得到通知，你可以在<a class="ae kv" href="https://medium.com/@moez-62905" rel="noopener">媒体</a>、<a class="ae kv" href="https://www.linkedin.com/in/profile-moez/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>和<a class="ae kv" href="https://twitter.com/moezpycaretorg1" rel="noopener ugc nofollow" target="_blank"> Twitter </a>上关注我。</p></div></div>    
</body>
</html>