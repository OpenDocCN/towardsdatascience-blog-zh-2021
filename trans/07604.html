<html>
<head>
<title>How to group yearly data by periods</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何按期间对年度数据进行分组</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-group-yearly-data-by-periods-5199a1dba5db?source=collection_archive---------13-----------------------#2021-07-12">https://towardsdatascience.com/how-to-group-yearly-data-by-periods-5199a1dba5db?source=collection_archive---------13-----------------------#2021-07-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="6a95" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">我将向您展示如何用Pandas将每年的数据分成给定长度的时间段，以及如何用Matplotlib绘制它们</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/e9de4a2fbbf33d1639ff5114252593f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i8wLraFfHvmaJcboFY1u2A.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">凯莉·贝丝·威廉姆斯在<a class="ae kv" href="https://unsplash.com/s/photos/baskets?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><p id="03e9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">去年春天，在我参加的一个课程中，一个客户让我将一些年度历史数据可视化为线图。由于每年可用的数据非常少，客户希望将这些年分成几个时间段。此外，如果年度范围不能与所选的期间长度平均分割，则最后一个期间应该更短。</p><h2 id="5a82" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">让我向您介绍一下我的解决方案</h2><p id="591b" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">首先，我们需要一些数据，我们可以根据年份列将这些数据分成不同的时间段。今天我选择用加拿大的气候历史数据来展示，这些数据可以从<a class="ae kv" href="https://www.kaggle.com/aturner374/eighty-years-of-canadian-climate-data#" rel="noopener ugc nofollow" target="_blank"> Kaggle </a>获得知识共享许可。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">使用的数据集中的前10行。该数据集包含从1940年初到2019年底加拿大八个测量点的日平均温度和降水量。</p></figure><p id="c3eb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将使用熊猫，NumPy和Plotly</p><pre class="kg kh ki kj gt ms mt mu mv aw mw bi"><span id="8b8a" class="ls lt iq mt b gy mx my l mz na">import pandas as pd<br/>import numpy as np<br/>import matplotlib.pyplot as plt</span></pre><p id="78d6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们从将数据读入数据帧开始。然后，让我们缩小数据范围，只包括“本地日期”和“平均温度多伦多”两列。</p><pre class="kg kh ki kj gt ms mt mu mv aw mw bi"><span id="5307" class="ls lt iq mt b gy mx my l mz na">df = pd.read_csv('Canadian_climate_history.csv')<br/>df = df[['LOCAL_DATE', 'MEAN_TEMPERATURE_TORONTO']]</span></pre><p id="c231" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要创建year列，让我们首先将“LOCAL_DATE”列更改为datetime，它的初始类型是object。从日期时间类型列中，我们可以提取年份信息，如下所示。</p><pre class="kg kh ki kj gt ms mt mu mv aw mw bi"><span id="0851" class="ls lt iq mt b gy mx my l mz na">df['LOCAL_DATE'] = pd.to_datetime(df['LOCAL_DATE'])<br/>df['YEAR'] = df['LOCAL_DATE'].dt.year</span></pre><p id="f0e4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">结果列的类型是integer，就像我在春天得到的数据一样。</p><pre class="kg kh ki kj gt ms mt mu mv aw mw bi"><span id="f5ad" class="ls lt iq mt b gy mx my l mz na">0        1940<br/>1        1940<br/>2        1940<br/>3        1940<br/>4        1940<br/>         ... <br/>29216    2019<br/>29217    2019<br/>29218    2019<br/>29219    2019<br/>29220    2020<br/>Name: YEAR, Length: 29221, dtype: int64</span></pre><p id="fd48" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了得到结果，我们将调查1940-2019年的范围和20年的周期长度。对于全年范围，我们会得到一个很好的平均分割，但由于数据中只有一个2020年的测量值，这没有意义。</p><pre class="kg kh ki kj gt ms mt mu mv aw mw bi"><span id="63df" class="ls lt iq mt b gy mx my l mz na">period_length = 20</span><span id="174e" class="ls lt iq mt b gy nb my l mz na">start_year = 1940<br/>end_year = 2019</span><span id="df80" class="ls lt iq mt b gy nb my l mz na">df = df[(df['YEAR'] &gt;= 1940) &amp; (df['YEAR'] &lt;= 2019)]</span></pre><p id="bbcd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了检查分割是否均匀，以及为了确定最后一个周期的长度，我们将取模。</p><pre class="kg kh ki kj gt ms mt mu mv aw mw bi"><span id="9364" class="ls lt iq mt b gy mx my l mz na">year_range = end_year - start_year</span><span id="a098" class="ls lt iq mt b gy nb my l mz na">modulo = year_range % period_length</span><span id="e36d" class="ls lt iq mt b gy nb my l mz na"># For 1940–2019 the modulo is 19</span></pre><p id="59dc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，让我们找出最后一期的起止年份。增加一个也是为了包括去年。否则，2019年将被遗漏，因为它将是下一个时期(如果有的话)的开始年。</p><pre class="kg kh ki kj gt ms mt mu mv aw mw bi"><span id="e744" class="ls lt iq mt b gy mx my l mz na">if modulo == 0:<br/>    final_start = end_year - period_length<br/>else:<br/>    final_start = end_year - modulo</span><span id="bac0" class="ls lt iq mt b gy nb my l mz na">final_end = end_year + 1</span></pre><p id="cc8e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，我继续使用NumPy创建一个列表，列出该年范围内所有较早开始的年份。</p><pre class="kg kh ki kj gt ms mt mu mv aw mw bi"><span id="469d" class="ls lt iq mt b gy mx my l mz na">starts = np.arange(start_year, final_start, period_length).tolist()</span></pre><p id="92eb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，让我们创建元组列表，其中每个元组类似于(period_start，period_end)。从这些元组中，我们最终可以创建熊猫<a class="ae kv" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.IntervalIndex.html" rel="noopener ugc nofollow" target="_blank">interval index</a>的库。</p><pre class="kg kh ki kj gt ms mt mu mv aw mw bi"><span id="4758" class="ls lt iq mt b gy mx my l mz na">tuples = [(start, start+period_length) for start in starts]<br/># We'll add the last period calculated earlier<br/>tuples.append(tuple([final_start, final_end]))</span><span id="7994" class="ls lt iq mt b gy nb my l mz na">bins = pd.IntervalIndex.from_tuples(tuples, closed='left')</span></pre><p id="d0a2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，通过将它们转换为字符串，这些bin可以很好地转换为标签。例如，当周期长度为20时，“1940，1960”将是第一个标签。在这里，我们可以看到bin是如何显示周期在左边关闭，在右边打开的。为了清楚起见，我同意客户将它们描述为“1940-1959”。我创建了一个字典，便于在数据框中替换。</p><pre class="kg kh ki kj gt ms mt mu mv aw mw bi"><span id="b8b5" class="ls lt iq mt b gy mx my l mz na">original_labels = list(bins.astype(str))</span><span id="4504" class="ls lt iq mt b gy nb my l mz na">new_labels = ['{} - {}'.format(b.strip('[)').split(', ')[0], int(b.strip('[)').split(', ')[1])-1) for b in original_labels]</span><span id="e3f8" class="ls lt iq mt b gy nb my l mz na">label_dict = dict(zip(original_labels, new_labels))</span><span id="657d" class="ls lt iq mt b gy nb my l mz na"><br/># The label dict when year range is 1940-2019</span><span id="c53b" class="ls lt iq mt b gy nb my l mz na">{'[1940, 1960)': '1940 - 1959',<br/> '[1960, 1980)': '1960 - 1979',<br/> '[1980, 2000)': '1980 - 1999',<br/> '[2000, 2020)': '2000 - 2019'}</span></pre><p id="a657" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，使用Pandas <a class="ae kv" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.cut.html" rel="noopener ugc nofollow" target="_blank"> cut() </a>，我们可以轻松地将year列的内容放入这些bin中，并创建一个新列“PERIOD”。最后，在label_dict的帮助下，bin标签被替换。</p><pre class="kg kh ki kj gt ms mt mu mv aw mw bi"><span id="1b02" class="ls lt iq mt b gy mx my l mz na"># Assign each row to a period<br/>df['PERIOD'] = pd.cut(df['YEAR'], bins=bins, include_lowest=True, precision=0)<br/>df['PERIOD'] = df['PERIOD'].astype("str")<br/>df = df.replace(label_dict)</span></pre><p id="7a80" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，我们按照PERIOD列对数据进行分组。我去掉了年份一栏，只是为了让df更整洁。</p><pre class="kg kh ki kj gt ms mt mu mv aw mw bi"><span id="75f2" class="ls lt iq mt b gy mx my l mz na">df = df.groupby('PERIOD').mean().reset_index().drop('YEAR', axis=1)</span></pre><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">最终数据帧</p></figure><p id="2fb9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们可以用Matplotlib可视化它</p><pre class="kg kh ki kj gt ms mt mu mv aw mw bi"><span id="2618" class="ls lt iq mt b gy mx my l mz na"># Styling of the figure<br/>fig = plt.figure()<br/>fig.set_figwidth(12)<br/>fig.set_figheight(5)<br/>fig.patch.set_facecolor('white')</span><span id="1198" class="ls lt iq mt b gy nb my l mz na">plt.plot(df['PERIOD'], df['MEAN_TEMPERATURE_TORONTO'], color='#004cff')</span><span id="37e6" class="ls lt iq mt b gy nb my l mz na">plt.title(f"20-year average of daily mean temperatures in Toronto between {start_year} and {end_year}")<br/>plt.xlabel("Period") <br/>plt.ylabel("Mean temperature") </span><span id="eed7" class="ls lt iq mt b gy nb my l mz na"># Styling of the plot<br/>plt.grid(color = 'white', linewidth = 1)<br/>plt.locator_params(axis='y', nbins=6)</span><span id="5893" class="ls lt iq mt b gy nb my l mz na"># Styling of the axes<br/>ax = plt.gca()<br/>ax.set_facecolor('#e6ecf7')<br/>ax.spines['top'].set_visible(False)<br/>ax.spines['right'].set_visible(False)<br/>ax.spines['bottom'].set_visible(False)<br/>ax.spines['left'].set_visible(False)<br/>ax.tick_params(axis=u'both', which=u'both',length=0)</span><span id="d5d2" class="ls lt iq mt b gy nb my l mz na">plt.show()</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nc"><img src="../Images/ea9529d3e597592e3b1b78b7f43b499a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7139G_q4JvZzApc31WBv-A.png"/></div></div></figure><h2 id="bda9" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">结论</h2><p id="182d" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">当每年只有少量可用的数据点，或者当数据点的数量在各年之间变化很大时，为每年的数据创建周期是有益的。为了清楚起见，我鼓励用确切的年份(例如“1940-1959”)来标记周期，而不是用数学区间来表示限制是封闭的还是开放的(例如“[1940-1960)”)。</p></div><div class="ab cl nd ne hu nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ij ik il im in"><p id="93b4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢您的阅读！如果你学到了新的东西或者喜欢这篇文章，<a class="ae kv" href="https://medium.com/@miiaramo/follow" rel="noopener">在Medium </a>上跟随我。我目前正在撰写关于NLP和数据工程的未来文章。你也可以在<a class="ae kv" href="https://www.linkedin.com/in/miiaramo/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上找到我。</p><p id="75f4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你对完成这项任务有其他想法吗？如果你能在评论中告诉我，那就太好了😊</p></div></div>    
</body>
</html>