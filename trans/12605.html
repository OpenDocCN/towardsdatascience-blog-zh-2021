<html>
<head>
<title>How To Build Scikit-learn Pipelines Like A Pro</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何构建 Scikit-像专家一样学习管道</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-build-scikit-learn-pipelines-like-a-pro-107c1ffec225?source=collection_archive---------17-----------------------#2021-12-27">https://towardsdatascience.com/how-to-build-scikit-learn-pipelines-like-a-pro-107c1ffec225?source=collection_archive---------17-----------------------#2021-12-27</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="a247" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">通过一个迷你项目，学习构建预处理、建模以及网格搜索管道的简单方法</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/dead7783d27a4a09bd050f9dc5c9535b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Nd44z6L5llXAy9-c"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated"><a class="ae kz" href="https://unsplash.com/@vork?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">马克老板</a>在<a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</p></figure><p id="2f06" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">每次为项目选择数据集时，您的任务都是清理和预处理数据、处理缺失数据和异常值、建模，甚至执行超参数搜索以找到用于评估的最佳超参数集。</p><p id="5620" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">显然，在代码中用<strong class="lc iv">管道</strong>可以方便快捷地做到这一点。</p><p id="71d2" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在本文中，我们将浏览一个相当流行的 Kaggle 数据集，执行所有这些步骤，并构建一个真正的 sklearn 管道来学习。</p><p id="a826" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们开始吧👇</p><h1 id="1de1" class="lw lx iu bd ly lz ma mb mc md me mf mg ka mh kb mi kd mj ke mk kg ml kh mm mn bi translated">探索数据集</h1><p id="2567" class="pw-post-body-paragraph la lb iu lc b ld mo jv lf lg mp jy li lj mq ll lm ln mr lp lq lr ms lt lu lv in bi translated">我们将在这个迷你项目中使用的数据集将来自 Kaggle — <a class="ae kz" href="https://www.kaggle.com/andrewmvd/heart-failure-clinical-data" rel="noopener ugc nofollow" target="_blank">心力衰竭检测表格数据集</a>，可在 Creative Common 的许可下获得。从下面的 Kaggle 链接获取:</p><div class="mt mu gq gs mv mw"><a href="https://www.kaggle.com/andrewmvd/heart-failure-clinical-data" rel="noopener  ugc nofollow" target="_blank"><div class="mx ab fp"><div class="my ab mz cl cj na"><h2 class="bd iv gz z fq nb fs ft nc fv fx it bi translated">心力衰竭预测</h2><div class="nd l"><h3 class="bd b gz z fq nb fs ft nc fv fx dk translated">预测死亡事件的 12 个临床特征。</h3></div><div class="ne l"><p class="bd b dl z fq nb fs ft nc fv fx dk translated">www.kaggle.com</p></div></div><div class="nf l"><div class="ng l nh ni nj nf nk kt mw"/></div></div></a></div><p id="6428" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们导入一下，看看是什么样子的！</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nl nm l"/></div></figure><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj nn"><img src="../Images/2405a967fa038bd7003472f9517e3d1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T24WTdYnKNuFUcGJUMTEUg.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">按作者分类的图像-数据预览</p></figure><p id="79e0" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">下一步是将数据集分成训练集和测试集。除了最后一列是“<strong class="lc iv">死亡事件</strong>”之外，我们有所有用于训练的特征。查看最后一列，我们可以看到这是一个<strong class="lc iv">二进制分类</strong>任务。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nl nm l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">列车测试分离</p></figure><pre class="kk kl km kn gu no np nq nr aw ns bi"><span id="b7bf" class="nt lx iu np b gz nu nv l nw nx">The shape of the data:</span><span id="5c46" class="nt lx iu np b gz ny nv l nw nx">Output:</span><span id="18d8" class="nt lx iu np b gz ny nv l nw nx">((209, 12), (90, 12), (209,), (90,))</span></pre><p id="67e5" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">最后，我们探索数据集的所有数字列:</p><pre class="kk kl km kn gu no np nq nr aw ns bi"><span id="1864" class="nt lx iu np b gz nu nv l nw nx">X_train.describe().T</span></pre><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj nz"><img src="../Images/fd8103337c165c49825b66ce2c9b121a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KYjS13LsR7irGFfO1J-DSw.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">按作者分类的图像-描述数据集</p></figure><p id="c7cf" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">查看分类数据，我们确认没有:</p><pre class="kk kl km kn gu no np nq nr aw ns bi"><span id="2fb7" class="nt lx iu np b gz nu nv l nw nx"># there are no categorical features</span><span id="e532" class="nt lx iu np b gz ny nv l nw nx">categorical_features = X_train.select_dtypes(exclude='number').columns.tolist()</span><span id="4ba9" class="nt lx iu np b gz ny nv l nw nx">categorical_features</span></pre><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj oa"><img src="../Images/c73bd814d923630329f9d16b8a3a81f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GIb50K4oi3_Vj5JRY9Fv-Q.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">作者提供的图片-无猫特征</p></figure><p id="895b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">现在，我们可以继续建设我们的管道了！</p><h1 id="7efc" class="lw lx iu bd ly lz ma mb mc md me mf mg ka mh kb mi kd mj ke mk kg ml kh mm mn bi translated">我们的 Scikit-learn 管道</h1><h2 id="e1d2" class="nt lx iu bd ly ob oc dn mc od oe dp mg lj of og mi ln oh oi mk lr oj ok mm ol bi translated">预处理流水线</h2><p id="0dcd" class="pw-post-body-paragraph la lb iu lc b ld mo jv lf lg mp jy li lj mq ll lm ln mr lp lq lr ms lt lu lv in bi translated">首先，我们构建预处理管道。它将由两个组件组成——1)一个用于将数据转换到(0，1)之间的<code class="fe om on oo np b"><strong class="lc iv">MinMaxScalar</strong></code>实例，以及 2)一个用于使用列中现有值的平均值填充缺失值的<code class="fe om on oo np b"><strong class="lc iv">SimpleImputer</strong></code>实例。</p><pre class="kk kl km kn gu no np nq nr aw ns bi"><span id="c3ec" class="nt lx iu np b gz nu nv l nw nx">col_transformation_pipeline = Pipeline(steps=[</span><span id="9f29" class="nt lx iu np b gz ny nv l nw nx">    ('impute', SimpleImputer(strategy='mean')),</span><span id="893d" class="nt lx iu np b gz ny nv l nw nx">    ('scale', MinMaxScaler())</span><span id="1196" class="nt lx iu np b gz ny nv l nw nx">])</span></pre><p id="f611" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们用一个<code class="fe om on oo np b"><strong class="lc iv">ColumnTransformer</strong></code>把它们放在一起。</p><p id="cb67" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">A <code class="fe om on oo np b"><strong class="lc iv">ColumnTransformer</strong></code> <strong class="lc iv"> </strong>可以接受由我们需要应用于数据的不同列转换组成的元组。对于每个转换，它还需要一个列列表。因为这里只有数字列，所以我们将所有的列都提供给列转换器对象。</p><p id="ccab" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">那么让我们把它们放在一起:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nl nm l"/></div></figure><p id="466c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">厉害！我们管道的第一部分完成了！</p><p id="f6a3" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">让我们现在去建立我们的模型。</p><h2 id="5885" class="nt lx iu bd ly ob oc dn mc od oe dp mg lj of og mi ln oh oi mk lr oj ok mm ol bi translated">模型管道</h2><p id="941e" class="pw-post-body-paragraph la lb iu lc b ld mo jv lf lg mp jy li lj mq ll lm ln mr lp lq lr ms lt lu lv in bi translated">我们为此任务选择了一个随机的森林分类器。让我们旋转一个快速分类器对象:</p><pre class="kk kl km kn gu no np nq nr aw ns bi"><span id="3388" class="nt lx iu np b gz nu nv l nw nx"># random forest classifier</span><span id="5427" class="nt lx iu np b gz ny nv l nw nx">rf_classifier = RandomForestClassifier(n_estimators = 11, criterion='entropy', random_state=0)</span></pre><p id="5181" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">而且，我们可以将预处理和模型结合在一个管道中:</p><pre class="kk kl km kn gu no np nq nr aw ns bi"><span id="3efc" class="nt lx iu np b gz nu nv l nw nx">rf_model_pipeline = Pipeline(steps=[</span><span id="f6c1" class="nt lx iu np b gz ny nv l nw nx">    ('preprocessing', columns_transformer),</span><span id="dd74" class="nt lx iu np b gz ny nv l nw nx">    ('rf_model', rf_classifier),</span><span id="f156" class="nt lx iu np b gz ny nv l nw nx">])</span></pre><p id="3837" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">现在，拟合我们的训练数据非常简单:</p><pre class="kk kl km kn gu no np nq nr aw ns bi"><span id="78f9" class="nt lx iu np b gz nu nv l nw nx">rf_model_pipeline.fit(X_train, y_train)</span></pre><p id="908b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">最后，我们可以预测我们的测试集，并计算我们的准确度分数:</p><pre class="kk kl km kn gu no np nq nr aw ns bi"><span id="663c" class="nt lx iu np b gz nu nv l nw nx"># predict on test set</span><span id="5383" class="nt lx iu np b gz ny nv l nw nx">y_pred = rf_model_pipeline.predict(X_test)</span></pre><p id="2e8e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">综合起来看:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nl nm l"/></div></figure><p id="0a52" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这一切都很好。但是，如果我说您也可以使用这个管道执行网格搜索来查找最佳超参数，那会怎么样呢？那不是很酷吗？</p><p id="4f4f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">接下来让我们来探索一下！</p><h1 id="b4e7" class="lw lx iu bd ly lz ma mb mc md me mf mg ka mh kb mi kd mj ke mk kg ml kh mm mn bi translated">在我们的管道中使用 GridSearch</h1><p id="ab0a" class="pw-post-body-paragraph la lb iu lc b ld mo jv lf lg mp jy li lj mq ll lm ln mr lp lq lr ms lt lu lv in bi translated">我们已经建立并使用我们的模型来预测我们的数据集。我们现在将关注于为我们的随机森林模型寻找最佳超参数。</p><p id="b1c1" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">让我们首先建立我们的参数网格:</p><pre class="kk kl km kn gu no np nq nr aw ns bi"><span id="ab30" class="nt lx iu np b gz nu nv l nw nx">params_dict = {'rf_model__n_estimators' : np.arange(5, 100, 1), 'rf_model__criterion': ['gini', 'entropy'], 'rf_model__max_depth': np.arange(10, 200, 5)}</span></pre><p id="0d06" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在这种情况下，我们着重于调整模型的三个参数:</p><ol class=""><li id="a871" class="op oq iu lc b ld le lg lh lj or ln os lr ot lv ou ov ow ox bi translated"><strong class="lc iv"> n_estimators </strong>:随机森林中的树木数量，</li></ol><p id="e44d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">2.<strong class="lc iv">标准</strong>:测量分割质量的功能，以及</p><p id="c4de" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">3.<strong class="lc iv">最大深度:</strong>树的最大深度</p><p id="9797" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><strong class="lc iv">这里需要注意的一件重要事情是</strong>:在我们的网格中，我们不是简单地使用<code class="fe om on oo np b"><strong class="lc iv">n_estimators</strong></code>作为参数名，而是使用:<code class="fe om on oo np b"><strong class="lc iv">rf_model__n_estimators</strong></code>。这里的<code class="fe om on oo np b"><strong class="lc iv">rf_model__</strong></code>前缀来自我们为管道中的随机森林模型选择的名称。(参考上一节)。</p><p id="7394" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">接下来，我们简单地使用 GridSearch 模块来训练我们的分类器:</p><pre class="kk kl km kn gu no np nq nr aw ns bi"><span id="7e7d" class="nt lx iu np b gz nu nv l nw nx">grid_search = GridSearchCV(rf_model_pipeline, params_dict, cv=10, n_jobs=-1)</span><span id="7c51" class="nt lx iu np b gz ny nv l nw nx">grid_search.fit(X_train, y_train)</span></pre><p id="5350" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">让我们把所有这些放在一起:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nl nm l"/></div></figure><p id="de30" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">现在，用我们的<code class="fe om on oo np b"><strong class="lc iv">grid_search</strong></code>物体来预测很容易，就像这样:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj oy"><img src="../Images/5b7ee3dd0a4d225d670080d28aa91397.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yRnLIK0Bou7AoKmLT7SF2Q.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">按作者分类的图像—准确度分数</p></figure><p id="d299" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">厉害！我们现在已经为我们的项目建立了一个完整的管道！</p><h1 id="da43" class="lw lx iu bd ly lz ma mb mc md me mf mg ka mh kb mi kd mj ke mk kg ml kh mm mn bi translated">几句临别赠言…</h1><p id="17a5" class="pw-post-body-paragraph la lb iu lc b ld mo jv lf lg mp jy li lj mq ll lm ln mr lp lq lr ms lt lu lv in bi translated">所以，你有它！由预处理器、模型和网格搜索组成的完整 sklearn 管道都在 Kaggle 的一个迷你项目上进行实验。我希望你会发现这篇教程很有启发性，并且很容易理解。</p><p id="95d2" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">是时候表扬一下自己了！😀</p><p id="eadc" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在这里找到本教程的完整代码。这是我所有数据科学文章的代码库。如果你愿意的话，请给它标上星号和书签！</p><p id="c70a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">将来，我会回来写更多基于 Scikit-learn 的文章。所以<a class="ae kz" href="https://ipom.medium.com/" rel="noopener">跟着我</a>在媒体上，并留在循环！</p><h2 id="84a8" class="nt lx iu bd ly ob oc dn mc od oe dp mg lj of og mi ln oh oi mk lr oj ok mm ol bi translated"><a class="ae kz" href="https://ipom.medium.com/membership/" rel="noopener">我还建议成为一名中等会员，不要错过我每周发表的任何数据科学文章。</a>在此加入👇</h2><div class="mt mu gq gs mv mw"><a href="https://ipom.medium.com/membership" rel="noopener follow" target="_blank"><div class="mx ab fp"><div class="my ab mz cl cj na"><h2 class="bd iv gz z fq nb fs ft nc fv fx it bi translated">通过我的推荐链接加入 Medium—Yash pra kash</h2><div class="nd l"><h3 class="bd b gz z fq nb fs ft nc fv fx dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="ne l"><p class="bd b dl z fq nb fs ft nc fv fx dk translated">ipom.medium.com</p></div></div><div class="nf l"><div class="oz l nh ni nj nf nk kt mw"/></div></div></a></div></div><div class="ab cl pa pb hy pc" role="separator"><span class="pd bw bk pe pf pg"/><span class="pd bw bk pe pf pg"/><span class="pd bw bk pe pf"/></div><div class="in io ip iq ir"><h1 id="0863" class="lw lx iu bd ly lz ph mb mc md pi mf mg ka pj kb mi kd pk ke mk kg pl kh mm mn bi translated">接通电话！</h1><blockquote class="pm pn po"><p id="ea28" class="la lb pp lc b ld le jv lf lg lh jy li pq lk ll lm pr lo lp lq ps ls lt lu lv in bi translated"><em class="iu">关注我</em> <a class="ae kz" href="https://twitter.com/csandyash" rel="noopener ugc nofollow" target="_blank"> <em class="iu">推特</em> </a> <em class="iu">。<br/> </em> <a class="ae kz" href="https://github.com/yashprakash13/data-another-day" rel="noopener ugc nofollow" target="_blank"> <em class="iu">查看我所有数据科学帖子的完整代码库！</em> </a></p></blockquote><p id="e216" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我的其他几篇文章你可能会感兴趣:</p><div class="mt mu gq gs mv mw"><a rel="noopener follow" target="_blank" href="/the-nice-way-to-deploy-an-ml-model-using-docker-91995f072fe8"><div class="mx ab fp"><div class="my ab mz cl cj na"><h2 class="bd iv gz z fq nb fs ft nc fv fx it bi translated">使用 Docker 部署 ML 模型的好方法</h2><div class="nd l"><h3 class="bd b gz z fq nb fs ft nc fv fx dk translated">使用 FastAPI 部署 ML 模型并在 VSCode 中轻松封装它的快速指南。</h3></div><div class="ne l"><p class="bd b dl z fq nb fs ft nc fv fx dk translated">towardsdatascience.com</p></div></div><div class="nf l"><div class="pt l nh ni nj nf nk kt mw"/></div></div></a></div><div class="mt mu gq gs mv mw"><a rel="noopener follow" target="_blank" href="/31-datasets-for-your-next-data-science-project-6ef9a6f8cac6"><div class="mx ab fp"><div class="my ab mz cl cj na"><h2 class="bd iv gz z fq nb fs ft nc fv fx it bi translated">您下一个数据科学项目的 31 个数据集</h2><div class="nd l"><h3 class="bd b gz z fq nb fs ft nc fv fx dk translated">基于任务的数据集的汇编，可用于构建下一个数据科学项目</h3></div><div class="ne l"><p class="bd b dl z fq nb fs ft nc fv fx dk translated">towardsdatascience.com</p></div></div><div class="nf l"><div class="pu l nh ni nj nf nk kt mw"/></div></div></a></div><div class="mt mu gq gs mv mw"><a rel="noopener follow" target="_blank" href="/how-to-use-bash-to-automate-the-boring-stuff-for-data-science-d447cd23fffe"><div class="mx ab fp"><div class="my ab mz cl cj na"><h2 class="bd iv gz z fq nb fs ft nc fv fx it bi translated">如何使用 Bash 来自动化数据科学的枯燥工作</h2><div class="nd l"><h3 class="bd b gz z fq nb fs ft nc fv fx dk translated">使用命令行为您的数据科学项目编写一些可重用代码的指南</h3></div><div class="ne l"><p class="bd b dl z fq nb fs ft nc fv fx dk translated">towardsdatascience.com</p></div></div><div class="nf l"><div class="pv l nh ni nj nf nk kt mw"/></div></div></a></div></div></div>    
</body>
</html>