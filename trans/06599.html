<html>
<head>
<title>Graph Coloring with networkx</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">网络图着色</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/graph-coloring-with-networkx-88c45f09b8f4?source=collection_archive---------4-----------------------#2021-06-14">https://towardsdatascience.com/graph-coloring-with-networkx-88c45f09b8f4?source=collection_archive---------4-----------------------#2021-06-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="37d2" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">图着色问题的解决方案在概念上很简单，但在应用上却很强大。本教程将向您展示如何使用python技能来解决这个问题。</h2></div><p id="b5a3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们从一个可能的现实生活挑战开始，我想让你相信网络理论和在这个领域发展起来的数学工具可以为你解决这个问题。</p><p id="3125" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">想象你现在在一所学校的行政部门工作了几年。制定考试时间表是很痛苦的，但到目前为止，用纸和笔还是可以做到的。但是学校发展得非常快，整个时间安排变得令人不堪重负。注册的学生如此之多，你希望他们都能在放假前参加考试。如果学生在假期后不得不回来参加考试，那将是多么可怕。你打算怎么解决这个问题？</p><p id="908d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我认为，到本文结束时，你可以从野外获取数据，例如学生名单和他们参加的课程，并建立一个考试时间表，这样没有学生会遇到考试日期冲突的尴尬情况。着色问题不仅对考试时间表有用，而且在许多不同的情况下都有用。也许你想出了另一个主意，我会很高兴在评论区听到你的意见！</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi lb"><img src="../Images/ea7fa95a24f3a1b377677557c4a889f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*YHkJAUwvKuP4K2tD"/></div></div><p class="ln lo gj gh gi lp lq bd b be z dk translated"><a class="ae lr" href="https://unsplash.com/@rohankrishnann?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">罗汉</a>在<a class="ae lr" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</p></figure><p id="bea2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们开始这个简短的教程之前，我想和你分享一下这篇文章的学习目标，你可以边学习边核对。</p><h1 id="b6d1" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">目录</h1><ol class=""><li id="0829" class="mk ml iq kh b ki mm kl mn ko mo ks mp kw mq la mr ms mt mu bi translated">python中的网络与库网络x</li><li id="b2ce" class="mk ml iq kh b ki mv kl mw ko mx ks my kw mz la mr ms mt mu bi translated">图着色问题，是什么，怎么解决？</li><li id="9eec" class="mk ml iq kh b ki mv kl mw ko mx ks my kw mz la mr ms mt mu bi translated">解决实际问题</li></ol></div><div class="ab cl na nb hu nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="ij ik il im in"><h1 id="adfc" class="ls lt iq bd lu lv nh lx ly lz ni mb mc jw nj jx me jz nk ka mg kc nl kd mi mj bi translated">Python中的网络</h1><p id="dfbe" class="pw-post-body-paragraph kf kg iq kh b ki mm jr kk kl mn ju kn ko nm kq kr ks nn ku kv kw no ky kz la ij bi translated">我假设你熟悉网络理论或也称为图论。如果没有，让我们回顾一下网络中最基本的模块，同时了解networkx的功能。</p><pre class="lc ld le lf gt np nq nr ns aw nt bi"><span id="3bb7" class="nu lt iq nq b gy nv nw l nx ny">import networkx as nx</span></pre><p id="9b3a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您的计算机或虚拟环境中没有networkx，请使用</p><pre class="lc ld le lf gt np nq nr ns aw nt bi"><span id="2b16" class="nu lt iq nq b gy nv nw l nx ny">pip install networkx</span></pre><p id="fad1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者</p><pre class="lc ld le lf gt np nq nr ns aw nt bi"><span id="6bb3" class="nu lt iq nq b gy nv nw l nx ny">conda install networkx</span></pre><p id="6a1b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们用这个库创建一个网络，称之为network。</p><pre class="lc ld le lf gt np nq nr ns aw nt bi"><span id="db55" class="nu lt iq nq b gy nv nw l nx ny">network = nx.Graph()</span></pre><p id="1736" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">网络由节点和连接节点的边组成。让我们在网络中添加三个节点和两条边。</p><p id="2bce" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于多个节点，我们可以提供节点名称列表。在这种情况下，节点被称为1、2和3..</p><pre class="lc ld le lf gt np nq nr ns aw nt bi"><span id="af7a" class="nu lt iq nq b gy nv nw l nx ny">network.add_nodes_from([1,2,3])<br/>print(f"This network has now {network.number_of_nodes()} nodes.")</span></pre><p id="de7c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个网络现在有3个节点..</p><p id="29f5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要在两个节点之间添加边，请命名要相互连接的第一个和第二个节点。</p><pre class="lc ld le lf gt np nq nr ns aw nt bi"><span id="309e" class="nu lt iq nq b gy nv nw l nx ny">network.add_edge(1,2)<br/>network.add_edge(1,3)</span></pre></div><div class="ab cl na nb hu nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="ij ik il im in"><p id="6883" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们也可以绘制这个网络来获得视觉上的理解。</p><pre class="lc ld le lf gt np nq nr ns aw nt bi"><span id="92d5" class="nu lt iq nq b gy nv nw l nx ny">nx.draw_networkx(network, with_labels=True)</span></pre><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/980419c8d83375a52fe8f2d44fb6171e.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/format:webp/1*rKbGerurmbv3mC-AXAolKA.png"/></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">简单图的非常简单的图</p></figure><p id="1467" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以总结这一段，我们知道网络是由什么组成的，如何用networkx来构建和可视化。如果我想描述这个图，我会说，这个图G由三个节点组成，分别叫1，2，3。其中节点2与节点1相邻，节点3与节点1相邻。节点1与节点2和3相邻。好了，现在够了。让我们继续着色问题。</p></div><div class="ab cl na nb hu nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="ij ik il im in"><h1 id="e61a" class="ls lt iq bd lu lv nh lx ly lz ni mb mc jw nj jx me jz nk ka mg kc nl kd mi mj bi translated">图着色问题</h1><p id="c6a4" class="pw-post-body-paragraph kf kg iq kh b ki mm jr kk kl mn ju kn ko nm kq kr ks nn ku kv kw no ky kz la ij bi translated">图着色问题定义为:</p><pre class="lc ld le lf gt np nq nr ns aw nt bi"><span id="58d0" class="nu lt iq nq b gy nv nw l nx ny">Given a graph G and k colors, assign a color to each node so that adjacent nodes get different colors.</span></pre><p id="00dd" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从这个意义上说，颜色是类别的另一个词。让我们看看前面的例子，添加两到三个节点，并给它们分配不同的颜色。</p><pre class="lc ld le lf gt np nq nr ns aw nt bi"><span id="e283" class="nu lt iq nq b gy nv nw l nx ny">network.add_nodes_from([4,5,6,7])</span><span id="524f" class="nu lt iq nq b gy oa nw l nx ny">network.add_edge(1,4)<br/>network.add_edge(1,5)<br/>network.add_edge(2,4)<br/>network.add_edge(3,5)<br/>network.add_edge(5,6)<br/>network.add_edge(7,3)<br/>network.add_edge(7,6)</span></pre><p id="81d3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">好的，让我们手动给这个图着色，来解决着色问题。</p><pre class="lc ld le lf gt np nq nr ns aw nt bi"><span id="b81b" class="nu lt iq nq b gy nv nw l nx ny">color_list = ["gold", "violet", "violet", "violet",<br/>              "limegreen", "limegreen", "darkorange"]<br/>nx.draw_networkx(network,node_color=color_list, with_labels=True)</span></pre><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/6fe8ac467456ffb55562b0aad447d0a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/format:webp/1*Mo-SsOII3lBp-clv3Vc08Q.png"/></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">解决着色问题的首次尝试</p></figure><p id="41b9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">好吧，这不是我们想要的。节点5和6颜色相同但相邻，节点4和2也相邻但颜色相同。我们必须解决这个问题。</p><pre class="lc ld le lf gt np nq nr ns aw nt bi"><span id="3ab7" class="nu lt iq nq b gy nv nw l nx ny">color_list = [“gold”, “red”, “violet”, “pink”, “limegreen”,<br/>              “violet”, “darkorange”]</span></pre><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/869772f255377d0749e7db1b1b552f16.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/format:webp/1*W9p0coQi66SxaXCfTHG9mg.png"/></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">着色问题的有效解决方案</p></figure><p id="e6c5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">好的，这看起来是解决图表着色问题的一个可能的解决方案。但是你可能会问自己，我怎么知道我需要多少种颜色？我们现在来看一个制作考试时间表的玩具例子，这个例子变得更加清晰。</p></div><div class="ab cl na nb hu nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="ij ik il im in"><h1 id="e779" class="ls lt iq bd lu lv nh lx ly lz ni mb mc jw nj jx me jz nk ka mg kc nl kd mi mj bi translated">实际例子</h1><p id="abcf" class="pw-post-body-paragraph kf kg iq kh b ki mm jr kk kl mn ju kn ko nm kq kr ks nn ku kv kw no ky kz la ij bi translated">在这个实际的例子中，我们试图为一个学期的考试安排找到一个最优的解决方案。</p><p id="4214" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我创建了一个由250名学生组成的人工数据集，这些学生就读于我们的虚拟学校，该学校提供5个专业，也可以作为辅修专业。每个学生可以注册5门课，如果她或他注册了辅修专业和主修专业的组合(有10%的学生注册了),那么她或他可以选择主修专业的3门课和辅修专业的2门课。否则，如果他们只学习一个专业，他们会从他们的主要科目中选择所有5个讲座。每个科目提供6至9门课程(班)。</p><p id="1541" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我在kaggle上用下面的<a class="ae lr" href="https://www.kaggle.com/yvesboutellier/synthetic-school-enrollment-data" rel="noopener ugc nofollow" target="_blank">链接</a>上传了这个数据集。我们下载它并用熊猫来阅读csv。csv具有以下结构。行显示学生，列1显示专业，列2显示辅修专业，如果她或他有一个。第3栏到第42栏是不同的主题。</p><pre class="lc ld le lf gt np nq nr ns aw nt bi"><span id="5453" class="nu lt iq nq b gy nv nw l nx ny">import pandas as pd</span><span id="a1e6" class="nu lt iq nq b gy oa nw l nx ny">student_data = pd.read_csv("synthetic_school_enrollment_data.csv")</span></pre><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi ob"><img src="../Images/0c111eeeace917c4c48998de3e0ea029.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Tyhfx0u7z8OU-Ms8HkkUBA.png"/></div></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">摘自我们的数据</p></figure><p id="4704" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">到目前为止，我还没有告诉你我们将如何防止学生有冲突的考试日期。但是现在我们已经为解决这个问题做好了一切准备。</p><p id="aed1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我之前提到过，在着色问题中，我们希望防止相邻(邻近)节点具有相同的颜色。在我们的例子中，我们希望避免学生不得不同时参加两次考试。</p><p id="929c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这两个问题听起来差不多！</p><p id="ebab" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我们可以提出这样的想法，我们希望将课程建模为节点，将考试日期建模为颜色，如果这些节点共享参与的学生，则它们是连接的。因此，当没有相邻的课程/节点具有相同的日期/颜色时，我们的考试安排被解决。好的，让我们创建一个网络，将我们的40门课程作为节点，如果参与的学生共享，就将它们连接起来。</p><p id="2562" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">创建一个我们40门课程的列表。</p><pre class="lc ld le lf gt np nq nr ns aw nt bi"><span id="84ad" class="nu lt iq nq b gy nv nw l nx ny">courses = list(student_data.columns)[2:]</span></pre><p id="f86c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用networkx创建一个网络对象，并为40个课程中的每一个课程添加一个节点</p><pre class="lc ld le lf gt np nq nr ns aw nt bi"><span id="069b" class="nu lt iq nq b gy nv nw l nx ny">class_network = nx.Graph()<br/>class_network.add_nodes_from(courses)</span></pre><p id="b60c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们添加边来连接节点。如果A班和b班至少有一个学生，那么这两个班之间就有一条边。</p><p id="e466" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">每个学生参加5门课程。我想把它们打包到一个列表中，这样我就可以在这个列表中所有可能的组合之间创建边，因为这个学生不能同时参加这5个考试中的任何一个。因此，我在学生中循环，并为每个学生列出一个清单。</p><pre class="lc ld le lf gt np nq nr ns aw nt bi"><span id="1eb1" class="nu lt iq nq b gy nv nw l nx ny">without_subj = student_data.drop([‘Major’, ‘Minor’], axis=1) # We don’t need major and minor for the moment<br/>without_subj = without_subj.T # transpose</span><span id="cf23" class="nu lt iq nq b gy oa nw l nx ny">list_of_overlaps = []<br/>for student in name_list:<br/>list_of_overlaps.append(list(without_subj.loc[without_subj[student]].index))</span></pre><p id="80a4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下一步使用一个库(itertools ),它有一个很酷的功能，叫做组合。第一个参数是您想要组合的列表，第二个参数表示一个组合由多少个元素组成。我提供了一个小例子，让您熟悉这个功能。</p><pre class="lc ld le lf gt np nq nr ns aw nt bi"><span id="eef9" class="nu lt iq nq b gy nv nw l nx ny">import itertools</span><span id="9146" class="nu lt iq nq b gy oa nw l nx ny">for pair in itertools.combinations([1,2,3],2):<br/> print(pair)</span><span id="be6b" class="nu lt iq nq b gy oa nw l nx ny">(1, 2)<br/>(1, 3)<br/>(2, 3)</span></pre><p id="0917" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我们循环遍历为每个学生创建的重叠列表，然后将列表中的每门课程与其他课程相结合。这使我们能够获得线对并在它们之间形成边。</p><pre class="lc ld le lf gt np nq nr ns aw nt bi"><span id="8094" class="nu lt iq nq b gy nv nw l nx ny">for sublist in list_of_overlaps:<br/>   for pair in itertools.combinations(sublist, 2):<br/>      class_network.add_edge(pair[0], pair[1])</span></pre><p id="6085" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个过程产生了259个类之间的连接。</p><pre class="lc ld le lf gt np nq nr ns aw nt bi"><span id="a7b3" class="nu lt iq nq b gy nv nw l nx ny">n_edges_total = len(list(class_network.edges))</span><span id="b6ba" class="nu lt iq nq b gy oa nw l nx ny">print(n_edges_total)<br/>259</span></pre><p id="a6e0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">描述一个图可能有多少个连接或边的公式是。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi oc"><img src="../Images/49b533c5da0c88b6c74fbe34c07c071e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*18YMGykev-1Dp1poE3p_dA.png"/></div></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">公式背后的直觉非常简单，试着说服自己从一个3节点的网络开始，到4和5。</p></figure><pre class="lc ld le lf gt np nq nr ns aw nt bi"><span id="ebce" class="nu lt iq nq b gy nv nw l nx ny">n_nodes = len(list(class_network.nodes))<br/>n_edges_possible = (n_nodes*(n_nodes-1))/2</span></pre><p id="c81b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该图中有780条可能的边，我们在学校示例中的特定图有259条，因此实现了33%的可能边。</p><p id="3e5b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以看看我们学校的网络，上面显示了课程和共享的学生。</p><pre class="lc ld le lf gt np nq nr ns aw nt bi"><span id="1ecd" class="nu lt iq nq b gy nv nw l nx ny">fig = plt.figure(figsize=(12,12))<br/>nx.draw_networkx(class_network, with_labels=True)</span></pre><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi od"><img src="../Images/54529941b3c438b88bcf3a5279a28134.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oLmrrAezvG_1-uvom_A4UA.png"/></div></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">我们虚构的学校例子中的班级</p></figure></div><div class="ab cl na nb hu nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="ij ik il im in"><p id="2b42" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">好了，让我们为着色问题建立算法。首先，我想说这是一个NP完全问题，也就是说只能用强力算法才能找到解决方案。所以基本上，我们做的是:</p><ol class=""><li id="da2e" class="mk ml iq kh b ki kj kl km ko oe ks of kw og la mr ms mt mu bi translated">随机排列节点</li><li id="6cf9" class="mk ml iq kh b ki mv kl mw ko mx ks my kw mz la mr ms mt mu bi translated">给颜色排序(如果颜色代表日期，从你的第一个日期开始)</li><li id="5598" class="mk ml iq kh b ki mv kl mw ko mx ks my kw mz la mr ms mt mu bi translated">一次处理一个节点，将列表中的第一个合法颜色分配给我们的节点</li></ol><p id="62a2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为这是一个NP完全问题，我们不能得到比这个贪婪算法更好的算法。</p><p id="893a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae lr" href="http://Greedy Algorithms | Brilliant Math &amp; Science Wiki" rel="noopener ugc nofollow" target="_blank">贪婪算法<strong class="kh ir"/>是一种简单、直观的<strong class="kh ir">算法</strong>，用于最优化问题。<strong class="kh ir">算法</strong>在每一步都做出最优选择，试图找到解决整个问题的整体最优方法。</a></p><p id="ed75" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">并且不同的排序(步骤1)可以为相同的图给出不同的结果。</p><p id="8201" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了证明这一点，我们将运行该算法几次以获得一个示例。</p><p id="588a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你感兴趣，这个<a class="ae lr" href="https://youtu.be/h9wxtqoa1jY" rel="noopener ugc nofollow" target="_blank">视频</a>给出了数学基础的解释。有一点我想说的很重要，就是算法在max使用max n+1个颜色，其中n是我们网络中最高度的数字。节点v_i的度表示一个特定的节点v_i连接了多少个节点。</p><p id="0628" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以通过调用network.degree来找出我们的网络有多少度，这可以转换成一个字典，我们取最大值。</p><pre class="lc ld le lf gt np nq nr ns aw nt bi"><span id="a712" class="nu lt iq nq b gy nv nw l nx ny">max(dict(class_network.degree).values())</span></pre><p id="1c97" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它在我们的网络23中。但请记住，这是上限，也许我们可以做得更好。24 (23+1)真的是一个好数字吗？我们必须看看我们提供了多少门课程，看看我们是否可以将考试日期缩短。</p><pre class="lc ld le lf gt np nq nr ns aw nt bi"><span id="0be7" class="nu lt iq nq b gy nv nw l nx ny">len(courses)</span></pre><p id="c3ad" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">哦，我们有40节课！因此，至少可以节省16个日期，这是令人鼓舞的。也许更少的日期是可能的？为了节约起见，我将准备24种不同的颜色(来自matplotlib)，这是我们需要的最大数量的颜色。</p><pre class="lc ld le lf gt np nq nr ns aw nt bi"><span id="c623" class="nu lt iq nq b gy nv nw l nx ny">colors = [<br/>"lightcoral", "gray", "lightgray", "firebrick", "red", "chocolate", "darkorange", "moccasin", "gold", "yellow", "darkolivegreen", "chartreuse", "forestgreen", "lime", "mediumaquamarine", "turquoise", "teal", "cadetblue", "dogerblue", "blue", "slateblue", "blueviolet", "magenta", "lightsteelblue"]</span></pre><p id="23d5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还需要24个可能的考试日期，我们可以将考试分配到这些日期，还需要一个将颜色转换为日期时间对象的字典。</p><pre class="lc ld le lf gt np nq nr ns aw nt bi"><span id="fc9a" class="nu lt iq nq b gy nv nw l nx ny">from datetime import datetime<br/>dates = []<br/>calendar = {}<br/>for i in list(range(14,20)):<br/>    for j in list(range(10,18,2)):<br/>        date = datetime(2021, 6, i, j, 0)<br/>        dates.append(date)<br/>        calendar[date] = []</span></pre><p id="b8a8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们的翻译词典:</p><pre class="lc ld le lf gt np nq nr ns aw nt bi"><span id="f519" class="nu lt iq nq b gy nv nw l nx ny">from_color_to_date = {col: dates[i] for i, col in enumerate(colors)}</span></pre><p id="832a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们可以编写我们的贪婪算法了…</p><pre class="lc ld le lf gt np nq nr ns aw nt bi"><span id="b959" class="nu lt iq nq b gy nv nw l nx ny">def <strong class="nq ir">greedy_coloring_algorithm</strong>(network, colors):<br/>    nodes = list(network.nodes()) <br/>    random.shuffle(nodes) # <strong class="nq ir">step 1</strong> random ordering<br/>    for node in nodes:<br/>        dict_neighbors = dict(network[node])</span><span id="890a" class="nu lt iq nq b gy oa nw l nx ny"># gives names of nodes that are neighbors<br/>        nodes_neighbors = list(dict_neighbors.keys())<br/>        <br/>        forbidden_colors = []<br/>        for neighbor in nodes_neighbors:<br/>            example.nodes.data()[1]<br/>            len(example.nodes.data()[1].keys())<br/>            if len(network.nodes.data()[neighbor].keys()) == 0: <br/>                # if the neighbor has no color, proceed<br/>                continue<br/>            else:<br/>                # if the neighbor has a color,<br/>                # this color is forbidden<br/>                example.nodes.data()[1]['color']<br/>                forbidden_color = network.nodes.data()[neighbor]<br/>                forbidden_color = forbidden_color['color']</span><span id="01c9" class="nu lt iq nq b gy oa nw l nx ny">                forbidden_colors.append(forbidden_color)</span><span id="45bd" class="nu lt iq nq b gy oa nw l nx ny">        # assign the first color <br/>        # that is not forbidden<br/>        for color in colors:<br/>            # <strong class="nq ir">step 2</strong>: start everytime at the top of the colors,<br/>            # so that the smallest number of colors is used<br/>            if color in forbidden_colors:<br/>                continue<br/>            else:<br/>                # <strong class="nq ir">step 3</strong>: color one node at the time<br/>                network.nodes[node]['color'] = color<br/>                break</span></pre><p id="d202" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">运行算法</p><pre class="lc ld le lf gt np nq nr ns aw nt bi"><span id="2ffa" class="nu lt iq nq b gy nv nw l nx ny">greedy_coloring_algorithm(class_network, colors)</span></pre><p id="8590" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">是时候看结果了。让我获取每个节点的颜色值，并将其传递给一个名为colors_node的列表。</p><pre class="lc ld le lf gt np nq nr ns aw nt bi"><span id="7998" class="nu lt iq nq b gy nv nw l nx ny">colors_nodes = [data[‘color’] for v, data in class_network.nodes(data=True)]</span><span id="6371" class="nu lt iq nq b gy oa nw l nx ny">nx.draw(class_network, node_color=colors_nodes, with_labels=True)</span></pre><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi oi"><img src="../Images/3df8bc172235e68c5cd62866ce3a76ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RQvIpj-xgHrCXg8B8KQuzQ.png"/></div></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">我们的解决方案至少在视觉上，看起来不需要太多的颜色</p></figure><p id="f454" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这张图表看起来很有希望。有点乱。但是我们也可以查看颜色列表，看看我们最终需要多少种颜色或日期。</p><pre class="lc ld le lf gt np nq nr ns aw nt bi"><span id="82cc" class="nu lt iq nq b gy nv nw l nx ny">len(set(colors_nodes))</span></pre><p id="2557" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">10!我们的40次考试只需要10次约会。谁会想到呢？对我来说，这是惊人的。如此强大的工具。</p><p id="0294" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是如前所述，这种算法不会可靠地生成10个类别，它肯定会生成24个或更少，但是会有多少，取决于我们给节点着色的顺序。</p><p id="db92" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们对不同的排序做一个简短的比较，看看我们能得到什么，如果我们能得到比10更好的话。</p><pre class="lc ld le lf gt np nq nr ns aw nt bi"><span id="e3d0" class="nu lt iq nq b gy nv nw l nx ny">number = []<br/>for i in list(range(0,50)):<br/>    greedy_coloring_algorithm(class_network, colors)<br/>    colors_nodes = [data['color'] for v, data in class_network.nodes(data=True)]<br/>    num_col = len(set(colors_nodes))<br/>    number.append(num_col)</span><span id="39af" class="nu lt iq nq b gy oa nw l nx ny">[10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10]</span></pre><p id="4dc1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">好的，看起来这个网络很容易解决着色问题。我们每次都得到同样的结果。</p><p id="3dde" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们的最终目标是为我们学校的校长提供一份考试时间表。我们假设考试持续1.5小时，学生有30分钟的休息时间。</p><pre class="lc ld le lf gt np nq nr ns aw nt bi"><span id="52ee" class="nu lt iq nq b gy nv nw l nx ny">for v, data in class_network.nodes(data=True):<br/>    calendar[from_color_to_date[data['color']]].append(v)</span><span id="67df" class="nu lt iq nq b gy oa nw l nx ny">max_number_exams_sync = len(max(list(calendar.values()),key=len))</span><span id="0233" class="nu lt iq nq b gy oa nw l nx ny">rooms = ["Room "+str(i) for i in list(range(max_number_exams_sync))]</span><span id="63cd" class="nu lt iq nq b gy oa nw l nx ny">pd.DataFrame.from_dict(calendar, orient='index', columns=rooms)</span></pre><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi oj"><img src="../Images/380ca0307d5d26045e14d1f5abf58356.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KQ2aLfZwE6aDxPMnxrZUrA.png"/></div></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">我们的最终结果，显然是可以对持续暂停等提供更多的约束。</p></figure><p id="c5d3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">开始了。我们可以自豪地把考试时间表交给校长，他会惊讶地发现我们只用了2.5天就能完成所有的考试。</p><h2 id="6cbb" class="nu lt iq bd lu ok ol dn ly om on dp mc ko oo op me ks oq or mg kw os ot mi ou bi translated">结论</h2><p id="e82b" class="pw-post-body-paragraph kf kg iq kh b ki mm jr kk kl mn ju kn ko nm kq kr ks nn ku kv kw no ky kz la ij bi translated">我声称你将能够使用一些数据和图形着色算法来自动完成困难的任务。您已经看到了如何使用networkx创建图形，以及如何在python中应用这样的图形着色算法。我用一个很好的应用程序向你展示了这个相当理论化的算法，如果你在一所希望防止考试日期冲突的学校工作，你会看到一个可能的解决方案。但如果没有，我希望你仍然可以将这些知识转移到你的领域。让我知道它是否帮助你在你面临的挑战中找到了解决方案。</p></div></div>    
</body>
</html>