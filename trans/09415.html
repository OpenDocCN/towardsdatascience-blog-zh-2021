<html>
<head>
<title>How to Structure DDD in Golang</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何构建戈朗的DDD</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-structure-ddd-in-golang-28a7c3e7263b?source=collection_archive---------13-----------------------#2021-09-01">https://towardsdatascience.com/how-to-structure-ddd-in-golang-28a7c3e7263b?source=collection_archive---------13-----------------------#2021-09-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8abf" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">关于如何在Go中用DDD方法组织代码和包结构的后续文章</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/1522f7127eed07def459351d76933efe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e73b4nNIuvXisMF26Qeovw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">是时候清理代码结构了。上田拓也的Gopher，勒内·弗伦奇的原始Go Gopher(CC 3.0)</p></figure><p id="b813" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在Go项目中使用DDD时，是时候看看更好的架构解决方案了。在本文中，我们将采用一个包含所有DDD组件的存储库，并展示如何在维护DDD的同时管理一个不太复杂的项目设置。</p><p id="4ad3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们将要改变的库来自我以前写的一篇关于如何在Go中实现DDD的文章。在那篇文章中，我解释了Eric Evans所解释的DDD的所有组成部分。这个库可以在<a class="ae lu" href="https://github.com/percybolmer/ddd-go" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到。</p><div class="lv lw gp gr lx ly"><a rel="noopener follow" target="_blank" href="/how-to-implement-domain-driven-design-ddd-in-golang-2e2139beb09d"><div class="lz ab fo"><div class="ma ab mb cl cj mc"><h2 class="bd iu gy z fp md fr fs me fu fw is bi translated">如何在Golang中实现领域驱动设计(DDD)</h2><div class="mf l"><h3 class="bd b gy z fp md fr fs me fu fw dk translated">学习如何在Go应用程序中使用DDD的简单方法</h3></div><div class="mg l"><p class="bd b dl z fp md fr fs me fu fw dk translated">towardsdatascience.com</p></div></div><div class="mh l"><div class="mi l mj mk ml mh mm ks ly"/></div></div></a></div><blockquote class="mn mo mp"><p id="9ecf" class="ky kz mq la b lb lc ju ld le lf jx lg mr li lj lk ms lm ln lo mt lq lr ls lt im bi translated">本文中绘制的所有图像均由珀西·博尔梅勒绘制，地鼠由<a class="ae lu" href="https://twitter.com/tenntenn" rel="noopener ugc nofollow" target="_blank">拓也·上田</a>绘制，灵感来自蕾妮·弗伦奇的作品。图像中的地鼠已被修改</p></blockquote><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mu mv l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">如果你想看这篇文章的视频，可以在Youtube上找到</p></figure><h2 id="6503" class="mw mx it bd my mz na dn nb nc nd dp ne lh nf ng nh ll ni nj nk lp nl nm nn no bi translated">将聚合移动到其域包中</h2><p id="e17e" class="pw-post-body-paragraph ky kz it la b lb np ju ld le nq jx lg lh nr lj lk ll ns ln lo lp nt lr ls lt im bi translated">首先要做的是把<code class="fe nu nv nw nx b">aggregate</code>包一起去掉。我们学习了什么是聚合以及应用什么规则，我们不一定要命名要聚合的包。我倾向于将聚合放在它们各自的域包中，所以<code class="fe nu nv nw nx b">Customer</code>聚合应该放在<code class="fe nu nv nw nx b">customer</code>域中。在我看来这更有意义。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/6bd55cdc75b07dc6b70808760a178079.png" data-original-src="https://miro.medium.com/v2/resize:fit:782/format:webp/1*V2peW_o-M4wEI_bzZqGs4w.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">从聚合包中删除客户聚合</p></figure><p id="86ba" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当然，在将文件移动到<code class="fe nu nv nw nx b">customer</code>域后，您还需要更改任何指向<code class="fe nu nv nw nx b">aggregate.Customer</code>的引用，如果您在客户包中，就用<code class="fe nu nv nw nx b">customer.Customer</code>或<code class="fe nu nv nw nx b">Customer</code>替换它。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz mv l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">customer/repository.go —删除对聚合包的所有提及</p></figure><p id="0f84" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">必须对<code class="fe nu nv nw nx b">Product</code>聚合执行同样的操作，它应该进入<code class="fe nu nv nw nx b">product</code>域。我不会涵盖所有的代码更改，找到并重构所有提到的<code class="fe nu nv nw nx b">aggregate</code>包应该很容易。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/d188459462321ec35b66ce0a3ff574f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:754/format:webp/1*Ydy_uTz_ATryN0n-r4-1xg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">包含产品集合的产品域</p></figure><p id="fd14" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在我看来，以这种方式在他们的域包中包含聚合看起来更好，也更有意义。</p><p id="8076" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">删除聚合文件夹，我们已经整理了一些代码气味。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/8aad0f01f3daec5f2ac950becdbb4357.png" data-original-src="https://miro.medium.com/v2/resize:fit:780/format:webp/1*cCShTiof4F6o18sTI5NEag.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">该项目的改进结构，但尚未完成</p></figure><h2 id="2725" class="mw mx it bd my mz na dn nb nc nd dp ne lh nf ng nh ll ni nj nk lp nl nm nn no bi translated">移动值对象和实体</h2><p id="a69e" class="pw-post-body-paragraph ky kz it la b lb np ju ld le nq jx lg lh nr lj lk ll ns ln lo lp nt lr ls lt im bi translated">对于<code class="fe nu nv nw nx b">entity</code>和<code class="fe nu nv nw nx b">valueobject</code>，我们仍然有一个文件夹，我想这没有错。以这种方式将共享结构存储在单独的包中的一个好处是避免了循环导入。</p><p id="d10b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">不过，我们可以用另一种不那么臃肿的方式来实现这一点。现在我们根本没有根包。将实体和值对象中的所有文件移动到根目录，并将包重命名为<code class="fe nu nv nw nx b">tavern</code></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz mv l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">item.go在根目录下，包名为tavern</p></figure><p id="6ee1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这给我们留下了一个更好的结构。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/0e6fc9ed05146fd4997da7f5f47be9a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1096/format:webp/1*7Bgw0Aq986mkncULJOkLvg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">将实体和其他共享项目移动到根包中</p></figure><p id="575d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您还需要将<code class="fe nu nv nw nx b">go.mod</code>中的模块重命名为合适的名称。</p><pre class="kj kk kl km gt od nx oe of aw og bi"><span id="41a5" class="mw mx it nx b gy oh oi l oj ok">module github.com/percybolmer/tavern</span></pre><p id="6b38" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">不仅如此，我们需要更改所有文件中的所有导入来反映这一更改，并且<code class="fe nu nv nw nx b">entities</code>包的所有引用都必须更改为<code class="fe nu nv nw nx b">tavern</code>，如下所示。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz mv l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">用tavern替换实体的所有实例，以及所有导入。</p></figure><p id="497d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">所有以<code class="fe nu nv nw nx b">github.com/percybolmer/go-ddd</code>开头的导入都改为<code class="fe nu nv nw nx b">github.com/percybolmer/tavern</code>。</p><p id="120e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">应用此更改的最简单方法是更改所有文件，删除go.mod和go.sum文件，并用新名称<code class="fe nu nv nw nx b">go mod init github.com/percybolmer/tavern</code>重新初始化go模块。</p><p id="dcac" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是相当的重构练习，但它是值得的。请随意重新运行任何测试，这样您就知道它正在按预期工作。</p><h2 id="ec2e" class="mw mx it bd my mz na dn nb nc nd dp ne lh nf ng nh ll ni nj nk lp nl nm nn no bi translated">拆分服务包</h2><p id="0001" class="pw-post-body-paragraph ky kz it la b lb np ju ld le nq jx lg lh nr lj lk ll ns ln lo lp nt lr ls lt im bi translated">现在，服务包包含同一个包中的所有服务。我想把这些分成两个包，<code class="fe nu nv nw nx b">Order</code>和<code class="fe nu nv nw nx b">Tavern</code>。</p><p id="37e8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">原因是随着项目的增长，将服务分成更小的包是很好的。在我看来，把它们都放在同一个包里会显得臃肿。我也喜欢将域作为基础设施的一部分，在这种情况下，我们在<code class="fe nu nv nw nx b">services</code>文件夹中创建一个名为<code class="fe nu nv nw nx b">order</code>的新文件夹。原因是在未来我们可能会看到更多与订单相关的服务出现，例如，当前的订单服务专注于点饮料的<code class="fe nu nv nw nx b">Customer</code>，但是当酒馆需要补给时呢？使用这种结构，开发人员很容易知道在哪里可以找到相关的代码。</p><p id="580b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">另一件重要的事情是配置函数的命名，如果我们继续创建像<code class="fe nu nv nw nx b">WithMemoryCustomerRepository</code>这样的函数，就很难保持什么配置去哪里。如果我们看到<code class="fe nu nv nw nx b">order.WithMemoryCustomerRepository</code>就很容易知道发生了什么。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/f1c3d504770568308d190697e9619bc4.png" data-original-src="https://miro.medium.com/v2/resize:fit:768/format:webp/1*3_0KwBrsQgUg_uCvI6-v7A.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">如何将服务包组织成子包</p></figure><p id="b606" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">做出这个改变需要<code class="fe nu nv nw nx b">Tavern</code>包引用<code class="fe nu nv nw nx b">order.OrderService</code>而不是唯一的<code class="fe nu nv nw nx b">OrderService</code></p><p id="eb1d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">更改所有引用以匹配新结构。我们还将在<code class="fe nu nv nw nx b">OrderService</code>中添加一个新函数来添加新客户，因为现在我们只能通过使用struct中的<code class="fe nu nv nw nx b">customer</code>库来做到这一点。这是行不通的，因为服务将暴露给其他包。此外，服务永远不应该假设服务的用户知道如何这样操作，因此在服务自己的域中维护这种逻辑是很自然的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz mv l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在OrderService中添加Customer以帮助创建新客户。</p></figure><p id="d2f0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在应用了这些更改之后，订购产品的测试变得更加容易了。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz mv l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">taver_test.go —创建新客户和订购更加容易</p></figure><p id="cded" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在我们终于有了最终的解决方案。一个非常简单的导航，干净的结构化项目。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi om"><img src="../Images/f1c692713ac7b929d83d583290b55f67.png" data-original-src="https://miro.medium.com/v2/resize:fit:1104/format:webp/1*FnneYclahI179mR2i93OWQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">要使用的最终架构</p></figure><h2 id="13ad" class="mw mx it bd my mz na dn nb nc nd dp ne lh nf ng nh ll ni nj nk lp nl nm nn no bi translated">如何经营酒馆</h2><p id="2599" class="pw-post-body-paragraph ky kz it la b lb np ju ld le nq jx lg lh nr lj lk ll ns ln lo lp nt lr ls lt im bi translated">我想推荐的最后一件事是使用许多Go存储库中的<code class="fe nu nv nw nx b">cmd</code>文件夹。在那个文件夹中，应该可以找到所有的命令行工具，而且可以不止一个。为了结束这篇文章，我将在<code class="fe nu nv nw nx b">cmd</code>文件夹中创建一个主程序。</p><pre class="kj kk kl km gt od nx oe of aw og bi"><span id="e8d9" class="mw mx it nx b gy oh oi l oj ok">mkdir cmd<br/>touch main.go</span></pre><p id="7598" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们点杯啤酒庆祝一下吧。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz mv l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">main . go——试着运行程序，看看是否一切正常，明白这个双关语了吗？</p></figure></div><div class="ab cl on oo hx op" role="separator"><span class="oq bw bk or os ot"/><span class="oq bw bk or os ot"/><span class="oq bw bk or os"/></div><div class="im in io ip iq"><p id="c185" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个关于DDD的很长的两部分系列到此结束。</p><p id="71c3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你可以在<a class="ae lu" href="https://github.com/percybolmer/ddd-go/tree/clean-architecture" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到完整代码。</p><p id="5888" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">关于DDD还有很多东西要学，这只触及了基础，以及我如何找到结构化项目。我们还没有触及<code class="fe nu nv nw nx b">Domain events</code>、<code class="fe nu nv nw nx b">CQRS</code>、<code class="fe nu nv nw nx b">EventSourcing</code>等话题。敬请关注更多内容。</p><p id="9782" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你渴望了解更多关于DDD的知识，我推荐Eric Evans的书<em class="mq">《领域驱动设计:解决软件核心的复杂性》。你可以在亚马逊上找到它。</em></p><p id="62f5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一如既往，请随时通过我的任何社交媒体联系我。我确实喜欢反馈、批评，甚至愤怒。</p><p id="1e68" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我可以在medium、T <a class="ae lu" href="https://twitter.com/percybolmer" rel="noopener ugc nofollow" target="_blank"> witter </a>、<a class="ae lu" href="https://www.instagram.com/programmingpercy/" rel="noopener ugc nofollow" target="_blank"> Instagram </a>和<a class="ae lu" href="https://www.linkedin.com/in/percy-bolmer-bb223b122/" rel="noopener ugc nofollow" target="_blank"> Linkedin </a>上找到我。</p></div></div>    
</body>
</html>