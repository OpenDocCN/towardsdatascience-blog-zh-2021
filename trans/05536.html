<html>
<head>
<title>Model Deployment using Flask</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Flask的模型部署</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/model-deployment-using-flask-c5dcbb6499c9?source=collection_archive---------5-----------------------#2021-05-17">https://towardsdatascience.com/model-deployment-using-flask-c5dcbb6499c9?source=collection_archive---------5-----------------------#2021-05-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="1aab" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">制作可消耗的模型</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi kf"><img src="../Images/da510a6f411b45922df593e6a618d08f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1264/format:webp/1*W2s9FMfOSadzjMV25-v4bQ.png"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">来源:<a class="ae kr" href="https://thenounproject.com/term/launch-project/2041279/" rel="noopener ugc nofollow" target="_blank">名词项目</a></p></figure><h1 id="671d" class="ks kt iq bd ku kv kw kx ky kz la lb lc jw ld jx le jz lf ka lg kc lh kd li lj bi translated">介绍</h1><blockquote class="lk ll lm"><p id="1173" class="ln lo lp lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">无论你做了多么棒的模型，坐在jupyter笔记本上也不会有任何价值。</p></blockquote><p id="927a" class="pw-post-body-paragraph ln lo iq lq b lr ls jr lt lu lv ju lw mk ly lz ma ml mc md me mm mg mh mi mj ij bi translated">我们通常会在EDA模型开发部分投入很多精力，但是我们往往会忽略一个更重要的方面，即创建端到端的应用程序或部署模型，在您为开发模型付出了大量努力之后，以最终用户可以直接使用的可用形式提供模型也同样重要。此外，围绕您开发的代码构建应用程序有助于您使您的工作更有吸引力，并有助于您更好地展示您的工作。</p><h1 id="ebc7" class="ks kt iq bd ku kv kw kx ky kz la lb lc jw ld jx le jz lf ka lg kc lh kd li lj bi translated">瓶</h1><p id="1676" class="pw-post-body-paragraph ln lo iq lq b lr mn jr lt lu mo ju lw mk mp lz ma ml mq md me mm mr mh mi mj ij bi translated">Flask是一个用python 编写的<strong class="lq ir"> web应用框架，简单来说，它帮助最终用户直接从他们的web浏览器与你的python代码(在这种情况下是我们的ML模型)交互，而不需要任何库、代码文件等。</strong></p><p id="17fd" class="pw-post-body-paragraph ln lo iq lq b lr ls jr lt lu lv ju lw mk ly lz ma ml mc md me mm mg mh mi mj ij bi translated">Flask使你能够非常容易地创建web应用程序，从而使你能够将精力更多地集中在ML生命周期的其他重要部分，如EDA、特征工程等。在这篇博客中，我将向你展示如何用你的ML模型构建一个简单的web应用程序，并最终部署它。</p><h1 id="6569" class="ks kt iq bd ku kv kw kx ky kz la lb lc jw ld jx le jz lf ka lg kc lh kd li lj bi translated">目录结构</h1><p id="a64f" class="pw-post-body-paragraph ln lo iq lq b lr mn jr lt lu mo ju lw mk mp lz ma ml mq md me mm mr mh mi mj ij bi translated">首先让我们看一下我们的目录结构，这将给我们一个整体项目的更广阔的画面，并且当你使用flask时知道它也是有用的，我已经将项目保存在一个名为<strong class="lq ir"> ML_Model_deployment </strong>的主目录下</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi ms"><img src="../Images/8b8db238f1121e55aad1615750b80a10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LZSBiEfCJSccHEhVAVjiFg.png"/></div></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">来源:作者图片</p></figure><ul class=""><li id="6e2c" class="mx my iq lq b lr ls lu lv mk mz ml na mm nb mj nc nd ne nf bi translated"><strong class="lq ir">模板</strong> :-这个文件夹包含html文件<em class="lp"> (index.html，predict.html)</em>，我们的主文件<em class="lp"> (app.py) </em>将使用这些文件来生成我们的应用程序的前端</li><li id="1346" class="mx my iq lq b lr ng lu nh mk ni ml nj mm nk mj nc nd ne nf bi translated">app.py  :-这是主应用程序文件，我们所有的代码都驻留在这里，它将所有的东西绑定在一起。</li><li id="ee7b" class="mx my iq lq b lr ng lu nh mk ni ml nj mm nk mj nc nd ne nf bi translated"><strong class="lq ir"> requirements.txt </strong></li><li id="776c" class="mx my iq lq b lr ng lu nh mk ni ml nj mm nk mj nc nd ne nf bi translated"><strong class="lq ir"> model.pkl </strong> <strong class="lq ir"> :- </strong>这是我们将使用的分类模型，在这种情况下，它是一个逻辑回归模型，我已经训练过了。</li><li id="1f9c" class="mx my iq lq b lr ng lu nh mk ni ml nj mm nk mj nc nd ne nf bi translated"><strong class="lq ir"> vectorizer.pkl :- </strong>这是一个矢量器文件，用于将文本转换成模型要处理的矢量，在本例中，我们使用了tf-idf矢量器</li><li id="f9f0" class="mx my iq lq b lr ng lu nh mk ni ml nj mm nk mj nc nd ne nf bi translated">Procfile :- 这是一个特殊的文件，当我们在公共服务器(heroku)上部署应用程序时，将需要这个文件</li></ul><h1 id="b11f" class="ks kt iq bd ku kv kw kx ky kz la lb lc jw ld jx le jz lf ka lg kc lh kd li lj bi translated">理解代码</h1><p id="f951" class="pw-post-body-paragraph ln lo iq lq b lr mn jr lt lu mo ju lw mk mp lz ma ml mq md me mm mr mh mi mj ij bi translated">我在Kaggle上举办了一个名为<strong class="lq ir"> Quora不真诚问题分类</strong>的比赛，基本上这是一个分类问题，Quora试图识别不真诚的问题，即那些建立在错误前提上的问题，或者那些打算发表声明而不是寻找有用答案的问题，你可以在<a class="ae kr" href="http://those founded upon false premises, or that intend to make a statement rather than look for helpful answers" rel="noopener ugc nofollow" target="_blank">这里</a>阅读更多关于问题声明的内容。</p><p id="a209" class="pw-post-body-paragraph ln lo iq lq b lr ls jr lt lu lv ju lw mk ly lz ma ml mc md me mm mg mh mi mj ij bi translated">既然我们已经完成了所有的介绍部分，让我们来谈谈代码吧！</p><pre class="kg kh ki kj gt nl nm nn no aw np bi"><span id="cbb2" class="nq kt iq nm b gy nr ns l nt nu"><strong class="nm ir">from</strong> flask <strong class="nm ir">import</strong> Flask<br/>app = Flask(__name__)</span></pre><p id="7e2a" class="pw-post-body-paragraph ln lo iq lq b lr ls jr lt lu lv ju lw mk ly lz ma ml mc md me mm mg mh mi mj ij bi translated">就像任何其他python类对象一样，最终这个应用程序只不过是Flask类的一个对象，它将为我们完成所有繁重的工作，比如处理来自浏览器的传入请求(在我们的例子中是用户输入的问题),并使用html、css以某种良好的形式提供适当的响应(在我们的例子中是模型预测)。我们将逐渐看到所有这些事情，以及这个应用程序对象如何适合解决所有这些问题。</p><p id="b1de" class="pw-post-body-paragraph ln lo iq lq b lr ls jr lt lu lv ju lw mk ly lz ma ml mc md me mm mg mh mi mj ij bi translated">下一部分可能看起来有点吓人，但是不要担心，我们会试着一点一点地理解它。</p><pre class="kg kh ki kj gt nl nm nn no aw np bi"><span id="9074" class="nq kt iq nm b gy nr ns l nt nu"><a class="ae kr" href="http://twitter.com/app" rel="noopener ugc nofollow" target="_blank"><strong class="nm ir">@app</strong></a><strong class="nm ir">.route('/')<br/></strong>def index():<br/>    return flask.render_template('index.html')</span><span id="0fd6" class="nq kt iq nm b gy nv ns l nt nu"><a class="ae kr" href="http://twitter.com/app" rel="noopener ugc nofollow" target="_blank"><strong class="nm ir">@app</strong></a><strong class="nm ir">.route('/predict', methods=['POST'])<br/>def</strong> predict():<br/>    to_predict_list = request.form.to_dict()<br/>    review_text = pre_processing(to_predict_list['review_text'])<br/>    prob = clf.predict_proba(count_vect.transform([review_text]))<br/>    if prob[0][0]&gt;=0.5:<br/>        prediction = "Positive"<br/>   else:<br/>        prediction = "Negative"</span><span id="30f5" class="nq kt iq nm b gy nv ns l nt nu"><strong class="nm ir">return</strong> flask.render_template('predict.html', prediction = prediction, prob =np.round(prob[0][0],3)*100)</span></pre><p id="9938" class="pw-post-body-paragraph ln lo iq lq b lr ls jr lt lu lv ju lw mk ly lz ma ml mc md me mm mg mh mi mj ij bi translated">第一行<strong class="lq ir"> @app.route ('/index') </strong>是一个decorator，简单地说，它只是将它下面定义的方法映射到decorator中提到的URL，也就是说，每当用户访问那个URL <strong class="lq ir"> '/' </strong> <em class="lp">(完整的地址也将有一个ip地址和一个端口号，类似http://127.0.0.1:5000/) </em>，<strong class="lq ir"> index() </strong>方法将被自动调用，而index()将被调用</p><p id="a000" class="pw-post-body-paragraph ln lo iq lq b lr ls jr lt lu lv ju lw mk ly lz ma ml mc md me mm mg mh mi mj ij bi translated"><strong class="lq ir">flask . render _ template()</strong>在我们在主目录中创建的<strong class="lq ir"> templates文件夹</strong>中查找这个<strong class="lq ir">index.html</strong>文件，并为最终用户动态生成/呈现一个HTML页面，我稍后将解释动态部分</p><p id="b580" class="pw-post-body-paragraph ln lo iq lq b lr ls jr lt lu lv ju lw mk ly lz ma ml mc md me mm mg mh mi mj ij bi translated"><em class="lp">(注意:因为predict一词在多个上下文中使用，所以为了避免混淆，我将把predict()称为我们代码中定义的预测方法，把predict.html称为存储在模板文件夹中的预测模板，把/predict称为预测URL ) </em></p><p id="4af8" class="pw-post-body-paragraph ln lo iq lq b lr ls jr lt lu lv ju lw mk ly lz ma ml mc md me mm mg mh mi mj ij bi translated">现在我们有了另一个装饰器<strong class="lq ir"> @app.route ('/predict') </strong>，它将<strong class="lq ir"> predict() </strong>方法映射到<strong class="lq ir">/predict</strong><em class="lp"/>URL<em class="lp"/>，顾名思义，这个predict()方法接受用户给定的输入，进行所有的预处理，生成最终的特征向量，对其运行模型并获得最终的预测。现在让我们把重点放在呈现动态HTML页面部分，有时我们需要在HTML页面中动态地放置信息，就像在这种情况下，我们的<strong class="lq ir">predict.html</strong>页面将需要预测值来正确地呈现页面，只有当用户在我们的<strong class="lq ir">index.html</strong>页面中输入文本并点击提交按钮时才可用，这就是<strong class="lq ir"> render_template </strong>出现的地方。 在predict.html页面中，我们已经为这些变量值创建了占位符(稍后将讨论这些占位符)，<strong class="lq ir">这个render_template将模板文件夹中的predict.html和预测值放在一起，最终生成/呈现最终的HTML页面，在这种情况下，HTML页面包含预测，</strong>对吗？</p><p id="4d9b" class="pw-post-body-paragraph ln lo iq lq b lr ls jr lt lu lv ju lw mk ly lz ma ml mc md me mm mg mh mi mj ij bi translated">现在让我们快速地看一下主代码中的<strong class="lq ir"> predict() </strong>方法，方法中的第一行，即<strong class="lq ir">to _ predict _ list = request . form . to _ dict()，</strong>它接受用户输入的文本，当单击表单中的提交按钮<strong class="lq ir">时，返回一个json，其中包含具有响应的键值对</strong>， 当点击submit按钮时，这个<strong class="lq ir"> /predcit URL被调用，响应作为json </strong>被发送到对应于这个URL的页面，我们在前面也看到过，一旦这个/predict URL被调用，相关的predict()方法被自动调用，它将这个json和输出模板(predict.html)放在一起生成我们的最终输出。 (我们在最后有一个输出部分，我们将实际查看这里讨论的所有内容的结果)</p><p id="b6b0" class="pw-post-body-paragraph ln lo iq lq b lr ls jr lt lu lv ju lw mk ly lz ma ml mc md me mm mg mh mi mj ij bi translated">现在，在进一步研究代码之前，让我们看看我们的<strong class="lq ir">index.html</strong>，它负责从用户那里获取输入文本，并通过调用<strong class="lq ir"> /predict </strong> URL最终显示最终输出</p><pre class="kg kh ki kj gt nl nm nn no aw np bi"><span id="b6a2" class="nq kt iq nm b gy nr ns l nt nu">&lt;form action="/predict" method="POST" target="_blank"&gt;<br/> &lt;textarea name="review_text" placeholder="Enter your question here..." rows="10" cols="15"&gt;&lt;/textarea&gt;<br/>    &lt;input type="submit" value="Submit"&gt;<br/>  &lt;/form&gt;</span></pre><p id="164d" class="pw-post-body-paragraph ln lo iq lq b lr ls jr lt lu lv ju lw mk ly lz ma ml mc md me mm mg mh mi mj ij bi translated">这里是index.html的一小部分，在这里<strong class="lq ir">表单被创建</strong>，我们可以看到一个叫做<strong class="lq ir">动作</strong>的字段，这意味着表单数据被发送到<strong class="lq ir">动作属性</strong>中指定的页面，而<strong class="lq ir">方法属性</strong>告诉我们这个表单数据是如何被共享的， 这里我们使用了<strong class="lq ir"> POST方法</strong>，这意味着表单数据被共享为一个json(以键-值对的形式)，同时让我们也看看我们的第二个模板文件，即<strong class="lq ir">predict.html</strong>模板，基本上它接受预测输出并根据输出值显示结果，因此我们在predict.html模板中需要两个主要的东西来实现这一点</p><ul class=""><li id="e162" class="mx my iq lq b lr ls lu lv mk mz ml na mm nb mj nc nd ne nf bi translated">用于预测输出的<strong class="lq ir">变量/占位符</strong></li><li id="bbb2" class="mx my iq lq b lr ng lu nh mk ni ml nj mm nk mj nc nd ne nf bi translated">根据预测值显示结果的基本if/else逻辑<strong class="lq ir"/></li></ul><p id="2b9b" class="pw-post-body-paragraph ln lo iq lq b lr ls jr lt lu lv ju lw mk ly lz ma ml mc md me mm mg mh mi mj ij bi translated">下面是来自predict.html页面的一小段代码，它根据预测结果打印了一条消息和一幅图像</p><pre class="kg kh ki kj gt nl nm nn no aw np bi"><span id="7515" class="nq kt iq nm b gy nr ns l nt nu"><strong class="nm ir">{% if prediction == "Negative" %}</strong><br/>   <br/>      &lt;h1&gt; THIS IS NOT A GENUINE QUESTION   &lt;/h1&gt;<br/>  &lt;img src="<a class="ae kr" href="https://i.pinimg.com/564x/b0/41/75/b04175fd1ffbefdc02d90136c262a6e3.jpg" rel="noopener ugc nofollow" target="_blank">https://i.pinimg.com/564x/b0/41/75/b04175fd1ffbefdc02d90136c262a6e3.jpg</a>" width=250&gt;<br/>     &lt;progress value= <strong class="nm ir">{{prob}}</strong> max="100"&gt;</span></pre><p id="3f95" class="pw-post-body-paragraph ln lo iq lq b lr ls jr lt lu lv ju lw mk ly lz ma ml mc md me mm mg mh mi mj ij bi translated">在html页面中编写代码/变量非常简单，flask使用一个名为Jinja2 的<strong class="lq ir"> web模板引擎，帮助你将代码/变量嵌入到html中</strong></p><ul class=""><li id="ef5c" class="mx my iq lq b lr ls lu lv mk mz ml na mm nb mj nc nd ne nf bi translated"><strong class="lq ir"> {{}} </strong>用于添加变量/占位符(这个prob变量已经由predict()方法中的render_template传递)</li><li id="54ac" class="mx my iq lq b lr ng lu nh mk ni ml nj mm nk mj nc nd ne nf bi translated"><strong class="lq ir"> { % %} </strong>写if-else条件/for循环等语句</li></ul><p id="4e68" class="pw-post-body-paragraph ln lo iq lq b lr ls jr lt lu lv ju lw mk ly lz ma ml mc md me mm mg mh mi mj ij bi translated">现在，回到predict()方法中的原始代码，一旦我们从表单响应中获得输入文本，我们就将该文本传递给我们的预处理函数，在那里我们执行一些基本的NLP预处理，如转换为小写、一些标记化、单词词汇化。下面是预处理函数的定义</p><pre class="kg kh ki kj gt nl nm nn no aw np bi"><span id="507a" class="nq kt iq nm b gy nr ns l nt nu"><strong class="nm ir">def</strong> pre_processing(text):<br/>    lemmatizer = WordNetLemmatizer()<br/>    text = text.lower()<br/>    text = re.sub('[0-9]+','num',text)<br/>    word_list = nltk.word_tokenize(text)<br/>    word_list =  [lemmatizer.lemmatize(item) for item in word_list]<br/>    return ' '.join(word_list)</span></pre><p id="fc87" class="pw-post-body-paragraph ln lo iq lq b lr ls jr lt lu lv ju lw mk ly lz ma ml mc md me mm mg mh mi mj ij bi translated">在预处理之后，我们调用我们的<strong class="lq ir">矢量器和模型</strong>，我们已经在训练阶段定义并保存了它们，我们的count _ vectorizer将文本转换为数字矢量，模型给出预测概率，稍后这些值被提供给render_template以生成包含输出的整个html页面。</p><h1 id="b53b" class="ks kt iq bd ku kv kw kx ky kz la lb lc jw ld jx le jz lf ka lg kc lh kd li lj bi translated">部署和输出</h1><p id="d974" class="pw-post-body-paragraph ln lo iq lq b lr mn jr lt lu mo ju lw mk mp lz ma ml mq md me mm mr mh mi mj ij bi translated">现在让我们看看最终的结果，一旦我们部署它，一切看起来如何，首先我将它部署在我的本地机器上，然后我们将它部署在公共服务器上。部署非常简单，您只需设置您的python环境并运行app.py应用程序，因为我已经在我的计算机上安装了anaconda，我将从那里运行app.py文件，否则您可以创建您单独的虚拟环境，安装所有依赖项并从那里运行它，您不需要整个Anaconda包来运行它，您只需要python和代码中使用的库。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi nw"><img src="../Images/70b044a4128ea28ac429d69f2f39bc47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Bvcmb03mJsOzbIFttrV5Sw.png"/></div></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">来源:作者图片</p></figure><p id="5040" class="pw-post-body-paragraph ln lo iq lq b lr ls jr lt lu lv ju lw mk ly lz ma ml mc md me mm mg mh mi mj ij bi translated">打开anaconda提示符后，只需转到主文件夹(本例中为ML_Model_deployement ),运行maint python代码文件(app.py ),只需查看最后一行，上面写着running on<a class="ae kr" href="http://127.0.0.1:5000/" rel="noopener ugc nofollow" target="_blank">http://127 . 0 . 0 . 1:5000/</a>这是我们的web应用程序正在运行的地方，您可以复制这个URL并将其粘贴到您的web浏览器中，然后查看web应用程序。 这里127.0.0.1是本地主机的<strong class="lq ir"> ip地址</strong>(就像我们有一个住宅地址一样，ip地址是在互联网或本地网络上识别你的机器的唯一地址)，5000是端口号，这是你的web应用程序驻留在服务器中的位置(把它看作是访问你的应用程序的入口)。 现在让我们在浏览器上复制这个URL，看看主页是什么样子的(请原谅我的前端技能，我在这方面的经验非常有限)</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi nx"><img src="../Images/1beb0d6efa025aa5c98e6b6049b4527d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vdQtUAf4ZzjXJKsl4mN1Ng.png"/></div></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">来源:作者图片</p></figure><p id="4016" class="pw-post-body-paragraph ln lo iq lq b lr ls jr lt lu lv ju lw mk ly lz ma ml mc md me mm mg mh mi mj ij bi translated">现在让我们键入两个类中的一些问题，看看我们的预测页面看起来如何，首先让我们看一个真正的问题。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi ny"><img src="../Images/95791294f74dbbdda611c89d3ac02969.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*ToaVixXfc81NosRDZhgdUA.gif"/></div></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">来源:作者视频</p></figure><p id="99d9" class="pw-post-body-paragraph ln lo iq lq b lr ls jr lt lu lv ju lw mk ly lz ma ml mc md me mm mg mh mi mj ij bi translated">现在我们将键入一个不真诚/不真诚的问题，看看结果如何</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi ny"><img src="../Images/028d7af79f3798f3b9a56fba85fcb7e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*RKiJNFybrYaTn4jBOUL77Q.gif"/></div></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">来源:作者视频</p></figure><p id="f74a" class="pw-post-body-paragraph ln lo iq lq b lr ls jr lt lu lv ju lw mk ly lz ma ml mc md me mm mg mh mi mj ij bi translated">就像我们部署在本地机器上一样，我们可以将它部署在公共web服务器上，让web上的每个人都可以访问我们的应用程序。这里我使用了<strong class="lq ir"> heroku </strong>来部署我的应用程序。</p><p id="4a31" class="pw-post-body-paragraph ln lo iq lq b lr ls jr lt lu lv ju lw mk ly lz ma ml mc md me mm mg mh mi mj ij bi translated">Heroku是<strong class="lq ir"> PAAS(平台即服务应用)</strong>它使开发者能够在网络上部署他们的应用程序，并且它确实提供了一个免费的计划！，在heroku部署很简单，你可以直接把你的github repository链接到heroku(最后我会把github repo和web应用的链接都分享出来)。你只需要添加两个特殊的文件<strong class="lq ir"> requirements.txt </strong>和<strong class="lq ir"> Procfile(没有任何扩展名)</strong>，我们在讨论目录结构的时候已经讨论过需求文件，现在让我们再来讨论一下这个Procfile。基本上，Procfile告诉heroku需要预先运行的一组进程/命令，Procfile看起来像这样</p><pre class="kg kh ki kj gt nl nm nn no aw np bi"><span id="fcf6" class="nq kt iq nm b gy nr ns l nt nu">web: gunicorn app:app</span></pre><p id="f047" class="pw-post-body-paragraph ln lo iq lq b lr ls jr lt lu lv ju lw mk ly lz ma ml mc md me mm mg mh mi mj ij bi translated"><strong class="lq ir"> web </strong>命令告诉heroku使用gunicorn(帮助您运行python应用程序的web服务器)启动web服务器，第一个应用程序引用我们的主<strong class="lq ir"> app.py </strong>文件，第二个引用<strong class="lq ir"> flask实例应用程序</strong>，它也可以有不同的名称，如果您对部署有任何疑问，您可以参考这个令人惊叹的<a class="ae kr" href="https://www.youtube.com/watch?v=mrExsjcvF4o" rel="noopener ugc nofollow" target="_blank">视频</a>教程，它包含在hero中部署的完整分步教程</p><h1 id="8a84" class="ks kt iq bd ku kv kw kx ky kz la lb lc jw ld jx le jz lf ka lg kc lh kd li lj bi translated">结论</h1><p id="72b9" class="pw-post-body-paragraph ln lo iq lq b lr mn jr lt lu mo ju lw mk mp lz ma ml mq md me mm mr mh mi mj ij bi translated">如果你觉得这个教程很有帮助，那么请与你的朋友分享，下面是github资源库和部署在heroku的web应用程序的链接。为了感受它，我强烈建议你自己尝试一次，如果你过去已经从事过一些ML项目，那么试着部署那些模型，这样你会有更好的理解。</p><p id="5697" class="pw-post-body-paragraph ln lo iq lq b lr ls jr lt lu lv ju lw mk ly lz ma ml mc md me mm mg mh mi mj ij bi translated"><strong class="lq ir"> Github资源库:-</strong>【https://github.com/ravi207/Model_Deployment T2】</p><p id="0ea4" class="pw-post-body-paragraph ln lo iq lq b lr ls jr lt lu lv ju lw mk ly lz ma ml mc md me mm mg mh mi mj ij bi translated"><strong class="lq ir">网络应用</strong>:-h<a class="ae kr" href="https://question-classification.herokuapp.com/" rel="noopener ugc nofollow" target="_blank">ttps://question-classification . heroku app . com/</a></p><p id="9823" class="pw-post-body-paragraph ln lo iq lq b lr ls jr lt lu lv ju lw mk ly lz ma ml mc md me mm mg mh mi mj ij bi translated"><em class="lp">(注意:我已经使用tf-idf矢量器在整个数据集的一个小子集上训练了一个非常基本的逻辑回归模型，因此模型预测不会太好，现在它能够识别特定类型的不真诚问题，这些问题具有它在训练期间从数据集学习的一些特定的仇恨词汇)</em></p><p id="4376" class="pw-post-body-paragraph ln lo iq lq b lr ls jr lt lu lv ju lw mk ly lz ma ml mc md me mm mg mh mi mj ij bi translated">如果您有任何建议或疑问，请随时联系我</p><p id="6fbf" class="pw-post-body-paragraph ln lo iq lq b lr ls jr lt lu lv ju lw mk ly lz ma ml mc md me mm mg mh mi mj ij bi translated">领英:<a class="ae kr" href="https://www.linkedin.com/in/ravindra-sharma-832a04156" rel="noopener ugc nofollow" target="_blank">https://www.linkedin.com/in/ravindra-sharma-832a04156</a></p><p id="3478" class="pw-post-body-paragraph ln lo iq lq b lr ls jr lt lu lv ju lw mk ly lz ma ml mc md me mm mg mh mi mj ij bi translated">快乐学习！</p></div></div>    
</body>
</html>