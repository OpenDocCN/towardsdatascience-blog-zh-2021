<html>
<head>
<title>Parallel Computing On Raspberry Pi 4B+ IoT Boards Made Easier</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Raspberry Pi 4B+物联网板上的并行计算变得更加简单</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/parallel-computing-on-raspberry-pi-4b-iot-boards-made-easier-d3d6ccbb8e76?source=collection_archive---------28-----------------------#2021-06-18">https://towardsdatascience.com/parallel-computing-on-raspberry-pi-4b-iot-boards-made-easier-d3d6ccbb8e76?source=collection_archive---------28-----------------------#2021-06-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/9c6bc053ececba09abd00b88b8a13bdd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YH_zfktV-QwoIB65qCWmAw.jpeg"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">来自Unsplash的Arthur V. Ratz的照片</p></figure><div class=""/><div class=""><h2 id="f712" class="pw-subtitle-paragraph kc je jf bd b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt dk translated">在Raspberry Pi物联网板上构建和运行使用Khronos CL/SYCL-model规范实现的C++17并行代码。</h2></div><h1 id="3e79" class="ku kv jf bd kw kx ky kz la lb lc ld le kl lf km lg ko lh kp li kr lj ks lk ll bi translated">我们的目标…</h1><p id="6a3c" class="pw-post-body-paragraph lm ln jf lo b lp lq kg lr ls lt kj lu lv lw lx ly lz ma mb mc md me mf mg mh ij bi translated">该项目提供了有用的指南、技巧和教程，用于在C++17/2x0中构建现代并行代码，使用CL/SYCL编程模型实现，并在基于创新的ARM Cortex-A72、四核、64位RISC-V CPU的下一代Raspberry Pi 4B物联网板上运行。</p><p id="d0a4" class="pw-post-body-paragraph lm ln jf lo b lp mi kg lr ls mj kj lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">读者观众将了解如何设置Raspberry 4B物联网板，开箱即用，并将其用于并行计算，使用Khronos CL/triSYCL和Aksel Alpay的hipSYCL项目的开源发行版交付C++17中的并行代码，安装和配置GNU的编译器集合(GCC)和LLVM/Clang-9 . x . x Arm/aarch 64-tool chains，以构建并行代码的可执行文件并在Raspbian Buster 10.6 OS中运行。</p><h1 id="59e7" class="ku kv jf bd kw kx ky kz la lb lc ld le kl lf km lg ko lh kp li kr lj ks lk ll bi translated">Raspberry PI 4B+物联网板概述</h1><p id="6b93" class="pw-post-body-paragraph lm ln jf lo b lp lq kg lr ls lt kj lu lv lw lx ly lz ma mb mc md me mf mg mh ij bi translated">下一代创新的Raspberry Pi 4B+物联网主板基于强大的ARM多核对称64位RISC-V CPU，提供了无与伦比的性能，从而实现了并行计算本身的终极生产力。使用最新的Raspberry Pi板可以大幅提高边缘计算过程的实际性能，例如在将数据交付到数据中心进行处理之前，实时收集和预处理数据。并行运行这些流程显著提高了基于云的解决方案的效率，为数十亿个客户端请求提供服务，或者提供数据分析和其他推断。</p><p id="1848" class="pw-post-body-paragraph lm ln jf lo b lp mi kg lr ls mj kj lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">在我们讨论如何在C++17中构建和运行并行代码之前，让我们先花点时间简要了解一下下一代Raspberry Pi 4B+板及其技术规格，该并行代码是使用CL/SYCL异构编程模型规范为采用Arm/Aarch64架构的Raspberry Pi板设计的:</p><figure class="mo mp mq mr gt is gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/04664e2254c8e0deaea80c285d8a53c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1328/0*gYgawGRpKZoJXtJq"/></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">Raspberry Pi 4B+物联网板</p></figure><p id="b40a" class="pw-post-body-paragraph lm ln jf lo b lp mi kg lr ls mj kj lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">Raspberry Pi 4B+物联网板基于创新的Broadcom BCM2711B0 (SoC)芯片制造，配备最新的ARM四核Cortex-A72 @ 1.5GHz 64位RISC-V CPU，提供终极性能和可扩展性，同时利用它进行边缘并行计算。</p><p id="93a9" class="pw-post-body-paragraph lm ln jf lo b lp mi kg lr ls mj kj lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">Raspberry Pi以“可靠”和“快速”的微型纳米计算机而闻名，专为数据挖掘和并行计算而设计。ARM的多核对称64位RISC-V CPU的主要新硬件架构特性，如DSP、SIMD、VFPv4和硬件虚拟化支持，可以显著提高边缘大规模处理数据的物联网集群的性能、加速和可扩展性。</p><p id="75b8" class="pw-post-body-paragraph lm ln jf lo b lp mi kg lr ls mj kj lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">具体来说，最新的Raspberry Pi 4B+板最重要的优势之一是薄型LPDDR4存储器，可选择2、4或8 GiB RAM容量，工作频率为3200Mhz，提供典型的大内存事务带宽，总体上对并行计算的性能产生积极影响。对于数据挖掘和并行计算，强烈建议使用安装了4gb或更高内存的主板。此外，BCM2711B0 SoC芯片还捆绑了各种集成设备和外设，如Broadcom VideoCore VI @ 500Mhz GPUs、PCI-Ex千兆以太网适配器等。</p><p id="25d1" class="pw-post-body-paragraph lm ln jf lo b lp mi kg lr ls mj kj lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">为了在C++17中构建和运行特定的并行现代代码，使用CL/SYCL异构编程模型实现，我们真正需要的第一个是Raspberry Pi 4B+物联网板，该板安装了最新的Raspbian Buster 10.6操作系统，并针对首次使用进行了配置。</p><p id="bf53" class="pw-post-body-paragraph lm ln jf lo b lp mi kg lr ls mj kj lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">以下是硬件和软件要求的简要清单:</p><p id="8496" class="pw-post-body-paragraph lm ln jf lo b lp mi kg lr ls mj kj lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated"><strong class="lo jg">硬件:</strong></p><ul class=""><li id="fd11" class="ms mt jf lo b lp mi ls mj lv mu lz mv md mw mh mx my mz na bi translated">树莓Pi 4型号B0，4GB物联网板；</li><li id="90a6" class="ms mt jf lo b lp nb ls nc lv nd lz ne md nf mh mx my mz na bi translated">Micro-SD卡16GB，用于Raspbian操作系统和数据存储；</li><li id="554b" class="ms mt jf lo b lp nb ls nc lv nd lz ne md nf mh mx my mz na bi translated">DC电源:通过USB Type-C连接器的5.0V/2–3A(最小3A —用于数据挖掘和并行计算)；</li></ul><p id="dbc3" class="pw-post-body-paragraph lm ln jf lo b lp mi kg lr ls mj kj lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated"><strong class="lo jg">软件:</strong></p><ul class=""><li id="b3d8" class="ms mt jf lo b lp mi ls mj lv mu lz mv md mw mh mx my mz na bi translated">Raspbian Buster 10.6.0完整OS；</li><li id="8537" class="ms mt jf lo b lp nb ls nc lv nd lz ne md nf mh mx my mz na bi translated">拉斯比安成像仪1.4；</li><li id="30b7" class="ms mt jf lo b lp nb ls nc lv nd lz ne md nf mh mx my mz na bi translated">MobaXterm 20.3 build 4396或任何其他SSH客户端；</li></ul><p id="6cfd" class="pw-post-body-paragraph lm ln jf lo b lp mi kg lr ls mj kj lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">既然我们已经有了一个Raspberry Pi 4B+物联网板，现在，我们可以开箱即用地打开它并进行设置。</p><h1 id="c398" class="ku kv jf bd kw kx ky kz la lb lc ld le kl lf km lg ko lh kp li kr lj ks lk ll bi translated">设置Raspberry Pi 4B物联网板</h1><p id="94b3" class="pw-post-body-paragraph lm ln jf lo b lp lq kg lr ls lt kj lu lv lw lx ly lz ma mb mc md me mf mg mh ij bi translated">在开始之前，我们必须从官方的Raspbian库下载Raspbian Buster 10.6.0完整操作系统映像的最新版本。要将Raspbian操作系统映像安装到SD卡，我们还需要下载并使用适用于各种平台的Raspbian Imager 1.4应用程序，如Windows、Linux或macOS:</p><ul class=""><li id="9799" class="ms mt jf lo b lp mi ls mj lv mu lz mv md mw mh mx my mz na bi translated"><a class="ae ng" href="http://downloads.raspberrypi.org/raspbian_full/images/raspbian_full-2020-02-14/" rel="noopener ugc nofollow" target="_blank">拉斯边巴斯特10.6.0 </a></li><li id="fa09" class="ms mt jf lo b lp nb ls nc lv nd lz ne md nf mh mx my mz na bi translated"><a class="ae ng" href="http://downloads.raspberrypi.org/imager/" rel="noopener ugc nofollow" target="_blank">拉斯比安成像仪1.4 </a></li></ul><p id="fee6" class="pw-post-body-paragraph lm ln jf lo b lp mi kg lr ls mj kj lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">此外，我们还必须下载并安装MobaXterm应用程序，以便通过SSH或FTP协议远程建立与Raspberry Pi板的连接:</p><ul class=""><li id="5e84" class="ms mt jf lo b lp mi ls mj lv mu lz mv md mw mh mx my mz na bi translated"><a class="ae ng" href="https://mobaxterm.mobatek.net/download.html" rel="noopener ugc nofollow" target="_blank"> MobaXterm 20.3 </a></li></ul><p id="acaa" class="pw-post-body-paragraph lm ln jf lo b lp mi kg lr ls mj kj lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">由于Raspbian Buster操作系统和Imager应用程序已成功下载并安装，我们将使用Imager应用程序执行以下操作:</p><p id="fb14" class="pw-post-body-paragraph lm ln jf lo b lp mi kg lr ls mj kj lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">1.默认情况下，擦除SD卡，将其格式化为FAT32文件系统；</p><p id="aa7e" class="pw-post-body-paragraph lm ln jf lo b lp mi kg lr ls mj kj lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">2.提取预装的Raspbian Buster OS镜像(*。img)到SD卡；</p><p id="ec11" class="pw-post-body-paragraph lm ln jf lo b lp mi kg lr ls mj kj lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">由于上述步骤已经完成，从读卡器中取出SD卡，并将其插入Raspberry Pi板的SD卡插槽中。然后，连接微型HDMI和以太网电缆。最后，插入DC电源电缆的连接器，并打开电路板。最后，系统将启动安装在SD卡上的Raspbian Buster操作系统，提示执行几个安装后步骤来配置它以供首次使用。</p><p id="5984" class="pw-post-body-paragraph lm ln jf lo b lp mi kg lr ls mj kj lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">由于主板已通电，请确保已完成以下所有安装后步骤:</p><p id="c87a" class="pw-post-body-paragraph lm ln jf lo b lp mi kg lr ls mj kj lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">1.打开bash控制台并设置“root”密码:</p><pre class="mo mp mq mr gt nh ni nj nk aw nl bi"><span id="dbf3" class="nm kv jf ni b gy nn no l np nq">pi@raspberrypi4:~ $ sudo passwd root</span></pre><p id="5adb" class="pw-post-body-paragraph lm ln jf lo b lp mi kg lr ls mj kj lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">2.以“root”权限登录Raspbian bash控制台:</p><pre class="mo mp mq mr gt nh ni nj nk aw nl bi"><span id="5303" class="nm kv jf ni b gy nn no l np nq">pi@raspberrypi4:~ $ sudo -s</span></pre><p id="7ca0" class="pw-post-body-paragraph lm ln jf lo b lp mi kg lr ls mj kj lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">3.使用以下命令升级Raspbian的Linux基本系统和固件:</p><pre class="mo mp mq mr gt nh ni nj nk aw nl bi"><span id="834a" class="nm kv jf ni b gy nn no l np nq">root@raspberrypi4:~# sudo apt update<br/>root@raspberrypi4:~# sudo apt full-upgrade<br/>root@raspberrypi4:~# sudo rpi-update</span></pre><p id="17ef" class="pw-post-body-paragraph lm ln jf lo b lp mi kg lr ls mj kj lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">4.首次重新启动系统:</p><pre class="mo mp mq mr gt nh ni nj nk aw nl bi"><span id="954c" class="nm kv jf ni b gy nn no l np nq">root@raspberrypi4:~# sudo shutdown -r now</span></pre><p id="8b2c" class="pw-post-body-paragraph lm ln jf lo b lp mi kg lr ls mj kj lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">5.再次安装最新的Raspbian引导程序并重启系统:</p><pre class="mo mp mq mr gt nh ni nj nk aw nl bi"><span id="7575" class="nm kv jf ni b gy nn no l np nq">root@raspberrypi4:~# sudo rpi-eeprom-update -d -a<br/>root@raspberrypi4:~# sudo shutdown -r now</span></pre><p id="c6fe" class="pw-post-body-paragraph lm ln jf lo b lp mi kg lr ls mj kj lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">6.启动“raspi-config”安装工具:</p><pre class="mo mp mq mr gt nh ni nj nk aw nl bi"><span id="e24d" class="nm kv jf ni b gy nn no l np nq">root@raspberrypi4:~# sudo raspi-config</span></pre><p id="4f19" class="pw-post-body-paragraph lm ln jf lo b lp mi kg lr ls mj kj lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">7.使用“raspi-config”工具完成以下步骤:</p><p id="a5c9" class="pw-post-body-paragraph lm ln jf lo b lp mi kg lr ls mj kj lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated"><strong class="lo jg"> *更新“raspi-config”工具:</strong></p><figure class="mo mp mq mr gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nr"><img src="../Images/5efc44ee971af24ba34d5caab9bda9de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*bN0pNToWKpSxE5eP"/></div></div></figure><p id="30f8" class="pw-post-body-paragraph lm ln jf lo b lp mi kg lr ls mj kj lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated"><strong class="lo jg"> *启动时禁用Raspbian的桌面GUI:</strong></p><p id="be4f" class="pw-post-body-paragraph lm ln jf lo b lp mi kg lr ls mj kj lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated"><strong class="lo jg">系统选项</strong> &gt; &gt; <strong class="lo jg">开机/自动登录</strong> &gt; &gt; <strong class="lo jg">控制台自动登录:</strong></p><figure class="mo mp mq mr gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nr"><img src="../Images/0a3c86aa6933faa5bfef5a3d98096c0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*IGCO_hT7vQ7jQp7D"/></div></div></figure><p id="605b" class="pw-post-body-paragraph lm ln jf lo b lp mi kg lr ls mj kj lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated"><strong class="lo jg"> *扩展SD卡上的根'/'分区大小:</strong></p><figure class="mo mp mq mr gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nr"><img src="../Images/8f51506cc779d3eb0a21df27671efb80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5agxJpE8mPSL1ZFl"/></div></div></figure><p id="6da1" class="pw-post-body-paragraph lm ln jf lo b lp mi kg lr ls mj kj lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">最后，在执行Raspbian安装后配置后，重新引导系统。重启后，系统会提示您登录。使用之前设置的“root”用户名和密码，以root权限登录bash控制台。</p><p id="d0ce" class="pw-post-body-paragraph lm ln jf lo b lp mi kg lr ls mj kj lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">因为您已经成功登录，所以在bash-console中使用下面的命令安装APT-repositories中的一些包:</p><pre class="mo mp mq mr gt nh ni nj nk aw nl bi"><span id="2f89" class="nm kv jf ni b gy nn no l np nq">root@raspberrypi4:~# sudo apt install -y net-tools openssh-server</span></pre><p id="a932" class="pw-post-body-paragraph lm ln jf lo b lp mi kg lr ls mj kj lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">需要这两个软件包来配置Raspberry Pi的网络接口或OpenSSH-server，以便使用MobaXterm通过SSH协议远程连接到电路板。</p><p id="05cd" class="pw-post-body-paragraph lm ln jf lo b lp mi kg lr ls mj kj lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">通过修改/etc/network/interfaces配置板的网络接口“eth0 ”,例如:</p><pre class="mo mp mq mr gt nh ni nj nk aw nl bi"><span id="e3b5" class="nm kv jf ni b gy nn no l np nq">auto eth0<br/>iface eth0 inet static<br/>address 192.168.87.100<br/>netmask 255.255.255.0<br/>broadcast 192.168.87.255<br/>gateway 192.168.87.254<br/>nameserver 192.168.87.254</span></pre><p id="9830" class="pw-post-body-paragraph lm ln jf lo b lp mi kg lr ls mj kj lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">在网络接口旁边，通过取消注释<strong class="lo jg"> /etc/ssh/sshd_config </strong>中的这些行来执行OpenSSH-server的基本配置:</p><pre class="mo mp mq mr gt nh ni nj nk aw nl bi"><span id="966a" class="nm kv jf ni b gy nn no l np nq">PermitRootLogin yes<br/>StrictModes no</span><span id="762d" class="nm kv jf ni b gy ns no l np nq">PasswordAuthentication yes<br/>PermitEmptyPasswords yes</span></pre><p id="65b3" class="pw-post-body-paragraph lm ln jf lo b lp mi kg lr ls mj kj lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">这将允许“root”登录，通过SSH协议进入bash控制台，而无需输入密码。</p><p id="2437" class="pw-post-body-paragraph lm ln jf lo b lp mi kg lr ls mj kj lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">最后，尝试通过网络连接板，使用MobaXterm应用程序并打开到IP地址为192.168.87.100的主机的远程SSH会话。您还必须能够使用之前设置的凭证成功登录到Raspbian的bash控制台:</p><figure class="mo mp mq mr gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nr"><img src="../Images/a63573342687fe660394ca5d45cc5ac8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*xP9mNu6Cw_qNWhBs"/></div></div></figure><h1 id="6370" class="ku kv jf bd kw kx ky kz la lb lc ld le kl lf km lg ko lh kp li kr lj ks lk ll bi translated">用CL/SYCL-Model在C++17中开发并行代码</h1><p id="d54d" class="pw-post-body-paragraph lm ln jf lo b lp lq kg lr ls lt kj lu lv lw lx ly lz ma mb mc md me mf mg mh ij bi translated">2020年，Khronos集团、英特尔公司和其他供应商宣布推出革命性的新型异构并行计算平台(XPU)，提供了将“繁重”数据处理工作负载的执行卸载到广泛的硬件加速(例如，GPGPU或FPGAs)目标的能力，而不仅仅是主机CPU。从概念上讲，使用XPU平台的并行代码开发完全基于Khronos CL/SYCL编程模型规范OpenCL 2.0库的抽象层。</p><p id="b017" class="pw-post-body-paragraph lm ln jf lo b lp mi kg lr ls mj kj lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">下面是一个很小的例子，展示了使用CL/SYCL-model抽象层实现的C++17中的代码:</p><pre class="mo mp mq mr gt nh ni nj nk aw nl bi"><span id="53e7" class="nm kv jf ni b gy nn no l np nq">#include &lt;CL/sycl.hpp&gt;</span><span id="1a90" class="nm kv jf ni b gy ns no l np nq">using namespace cl::sycl;</span><span id="7144" class="nm kv jf ni b gy ns no l np nq">constexpr std::uint32<em class="nt">_t N = 1000;</em></span><span id="bc0d" class="nm kv jf ni b gy ns no l np nq"><em class="nt">cl::sycl::queue q{};</em></span><span id="b59d" class="nm kv jf ni b gy ns no l np nq"><em class="nt">q.submit([&amp;](cl::sycl::handler &amp;cgh) {</em><br/><em class="nt">    cgh.parallel_</em>for&lt;class Kernel&gt;(cl::sycl::range&lt;1&gt;{N}, \<br/>       [=](cl::sycl::id&lt;1&gt; idx) {<br/>           // Do some work in parallel<br/>       });<br/>});</span><span id="8961" class="nm kv jf ni b gy ns no l np nq">q.wait();</span></pre><p id="2be8" class="pw-post-body-paragraph lm ln jf lo b lp mi kg lr ls mj kj lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">如上所示，C++17中的代码片段完全基于CL/SYCL编程模型交付。它用默认参数初始化列表实例化一个cl::sycl::queue{}对象，用于将sycl内核提交给默认使用的主机CPU加速目标来执行。接下来，它调用cl::sycl::submit(…)方法，使用cl::sycl::handler{}对象的单个参数来访问提供基本内核功能的方法，这些方法基于各种并行算法，包括cl::sycl::handler::parallel _ for(…)方法。</p><p id="d282" class="pw-post-body-paragraph lm ln jf lo b lp mi kg lr ls mj kj lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">下面的方法用于实现从正在运行的内核中产生的紧密并行循环。这个循环的每次迭代都由它自己的线程并行执行。cl::sycl::handler::parallel _ for(…)接受cl::sycl::range &lt;&gt; {}对象的两个主要参数和一个在每次循环迭代中调用的特定lambda函数。cl::sycl::range &lt;&gt; {}对象基本上为每个特定维度定义了几个正在执行的并行循环迭代，以防在处理多维数据时多个嵌套循环被折叠。</p><p id="e8f4" class="pw-post-body-paragraph lm ln jf lo b lp mi kg lr ls mj kj lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">在上面的代码中，cl::sycl::range &lt;1&gt; (N)对象用于调度一维并行循环的N次迭代。parallel_for(…)方法的lambda函数接受另一个cl::sycl::id &lt;&gt; {}对象的单个参数。和cl::sycl::range &lt;&gt; {}一样，这个对象实现了一个向量容器，其中的每个元素分别是并行循环的每个维度和每个迭代的索引值。作为参数传递给lambda函数范围内的代码，下面的对象用于检索特定的索引值。lambda函数的主体包含一段并行处理数据的代码。</p><p id="e1a1" class="pw-post-body-paragraph lm ln jf lo b lp mi kg lr ls mj kj lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">在将特定内核提交到队列并生成以供执行后，以下代码调用不带参数的cl::sycl::wait()方法来设置屏障同步，以确保它不会执行任何代码，直到正在生成的内核完成其并行工作。</p><blockquote class="nu nv nw"><p id="a4c8" class="lm ln nt lo b lp mi kg lr ls mj kj lu nx mk lx ly ny ml mb mc nz mm mf mg mh ij bi translated"><em class="jf">CL/SYCL异构编程模型效率高，应用广泛。</em></p><p id="f715" class="lm ln nt lo b lp mi kg lr ls mj kj lu nx mk lx ly ny ml mb mc nz mm mf mg mh ij bi translated">然而，英特尔公司和CodePlay Software Inc .很快就否决了除x86_64之外的硬件架构对CL/SYCL的支持。这使得不可能使用特定的CL/SYCL库，针对Arm/Aarch64和其他架构来交付并行C++代码。</p></blockquote><p id="1c07" class="pw-post-body-paragraph lm ln jf lo b lp mi kg lr ls mj kj lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">目前，有几个CL/SYCL开源库项目，由许多开发人员和爱好者开发，提供对更多硬件架构的支持，而不仅仅是x86_64。</p><blockquote class="nu nv nw"><p id="1717" class="lm ln nt lo b lp mi kg lr ls mj kj lu nx mk lx ly ny ml mb mc nz mm mf mg mh ij bi translated"><em class="jf">自2016年以来，Khronos Group，Inc .发布了他们的tri cycl库开源项目的修订版(</em><a class="ae ng" href="https://github.com/triSYCL/triSYCL" rel="noopener ugc nofollow" target="_blank"><em class="jf">https://github . com/tri cycl/tri cycl)、</em> </a> <em class="jf">，建议将其用作测试平台，同时评估最新的CL/SYCL编程模型层规范，并向Khronos-和ISO-委员会发送反馈。然而，下面的库发行版并不“稳定”,只能用于演示目的，而不能用于在生产中构建CL/SYCL代码。此外，Khronos triSYCL库发行版完全支持x86_64开发机器上的跨平台编译，使用GNU的Arm/Aarch64跨平台工具链，而不是在Raspberry Pi上使用LLVM/Clang编译器“本机”构建代码。</em></p><p id="962f" class="lm ln nt lo b lp mi kg lr ls mj kj lu nx mk lx ly ny ml mb mc nz mm mf mg mh ij bi translated"><em class="jf">2019年，海德堡大学(德国)的Aksel Alpay实现了最新的CL/SYCL编程模型层规范库，针对各种硬件架构，包括Raspberry Pi的Arm/Aarch64架构，并向GitHub(</em><a class="ae ng" href="https://github.com/illuhad/hipSYCL" rel="noopener ugc nofollow" target="_blank"><em class="jf">https://github.com/illuhad/hipSYCL</em></a><em class="jf">)贡献了hipSYCL开源库发行版中最“稳定”的版本。</em></p></blockquote><p id="4b48" class="pw-post-body-paragraph lm ln jf lo b lp mi kg lr ls mj kj lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">此外，在这个故事中，我们将讨论安装和配置GNU的跨平台GCC/G++-10.x.x和“本机”Arm/Aarch64的LLVM/Clang-9.x.x工具链，并使用triSYCL和hipSYCL库发行版，在C++17中交付一个现代的并行代码，基于正在讨论的库的使用。</p><h1 id="03c0" class="ku kv jf bd kw kx ky kz la lb lc ld le kl lf km lg ko lh kp li kr lj ks lk ll bi translated">在Debian/Ubuntu开发机器(x86_64)和Raspberry Pi物联网板上构建CL/SYCL代码</h1><p id="f4f3" class="pw-post-body-paragraph lm ln jf lo b lp lq kg lr ls lt kj lu lv lw lx ly lz ma mb mc md me mf mg mh ij bi translated">在C++17中，基本上有两种构建CL/SYCL代码的方法，如上所述，通过使用GNU的GCC/G++-10.x.x跨平台工具链和基于x86_64 Debian/Ubuntu的开发机器，或者在安装了LLVM/Clang-9.x.x用于Arm/Aarch64硬件架构的Raspberry Pi物联网板上“本地”构建。</p><p id="f65d" class="pw-post-body-paragraph lm ln jf lo b lp mi kg lr ls mj kj lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">使用第一种方法允许在C++17/2x0中构建代码源，在Raspberry Pi上运行之前，使用Khronos triSYCL库和GNU的跨平台Arm/aarch 64-tool chain Debian/Ubuntu-based x86 _ 64开发机器来实现。</p><p id="6556" class="pw-post-body-paragraph lm ln jf lo b lp mi kg lr ls mj kj lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">要部署x86_64开发机器，需要安装最新的Debian Buster 10.6.0或Ubuntu 20.04 LTS:</p><ul class=""><li id="7b15" class="ms mt jf lo b lp mi ls mj lv mu lz mv md mw mh mx my mz na bi translated"><a class="ae ng" href="https://cdimage.debian.org/debian-cd/current/amd64/iso-dvd/" rel="noopener ugc nofollow" target="_blank"> Debian Buster 10.6.0 x86_64 </a></li><li id="cbb5" class="ms mt jf lo b lp nb ls nc lv nd lz ne md nf mh mx my mz na bi translated"><a class="ae ng" href="https://ubuntu.com/#download" rel="noopener ugc nofollow" target="_blank"> Ubuntu 20.04 LTS x86_64 </a></li></ul><p id="8ef4" class="pw-post-body-paragraph lm ln jf lo b lp mi kg lr ls mj kj lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">为了能够在运行Microsoft Windows 10的主机上使用开发机器，可以使用选择的任何现有(例如Oracle VirtualBox或VMware Workstation)虚拟化环境，用于该目的:</p><ul class=""><li id="bb71" class="ms mt jf lo b lp mi ls mj lv mu lz mv md mw mh mx my mz na bi translated"><a class="ae ng" href="https://www.virtualbox.org/wiki/Downloads" rel="noopener ugc nofollow" target="_blank">用于Windows 10的64位Oracle VirtualBox 6.1</a></li><li id="5bcd" class="ms mt jf lo b lp nb ls nc lv nd lz ne md nf mh mx my mz na bi translated"><a class="ae ng" href="https://my.vmware.com/en/web/vmware/downloads/info/slug/desktop_end_user_computing/vmware_workstation_pro/16_0" rel="noopener ugc nofollow" target="_blank">适用于Windows 10的64位VMware Workstation 16</a></li></ul><p id="ec1e" class="pw-post-body-paragraph lm ln jf lo b lp mi kg lr ls mj kj lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">要开始部署开发机器，我们必须做的就是设置一个特定的虚拟化环境，创建一个虚拟机，并启动Debian或Ubuntu安装。</p><p id="b29c" class="pw-post-body-paragraph lm ln jf lo b lp mi kg lr ls mj kj lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">既然已经创建了虚拟机，并且Debian/Ubuntu已经成功安装，我们可以继续几个步骤，安装和配置GNU的GCC/G++-10.x.x跨平台编译器、开发工具和Khronos triSYCL库，这是针对Raspberry Pi的Arm/Aarch64架构构建代码所必需的。</p><p id="c5c4" class="pw-post-body-paragraph lm ln jf lo b lp mi kg lr ls mj kj lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">在安装和配置GCC/G++编译器工具链和运行时库之前，请确保已经完成了以下先决步骤:</p><ul class=""><li id="46fb" class="ms mt jf lo b lp mi ls mj lv mu lz mv md mw mh mx my mz na bi translated">升级Debian/Ubuntu的Linux基础系统:</li></ul><pre class="mo mp mq mr gt nh ni nj nk aw nl bi"><span id="cff3" class="nm kv jf ni b gy nn no l np nq">root@uarmhf64-dev:~# sudo apt update<br/>root@uarmhf64-dev:~# sudo apt upgrade -y<br/>root@uarmhf64-dev:~# sudo apt full-upgrade -y</span></pre><p id="3c4a" class="pw-post-body-paragraph lm ln jf lo b lp mi kg lr ls mj kj lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">要确保x86_64主机开发机器上运行的Debian/Ubuntu安装是最新的，并且安装了最新的内核和软件包，需要完成这个步骤。</p><ul class=""><li id="b17c" class="ms mt jf lo b lp mi ls mj lv mu lz mv md mw mh mx my mz na bi translated">从APT-repository安装“net-tools”和OpenSSH-server软件包:</li></ul><pre class="mo mp mq mr gt nh ni nj nk aw nl bi"><span id="cc94" class="nm kv jf ni b gy nn no l np nq">root@uarmhf64-dev:~# sudo apt install -y net-tools openssh-server</span></pre><p id="1c02" class="pw-post-body-paragraph lm ln jf lo b lp mi kg lr ls mj kj lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">安装“net-tools”和“openssh-server”是为了能够配置开发机器的网络接口，并通过ssh和FTP协议远程连接到正在运行的开发机器。</p><p id="5fcd" class="pw-post-body-paragraph lm ln jf lo b lp mi kg lr ls mj kj lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">由于系统已经升级，所有必需的软件包都已安装，我们可以安装和配置特定的编译器和工具链。</p><h1 id="abf8" class="ku kv jf bd kw kx ky kz la lb lc ld le kl lf km lg ko lh kp li kr lj ks lk ll bi translated">安装和配置GNU的GCC/G++-10.x.x</h1><p id="d659" class="pw-post-body-paragraph lm ln jf lo b lp lq kg lr ls lt kj lu lv lw lx ly lz ma mb mc md me mf mg mh ij bi translated">1.为x86_64平台安装GNU编译器集合(GCC)的工具链:</p><pre class="mo mp mq mr gt nh ni nj nk aw nl bi"><span id="972e" class="nm kv jf ni b gy nn no l np nq">root@uarmhf64-dev:~# sudo apt install -y build-essential</span></pre><p id="0021" class="pw-post-body-paragraph lm ln jf lo b lp mi kg lr ls mj kj lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">2.安装GNU的跨平台Arm64/Armhf工具链:</p><pre class="mo mp mq mr gt nh ni nj nk aw nl bi"><span id="d715" class="nm kv jf ni b gy nn no l np nq">root@uarmhf64-dev:~# sudo apt install -y crossbuild-essential-arm64<br/>root@uarmhf64-dev:~# sudo apt install -y crossbuild-essential-armhf</span></pre><p id="c462" class="pw-post-body-paragraph lm ln jf lo b lp mi kg lr ls mj kj lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">需要为Arm64/Armhf硬件架构安装跨平台工具链，以便在x86_64开发机器上构建使用triSYCL库的C++17并行代码。</p><p id="c4c2" class="pw-post-body-paragraph lm ln jf lo b lp mi kg lr ls mj kj lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">3.安装GNU的GCC/G++、OpenMP 5.0、Boost、Range-v3、POSIX线程、C/C++标准运行时库，需要:</p><pre class="mo mp mq mr gt nh ni nj nk aw nl bi"><span id="768f" class="nm kv jf ni b gy nn no l np nq">root@uarmhf64-dev:~# sudo apt install -y g++-10 libomp-dev libomp5 libboost-all-dev librange-v3-dev libc++-dev libc++1 libc++abi-dev libc++abi1 libpthread-stubs0-dev libpthread-workqueue-dev</span></pre><p id="a0eb" class="pw-post-body-paragraph lm ln jf lo b lp mi kg lr ls mj kj lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">4.安装GNU的GCC/G++-10.x.x .跨平台编译器，用于构建针对Arm64/Armhf架构的代码:</p><pre class="mo mp mq mr gt nh ni nj nk aw nl bi"><span id="bd45" class="nm kv jf ni b gy nn no l np nq">root@uarmhf64-dev:~# sudo apt install -y gcc-10-arm-linux-gnueabi g++-10-arm-linux-gnueabi gcc-10-arm-linux-gnueabihf g++-10-arm-linux-gnueabihf</span></pre><p id="b552" class="pw-post-body-paragraph lm ln jf lo b lp mi kg lr ls mj kj lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">5.选择默认情况下使用的GCC/G++-10.x.x“本机”x86_64编译器，更新备选方案:</p><pre class="mo mp mq mr gt nh ni nj nk aw nl bi"><span id="4d38" class="nm kv jf ni b gy nn no l np nq">sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-9 1<br/>sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-10 2<br/>sudo update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-9 1<br/>sudo update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-10 2<br/>sudo update-alternatives --install /usr/bin/cc cc /usr/bin/gcc 3<br/>sudo update-alternatives --set cc /usr/bin/gcc<br/>sudo update-alternatives --install /usr/bin/c++ c++ /usr/bin/g++ 3<br/>sudo update-alternatives --set c++ /usr/bin/g++</span></pre><p id="1aa1" class="pw-post-body-paragraph lm ln jf lo b lp mi kg lr ls mj kj lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">6.选择默认情况下使用的GCC/G++-10.x.x跨平台Arm/Aarch64编译器，更新备选方案:</p><pre class="mo mp mq mr gt nh ni nj nk aw nl bi"><span id="21bc" class="nm kv jf ni b gy nn no l np nq">sudo update-alternatives --install /usr/bin/arm-linux-gnueabihf-gcc arm-linux-gnueabihf-gcc /usr/bin/arm-linux-gnueabihf-gcc-9 1<br/>sudo update-alternatives --install /usr/bin/arm-linux-gnueabihf-gcc arm-linux-gnueabihf-gcc /usr/bin/arm-linux-gnueabihf-gcc-10 2<br/>sudo update-alternatives --install /usr/bin/arm-linux-gnueabihf-g++ arm-linux-gnueabihf-g++ /usr/bin/arm-linux-gnueabihf-g++-9 1<br/>sudo update-alternatives --install /usr/bin/arm-linux-gnueabihf-g++ arm-linux-gnueabihf-g++ /usr/bin/arm-linux-gnueabihf-g++-10 2<br/>sudo update-alternatives --install /usr/bin/arm-linux-gnueabihf-cc arm-linux-gnueabihf-cc /usr/bin/arm-linux-gnueabihf-gcc 3<br/>sudo update-alternatives --set arm-linux-gnueabihf-cc /usr/bin/arm-linux-gnueabihf-gcc<br/>sudo update-alternatives --install /usr/bin/arm-linux-gnueabihf-c++ arm-linux-gnueabihf-c++ /usr/bin/arm-linux-gnueabihf-g++ 3<br/>sudo update-alternatives --set arm-linux-gnueabihf-c++ /usr/bin/arm-linux-gnueabihf-g++</span></pre><p id="c68c" class="pw-post-body-paragraph lm ln jf lo b lp mi kg lr ls mj kj lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">7.最后，检查是否安装了GNU的“本地”和跨平台工具链的正确版本:</p><pre class="mo mp mq mr gt nh ni nj nk aw nl bi"><span id="a84d" class="nm kv jf ni b gy nn no l np nq">root@uarmhf64-dev:~# gcc --version &amp;&amp; g++ --version<br/>root@uarmhf64-dev:~# arm-linux-gnueabihf-gcc --version<br/>root@uarmhf64-dev:~# arm-linux-gnueabihf-g++ --version</span></pre><p id="74a9" class="pw-post-body-paragraph lm ln jf lo b lp mi kg lr ls mj kj lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">8.导航到/opt目录，从GitHub存储库中克隆Khronos triSYCL库发行版:</p><pre class="mo mp mq mr gt nh ni nj nk aw nl bi"><span id="fda7" class="nm kv jf ni b gy nn no l np nq">root@uarmhf64-dev:~# cd /opt<br/>root@uarmhf64-dev:~# git clone --recurse-submodules <a class="ae ng" href="https://github.com/triSYCL/triSYCL" rel="noopener ugc nofollow" target="_blank">https://github.com/triSYCL/triSYCL</a></span></pre><p id="1fa6" class="pw-post-body-paragraph lm ln jf lo b lp mi kg lr ls mj kj lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">以下命令将创建/opt/tri cycl子目录，其中包含tri cycl库分发源。</p><p id="ded1" class="pw-post-body-paragraph lm ln jf lo b lp mi kg lr ls mj kj lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">9.使用“rsync”命令，将triSYCL库的C++头文件从/opt/triSYCL/include目录复制到开发计算机上的默认位置/usr/include/c++/10/:</p><pre class="mo mp mq mr gt nh ni nj nk aw nl bi"><span id="0eb3" class="nm kv jf ni b gy nn no l np nq">root@uarmhf64-dev:~# cd /opt/triSYCL<br/>root@uarmhf64-dev:~# sudo rsync -r ./ include/ /usr/include/c++/10/</span></pre><p id="75cd" class="pw-post-body-paragraph lm ln jf lo b lp mi kg lr ls mj kj lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">10.设置使用triSYCL库和GNU跨平台工具链所需的环境变量，以前安装了:</p><pre class="mo mp mq mr gt nh ni nj nk aw nl bi"><span id="c3ea" class="nm kv jf ni b gy nn no l np nq">export CPLUS_INCLUDE_PATH=/usr/include/c++/10<br/>env CPLUS_INCLUDE_PATH=/usr/include/c++/10<br/>sudo echo "export CPLUS_INCLUDE_PATH=/usr/include/c++/10" &gt;&gt; /root/.bashrc</span></pre><p id="d989" class="pw-post-body-paragraph lm ln jf lo b lp mi kg lr ls mj kj lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">11.通过删除/opt/triSYCL子目录来执行简单的清理:</p><pre class="mo mp mq mr gt nh ni nj nk aw nl bi"><span id="45f1" class="nm kv jf ni b gy nn no l np nq">root@uarmhf64-dev:~# rm -rf /opt/triSYCL</span></pre><p id="2609" class="pw-post-body-paragraph lm ln jf lo b lp mi kg lr ls mj kj lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">12.使用“本机”x86_64 GNU的GCC/G++编译器构建“hello.cpp”代码示例:</p><pre class="mo mp mq mr gt nh ni nj nk aw nl bi"><span id="287a" class="nm kv jf ni b gy nn no l np nq">root@uarmhf64-dev:~# g++ -std=c++17 -o hello hello.cpp -lpthread -lstdc++</span></pre><p id="33ae" class="pw-post-body-paragraph lm ln jf lo b lp mi kg lr ls mj kj lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">在C++17/2x0中构建使用Khronos triSYCL库的特定代码需要POSIX线程和C++标准库的运行时链接。</p><p id="ab87" class="pw-post-body-paragraph lm ln jf lo b lp mi kg lr ls mj kj lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">13.使用GNU的跨平台GCC/G++编译器构建“hello.cpp”代码示例:</p><pre class="mo mp mq mr gt nh ni nj nk aw nl bi"><span id="57bf" class="nm kv jf ni b gy nn no l np nq">root@uarmhf64-dev:~# arm-linux-gnueabihf-g++ -std=c++17 -o hello_rpi4b hello.cpp -lpthread -lstdc++</span></pre><p id="f6a4" class="pw-post-body-paragraph lm ln jf lo b lp mi kg lr ls mj kj lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">既然我们已经成功地为Arm/Aarch64架构生成了代码可执行文件，那么就使用MobaXterm应用程序，通过FTP或SSH协议，从开发机器上下载可执行文件。之后，使用另一个SSH会话将“hello_rpi4b”可执行文件上传到Raspberry Pi板。</p><p id="51b1" class="pw-post-body-paragraph lm ln jf lo b lp mi kg lr ls mj kj lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">要运行“hello_rpi4b”可执行文件，请在Raspbian的bash控制台中使用以下命令，例如:</p><pre class="mo mp mq mr gt nh ni nj nk aw nl bi"><span id="c767" class="nm kv jf ni b gy nn no l np nq">root@uarmhf64-dev:~# chmod +rwx hello_rpi4b<br/>root@uarmhf64-dev:~# ./hello_rpi4b &gt; output.txt &amp;&amp; cat output.txt</span></pre><p id="1281" class="pw-post-body-paragraph lm ln jf lo b lp mi kg lr ls mj kj lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">这将创建输出并将其附加到‘output . txt’文件，将其内容打印到bash控制台:</p><pre class="mo mp mq mr gt nh ni nj nk aw nl bi"><span id="6368" class="nm kv jf ni b gy nn no l np nq">Hello from triSYCL on Rasberry Pi 4B+!!!<br/>Hello from triSYCL on Rasberry Pi 4B+!!!<br/>Hello from triSYCL on Rasberry Pi 4B+!!!<br/>Hello from triSYCL on Rasberry Pi 4B+!!!<br/>Hello from triSYCL on Rasberry Pi 4B+!!!</span></pre><p id="ec93" class="pw-post-body-paragraph lm ln jf lo b lp mi kg lr ls mj kj lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated"><strong class="lo jg">注意:</strong>通常，第一种方法不需要从源代码构建Khronos triSYCL库发行版，除非您计划将tri cycl用于其他HPC库，如OpenCL、OpenMP或TBB。有关使用triSYCL以及其他库的更多信息，请参考以下指南和文档<a class="ae ng" href="https://github.com/triSYCL/triSYCL/blob/master/doc/cmake.rst" rel="noopener ugc nofollow" target="_blank">https://github . com/triSYCL/triSYCL/blob/master/doc/cmake . rst</a>。</p><p id="6771" class="pw-post-body-paragraph lm ln jf lo b lp mi kg lr ls mj kj lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">使用Aksel Alpay的hipSYCL开源库发行版和LLVM/Clang-9.x.x. "native "编译器工具链，以Arm/Aarch64架构为目标，是第二种允许在C++17/2x0中构建CL/SYCL代码的方法，以便在Raspberry Pi板上运行。只有在LLVM/Clang-9.x.x工具链和hipSYCL库发行版都安装在Raspberry Pi板上，而不是x86_64开发机器本身上的情况下，特定代码的本地构建才是可能的。</p><p id="abc3" class="pw-post-body-paragraph lm ln jf lo b lp mi kg lr ls mj kj lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">此外，我们将讨论在Raspberry Pi板上安装和配置LLVM/Clang-9.x.x编译器工具链以及从源代码构建Aksel Alpay的hipSYCL库所需了解的一切。</p><h1 id="e2e8" class="ku kv jf bd kw kx ky kz la lb lc ld le kl lf km lg ko lh kp li kr lj ks lk ll bi translated">安装和配置LLVM/Clang-9.x.x</h1><p id="b591" class="pw-post-body-paragraph lm ln jf lo b lp lq kg lr ls lt kj lu lv lw lx ly lz ma mb mc md me mf mg mh ij bi translated">在使用Aksel Alpay的hipSYCL库项目发行版之前，必须正确安装和配置特定的LLVM/Clang-9.x.x编译器和Arm/Aarch64工具链。为此，请确保您已经完成了下列步骤:</p><p id="0cca" class="pw-post-body-paragraph lm ln jf lo b lp mi kg lr ls mj kj lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">1.更新Raspbian的APT-repositories并安装以下必备软件包:</p><pre class="mo mp mq mr gt nh ni nj nk aw nl bi"><span id="b6fb" class="nm kv jf ni b gy nn no l np nq">root@raspberrypi4:~# sudo apt update<br/>root@raspberrypi4:~# sudo apt install -y bison flex python python3 snap snapd git wget</span></pre><p id="ec4c" class="pw-post-body-paragraph lm ln jf lo b lp mi kg lr ls mj kj lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">上面的命令将安装一个替代的“snap”包管理器，这是安装cmake &gt;= 3.18.0实用程序的正确版本所必需的，以及使用“cmake”实用程序从头开始构建hipSYCL开源项目所需的“python”、“python3”发行版和“bison”、“flex”实用程序。</p><p id="311d" class="pw-post-body-paragraph lm ln jf lo b lp mi kg lr ls mj kj lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">2.使用“快照”软件包管理器安装“cmake”&gt; = 3 . 18 . 0实用程序和LLVM/Clang守护程序:</p><pre class="mo mp mq mr gt nh ni nj nk aw nl bi"><span id="4201" class="nm kv jf ni b gy nn no l np nq">root@raspberrypi4:~# sudo snap install cmake --classic<br/>root@raspberrypi4:~# sudo snap install clangd --classic</span></pre><p id="ecb3" class="pw-post-body-paragraph lm ln jf lo b lp mi kg lr ls mj kj lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">安装“cmake”实用程序后，让我们使用下面的命令检查它是否工作，以及是否从“snap”存储库中安装了正确的版本:</p><pre class="mo mp mq mr gt nh ni nj nk aw nl bi"><span id="e780" class="nm kv jf ni b gy nn no l np nq">root@raspberrypi4:~# sudo cmake --version</span></pre><p id="f4b0" class="pw-post-body-paragraph lm ln jf lo b lp mi kg lr ls mj kj lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">运行此命令后，您必须看到以下输出:</p><pre class="mo mp mq mr gt nh ni nj nk aw nl bi"><span id="e9de" class="nm kv jf ni b gy nn no l np nq">cmake version 3.18.4</span><span id="03d8" class="nm kv jf ni b gy ns no l np nq">CMake suite maintained and supported by Kitware (kitware.com/cmake).</span></pre><p id="8590" class="pw-post-body-paragraph lm ln jf lo b lp mi kg lr ls mj kj lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">3.为LLVM/Clang工具链安装最新的Boost、POSIX-Threads和C/C++标准运行时库:</p><pre class="mo mp mq mr gt nh ni nj nk aw nl bi"><span id="4372" class="nm kv jf ni b gy nn no l np nq">root@raspberrypi4:~# sudo apt install -y libc++-dev libc++1 libc++abi-dev libc++abi1 libpthread-stubs0-dev libpthread-workqueue-dev</span><span id="ce2e" class="nm kv jf ni b gy ns no l np nq">root@raspberrypi4:~# sudo apt install -y clang-format clang-tidy clang-tools clang libc++-dev libc++1 libc++abi-dev libc++abi1 libclang-dev libclang1 liblldb-dev libllvm-ocaml-dev libomp-dev libomp5 lld lldb llvm-dev llvm-runtime llvm python-clang libboost-all-dev</span></pre><p id="9572" class="pw-post-body-paragraph lm ln jf lo b lp mi kg lr ls mj kj lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">4.下载并添加LLVM/Clang的APT-repositories安全密钥:</p><pre class="mo mp mq mr gt nh ni nj nk aw nl bi"><span id="94cc" class="nm kv jf ni b gy nn no l np nq">root@raspberrypi4:~# wget -O - https://apt.llvm.org/llvm-snapshot.gpg.key | sudo apt-key add -</span></pre><p id="797e" class="pw-post-body-paragraph lm ln jf lo b lp mi kg lr ls mj kj lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">5.将LLVM/Clang的存储库URL附加到APT的源中。</p><pre class="mo mp mq mr gt nh ni nj nk aw nl bi"><span id="6824" class="nm kv jf ni b gy nn no l np nq">root@raspberrypi4:~# echo "deb http://apt.llvm.org/buster/ llvm-toolchain-buster main" &gt;&gt; /etc/apt/sources.list.d/raspi.list</span><span id="42b7" class="nm kv jf ni b gy ns no l np nq">root@raspberrypi4:~# echo "deb-src http://apt.llvm.org/buster/ llvm-toolchain-buster main" &gt;&gt; /etc/apt/sources.list.d/raspi.list</span></pre><p id="3358" class="pw-post-body-paragraph lm ln jf lo b lp mi kg lr ls mj kj lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">要从特定的APT资源库安装LLVM/Clang-9.x.x .编译器和特定的工具链，必须完成前面的两个步骤4和5。</p><p id="2627" class="pw-post-body-paragraph lm ln jf lo b lp mi kg lr ls mj kj lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">6.删除LLVM/Clang先前版本的现有符号链接，安装:</p><pre class="mo mp mq mr gt nh ni nj nk aw nl bi"><span id="1b49" class="nm kv jf ni b gy nn no l np nq">root@raspberrypi4:~# cd /usr/bin &amp;&amp; rm -f clang clang++</span></pre><p id="3c46" class="pw-post-body-paragraph lm ln jf lo b lp mi kg lr ls mj kj lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">7.再次更新APT库，并安装LLVM/Clang的编译器、调试器和链接器:</p><pre class="mo mp mq mr gt nh ni nj nk aw nl bi"><span id="01f6" class="nm kv jf ni b gy nn no l np nq">root@raspberrypi4:~# sudo apt update<br/>root@raspberrypi4:~# sudo apt install -y clang-9 lldb-9 lld-9</span></pre><p id="f203" class="pw-post-body-paragraph lm ln jf lo b lp mi kg lr ls mj kj lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">8.创建“clang-9”和“clang++-9”编译器的相应符号链接，安装:</p><pre class="mo mp mq mr gt nh ni nj nk aw nl bi"><span id="e2ff" class="nm kv jf ni b gy nn no l np nq">root@raspberrypi4:~# cd /usr/bin &amp;&amp; ln -s clang-9 clang<br/>root@raspberrypi4:~# cd /usr/bin &amp;&amp; ln -s clang++-9 clang++</span></pre><p id="a366" class="pw-post-body-paragraph lm ln jf lo b lp mi kg lr ls mj kj lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">9.最后，您必须能够在bash控制台中使用“clang”和“clang++”命令:</p><pre class="mo mp mq mr gt nh ni nj nk aw nl bi"><span id="5056" class="nm kv jf ni b gy nn no l np nq">root@raspberrypi4:~# clang --version &amp;&amp; clang++ --version</span></pre><p id="c30e" class="pw-post-body-paragraph lm ln jf lo b lp mi kg lr ls mj kj lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">这里，让我们检查使用上面的命令安装的LLVM/Clang的版本。</p><p id="1e9a" class="pw-post-body-paragraph lm ln jf lo b lp mi kg lr ls mj kj lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">使用这些命令后，您必须看到以下输出:</p><pre class="mo mp mq mr gt nh ni nj nk aw nl bi"><span id="5932" class="nm kv jf ni b gy nn no l np nq">clang version 9.0.1-6+rpi1~bpo10+1<br/>Target: armv6k-unknown-linux-gnueabihf<br/>Thread model: posix<br/>InstalledDir: /usr/bin<br/>clang version 9.0.1-6+rpi1~bpo10+1<br/>Target: armv6k-unknown-linux-gnueabihf<br/>Thread model: posix<br/>InstalledDir: /usr/bin</span></pre><h1 id="63cd" class="ku kv jf bd kw kx ky kz la lb lc ld le kl lf km lg ko lh kp li kr lj ks lk ll bi translated">下载并构建hipSYCL库发行版</h1><p id="ba3b" class="pw-post-body-paragraph lm ln jf lo b lp lq kg lr ls lt kj lu lv lw lx ly lz ma mb mc md me mf mg mh ij bi translated">另一个重要的步骤是下载和构建开源hipSYCL库staging distribution，从它的源代码，贡献给GitHub。</p><p id="6ccd" class="pw-post-body-paragraph lm ln jf lo b lp mi kg lr ls mj kj lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">这通常通过完成以下步骤来完成:</p><p id="6159" class="pw-post-body-paragraph lm ln jf lo b lp mi kg lr ls mj kj lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">1.下载hipSYCL项目的发行版，从GitHub克隆它:</p><pre class="mo mp mq mr gt nh ni nj nk aw nl bi"><span id="0f0d" class="nm kv jf ni b gy nn no l np nq">root@raspberrypi4:~# git clone https://github.com/llvm/llvm-project llvm-project<br/>root@raspberrypi4:~# git clone --recurse-submodules <a class="ae ng" href="https://github.com/illuhad/hipSYCL" rel="noopener ugc nofollow" target="_blank">https://github.com/illuhad/hipSYCL</a></span></pre><p id="65ff" class="pw-post-body-paragraph lm ln jf lo b lp mi kg lr ls mj kj lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">Aksel Alpay的hipSYCL项目的发行版依赖于另一个项目LLVM/Clang的开源项目。这就是为什么我们通常需要克隆两个发行版来“从头”构建hipSYCL库运行时。</p><p id="3816" class="pw-post-body-paragraph lm ln jf lo b lp mi kg lr ls mj kj lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">2.通过使用“export”和“env”命令，以及将下面的特定行附加到。bashrc配置文件脚本:</p><pre class="mo mp mq mr gt nh ni nj nk aw nl bi"><span id="9b73" class="nm kv jf ni b gy nn no l np nq">export LLVM_INSTALL_PREFIX=/usr<br/>export LLVM_DIR=~/llvm-project/llvm<br/>export CLANG_EXECUTABLE_PATH=/usr/bin/clang++<br/>export CLANG_INCLUDE_PATH=$LLVM_INSTALL_PREFIX/include/clang/9.0.1/include</span><span id="c5d0" class="nm kv jf ni b gy ns no l np nq">echo "export LLVM_INSTALL_PREFIX=/usr" &gt;&gt; /root/.bashrc<br/>echo "export LLVM_DIR=~/llvm-project/llvm" &gt;&gt; /root/.bashrc<br/>echo "export CLANG_EXECUTABLE_PATH=/usr/bin/clang++" &gt;&gt; /root/.bashrc<br/>echo "export CLANG_INCLUDE_PATH=$LLVM_INSTALL_PREFIX/include/clang/9.0.1/include" &gt;&gt; /root/.bashrc</span><span id="a654" class="nm kv jf ni b gy ns no l np nq">env LLVM_INSTALL_PREFIX=/usr<br/>env LLVM_DIR=~/llvm-project/llvm<br/>env CLANG_EXECUTABLE_PATH=/usr/bin/clang++<br/>env CLANG_INCLUDE_PATH=$LLVM_INSTALL_PREFIX/include/clang/9.0.1/include</span></pre><p id="b87c" class="pw-post-body-paragraph lm ln jf lo b lp mi kg lr ls mj kj lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">3.在hipSYCL项目的主目录下创建并切换到~/hipSYCL/build子目录:</p><pre class="mo mp mq mr gt nh ni nj nk aw nl bi"><span id="1cda" class="nm kv jf ni b gy nn no l np nq">root@raspberrypi4:~# mkdir ~/hipSYCL/build &amp;&amp; cd ~/hipSYCL/build</span></pre><p id="7040" class="pw-post-body-paragraph lm ln jf lo b lp mi kg lr ls mj kj lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">4.使用“cmake”实用程序配置hipSYCL项目的源代码:</p><pre class="mo mp mq mr gt nh ni nj nk aw nl bi"><span id="4445" class="nm kv jf ni b gy nn no l np nq">root@raspberrypi4:~# cmake -DCMAKE_INSTALL_PREFIX=/opt/hipSYCL ..</span></pre><p id="456b" class="pw-post-body-paragraph lm ln jf lo b lp mi kg lr ls mj kj lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">5.使用GNU的“make”命令构建并安装hipSYCL运行时库:</p><pre class="mo mp mq mr gt nh ni nj nk aw nl bi"><span id="4730" class="nm kv jf ni b gy nn no l np nq">root@raspberrypi4:~# make -j $(nproc) &amp;&amp; make install -j $(nproc)</span></pre><p id="54a7" class="pw-post-body-paragraph lm ln jf lo b lp mi kg lr ls mj kj lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">6.将libhipSYCL-rt.iso运行时库复制到Raspbian的默认库位置:</p><pre class="mo mp mq mr gt nh ni nj nk aw nl bi"><span id="d1fe" class="nm kv jf ni b gy nn no l np nq">root@raspberrypi4:~# cp /opt/hipSYCL/lib/libhipSYCL-rt.so /usr/lib/libhipSYCL-rt.so</span></pre><p id="9458" class="pw-post-body-paragraph lm ln jf lo b lp mi kg lr ls mj kj lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">7.设置使用hipSYCL运行时库和LLVM/Clang编译器构建源代码所需的环境变量:</p><pre class="mo mp mq mr gt nh ni nj nk aw nl bi"><span id="d4cf" class="nm kv jf ni b gy nn no l np nq">export PATH=$PATH:/opt/hipSYCL/bin<br/>export C_INCLUDE_PATH=$C_INCLUDE_PATH:/opt/hipSYCL/include<br/>export CPLUS_INCLUDE_PATH=$CPLUS_INCLUDE_PATH:/opt/hipSYCL/include<br/>export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/opt/hipSYCL/lib</span><span id="9919" class="nm kv jf ni b gy ns no l np nq">echo "export PATH=$PATH:/opt/hipSYCL/bin" &gt;&gt; /root/.bashrc<br/>echo "export C_INCLUDE_PATH=$C_INCLUDE_PATH:/opt/hipSYCL/include" &gt;&gt; /root/.bashrc<br/>echo "export CPLUS_INCLUDE_PATH=$CPLUS_INCLUDE_PATH:/opt/hipSYCL/include" &gt;&gt; /root/.bashrc<br/>echo "export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/opt/hipSYCL/lib" &gt;&gt; /root/.bashrc</span><span id="46c0" class="nm kv jf ni b gy ns no l np nq">env PATH=$PATH:/opt/hipSYCL/bin<br/>env C_INCLUDE_PATH=$C_INCLUDE_PATH:/opt/hipSYCL/include<br/>env CPLUS_INCLUDE_PATH=$CPLUS_INCLUDE_PATH:/opt/hipSYCL/include<br/>env LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/opt/hipSYCL/lib</span></pre><h1 id="b3ae" class="ku kv jf bd kw kx ky kz la lb lc ld le kl lf km lg ko lh kp li kr lj ks lk ll bi translated">在Raspberry Pi 4B+上运行C++17中的并行CL/SYCL代码</h1><p id="12ef" class="pw-post-body-paragraph lm ln jf lo b lp lq kg lr ls lt kj lu lv lw lx ly lz ma mb mc md me mf mg mh ij bi translated">由于我们最终已经完成了LLVM/Clang和hipSYCL库的安装和配置，所以强烈建议构建并运行“matmul_hipsycl”示例的可执行文件，确保一切正常运行:</p><p id="1464" class="pw-post-body-paragraph lm ln jf lo b lp mi kg lr ls mj kj lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">以下是从源代码构建以下示例的最常见步骤:</p><pre class="mo mp mq mr gt nh ni nj nk aw nl bi"><span id="3439" class="nm kv jf ni b gy nn no l np nq">rm -rf ~/sources<br/>mkdir ~/sources &amp;&amp; cd ~/sources<br/>cp ~/matmul_hipsycl.tar.gz ~/sources/matmul_hipsycl.tar.gz<br/>tar -xvf matmul_hipsycl.tar.gz<br/>rm -f matmul_hipsycl.tar.gz</span></pre><p id="2e7e" class="pw-post-body-paragraph lm ln jf lo b lp mi kg lr ls mj kj lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">上面的一组命令将创建~/source子目录，并从matmul_hipsycl.tar.gz归档文件中提取sample的源代码。</p><p id="0767" class="pw-post-body-paragraph lm ln jf lo b lp mi kg lr ls mj kj lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">要构建示例的可执行文件，请使用GNU的“make”命令:</p><pre class="mo mp mq mr gt nh ni nj nk aw nl bi"><span id="f8e6" class="nm kv jf ni b gy nn no l np nq">root@raspberrypi4:~# make all</span></pre><p id="2815" class="pw-post-body-paragraph lm ln jf lo b lp mi kg lr ls mj kj lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">这将调用“clang++”命令来构建可执行文件:</p><pre class="mo mp mq mr gt nh ni nj nk aw nl bi"><span id="efbc" class="nm kv jf ni b gy nn no l np nq">syclcc-clang -O3 -std=c++17 -o matrix_mul_rpi4 src/matrix_mul_rpi4b.cpp -lstdc++</span></pre><p id="6dc1" class="pw-post-body-paragraph lm ln jf lo b lp mi kg lr ls mj kj lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">该命令将使用最高级别的代码优化(例如O3)来编译特定的C++17代码，并将其与C++标准库运行时相链接。</p><blockquote class="nu nv nw"><p id="75f3" class="lm ln nt lo b lp mi kg lr ls mj kj lu nx mk lx ly ny ml mb mc nz mm mf mg mh ij bi translated"><strong class="lo jg"> <em class="jf">注:</em> </strong> <em class="jf">随着库运行时，hipSYCL项目的建立，还提供了同样的‘syc LCC’和‘syc LCC-clang’工具，用于构建并行代码，在C++17中，使用hipSYCL库实现。这些工具的使用与“clang”和“clang++”命令的常规用法略有不同。但是，仍然可以使用“syclcc”和“syclcc-clang ”,指定与原始“clang”和“clang++”命令相同的编译器和链接器选项。</em></p></blockquote><p id="c41d" class="pw-post-body-paragraph lm ln jf lo b lp mi kg lr ls mj kj lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">使用这些工具执行编译后，使用下面列出的命令向编译器生成的“matrix_mul_rpi4”文件授予执行权限:</p><pre class="mo mp mq mr gt nh ni nj nk aw nl bi"><span id="509c" class="nm kv jf ni b gy nn no l np nq">root@raspberrypi4:~# chmod +rwx matrix_mul_rpi4</span></pre><p id="9d94" class="pw-post-body-paragraph lm ln jf lo b lp mi kg lr ls mj kj lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">在bash控制台中运行可执行文件:</p><pre class="mo mp mq mr gt nh ni nj nk aw nl bi"><span id="177b" class="nm kv jf ni b gy nn no l np nq">root@raspberrypi4:~# ./matrix_mul_rpi4</span></pre><p id="3ad6" class="pw-post-body-paragraph lm ln jf lo b lp mi kg lr ls mj kj lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">运行之后，执行将会以以下输出结束:</p><pre class="mo mp mq mr gt nh ni nj nk aw nl bi"><span id="83e7" class="nm kv jf ni b gy nn no l np nq">* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *</span><span id="84db" class="nm kv jf ni b gy ns no l np nq">Multiplication C = A x B:</span><span id="acb5" class="nm kv jf ni b gy ns no l np nq">Matrix C:</span><span id="1815" class="nm kv jf ni b gy ns no l np nq">323 445 243 343 363 316 495 382 463 374<br/>322 329 328 388 378 395 392 432 470 326<br/>398 357 337 366 386 407 478 457 520 374<br/>543 531 382 470 555 520 602 534 639 505<br/>294 388 277 314 278 330 430 319 396 372<br/>447 445 433 485 524 505 604 535 628 509<br/>445 468 349 432 511 391 552 449 534 470<br/>434 454 339 417 502 455 533 498 588 444<br/>470 340 416 364 401 396 485 417 496 464<br/>431 421 325 325 272 331 420 385 419 468<br/></span><span id="5720" class="nm kv jf ni b gy ns no l np nq">Execution time: 5 ms</span></pre><p id="fd9c" class="pw-post-body-paragraph lm ln jf lo b lp mi kg lr ls mj kj lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">或者，我们可以通过安装和使用以下实用程序来评估正在执行的并行代码的性能:</p><pre class="mo mp mq mr gt nh ni nj nk aw nl bi"><span id="34e5" class="nm kv jf ni b gy nn no l np nq">root@raspberrypi4:~# sudo apt install -y top htop</span></pre><p id="45b4" class="pw-post-body-paragraph lm ln jf lo b lp mi kg lr ls mj kj lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">使用已安装的“htop”实用程序，可以在运行并行代码可执行文件时直观显示CPU和系统内存的利用率:</p><figure class="mo mp mq mr gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nr"><img src="../Images/aac90d3d869f45d446c91fee24233418.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ODJ6r2cQc8yVV7va"/></div></div></figure><h1 id="697b" class="ku kv jf bd kw kx ky kz la lb lc ld le kl lf km lg ko lh kp li kr lj ks lk ll bi translated"><strong class="ak"> LLVM/Clang-9.x.x编译器和Aksel Alpay的hipSYCL安装和配置脚本</strong></h1><p id="ffac" class="pw-post-body-paragraph lm ln jf lo b lp lq kg lr ls lt kj lu lv lw lx ly lz ma mb mc md me mf mg mh ij bi translated">用于安装和配置LLVM/Clang-9.x.x Arm/Aarch64编译器和Aksel Alpay的hipSYCL库开源发行版的自动化bash脚本</p><pre class="mo mp mq mr gt nh ni nj nk aw nl bi"><span id="b125" class="nm kv jf ni b gy nn no l np nq">#!/bin/sh<br/><br/>sudo apt update<br/><br/>sudo apt install -y bison flex python python3 snap snapd git wget<br/><br/>sudo snap install cmake --classic<br/>sudo snap install clangd --classic<br/><br/>sudo apt install -y libc++-dev libc++1 libc++abi-dev libc++abi1 libpthread-stubs0-dev libpthread-workqueue-dev<br/>sudo apt install -y clang-format clang-tidy clang-tools clang libc++-dev libc++1 libc++abi-dev libc++abi1 libclang-dev libclang1 liblldb-dev libllvm-ocaml-dev libomp-dev libomp5 lld lldb llvm-dev llvm-runtime llvm python-clang libboost-all-dev<br/><br/>wget -O - https://apt.llvm.org/llvm-snapshot.gpg.key | sudo apt-key add -<br/><br/>echo "deb http://apt.llvm.org/buster/ llvm-toolchain-buster main" &gt;&gt; /etc/apt/sources.list.d/raspi.list<br/>echo "deb-src http://apt.llvm.org/buster/ llvm-toolchain-buster main" &gt;&gt; /etc/apt/sources.list.d/raspi.list<br/><br/>cd ~<br/><br/>sudo apt update<br/><br/>sudo apt install -y clang-9 lldb-9 lld-9<br/><br/>cd /usr/bin &amp;&amp; rm -f clang clang++<br/><br/>cd /usr/bin &amp;&amp; ln -s clang-9 clang<br/>cd /usr/bin &amp;&amp; ln -s clang++-9 clang++<br/><br/>cd ~<br/><br/>git clone https://github.com/llvm/llvm-project llvm-project<br/>git clone --recurse-submodules https://github.com/illuhad/hipSYCL<br/><br/>export LLVM_INSTALL_PREFIX=/usr<br/>export LLVM_DIR=~/llvm-project/llvm<br/>export CLANG_EXECUTABLE_PATH=/usr/bin/clang++<br/>export CLANG_INCLUDE_PATH=$LLVM_INSTALL_PREFIX/include/clang/9.0.1/include<br/><br/>echo "export LLVM_INSTALL_PREFIX=/usr" &gt;&gt; /root/.bashrc<br/>echo "export LLVM_DIR=~/llvm-project/llvm" &gt;&gt; /root/.bashrc<br/>echo "export CLANG_EXECUTABLE_PATH=/usr/bin/clang++" &gt;&gt; /root/.bashrc<br/>echo "export CLANG_INCLUDE_PATH=$LLVM_INSTALL_PREFIX/include/clang/9.0.1/include" &gt;&gt; /root/.bashrc<br/><br/>env LLVM_INSTALL_PREFIX=/usr<br/>env LLVM_DIR=~/llvm-project/llvm<br/>env CLANG_EXECUTABLE_PATH=/usr/bin/clang++<br/>env CLANG_INCLUDE_PATH=$LLVM_INSTALL_PREFIX/include/clang/9.0.1/include<br/><br/>mkdir ~/hipSYCL/build &amp;&amp; cd ~/hipSYCL/build<br/><br/>cmake -DCMAKE_INSTALL_PREFIX=/opt/hipSYCL ..<br/><br/>make -j $(nproc) &amp;&amp; make install -j $(nproc)<br/><br/>cp /opt/hipSYCL/lib/libhipSYCL-rt.so /usr/lib/libhipSYCL-rt.so<br/><br/>export PATH=$PATH:/opt/hipSYCL/bin<br/>export C_INCLUDE_PATH=$C_INCLUDE_PATH:/opt/hipSYCL/include<br/>export CPLUS_INCLUDE_PATH=$CPLUS_INCLUDE_PATH:/opt/hipSYCL/include<br/>export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/opt/hipSYCL/lib<br/><br/>echo "export PATH=$PATH:/opt/hipSYCL/bin" &gt;&gt; /root/.bashrc<br/>echo "export C_INCLUDE_PATH=$C_INCLUDE_PATH:/opt/hipSYCL/include" &gt;&gt; /root/.bashrc<br/>echo "export CPLUS_INCLUDE_PATH=$CPLUS_INCLUDE_PATH:/opt/hipSYCL/include" &gt;&gt; /root/.bashrc<br/>echo "export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/opt/hipSYCL/lib" &gt;&gt; /root/.bashrc<br/><br/>env PATH=$PATH:/opt/hipSYCL/bin<br/>env C_INCLUDE_PATH=$C_INCLUDE_PATH:/opt/hipSYCL/include<br/>env CPLUS_INCLUDE_PATH=$CPLUS_INCLUDE_PATH:/opt/hipSYCL/include<br/>env LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/opt/hipSYCL/lib<br/><br/>echo "\n*** CONGRATULATIONS!!! YOU'RE ALL SET! ***\n\n"<br/>echo "*** BUILDING MATMUL PROJECT FOR RASPI4B+ ***\n\n"<br/><br/>rm -rf ~/sources<br/><br/>mkdir ~/sources &amp;&amp; cd ~/sources<br/><br/>cp ~/matmul_hipsycl.tar.gz ~/sources/matmul_hipsycl.tar.gz<br/><br/>tar -xvf matmul_hipsycl.tar.gz<br/><br/>rm -f matmul_hipsycl.tar.gz<br/><br/>make all<br/><br/>echo "\n*** RUNNING PARALLEL MATMUL (CL/HIPSYCL) EXECUTABLE ON RASPI4B+ ***\n"<br/><br/>./matrix_mul_rpi4 &gt; output.txt<br/><br/>cat output.txt<br/><br/>rm -f output.txt &amp;&amp; cd ~<br/><br/>echo "\n*** SUCCESS!!! ***\n\n"</span></pre><h1 id="2173" class="ku kv jf bd kw kx ky kz la lb lc ld le kl lf km lg ko lh kp li kr lj ks lk ll bi translated">总之…</h1><p id="f035" class="pw-post-body-paragraph lm ln jf lo b lp lq kg lr ls lt kj lu lv lw lx ly lz ma mb mc md me mf mg mh ij bi translated">微FPGAs，以及具有计算能力的口袋大小的GPGPUs，通过GPIO或USB接口从外部连接到物联网板，是物联网并行计算的下一个巨大进步。使用微型FPGAs和GPGPUs提供了并行执行更复杂和“繁重”计算的机会，大大提高了实际性能，同时实时处理大量大数据。</p><p id="d2f5" class="pw-post-body-paragraph lm ln jf lo b lp mi kg lr ls mj kj lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">显然，物联网并行计算的另一个重要方面是继续开发特定的库和框架，提供CL/SYCL模型层规范，从而提供异构计算平台(XPU)支持。目前，这些库的最新版本仅提供对将并行代码执行卸载到主机CPU加速目标的支持，因为其他加速硬件，如用于纳米计算机的小型GPGPUs和FPGAs，目前还没有由其供应商设计和制造。</p><p id="a3e8" class="pw-post-body-paragraph lm ln jf lo b lp mi kg lr ls mj kj lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">事实上，使用Raspberry Pi和其他特定物联网板进行并行计算是软件开发人员和硬件技术人员的一个特别兴趣点，在与物联网并行运行时对现有计算流程进行性能评估。</p><p id="bb3c" class="pw-post-body-paragraph lm ln jf lo b lp mi kg lr ls mj kj lu lv mk lx ly lz ml mb mc md mm mf mg mh ij bi translated">总之，利用基于物联网的并行计算通常有利于旨在实时收集和大规模处理大数据的基于云的解决方案的整体性能。因此，它会积极影响机器学习(ML)和数据分析本身的质量。</p></div></div>    
</body>
</html>