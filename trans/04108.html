<html>
<head>
<title>Git commands data scientists use on a day-to-day basis</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Git命令科学家日常使用的数据</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/git-commands-data-scientists-use-on-a-day-to-day-basis-40d588cd63f7?source=collection_archive---------4-----------------------#2021-04-07">https://towardsdatascience.com/git-commands-data-scientists-use-on-a-day-to-day-basis-40d588cd63f7?source=collection_archive---------4-----------------------#2021-04-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="bf8c" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">面向数据科学家的GIT</h2><div class=""/><div class=""><h2 id="daf0" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">适用于查看本地PR副本、带回混乱的文件或删除PR中的文件等情况。</h2></div><p id="4644" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">在你问我为什么在2021年还在使用命令行Git之前，<em class="ln">等等</em>，我可以解释！所以你真的不喜欢使用命令行，尤其是当有这么多完美的图形用户界面存在的时候。</p><p id="8a3d" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">最近，我的大部分工作转移到了Linux机器上，我正在寻找一个git扩展或GUI来支持Jupyterlab远程服务器。在这个问题<a class="ae lo" href="https://github.com/shiftkey/desktop/issues/281" rel="noopener ugc nofollow" target="_blank">这里</a>浪费了许多宝贵的时间之后，我最终决定系好安全带，作为一名数据科学家，学习一些可能对任何给定场景都有用的命令。同样，我希望在无法使用GUI并且Git命令行是唯一选择的服务器环境中工作时，学习这些知识会派上用场。</p><p id="4cd1" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">不仅仅是一个备忘单，我更愿意把这篇文章看作是一个假设的<em class="ln">你会做什么</em>的场景列表，一个我可能会比你们中的任何人使用得更多的场景(尽管如果它确实对你有帮助，嗯…越多越好！:) ).有些场景是基本的，我相信你知道如何通过它们，其他的场景更具体，尽管我相信你能理解它们。</p><p id="9db4" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">这绝不是一个详尽的列表，而是一些在我日常工作环境中经常出现的主题。</p><p id="8633" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><em class="ln">免责声明:本文是为具有一些Git基础知识的读者而写的。我的基本意思是，如果你拥有一个Github账户，并且当我说“检查一个分支”和“提交一个更改”时，你不认为我在说某种外星语言，那么你就一切就绪了！</em></p><h2 id="15e0" class="lt lu it bd lv lw lx dn ly lz ma dp mb la mc md me le mf mg mh li mi mj mk iz bi translated">术语和术语</h2><p id="3d8e" class="pw-post-body-paragraph kr ks it kt b ku ml kd kw kx mm kg kz la mn lc ld le mo lg lh li mp lk ll lm im bi translated">在整篇文章中，每当我提到<strong class="kt jd">本地</strong>变更时，我指的是您在本地对您计算机上的项目副本所做的变更。<strong class="kt jd">远程</strong>变更意味着您正在对存在于Github服务器上的项目副本进行变更。</p><p id="ddc2" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">作为一个经验法则，在本地拷贝上玩你想玩的，但是在用你的本地改变修改远程拷贝时要非常小心。</p><p id="0881" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">考虑到所有这些，让我们浏览一下初学者可能面临的一些常见场景以及如何解决它们。</p><p id="a9f4" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><em class="ln">附言:这些场景没有特定的顺序。</em></p><h2 id="eb46" class="lt lu it bd lv lw lx dn ly lz ma dp mb la mc md me le mf mg mh li mi mj mk iz bi translated">场景1</h2><blockquote class="mq mr ms"><p id="b720" class="kr ks ln kt b ku kv kd kw kx ky kg kz mt lb lc ld mu lf lg lh mv lj lk ll lm im bi translated">公司开始了一个新项目，你想参与其中，这样你就可以开始为之做出贡献。</p></blockquote><p id="3fc6" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">一旦某个团队成员将您添加为协作者，您所要做的就是转到Git bash或Mac终端，根据您是想在桌面上还是下载文件夹中创建这个本地repo来执行<code class="fe lp lq lr ls b">cd Desktop</code>或<code class="fe lp lq lr ls b">cd Downloads</code>，然后执行以下操作:</p><pre class="mw mx my mz gt na ls nb nc aw nd bi"><span id="ff80" class="lt lu it ls b gy ne nf l ng nh">git clone https://github.com/V-Sher/medium_demo.git</span></pre><p id="e12e" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">在这里，我试图克隆我为这篇文章创建的一个(私人)回购，但请随意用您自己的远程URL替换它。您感兴趣的repo的远程URL可以在该项目的Github页面上找到(参见下图中用蓝色突出显示的文本)。</p><figure class="mw mx my mz gt nj gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi ni"><img src="../Images/9a94bf0a9ef15987e8da63a229410395.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zi3t87JdaksOAe2OghW2wQ.png"/></div></div><p class="nq nr gj gh gi ns nt bd b be z dk translated">图1:蓝色突出显示的文本是repo的远程URL。</p></figure><h2 id="93af" class="lt lu it bd lv lw lx dn ly lz ma dp mb la mc md me le mf mg mh li mi mj mk iz bi translated">场景2</h2><blockquote class="mq mr ms"><p id="1a9e" class="kr ks ln kt b ku kv kd kw kx ky kg kz mt lb lc ld mu lf lg lh mv lj lk ll lm im bi translated">创建你自己的分支，开始工作并与同事分享。</p></blockquote><p id="e4b2" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">创建一个分支并开始工作总是比搞乱<code class="fe lp lq lr ls b">main</code>分支好。在这样做之前，最好先检查所有可用的本地分支:</p><pre class="mw mx my mz gt na ls nb nc aw nd bi"><span id="29d8" class="lt lu it ls b gy ne nf l ng nh">git branch</span></pre><figure class="mw mx my mz gt nj gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi nu"><img src="../Images/edeff65f81b29c08148cfe3eab745e0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JhgXurlmbdm6kwqkJvNjhw.png"/></div></div></figure><p id="d78a" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">您当前所在的分支旁边会有一个<code class="fe lp lq lr ls b">*</code>。在我的例子中，我好像在<code class="fe lp lq lr ls b">main</code>上，我想从这个分支创建一个名为<code class="fe lp lq lr ls b">agenda</code>的分支。</p><pre class="mw mx my mz gt na ls nb nc aw nd bi"><span id="dc04" class="lt lu it ls b gy ne nf l ng nh">git checkout -b agenda</span></pre><p id="52a4" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">这里的<code class="fe lp lq lr ls b">agenda</code>是我的分支的名字，但是你可以随意选择你喜欢的名字。运行该命令将使<code class="fe lp lq lr ls b">agenda</code>成为当前工作分支，如果再次运行<code class="fe lp lq lr ls b">git branch</code>命令，您将看到<code class="fe lp lq lr ls b">*</code>已经转移。</p><figure class="mw mx my mz gt nj gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi nv"><img src="../Images/121e35309801c77c705d8e90b27e0a78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FPqHKFRezzSUe9bBJGeZcQ.png"/></div></div></figure><p id="6ce8" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">从这里开始，我将把两个文件添加到本地机器上的<code class="fe lp lq lr ls b">medium_demo</code>文件夹中，分别名为<code class="fe lp lq lr ls b">agenda.py</code>和<code class="fe lp lq lr ls b">fake_agenda.py</code>，然后执行一个<code class="fe lp lq lr ls b">git add .</code>操作，把这两个文件都添加到暂存区，然后使用<code class="fe lp lq lr ls b">git commit -m "Adding a real and fake agenda"</code>提交这些更改。</p><p id="0124" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">现在，我的本地回购副本有两个额外的文件，我必须将它们推送到远程使用:</p><pre class="mw mx my mz gt na ls nb nc aw nd bi"><span id="fa1f" class="lt lu it ls b gy ne nf l ng nh">git push -u origin agenda</span></pre><p id="c570" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">这里的<code class="fe lp lq lr ls b">origin</code>是远程Github的名称(附注，我们将在文章末尾更详细地讨论这个问题),<code class="fe lp lq lr ls b">-u</code>表示在“本地”<code class="fe lp lq lr ls b">agenda</code>分支和“远程”<code class="fe lp lq lr ls b">agenda</code>分支之间建立了跟踪连接。</p><p id="4f2b" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">现在回到您的回购的Github页面，您可以看到已经准备好成为拉取请求(PR)的一部分的更改:</p><figure class="mw mx my mz gt nj gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi nw"><img src="../Images/67ef15c8732d83ef2e8321aa84ef312b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RgwowVbUt0L_x9pNTROtuw.png"/></div></div></figure><p id="50a8" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">您可以点击<em class="ln">比较&amp;拉动式请求</em>按钮来创建一个PR，并将您的同事/上司指定为其审核人。</p><p id="ca0b" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">一旦你的同事审阅了简历，他们可能会在简历上留下自己的评论，如下所示:</p><figure class="mw mx my mz gt nj gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi nx"><img src="../Images/a856e9216324f9f95a65fe99e986c086.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gCqU7BazHFvA_Zv9EN8iKQ.png"/></div></div></figure><p id="c5f4" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">如你所见，审查员告诉我们必须删除不必要的<code class="fe lp lq lr ls b">fake_agenda.py</code>文件。让我们在场景3中看看如何做到这一点。</p><p id="7f04" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><strong class="kt jd">场景3 </strong></p><blockquote class="mq mr ms"><p id="ac76" class="kr ks ln kt b ku kv kd kw kx ky kg kz mt lb lc ld mu lf lg lh mv lj lk ll lm im bi translated">删除您作为拉请求的一部分错误添加的文件。</p></blockquote><p id="f2d1" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">显然，我们不想让经理看到我们为这个项目创建的虚假议程。要解决这个问题，我们需要从PR中删除文件<code class="fe lp lq lr ls b">fake_agenda.py</code>。</p><p id="8a56" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">如果我们这样做:</p><pre class="mw mx my mz gt na ls nb nc aw nd bi"><span id="8111" class="lt lu it ls b gy ne nf l ng nh">git rm fake_agenda.py</span></pre><p id="d7d1" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">您会注意到它会将文件从您的工作目录中完全删除。这不是我们想要的(或者至少不是我想要的)。我们想从PR <strong class="kt jd">中删除它，但</strong>不是从我们的本地回购中。</p><p id="e0f5" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">相反，让我们先把文件带回来:</p><pre class="mw mx my mz gt na ls nb nc aw nd bi"><span id="a3b0" class="lt lu it ls b gy ne nf l ng nh">git reset -- fake_agenda.py<br/>git checkout -- fake_agenda.py</span></pre><p id="db04" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">现在将它作为我们PR的一部分删除，使其成为一个未跟踪的文件:</p><pre class="mw mx my mz gt na ls nb nc aw nd bi"><span id="f830" class="lt lu it ls b gy ne nf l ng nh">git rm --cached fake_agenda.py</span></pre><p id="4f10" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">要提交此更改:</p><pre class="mw mx my mz gt na ls nb nc aw nd bi"><span id="0e3d" class="lt lu it ls b gy ne nf l ng nh">git commit -m "the file fake_agenda is gone from the repository"</span></pre><p id="1cf7" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">最后，像上次一样提交:</p><pre class="mw mx my mz gt na ls nb nc aw nd bi"><span id="c173" class="lt lu it ls b gy ne nf l ng nh">git push -u origin agenda</span></pre><p id="50cd" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">如果您返回到PR的Github页面，您将看到添加了另一个commit，描述如何删除不必要的文件。</p><figure class="mw mx my mz gt nj gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi nx"><img src="../Images/b3d1d1a85437c677855b8bb8d19ec9ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EQ2IIgdzobjeP0oNFUmMXA.png"/></div></div></figure><p id="57ba" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">此外，要确认该文件不再是PR的一部分，请查看“文件已更改”选项卡，它应该显示1(之前是2，因为有额外的<code class="fe lp lq lr ls b">fake_agenda.py</code>文件)。</p><figure class="mw mx my mz gt nj gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi ny"><img src="../Images/d891181cc45d28d907ccdde82c99ae22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U_-rUWyseY80eA4HbEuXdg.png"/></div></div></figure><h2 id="2d81" class="lt lu it bd lv lw lx dn ly lz ma dp mb la mc md me le mf mg mh li mi mj mk iz bi translated">场景4</h2><blockquote class="mq mr ms"><p id="4a79" class="kr ks ln kt b ku kv kd kw kx ky kg kz mt lb lc ld mu lf lg lh mv lj lk ll lm im bi translated">当您在其他分支上工作时，将远程更改放到您的本地机器上。</p></blockquote><p id="1bc6" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">当你忙于自己的分支(从<code class="fe lp lq lr ls b">main</code>分支分出)<em class="ln">本地</em>时，在<em class="ln">远程</em>回购中的<code class="fe lp lq lr ls b">main</code>分支，事情可能会发生变化。随着越来越多的人在一个项目上工作——每个人都在他们自己的分支上——过一段时间，他们的分支将开始与<code class="fe lp lq lr ls b">main</code>分支合并(当然，一旦它通过了所有的检查和评审)。</p><p id="88a1" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">例如，您团队中的高级数据科学家决定更新<code class="fe lp lq lr ls b">main</code>“远程”分支中的自述文件。</p><figure class="mw mx my mz gt nj gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi nx"><img src="../Images/5487045521cb50a6dc5894dc2c4a908a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gGCrC4UtY9YpzGgVj2IaAw.png"/></div></div></figure><p id="fc44" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">但是这些变化不会出现在你的‘local’<code class="fe lp lq lr ls b">main</code>分支中。因此，您应该掌握这些变更，以保持您的本地<code class="fe lp lq lr ls b">main</code>分支是最新的(毕竟，这是您将来创建新分支的地方)。为此，我们首先检出<code class="fe lp lq lr ls b">main</code>分支，然后引入变更。</p><pre class="mw mx my mz gt na ls nb nc aw nd bi"><span id="611a" class="lt lu it ls b gy ne nf l ng nh">git checkout main<br/>git pull</span></pre><p id="e0fb" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">现在，如果您打开自述文件，您将会看到附加行。这意味着你当地的<code class="fe lp lq lr ls b">main</code>分支机构全部被赶上了。</p><p id="26fc" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">然而，如果你回到你在本地工作的分支，即<code class="fe lp lq lr ls b">agenda</code></p><pre class="mw mx my mz gt na ls nb nc aw nd bi"><span id="7758" class="lt lu it ls b gy ne nf l ng nh">git checkout agenda</span></pre><p id="30d7" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">并打开自述文件，它仍将和以前一样，即没有变化。理想情况下，我希望将本地<code class="fe lp lq lr ls b">main</code>中的所有变更合并为我正在处理的分支的一部分，这样我就知道我拥有项目的最新文件。</p><p id="e428" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">更一般地说，要使本地分支<strong class="kt jd"> X </strong>达到本地分支<strong class="kt jd"> Y </strong>的速度，请确保您已经首先检出了<strong class="kt jd"> X </strong>(在我们的示例中，<strong class="kt jd"> X </strong>将是本地<code class="fe lp lq lr ls b">agenda</code>分支，<strong class="kt jd"> Y </strong>将是<code class="fe lp lq lr ls b">main</code>)，然后进行合并:</p><pre class="mw mx my mz gt na ls nb nc aw nd bi"><span id="2abb" class="lt lu it ls b gy ne nf l ng nh">git checkout agenda<br/>git merge main</span></pre><p id="3038" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">您之前在<code class="fe lp lq lr ls b">agenda</code>分支中的所有文件将保持不变(以确认转到并手动检查文件)，并添加了一些由高级数据科学家引入的新内容。</p><p id="33dc" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">有时，合并过程可能不像您希望的那样顺利。<em class="ln">那到底是什么意思？这意味着在合并过程完成之前，可能会有一些问题需要解决——这是由两个人在完全相同的行上更改相同的文件引起的。让我们看看如何在下一个场景中修复它们。</em></p><h2 id="d8a1" class="lt lu it bd lv lw lx dn ly lz ma dp mb la mc md me le mf mg mh li mi mj mk iz bi translated">场景5</h2><blockquote class="mq mr ms"><p id="28fc" class="kr ks ln kt b ku kv kd kw kx ky kg kz mt lb lc ld mu lf lg lh mv lj lk ll lm im bi translated">如何解决合并冲突？</p></blockquote><p id="366b" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">从场景4继续，让我们假设您和高级数据科学家都在完全相同的行上更改了同一个文件。在这种情况下，从最后一个场景合并将会提示如下错误:</p><figure class="mw mx my mz gt nj gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi nz"><img src="../Images/293e212c7afe05470e36786afb74012c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zXTHImR7ZFw-LfUS3HdY2Q.png"/></div></div></figure><p id="5790" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">这条消息不言自明，告诉我们它不能合并README.md，因为我和我的学长都试图修改完全相同的行。因此，我必须在合并之前解决这个错误。为此，在编辑器中打开文件(我个人偏好VScode)，你会看到需要在<code class="fe lp lq lr ls b">&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>和<code class="fe lp lq lr ls b">&gt;&gt;&gt;&gt;&gt;&gt;</code>之间解决的问题。</p><figure class="mw mx my mz gt nj gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi oa"><img src="../Images/482d6b3265aebd14dfa18bfe89bd0424.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NQj_J_i5mZKiFXfaRyrJUg.png"/></div></div></figure><p id="2baf" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">似乎我们都在试图修改最后一行(我想说苹果，她想说橙色)。此时，您可以接受即将到来的更改，或者坚持当前的更改，或者做其他事情。一旦您对更改感到满意，保存并关闭文件。回到终端，添加并提交此更改，最后推送它:</p><pre class="mw mx my mz gt na ls nb nc aw nd bi"><span id="d0f4" class="lt lu it ls b gy ne nf l ng nh">git add README.md<br/>git commit -m "Apples and oranges issue averted"<br/>git push</span></pre><p id="ee5d" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">回到PR的Github页面，您可以看到新的提交已经作为PR的一部分被添加。</p><figure class="mw mx my mz gt nj gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi nx"><img src="../Images/8ef7a1737f6c69c0c82de36e6728779f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cNrG3M1p5aB4W6g8YXVFgQ.png"/></div></div></figure><p id="0d59" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">一旦你的评审者对所有的改变感到满意，她会将remote上的<code class="fe lp lq lr ls b">agenda</code>分支与remote上的<code class="fe lp lq lr ls b">main</code>分支合并，你可以在Github页面上看到。</p><figure class="mw mx my mz gt nj gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi nx"><img src="../Images/7a970e004fcdc18bf7e308fdff8a5e75.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Cc2n-GninIRXwbTJOi4k1A.png"/></div></div></figure><p id="f4a0" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">一旦合并，您不再需要<code class="fe lp lq lr ls b">agenda</code>分支——您甚至可以删除它。从现在开始，我强烈建议任何时候你想在项目的其他方面工作，在确保你已经将远程<code class="fe lp lq lr ls b">main</code>分支的最新版本拉到你的本地<code class="fe lp lq lr ls b">main</code>分支之后，你应该从本地<code class="fe lp lq lr ls b">main</code>分支创建一个新的分支。</p><h2 id="4215" class="lt lu it bd lv lw lx dn ly lz ma dp mb la mc md me le mf mg mh li mi mj mk iz bi translated">场景6</h2><blockquote class="mq mr ms"><p id="84dc" class="kr ks ln kt b ku kv kd kw kx ky kg kz mt lb lc ld mu lf lg lh mv lj lk ll lm im bi translated">把一个被你搞砸的同事的文件带回来，恢复原状。</p></blockquote><p id="a537" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">有时，在您的分支机构工作时，您可能会弄乱您或您的同事创建的现有文件。例如，假设我错误地修改了<code class="fe lp lq lr ls b">agenda.py</code>文件中的打印语句</p><p id="8053" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">从这个</p><pre class="mw mx my mz gt na ls nb nc aw nd bi"><span id="97a9" class="lt lu it ls b gy ne nf l ng nh">print(“The agenda for this demo is as follows: Do A then B and finally C.”)</span></pre><p id="9499" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">对此</p><pre class="mw mx my mz gt na ls nb nc aw nd bi"><span id="f7fe" class="lt lu it ls b gy ne nf l ng nh">print(“The agenda for this demo is as follows: Do A and finally C.”)</span></pre><p id="0fca" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">还使用提交了这些更改</p><pre class="mw mx my mz gt na ls nb nc aw nd bi"><span id="04aa" class="lt lu it ls b gy ne nf l ng nh">git add agenda.py<br/>git commit -m "Messing up the file by removing B's info"</span></pre><p id="e5e2" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">要将其恢复到原始形式(即，它在上次提交时的样子)，只需执行<code class="fe lp lq lr ls b">git checkout &lt;commit_id&gt; — filename</code>。在这里，如果您在Github Web UI上找到相关文件并选择其最新的提交号，就可以快速检索到<code class="fe lp lq lr ls b">commit_id</code>。</p><figure class="mw mx my mz gt nj gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi ob"><img src="../Images/f9dd157a3138d1de74ac21f726a1dab4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f2gW6NwcVXISBvquBgZMjA.png"/></div></div><p class="nq nr gj gh gi ns nt bd b be z dk translated">为Github上的文件选择最新的提交id(在“最新提交”之后的右边)</p></figure><p id="82a1" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">在我们的例子中，<code class="fe lp lq lr ls b">agenda.py</code>文件的提交id是<code class="fe lp lq lr ls b">3c8ebf0</code>。因此，要使它看起来就像上一次提交一样，只需</p><pre class="mw mx my mz gt na ls nb nc aw nd bi"><span id="c271" class="lt lu it ls b gy ne nf l ng nh">git checkout 3c8ebf0 -- agenda.py</span></pre><p id="3b3d" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">其次是:</p><pre class="mw mx my mz gt na ls nb nc aw nd bi"><span id="04ec" class="lt lu it ls b gy ne nf l ng nh">git add agenda.py<br/>git commit -m "Restoring B's info in the agenda"</span></pre><h2 id="8688" class="lt lu it bd lv lw lx dn ly lz ma dp mb la mc md me le mf mg mh li mi mj mk iz bi translated">场景7</h2><blockquote class="mq mr ms"><p id="85e2" class="kr ks ln kt b ku kv kd kw kx ky kg kz mt lb lc ld mu lf lg lh mv lj lk ll lm im bi translated">一位同事邀请您在她现有的远程分支机构工作。</p></blockquote><p id="c132" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">通常，你的一个已经在做某个分支的同事，比如说<code class="fe lp lq lr ls b">featureB</code>，会邀请你去做这个分支。现在让我们假设这个分支除了Readme文件之外，还包含一个文件<code class="fe lp lq lr ls b">featureB.py</code>。</p><p id="ab49" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">要开始协作，您需要创建一个<em class="ln">本地</em> <code class="fe lp lq lr ls b">featureB</code>分支，并在远程和本地<code class="fe lp lq lr ls b">featureB </code>分支之间建立某种跟踪连接，以便您可以推送提交并对它们进行更改。</p><p id="5dc3" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">首先，确保同事的分支存在于远程服务器上——这意味着你的同事已经将她的分支推送到origin上——并且你可以访问它。要检查您有权访问的所有远程分支，请执行<code class="fe lp lq lr ls b">git fetch</code>，然后执行:</p><pre class="mw mx my mz gt na ls nb nc aw nd bi"><span id="e69e" class="lt lu it ls b gy ne nf l ng nh">git branch -r</span></pre><figure class="mw mx my mz gt nj gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi oc"><img src="../Images/6bc852458150ee6eee3b04f298dd807f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hQybTYlkv5H-dn8aB2BdVg.png"/></div></div></figure><p id="60c1" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">看到我的同事希望我插话的分支，即<code class="fe lp lq lr ls b">origin/featureB</code>，我们将简单地做:</p><pre class="mw mx my mz gt na ls nb nc aw nd bi"><span id="35b1" class="lt lu it ls b gy ne nf l ng nh">git checkout --track origin/featureB</span></pre><p id="d70c" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">这将创建一个名为<code class="fe lp lq lr ls b">featureB</code>的本地分支，您现在应该看到由文件<code class="fe lp lq lr ls b">featureB.py</code>组成的本地回购。接下来，我将继续对该文件进行一些简单的更改(基本上添加我作为初级数据科学家的想法)，并使用<code class="fe lp lq lr ls b">git push origin featureB</code>将其推送到<em class="ln">远程</em>分支。这是添加我的更改后文件在remote上的样子:</p><figure class="mw mx my mz gt nj gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi nx"><img src="../Images/8bc053f2344775adfd761ee16ed37c8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kod-OjX2i6zQ586aDauotg.png"/></div></div></figure><p id="047d" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">因为你们可以同时处理文件并对其进行修改，所以我强烈建议每次在开始处理<code class="fe lp lq lr ls b">featureB</code>分支之前先做<code class="fe lp lq lr ls b">git fetch</code>再做<code class="fe lp lq lr ls b">git pull</code>。一如既往，您可能需要解决一些冲突，一旦解决完毕:</p><pre class="mw mx my mz gt na ls nb nc aw nd bi"><span id="0393" class="lt lu it ls b gy ne nf l ng nh">git add featureB.py<br/>git commit -m "Resolved conflict"<br/>git push origin featureB </span></pre><p id="4415" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">或者，如果您不希望在您同事的分支<code class="fe lp lq lr ls b">featureB</code>的本地和远程副本之间建立跟踪连接，而是希望将其与您当前工作的分支(即<code class="fe lp lq lr ls b">&lt;branch-name&gt;</code>)合并:</p><pre class="mw mx my mz gt na ls nb nc aw nd bi"><span id="b847" class="lt lu it ls b gy ne nf l ng nh">git checkout &lt;branch-name&gt;<br/>git merge origin/featureB</span></pre><h2 id="b42b" class="lt lu it bd lv lw lx dn ly lz ma dp mb la mc md me le mf mg mh li mi mj mk iz bi translated">场景8</h2><blockquote class="mq mr ms"><p id="db7b" class="kr ks ln kt b ku kv kd kw kx ky kg kz mt lb lc ld mu lf lg lh mv lj lk ll lm im bi translated">如何将采购申请提取到本地回购进行审查？</p></blockquote><p id="8a3e" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">有些情况下，你会被指派为公关的“审查者”，这意味着你的工作是通过分析同事的分支来确保一切正常。作为审查过程的一部分，人们可以简单地在Github Web UI上浏览代码，但我通常更喜欢制作PR的本地只读副本，并在我的终端运行它。</p><p id="7eea" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><em class="ln">附注:只读副本意味着您不能将变更推送到该PR，这是理想的，因为我们不应该将变更推送到由其他人创建的PR，只有PR的</em> <strong class="kt jd"> <em class="ln">作者</em> </strong> <em class="ln">应该进行变更。</em></p><p id="a06d" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">为此，先使用<code class="fe lp lq lr ls b">git fetch origin pull/PULL_REQUEST_ID/head:NEW-BRANCH-NAME</code>，再使用<code class="fe lp lq lr ls b">git checkout BRANCH_NAME</code>。</p><p id="2f6c" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">附言:您在上面的命令中看到的所有内容都是您需要提供的:</p><ul class=""><li id="9e41" class="od oe it kt b ku kv kx ky la of le og li oh lm oi oj ok ol bi translated">PULL_REQUEST_ID可以从PR的Github页面检索。它通常是#符号后面的一个数字。对我们来说，是4。</li></ul><figure class="mw mx my mz gt nj gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi nx"><img src="../Images/8258cc1e9d5cb0c112e20b9523c3b2de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*igXkGlrL3qNWGSkwkOd0KA.png"/></div></div><p class="nq nr gj gh gi ns nt bd b be z dk translated">图Github Web UI上的PR页面。它包含有关拉取请求id的信息，以及创建PR的分支。</p></figure><ul class=""><li id="6c6c" class="od oe it kt b ku kv kx ky la of le og li oh lm oi oj ok ol bi translated">NEW-BRANCH_NAME可以是您想称为PR的只读副本的任何名称。我喜欢叫我的<code class="fe lp lq lr ls b">review_***</code>。</li></ul><p id="88bb" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">一旦你的猫咪里有了这两样东西，就去做吧:</p><pre class="mw mx my mz gt na ls nb nc aw nd bi"><span id="398f" class="lt lu it ls b gy ne nf l ng nh">git fetch origin pull/4/head:review_featureb1<br/>git checkout review_featureb1</span></pre><p id="2558" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">在<code class="fe lp lq lr ls b">review_featureb1</code>分支上，你想怎么复习就怎么复习。一旦你完成了，你可以通过在PR的Github页面上留下评论来告诉作者需要做什么改变，或者你可以自己做这些改变，并使用<code class="fe lp lq lr ls b">git push -u origin patch-test_featureb1</code>将它们推送到一个新创建的分支。</p><p id="ec2e" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">尽管我提到除了PR作者之外，任何人都不应该对PR进行更改，但有时您会希望直接对某人的PR进行一些更改——例如，一个非常小的打字错误需要修复——并将这些更改作为PR的一部分。</p><p id="c452" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">在这种情况下，您需要首先获得创建PR的分支的名称(让我们称之为<code class="fe lp lq lr ls b">&lt;PR-branch-name&gt;</code>)。它通常会出现在Github Web UI的PR页面上，内容如下:<code class="fe lp lq lr ls b">&lt;repo-author&gt; wants to merge X commits into main from &lt;PR-branch_name&gt;</code>(参见上面的图2)。</p><p id="7b7d" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">在我们的例子中，公关似乎是从<code class="fe lp lq lr ls b">featureb1</code>创建的。让我们使用以下方法之一来检查这个分支:</p><p id="2153" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">(a) <code class="fe lp lq lr ls b">git checkout featureb1</code>(如果你在本地跟踪<code class="fe lp lq lr ls b">featureb1</code></p><p id="b60f" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">运筹学</p><p id="9e78" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">(b)情景7中描述的步骤(如果您没有在本地跟踪该分支机构)。</p><p id="a66c" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">之后，您进行所需的更改，最后使用<code class="fe lp lq lr ls b">git push origin featureb1</code>推送到遥控器上同名的分支，使其成为PR的一部分。</p><p id="4316" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><em class="ln">注意:在解释了两种评审方法之后，我强烈建议创建一个新的分支(而不是修改现有的PR ),因为它给了某人一个评审你的工作(在合并之前)的机会，这样你就不会在不知不觉中弄乱某人的PR。</em></p><h2 id="63b8" class="lt lu it bd lv lw lx dn ly lz ma dp mb la mc md me le mf mg mh li mi mj mk iz bi translated">场景9</h2><blockquote class="mq mr ms"><p id="c925" class="kr ks ln kt b ku kv kd kw kx ky kg kz mt lb lc ld mu lf lg lh mv lj lk ll lm im bi translated">如何将我的本地更改推送到远程回购？</p></blockquote><p id="2b5f" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">简而言之，这取决于你的场景。</p><p id="2bdd" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">如果您处于类似场景2的情况，即在本地创建的分支上工作，(这意味着它在远程还不存在)，您可以</p><pre class="mw mx my mz gt na ls nb nc aw nd bi"><span id="30be" class="lt lu it ls b gy ne nf l ng nh">git push -u origin &lt;my_branch_name&gt;</span></pre><p id="b262" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">它会自动在遥控器上创建同名的分支，其中的<code class="fe lp lq lr ls b">&lt;my_branch_name&gt;</code>会被您在本地创建的分支的名称所替换。</p><p id="ac5c" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">或者，如果您在场景7中，即在本地工作于远程跟踪的分支机构，则您可以:</p><pre class="mw mx my mz gt na ls nb nc aw nd bi"><span id="4810" class="lt lu it ls b gy ne nf l ng nh">git push origin &lt;remote_branch_name&gt;</span></pre><p id="d942" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">其中<code class="fe lp lq lr ls b">&lt;remote_branch_name&gt;</code>应该替换为远程repo上存在的分支名称，并且在运行命令<code class="fe lp lq lr ls b">git branch -r</code>时可见。</p><h2 id="4799" class="lt lu it bd lv lw lx dn ly lz ma dp mb la mc md me le mf mg mh li mi mj mk iz bi translated">场景10</h2><blockquote class="mq mr ms"><p id="edc4" class="kr ks ln kt b ku kv kd kw kx ky kg kz mt lb lc ld mu lf lg lh mv lj lk ll lm im bi translated">如何在Github上推送空目录？</p></blockquote><p id="dd05" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">要了解Git如何处理空目录，让我们做一个快速设置。</p><p id="27f8" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">使用<code class="fe lp lq lr ls b">git checkout</code>签出任何分支，并尝试在本地repo中创建一个空文件夹<code class="fe lp lq lr ls b">e_folder</code>。</p><figure class="mw mx my mz gt nj gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi om"><img src="../Images/99978abbe298e55ae62331e95b9d172a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Wc9RnbYg6tS1Ud2MsYrzrA.png"/></div></div></figure><p id="259f" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">接下来，在终端中尝试:</p><pre class="mw mx my mz gt na ls nb nc aw nd bi"><span id="b596" class="lt lu it ls b gy ne nf l ng nh">git status</span></pre><p id="caaa" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">在理想的情况下，git应该会提示您将这个新创建的文件夹添加到staging area，但是没有发生类似的事情。现在继续向<code class="fe lp lq lr ls b">e_folder</code>添加任何文件，使其不再为空:</p><figure class="mw mx my mz gt nj gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi om"><img src="../Images/68efbbd71e47b05c5cf5044e0681c544.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RMM5xv5-TKfKVUJZmjQ2Ow.png"/></div></div></figure><p id="e5ef" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">如果您现在要做一个<code class="fe lp lq lr ls b">git status</code>，您会看到一个提示，告诉您使用<code class="fe lp lq lr ls b">git add</code>命令添加文件夹</p><figure class="mw mx my mz gt nj gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi on"><img src="../Images/59c7091547b50c652a1d300c40ae3863.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EZWA6OxmSO8kJdMeGYgEgw.png"/></div></div></figure><p id="0752" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">简而言之，默认情况下，Git只会跟踪非空目录——这在大多数情况下对我们来说不成问题。然而，有时我们会希望推送一个空目录。例如，我喜欢有一个空的目录作为占位符，告诉人们在使用我的模型时可以上传他们的自定义图像。</p><p id="61f5" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">为了明确地通知Git跟踪我们的空目录<code class="fe lp lq lr ls b">e_folder</code>，首先，让我们继续手动删除其中的<code class="fe lp lq lr ls b">img.jpeg</code>文件。然后转到Git命令行:</p><pre class="mw mx my mz gt na ls nb nc aw nd bi"><span id="931d" class="lt lu it ls b gy ne nf l ng nh">cd e_folder<br/>touch .gitignore<br/>vi .gitignore</span></pre><p id="acbf" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">一旦进入可视化编辑器，</p><ul class=""><li id="a8e1" class="od oe it kt b ku kv kx ky la of le og li oh lm oi oj ok ol bi translated">按下键盘上的<code class="fe lp lq lr ls b">i</code></li><li id="b5d4" class="od oe it kt b ku oo kx op la oq le or li os lm oi oj ok ol bi translated">将下面几行粘贴(或Ctrl+V)在那里[Credits:<a class="ae lo" href="https://stackoverflow.com/questions/115983/how-can-i-add-an-empty-directory-to-a-git-repository" rel="noopener ugc nofollow" target="_blank">stack overflow</a></li></ul><pre class="mw mx my mz gt na ls nb nc aw nd bi"><span id="b893" class="lt lu it ls b gy ne nf l ng nh"># Ignore everything in this directory<br/>*<br/># Except this file<br/>!.gitignore</span></pre><ul class=""><li id="efef" class="od oe it kt b ku kv kx ky la of le og li oh lm oi oj ok ol bi translated">按下键盘上的<code class="fe lp lq lr ls b">esc</code></li><li id="e6df" class="od oe it kt b ku oo kx op la oq le or li os lm oi oj ok ol bi translated">类型<code class="fe lp lq lr ls b">:wq</code></li></ul><p id="b2b1" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">在git终端上，使用<code class="fe lp lq lr ls b">cd ..</code>返回到<code class="fe lp lq lr ls b">medium_repo</code>目录，然后</p><pre class="mw mx my mz gt na ls nb nc aw nd bi"><span id="3cf2" class="lt lu it ls b gy ne nf l ng nh">git status</span></pre><p id="171b" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">您将看到现在git已经准备好将您的空文件夹添加到临时区域</p><figure class="mw mx my mz gt nj gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi ot"><img src="../Images/d3e1db5ecf31d9d625fb25bafaf21d6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nP6ZqITqtbTzuTbpr5bKAw.png"/></div></div></figure><p id="76f5" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">继续添加它，提交它并推动它:</p><pre class="mw mx my mz gt na ls nb nc aw nd bi"><span id="418f" class="lt lu it ls b gy ne nf l ng nh">git add e_folder<br/>git commit -m "placeholder for images"<br/>git push</span></pre></div><div class="ab cl ou ov hx ow" role="separator"><span class="ox bw bk oy oz pa"/><span class="ox bw bk oy oz pa"/><span class="ox bw bk oy oz"/></div><div class="im in io ip iq"><h2 id="7a5a" class="lt lu it bd lv lw lx dn ly lz ma dp mb la mc md me le mf mg mh li mi mj mk iz bi translated">奖金方案1</h2><blockquote class="mq mr ms"><p id="8b63" class="kr ks ln kt b ku kv kd kw kx ky kg kz mt lb lc ld mu lf lg lh mv lj lk ll lm im bi translated">我检查了一个分支X，在那里做了一些更改，使用File -&gt; Save保存了这些更改。然后我继续检查另一个分支Y，我可以看到与我在x中所做的相同的更改。为什么在一个分支中进行更改，git会更改所有其他分支？</p></blockquote><p id="aa38" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">查看<a class="ae lo" href="https://stackoverflow.com/questions/59415116/why-if-i-make-changes-in-one-of-my-branches-git-changes-every-branch" rel="noopener ugc nofollow" target="_blank"> Stackoverflow </a>上的长答案。</p><p id="3e3e" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">简而言之，如果您没有使用<code class="fe lp lq lr ls b">git commit</code>提交您在一个分支中所做的变更，那么当您切换分支时，变更也会随之而来。这意味着当您签出其他分支时，您有无意中破坏它们的风险。所以尽可能多的提交，尽可能多的提交，尤其是在对代码做一些重大修改的时候！</p><h2 id="4a40" class="lt lu it bd lv lw lx dn ly lz ma dp mb la mc md me le mf mg mh li mi mj mk iz bi translated">奖金方案2</h2><blockquote class="mq mr ms"><p id="548f" class="kr ks ln kt b ku kv kd kw kx ky kg kz mt lb lc ld mu lf lg lh mv lj lk ll lm im bi translated">在推送到远程之前，如何检查我提交(即更改)了哪些文件？</p></blockquote><p id="d439" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">通常，我们会在几周甚至几个月的时间里在几个文件中提交大量的变更，而不需要将它们推送到远程。因此，当最终<em class="ln">推送</em>变更(以便您的同事可以查看您的工作)的时候，我们不确定我们将要推送什么文件！</p><p id="ae69" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">要获得自上次推送以来修改过的文件名列表(并避免任何不必要的意外)，这个命令很有用:</p><pre class="mw mx my mz gt na ls nb nc aw nd bi"><span id="2ff7" class="lt lu it ls b gy ne nf l ng nh">git diff --name-only &lt;local_branch_name&gt; origin/&lt;remote_branch&gt;</span></pre><p id="7d81" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">将<code class="fe lp lq lr ls b">&lt;local_branch_name&gt;</code>替换为您正在处理的本地分支的名称，将<code class="fe lp lq lr ls b">&lt;remote_branch&gt;</code>替换为远程服务器上的分支的名称，您希望将您的更改推进到该分支中。<code class="fe lp lq lr ls b">--name-only</code>标签将确保只列举文件名，并保留每个文件中更改的细节(例如，添加或删除了哪些特定的行)。</p><h2 id="5836" class="lt lu it bd lv lw lx dn ly lz ma dp mb la mc md me le mf mg mh li mi mj mk iz bi translated">奖金方案3</h2><blockquote class="mq mr ms"><p id="9a1a" class="kr ks ln kt b ku kv kd kw kx ky kg kz mt lb lc ld mu lf lg lh mv lj lk ll lm im bi translated">我的同事正在进行Git回购，我想推送/拉取/查看他们回购中的一些文件。</p></blockquote><p id="2a74" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">还记得我说的关于<em class="ln">的来历</em>吗？这是我们的远程Github repo的名称。要检查您可以访问哪些远程Github repos:</p><pre class="mw mx my mz gt na ls nb nc aw nd bi"><span id="f5b5" class="lt lu it ls b gy ne nf l ng nh">git remote -v</span></pre><figure class="mw mx my mz gt nj gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi pb"><img src="../Images/fc44ec8b7354337b466f219d78dc1eec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D8N1fTw7ruBO3wWSDwVAbw.png"/></div></div></figure><p id="0bd8" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">到目前为止，我们主要在一个名为<code class="fe lp lq lr ls b">origin</code>的repo上工作，但假设我也想在GitHub上托管的其他一些远程存储库上工作。<em class="ln">添加我的同事</em> <code class="fe lp lq lr ls b"><em class="ln">ABC</em></code> <em class="ln">为他的一篇媒体文章创建的Github repo怎么样？我确信我能帮她复习一些内容。它的远程URL是<code class="fe lp lq lr ls b"><a class="ae lo" href="https://github.com/V-Sher/GANs_Pytorch.git." rel="noopener ugc nofollow" target="_blank">https://github.com/ABC/coworker_medium_repo.git</a></code>。</em></p><p id="1c18" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">首先要做的是添加这个远程存储库，即建立某种连接，并为它设置一个名称。我也不能命名我同事的repo <code class="fe lp lq lr ls b">origin</code>,因为它可能会混淆Git并导致致命错误。因此，最好使用与回购相对应的名称——我倾向于将它们命名为<code class="fe lp lq lr ls b">origin_***</code>。</p><pre class="mw mx my mz gt na ls nb nc aw nd bi"><span id="a910" class="lt lu it ls b gy ne nf l ng nh">git remote add origin_medium <a class="ae lo" href="https://github.com/V-Sher/GANs_Pytorch.git." rel="noopener ugc nofollow" target="_blank">https://github.com/ABC/coworker_medium_repo.git</a></span></pre><p id="03db" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">现在，如果您在终端中执行<code class="fe lp lq lr ls b">git remote -v</code>命令，您将看到您可以访问的所有遥控器:</p><figure class="mw mx my mz gt nj gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi pc"><img src="../Images/5de4bacd4b608474611dc0eb3b232639.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Nh94gPEoTU5lX9WBVR8w3Q.png"/></div></div></figure><p id="b640" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">同样，你可以继续使用同事的回购URL创建对他们回购的引用。</p><p id="021a" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><em class="ln">注意:如果您需要复习如何定位回购URL，请看图1。</em></p><pre class="mw mx my mz gt na ls nb nc aw nd bi"><span id="1aaa" class="lt lu it ls b gy ne nf l ng nh">git remote add project1_origin http:github.com/XYZ/project1.git</span><span id="f49c" class="lt lu it ls b gy pd nf l ng nh">git remote add project2_origin http:github.com/MNO/project2.git</span><span id="9792" class="lt lu it ls b gy pd nf l ng nh">git remote add project3_origin http:github.com/PQR/project3.git</span></pre><p id="43a4" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">现在，假设你的同事在Github上为项目2制作了一份PR，你必须审阅它。场景8中已经讨论了这样做的步骤(确保您有适当的PULL_REQUEST_ID)。这次您需要做的唯一更改是指向正确的来源，即正确的回购名称:</p><pre class="mw mx my mz gt na ls nb nc aw nd bi"><span id="2edb" class="lt lu it ls b gy ne nf l ng nh">git fetch <strong class="ls jd">origin_medium</strong> pull/PULL_REQUEST_ID/head:REVIEW_FEATURENAME<br/>git checkout REVIEW_FEATURENAME</span></pre><p id="52cf" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">您甚至可以获取它们的一个分支，并使用以下命令在本地跟踪它们:</p><pre class="mw mx my mz gt na ls nb nc aw nd bi"><span id="0789" class="lt lu it ls b gy ne nf l ng nh">git fetch <strong class="ls jd">origin_medium</strong> new_agenda<br/>git checkout new_agenda</span></pre><p id="644d" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">其中<code class="fe lp lq lr ls b">new_agenda</code>是我同事的回购协议中的一个远程分支。接下来，进行一些更改——添加、提交和推送。你现在知道规矩了:</p><pre class="mw mx my mz gt na ls nb nc aw nd bi"><span id="41ee" class="lt lu it ls b gy ne nf l ng nh">git commit -a -m "Some input from V-Sher's end as well"<br/>git push</span></pre><figure class="mw mx my mz gt nj gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi pe"><img src="../Images/bc1cde9305d00be3e42d9617be7e750b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yXmYl0AtDogZ9BCzyOmTPw.png"/></div></div></figure><p id="f0b1" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><em class="ln">注意:请记住，在我们的示例中，存在一个由来自</em> <code class="fe lp lq lr ls b"><em class="ln">new_agenda</em></code> <em class="ln">分支的同事创建的PR，我们刚刚推送到该分支的任何更改也将是PR的一部分(见下图)。如果这不是故意的，请制作PR的本地副本，创建一个新分支，并将其推送到同事的repo。</em></p><figure class="mw mx my mz gt nj gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi nx"><img src="../Images/45fcf8eaed52f840f03fd0ebfa6826ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ifV8KznO6ixEsQUVBwX_QQ.png"/></div></div></figure><p id="c079" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">您甚至可以将同事的一个远程分支机构拉入您自己的本地分支机构。也就是说，我将检查<strong class="kt jd">我的</strong>本地分支<code class="fe lp lq lr ls b">agenda</code>，并尝试将我的<strong class="kt jd">同事的</strong>T2分支拉入其中:</p><p id="c6a0" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><em class="ln">注意:坦白地说，我不知道我什么时候会用到它，因为这两个项目的提交历史是不相关的。如果你有想法，让我知道！</em></p><pre class="mw mx my mz gt na ls nb nc aw nd bi"><span id="af48" class="lt lu it ls b gy ne nf l ng nh">git checkout agenda<br/>git pull <strong class="ls jd">origin_medium</strong> second_agenda --allow-unrelated-histories</span></pre><figure class="mw mx my mz gt nj gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi pf"><img src="../Images/ac00c3b41d56b42e1c075114b537fa92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tKxc2JgDPpwU_F3aAUMNlw.png"/></div></div></figure><p id="0051" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">使用场景5中的步骤可以解决一些冲突，但没有什么是我们不能解决的。</p><h2 id="6d15" class="lt lu it bd lv lw lx dn ly lz ma dp mb la mc md me le mf mg mh li mi mj mk iz bi translated">至理名言</h2><ul class=""><li id="4e63" class="od oe it kt b ku ml kx mm la pg le ph li pi lm oi oj ok ol bi translated">你永远做不够<code class="fe lp lq lr ls b">git fetch</code>和<code class="fe lp lq lr ls b">git status</code>——前者通知你远程回购的新进展，后者提醒你本地回购中未提交的文件。</li><li id="72d4" class="od oe it kt b ku oo kx op la oq le or li os lm oi oj ok ol bi translated">一旦你对你的代码做了一些重要的改变，就养成<code class="fe lp lq lr ls b">git commit</code>的习惯。(<em class="ln">不，文件- &gt;保存不充分</em>)</li><li id="0343" class="od oe it kt b ku oo kx op la oq le or li os lm oi oj ok ol bi translated">如果远程跟踪被启用*, <code class="fe lp lq lr ls b">git push</code>(和<code class="fe lp lq lr ls b">git pull</code>)将从当前检出的<strong class="kt jd">分支向远程上的相应分支推送(和拉取)变更。如果未启用，将会引发一个错误，您必须通过显式声明repo名称和您希望拉入/推送的分支名称来修复该错误。<br/>注意:我比大多数人更偏执，所以你会发现我总是明确地说出回购协议名称和分行名称。例如<code class="fe lp lq lr ls b">git push origin_name branch_name</code>。<br/> *:要检查分支机构是否启用远程跟踪，请尝试<code class="fe lp lq lr ls b">git remote show origin</code>。这将显示每个本地分支及其链接的远程分支。</strong></li></ul></div><div class="ab cl ou ov hx ow" role="separator"><span class="ox bw bk oy oz pa"/><span class="ox bw bk oy oz pa"/><span class="ox bw bk oy oz"/></div><div class="im in io ip iq"><h2 id="1c94" class="lt lu it bd lv lw lx dn ly lz ma dp mb la mc md me le mf mg mh li mi mj mk iz bi translated">恭喜你走到这一步…</h2><p id="16d6" class="pw-post-body-paragraph kr ks it kt b ku ml kd kw kx mm kg kz la mn lc ld le mo lg lh li mp lk ll lm im bi translated">我真的相信您能够在日常生活中使用这些Git命令。对于那些想要学习更复杂的命令的人(为了有一天可能在你的工作场所出现的场景)，我会说建立两个虚拟的Github帐户——你需要扮演两个合作者的角色——并开始练习你的疯狂的一生一次的场景。</p><p id="faa8" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">一如既往，如果有更简单的方法来做我在本文中提到的一些事情，请让我知道。</p><p id="e589" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">直到下次:)</p><div class="pj pk gp gr pl pm"><a rel="noopener follow" target="_blank" href="/step-by-step-guide-to-explaining-your-ml-project-during-a-data-science-interview-81dfaaa408bf"><div class="pn ab fo"><div class="po ab pp cl cj pq"><h2 class="bd jd gy z fp pr fr fs ps fu fw jc bi translated">在数据科学面试中解释你的ML项目的逐步指南。</h2><div class="pt l"><h3 class="bd b gy z fp pr fr fs ps fu fw dk translated">在结尾有一个额外的样本脚本，让你谨慎地展示你的技术技能！</h3></div><div class="pu l"><p class="bd b dl z fp pr fr fs ps fu fw dk translated">towardsdatascience.com</p></div></div><div class="pv l"><div class="pw l px py pz pv qa no pm"/></div></div></a></div><div class="pj pk gp gr pl pm"><a href="https://medium.com/swlh/how-i-would-explain-gans-from-scratch-to-a-5-year-old-part-1-ce6a6bccebbb" rel="noopener follow" target="_blank"><div class="pn ab fo"><div class="po ab pp cl cj pq"><h2 class="bd jd gy z fp pr fr fs ps fu fw jc bi translated">我将如何从零开始向一个5岁的孩子解释甘斯:第1部分</h2><div class="pt l"><h3 class="bd b gy z fp pr fr fs ps fu fw dk translated">GANs背后的基本直觉、目标函数、生成器和鉴别器架构以及深入的伪代码…</h3></div><div class="pu l"><p class="bd b dl z fp pr fr fs ps fu fw dk translated">medium.com</p></div></div><div class="pv l"><div class="qb l px py pz pv qa no pm"/></div></div></a></div><div class="pj pk gp gr pl pm"><a rel="noopener follow" target="_blank" href="/recreating-keras-code-in-pytorch-an-introductory-tutorial-8db11084c60c"><div class="pn ab fo"><div class="po ab pp cl cj pq"><h2 class="bd jd gy z fp pr fr fs ps fu fw jc bi translated">在PyTorch中重新创建Keras代码——入门教程</h2><div class="pt l"><h3 class="bd b gy z fp pr fr fs ps fu fw dk translated">学习在PyTorch中创建神经网络的基础知识。</h3></div><div class="pu l"><p class="bd b dl z fp pr fr fs ps fu fw dk translated">towardsdatascience.com</p></div></div><div class="pv l"><div class="qc l px py pz pv qa no pm"/></div></div></a></div></div></div>    
</body>
</html>