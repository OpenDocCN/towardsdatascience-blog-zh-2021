<html>
<head>
<title>Using Docker for Deep Learning projects</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将Docker用于深度学习项目</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/using-docker-for-deep-learning-projects-fa51d2c4f64c?source=collection_archive---------2-----------------------#2021-09-17">https://towardsdatascience.com/using-docker-for-deep-learning-projects-fa51d2c4f64c?source=collection_archive---------2-----------------------#2021-09-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="91fd" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">作为一名机器学习工程师，我每天都使用docker容器，这帮助我节省了大量时间，并保持有序。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/500465baa4940bc5b62e045ea23576ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ZhTVVoBS76GVktES"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">保罗·泰森在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="92bc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这篇文章中，我将解释如何在我的日常项目中使用Docker。关于这个主题有很多很好的文档和视频，但我想分享一种我在从事的几个行业项目中一直使用的方法。</p><blockquote class="ls lt lu"><p id="eb27" class="kw kx lv ky b kz la jr lb lc ld ju le lw lg lh li lx lk ll lm ly lo lp lq lr ij bi translated">Docker是什么？</p></blockquote><p id="96d3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Docker使用操作系统级虚拟化来交付称为容器的软件包中的软件。每个<strong class="ky ir">停靠容器</strong>都是从<strong class="ky ir">停靠图像</strong>中创建的。一个映像拥有构建<strong class="ky ir">环境</strong>的所有信息(库、文件夹、文件、操作系统等)。容器是相互隔离的。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi lz"><img src="../Images/f64e8210db0a4021c48ed67be951f5e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wb9I7NMZ6BtmT_7tebJMlg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Docker流-按作者分类的图像</p></figure><p id="c613" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">官方Docker文档可以在此<a class="ae kv" href="https://docs.docker.com/" rel="noopener ugc nofollow" target="_blank">链接</a>找到。</p><p id="1ee1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要下载Docker，您可以访问这个<a class="ae kv" href="https://www.docker.com/products/docker-desktop" rel="noopener ugc nofollow" target="_blank">链接</a>，在本文的其余部分，我将假设Docker已经正确安装在机器上。</p><h1 id="1a44" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">深度学习项目为什么要用Docker？</h1><p id="4fcf" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">当你在机器上运行深度学习培训时(在云上或本地)，你需要能够轻松地运行培训，而不必每次都为设置环境而挣扎。此外，如果出于某种原因，您想在另一台机器上运行此培训，您不希望再次经历所有设置。</p><p id="6495" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">理想情况下，我们希望有一个命令可以放心地跨机器运行。这就是为什么我几乎一直使用Docker容器进行培训。</p><p id="1ccb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以下是Docker对我的主要优势:</p><ul class=""><li id="dc82" class="mx my iq ky b kz la lc ld lf mz lj na ln nb lr nc nd ne nf bi translated">所有必需的包都已经安装了训练的正确版本:例如，如果我想使用<em class="lv"> Tensorflow2 </em>进行一次训练，我为此配置了一个docker映像，另一个用于<em class="lv"> Tensorflow1 </em>，另一个用于<em class="lv"> Pytorch </em>。</li><li id="1cd8" class="mx my iq ky b kz ng lc nh lf ni lj nj ln nk lr nc nd ne nf bi translated">如果在单个GPU上运行，我可以对所需的GPU进行分区。</li><li id="e0d1" class="mx my iq ky b kz ng lc nh lf ni lj nj ln nk lr nc nd ne nf bi translated">由于所有容器都是独立的，因此如果执行崩溃，其他进程不会受到影响——因此其他GPU不会受到影响，例如当我选择特定的GPU用于训练时。</li><li id="f349" class="mx my iq ky b kz ng lc nh lf ni lj nj ln nk lr nc nd ne nf bi translated">如果使用git存储库作为源代码，我通常会将它添加到主docker映像中，然后在每次创建docker容器时进行git pull，并切换到我想要使用的分支/提交。</li><li id="6a3c" class="mx my iq ky b kz ng lc nh lf ni lj nj ln nk lr nc nd ne nf bi translated">本地文件夹/文件和NAS可以在启动容器时轻松挂载——因此不需要复制，节省了时间，尤其是在我调试某些东西的时候。</li></ul><h1 id="a829" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">Docker简介</h1><p id="dbc3" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">以下是您需要了解的一些基本命令:</p><ul class=""><li id="7de1" class="mx my iq ky b kz la lc ld lf mz lj na ln nb lr nc nd ne nf bi translated">显示当前运行的容器:</li></ul><pre class="kg kh ki kj gt nl nm nn no aw np bi"><span id="2ebd" class="nq mb iq nm b gy nr ns l nt nu">docker ps</span></pre><ul class=""><li id="f3f4" class="mx my iq ky b kz la lc ld lf mz lj na ln nb lr nc nd ne nf bi translated">显示所有容器(甚至那些不再运行的容器):</li></ul><pre class="kg kh ki kj gt nl nm nn no aw np bi"><span id="f547" class="nq mb iq nm b gy nr ns l nt nu">docker ps -a </span></pre><ul class=""><li id="def2" class="mx my iq ky b kz la lc ld lf mz lj na ln nb lr nc nd ne nf bi translated">显示本地保存的图像:</li></ul><pre class="kg kh ki kj gt nl nm nn no aw np bi"><span id="c56f" class="nq mb iq nm b gy nr ns l nt nu">docker images</span></pre><ul class=""><li id="60a9" class="mx my iq ky b kz la lc ld lf mz lj na ln nb lr nc nd ne nf bi translated">移除docker容器:</li></ul><pre class="kg kh ki kj gt nl nm nn no aw np bi"><span id="ac54" class="nq mb iq nm b gy nr ns l nt nu">docker stop container_name # if container is running<br/>docker rm container_name</span></pre><ul class=""><li id="ae4b" class="mx my iq ky b kz la lc ld lf mz lj na ln nb lr nc nd ne nf bi translated">移除所有docker容器(不再运行):</li></ul><pre class="kg kh ki kj gt nl nm nn no aw np bi"><span id="cc4d" class="nq mb iq nm b gy nr ns l nt nu">docker container prune</span></pre><ul class=""><li id="93dd" class="mx my iq ky b kz la lc ld lf mz lj na ln nb lr nc nd ne nf bi translated">移除图像:</li></ul><pre class="kg kh ki kj gt nl nm nn no aw np bi"><span id="bc0a" class="nq mb iq nm b gy nr ns l nt nu">docker rmi image_name</span></pre><ul class=""><li id="a0a0" class="mx my iq ky b kz la lc ld lf mz lj na ln nb lr nc nd ne nf bi translated">删除所有docker图像(非常小心这一个！):</li></ul><pre class="kg kh ki kj gt nl nm nn no aw np bi"><span id="988f" class="nq mb iq nm b gy nr ns l nt nu">docker image prune -a</span></pre><h1 id="5d49" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">在Docker容器中运行Tensorflow2培训</h1><h2 id="739b" class="nq mb iq bd mc nv nw dn mg nx ny dp mk lf nz oa mm lj ob oc mo ln od oe mq of bi translated">Docker图像</h2><p id="b352" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">首先，我们提取包含Tensorflow版本2.1.04和Python3的NVIDIA映像(这将需要一些时间):</p><pre class="kg kh ki kj gt nl nm nn no aw np bi"><span id="6843" class="nq mb iq nm b gy nr ns l nt nu">docker pull nvcr.io/nvidia/tensorflow:21.04-tf2-py3</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi og"><img src="../Images/2bc445c6b5a88ba1c6d7843f13474156.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dHPZgq2A-sNUS-0qt1FrBQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Docker pull done按作者分类的图像</p></figure><p id="3d9e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">完成后，我们使用命令<code class="fe oh oi oj nm b">docker images</code>检查图像是否在本地图像列表中:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ok"><img src="../Images/4c9b78892be790cce797303660e89f46.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u0YwNH3NviZZ1vd7le9okw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">列出Docker本地图像—按作者分类的图像</p></figure><p id="7b9b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们确实看到了带有标签<code class="fe oh oi oj nm b">21.04-tf2-py3</code>的图像<code class="fe oh oi oj nm b">nvcr.io/nvidia/tensorflow</code>。</p><h2 id="cfd5" class="nq mb iq bd mc nv nw dn mg nx ny dp mk lf nz oa mm lj ob oc mo ln od oe mq of bi translated">用这个图像启动一个容器，并浏览一些标志</h2><p id="4c74" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">我们可以使用此图像创建一个容器:</p><pre class="kg kh ki kj gt nl nm nn no aw np bi"><span id="3e24" class="nq mb iq nm b gy nr ns l nt nu">docker run -it --rm --name tensorflow2-container --network=host nvcr.io/nvidia/tensorflow:21.04-tf2-py3 bash</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ol"><img src="../Images/5d641c499db1aef2b843985a23bc7240.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KdinOOas4TlH2YKXO49j5w.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Tensorflow2图像中的Docker容器已打开-作者提供的图像</p></figure><p id="0b8c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们在这个命令中使用了一些特定的标志:</p><ul class=""><li id="64af" class="mx my iq ky b kz la lc ld lf mz lj na ln nb lr nc nd ne nf bi translated"><code class="fe oh oi oj nm b">-it</code>用于打开一个交互终端</li><li id="d387" class="mx my iq ky b kz ng lc nh lf ni lj nj ln nk lr nc nd ne nf bi translated"><code class="fe oh oi oj nm b">--rm</code>是用来当我们退出集装箱时，它会把它移走</li><li id="e812" class="mx my iq ky b kz ng lc nh lf ni lj nj ln nk lr nc nd ne nf bi translated"><code class="fe oh oi oj nm b">--name</code>用于用自定义名称给容器命名</li><li id="10e6" class="mx my iq ky b kz ng lc nh lf ni lj nj ln nk lr nc nd ne nf bi translated"><code class="fe oh oi oj nm b">--network=host</code>用于访问容器中的互联网(与主机相同的网络)</li><li id="42a1" class="mx my iq ky b kz ng lc nh lf ni lj nj ln nk lr nc nd ne nf bi translated">然后，我们有了要使用的图像的名称，后跟<code class="fe oh oi oj nm b">bash</code>以在容器中创建一个交互式shell</li></ul><p id="ce00" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们在另一个终端中运行<code class="fe oh oi oj nm b">docker ps</code>，我们将看到我们的新容器:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi om"><img src="../Images/6a8d2eae6852b4c8824b5f0d2239ecdb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*krE77hagdZk4bcDrFXaZ1g.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">docker ps命令来查看新启动的容器——按作者排序的图像</p></figure><p id="7479" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们确实看到了我们的集装箱<code class="fe oh oi oj nm b">tensorflow2-container</code> ✅</p><p id="1ea9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，如果我们想将我们的<strong class="ky ir">本地工作区</strong>用于训练脚本，我们可以通过使用<code class="fe oh oi oj nm b">-v /Users/margauxmforstyhe/workspace/:/workspace</code>将我的工作区文件夹挂载到容器中。此参数将我们计算机上的工作区文件夹挂载到容器中的基本工作区文件夹。</p><p id="555f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们当前的容器中，如果我们运行<code class="fe oh oi oj nm b">ls</code>,我们会看到:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi on"><img src="../Images/2274fcdfc08219f1e9a05de3ee9dd98b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tjcf1XzAEwN7xNMO-qjXfw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Docker容器中的默认工作空间文件夹-按作者排序的图像</p></figure><p id="3f2d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们退出当前使用命令<code class="fe oh oi oj nm b">exit</code>打开的docker容器，并使用工作区文件夹创建一个新的容器:</p><pre class="kg kh ki kj gt nl nm nn no aw np bi"><span id="3277" class="nq mb iq nm b gy nr ns l nt nu">docker run -it --rm --name tensorflow2-container --network=host -v /Users/margauxmforstyhe/workspace/:/workspace nvcr.io/nvidia/tensorflow:21.04-tf2-py3 bash</span></pre><p id="821b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">并运行<code class="fe oh oi oj nm b">ls</code>:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oo"><img src="../Images/0d2c045dc49a271e8362a4603c755c6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:682/format:webp/1*sgPYFhbEBLywq2nq7As8hQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Docker容器中的本地工作区文件夹-按作者排序的图像</p></figure><p id="8c28" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">➡️本地工作区安装在Docker容器中，我们现在可以使用它进行培训/测试。</p><p id="b780" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我做一些训练测试时，我使用一台带有GPU的机器，并为GPU0选择一个带有<code class="fe oh oi oj nm b">--gpu=device=0</code>的GPU。然后，当我完成测试时，我通常运行如下命令来开始训练:</p><pre class="kg kh ki kj gt nl nm nn no aw np bi"><span id="b33a" class="nq mb iq nm b gy nr ns l nt nu">docker run -i -d --rm --gpus=device=0 --name tensorflow2-container --network=host -v /Users/margauxmforstyhe/workspace/:/workspace nvcr.io/nvidia/tensorflow:21.04-tf2-py3 bash -c "export PYTHONPATH=/workspace &amp;&amp; python3 /workspace/training_repo/train.py .... {parameters for the training}"</span></pre><p id="0bda" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里我们有一个处于<strong class="ky ir">分离模式的docker容器</strong> ( <code class="fe oh oi oj nm b">-d</code>意味着我们看不到终端中代码的执行)在0号GPU上运行本地训练脚本。</p><blockquote class="ls lt lu"><p id="ccde" class="kw kx lv ky b kz la jr lb lc ld ju le lw lg lh li lx lk ll lm ly lo lp lq lr ij bi translated"><strong class="ky ir">注意:</strong>这和推理脚本完全一样，你只需要改变被调用的python脚本。</p></blockquote><p id="f754" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另一种方法是拥有一个包含所有训练脚本的git存储库，并将其作为映像的一部分添加进来。让我们用一个<a class="ae kv" href="https://docs.docker.com/engine/reference/builder/" rel="noopener ugc nofollow" target="_blank"> Dockerfile </a>来做这件事吧！</p><h2 id="f3b5" class="nq mb iq bd mc nv nw dn mg nx ny dp mk lf nz oa mm lj ob oc mo ln od oe mq of bi translated">使用Docker文件构建Docker映像，并使用git存储库作为训练存储库</h2><p id="be5b" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">Dockerfile文件用于创建图像。例如，我们想要在我们之前使用的映像<code class="fe oh oi oj nm b">nvcr.io/nvidia/tensorflow:21.04-tf2-py3</code>之上创建一个映像，然后我们想要从Github克隆<a class="ae kv" href="https://github.com/MargauxMasson/training_repo.git" rel="noopener ugc nofollow" target="_blank"><em class="lv">training _ repo</em></a>并安装运行培训的所有需求(例如<code class="fe oh oi oj nm b">install rasterio</code>，或者安装一个特定包的版本)，这为我们提供了这个docker文件:</p><pre class="kg kh ki kj gt nl nm nn no aw np bi"><span id="8afd" class="nq mb iq nm b gy nr ns l nt nu">FROM nvcr.io/nvidia/tensorflow:21.04-tf2-py3</span><span id="dc5c" class="nq mb iq nm b gy op ns l nt nu">RUN apt-get update <br/>RUN git clone <a class="ae kv" href="https://github.com/MargauxMasson/training_repo.git" rel="noopener ugc nofollow" target="_blank">https://github.com/MargauxMasson/training_repo.git</a><br/>RUN pip install -r /workspace/training_repo/requirements.txt<br/>RUN ls</span><span id="b767" class="nq mb iq nm b gy op ns l nt nu">WORKDIR /workspace/</span><span id="af6f" class="nq mb iq nm b gy op ns l nt nu">CMD "ls"</span></pre><p id="855f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了构建这个图像——我们将把它命名为<code class="fe oh oi oj nm b">tensorflow-21.04-tf2-py3-with-requirements-and-git-repo</code>——我们使用命令<code class="fe oh oi oj nm b">docker build</code>(需要在Dockerfile所在的文件夹中运行):</p><pre class="kg kh ki kj gt nl nm nn no aw np bi"><span id="806f" class="nq mb iq nm b gy nr ns l nt nu">docker build . --network=host -t tensorflow-21.04-tf2-py3-with-requirements-and-git-repo</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oq"><img src="../Images/f7256a0da1fbc39b2c5676c35d8e398d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6nydNiqZq4CXAdTh6HlK3Q.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">使用Dockefile构建图像—按作者分类的图像</p></figure><p id="3290" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们看到图像的构建工作正常，当我们用<code class="fe oh oi oj nm b">docker images</code>检查时，我们确实看到了新的图像<code class="fe oh oi oj nm b">tensorflow-21.04-tf2-py3-with-requirements-and-git-repo</code>。</p><p id="5a2a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">注意:</strong>docker构建命令中的<code class="fe oh oi oj nm b">“.”</code>表示名为<code class="fe oh oi oj nm b">Dockerfile</code>的docker文件位于我们运行命令的文件夹中。</p><p id="5869" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，当我们使用这个映像启动容器时，我们不需要挂载本地工作区，因为git repo已经在映像中了:</p><pre class="kg kh ki kj gt nl nm nn no aw np bi"><span id="bd04" class="nq mb iq nm b gy nr ns l nt nu">docker run -it --rm --name tensorflow2-container --network=host <!-- -->tensorflow-21.04-tf2-py3-with-requirements-and-git-repo<!-- --> bash</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi or"><img src="../Images/a5dfdb4fffe217ea3e64529e7fbfd205.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H59z48zPlV5lQ-e2xb-zpg.png"/></div></div></figure><p id="5962" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">实际上，<em class="lv"> training_repo </em>就在容器的工作区中。</p><p id="b4a6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">即使git存储库中的代码发生了变化，也可以不加修改地使用这个映像。当启动容器时，我们可以<code class="fe oh oi oj nm b">git pull</code>或<code class="fe oh oi oj nm b">git checkout</code>到任何想要的分支/提交:</p><pre class="kg kh ki kj gt nl nm nn no aw np bi"><span id="0b2e" class="nq mb iq nm b gy nr ns l nt nu">docker run -i -d --rm --gpus=device=0 --name tensorflow2-container --network=host <!-- -->tensorflow-21.04-tf2-py3-with-requirements-and-git-repo<!-- --> bash -c "cd /workspace/training_repo &amp;&amp; git pull &amp;&amp; git checkout my_training_dev_branch &amp;&amp; export PYTHONPATH=/workspace &amp;&amp; python3 /workspace/training_repo/train.py .... {parameters for the training}"</span></pre><p id="03d5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">同样，正如启动容器时所建议的，我们可以添加这些标志:<code class="fe oh oi oj nm b">--shm-size=1g --ulimit memlock=-1 --ulimit stack=67108864</code></p><p id="6a32" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以:</p><pre class="kg kh ki kj gt nl nm nn no aw np bi"><span id="9251" class="nq mb iq nm b gy nr ns l nt nu">docker run -i -d --rm --gpus=device=0 --name tensorflow2-container --network=host <!-- -->--shm-size=1g --ulimit memlock=-1 --ulimit stack=67108864<!-- --> <!-- -->tensorflow-21.04-tf2-py3-with-requirements-and-git-repo<!-- --> bash -c "cd /workspace/training_repo &amp;&amp; git pull &amp;&amp; git checkout my_training_dev_branch &amp;&amp; export PYTHONPATH=/workspace &amp;&amp; python3 /workspace/training_repo/train.py .... {parameters for the training}"</span></pre></div><div class="ab cl os ot hu ou" role="separator"><span class="ov bw bk ow ox oy"/><span class="ov bw bk ow ox oy"/><span class="ov bw bk ow ox"/></div><div class="ij ik il im in"><p id="fede" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有很多方法可以使用Docker，但这是我喜欢使用它进行训练和推理的方式，它帮助我保持有组织性，因为我有一些特定的图像(或至少Docker文件),我可以自信地使用它们，并知道我的训练代码将毫无困难地运行。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oz"><img src="../Images/8af048fee324247aa6531b6ed0d10567.png" data-original-src="https://miro.medium.com/v2/resize:fit:998/1*uLW6noHHLd9ALIuW3OQGag.gif"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">GIF来自<a class="ae kv" href="https://media.giphy.com/media/g0gtihsbzj5pSWgcml/giphy.gif" rel="noopener ugc nofollow" target="_blank">https://media.giphy.com/media/g0gtihsbzj5pSWgcml/giphy.gif</a></p></figure></div></div>    
</body>
</html>