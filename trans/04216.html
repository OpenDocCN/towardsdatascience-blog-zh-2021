<html>
<head>
<title>Configure a Read Replica Database in Django</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Django中配置读取副本数据库</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/configure-a-read-replica-database-in-django-b0d54ec897f1?source=collection_archive---------29-----------------------#2021-04-09">https://towardsdatascience.com/configure-a-read-replica-database-in-django-b0d54ec897f1?source=collection_archive---------29-----------------------#2021-04-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="3842" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">软件开发</h2><div class=""/><div class=""><h2 id="6f16" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">何时以及如何在Django中配置读取副本数据库</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/7b25fe4477f64822e3044124e326c3b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*SN966T108tRg1alq.jpeg"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">图片由<a class="ae lh" href="https://unsplash.com/@petrebels" rel="noopener ugc nofollow" target="_blank">海燕</a>在<a class="ae lh" href="https://unsplash.com/photos/JwMGy1h-JsY" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><h1 id="9527" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">何时以及如何在Django中配置读取副本数据库</h1><p id="459f" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">在软件工程中，最关键的步骤之一是架构的选择，以至于选择中的任何错误都可能导致网站出现故障，从而对业务绩效产生不利影响。</p><p id="6cb6" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">通常，与系统性能相关的问题，尤其是对于大型复杂的系统，对于维护和诊断是至关重要的，因为它们可能与不同的软件环境相关。这些问题可能由多种因素引起，包括硬件、软件或网络相关问题。</p><p id="43e2" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">下一篇文章将讨论与<a class="ae lh" href="https://www.dtm.io/blog/tag/database/" rel="noopener ugc nofollow" target="_blank">数据库</a>性能相关的问题，以及使用读取副本减轻这些问题的方法。我目前的体验是基于部署在谷歌云平台上的<a class="ae lh" href="https://cloud.google.com/appengine" rel="noopener ugc nofollow" target="_blank"> App Engine </a>应用和<a class="ae lh" href="https://cloud.google.com/sql/docs/postgres/replication" rel="noopener ugc nofollow" target="_blank"> PostgreSQL复制</a>。</p><h2 id="a9cf" class="nb lj it bd lk nc nd dn lo ne nf dp ls mj ng nh lu mn ni nj lw mr nk nl ly iz bi translated">数据库中的性能问题</h2><p id="9f74" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">在大多数情况下，由于与数据库性能相关的问题，系统会变得混乱。造成这种情况的因素有很多，最常见的是选择了错误的模式设计。因此，如果在牢记预期操作的同时没有正确设计，<a class="ae lh" href="https://www.dtm.io/blog/tag/database/" rel="noopener ugc nofollow" target="_blank">数据库</a>将最终表现不佳。相反，一个设计良好的模式不一定能达到标准，因为许多其他因素会影响它的性能，例如连接数、压力或负载处理能力，或者数据库要处理的数据量。例如，当单个数据库处理大量用户(考虑几千个)时，它将遇到大量连接命中，并且它不一定有资源来实时满足这些命中。因此，为了缓解这种情况，引入了副本的概念。</p><h2 id="a96b" class="nb lj it bd lk nc nd dn lo ne nf dp ls mj ng nh lu mn ni nj lw mr nk nl ly iz bi translated">数据库副本</h2><p id="b8df" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">关于软件和硬件的术语“复制”是指利用特定资源的多个副本(或复制品)来改善/增强性能、服务可用性和容错的过程。关于<a class="ae lh" href="https://www.dtm.io/blog/tag/database/" rel="noopener ugc nofollow" target="_blank">数据库</a>系统中的复制，通常认为多台服务器在处理相同的数据。有多种配置和过程可用于将复制合并到数据库中:</p><ul class=""><li id="98f2" class="nm nn it mc b md mw mg mx mj no mn np mr nq mv nr ns nt nu bi translated">在所有情况下都允许读或写命令。</li><li id="d2fc" class="nm nn it mc b md nv mg nw mj nx mn ny mr nz mv nr ns nt nu bi translated">多个只读实例和一个主实例(允许读/写命令)。注意，在这种模式中，数据复制和同步可以以同步和异步方式执行。</li></ul><h2 id="cc5c" class="nb lj it bd lk nc nd dn lo ne nf dp ls mj ng nh lu mn ni nj lw mr nk nl ly iz bi translated">在Django中处理读取副本配置</h2><p id="9266" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">在<a class="ae lh" href="https://www.dtm.io/blog/tag/django/" rel="noopener ugc nofollow" target="_blank"> Django </a>应用中配置和使用读取副本之前，应考虑以下两点:</p><ul class=""><li id="32fe" class="nm nn it mc b md mw mg mx mj no mn np mr nq mv nr ns nt nu bi translated">读取副本实例应该在Django应用程序中声明为数据库。</li><li id="46ca" class="nm nn it mc b md nv mg nw mj nx mn ny mr nz mv nr ns nt nu bi translated">需要配置路由器来选择相应的读取副本。</li></ul><p id="854b" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated"><strong class="mc jd">在Django中声明读取副本实例为数据库的程序</strong></p><p id="3425" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">在<a class="ae lh" href="https://www.dtm.io/blog/tag/django/" rel="noopener ugc nofollow" target="_blank"> Django </a>中将读取副本配置和声明为数据库的方法包括设置Django设置文件。如上所述，我们将设置一个默认的单个主实例(允许读/写的服务器)<a class="ae lh" href="https://www.dtm.io/blog/tag/database/" rel="noopener ugc nofollow" target="_blank">数据库</a>，而读副本将被声明为附加数据库。例如，考虑到已经配置了两个复制副本，settings.py文件应该如下所示:</p><pre class="ks kt ku kv gt oa ob oc od aw oe bi"><span id="f1e7" class="nb lj it ob b gy of og l oh oi">DATABASES = {<br/>    "default": {<br/>        "ENGINE": "django.db.backends.postgresql",<br/>        "HOST": "/cloudsql/project-id:region:master-instance-id",<br/>        "NAME": "pg_master",<br/>        "USER": "pg_user",<br/>        "PASSWORD": "master_password",<br/>    },<br/>    "replica_1": {<br/>        "ENGINE": "django.db.backends.postgresql", <br/>        "HOST": "/cloudsql/project-id:region:replica1-instance-id",<br/>        "NAME": "pg_replica1",<br/>        "USER": "pg_user",<br/>        "PASSWORD": "replica1_password",<br/>    },<br/>    "replica_2": {<br/>        "ENGINE": "django.db.backends.postgresql",<br/>        "HOST": "/cloudsql/project-id:region:replica2-instance-id",<br/>        "NAME": "pg_replica2",<br/>        "USER": "pg_user",<br/>        "PASSWORD": "replica2_password",<br/>    }<br/>}</span></pre><p id="5908" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">一旦配置完成，这两个副本就可以通过<a class="ae lh" href="https://www.dtm.io/blog/tag/django/" rel="noopener ugc nofollow" target="_blank"> Django </a>应用程序使用了。我们可以通过使用QuerySet API的方法<a class="ae lh" href="https://docs.djangoproject.com/en/2.2/ref/models/querysets/#using" rel="noopener ugc nofollow" target="_blank">来再次确认这一点。例如，可以使用以下命令从主数据库和副本数据库检查<strong class="mc jd"> Lead </strong>模型的可访问性:</a></p><pre class="ks kt ku kv gt oa ob oc od aw oe bi"><span id="d44f" class="nb lj it ob b gy of og l oh oi"># Here the leads are retrieved from the master instance:<br/>Lead.objects.all()</span><span id="f82a" class="nb lj it ob b gy oj og l oh oi"># Here the leads are retrieved from the replica instance 1:<br/>Lead.objects.using('replica_1').all()</span><span id="77e6" class="nb lj it ob b gy oj og l oh oi"># Here the leads are retrieved from the replica instance 2:<br/>Lead.objects.using('replica_2').all()</span></pre><p id="df15" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">也可以在通过传递“using”参数的“<a class="ae lh" href="https://docs.djangoproject.com/en/2.2/topics/db/multi-db/#selecting-a-database-for-save" rel="noopener ugc nofollow" target="_blank"> save </a>方法保存对象时，将给定的<a class="ae lh" href="https://www.dtm.io/blog/tag/database/" rel="noopener ugc nofollow" target="_blank">数据库</a>设置为可用。请注意，在一个读取副本中保存对象时，将会遇到错误，因为实例只允许读取操作，不允许写入。</p><p id="5873" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated"><strong class="mc jd">路由器配置有助于在需要时访问特定的读取副本</strong></p><p id="cfbe" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">一旦在<a class="ae lh" href="https://www.dtm.io/blog/tag/django/" rel="noopener ugc nofollow" target="_blank"> Django </a>应用程序中配置了副本实例，并且确保了可访问性，软件开发人员就以这样的方式设计程序，即在适当的相应副本上执行只读操作。因此，默认情况下，这种方法会妨碍可扩展性，因为它更像是配置复制副本实例选择的手动过程。这意味着将来添加更多的副本将需要修改代码并手动配置路由过程。</p><p id="5e23" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">然而，手动配置的另一个聪明的方法是使用Django的数据库路由器。在这种配置中，可以创建定制的路由器，它自动选择默认实例来执行写操作，或者选择随机选择的副本来执行读操作。下面是自定义路由器配置，显示了该过程的工作原理:</p><pre class="ks kt ku kv gt oa ob oc od aw oe bi"><span id="45f2" class="nb lj it ob b gy of og l oh oi">class DatabaseRouter:<br/>    def db_for_read(self, model, **hints):<br/>        return random.choice(['replica_1', 'replica_2'])</span><span id="8fb8" class="nb lj it ob b gy oj og l oh oi">    def db_for_write(self, model, **hints):<br/>        return 'default'</span><span id="4d85" class="nb lj it ob b gy oj og l oh oi">    def allow_relation(self, obj1, obj2, **hints):<br/>        return True</span><span id="a26d" class="nb lj it ob b gy oj og l oh oi">    def allow_migrate(self, db, label, model=None, **hints):<br/>        return True</span></pre><p id="cab3" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">按照上面的过程，现在我们需要通过设置默认的数据库路由来更新“setting.py”文件:</p><pre class="ks kt ku kv gt oa ob oc od aw oe bi"><span id="9dc0" class="nb lj it ob b gy of og l oh oi">DATABASE_ROUTERS = ['app.router.DatabaseRouter']</span></pre><p id="3dd3" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">一旦更改生效，应用程序中的所有读取操作将被路由到副本，写入操作将被定向到主实例。</p><h2 id="6468" class="nb lj it bd lk nc nd dn lo ne nf dp ls mj ng nh lu mn ni nj lw mr nk nl ly iz bi translated">结论</h2><p id="8060" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">总结一下我们的讨论，在Django 中打开读取副本实例的过程非常简单。此外，它有助于增强应用程序的性能以及整个系统的功能。在我们原始代码的基础上，对配置文件和设置进行微小的修改，就可以让事情朝着对系统有利的方向发展。</p></div><div class="ab cl ok ol hx om" role="separator"><span class="on bw bk oo op oq"/><span class="on bw bk oo op oq"/><span class="on bw bk oo op"/></div><div class="im in io ip iq"><p id="75c2" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">感谢阅读这篇文章！如果你有任何问题，请在下面留言。另外，看看我以前的文章，你可能会喜欢:</p><div class="or os gp gr ot ou"><a rel="noopener follow" target="_blank" href="/data-structures-simplified-and-classified-e0c1e304436b"><div class="ov ab fo"><div class="ow ab ox cl cj oy"><h2 class="bd jd gy z fp oz fr fs pa fu fw jc bi translated">数据结构—简化和分类</h2><div class="pb l"><h3 class="bd b gy z fp oz fr fs pa fu fw dk translated">本文将简化和总结这些最基本的数据结构，您将理解并能够…</h3></div><div class="pc l"><p class="bd b dl z fp oz fr fs pa fu fw dk translated">towardsdatascience.com</p></div></div><div class="pd l"><div class="pe l pf pg ph pd pi lb ou"/></div></div></a></div><div class="or os gp gr ot ou"><a href="https://vpodk.medium.com/principles-of-software-engineering-6b702faf74a6" rel="noopener follow" target="_blank"><div class="ov ab fo"><div class="ow ab ox cl cj oy"><h2 class="bd jd gy z fp oz fr fs pa fu fw jc bi translated">软件工程原理</h2><div class="pb l"><h3 class="bd b gy z fp oz fr fs pa fu fw dk translated">固体干吻——这意味着什么？</h3></div><div class="pc l"><p class="bd b dl z fp oz fr fs pa fu fw dk translated">vpodk.medium.com</p></div></div><div class="pd l"><div class="pj l pf pg ph pd pi lb ou"/></div></div></a></div></div></div>    
</body>
</html>