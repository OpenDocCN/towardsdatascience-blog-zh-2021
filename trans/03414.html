<html>
<head>
<title>7 SQL Functionalities You Should Definitely Know</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你绝对应该知道的7个SQL功能</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/7-sql-functionalities-that-you-should-definitely-know-2b3fd9174608?source=collection_archive---------16-----------------------#2021-03-18">https://towardsdatascience.com/7-sql-functionalities-that-you-should-definitely-know-2b3fd9174608?source=collection_archive---------16-----------------------#2021-03-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="f4fb" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/getting-started" rel="noopener" target="_blank">入门</a></h2><div class=""/><div class=""><h2 id="1c28" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">更好地使用SQL将会节省您的时间并减少您的挫败感</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/5b8a9c7c64728156c6e13adc16b996c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_8b-rdoOpB1TBQUb"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">马库斯·斯皮斯克在<a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="d91d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">SQL是许多数据科学家的一项重要技能。SQL(结构化查询语言)是一种非常灵活的语言，读起来很像普通英语。它允许轻松访问数据库中最复杂的表结构。毕竟，如果不能访问数据，数据有什么用？市场上的许多工作都需要SQL知识，所以至少学习一些基础知识绝对是一个明智的想法。作为一个曾经管理过不使用SQL的数据库的人，我可以自信地说，如果你有一份使用SQL的工作，你一定会很感激。</p><p id="e3dd" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在本文中，我想与您分享SQL的一些功能，以帮助您更好地进行搜索，从而成为查询高手。</p><h1 id="9bed" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">1.格条款</h1><p id="ebf1" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated"><code class="fe nb nc nd ne b">CASE</code>子句允许您在查询中创建条件情况，并将它们作为列返回。</p><pre class="ks kt ku kv gt nf ne ng nh aw ni bi"><span id="b803" class="nj mf it ne b gy nk nl l nm nn">SELECT employee_name, salary,<br/>CASE<br/>    WHEN salary &gt;= 100000 THEN 'Senior'<br/>    WHEN salary &lt; 100000 AND salary &gt;= 50000 THEN 'Midlevel'<br/>    WHEN salary &lt; 50000 THEN 'Entrylevel' END<br/>FROM employees;</span></pre><p id="97ca" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">该查询将返回雇员姓名和薪金列，而<code class="fe nb nc nd ne b">CASE</code>子句将是一个新列，根据薪金条件语句所满足的条件，包含高级、中级或入门级的值。注意<code class="fe nb nc nd ne b">CASE</code>子句的语法。您可以使用<code class="fe nb nc nd ne b">WHEN</code>和<code class="fe nb nc nd ne b">THEN</code>添加任意多的条件语句，并在开始时将它们全部夹在<code class="fe nb nc nd ne b">CASE</code>中，当您完成条件语句时，将它们夹在<code class="fe nb nc nd ne b">END</code>中。</p><h1 id="1b82" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">2.聚合函数</h1><p id="22c4" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">您可以在查询中执行许多非常有用的功能。它们是非常直接的函数，通常只需要意识到它们的存在。所以要知道，像<code class="fe nb nc nd ne b">MIN()</code>、<code class="fe nb nc nd ne b">MAX()</code>、<code class="fe nb nc nd ne b">SUM()</code>、<code class="fe nb nc nd ne b">COUNT()</code>和<code class="fe nb nc nd ne b">AVG()</code>这样的东西会让你的查询更有效率。请注意，您总是需要将它们与GROUP BY子句配对。</p><pre class="ks kt ku kv gt nf ne ng nh aw ni bi"><span id="333c" class="nj mf it ne b gy nk nl l nm nn">SELECT region, COUNT(employee_name)<br/>FROM employees<br/>GROUP BY region;</span></pre><p id="4a31" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">该查询将返回地区列表以及每个地区的雇员人数。如前所述，您必须将count函数与一个<code class="fe nb nc nd ne b">GROUP BY</code>子句配对，以告诉数据库如何对计数进行分组。</p><pre class="ks kt ku kv gt nf ne ng nh aw ni bi"><span id="83a0" class="nj mf it ne b gy nk nl l nm nn">SELECT department, SUM(salary)<br/>FROM employees<br/>GROUP BY department;</span></pre><p id="60df" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">该查询将返回部门列表，其中包含该部门所有员工的工资总额。同样，您必须使用一个<code class="fe nb nc nd ne b">GROUP BY</code>子句来告诉数据库按部门对合计工资进行分组。</p><h1 id="9e93" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">3.WHERE和HAVING子句</h1><p id="6f34" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated"><code class="fe nb nc nd ne b">WHERE</code>和<code class="fe nb nc nd ne b">HAVING</code>子句彼此相似，因为它们都是基于标准进行过滤的简单方法。需要记住的两者之间的最大区别是，<code class="fe nb nc nd ne b">HAVING</code>将基于聚合数据列进行过滤，而<code class="fe nb nc nd ne b">WHERE</code>不会。</p><pre class="ks kt ku kv gt nf ne ng nh aw ni bi"><span id="b306" class="nj mf it ne b gy nk nl l nm nn">SELECT employee_name, department<br/>FROM employees<br/>WHERE salary &gt; 50000;</span></pre><p id="09e1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">该查询将只返回符合<code class="fe nb nc nd ne b">WHERE</code>语句标准的雇员的所有姓名和部门。也就是说，只有工资高于$50，000的雇员才会被返回。</p><pre class="ks kt ku kv gt nf ne ng nh aw ni bi"><span id="140d" class="nj mf it ne b gy nk nl l nm nn">SELECT department, SUM(salary)<br/>FROM employees<br/>GROUP BY department<br/>HAVING SUM(salary) &gt; 1000000;</span></pre><p id="2ebb" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这个查询与上面的查询相同，但是现在返回的部门是那些工资总额大于1，000，000美元的部门。注意在这个查询中我们如何使用了一个<code class="fe nb nc nd ne b">HAVING</code>语句，因为它是在一个聚合列上过滤的。</p><h1 id="8bc5" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">4.串联运算符</h1><p id="061b" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">这是将列合并成一列的一个方便的小技巧。例如，假设您有一个表，其中包含两个不同列中的雇员姓名，即名字和姓氏。也许您希望创建一个查询，返回同一列中的姓名，并显示全名。串联运算符将为您完成这项工作。它被表示为两个相邻的管道，如so <code class="fe nb nc nd ne b">||</code>。</p><pre class="ks kt ku kv gt nf ne ng nh aw ni bi"><span id="5779" class="nj mf it ne b gy nk nl l nm nn">SELECT first_name || ' ' || last_name<br/>FROM employees;</span></pre><p id="7ef5" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">该查询将返回一列，该列的名字和姓氏用空格隔开。你可以按照你希望名字出现的方式写这一行。如果您希望姓氏出现在最前面，您可以将该行写成<code class="fe nb nc nd ne b">last_name || ', '|| first_name</code>。这将首先显示姓氏列中的信息，然后是逗号和空格，最后是名字信息。</p><h1 id="2a3f" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">5.子查询</h1><p id="e2f3" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">许多希望从两个表中获取信息的人通常会立即转向连接。但是子查询也是组合来自两个来源的信息的有效方法，您可能会发现在某些情况下它们更容易。子查询可以用在几乎任何子句中(包括<code class="fe nb nc nd ne b">SELECT</code>、<code class="fe nb nc nd ne b">FROM</code>、<code class="fe nb nc nd ne b">WHERE</code>等)。).</p><pre class="ks kt ku kv gt nf ne ng nh aw ni bi"><span id="e8ad" class="nj mf it ne b gy nk nl l nm nn">SELECT *<br/>FROM employees<br/>WHERE department IN (SELECT department <br/>                     FROM departments<br/>                     WHERE division = 'Technology');</span></pre><p id="7e73" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这个查询乍一看可能很奇怪，但是让我们一次一部分来看。括号中的子查询返回属于技术部门的部门列表。因此，您可以将括号中的内容视为部门名称列表。主查询选择条目的所有列，这些条目的部门至少与子查询返回的列表中的一个部门名称匹配。</p><p id="7d1e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我发现保持子查询的新鲜感有助于我有更多的解决方案来处理棘手的情况。连接很好，但知道如何用多种方法解谜更有用。</p><h1 id="fc07" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">6.LIKE运算符</h1><p id="84d2" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">通常情况下，数据库中的信息必须精确搜索，并且区分大小写。也许您有一些条目的大写有所不同，或者有轻微的拼写差异。在这里,<code class="fe nb nc nd ne b">LIKE</code>操作符将是你最好的朋友，因为它是你搜索时不需要精确拼写的方式。</p><pre class="ks kt ku kv gt nf ne ng nh aw ni bi"><span id="144f" class="nj mf it ne b gy nk nl l nm nn">SELECT department<br/>FROM departments<br/>WHERE department LIKE '%omputer%';</span></pre><p id="c191" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这将返回包含字符串“omputer”的所有部门。因此，如果您将一些部门输入为“计算机”、“计算机”或“计算机”，所有这些条目都将被返回。</p><h1 id="5f37" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">7.美化你的结果</h1><p id="0516" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">最后一个是一些相关技巧的集合，可以让你的结果以简洁易读的格式显示。</p><p id="0ac3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">注意列的排列顺序。</strong>如果您希望某列首先出现，那么在查询中首先列出它。像<code class="fe nb nc nd ne b">SELECT last_name, first_name, department, salary</code>这样的语句将按这个顺序显示列。</p><p id="ae37" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">利用别名重命名列。</strong>别名在使用聚合函数时特别有用。让我们看看上面的一个查询，看看我们如何使用别名来重命名列。</p><pre class="ks kt ku kv gt nf ne ng nh aw ni bi"><span id="e966" class="nj mf it ne b gy nk nl l nm nn">SELECT region, COUNT(employee_name) AS number_of_employees<br/>FROM employees<br/>GROUP BY region;</span></pre><p id="9365" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">计数列现在将返回标题为“number_of_employees ”,这增加了可读性。</p><p id="2ce3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">使用一个</strong> <code class="fe nb nc nd ne b"><strong class="lk jd">ORDER BY</strong></code> <strong class="lk jd">语句。</strong>让我们再次使用相同的查询，看看如何使用<code class="fe nb nc nd ne b">ORDER BY</code>来改进结果。</p><pre class="ks kt ku kv gt nf ne ng nh aw ni bi"><span id="e395" class="nj mf it ne b gy nk nl l nm nn">SELECT region, COUNT(employee_name) AS number_of_employees<br/>FROM employees<br/>GROUP BY region<br/>ORDER BY number_of_employees DESC;</span></pre><p id="46ba" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">默认的排序方法是升序，所以如果你想首先显示最大的结果，你可以像例子中那样添加<code class="fe nb nc nd ne b">DESC</code>。这将极大地提高查询结果的可读性，因为我们现在可以在列表的顶部看到雇员人数最多的地区。</p><p id="1784" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">使用一个</strong> <code class="fe nb nc nd ne b"><strong class="lk jd">LIMIT</strong></code> <strong class="lk jd">语句。</strong> <code class="fe nb nc nd ne b">LIMIT</code>就像它听起来那样限制返回结果的数量。同样，我们可以使用相同的查询来看看这是如何工作的。</p><pre class="ks kt ku kv gt nf ne ng nh aw ni bi"><span id="3fb9" class="nj mf it ne b gy nk nl l nm nn">SELECT region, COUNT(employee_name) AS number_of_employees<br/>FROM employees<br/>GROUP BY region<br/>ORDER BY number_of_employees DESC<br/>LIMIT 5;</span></pre><p id="2b4b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在将只返回前5个结果，这将是拥有最多员工的前5个地区。</p><h1 id="0b7f" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">结论</h1><p id="1016" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">有了这么多的功能，学习SQL会很有趣。我喜欢编写SQL查询，因为每个查询都像是一个谜题。我希望这篇文章能帮助您认识到更多可用的功能，并为您的下一个查询找到一些有用的东西！</p></div></div>    
</body>
</html>