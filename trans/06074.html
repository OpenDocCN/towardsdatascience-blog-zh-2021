<html>
<head>
<title>Run node2vec ultrafast with less memory using PecanPy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用PecanPy以更少的内存运行node2vec ultrafast</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/run-node2vec-faster-with-less-memory-using-pecanpy-1bdf31f136de?source=collection_archive---------26-----------------------#2021-05-31">https://towardsdatascience.com/run-node2vec-faster-with-less-memory-using-pecanpy-1bdf31f136de?source=collection_archive---------26-----------------------#2021-05-31</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="c99e" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/making-sense-of-big-data" rel="noopener" target="_blank">理解大数据</a></h2><div class=""/><div class=""><h2 id="795d" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">一种流行的图形嵌入方法的简单实现</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/1f7a74e845f537b2e366c6437f9221ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pLsn0uOsSxly-wgFd9t1nA.jpeg"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">来自<a class="ae le" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=99684" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>的<a class="ae le" href="https://pixabay.com/users/12019-12019/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=99684" rel="noopener ugc nofollow" target="_blank">大卫·马克</a>的图片</p></figure><p id="3809" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">Node2vec是一种节点嵌入方法，它生成图中节点的数字表示(或嵌入)[1]。然后，这些嵌入被用于各种下游任务，例如节点分类和链路预测。如果你对node2vec不熟悉，可以看看我的另一篇文章来解释它的直觉。</p><h1 id="a8b3" class="mb mc iq bd md me mf mg mh mi mj mk ml kf mm kg mn ki mo kj mp kl mq km mr ms bi translated">TL；速度三角形定位法(dead reckoning)</h1><ul class=""><li id="1ef1" class="mt mu iq lh b li mv ll mw lo mx ls my lw mz ma na nb nc nd bi translated">Node2vec是一种非常流行的嵌入方法，用于生成图(也称为网络)中节点的数字表示，然而最初的实现是<strong class="lh ja">慢</strong>和<strong class="lh ja">内存低效</strong>。</li><li id="fff9" class="mt mu iq lh b li ne ll nf lo ng ls nh lw ni ma na nb nc nd bi translated"><strong class="lh ja"> PecanPy </strong>是node2vec的超快速和内存高效的实现，可以通过pip 轻松安装<strong class="lh ja">，并且可以从命令行或在您的Python脚本中使用。</strong></li><li id="c96e" class="mt mu iq lh b li ne ll nf lo ng ls nh lw ni ma na nb nc nd bi translated">作为一个使用字符串网络的例子，PecanPy将运行时间从<strong class="lh ja"> 5小时</strong>减少到略超过<strong class="lh ja">一分钟</strong>，并将内存使用量从<strong class="lh ja"> 100GB </strong>减少到<strong class="lh ja"> &lt; 1GB </strong>。</li></ul><h1 id="226a" class="mb mc iq bd md me mf mg mh mi mj mk ml kf mm kg mn ki mo kj mp kl mq km mr ms bi translated">node2vec的原始Python实现速度慢且内存效率低</h1><p id="96a6" class="pw-post-body-paragraph lf lg iq lh b li mv ka lk ll mw kd ln lo nj lq lr ls nk lu lv lw nl ly lz ma ij bi translated">最初的实现(在<a class="ae le" href="https://github.com/snap-stanford/snap/tree/master/examples/node2vec" rel="noopener ugc nofollow" target="_blank"> C++ </a>和<a class="ae le" href="https://github.com/aditya-grover/node2vec" rel="noopener ugc nofollow" target="_blank"> Python </a>中实现)非常慢，内存效率也很低。在这篇博客文章中，我将介绍PecanPy [2]，一个<strong class="lh ja"> p </strong>并行化的，内存<strong class="lh ja"> e </strong> ffi <strong class="lh ja"> c </strong> ient和<strong class="lh ja">a</strong>accelerated<strong class="lh ja">n</strong>ode 2 vec in<strong class="lh ja">Py</strong>thon，我们将看到运行时间和内存使用都比最初的实现有了显著的改进。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/f66f8aa66912eb3605609804811cc516.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*Mvs2l-L4JIq5HpRaF6kkyA.png"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">图1。两个生物网络BioGRID和STRING上node2vec的运行时和内存使用情况。</p></figure><p id="749a" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">让我们来看两个嵌入生物网络BioGRID和STRING的例子。两个网络都有大约20k个节点，STRING的密度稍大。使用原始Python实现完全嵌入字符串花费了超过<strong class="lh ja"> 5个小时</strong>和<strong class="lh ja"> 100GB </strong>的内存，并为BioGRID使用了超过1GB的内存，即使整个网络的文件大小只有2.5 MB。<em class="nn">惯坏警告:使用pec嵌入字符串只花费了略超过</em> <strong class="lh ja"> <em class="nn">一分钟</em> </strong> <em class="nn">，内存不到</em><strong class="lh ja"><em class="nn">1GB</em></strong><em class="nn"/></p><h1 id="b676" class="mb mc iq bd md me mf mg mh mi mj mk ml kf mm kg mn ki mo kj mp kl mq km mr ms bi translated">node2vec最初实现的三个主要问题</h1><p id="0d13" class="pw-post-body-paragraph lf lg iq lh b li mv ka lk ll mw kd ln lo nj lq lr ls nk lu lv lw nl ly lz ma ij bi translated">以下问题专门针对最初的Python实现。尽管C++实现在某些方面更有效，但我们将在下一节中看到，它仍然受到内存问题的困扰，并且运行速度比PecanPy慢。</p><p id="509e" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated"><strong class="lh ja">并行性问题</strong>:转移概率预处理和随机游走生成没有并行化，尽管这两个过程具有令人尴尬的并行性，即每个游走生成都是独立的任务，不依赖于任何其他的游走。</p><p id="d90c" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated"><strong class="lh ja">图形数据结构问题</strong>:Python原始实现使用<a class="ae le" href="https://networkx.org" rel="noopener ugc nofollow" target="_blank"> networkx </a>存储图形，对于大规模计算效率相当低。受Matt Ranger的这篇<a class="ae le" href="https://www.singlelunch.com/2019/08/01/700x-faster-node2vec-models-fastest-random-walks-on-a-graph/" rel="noopener ugc nofollow" target="_blank">博客文章</a>的启发，PecanPy对稀疏图使用紧凑稀疏行(CSR)格式，这种格式更紧凑地存储在内存中，最重要的是，运行速度更快，因为它可以更好地利用缓存。然而，CSR有一个问题，如果图是密集的(比如完全连接，这在生物学中很常见，如<a class="ae le" href="https://en.wikipedia.org/wiki/Gene_co-expression_network" rel="noopener ugc nofollow" target="_blank">基因共表达网络</a>)，那么由于显式存储索引，在CSR中存储需要比所需更多的内存。为了处理密集网络，我们还添加了另一个选项来存储为2D numpy数组。</p><p id="ea37" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated"><strong class="lh ja">内存问题</strong>:内存使用量远远超过网络文件大小的原因是二阶转移概率的预处理和存储。为了解决这个问题，我们可以简单地删除预处理步骤，并根据需要计算转移概率，而无需保存。然而，对于仍然可以保存所有二阶转移概率的小型稀疏网络，建议包括预处理步骤，因为它可以更快地生成随机游走，而无需在每个步骤中重新计算转移概率。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/8c8c54d0a1fe811444d65b8413d2de36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*GXxYLESmzk6333EAPUgURg.png"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">图2。PecanPy执行模式概述。</p></figure><p id="7951" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">PecanPy解决了上述所有问题，并提供了三种执行模式，包括<em class="nn"> PreComp </em>、<em class="nn"> SparseOTF </em>和<em class="nn"> DenseOTF </em>，每种模式都针对不同大小和密度的图形进行了更优化。简而言之，两种<em class="nn"> OTF </em>(代表On The Fly)模式通过即时计算转移概率来解决内存问题，而<em class="nn"> PreComp </em>模式保留了在较小网络上的原始实现中的预处理步骤，以实现更快的遍历生成。最后，<em class="nn">稀疏</em>和<em class="nn">密集</em>表示是用CSR还是numpy数组来存储图形。</p><h1 id="495d" class="mb mc iq bd md me mf mg mh mi mj mk ml kf mm kg mn ki mo kj mp kl mq km mr ms bi translated">基准测试结果</h1><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi no"><img src="../Images/7a08c235a3da82a0cf8eaa9e573f4889.png" data-original-src="https://miro.medium.com/v2/resize:fit:924/format:webp/1*C_T_lJ8jpYkaJVFRQ8Ei1w.png"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">图3。node2ec在8个不同网络上的不同实现的运行时和内存使用情况</p></figure><p id="442d" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">图3显示了原始实现和PecanPy之间的运行时和内存使用比较，使用了不同规模和密度的网络，包括node2vec论文[1]中测试的网络。首先，请注意，与最初的Python和C++实现相比，PecanPy的所有三种模式都实现了更快的运行时。特别是，嵌入字符串网络仅用了一分多钟。其次，<em class="nn"> OTF </em>策略显著降低了内存使用量。再看STRING，<em class="nn"> SparseOTF </em>能够用不到1GB的内存完全嵌入网络，而两个原始实现都需要~100GB的内存。此外，由于内存限制(使用200GB资源配置进行测试)，GIANT-TN网络(26k节点，完全连接)不能使用任何原始实现进行嵌入。</p><p id="1325" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">最后，PecanPy生成的嵌入质量被证实与原始Python实现生成的嵌入质量相同。查看[2]了解更多信息。</p><h1 id="bff2" class="mb mc iq bd md me mf mg mh mi mj mk ml kf mm kg mn ki mo kj mp kl mq km mr ms bi translated">PecanPy入门</h1><p id="4d4b" class="pw-post-body-paragraph lf lg iq lh b li mv ka lk ll mw kd ln lo nj lq lr ls nk lu lv lw nl ly lz ma ij bi translated">你可以在<a class="ae le" href="https://github.com/krishnanlab/PecanPy" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上查看最新(未发布)的PecanPy。也可以通过<a class="ae le" href="https://pypi.org/project/pecanpy/" rel="noopener ugc nofollow" target="_blank"> pip </a> : <code class="fe np nq nr ns b">pip install pecanpy</code>轻松安装，安装最新发布的PecanPy版本。使用由<a class="ae le" href="https://github.com/krishnanlab/PecanPy_benchmarks" rel="noopener ugc nofollow" target="_blank">基准库</a>提供的工作流脚本，所有基准都是可再现的(您也可以使用它来基准测试您自己的node2vec实现)。</p><p id="62da" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">PecanPy既可以从命令行使用，也可以作为Python脚本中的模块加载。例如，下面的命令行脚本嵌入了带有<em class="nn"> SparseOTF </em>模式的<a class="ae le" href="https://en.wikipedia.org/wiki/Zachary%27s_karate_club" rel="noopener ugc nofollow" target="_blank">空手道网络</a>:</p><pre class="kp kq kr ks gt nt ns nu nv aw nw bi"><span id="ebdd" class="nx mc iq ns b gy ny nz l oa ob">pecanpy --input karate.edg --output karate.emb --mode SparseOTF</span></pre><p id="bdaf" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">或者换句话说，您可以将PecanPy作为一个模块加载，并从图中生成随机遍历，然后可以用它来生成嵌入:</p><pre class="kp kq kr ks gt nt ns nu nv aw nw bi"><span id="ad76" class="nx mc iq ns b gy ny nz l oa ob">from pecanpy import pecanpy</span><span id="ef7e" class="nx mc iq ns b gy oc nz l oa ob"># load graph object using SparseOTF mode<br/>g = pecanpy.SparseOTF(p=1, q=1, workers=1, verbose=False)<br/>g.read_edg("karate.edg", weighted=False, directed=False)</span><span id="d17d" class="nx mc iq ns b gy oc nz l oa ob"># generate random walks<br/>walks = g.simulate_walks(num_walks=10, walk_length=80)</span><span id="9d59" class="nx mc iq ns b gy oc nz l oa ob"># use random walks to train embeddings<br/>w2v_model = Word2Vec(walks, vector_size=8, window=3, min_count=0, sg=1, workers=1, epochs=1)</span></pre><h1 id="e6d3" class="mb mc iq bd md me mf mg mh mi mj mk ml kf mm kg mn ki mo kj mp kl mq km mr ms bi translated">与ndoe2vec的现有实现相比</h1><p id="8c7e" class="pw-post-body-paragraph lf lg iq lh b li mv ka lk ll mw kd ln lo nj lq lr ls nk lu lv lw nl ly lz ma ij bi translated">尽管node2vec有许多其他现有的实现，包括由Matt Ranger<a class="ae le" href="https://www.singlelunch.com/2019/08/01/700x-faster-node2vec-models-fastest-random-walks-on-a-graph/" rel="noopener ugc nofollow" target="_blank">开发的<a class="ae le" href="https://github.com/VHRanger/nodevectors" rel="noopener ugc nofollow" target="_blank"> nodevectors </a>和由Elior Cohen </a>开发的<a class="ae le" href="https://github.com/eliorc/node2vec" rel="noopener ugc nofollow" target="_blank"> Python3 node2vec </a>，但是它们都没有提供一个系统化的基准来显示到底加速了多少，并且很少处理内存问题。此外，现有的实现都没有显示嵌入的质量控制，尽管在优化代码时容易出错并引入错误，例如在随机漫步生成中，从而降低了所得嵌入的质量。PecanPy提供了嵌入的系统性能基准和质量控制，使用<a class="ae le" href="https://github.com/krishnanlab/PecanPy_benchmarks" rel="noopener ugc nofollow" target="_blank">基准库</a>中设置的工作流程可以完全重现。</p></div><div class="ab cl od oe hu of" role="separator"><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi"/></div><div class="ij ik il im in"><h1 id="570d" class="mb mc iq bd md me ok mg mh mi ol mk ml kf om kg mn ki on kj mp kl oo km mr ms bi translated">参考</h1><p id="1a23" class="pw-post-body-paragraph lf lg iq lh b li mv ka lk ll mw kd ln lo nj lq lr ls nk lu lv lw nl ly lz ma ij bi translated">[1] Grover A .，Leskovec J. (2016) node2vec:网络的可扩展特征学习。在:<em class="nn">第22届ACM SIGKDD知识发现和数据挖掘国际会议论文集</em>，KDD 2016年，第855–864页。美国纽约州纽约市计算机协会。</p><p id="882b" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">[2]刘，Arjun Krishnan，pecan py:<em class="nn">node 2 vec</em>，<em class="nn">生物信息学</em>的快速高效并行Python实现，2021；，btab202，【https://doi.org/10.1093/bioinformatics/btab202 T4】</p></div></div>    
</body>
</html>