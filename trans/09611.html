<html>
<head>
<title>PyCaret + SKORCH: Build PyTorch Neural Networks using Minimal Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">PyCaret + SKORCH:使用最少的代码构建PyTorch神经网络</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/pycaret-skorch-build-pytorch-neural-networks-using-minimal-code-57079e197f33?source=collection_archive---------9-----------------------#2021-09-07">https://towardsdatascience.com/pycaret-skorch-build-pytorch-neural-networks-using-minimal-code-57079e197f33?source=collection_archive---------9-----------------------#2021-09-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e5e9" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用Pycaret构建PyTorch神经网络的低代码指南</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/2e0f3ed9eed135782baecbbaf2640fd1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zZdJl9NOBgocIjH_1K5y7g.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@danist07?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Danist Soh </a>在<a class="ae ky" href="https://unsplash.com/s/photos/build?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="0403" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">几乎在每个机器学习项目中，我们都训练和评估多个机器学习模型。这通常涉及编写多行导入、许多函数调用、打印语句来训练单个模型并比较模型间的结果。当用交叉验证循环比较不同的模型或者组装模型时，代码变得一塌糊涂。随着时间的推移，当我们从分类模型转移到回归模型时，情况会变得更加混乱，反之亦然。我们最终将代码片段从一个地方复制到另一个地方，造成混乱！我们可以通过导入<a class="ae ky" href="https://pycaret.org/" rel="noopener ugc nofollow" target="_blank"> PyCaret </a>轻松避免这种混乱！</p><p id="7124" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">PyCaret是一个低代码的机器库，它允许你在给定一个回归或分类问题的情况下，通过一个统一的API来创建、训练和测试ML模型。PyCaret还提供了机器学习项目中的各种步骤，从数据准备到模型部署，只需最少的代码。它可以与遵循Scikit-Learn API的任何模型/库一起工作，如Scikit-Learn Models、Xgboost、LightGBM、CatBoost等。总而言之，该库是一个易于使用的生产力助推器，可以实现快速实验，并帮助您更多地关注手头的业务问题。</p><p id="ce4a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，如果您想将神经网络添加到您的待试模型列表中，该怎么办？，您需要用PyTorch之类的框架编写用于训练和测试循环的代码片段，将NumPy数组转换为张量，或者反过来让现有的东西工作或编写一套全新的评估函数。一个小的类型错误最终会改变你已经写好的代码的一部分，这可能会产生更多你没有预料到的问题。您最终会花更多的时间更新代码，而不是尝试不同的模型和解决问题。</p><p id="26d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您可以将相同的PyCaret与神经网络一起使用，只需进行非常小的更改，会怎么样？</p><p id="3e15" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">是的，你没听错！SKORCH 让这一切成为可能！SKORCH是PyTorch的Scikit-Learn包装器，它使得用类似sklearn的API训练神经网络成为可能，这正是PyCaret所期望的！</p><p id="f5d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">许多参考资料都在解释如何使用<a class="ae ky" href="https://pycaret.readthedocs.io/en/latest/tutorials.html" rel="noopener ugc nofollow" target="_blank"> Pycaret用一行代码构建ML模型</a>！以及使用<a class="ae ky" href="https://skorch.readthedocs.io/en/latest/user/tutorials.html" rel="noopener ugc nofollow" target="_blank"> SKORCH构建神经网络</a>的教程和示例。建议在进入本博客的下一部分之前浏览这些教程。这个包含代码的<a class="ae ky" href="https://github.com/pranaymodukuru/pycaret-with-skorch/blob/main/pycaret-skorch-example.ipynb" rel="noopener ugc nofollow" target="_blank">笔记本</a>可以并行引用。</p><p id="ec7e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇博客中，我们将看到</p><ul class=""><li id="5c9c" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">如何使用SKORCH建立神经网络</li><li id="28ab" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">如何用PyCaret训练神经网络</li><li id="2529" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">如何用PyCaret调整神经网络</li></ul><p id="4621" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这些步骤中，我们还将看到如何使用PyCaret的oneliners将神经网络的性能与其他模型进行比较。</p><p id="e685" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本教程中，我们将使用“electrical_grid”数据集。这是一个包含12个输入特征和一个目标变量的二元分类问题。该数据集在PyCaret自带的内置数据集中可用，可以通过导入和调用get_data函数来访问，如下所示</p><pre class="kj kk kl km gt mj mk ml mm aw mn bi"><span id="bb91" class="mo mp it mk b gy mq mr l ms mt">from pycaret.datasets import get_data<br/>data = get_data('electrical_grid')</span></pre><p id="f609" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">笔记本中的输出应该是这样的，</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mu"><img src="../Images/411664d2be099c3b96db16d7a9bff17d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*on616qkzmoZ-ZXFxoV64aQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">PyCaret的电网数据(图片由作者提供)</p></figure><h1 id="7162" class="mv mp it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">如何用SKORCH构建神经网络</h1><h2 id="3f10" class="mo mp it bd mw nm nn dn na no np dp ne li nq nr ng lm ns nt ni lq nu nv nk nw bi translated">PyTorchModel</h2><p id="83e8" class="pw-post-body-paragraph kz la it lb b lc nx ju le lf ny jx lh li nz lk ll lm oa lo lp lq ob ls lt lu im bi translated">斯科奇与PyTorch模型合作；我们可以创建一个简单的模型，就像使用纯PyTorch时一样。我们将构建一个如图所示的三层MLP，第一层有12个输入，因为数据中有12个要素，两个类都有两个输出。</p><pre class="kj kk kl km gt mj mk ml mm aw mn bi"><span id="1fa1" class="mo mp it mk b gy mq mr l ms mt">import torch.nn as nn</span><span id="4860" class="mo mp it mk b gy oc mr l ms mt">class Net(nn.Module):<br/>    def __init__(self, num_inputs=12, num_units_d1=200, num_units_d2=100):<br/>        super(Net, self).__init__()</span><span id="a7a5" class="mo mp it mk b gy oc mr l ms mt">        self.dense0 = nn.Linear(num_inputs, num_units_d1)<br/>        self.nonlin = nn.ReLU()<br/>        self.dropout = nn.Dropout(0.5)<br/>        self.dense1 = nn.Linear(num_units_d1, num_units_d2)<br/>        self.output = nn.Linear(num_units_d2, 2)<br/>        self.softmax = nn.Softmax(dim=-1)</span><span id="a92e" class="mo mp it mk b gy oc mr l ms mt">    def forward(self, X, **kwargs):<br/>        X = self.nonlin(self.dense0(X))<br/>        X = self.dropout(X)<br/>        X = self.nonlin(self.dense1(X))<br/>        X = self.softmax(self.output(X))<br/>        return X</span></pre><h2 id="3f77" class="mo mp it bd mw nm nn dn na no np dp ne li nq nr ng lm ns nt ni lq nu nv nk nw bi translated">斯科奇分类器</h2><p id="d4dc" class="pw-post-body-paragraph kz la it lb b lc nx ju le lf ny jx lh li nz lk ll lm oa lo lp lq ob ls lt lu im bi translated">现在我们已经定义了网络架构，我们必须用SKORCH实例化一个sklearn兼容的神经网络，这是通过从skorch导入NeuralNetClassifier来完成的。我们正在进行分类工作。</p><pre class="kj kk kl km gt mj mk ml mm aw mn bi"><span id="de70" class="mo mp it mk b gy mq mr l ms mt">from skorch import NeuralNetClassifier</span><span id="29bb" class="mo mp it mk b gy oc mr l ms mt">net = NeuralNetClassifier(<br/>    module=Net,<br/>    max_epochs=30,<br/>    lr=0.1,<br/>    batch_size=32,<br/>    train_split=None<br/>)</span></pre><p id="2abc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">需要传递的最重要的参数是采用nn名称的模块。模块定义的，在这种情况下，我们传递Net给它。类似地，我们可以传递其他参数max_epochs来指示训练模型的次数，以及“lr”优化器的学习速率batch_size。设置小批量大小。我们将坚持使用Skorch中使用的默认SGD优化器，并且可以将其更改为任何自定义优化器，如这里的<a class="ae ky" href="https://skorch.readthedocs.io/en/latest/user/neuralnet.html#optimizer" rel="noopener ugc nofollow" target="_blank">所解释的</a>。</p><p id="e8a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Skorch默认使用5重交叉验证。因此，每次分割有80%的训练样本和20%的验证样本。这可以通过传递train_split=None来禁用，我们将这样做，因为我们将使用PyCaret来训练模型，py caret已经使用交叉验证来训练模型。</p><h1 id="6650" class="mv mp it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">如何用PyCaret训练神经网络</h1><h2 id="13f8" class="mo mp it bd mw nm nn dn na no np dp ne li nq nr ng lm ns nt ni lq nu nv nk nw bi translated">数据帧转换器</h2><p id="d227" class="pw-post-body-paragraph kz la it lb b lc nx ju le lf ny jx lh li nz lk ll lm oa lo lp lq ob ls lt lu im bi translated">现在我们已经初始化了一个SKORCH NN模型，我们可以用PyCaret来训练这个模型。这里我们必须记住的一件事是PyCaret天生适合熊猫。DataFrames，但是在Skorch模型中，它无法将数据直接传递给模型。(更多关于它的内容<a class="ae ky" href="https://github.com/pycaret/pycaret/issues/700#issuecomment-757488589" rel="noopener ugc nofollow" target="_blank">这里</a>)因此，我们需要用一个sko rch . helper . data frame transformer构造一个sklearn管道nn_pipe，将PyCaret传递的输入转换成除模型之外所需的格式。感谢<a class="ae ky" href="https://github.com/pycaret/pycaret/issues/700#issuecomment-879700610" rel="noopener ugc nofollow" target="_blank">孵化器Shokuhou </a>发现了这一点。</p><pre class="kj kk kl km gt mj mk ml mm aw mn bi"><span id="a8a6" class="mo mp it mk b gy mq mr l ms mt">from skorch.helper import DataFrameTransformer</span><span id="a62b" class="mo mp it mk b gy oc mr l ms mt">nn_pipe = Pipeline(<br/>    [<br/>        ("transform", DataFrameTransformer()),<br/>        ("net", net),<br/>    ]<br/>)</span></pre><h2 id="7790" class="mo mp it bd mw nm nn dn na no np dp ne li nq nr ng lm ns nt ni lq nu nv nk nw bi translated">PyCaret设置</h2><p id="9bef" class="pw-post-body-paragraph kz la it lb b lc nx ju le lf ny jx lh li nz lk ll lm oa lo lp lq ob ls lt lu im bi translated">现在我们终于准备好了我们的模型，可以训练它了，因为我们已经决定使用PyCaret来训练模型，而不是Skorch API。让我们快速了解一下PyCaret。在使用PyCaret训练任何模型之前，我们需要通过调用setup函数来启动一个实验，该函数执行所有的预处理步骤，当然，可以借助传递给函数的参数来控制这些步骤。</p><pre class="kj kk kl km gt mj mk ml mm aw mn bi"><span id="0be2" class="mo mp it mk b gy mq mr l ms mt">from pycaret.classification import *</span><span id="d251" class="mo mp it mk b gy oc mr l ms mt">target = "stabf"<br/>clf1 = setup(data = data, <br/>            target = target,<br/>            train_size = 0.8,<br/>            fold = 5,<br/>            session_id = 123,<br/>            log_experiment = True, <br/>            experiment_name = 'electrical_grid_1', <br/>            silent = True)</span></pre><p id="2f66" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们传递数据、目标列名、train_size、交叉验证中使用的折叠数作为设置的主要参数。我们将log_experiment设置为True，以跟踪MLFlow的实验，并设置一个experiment_name，以便我们可以在稍后阶段返回并引用结果。此外，我们将把silent参数设置为True，以避免设置阶段的“按enter继续”步骤。</p><h2 id="8c7e" class="mo mp it bd mw nm nn dn na no np dp ne li nq nr ng lm ns nt ni lq nu nv nk nw bi translated">PyCaret训练ML模型</h2><p id="57f3" class="pw-post-body-paragraph kz la it lb b lc nx ju le lf ny jx lh li nz lk ll lm oa lo lp lq ob ls lt lu im bi translated">为了训练一个ml模型，我们可以用我们想要训练的模型的缩写来调用create_model函数。在这种情况下，我们可以使用create_model("rf ")来训练一个随机的森林分类器。</p><pre class="kj kk kl km gt mj mk ml mm aw mn bi"><span id="d67c" class="mo mp it mk b gy mq mr l ms mt">model = create_model("rf")</span></pre><p id="c388" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，PyCaret使用默认参数实例化RandomForestClassifier，并在五个折叠上训练模型，并打印结果，如下所示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi od"><img src="../Images/68391b607f45d02a6123a7fd2213ba2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:972/format:webp/1*oatJIzUvK1fE82LQquehMQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="3e5a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">经过训练的RandomForestClassifier现在存储在变量模型中，我们将在后面使用它。</p><h2 id="1025" class="mo mp it bd mw nm nn dn na no np dp ne li nq nr ng lm ns nt ni lq nu nv nk nw bi translated">PyCaret火车斯科奇模型</h2><p id="7b98" class="pw-post-body-paragraph kz la it lb b lc nx ju le lf ny jx lh li nz lk ll lm oa lo lp lq ob ls lt lu im bi translated">现在我们已经知道PyCaret是如何工作的，让我们来训练我们已经实例化的Skorch模型。Pycaret的好处是create_model接受任何Sklearn API兼容的对象。因此，我们可以将上面创建的nn_pipe传递给create_model函数，如下所示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/b1601e6470b394d3c53be93a387989de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1002/format:webp/1*COGExl9Ef7X2Qh8SMrkODA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="d974" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，create_model采用skorch模型，在五折上训练模型，并打印结果。并且被训练的skorch模型现在被保存在变量skorch_model中。</p><h2 id="3534" class="mo mp it bd mw nm nn dn na no np dp ne li nq nr ng lm ns nt ni lq nu nv nk nw bi translated">比较模型</h2><p id="0959" class="pw-post-body-paragraph kz la it lb b lc nx ju le lf ny jx lh li nz lk ll lm oa lo lp lq ob ls lt lu im bi translated">现在我们可以通过将它们作为一个列表传递给PyCaret中的compare_models函数来比较这两个模型。“比较模型”功能现在将在交叉验证折叠上训练两个模型，并记录平均cv分数，以在所需指标上比较模型。我们可以通过向sort参数传递一个字符串来设置所需的度量；让我们在例子中使用“AUC”。</p><pre class="kj kk kl km gt mj mk ml mm aw mn bi"><span id="fe1e" class="mo mp it mk b gy mq mr l ms mt">best_model = compare_models(include=[skorch_model, rf_model], sort="AUC"</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/6f0a2f00cea427b84c6146f7d9e8fa66.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*20Xv1S_iI48tMdwf-u4kFQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><h1 id="805e" class="mv mp it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">如何用SKORCH调整神经网络</h1><h2 id="2372" class="mo mp it bd mw nm nn dn na no np dp ne li nq nr ng lm ns nt ni lq nu nv nk nw bi translated">设置超参数网格</h2><p id="a776" class="pw-post-body-paragraph kz la it lb b lc nx ju le lf ny jx lh li nz lk ll lm oa lo lp lq ob ls lt lu im bi translated">现在我们知道了如何训练神经网络，让我们看看如何调整超参数。在这种情况下，我们将调整隐藏密集层中的神经元数量、学习速率、优化器和历元数量。为此，我们需要创建一个自定义的超参数网格，如下所示。</p><pre class="kj kk kl km gt mj mk ml mm aw mn bi"><span id="8633" class="mo mp it mk b gy mq mr l ms mt">custom_grid = {<br/>	'net__max_epochs':[20, 30],<br/>	'net__lr': [0.01, 0.05, 0.1],<br/>	'net__module__num_units_d1': [50, 100, 150],<br/>	'net__module__num_units_d2': [50, 100, 150],<br/>	'net__optimizer': [optim.Adam, optim.SGD, optim.RMSprop]<br/>	}</span></pre><p id="9592" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，模块名和参数由双“__”分隔，因为这是NeuralNetClassifier期望传递参数的方式，以便它可以实例化所需的模块。同样，这里的“net”表示我们从NeuralnetClassifier创建的Net变量，“module”表示我们为Pytorch模型创建的Net模块。</p><p id="47d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果想知道模型的参数列表，可以通过执行estimator.get_params()来查看。按键()。其中，估计量是变量skorch_model，在本例中是skorch_model.get_params()。keys()打印以下输出，</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/c5de76230d354f8c9a19513156271660.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*viV6Fa2TgDP5Ewtpma55fw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="f0ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，参数net__module__num_units_d1/2没有出现在打印输出中，因为它们不是skorch_model的参数，而是net的参数；因此，需要用net__module__**对它们进行设置。</p><h2 id="7753" class="mo mp it bd mw nm nn dn na no np dp ne li nq nr ng lm ns nt ni lq nu nv nk nw bi translated">调谐</h2><p id="e715" class="pw-post-body-paragraph kz la it lb b lc nx ju le lf ny jx lh li nz lk ll lm oa lo lp lq ob ls lt lu im bi translated">在设置了超参数网格之后，我们必须从pycaret调用tune_model函数，并传入模型和custom_grid作为调优的参数。在这里，我们也可以从PyCaret支持的各种调优算法/库中进行选择，这些算法/库在<a class="ae ky" href="https://pycaret.readthedocs.io/en/latest/api/classification.html#pycaret.classification.tune_model" rel="noopener ugc nofollow" target="_blank">文档</a>中列出。</p><pre class="kj kk kl km gt mj mk ml mm aw mn bi"><span id="e2d5" class="mo mp it mk b gy mq mr l ms mt">tuned_skorch_model = tune_model(skorch_model, custom_grid=custom_grid)</span></pre><p id="22cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就是这样！现在将开始模型调整。要有耐心；根据网络大小、数据集大小等，这可能需要一些时间。调整完成后，您将再次看到交叉验证分数，如下所示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/0067220899d3123736af9027972a174c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1212/format:webp/1*PODvhtMWTb7QQMTProGQgw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="1ad9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">tune_model()函数返回已调优的模型，该模型现在在tuned_skorch_model变量中可用。</p><h2 id="d9de" class="mo mp it bd mw nm nn dn na no np dp ne li nq nr ng lm ns nt ni lq nu nv nk nw bi translated">比较模型</h2><p id="037c" class="pw-post-body-paragraph kz la it lb b lc nx ju le lf ny jx lh li nz lk ll lm oa lo lp lq ob ls lt lu im bi translated">同样，我们可以通过将这些模型作为列表传递给PyCaret中的compare_models函数来比较它们。</p><pre class="kj kk kl km gt mj mk ml mm aw mn bi"><span id="9891" class="mo mp it mk b gy mq mr l ms mt">best_model = compare_models(include=[tuned_skorch_model, skorch_model, rf_model], sort="AUC")</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/9b9ed1b477d523e0f7b681027caceedc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JpucrdNRSadgXHSHO230Dg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="c046" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不幸的是，没有将模型名称作为参数传递的选项。因此，tuned_skorch_model和skorch_model都被命名为NeuralNetClassifier(由PyCaret自动识别)。我假设第二行是优化的模型，第三行是未优化的模型。</p><p id="b032" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，这篇博客主要展示了我们如何使用Skorch和Pycaret来用最少的代码构建PyTorch模型。它并不特别关注于提高模型性能。</p><p id="994c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注:</strong></p><ol class=""><li id="05c9" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu oj mb mc md bi translated">在这里，compare_models函数在create_model或tuned_model之后使用，但是pycaret建议将compare_models用作比较所有可用模型的第一步。但这里的目的是说明如何使用Skorch+Pytorch。因此，在这种情况下，处理方式不同。一般来说，为了在训练后比较不同的模型，我们可以编写一个自定义的包装器函数。我们可以传递一个模型列表和要评估的数据来获得比较分数。</li></ol><h1 id="f79a" class="mv mp it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">MLFlow仪表板</h1><p id="e80b" class="pw-post-body-paragraph kz la it lb b lc nx ju le lf ny jx lh li nz lk ll lm oa lo lp lq ob ls lt lu im bi translated">因为我们已经在PyCaret设置中将log_experiment设置为True，所以所有的实验都用MLFlow记录，而不需要我们做任何事情！瞧啊。要查看所有实验，请在工作目录中打开一个终端，并键入mlflow ui。通过点击终端中显示的URL，您应该可以在浏览器中看到这一点。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ok"><img src="../Images/fba40e969382943db1e7ecce008c41ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PC_AZnnK5lcmRyEWoXuBdg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="011e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上图是我们在笔记本上运行的所有实验。</p><h1 id="20cf" class="mv mp it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">结论</h1><p id="43b5" class="pw-post-body-paragraph kz la it lb b lc nx ju le lf ny jx lh li nz lk ll lm oa lo lp lq ob ls lt lu im bi translated">我们看到了Skorch和PyCaret如何用最少的代码训练神经网络，并利用相同的API训练传统的ML模型和神经网络。此外，我们可以用一行代码比较所有模型的性能，并用一个参数保存所有保存到MLFlow中的指标！我强烈推荐阅读官方的<a class="ae ky" href="https://pycaret.org/" rel="noopener ugc nofollow" target="_blank"> PyCaret </a>和<a class="ae ky" href="https://github.com/skorch-dev/skorch" rel="noopener ugc nofollow" target="_blank"> Skorch </a>文档，了解更多关于如何使用这些神奇的库并使ML实验更容易！</p><h1 id="43d1" class="mv mp it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">参考</h1><ol class=""><li id="befb" class="lv lw it lb b lc nx lf ny li ol lm om lq on lu oj mb mc md bi translated"><a class="ae ky" href="https://pycaret.org/" rel="noopener ugc nofollow" target="_blank">https://pycaret.org/</a></li><li id="8a36" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu oj mb mc md bi translated"><a class="ae ky" href="https://www.analyticsvidhya.com/blog/2020/05/pycaret-machine-learning-model-seconds/" rel="noopener ugc nofollow" target="_blank">https://www . analyticsvidhya . com/blog/2020/05/py caret-machine-learning-model-seconds/</a></li><li id="8367" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu oj mb mc md bi translated"><a class="ae ky" href="https://github.com/skorch-dev/skorch" rel="noopener ugc nofollow" target="_blank">https://github.com/skorch-dev/skorch</a></li><li id="14dc" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu oj mb mc md bi translated"><a class="ae ky" rel="noopener" target="_blank" href="/skorch-pytorch-models-trained-with-a-scikit-learn-wrapper-62b9a154623e">https://towards data science . com/s korch-py torch-models-trained-with-a-scikit-learn-wrapper-62b 9a 154623 e</a></li></ol></div></div>    
</body>
</html>