<html>
<head>
<title>Full Deep Learning Portfolio Project Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">完整的深度学习组合项目第1部分</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/full-deep-learning-portfolio-project-part-1-78df161214aa?source=collection_archive---------14-----------------------#2021-10-26">https://towardsdatascience.com/full-deep-learning-portfolio-project-part-1-78df161214aa?source=collection_archive---------14-----------------------#2021-10-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="614b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">系统地寻找鸟类图像分类任务的最佳训练策略</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/8ccbcee15f72e92b6a8f79de63d6679b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*d-dnaw9mIfwNqHya"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">托马斯·列斐伏尔在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><h1 id="ffa1" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">介绍</h1><p id="9fc8" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">想从事机器学习工程师的工作，但从未实际从事过机器学习项目？然后找工作真的不容易。大多数公司都在寻找有经验的机器学习工程师。我所说的经验并不是指你参加过机器学习在线课程。不要误解我的意思:参加机器学习在线课程以获得更多关于该主题的知识总是很棒的！然而，对于一个雇主来说，正确地评估一门在线课程是非常困难的。有些很容易，有些很有挑战性。然而，雇主能评估好的是自己的项目。在那里，他可以直接看到你如何处理某些话题，以及你已经从项目中获得了什么经验。</p><p id="dbe0" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">然而，在这些项目中，你不应该只关注机器学习部分，这主要是在Jupyter笔记本上完成的，但你也应该考虑部署。因为现在训练深度学习模型不再具有挑战性。像Keras这样的库允许你在几行代码内创建和训练一个深度学习模型。然而，如果你能够开发一个成熟的应用程序，那么你肯定会更有趣。此外，如果你已经开发了一个网页，并可以在那里展示你训练有素的模型，而不是让他浏览你的Jupyter笔记本，在那里只能看到代码和打印输出，那么你可以更好地说服一个没有技术背景的招聘人员。</p><p id="f731" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">为此，我创作了两篇文章，其中系统地发现并应用了深度学习训练策略，并通过网站部署了训练好的模型。</p><p id="b16f" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在这个系列的第一部分，我想向你展示一个如何为图像分类任务找到一个好模型的系统方法。作为数据集，我决定使用来自Kaggle的开源鸟类物种数据集，你可以在这里找到<a class="ae ky" href="https://www.kaggle.com/gpiosenka/100-bird-species" rel="noopener ugc nofollow" target="_blank"/>。代码和所有文档都可以在我的Github页面<a class="ae ky" href="https://github.com/patrickbrus/Birds_Classifier_API" rel="noopener ugc nofollow" target="_blank">这里</a>找到。代码是用Python写的。</p><p id="0555" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在本系列的第二部分，我将向您展示如何使用html和Flask开发一个完整的web应用程序，包括前端和后端。你可以在这里找到文章<a class="ae ky" rel="noopener" target="_blank" href="/full-deep-learning-portfolio-project-part-2-e37d09a451fa"/>。</p><p id="f559" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">如果你对我如何使用Docker和Github Actions将完整的web应用程序部署到AWS Elastic Beanstalk感兴趣，那么我可以推荐你阅读我的这篇文章。</p><h1 id="022b" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">内容</h1><p id="6a8b" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在第一部分中，我介绍了数据集，并已经对输入数据进行了一些预处理。在第二部分，我将向您展示我如何使用Tensorflow创建输入管道，以及它的代码是什么样子。方法部分描述了我为找到最佳训练策略而进行的各种评估。每当要训练CNN时，可以使用这些评估。结果部分显示了最终培训策略的培训结果。结论部分总结了这个项目的结果，而展望部分提供了本系列第二篇文章的参考。</p><h1 id="f456" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">探索性数据分析和预处理</h1><p id="b0f3" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">作为第一步，我将提供的“Bird_Species.csv”文件加载到pandas数据框中(图1)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/b28c3a909d703725bce1f7dd8d3b62d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1166/format:webp/1*K7Kkk9TbcOKF6uytaIh-PQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图1:初始加载的数据帧头。</p></figure><p id="2abb" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">数据集的创建者还提供了第二个csv文件，包含图像的类和一些元数据。我还将这个csv文件加载到pandas数据框中(图2)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/9124295f457c3ea7eb48e109e75d2e07.png" data-original-src="https://miro.medium.com/v2/resize:fit:962/format:webp/1*HVc5UfOkcnHa-HBV9WWdww.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图2:包含类和图像形状的数据帧的头部。</p></figure><p id="2092" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">然后，我使用第二个数据框快速检查了该数据集中不同类的数量，并将其与“Bird_Species.csv”文件(代码1)中唯一标签的数量进行了比较。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mu mv l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码1:读入数据文件并检查所有的类是否都存在于完整的数据集中。</p></figure><p id="63ec" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">有趣的是，根据“class_dict.csv”文件，鸟类有300个不同的类别，但在整个数据集中，只有285个不同的类别。因此，我检查了哪些类没有出现在数据集中，并查看了文件夹，以确定它们是真的没有出现，还是只是在“Bird_Species.csv”文件中丢失了。确实有缺失班级的图片。这意味着现有的csv文件不正确。所以我首先创建了一个干净的csv文件，保存它并在这个项目的其余部分使用它。这一步的代码可以在“Make_Clean_Dataset.ipynb”笔记本<a class="ae ky" href="https://github.com/patrickbrus/Birds_Classifier_API/blob/master/Make_Clean_Dataset.ipynb" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><p id="4c62" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">既然数据集是干净的，我开始进一步研究它。我从绘制数据集的一些随机示例图像开始，以便对图像的外观有所了解。图3显示了两个示例鸟图像。</p><div class="kj kk kl km gt ab cb"><figure class="mw kn mx my mz na nb paragraph-image"><img src="../Images/09c55316dbe3abd24dd4574fb118cbab.png" data-original-src="https://miro.medium.com/v2/resize:fit:448/format:webp/1*dZy2AbG65yjblaCAT6gh8g.jpeg"/></figure><figure class="mw kn mx my mz na nb paragraph-image"><img src="../Images/b4b86f6387097e63ac159ccbe727b9e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:448/format:webp/1*FsS_d8Nxp6tFxFi-cqtAkg.jpeg"/><p class="ku kv gj gh gi kw kx bd b be z dk nc di nd ne translated">图3:鸟类数据集的两个示例图像。左图是一只非洲冠鹤，右图是一只冈比亚鹌鹑。</p></figure></div><p id="beef" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">作为下一步，我绘制了已经由作者创建的训练和测试集的分布图(图4和图5)。这对于检查数据集是否不平衡以及确保测试分布和训练分布大致相同非常重要。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nf"><img src="../Images/b66e78b1aeb01aaca80c8627f7c1d094.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Rotm5JexGmgHksMvVgDfCw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图4:从数据集作者创建的训练集的分布。</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/91cda2391e6ba25c1e261fb1166620f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6mNvxLX8i5m3zTc_S6Fyvw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图5:从数据集作者创建的测试集的分布。</p></figure><p id="b945" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">可以看出，训练集是不平衡的，而测试集是完全平衡的。这清楚地表明测试集来自不同于训练集的分布。这可能会导致模型在测试集上表现良好，但在真实世界数据上表现不佳，因为测试分布没有反映“真实”分布。因此，我决定使用Scikit-Learn的分层混洗技术创建自己的训练、验证和测试集。但是在分割数据之前，我还对标签进行了一次性编码，以匹配CNN所需的输入格式。代码2显示了这些步骤的代码，包括清理后的数据集csv文件的初始加载。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mu mv l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码2:用于通过执行分层混洗分割来创建训练、验证和测试集的代码。</p></figure><p id="437f" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">图6和图7显示了分层洗牌拆分后训练集和测试集的分布。这两个发行版现在来自同一个发行版。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nh"><img src="../Images/bd0952dfe3ee209fc1e52608879e4d8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RNsk_XXBVn-Wf5V5il3kIw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图6:使用分层洗牌拆分后的训练集分布。</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ni"><img src="../Images/bb6d4b9f24cc42d3e3cd49a95573869e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IxxBPuNJlXEIjbzYyAZteA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图7:使用分层洗牌拆分后测试集的分布。</p></figure><p id="7008" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">训练数据集有点不平衡，这应该不是问题。但是让我们稍后检查过采样是否可以提高这个数据集的性能。</p><p id="6564" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这里没有添加验证集的数字，但是它与测试集和训练集具有相同的分布。</p><h1 id="e018" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">创建输入管道</h1><p id="0396" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">对于训练深度学习模型来说，拥有一个好的输入管道总是很重要的。Tensorflow通过其ImageDataGenerator类为您提供了很好的支持。这个类允许您指定一些预处理，让您从一些数据扩充中选择，并允许您在训练期间批量加载图像。这一点尤其重要，因为对于大型数据集，如果在训练之前必须先加载一次所有图像，将会占用大量RAM。</p><p id="fb7a" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">对于鸟类分类，我创建了以下输入管道步骤:</p><ol class=""><li id="a301" class="nj nk it lt b lu mn lx mo ma nl me nm mi nn mm no np nq nr bi translated">应用一些随机选择的数据扩充，这样大约10%的数据没有被扩充。</li><li id="91ee" class="nj nk it lt b lu ns lx nt ma nu me nv mi nw mm no np nq nr bi translated">归一化图像像素值，使它们在(0，1)的范围内。</li></ol><p id="bf88" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我使用了一些来自<a class="ae ky" href="https://imgaug.readthedocs.io/en/latest/index.html" rel="noopener ugc nofollow" target="_blank"> imgaug </a> Python库的基本数据扩充，以增加数据集中的变化。这个库非常有用，因为它实现了几乎所有你能想到的扩充。本项目使用的数据扩充是通过对示例图像应用扩充并评估图像是否仍然有意义来手动选择的。在上面提到的Github存储库中，可以在Jupyter笔记本中看到不同应用增强的评估结果，称为“Check Augmentations.ipynb”。一般来说，可以使用这些增强，并且可以一次用一个额外的增强来训练模型，并且将其性能与没有任何增强的基线模型进行比较。但是为了这个项目，我决定不做这个评估，因为我假设每一个增强都会导致与基线模型相比的改进。</p><p id="51ab" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我使用了以下扩展(图8):</p><ol class=""><li id="b376" class="nj nk it lt b lu mn lx mo ma nl me nm mi nn mm no np nq nr bi translated">左右翻转图像。</li><li id="9f36" class="nj nk it lt b lu ns lx nt ma nu me nv mi nw mm no np nq nr bi translated">将像素值乘以偏移量。</li><li id="acb5" class="nj nk it lt b lu ns lx nt ma nu me nv mi nw mm no np nq nr bi translated">盐和胡椒。</li><li id="a2d4" class="nj nk it lt b lu ns lx nt ma nu me nv mi nw mm no np nq nr bi translated">伽玛对比度变化。</li><li id="c780" class="nj nk it lt b lu ns lx nt ma nu me nv mi nw mm no np nq nr bi translated">向像素值添加偏移量。</li><li id="4c5a" class="nj nk it lt b lu ns lx nt ma nu me nv mi nw mm no np nq nr bi translated">添加附加高斯噪声。</li><li id="736c" class="nj nk it lt b lu ns lx nt ma nu me nv mi nw mm no np nq nr bi translated">应用运动模糊。</li><li id="4fc7" class="nj nk it lt b lu ns lx nt ma nu me nv mi nw mm no np nq nr bi translated">应用仿射变换。</li><li id="003d" class="nj nk it lt b lu ns lx nt ma nu me nv mi nw mm no np nq nr bi translated">旋转图像。</li><li id="84c0" class="nj nk it lt b lu ns lx nt ma nu me nv mi nw mm no np nq nr bi translated">应用弹性变换。</li></ol><p id="fc0f" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">增强“添加”和“伽玛对比度”从不同时使用，因为这可能导致不真实的图像。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/4401b337e0fc29e2008944bf63085652.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cVd1l5aJUnhPnFXl6BCCFw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图8:应用增强的概述(图片由作者提供)。</p></figure><p id="112e" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">代码3展示了创建输入管道的完整Python代码，同时使用了Tensorflow的“flow_from_dataframe”选项。这允许在训练期间分批加载图像。您只需要一个csv文件，其中第一列包含图像的名称，其他列包含该图像的标签。为了首先找到最佳的CNN架构，我决定使用8的批量大小，并将图像的大小固定为(224，224)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mu mv l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码3:使用Tensorflow和ImageDataGenerator类创建输入管道的代码。</p></figure><h1 id="b8f2" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">方法学</h1><p id="15c9" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">输入管道已创建。现在是时候找到最适合的训练策略了。首先，比较了一些最先进的CNN架构，并选择性能最佳的架构作为本项目剩余部分的架构。其次，比较不同的图像尺寸，以便找到最佳的图像尺寸。第三步，尝试过采样来处理稍微不平衡的数据集。最后一步，使用贝叶斯超参数搜索来搜索最优超参数。</p><p id="bf89" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">方法部分的代码没有包含在本文中，因为它太长了。请随意检查我的<a class="ae ky" href="https://github.com/patrickbrus/Birds_Classifier_API/blob/master/DeepLearning_Project.ipynb" rel="noopener ugc nofollow" target="_blank"> Github Jupyter笔记本</a>，查看并复制我创建的代码。我只包含了对数据帧进行过采样的代码，因为这可能是更有趣的代码部分。</p><h2 id="7c05" class="ny la it bd lb nz oa dn lf ob oc dp lj ma od oe ll me of og ln mi oh oi lp oj bi translated">CNN架构比较</h2><p id="7aad" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">有许多不同的CNN架构可用于鸟类分类器。在本项目中，选择了六种不同的CNN架构(表2)并进行相互比较。每种架构都用于训练具有表1中给出的超参数的鸟分类器。最后，最佳验证f1分数被存储并用于找到最佳CNN架构。这里，仅使用最佳验证f1分数，并且忽略了这一点，即每个体系结构具有不同的训练复杂性，并且可能一个体系结构仅导致稍差的验证f1分数，但是具有比达到更高验证f1分数的模型少得多的参数。但是对于未来的优化，也可以考虑训练复杂度，并且可以将其包括在决定中，将哪个编码器架构用于最终的鸟分类器。表2还显示了最终结果。可以看出，DenseNet121实现了最佳的f1验证分数，因此被用作鸟类分类器的最终编码器架构，也用于该项目的其他评估。图5显示了不同编码器在训练过程中的f1分数，图4显示了训练过程中的损失值。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/94595a9e47e971e0fc1ed563da5e40dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:612/format:webp/1*n4LALhfnI7o3jMZNjmj5Wg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">表1:用于CNN架构比较的超参数。</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ol"><img src="../Images/4210c16cac2de809e529bfea5e3e642b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BplBS_BOBwjIZPgHmRiOjw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图4:不同编码器架构的训练过程中的损耗值。使用分类交叉熵作为损失函数。</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi om"><img src="../Images/ee7a3217fbfbb4ad30ef65a72d198a56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZfF6Q2bXgKkrNrn4QdMIXg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图5:F1-不同编码器架构训练过程中的得分。</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi on"><img src="../Images/95766ca28cbb41e10983547d9b05b071.png" data-original-src="https://miro.medium.com/v2/resize:fit:764/format:webp/1*FADaACSItNSGsArBVK5CzQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">表2:在训练过程中使用的CNN架构和它们的最好成绩。</p></figure><h2 id="0ed9" class="ny la it bd lb nz oa dn lf ob oc dp lj ma od oe ll me of og ln mi oh oi lp oj bi translated">图像大小比较</h2><p id="d09a" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在通往最佳训练策略的道路上，接下来应该找到最佳图像尺寸。将评估和比较四个不同的选项。使用表1中的超参数为四种图像尺寸中的每一种训练DenseNet。结果可以在表3中找到，其中再次将最佳验证f1分数作为决策的衡量标准。图6和7显示了在不同图像尺寸的训练过程中f1分数和损失值的结果。</p><p id="c10b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">正如人们所猜测的:图像越大，模型的性能越好。然而，从图像大小192x192到224x224，最佳验证f1分数仅增加0.4%。因此，我决定使用192x192作为图像大小，以便减少可训练参数的数量，并稍微加快训练过程。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oo"><img src="../Images/eeb5939dee8054628efe6e1d4571aa85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eufU3aYvdP9o-qQ1k48ngw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图6:F1-在用不同图像尺寸训练DenseNet的训练过程中的分数。</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/c7438a7697477e37508b1063c849f929.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dMedUxvMaGoQbBWulTjCVw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图7:用不同图像尺寸训练DenseNet的训练过程中的损失值。使用分类交叉熵作为损失函数。</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/9e94024946d4540e96baec7ebe3a2159.png" data-original-src="https://miro.medium.com/v2/resize:fit:698/format:webp/1*w7fzoobiJdPEyzam8E_4tQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">表3:最佳验证f1-用不同图像尺寸训练DenseNet的得分和准确度。</p></figure><h2 id="df82" class="ny la it bd lb nz oa dn lf ob oc dp lj ma od oe ll me of og ln mi oh oi lp oj bi translated">过采样</h2><p id="2863" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">如前所述，数据集略有不平衡。因此，可以使用过采样来更好地平衡数据集，并避免模型更偏向多数类而预测少数类不太准确的风险(图8，代码4)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mu mv l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码4:获取数据帧并对其进行过采样以获得完全平衡的数据帧的代码。过采样是通过对少数类更频繁地重用图像来实现的。</p></figure><p id="b122" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">然后使用过采样数据集和来自表1的超参数来训练DenseNet121，除了时期的数量减少到20个时期。这是由于过采样，因此是模型应该学习得更快的原因，因为相同的图像在一个训练时期内不止一次可用。过采样模型的最佳验证f1分数为95.4%，这与没有应用过采样的情况几乎相同。因此，过采样不用于训练最终的鸟类分类器，因为它也需要更多的训练时间，并且通常更容易过拟合。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi or"><img src="../Images/e8e7c02648517c366dc37e205b0c8bdb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1vj_Gk-Th4ZY-nT7oKOSSQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图8:应用过采样后的训练数据集。训练集现在完全平衡，这是通过复制少数类的相同图像来实现的，只要每个类具有相同数量的样本。</p></figure><h2 id="d849" class="ny la it bd lb nz oa dn lf ob oc dp lj ma od oe ll me of og ln mi oh oi lp oj bi translated">贝叶斯超参数搜索</h2><p id="510d" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">作为找到最佳训练策略的最后一步，使用贝叶斯超参数搜索来优化超参数。贝叶斯搜索的优点在于，它在寻找最优超参数方面比随机搜索更有效，并且比网格搜索需要更少的迭代。κ为3的高斯过程被用作优化策略。手动提供四个初始点，这将有助于将优化过程引向最佳方向。贝叶斯优化被执行12次迭代。使用称为“置信下限”的获取函数，并且它获得最佳验证f1分数作为要优化的度量。置信下限试图最小化其优化度量。因此，使用负的最佳验证f1分数。表4显示了超参数使用的搜索空间，而表5显示了最佳参数。衰减率指定学习率在每个衰减步骤时期应该减少多少。</p><p id="18b1" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">图9显示了贝叶斯超参数搜索的收敛图。可以看出，最佳参数是在最后一次迭代中找到的。这是由于贝叶斯优化的性质。在开始阶段，存在大量的不确定性，Bayes模型在非最优区域采样较多。但是最后，模型在最佳区域中采样更多，因此找到越来越好的参数。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi os"><img src="../Images/6a64b301d8e48ce1e6734d62370544fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:702/format:webp/1*D5D1OnETX8UcBOT0rZvYeg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">表4:贝叶斯超参数优化的优化超参数及其搜索空间。</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/966bbe6affc2978e2a6bad3c2b6b909a.png" data-original-src="https://miro.medium.com/v2/resize:fit:744/format:webp/1*j8CdPbHm_cNeno0BnG-mPA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">表5:通过贝叶斯超参数搜索找到的最佳超参数。</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/d2e917917cdd0d4ad2e3e4d43c9a7123.png" data-original-src="https://miro.medium.com/v2/resize:fit:1086/format:webp/1*7kKpINDjfp5sOowjBR-dOA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图9:贝叶斯优化的收敛图。该图显示了迭代次数和获得的最佳f1分数。</p></figure><h1 id="d403" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">结果</h1><p id="4dd5" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">使用在方法部分中找到的所有发现来训练鸟类分类器。鸟类分类器现在已经训练了30个时期，根据验证f1分数的最佳模型被存储为Tensorflow模型(图10)。之后，加载验证f1分数为96.2%的最佳模型，并在保留测试集上进行评估，以检查最终birds分类器在真实世界数据上的性能。最佳模型在保留测试集上获得了几乎96%的f1分数，这与在训练过程中获得的最佳验证f1分数几乎相同。这表明，该模型在真实世界数据上表现得非常好，并且该模型在训练和验证数据上没有过度拟合。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ov"><img src="../Images/3133ce2698f7e9fc07a6fab2000059bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zp3mCx1gvpgFbZ4gTsfBjA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图10:用于训练最终鸟类分类器的训练指标。</p></figure><h1 id="7bf9" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">结论</h1><p id="0184" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">最终的鸟类分类器在保留测试集上实现了几乎96%的f1分数。由于其良好的性能，DenseNet121被用作CNN的底层架构。作为目标图像尺寸，使用192x192像素的尺寸。训练集不是过采样的，因为在过采样的训练集上训练的模型与在非过采样的训练集上训练的模型获得了近似相同的验证f1分数。利用贝叶斯超参数搜索优化了一些超参数。</p><h1 id="c7d3" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">观点</h1><p id="80e0" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在本系列的第二部分中，我开发了一个API，前端用HTML编写，后端应用程序使用Python库Flask。如果你对它的工作原理感兴趣，请阅读第二篇文章。你可以在这里找到第二篇<a class="ae ky" rel="noopener" target="_blank" href="/full-deep-learning-portfolio-project-part-2-e37d09a451fa">。总的来说，我总是建议您将最终的机器学习应用程序嵌入到可部署的应用程序中，因为这是机器学习工程师在一天结束时需要考虑的问题。</a></p></div><div class="ab cl ow ox hx oy" role="separator"><span class="oz bw bk pa pb pc"/><span class="oz bw bk pa pb pc"/><span class="oz bw bk pa pb"/></div><div class="im in io ip iq"><p id="671d" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">谢谢你把我的文章看完！我希望你喜欢这篇文章和我参与的项目。如果你想在未来阅读更多类似的文章，请关注我，保持更新。</p></div></div>    
</body>
</html>