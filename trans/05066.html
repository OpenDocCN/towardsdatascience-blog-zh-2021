<html>
<head>
<title>What Are Named Tuples in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的命名元组是什么</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/what-are-named-tuples-in-python-59dc7bd15680?source=collection_archive---------17-----------------------#2021-05-04">https://towardsdatascience.com/what-are-named-tuples-in-python-59dc7bd15680?source=collection_archive---------17-----------------------#2021-05-04</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="fcb4" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">Python中被忽略的扩展数据类型</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/89f0ddf3b76ce2114a97b29604e0a22e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0mh4bmvgnljUc7lkWpp0QQ.jpeg"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">Sebastian Pociecha 在<a class="ae kz" href="https://unsplash.com/s/photos/name?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h2 id="a1ee" class="la lb iu bd lc ld le dn lf lg lh dp li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">介绍</h2><p id="72bb" class="pw-post-body-paragraph lw lx iu ly b lz ma jv mb mc md jy me lj mf mg mh ln mi mj mk lr ml mm mn mo in bi translated">元组是Python中最基本和最广泛使用的数据结构之一。大多数人不知道或者通常忘记的是，该语言附带了一个名为Tuple 的扩展类型，它构建在核心Tuple类型之上。</p><p id="b669" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">在本文中，我们将探索命名元组——一个很少使用的集合，它增强了标准元组。我们将讨论它们的语法，如何在你的代码中使用它们，最重要的是何时使用。</p></div><div class="ab cl mu mv hy mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="in io ip iq ir"><h2 id="52b1" class="la lb iu bd lc ld le dn lf lg lh dp li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">什么是命名元组以及何时使用它们</h2><p id="7f21" class="pw-post-body-paragraph lw lx iu ly b lz ma jv mb mc md jy me lj mf mg mh ln mi mj mk lr ml mm mn mo in bi translated">字典提供键查找，非常适合我们需要使用助记键名称创建键值数据结构的情况。另一方面，列表和元组是任意对象的有序和可索引的集合。</p><p id="a9bd" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">命名元组位于字典和元组(甚至类！)因为它们便于位置和属性查找。这意味着集合中的对象可以通过它们的键或索引来访问。</p></div><div class="ab cl mu mv hy mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="in io ip iq ir"><blockquote class="nb"><p id="2200" class="nc nd iu bd ne nf ng nh ni nj nk mo dk translated">“用于创建具有命名字段的元组子类的工厂函数”— <a class="ae kz" href="https://docs.python.org/3/library/collections.html#collections.namedtuple" rel="noopener ugc nofollow" target="_blank"> Python文档</a></p></blockquote><p id="c008" class="pw-post-body-paragraph lw lx iu ly b lz nl jv mb mc nm jy me lj nn mg mh ln no mj mk lr np mm mn mo in bi translated">命名元组容器数据类型是内置 <code class="fe nq nr ns nt b"><a class="ae kz" href="https://docs.python.org/3/library/stdtypes.html#tuple" rel="noopener ugc nofollow" target="_blank"><strong class="ly iv">tuple</strong></a></code>的<strong class="ly iv">替代。这种扩展类型增强了标准元组，因此它们的元素可以通过它们的属性名和位置索引来访问。</strong></p><p id="d7b0" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">在<code class="fe nq nr ns nt b">namedtuple</code>实用程序下的Python标准库<code class="fe nq nr ns nt b">collections</code>模块中可以获得命名元组。该类型接受<em class="nu"> typename </em>的名称和与之相关的字段名称作为参数。然后，该实用程序将返回一个新的元组子类，该子类用给定的typename命名。</p><p id="77ca" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">在下面的代码片段中，我们创建了一个名为<code class="fe nq nr ns nt b">Employee</code>的<code class="fe nq nr ns nt b">namedtuple</code> typename，它包含4个不同的字段。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nv nw l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">为员工创建命名元组</p></figure><p id="1889" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">现在我们可以使用生成的<code class="fe nq nr ns nt b">namedtuple</code> typename来创建对应于雇员的命名元组记录。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nv nw l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">使用命名元组类型名创建雇员</p></figure><p id="27f5" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">注意，只要使用关键字参数，就可以通过以任意顺序传递参数来创建新的typename对象，如下所示。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nv nw l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">使用关键字参数创建另一个雇员</p></figure><p id="a959" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">现在我们可以通过属性或位置来访问命名元组中的元素</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nv nw l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">通过索引或命名属性访问命名元组中的元素</p></figure></div><div class="ab cl mu mv hy mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="in io ip iq ir"><p id="9bc4" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">正如我们所见，命名元组结合了内置元组和字典的特征，甚至结合了Python类的特征。在幕后，这是通过创建一个从内置元组类型继承的新类(typename)来实现的。对于每个命名字段，添加一个<code class="fe nq nr ns nt b">@property</code>访问器，将属性名映射到相应的位置。</p><p id="9185" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">命名元组是一种扩展和自定义数据类型，它用额外的实用程序丰富了内置元组。在我们需要创建一个可以被元素的位置索引和命名属性访问的数据结构时，它们非常有用。</p></div><div class="ab cl mu mv hy mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="in io ip iq ir"><h2 id="0350" class="la lb iu bd lc ld le dn lf lg lh dp li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">使用命名元组的更多操作</h2><p id="d4e3" class="pw-post-body-paragraph lw lx iu ly b lz ma jv mb mc md jy me lj mf mg mh ln mi mj mk lr ml mm mn mo in bi translated">当转换为字典时，命名元组也可以支持键查找。<code class="fe nq nr ns nt b">_as_dict()</code>方法将返回一个<code class="fe nq nr ns nt b">OrderedDict()</code>，其中键是命名元组的属性。因此，通常的基于键的操作可以在返回的字典上执行。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nv nw l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">将命名元组解析为有序字典</p></figure></div><div class="ab cl mu mv hy mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="in io ip iq ir"><p id="4664" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">此外，命名元组支持解包元组赋值。这意味着可以使用元组赋值将<code class="fe nq nr ns nt b">namedtuple</code>的命名属性解包到相应的变量中。下面显示的代码片段演示了如何将命名属性解包到一个元组中。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nv nw l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">解包命名元组的属性</p></figure><p id="adf8" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">除了可索引，命名元组也是可迭代的。Pyhton中的Iterables实现了<code class="fe nq nr ns nt b">__iter__</code>并返回一个<em class="nu">迭代器</em>，该迭代器能够一次返回其成员的一个元素。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nv nw l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">遍历命名元组的属性</p></figure><p id="6b01" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">默认情况下，命名元组还提供了一个可读的<code class="fe nq nr ns nt b">__repr__</code>，它表示元组的类型名及其键值属性:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nv nw l"/></div></figure><p id="4ff4" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">最后，<code class="fe nq nr ns nt b"><a class="ae kz" href="https://docs.python.org/3/library/typing.html" rel="noopener ugc nofollow" target="_blank">typing</a></code>包提供的<code class="fe nq nr ns nt b">typing.NamedTuple</code>是<code class="fe nq nr ns nt b">collections.namedtuple</code>的类型化版本。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nv nw l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">namedtuple的类型化版本</p></figure><p id="c4d6" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">上面显示的类型化版本相当于下面的代码片段:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nv nw l"/></div></figure><p id="d823" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">带有类型提示的完整示例:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nv nw l"/></div></figure></div><div class="ab cl mu mv hy mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="in io ip iq ir"><h2 id="2834" class="la lb iu bd lc ld le dn lf lg lh dp li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">最后一句话</h2><p id="f98c" class="pw-post-body-paragraph lw lx iu ly b lz ma jv mb mc md jy me lj mf mg mh ln mi mj mk lr ml mm mn mo in bi translated">尽管命名元组很少使用，但仍然非常强大。这种特殊的扩展数据类型共享来自内置元组、字典甚至类的特征。当我们需要构建可以通过位置索引或属性名访问的数据结构时，命名元组通常很有用。</p><p id="bff6" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">在本文中，我们讨论了名称元组的用途，并探索了如何创建和访问它们。此外，我们讨论了命名元组的一些操作和特性，如迭代和基于键的查找(当转换为字典时)。</p><p id="fabb" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">最后要注意的是，命名元组是不可变的，这意味着它们的元素不能就地改变。在下面的文章中，你可以读到更多关于可变和不可变对象类型之间的区别，以及两者如何服务于Python的动态类型模型。</p><div class="nx ny gq gs nz oa"><a rel="noopener follow" target="_blank" href="/dynamic-typing-in-python-307f7c22b24e"><div class="ob ab fp"><div class="oc ab od cl cj oe"><h2 class="bd iv gz z fq of fs ft og fv fx it bi translated">Python中的动态类型</h2><div class="oh l"><h3 class="bd b gz z fq of fs ft og fv fx dk translated">探索Python中对象引用的工作方式</h3></div><div class="oi l"><p class="bd b dl z fq of fs ft og fv fx dk translated">towardsdatascience.com</p></div></div><div class="oj l"><div class="ok l ol om on oj oo kt oa"/></div></div></a></div></div></div>    
</body>
</html>