<html>
<head>
<title>Create a heatmap from the logs of your activity tracker</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从你的活动跟踪器的日志中创建一个热图</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/create-a-heatmap-from-the-logs-of-your-activity-tracker-c9fc7ace1657?source=collection_archive---------25-----------------------#2021-08-18">https://towardsdatascience.com/create-a-heatmap-from-the-logs-of-your-activity-tracker-c9fc7ace1657?source=collection_archive---------25-----------------------#2021-08-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9225" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何使用Python从应用程序和设备导入数据并从GPX文件创建热图。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/faa178c9bca84bc7d67ec67e2ad95211.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-vlBxRcUPcPX3Dcx7z2lfw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">热图(图片由作者提供)</p></figure><p id="6533" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我的电脑里有7年的步行记录。这些年来，从独立的GPS接收器，到SportsTracker，再到Garmin，这些都是通过几种设备和应用程序收集的。幸运的是，他们都有一个共同点，那就是记录的路线是GPX格式的。获取这些文件可能没有那么简单困难。</p><h2 id="3bcf" class="lu lv it bd lw lx ly dn lz ma mb dp mc lh md me mf ll mg mh mi lp mj mk ml mm bi translated">什么是GPX？</h2><p id="1bfc" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">GPS交换格式(GPX)是XML格式的GPS数据格式。它是一种开放的、免许可的格式，描述了路点、轨迹和路线。它被广泛采用，因此是交换位置数据的绝对标准。位置以经度-纬度(十进制度数)对的形式存储，并可选择使用海拔(米)、时间(UTC)和供应商特定信息进行扩展。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ms"><img src="../Images/9afd009bc53ce04bf0694cfc3ff44a7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TUIlZDDKKcKyPpx-PMMRwQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">GPX格式的音轨(图片由作者提供)</p></figure><p id="04fc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">上面的例子是Garmin存储的轨迹，例如SportsTracker和Fitbit存储的轨迹具有相同的结构，但细节不同。</p><p id="f99a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">根元素是<strong class="la iu"> <em class="mt"> gpx </em> </strong>。它包含一个<strong class="la iu"> <em class="mt">元数据</em> </strong>元素和一个<strong class="la iu"> <em class="mt"> trk </em> </strong>元素。<strong class="la iu"> <em class="mt">元数据</em> </strong>指定文件的来源和创建时间。<strong class="la iu"> <em class="mt"> trk </em> </strong>元素包含存储的音轨。一个轨迹由一个或多个片段组成，每个片段存储在一个<strong class="la iu"> <em class="mt"> trkseg </em> </strong>元素中。在曲目级别，有些字段包含曲目的名称和类型。该规范允许更多的字段，但这些字段并未被Garmin等公司使用。</p><p id="0e15" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu"> <em class="mt"> trkseg </em> </strong>段元素包含一个轨迹点列表(<strong class="la iu"> <em class="mt"> trkpt </em> </strong>)。线段是一组连续的点。如果跟踪被中断，例如失去连接或电源故障，应该创建一个新的段。</p><p id="dd11" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一个<strong class="la iu"> <em class="mt"> trkpt </em> </strong>有强制属性<strong class="la iu"> <em class="mt"> lat </em> </strong>和<strong class="la iu"> <em class="mt"> lon </em> </strong>来指定位置。有时间(<strong class="la iu"> <em class="mt">时间</em> </strong>)和标高(<strong class="la iu"> <em class="mt"> ele </em> </strong>)等可选字段。元素<strong class="la iu"> <em class="mt">扩展</em> </strong>允许每个设备/应用添加额外的信息，如心率(上面Garmin示例中的<strong class="la iu"> <em class="mt"> hr </em> </strong>)、速度或路线(Garmin不使用)。</p><p id="e421" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用SportsTracker创建的轨迹包括经度/纬度属性以及时间和海拔元素。他们没有像Garmin那样的扩展。假设以下数据结构用于解析GPX文件:</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="ea07" class="lu lv it mv b gy mz na l nb nc">&lt;gpx&gt;<br/>  &lt;metadata&gt;<br/>    &lt;name&gt;02-01-20 13:29&lt;/name&gt;<br/>  &lt;/metadata&gt;<br/>  &lt;trk&gt;<br/>    &lt;trkseg&gt;<br/>      &lt;trkpt lat="52.12345" lon="6.31235"&gt;<br/>        &lt;ele&gt;71.1&lt;/ele&gt;<br/>        &lt;time&gt;2021-08-02T12:29:18Z&lt;/time&gt;<br/>      &lt;/trkpt&gt;<br/>    &lt;/trkseg&gt;<br/>  &lt;/trk&gt;<br/>&lt;/gpx&gt;</span></pre><h2 id="1308" class="lu lv it bd lw lx ly dn lz ma mb dp mc lh md me mf ll mg mh mi lp mj mk ml mm bi translated">导入GPX文件</h2><p id="5944" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">为了读取GPX文件，有几个Python库可用，比如<a class="ae nd" href="https://github.com/tkrajina/gpxpy" rel="noopener ugc nofollow" target="_blank"> gpxpy </a>。但是出于教育目的，提供了一个实现。这个实现利用了Python中默认XML实现的<code class="fe ne nf ng mv b">ElementTree</code>。要从目录中读取所有gpx文件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="f02e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这段代码从目录<code class="fe ne nf ng mv b">data</code>中检索所有文件，并解析扩展名为<code class="fe ne nf ng mv b">.gpx</code>的所有文件(来自第18行)。从文档中检索根元素(第19行)，在本例中是<code class="fe ne nf ng mv b">&lt;gpx&gt;</code>元素。所有元素都位于第6行定义的名称空间中。</p><p id="1b92" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">跟踪日志的开始时间存储在元素<code class="fe ne nf ng mv b">&lt;metadata&gt;</code>的子元素<code class="fe ne nf ng mv b">&lt;time&gt;</code>中。然后(第21行)选择音轨，在这种情况下使用<code class="fe ne nf ng mv b">.find()</code>方法。这将查找具有指定名称的元素的第一个匹配项。这就足够了，因为我的GPX文件中没有一个包含多个音轨，甚至是多个片段。在多轨道的情况下，可以通过迭代<code class="fe ne nf ng mv b">.findAll()</code>的结果来替换<code class="fe ne nf ng mv b">.find()</code>。track元素包含元素<code class="fe ne nf ng mv b">name</code>和<code class="fe ne nf ng mv b">type</code>，这两个元素包含活动的名称和活动的类型(例如步行)(第22–23行)。</p><p id="e462" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">从轨道中选择第一个(也是唯一的)片段(第24行)。该段包含所有记录的位置，因此通过迭代该段，所有记录的位置都被解析(第25行)。点(元素<code class="fe ne nf ng mv b">trkpnt</code>)包含纬度和经度(26–27)两个属性，以及日志条目的时间戳和海拔(第28–31行)两个子元素。高程可能不存在，因此我们需要在转换之前检查它的存在(第31行)。</p><p id="a874" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">所有信息都被添加到一个数组中，该数组在第33行被转换成一个数据帧。最后，两个时间字段都被转换为时间戳对象，因此我们最终得到以下数据帧(在本例中有将近一百万个位置):</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nj"><img src="../Images/fea1515c810faf32e828e5818d466c38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DUhWN6GWrZcRyUC_1xErPQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">GPX所有记录位置的数据框(图片由作者提供)</p></figure><p id="4387" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">大部分的活动日志是在我居住的地方，在假期有少量的。过滤我家周围的位置可以得到热图的第一个概念。</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="ed81" class="lu lv it mv b gy mz na l nb nc">df[(df.lat &gt; LAT_MIN) &amp; (df.lat &lt; LAT_MAX) &amp; <br/>   (df.lon &gt; LON_MIN) &amp; (df.lon &lt; LON_MAX)]. \<br/>   plot.scatter('lon', 'lat', figsize=(10,10), s=0.1)</span></pre><p id="8244" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在<code class="fe ne nf ng mv b">(x,y)</code>坐标系中，经度为<code class="fe ne nf ng mv b">x</code>，纬度为<code class="fe ne nf ng mv b">y</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/e3f534b9d2b428ea37fcbd1e3fffd667.png" data-original-src="https://miro.medium.com/v2/resize:fit:1358/format:webp/1*mymM0OBIG7KzCFEAvtYX4g.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">跟踪的活动(作者图片)</p></figure><h2 id="6ba4" class="lu lv it bd lw lx ly dn lz ma mb dp mc lh md me mf ll mg mh mi lp mj mk ml mm bi translated">创建热图</h2><p id="ae00" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">最初的图给出了所有活动的一个很好的概述，但是没有提供大多数访问区域的洞察力。为此，我们将创建一个热图。我们会从头开始做这个。</p><p id="ed28" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">热图将在大小为<code class="fe ne nf ng mv b">&lt;size_x, size_y&gt;</code>的<strong class="la iu"> numpy </strong>数组中创建。所以首先我们要把经纬度转换成这个维度；最小经度到<code class="fe ne nf ng mv b">0</code>，最大经度到<code class="fe ne nf ng mv b">size_x</code>，纬度也一样。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="c023" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">首先，删除经度/纬度范围之外的所有位置。然后为<code class="fe ne nf ng mv b">x</code>和<code class="fe ne nf ng mv b">y</code>创建新的列，并使用线性转换为其分配适当的值。这些值被转换成整数，因为我们将使用它们来寻址numpy矩阵中的点。</p><p id="1797" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于那些感兴趣的人来说，线性回归背后的数学:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nl"><img src="../Images/ff387085b657beea796bcb8a66f72ea4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hp8dpQxbksMyK-fZDBQVWw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">线性回归解释(图片由作者提供)</p></figure><p id="3529" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下一步是创建一个用所需大小的零填充的矩阵。每个被跟踪的点将被添加到这个矩阵中。不仅添加了确切的位置，还添加了围绕它的正方形(基于<code class="fe ne nf ng mv b">width</code>)。这对于高分辨率图像特别有用，在这种图像中，宽度为一个像素的线条几乎看不见。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="25c4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以迭代<code class="fe ne nf ng mv b">df2</code>并逐个添加每个点。但是我们通过首先对<code class="fe ne nf ng mv b">(x,y)</code>进行分组并计算出现的次数来优化它。当相同的位置出现例如7次时，它仅被添加一次而不是7次。由于宽度的使用，仍然需要加法(第8行)而不是赋值。由于宽度的使用，相邻的位置会累加起来。</p><p id="e922" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">由于宽度增加的附加效应，使用频率高的路线会变亮。为了防止他们丢弃较少使用的路线，计数被最大化(第11行)为数据集中路线的数量。可以添加一个因子来优化最终结果(第10行)。</p><p id="82b2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在我们已经用每个<code class="fe ne nf ng mv b">&lt;x,y&gt; </code>的出现次数填充了数组，我们可以把它转换成一个色标。将这些值标准化后，将应用matplotlib色彩映射表。在这种情况下，使用'<code class="fe ne nf ng mv b">hot</code>'色图，因为它在黑色背景下工作良好(从等于黑色的数组中的零开始)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="1de5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后一步是使用matplotlib绘制图像:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="d1f6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe ne nf ng mv b">origin=”lower”</code>是必需的，因为图像的零点在左下角，但默认是左上角。我们努力的结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nm"><img src="../Images/02b067bafd92e35d406b069617fdff23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KnWg8CJK7TUY3n9rwKbaSw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">生成的热图(图片由作者提供)</p></figure><p id="e899" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是我们自己的热图。可以通过添加高斯模糊来使图片看起来更友好。但是现在，我对结果很满意。</p><h2 id="1a83" class="lu lv it bd lw lx ly dn lz ma mb dp mc lh md me mf ll mg mh mi lp mj mk ml mm bi translated">最终世界</h2><p id="943c" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">我们已经看到从任何来源导入GPX文件是多么简单。根据这些数据，我们创建了一个热图来直观显示游览地点。通过给图像添加模糊或者甚至添加一张地图作为背景，改进是可能的(很多工作，但是值得)。</p><p id="562e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在下一篇文章中，我将向你展示如何计算指标，如行驶距离、速度和方位。</p><p id="57ce" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我希望你喜欢这篇文章。要获得更多灵感，请查看我的其他文章:</p><ul class=""><li id="9135" class="nn no it la b lb lc le lf lh np ll nq lp nr lt ns nt nu nv bi translated"><a class="ae nd" rel="noopener" target="_blank" href="/remove-personal-information-from-text-with-python-232cb69cf074">用Python删除文本中的个人信息</a></li><li id="4600" class="nn no it la b lb nw le nx lh ny ll nz lp oa lt ns nt nu nv bi translated"><a class="ae nd" rel="noopener" target="_blank" href="/side-by-side-comparison-of-strings-in-python-b9491">Python中字符串的并排比较</a></li><li id="81a8" class="nn no it la b lb nw le nx lh ny ll nz lp oa lt ns nt nu nv bi translated"><a class="ae nd" rel="noopener" target="_blank" href="/parallel-web-requests-in-python-4d30cc7b8989">用Python实现并行web请求</a></li><li id="fb96" class="nn no it la b lb nw le nx lh ny ll nz lp oa lt ns nt nu nv bi translated"><a class="ae nd" rel="noopener" target="_blank" href="/all-public-transport-leads-to-utrecht-not-rome-bb9674600e81">所有公共交通工具都通向乌得勒支，而不是罗马</a></li><li id="ed31" class="nn no it la b lb nw le nx lh ny ll nz lp oa lt ns nt nu nv bi translated"><a class="ae nd" rel="noopener" target="_blank" href="/visualization-of-travel-times-with-otp-and-qgis-3947d3698042">使用OTP和QGIS可视化行程时间</a></li></ul><p id="328d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="mt">免责声明:本文包含的观点和看法仅归作者所有。</em></p></div></div>    
</body>
</html>