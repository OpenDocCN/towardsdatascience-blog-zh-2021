<html>
<head>
<title>GraphQL — Code First(Resolver-First) using TypeGraphQL and typegoose</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">GraphQL —使用TypeGraphQL和typegoose的代码优先(解析器优先)</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/graphql-code-first-resolver-first-using-typegraphql-and-typegoose-747616223786?source=collection_archive---------26-----------------------#2021-06-07">https://towardsdatascience.com/graphql-code-first-resolver-first-using-typegraphql-and-typegoose-747616223786?source=collection_archive---------26-----------------------#2021-06-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/d36718475ada61f9270add78c1c68d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5rXejhcKLorK7JiXnQH-tg.jpeg"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://unsplash.com/@homajob?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">斯科特·格雷厄姆</a>在<a class="ae kf" href="https://unsplash.com/s/photos/netowrk-graph?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</p></figure><p id="2963" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi le translated"><span class="l lf lg lh bm li lj lk ll lm di"> G </span> raphQL是一种开源的查询和数据操作语言，由脸书在2015年创建。尽管它被社区定义为REST的可能替代品，但根据每个API的架构和需求，有些项目可能适合GraphQL API，而有些项目可能适合REST API。但是由于它在过去几年的流行，一些大公司已经将他们的API迁移到GraphQL APIs，而一些公司选择了同时使用REST和GraphQL的混合方法。</p><figure class="lo lp lq lr gt ju gh gi paragraph-image"><div class="gh gi ln"><img src="../Images/ebf98614b8d9a0fc9d9c889e09c42990.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/1*fptrhT6BHtxxlvQL9DGrTg.png"/></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">图片由<a class="ae kf" href="https://graphql.org/" rel="noopener ugc nofollow" target="_blank"> GraphQL </a>提供</p></figure><p id="9f0e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在创建GraphQL API时，可以使用许多工具来管理API的创建。目前可用于创建GraphQL APIs的一些主要和流行的工具有</p><ul class=""><li id="ab89" class="ls lt it ki b kj kk kn ko kr lu kv lv kz lw ld lx ly lz ma bi translated">graph QL(<a class="ae kf" href="https://github.com/graphql/graphql-js" rel="noopener ugc nofollow" target="_blank"><strong class="ki iu">)graph QL/graph QL-js</strong></a><strong class="ki iu">)</strong></li><li id="6da5" class="ls lt it ki b kj mb kn mc kr md kv me kz mf ld lx ly lz ma bi translated">阿波罗(<a class="ae kf" href="https://github.com/apollographql/apollo-server" rel="noopener ugc nofollow" target="_blank"> <strong class="ki iu">)阿波罗/阿波罗服务器</strong> </a> <strong class="ki iu"> ) </strong></li><li id="6cb8" class="ls lt it ki b kj mb kn mc kr md kv me kz mf ld lx ly lz ma bi translated">express graph QL(<a class="ae kf" href="https://github.com/graphql/express-graphql" rel="noopener ugc nofollow" target="_blank"><strong class="ki iu">/express-graph QL</strong></a><strong class="ki iu">)</strong></li><li id="1693" class="ls lt it ki b kj mb kn mc kr md kv me kz mf ld lx ly lz ma bi translated">普里斯马(<a class="ae kf" href="https://www.prisma.io/" rel="noopener ugc nofollow" target="_blank">https://www.prisma.io/</a>)</li><li id="9c20" class="ls lt it ki b kj mb kn mc kr md kv me kz mf ld lx ly lz ma bi translated">AWS AppSync</li></ul><p id="3e4d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">除此之外，在我写这篇文章的时候，还有很多工具正在开发中。所有这些工具都有各自的优点和缺点。本文不打算对这些工具进行比较，所以让我们继续讨论GraphQL的创建。</p><p id="b25f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">创建GraphQL API时，我们需要做的主要工作是定义GraphQL模式。有两种常见的方法可以做到这一点。</p><ul class=""><li id="04ec" class="ls lt it ki b kj kk kn ko kr lu kv lv kz lw ld lx ly lz ma bi translated"><strong class="ki iu">模式优先开发</strong></li><li id="ced2" class="ls lt it ki b kj mb kn mc kr md kv me kz mf ld lx ly lz ma bi translated"><strong class="ki iu">代码优先开发</strong></li></ul><h1 id="aba9" class="mg mh it bd mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd bi translated">图式优先发展</h1><p id="bc7b" class="pw-post-body-paragraph kg kh it ki b kj ne kl km kn nf kp kq kr ng kt ku kv nh kx ky kz ni lb lc ld im bi translated">在模式优先开发中，我们首先定义模式，然后实现与已定义模式上的定义相匹配的代码。为了定义模式，我们将使用<strong class="ki iu">模式定义语言</strong>，这是GraphQL团队推出的一种查询定义语言。下面是一个我们如何使用模式优先开发来定义模式的例子。</p><figure class="lo lp lq lr gt ju"><div class="bz fp l di"><div class="nj nk l"/></div></figure><h1 id="794c" class="mg mh it bd mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd bi translated">代码优先开发</h1><p id="959b" class="pw-post-body-paragraph kg kh it ki b kj ne kl km kn nf kp kq kr ng kt ku kv nh kx ky kz ni lb lc ld im bi translated">在代码优先开发中，我们首先开始创建解析器，而不是首先创建模式。因此，解析器会自动生成模式。因此，在这里我们不必手动创建模式。但是缺点是仅仅看代码很难理解模式。</p><figure class="lo lp lq lr gt ju"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="5706" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如上所示，我们可以看到，对于类型，我们可以使用<strong class="ki iu"> GraphQLObjectType </strong>和属性作为字段来定义。解析器也是如此。</p><p id="d41e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可以选择用于创建GraphQL API开发的开发方法。这种选择需要在开发之初完成，并且可能取决于几个因素，如语言支持、开发人员经验等...在本文中，我们将探讨代码优先的开发方法。</p><h2 id="70ee" class="nl mh it bd mi nm nn dn mm no np dp mq kr nq nr mu kv ns nt my kz nu nv nc nw bi translated">使用TypeScript进行代码优先开发</h2><p id="8cce" class="pw-post-body-paragraph kg kh it ki b kj ne kl km kn nf kp kq kr ng kt ku kv nh kx ky kz ni lb lc ld im bi translated">Typescript是一种基于Javascript的语言，我们可以在其中使用静态类型定义。通过使用静态类型检查，我们可以理想地在编译时移除许多错误，而不是在运行时将它们识别为错误，这在大型应用程序中非常有用。除了静态类型检查之外，使用Typescript还可以获得更多的开发人员功能，如IntelliSense。由于这些特性，许多大型Javascript项目选择在其Javascript项目之上使用Typescript来增强其用途。对于GraphQL APIs也是如此。</p><p id="ca16" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们再来看看如何使用TypeScript实现GraphQL的代码优先开发。</p><figure class="lo lp lq lr gt ju"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="a4a3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如您所看到的，当我们使用Typescript时，我们需要定义用户类型，因此之后我们可以将这个静态类型用于我们的其他实现和验证。此外，我还添加了一个模拟用户列表，用作模拟数据，它也使用创建的类型user。但是在大多数应用程序中，这些数据将来自数据库。让我们使用MongoDBas作为我们的数据库，使用mongoose作为我们的ODM工具。那么完整的模式实现将如下所示。</p><figure class="lo lp lq lr gt ju"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="7ee1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们可以看到，对于mongoose，我们使用user类型定义了UserModel，在解析器中(第17行),我们调用MongoDB并直接从数据库中获取结果。</p><p id="8a76" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上述解决方案运行良好，并提供了我们期望从GraphQL API获得的所需功能。但是现在让我们假设我们需要向我们的用户类型添加一个电子邮件字段。让我们检查上面的代码，并确定我们需要在哪里进行代码修改，以便进行这个简单的修改。经过调查，您可能已经发现我们需要在3个位置进行代码修改。</p><ul class=""><li id="a446" class="ls lt it ki b kj kk kn ko kr lu kv lv kz lw ld lx ly lz ma bi translated">在UserType GraphQLObjectType中，我们需要添加</li></ul><pre class="lo lp lq lr gt nx ny nz oa aw ob bi"><span id="51d1" class="nl mh it ny b gy oc od l oe of">email: { type: GraphQLString }</span></pre><ul class=""><li id="2fda" class="ls lt it ki b kj kk kn ko kr lu kv lv kz lw ld lx ly lz ma bi translated">在Typescript接口定义中，我们需要添加</li></ul><pre class="lo lp lq lr gt nx ny nz oa aw ob bi"><span id="4434" class="nl mh it ny b gy oc od l oe of">email: string</span></pre><ul class=""><li id="d5ba" class="ls lt it ki b kj kk kn ko kr lu kv lv kz lw ld lx ly lz ma bi translated">在mongoose模式定义中，我们需要添加</li></ul><pre class="lo lp lq lr gt nx ny nz oa aw ob bi"><span id="1954" class="nl mh it ny b gy oc od l oe of">email: { type: String, required: true }</span></pre><p id="e49e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这在我们的例子中可能看起来不多，但是在大型应用程序中，这些定义将位于不同的文件中，开发人员需要跟踪所有这些文件来进行这些修改。那么，有没有一种方法可以让我们只在一个地方修改就能处理这些场景呢？答案是<strong class="ki iu">是的</strong>，这就是我们介绍<strong class="ki iu"> TypeGraphQL </strong>和<strong class="ki iu"> typegoose </strong>的地方。</p><h2 id="de06" class="nl mh it bd mi nm nn dn mm no np dp mq kr nq nr mu kv ns nt my kz nu nv nc nw bi translated">TypeGraphQL和TypeGoose</h2><figure class="lo lp lq lr gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi og"><img src="../Images/4c4b9253006abd70a29b1bdf54f3a282.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8tZq2SQ2edtZM-pZxAdGRg.png"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">图片来自<a class="ae kf" href="https://typegraphql.com/docs/introduction.html" rel="noopener ugc nofollow" target="_blank"> <strong class="bd oh">类型图QL </strong> </a></p></figure><p id="2402" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><a class="ae kf" href="https://typegraphql.com/docs/introduction.html" rel="noopener ugc nofollow" target="_blank"> <strong class="ki iu"> TypeGraphQL </strong> </a>是一个库，可以用来使用TypeScript创建GraphQL APIs。它提供的主要特性是在GraphQL模式和Typescript静态类型之间保持同步。</p><p id="1395" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Typegoose是一个使用Typescript轻松编写mongoose模式的包装器。</p><p id="ebad" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先，让我们看看如何使用TypeGraphQL来转换我们定义的模式。</p><figure class="lo lp lq lr gt ju"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="6c3e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如你所见，我们在代码中引入了一些装饰器。主要是<strong class="ki iu"> @ObjectType </strong>和<strong class="ki iu"> @Field </strong> decorator。通过使用@Field这个装饰器，我们指定这个字段也应该在我们的GraphQL模式中可用。因此，如果我们希望在静态类型中有一个属性，而这个属性不需要在GraphQL模式中，我们可以忽略为这个属性提到这个@Field装饰器。</p><p id="4aeb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下一个问题是，我们应该在哪里为GraphQL类型定义数据类型。为此，我们可以使用相同的<strong class="ki iu"> @Field </strong>装饰器。但是在上面的代码中，我们从来没有使用这个decorator来定义GraphQL类型的数据类型，我们只为我们的Typescript类型定义了类型。这是因为对于字符串，布尔数据类型TypeGraphQL足够智能，可以为GraphQL类型识别相同底层数据类型。当Typescript类型和GraphQL类型不同时，我们可以使用@Field decorator来表示数据类型，如下所示。</p><pre class="lo lp lq lr gt nx ny nz oa aw ob bi"><span id="cbe9" class="nl mh it ny b gy oc od l oe of">@Field(() =&gt; Int, description: "Age of the user")<br/>age: Number;</span><span id="d37f" class="nl mh it ny b gy oi od l oe of">@Field(() =&gt; String)<br/>createdAt = new Date().toUTCString()</span></pre><p id="138a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如您所做的，除了指定类型，我们还可以使用decorators指定其他选项。(描述等……)</p><p id="c644" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来，让我们尝试将typegoose集成到同一个模式中。</p><figure class="lo lp lq lr gt ju"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="2c7c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这里，你可以再次看到我们引入了另一个名为<strong class="ki iu"> @props </strong>的装饰器。这个装饰器和<strong class="ki iu"> @Field </strong>装饰器的作用是一样的，只是针对猫鼬。它指定这个字段应该在我们的mongoose模式中可用，并最终在我们的MongoDB数据库中可用。和上面的@prop一样，我们也可以传递将被映射到数据库集合中的选项。同样，如果我们需要在数据库中存储不同的数据类型，我们可以像下面这样定义它们。</p><pre class="lo lp lq lr gt nx ny nz oa aw ob bi"><span id="a3ba" class="nl mh it ny b gy oc od l oe of">@prop({ type: () =&gt; [String] })<br/>  <br/>@prop({ type: () =&gt; Job })</span></pre><p id="1175" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">集成TypeGraphQL后，我们的解析器将如下所示。</p><figure class="lo lp lq lr gt ju"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="5850" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里我们使用<strong class="ki iu"> @Query </strong> decorator来定义一个查询，并通过使用typegoose定义来查询我们的数据库并返回数据。</p><p id="8d13" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在让我们来看一下我们的场景，我们的GraphQL模式需要一个新的email字段。你能确定哪些地方我们需要改变吗？是的，现在我们只需要改变一个位置，如下所示。</p><pre class="lo lp lq lr gt nx ny nz oa aw ob bi"><span id="e442" class="nl mh it ny b gy oc od l oe of">@Field()<br/>@prop({ required: true })    <br/>email!: string;</span></pre><p id="6842" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在不需要找到每个位置，因为我们的GraphQL模式、Typescript类型和mongoose模式都是从一个位置同步的。</p><p id="09a0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是一个简单的介绍，其中我们使用代码优先方法中的TypeGraphQL和typegoose来创建GraphQL。显然，这些工具比我在本文中使用的用例更强大。因此，如果您对如何在您的下一个项目中安装这两个非常棒的库更感兴趣，或者需要找到相关指南，请务必访问它们的官方文档，以便在您的下一个GraphQL API项目中增强更多功能。</p><p id="65a0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">谢谢:)</p></div></div>    
</body>
</html>