<html>
<head>
<title>Getting Started with Graph Embeddings in Neo4j</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Neo4j图形嵌入入门</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/getting-started-with-graph-embeddings-2f06030e97ae?source=collection_archive---------10-----------------------#2021-05-23">https://towardsdatascience.com/getting-started-with-graph-embeddings-2f06030e97ae?source=collection_archive---------10-----------------------#2021-05-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="9eb7" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/hands-on-tutorials" rel="noopener" target="_blank">实践教程</a></h2><div class=""/><div class=""><h2 id="bc98" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">浅谈如何将网络图的节点转化为向量</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/3b887ce27de101f500766bf40fad7168.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BeUa-Pt8rbblnX-BC8Rjhw.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">图片由<a class="ae le" href="https://commons.wikimedia.org/w/index.php?title=User:Savionasc&amp;action=edit&amp;redlink=1" rel="noopener ugc nofollow" target="_blank"> Savionasc </a>提供，根据<a class="ae le" href="https://en.wikipedia.org/wiki/en:Creative_Commons" rel="noopener ugc nofollow" target="_blank">知识共享</a> <a class="ae le" href="https://creativecommons.org/licenses/by-sa/4.0/deed.en" rel="noopener ugc nofollow" target="_blank">署名-共享4.0国际版</a>许可授权。未对原始图像进行任何更改。</p></figure><h1 id="8c0f" class="lf lg iq bd lh li lj lk ll lm ln lo lp kf lq kg lr ki ls kj lt kl lu km lv lw bi translated">介绍</h1><p id="3f80" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">所有机器学习的起点都是把你的数据变成向量/嵌入(如果他们还没有的话)。也许在你的问题中你是幸运的，你已经有了许多列与每个数据点相关联的规格化浮点数，它们很容易组合起来进行嵌入。或者你可以很容易地推导出它们。许多不同类型的数据可以用来生成向量，如文本、图像等。但是，当您的数据以图表或其他相互关联的数据的形式出现时，该怎么办呢？</p><p id="38eb" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">在接下来的几篇博文中，我希望深入了解如何创建和调整这些向量的一些细节。为了这篇文章，我将介绍<a class="ae le" href="http://dev.neo4j.com/neo4j" rel="noopener ugc nofollow" target="_blank"> Neo4j </a>的<a class="ae le" href="http://dev.neo4j.com/graph_data_science" rel="noopener ugc nofollow" target="_blank">图形数据科学</a> (GDS)库中存在的三种方法。(我们将在一两篇不同的文章中讨论嵌入调整。这些超参数包含很多内容！)我们将使用一个使用<a class="ae le" href="http://dev.neo4j.com/sandbox" rel="noopener ugc nofollow" target="_blank"> Neo4j沙箱</a>可用的小图(但你也可以使用<a class="ae le" href="http://dev.neo4j.com/desktop" rel="noopener ugc nofollow" target="_blank"> Neo4j桌面</a>或使用我在<a class="ae le" href="http://dev.neo4j.com/docker_neo_jupyter" rel="noopener ugc nofollow" target="_blank">这篇文章</a>中描述的自定义Docker容器来完成此操作)，这是一个免费工具，可用于免费试用Neo4j和GDS。</p><p id="c48d" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">这篇文章是一系列文章中的第二篇，我们将看看如何用图表进行数据科学研究，从…</p><ol class=""><li id="d38c" class="my mz iq lz b ma mt md mu mg na mk nb mo nc ms nd ne nf ng bi translated"><a class="ae le" href="http://dev.neo4j.com/docker_neo_jupyter" rel="noopener ugc nofollow" target="_blank">“通过Docker开始使用Neo4j和Jupyter Lab”</a></li></ol><p id="6ee2" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">(在未来的博客文章中，我们将更多地使用Docker参考。)</p><h1 id="42a2" class="lf lg iq bd lh li lj lk ll lm ln lo lp kf lq kg lr ki ls kj lt kl lu km lv lw bi translated">Neo4j沙盒入门</h1><p id="99a0" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">我已经在<a class="ae le" rel="noopener" target="_blank" href="/create-a-graph-database-in-neo4j-using-python-4172d40f89c4">的另一篇博文</a>中描述了这一点，所以让我们在这里重点讨论一下。第一步是创建沙箱本身。你可以在这里做<a class="ae le" href="http://dev.neo4j.com/sandbox" rel="noopener ugc nofollow" target="_blank"/>。我们将创建一个新的沙盒实例，方法是选择“新建项目”，然后选择“图形数据科学”，如下所示。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nh"><img src="../Images/a4ce0bcf7f4cd1760092b1b3c6fcb718.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cqeh0rrfWzyiNNYbDwTVLg.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">创建图形数据科学沙盒数据库</p></figure><p id="e52e" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">一旦完成设置，点击右边的绿色按钮，告诉它“在浏览器中打开”</p><p id="6061" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">现在，让我们单击左上角看起来像数据库图标的按钮，看看我们在这个代表“权力的游戏”的预填充图形中有什么酷毙了。我们有几个节点标签和关系类型，这对以后的工作非常有帮助。当您发出Cypher命令<code class="fe ni nj nk nl b">MATCH (n) RETURN n</code>时，您的图形应该如下所示:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nm"><img src="../Images/22c775e47a86f6e4570eb82bb42360ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3IWnTn_kKgeHoipAnCY-zQ.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">权力的游戏，形象化为网络图。(图片由作者提供。)</p></figure><h1 id="7710" class="lf lg iq bd lh li lj lk ll lm ln lo lp kf lq kg lr ki ls kj lt kl lu km lv lw bi translated">使用GDS创建内存中的图形</h1><p id="a471" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">使用GDS的第一步总是创建内存中的图形，这是通过使用图形投影来实现的。关于图投影的好处是，您可以(并且通常应该)明确您想要为图的哪个(哪些)部分创建嵌入。一般来说，使用整个图表不是一个好主意，特别是当图表变大时。此外，GDS中的一些图算法不适用于二分图或多分图。最后，使用内存中的图并不一定要永久地改变整个数据库，除非您使用带有<code class="fe ni nj nk nl b">.write()</code>的算法，您可以用它来编写作为节点属性的嵌入。当我们想在图上做ML时，这将是非常有用的，我将在这篇文章中展示如何做。所以使用内存中的图形。你会喜欢他们的！</p><p id="a1a2" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">有两种方法可以创建内存中的图形，这两种方法都是用投影表示的图形数据模型。投影指定了节点类型和关系类型，它们可以是全包含的。这两种方法包括通过<a class="ae le" href="https://neo4j.com/docs/graph-data-science/current/management-ops/cypher-projection/#cypher-projection" rel="noopener ugc nofollow" target="_blank"> Cypher投影</a>或所谓的<a class="ae le" href="https://neo4j.com/docs/graph-data-science/current/management-ops/native-projection/" rel="noopener ugc nofollow" target="_blank">“本地”投影</a>创建图形。Cypher投影的优点是编写简单，同时还提供了Cypher查询的所有灵活性，但代价是比原生投影慢得多。</p><p id="4336" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">所以让我们从创建一个内存图开始。这里我将使用本机投影，但是如果您愿意，它们可以很容易地转换成Cypher投影。假设我想查看图表中的所有人。我们会使用</p><pre class="kp kq kr ks gt nn nl no np aw nq bi"><span id="69f6" class="nr lg iq nl b gy ns nt l nu nv">CALL gds.graph.create(<br/>    'people', {<br/>        Person: { label: 'Person' }<br/>    },<br/>    '*'<br/>)<br/>YIELD graphName, nodeCount, relationshipCount;</span></pre><p id="594e" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">来创建这个内存中的图形。这里，节点投影简单地指定了具有标签<code class="fe ni nj nk nl b">Person</code>的每个节点。边缘投影<code class="fe ni nj nk nl b">'*'</code>包括与节点投影中的节点相关联的所有边缘。</p><p id="b0bc" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">我们可以创建一些更具体的东西，比如指定多个节点类型。然后我们可以使用语法</p><pre class="kp kq kr ks gt nn nl no np aw nq bi"><span id="ce50" class="nr lg iq nl b gy ns nt l nu nv">CALL gds.graph.create(<br/>    'a-different-graph', {<br/>        Person: { label: 'Person' },<br/>        House: { label: 'House' }<br/>    },<br/>    '*'<br/>)<br/>YIELD graphName, nodeCount, relationshipCount</span></pre><p id="ccdd" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">所以现在我们有了人和房子，这可能对ML任务有用，比如预测人和房子之间的联系。(我们将把它留到以后的文章中。)</p><p id="a195" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">也许我们还想只包括人和房子之间的特定关系类型。(在Cypher中，你可以通过快速查询<code class="fe ni nj nk nl b">MATCH (p:Person)--(h:House) RETURN p, h</code>来查看所有的关系类型。)假设我们只关心关系<code class="fe ni nj nk nl b">BELONGS_TO</code>。为了创建内存中图形，我们将包括一个特定的边投影:</p><pre class="kp kq kr ks gt nn nl no np aw nq bi"><span id="d4d2" class="nr lg iq nl b gy ns nt l nu nv">CALL gds.graph.create(<br/>    'belongs-graph', {<br/>        Person: { label: 'Person' },<br/>        House: { label: 'House' }<br/>    },<br/>    {<br/>     BELONGS: { type: 'BELONGS_TO',<br/>            orientation: 'NATURAL'<br/>        }<br/>    }<br/>)<br/>YIELD graphName, nodeCount, relationshipCount</span></pre><p id="c546" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">边缘投影<code class="fe ni nj nk nl b">BELONGS</code>有一些我们已经包括的东西，即边缘类型和方向。关于后者的一个注意事项:GDS的一些图形算法倾向于使用<code class="fe ni nj nk nl b">'UNDIRECTED'</code>方向，然而默认方向是<code class="fe ni nj nk nl b">'NATURAL'</code>。我们鼓励您查阅API文档来确定每个算法需要什么。当有疑问时，最安全的方法是假设无向单部图。</p><p id="8986" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">酷毙了。现在我们有了一些内存中的图形(请看<code class="fe ni nj nk nl b">CALL gds.graph.list())</code>)。最佳实践表明，您应该丢弃所有不打算使用<code class="fe ni nj nk nl b">CALL gds.graph.drop(graph_name)</code>的图形，以释放内存。</p><h1 id="f19a" class="lf lg iq bd lh li lj lk ll lm ln lo lp kf lq kg lr ki ls kj lt kl lu km lv lw bi translated">创建嵌入</h1><p id="2e58" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">您可以使用GDS创建三种类型的嵌入:<a class="ae le" href="https://neo4j.com/docs/graph-data-science/current/algorithms/fastrp/#algorithms-embeddings-fastrp" rel="noopener ugc nofollow" target="_blank"> FastRP </a>、<a class="ae le" href="https://neo4j.com/docs/graph-data-science/current/algorithms/graph-sage/" rel="noopener ugc nofollow" target="_blank"> GraphSAGE </a>和<a class="ae le" href="https://neo4j.com/docs/graph-data-science/current/algorithms/node2vec/" rel="noopener ugc nofollow" target="_blank"> node2vec </a>。每一个都以自己的方式在内存图中创建节点的嵌入。在我们讨论每一个之前，让我们来看一下它们的一些公共参数，您将使用它们来生成嵌入。</p><p id="7898" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">所有的嵌入(事实上，所有的图形算法)都有一些不同的方法。我们这里要用的是<code class="fe ni nj nk nl b">.stream()</code>(把结果输出到屏幕上)和<code class="fe ni nj nk nl b">.write()</code>(把计算出来的东西写成节点属性)。对于它们中的每一个，我们都需要提供内存图的名称、一些配置参数集以及算法返回的内容。在<code class="fe ni nj nk nl b">.write()</code>的情况下，这将通过<code class="fe ni nj nk nl b">YIELD</code>语句返回。当您返回结果时，它们是根据节点id完成的，节点id是图的内部id。请注意，它们特定于内存中的图形，并且不匹配数据库本身中的任何内容，因此我们将很快展示如何将它们转换回可识别的内容。这些配置往往是特定于每种算法的，我们鼓励您查阅这方面的API文档。</p><p id="100f" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">现在让我们看看三种嵌入算法。FastRP，顾名思义就是，嗯，快。它使用基于线性代数的稀疏随机投影，根据图的结构创建节点嵌入。另一个好处是，它很好地处理了有限的内存，这意味着它可以在沙箱中很好地工作。node2vec的工作方式类似于<a class="ae le" href="https://en.wikipedia.org/wiki/Word2vec" rel="noopener ugc nofollow" target="_blank"> word2vec </a>的NLP矢量化方法，其中为每个节点计算给定长度的随机游走。最后，GraphSAGE是一种归纳方法，这意味着当添加新节点时，您不需要重新计算整个图的嵌入，而对于其他两种方法，您必须这样做。此外，GraphSAGE能够使用每个节点的属性，这对于以前的方法是不可能的。</p><p id="2df0" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">因此，你可能会认为你应该总是使用GraphSAGE。但是，它比其他两种方法运行时间更长。例如，FastRP除了非常快(因此经常用于基线嵌入)之外，有时还可以提供非常高质量的嵌入。我们将在以后的博文中讨论嵌入结果的优化和比较。</p><p id="787b" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">现在让我们从一个内存图开始，看看使用FastRP创建嵌入的最基本的方法。我们将创建一个单部分、无方向的人物图:</p><pre class="kp kq kr ks gt nn nl no np aw nq bi"><span id="0372" class="nr lg iq nl b gy ns nt l nu nv">CALL gds.graph.create(<br/>    'people', {<br/>        Person: { label: 'Person' }<br/>    },<br/>    {<br/>     ALL_INTERACTS: { type: 'INTERACTS',<br/>            orientation: 'UNDIRECTED'<br/>        }<br/>    }<br/>)<br/>YIELD graphName, nodeCount, relationshipCount</span></pre><p id="a49e" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">请注意，当我们创建一个无向内存图时，您正在创建两个方向上的关系投影(自然和反向)。</p><p id="6f25" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">为了获得FastRP嵌入，我们将使用</p><pre class="kp kq kr ks gt nn nl no np aw nq bi"><span id="67e0" class="nr lg iq nl b gy ns nt l nu nv">CALL gds.fastRP.stream('people',<br/> {<br/>     embeddingDimension: 10<br/>    }<br/>)<br/>YIELD nodeId, embedding<br/>RETURN gds.util.asNode(nodeId).name AS name, embedding</span></pre><p id="9cf6" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">在这里，我们已经告诉FastRP创建一个10维向量，流式传输到屏幕上。最后一行使用<code class="fe ni nj nk nl b">gds.util.asNode()</code>将这些内部节点id转换成我们可以理解的东西(在本例中是角色名)。当我们运行它时，我们会得到如下结果:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nw"><img src="../Images/d094013fa6919a8b28f2007bf00e297d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EH4aoQgQvOEddaQFKfd_zg.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">FastRP嵌入。(图片由作者提供。)</p></figure><p id="8228" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">如果我们想将这些作为属性写入数据库，我们可以使用</p><pre class="kp kq kr ks gt nn nl no np aw nq bi"><span id="5ea1" class="nr lg iq nl b gy ns nt l nu nv">CALL gds.fastRP.write('people',<br/> {<br/>     embeddingDimension: 10,<br/>     writeProperty: 'fastrf_embedding'<br/>    }<br/>)</span></pre><p id="6a87" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">现在，如果你看一些人节点<code class="fe ni nj nk nl b">MATCH (p:Person) RETURN p LIMIT 3</code>你会看到，例如，詹姆·兰尼斯特给了我们</p><pre class="kp kq kr ks gt nn nl no np aw nq bi"><span id="c0ae" class="nr lg iq nl b gy ns nt l nu nv">{<br/>  "identity": 96,<br/>  "labels": [<br/>    "Knight",<br/>    "Person"<br/>  ],<br/>  "properties": {<br/>"fastrf_embedding": [<br/>      -0.57976233959198,<br/>      1.2105076313018799,<br/>      -0.7537267208099365,<br/>      -0.6507896184921265,<br/>      -0.23426271975040436,<br/>      -0.8760757446289062,<br/>      0.23972077667713165,<br/>      -0.07020065188407898,<br/>      -0.15781474113464355,<br/>      -0.4160367250442505<br/>    ],<br/>"pageRank": 13.522417121008036,<br/>"wcc_partition": 2,<br/>"gender": "male",<br/>"book_intro_chapter": "5",<br/>"name": "Jaime Lannister",<br/>"pageRank-1": 3.143866012990475,<br/>"community": 304,<br/>"title": "Ser",<br/>"age": 39,<br/>"birth_year": 266<br/>  }<br/>}</span></pre><p id="c61c" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">我们可以看到有一个很好的嵌入在等着我们。</p><h1 id="40b1" class="lf lg iq bd lh li lj lk ll lm ln lo lp kf lq kg lr ki ls kj lt kl lu km lv lw bi translated">这个系列的下一部是什么？</h1><p id="a8ac" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">在这篇文章中，我们演示了在Neo4j沙盒实例上创建FastRP嵌入。但是等等，node2vec或者GraphSAGE呢？！这些方法需要更多一点的内存，所以我们将把它们保存到以后的文章中，我们将用更多的计算能力来完成。因此，我们将在未来的博客文章中使用Docker容器来讨论这些，可以通过<a class="ae le" href="http://dev.neo4j.com/docker_neo_jupyter" rel="noopener ugc nofollow" target="_blank">这篇文章</a>找到它。我们还将花一些时间讨论如何调优这些不同的嵌入，这是任何基于ML的解决方案都需要的一个步骤。当然，如果我们不讨论常见的基于ML的解决方案，如自动节点分类或链接预测，我们会怎么样呢？敬请期待！</p></div></div>    
</body>
</html>