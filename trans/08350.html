<html>
<head>
<title>How To Use “yield” in Python?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中“yield”怎么用？</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-use-yield-in-python-5f1fbb864f94?source=collection_archive---------13-----------------------#2021-08-01">https://towardsdatascience.com/how-to-use-yield-in-python-5f1fbb864f94?source=collection_archive---------13-----------------------#2021-08-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/bf49be107287b7667dccd412dccfd954.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OE4iR3bZavK6kSKc1p6uYA.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">图片由<a class="ae jg" href="https://pixabay.com/users/kangbch-3007100/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=1684052" rel="noopener ugc nofollow" target="_blank"> kangbch </a>从<a class="ae jg" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=1684052" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>拍摄</p></figure><div class=""/><div class=""><h2 id="920d" class="pw-subtitle-paragraph kg ji jj bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dk translated">Python生成器——从基本用法到高级用法</h2></div><p id="9f2d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你是一个Python开发者，我相信你一定知道Python中的生成器。定义Python生成器的关键是使用“yield”关键字。Python生成器在我们需要大量集合、提高代码可读性以及多线程等特定场景中无处不在。</p><p id="ab2f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你可能知道也可能不知道如何正确使用“yield”关键字。在本文中，我将从基本用法开始介绍Python生成器。一些更高级的使用模式也将在后面的章节中介绍。</p><h1 id="3b36" class="lu lv jj bd lw lx ly lz ma mb mc md me kp mf kq mg ks mh kt mi kv mj kw mk ml bi translated">1.基础</h1><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/97fcf7392bd47171b656942f74ecd9ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*flbXHugXtWWoYIk90Dl29w.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">图片来自<a class="ae jg" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=640960" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>的<a class="ae jg" href="https://pixabay.com/users/pezibear-526143/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=640960" rel="noopener ugc nofollow" target="_blank"> Pezibear </a></p></figure><p id="a07b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们在本教程中编一个例子。假设我们公司有一群人，需要一个个随叫随到。所以，这将是一个轮换的花名册。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="8545" class="mv lv jj mr b gy mw mx l my mz">names = ['Alice', 'Bob', 'Chris', 'David', 'Emily']</span></pre><p id="14f5" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，我们想从这个名称列表中定义一个Python生成器。代码如下所示。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="ea0a" class="mv lv jj mr b gy mw mx l my mz">def gen_roster(names):<br/>    for name in names:<br/>        yield name</span></pre><p id="fbd2" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请注意，我们需要使用<code class="fe na nb nc mr b">yield</code>关键字而不是<code class="fe na nb nc mr b">return</code>，所以我们可以使用这个函数来制作一个生成器。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="0577" class="mv lv jj mr b gy mw mx l my mz">roster = gen_roster(names)</span></pre><p id="ac3d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对，就是这样。如果你想检查变量<code class="fe na nb nc mr b">roster</code>的类型，下面是结果。</p><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/3182c7fc7801ebbbd830beac67036622.png" data-original-src="https://miro.medium.com/v2/resize:fit:910/format:webp/1*5-uwJNdj39cdBwkQ-csJoA.png"/></div></figure><p id="5b03" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，我们有了<code class="fe na nb nc mr b">roster</code>。Python生成器也是可迭代的，所以我们可以把它放在一个for循环中，一次获得所有的名字。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="c00a" class="mv lv jj mr b gy mw mx l my mz">for name in roster:<br/>    print(name)</span></pre><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/9adf7522615a8be4731ed4ba81fe14f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:462/format:webp/1*d4ff-cyBsKinDtODokoARg.png"/></div></figure><h1 id="5db8" class="lu lv jj bd lw lx ly lz ma mb mc md me kp mf kq mg ks mh kt mi kv mj kw mk ml bi translated">2.得到下一个</h1><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/13ffeef376d9df3590f2f9d34ac3881b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FK8MeeLOT0Z361W9i4x5kg.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">来自<a class="ae jg" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=3474854" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>的<a class="ae jg" href="https://pixabay.com/users/couleur-1195798/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=3474854" rel="noopener ugc nofollow" target="_blank"> Couleur </a>的图像</p></figure><p id="d7e9" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">好吧，在前面的例子中，在for循环中使用生成器没有太大的意义。使用生成器的好处是我们可以一次得到一个值。当我们处理一个巨大的集合时，这可能非常有用。也就是说，当我们创建一个生成器时，这些项不会被读入内存。只有当我们试图获取下一项并点击<code class="fe na nb nc mr b">yield</code>关键字时，该项才会生成。</p><p id="0a00" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，无论如何，获得生成器的“下一个”元素是很重要的。在这种情况下，我们可以使用它的<code class="fe na nb nc mr b">__next__()</code>函数。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="cc9a" class="mv lv jj mr b gy mw mx l my mz">roster.__next__()</span></pre><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/ab862d99e1c4415d84328b8d79578c70.png" data-original-src="https://miro.medium.com/v2/resize:fit:442/format:webp/1*o7XNRuN73ce8iP30zvPr_A.png"/></div></figure><p id="36af" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">其实我们也可以这样做，这样更直观，也更容易记忆。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="355f" class="mv lv jj mr b gy mw mx l my mz">next(roster)</span></pre><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/fb4d42eda9d1d62d7074b3216dcc153e.png" data-original-src="https://miro.medium.com/v2/resize:fit:348/format:webp/1*sTnGuJuoOxhklUP-rrv1hw.png"/></div></figure><p id="a228" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你是否注意到当我们试图获取“下一个”项目时，“光标”被移动了？还记得我们在生成器的定义中定义了for循环吗？我们可以认为for循环将一次执行一次，直到到达关键字<code class="fe na nb nc mr b">yield</code>。</p><p id="6893" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这也意味着，我们的“光标”现在在第三个名字上。因此，如果我们试图输出所有剩余的项目，“Alice”和“Bob”将被跳过。</p><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/772b76aeab88d61b1098905e82bbcb1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:438/format:webp/1*SgTmTQ2vK37tefnXZNr0bA.png"/></div></figure><p id="ad65" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，“光标”在末尾。如果我们试图获取下一个项目，将会抛出一个错误，因为没有更多的项目。</p><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/2b3de2ce337f9a447f106cb6669c51b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1364/format:webp/1*ZfZkqfkY0JcZDpzrAfVQbg.png"/></div></figure><p id="1e0a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这实际上不是我们想要的，因为花名册将被用来决定谁将在当前的轮换中待命。换句话说，我们希望“光标”回到开头，这样所有的名字将再次循环。</p><p id="17fd" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">诀窍是简单地在for循环上面放一个<code class="fe na nb nc mr b">while True</code>语句。所以，一旦所有的名字都用完了，for循环就会重新开始。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="4119" class="mv lv jj mr b gy mw mx l my mz">def gen_roster(names):<br/>    while True:<br/>        for name in names:<br/>            yield name</span></pre><p id="a1b9" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，假设我们想要一个有12个名字的花名册。我们只有5名员工。因此，它们将被轮换。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="5920" class="mv lv jj mr b gy mw mx l my mz">for i in range(12):<br/>    print(next(roster))</span></pre><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/5eb03433a6766649dcf90330e242d799.png" data-original-src="https://miro.medium.com/v2/resize:fit:604/format:webp/1*xNDOz-gO0c9wG60aB2NXHg.png"/></div></figure><p id="c6fe" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我们不输入数字“12”，生成器可以无限期地生成更多的名字。</p><h1 id="62a1" class="lu lv jj bd lw lx ly lz ma mb mc md me kp mf kq mg ks mh kt mi kv mj kw mk ml bi translated">3.发送一个值</h1><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/4b31239ca844912bc06db416f55ada1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IoS2Zg3OUhhArFZXXfvDRw.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">图片由<a class="ae jg" href="https://pixabay.com/users/congerdesign-509903/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=3431122" rel="noopener ugc nofollow" target="_blank">设计</a>来自<a class="ae jg" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=3431122" rel="noopener ugc nofollow" target="_blank"> Pixabay </a></p></figure><p id="51b6" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">生成器的一个高级用法是向生成器发送一个值。该值将成为<strong class="la jk">当前</strong>产出表达式的结果，该方法返回生成器产出的<strong class="la jk">下一个</strong>值。</p><p id="43a3" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">所以，不要指望生成器会返回我们刚刚发送的值，因为它会返回下一个值。然而，我们可以用它在生成器内部做一些事情。例如，我们可以通过向一个无限生成器发送某个值来停止它。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="0490" class="mv lv jj mr b gy mw mx l my mz">def gen_roster(names):<br/>    while names:<br/>        for name in names:<br/>            current_name = yield name<br/>            if current_name == 'stop':<br/>                names = None<br/>                break</span></pre><p id="57f1" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果从外部发送一个值“stop ”,发生器将终止循环。因此，我们可以验证如下行为。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="2bda" class="mv lv jj mr b gy mw mx l my mz">roster = gen_roster(names)</span><span id="ae3a" class="mv lv jj mr b gy nk mx l my mz">for i in range(10):<br/>    if i == 3:<br/>        roster.send('stop')<br/>    print(next(roster))</span></pre><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/035464038840e171d253ea2b43dc3b3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1372/format:webp/1*FH1152tWN-RBwVUus9oqrA.png"/></div></figure><p id="0d83" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在上面的代码中，我们要求程序循环10次。然而，对于第四轮，我们将值“stop”传递给生成器。结果，只有3个名字被输出，并且发生器在第4轮停止，而不是循环10次。</p><p id="f07b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当我们想在多线程编程场景中改变生成器的行为或规则时，send方法将非常有用。</p><h1 id="ec55" class="lu lv jj bd lw lx ly lz ma mb mc md me kp mf kq mg ks mh kt mi kv mj kw mk ml bi translated">4.停止生成器—抛出异常并关闭</h1><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/1ac467f71d07800dab1857ae38e2fb69.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vnnfRmyGE03pxQvhGYnaCg.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">图片来自<a class="ae jg" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=3783066" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>的<a class="ae jg" href="https://pixabay.com/users/jolakalmuk-6823127/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=3783066" rel="noopener ugc nofollow" target="_blank">乔拉卡尔穆克</a></p></figure><p id="3f10" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当出现问题时，我们可以使用<code class="fe na nb nc mr b">throw()</code>方法在生成器暂停的地方引发一个异常。我们可以自定义错误类型。在本教程中，出于演示的目的，为了方便起见，我将简单地使用一个“类型错误”。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="c704" class="mv lv jj mr b gy mw mx l my mz">roster = gen_roster(names)</span><span id="564b" class="mv lv jj mr b gy nk mx l my mz">next_name = roster.throw(TypeError, 'Stop!')</span></pre><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nl"><img src="../Images/69d80860437cf48c865a8f0939ea3f8f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1372/format:webp/1*jLRJdd8JCWRRcKh9L5wcAA.png"/></div></div></figure><p id="5ed9" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果没有出错，但我们仍然想终止生成器，我们可以使用<code class="fe na nb nc mr b">close()</code>方法生成一个生成器。当我们有一个无限大的生成器，并且我们想在某个点停止它时，这将是非常有用的。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="7179" class="mv lv jj mr b gy mw mx l my mz">roster = gen_roster(names)</span><span id="94fd" class="mv lv jj mr b gy nk mx l my mz">for i in range(10):<br/>    if i == 3:<br/>        roster.close()<br/>    print(next(roster))</span></pre><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/03aabfbd23589d37b3cd6263c0c75159.png" data-original-src="https://miro.medium.com/v2/resize:fit:1392/format:webp/1*RC8pLlhLIAQ2u6pYDALFwg.png"/></div></figure><p id="3115" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">上面的代码在第四轮关闭了生成器“花名册”，所以当下一个循环试图获取下一个值时，异常被抛出。</p><h1 id="c521" class="lu lv jj bd lw lx ly lz ma mb mc md me kp mf kq mg ks mh kt mi kv mj kw mk ml bi translated">摘要</h1><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nn"><img src="../Images/7a9100ba35caa831a4013b1f2607108e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5JgVhPi3LZUeZ61kts6FtA.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">图片来自<a class="ae jg" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=192179" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>的<a class="ae jg" href="https://pixabay.com/users/realworkhard-23566/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=192179" rel="noopener ugc nofollow" target="_blank">拉尔夫·昆泽</a></p></figure><p id="62fe" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在本文中，我介绍了Python中最重要的“Python式”概念之一——生成器。关键字<code class="fe na nb nc mr b">yield</code>的用法是Python生成器的关键。</p><p id="2544" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">不仅介绍了基本用法，还介绍了一些高级用法，如从外部向生成器发送值、引发异常和关闭生成器。希望它能帮助你了解更多关于Python生成器的知识。</p><div class="is it gp gr iu no"><a href="https://medium.com/@qiuyujx/membership" rel="noopener follow" target="_blank"><div class="np ab fo"><div class="nq ab nr cl cj ns"><h2 class="bd jk gy z fp nt fr fs nu fu fw ji bi translated">通过我的推荐链接加入Medium克里斯托弗·陶</h2><div class="nv l"><h3 class="bd b gy z fp nt fr fs nu fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="nw l"><p class="bd b dl z fp nt fr fs nu fu fw dk translated">medium.com</p></div></div><div class="nx l"><div class="ny l nz oa ob nx oc ja no"/></div></div></a></div><p id="b6e0" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你觉得我的文章有帮助，请考虑加入Medium会员来支持我和成千上万的其他作者！(点击上面的链接)</p></div></div>    
</body>
</html>