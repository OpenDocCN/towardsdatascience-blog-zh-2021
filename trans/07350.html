<html>
<head>
<title>Functional “Control Flow” — Writing Programs without Loops</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">功能“控制流”——编写没有循环的程序</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/functional-control-flow-writing-programs-without-loops-ce07e6137bba?source=collection_archive---------25-----------------------#2021-07-04">https://towardsdatascience.com/functional-control-flow-writing-programs-without-loops-ce07e6137bba?source=collection_archive---------25-----------------------#2021-07-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="db07" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/tips-and-tricks" rel="noopener" target="_blank"> <em class="iy">小窍门</em> </a></h2><div class=""/><div class=""><h2 id="d716" class="pw-subtitle-paragraph jx ja iq bd b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko dk translated">控制流的函数式编程特性概述—没有循环和if-else</h2></div><h1 id="140c" class="kp kq iq bd kr ks kt ku kv kw kx ky kz kg la kh lb kj lc kk ld km le kn lf lg bi translated">概述</h1><p id="b433" class="pw-post-body-paragraph lh li iq lj b lk ll kb lm ln lo ke lp lq lr ls lt lu lv lw lx ly lz ma mb mc ij bi translated">在我上一篇关于<a class="ae md" rel="noopener" target="_blank" href="/3-key-principles-of-functional-programming-for-data-engineering-67d2b82c7483">函数式编程的关键原则</a>的文章中，我解释了函数式编程范例与命令式编程的不同之处，并讨论了幂等性和避免副作用的概念是如何与函数式编程中支持等式推理的引用透明性联系起来的。</p><p id="0144" class="pw-post-body-paragraph lh li iq lj b lk me kb lm ln mf ke lp lq mg ls lt lu mh lw lx ly mi ma mb mc ij bi translated">在我们深入了解函数式编程的一些特性之前，让我们从我写Scala代码的前三个月的个人轶事开始。</p><h1 id="e48e" class="kp kq iq bd kr ks kt ku kv kw kx ky kz kg la kh lb kj lc kk ld km le kn lf lg bi translated">函数代码中没有“如果-否则”</h1><p id="e1a6" class="pw-post-body-paragraph lh li iq lj b lk ll kb lm ln lo ke lp lq lr ls lt lu lv lw lx ly lz ma mb mc ij bi translated">我正在为一个定制的Spark UDF编写一个纯Scala函数，它基于一个用JSON字符串表示的定制分级调整来计算收入调整。当我试图用纯功能代码来表达业务逻辑时(因为这是团队的编码风格)，我对我感觉到的生产力下降感到非常沮丧，以至于我在代码中引入了“if-else”逻辑，试图“完成工作”。</p><p id="d3e3" class="pw-post-body-paragraph lh li iq lj b lk me kb lm ln mf ke lp lq mg ls lt lu mh lw lx ly mi ma mb mc ij bi translated">这么说吧，我在对那个特定的合并请求进行代码审查的过程中学到了一个非常艰难的教训。</p><p id="9d29" class="pw-post-body-paragraph lh li iq lj b lk me kb lm ln mf ke lp lq mg ls lt lu mh lw lx ly mi ma mb mc ij bi translated"><em class="mj">“函数代码中没有if-else，这不是命令式编程… </em> <strong class="lj jb"> <em class="mj">没有if，就没有else。</em></strong><em class="mj"/></p><p id="5158" class="pw-post-body-paragraph lh li iq lj b lk me kb lm ln mf ke lp lq mg ls lt lu mh lw lx ly mi ma mb mc ij bi translated">没有“if-else”，我们如何在函数式编程中写出“控制流”？</p><p id="5e8b" class="pw-post-body-paragraph lh li iq lj b lk me kb lm ln mf ke lp lq mg ls lt lu mh lw lx ly mi ma mb mc ij bi translated">简答:<strong class="lj jb">功能构成</strong>。</p><p id="9d7f" class="pw-post-body-paragraph lh li iq lj b lk me kb lm ln mf ke lp lq mg ls lt lu mh lw lx ly mi ma mb mc ij bi translated">最长的答案是:函数组合和函数数据结构的结合。</p><p id="cbf9" class="pw-post-body-paragraph lh li iq lj b lk me kb lm ln mf ke lp lq mg ls lt lu mh lw lx ly mi ma mb mc ij bi translated">由于对每个功能设计模式的深入探究可能相当冗长，本文的重点是提供一个函数组合的概述，以及它如何实现一个更直观的方法来设计数据管道。</p><h1 id="b72c" class="kp kq iq bd kr ks kt ku kv kw kx ky kz kg la kh lb kj lc kk ld km le kn lf lg bi translated">函数合成简介</h1><figure class="ml mm mn mo gt mp gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi mk"><img src="../Images/34752c4e317e14a0bdf26ec1e06338ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*dZNwn3tQS4QZ9bLl.jpg"/></div></div><p class="mw mx gj gh gi my mz bd b be z dk translated">功能构成(图片由作者提供)</p></figure><p id="4f94" class="pw-post-body-paragraph lh li iq lj b lk me kb lm ln mf ke lp lq mg ls lt lu mh lw lx ly mi ma mb mc ij bi translated">在数学中，<strong class="lj jb">函数合成</strong>是将两个函数<em class="mj"> f </em>和<em class="mj"> g </em>依次取值，形成一个复合函数<em class="mj"> h </em>，使得<em class="mj">h(x)= g(f(x)】</em>—函数<em class="mj"> g </em>应用于将函数<em class="mj"> f </em>应用于一个泛型输入<em class="mj"> x </em>的结果。在数学上，该操作可以表示为:</p><p id="a437" class="pw-post-body-paragraph lh li iq lj b lk me kb lm ln mf ke lp lq mg ls lt lu mh lw lx ly mi ma mb mc ij bi translated"><em class="mj"> f : X → Y，g:y→z⟹g♀f:x→z</em></p><p id="870f" class="pw-post-body-paragraph lh li iq lj b lk me kb lm ln mf ke lp lq mg ls lt lu mh lw lx ly mi ma mb mc ij bi translated">其中<em class="mj">g♀f</em>是复合函数。</p><p id="86b2" class="pw-post-body-paragraph lh li iq lj b lk me kb lm ln mf ke lp lq mg ls lt lu mh lw lx ly mi ma mb mc ij bi translated">直观地说，对于域<em class="mj"> X </em>中的所有值，复合函数将域<em class="mj"> Z </em>中的<em class="mj">X</em>X映射到域<em class="mj"> g(f(x)) </em>。</p><p id="2769" class="pw-post-body-paragraph lh li iq lj b lk me kb lm ln mf ke lp lq mg ls lt lu mh lw lx ly mi ma mb mc ij bi translated">用一个有用的类比来说明函数组合的概念，就是用一片面包和冷黄油在烤箱里做黄油吐司。有两种可能的操作:</p><ol class=""><li id="bb70" class="na nb iq lj b lk me ln mf lq nc lu nd ly ne mc nf ng nh ni bi translated">在烤箱中烘烤(操作f)</li><li id="0b4b" class="na nb iq lj b lk nj ln nk lq nl lu nm ly nn mc nf ng nh ni bi translated">将黄油涂在最宽的表面上(操作g)</li></ol><p id="4007" class="pw-post-body-paragraph lh li iq lj b lk me kb lm ln mf ke lp lq mg ls lt lu mh lw lx ly mi ma mb mc ij bi translated">如果我们先在烤箱里烤面包，然后把冷黄油涂在从烤箱里出来的面包的最宽表面上，我们会得到一片涂有冷黄油的烤面包。</p><p id="47c7" class="pw-post-body-paragraph lh li iq lj b lk me kb lm ln mf ke lp lq mg ls lt lu mh lw lx ly mi ma mb mc ij bi translated">如果我们先将冷黄油涂在面包最宽的表面上，然后在烤箱中烘烤涂有冷黄油的面包，我们会得到一片涂有<em class="mj">热黄油的烤面包</em>(<em class="mj">f♀g</em>)。而且我们知道<em class="mj">“冷黄油涂抹”！= "温黄油涂抹"</em>。</p><p id="920c" class="pw-post-body-paragraph lh li iq lj b lk me kb lm ln mf ke lp lq mg ls lt lu mh lw lx ly mi ma mb mc ij bi translated">从这些例子中，我们可以直观地推断出函数应用的顺序在函数合成中很重要。(<em class="mj">g♀f≠f♀g</em>)</p><p id="9bb7" class="pw-post-body-paragraph lh li iq lj b lk me kb lm ln mf ke lp lq mg ls lt lu mh lw lx ly mi ma mb mc ij bi translated">类似地，在设计数据管道时，我们经常通过将函数应用于其他函数的结果来编写数据转换。组合函数的能力鼓励<strong class="lj jb">将重复的代码段重构</strong>成函数，以实现<strong class="lj jb">可维护性</strong>和<strong class="lj jb">可重用性</strong>。</p><h1 id="8309" class="kp kq iq bd kr ks kt ku kv kw kx ky kz kg la kh lb kj lc kk ld km le kn lf lg bi translated">充当一级对象</h1><p id="a5a9" class="pw-post-body-paragraph lh li iq lj b lk ll kb lm ln lo ke lp lq lr ls lt lu lv lw lx ly lz ma mb mc ij bi translated">函数式编程中的核心思想是:<strong class="lj jb">函数就是值</strong>。</p><p id="1bcd" class="pw-post-body-paragraph lh li iq lj b lk me kb lm ln mf ke lp lq mg ls lt lu mh lw lx ly mi ma mb mc ij bi translated">这个特征意味着一个函数可以是[2，3]:</p><ol class=""><li id="976e" class="na nb iq lj b lk me ln mf lq nc lu nd ly ne mc nf ng nh ni bi translated">赋给变量</li><li id="1552" class="na nb iq lj b lk nj ln nk lq nl lu nm ly nn mc nf ng nh ni bi translated">作为参数传递给其他函数</li><li id="824f" class="na nb iq lj b lk nj ln nk lq nl lu nm ly nn mc nf ng nh ni bi translated">作为其他函数的值返回</li></ol><p id="5954" class="pw-post-body-paragraph lh li iq lj b lk me kb lm ln mf ke lp lq mg ls lt lu mh lw lx ly mi ma mb mc ij bi translated">为此，函数必须是运行时环境中的一级对象(并存储在数据结构中)——就像数字、字符串和数组一样。包括Scala在内的所有函数式语言以及Python等一些解释型语言都支持一级函数。</p><h1 id="4a3b" class="kp kq iq bd kr ks kt ku kv kw kx ky kz kg la kh lb kj lc kk ld km le kn lf lg bi translated">高阶函数</h1><p id="460c" class="pw-post-body-paragraph lh li iq lj b lk ll kb lm ln lo ke lp lq lr ls lt lu lv lw lx ly lz ma mb mc ij bi translated">函数作为一级对象的概念所产生的一个关键含义是，函数组合可以自然地表达为一个高阶函数。</p><p id="dfef" class="pw-post-body-paragraph lh li iq lj b lk me kb lm ln mf ke lp lq mg ls lt lu mh lw lx ly mi ma mb mc ij bi translated">高阶函数至少具有下列特性之一:</p><ol class=""><li id="2f3e" class="na nb iq lj b lk me ln mf lq nc lu nd ly ne mc nf ng nh ni bi translated">接受函数作为参数</li><li id="5b90" class="na nb iq lj b lk nj ln nk lq nl lu nm ly nn mc nf ng nh ni bi translated">将函数作为值返回</li></ol><p id="1572" class="pw-post-body-paragraph lh li iq lj b lk me kb lm ln mf ke lp lq mg ls lt lu mh lw lx ly mi ma mb mc ij bi translated">高阶函数的一个例子是<code class="fe no np nq nr b">map</code>。</p><p id="1a0a" class="pw-post-body-paragraph lh li iq lj b lk me kb lm ln mf ke lp lq mg ls lt lu mh lw lx ly mi ma mb mc ij bi translated">当我们查看Python内置函数<code class="fe no np nq nr b">map</code>的文档时，发现<code class="fe no np nq nr b">map</code>函数接受另一个函数和一个iterable作为输入参数，并返回一个产生结果的迭代器[4]。</p><p id="4075" class="pw-post-body-paragraph lh li iq lj b lk me kb lm ln mf ke lp lq mg ls lt lu mh lw lx ly mi ma mb mc ij bi translated">在Scala中，包<code class="fe no np nq nr b">scala.collections</code>中的每个集合类及其子集都包含由ScalaDoc [5]上的以下函数签名定义的<code class="fe no np nq nr b">map</code>方法:</p><pre class="ml mm mn mo gt ns nr nt nu aw nv bi"><span id="7e83" class="nw kq iq nr b gy nx ny l nz oa">def map[B](f: (A) =&gt; B): Iterable[B]    // for collection classes<br/>def map[B](f: (A) =&gt; B): Iterator[B]    // for iterators that access elements of a collection</span></pre><p id="1d21" class="pw-post-body-paragraph lh li iq lj b lk me kb lm ln mf ke lp lq mg ls lt lu mh lw lx ly mi ma mb mc ij bi translated">函数签名的意思是<code class="fe no np nq nr b">map</code>接受一个函数输入参数<code class="fe no np nq nr b">f</code>，而<code class="fe no np nq nr b">f</code>将一个<code class="fe no np nq nr b">A</code>类型的通用输入转换成一个<code class="fe no np nq nr b">B</code>类型的结果值。</p><p id="6e83" class="pw-post-body-paragraph lh li iq lj b lk me kb lm ln mf ke lp lq mg ls lt lu mh lw lx ly mi ma mb mc ij bi translated">为了对整数集合中的每个值求平方，<strong class="lj jb">迭代方法</strong>是遍历集合中的每个元素，对元素求平方，并将结果附加到随着每次迭代而长度扩展的结果集合中。</p><ul class=""><li id="5f4a" class="na nb iq lj b lk me ln mf lq nc lu nd ly ne mc ob ng nh ni bi translated">在Python中:</li></ul><pre class="ml mm mn mo gt ns nr nt nu aw nv bi"><span id="8de8" class="nw kq iq nr b gy nx ny l nz oa">def square(x):<br/>    return x * x<br/><br/>def main(args):</span><span id="225a" class="nw kq iq nr b gy oc ny l nz oa">    collection = [1,2,3,4,5]<br/>    # initialize list to hold results<br/>    squared_collection = []<br/>    # loop till the end of the collection<br/>    for num in collection:<br/>        # square the current number <br/>        squared = square(num)<br/>        # add the result to list<br/>        squared_collection.append(squared) <br/><br/>    print(squared_collection)</span></pre><p id="c2d5" class="pw-post-body-paragraph lh li iq lj b lk me kb lm ln mf ke lp lq mg ls lt lu mh lw lx ly mi ma mb mc ij bi translated">在迭代方法中，循环中的每次迭代都会发生两种状态变化:</p><ol class=""><li id="aea2" class="na nb iq lj b lk me ln mf lq nc lu nd ly ne mc nf ng nh ni bi translated">保存从<code class="fe no np nq nr b">square</code>函数返回的结果的<code class="fe no np nq nr b">squared</code>变量；和</li><li id="b210" class="na nb iq lj b lk nj ln nk lq nl lu nm ly nn mc nf ng nh ni bi translated">保存square函数结果的集合。</li></ol><p id="5909" class="pw-post-body-paragraph lh li iq lj b lk me kb lm ln mf ke lp lq mg ls lt lu mh lw lx ly mi ma mb mc ij bi translated">为了使用<strong class="lj jb">函数方法</strong>执行相同的操作(即不使用可变变量)，可以使用<code class="fe no np nq nr b">map</code>函数将集合中的每个元素“映射”到一个新集合，该新集合具有与输入集合相同数量的元素——通过对每个元素应用平方运算并将结果收集到新集合中。</p><ul class=""><li id="a61e" class="na nb iq lj b lk me ln mf lq nc lu nd ly ne mc ob ng nh ni bi translated">在Python中:</li></ul><pre class="ml mm mn mo gt ns nr nt nu aw nv bi"><span id="50f1" class="nw kq iq nr b gy nx ny l nz oa">def square(x):<br/>    return x * x<br/><br/>def main(args):<br/><br/>    collection = [1,2,3,4,5]<br/>    squared = list(map(square, collection))<br/>    print(squared)</span></pre><ul class=""><li id="42dd" class="na nb iq lj b lk me ln mf lq nc lu nd ly ne mc ob ng nh ni bi translated">在Scala中:</li></ul><pre class="ml mm mn mo gt ns nr nt nu aw nv bi"><span id="66c9" class="nw kq iq nr b gy nx ny l nz oa">object MapSquare {<br/><br/>    def square(x: Int): Int = {<br/>        x * x<br/>    }<br/><br/>    def main(args: Array[String]) {<br/><br/>        val collection = List[1,2,3,4,5]<br/>        val squared = collection.map(square)<br/>        println(squared)<br/>    }<br/>}</span></pre><p id="7576" class="pw-post-body-paragraph lh li iq lj b lk me kb lm ln mf ke lp lq mg ls lt lu mh lw lx ly mi ma mb mc ij bi translated">在这两个实现中，<code class="fe no np nq nr b">map</code>函数接受应用于值集合中每个元素的输入函数，并返回包含结果的新集合。由于<code class="fe no np nq nr b">map</code>具有接受另一个函数作为参数的属性，所以它是一个高阶函数。</p><p id="fc9a" class="pw-post-body-paragraph lh li iq lj b lk me kb lm ln mf ke lp lq mg ls lt lu mh lw lx ly mi ma mb mc ij bi translated">关于Python和Scala实现之间的差异，有一些简短的补充说明:</p><ul class=""><li id="3468" class="na nb iq lj b lk me ln mf lq nc lu nd ly ne mc ob ng nh ni bi translated">Python <code class="fe no np nq nr b">map</code> vs Scala <code class="fe no np nq nr b">map</code>:需要一个像<code class="fe no np nq nr b">list</code>这样的可迭代函数将Python <code class="fe no np nq nr b">map</code>函数返回的迭代器转换成可迭代函数。在Scala中，不需要将来自<code class="fe no np nq nr b">map</code>函数的结果显式转换为iterable，因为<code class="fe no np nq nr b">Iterable</code> trait中的所有方法都是根据抽象方法<code class="fe no np nq nr b">iterator</code>定义的，抽象方法<code class="fe no np nq nr b">iterator</code>返回<code class="fe no np nq nr b">Iterator</code> trait的一个实例，该实例一个接一个地产生集合的元素[6]。</li><li id="8d3c" class="na nb iq lj b lk nj ln nk lq nl lu nm ly nn mc ob ng nh ni bi translated">如何从函数中返回值:虽然在Python中使用了<code class="fe no np nq nr b">return</code>关键字来返回函数结果，但是在Scala中很少使用<code class="fe no np nq nr b">return</code>关键字。相反，在Scala中定义函数时，会计算函数声明中的最后一行，并返回结果值。事实上，在Scala中使用<code class="fe no np nq nr b">return</code>关键字对于函数式编程来说并不是一个好的实践，因为它放弃了当前的计算，并且不是引用透明的[7-8]。</li></ul><h1 id="69e5" class="kp kq iq bd kr ks kt ku kv kw kx ky kz kg la kh lb kj lc kk ld km le kn lf lg bi translated">匿名函数</h1><p id="e743" class="pw-post-body-paragraph lh li iq lj b lk ll kb lm ln lo ke lp lq lr ls lt lu lv lw lx ly lz ma mb mc ij bi translated">当使用高阶函数时，能够用函数文字或<strong class="lj jb">匿名函数</strong>调用输入函数参数通常是方便的，而不必在它们可以在高阶函数中使用之前将其定义为命名函数对象。</p><p id="fbb5" class="pw-post-body-paragraph lh li iq lj b lk me kb lm ln mf ke lp lq mg ls lt lu mh lw lx ly mi ma mb mc ij bi translated">在Python中，匿名函数也称为<strong class="lj jb"> lambda表达式</strong>，因为它们源于lambda演算。一个匿名函数是用关键字<code class="fe no np nq nr b">lambda</code>创建的，它不使用关键字<code class="fe no np nq nr b">def</code>或<code class="fe no np nq nr b">return</code>包装一个表达式。例如，Python中前面示例中的<code class="fe no np nq nr b">square</code>函数可以表示为<code class="fe no np nq nr b">map</code>函数中的匿名函数，其中lambda表达式<code class="fe no np nq nr b">lambda x: x * x</code>用作<code class="fe no np nq nr b">map</code>的函数输入参数:</p><pre class="ml mm mn mo gt ns nr nt nu aw nv bi"><span id="6e79" class="nw kq iq nr b gy nx ny l nz oa">def main(args):<br/><br/>    collection = [1,2,3,4,5]squared = map(lambda x: x * x, collection)<br/>    print(squared)</span></pre><p id="c12d" class="pw-post-body-paragraph lh li iq lj b lk me kb lm ln mf ke lp lq mg ls lt lu mh lw lx ly mi ma mb mc ij bi translated">在Scala中，匿名函数是按照<code class="fe no np nq nr b">=&gt;</code>符号定义的——其中函数参数定义在<code class="fe no np nq nr b">=&gt;</code>箭头的左边，函数表达式定义在<code class="fe no np nq nr b">=&gt;</code>箭头的右边。例如，Scala中前面示例中的<code class="fe no np nq nr b">square</code>函数可以用<code class="fe no np nq nr b">(x: Int) =&gt; x * x</code>语法表示为匿名函数，并用作<code class="fe no np nq nr b">map</code>的函数输入参数:</p><pre class="ml mm mn mo gt ns nr nt nu aw nv bi"><span id="c9f6" class="nw kq iq nr b gy nx ny l nz oa">object MapSquareAnonymous {<br/><br/>    def main(args: Array[String]) {<br/>        val collection = List[1,2,3,4,5]<br/>        val squared = collection.map((x: Int) =&gt; x * x)<br/>        println(squared) <br/>    }<br/>}</span></pre><p id="1653" class="pw-post-body-paragraph lh li iq lj b lk me kb lm ln mf ke lp lq mg ls lt lu mh lw lx ly mi ma mb mc ij bi translated">在高阶函数中使用匿名函数的一个关键好处是，单次使用的单表达式函数不需要显式包装在命名函数定义中，因此<strong class="lj jb">优化了代码行</strong>和<strong class="lj jb">提高了代码的可维护性</strong>。</p><h1 id="43e5" class="kp kq iq bd kr ks kt ku kv kw kx ky kz kg la kh lb kj lc kk ld km le kn lf lg bi translated">递归作为“函数迭代”的一种形式</h1><p id="7ac9" class="pw-post-body-paragraph lh li iq lj b lk ll kb lm ln lo ke lp lq lr ls lt lu lv lw lx ly lz ma mb mc ij bi translated"><strong class="lj jb">递归</strong>是自引用<strong class="lj jb">函数组合</strong>的一种形式——递归函数获取自身(较小实例)的结果，并将它们作为自身另一个实例的输入。为了防止递归调用的无限循环，需要一个<em class="mj">基本用例</em>作为终止条件，以便在不使用递归的情况下返回结果。</p><p id="cdc0" class="pw-post-body-paragraph lh li iq lj b lk me kb lm ln mf ke lp lq mg ls lt lu mh lw lx ly mi ma mb mc ij bi translated">递归的一个经典例子是阶乘函数，它被定义为所有小于或等于整数<em class="mj"> n </em>的正整数的乘积:</p><p id="ed96" class="pw-post-body-paragraph lh li iq lj b lk me kb lm ln mf ke lp lq mg ls lt lu mh lw lx ly mi ma mb mc ij bi translated"><em class="mj"> n！= n ⋅ (n-1) ⋅ (n-2)⋅⋯⋅3⋅2⋅1 </em></p><p id="0d41" class="pw-post-body-paragraph lh li iq lj b lk me kb lm ln mf ke lp lq mg ls lt lu mh lw lx ly mi ma mb mc ij bi translated">实现阶乘函数有两种可能的迭代方法:使用<code class="fe no np nq nr b">for</code>循环和使用<code class="fe no np nq nr b">while</code>循环。</p><ul class=""><li id="acf3" class="na nb iq lj b lk me ln mf lq nc lu nd ly ne mc ob ng nh ni bi translated">在Python中:</li></ul><pre class="ml mm mn mo gt ns nr nt nu aw nv bi"><span id="12c1" class="nw kq iq nr b gy nx ny l nz oa">def factorial_for(n):<br/>    # initialize variable to hold factorial<br/>    fact = 1<br/>    # loop from n to 1 in decrements of 1<br/>    for num in range(n, 1, -1):<br/>        # multiply current number with the current product<br/>        fact = fact * num<br/>    return fact<br/><br/>def factorial_while(n):<br/>    # initialize variable to hold factorial<br/>    fact = 1<br/>    # loop till n reaches 1<br/>    while n &gt;= 1:<br/>        # multiply current number with the current product<br/>        fact = fact * n<br/>        # subtract the number by 1<br/>        n = n - 1<br/>    return fact</span></pre><p id="569f" class="pw-post-body-paragraph lh li iq lj b lk me kb lm ln mf ke lp lq mg ls lt lu mh lw lx ly mi ma mb mc ij bi translated">在阶乘函数的两种迭代实现中，循环中的每次迭代都会发生两种状态变化:</p><ol class=""><li id="c5dd" class="na nb iq lj b lk me ln mf lq nc lu nd ly ne mc nf ng nh ni bi translated">存储当前产品的阶乘变量；和</li><li id="05c6" class="na nb iq lj b lk nj ln nk lq nl lu nm ly nn mc nf ng nh ni bi translated">被相乘的数字。</li></ol><p id="b9df" class="pw-post-body-paragraph lh li iq lj b lk me kb lm ln mf ke lp lq mg ls lt lu mh lw lx ly mi ma mb mc ij bi translated">为了使用<strong class="lj jb">函数方法</strong>实现阶乘函数，递归在将问题分成相同类型的子问题时非常有用——在本例中，子问题是<em class="mj"> n </em>和<em class="mj"> (n-1)的乘积！</em>。</p><p id="5f7b" class="pw-post-body-paragraph lh li iq lj b lk me kb lm ln mf ke lp lq mg ls lt lu mh lw lx ly mi ma mb mc ij bi translated">阶乘函数的基本递归方法如下所示:</p><ul class=""><li id="f4c5" class="na nb iq lj b lk me ln mf lq nc lu nd ly ne mc ob ng nh ni bi translated">在Python中:</li></ul><pre class="ml mm mn mo gt ns nr nt nu aw nv bi"><span id="13de" class="nw kq iq nr b gy nx ny l nz oa">def factorial(n):<br/>    # base case to return value<br/>    if n &lt;= 0: return 1<br/>    # recursive function call with another set of inputs<br/>    return n * factorial(n-1)</span></pre><ul class=""><li id="0e46" class="na nb iq lj b lk me ln mf lq nc lu nd ly ne mc ob ng nh ni bi translated">在Scala中:</li></ul><pre class="ml mm mn mo gt ns nr nt nu aw nv bi"><span id="6f3e" class="nw kq iq nr b gy nx ny l nz oa">def factorial(n: Int): Long = {<br/>    if (n &lt;= 0) 1 else n * factorial(n-1)<br/>}</span></pre><p id="0049" class="pw-post-body-paragraph lh li iq lj b lk me kb lm ln mf ke lp lq mg ls lt lu mh lw lx ly mi ma mb mc ij bi translated">对于基本递归方法，5的阶乘按以下方式计算:</p><pre class="ml mm mn mo gt ns nr nt nu aw nv bi"><span id="8d37" class="nw kq iq nr b gy nx ny l nz oa">factorial(5)<br/>if (5 &lt;= 0) 1 else 5 * factorial(5 - 1)<br/>5 * factorial(4)    // factorial(5) is added to call stack<br/>5 * (4 * factorial(3))  // factorial(4) is added to call stack<br/>5 * (4 * (3 * factorial(2)))    // factorial(3) is added to call stack<br/>5 * (4 * (3 * (2 * factorial(1))))  // factorial(2) is added to call stack<br/>5 * (4 * (3 * (2 * (1 * factorial(0)))))    // factorial(1) is added to call stack<br/>5 * (4 * (3 * (2 * (1 * 1)))) // factorial(0) returns 1 to factorial(1)<br/>5 * (4 * (3 * (2 * 1))) // factorial(1) return 1 * factorial(0) = 1 to factorial(2)<br/>5 * (4 * (3 * 2))   // factorial(2) return 2 * factorial(1) = 2 to factorial(3)<br/>5 * (4 * 6) // factorial(3) return 3 * factorial(2) = 6 to factorial(4)<br/>5 * 24  // factorial(4) returns 4 * factorial(3) = 24 to factorial(5)<br/>120 // factorial(5) returns 5 * factorial(4) = 120 to global execution context</span></pre><p id="95a2" class="pw-post-body-paragraph lh li iq lj b lk me kb lm ln mf ke lp lq mg ls lt lu mh lw lx ly mi ma mb mc ij bi translated">对于<em class="mj"> n = 5 </em>，阶乘函数的评估涉及对阶乘函数的6次递归调用，包括基本情况。</p><p id="45ae" class="pw-post-body-paragraph lh li iq lj b lk me kb lm ln mf ke lp lq mg ls lt lu mh lw lx ly mi ma mb mc ij bi translated">虽然与迭代方法相比，基本递归方法更接近于阶乘函数的定义(也更自然地)来表达阶乘函数，但它也使用更多的内存，因为每个函数调用都作为堆栈帧被推送到调用堆栈，并在函数调用返回值时从调用堆栈中弹出。</p><p id="1053" class="pw-post-body-paragraph lh li iq lj b lk me kb lm ln mf ke lp lq mg ls lt lu mh lw lx ly mi ma mb mc ij bi translated">对于更大的<em class="mj"> n </em>值，递归会随着对自身的更多函数调用而变得更深，并且更多的空间必须分配给调用栈。当存储函数调用所需的空间超过调用堆栈的容量时，就会发生<strong class="lj jb">堆栈溢出</strong>！</p><h1 id="7f28" class="kp kq iq bd kr ks kt ku kv kw kx ky kz kg la kh lb kj lc kk ld km le kn lf lg bi translated">尾部递归和尾部调用优化</h1><p id="c7f0" class="pw-post-body-paragraph lh li iq lj b lk ll kb lm ln lo ke lp lq lr ls lt lu lv lw lx ly lz ma mb mc ij bi translated">为了防止无限递归导致堆栈溢出和程序崩溃，必须对递归函数进行一些优化，以减少调用堆栈中堆栈帧的消耗。优化递归函数的一种可能方法是将其重写为一个<strong class="lj jb">尾递归</strong>函数。</p><p id="4665" class="pw-post-body-paragraph lh li iq lj b lk me kb lm ln mf ke lp lq mg ls lt lu mh lw lx ly mi ma mb mc ij bi translated">尾部递归函数递归调用自身，并且在递归调用返回后不执行任何计算。当一个函数调用除了返回函数调用的值之外什么也不做时，它就是一个<strong class="lj jb">尾调用</strong>。</p><p id="9d12" class="pw-post-body-paragraph lh li iq lj b lk me kb lm ln mf ke lp lq mg ls lt lu mh lw lx ly mi ma mb mc ij bi translated">在Scala等函数式编程语言中，<strong class="lj jb">尾调用优化</strong>通常包含在编译器中，以识别尾调用，并将递归编译为迭代循环，每次迭代都不会消耗堆栈帧。事实上，堆栈帧可以被递归函数和递归函数中被调用的函数重用[1]。</p><p id="6822" class="pw-post-body-paragraph lh li iq lj b lk me kb lm ln mf ke lp lq mg ls lt lu mh lw lx ly mi ma mb mc ij bi translated">通过这种优化，递归函数的空间性能可以从<em class="mj"> O(N) </em>减少到<em class="mj">O(1)</em>——从每次调用一个堆栈帧减少到所有调用一个堆栈帧[8]。在某种程度上，尾部递归函数是“函数迭代”的一种形式，其性能与循环相当。</p><p id="b146" class="pw-post-body-paragraph lh li iq lj b lk me kb lm ln mf ke lp lq mg ls lt lu mh lw lx ly mi ma mb mc ij bi translated">例如，阶乘函数可以在Scala中以尾部递归的形式表示:</p><pre class="ml mm mn mo gt ns nr nt nu aw nv bi"><span id="ade4" class="nw kq iq nr b gy nx ny l nz oa">def factorialTailRec(n: Int): Long = {<br/>    def fact(n: Int, product: Long): Long = {<br/>        if (n &lt;= 0) product<br/>        else fact(n-1, n * product)<br/>    }<br/><br/>    fact(n, 1)<br/>}</span></pre><p id="976b" class="pw-post-body-paragraph lh li iq lj b lk me kb lm ln mf ke lp lq mg ls lt lu mh lw lx ly mi ma mb mc ij bi translated">虽然在Scala中尾调用优化是在编译期间自动执行的，但Python却不是这样。此外，Python中有一个递归限制(缺省值为1000)，作为防止CPython实现的C调用堆栈溢出的措施。</p><h1 id="61b1" class="kp kq iq bd kr ks kt ku kv kw kx ky kz kg la kh lb kj lc kk ld km le kn lf lg bi translated">接下来是什么:高阶函数</h1><p id="31a4" class="pw-post-body-paragraph lh li iq lj b lk ll kb lm ln lo ke lp lq lr ls lt lu lv lw lx ly lz ma mb mc ij bi translated">在本帖中，我们将了解:</p><ol class=""><li id="ca62" class="na nb iq lj b lk me ln mf lq nc lu nd ly ne mc nf ng nh ni bi translated">功能组成</li><li id="27ea" class="na nb iq lj b lk nj ln nk lq nl lu nm ly nn mc nf ng nh ni bi translated">高阶函数是函数式编程的关键含义</li><li id="e9ba" class="na nb iq lj b lk nj ln nk lq nl lu nm ly nn mc nf ng nh ni bi translated">递归作为“函数迭代”的一种形式</li></ol><p id="cb8d" class="pw-post-body-paragraph lh li iq lj b lk me kb lm ln mf ke lp lq mg ls lt lu mh lw lx ly mi ma mb mc ij bi translated">我们找到“如果-否则”的替代词了吗？不完全是，但是我们现在知道如何使用高阶函数和尾部递归在函数式编程中编写“循环”。</p><p id="166c" class="pw-post-body-paragraph lh li iq lj b lk me kb lm ln mf ke lp lq mg ls lt lu mh lw lx ly mi ma mb mc ij bi translated">在下一篇文章中，我将更多地探讨高阶函数，以及如何将它们用于设计函数式数据管道。</p></div><div class="ab cl od oe hu of" role="separator"><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi"/></div><div class="ij ik il im in"><p id="2132" class="pw-post-body-paragraph lh li iq lj b lk me kb lm ln mf ke lp lq mg ls lt lu mh lw lx ly mi ma mb mc ij bi translated">想要更多关于我作为数据专业人员的学习历程的幕后文章吗？查看我的网站https://ongchinhwee.me ！</p></div><div class="ab cl od oe hu of" role="separator"><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi"/></div><div class="ij ik il im in"><h1 id="ed2a" class="kp kq iq bd kr ks ok ku kv kw ol ky kz kg om kh lb kj on kk ld km oo kn lf lg bi translated">参考</h1><p id="edfc" class="pw-post-body-paragraph lh li iq lj b lk ll kb lm ln lo ke lp lq lr ls lt lu lv lw lx ly lz ma mb mc ij bi translated">[1]保罗·丘萨诺和罗纳·比雅纳松，<a class="ae md" href="https://www.amazon.com/Functional-Programming-Scala-Paul-Chiusano/dp/1617290653" rel="noopener ugc nofollow" target="_blank">Scala中的函数式编程</a> (2014)</p><p id="08c5" class="pw-post-body-paragraph lh li iq lj b lk me kb lm ln mf ke lp lq mg ls lt lu mh lw lx ly mi ma mb mc ij bi translated">[2]阿尔文·亚历山大，<a class="ae md" href="https://fpsimplified.com/scala-fp-Functions-are-Variables.html" rel="noopener ugc nofollow" target="_blank">《函数也是变量》</a> (2018)，函数式编程简化版</p><p id="50c2" class="pw-post-body-paragraph lh li iq lj b lk me kb lm ln mf ke lp lq mg ls lt lu mh lw lx ly mi ma mb mc ij bi translated">[3] Steven F. Lott，<a class="ae md" href="https://www.amazon.com/Functional-Python-Programming-programming-built-dp-1788627067/dp/1788627067/ref=dp_ob_title_bk" rel="noopener ugc nofollow" target="_blank">函数式Python编程(第二版</a> ) (2018)</p><p id="f6aa" class="pw-post-body-paragraph lh li iq lj b lk me kb lm ln mf ke lp lq mg ls lt lu mh lw lx ly mi ma mb mc ij bi translated">[4] <a class="ae md" href="https://docs.python.org/3/library/functions.html#map" rel="noopener ugc nofollow" target="_blank">内置函数— Python 3.9.6文档</a></p><p id="bb90" class="pw-post-body-paragraph lh li iq lj b lk me kb lm ln mf ke lp lq mg ls lt lu mh lw lx ly mi ma mb mc ij bi translated">[5] <a class="ae md" href="https://www.scala-lang.org/api/2.13.6/scala/collection/Iterable.html" rel="noopener ugc nofollow" target="_blank"> Scala标准库2 . 13 . 6—Scala . collections . iterable</a></p><p id="26fd" class="pw-post-body-paragraph lh li iq lj b lk me kb lm ln mf ke lp lq mg ls lt lu mh lw lx ly mi ma mb mc ij bi translated">[6]<a class="ae md" href="https://docs.scala-lang.org/overviews/collections-2.13/trait-iterable.html" rel="noopener ugc nofollow" target="_blank">Trait Iterable | Collections | Scala文档</a></p><p id="ae6d" class="pw-post-body-paragraph lh li iq lj b lk me kb lm ln mf ke lp lq mg ls lt lu mh lw lx ly mi ma mb mc ij bi translated">[7]<a class="ae md" href="https://tpolecat.github.io/2014/05/09/return.html" rel="noopener ugc nofollow" target="_blank">tpolecat——不归之点</a></p><p id="d377" class="pw-post-body-paragraph lh li iq lj b lk me kb lm ln mf ke lp lq mg ls lt lu mh lw lx ly mi ma mb mc ij bi translated">【8】<a class="ae md" href="https://users.scala-lang.org/t/dont-use-return-in-scala/3688/42" rel="noopener ugc nofollow" target="_blank">Scala中不使用Return？—问题— Scala用户</a></p><p id="95ad" class="pw-post-body-paragraph lh li iq lj b lk me kb lm ln mf ke lp lq mg ls lt lu mh lw lx ly mi ma mb mc ij bi translated">[9] Michael R. Clarkson，<a class="ae md" href="https://www.cs.cornell.edu/courses/cs3110/2019sp/textbook/data/tail_recursion.html" rel="noopener ugc nofollow" target="_blank">尾部递归</a> (2021)，OCaml中的函数式编程</p></div><div class="ab cl od oe hu of" role="separator"><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi"/></div><div class="ij ik il im in"><p id="7331" class="pw-post-body-paragraph lh li iq lj b lk me kb lm ln mf ke lp lq mg ls lt lu mh lw lx ly mi ma mb mc ij bi translated"><em class="mj">原载于2021年7月4日</em><a class="ae md" href="https://ongchinhwee.me/learning-scala-functional-programming-features-control-flow/" rel="noopener ugc nofollow" target="_blank"><em class="mj">https://ongchinhwee . me</em></a><em class="mj">。</em></p></div></div>    
</body>
</html>