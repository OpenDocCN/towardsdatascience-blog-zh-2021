<html>
<head>
<title>Create a fast auto-documented, maintainable and easy-to-use Python API — CRUD routes and routing management</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">创建快速自动记录、可维护且易于使用的Python API——CRUD路由和路由管理</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/create-a-fast-auto-documented-maintainable-and-easy-to-use-python-api-crud-routes-and-routing-7e8f35ebda46?source=collection_archive---------28-----------------------#2021-10-05">https://towardsdatascience.com/create-a-fast-auto-documented-maintainable-and-easy-to-use-python-api-crud-routes-and-routing-7e8f35ebda46?source=collection_archive---------28-----------------------#2021-10-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4568" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">学习如何捕捉请求并获取它们所携带的信息</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e5b8457ef4cab6f79ff02ff27e80c99b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*jrob-mez4_AINggt"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">我们的API监听传入的请求(图片由唐纳德·詹纳蒂在<a class="ae ky" href="https://unsplash.com/photos/4qk3nQI3WHY" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上提供)</p></figure><p id="ce1e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<a class="ae ky" href="https://mikehuls.medium.com/create-a-fast-auto-documented-maintainable-and-easy-to-use-python-api-in-5-lines-of-code-with-4e574c00f70e" rel="noopener"> <strong class="lb iu">上一篇文章</strong> </a>中，我们已经用5行代码建立了一个API。我们已经安装了依赖项，并创建了一个工作API，只有一个简单的路径。在本文中，我们将进一步构建，用多种不同的途径充实API，向您展示使用FastAPI可以做的所有事情。然后，我们将关注如何以简洁明了的方式组织所有这些路线</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="366b" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">安装</h1><p id="8cea" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">为了让这篇文章尽可能容易理解，我们将假设我们正在为我们的博客网站编写一个API。目标是创建一些我们可以CRUD(创建、读取、更新、删除)的公共路径:</p><ul class=""><li id="8bc6" class="na nb it lb b lc ld lf lg li nc lm nd lq ne lu nf ng nh ni bi translated">添加新文章</li><li id="d4d3" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">从数据库中检索文章</li><li id="3761" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">更新文章以修复打字错误，例如</li><li id="68ef" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">删除一篇文章</li></ul><p id="0d1d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将专注于捕捉请求和提取信息。我们的API如何与我们的数据库通信是另一个主题，在本文的<a class="ae ky" href="https://mikehuls.medium.com/dramatically-improve-your-database-inserts-with-a-simple-upgrade-6dfa672f1424" rel="noopener"><strong class="lb iu"/></a>中有很好的描述。也可以查看本文 中的<a class="ae ky" href="https://mikehuls.medium.com/version-control-your-database-part-1-creating-migrations-and-seeding-992d86c90170" rel="noopener"> <strong class="lb iu">来创建一个版本控制的数据库结构。</strong></a></p><p id="8000" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于我们的API将负责捕捉请求并获取它们携带的信息，所以让我们首先快速检查一下请求是如何工作的，以便我们可以准确地为我们的API创建端点来捕捉所有信息。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d2659596907944e4168273d08fba9260.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*rTrRpfRuuXzVYBcR"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">要求近距离拍摄(图片由<a class="ae ky" href="https://unsplash.com/@yassine_khalfalli" rel="noopener ugc nofollow" target="_blank"> Jassine Khalfalli </a>在<a class="ae ky" href="https://unsplash.com/photos/_c70Nhh6p44" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄)</p></figure><h1 id="a52a" class="md me it bd mf mg no mi mj mk np mm mn jz nq ka mp kc nr kd mr kf ns kg mt mu bi translated">请求</h1><p id="0397" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">让我们稍微简化一下，假设一个请求由一个<code class="fe nt nu nv nw b">URL</code>、一个<code class="fe nt nu nv nw b">HTTP method</code>和一个可选的<code class="fe nt nu nv nw b">body</code>组成。在我们的API中实现它们之前，我们将快速浏览每一个。</p><h2 id="7cb7" class="nx me it bd mf ny nz dn mj oa ob dp mn li oc od mp lm oe of mr lq og oh mt oi bi translated">剖析URL</h2><p id="9947" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">我假设你对网址很熟悉，因为你在使用互联网时必须把它们输入浏览器。为了我们的API，让我们把下面的URL分成与我们相关的3个部分。</p><blockquote class="oj"><p id="d8b3" class="ok ol it bd om on oo op oq or os lu dk translated"><a class="ae ky" href="https://www.github.com/mike-huls?tab=overview&amp;lang=en" rel="noopener ugc nofollow" target="_blank">https://www.github.com/mike-huls?tab=overview&amp;郎=恩</a></p></blockquote><ol class=""><li id="8af6" class="na nb it lb b lc ot lf ou li ov lm ow lq ox lu oy ng nh ni bi translated"><a class="ae ky" href="https://github.com" rel="noopener ugc nofollow" target="_blank">https://www.github.com</a><br/>这部分指定网站托管的<strong class="lb iu">服务器</strong>的位置。</li><li id="baae" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu oy ng nh ni bi translated">/mike-huls <br/>路径<strong class="lb iu">路径</strong>。这指定了我们想要在网站上访问的资源(文件)的确切位置。把它想象成你计算机上的一个文件系统；就像<code class="fe nt nu nv nw b">c:/users/mike/mystuff</code>一样。</li><li id="0ed1" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu oy ng nh ni bi translated">？tab=overview&amp;lang=en <br/>问号是查询字符串分隔符。它将到特定资源的路由与将被传递给资源的<strong class="lb iu">查询参数</strong>分开。参数成对传递，用“&amp;”分隔。</li></ol><p id="b16e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">总之:我们向<code class="fe nt nu nv nw b"><a class="ae ky" href="https://www.github.com/mike-huls?tab=overview" rel="noopener ugc nofollow" target="_blank">https://www.github.com</a></code>发送一个请求，在<code class="fe nt nu nv nw b">/mike-huls</code>的服务器上搜索我们的资源，然后给资源传递一些查询参数，即<code class="fe nt nu nv nw b">tab=overview</code>和<code class="fe nt nu nv nw b">lang=en</code>。我们将在以后创建路线时使用这些术语。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h2 id="98a3" class="nx me it bd mf ny nz dn mj oa ob dp mn li oc od mp lm oe of mr lq og oh mt oi bi translated">HTTP方法</h2><p id="ed75" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">方法(也称为“动词”)用于在发送请求时区分不同的(HTTP)操作。虽然还有很多，但对于本文，我们将使用主要的4:</p><ul class=""><li id="1e38" class="na nb it lb b lc ld lf lg li nc lm nd lq ne lu nf ng nh ni bi translated">获取—用于检索数据</li><li id="476f" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">发布-用于提交数据</li><li id="b266" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">上传—用于更新数据</li><li id="217c" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">删除—用于删除数据</li></ul><p id="5b7e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我愿意把这些方法看作是区分你的目标的额外数据。</p><h2 id="3488" class="nx me it bd mf ny nz dn mj oa ob dp mn li oc od mp lm oe of mr lq og oh mt oi bi translated">请求正文</h2><p id="499a" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">主体是我们想要发送的实际数据。在我们的例子中，我们可以发布一篇新文章，这样我们的API就可以将它插入到数据库中。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/94cacade84c71cc4203f110cd062d30a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wN6U6Dpz94d1IOid"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在我们的API中路由不同类型的请求(图片由<a class="ae ky" href="https://unsplash.com/@soymeraki" rel="noopener ugc nofollow" target="_blank"> Javier Allegue Barros </a>在<a class="ae ky" href="https://unsplash.com/photos/C7B-ExXpOIE" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上提供)</p></figure><h1 id="54bc" class="md me it bd mf mg no mi mj mk np mm mn jz nq ka mp kc nr kd mr kf ns kg mt mu bi translated">创建我们的API</h1><p id="c3ac" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">记住，请求由一个URL和一个方法组成。为了捕捉这些，我们需要为不同类型的请求创建特定的路由。在路线中，我们需要指定(至少)两件事:</p><ul class=""><li id="d9d6" class="na nb it lb b lc ld lf lg li nc lm nd lq ne lu nf ng nh ni bi translated">路径(捕捉URL的路径</li><li id="0f83" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">一个方法(捕捉请求的HTTP方法)</li></ul><p id="5e50" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来看看创建、读取、更新和删除文章(CRUD)所需的所有操作。我们将从最简单的开始:检索文章。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h2 id="ac4c" class="nx me it bd mf ny nz dn mj oa ob dp mn li oc od mp lm oe of mr lq og oh mt oi bi translated">简单阅读:检索所有文章的路径</h2><p id="06f9" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">最简单的途径是检索所有文章。看起来是这样的:</p><pre class="kj kk kl km gt oz nw pa pb aw pc bi"><span id="73ba" class="nx me it nw b gy pd pe l pf pg">@app.get("/all_articles")<br/>def get_all_articles():<br/>    return function_that_retrieves_all_articles()</span></pre><p id="4e9f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">两件事很重要。首先注意我们使用了GET方法(用<code class="fe nt nu nv nw b">@app.get</code>表示)。第二个是我们指定路径的地方:GET方法中的<code class="fe nt nu nv nw b">articles</code>部分。这定义了到此路由的路径。对这个路由的get请求可能类似于:<code class="fe nt nu nv nw b"><a class="ae ky" href="http://mikehuls.medium.com/" rel="noopener">www.ourbloggingwebsite.com/all_articles</a></code>，它将从数据库中检索我们所有的文章。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h2 id="886b" class="nx me it bd mf ny nz dn mj oa ob dp mn li oc od mp lm oe of mr lq og oh mt oi bi translated">使用查询参数读取:检索一篇文章的路线</h2><p id="821b" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">检索所有文章对于获得我们所有文章的概览来说是非常好的，但是如果用户只想阅读一篇文章呢？让我们创建另一个只检索一篇文章的路径:</p><pre class="kj kk kl km gt oz nw pa pb aw pc bi"><span id="0a9e" class="nx me it nw b gy pd pe l pf pg">@app.get("/article")<br/>def get_one_article(articleId:int):<br/>    return function_that_retrieves_article(articleId=articleId)</span></pre><p id="77e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，这条路线看起来与前一条非常相似。它仍然使用get方法，但是路径略有不同:函数现在需要一个参数；我们必须提供一个文章Id。这称为查询参数。对该路由的GET请求如下所示:<code class="fe nt nu nv nw b"><a class="ae ky" href="https://mike-huls.github.io/" rel="noopener ugc nofollow" target="_blank">www.ourbloggingwebsite.com/article?articleId=1</a></code>。这将只返回一篇文章，即articleId =1的文章。</p><p id="e85f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以在这条路线上增加一点这样的东西</p><pre class="kj kk kl km gt oz nw pa pb aw pc bi"><span id="a358" class="nx me it nw b gy pd pe l pf pg">@app.get("/article")<br/>@app.get("/article/{articleId}")<br/>def get_one_article(articleId:int):<br/>    return dbConnection.get_one_article(articleId=articleId)</span></pre><p id="7fb5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，我们在这里添加了第二行；它允许用户使用查询参数如<code class="fe nt nu nv nw b">/article?articleId=1</code> <em class="lv">和路径如<code class="fe nt nu nv nw b">/article/1</code>检索文章。我们可以使用两条线或只用一条线。</em></p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h2 id="fd0f" class="nx me it bd mf ny nz dn mj oa ob dp mn li oc od mp lm oe of mr lq og oh mt oi bi translated">删除:删除文章的途径</h2><p id="e4e6" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">delete语句的工作方式与带有查询参数的GET完全相同，它使用查询参数进行筛选。</p><pre class="kj kk kl km gt oz nw pa pb aw pc bi"><span id="e84f" class="nx me it nw b gy pd pe l pf pg">@app.delete("/article")<br/>def delete_one_article(articleId:int):<br/>    return dbConnection.delete_one_article(articleId=articleId)</span></pre><p id="a3d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，它与前面的方法非常相似，唯一的例外是我们在第一行中使用了DELETE方法。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h2 id="b554" class="nx me it bd mf ny nz dn mj oa ob dp mn li oc od mp lm oe of mr lq og oh mt oi bi translated">创建:发布新文章的途径</h2><p id="5226" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">让我们来看看现有的东西。插入新文章。路线看起来像这样:</p><pre class="kj kk kl km gt oz nw pa pb aw pc bi"><span id="5fd3" class="nx me it nw b gy pd pe l pf pg">@app.post("/article")<br/>def post_article(body:dict):<br/>    return dbConnection.post_article(articleJson=body)</span></pre><p id="a011" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">再次注意，我们使用的是发送到/article路径的帖子。FastAPI从请求中获取主体数据，并将其传递给负责将其插入数据库的函数。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h2 id="7a9e" class="nx me it bd mf ny nz dn mj oa ob dp mn li oc od mp lm oe of mr lq og oh mt oi bi translated">更新:更新现有文章的途径</h2><p id="8cb2" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">更新将来自GET的查询参数和来自POST请求的主体的查询参数组合在一起:</p><pre class="kj kk kl km gt oz nw pa pb aw pc bi"><span id="8d47" class="nx me it nw b gy pd pe l pf pg">@app.put("/article")<br/>@app.put("/article/{articleId}")<br/>def update_article(articleId:int, body:dict):<br/>    return dbConnection.update_article(articleId=articleId, articleJson=body)</span></pre><p id="f1ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，它接收一个articleId和一个body。我们可以用这些来替换数据库中的记录；我们使用articleId查找它，然后用articleJson中的数据替换它。轻松点。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="c608" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">组织路线</h1><p id="7834" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">我们刚刚创建的所有路线都是为了一件事:修改文章。如果我们也有故事呢？有了所有这些途径，你可以想象你的项目会很快变得混乱。谢天谢地，组织这些路线很容易。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/0ffceb16c56284ed30b011d223851c60.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Th9NBJJ-pGF6MFhU"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">我们的路线整洁有序(图片由<a class="ae ky" href="https://unsplash.com/@martin_lostak" rel="noopener ugc nofollow" target="_blank"> Martin Lostak </a>在<a class="ae ky" href="https://unsplash.com/photos/Gzu-sNr19TU" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄)</p></figure><p id="d87d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将创建一个名为<code class="fe nt nu nv nw b">article_routes.py</code>的文件，并添加以下代码:</p><pre class="kj kk kl km gt oz nw pa pb aw pc bi"><span id="c777" class="nx me it nw b gy pd pe l pf pg">from fastapi import APIRouter<br/>router_articles = APIRouter()</span></pre><p id="8a69" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">添加完这段代码后，我们可以使用路由器来捕捉请求。我们只需将前一章中编写的所有代码片段粘贴到<code class="fe nt nu nv nw b">article_routes.py</code>中。</p><pre class="kj kk kl km gt oz nw pa pb aw pc bi"><span id="f626" class="nx me it nw b gy pd pe l pf pg">@router_articles.get("/article")<br/>def get_one_article(articleId:int):<br/>    return function_that_retrieves_article(articleId=articleId)</span></pre><p id="6c29" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那些对细节有敏锐眼光的人注意到了一件事:在前一部分，我们用<code class="fe nt nu nv nw b">@app.get(....)</code>修饰了函数。在上面的例子中，我们必须使用<code class="fe nt nu nv nw b">@router_articles</code>，因为这是我们的新路由器。点击 查看此文件<a class="ae ky" href="https://github.com/mike-huls/fastapi_2/blob/main/routes/article_routes.py" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">的最终版本。</strong></a></p><p id="294a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后一步是转到我们的<code class="fe nt nu nv nw b">main.py</code>文件，告诉它将某些请求重定向到我们的新文件。我们将所有与文章有关的请求重定向到我们的文章路由器，方法是导入它并告诉FastAPI重定向某些请求。我们的main.py文件现在简洁明了:</p><pre class="kj kk kl km gt oz nw pa pb aw pc bi"><span id="535e" class="nx me it nw b gy pd pe l pf pg">from fastapi import FastAPI<br/>from routes.article_routes import router_articles<br/><br/>app = FastAPI()<br/>app.include_router(router=router_articles, prefix='/articles')</span></pre><p id="3119" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们开始处理故事时，我们可以轻松地包括一个新的路由器，并在其中编写我们所需的所有代码！轻松又有条理。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="2231" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">结论/TL；速度三角形定位法(dead reckoning)</h1><p id="39d4" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated"><a class="ae ky" href="https://github.com/mike-huls/fastapi_2" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">在这里</strong> </a> <strong class="lb iu">查看最终api的回购。</strong></p><p id="e461" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本文主要关注什么是请求，以及我们如何在路由中从这些请求中获取不同类型的信息。有了这些知识，你就可以创建一个非常好的API了。在下一篇文章中，我们将关注于为我们的路线定义<strong class="lb iu">模型</strong>。有了这些，我们就可以在将数据传递给数据库之前对其进行<strong class="lb iu">清理和检查。此外，我们将重点关注<strong class="lb iu">安全性</strong>；例如，只有经过认证的访问，或者您必须提供密码。订阅敬请关注！</strong></p><p id="0392" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你有建议/澄清，请评论，以便我可以改进这篇文章。同时，查看我的其他关于各种编程相关主题的文章。</p><p id="e887" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">编码快乐！</p><p id="961d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">—迈克</p><p id="5bc6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">页（page的缩写）学生:比如我正在做的事情？跟我来！</p></div></div>    
</body>
</html>