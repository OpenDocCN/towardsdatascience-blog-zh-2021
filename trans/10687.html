<html>
<head>
<title>From Jupyter Notebook to Deployment — A Straightforward Example</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从Jupyter笔记本到部署—一个简单的例子</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/from-jupyter-notebook-to-deployment-a-straightforward-example-1838c203a437?source=collection_archive---------1-----------------------#2021-10-14">https://towardsdatascience.com/from-jupyter-notebook-to-deployment-a-straightforward-example-1838c203a437?source=collection_archive---------1-----------------------#2021-10-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1a88" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">一步一步的例子，采用典型的机器学习研究代码，构建一个生产就绪的微服务。</h2></div><p id="3aed" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">本文旨在作为我作为数据科学家的旅程的一个整合示例，从Jupyter笔记本格式的一个典型已解决问题开始，并将其发展为一个已部署的微服务。虽然会有代码，但这不是一个教程，而是一个逐步说明我在将数据科学解决方案投入生产时所面临的挑战和解决方案的示例。我也不认为我一路走来所做的选择是做事的唯一方式，而是希望它能为将来可能面临类似任务的其他人提供一个有用的例子。</p><p id="7170" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这篇文章的配套代码可以在我的GitHub账户上找到，原始的Jupyter笔记本<a class="ae le" href="https://github.com/alanjeffares/notebook-to-microservice/blob/master/original_notebook.ipynb" rel="noopener ugc nofollow" target="_blank">在这里</a>和最终的完整项目<a class="ae le" href="https://github.com/alanjeffares/notebook-to-microservice/tree/master/Step%204%20-%20Deployment" rel="noopener ugc nofollow" target="_blank">在这里</a>。我将包括这些变化的片段，以演示我们讨论的各种主题，但这并不是对所有变化的完整描述。在这篇文章中，我将关注我所采取的每一步的过程和动机。</p><p id="350e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">朱庇特笔记本解决方案(</strong> <a class="ae le" href="https://github.com/alanjeffares/notebook-to-microservice/blob/master/original_notebook.ipynb" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu">代号</strong> </a> <strong class="kk iu"> ) </strong></p><p id="a7df" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个玩具解决方案旨在充当数据科学家建模输出的高度简化的示例。我们可以想象，任务是建立一个分类器，给定鸢尾花的一些测量值，预测该观察值的确切种类。数据科学家获得了<a class="ae le" href="https://en.wikipedia.org/wiki/Iris_flower_data_set" rel="noopener ugc nofollow" target="_blank"> Fisher著名的iris数据集</a>，并构建了一个管道来可视化和预处理数据，然后训练和评估一个简单的模型。这个模型现在可以用来预测任何新的观察结果。本文的目标是描述将这种典型的研究成果投入生产的步骤。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi lf"><img src="../Images/11d0f5a656c8793f97c9fb84ab283f6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1040/format:webp/1*Z9j63nWnGqIZJsuVoUCdUg.jpeg"/></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">罗纳德·费雪在1936年引入了著名的鸢尾花数据集。</p></figure><p id="c514" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">第一步:重构，代码风格和测试(</strong> <a class="ae le" href="https://github.com/alanjeffares/notebook-to-microservice/tree/master/Step%201%20-%20Refactoring%2C%20code%20style%20and%20testing" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu">代码</strong> </a> <strong class="kk iu"> ) </strong></p><p id="eb77" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第一步是将笔记本<a class="ae le" href="https://www.python-course.eu/python3_modules_and_modular_programming.php" rel="noopener ugc nofollow" target="_blank">模块化</a>成一个合理的文件夹结构，这实际上意味着将文件从<code class="fe lr ls lt lu b">.ipynb</code>格式转换成<code class="fe lr ls lt lu b">.py</code>格式，确保每个脚本都有明确的目的，并以连贯的方式组织这些文件。我采用了下面的标准布局，但这是灵活的，应该适应不同的用例。</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="lv lw l"/></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">我们的文件结构最终会是什么样子。</p></figure><p id="5b61" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一旦项目结构良好，我们就可以整理或重构代码。例如，考虑下面的代码块，它执行对数据进行分层训练测试分割的任务:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="lv lw l"/></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">分层分离逻辑来自我们最初的Jupyter笔记本。</p></figure><p id="8048" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在当前的格式中，不清楚这段代码到底在做什么，它不可重用，也无法测试。为了减轻这种情况，我们可以用文档和<a class="ae le" href="https://www.python.org/dev/peps/pep-0484/" rel="noopener ugc nofollow" target="_blank">类型提示</a>将它重写为一个函数。</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="lv lw l"/></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">重构的分层分裂函数。</p></figure><p id="06cb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个看起来好多了，遵循<a class="ae le" href="https://www.python.org/dev/peps/pep-0008/" rel="noopener ugc nofollow" target="_blank"> pep8风格指南</a>。事实上，我们可以通过使用<a class="ae le" href="https://pypi.org/project/pycodestyle/" rel="noopener ugc nofollow" target="_blank"> pycodestyle </a>这样的<a class="ae le" href="https://en.wikipedia.org/wiki/Lint_(software)" rel="noopener ugc nofollow" target="_blank">林挺</a>包来确保整个项目符合pep8。一旦安装了这个包，我们就可以导航到项目的根目录，并在命令行上运行<code class="fe lr ls lt lu b">pycodestyle src</code>。这将列出任何pep8问题的位置和详细信息。我们甚至可以更进一步，使用像<a class="ae le" href="https://pypi.org/project/autopep8/" rel="noopener ugc nofollow" target="_blank"> autopep8 </a>这样的包，它可以自动格式化pycodestyle标识的任何代码。</p><p id="233e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们还应该简单地谈一下测试。有大量关于代码测试的文献(例如参见<a class="ae le" href="https://realpython.com/python-testing/" rel="noopener ugc nofollow" target="_blank">这里的</a>，但是我们将在这个项目中只实现单元测试。这些测试相互独立地测试代码的最小可能单元。对于我们前面例子中的<code class="fe lr ls lt lu b">stratified_split()</code>函数，单元测试可能看起来像这样:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="lv lw l"/></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">对我们的<em class="ly">分层分离</em>函数的单元测试。</p></figure><p id="f298" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">通过运行这段代码，我们将检查函数输出在许多预定义的情况下是否符合预期。这证实了我们现有的代码正在正常工作，但它也确保了如果任何未来的更改导致该函数停止正常工作，我们可以在该错误导致这些测试失败时及早发现它。</p><p id="caed" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">第二步:协同(</strong> <a class="ae le" href="https://github.com/alanjeffares/notebook-to-microservice/tree/master/Step%202%20-%20Collaberation" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu">代码</strong> </a> <strong class="kk iu"> ) </strong></p><p id="c166" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">任何大规模的项目都不太可能是单个人工作的产物，因此出于这个原因，我们将讨论<a class="ae le" href="https://en.wikipedia.org/wiki/Version_control" rel="noopener ugc nofollow" target="_blank">版本控制</a>。版本控制工具，如<a class="ae le" href="https://git-scm.com/" rel="noopener ugc nofollow" target="_blank"> git </a>是一个记录项目随时间变化的系统，允许多个用户将变化分支并合并到一个存储库中。有很多关于使用版本控制的<a class="ae le" href="https://betterexplained.com/articles/a-visual-guide-to-version-control/" rel="noopener ugc nofollow" target="_blank">的原则和最佳实践的文章，但是我们假设大部分数据科学工作已经完成，因此我们将专注于一个叫做<code class="fe lr ls lt lu b">pre-commit.sh</code>的有用文件。这就是所谓的</a><a class="ae le" href="https://git-scm.com/book/en/v2/Customizing-Git-Git-Hooks" rel="noopener ugc nofollow" target="_blank"> git钩子</a>，git提供的一个有用的特性，它允许在某些重要的动作发生时运行定制脚本——在本例中是命令<code class="fe lr ls lt lu b">git commit</code>。我们可以使用这个特性在任何提交之前方便地运行<code class="fe lr ls lt lu b">test-all.sh</code>脚本，这反过来运行我们所有的单元测试以及pycodestyle检查，只有在没有失败的情况下才允许提交继续进行。这个过程确保对存储库的任何更改都不会破坏现有的功能，并且符合pep8。</p><p id="b6db" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">另一个对协作有用的文件是名为<code class="fe lr ls lt lu b">requirements.txt</code>的需求文件。该文件保存在项目根目录下，列出了整个项目中使用的所有Python包。该项目的任何新用户都可以简单地使用<a class="ae le" href="https://pypi.org/project/pip/" rel="noopener ugc nofollow" target="_blank"> pip </a>通过下面的命令来安装这些需求。</p><pre class="lg lh li lj gt lz lu ma mb aw mc bi"><span id="62a9" class="md me it lu b gy mf mg l mh mi">pip install -r requirements.txt</span></pre><p id="a1cf" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">创建一个<code class="fe lr ls lt lu b">requirements.txt</code>也非常简单。假设我们已经为这个项目使用了一个虚拟环境，如<a class="ae le" href="https://docs.python.org/3/library/venv.html" rel="noopener ugc nofollow" target="_blank"> venv </a>或<a class="ae le" href="https://docs.conda.io/projects/conda/en/latest/user-guide/tasks/manage-environments.html" rel="noopener ugc nofollow" target="_blank"> conda </a>并安装了所有的包，我们可以通过激活环境并运行</p><pre class="lg lh li lj gt lz lu ma mb aw mc bi"><span id="3ede" class="md me it lu b gy mf mg l mh mi">pip freeze &gt; requirements.txt</span></pre><p id="e879" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">第三步:准备部署(</strong> <a class="ae le" href="https://github.com/alanjeffares/notebook-to-microservice/tree/master/Step%203%20-%20Prepare%20to%20deploy" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu">代码</strong> </a> <strong class="kk iu"> ) </strong></p><p id="d941" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在我们已经为本地使用做好了项目准备，是时候做一些改变来为云使用做准备了。其中一个变化是日志记录。在本地工作时，跟踪程序和调试相对简单。打印语句、调试工具和控制台输出的组合通常可以达到目的，但是一旦部署了组件，我们就需要一些稍微复杂一点的东西。这就是python<a class="ae le" href="https://docs.python.org/3/library/logging.html" rel="noopener ugc nofollow" target="_blank">日志</a>模块可以提供帮助的地方。一旦配置好模块，我们可以简单地替换打印语句，如</p><pre class="lg lh li lj gt lz lu ma mb aw mc bi"><span id="74ff" class="md me it lu b gy mf mg l mh mi">print('Splitting train and test sets')</span></pre><p id="fdad" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">随着</p><pre class="lg lh li lj gt lz lu ma mb aw mc bi"><span id="d04f" class="md me it lu b gy mf mg l mh mi">logger.info('Splitting train and test sets')</span></pre><p id="41e3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，日志可以与用户定义的元数据(如时间、模块、函数名和行号)一起存储在日志文件中。这些信息不仅可以让我们跟踪程序的进度，还可以给出用于调试目的的详细信息，这些信息都安全地存储在日志文件中。</p><p id="17f3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这也是从本地存储数据和文件转向远程存储的好时机。例如，训练数据目前存储在一个在线csv文件中，如果我们获得额外的数据，更新该文件的过程会很麻烦。一种替代方法是使用开源关系数据库管理系统MySQL和它的连接器。我们不会在这里详述细节，但是一旦设置好，我们就可以使用sql查询轻松地从我们的数据库中读入数据。</p><p id="f516" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们还希望从本地保存文件开始。当需要进行预测时，我们可能想要使用几个月前训练的模型，获得这种类型的对象存储服务的最简单、最便宜的方法之一是通过亚马逊S3。这里我们将再次跳过一些配置细节，但是<a class="ae le" href="https://boto3.amazonaws.com/v1/documentation/api/latest/index.html" rel="noopener ugc nofollow" target="_blank"> boto3 </a>提供了一个方便的Python接口来访问S3桶。上传和下载文件到这个远程桶是一件轻而易举的事情，让我们可以轻松访问我们所有的模型。我还没有在本文的示例代码中实现MySQL或S3，但是网上有很多其他的指导来完成这个步骤(例如，这里的<a class="ae le" href="https://www.datacamp.com/community/tutorials/mysql-python" rel="noopener ugc nofollow" target="_blank">和这里的</a>和<a class="ae le" href="https://realpython.com/python-boto3-aws-s3/" rel="noopener ugc nofollow" target="_blank">分别是</a>)。</p><p id="77e7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我们准备开始部署之前，我们应该对这个存储库做的最后一个更改是抽象出所有硬编码的变量。一旦这个项目是远程部署，这将是一个相当艰巨的任务，以改变代码。因此，我们将把所有参数从硬编码值转移到json配置文件中。现在，当涉及到更改参数时，我们只需要更改这个json文件中的值，而不是代码本身，这样做要简单得多。像这样的一行</p><pre class="lg lh li lj gt lz lu ma mb aw mc bi"><span id="7ee3" class="md me it lu b gy mf mg l mh mi">gscv = GridSearchCV(pipeline, parameters, cv=3, scoring="accuracy")</span></pre><p id="f2d1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">可能会将交叉验证折叠数和评分标准移动到配置文件中，并成为</p><pre class="lg lh li lj gt lz lu ma mb aw mc bi"><span id="8bcf" class="md me it lu b gy mf mg l mh mi">gscv = GridSearchCV(pipeline, parameters, cv=NUM_FOLDS, scoring=SCORING)</span></pre><p id="c0c3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">其中变量<code class="fe lr ls lt lu b">NUM_FOLDS</code>和<code class="fe lr ls lt lu b">SCORING</code>从<code class="fe lr ls lt lu b">design.json</code>配置文件中加载，并且<code class="fe lr ls lt lu b">get_default()</code>函数被添加到<code class="fe lr ls lt lu b">config.py</code>中以方便访问这些值。</p><p id="a374" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">第四步:部署(</strong> <a class="ae le" href="https://github.com/alanjeffares/notebook-to-microservice/tree/master/Step%204%20-%20Deployment" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu">代码</strong> </a> <strong class="kk iu"> ) </strong></p><p id="ff43" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">完成前面的三个步骤后，我们终于准备好部署代码了。我们将把这个服务部署为一个<a class="ae le" href="https://en.wikipedia.org/wiki/Web_application" rel="noopener ugc nofollow" target="_blank"> web应用程序</a>，我们将通过一组api端点与之通信。为此，我们将使用一个<a class="ae le" href="https://en.wikipedia.org/wiki/Web_framework" rel="noopener ugc nofollow" target="_blank"> web框架</a>来自动处理大量开销。虽然我们可以使用很多，但对于这个简化的应用程序来说，烧瓶似乎是一个不错的选择，因为它易于安装和运行，并且非常灵活。主要思想是通过运行<code class="fe lr ls lt lu b">python3 run_app.py</code>，这将通过<code class="fe lr ls lt lu b">src/template_app</code>文件夹访问项目的功能，并将在<code class="fe lr ls lt lu b">http://localhost:5000</code>开始运行应用程序。一旦应用程序启动并运行，我们就可以使用<code class="fe lr ls lt lu b">GET</code>和<code class="fe lr ls lt lu b">POST</code>请求来访问它的火车，通过浏览器或API开发平台(如<a class="ae le" href="https://www.postman.com/" rel="noopener ugc nofollow" target="_blank"> Postman </a>)预测或可视化功能。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi mj"><img src="../Images/ec171f8f6873e97e0b35590af5d2132d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*k9SgtXZh-VNqnA2EqUqQCg.gif"/></div></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">在本地运行flask应用程序以可视化数据。</p></figure><p id="50aa" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">即使对于这个非常简单的项目，需求列表也开始大幅增长。对于另一个开发人员来说，启动并运行我们的代码需要设置虚拟环境并下载包。为了自动化这个过程并避免陷入依赖问题的风险，我们将使用一个叫做<a class="ae le" href="https://www.docker.com/" rel="noopener ugc nofollow" target="_blank"> Docker </a>的工具。Docker有效地创建了一个空容器，从头开始安装整个项目。这样做的好处是，任何机器上的任何人都可以通过安装docker并简单地从项目的根文件夹中运行<code class="fe lr ls lt lu b">docker build sample_app:v.1.0 .</code>来启动并运行我们的代码。一旦构建了本地映像，我们就可以用<code class="fe lr ls lt lu b">docker run -p 5000:5000 sample_app:v.1.0</code>运行并公开它。就是这样！Dockerfile文件包括下载Python、pip和需求的说明。然后它运行测试和pycodestyle，如果成功完成，它通过<code class="fe lr ls lt lu b">run_app.py</code>脚本运行应用程序。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi mo"><img src="../Images/7e561d4de9254d85b528c8161b48ba3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*E5IoY8GB_jiR_vLP4IRaaw.gif"/></div></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">构建Docker容器(注意，这比平常运行得更快，因为容器是第二次构建的，所以大多数步骤都在缓存中)。</p></figure><p id="684f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们现在已经将我们最初的jupyter笔记本电脑转变为一个完全成熟的微服务。我们的最终代码是模块化的，它遵循pep8，包括日志记录和测试，并且可以作为Dockerised Flask应用程序进行部署。我们还讨论了SQL和Amazon s3的数据管理。你应该在哪里部署你的应用将取决于你的项目需求，大规模的项目通常使用<a class="ae le" href="https://aws.amazon.com/" rel="noopener ugc nofollow" target="_blank"> AWS </a>、<a class="ae le" href="https://azure.microsoft.com/en-us/" rel="noopener ugc nofollow" target="_blank"> Azure </a>或<a class="ae le" href="https://cloud.google.com/" rel="noopener ugc nofollow" target="_blank"> Google Cloud </a>，而像<a class="ae le" href="https://www.heroku.com/home#" rel="noopener ugc nofollow" target="_blank"> Heroku </a>这样的平台为小型爱好项目提供免费托管。对于拥有大量微服务的大型项目来说，<a class="ae le" href="https://kubernetes.io/" rel="noopener ugc nofollow" target="_blank"> Kubernetes </a>是一个开源系统，用于自动化容器化应用程序的部署、扩展和管理。一旦一个大型项目投入使用，持续集成就会成为一个主要的挑战。在这种情况下，像<a class="ae le" href="https://www.jenkins.io/" rel="noopener ugc nofollow" target="_blank"> Jenkins </a>这样的自动化服务器可以管理与构建、测试和部署软件相关的任务。</p></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><p id="691d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="lx">感谢您的阅读，请在评论中分享您的反馈或问题。</em></p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi mw"><img src="../Images/0519f2041236e9f6cfa2515ae8e58333.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*btlQdywHS6UdZcWobg2ZPQ.jpeg"/></div></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">[图片来源Unsplash]</p></figure></div></div>    
</body>
</html>