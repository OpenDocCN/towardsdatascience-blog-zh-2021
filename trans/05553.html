<html>
<head>
<title>Demystifying Git references aka refs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">揭开Git引用的神秘面纱</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/demystifying-git-references-aka-refs-bdd09029d072?source=collection_archive---------22-----------------------#2021-05-17">https://towardsdatascience.com/demystifying-git-references-aka-refs-bdd09029d072?source=collection_archive---------22-----------------------#2021-05-17</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><div class=""/><div class=""><h2 id="46ae" class="pw-subtitle-paragraph jo iq ir bd b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf dk translated">支持核心Git操作的真正主力</h2></div><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj kg"><img src="../Images/c47d5d2765ca0a7ff264da42d880b7c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FrNCU_lpZOiqx-_LrJeo2Q.png"/></div></div><p class="ks kt gk gi gj ku kv bd b be z dk translated">图片由作者提供，使用<a class="ae kw" href="https://diagrams.net" rel="noopener ugc nofollow" target="_blank">图</a>制作。</p></figure><p id="02e5" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">作为一名数据科学家或数据工程师，当他/她知道所有的核心元素都被像<em class="lt"> git-clone </em>或<em class="lt"> git-push </em>这样的<em class="lt"> Git </em>操作所利用时，与<em class="lt"> Git </em>一起工作总是轻而易举的。尽管核心<em class="lt"> Git </em>操作已经得到了爱好者们的充分关注，但这里特别关注的是一个名为<em class="lt"> Git </em>引用<em class="lt">的核心实体，它支持几个这样的核心<em class="lt"> Git </em>操作。</em></p><p id="a1bc" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">为了理解Git引用及其重要性，让我们考虑下面的复杂结构的远程仓库</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj lu"><img src="../Images/211c38a2aeb2e97dab31e5d3f369541a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5-6nos2C7IlAsq-FZWUWZQ.png"/></div></div><p class="ks kt gk gi gj ku kv bd b be z dk translated">展示了一个包含五个分支(包括主分支)的远程存储库结构。图片由作者提供，使用<a class="ae kw" href="https://diagrams.net" rel="noopener ugc nofollow" target="_blank">图</a>制作。</p></figure><p id="026b" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">并如下克隆上面所示的远程存储库</p><pre class="kh ki kj kk gu lv lw lx ly aw lz bi"><span id="f060" class="ma mb ir lw b gz mc md l me mf">$ git clone https://github.com/&lt;git_username&gt;/my-repo.git</span></pre><p id="013d" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">正如预期的那样，克隆操作会产生一个本地存储库，其中有一个默认的本地主分支链接到远程主分支<em class="lt">上，还有一个远程连接<em class="lt">源分支</em>和所有远程分支，如下所示</em></p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj mg"><img src="../Images/08c50d4e46ae14af5161a6e606bd75ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BbuYGSe9Pp4Y8bu1oCy8Mg.png"/></div></div><p class="ks kt gk gi gj ku kv bd b be z dk translated">说明了包含五个分支(包括主分支)的远程存储库的克隆操作。图片由作者提供，使用<a class="ae kw" href="https://diagrams.net" rel="noopener ugc nofollow" target="_blank">图表</a>制作。</p></figure><p id="31ef" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">然而，在您的本地机器上仔细观察，本地目录<em class="lt"> my_repo </em>恰好包含您的远程<em class="lt"> main </em>分支中存在的文件的副本。尽管像<em class="lt"> branch_1 </em>和<em class="lt"> branch_2 </em>这样的远程分支的内容被克隆并存在于您的本地存储库中，但是它们的文件内容在您的本地机器上似乎还不可见。因此，引出了一个问题</p><p id="fa9e" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">如何访问远程分支的内容？</p><p id="eafc" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">好啦好啦，别担心，这就是<em class="lt"> Git引用</em>发挥作用的地方。为了能够访问除远程<em class="lt">主</em>分支之外的其他远程分支的内容，<em class="lt"> git-clone </em>不仅仅是创建远程<em class="lt">主</em>分支和远程连接<em class="lt">源</em>的本地副本。根据亚特兰蒂斯人的<a class="ae kw" href="https://www.atlassian.com/git/tutorials/setting-up-a-repository/git-clone" rel="noopener ugc nofollow" target="_blank"> git-clone </a>文档，</p><blockquote class="mh mi mj"><p id="d891" class="kx ky lt kz b la lb js lc ld le jv lf mk lh li lj ml ll lm ln mm lp lq lr ls ik bi translated">为了方便起见，克隆会自动创建一个名为“origin”的远程连接，指向原始存储库。这使得与中央存储库交互变得非常容易。这种自动连接是通过在<code class="fe mn mo mp lw b">refs/remotes/origin</code>下创建到远程分支负责人的Git refs并初始化<code class="fe mn mo mp lw b">remote.origin.url</code>和<code class="fe mn mo mp lw b">remote.origin.fetch</code>配置变量来建立的。</p></blockquote><p id="d45e" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">换句话说，除了简单地创建一个远程连接<em class="lt">源，</em>见上图，<em class="lt"> git-clone </em>操作还<em class="lt"> </em>创建<em class="lt"> Git </em> <em class="lt">引用</em>又名<em class="lt"> refs </em>到远程分支<em class="lt"> branch_1 </em>、<em class="lt"> branch_2 </em>等。这些<em class="lt">参考</em>位于您本地的<em class="lt"> my_repo </em>目录<em class="lt">下</em>文件夹<em class="lt"> refs/remotes/origin </em>下。进一步简化，默认情况下，<em class="lt"> git-clone </em>操作创建一个本地分支<em class="lt"> main </em>，其文件内容位于您的本地目录<em class="lt"> my_repo </em>中。<em class="lt"> </em>对于其余的远程分支，它获取其内容，存储在本地<em class="lt">。git </em>目录，并创建<em class="lt"> Git </em> <em class="lt">引用</em>，而不是创建多个本地分支及其自己的特定于分支的本地<em class="lt"> my_repo </em>目录。所有<em class="lt"> Git </em> <em class="lt">引用</em>到这些远程(<em class="lt"> origin </em>)分支可以列出如下</p><pre class="kh ki kj kk gu lv lw lx ly aw lz bi"><span id="99c5" class="ma mb ir lw b gz mc md l me mf">my_repo $ cd .git/refs/remotes/origin<br/>origin $ ls</span><span id="7374" class="ma mb ir lw b gz mq md l me mf">HEAD        branch_1        branch_2        branch_3        branch_4</span></pre><p id="9e70" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">注意<em class="lt">。git </em>在<em class="lt"> refs </em>目录前面。一般来说，所有的<em class="lt"> Git </em>元数据都存储在<em class="lt">下。git </em>目录在你本地的<em class="lt"> my_repo </em>目录下，除了<em class="lt">之外。gitignore </em>文件，这是用户特定的。使用<em class="lt"> ls -a </em>列出隐藏文件。</p><p id="485e" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">列出上述远程<em class="lt"> Git </em> <em class="lt">引用</em> ( <em class="lt"> refs </em>)的另一种方式是利用<em class="lt"> git分支</em>命令以及标志<em class="lt"> -a </em>或<em class="lt"> - remote </em>。我们使用- <em class="lt"> -remote </em>标志，它列出了所有的<em class="lt"> refs </em>上面的<em class="lt"> git-clone </em>操作，这些操作是为远程存储库中的所有远程分支创建的，如下所示</p><pre class="kh ki kj kk gu lv lw lx ly aw lz bi"><span id="7874" class="ma mb ir lw b gz mc md l me mf">my_repo $ git branch --remote</span><span id="532f" class="ma mb ir lw b gz mq md l me mf">  remotes/origin/HEAD -&gt; origin/main<br/>  remotes/origin/branch_1<br/>  remotes/origin/branch_2<br/>  remotes/origin/branch_3<br/>  remotes/origin/branch_4<br/>  remotes/origin/main</span></pre><p id="3a91" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated"><em class="lt"> Git </em> <em class="lt">引用</em> <em class="lt"> remotes/origin/HEAD </em>，默认指向remote ( <em class="lt"> origin) main </em>分支。注意<em class="lt"> origin/main </em>只是引用<em class="lt">Git</em><em class="lt">reference</em><em class="lt">remotes/origin/main</em>的另一种方式。或者，<em class="lt"> -a </em>标志列出了本地和远程<em class="lt"> Git </em> <em class="lt">引用</em>，见下文</p><pre class="kh ki kj kk gu lv lw lx ly aw lz bi"><span id="2fea" class="ma mb ir lw b gz mc md l me mf">my_repo $ git branch -a</span><span id="689b" class="ma mb ir lw b gz mq md l me mf">* main<br/>  remotes/origin/HEAD -&gt; origin/main<br/>  remotes/origin/branch_1<br/>  remotes/origin/branch_2<br/>  remotes/origin/branch_3<br/>  remotes/origin/branch_4<br/>  remotes/origin/main</span></pre><p id="2eef" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">请注意，默认情况下，本地<em class="lt"> Git </em> <em class="lt">引用</em> <em class="lt"> main </em>是在<em class="lt"> git-clone </em>操作期间创建的，并且在<em class="lt"> refs/heads </em>文件夹<em class="lt"> </em>下可用，与位于<em class="lt"> refs/remotes/origin </em>文件夹中的远程<em class="lt"> Git </em> <em class="lt">引用</em>相反。</p><p id="b8bc" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">鉴于所有的远程<em class="lt">参考</em>都已设置，<strong class="kz is">我们将我们之前的问题</strong>重新表述为</p><p id="adf8" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated"><strong class="kz is">我们如何使用远程<em class="lt"> Git引用</em>来访问远程分支的内容，比如本地机器上的<em class="lt"> branch_1 </em>？</strong></p><p id="4cbb" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">假设我们想要访问本地机器上的远程<em class="lt"> branch_1 </em>的内容，即在我们的本地存储库中，我们需要做的就是利用<em class="lt"> refs/remotes/origin </em>中为<em class="lt"> branch_1 </em>设置的远程<em class="lt"> Git引用</em>，并执行以下操作</p><pre class="kh ki kj kk gu lv lw lx ly aw lz bi"><span id="f744" class="ma mb ir lw b gz mc md l me mf">my_repo $ git checkout branch_1</span></pre><p id="2b0a" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">上面的命令在幕后做了很多事情。首先在<em class="lt"> refs/remotes/origin </em>文件夹中寻找<em class="lt"> Git </em> <em class="lt">引用</em> <em class="lt"> branch_1 </em>。如果没有找到，它抛出一个错误。其次，它在您的本地存储库中创建了一个名为<em class="lt"> branch_1 </em>的本地分支，它是基于远程<em class="lt"> branch_1 </em>的。本地<em class="lt">分支_1 </em>也链接到远程<em class="lt">分支_1 </em>，即用于执行<em class="lt">拉</em>或<em class="lt">推</em>操作。第三，在文件夹<em class="lt"> refs/heads </em>下创建一个本地<em class="lt">Git</em><em class="lt">reference</em><em class="lt">branch _ 1</em>。最后，它将本地目录<em class="lt"> my_repo </em>中的文件内容替换为远程<em class="lt"> branch_1 </em>中的文件内容，即本地目录<em class="lt"> my_repo </em>中的文件不再是远程<em class="lt"> main </em>分支中文件的副本。因此，我们现在有两个本地分支，即<em class="lt"> main </em>和<em class="lt"> branch_1 </em>，链接到相应的远程分支，但仍然只有一个本地<em class="lt"> my_repo </em>目录，如下所示</p><pre class="kh ki kj kk gu lv lw lx ly aw lz bi"><span id="2aa7" class="ma mb ir lw b gz mc md l me mf">my_repo $ git branch -a</span><span id="a0b8" class="ma mb ir lw b gz mq md l me mf">* branch_1<br/>  main<br/>  remotes/origin/HEAD -&gt; origin/main<br/>  remotes/origin/branch_1<br/>  remotes/origin/branch_2<br/>  remotes/origin/branch_3<br/>  remotes/origin/branch_4<br/>  remotes/origin/main</span></pre><p id="9e20" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">本地<em class="lt">Git</em><em class="lt">reference</em><em class="lt">branch _ 1</em>前面的星号“*”表示本地存储库中当前活动的分支。类似地，我们也可以<em class="lt">检出</em>(访问)其他远程分支的内容，比如本地存储库中的<em class="lt"> branch_2 </em>和<em class="lt"> branch_3 </em>。用这种方式做的一件很酷的事情是，您只在需要的时候基于远程分支创建一个本地分支。因此，避免了本地存储库中不必要的本地分支混乱。</p><p id="2f62" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">要从本地<em class="lt">分支_1 </em>切换回本地<em class="lt">主</em>分支，您需要做的就是</p><pre class="kh ki kj kk gu lv lw lx ly aw lz bi"><span id="2b65" class="ma mb ir lw b gz mc md l me mf">my_repo $ git checkout main</span></pre><p id="1068" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">这将在本地<em class="lt">主</em>分支旁边放置星号“*”。为了确保本地<em class="lt">主</em>分支中的文件内容与远程<em class="lt">主</em>分支中的文件内容相同，执行<em class="lt"> git-pull </em>。</p><p id="fd7b" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">这就是我们的结局。希望以上见解有所加强🏋️‍♀️你对<em class="lt"> Git引用</em>及其好处的理解。享受Gitting！🙏</p></div><div class="ab cl mr ms hv mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="ik il im in io"><p id="c730" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi my translated">还是那些好奇的人。为了查看本地<em class="lt"> Git </em> <em class="lt">引用</em>如<em class="lt"> main </em>或<em class="lt"> branch_1 </em>如何链接到其对应的远程分支，我们列出了本地存储库的配置变量</p><pre class="kh ki kj kk gu lv lw lx ly aw lz bi"><span id="6cb3" class="ma mb ir lw b gz mc md l me mf">my_repo $ git config --list</span><span id="585b" class="ma mb ir lw b gz mq md l me mf">... skipped other variables ...<br/><br/>remote.origin.url=https://github.com/&lt;git_username&gt;/my_repo.git<br/>remote.origin.fetch=+refs/heads/*:refs/remotes/origin/*<br/><strong class="lw is">branch.main.remote=origin</strong><br/>branch.main.merge=refs/heads/main<br/><strong class="lw is">branch.branch_1.remote=origin</strong><br/>branch.branch_1.merge=refs/heads/branch_1</span></pre><p id="8524" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">如你所见，以粗体显示的本地配置变量<em class="lt"> branch.main.remote </em>和<em class="lt"> branch.branch_1.remote </em>是用远程连接<em class="lt"> origin </em>初始化的。意味着本地分支<em class="lt">主</em>和<em class="lt">分支_1 </em>链接到远程分支<em class="lt">主</em>和<em class="lt">分支_1 </em>。请注意，每当在本地计算机上签出新的远程分支时，相应的配置变量将被添加到本地存储库的配置文件中。</p></div></div>    
</body>
</html>