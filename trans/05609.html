<html>
<head>
<title>Seven (7) Essential Data Structures for a Coding Interview and associated common questions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">编码面试的七(7)个基本数据结构和相关的常见问题</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/seven-7-essential-data-structures-for-a-coding-interview-and-associated-common-questions-72ceb644290?source=collection_archive---------1-----------------------#2021-05-19">https://towardsdatascience.com/seven-7-essential-data-structures-for-a-coding-interview-and-associated-common-questions-72ceb644290?source=collection_archive---------1-----------------------#2021-05-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/786dbbd64ce38ae2b707eae9ee1bfd5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2rKGJ6h1regwmfMcty3SLw.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">作者图片</p></figure><div class=""/><div class=""><h2 id="5db3" class="pw-subtitle-paragraph kc je jf bd b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt dk translated">用动画可视化的重要数据结构</h2></div><p id="7b9b" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">编码面试是各种软件工程、机器学习和数据科学工作的重要组成部分。大多数候选人擅长使用编程来解决他们的日常研究问题。但是当进行编码面试时，人们需要温习不同数据结构的基础知识，因为大多数问题都围绕着为给定的问题选择正确的数据结构。</p><p id="4776" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">本文将详细介绍对编码面试很重要的七种基本数据结构，它们的时间复杂性，以及常见的编码问题。</p><h1 id="2c6c" class="lq lr jf bd ls lt lu lv lw lx ly lz ma kl mb km mc ko md kp me kr mf ks mg mh bi translated">1.数组/列表</h1><p id="bd24" class="pw-post-body-paragraph ku kv jf kw b kx mi kg kz la mj kj lc ld mk lf lg lh ml lj lk ll mm ln lo lp ij bi translated">List包含一系列有序的值，这些值在内存中相邻放置。列表由第一个元素的地址来标识。由于列表元素在内存中的放置顺序与它们被定义的顺序相同(在下面的例子中，由于2在12之后，所以12在内存中的位置紧接在2之后)，所以列表中的每个元素都可以通过将第一个元素的地址增加正确的索引量来访问。因此，无论元素在列表中的位置如何，访问列表中的任何元素都需要恒定的时间。</p><figure class="mn mo mp mq gt is"><div class="bz fp l di"><div class="mr ms l"/></div></figure><h2 id="935c" class="mt lr jf bd ls mu mv dn lw mw mx dp ma ld my mz mc lh na nb me ll nc nd mg ne bi translated">时间复杂度:</h2><p id="6d0f" class="pw-post-body-paragraph ku kv jf kw b kx mi kg kz la mj kj lc ld mk lf lg lh ml lj lk ll mm ln lo lp ij bi translated"><strong class="kw jg">Access-O(1):</strong>访问列表中的元素需要用索引对其进行寻址。</p><p id="3a57" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated"><strong class="kw jg">Search-O(n):</strong>搜索列表中是否存在元素需要(在最坏的情况下)逐个遍历每个索引</p><p id="ec84" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated"><strong class="kw jg">插入/删除— O(n) </strong>:从列表中插入(删除)一个元素首先需要找到它，也就是O(n)</p><h2 id="49ff" class="mt lr jf bd ls mu mv dn lw mw mx dp ma ld my mz mc lh na nb me ll nc nd mg ne bi translated">常见问题:</h2><ol class=""><li id="8aae" class="nf ng jf kw b kx mi la mj ld nh lh ni ll nj lp nk nl nm nn bi translated"><a class="ae no" href="https://leetcode.com/problems/reverse-linked-list/" rel="noopener ugc nofollow" target="_blank">反转链表</a></li><li id="3c89" class="nf ng jf kw b kx np la nq ld nr lh ns ll nt lp nk nl nm nn bi translated"><a class="ae no" href="https://leetcode.com/problems/middle-of-the-linked-list/" rel="noopener ugc nofollow" target="_blank">查找链表的中间元素</a></li><li id="dc3d" class="nf ng jf kw b kx np la nq ld nr lh ns ll nt lp nk nl nm nn bi translated"><a class="ae no" href="https://leetcode.com/problems/linked-list-cycle-ii/solution/" rel="noopener ugc nofollow" target="_blank">查找链表是否循环</a></li></ol></div><div class="ab cl nu nv hu nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="ij ik il im in"><h1 id="4003" class="lq lr jf bd ls lt ob lv lw lx oc lz ma kl od km mc ko oe kp me kr of ks mg mh bi translated">2.链表</h1><p id="d28b" class="pw-post-body-paragraph ku kv jf kw b kx mi kg kz la mj kj lc ld mk lf lg lh ml lj lk ll mm ln lo lp ij bi translated">与列表/数组相反，链表的顺序不是由它们在内存中的物理位置定义的。链表的连续元素在内存中不是彼此相邻放置的。相反，每个链表元素包含值和指向下一个链表元素的地址(指针)。因此，链表只能一次顺序遍历每个元素。这也意味着链表的长度只有在完全遍历完一个元素之后才能知道。链表的最后一个元素以None/Null作为指针。链表由指向第一个元素的指针定义。</p><figure class="mn mo mp mq gt is"><div class="bz fp l di"><div class="mr ms l"/></div></figure><h2 id="3721" class="mt lr jf bd ls mu mv dn lw mw mx dp ma ld my mz mc lh na nb me ll nc nd mg ne bi translated">时间复杂度:</h2><p id="feb6" class="pw-post-body-paragraph ku kv jf kw b kx mi kg kz la mj kj lc ld mk lf lg lh ml lj lk ll mm ln lo lp ij bi translated"><strong class="kw jg"> Access — O(n): </strong>访问链表中的一个元素需要(在最坏的情况下)逐个遍历每个元素。</p><p id="c8e7" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated"><strong class="kw jg">Search-O(n):</strong>搜索一个元素是否存在于一个链表中需要(在最坏的情况下)逐个遍历每个元素</p><p id="9679" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated"><strong class="kw jg">插入/删除— O(1) </strong>:插入(删除)一个给定指针的元素到需要插入(删除)的地方只需要重新排列指针。然而，在末尾插入(删除)一个元素需要遍历整个链表，因此是O(n)</p><h2 id="d0f2" class="mt lr jf bd ls mu mv dn lw mw mx dp ma ld my mz mc lh na nb me ll nc nd mg ne bi translated">常见问题:</h2><ol class=""><li id="33f3" class="nf ng jf kw b kx mi la mj ld nh lh ni ll nj lp nk nl nm nn bi translated"><a class="ae no" href="https://leetcode.com/problems/reverse-linked-list/" rel="noopener ugc nofollow" target="_blank">反转链表</a></li><li id="27da" class="nf ng jf kw b kx np la nq ld nr lh ns ll nt lp nk nl nm nn bi translated"><a class="ae no" href="https://leetcode.com/problems/middle-of-the-linked-list/" rel="noopener ugc nofollow" target="_blank">查找链表的中间元素</a></li><li id="6498" class="nf ng jf kw b kx np la nq ld nr lh ns ll nt lp nk nl nm nn bi translated"><a class="ae no" href="https://leetcode.com/problems/linked-list-cycle-ii/solution/" rel="noopener ugc nofollow" target="_blank">查找链表是否循环</a></li></ol></div><div class="ab cl nu nv hu nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="ij ik il im in"><h1 id="51e2" class="lq lr jf bd ls lt ob lv lw lx oc lz ma kl od km mc ko oe kp me kr of ks mg mh bi translated">3.哈希表</h1><p id="746a" class="pw-post-body-paragraph ku kv jf kw b kx mi kg kz la mj kj lc ld mk lf lg lh ml lj lk ll mm ln lo lp ij bi translated">散列表可以被认为是列表的一般形式。在列表中，我们将索引映射到可以在常量时间内访问的值。哈希表试图映射一种数据类型(整数、浮点、字符串等。)转换为另一种数据类型，从而创建成对的赋值(键映射到值)，这样就可以在常量时间内访问这些对<strong class="kw jg">。</strong></p><figure class="mn mo mp mq gt is"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="cdbd" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">对于每个<em class="og"> (key，value) </em>对，通过哈希函数传递密钥，试图为要存储在内存中的值创建唯一的物理地址。大多数情况下，哈希函数可以跨键值创建唯一的物理地址。有时候，散列函数最终会为不同的键(比如key_1、key_2)生成相同的物理地址。这被称为<strong class="kw jg">碰撞。</strong>哈希表通过创建一个键和值都很强的链表来处理冲突。然后遍历链表以匹配&lt; <em class="og">键&gt; </em>，返回<em class="og"> &lt;值&gt; </em>对。</p><p id="dc0c" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">当必须在代码算法中执行多个搜索操作时，哈希表会很有用。</p><h2 id="0bb7" class="mt lr jf bd ls mu mv dn lw mw mx dp ma ld my mz mc lh na nb me ll nc nd mg ne bi translated">时间复杂度:</h2><p id="49d1" class="pw-post-body-paragraph ku kv jf kw b kx mi kg kz la mj kj lc ld mk lf lg lh ml lj lk ll mm ln lo lp ij bi translated"><strong class="kw jg">Search-O(1):</strong>搜索一个关键字是否存在于一个哈希表中需要(平均来说)恒定的时间量。</p><p id="3ae1" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated"><strong class="kw jg">插入/删除— O(1) </strong>:从哈希表中插入(删除)一个<em class="og"> &lt;键、值&gt; </em>对需要一个恒定的时间量，而与字典的大小无关</p><h2 id="2230" class="mt lr jf bd ls mu mv dn lw mw mx dp ma ld my mz mc lh na nb me ll nc nd mg ne bi translated">常见问题:</h2><ol class=""><li id="7f70" class="nf ng jf kw b kx mi la mj ld nh lh ni ll nj lp nk nl nm nn bi translated"><a class="ae no" href="https://leetcode.com/explore/interview/card/microsoft/30/array-and-strings/173/" rel="noopener ugc nofollow" target="_blank">判断列表中的两个元素的总和是否为目标值</a></li><li id="b1a8" class="nf ng jf kw b kx np la nq ld nr lh ns ll nt lp nk nl nm nn bi translated"><a class="ae no" href="https://leetcode.com/explore/interview/card/microsoft/30/array-and-strings/200/" rel="noopener ugc nofollow" target="_blank">分组字谜</a></li><li id="6822" class="nf ng jf kw b kx np la nq ld nr lh ns ll nt lp nk nl nm nn bi translated"><a class="ae no" href="https://leetcode.com/problems/longest-substring-without-repeating-characters/" rel="noopener ugc nofollow" target="_blank">没有重复字符的最长子串</a></li></ol></div><div class="ab cl nu nv hu nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="ij ik il im in"><h1 id="18a4" class="lq lr jf bd ls lt ob lv lw lx oc lz ma kl od km mc ko oe kp me kr of ks mg mh bi translated">4.长队</h1><p id="c8f1" class="pw-post-body-paragraph ku kv jf kw b kx mi kg kz la mj kj lc ld mk lf lg lh ml lj lk ll mm ln lo lp ij bi translated">队列是一种顺序数据结构，当元素被插入队列时，它保持元素的顺序。它保持先入先出(<strong class="kw jg"> FIFO </strong>)的顺序，这意味着元素只能以与它们被插入队列时相同的顺序<strong class="kw jg"><em class="og"/></strong>被访问。将<strong class="kw jg"> <em class="og">元素先插入</em> </strong>，将<strong class="kw jg"> <em class="og">第一个从队列中移除</em> </strong>。</p><p id="d83a" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">对队列执行的两个最常见的操作是Enqueue()和Dequeue()。<strong class="kw jg"> Enqueue() </strong>将一个元素添加到队列中，而<strong class="kw jg"> Dequeue() </strong>从队列中移除一个元素。在给定阶段，由出列移除的元素取决于队列的初始状态和Enqueue()操作的顺序。</p><p id="7c89" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">为了理解队列是如何工作的，让我们考虑队列中的两个位置(水平放置，以便更好地理解)——前端<strong class="kw jg"> <em class="og">和末端</em> </strong>。每当添加一个元素(Enqueue())时，它都被添加到队列的末尾。另一方面，元素移除(Dequeue())是从队列的前面完成的。现实生活中的一个例子是杂货店的结账队伍。顾客进入队列，等待轮到自己。只有当他/她前面的所有客户都已被处理(从队列中删除)时，才能处理(从队列中删除)。</p><figure class="mn mo mp mq gt is"><div class="bz fp l di"><div class="mr ms l"/></div></figure><h2 id="c894" class="mt lr jf bd ls mu mv dn lw mw mx dp ma ld my mz mc lh na nb me ll nc nd mg ne bi translated">时间复杂度(平均):</h2><p id="80ab" class="pw-post-body-paragraph ku kv jf kw b kx mi kg kz la mj kj lc ld mk lf lg lh ml lj lk ll mm ln lo lp ij bi translated"><strong class="kw jg">Access-O(n):</strong>访问队列中的一个元素需要(在最坏的情况下)逐个使每个元素出列()。</p><p id="62b9" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated"><strong class="kw jg">Search-O(n):</strong>搜索一个元素是否存在于队列中需要(在最坏的情况下)将每个元素出列()并与目标进行比较。</p><p id="02e1" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated"><strong class="kw jg">插入/删除-O(1)</strong>:从队列中插入(删除)一个元素，将该元素添加到(从)队列的末端(前端)。这总是可以在恒定的时间内完成。</p><h2 id="3918" class="mt lr jf bd ls mu mv dn lw mw mx dp ma ld my mz mc lh na nb me ll nc nd mg ne bi translated">常见问题:</h2><ol class=""><li id="8945" class="nf ng jf kw b kx mi la mj ld nh lh ni ll nj lp nk nl nm nn bi translated"><a class="ae no" href="https://leetcode.com/problems/binary-tree-right-side-view/" rel="noopener ugc nofollow" target="_blank">二叉树右侧视图</a></li><li id="92aa" class="nf ng jf kw b kx np la nq ld nr lh ns ll nt lp nk nl nm nn bi translated"><a class="ae no" href="https://leetcode.com/problems/task-scheduler/" rel="noopener ugc nofollow" target="_blank">任务调度器</a></li><li id="4d48" class="nf ng jf kw b kx np la nq ld nr lh ns ll nt lp nk nl nm nn bi translated"><a class="ae no" href="https://leetcode.com/problems/shortest-subarray-with-sum-at-least-k/" rel="noopener ugc nofollow" target="_blank">总和至少为K的最短子阵列</a></li></ol></div><div class="ab cl nu nv hu nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="ij ik il im in"><h1 id="7db1" class="lq lr jf bd ls lt ob lv lw lx oc lz ma kl od km mc ko oe kp me kr of ks mg mh bi translated">5.堆</h1><p id="9ea6" class="pw-post-body-paragraph ku kv jf kw b kx mi kg kz la mj kj lc ld mk lf lg lh ml lj lk ll mm ln lo lp ij bi translated">堆栈也是一种顺序数据结构(类似于队列),它维护元素插入时的顺序。然而，与队列不同，堆栈保持后进先出(<strong class="kw jg"> LIFO </strong>)的顺序，这意味着元素只能以插入堆栈时的<strong class="kw jg"> <em class="og">逆序</em> </strong>访问。最后插入<strong class="kw jg"> <em class="og">的元素，</em> </strong>将把<em class="og"> </em> <strong class="kw jg"> <em class="og">的第一个从堆栈中删除</em> </strong>。</p><p id="abb4" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">对堆栈执行的两个最常见的操作是push()和pop()。<strong class="kw jg"> Push() </strong>(类似Enqueue())将一个元素添加到堆栈中，而<strong class="kw jg"> pop() </strong>(就像Dequeue())将一个元素从中移除。在给定阶段，pop()移除的元素取决于堆栈的初始状态或最后一次push()操作</p><p id="3ca9" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">为了理解堆栈如何工作，让我们考虑堆栈中的两个位置(<strong class="kw jg"> <em class="og">垂直</em> </strong>放置以便更好地理解)——头和尾。每当添加或删除一个元素时(push()或pop())，总是在头部位置完成。堆叠的真实例子是一堆厨房盘子。最后一个被添加到盘子堆中的盘子将是第一个被使用的(虽然您可以访问最上面的盘子下面的盘子，但是人们很少这样做)</p><figure class="mn mo mp mq gt is"><div class="bz fp l di"><div class="mr ms l"/></div></figure><h2 id="736f" class="mt lr jf bd ls mu mv dn lw mw mx dp ma ld my mz mc lh na nb me ll nc nd mg ne bi translated">时间复杂度(平均):</h2><p id="864c" class="pw-post-body-paragraph ku kv jf kw b kx mi kg kz la mj kj lc ld mk lf lg lh ml lj lk ll mm ln lo lp ij bi translated"><strong class="kw jg"> Access — O(n): </strong>访问堆栈中的一个元素需要(在最坏的情况下)逐个pop()每个元素。</p><p id="05e3" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated"><strong class="kw jg"> Search — O(n): </strong>搜索一个元素是否存在于一个栈中，需要(在最坏的情况下)pop()每个元素，并与目标进行比较。</p><p id="fce4" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated"><strong class="kw jg"> Insert/Delete — O(1) </strong>:向堆栈中插入(删除)一个元素，在堆栈顶部添加(删除)该元素。这总是可以在恒定的时间内完成。</p><h2 id="88e9" class="mt lr jf bd ls mu mv dn lw mw mx dp ma ld my mz mc lh na nb me ll nc nd mg ne bi translated">常见问题:</h2><ol class=""><li id="10ef" class="nf ng jf kw b kx mi la mj ld nh lh ni ll nj lp nk nl nm nn bi translated"><a class="ae no" href="https://leetcode.com/problems/valid-parentheses/" rel="noopener ugc nofollow" target="_blank">有效括号</a></li><li id="75e9" class="nf ng jf kw b kx np la nq ld nr lh ns ll nt lp nk nl nm nn bi translated"><a class="ae no" href="https://leetcode.com/problems/trapping-rain-water/" rel="noopener ugc nofollow" target="_blank">收集雨水</a></li><li id="9a56" class="nf ng jf kw b kx np la nq ld nr lh ns ll nt lp nk nl nm nn bi translated"><a class="ae no" href="https://leetcode.com/problems/exclusive-time-of-functions/" rel="noopener ugc nofollow" target="_blank">功能独占时间</a></li></ol></div><div class="ab cl nu nv hu nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="ij ik il im in"><h1 id="5482" class="lq lr jf bd ls lt ob lv lw lx oc lz ma kl od km mc ko oe kp me kr of ks mg mh bi translated">6.树(二进制)</h1><p id="03c5" class="pw-post-body-paragraph ku kv jf kw b kx mi kg kz la mj kj lc ld mk lf lg lh ml lj lk ll mm ln lo lp ij bi translated">树是一种数据结构，它维护其元素之间的层次关系。每个元素都有一个前任和多个继任者，分别称为<strong class="kw jg"> <em class="og">父</em> </strong>和<strong class="kw jg"> <em class="og">子</em> </strong>。在这一节，我们将考虑一个二叉树。在二叉树中，每个节点最多可以有两个子节点(左子节点，右子节点)。以下是与二叉树相关的一些基本定义</p><ul class=""><li id="e502" class="nf ng jf kw b kx ky la lb ld oh lh oi ll oj lp ok nl nm nn bi translated"><strong class="kw jg">根</strong>树由指向其根节点的指针定义。</li><li id="e0d5" class="nf ng jf kw b kx np la nq ld nr lh ns ll nt lp ok nl nm nn bi translated"><strong class="kw jg">父节点</strong>——任何至少有一个子节点的节点称为父节点。</li><li id="96ea" class="nf ng jf kw b kx np la nq ld nr lh ns ll nt lp ok nl nm nn bi translated"><strong class="kw jg">子节点</strong>—父节点的后继节点称为子节点。节点既可以是父节点，也可以是子节点。根永远不是子节点。</li><li id="051a" class="nf ng jf kw b kx np la nq ld nr lh ns ll nt lp ok nl nm nn bi translated"><strong class="kw jg">叶节点</strong>——没有任何子节点的节点称为叶节点。</li><li id="83f2" class="nf ng jf kw b kx np la nq ld nr lh ns ll nt lp ok nl nm nn bi translated"><strong class="kw jg">子树</strong>——原始树的有效子集。</li><li id="84b9" class="nf ng jf kw b kx np la nq ld nr lh ns ll nt lp ok nl nm nn bi translated"><strong class="kw jg">路径</strong>——沿着树的边缘的节点序列被称为路径。</li><li id="ff87" class="nf ng jf kw b kx np la nq ld nr lh ns ll nt lp ok nl nm nn bi translated"><strong class="kw jg">遍历</strong>——以一定的顺序遍历节点，如广度优先遍历、深度优先遍历等。</li></ul><p id="8c7c" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">基于条件层次结构，我们可以有多种类型的树。最常用的一种是二叉查找树。二叉查找树(BST)是一种有序或排序的二叉树，其中左侧子节点的值小于父节点的值，右侧子节点的值大于父节点的值。</p><figure class="mn mo mp mq gt is"><div class="bz fp l di"><div class="mr ms l"/></div></figure><h2 id="d920" class="mt lr jf bd ls mu mv dn lw mw mx dp ma ld my mz mc lh na nb me ll nc nd mg ne bi translated">常见问题:</h2><ol class=""><li id="05c0" class="nf ng jf kw b kx mi la mj ld nh lh ni ll nj lp nk nl nm nn bi translated"><a class="ae no" href="https://leetcode.com/problems/validate-binary-search-tree/" rel="noopener ugc nofollow" target="_blank">验证二叉查找树</a></li><li id="2bdd" class="nf ng jf kw b kx np la nq ld nr lh ns ll nt lp nk nl nm nn bi translated"><a class="ae no" href="https://leetcode.com/problems/binary-tree-level-order-traversal/" rel="noopener ugc nofollow" target="_blank">二叉树层次顺序遍历</a></li><li id="811b" class="nf ng jf kw b kx np la nq ld nr lh ns ll nt lp nk nl nm nn bi translated"><a class="ae no" href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/" rel="noopener ugc nofollow" target="_blank">二叉树的最低共同祖先</a></li></ol></div><div class="ab cl nu nv hu nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="ij ik il im in"><h1 id="0fd6" class="lq lr jf bd ls lt ob lv lw lx oc lz ma kl od km mc ko oe kp me kr of ks mg mh bi translated">7.图表</h1><p id="c352" class="pw-post-body-paragraph ku kv jf kw b kx mi kg kz la mj kj lc ld mk lf lg lh ml lj lk ll mm ln lo lp ij bi translated">图由节点或顶点和连接一对节点的边组成。从形式上讲，一个图<strong class="kw jg"> G </strong>是一对集合<strong class="kw jg"> (V，E) </strong>，其中<strong class="kw jg"> V </strong>是所有顶点的集合，<strong class="kw jg"> E </strong>是所有边的集合。如果所有顶点都通过一条边与一个节点或顶点相连，则称该节点或顶点为邻居。与树相反，图可以是循环的，这意味着从一个节点开始，沿着边，可以在同一个节点结束。</p><figure class="mn mo mp mq gt is"><div class="bz fp l di"><div class="mr ms l"/></div></figure><h2 id="7a01" class="mt lr jf bd ls mu mv dn lw mw mx dp ma ld my mz mc lh na nb me ll nc nd mg ne bi translated">常见问题:</h2><ol class=""><li id="77c7" class="nf ng jf kw b kx mi la mj ld nh lh ni ll nj lp nk nl nm nn bi translated"><a class="ae no" href="https://leetcode.com/problems/clone-graph/" rel="noopener ugc nofollow" target="_blank">克隆图形</a></li><li id="7aee" class="nf ng jf kw b kx np la nq ld nr lh ns ll nt lp nk nl nm nn bi translated"><a class="ae no" href="https://leetcode.com/problems/is-graph-bipartite/" rel="noopener ugc nofollow" target="_blank">图是二分的吗？</a></li><li id="52dd" class="nf ng jf kw b kx np la nq ld nr lh ns ll nt lp nk nl nm nn bi translated"><a class="ae no" href="https://leetcode.com/problems/alien-dictionary/" rel="noopener ugc nofollow" target="_blank">外星人字典</a></li></ol><h1 id="da03" class="lq lr jf bd ls lt lu lv lw lx ly lz ma kl mb km mc ko md kp me kr mf ks mg mh bi translated">重要资源:</h1><ul class=""><li id="3035" class="nf ng jf kw b kx mi la mj ld nh lh ni ll nj lp ok nl nm nn bi translated">【LeetCode.com T4】</li><li id="ea77" class="nf ng jf kw b kx np la nq ld nr lh ns ll nt lp ok nl nm nn bi translated"><a class="ae no" href="https://www.bigocheatsheet.com" rel="noopener ugc nofollow" target="_blank"> BigOCheatSheet </a></li></ul><p id="7306" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">您可能还会发现下面的文章很有用</p><div class="ip iq gp gr ir ol"><a rel="noopener follow" target="_blank" href="/how-to-prepare-for-a-behavioral-soft-skills-interview-cheat-sheet-9347aaeaef82"><div class="om ab fo"><div class="on ab oo cl cj op"><h2 class="bd jg gy z fp oq fr fs or fu fw je bi translated">如何准备行为/软技能面试？</h2><div class="os l"><h3 class="bd b gy z fp oq fr fs or fu fw dk translated">用备忘单准备数据科学行为面试的有组织指南。</h3></div><div class="ot l"><p class="bd b dl z fp oq fr fs or fu fw dk translated">towardsdatascience.com</p></div></div><div class="ou l"><div class="ov l ow ox oy ou oz ix ol"/></div></div></a></div></div><div class="ab cl nu nv hu nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="ij ik il im in"><p id="32d2" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated"><strong class="kw jg">如果这篇文章对你有帮助，或者你想了解更多关于机器学习和数据科学的知识，请关注我</strong><a class="pa pb ep" href="https://medium.com/u/a7cc4f201fb5?source=post_page-----72ceb644290--------------------------------" rel="noopener" target="_blank"><strong class="kw jg">Aqeel an war</strong></a><strong class="kw jg">，或者联系我</strong><a class="ae no" href="https://www.linkedin.com/in/aqeelanwarmalik/" rel="noopener ugc nofollow" target="_blank"><strong class="kw jg"><em class="og">LinkedIn</em></strong></a><strong class="kw jg"><em class="og">。</em>T25】</strong></p></div></div>    
</body>
</html>