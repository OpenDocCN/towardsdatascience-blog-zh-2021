<html>
<head>
<title>Python Named Tuple: What, How and When to Use</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 命名元组:什么、如何以及何时使用</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/python-named-tuple-what-how-and-when-to-use-4718b0668afd?source=collection_archive---------3-----------------------#2021-11-21">https://towardsdatascience.com/python-named-tuple-what-how-and-when-to-use-4718b0668afd?source=collection_archive---------3-----------------------#2021-11-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/672e041df0c401f2425005ec35aee229.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o8NmX6LSKVJz87sTjiTmlg.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">图片来自<a class="ae jg" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=5960731" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>的<a class="ae jg" href="https://pixabay.com/users/eloiroudaire77-19296305/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=5960731" rel="noopener ugc nofollow" target="_blank"> eloiroudaire77 </a></p></figure><div class=""/><div class=""><h2 id="b2e0" class="pw-subtitle-paragraph kg ji jj bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dk translated">Python 命名 Tuple 的配方以及我们为什么要使用它</h2></div><p id="9092" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Python 中有一种“特殊”类型的元组，叫做“命名元组”。对于 Python 学习者来说，对它感到困惑是很常见的，尤其是我们应该何时以及为什么使用它。</p><p id="9cab" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">命名元组就是元组，所以它做元组能做的一切。然而，它超出了普通的 Python 元组。它更像是 C++等其他编程语言中的“struct”。它是一个元组的特定子类，是根据您的规范以编程方式创建的，具有命名字段和固定长度。</p><p id="f46c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在本文中，我将介绍名为 tuples 的 Python，并尝试演示如何使用它、何时使用它以及为什么我们应该使用它。</p><h1 id="9b6c" class="lu lv jj bd lw lx ly lz ma mb mc md me kp mf kq mg ks mh kt mi kv mj kw mk ml bi translated">1.创建命名元组</h1><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/4a6ff59c7ae62e85f157a6fc753738ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Fs5Cv2gwGKuw1y6eUJUPWg.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">图片来自<a class="ae jg" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=550622" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>的<a class="ae jg" href="https://pixabay.com/users/ptdh-275507/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=550622" rel="noopener ugc nofollow" target="_blank"> Dirk Hoenes </a></p></figure><p id="d8e3" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在我们开始之前，这里有一个小提示。从 Python 3.1 开始，有一个重要的名为 tuple 的内置常量来表示我们现在使用的 Python 版本。我们可以如下得到。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="c576" class="mv lv jj mr b gy mw mx l my mz">import sys<br/>sys.version_info</span></pre><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi na"><img src="../Images/599322acdb0540751b49f8715a7a97bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Iq8-GU8GVPcB1_gZW6k9ow.png"/></div></div></figure><p id="0948" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我们想在我们的程序中使用它，我们需要从集合模块中导入它。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="8125" class="mv lv jj mr b gy mw mx l my mz">from collections import namedtuple</span></pre><p id="65fa" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">集合模块中的<code class="fe nb nc nd mr b">namedtuple</code>是一个类工厂。换句话说，它制造类。我们需要提供下面的东西来产生我们想要的类。</p><ul class=""><li id="85ae" class="ne nf jj la b lb lc le lf lh ng ll nh lp ni lt nj nk nl nm bi translated">我们要使用的类名</li><li id="7339" class="ne nf jj la b lb nn le no lh np ll nq lp nr lt nj nk nl nm bi translated">我们要分配的字段名序列，按照元组中元素的顺序。</li><li id="bd7a" class="ne nf jj la b lb nn le no lh np ll nq lp nr lt nj nk nl nm bi translated">我们需要在代码中将该类赋给一个变量名，这样我们就可以用它来构造实例。</li></ul><p id="9002" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如，如果我们想要定义一个具有纬度和经度两个属性的<code class="fe nb nc nd mr b">Coords</code>类，我们可以如下实现它。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="7f03" class="mv lv jj mr b gy mw mx l my mz">Coords = namedtuple('Coords', ['latitude', 'longitude'])</span></pre><p id="82cf" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后，我们可以使用<code class="fe nb nc nd mr b">Coords</code>类实例化一个对象，这将是一个命名元组。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="d1a6" class="mv lv jj mr b gy mw mx l my mz">home = Coords(latitude=-37.8871270826, longitude=144.7558373041)</span></pre><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ns"><img src="../Images/9b02f2c5d7a2ca353154502457c7b319.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YruKtcqTzmTcCfUtfwQbAA.png"/></div></div></figure><p id="61ed" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以验证它是一个元组，尽管它有字段名。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="5237" class="mv lv jj mr b gy mw mx l my mz">isinstance(home, tuple)</span></pre><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/934243921665345161b3151914e5956f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1060/format:webp/1*CaXuzsUWpb48hSww3PlFJQ.png"/></div></figure><p id="7764" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">此外，为了从类中实例化一个命名元组，我们不必每次都指定字段名，因为命名元组的顺序和长度是固定的。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="ac6b" class="mv lv jj mr b gy mw mx l my mz">home = Coords(-37.8871270826, 144.7558373041)</span></pre><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nu"><img src="../Images/2bbe0cb2b28f03c06e8bc92b3c421ffc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gyNlI0TN_BVL4e-WWsJL0w.png"/></div></div></figure><h2 id="b73e" class="mv lv jj bd lw nv nw dn ma nx ny dp me lh nz oa mg ll ob oc mi lp od oe mk of bi translated">1.1 定义命名元组类的简单方法</h2><p id="2c91" class="pw-post-body-paragraph ky kz jj la b lb og kk ld le oh kn lg lh oi lj lk ll oj ln lo lp ok lr ls lt im bi translated">我们可以很容易地使用字符串来指定字段，而不是使用列表。例如，我们可以使用 common 来分隔字段名称。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="306c" class="mv lv jj mr b gy mw mx l my mz">Coords = namedtuple('Coords', 'latitude, longitude')</span></pre><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ol"><img src="../Images/9bfa0cacabdae409d8397167a0b50a32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JDEjLnCmlH_cTZdyEnw-aQ.png"/></div></div></figure><p id="02b4" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们甚至可以使用空格作为分隔符，这完全没问题。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="425f" class="mv lv jj mr b gy mw mx l my mz">Triangle = namedtuple('Triangle', 'first_side second_side third_side')<br/>t1 = Triangle(5, 5, 5)</span></pre><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi om"><img src="../Images/bf85a598d95315c1001a4e6c59c3ccb0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nf7DSAsQ4OqbF3kkkiiT-g.png"/></div></div></figure><h2 id="083e" class="mv lv jj bd lw nv nw dn ma nx ny dp me lh nz oa mg ll ob oc mi lp od oe mk of bi translated">1.2 使用类型提示从超类创建</h2><p id="820a" class="pw-post-body-paragraph ky kz jj la b lb og kk ld le oh kn lg lh oi lj lk ll oj ln lo lp ok lr ls lt im bi translated">从 Python 3.6 开始，我们还可以更正式地定义一个命名元组类。这也将支持命名字段的类型提示。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="e413" class="mv lv jj mr b gy mw mx l my mz">from typing import NamedTuple  # 3.6+</span><span id="e875" class="mv lv jj mr b gy on mx l my mz">class Coords(NamedTuple):<br/>    """A coordinate consists latitude and longitude"""<br/>    latitude: float<br/>    longitude: float</span><span id="7030" class="mv lv jj mr b gy on mx l my mz">home = Coords(-37.8871270826, 144.7558373041)</span></pre><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oo"><img src="../Images/a3fd4f387d019b14ee1eb85b9b66fc1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*04mdOgq6uv_3qylS1Ywp7Q.png"/></div></div></figure><p id="4c32" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">不同之处在于，我们需要使用类型模块中的<code class="fe nb nc nd mr b">NamedTuple</code>超类。</p><h1 id="1f80" class="lu lv jj bd lw lx ly lz ma mb mc md me kp mf kq mg ks mh kt mi kv mj kw mk ml bi translated">2.字段名称自动重命名</h1><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/5d771fa6b8a8d6e91946ace6e2c51d25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*viypLwSkda7wg166q0PLMA.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">图片来自<a class="ae jg" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=2574751" rel="noopener ugc nofollow" target="_blank"> Pixabay </a></p></figure><p id="8ad0" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当我们定义一个命名的元组类时，虽然我们可能使用字符串作为字段名，但它们将被反映为类属性。因此，这些字段名称会有一些限制。</p><p id="d6d7" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">首先，我们不能使用以下划线开头的字段名。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="5b29" class="mv lv jj mr b gy mw mx l my mz">MyNamedTuple = namedtuple('MyNamedTuple', ['_attr1', 'attr2'])</span></pre><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi op"><img src="../Images/6b143e5e8d56be271694ed6868d86742.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v6IdVXScmwbbSu2OpnDePA.png"/></div></div></figure><p id="bc7c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一些保留的关键词也被禁止，比如<code class="fe nb nc nd mr b">def</code>。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="5a4f" class="mv lv jj mr b gy mw mx l my mz">MyNamedTuple = namedtuple('MyNamedTuple', ['def', 'attr2'])</span></pre><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oq"><img src="../Images/f8461b038d7b4febfc0024e82836f63e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zo8YBJJUe5YXZw6Zt8yMMw.png"/></div></div></figure><p id="e596" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">此外，字段名称不能重复，因为一个类不能有两个同名的属性。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="df2c" class="mv lv jj mr b gy mw mx l my mz">MyNamedTuple = namedtuple('MyNamedTuple', ['attr1', 'attr1'])</span></pre><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi or"><img src="../Images/f3a3500f0a07cb763c44ff65fd53f76e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XOyDB-I284jgIEDCYpQ46Q.png"/></div></div></figure><p id="aa2b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然而，从 Python 3.1 开始，我们可以将标志<code class="fe nb nc nd mr b">rename</code>设置为 True，这样任何无效的字段名都会被自动重命名，而不会抛出错误。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="b9bb" class="mv lv jj mr b gy mw mx l my mz">MyNamedTuple = namedtuple(<br/>    'MyNamedTuple', <br/>    ['_attr1', 'def', 'attr2', 'attr2'], <br/>    rename=True<br/>)</span></pre><p id="d417" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">上面代码中的命名元组定义违反了这三条规则，但是因为我们将 rename 标志设置为 true，所以它不会出错。</p><p id="635d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">有一个小技巧来检查一个命名元组类的字段名，这个类使用它的私有属性<code class="fe nb nc nd mr b">_fields</code>。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="51e2" class="mv lv jj mr b gy mw mx l my mz">MyNamedTuple._fields</span></pre><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi os"><img src="../Images/2477d246b87592c8b964a9afb8cc7f68.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZKHxJ-WGbO4VFLW9yctNnw.png"/></div></div></figure><h1 id="ddde" class="lu lv jj bd lw lx ly lz ma mb mc md me kp mf kq mg ks mh kt mi kv mj kw mk ml bi translated">3.使用命名元组</h1><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/2d365edd71146d5757a831bf7a25f068.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-iPXNVS7S2MbvdgXmYXBTw.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">图片由<a class="ae jg" href="https://pixabay.com/users/geralt-9301/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=3236285" rel="noopener ugc nofollow" target="_blank"> Gerd Altmann </a>来自<a class="ae jg" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=3236285" rel="noopener ugc nofollow" target="_blank"> Pixabay </a></p></figure><p id="bf33" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了演示如何使用一个命名元组，让我们重复我们在上面几节中使用的例子。我们可以定义<code class="fe nb nc nd mr b">Coords</code>类并实例化一个命名元组<code class="fe nb nc nd mr b">home</code>。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="38d0" class="mv lv jj mr b gy mw mx l my mz">Coords = namedtuple('Coords', 'latitude, longitude')<br/>home = Coords(-37.8871270826, 144.7558373041)</span></pre><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ot"><img src="../Images/ff9b7397688af7b210a6349a73aff7e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Yp-Q8DdIPuhXlyzWCKcKwQ.png"/></div></div></figure><h2 id="7f53" class="mv lv jj bd lw nv nw dn ma nx ny dp me lh nz oa mg ll ob oc mi lp od oe mk of bi translated">3.1 访问值</h2><p id="27d1" class="pw-post-body-paragraph ky kz jj la b lb og kk ld le oh kn lg lh oi lj lk ll oj ln lo lp ok lr ls lt im bi translated">然后，我们可以访问命名元组中的值。非常直观地，我们可以使用字段名来访问它们对应的值。这是使用命名元组的主要好处之一。它还提高了代码的可读性。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="4146" class="mv lv jj mr b gy mw mx l my mz">print(home.latitude)<br/>print(home.longitude)</span></pre><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/775c8ca2edb333b61bd6d4d911720343.png" data-original-src="https://miro.medium.com/v2/resize:fit:1068/format:webp/1*ConS0Mdbf5NOLx-xzQ4xfQ.png"/></div></figure><p id="34c9" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">另外，不要忘记命名元组就是元组。因此，我们也可以使用索引来获取值。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="a793" class="mv lv jj mr b gy mw mx l my mz">print(home[0])<br/>print(home[1])</span></pre><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div class="gh gi ov"><img src="../Images/b2a7fee8107001b31bdde028fdb5630e.png" data-original-src="https://miro.medium.com/v2/resize:fit:760/format:webp/1*jJ2McicgBOCJ1CJWHoj4_A.png"/></div></figure><h2 id="4499" class="mv lv jj bd lw nv nw dn ma nx ny dp me lh nz oa mg ll ob oc mi lp od oe mk of bi translated">3.2 将命名元组转换成字典</h2><p id="fa74" class="pw-post-body-paragraph ky kz jj la b lb og kk ld le oh kn lg lh oi lj lk ll oj ln lo lp ok lr ls lt im bi translated">就其表现形式而言，命名元组非常类似于字典。字段名可以看作是字典的键，它们都有相应的值。</p><p id="e4ff" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">事实上，一个命名的元组有一个内置的私有方法来将其自身转换为有序字典。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="72ee" class="mv lv jj mr b gy mw mx l my mz">home._asdict()</span></pre><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ow"><img src="../Images/600cb107663e3c9a747bd916e203e979.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xHaNNxU4Um0ka06MCLVM3A.png"/></div></div></figure><p id="0166" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是有道理的。命名元组和字典之间最重要的区别可能是命名元组中字段的顺序很重要。这意味着命名元组和有序字典可以互换。</p><p id="f8b0" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然而，如果我们不关心键的顺序，而只想要一本字典，那该怎么办呢？我们可以简单地向有序字典添加一个类型转换，如下所示。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="14fc" class="mv lv jj mr b gy mw mx l my mz">dict(home._asdict())</span></pre><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ot"><img src="../Images/38ac4f93f77a9e6ded5b59bdf03bb280.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yzZMYX_sNMJZVI4SHFes5A.png"/></div></div></figure><h2 id="b4b6" class="mv lv jj bd lw nv nw dn ma nx ny dp me lh nz oa mg ll ob oc mi lp od oe mk of bi translated">3.3 替换字段的值</h2><p id="4730" class="pw-post-body-paragraph ky kz jj la b lb og kk ld le oh kn lg lh oi lj lk ll oj ln lo lp ok lr ls lt im bi translated">由于命名元组是元组，并且元组是不可变的，所以不可能改变字段的值。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="a964" class="mv lv jj mr b gy mw mx l my mz">home.latitude = 10</span></pre><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ox"><img src="../Images/3c26659755f0c5b5ace04eafa4532a6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hpRULNWpwG3eeYqI5_jD4w.png"/></div></div></figure><p id="787f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这种情况下，我们必须使用另一个私有方法<code class="fe nb nc nd mr b">_replace()</code>来替换字段的值。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="ee5b" class="mv lv jj mr b gy mw mx l my mz">home1 = home._replace(latitude=10)</span></pre><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oy"><img src="../Images/453294c5db1284160e4ce3508e553727.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VrtsWXvtb_rRjWOxEOX8Iw.png"/></div></div></figure><p id="d7a0" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe nb nc nd mr b">_replace()</code>方法将返回一个新的命名元组。这很重要，因为即使使用这种方法，我们仍然不能修改命名元组。</p><p id="46bf" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我们检查原始的命名元组，它没有改变。</p><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ot"><img src="../Images/4d421f3d309eafc1546c4bf521fafdbc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QpqGZdNFt_O5Ro_nr1Q1gg.png"/></div></div></figure><h2 id="1375" class="mv lv jj bd lw nv nw dn ma nx ny dp me lh nz oa mg ll ob oc mi lp od oe mk of bi translated">3.4 具有默认值的命名元组</h2><p id="c0fe" class="pw-post-body-paragraph ky kz jj la b lb og kk ld le oh kn lg lh oi lj lk ll oj ln lo lp ok lr ls lt im bi translated">就像在一个普通的类中我们可以为属性设置默认值一样，一个命名的元组类也可以设置默认值。然而，由于具有默认值的字段必须在任何没有默认值的字段之后，默认值应用于最右边的<strong class="la jk">参数。</strong></p><p id="ec10" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如，让我们再次定义只有一个默认值的<code class="fe nb nc nd mr b">Coords</code>类。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="a60f" class="mv lv jj mr b gy mw mx l my mz">Coords = namedtuple('Coords', 'latitude, longitude', defaults=[100])<br/>home = Coords(-37.8871270826)</span></pre><p id="b608" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我们实例化只有一个值的命名元组，默认值<code class="fe nb nc nd mr b">100</code>将用于经度，这是我们定义中最右边的一个。</p><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oz"><img src="../Images/d517281b777b6fae88df9b50343f03df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dlWAbdbSr-tOxV1hLi335g.png"/></div></div></figure><p id="85e3" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我们显式地将字段设置为经度，那么默认值将用于纬度吗？</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="40e8" class="mv lv jj mr b gy mw mx l my mz">home = Coords(longitude=-37.8871270826)</span></pre><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pa"><img src="../Images/2354aa783c63e182e2fb30a622a01e15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QdqVNGykQb1F9PgqWgLjbQ.png"/></div></div></figure><p id="22f5" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">答案当然是否定的。在一个命名元组中，字段的顺序是非常严格的。为了避免混淆和潜在的问题，默认值必须在最右边，即使我们明确地指定了一些东西。</p><p id="e1d1" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我们给所有字段赋予默认值，这意味着所提供的默认值的数量与字段的数量相同，那么当我们实例化一个命名元组时，我们将不必传入任何值。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="40a5" class="mv lv jj mr b gy mw mx l my mz">Coords = namedtuple('Coords', 'latitude, longitude', defaults=[-50, 100])<br/>home = Coords()</span></pre><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pb"><img src="../Images/4f7e5e3b3f21514b2463d996aa197f8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OlJJWkrPXMaMI6hT_eml2g.png"/></div></div></figure><p id="5c42" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">检查命名元组类的默认值的一个技巧是使用它的私有属性<code class="fe nb nc nd mr b">_field_defaults</code>。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="2cd4" class="mv lv jj mr b gy mw mx l my mz">Coords._field_defaults</span></pre><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pc"><img src="../Images/d8fb3556265c9c0c1c523a14447b55c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IvSC4NJ_H-Ehmj1kTRmCKw.png"/></div></div></figure><h2 id="3346" class="mv lv jj bd lw nv nw dn ma nx ny dp me lh nz oa mg ll ob oc mi lp od oe mk of bi translated">3.5 将元组转换为命名元组</h2><p id="d57f" class="pw-post-body-paragraph ky kz jj la b lb og kk ld le oh kn lg lh oi lj lk ll oj ln lo lp ok lr ls lt im bi translated">如果我们已经准备好了一个普通元组和一个命名元组类，我们可以使用私有方法<code class="fe nb nc nd mr b">_make()</code>轻松地将元组转换为命名元组。请注意，元组的长度必须与命名元组的长度相同。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="cd60" class="mv lv jj mr b gy mw mx l my mz">t1 = (-37.8871270826, 144.7558373041)<br/>home = Coords._make(t1)</span></pre><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pd"><img src="../Images/75234bd1a6c8dccd7eaeda354df77df0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HjGU2ADEZA2_DcVNCV9IEQ.png"/></div></div></figure><h1 id="95e2" class="lu lv jj bd lw lx ly lz ma mb mc md me kp mf kq mg ks mh kt mi kv mj kw mk ml bi translated">4.为什么以及何时使用命名元组？</h1><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/adce0ad1009ebf8491084b96bd7388bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UF97Ke9RMDkc3JDZjNIoOA.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">图片由<a class="ae jg" href="https://pixabay.com/users/geralt-9301/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=2212771" rel="noopener ugc nofollow" target="_blank"> Gerd Altmann </a>从<a class="ae jg" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=2212771" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>拍摄</p></figure><p id="ddbe" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们已经介绍了 Python 中关于命名元组的几乎所有内容。Python 为什么会有它，我们应该什么时候使用它？</p><p id="a1ed" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">答案如下:</p><ul class=""><li id="dd00" class="ne nf jj la b lb lc le lf lh ng ll nh lp ni lt nj nk nl nm bi translated">与普通元组相比，使用命名元组可以改进我们的代码，以表达元组元素的语义。</li><li id="030f" class="ne nf jj la b lb nn le no lh np ll nq lp nr lt nj nk nl nm bi translated">与 Python 类相比，使用命名元组可以提高代码可读性，并显著减少代码行数。</li></ul><p id="53d8" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">第一点很容易理解。对于第二个，让我们考虑下面的例子。假设我们需要定义一个<code class="fe nb nc nd mr b">Student</code>类。它不一定有任何方法。换句话说，它只是保存一个学生对象的数据。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="580f" class="mv lv jj mr b gy mw mx l my mz">class Student:<br/>    def __init__(self, student_no, first_name, last_name, birth_year, gender):<br/>        self.student_no = student_no<br/>        self.first_name = first_name<br/>        self.last_name = last_name<br/>        self.birth_year = birth_year<br/>        self.gender = gender</span></pre><p id="1f41" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我们使用一个命名元组，定义就像下面这样简单。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="af0a" class="mv lv jj mr b gy mw mx l my mz">Student = namedtuple('Student', 'student_no, first_name, last_name, birth_year, gender')</span></pre><p id="96b4" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，对于这种情况，使用命名元组比使用类要简单和整洁得多。然而，如果我们需要任何类方法，命名元组将不再适用。</p><p id="28ab" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用命名元组的另一个好处是它的可迭代性。也就是说，命名元组是可迭代的，因此它可以用于许多场景，如循环和生成器。</p><p id="f36a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们使用<code class="fe nb nc nd mr b">Student</code>类来实例化一个命名元组</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="b250" class="mv lv jj mr b gy mw mx l my mz">s1 = Student(123, 'Chris', 'Tao', 1900, 'Male')</span></pre><p id="df14" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后，我们可以循环它的值。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="5258" class="mv lv jj mr b gy mw mx l my mz">for attr in s1:<br/>    print(attr)</span></pre><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pe"><img src="../Images/60cdc1710a6b4c2de2ad0416ceef8187.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*08VUpVE1GUdIYHJ19VlWfw.png"/></div></div></figure><h1 id="83cb" class="lu lv jj bd lw lx ly lz ma mb mc md me kp mf kq mg ks mh kt mi kv mj kw mk ml bi translated">摘要</h1><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/94c048131c73d1efdc32122a3d07d64d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ovzVqAex2bWYpFP1NQ-9ug.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">图片来自<a class="ae jg" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=6803226" rel="noopener ugc nofollow" target="_blank"> Pixabay </a></p></figure><p id="ade9" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在本文中，我介绍了 Python 中的命名元组，它是什么，如何创建命名元组类，以及如何将该类实例化为命名元组。然后，我举例说明了什么时候我们应该使用命名元组，什么时候不应该。希望你喜欢阅读！</p><div class="is it gp gr iu pf"><a href="https://medium.com/@qiuyujx/membership" rel="noopener follow" target="_blank"><div class="pg ab fo"><div class="ph ab pi cl cj pj"><h2 class="bd jk gy z fp pk fr fs pl fu fw ji bi translated">通过我的推荐链接加入灵媒-陶</h2><div class="pm l"><h3 class="bd b gy z fp pk fr fs pl fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="pn l"><p class="bd b dl z fp pk fr fs pl fu fw dk translated">medium.com</p></div></div><div class="po l"><div class="pp l pq pr ps po pt ja pf"/></div></div></a></div><p id="88f0" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你觉得我的文章有帮助，请考虑加入 Medium 会员来支持我和成千上万的其他作者！(点击上面的链接)</p></div></div>    
</body>
</html>