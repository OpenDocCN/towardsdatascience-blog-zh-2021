<html>
<head>
<title>A Not so Short Introduction to the Rust Programming Language</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Rust编程语言的简短介绍</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/a-not-so-short-introduction-to-the-rust-programming-language-2e8542a06b76?source=collection_archive---------2-----------------------#2021-11-17">https://towardsdatascience.com/a-not-so-short-introduction-to-the-rust-programming-language-2e8542a06b76?source=collection_archive---------2-----------------------#2021-11-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="aba0" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">从这里开始，快速学习一门快速、安全、现代的语言</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ced74389caf8f9cef177b23773b30c3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NBwn1QUb02-aXI-K7uxoCw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来自<a class="ae ky" href="https://commons.wikimedia.org/wiki/File:RED_RUST_TEXTURE.jpg" rel="noopener ugc nofollow" target="_blank">维基共享资源</a></p></figure><p id="9d3c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你最喜欢的编程语言是什么？</p><p id="a2c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你的答案不是生锈，那么请阅读这篇文章。最后，你的答案可能会改变！</p><p id="3864" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，我将教你Rust编程的基础知识。足以让你开始并创建自己的程序。</p><p id="e9c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在文章的最后，我会指导你一些非常好的深造方向。</p><p id="21a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以在Rust培训期间以小词典或查找文章的形式回到本文。</p><p id="1f36" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">学习一门新的编程语言就像学习任何其他语言一样。最快的方法是尝试一下，在这种情况下，你不需要来自不同国家的朋友或飞机。你只需要你的新朋友Rust编译器。相信我，它会是一个真正的好朋友。</p><p id="8d89" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，请随意编写代码，尝试自己的例子，或者像阅读任何其他文章或书籍一样，简单地用一杯浓咖啡阅读这篇文章。</p><p id="8182" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们开始吧…</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="9cb2" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">目录</h1><p id="8907" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><a class="ae ky" href="#cdf0" rel="noopener ugc nofollow">安装和第一个项目</a> <br/> <a class="ae ky" href="#8cb5" rel="noopener ugc nofollow">变量</a> <br/> <a class="ae ky" href="#97ff" rel="noopener ugc nofollow">数据类型</a> <br/> ∘ <a class="ae ky" href="#cf00" rel="noopener ugc nofollow">数字</a> <br/> ∘ <a class="ae ky" href="#1cb8" rel="noopener ugc nofollow">布尔值</a> <br/> ∘ <a class="ae ky" href="#260e" rel="noopener ugc nofollow">字符串、 &amp; str和字符</a> <br/> <a class="ae ky" href="#40cf" rel="noopener ugc nofollow">集合</a> <br/> ∘ <a class="ae ky" href="#c68c" rel="noopener ugc nofollow">数组</a> <br/> ∘ <a class="ae ky" href="#6e43" rel="noopener ugc nofollow">元组</a> <br/> ∘ <a class="ae ky" href="#ccf2" rel="noopener ugc nofollow">向量</a> <br/> ∘ <a class="ae ky" href="#1abe" rel="noopener ugc nofollow">哈希映射</a> <br/> <a class="ae ky" href="#316f" rel="noopener ugc nofollow">函数</a> <br/> <a class="ae ky" href="#25cf" rel="noopener ugc nofollow">控制流和循环</a> <br/> ∘ <a class="ae ky" href="#7af5" rel="noopener ugc nofollow">条件</a> <br/> ∘ <a class="ae ky" href="#95ce" rel="noopener ugc nofollow">循环</a></p><p id="3a3b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Rust已经存在，如果你想学习一门既安全又经得起未来考验的现代表演语言，Rust是一个不错的选择。</p><p id="31dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Rust是一种系统编程语言，运行速度极快，几乎可以防止所有的崩溃，并消除数据竞争。</p><p id="79bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管Rust被归类为系统编程语言，但你真的可以在Rust中构建任何东西。你只需要牺牲一些时间。作为回报，你得到的是安全和惊人的速度。</p><p id="8188" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Rust以难学而闻名，但我认为这实际上取决于最初的方法和心态。</p><p id="3b44" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你只需要在编码时有一点不同的想法——就像一个乡下人！</p><h1 id="cdf0" class="mc md it bd me mf mz mh mi mj na ml mm jz nb ka mo kc nc kd mq kf nd kg ms mt bi translated">安装和第一个项目</h1><p id="51a7" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">Rust的安装没有痛苦，这要感谢一个叫做rustup的小工具。</p><p id="a317" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以按照这里的说明<a class="ae ky" href="https://doc.rust-lang.org/book/ch01-01-installation.html" rel="noopener ugc nofollow" target="_blank">安装Rust</a>或者只是通过谷歌搜索。</p><p id="076c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当你安装了Rust和它神奇的软件包管理器——Cargo——之后，你就可以开始工作了。</p><p id="6982" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设您想要创建一个名为“rusty_cli”的项目。</p><p id="3150" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在您的文件系统上找到一个您想要放置项目的位置。然后将自己“cd”到<em class="ne">命令/终端</em>中的位置。</p><p id="b0c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您在想要放置项目的文件夹中时，只需使用<code class="fe nf ng nh ni b">cargo new rusty_cli</code>。</p><p id="e035" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Cargo将施展它的魔法，创建一个它理解的项目结构，包括一个名为<code class="fe nf ng nh ni b">src</code>的文件夹，里面是一个名为<code class="fe nf ng nh ni b">main.rs</code>的文件。</p><p id="ae76" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">文件<code class="fe nf ng nh ni b">main.rs</code>是程序的入口点。为了运行程序，你有几个不同的选择使用货物。</p><p id="4868" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以使用<code class="fe nf ng nh ni b">cargo run</code>在调试模式下运行主文件，或者使用<code class="fe nf ng nh ni b">cargo build </code>创建可执行文件。这个可执行文件将存储在<code class="fe nf ng nh ni b">target/debug</code>中。</p><blockquote class="nj nk nl"><p id="e4e2" class="kz la ne lb b lc ld ju le lf lg jx lh nm lj lk ll nn ln lo lp no lr ls lt lu im bi translated">你不必使用cargo来编译和运行Rust程序，但它是一个非常友好的工具，我强烈推荐使用它。</p></blockquote><p id="fd43" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您准备好构建最终的可执行文件时，您可以使用命令<code class="fe nf ng nh ni b">cargo build --release</code>对其进行编译和优化。该命令将在<code class="fe nf ng nh ni b">target/release</code>而不是<code class="fe nf ng nh ni b">target/debug</code>中创建一个可执行文件。</p><p id="776a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些优化使Rust代码运行得更快，但编译时间上的损失很小。</p><h1 id="8cb5" class="mc md it bd me mf mz mh mi mj na ml mm jz nb ka mo kc nc kd mq kf nd kg ms mt bi translated">变量</h1><p id="50d0" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">Rust中的变量是使用<code class="fe nf ng nh ni b">let</code>关键字定义的，默认情况下是不可变的。我们来举个例子。下面的代码将<em class="ne">还没有</em>编译。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="c335" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你一直跟随，那么你会看到编译器抱怨类似“<em class="ne">不能给不可变变量</em>赋值两次”。</p><p id="c672" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了解决这个问题，我们可以采取以下措施:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="9436" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，如果我们把关键字<code class="fe nf ng nh ni b">mut</code>放在变量名的前面，那么变量就变得可变了。</p><p id="ad60" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另外，请注意Rust中的表达式是如何工作的。表达式是返回值的东西。如果你加上分号，你就抑制了这个表达式的结果，这在大多数情况下是你想要的。</p><p id="0187" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们一会儿谈到函数时，这一点会更清楚。</p><h1 id="97ff" class="mc md it bd me mf mz mh mi mj na ml mm jz nb ka mo kc nc kd mq kf nd kg ms mt bi translated">数据类型</h1><p id="cf0c" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">数据类型通常与算术运算密切相关，但我不会花太多篇幅来讨论这个问题，因为对数字的常见运算也适用于Rust。</p><p id="2668" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Rust中的许多数据类型与其他语言共享。我们有整数类型，如<code class="fe nf ng nh ni b">i32</code>或<code class="fe nf ng nh ni b">i64</code>，也有浮点数类型，如<code class="fe nf ng nh ni b">f64</code>。</p><p id="7333" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还有数据类型<code class="fe nf ng nh ni b">bool</code>，它可以包含值<code class="fe nf ng nh ni b">true</code>或<code class="fe nf ng nh ni b">false</code> <em class="ne">，</em>我们有<code class="fe nf ng nh ni b">string</code> <em class="ne">，</em> <code class="fe nf ng nh ni b"><em class="ne">&amp;str</em></code>和<code class="fe nf ng nh ni b">char</code>用于存储文本数据，还有<code class="fe nf ng nh ni b">tuple</code>，<code class="fe nf ng nh ni b">array</code>，<code class="fe nf ng nh ni b">vector</code>和<code class="fe nf ng nh ni b">hash map</code>作为一些常见的集合。</p><p id="8555" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在此之上，我们有<code class="fe nf ng nh ni b">structs</code> <em class="ne">、</em> <code class="fe nf ng nh ni b"><em class="ne">methods</em></code> <em class="ne"> </em>和<code class="fe nf ng nh ni b">associated functions</code>作为<em class="ne"> OOP </em>语言中类和方法的替代，还有一个有趣的类型叫做<code class="fe nf ng nh ni b">trait</code>，有点像<em class="ne">接口</em>，例如<em class="ne"> Go </em>。</p><p id="0e64" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了用于结构化相关数据的结构和元组结构，我们还有在Rust语言中起核心作用的类型<code class="fe nf ng nh ni b">enum</code>。</p><p id="bbd4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其中一些类型的用法最好通过例子和自己的实验来学习，但是，我认为在这一点上一些最初的解释和例子是合适的。</p><h2 id="cf00" class="nr md it bd me ns nt dn mi nu nv dp mm li nw nx mo lm ny nz mq lq oa ob ms oc bi translated">数字</h2><p id="0328" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">请注意，当您声明变量时，您可以选择通过在声明中显式声明来指定数据类型。</p><p id="645a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们想存储一个包含大小为8位的无符号整数的变量，我们必须像下面这样做:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="6c33" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你刚刚写了<code class="fe nf ng nh ni b">let age = 18;</code>，那么Rust会推断出年龄的类型是<code class="fe nf ng nh ni b">i32</code>。</p><h2 id="1cb8" class="nr md it bd me ns nt dn mi nu nv dp mm li nw nx mo lm ny nz mq lq oa ob ms oc bi translated">布尔运算</h2><p id="b838" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">Rust中称为“布尔”的布尔与其他语言中的布尔相似。语法是<code class="fe nf ng nh ni b">true</code>和<code class="fe nf ng nh ni b">false</code>(注意小写)，一个例子是<code class="fe nf ng nh ni b">let b = true;</code>。</p><h2 id="260e" class="nr md it bd me ns nt dn mi nu nv dp mm li nw nx mo lm ny nz mq lq oa ob ms oc bi translated">字符串、字符串和字符</h2><p id="77a3" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">字符类型用单引号写成，如<em class="ne">‘c’</em>，表示数据类型的关键字是<code class="fe nf ng nh ni b">char</code>。</p><p id="612d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Rust中的字符串比Python中的要复杂一些，但这是因为Python中隐藏了很多细节。嗯，没有那么多铁锈！</p><p id="2d0a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样做的原因是为了防止将来处理字符串时出现错误。Rust中的一个常见概念是，该语言通过处理编译时可能出现的错误来确保安全性。无论如何，这是一件好事，但它对程序员提出了一些要求。</p><p id="27f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">字符串被实现为字节的集合，当这些字节被解释为文本时，还有一些方法提供有用的功能。</p><p id="83db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">字符串比许多程序员认为的更复杂。这是因为它们对程序员来说很自然——毕竟，我们现代人习惯于在日常生活中处理文本。</p><p id="6e66" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，由于我们认为有意义的子串和机器如何解释子串之间存在差异，事情并不像看起来那么简单。我们需要一种叫做编码的东西作为机器和大脑之间的桥梁。</p><p id="1cc9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们不会深入编码世界的细节，但是如果你发现自己有一天晚上无法入睡，那么尽一切办法进行一次研究之旅，深入研究编码，它比你想象的更令人着迷！</p><p id="57c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Rust在<code class="fe nf ng nh ni b">UTF-8</code>中对字符串进行编码，与Python不同，我们可以让字符串在Rust中生长。</p><p id="2d80" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如上所述，Rust有不止一种类型的字符串。类型<code class="fe nf ng nh ni b">String</code>和类型<code class="fe nf ng nh ni b">str</code>，后者通常以<code class="fe nf ng nh ni b">&amp;str</code> <em class="ne">、</em>的形式出现，被<em class="ne"> </em>称为<em class="ne">字符串片</em>或<em class="ne">字符串文字</em>。</p><p id="af2f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个<code class="fe nf ng nh ni b">String</code>被存储为一个字节<code class="fe nf ng nh ni b">Vec&lt;u8&gt;</code>的向量，并带有方便的方法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="1704" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将很快处理向量。现在，你可以把它们看作一个典型的数组。</p><p id="20b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这两种类型的字符串之间到底有什么区别，现在就跳过，但是我能说的是，如果你做一个如下的变量:</p><pre class="kj kk kl km gt od ni oe of aw og bi"><span id="58a5" class="nr md it ni b gy oh oi l oj ok">let s = "Towards Data Science";</span></pre><p id="c42a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么<em class="ne"> s </em>将是<code class="fe nf ng nh ni b">&amp;str</code>T26】类型。如果你想将<code class="fe nf ng nh ni b">"Towards Data Science"</code>存储为一个字符串类型，你可以</p><pre class="kj kk kl km gt od ni oe of aw og bi"><span id="13d1" class="nr md it ni b gy oh oi l oj ok">let s = "Towards Data Science".to_string();</span></pre><p id="9705" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者相当于:</p><pre class="kj kk kl km gt od ni oe of aw og bi"><span id="73d9" class="nr md it ni b gy oh oi l oj ok">let s = String::from("Towards Data Science");</span></pre><p id="7e22" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这两种类型的主要区别在于<code class="fe nf ng nh ni b">&amp;str</code>是不可变的，存储在堆栈上，而字符串类型可以是可变的，因此存储在堆上。</p><p id="cdf2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你不知道栈和堆，不要担心。了解它们最重要的一点是，访问和写入堆栈要比堆快得多。</p><p id="cc68" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在整个运行期间，存储在堆栈上的数据需要具有固定的大小。这意味着如果一个变量被允许增加大小，那么它需要被存储在堆中。</p><p id="1e61" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这两种类型也是相关的，正如名称string slice所表明的那样，<code class="fe nf ng nh ni b">&amp;str</code>是一个字符串类型的子串，不管这意味着什么(试着自己找出答案)。</p><p id="e288" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于这是一个简短的介绍，我们现在将离开这个主题和这个数据类型，但字符串的数据类型是一个丰富而令人兴奋的主题，我鼓励你在阅读完这篇文章后深入研究这个主题。</p><h1 id="40cf" class="mc md it bd me mf mz mh mi mj na ml mm jz nb ka mo kc nc kd mq kf nd kg ms mt bi translated">收集</h1><p id="0a52" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在Rust中，我们有许多集合，但其中一些比另一些使用得更多。</p><h2 id="c68c" class="nr md it bd me ns nt dn mi nu nv dp mm li nw nx mo lm ny nz mq lq oa ob ms oc bi translated">排列</h2><p id="cd40" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">例如，Rust中的数组就像Go中的数组。它的大小是固定的，因此可以存储在堆栈中，这意味着快速访问。</p><p id="e063" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在数组中，一次只能存储一种数据类型。</p><p id="deb7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">语法类似于Python的list:</p><pre class="kj kk kl km gt od ni oe of aw og bi"><span id="4447" class="nr md it ni b gy oh oi l oj ok">let rust_array = [1, 2, 3];</span></pre><p id="582a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以像在Python中一样访问特定的元素。<code class="fe nf ng nh ni b">rust_array[0]</code>给了我们第一个元素，在这个例子中是<em class="ne"> 1 </em>。</p><h2 id="6e43" class="nr md it bd me ns nt dn mi nu nv dp mm li nw nx mo lm ny nz mq lq oa ob ms oc bi translated">元组</h2><p id="7998" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">tuple类型通常在Rust中用于在一个集合中存储不同的数据类型。</p><p id="2e33" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以用点符号来访问元素:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><h2 id="ccf2" class="nr md it bd me ns nt dn mi nu nv dp mm li nw nx mo lm ny nz mq lq oa ob ms oc bi translated">矢量</h2><p id="e204" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">Vectors是Rust中最常用的集合之一，因为就像<em class="ne"> Python </em>的列表或<em class="ne"> Go </em>的切片一样，Rust中的vector的大小可以增长。</p><p id="5338" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它只能保存一种数据类型，但是正如您稍后将看到的，有一些方法可以解决这个问题。不过，我们必须知道一种叫做<code class="fe nf ng nh ni b">enum</code>的类型，才能开始写这方面的内容。</p><p id="8fb5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如你所想象的，向量可以增长的事实使它成为一个非常重要的类型。</p><p id="bc8d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要创建一个新的空向量，我们可以调用<code class="fe nf ng nh ni b">Vec::new</code>函数:</p><pre class="kj kk kl km gt od ni oe of aw og bi"><span id="857d" class="nr md it ni b gy oh oi l oj ok">let mut v: Vec&lt;i32&gt; = Vec::new();</span></pre><p id="3588" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦创建完成，我们现在就可以将元素放入其中。例如，<code class="fe nf ng nh ni b">v.push(1)</code>将在<code class="fe nf ng nh ni b">v</code>后追加1，现在大小已经增大。</p><p id="45b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您想实例化包含元素的向量，我们有一个方便的宏:</p><pre class="kj kk kl km gt od ni oe of aw og bi"><span id="39ae" class="nr md it ni b gy oh oi l oj ok">let v = vec![1, 2, 3];</span></pre><p id="bb8a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">稍后我们会看到更多的宏。</p><p id="bf7d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从向量中获取元素有两种方法。在这种情况下，我们可以像在<em class="ne"> Python </em>中那样用<em class="ne"> v[i] </em>符号获取第<em class="ne"> i </em>个元素。但是我们需要小心，向量实际上有足够的元素。</p><p id="c2e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果它有更少的元素，而我们试图访问一个不存在的元素，那么我们将在运行时得到一个错误！这很危险，所以Rust有另一种方法来访问vector中的元素。</p><p id="fefa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们像<code class="fe nf ng nh ni b">let second = v.get(1);</code>一样访问它</p><p id="cf95" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在<code class="fe nf ng nh ni b">second</code>将属于<code class="fe nf ng nh ni b">Option&lt;T&gt;</code>类型，我还没有介绍过，但是很快你就会知道这意味着什么，以及如何获取值。</p><p id="b955" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们也可以在for循环中迭代向量，但是因为我还没有讨论循环，所以我会向你展示语法。</p><h2 id="1abe" class="nr md it bd me ns nt dn mi nu nv dp mm li nw nx mo lm ny nz mq lq oa ob ms oc bi translated">哈希映射</h2><p id="0c07" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">哈希映射就像Python中的字典或Go中的映射，类型用<code class="fe nf ng nh ni b">HashMap&lt;K, V&gt;</code>表示。它存储了类型为<code class="fe nf ng nh ni b">K</code>的键到类型为<code class="fe nf ng nh ni b">V.</code>的值的映射</p><p id="f5dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要初始化和填充散列映射，我们可以执行以下操作:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="674b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nf ng nh ni b">insert</code>方法通过一组键和值作为参数将数据推入散列映射。</p><p id="9e28" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您想访问哈希表中的数据，我们也有<code class="fe nf ng nh ni b">get</code>方法。具体来说，</p><pre class="kj kk kl km gt od ni oe of aw og bi"><span id="5cce" class="nr md it ni b gy oh oi l oj ok">let a = articles.get(&amp;String::from("Python Graph"));</span></pre><p id="340a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将返回一个<code class="fe nf ng nh ni b">Option</code>类型，我们可以从中获取值。符号<code class="fe nf ng nh ni b">&amp;</code>也将很快被涵盖。</p><p id="d201" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们想通过一个键来更新哈希表，并且不确定它是否已经存在时，我们有几种选择。其中之一是方便的<code class="fe nf ng nh ni b">entry</code>方法:</p><pre class="kj kk kl km gt od ni oe of aw og bi"><span id="3406" class="nr md it ni b gy oh oi l oj ok">articles.entry(String::from("Rust")).or_insert("https://www.cantorsparadise.com/the-most-loved-programming-language-in-the-world-5220475fcc22");</span></pre><p id="cca3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果这个键已经在散列映射中，那么我们将得到一个对它的<em class="ne">可变引用</em>，如果没有，那么我们将把参数中指定的数据插入到<code class="fe nf ng nh ni b">or_insert</code>中。参考文献将在稍后解释。</p><h1 id="316f" class="mc md it bd me mf mz mh mi mj na ml mm jz nb ka mo kc nc kd mq kf nd kg ms mt bi translated">功能</h1><p id="137f" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">功能是Rust最重要的特征之一。</p><p id="7bff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们已经看到了起特殊作用的<em class="ne"> main </em>函数，但是我们当然也能够创建其他函数。</p><p id="52b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">语法很简单。下面是Rust中另一个函数的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="40c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，我们需要告诉Rust函数接受哪种数据类型作为输入，以及它将输出哪种类型。这是一件好事，因为它可以防止许多错误。</p><p id="4477" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关于Rust的另一个有趣的事情是，你不必通过一个<code class="fe nf ng nh ni b">return</code>关键字显式地告诉Rust你返回了什么。如果函数中的最后一条语句没有尾随分号，那么这就是函数返回的内容。</p><p id="47fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这通常也适用于花括号中的代码块。很像Scala。</p><p id="528c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的例子中。函数<code class="fe nf ng nh ni b">plus_one</code>返回<code class="fe nf ng nh ni b">x+1</code>，其中x是函数作为参数接受的整数。</p><p id="8bac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Rust中，我们有一个<code class="fe nf ng nh ni b">return</code>关键字，但它通常只在你想提前返回某个东西时使用。</p><h1 id="25cf" class="mc md it bd me mf mz mh mi mj na ml mm jz nb ka mo kc nc kd mq kf nd kg ms mt bi translated">控制流程和循环</h1><p id="c670" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">控制流操作的语法通常最好通过自己做一些小练习来学习。</p><h2 id="7af5" class="nr md it bd me ns nt dn mi nu nv dp mm li nw nx mo lm ny nz mq lq oa ob ms oc bi translated">情况</h2><p id="9abb" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">看看下面的程序，并尝试修改它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="4387" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们看到Rust中的注释是用双斜线或者多行注释的<code class="fe nf ng nh ni b">/* blah blah */</code>来完成的。还要注意我们如何能够用关键字<code class="fe nf ng nh ni b">return</code>提前返回一些东西。</p><p id="fc43" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nf ng nh ni b">if, else if, else</code>的语法类似于<em class="ne"> Go </em>的。布尔表达式周围不需要括号，这对可读性很好。</p><h2 id="95ce" class="nr md it bd me ns nt dn mi nu nv dp mm li nw nx mo lm ny nz mq lq oa ob ms oc bi translated">环</h2><p id="3583" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在Rust中，我们有几种不同的循环。</p><p id="e43d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想要一个无限循环，我们有<code class="fe nf ng nh ni b">loop</code>，它当然应该在某个时候被打破。因此，Rust还有一个方便的特性，使您能够打破特定的循环，而不仅仅是内部循环。</p><p id="90d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面的例子是从《锈书》中借来的，我们都应该把它放在枕头下(或者在这个时代保存为书签)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="caa3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，我们如何通过<code class="fe nf ng nh ni b">'label: loop</code>语法标记循环，并通过稍后基于某些条件调用该标记来中断特定的循环。</p><p id="f1da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还有一个while循环，使用起来非常直观:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="bbdb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来当然是for循环，其语法如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="0f16" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们能够在迭代器上循环，你是否必须让你的数据类型成为迭代器当然取决于类型本身。注意，这种语法很像Python中的语法，只是在Python中很少需要改变类型。</p><h1 id="0ec7" class="mc md it bd me mf mz mh mi mj na ml mm jz nb ka mo kc nc kd mq kf nd kg ms mt bi translated">所有权和借款</h1><p id="ff77" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">Rust真正区别于其他语言的一个特征是它处理内存的聪明的所有权系统。</p><p id="e6a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你看，不同的编程语言以不同的方式处理内存。在一些语言中，你必须自己分配和释放内存，这使得你的代码很快，并给你低级别的控制。可以说你“离金属更近了”。这方面的一个例子是<strong class="lb iu"> C </strong>。</p><p id="2087" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在其他语言中，你有一个垃圾收集器，它可以确保你的安全并自动清理内存。这既方便又安全，但不是免费的。它会减慢程序的速度。这方面的例子包括<strong class="lb iu"> Python </strong>、<strong class="lb iu"> Java </strong>和<strong class="lb iu"> Go </strong>以及许多其他的。</p><p id="33f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Rust采取了一种完全不同的内存管理方法。Rust在一个被称为所有权的系统中结合了安全性和速度。</p><p id="d0c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如铁锈书所说:</p><blockquote class="ol"><p id="27d0" class="om on it bd oo op oq or os ot ou lu dk translated">因为所有权对于许多程序员来说是一个新概念，所以确实需要一些时间来适应。好消息是，你对Rust和所有权系统的规则越有经验，你就越能自然地开发出安全高效的代码。坚持下去！</p><p id="15f9" class="om on it bd oo op oq or os ot ou lu dk translated">——<a class="ae ky" href="https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html" rel="noopener ugc nofollow" target="_blank">锈书</a>。</p></blockquote><p id="54c3" class="pw-post-body-paragraph kz la it lb b lc ov ju le lf ow jx lh li ox lk ll lm oy lo lp lq oz ls lt lu im bi translated">首先，让我们陈述所有权的规则:</p><ul class=""><li id="accf" class="pa pb it lb b lc ld lf lg li pc lm pd lq pe lu pf pg ph pi bi translated">Rust中的每个值都有一个变量，称为它的<em class="ne">所有者</em>。</li><li id="d2c4" class="pa pb it lb b lc pj lf pk li pl lm pm lq pn lu pf pg ph pi bi translated">一次只能有一个所有者。</li><li id="d58d" class="pa pb it lb b lc pj lf pk li pl lm pm lq pn lu pf pg ph pi bi translated">当所有者超出范围时，该值将被丢弃。</li></ul><p id="6bd5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有意思…是什么意思？</p><p id="ba18" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">考虑以下代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="ecce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这实际上将<strong class="lb iu">而不是</strong>编译。为了理解这一点，让我们从所有权的角度来看。</p><p id="2c02" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，变量<code class="fe nf ng nh ni b">s1</code>通过取得值<code class="fe nf ng nh ni b">String::from("Hi")</code>的所有权而进入范围。然后变量<code class="fe nf ng nh ni b">s2</code>获得该值的所有权，我们从所有权规则中知道，只能有一个所有者。</p><p id="7d11" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这意味着变量<code class="fe nf ng nh ni b">s1</code>不再有效。在《铁锈》中，我们谈到了“一个被移动的价值”。所以真正发生的是所有权或价值被转移到了<code class="fe nf ng nh ni b">s2</code>，因此在那之后我们无法访问<code class="fe nf ng nh ni b">s1</code>。</p><p id="8298" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果<code class="fe nf ng nh ni b">s1</code>和<code class="fe nf ng nh ni b">s2</code>是例如<code class="fe nf ng nh ni b">i32</code>，那么这就不会发生，因为它们的值会被复制。这与Rust如何存储不同的值有关。如果一个值存储在堆上，那么这些规则适用，但是如果它存储在栈上，因此实现了<code class="fe nf ng nh ni b">Copy</code>特征，那么将会发生一个简单的值拷贝。</p><p id="3548" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看另一个例子，在这里我们将看到函数也可以获得所有权。</p><p id="00f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面的例子也是来自铁锈书。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="3640" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以通过查看评论清楚地看到发生了什么。当一个变量作为参数传递给一个函数时，该变量的所有权被转移到该函数，并且该变量在当前范围内变得不可访问。</p><p id="7e58" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另外，请注意，如果存储在堆上的变量(例如字符串或向量)超出范围，那么只有在所有权在此之前没有移动的情况下，才会释放内存。</p><p id="4453" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这一点上，我确信这看起来有点限制和麻烦，你甚至不能在不转移所有权的情况下打印出变量，从而使变量不可访问。</p><p id="391b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，有一个系统可以解决这个问题。</p><p id="e7de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个系统叫做<em class="ne">借力。任何其他语言都有指针。Rust有引用，这些引用与借用规则配合得很好。</em></p><p id="21ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">考虑以下代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="596f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这实际上编译和运行没有任何问题。前缀被称为引用，当一个函数被赋予一个引用或者一个变量被赋予一个引用时，它们并不拥有它的所有权。</p><p id="5c46" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的例子中，我们需要在<code class="fe nf ng nh ni b">println!</code>宏中使用变量<code class="fe nf ng nh ni b">s1</code>，因此我们不能让函数<code class="fe nf ng nh ni b">calculate_lenght</code>获得所有权。这个函数只是借用了一个不可变的引用，这个引用的值被分配给了我们想要的<code class="fe nf ng nh ni b">s1</code>。</p><p id="f73f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们也可以有可变的引用，但是有一些规则来管理这个特性，以避免诸如竞争条件等讨厌的问题。</p><p id="2773" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">引用的规则如下:</p><ul class=""><li id="3763" class="pa pb it lb b lc ld lf lg li pc lm pd lq pe lu pf pg ph pi bi translated">在任何给定的时间，你可以拥有<em class="ne">或者</em>一个可变引用<em class="ne">或者</em>任意数量的不可变引用。</li><li id="5e87" class="pa pb it lb b lc pj lf pk li pl lm pm lq pn lu pf pg ph pi bi translated">参考必须始终有效。</li></ul><p id="9d9c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">记住这一点的方法是，它就像任何其他文件。一次将读权限分配给几个不同的人是没问题的，因为在这种情况下不会发生任何不好的事情。但是，如果您同时授予几个人对一个文件的写访问权限，可能会出现很多问题。</p><p id="2877" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是当你在Git中遇到合并冲突时发生的事情，对吗？我们不应该在代码中出现这个问题，因为Rust不知道如何处理这个问题。因此，在任何给定时间最多只能有一个可变引用。</p><h1 id="82bf" class="mc md it bd me mf mz mh mi mj na ml mm jz nb ka mo kc nc kd mq kf nd kg ms mt bi translated">结构、枚举和方法</h1><p id="61ee" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">结构和枚举在很多方面都是Rust的核心构件。如果你来自面向对象的语言，你会有宾至如归的感觉。</p><p id="faab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们引入哈希映射时，我们创建了一个<code class="fe nf ng nh ni b">articles</code>哈希映射来存储文章。然而，如果我们想保存更多关于它们的信息，比如出版商或长度(分钟)呢？</p><p id="202a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以定制包含这种结构化信息的数据类型吗？嗯，是的。</p><p id="4dcc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看一看以下内容:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="bff9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在文件的底部，我们创建了一个名为<code class="fe nf ng nh ni b">Article</code>的结构。我们现在能够在一个容器中存储相关数据。链接、料盒和长度数据称为字段，我们可以用点符号来访问它们，稍后我们会看到。</p><p id="9eb2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看如何使用<code class="fe nf ng nh ni b">impl</code>语法在结构上实现方法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="0e4b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该程序的输出如下:</p><pre class="kj kk kl km gt od ni oe of aw og bi"><span id="289d" class="nr md it ni b gy oh oi l oj ok">The article "The Most Loved Programming Language in the World" is about 4 minutes long and is published in Cantors's Paradise.</span><span id="680e" class="nr md it ni b gy po oi l oj ok">Please go to https://www.cantorsparadise.com/the-most-loved-programming-language-in-the-world-5220475fcc22 to read it.</span><span id="d226" class="nr md it ni b gy po oi l oj ok">The article "How to Give Your Python Code a Magic Touch" is about 6 minutes long and is published in Towards Data Science.</span><span id="0bdd" class="nr md it ni b gy po oi l oj ok">Please go to https://towardsdatascience.com/how-to-give-your-python-code-a-magic-touch-c778eeb9ac57 to read it.<br/></span></pre><p id="1247" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">枚举很像结构，但是在枚举中，可以有给定数据类型的子类型，这非常有用。</p><p id="d896" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请考虑对我们的代码进行以下更改:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="2cf3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个程序的输出是:</p><pre class="kj kk kl km gt od ni oe of aw og bi"><span id="9bdd" class="nr md it ni b gy oh oi l oj ok">The article "How to Give Your Python Code a Magic Touch" is about 6 minutes long and is published in Towards Data Science.</span><span id="af1c" class="nr md it ni b gy po oi l oj ok">Please go to https://towardsdatascience.com/how-to-give-your-python-code-a-magic-touch-c778eeb9ac57 to read it.</span><span id="ea5b" class="nr md it ni b gy po oi l oj ok">Programming article coming up!</span><span id="f187" class="nr md it ni b gy po oi l oj ok">The article "The Most Loved Programming Language in the World" is about 4 minutes long and is published in Cantors's Paradise.</span><span id="57de" class="nr md it ni b gy po oi l oj ok">Please go to https://www.cantorsparadise.com/the-most-loved-programming-language-in-the-world-5220475fcc22 to read it.</span></pre><p id="6f67" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里介绍了几个新特性，同时也收集了一些旧特性。</p><p id="eb38" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，注意我们如何创建了一个包含两个变量的<code class="fe nf ng nh ni b">Story</code>枚举:<code class="fe nf ng nh ni b">Mathematics</code>和<code class="fe nf ng nh ni b">DataScience</code>。这很方便，因为回想一下在上面的vector小节中，我们说过vector只能保存一种类型。嗯，我们已经创建了一个保存类型<code class="fe nf ng nh ni b">Story</code>的向量，但是它有一些变体，这些变体不一定包含相同的类型。</p><p id="b768" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nf ng nh ni b">DataScience</code>和<code class="fe nf ng nh ni b">Mathematics</code>都包含类型<code class="fe nf ng nh ni b">Article</code>，但是如果我们愿意，我们也可以选择<code class="fe nf ng nh ni b">String</code>和<code class="fe nf ng nh ni b">f64</code>。</p><p id="469c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们还引入了<code class="fe nf ng nh ni b">match</code>控制流操作符，它在这种情况下接受一个enum并检查它的变量。如果找到匹配，我们就执行一些代码。</p><p id="850a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">非常简单，但是非常强大。</p><p id="e2bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">回想一下，vectors和hash maps上的get-method都返回了某种叫做<code class="fe nf ng nh ni b">Option</code>的类型。</p><p id="113f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nf ng nh ni b">Option</code>是一个有两个变体的枚举:<code class="fe nf ng nh ni b">Some</code>和<code class="fe nf ng nh ni b">None</code>。</p><p id="1611" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Rust迫使你以可控和安全的方式处理<code class="fe nf ng nh ni b">None</code>值，不像其他语言。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="dc35" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，我们可以有嵌套的匹配子句。此代码的输出将与之前相同，但也是一行:</p><pre class="kj kk kl km gt od ni oe of aw og bi"><span id="0e7c" class="nr md it ni b gy oh oi l oj ok">We have less than three elements...</span></pre><p id="3045" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样，我们可以安全地处理丢失的值。</p><h1 id="a22f" class="mc md it bd me mf mz mh mi mj na ml mm jz nb ka mo kc nc kd mq kf nd kg ms mt bi translated">错误处理</h1><p id="a4c2" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">Rust需要像其他编程语言一样处理错误。没有不出错的软件。</p><p id="9845" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是在Rust中，我们有enums供我们使用，这意味着安全的错误处理！</p><p id="8fd1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有时候我们真的需要让程序崩溃。这听起来可能很奇怪，但是如果一个错误是不可恢复的和危险的，那么最好关闭它。</p><p id="281f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这可以通过<code class="fe nf ng nh ni b">panic!</code>宏来完成。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="7523" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nf ng nh ni b">panic!</code>宏通过在关闭前清除内存来结束。这需要一点时间，这个行为是可以修改的。</p><p id="c06b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">大多数时候，我们实际上能够优雅地处理错误。这是通过<code class="fe nf ng nh ni b">Result</code>枚举完成的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="34ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还没有谈到泛型，所以这对你来说应该没什么意义。</p><p id="a130" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">只需将<code class="fe nf ng nh ni b">T</code>替换为任何数据类型，将<code class="fe nf ng nh ni b">E</code>替换为任何错误类型。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="8329" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你现在不需要得到所有这些。但是我认为你已经抓住了要点。<code class="fe nf ng nh ni b">File::open</code>返回一个<code class="fe nf ng nh ni b">Result</code>枚举，它可能包含错误，也可能不包含错误。</p><p id="9d95" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可以用模式匹配来提取和处理。一旦你学会了闭包，你将有更多的选择。</p><h1 id="1b91" class="mc md it bd me mf mz mh mi mj na ml mm jz nb ka mo kc nc kd mq kf nd kg ms mt bi translated">试验</h1><p id="0dc3" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">Rust中的测试内置于语言本身的结构中。看看下面的片段:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="8e60" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您应该为您编写的每个文件添加一个测试模块。我们还没有讨论Rust中的模块，但是你已经明白了。</p><p id="846e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你运行<code class="fe nf ng nh ni b">cargo test</code>，所有的测试都会自动运行。</p><p id="df5f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Rust中测试的巨大优势是极其有用的编译器。事实上，Rust开发软件的最佳实践是使用测试驱动开发(TDD)。</p><p id="2385" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是因为编译器为您的问题提供了很好的解决方案。以至于它几乎可以帮你写代码。</p><p id="d442" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看看这个小教程，明白我的意思:</p><div class="pp pq gp gr pr ps"><a href="https://doc.rust-lang.org/book/ch12-00-an-io-project.html" rel="noopener  ugc nofollow" target="_blank"><div class="pt ab fo"><div class="pu ab pv cl cj pw"><h2 class="bd iu gy z fp px fr fs py fu fw is bi translated">I/O项目:构建命令行程序</h2><div class="pz l"><h3 class="bd b gy z fp px fr fs py fu fw dk translated">这一章是对到目前为止你所学的许多技能的一个回顾，也是对一些更标准的库的一个探索…</h3></div><div class="qa l"><p class="bd b dl z fp px fr fs py fu fw dk translated">doc.rust-lang.org</p></div></div></div></a></div><h1 id="76ca" class="mc md it bd me mf mz mh mi mj na ml mm jz nb ka mo kc nc kd mq kf nd kg ms mt bi translated">高级概念:一般类型、特征、生存期、闭包和并发性</h1><p id="27b4" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">关于Rust还有很多需要学习的地方，但是如果你一直这么做，你肯定是在正确的轨道上。</p><p id="f242" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个标题中的特性是你接下来应该关注的，但我会从这里重新引导你，因为这只是一篇介绍性的文章，而不是一本成熟的书。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="0fe8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您还不是Medium的成员，但想要无限制地访问像这样的故事，您只需点击下面的:</p><div class="pp pq gp gr pr ps"><a href="https://kaspermuller.medium.com/membership" rel="noopener follow" target="_blank"><div class="pt ab fo"><div class="pu ab pv cl cj pw"><h2 class="bd iu gy z fp px fr fs py fu fw is bi translated">通过我的推荐链接加入Medium-Kasper müller</h2><div class="pz l"><h3 class="bd b gy z fp px fr fs py fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="qa l"><p class="bd b dl z fp px fr fs py fu fw dk translated">kaspermuller.medium.com</p></div></div><div class="qb l"><div class="qc l qd qe qf qb qg ks ps"/></div></div></a></div><p id="6bb1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">进一步阅读的资源:</p><p id="e5f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">锈书:</strong></p><div class="pp pq gp gr pr ps"><a href="https://doc.rust-lang.org/book/" rel="noopener  ugc nofollow" target="_blank"><div class="pt ab fo"><div class="pu ab pv cl cj pw"><h2 class="bd iu gy z fp px fr fs py fu fw is bi translated">Rust编程语言</h2><div class="pz l"><h3 class="bd b gy z fp px fr fs py fu fw dk translated">史蒂夫·克拉布尼克和卡罗尔·尼科尔斯，Rust社区的贡献，这个版本的文本假设你…</h3></div><div class="qa l"><p class="bd b dl z fp px fr fs py fu fw dk translated">doc.rust-lang.org</p></div></div></div></a></div><p id="aa77" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">铁锈举例:</strong></p><div class="pp pq gp gr pr ps"><a href="https://doc.rust-lang.org/rust-by-example/" rel="noopener  ugc nofollow" target="_blank"><div class="pt ab fo"><div class="pu ab pv cl cj pw"><h2 class="bd iu gy z fp px fr fs py fu fw is bi translated">生锈的例子</h2><div class="pz l"><h3 class="bd b gy z fp px fr fs py fu fw dk translated">Rust是一种现代系统编程语言，专注于安全性、速度和并发性。它实现了这些目标…</h3></div><div class="qa l"><p class="bd b dl z fp px fr fs py fu fw dk translated">doc.rust-lang.org</p></div></div></div></a></div><p id="49ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">文档</strong>:</p><div class="pp pq gp gr pr ps"><a href="http://web.mit.edu/rust-lang_v1.25/arch/amd64_ubuntu1404/share/doc/rust/html/book/first-edition/documentation.html" rel="noopener  ugc nofollow" target="_blank"><div class="pt ab fo"><div class="pu ab pv cl cj pw"><h2 class="bd iu gy z fp px fr fs py fu fw is bi translated">Rust编程语言</h2><div class="pz l"><h3 class="bd b gy z fp px fr fs py fu fw dk translated">文档是任何软件项目的重要组成部分，在Rust中是一流的。让我们来谈谈工具…</h3></div><div class="qa l"><p class="bd b dl z fp px fr fs py fu fw dk translated">web.mit.edu</p></div></div></div></a></div><p id="3077" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">让我们生锈吧:</strong></p><div class="pp pq gp gr pr ps"><a href="https://www.youtube.com/channel/UCSp-OaMpsO8K0KkOqyBl7_w" rel="noopener  ugc nofollow" target="_blank"><div class="pt ab fo"><div class="pu ab pv cl cj pw"><h2 class="bd iu gy z fp px fr fs py fu fw is bi translated">让我们生锈吧</h2><div class="pz l"><h3 class="bd b gy z fp px fr fs py fu fw dk translated">这个频道是你学习Rust编程语言的第一资源！我们将讨论基本的Rust语言教程…</h3></div><div class="qa l"><p class="bd b dl z fp px fr fs py fu fw dk translated">www.youtube.com</p></div></div><div class="qb l"><div class="qh l qd qe qf qb qg ks ps"/></div></div></a></div></div></div>    
</body>
</html>