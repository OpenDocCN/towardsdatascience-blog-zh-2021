<html>
<head>
<title>Learning SQL and Ethereum (Part 3)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">学习SQL和以太坊(第3部分)</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/learning-sql-and-ethereum-part-3-5422f080ad36?source=collection_archive---------15-----------------------#2021-06-23">https://towardsdatascience.com/learning-sql-and-ethereum-part-3-5422f080ad36?source=collection_archive---------15-----------------------#2021-06-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="d905" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">实践教程</h2><div class=""/><div class=""><h2 id="fd5b" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">让我们看看Barnbridge(一种信贷份额协议)的合同和对锁定总价值和用户利润的查询。</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/e45b21715b2d3d7dc61f4ee793f3e8e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*crRFFm2BHDgM3W7Mnd02sw.jpeg"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">由<a class="ae lh" href="https://unsplash.com/s/photos/risk?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae lh" href="https://unsplash.com/@loicleray?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Loic Leray </a>拍摄的照片</p></figure><blockquote class="li lj lk"><p id="6c4b" class="ll lm ln lo b lp lq kd lr ls lt kg lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">我将在解释以太坊的基本概念时创建更多的小型查询细目，<strong class="lo jd">这是我写的</strong> <a class="ae lh" rel="noopener" target="_blank" href="/your-guide-to-basic-sql-while-learning-ethereum-at-the-same-time-9eac17a05929"> <strong class="lo jd">初级</strong> </a> <strong class="lo jd">和</strong> <a class="ae lh" rel="noopener" target="_blank" href="/your-guide-to-intermediate-sql-while-learning-ethereum-at-the-same-time-7b25119ef1e2"> <strong class="lo jd">中级</strong> </a> <strong class="lo jd">指南</strong>的延续。</p><p id="4a78" class="ll lm ln lo b lp lq kd lr ls lt kg lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">这篇文章是与我的朋友0x九龙合作写的，请去看看他对barn bridge的可靠性架构的深入研究，以更好地理解该协议的来龙去脉。</p></blockquote><p id="2d47" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated">我们之前已经研究过资产证券化，你必须在一项资产中存入一定数量的抵押品(比如瑞士联邦理工学院)，才能借入另一项资产中75%的抵押品价值(比如USDC)。就像在传统的金融系统中一样，你可以赚取固定或可变的利息，除了在DeFi中，这个利率通常由你存入或借入的资产的“利用率”决定。</p><p id="4ec8" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated">让我们以复合(类似于Aave的协议)为例来看看USDC:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ml"><img src="../Images/1bf6d7e9ed5fbdfcbacd79c06f587774.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N2Q0YBSbwTnsyV2Yt5tddw.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated"><a class="ae lh" href="https://compound.finance/markets/USDC" rel="noopener ugc nofollow" target="_blank">https://compound.finance/markets/USDC</a></p></figure><p id="eb09" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated">重要的图表在左边，黑线表示USDC的当前利用率(借入的USDC总额/存入的USDC总额)，绿线和紫线分别表示支付的可变利率和固定利率。你会注意到有一个点，利率的斜率会突然上升，通常设定在80%左右，这是为了避免资产池被100%利用(借入)。</p><p id="c53c" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated">现在，如果你是存款人，愿意放弃你获得的任何额外回报，以换取总是在某个固定利率上获得全部回报，会怎么样？例如，假设你和另一个投资者都存可变利率USDC。你想每年获得2%的回报。其他投资者已经同意从他们的存款(本金)中支付给你，以弥补差额，如果可变利率在一段时间内低于2%(差额*你的本金*time_under_2%)。作为交换，如果可变利率超过2%，那么你就支付他们额外的收益(差额*你的本金*时间_高于_2%)。这就是巴恩布里奇和他们的SmartYield产品的基本运作方式，有数百名投资者在安全(2%有保证)和高风险(2%以上/以下)部分之间进行选择。</p><p id="e05d" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated">然而，如果巴恩布里奇推出自己的存款和借款资产池，那么他们将不得不从头开始增加市场的流动性。自举流动性可能会很困难，并导致利用率大幅波动，进而导致利率波动。这就是金钱概念的重要性所在——本质上，BarnBridge可以构建一种产品，在这种产品中，你从其资产池中借入或存入的资产将直接存入Compound或Aave。通过这种方式，巴恩布里奇可以处理智能合约中的双重份额逻辑，同时利用复合或Aave市场的稳定性。如果你想更多地了解这个金钱乐高结构，我推荐阅读<a class="ae lh" href="https://medium.com/coinmonks/crypto-and-web-3-0-are-the-future-of-product-and-work-3d19e3733181" rel="noopener">我的Web3产品讲解者</a>。</p><p id="6f7b" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated">现在我们可以进入数据分析了。这就是我们想要的:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi mm"><img src="../Images/3ac3716387554f3ecea7e8509beb963b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M5Lkw0UbHz_arZDaU7qztQ.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">【https://duneanalytics.com/ilemi/Barnbridge-PnL T4】</p></figure><p id="19a8" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated">为此，我们需要知道用户在智能合约上进行的主要事务(函数调用和发出的事件)。请记住，SQL表是基于每个智能合约的<strong class="lo jd">交易数据。用户可以进入或离开风险较高的部分(次级代币/债券)，也可以进入或离开较安全的部分(高级债券)，因此我们有四个主要操作。在“离开风险部分”的过程中有一点需要注意的地方，但是我们稍后会解决这个问题。</strong></p><p id="33dd" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated">让我们从将<strong class="lo jd">“锁定的总价值”</strong>(指存入的总资产)放入协议<strong class="lo jd">开始。这意味着我们需要加上总存款，减去初级和高级部分的总提款。</strong></p><p id="596a" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated">将USDC存入初级部分与存入Aave不同，因为初级部分的回报取决于他们从高级部分欠下(或获得)多少。这意味着，如果你在发行后加入这一部分，它不会是基础资产(USDC)和你作为回报获得的代币(bb_USDC)的1:1存款。同样，当你出售时，价格也不是1:1。</p><p id="8c95" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated">我们用以下公式计算比率:</p><pre class="ks kt ku kv gt mn mo mp mq aw mr bi"><span id="6b78" class="ms mt it mo b gy mu mv l mw mx">SELECT  date_trunc('day', evt_block_time) as day,<br/>                contract_address,<br/>                "underlyingIn"-fee, <br/>                "tokensOut",<br/>                ("underlyingIn"-fee)/"tokensOut" as ratios<br/>        FROM barnbridge."smartYield_evt_BuyTokens" <br/>        <br/>UNION ALL<br/>        <br/>SELECT  date_trunc('day', evt_block_time) as day,<br/>                contract_address,<br/>                "underlyingOut", <br/>                "tokensIn",<br/>                "underlyingOut"/"tokensIn" as ratios<br/>        FROM barnbridge."smartYield_evt_SellTokens"<br/>        where "tokensIn" != 0</span></pre><p id="1fbc" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated">我们正在查询Barnbridge初级阶段的表中的<code class="fe my mz na mo b">BuyTokens</code>和<code class="fe my mz na mo b">SellTokens</code>事件。因为该部分中有许多类型的令牌(如、戴、)，所以我们需要保留<code class="fe my mz na mo b">contract_address</code>列，以便稍后进行过滤。<code class="fe my mz na mo b">tokensOut</code>代表为用户制造的令牌，而<code class="fe my mz na mo b">underlyingIn</code>是存放在协议中的资产。<code class="fe my mz na mo b">underlying/tokens</code>的比值给了我们两者之间的汇率。我们将在用<code class="fe my mz na mo b">total barnbridge tokens in pool * ratio</code>锁定的总价值中使用这一比率计算，以回到总基础资产的价值。</p><p id="fa6d" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated"><code class="fe my mz na mo b">day</code>将只返回交易发生的日期，因此在没有人从BarnBridge存款或取款的日子可能会有间隔。这将导致非常不连贯或扭曲的时间序列图，因此我们将使用<code class="fe my mz na mo b">generate_series</code>表填充所有缺失的日期。</p><pre class="ks kt ku kv gt mn mo mp mq aw mr bi"><span id="5112" class="ms mt it mo b gy mu mv l mw mx">SELECT generate_series('2021-03-14'::timestamp, date_trunc('day', NOW()), '1 day') AS day </span></pre><p id="f363" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated">接下来，我们将计算第二天(在数据的最后一天之后)作为系列的终点:</p><pre class="ks kt ku kv gt mn mo mp mq aw mr bi"><span id="a97f" class="ms mt it mo b gy mu mv l mw mx">SELECT  ratios,<br/>                contract_address,<br/>                day,<br/>                lead(day, 1, now()) OVER (ORDER BY day) AS next_day <br/>        FROM ratioavg</span></pre><p id="c446" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated">这看起来有点复杂，但本质上是创建一个常量值列<code class="fe my mz na mo b">next_day</code>作为时间序列中的最后一天。</p><p id="e2de" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated">我们可以用一个连接把它们放在一起:</p><pre class="ks kt ku kv gt mn mo mp mq aw mr bi"><span id="c4ac" class="ms mt it mo b gy mu mv l mw mx">SELECT  ratios, <br/>                d.day,<br/>                a.contract_address,<br/>                symbol<br/>        FROM days d<br/>        left join ratio_with_lead_day a on a.day &lt;= d.day AND d.day &lt; a.next_day<br/>        left join dune_user_generated.smartyield_token_mapping u on u.contract_address= a.contract_address</span></pre><p id="13a2" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated">这样就完成了在没有事务的日子里包含行的时间序列(在时间序列图中显示为0 ),并在<code class="fe my mz na mo b">next_day</code>结束。我们还加入了一个表，该表将<code class="fe my mz na mo b">contract_address</code>映射到底层资产的令牌符号，以便以后阅读和过滤。</p><p id="57a0" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated">所有这些返回下表</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nb"><img src="../Images/465128deb2fd54c0ca079c932f3dd4d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7RoUK5On_r2WL6AK__A5yA.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">完整查询此处<a class="ae lh" href="https://duneanalytics.com/queries/67210" rel="noopener ugc nofollow" target="_blank">https://duneanalytics.com/queries/67210</a></p></figure><p id="aaf8" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated">既然这个问题已经解决了，我们可以看看初级份额代币的存款和取款总额。这从两个查询开始:</p><pre class="ks kt ku kv gt mn mo mp mq aw mr bi"><span id="1e5d" class="ms mt it mo b gy mu mv l mw mx">SELECT  buyer,<br/>        evt_tx_hash,<br/>        contract_address,<br/>        "tokensOut" as deposit,<br/>        date_trunc('day', evt_block_time) as day<br/>        <br/>FROM barnbridge."smartYield_evt_BuyTokens"</span></pre><p id="1d54" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated">和</p><pre class="ks kt ku kv gt mn mo mp mq aw mr bi"><span id="4e2d" class="ms mt it mo b gy mu mv l mw mx">SELECT  seller as buyer,<br/>        evt_tx_hash,<br/>        contract_address,<br/>        -"tokensIn" as deposit,<br/>        date_trunc('day', evt_block_time) as day<br/>        <br/>FROM barnbridge."smartYield_evt_SellTokens"</span></pre><p id="2f0b" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated">我认为这两个不需要太多的解释，因为列是不言自明的，我们在这里做了同样的日期填充，但是使用了contract_address分区。</p><pre class="ks kt ku kv gt mn mo mp mq aw mr bi"><span id="7278" class="ms mt it mo b gy mu mv l mw mx">SELECT<br/>        buyer,<br/>        contract_address,<br/>        deposit, <br/>        day,<br/>        lead(day, 1, now()) OVER (partition by evt_tx_hash, contract_address ORDER BY day) AS next_day <br/>FROM redeemjbonds</span></pre><p id="102a" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated">我们用这个看起来有些混乱的查询将所有这些放在一起:</p><pre class="ks kt ku kv gt mn mo mp mq aw mr bi"><span id="de5c" class="ms mt it mo b gy mu mv l mw mx">SELECT<br/>sum(((d.deposit + coalesce(r.deposit,0))/10^u.u_decimals)*ratios) as deposits,<br/>sum(coalesce(r.deposit,0)/10^u.u_decimals*ratios) as withdrawls</span><span id="eac7" class="ms mt it mo b gy nc mv l mw mx">FROM<br/>depositfinal d</span><span id="3af9" class="ms mt it mo b gy nc mv l mw mx">LEFT JOIN redeemfinal r  on d.day = r.day and d.buyer = r.buyer and r.contract_address = d.contract_address </span><span id="5d19" class="ms mt it mo b gy nc mv l mw mx">LEFT JOIN ratioq q on d.day = q.day and q.contract_address = d.contract_address</span><span id="ce52" class="ms mt it mo b gy nc mv l mw mx">LEFT JOIN dune_user_generated.smartyield_token_mapping u on u.contract_address= q.contract_address</span><span id="d812" class="ms mt it mo b gy nc mv l mw mx">WHERE((d.deposit + coalesce(r.deposit,0))*ratios)/10^u.u_decimals &gt; 0<br/>AND u."symbol"='cUSDC'</span></pre><p id="bc13" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated">我们将每个用户的总存款(<code class="fe my mz na mo b">depositfinal</code>)和总取款(<code class="fe my mz na mo b">redeemfinal</code>)以及资产(<code class="fe my mz na mo b">contract_address</code>)连接起来。我们在这个连接中也保持日期一致。接下来，我们加入从第一次查询到日期的<code class="fe my mz na mo b">ratioq</code>(记住，随着利息和高级部分付款/奖励的增加，比率每天都在变化)。最后，我们将<code class="fe my mz na mo b">contract_address </code>上的映射加入到资产符号中，并只过滤复合USDC存款(<code class="fe my mz na mo b">cUSDC</code>)。至于我们选择的内容，我们用存款总额减去取款总额(<code class="fe my mz na mo b">COALESCE</code>在这里用于涵盖用户没有提取任何东西并且值为null的情况，我们希望用0来代替——把它想象成一个<code class="fe my mz na mo b">if null then value (0) </code>函数)。然后我们将总和除以资产的小数(由于你在solidity中没有小数，我们必须在前端进行转换)。最后，我们用比率乘以这个存款，因为这个存款用BarnBridge代币表示，我们需要它来显示USDC值。如果这不是使用像USDC这样的稳定货币资产，那么我们将使用另一个连接(在连接<code class="fe my mz na mo b">symbol</code>和<code class="fe my mz na mo b">date</code>时添加价格列)将它乘以每个日期的价格。</p><p id="4946" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated">这为我们提供了下表:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nd"><img src="../Images/eb37aee45acc4627385938ebeb94cdbf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eBVip50cKd9AYBbUmY9sbw.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated"><a class="ae lh" href="https://duneanalytics.com/queries/67226" rel="noopener ugc nofollow" target="_blank">https://duneanalytics.com/queries/67226</a></p></figure><p id="821f" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated">我们将对select查询稍加修改，以添加高级令牌，但过程几乎完全相同(只是没有比率)。</p><p id="0b53" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated">完整的TVL查询可以在<a class="ae lh" href="https://duneanalytics.com/queries/67051/134549" rel="noopener ugc nofollow" target="_blank">这里</a>找到，并给出了如下图表:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ne"><img src="../Images/b6566488a05100434321e4175fdc0f85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eIBlnTZWo5vgYSt2XVyMaQ.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated"><a class="ae lh" href="https://duneanalytics.com/queries/67051/134549" rel="noopener ugc nofollow" target="_blank">https://duneanalytics.com/queries/67051/134549</a></p></figure><p id="fae3" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated">现在我们唯一需要计算的是每个用户和日期的利润和损失。我们想要检查已经进入和完全退出池的用户获得或丧失了多少利息(即<code class="fe my mz na mo b">deposit-withdrawals=0</code>)。我之前提到的额外警告是，当有人退出初级部分时，他们需要补偿高级部分的任何利息损失。在典型的<a class="ae lh" href="https://www.investopedia.com/terms/a/asset-backedsecurity.asp" rel="noopener ugc nofollow" target="_blank">证券化式结构</a>中，份额被锁定发行，任何人都不能随心所欲地退出或进入(至少不能以改变主要发行的方式)。在BarnBridge案中，提前提款的补偿有两种形式:要么是没收，要么是考虑到所欠利息的加权平均到期日的次级债券。</p><p id="30f1" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated">计算方法如下:</p><pre class="ks kt ku kv gt mn mo mp mq aw mr bi"><span id="a0af" class="ms mt it mo b gy mu mv l mw mx">SELECT date_trunc('day',buy."evt_block_time") as date, buy."buyer", buy."tokensIn", redeem."underlyingOut", buy."maturesAt", true as did_redeem<br/>        FROM barnbridge."smartYield_evt_BuyJuniorBond" buy<br/>        INNER JOIN barnbridge."smartYield_evt_RedeemJuniorBond" redeem ON buy."juniorBondId" = redeem."juniorBondId" AND buy."buyer" = redeem."owner"<br/>        INNER JOIN dune_user_generated."smartyield_token_mapping" map ON buy."contract_address"=map."contract_address"<br/>        WHERE map."u_symbol"='USDC'</span></pre><p id="55fd" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated">这里我只考虑那些既购买了债券(<code class="fe my mz na mo b">BuyJuniorBond</code>)又赎回了债券(<code class="fe my mz na mo b">RedeemJuniorBond</code>)的买家。连接在买方地址和次级债券ID上(以防他们有多个不同到期日和金额的债券)。我创建了一列作为<code class="fe my mz na mo b">did_redeem</code>的<code class="fe my mz na mo b">true</code>值，用于以后的健全性检查。</p><p id="3d78" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated">然后，我们将这些赎回与初级部分存款和取款查询结合起来(表<code class="fe my mz na mo b">jtokens_t</code>是我们原始查询的修改版本):</p><pre class="ks kt ku kv gt mn mo mp mq aw mr bi"><span id="56ce" class="ms mt it mo b gy mu mv l mw mx">SELECT "date","buyer","underlyingOut","underlyingIn","tokensOut","tokensIn", false as "did_redeem"<br/>        FROM jtokens_t<br/>        UNION <br/>        SELECT "date","buyer","underlyingOut", 0 as "underlyingIn", 0 as "tokensOut","tokensIn", "did_redeem"<br/>        FROM  SELECT "date","buyer","underlyingOut","underlyingIn","tokensOut","tokensIn", false as "did_redeem"<br/>        FROM jtokens_t<br/>        UNION <br/>        SELECT "date","buyer","underlyingOut", 0 as "underlyingIn", 0 as "tokensOut","tokensIn", "did_redeem"<br/>        FROM junior_bond_redemptions</span></pre><p id="74b0" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated">请注意，<code class="fe my mz na mo b">junior_bond_redemptions</code>没有<code class="fe my mz na mo b">underlyingIn</code>或<code class="fe my mz na mo b">tokensOut</code>列，所以我用常量值<code class="fe my mz na mo b">0</code>创建了它们，以便UNION函数按预期工作。</p><p id="c952" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated">最后，我们将选择查询放在一起:</p><pre class="ks kt ku kv gt mn mo mp mq aw mr bi"><span id="165e" class="ms mt it mo b gy mu mv l mw mx">SELECT union_by_date."buyer", sum("underlyingOut" - "underlyingIn")/1e6 as net_profit_loss<br/>FROM union_by_date<br/>INNER JOIN<br/>    (SELECT "buyer" <br/>    FROM buyer_pivot<br/>    WHERE "out" - "in" = 0) as exit_buyers<br/>ON union_by_date."buyer" = exit_buyers."buyer" <br/>GROUP BY 1<br/>ORDER BY 2 DESC</span></pre><p id="8b3e" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated">这里，我用<code class="fe my mz na mo b">sum(“underlyingOut” — “underlyingIn”)/1e6</code>来表示已经完全退出的买家子集的PnL。我通过子查询<code class="fe my mz na mo b">exit_buyers</code>上的内部连接来实现这一点，然后除以USDC的六位小数。最后是一个<code class="fe my mz na mo b">GROUP BY</code>，因为我使用了一个聚合函数和一个<code class="fe my mz na mo b">ORDER BY</code>来使图表更漂亮。</p><p id="55ac" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated">这给了我们这个:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nf"><img src="../Images/1a677277766fa168891cb0f4cd469835.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E4MYOjoQa2lkT5J87o7SwA.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated"><a class="ae lh" href="https://duneanalytics.com/queries/66812" rel="noopener ugc nofollow" target="_blank">https://duneanalytics.com/queries/66812</a></p></figure><p id="9d19" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated">它显然有点倾斜(有人肯定是条鲸鱼)，这就是为什么我也在仪表板中包含了表格视图。对于PnL的日期版本，我对最终的选择查询做了一点调整，但在其他方面没有变化。总的来说，它看起来相当均匀，损失可能是由一般的加密市场压力造成的。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ng"><img src="../Images/c0b357849c4de358b3de392b61f30420.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Susu5-uf_HmRnRNFOzHCWw.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated"><a class="ae lh" href="https://duneanalytics.com/queries/65891" rel="noopener ugc nofollow" target="_blank">https://duneanalytics.com/queries/65891</a></p></figure><p id="202d" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated">如果您对仪表板本身感到好奇，它只是查询的拖放，所以没有什么复杂的解释。Dune使这一部分变得非常简单，不需要在Python Plotly Dash或Bokeh中摆弄来获得正确的可视化效果，也不需要担心部署。</p><p id="eb3d" class="pw-post-body-paragraph ll lm it lo b lp lq kd lr ls lt kg lu mi lw lx ly mj ma mb mc mk me mf mg mh im bi translated">这个简短的讲解到此结束，希望你学到了一些以太坊和/或SQL的知识！</p></div></div>    
</body>
</html>