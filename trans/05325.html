<html>
<head>
<title>400x times faster Pandas Data Frame Iteration</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Pandas数据帧迭代速度快400倍</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/400x-time-faster-pandas-data-frame-iteration-16fb47871a0a?source=collection_archive---------4-----------------------#2021-05-11">https://towardsdatascience.com/400x-time-faster-pandas-data-frame-iteration-16fb47871a0a?source=collection_archive---------4-----------------------#2021-05-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a599" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">避免使用iterrows()函数</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e40471b726dfff97379a99396fb0a367.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YuyJvayQyKgTk5woZJW23g.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来自<a class="ae ky" href="https://pixabay.com/?utm_source=link-attribution&amp;amp;utm_medium=referral&amp;amp;utm_campaign=image&amp;amp;utm_content=259375" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>的<a class="ae ky" href="https://pixabay.com/users/jarmoluk-143740/?utm_source=link-attribution&amp;amp;utm_medium=referral&amp;amp;utm_campaign=image&amp;amp;utm_content=259375" rel="noopener ugc nofollow" target="_blank">米哈尔·贾莫鲁克</a></p></figure><p id="2d2f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">数据处理是数据科学模型开发流程的重要组成部分。数据科学家花费80%的时间准备数据集，使其适合建模。有时，对大规模数据集进行数据争论和探索成为一项乏味的任务，人们只能等待相当长的时间直到计算完成，或者转移到一些并行处理。</p><p id="6305" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Pandas是著名的Python库之一，它有大量的API，但是当谈到可伸缩性时，它失败得很惨。对于大型数据集，仅迭代循环就要花费大量时间，有时甚至数小时，即使对于小型数据集，使用标准循环迭代数据帧也非常耗时，</p><p id="3ca4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将讨论在大型数据集上加速迭代过程的技术或技巧。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lv"><img src="../Images/bbfc9b194a3e7fa04070236cff1f58d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r1vnfNuPzrhaNZYg-z2nlw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)，时间约束比较以迭代数据框</p></figure><h1 id="493f" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">Pandas内置函数:iterrows()</h1><p id="36a3" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">iterrows()是一个内置的Pandas库函数，它返回一系列的每个实例或行。它以一对索引和一系列列要素的形式遍历数据框。</p><p id="5f13" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了比较基准时间约束，我使用了一个包含1000万条记录和5列的数据集。我们的数据集中有一个字符串类型的特征<code class="fe mt mu mv mw b">‘name’</code>,需要去除其中的空格。</p><pre class="kj kk kl km gt mx mw my mz aw na bi"><span id="0026" class="nb lx it mw b gy nc nd l ne nf"><strong class="mw iu">temp=[]<br/>for i,row in df.iterrows():<br/>name_new = row['name'].strip()<br/>temp.append(name_new)</strong></span></pre><p id="f767" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">代码片段花了将近1967秒来执行，包括悬停在数据框上并执行“name”值的剥离函数。</p><p id="5731" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不建议使用iterrows，这不仅是因为时间性能问题，而且<code class="fe mt mu mv mw b"><strong class="lb iu">iterrows()</strong></code>函数不能跨行保留数据类型。你可以使用<code class="fe mt mu mv mw b"><strong class="lb iu">itertuples()</strong></code>函数来保存类型。</p><p id="f741" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们找出迭代数据帧的其他技术，并比较其时间复杂度。</p><h1 id="dad7" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">按索引迭代:</h1><p id="58f8" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">数据帧是有行和列的熊猫对象。数据框的行和列被索引，并且可以循环遍历索引以遍历行。</p><pre class="kj kk kl km gt mx mw my mz aw na bi"><span id="6348" class="nb lx it mw b gy nc nd l ne nf"><strong class="mw iu">temp=[]<br/>for idx in range(0,df.shape[0],1):<br/>name_new = df['name'].iloc[idx].strip()<br/>temp.append(name_new)</strong></span></pre><p id="7850" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">迭代数据帧并执行剥离操作花费了将近223秒(比iterrows函数快9倍)。</p><h1 id="0cd2" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">使用to_dict():</h1><p id="9461" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">您可以迭代数据框并以闪电般的速度执行操作，只需将您的Pandas数据框转换为字典即可。可以使用Pandas中的<code class="fe mt mu mv mw b"><strong class="lb iu">.to_dict()</strong></code>函数将数据框转换成字典。与<code class="fe mt mu mv mw b"><strong class="lb iu">iterrows()</strong></code>函数相比，现在迭代一个字典相对来说非常快。</p><pre class="kj kk kl km gt mx mw my mz aw na bi"><span id="2b21" class="nb lx it mw b gy nc nd l ne nf"><strong class="mw iu">df_dict = df.to_dict('records')</strong></span><span id="28fe" class="nb lx it mw b gy ng nd l ne nf"><strong class="mw iu">temp=[]<br/>for row in df_dict:<br/>name_new = row['name'].strip()<br/>temp.append(name_new)</strong></span></pre><p id="f105" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">迭代一个字典格式的数据集需要大约25条记录，比<code class="fe mt mu mv mw b"><strong class="lb iu">iterrows()</strong></code>函数快77倍。</p><h1 id="2824" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">使用apply():</h1><p id="f787" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">apply()是一个内置的Pandas函数，它允许传递一个函数并将其应用于Pandas系列的每个值。apply()函数本身并不快，但是它对Pandas库有很大的改进，因为这个函数有助于根据需要的条件分离数据。</p><pre class="kj kk kl km gt mx mw my mz aw na bi"><span id="40a9" class="nb lx it mw b gy nc nd l ne nf"><strong class="mw iu">temp = df['name'].apply(lambda x: x.strip())</strong></span></pre><p id="736a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mt mu mv mw b"><strong class="lb iu">apply()</strong></code>该函数执行时间为4.60秒，比<code class="fe mt mu mv mw b"><strong class="lb iu">iterrows()</strong></code>函数快427倍。</p><blockquote class="nh ni nj"><p id="787d" class="kz la nk lb b lc ld ju le lf lg jx lh nl lj lk ll nm ln lo lp nn lr ls lt lu im bi translated">从上面的图(本文开始)中，您可以比较在具有8个内核和32GB RAM的系统上计算的基准时间数。</p></blockquote><h1 id="cccc" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">结论:</h1><p id="c6a0" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">在本文中，我们讨论了几种迭代熊猫数据帧的技术，并比较了它们的时间复杂度。建议在非常特殊的情况下使用<code class="fe mt mu mv mw b"><strong class="lb iu">iterrows()</strong></code>功能。人们可以很容易地从使用<code class="fe mt mu mv mw b"><strong class="lb iu">iterrows()</strong></code>或索引方法转移到基于字典的迭代技术，这将工作流的速度提高了77倍。</p><p id="16cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Apply函数的速度快了大约400倍，但它的用途有限，并且需要对代码进行大量修改才能转换到这种方法。我亲自将我的数据框转换成字典，然后继续迭代。</p><h1 id="2533" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">参考资料:</h1><p id="b554" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">[1]熊猫文献:<a class="ae ky" href="https://pandas.pydata.org/docs/index.html" rel="noopener ugc nofollow" target="_blank">https://pandas.pydata.org/docs/index.html</a></p></div><div class="ab cl no np hx nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="im in io ip iq"><p id="e1a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nk">喜欢这篇文章吗？成为</em> <a class="ae ky" href="https://satyam-kumar.medium.com/membership" rel="noopener"> <em class="nk">中等会员</em> </a> <em class="nk">继续无限制学习。如果你使用下面的链接，我会收到你的一小部分会员费，不需要你额外付费。</em></p><div class="nv nw gp gr nx ny"><a href="https://satyam-kumar.medium.com/membership" rel="noopener follow" target="_blank"><div class="nz ab fo"><div class="oa ab ob cl cj oc"><h2 class="bd iu gy z fp od fr fs oe fu fw is bi translated">加入我的推荐链接-萨蒂扬库马尔媒体</h2><div class="of l"><h3 class="bd b gy z fp od fr fs oe fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="og l"><p class="bd b dl z fp od fr fs oe fu fw dk translated">satyam-kumar.medium.com</p></div></div><div class="oh l"><div class="oi l oj ok ol oh om ks ny"/></div></div></a></div><blockquote class="on"><p id="d330" class="oo op it bd oq or os ot ou ov ow lu dk translated">感谢您的阅读</p></blockquote></div></div>    
</body>
</html>