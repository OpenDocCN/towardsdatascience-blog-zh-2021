<html>
<head>
<title>Using Bayesian Hierarchical Models in PyMC3 to Infer the Disease Parameters of COVID-19</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">利用PyMC3中的贝叶斯分层模型推断新冠肺炎的疾病参数</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/using-bayesian-hierarchical-models-in-pymc3-to-infer-the-disease-parameters-of-covid-19-b396c8b9845?source=collection_archive---------22-----------------------#2021-10-05">https://towardsdatascience.com/using-bayesian-hierarchical-models-in-pymc3-to-infer-the-disease-parameters-of-covid-19-b396c8b9845?source=collection_archive---------22-----------------------#2021-10-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="9b12" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本帖中，我们来看看如何使用PyMC3来推断新冠肺炎的疾病参数。PyMC3是一个流行的概率编程框架，用于贝叶斯建模。实现这一点的两种流行方法是马尔可夫链蒙特卡罗(<a class="ae kl" href="https://reference.wolfram.com/language/howto/PerformAMonteCarloSimulation.html" rel="noopener ugc nofollow" target="_blank"> MCMC </a>)和<a class="ae kl" href="https://reference.wolfram.com/language/VariationalMethods/tutorial/VariationalMethods.html" rel="noopener ugc nofollow" target="_blank">变分推断</a>方法。这里的工作着眼于使用美国感染病例的当前可用数据作为时间序列，并试图使用分室概率模型对此建模。我们想尝试推断疾病参数，并最终使用MCMC采样估计<em class="km"> R0 </em>。然后，我们将探索如何使用贝叶斯分层模型来做同样的事情，以及与池化或非池化模型相比的好处。我们总结了这个模型的局限性，并概述了改进推理过程的步骤。</p><p id="0214" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里介绍的工作仅用于说明目的，现实生活中的贝叶斯建模需要比这里显示的复杂得多的工具。这里作出了关于种群动态的各种假设，这些假设可能不适用于大型非同质种群。此外，这里不考虑社会距离和疫苗接种等干预措施。</p><p id="bb6f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">本帖将涵盖以下内容:</p><ol class=""><li id="107a" class="kn ko iq jp b jq jr ju jv jy kp kc kq kg kr kk ks kt ku kv bi translated">流行病的分室模型</li><li id="20a0" class="kn ko iq jp b jq kw ju kx jy ky kc kz kg la kk ks kt ku kv bi translated">数据从何而来，如何获取</li><li id="172f" class="kn ko iq jp b jq kw ju kx jy ky kc kz kg la kk ks kt ku kv bi translated">疾病动力学SIR/SIRS模型</li><li id="d358" class="kn ko iq jp b jq kw ju kx jy ky kc kz kg la kk ks kt ku kv bi translated">PyMC3常微分方程的贝叶斯推理</li><li id="8164" class="kn ko iq jp b jq kw ju kx jy ky kc kz kg la kk ks kt ku kv bi translated">使用层次模型扩展工作</li><li id="42c1" class="kn ko iq jp b jq kw ju kx jy ky kc kz kg la kk ks kt ku kv bi translated">概率编程的指南和调试技巧</li></ol><p id="bcf2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我还在Coursera上推出了一系列课程，涵盖贝叶斯建模和推理的主题，课程2和3与本文特别相关。请到<a class="ae kl" href="https://www.coursera.org/specializations/compstats" rel="noopener ugc nofollow" target="_blank">https://www.coursera.org/specializations/compstats</a>查看。</p><h1 id="6b9e" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">流行病的分室模型</h1><p id="3438" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">关于房室模型及其行为的概述，请参考朱莉亚<a class="ae kl" href="https://github.com/sjster/Epidemic." rel="noopener ugc nofollow" target="_blank">—https://github.com/sjster/Epidemic.</a>的笔记</p><p id="9182" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">房室模型是封闭种群的一组常微分方程(ODEs ),这意味着种群没有进出该房室的运动。这些旨在模拟同质人群中的疾病传播。可以想象，这些假设在大人群中可能不成立。这里还必须指出的是，人口出生和死亡人数等生命统计数据可能不包括在这个模型中。下面的列表提到了一些分室模型以及疾病传播的各个分室，然而，这决不是一个详尽的列表。</p><ul class=""><li id="eaed" class="kn ko iq jp b jq jr ju jv jy kp kc kq kg kr kk me kt ku kv bi translated">易感感染(SI)</li><li id="e5e4" class="kn ko iq jp b jq kw ju kx jy ky kc kz kg la kk me kt ku kv bi translated">易感感染者康复(SIR)</li><li id="0661" class="kn ko iq jp b jq kw ju kx jy ky kc kz kg la kk me kt ku kv bi translated">易受感染的</li><li id="f899" class="kn ko iq jp b jq kw ju kx jy ky kc kz kg la kk me kt ku kv bi translated">易感感染恢复易感(SIRS)</li><li id="d644" class="kn ko iq jp b jq kw ju kx jy ky kc kz kg la kk me kt ku kv bi translated">易感感染者康复死亡(SIRD)</li><li id="6f3d" class="kn ko iq jp b jq kw ju kx jy ky kc kz kg la kk me kt ku kv bi translated">易感暴露感染康复(SEIR)</li><li id="a042" class="kn ko iq jp b jq kw ju kx jy ky kc kz kg la kk me kt ku kv bi translated">易感暴露感染恢复易感(SEIRS)</li><li id="a9af" class="kn ko iq jp b jq kw ju kx jy ky kc kz kg la kk me kt ku kv bi translated">易感暴露感染康复死亡</li><li id="12ff" class="kn ko iq jp b jq kw ju kx jy ky kc kz kg la kk me kt ku kv bi translated">母源性免疫易感传染病痊愈(MSIR)</li><li id="d1c6" class="kn ko iq jp b jq kw ju kx jy ky kc kz kg la kk me kt ku kv bi translated">西达尔特(<a class="ae kl" href="https://www.nature.com/articles/s41591-020-0883-7" rel="noopener ugc nofollow" target="_blank">https://www.nature.com/articles/s41591-020-0883-7</a>)</li></ul><p id="29d0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上面列出的最后一个是最近的，专门针对新冠肺炎的，可能值得感兴趣的人读一读。现实世界的疾病建模通常不仅仅涉及疾病阶段的时间演变，因为许多与分室相关的假设都被违反了。为了了解疾病是如何传播的，我们需要观察疾病在人群中的空间离散化和演变。GLEAM是模拟这种时空演变的框架的一个例子(图1)。</p><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi mf"><img src="../Images/a88cd6c178206e00aa2d79eea8d05b60.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*8U6Vii30df4rxsum"/></div></div></figure><p id="655d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">图1-真实世界流行病建模(时空动态)。</p><p id="74e9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">GLEAM等工具使用人口普查数据和流动模式来了解人们如何在地理上流动。GLEAM将地球划分为大约25公里x25公里的空间网格。大致有两种类型的移动:全球或远程移动和本地或短程移动。长期流动性主要涉及航空旅行，因此机场被认为是疾病传播的中心。海上旅行也是另一个重要因素，因此军港是另一种进入点。与上面列出的数学模型一起，这提供了一个随机框架，可用于进行数百万次模拟，以推断参数并进行预测。</p><h1 id="a4b0" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">新冠肺炎数据</h1><p id="f6dc" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">此处使用的数据来自约翰·霍普金斯CSSE Github页面，该页面中的病例数会定期更新:</p><p id="9303" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kl" href="https://github.com/CSSEGISandData/COVID-19/tree/master/csse_covid_19_data/csse_covid_19_time_series" rel="noopener ugc nofollow" target="_blank"> CSSE GitHub </a></p><p id="df01" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kl" href="https://raw.githubusercontent.com/CSSEGISandData/COVID-19/master/csse_covid_19_data/csse_covid_19_time_series/time_series_covid19_confirmed_global.csv" rel="noopener ugc nofollow" target="_blank">确诊病例</a></p><p id="74cd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kl" href="https://raw.githubusercontent.com/CSSEGISandData/COVID-19/master/csse_covid_19_data/csse_covid_19_time_series/time_series_covid19_deaths_global.csv" rel="noopener ugc nofollow" target="_blank">死亡人数</a></p><p id="1cde" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这些数据以CSV文件的形式提供，可以通过Python pandas读取。</p><h1 id="2837" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">SIR和SIRS模型</h1><h2 id="f33b" class="mr lc iq bd ld ms mt dn lh mu mv dp ll jy mw mx lp kc my mz lt kg na nb lx nc bi translated">SIR模型</h2><p id="2a0a" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">SIR模型由下面所示的三个常微分方程组(ODEs)给出。这个模型有三个部分。</p><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/2594603d0144efebbd9f3428793cc971.png" data-original-src="https://miro.medium.com/v2/resize:fit:316/0*vmg_ECDYu_7veTb1"/></div></figure><p id="a2aa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里的‘S’、‘I’和‘R’指大小为‘N’的人群中的易感、感染和康复部分，因此</p><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/104f12b9741289d646e5c2816e99e956.png" data-original-src="https://miro.medium.com/v2/resize:fit:310/0*-DveUVqJ2wP-saCW"/></div></figure><p id="692a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里的假设是，一旦你从疾病中康复，个人将获得终身免疫。许多疾病的情况并非如此，因此可能不是一个有效的模型。</p><p id="6206" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">λ是感染率，μ是从疾病中康复的速度。从感染中康复的人的比例由“f”给出，但是为了这项工作的目的，“f”在这里被设置为1。我们以我们的常微分方程组的初值问题(IVP)结束，其中I(0)被假设为从疫情开始的情况计数中已知，并且S(0)可以被估计为N-I(0)。这里我们假设整个人口都是易感的。我们的目标是实现以下目标:</p><ul class=""><li id="ac95" class="kn ko iq jp b jq jr ju jv jy kp kc kq kg kr kk me kt ku kv bi translated">使用贝叶斯推理对λ和μ进行估计</li><li id="aac0" class="kn ko iq jp b jq kw ju kx jy ky kc kz kg la kk me kt ku kv bi translated">使用上述参数估算任何时间“t”的I(t)</li><li id="4854" class="kn ko iq jp b jq kw ju kx jy ky kc kz kg la kk me kt ku kv bi translated">计算<em class="km"> R0 </em></li></ul><p id="edc0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如已经指出的，λ是疾病传播系数。这取决于在单位时间内与有传染性的人互动的次数。这又取决于人群中的感染人数。</p><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/6207ea91012fd0e700de4e8e8d415a24.png" data-original-src="https://miro.medium.com/v2/resize:fit:998/0*ytffiSqBMYYGO_Vf"/></div></figure><p id="0e79" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在任何时间‘t’的感染力或风险被定义为:</p><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/5d33f77571e813a7c3a05ec036e9f9e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:74/0*q_oMfYrqwXDlX8nw"/></div></figure><p id="b0fd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">另外，μ是单位时间内发生的恢复的分数。因此，μ的倒数就是平均恢复时间。“基本再生数”<em class="km"> R0 </em>是由单个主要案例产生的次要案例的平均数(例如<a class="ae kl" href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC6002118/" rel="noopener ugc nofollow" target="_blank">https://www.ncbi.nlm.nih.gov/pmc/articles/PMC6002118/</a>)。<em class="km"> R0 </em>也被定义为λ和μ的比值，由下式给出</p><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/a32717ba71b987cd18c08c846abbb4dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:150/0*NGbje-UfrCWId-sO"/></div></figure><p id="3d8d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以上假设<em class="km"> S0 </em>接近1。当<em class="km"> R0 &gt; 1 </em>时，我们有了疾病的扩散，我们有了疫情。随着最近对脆弱人群进行疫苗接种的努力，这一点变得更加需要理解。如果我们给人口中的一小部分“p”接种疫苗以获得<em class="km">(1p)R0&lt;1</em>，我们就能阻止疾病的传播。</p><h2 id="001b" class="mr lc iq bd ld ms mt dn lh mu mv dp ll jy mw mx lp kc my mz lt kg na nb lx nc bi translated">SIRS模型</h2><p id="72c8" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">如下图所示，SIRS模型并没有假设感染者一旦康复后会终身免疫。因此，从恢复区室到易感区室。因此，对于新冠肺炎来说，这可能是一个更好的低保真度基线模型，因为它表明获得性免疫是短期的。这里唯一的附加参数是γ，它指的是免疫力丧失和受感染个体从恢复池移动到易感池的速率。</p><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/410e7016a2c1bc59a721fc04002c049a.png" data-original-src="https://miro.medium.com/v2/resize:fit:338/0*X2v31PqHURmWc5r8"/></div></figure><p id="efdb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于这项工作，只实现了SIR模型，SIRS模型及其变体留待将来的工作。</p><h1 id="aea8" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">使用PyMC3推断疾病参数</h1><p id="9824" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">我们可以使用一阶或二阶时间差分方案对SIR模型进行离散化，然后将其传递给PyMC3，pymc 3将使用这些离散化方程及时推进求解。然后可以使用蒙特卡罗采样程序拟合参数λ和μ。</p><h2 id="0343" class="mr lc iq bd ld ms mt dn lh mu mv dp ll jy mw mx lp kc my mz lt kg na nb lx nc bi translated">一阶方案</h2><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/61a0642824c94b04386975073e3d2e06.png" data-original-src="https://miro.medium.com/v2/resize:fit:548/0*hphRZ0a5OMhvADPj"/></div></figure><h2 id="9e7d" class="mr lc iq bd ld ms mt dn lh mu mv dp ll jy mw mx lp kc my mz lt kg na nb lx nc bi translated">二阶方案</h2><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/94ebbc570b0afb507977276c339b9e7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:858/0*dl5vxTEdffI7_QPV"/></div></figure><h2 id="0ecb" class="mr lc iq bd ld ms mt dn lh mu mv dp ll jy mw mx lp kc my mz lt kg na nb lx nc bi translated">PyMC3中的微分方程方法</h2><p id="1cf4" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">虽然我们可以选择高阶离散化方案来手动提供离散化，但这很快就会变得繁琐且容易出错，更不用说在Python这样的语言中计算效率低下了。幸运的是，PyMC3有一个ODE模块来完成这个任务。我们可以使用ODE模块中的微分方程方法，该方法将一个函数作为输入，该函数以向量的形式返回一组ODE的值、需要求解的时间步长、对应于方程数量的状态数量以及我们想要求解的变量数量。尽管这仍然比手工离散化要快，但是这种方法对于问题的规模来说扩展性很差。推荐的最佳实践是使用PyMC3中的“sunode”模块(见下文)。例如，对于100个样本、100个调整样本和20个时间点，相同的问题使用微分方程需要5.4分钟，而使用sunode需要16秒。</p><pre class="mg mh mi mj gt nl nm nn no aw np bi"><span id="9742" class="mr lc iq nm b gy nq nr l ns nt">self.sir_model_non_normalized = DifferentialEquation(<br/>   func = self.SIR_non_normalized,<br/>   times = self.time_range1:],<br/>   n_states = 2,<br/>   n_theta = 2,<br/>   t0 = 0)</span><span id="8478" class="mr lc iq nm b gy nu nr l ns nt">def SIR_non_normalized(self, y, t, p):<br/>   ds = -p[0] * y[0] * y[1] / self.covid_data.N,<br/>   di = p[0] * y[0] * y[1] / self.covid_data.N — p[1] * y[1]<br/>   return[ds, di]</span></pre><p id="b3c7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用sunode模块的语法如下所示。虽然有一些句法上的差异，但总体结构与微分方程是相同的。</p><pre class="mg mh mi mj gt nl nm nn no aw np bi"><span id="3df9" class="mr lc iq nm b gy nq nr l ns nt">import sunode<br/>import sunode.wrappers.as_theano</span><span id="1823" class="mr lc iq nm b gy nu nr l ns nt">def SIR_sunode(t, y, p):<br/>  return { ‘S’: -p.lam * y.S * y.I,<br/>  ‘I’: p.lam * y.S * y.I — p.mu * y.I}</span><span id="7085" class="mr lc iq nm b gy nu nr l ns nt">…</span><span id="5a7d" class="mr lc iq nm b gy nu nr l ns nt">…</span><span id="b99d" class="mr lc iq nm b gy nu nr l ns nt">sir_curves, _, problem, solver, _, _ =       <br/>   sunode.wrappers.as_theano.solve_ivp(<br/>   y0={ # Initial conditions of the ODE<br/>   ‘S’: (S_init, ()),<br/>   ‘I’: (I_init, ()),},<br/>   params={<br/>      # Parameters of the ODE, specify shape<br/>     ‘lam’: (lam, ()),<br/>     ‘mu’: (mu, ()),<br/>     ‘_dummy’: (np.array(1.), ())} # currently, sunode throws an error, without this</span><span id="8224" class="mr lc iq nm b gy nu nr l ns nt">   # RHS of the ODE<br/>   rhs=SIR_sunode,<br/>   # Time points of th solution<br/>   tvals=times,<br/>   t0=times[0],)</span></pre><h2 id="4078" class="mr lc iq bd ld ms mt dn lh mu mv dp ll jy mw mx lp kc my mz lt kg na nb lx nc bi translated">SIR模型的推理过程</h2><p id="71e2" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">为了对我们寻求的参数进行推断，我们首先为疾病参数选择合理的先验。基于我们对疾病现象行为的理解，对数正态分布是疾病参数的合理先验。理想情况下，我们希望这个对数正态分布的平均参数在我们期望的参数附近。对于良好的融合和解决方案，数据似然性是适当的(领域专业知识！).通常选择以下之一作为可能性。</p><ul class=""><li id="c9cd" class="kn ko iq jp b jq jr ju jv jy kp kc kq kg kr kk me kt ku kv bi translated">正态分布</li><li id="0f41" class="kn ko iq jp b jq kw ju kx jy ky kc kz kg la kk me kt ku kv bi translated">对数正态分布</li><li id="08f5" class="kn ko iq jp b jq kw ju kx jy ky kc kz kg la kk me kt ku kv bi translated">学生的t分布</li></ul><p id="169a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们从ODE求解器获得易感(S(t))和传染(I(t))数，然后对λ和μ的值进行采样，如下所示。</p><pre class="mg mh mi mj gt nl nm nn no aw np bi"><span id="6067" class="mr lc iq nm b gy nq nr l ns nt">with pm.Model() as model4:</span><span id="04b3" class="mr lc iq nm b gy nu nr l ns nt">   sigma = pm.HalfCauchy(‘sigma’, self.likelihood[‘sigma’], shape=1)</span><span id="6a1c" class="mr lc iq nm b gy nu nr l ns nt">   lam = pm.Lognormal(‘lambda’, self.prior[‘lam’], self.prior[‘lambda_std’]) # 1.5, 1.5</span><span id="0e85" class="mr lc iq nm b gy nu nr l ns nt">   mu = pm.Lognormal(‘mu’, self.prior[‘mu’], self.prior[‘mu_std’])</span><span id="712a" class="mr lc iq nm b gy nu nr l ns nt">   res, _, problem, solver, _, _ = sunode.wrappers.as_theano.solve_ivp(<br/>   y0={‘S’: (self.S_init, ()), ‘I’: (self.I_init, ()),},<br/>   params={‘lam’: (lam, ()), ‘mu’: (mu, ()), ‘_dummy’: (np.array(1.), ())},<br/>   rhs=self.SIR_sunode,<br/>   tvals=self.time_range,<br/>   t0=self.time_range[0])</span><span id="2389" class="mr lc iq nm b gy nu nr l ns nt">   # likelihood distribution mean, these are the predictions from the SIR model ODE solver</span><span id="2eee" class="mr lc iq nm b gy nu nr l ns nt">   if(likelihood[‘distribution’] == ‘lognormal’):</span><span id="0bbd" class="mr lc iq nm b gy nu nr l ns nt">       I = pm.Lognormal(‘I’, mu=res[‘I’], sigma=sigma, observed=self.cases_obs_scaled)</span><span id="0080" class="mr lc iq nm b gy nu nr l ns nt">   elif(likelihood[‘distribution’] == ‘normal’):</span><span id="cf24" class="mr lc iq nm b gy nu nr l ns nt">       I = pm.Normal(‘I’, mu=res[‘I’], sigma=sigma, observed=self.cases_obs_scaled)</span><span id="d16f" class="mr lc iq nm b gy nu nr l ns nt">   elif(likelihood[‘distribution’] == ‘students-t’):</span><span id="16f9" class="mr lc iq nm b gy nu nr l ns nt">       I = pm.StudentT( “I”, nu=likelihood[‘nu’], \<br/>       mu=res[‘I’], <br/>       sigma=sigma,<br/>       observed=self.cases_obs_scaled)</span><span id="9155" class="mr lc iq nm b gy nu nr l ns nt">   R0 = pm.Deterministic(‘R0’,lam/mu)</span><span id="a791" class="mr lc iq nm b gy nu nr l ns nt">   trace = pm.sample(self.n_samples, tune=self.n_tune, chains=4, cores=4)</span><span id="d53d" class="mr lc iq nm b gy nu nr l ns nt">   data = az.from_pymc3(trace=trace)</span></pre><h1 id="30c6" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">PyMC3的推理流程</h1><p id="ecc2" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">因为开发这样一个模型，使用贝叶斯推理来估计疾病参数，是一个迭代过程，我们希望尽可能自动化。用各种参数实例化一类模型对象并自动运行可能是个好主意。为每次运行保存跟踪信息、推理度量(如R̂ (R-hat ))以及其他元数据信息也是一个好主意。诸如NetCDF之类的文件格式可以用于此，尽管它可以像使用Python内置数据库模块“shelve”一样简单。这里没有显示用于数据提取的类，但是显示了它们的调用，以便您对这里使用的数据和模型参数有所了解。</p><pre class="mg mh mi mj gt nl nm nn no aw np bi"><span id="c8d6" class="mr lc iq nm b gy nq nr l ns nt">covid_obj = COVID_data(‘US’, Population=328.2e6)</span><span id="4b6d" class="mr lc iq nm b gy nu nr l ns nt">covid_obj.get_dates(data_begin=’10/1/20', data_end=’10/28/20')</span><span id="dd36" class="mr lc iq nm b gy nu nr l ns nt">sir_model = SIR_model_sunode(covid_obj)</span><span id="6ba6" class="mr lc iq nm b gy nu nr l ns nt">likelihood = {‘distribution’: ‘normal’, ‘sigma’: 2}</span><span id="3de3" class="mr lc iq nm b gy nu nr l ns nt">prior = {‘lam’: 1.5,‘mu’: 1.5, ‘lambda_std’: 1.5, ‘mu_std’: 1.5 }</span><span id="f97b" class="mr lc iq nm b gy nu nr l ns nt">sir_model.run_SIR_model(n_samples=500, n_tune=500, likelihood=likelihood, prior=prior)</span></pre><p id="b01c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这些结果纯粹是为了说明的目的，需要进行大量的实验才能从模拟中得到有意义的结果。美国1月至10月的病例数如下所示(图2)。</p><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi nv"><img src="../Images/86fb580cda96d01a039c7fbea4c7bd49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wxZ7ElSC3aocMGzC"/></div></div></figure><p id="c5ee" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">图2 -美国新冠肺炎病例数可视化示例</p><p id="eb32" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">图3示出了推理运行的结果，其中显示了λ、μ和<em class="km"> R0 </em>的后验分布。执行贝叶斯推断的一个优点是，分布显示了平均值估计以及用于量化不确定性的最高密度区间(HDI)。检查跟踪是一个好主意(至少！)以确保正确采样。</p><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi nw"><img src="../Images/a2e974d3f6c9ebfffaf524a24a4d7ef4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*lHo2DQQWjUrHMGk3"/></div></div></figure><p id="9100" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">图3 -使用PyMC3显示最高密度区间(HDI)的推理运行结果示例。</p><h1 id="15d7" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">池化、非池化和分层模型</h1><p id="7e6c" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">假设您有关于美国各州感染人数的信息。使用该数据来推断新冠肺炎的疾病参数(例如<em class="km"> R0) </em>的一种方式是将其全部相加以估计单个参数。这被称为<em class="km">集合模型</em>。然而，这种方法的问题是可能包含在这些单独的状态或组中的细粒度信息丢失了。另一个极端是估计每个状态的单个参数<em class="km"> R0 </em>。这种方法产生了一个<em class="km">非池模型</em>。然而，考虑到我们正在尝试估计对应于同一病毒的参数，必须有一种方法来集体执行此操作，这将我们带到了<em class="km">层次模型</em>。当在某些州没有足够的信息来创建准确的估计时，这特别有用。分层模型允许我们使用共享的“超优先级”来共享来自其他状态的信息。让我们以下面的例子来更详细地看看这个公式:</p><p id="ebb4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于混合模型，我们可以从具有固定参数λ_μ，λ_σ的单个分布中提取</p><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/037205fc42155ab840e3fcffa196d39a.png" data-original-src="https://miro.medium.com/v2/resize:fit:474/0*yb39dle6bY0c0qYL"/></div></figure><p id="bf82" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于未规划的模型，我们可以从具有固定参数λ_μᵢ、λ_σᵢ</p><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/62f10a04fea2ff6f2258952c6d1cbe54.png" data-original-src="https://miro.medium.com/v2/resize:fit:510/0*FrN3oqUL8HdO0ppl"/></div></figure><p id="756e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于分层模型，我们有一个先验，它由来自其他分布的非常数参数来参数化。这里，我们为每个状态画一个λ值，但是它们通过共享的超优分布(具有常数参数)连接，如下所示。</p><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/a3b36f647d0f4cf16b8da43a0f295c57.png" data-original-src="https://miro.medium.com/v2/resize:fit:474/0*voePPeerx6T8dTzR"/></div></figure><p id="a887" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">查看课程3 <em class="km">贝叶斯建模和推理的PyMC3介绍</em>(【https://www.coursera.org/learn/introduction-to-pymc3?】T2)specialization=compstats )来了解更多关于层次模型的细节。</p><h1 id="d2d4" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">分层模型的新冠肺炎数据</h1><p id="4bce" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">这里我们绘制并使用了美国和巴西这两个国家每天的感染病例数。然而，在层级模型中可以使用的国家的选择或数量没有限制。以下案例发生于2020年3月1日至2021年1月1日。这些图表似乎遵循相似的轨迹，尽管这些国家在<em class="km"> y轴</em>上的比例不同。考虑到这些病例来自同一个新冠肺炎病毒，这是合理的。然而，在现实场景中，需要考虑差异，例如不同的变量、不同的地理结构和社会距离规则、医疗保健基础设施等等。</p><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi nz"><img src="../Images/da57324b2d4816a617824c86704ca9aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*X6oqUgiB0TQHPB-y"/></div></div></figure><p id="4957" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">图4 -两个国家的新冠肺炎病例数量图</p><h1 id="5c0e" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">参数推断</h1><p id="6b13" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">对于分层模型，下面给出了执行疾病参数推断的代码片段。</p><pre class="mg mh mi mj gt nl nm nn no aw np bi"><span id="1804" class="mr lc iq nm b gy nq nr l ns nt">with pm.Model() as model4:</span><span id="1a53" class="mr lc iq nm b gy nu nr l ns nt">   # narrow std is roughly equivalent to a constant prior parameter,  if there are issues with sampling from the prior distribution<br/>   # make the variance of the mean smaller. Variance of the distribution of the variance parameter seems less relevant in this regard.</span><span id="b9e1" class="mr lc iq nm b gy nu nr l ns nt">   nsamples = 8000 </span><span id="f214" class="mr lc iq nm b gy nu nr l ns nt">   ntune = 4000</span><span id="cc8c" class="mr lc iq nm b gy nu nr l ns nt">   Hyperprior = {“Lambda mean”: 0.75, “Lambda std”: 2, “Mu mean”: 0.75, “Mu std”: 2}</span><span id="9353" class="mr lc iq nm b gy nu nr l ns nt">   Prior = {“Lambda std”: 1.0, “Mu std”: 1.0}</span><span id="945e" class="mr lc iq nm b gy nu nr l ns nt">   Likelihood = {“Name”: “Normal”, “Parameters”: {“std”: 0.01}}</span><span id="7e38" class="mr lc iq nm b gy nu nr l ns nt">   prior_lam = pm.Lognormal(‘prior_lam’, Hyperprior[‘Lambda mean’], Hyperprior[‘Lambda std’])</span><span id="960f" class="mr lc iq nm b gy nu nr l ns nt">   prior_mu = pm.Lognormal(‘prior_mu’, Hyperprior[‘Mu mean’], Hyperprior[‘Mu std’])</span><span id="5816" class="mr lc iq nm b gy nu nr l ns nt">   prior_lam_std = pm.HalfNormal(‘prior_lam_std’, Prior[‘Lambda std’])</span><span id="d67d" class="mr lc iq nm b gy nu nr l ns nt">   prior_mu_std = pm.HalfNormal(‘prior_mu_std’, Prior[‘Mu std’])</span><span id="cd6f" class="mr lc iq nm b gy nu nr l ns nt">   lam = pm.Lognormal(‘lambda’, prior_lam , prior_lam_std, shape=2)</span><span id="8c6e" class="mr lc iq nm b gy nu nr l ns nt">   mu = pm.Lognormal(‘mu’, prior_mu , prior_mu_std, shape=2)</span><span id="a970" class="mr lc iq nm b gy nu nr l ns nt">   # — — — — — — — — — — ODE model — — — — — — — — #</span><span id="c016" class="mr lc iq nm b gy nu nr l ns nt">   res, _, problem, solver, _, _ = sunode.wrappers.as_theano.solve_ivp(<br/>   y0={ ‘S’: (S_init, (2,)), ‘I’: (I_init, (2,)),},<br/>   params={‘lam’: (lam, (2,)), ‘mu’: (mu, (2,)), ‘_dummy’: (np.array(1.), ())},<br/>   rhs=SIR_sunode,<br/>   tvals=time_range[1:],<br/>   t0=time_range[0])</span><span id="fa1d" class="mr lc iq nm b gy nu nr l ns nt">   I = pm.Normal(‘I’, mu=res[‘I’], sigma=Likelihood[‘Parameters’][‘std’], observed=cases_obs_scaled[1:])</span><span id="c47d" class="mr lc iq nm b gy nu nr l ns nt">   R0 = pm.Deterministic(‘R0’,lam/mu)</span><span id="5b56" class="mr lc iq nm b gy nu nr l ns nt">   # if you increase the variance and the distributions looks choppy, increase the tuning sample size to sample the space more effectively<br/>   # also, increase the total number of samples</span><span id="004d" class="mr lc iq nm b gy nu nr l ns nt">  trace = pm.sample(nsamples, tune=ntune, chains=8, cores=8)</span><span id="efbe" class="mr lc iq nm b gy nu nr l ns nt">  data = az.from_pymc3(trace=trace)</span></pre><p id="f6b6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">样本后验分布及其94%的最高密度区间(HDI)如下所示。</p><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi nz"><img src="../Images/4780d5d9769243b2cd21246042355fad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*jZZ3iUno8kg0ev7K"/></div></div></figure><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi nz"><img src="../Images/94fa1d0684dcfdf1241db964f64fddda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*OF7ZN4cS7r52W9MV"/></div></div></figure><p id="8abc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">图5 -采样后验分布及其94%的最高密度区间(HDI)。</p><p id="4226" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们还可以检查轨迹图的收敛性，它显示了所有变量的良好混合——这是采样器很好地探索了空间的好迹象。所有的痕迹之间有很好的一致性。这种现象可以从上图中相当窄的HDI区间得到证实。</p><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi nz"><img src="../Images/4018dcb29736a31946649f95ae458b54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*94yljDESp_2RSh7F"/></div></div></figure><p id="bc6d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">图6-R0和其他变量的轨迹图和密度图</p><p id="47f7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下表总结了各种推断变量和参数的分布，以及抽样统计。虽然对变量的估计是必不可少的，但此表对于告知我们采样器的质量和效率特别有用。例如，R-hat都接近或等于1.0，表明所有链之间的一致性良好。有效样本量是另一个关键指标。如果这与样本总数相比很小，这肯定是取样器有问题的迹象。即使R-hat值看起来不错，也一定要检查有效样本量！</p><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi oa"><img src="../Images/805b01bab7f9a8bc3abec2724c042b71.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3l8_aWsjvwEDwBzH"/></div></div></figure><p id="8c97" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">图7 -推断变量分布表以及抽样统计</p><h1 id="c930" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">注意事项和指南</h1><p id="be62" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">建模和推理的一些一般准则:</p><ul class=""><li id="b7b1" class="kn ko iq jp b jq jr ju jv jy kp kc kq kg kr kk me kt ku kv bi translated">使用至少5000个样本和1000个样本进行调整。</li><li id="25c1" class="kn ko iq jp b jq kw ju kx jy ky kc kz kg la kk me kt ku kv bi translated">对于上面显示的结果，我使用了:均值:λ= 1.5，= 1.5，两个参数的标准差:2.0。领域专家和他的知识在设置这些参数时是非常宝贵的。</li><li id="e232" class="kn ko iq jp b jq kw ju kx jy ky kc kz kg la kk me kt ku kv bi translated">至少从3条链上取样。</li><li id="272e" class="kn ko iq jp b jq kw ju kx jy ky kc kz kg la kk me kt ku kv bi translated">将<strong class="jp ir"> target_accept </strong>设置为&gt; 0.85(取决于采样算法)。</li><li id="b2fa" class="kn ko iq jp b jq kw ju kx jy ky kc kz kg la kk me kt ku kv bi translated">如果可能，用<strong class="jp ir">核心=n </strong>并行采样，其中‘n’是可用核心的数量。</li><li id="b43d" class="kn ko iq jp b jq kw ju kx jy ky kc kz kg la kk me kt ku kv bi translated">检查轨迹是否收敛。</li><li id="cd93" class="kn ko iq jp b jq kw ju kx jy ky kc kz kg la kk me kt ku kv bi translated">有限的时间样本会影响推断的准确性，拥有更多高质量的数据总是更好的。</li><li id="b188" class="kn ko iq jp b jq kw ju kx jy ky kc kz kg la kk me kt ku kv bi translated">规范化您的数据，大值通常不利于收敛</li></ul><h2 id="5135" class="mr lc iq bd ld ms mt dn lh mu mv dp ll jy mw mx lp kc my mz lt kg na nb lx nc bi translated">调试您的模型</h2><ul class=""><li id="794b" class="kn ko iq jp b jq lz ju ma jy ob kc oc kg od kk me kt ku kv bi translated">因为PyMC3的后端是theano，所以Python print语句不能用于检查变量值。使用<strong class="jp ir">the no . printing . print(DESCRIPTIVE _ STRING)(VAR)</strong>来完成这个。</li><li id="bc69" class="kn ko iq jp b jq kw ju kx jy ky kc kz kg la kk me kt ku kv bi translated">通过传递“testval”来初始化随机变量。这非常有助于检查那些讨厌的“坏能量”错误，这些错误通常是由于对可能性或先验的错误选择。使用<strong class="jp ir"> Model.check_test_point() </strong>来验证这一点。</li><li id="04a4" class="kn ko iq jp b jq kw ju kx jy ky kc kz kg la kk me kt ku kv bi translated">使用<strong class="jp ir">步骤= pm。Metropolis() </strong>对于快速调试来说，这运行得更快，但结果却更粗糙。</li><li id="2c97" class="kn ko iq jp b jq kw ju kx jy ky kc kz kg la kk me kt ku kv bi translated">如果采样很慢，检查你的先验分布和似然分布。</li><li id="ec51" class="kn ko iq jp b jq kw ju kx jy ky kc kz kg la kk me kt ku kv bi translated">先验分布的窄西格玛值可用于模拟常数先验，并有助于调试从先验分布采样的问题。</li><li id="7474" class="kn ko iq jp b jq kw ju kx jy ky kc kz kg la kk me kt ku kv bi translated">如果增加方差导致不连续的后验分布，则增加调整样本大小和样本数量，以便更有效地对空间进行采样。</li></ul><h1 id="3d5d" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">未来的工作</h1><p id="191d" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">虽然这为我们的参数产生了令人满意的估计，但我们经常遇到采样器不能有效地执行的问题。对于未来的工作，有几种方法可以诊断和改进建模过程。下面按难度递增的顺序列出了这些问题:</p><ol class=""><li id="dbe5" class="kn ko iq jp b jq jr ju jv jy kp kc kq kg kr kk ks kt ku kv bi translated">增加调整大小和抽取的样本数。</li><li id="2d87" class="kn ko iq jp b jq kw ju kx jy ky kc kz kg la kk ks kt ku kv bi translated">减小采样器的target_accept参数，以减少样本间的自相关。使用自相关图来证实这一点。</li><li id="6867" class="kn ko iq jp b jq kw ju kx jy ky kc kz kg la kk ks kt ku kv bi translated">向观测数据中添加更多样本，即增加采样频率。</li><li id="f31b" class="kn ko iq jp b jq kw ju kx jy ky kc kz kg la kk ks kt ku kv bi translated">为参数使用更好的先验和超先验。</li><li id="3966" class="kn ko iq jp b jq kw ju kx jy ky kc kz kg la kk ks kt ku kv bi translated">使用模型的替代参数化。</li><li id="e1ff" class="kn ko iq jp b jq kw ju kx jy ky kc kz kg la kk ks kt ku kv bi translated">将社交距离测量等变化纳入模型。</li></ol><h2 id="b296" class="mr lc iq bd ld ms mt dn lh mu mv dp ll jy mw mx lp kc my mz lt kg na nb lx nc bi translated">了解更多信息</h2><p id="85c9" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">你可以在我的Coursera specialization(<a class="ae kl" href="https://www.coursera.org/specializations/compstats" rel="noopener ugc nofollow" target="_blank">https://www.coursera.org/specializations/compstats</a>)了解更多关于这些主题的信息，该课程包括以下课程:</p><ol class=""><li id="74b6" class="kn ko iq jp b jq jr ju jv jy kp kc kq kg kr kk ks kt ku kv bi translated">贝叶斯统计导论(<a class="ae kl" href="https://www.coursera.org/learn/compstatsintro?specialization=compstats" rel="noopener ugc nofollow" target="_blank">https://www.coursera.org/learn/compstatsintro?专门化=compstats </a></li><li id="a6a7" class="kn ko iq jp b jq kw ju kx jy ky kc kz kg la kk ks kt ku kv bi translated">贝叶斯推理与MCMC(【https://www.coursera.org/learn/mcmc? T2】专门化=compstats </li><li id="e00f" class="kn ko iq jp b jq kw ju kx jy ky kc kz kg la kk ks kt ku kv bi translated">用于贝叶斯建模和推理的PyMC3简介(【https://www.coursera.org/learn/introduction-to-pymc3?】T4)专业化=compstats </li></ol><h1 id="5ae3" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">参考</h1><ol class=""><li id="778f" class="kn ko iq jp b jq lz ju ma jy ob kc oc kg od kk ks kt ku kv bi translated">Priesemann小组的工作</li></ol><div class="oe of gp gr og oh"><a href="https://github.com/Priesemann-Group/covid_bayesian_mcmc" rel="noopener  ugc nofollow" target="_blank"><div class="oi ab fo"><div class="oj ab ok cl cj ol"><h2 class="bd ir gy z fp om fr fs on fu fw ip bi translated">GitHub-Priesemann-Group/covid _ Bayesian _ MCMC:Bayesian Markov Chain Monte Carlo预测…</h2><div class="oo l"><h3 class="bd b gy z fp om fr fs on fu fw dk translated">这个库提供了我们对新冠肺炎在德国传播的预测背后的代码。它被用于三个…</h3></div><div class="op l"><p class="bd b dl z fp om fr fs on fu fw dk translated">github.com</p></div></div><div class="oq l"><div class="or l os ot ou oq ov mp oh"/></div></div></a></div><p id="8460" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">2.Demetri Pananos在PyMC3网站上的工作</p><div class="oe of gp gr og oh"><a href="https://docs.pymc.io/notebooks/ODE_API_introduction.html" rel="noopener  ugc nofollow" target="_blank"><div class="oi ab fo"><div class="oj ab ok cl cj ol"><h2 class="bd ir gy z fp om fr fs on fu fw ip bi translated">GSoC 2019:pymc 3 . ode API-pymc 3 3 . 10 . 0文档介绍</h2><div class="oo l"><h3 class="bd b gy z fp om fr fs on fu fw dk translated">由德米特里·帕纳诺斯常微分方程(ODEs)是一个方便的数学框架建模的…</h3></div><div class="op l"><p class="bd b dl z fp om fr fs on fu fw dk translated">docs.pymc.io</p></div></div></div></a></div><p id="60cf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">3.太阳之歌</p><div class="oe of gp gr og oh"><a href="https://github.com/aseyboldt/sunode" rel="noopener  ugc nofollow" target="_blank"><div class="oi ab fo"><div class="oj ab ok cl cj ol"><h2 class="bd ir gy z fp om fr fs on fu fw ip bi translated">GitHub - aseyboldt/sunode:快速求解ODEs，支持PyMC3</h2><div class="oo l"><h3 class="bd b gy z fp om fr fs on fu fw dk translated">您可以在这里找到文档。《太阳之歌》包含了日晷解算器亚当和BDF，以及他们对解算的支持…</h3></div><div class="op l"><p class="bd b dl z fp om fr fs on fu fw dk translated">github.com</p></div></div><div class="oq l"><div class="ow l os ot ou oq ov mp oh"/></div></div></a></div><p id="d8ed" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">4.闪光</p><p id="ad6c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kl" href="http://www.gleamviz.org" rel="noopener ugc nofollow" target="_blank">http://www.gleamviz.org</a></p></div></div>    
</body>
</html>