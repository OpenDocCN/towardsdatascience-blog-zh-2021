<html>
<head>
<title>Customizing Scipy ODE solvers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">自定义Scipy ODE解算器</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/do-stuff-at-each-ode-integration-step-monkey-patching-solve-ivp-359b39d5f2?source=collection_archive---------25-----------------------#2021-09-14">https://towardsdatascience.com/do-stuff-at-each-ode-integration-step-monkey-patching-solve-ivp-359b39d5f2?source=collection_archive---------25-----------------------#2021-09-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="ba70" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph">融入时尚</h2><div class=""/><div class=""><h2 id="c81c" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">猴子给Scipy打补丁，在每个集成步骤做事情</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ko"><img src="../Images/b1cf7f2ea1192da7af4de2dbbb7e3000.png" data-original-src="https://miro.medium.com/v2/resize:fit:1352/format:webp/1*vX_hVIfIvBbk027JgZfrrw.jpeg"/></div><p class="kw kx gj gh gi ky kz bd b be z dk translated">由<a class="ae la" href="https://unsplash.com/@robin_schreiner" rel="noopener ugc nofollow" target="_blank">罗宾·施雷纳</a>在<a class="ae la" href="http://unsplash.com" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="f041" class="pw-post-body-paragraph lb lc iq ld b le lf ka lg lh li kd lj lk ll lm ln lo lp lq lr ls lt lu lv lw ij bi lx translated">除非你在过去的几年里生活在岩石下，否则你肯定知道Python语言通常是科学计算任务的首选武器，因为它是免费的、可扩展的、易于掌握的，并且具有与最好的商业软件相当的性能。科学计算Python栈几乎总是由著名的包<strong class="ld ja"> Numpy和Scipy </strong>、数值类型的高质量实现、许多不同的数学运算和常见的计算原语组成。</p><p id="29f3" class="pw-post-body-paragraph lb lc iq ld b le lf ka lg lh li kd lj lk ll lm ln lo lp lq lr ls lt lu lv lw ij bi translated">在研究和工程中一个很常见的任务就是<strong class="ld ja">整合</strong><a class="ae la" href="https://en.wikipedia.org/wiki/Ordinary_differential_equation" rel="noopener ugc nofollow" target="_blank"><strong class="ld ja"/></a>的系统，特别是初值问题。在Scipy中，实现这一点的首选方式是通过函数<code class="fe mg mh mi mj b"><a class="ae la" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.solve_ivp.html" rel="noopener ugc nofollow" target="_blank">solve_ivp</a></code>。你提供要积分的函数，你想要使用的积分算法/解算器的种类(<a class="ae la" href="https://en.wikipedia.org/wiki/Runge%E2%80%93Kutta_methods" rel="noopener ugc nofollow" target="_blank"> RK25，RK45 </a>等)。)，通常的集成参数，您就可以开始了。让我们试着整合一个著名的自治微分系统，<a class="ae la" href="https://en.wikipedia.org/wiki/Lorenz_system" rel="noopener ugc nofollow" target="_blank">洛伦兹方程</a>:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mk ml l"/></div><p class="kw kx gj gh gi ky kz bd b be z dk translated">洛伦兹系统的代码</p></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi mm"><img src="../Images/463f03b105152ae3e1246c14af4bec41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*IXtuIjY5U7PK65T-7waX5w.png"/></div><p class="kw kx gj gh gi ky kz bd b be z dk translated">一个人可以解决洛伦兹系统，而不显示解决方案的图形吗？那鸿(图片由作者提供)</p></figure><p id="d198" class="pw-post-body-paragraph lb lc iq ld b le lf ka lg lh li kd lj lk ll lm ln lo lp lq lr ls lt lu lv lw ij bi translated"><strong class="ld ja">在使用了一点点</strong> <code class="fe mg mh mi mj b"><strong class="ld ja">solve_ivp</strong></code> <strong class="ld ja">之后，我很快意识到</strong> <strong class="ld ja">当前版本的函数没有办法指定在集成的每一步之后要执行的回调或任务</strong>。</p><p id="4a34" class="pw-post-body-paragraph lb lc iq ld b le lf ka lg lh li kd lj lk ll lm ln lo lp lq lr ls lt lu lv lw ij bi translated">在执行这类任务的软件中，这通常是可能的。虽然最终的解决方案是在最后交付的，但是在每一步之后，您可能想要做的事情是，例如，在解决方案生成时绘制解决方案，以便在早期发现bug和错误，或者简单地显示某种信息或指标。当解决计算昂贵和/或必须长时间集成的系统时，特别需要这些特性。那么……怎么做呢？</p><p id="5c47" class="pw-post-body-paragraph lb lc iq ld b le lf ka lg lh li kd lj lk ll lm ln lo lp lq lr ls lt lu lv lw ij bi translated">最幼稚的做法是编辑<code class="fe mg mh mi mj b">solve_ivp</code>的源代码，但这是一个大禁忌:该功能将不再像所有其他使用它的软件预期的那样工作，这是一个灾难。我们可以推出自己版本的<code class="fe mg mh mi mj b">solve_ivp</code>或我们正在使用的求解器，但这涉及到大量的复制粘贴，这将意味着有效地派生当前版本的函数，并且如果我们想跟上可能推出的更新，还需要进行艰苦的维护。最正统、最精简、最优雅的解决方案，或者说最不会让计算机科学家皱眉的解决方案，是<a class="ae la" href="https://en.wikipedia.org/wiki/Monkey_patch" rel="noopener ugc nofollow" target="_blank"> <strong class="ld ja">猴子补丁</strong> </a>。</p><p id="aa9c" class="pw-post-body-paragraph lb lc iq ld b le lf ka lg lh li kd lj lk ll lm ln lo lp lq lr ls lt lu lv lw ij bi translated"><strong class="ld ja"> Monkey patching是一种编程技术，涉及在运行时动态修改对象，以完成一些期望的行为，而不干预它们的源代码</strong>。你可以把它想象成在你的代码开始运行的时候临时定制一个对象来满足你的需求。在本文中，我将展示一个非常简单的用例:添加一个进度条，它将告诉我们在什么点上进行集成，并给我们关于计算速度和进展的反馈。为此，我们将使用轻量级的可扩展包<code class="fe mg mh mi mj b"><a class="ae la" href="https://github.com/tqdm/tqdm" rel="noopener ugc nofollow" target="_blank">tqdm</a></code>。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mk ml l"/></div><p class="kw kx gj gh gi ky kz bd b be z dk translated">猴子补丁代码</p></figure><p id="154e" class="pw-post-body-paragraph lb lc iq ld b le lf ka lg lh li kd lj lk ll lm ln lo lp lq lr ls lt lu lv lw ij bi translated">这是怎么回事？嗯，通过查看<a class="ae la" href="https://github.com/scipy/scipy/blob/701ffcc8a6f04509d115aac5e5681c538b5265a2/scipy/integrate/_ivp/ivp.py#L156" rel="noopener ugc nofollow" target="_blank"> solve_ivp源代码</a>，我体会到两件事:</p><ul class=""><li id="caba" class="mn mo iq ld b le lf lh li lk mp lo mq ls mr lw ms mt mu mv bi translated">所有可用的解算器，如<code class="fe mg mh mi mj b">RK23</code>、<code class="fe mg mh mi mj b">RK45</code>、<code class="fe mg mh mi mj b">BDF</code>等。，继承自一个名为<code class="fe mg mh mi mj b">OdeSolver</code>的母类。</li><li id="d906" class="mn mo iq ld b le mw lh mx lk my lo mz ls na lw ms mt mu mv bi translated"><code class="fe mg mh mi mj b">solve_ivp</code>初始化<code class="fe mg mh mi mj b">OdeSolver</code>并调用方法<code class="fe mg mh mi mj b">step</code>推进整合。</li></ul><p id="9652" class="pw-post-body-paragraph lb lc iq ld b le lf ka lg lh li kd lj lk ll lm ln lo lp lq lr ls lt lu lv lw ij bi translated">因此，这个想法是将我们自己的进度条形码添加到<code class="fe mg mh mi mj b">__init__</code>和<code class="fe mg mh mi mj b">step</code>方法中。由于我们还想继续做这两个方法在原始代码中做的老事情(咄)，我们将这两个方法“保存”为<code class="fe mg mh mi mj b">old_init</code>和<code class="fe mg mh mi mj b">old_step</code>，并用与方法完全相同的签名编写我们自己的包装函数。我们的版本，除了调用旧代码，还创建、更新和关闭一个tqdm进度条。最后，我们只是用我们自己的增强版本修补了这两个方法；也就是说，我们简单地在加载的活类上动态替换那些属性——这就是动态编程语言的本质。瞧啊。现在，每当<code class="fe mg mh mi mj b">solve_ivp</code>使用<code class="fe mg mh mi mj b">OdeSolver</code>时，就会出现进度条。</p><pre class="kp kq kr ks gt nc mj nd ne aw nf bi"><span id="4b2c" class="ng nh iq mj b gy ni nj l nk nl"><strong class="mj ja">IVP: 100%|##########| 40.0/40.0 [00:00&lt;00:00, 232.66ut/s]</strong></span></pre><p id="4bf5" class="pw-post-body-paragraph lb lc iq ld b le lf ka lg lh li kd lj lk ll lm ln lo lp lq lr ls lt lu lv lw ij bi translated">您还可以继续做其他有趣的事情:绘制解决方案、显示指标、发出警告、进行健全性检查……就像您可以提供自己的回调函数一样！</p></div></div>    
</body>
</html>