<html>
<head>
<title>An overview of the Scikit-learn Library — Episode 1 Preprocessing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Scikit-learn库概述—第1集预处理</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/an-overview-of-the-scikit-learn-library-episode-1-preprocessing-9b17ab4dde4f?source=collection_archive---------27-----------------------#2021-11-09">https://towardsdatascience.com/an-overview-of-the-scikit-learn-library-episode-1-preprocessing-9b17ab4dde4f?source=collection_archive---------27-----------------------#2021-11-09</a></blockquote><div><div class="fc ik il im in io"/><div class="ip iq ir is it"><h2 id="db12" class="iu iv iw bd b dl ix iy iz ja jb jc dk jd translated" aria-label="kicker paragraph">机器学习</h2><div class=""/><div class=""><h2 id="784c" class="pw-subtitle-paragraph kc jf iw bd b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt dk translated">著名的用于机器学习的Python库的剧集中的描述。第一集处理预处理子包。</h2></div><figure class="kv kw kx ky gu kz gi gj paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="gi gj ku"><img src="../Images/cba14a6256809fdaa2d6d61e8712ccc8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_EWf0TGb1wnNyD6mn_nk9w.jpeg"/></div></div><p class="lg lh gk gi gj li lj bd b be z dk translated">作者图片</p></figure><p id="1941" class="pw-post-body-paragraph lk ll iw lm b ln lo kg lp lq lr kj ls lt lu lv lw lx ly lz ma mb mc md me mf ip bi translated">Scikit-learn是一个非常流行的用于机器学习的Python库。最初由David Cournapeau于2007年开发，2010年，当法国计算机科学和自动化研究所INRIA参与该项目时，它开始成长。2021年9月，Scikit-learn最新版本发布，即1.0。</p><p id="3c3b" class="pw-post-body-paragraph lk ll iw lm b ln lo kg lp lq lr kj ls lt lu lv lw lx ly lz ma mb mc md me mf ip bi translated">Scikit-learn提供了机器学习过程中涉及的所有步骤，包括数据预处理、特征提取、模型选择、模型训练、模型评估和模型部署。</p><p id="75f0" class="pw-post-body-paragraph lk ll iw lm b ln lo kg lp lq lr kj ls lt lu lv lw lx ly lz ma mb mc md me mf ip bi translated">在这篇文章中，<strong class="lm jg">我开始了一系列的情节，每一集都描述了Scikit-learn </strong>提供的一个单独的子包。Scikit-learn被组织成一个名为<code class="fe mg mh mi mj b">sklearn</code>的主模块，这个主模块又被分成许多子模块。在本文中，我关注数据预处理。</p><p id="30cf" class="pw-post-body-paragraph lk ll iw lm b ln lo kg lp lq lr kj ls lt lu lv lw lx ly lz ma mb mc md me mf ip bi translated">用于数据预处理的所有类和函数都包含在子模块<code class="fe mg mh mi mj b">sklearn.preprocessing</code>中，该子模块提供以下操作:</p><ul class=""><li id="acc6" class="mk ml iw lm b ln lo lq lr lt mm lx mn mb mo mf mp mq mr ms bi translated">特征缩放</li><li id="c294" class="mk ml iw lm b ln mt lq mu lt mv lx mw mb mx mf mp mq mr ms bi translated">特征二值化</li><li id="9134" class="mk ml iw lm b ln mt lq mu lt mv lx mw mb mx mf mp mq mr ms bi translated">特征编码</li><li id="bbf2" class="mk ml iw lm b ln mt lq mu lt mv lx mw mb mx mf mp mq mr ms bi translated">非线性变换</li><li id="dfdf" class="mk ml iw lm b ln mt lq mu lt mv lx mw mb mx mf mp mq mr ms bi translated">其他的</li></ul><h1 id="8a2c" class="my mz iw bd na nb nc nd ne nf ng nh ni kl nj km nk ko nl kp nm kr nn ks no np bi translated">1特征缩放</h1><p id="ab1a" class="pw-post-body-paragraph lk ll iw lm b ln nq kg lp lq nr kj ls lt ns lv lw lx nt lz ma mb nu md me mf ip bi translated">特征缩放涉及数据规范化和标准化。在这篇由<a class="nv nw ep" href="https://medium.com/u/583a83b12a79?source=post_page-----9b17ab4dde4f--------------------------------" rel="noopener" target="_blank"> Baijayanta Roy </a>撰写的名为<a class="ae nx" rel="noopener" target="_blank" href="/all-about-feature-scaling-bcc0ad75cb35">关于特性缩放</a>的有趣文章中，你可以理解规范化和标准化之间的区别。</p><p id="e808" class="pw-post-body-paragraph lk ll iw lm b ln lo kg lp lq lr kj ls lt lu lv lw lx ly lz ma mb mc md me mf ip bi translated">Scikit-learn为功能缩放提供了许多类:</p><ul class=""><li id="99db" class="mk ml iw lm b ln lo lq lr lt mm lx mn mb mo mf mp mq mr ms bi translated"><code class="fe mg mh mi mj b">MaxAbsScaler()</code> —给定一个特征值列表，将列表中的每个值转换为0到1之间的数字。新值的计算方法是当前值除以列的最大值。</li><li id="2eb4" class="mk ml iw lm b ln mt lq mu lt mv lx mw mb mx mf mp mq mr ms bi translated"><code class="fe mg mh mi mj b">MinMaxScaler()</code> —新值计算为当前值和最小值之差除以特征值列表的范围。</li><li id="56a2" class="mk ml iw lm b ln mt lq mu lt mv lx mw mb mx mf mp mq mr ms bi translated"><code class="fe mg mh mi mj b">RobustScaler()</code> —移除中间值，并根据四分位范围缩放数据。<strong class="lm jg">该定标器对异常值具有鲁棒性</strong>。</li><li id="2b10" class="mk ml iw lm b ln mt lq mu lt mv lx mw mb mx mf mp mq mr ms bi translated"><code class="fe mg mh mi mj b">StandardScaler()</code> —移除平均值并缩放至方差。这个定标器对应于经典的标准化过程。</li><li id="6c3d" class="mk ml iw lm b ln mt lq mu lt mv lx mw mb mx mf mp mq mr ms bi translated"><code class="fe mg mh mi mj b">Normalizer()</code> —将每个值标准化为单位定额。</li></ul><p id="aaab" class="pw-post-body-paragraph lk ll iw lm b ln lo kg lp lq lr kj ls lt lu lv lw lx ly lz ma mb mc md me mf ip bi translated">为了使用whatever scaler，您应该首先实例化一个对象，例如:</p><pre class="kv kw kx ky gu ny mj nz oa aw ob bi"><span id="0a14" class="oc mz iw mj b gz od oe l of og">scaler = StandardScaler()</span></pre><p id="53bf" class="pw-post-body-paragraph lk ll iw lm b ln lo kg lp lq lr kj ls lt lu lv lw lx ly lz ma mb mc md me mf ip bi translated">然后你必须用所有可用的数据来拟合它:</p><pre class="kv kw kx ky gu ny mj nz oa aw ob bi"><span id="9f04" class="oc mz iw mj b gz od oe l of og">scaler.fit(data)</span></pre><p id="69a7" class="pw-post-body-paragraph lk ll iw lm b ln lo kg lp lq lr kj ls lt lu lv lw lx ly lz ma mb mc md me mf ip bi translated">最后，您可以将缩放器仅应用于感兴趣的数据(也可能包括所有数据)。数据集):</p><pre class="kv kw kx ky gu ny mj nz oa aw ob bi"><span id="a4b1" class="oc mz iw mj b gz od oe l of og">scaled_data = scaler.transform(subset_of_data)</span></pre><p id="02e5" class="pw-post-body-paragraph lk ll iw lm b ln lo kg lp lq lr kj ls lt lu lv lw lx ly lz ma mb mc md me mf ip bi translated">或者，您可以用一个函数同时应用拟合和变换:</p><pre class="kv kw kx ky gu ny mj nz oa aw ob bi"><span id="3e34" class="oc mz iw mj b gz od oe l of og">scaled_data = scaler.fit_transform(data)</span></pre><p id="39cb" class="pw-post-body-paragraph lk ll iw lm b ln lo kg lp lq lr kj ls lt lu lv lw lx ly lz ma mb mc md me mf ip bi translated">你可以在我之前的文章中读到一个关于<code class="fe mg mh mi mj b">MinMaxScaler()</code>和<code class="fe mg mh mi mj b">MaxAbsScaler</code>的实际例子，标题是<a class="ae nx" rel="noopener" target="_blank" href="/data-normalization-with-python-scikit-learn-e9c5640fed58">使用Python scikit进行数据规范化-学习</a>。</p></div><div class="ab cl oh oi ia oj" role="separator"><span class="ok bw bk ol om on"/><span class="ok bw bk ol om on"/><span class="ok bw bk ol om"/></div><div class="ip iq ir is it"><p id="6024" class="pw-post-body-paragraph lk ll iw lm b ln lo kg lp lq lr kj ls lt lu lv lw lx ly lz ma mb mc md me mf ip bi translated">除了所描述的类之外，Scikit-learn还提供了一些用于特征缩放的函数，这些函数可以直接在固定数组上使用，而无需拟合过程:</p><ul class=""><li id="db97" class="mk ml iw lm b ln lo lq lr lt mm lx mn mb mo mf mp mq mr ms bi translated"><code class="fe mg mh mi mj b">maxabs_scale()</code></li><li id="961a" class="mk ml iw lm b ln mt lq mu lt mv lx mw mb mx mf mp mq mr ms bi translated"><code class="fe mg mh mi mj b"><a class="ae nx" href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.minmax_scale.html#sklearn.preprocessing.minmax_scale" rel="noopener ugc nofollow" target="_blank">minmax_scale</a>()</code></li><li id="2c69" class="mk ml iw lm b ln mt lq mu lt mv lx mw mb mx mf mp mq mr ms bi translated"><code class="fe mg mh mi mj b">normalize()</code></li><li id="48bf" class="mk ml iw lm b ln mt lq mu lt mv lx mw mb mx mf mp mq mr ms bi translated"><code class="fe mg mh mi mj b">robust_scale()</code></li><li id="4259" class="mk ml iw lm b ln mt lq mu lt mv lx mw mb mx mf mp mq mr ms bi translated"><code class="fe mg mh mi mj b">scale()</code></li></ul><h1 id="edc5" class="my mz iw bd na nb nc nd ne nf ng nh ni kl nj km nk ko nl kp nm kr nn ks no np bi translated">2特征二值化</h1><p id="5527" class="pw-post-body-paragraph lk ll iw lm b ln nq kg lp lq nr kj ls lt ns lv lw lx nt lz ma mb nu md me mf ip bi translated">特征二值化阈值数字特征获取布尔值，存储为0或1。</p><p id="fb11" class="pw-post-body-paragraph lk ll iw lm b ln lo kg lp lq lr kj ls lt lu lv lw lx ly lz ma mb mc md me mf ip bi translated">Scikit-learn为二进制化提供了许多类:</p><ul class=""><li id="4408" class="mk ml iw lm b ln lo lq lr lt mm lx mn mb mo mf mp mq mr ms bi translated"><code class="fe mg mh mi mj b">Binarizer()</code> —根据阈值将特征值设置为0或1。大于阈值的值设置为1，小于或等于阈值的值设置为0。</li><li id="38a1" class="mk ml iw lm b ln mt lq mu lt mv lx mw mb mx mf mp mq mr ms bi translated"><code class="fe mg mh mi mj b">LabelBinarizer()</code> —对于每个输出标签，构建一个向量，其中元素的数量等于唯一标签的数量，然后根据向量的每个元素在哪个标签中，为其分配1或0。这个类与<code class="fe mg mh mi mj b">OneHotEncoder()</code>非常相似，区别在于<code class="fe mg mh mi mj b">LabelBinarizer()</code>用于输出类，而OneHotEncoder用于输入特性。更多细节，你可以在Stackoverflow上阅读<a class="ae nx" href="https://stackoverflow.com/questions/50473381/scikit-learns-labelbinarizer-vs-onehotencoder" rel="noopener ugc nofollow" target="_blank">这个线程</a>。</li><li id="b169" class="mk ml iw lm b ln mt lq mu lt mv lx mw mb mx mf mp mq mr ms bi translated"><code class="fe mg mh mi mj b">MultilabelBinarizer()</code>—<code class="fe mg mh mi mj b">LabelBinarizer()</code>的扩展，支持多标签。</li></ul><p id="d839" class="pw-post-body-paragraph lk ll iw lm b ln lo kg lp lq lr kj ls lt lu lv lw lx ly lz ma mb mc md me mf ip bi translated">类似于缩放器，二进制化器也应该首先被实例化，然后被拟合，最后被应用于数据:</p><pre class="kv kw kx ky gu ny mj nz oa aw ob bi"><span id="eae6" class="oc mz iw mj b gz od oe l of og">binarizer = Binarizer()<br/>binarizer.fit(data)<br/>binarized_data = binarizer.transform(new_data)</span></pre><p id="0a1d" class="pw-post-body-paragraph lk ll iw lm b ln lo kg lp lq lr kj ls lt lu lv lw lx ly lz ma mb mc md me mf ip bi translated">或者:</p><pre class="kv kw kx ky gu ny mj nz oa aw ob bi"><span id="8500" class="oc mz iw mj b gz od oe l of og">binarizer = Binarizer()<br/>data = binarizer.fit_transform(data)</span></pre><p id="883f" class="pw-post-body-paragraph lk ll iw lm b ln lo kg lp lq lr kj ls lt lu lv lw lx ly lz ma mb mc md me mf ip bi translated">Scikit-learn还为二进制化提供了有用的函数，当元素数量固定时可以使用:</p><ul class=""><li id="ce8a" class="mk ml iw lm b ln lo lq lr lt mm lx mn mb mo mf mp mq mr ms bi translated"><code class="fe mg mh mi mj b">binarize()</code></li><li id="d853" class="mk ml iw lm b ln mt lq mu lt mv lx mw mb mx mf mp mq mr ms bi translated"><code class="fe mg mh mi mj b">label_binarize()</code></li></ul><p id="e8f9" class="pw-post-body-paragraph lk ll iw lm b ln lo kg lp lq lr kj ls lt lu lv lw lx ly lz ma mb mc md me mf ip bi translated">正如已经说过的特征缩放，请提醒保存安装的二进制化器，因为它将在模型部署期间使用。</p><h1 id="4dfe" class="my mz iw bd na nb nc nd ne nf ng nh ni kl nj km nk ko nl kp nm kr nn ks no np bi translated">3特征编码</h1><p id="c385" class="pw-post-body-paragraph lk ll iw lm b ln nq kg lp lq nr kj ls lt ns lv lw lx nt lz ma mb nu md me mf ip bi translated">在模型能够被拟合和评估之前，分类特征必须被转换成数字。特征编码就是这种转换。</p><p id="badc" class="pw-post-body-paragraph lk ll iw lm b ln lo kg lp lq lr kj ls lt lu lv lw lx ly lz ma mb mc md me mf ip bi translated">Scikit-learn为特征编码提供了不同的类:</p><ul class=""><li id="e6c2" class="mk ml iw lm b ln lo lq lr lt mm lx mn mb mo mf mp mq mr ms bi translated"><code class="fe mg mh mi mj b">LabelEncoder()</code> —用介于0和类别总数减1之间的值对输出标签进行编码。</li><li id="6eb9" class="mk ml iw lm b ln mt lq mu lt mv lx mw mb mx mf mp mq mr ms bi translated"><code class="fe mg mh mi mj b">OneHotEncoder()</code>-对于每个输入分类特征，构建一个向量，其中元素的数量等于唯一标签的数量，然后根据向量的每个元素在哪个标签中，为其分配1或0。</li><li id="371a" class="mk ml iw lm b ln mt lq mu lt mv lx mw mb mx mf mp mq mr ms bi translated"><code class="fe mg mh mi mj b">OrdinalEncoder()</code> —每个唯一的类别值被分配一个整数值。然后，每个输入分类特征值被转换成一个数字，对应于相对类别。比如，“<em class="oo">苹果</em>”是1，“<em class="oo">橘子</em>”是2，“<em class="oo">甜瓜</em>”是3。</li></ul><p id="e9cf" class="pw-post-body-paragraph lk ll iw lm b ln lo kg lp lq lr kj ls lt lu lv lw lx ly lz ma mb mc md me mf ip bi translated">每个编码的使用与前面的操作非常相似。因此，实例化所选的编码器，然后用分类数据对其进行拟合和转换就足够了。</p><h1 id="ee62" class="my mz iw bd na nb nc nd ne nf ng nh ni kl nj km nk ko nl kp nm kr nn ks no np bi translated">4非线性变换</h1><p id="b2a4" class="pw-post-body-paragraph lk ll iw lm b ln nq kg lp lq nr kj ls lt ns lv lw lx nt lz ma mb nu md me mf ip bi translated">Scikit-learn还为非线性转换提供了一些有趣的类:</p><ul class=""><li id="43f1" class="mk ml iw lm b ln lo lq lr lt mm lx mn mb mo mf mp mq mr ms bi translated"><code class="fe mg mh mi mj b">PowerTransformer()</code> —应用幂变换使特征更像高斯。这对于建模需要数据正态性的情况很有用。</li><li id="9110" class="mk ml iw lm b ln mt lq mu lt mv lx mw mb mx mf mp mq mr ms bi translated"><code class="fe mg mh mi mj b">QuantileTransformer()</code>-变换特征以遵循均匀分布或正态分布。这是通过利用分位数信息来实现的。</li><li id="b8bd" class="mk ml iw lm b ln mt lq mu lt mv lx mw mb mx mf mp mq mr ms bi translated"><code class="fe mg mh mi mj b">SplineTransformer()</code> —基于单变量B样条函数生成新的特征矩阵。</li><li id="5baa" class="mk ml iw lm b ln mt lq mu lt mv lx mw mb mx mf mp mq mr ms bi translated"><code class="fe mg mh mi mj b">FunctionTransformer()</code> —应用自定义变换。</li></ul><p id="0f53" class="pw-post-body-paragraph lk ll iw lm b ln lo kg lp lq lr kj ls lt lu lv lw lx ly lz ma mb mc md me mf ip bi translated">每个转换器必须首先被实例化，然后用数据拟合，最后通过<code class="fe mg mh mi mj b">transform()</code>函数使用。</p><p id="44b4" class="pw-post-body-paragraph lk ll iw lm b ln lo kg lp lq lr kj ls lt lu lv lw lx ly lz ma mb mc md me mf ip bi translated">如果元素的数量是固定的，也可以直接通过以下函数进行变换，而无需任何拟合:</p><ul class=""><li id="f74e" class="mk ml iw lm b ln lo lq lr lt mm lx mn mb mo mf mp mq mr ms bi translated"><code class="fe mg mh mi mj b">quantile_transform()</code></li><li id="2a65" class="mk ml iw lm b ln mt lq mu lt mv lx mw mb mx mf mp mq mr ms bi translated"><code class="fe mg mh mi mj b">power_transform()</code></li></ul><h1 id="2afd" class="my mz iw bd na nb nc nd ne nf ng nh ni kl nj km nk ko nl kp nm kr nn ks no np bi translated">5其他</h1><p id="ce74" class="pw-post-body-paragraph lk ll iw lm b ln nq kg lp lq nr kj ls lt ns lv lw lx nt lz ma mb nu md me mf ip bi translated"><code class="fe mg mh mi mj b">preprocessing</code>包还包括以下类:</p><ul class=""><li id="269d" class="mk ml iw lm b ln lo lq lr lt mm lx mn mb mo mf mp mq mr ms bi translated"><code class="fe mg mh mi mj b">KBinsDiscretizer()</code> —将连续数据归入区间。</li><li id="8cf6" class="mk ml iw lm b ln mt lq mu lt mv lx mw mb mx mf mp mq mr ms bi translated"><code class="fe mg mh mi mj b">KernelCenterer()</code> —将内核矩阵居中。</li><li id="d4c0" class="mk ml iw lm b ln mt lq mu lt mv lx mw mb mx mf mp mq mr ms bi translated"><code class="fe mg mh mi mj b">PolynomialFeatures()</code> —生成一个新的特征矩阵，该矩阵包含所有次数小于或等于指定次数的特征的多项式组合。</li></ul><p id="e5ca" class="pw-post-body-paragraph lk ll iw lm b ln lo kg lp lq lr kj ls lt lu lv lw lx ly lz ma mb mc md me mf ip bi translated">还有一个有趣的功能:</p><ul class=""><li id="be71" class="mk ml iw lm b ln lo lq lr lt mm lx mn mb mo mf mp mq mr ms bi translated"><code class="fe mg mh mi mj b">add_dummy_feature()</code>-用虚拟输入特征扩充数据集。</li></ul><h1 id="05ed" class="my mz iw bd na nb nc nd ne nf ng nh ni kl nj km nk ko nl kp nm kr nn ks no np bi translated">摘要</h1><p id="8df5" class="pw-post-body-paragraph lk ll iw lm b ln nq kg lp lq nr kj ls lt ns lv lw lx nt lz ma mb nu md me mf ip bi translated">在本文中，我描述了Scikit-learn <code class="fe mg mh mi mj b">preprocessing</code>包的概述。许多操作和变换可应用于数据集，包括输入要素和输出类，包括要素缩放、要素二值化、要素编码、非线性变换和其他操作。要了解更多信息，你可以阅读预处理包上的官方<a class="ae nx" href="https://scikit-learn.org/stable/modules/classes.html#module-sklearn.preprocessing" rel="noopener ugc nofollow" target="_blank"> Scikit-learn文档</a>。</p><p id="c583" class="pw-post-body-paragraph lk ll iw lm b ln lo kg lp lq lr kj ls lt lu lv lw lx ly lz ma mb mc md me mf ip bi translated">如果你想发现Scikit-learn提供的其他类和函数，可以<a class="ae nx" href="https://alod83.medium.com/" rel="noopener">关注我</a>，<a class="ae nx" href="https://alod83.medium.com/subscribe" rel="noopener">订阅我的邮件列表</a>敬请关注。</p><p id="6f6a" class="pw-post-body-paragraph lk ll iw lm b ln lo kg lp lq lr kj ls lt lu lv lw lx ly lz ma mb mc md me mf ip bi translated">如果你已经走了这么远来阅读，对我来说今天已经很多了。谢谢！你可以在<a class="ae nx" href="https://alod83.medium.com/which-topics-would-you-like-to-read-c68314dc6813" rel="noopener">这篇文章</a>里读到更多关于我的内容。</p><h1 id="af7d" class="my mz iw bd na nb nc nd ne nf ng nh ni kl nj km nk ko nl kp nm kr nn ks no np bi translated">你愿意支持我的研究吗？</h1><p id="8afc" class="pw-post-body-paragraph lk ll iw lm b ln nq kg lp lq nr kj ls lt ns lv lw lx nt lz ma mb nu md me mf ip bi translated">你可以每月订阅几美元，解锁无限的文章。</p><h1 id="4f31" class="my mz iw bd na nb nc nd ne nf ng nh ni kl nj km nk ko nl kp nm kr nn ks no np bi translated">奖金</h1><p id="459a" class="pw-post-body-paragraph lk ll iw lm b ln nq kg lp lq nr kj ls lt ns lv lw lx nt lz ma mb nu md me mf ip bi translated"><strong class="lm jg">提醒将拟合的预处理操作保存到一个外部文件</strong>，因为当您部署模型时，您需要将处理过程中使用的同一scaler应用到新数据:</p><pre class="kv kw kx ky gu ny mj nz oa aw ob bi"><span id="1bb8" class="oc mz iw mj b gz od oe l of og">from sklearn.externals import joblib</span><span id="f234" class="oc mz iw mj b gz op oe l of og">joblib.dump(prep, 'prep.pkl')</span></pre><p id="6832" class="pw-post-body-paragraph lk ll iw lm b ln lo kg lp lq lr kj ls lt lu lv lw lx ly lz ma mb mc md me mf ip bi translated">然后，要从文件中打开scaler，您可以执行以下代码:</p><pre class="kv kw kx ky gu ny mj nz oa aw ob bi"><span id="c675" class="oc mz iw mj b gz od oe l of og">prep = joblib.load('prep.pkl')</span></pre><h1 id="c9a0" class="my mz iw bd na nb nc nd ne nf ng nh ni kl nj km nk ko nl kp nm kr nn ks no np bi translated">相关文章</h1><div class="oq or gq gs os ot"><a rel="noopener follow" target="_blank" href="/machine-learning-getting-started-with-the-k-neighbours-classifier-d7e6b25f2b09"><div class="ou ab fp"><div class="ov ab ow cl cj ox"><h2 class="bd jg gz z fq oy fs ft oz fv fx jf bi translated">机器学习:K近邻分类器入门</h2><div class="pa l"><h3 class="bd b gz z fq oy fs ft oz fv fx dk translated">一个Python的现成代码，实现了scikit-learn中的K-neighbors分类器，从数据预处理到…</h3></div><div class="pb l"><p class="bd b dl z fq oy fs ft oz fv fx dk translated">towardsdatascience.com</p></div></div><div class="pc l"><div class="pd l pe pf pg pc ph le ot"/></div></div></a></div><div class="oq or gq gs os ot"><a rel="noopener follow" target="_blank" href="/how-to-check-if-a-classification-model-is-overfitted-using-scikit-learn-148b6b19af8b"><div class="ou ab fp"><div class="ov ab ow cl cj ox"><h2 class="bd jg gz z fq oy fs ft oz fv fx jf bi translated">如何使用scikit-learn检查分类模型是否过度拟合</h2><div class="pb l"><p class="bd b dl z fq oy fs ft oz fv fx dk translated">towardsdatascience.com</p></div></div><div class="pc l"><div class="pi l pe pf pg pc ph le ot"/></div></div></a></div><div class="oq or gq gs os ot"><a rel="noopener follow" target="_blank" href="/a-complete-data-analysis-workflow-in-python-and-scikit-learn-9a77f7c283d3"><div class="ou ab fp"><div class="ov ab ow cl cj ox"><h2 class="bd jg gz z fq oy fs ft oz fv fx jf bi translated">Python和scikit中的完整数据分析工作流程-学习</h2><div class="pb l"><p class="bd b dl z fq oy fs ft oz fv fx dk translated">towardsdatascience.com</p></div></div><div class="pc l"><div class="pj l pe pf pg pc ph le ot"/></div></div></a></div><div class="oq or gq gs os ot"><a rel="noopener follow" target="_blank" href="/understanding-the-n-jobs-parameter-to-speedup-scikit-learn-classification-26e3d1220c28"><div class="ou ab fp"><div class="ov ab ow cl cj ox"><h2 class="bd jg gz z fq oy fs ft oz fv fx jf bi translated">了解n_jobs参数以加速scikit-learn分类</h2><div class="pa l"><h3 class="bd b gz z fq oy fs ft oz fv fx dk translated">一个现成的代码，演示了如何使用n_jobs参数来减少训练时间</h3></div><div class="pb l"><p class="bd b dl z fq oy fs ft oz fv fx dk translated">towardsdatascience.com</p></div></div><div class="pc l"><div class="pk l pe pf pg pc ph le ot"/></div></div></a></div></div></div>    
</body>
</html>