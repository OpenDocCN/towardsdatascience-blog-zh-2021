<html>
<head>
<title>How to Collect Text Information from Images with Python &amp; Tesseract</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用Python &amp; Tesseract从图像中收集文本信息</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-collect-text-information-from-images-with-python-tesseract-7073785b1d77?source=collection_archive---------5-----------------------#2021-05-08">https://towardsdatascience.com/how-to-collect-text-information-from-images-with-python-tesseract-7073785b1d77?source=collection_archive---------5-----------------------#2021-05-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="541e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">一个从公寓平面图中自动收集房间尺寸的脚本…或者至少它尝试了</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/73ee90945cb300abf3c9968f2119161f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hPODlxoi5o6N_95AfypAOQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="1795" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你有分析思维，并且曾经进行过虚拟找房之旅，你可能会遇到我个人一直觉得令人恼火的问题:你几乎永远无法通过房产大小进行搜索，更不用说通过单个房间的大小了。然而，这种信息经常以平面布置图的形式出现。只是大量的缩放和手动输入来收集数据…</p><p id="8ab8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">嗯，我认为这将是一个练习图像识别技能和创建一个脚本的绝佳机会，该脚本可以将图像转换成一个漂亮而干净的数据表。毕竟，随着每个过于雄心勃勃的项目开始:</p><blockquote class="lu"><p id="c705" class="lv lw it bd lx ly lz ma mb mc md lt dk translated">能有多难？</p></blockquote><p id="cebd" class="pw-post-body-paragraph ky kz it la b lb me ju ld le mf jx lg lh mg lj lk ll mh ln lo lp mi lr ls lt im bi translated">事实证明，相当困难。我其实并不确定这是一个可以100%准确解决的问题。我认为我充分探索了各种可能性，并取得了良好的进展，但请注意<strong class="la iu">这个项目不会完全成功</strong>。即使经过重大的调整和微调，一个特别棘手或质量差的图像可能会使算法出错。</p><p id="94c8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然而，我认为对于像我一样抱着天真的期望开始类似项目的人来说，这是一个宝贵的教训。</p><h1 id="4637" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">摘要</h1><p id="78c3" class="pw-post-body-paragraph ky kz it la b lb nb ju ld le nc jx lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">最后，我们希望将平面图转换成显示房间和房间大小的表格。我们正在使用米，但调整代码应该很简单，这样它也可以识别英尺的度量。</p><p id="526b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们将使用<a class="ae ng" href="https://pypi.org/project/pytesseract/" rel="noopener ugc nofollow" target="_blank">的pytesseract </a>，它是<a class="ae ng" href="https://opensource.google/projects/tesseract" rel="noopener ugc nofollow" target="_blank">谷歌的Tesseract OCR </a>的Python包装器。</p><p id="9b5a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">该项目的代码在我的<a class="ae ng" href="https://github.com/MatePocs/floorplan_reader" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上。</p><ul class=""><li id="db38" class="nh ni it la b lb lc le lf lh nj ll nk lp nl lt nm nn no np bi translated">如果你只是想自己尝试一下，你将需要<a class="ae ng" href="https://github.com/MatePocs/floorplan_reader/blob/main/floorplan_reader.py" rel="noopener ugc nofollow" target="_blank"><em class="nq">floor plan _ reader</em></a>脚本。您将需要安装软件包和Tesseract，另外您可能需要调整它在脚本中的位置。<a class="ae ng" href="https://github.com/MatePocs/floorplan_reader/blob/main/main.ipynb" rel="noopener ugc nofollow" target="_blank"> <em class="nq">主</em> </a> Jupyter笔记本显示了如何使用代码。祝你好运！</li><li id="75da" class="nh ni it la b lb nr le ns lh nt ll nu lp nv lt nm nn no np bi translated">如果您想继续学习，请继续下一节，在这里我们将设置环境。</li></ul><h1 id="9644" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">环境</h1><h2 id="39f7" class="nw mk it bd ml nx ny dn mp nz oa dp mt lh ob oc mv ll od oe mx lp of og mz oh bi translated">宇宙魔方</h2><p id="d920" class="pw-post-body-paragraph ky kz it la b lb nb ju ld le nc jx lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">首先，我们需要宇宙魔方包本身，即使我们不直接使用它。安装过程并不简单，你也可以在官方的<a class="ae ng" href="https://github.com/tesseract-ocr/tessdoc/blob/master/Installation.md" rel="noopener ugc nofollow" target="_blank"> GitHub页面</a>找到更多信息，但是我发现<a class="ae ng" href="https://guides.library.illinois.edu/c.php?g=347520&amp;p=4121425" rel="noopener ugc nofollow" target="_blank">这个摘要</a>更有用。</p><p id="dafd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在Mac上，安装自制软件非常简单:</p><pre class="kj kk kl km gt oi oj ok ol aw om bi"><span id="f38a" class="nw mk it oj b gy on oo l op oq">brew install tesseract</span></pre><p id="9ee0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您还需要Tesseract的位置，我跟踪了这个<a class="ae ng" href="https://stackoverflow.com/questions/55235369/where-is-the-tesseract-executable-file-located-on-macos-and-how-to-define-it-in" rel="noopener ugc nofollow" target="_blank">堆栈溢出线程</a>，我的安装位置是:</p><pre class="kj kk kl km gt oi oj ok ol aw om bi"><span id="2c86" class="nw mk it oj b gy on oo l op oq">/usr/local/bin/tesseract</span></pre><p id="de2f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">(当然，不同系统的位置不同。)</p><h2 id="2cef" class="nw mk it bd ml nx ny dn mp nz oa dp mt lh ob oc mv ll od oe mx lp of og mz oh bi translated">Python包</h2><p id="0578" class="pw-post-body-paragraph ky kz it la b lb nb ju ld le nc jx lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">我们需要两个“非标准”包:<a class="ae ng" href="https://pypi.org/project/Pillow/" rel="noopener ugc nofollow" target="_blank">枕头</a>和<a class="ae ng" href="https://pypi.org/project/pytesseract/" rel="noopener ugc nofollow" target="_blank">宇宙魔方</a>:</p><pre class="kj kk kl km gt oi oj ok ol aw om bi"><span id="f59c" class="nw mk it oj b gy on oo l op oq">pip install Pillow</span><span id="1e79" class="nw mk it oj b gy or oo l op oq">pip install pytesseract</span></pre><p id="45b0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Pillow是一个处理图像的包，是一个名为PIL的旧包的分支，我们将使用它的图像对象:</p><pre class="kj kk kl km gt oi oj ok ol aw om bi"><span id="958a" class="nw mk it oj b gy on oo l op oq">from PIL import Image</span></pre><p id="00a9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">(是的，这个库在项目内部仍然被称为PIL，这并不意味着我们使用了过时的PIL包。)</p><p id="7321" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于宇宙魔方，我们需要连接到它的位置:</p><pre class="kj kk kl km gt oi oj ok ol aw om bi"><span id="800f" class="nw mk it oj b gy on oo l op oq">import pytesseract<br/>pytesseract.pytesseract.tesseract_cmd = r'/usr/local/bin/tesseract'</span></pre><h1 id="e444" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">从错误中学习</h1><p id="8bbf" class="pw-post-body-paragraph ky kz it la b lb nb ju ld le nc jx lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">我将向你介绍我在开始使用pytesseract时犯的四个业余错误。如果你更喜欢"<em class="nq">这是目的地，而不是旅程。</em>“种人，跳过这一点，我们在下一节开始看实际代码。</p><h2 id="51f9" class="nw mk it bd ml nx ny dn mp nz oa dp mt lh ob oc mv ll od oe mx lp of og mz oh bi translated">文件路径与图像</h2><p id="21d1" class="pw-post-body-paragraph ky kz it la b lb nb ju ld le nc jx lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">如果您从pytesseract开始，您尝试的第一件事可能是<code class="fe os ot ou oj b">image_to_string</code>函数。顾名思义，它确实如此。</p><p id="c163" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您可以将图像或文件路径作为参数传递。然而，根据我的经验，首先处理图像总是更好。用枕头，用它打开图片，传递图像对象。<strong class="la iu"> </strong>考虑这个平面布置图示例:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ov"><img src="../Images/acab00301819666abd7593edc878e9bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jWkC3M-bPAwBhC-JYmWOYQ.png"/></div></div></figure><p id="97ed" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我们直接用pytesseract打开:</p><pre class="kj kk kl km gt oi oj ok ol aw om bi"><span id="c30c" class="nw mk it oj b gy on oo l op oq">pytesseract.image_to_string(‘plans/floorplan_02.png’)</span></pre><p id="e9e3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是我们得到的结果:</p><pre class="kj kk kl km gt oi oj ok ol aw om bi"><span id="6307" class="nw mk it oj b gy on oo l op oq">'KITCHENIDINER — MASTER BEDROOM\ngo" xis" Tatra hou" xara\nPi\n\n3.14m x 2.95m\n\nSITTING ROOM\n12\'1" x 15\'7"\n3.69m x 4.74m\n\nBEDROOM 2\n8\'1" x 12\'0"\n2.47m x 3.66m\nBEDROOM 3\n71" x 85"\n2.17m x 2.56m\n\n \n\x0c'</span></pre><p id="0a4c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">而如果我们先用枕头打开:</p><pre class="kj kk kl km gt oi oj ok ol aw om bi"><span id="c3bb" class="nw mk it oj b gy on oo l op oq">pytesseract.image_to_string(Image.open('plans/floorplan_02.png'))</span></pre><p id="24df" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是我们得到的结果:</p><pre class="kj kk kl km gt oi oj ok ol aw om bi"><span id="a292" class="nw mk it oj b gy on oo l op oq">'KITCHEN/DINER\n15°7" x 11\'8"\n4.74m x 3.55m\n\nSITTING ROOM\n12\'1" x 15\'7"\n3.69m x 4.74m\n\n \n\n \n\n \n\n \n\n \n\n \n\nMASTER BEDROOM\n10\'4" x 9\'8"\n3.14m x 2.95m\n\nBEDROOM 2\n8\'1" x 12\'0"\n2.47m x 3.66m\n\nBEDROOM 3\n71" x 85"\n2.17m x 2.56m\n\n \n\x0c'</span></pre><p id="5a93" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">是的，你的眼睛没有欺骗你，那是一个完整的额外线！那以后会派上用场的。</p><blockquote class="ow ox oy"><p id="1df8" class="ky kz nq la b lb lc ju ld le lf jx lg oz li lj lk pa lm ln lo pb lq lr ls lt im bi translated"><strong class="la iu"> <em class="it">第一课</em> </strong> <em class="it">。:在将任何东西传递给pytesseract之前，始终使用Pillow之类的图像处理包。将图像对象作为参数传递，而不是文件路径。</em></p></blockquote><h2 id="8f12" class="nw mk it bd ml nx ny dn mp nz oa dp mt lh ob oc mv ll od oe mx lp of og mz oh bi translated">调整大小很重要</h2><p id="5d1e" class="pw-post-body-paragraph ky kz it la b lb nb ju ld le nc jx lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">下一个令人惊讶的是关于调整大小。考虑下面的图像(模糊，是的，这将是重点。):</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pc"><img src="../Images/7a0d742c7fd6ac055a69a70282c25c19.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mEo4nAmHcgkB55g324a16Q.jpeg"/></div></div></figure><p id="d8a8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您只是将它作为一个枕头图像读入，并将其传递给image_to_string，您会得到以下结果:</p><pre class="kj kk kl km gt oi oj ok ol aw om bi"><span id="0b1c" class="nw mk it oj b gy on oo l op oq">' \n    \n   \n\nUTILITY ROOM\n\n  \n  \n  \n\n  \n \n\n  \n\n       \n   \n    \n\n  <br/>...</span></pre><p id="211c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是，如果您首先调整图像的大小，比如说将其宽度和高度调整为原来的5倍:</p><pre class="kj kk kl km gt oi oj ok ol aw om bi"><span id="8204" class="nw mk it oj b gy on oo l op oq">image = image.resize((image.size[0] * 5, image.size[1] * 5))</span></pre><p id="1f84" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">结果是:</p><pre class="kj kk kl km gt oi oj ok ol aw om bi"><span id="ec43" class="nw mk it oj b gy on oo l op oq">'UTILITY ROOM\nR\' i\nSe 2.51m x 2.44m\n3.88m x ?2.57m\nSITTING ROOM<br/>...</span></pre><p id="cfc3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我没有复制整个结果，重点是，如果没有重新缩放，杂物间下的较小文本不会被读入。</p><p id="2e49" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你可以在这里了解更多关于枕头<a class="ae ng" href="https://auth0.com/blog/image-processing-in-python-with-pillow/" rel="noopener ugc nofollow" target="_blank">的图像处理。我个人没有调整图像亮度或对比度的运气。只有重新调整似乎工作得很好。我不知道为什么会这样。</a></p><blockquote class="ow ox oy"><p id="1935" class="ky kz nq la b lb lc ju ld le lf jx lg oz li lj lk pa lm ln lo pb lq lr ls lt im bi translated"><strong class="la iu"> <em class="it">第二课</em> </strong> <em class="it">。:利用Pillow的图像处理功能。如果您调整图像的大小，调整亮度或对比度，Tesseract会以不同的方式读入您的图像。然而，变化并不总是积极的！例如，您可能会注意到，缩放超过某个阈值会降低精度。</em></p></blockquote><h2 id="57fc" class="nw mk it bd ml nx ny dn mp nz oa dp mt lh ob oc mv ll od oe mx lp of og mz oh bi translated">裁剪也很重要…</h2><p id="aacd" class="pw-post-body-paragraph ky kz it la b lb nb ju ld le nc jx lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">…当我们这样做的时候，你对图像所做的任何其他事情都很重要！</p><p id="bf1f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我实际上对你耍了点小花招，如果你真的读了上面的图片，杂物间的第一面<code class="fe os ot ou oj b">2.51</code>，将被读为<code class="fe os ot ou oj b">2.91</code>。原因？我从原始图片中截取了主要信息。没有缩放，或以任何方式调整，只是排除了一些空白区域。没有裁剪，数字可以正确读取。</p><p id="4116" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">正是在这个时候，我第一次开始考虑接受失败…</p><blockquote class="ow ox oy"><p id="978d" class="ky kz nq la b lb lc ju ld le lf jx lg oz li lj lk pa lm ln lo pb lq lr ls lt im bi translated"><strong class="la iu"> <em class="it">第三课</em> </strong> <em class="it">。:实际上任何事情都可以改变结果。您永远无法确定字符是否被正确地读入，即使它们是用漂亮、一致的字体书写的，并且在您的人眼看来似乎没问题。宇宙魔方的算法并不适用于所有情况。</em></p></blockquote><h2 id="bc4c" class="nw mk it bd ml nx ny dn mp nz oa dp mt lh ob oc mv ll od oe mx lp of og mz oh bi translated">一张整洁有序的表格胜过一大堆杂乱的文字</h2><p id="6911" class="pw-post-body-paragraph ky kz it la b lb nb ju ld le nc jx lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">在很长一段时间里，我试图用<code class="fe os ot ou oj b">image_to_string</code>方法来强迫项目工作。如果你看一下上面的一些例子，你可能会发现我没有发现的问题。</p><p id="f00c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">问题是<code class="fe os ot ou oj b">image_to_string</code>将逐行从左到右、从上到下扫描文档。(它如何确定<em class="nq"> \n </em>的位置，谁也说不准。)我非常确定我可以让下面的逻辑工作:</p><pre class="kj kk kl km gt oi oj ok ol aw om bi"><span id="2bb6" class="nw mk it oj b gy on oo l op oq">loop over the string<br/>search for matches of pre-defined room names from a set<br/>if there is a match: <br/>    put the room name in a dictionary<br/>    delete the corresponding room from the set and the string<br/>    look for the next bit that looks like the two sides<br/>    when found, save the sides in the dictionary<br/>    delete the sides from the string</span><span id="af71" class="nw mk it oj b gy or oo l op oq">repeat the process with the shortened room name set and main string, until there is no new room found</span></pre><p id="9baa" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个想法是，房间可以彼此靠近，但第一个房间名称后从左到右和从上到下的第一个数字必须是与所讨论的房间相对应的数字...是的，我知道，但我要说的是，这招出奇的有效。</p><p id="55c2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后我终于遇到了我的克星:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pd"><img src="../Images/22b9317ce31e862c3e182ac34e795534.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AuT77e0psrgvI5jCFAuhsw.png"/></div></div></figure><p id="59ea" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我不知道为什么我以前没有想到这种可能性，但是把米放在两条不同的线上完全打乱了我以前的方法。更不用说我还没有遇到过的任何其他平面图结构。</p><p id="828e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我认为仅仅通过阅读<code class="fe os ot ou oj b">image_to_string</code>产生的连续文本是无法确定哪个尺寸属于哪个房间的。然而，通过使用<code class="fe os ot ou oj b">image_to_data</code>方法(加上一些额外的调整，我们将在下一节中看到)，我们得到了一个漂亮且有组织的表:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pe"><img src="../Images/e4a14554dfd195dc8360e88820bbb4b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8ha2nSURmfG2554qwWDSnw.png"/></div></div></figure><blockquote class="ow ox oy"><p id="8695" class="ky kz nq la b lb lc ju ld le lf jx lg oz li lj lk pa lm ln lo pb lq lr ls lt im bi translated"><strong class="la iu"> <em class="it">第四课</em> </strong> <em class="it">。:除非你有一个微不足道的问题，否则你会想用</em> <code class="fe os ot ou oj b"><em class="it">image_to_data</em></code> <em class="it">而不是</em> <code class="fe os ot ou oj b"><em class="it">image_to_string</em></code> <em class="it">。只要确保将</em> <code class="fe os ot ou oj b"><em class="it">output_type</em></code> <em class="it">参数设置为“</em> data.frame <em class="it">”就可以得到熊猫数据帧，而不是更乱更大的文本块。</em></p></blockquote><h1 id="fc5f" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">浏览代码</h1><p id="7361" class="pw-post-body-paragraph ky kz it la b lb nb ju ld le nc jx lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">在这一部分，我将带大家浏览代码。请注意，我不会完全照搬脚本，我们只讨论要点。</p><h2 id="9b73" class="nw mk it bd ml nx ny dn mp nz oa dp mt lh ob oc mv ll od oe mx lp of og mz oh bi translated">打开图像</h2><p id="e295" class="pw-post-body-paragraph ky kz it la b lb nb ju ld le nc jx lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">首先，我们需要一个方法来打开图像本身，这是我最终使用的方法:</p><pre class="kj kk kl km gt oi oj ok ol aw om bi"><span id="4f19" class="nw mk it oj b gy on oo l op oq">def <strong class="oj iu">process_image</strong>(filepath, resize_factor = 1): </span><span id="ebc3" class="nw mk it oj b gy or oo l op oq">  image = Image.open(filepath)<br/>  image = image.resize(<br/>    (image.size[0] * resize_factor, image.size[1] * resize_factor)) </span><span id="8126" class="nw mk it oj b gy or oo l op oq">  return image</span></pre><p id="6b86" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我花了很多时间试图找出一个最佳的<code class="fe os ot ou oj b">resize_factor</code>。有人会认为这与图片的像素大小有关，但显然，事实并非如此。我最终把责任抽离出来，变成了一场争论。我猜你可以对不同的<code class="fe os ot ou oj b">resize_factors</code>重复这个过程，看看你是否得到相同的结果。</p><h2 id="c177" class="nw mk it bd ml nx ny dn mp nz oa dp mt lh ob oc mv ll od oe mx lp of og mz oh bi translated">用宇宙魔方读入图像</h2><p id="4e30" class="pw-post-body-paragraph ky kz it la b lb nb ju ld le nc jx lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">这在技术上是整个代码的图像识别部分。如前所述，我们希望使用<code class="fe os ot ou oj b">image_to_data</code>。这就是如何将它转换成一个美观易读的表格:</p><pre class="kj kk kl km gt oi oj ok ol aw om bi"><span id="6598" class="nw mk it oj b gy on oo l op oq">def <strong class="oj iu">convert_floorplan_pic_to_df</strong>(filepath, resize_factor = 1):</span><span id="1d56" class="nw mk it oj b gy or oo l op oq">  image = process_image(filepath, resize_factor)</span><span id="beaf" class="nw mk it oj b gy or oo l op oq">  df = pytesseract.image_to_data(image, output_type='data.frame')<br/>  df = df[df['conf'] != -1] <br/>  df['text'] = df['text'].apply(lambda x: x.strip())<br/>  df = df[df['text']!=""]<br/>  df['text'] = df['text'].apply(lambda x: x.upper())</span><span id="7c1d" class="nw mk it oj b gy or oo l op oq">  return df</span></pre><p id="1684" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">向上滚动一点，看看这个数据帧应该是什么样子。</p><p id="8154" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们将使用其中大约一半的列。列<code class="fe os ot ou oj b">conf</code>显示了模型在其解决方案中的确定性，-1是这些奇怪的额外行，不知道它们为什么在那里，但我们肯定不需要它们。还有很多读入的空白，我们也不需要。</p><h2 id="5694" class="nw mk it bd ml nx ny dn mp nz oa dp mt lh ob oc mv ll od oe mx lp of og mz oh bi translated">识别文本部分</h2><p id="614e" class="pw-post-body-paragraph ky kz it la b lb nb ju ld le nc jx lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">我们已经有了一个图像上带有文本的数据框架，但是我们还远远没有完成，在它可用之前还有大量的处理工作。</p><p id="0cc0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们利用另外两个函数，将图像转换成包含文本信息的数据帧:</p><pre class="kj kk kl km gt oi oj ok ol aw om bi"><span id="4f77" class="nw mk it oj b gy on oo l op oq">def <strong class="oj iu">process_floorplan</strong>(<br/>    filepath, rooms_set = default_rooms_set, resize_factor = 1):</span><span id="5f88" class="nw mk it oj b gy or oo l op oq">    df = convert_floorplan_pic_to_df(filepath, resize_factor)</span></pre><p id="f04a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们想一行一行地检查这个数据帧，并决定这个字符串是房间名称、大小还是其他什么。</p><p id="e048" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">房间将从一组房间名称字符串中识别出来，默认情况下看起来像这样:</p><pre class="kj kk kl km gt oi oj ok ol aw om bi"><span id="b177" class="nw mk it oj b gy on oo l op oq">default_rooms_set = {"DINING ROOM", "KITCHEN", "LIVING ROOM",<br/>   ...<br/>}</span></pre><p id="69e5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">另一方面，使用正则表达式来识别大小。我们基本上要考虑每个浮点数，这很容易做到:</p><pre class="kj kk kl km gt oi oj ok ol aw om bi"><span id="3051" class="nw mk it oj b gy on oo l op oq">room_side_regex = r'[0-9]+[.][0-9]+'</span></pre><p id="ee7e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我们看一下<code class="fe os ot ou oj b">df</code>对象，我们会立即发现一个问题:一些房间名可能会被分成多行。(从今以后，我们假设我们从不希望搜索由两个以上部分组成的房间名。)</p><p id="11c1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我解决这个问题的方法是创建另一个名为<code class="fe os ot ou oj b">text_2row</code>的文本列，它是两行文本的串联。</p><pre class="kj kk kl km gt oi oj ok ol aw om bi"><span id="ebc2" class="nw mk it oj b gy on oo l op oq">shifted_text_col = list(df['text'].iloc[1:])<br/>shifted_text_col.append("")<br/>df['text_2row'] = df['text'] + " " + shifted_text_col</span></pre><p id="aa1c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在我们可以循环了。这里不打算复制代码，再次请参考我的<a class="ae ng" href="https://github.com/MatePocs/floorplan_reader/blob/main/floorplan_reader.py" rel="noopener ugc nofollow" target="_blank"> GitHub </a>。逻辑如下:</p><pre class="kj kk kl km gt oi oj ok ol aw om bi"><span id="b709" class="nw mk it oj b gy on oo l op oq">for each row in the DataFrame: <br/>  if the text_2rows matches one of the rooms<br/>    the current row gets a room id<br/>    go to next in loop, skip an extra line<br/>  if not match so far<br/>    if text column matches one of the rooms<br/>      current row gets a room id<br/>      go to next in loop<br/>  if no match so far<br/>    if text column matches the size regex<br/>      current row gets a room_side id<br/>      go to next in loop<br/>  if still no match<br/>    current row gets no id<br/>    go to next in loop</span></pre><p id="c1b7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在大小匹配中有一个假设:如果行中有多个浮点数，我们总是取第一个浮点数。所以如果这个列表的长度大于0:</p><pre class="kj kk kl km gt oi oj ok ol aw om bi"><span id="8f72" class="nw mk it oj b gy on oo l op oq">regex_list = re.findall(room_side_regex,df[‘text’].iloc[i])</span></pre><p id="b288" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们取第一个元素:</p><pre class="kj kk kl km gt oi oj ok ol aw om bi"><span id="1a2f" class="nw mk it oj b gy on oo l op oq">df['side_number'].iloc[i] = float(regex_list[0])</span></pre><p id="7b9b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">经过一些清理后，我将数据帧分成两个较小的数据帧。两者都包含被确定为<code class="fe os ot ou oj b">room</code>或<code class="fe os ot ou oj b">room_side</code>的行的<code class="fe os ot ou oj b">left</code>、<code class="fe os ot ou oj b">top</code>和<code class="fe os ot ou oj b">value</code>列。这是我们的房间:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pf"><img src="../Images/7568b67fbdfe3306fba5d2fe3c1c5c71.png" data-original-src="https://miro.medium.com/v2/resize:fit:488/format:webp/1*5d0i75PB-t1XxLuMTAx42g.png"/></div></figure><p id="5ab4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们有一个类似的边表，数字在<code class="fe os ot ou oj b">value</code>列。</p><h2 id="e389" class="nw mk it bd ml nx ny dn mp nz oa dp mt lh ob oc mv ll od oe mx lp of og mz oh bi translated">搭配带侧边的房间</h2><p id="9a6f" class="pw-post-body-paragraph ky kz it la b lb nb ju ld le nc jx lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">我们已经从文本中获得了所有需要的信息，我们现在只需要匹配它们。</p><p id="6fd0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">有许多不同的方法可以解决这个问题。注意，当我们用<code class="fe os ot ou oj b">image_to_data</code>创建原始DataFrame时，pytesseract会放入一些有用的信息。例如，我们有一个<code class="fe os ot ou oj b">block</code>列，它将文本排列成簇。</p><p id="4f6a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我最终使用了<code class="fe os ot ou oj b">left</code>和<code class="fe os ot ou oj b">top</code>列，它们应该是包含文本的框的位置，从图像的左上角开始计算。我们将计算这些左上角的欧几里德距离，并为每个房间选择两个最接近的数字。这种方法有一些缺点，我们将很快回到它。</p><p id="fce4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们将使用<code class="fe os ot ou oj b">scipy</code>中的<code class="fe os ot ou oj b">distance_matrix</code>方法:</p><pre class="kj kk kl km gt oi oj ok ol aw om bi"><span id="a3e0" class="nw mk it oj b gy on oo l op oq">from scipy.spatial import distance_matrix</span><span id="b58a" class="nw mk it oj b gy or oo l op oq">dist = distance_matrix(<br/>  df_rooms[['left', 'top']], <br/>  df_sides[['left', 'top']])</span></pre><p id="eced" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后这只是一个为每个房间选择两个最近点的练习。我们依赖于<code class="fe os ot ou oj b">numpy</code>的<code class="fe os ot ou oj b">argpartition</code>方法，同样，代码在我的<a class="ae ng" href="https://github.com/MatePocs/floorplan_reader/blob/main/floorplan_reader.py" rel="noopener ugc nofollow" target="_blank"> GitHub </a>中。</p><h2 id="aa70" class="nw mk it bd ml nx ny dn mp nz oa dp mt lh ob oc mv ll od oe mx lp of og mz oh bi translated">最终确定</h2><p id="05a0" class="pw-post-body-paragraph ky kz it la b lb nb ju ld le nc jx lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">经过一些格式化之后，我们终于得到了我们的最终产品:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pg"><img src="../Images/5cc8e611d78fa52658f95930cd20d55f.png" data-original-src="https://miro.medium.com/v2/resize:fit:614/format:webp/1*imuYfuJXUCrMZlzVTFecxQ.png"/></div></figure><h1 id="431c" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">成功了吗？</h1><p id="c152" class="pw-post-body-paragraph ky kz it la b lb nb ju ld le nc jx lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">我想，算是吧。如果你看一下上面的表格，我认为只有一个小小的错误。加上学习没有找到…</p><p id="b482" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当然，这只是一个例子。最大的挑战是读取以前看不到的格式的平面图。我相信，如果你关注某个机构的平面图，并对图像处理进行微调，它可以在更大范围内变得可靠。</p><p id="dbf3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我确实学到了很多关于图像文本处理的知识。大部分是关于它的局限性，但是嘿，那仍然算数！我希望你通过阅读这篇文章也学到了一些新的东西。</p><h1 id="c35e" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">可能的改进</h1><p id="a6b1" class="pw-post-body-paragraph ky kz it la b lb nb ju ld le nc jx lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">我有一些想法可以让这个过程变得更好:</p><ul class=""><li id="484e" class="nh ni it la b lb lc le lf lh nj ll nk lp nl lt nm nn no np bi translated">专注于某些房间类型，不要像我一样试图处理所有房间。问题是很难确定一个房间在平面图上是否有尺寸。我想象一个杂物间会在没有精确尺寸的情况下被展示。</li><li id="fd0f" class="nh ni it la b lb nr le ns lh nt ll nu lp nv lt nm nn no np bi translated">我放弃了调整贴图的对比度和亮度的想法，结果似乎不可靠，但也许值得花时间来研究这如何改变pytesseract的结果。</li><li id="5d32" class="nh ni it la b lb nr le ns lh nt ll nu lp nv lt nm nn no np bi translated">房间到侧面的匹配有点简单。这里可以有额外的检查，例如，我们可以检查某些元素是否大致在彼此之下，这将表明更密切的关系。</li></ul><div class="ph pi gp gr pj pk"><a href="https://matepocs.medium.com/membership" rel="noopener follow" target="_blank"><div class="pl ab fo"><div class="pm ab pn cl cj po"><h2 class="bd iu gy z fp pp fr fs pq fu fw is bi translated">加入我的推荐链接-伴侣概念</h2><div class="pr l"><h3 class="bd b gy z fp pp fr fs pq fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="ps l"><p class="bd b dl z fp pp fr fs pq fu fw dk translated">matepocs.medium.com</p></div></div><div class="pt l"><div class="pu l pv pw px pt py ks pk"/></div></div></a></div></div></div>    
</body>
</html>