<html>
<head>
<title>Demystifying Python Multiprocessing and Multithreading</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">揭开Python多重处理和多线程的神秘面纱</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/demystifying-python-multiprocessing-and-multithreading-9b62f9875a27?source=collection_archive---------0-----------------------#2021-10-11">https://towardsdatascience.com/demystifying-python-multiprocessing-and-multithreading-9b62f9875a27?source=collection_archive---------0-----------------------#2021-10-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1da3" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">…和全局解释器锁</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/dc7d77d35af122e42d217611407ace83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*L7Rgn9FI2Uaqbkbg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@oxaroxa?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">奥克萨·洛克萨</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><blockquote class="kz la lb"><p id="156e" class="lc ld le lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated"><strong class="lf iu"> <em class="it"> TLDR </em> </strong> <em class="it">:如果你的程序是网络绑定的，你应该使用</em>线程<em class="it">或者</em>多处理<em class="it">如果是CPU绑定的。</em></p></blockquote><p id="1de4" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">就我个人而言，这些年来我多次试图理解多重处理和多线程，但总是无法完全理解这些概念。为此，我们需要理解几个重要的术语以及Python编程语言特有的东西——全局解释器锁(GIL)。</p><p id="736a" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">如果您已经知道这些术语，请随意跳到下一节。</p><h1 id="f7bb" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">术语</h1><p id="cbfd" class="pw-post-body-paragraph lc ld it lf b lg mu ju li lj mv jx ll lz mw lo lp ma mx ls lt mb my lw lx ly im bi translated"><strong class="lf iu">核心</strong>:CPU的处理器。这个术语指的是CPU的硬件组件。核心可以处理单个任务；多核处理器可以同时执行多项任务。</p><p id="cf5f" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated"><strong class="lf iu">线程</strong>:管理任务的<strong class="lf iu">虚拟组件</strong>。如果您的CPU启用了多线程/超线程，每个CPU内核最多可以有两个线程。您可以搜索自己的CPU处理器来了解更多信息。对于Mac用户，可以从<em class="le">了解关于&gt;系统报告</em>。这意味着我的6核i7处理器有6个内核，最多可以有12个线程。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mz"><img src="../Images/4da54345f7d6a3d65651b61d6d6431b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8oB1kUQit5bNRFzq-BXNoA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="e2bd" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">我们可以使用<code class="fe na nb nc nd b">htop</code>(见下图GIF)来重新确认我的机器拥有的线程数量，从0到11。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ne"><img src="../Images/08260844257f95d453ca7d5a93709313.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*lfxZgUYaW1_ukuagZSvlNA.gif"/></div></div></figure><p id="d09a" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">进程:由一个或多个线程执行的计算机程序的实例。根据操作系统的不同，一个进程可能由多个执行线程组成，这些线程同时执行指令[1][2]。</p><p id="6242" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated"><strong class="lf iu">多线程</strong>:中央处理器(CPU)(或多核处理器中的单核)提供多个线程并发执行的能力，由操作系统支持[3]。</p><p id="ff6d" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated"><strong class="lf iu">多重处理</strong>:在一个计算机系统中使用两个或多个CPU[4][5]。该术语也指系统支持一个以上处理器的能力或在它们之间分配任务的能力。</p><h1 id="2245" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">什么是全局解释器锁(GIL)？</h1><p id="a58a" class="pw-post-body-paragraph lc ld it lf b lg mu ju li lj mv jx ll lz mw lo lp ma mx ls lt mb my lw lx ly im bi translated">如果我们用谷歌搜索“<em class="le">什么是Python </em>中的全局解释器锁”，我们得到的答案是这样的:</p><blockquote class="kz la lb"><p id="8d31" class="lc ld le lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">Python全局解释器锁(GIL)是<strong class="lf iu">一种进程锁，每当python处理进程</strong>时都会使用它。一般来说，Python只使用一个线程来执行这组写好的语句。这意味着在python中一次只能执行一个线程。</p></blockquote><p id="f126" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">通过在每次运行一个Python进程时只允许使用一个线程，这确保了一次只有<em class="le">一个线程可以访问一个特定的资源</em>，并且还防止了同时使用对象和字节码。</p><h1 id="b66d" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">多线程操作</h1><p id="e931" class="pw-post-body-paragraph lc ld it lf b lg mu ju li lj mv jx ll lz mw lo lp ma mx ls lt mb my lw lx ly im bi translated">GIL和多线程有什么关系？没什么，但它有助于我们理解何时使用多线程。让我们看一个例子。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者Github要点</p></figure><p id="9caf" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">如果我们看一下上面的函数，变量<code class="fe na nb nc nd b">final</code>在<code class="fe na nb nc nd b">range(100_000_000)</code>上被求和。在我的机器上执行这个需要大约7.88秒——现在，你认为多线程会加速这个操作吗？</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者Github要点</p></figure><p id="1b16" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">如果你猜的是“不”，那你就对了！使用8个线程的<code class="fe na nb nc nd b">ThreadPoolExecutor</code>，我们注意到这并没有加速进程！为什么会这样，引擎盖下发生了什么？</p><p id="0b1b" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">即使我们指定使用8个线程，也没有加速这个过程。以下是事情经过的详细分析:</p><ul class=""><li id="02fe" class="nh ni it lf b lg lh lj lk lz nj ma nk mb nl ly nm nn no np bi translated">python解释器创建一个新的进程并产生线程</li><li id="1296" class="nh ni it lf b lg nq lj nr lz ns ma nt mb nu ly nm nn no np bi translated">线程1开始运行，获取GIL</li><li id="3eba" class="nh ni it lf b lg nq lj nr lz ns ma nt mb nu ly nm nn no np bi translated">线程2到8想要协助线程1，但是必须等待线程1释放GIL，然后其他线程才能处理它</li><li id="4799" class="nh ni it lf b lg nq lj nr lz ns ma nt mb nu ly nm nn no np bi translated">由于没有I/O操作，线程1将继续处理整个<code class="fe na nb nc nd b">sum_square(100_000_000)</code>操作</li></ul><h2 id="4c3e" class="nv md it bd me nw nx dn mi ny nz dp mm lz oa ob mo ma oc od mq mb oe of ms og bi translated">为什么需要GIL？</h2><p id="e7ca" class="pw-post-body-paragraph lc ld it lf b lg mu ju li lj mv jx ll lz mw lo lp ma mx ls lt mb my lw lx ly im bi translated">在上面的例子中，我们在每次迭代中不断更新<code class="fe na nb nc nd b">final</code>变量。如果多个线程能够同时<strong class="lf iu"><em class="le"/></strong>访问该代码的执行，则由每个线程检索和修改的<code class="fe na nb nc nd b">i</code>的值可以在其他线程访问它时发生变化。那么，<code class="fe na nb nc nd b">i</code>和<code class="fe na nb nc nd b">final</code>在任一时间点的真实值是什么呢？这是一个程序不希望的状态，称为<strong class="lf iu">竞争条件</strong>。</p><h2 id="5058" class="nv md it bd me nw nx dn mi ny nz dp mm lz oa ob mo ma oc od mq mb oe of ms og bi translated">那么，什么时候应该使用多线程呢？</h2><p id="46d6" class="pw-post-body-paragraph lc ld it lf b lg mu ju li lj mv jx ll lz mw lo lp ma mx ls lt mb my lw lx ly im bi translated">正如我们在前面的<code class="fe na nb nc nd b">sum_square</code>中看到的，一个100%计算密集型任务无法利用多线程，因为一次只能使用一个线程(由于GIL)。如果我们执行一个很大程度上受I/O限制的任务，我们就可以利用多线程。这里有一个我们试图从网上下载图片的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者Github要点</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ne"><img src="../Images/d2bd112f43dc9c89049a8df90d85a13e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*AB4l306e8AiELn0ru_4l6A.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">单线程性能—作者GIF</p></figure><p id="8502" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">使用一个仅由80个图片URL组成的<code class="fe na nb nc nd b">demo_urls.txt</code>，这个过程总共花费了6.71秒。此外，请注意，其他核心/线程没有启动(保持0%的利用率)。让我们用多线程做同样的事情。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者Github要点</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ne"><img src="../Images/47ded1cb95d4a43a752b027208f97a1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*aUbnIEJruV66pCncDloZ8Q.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">多线程性能—作者GIF</p></figure><p id="ba18" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">同样是80个图片网址，使用多线程在1.38秒内完成了整个过程。请注意，所有12个线程(从0到11)都被利用了(非零)。</p><h1 id="4eb3" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">多重处理</h1><p id="34f6" class="pw-post-body-paragraph lc ld it lf b lg mu ju li lj mv jx ll lz mw lo lp ma mx ls lt mb my lw lx ly im bi translated">如果我们使用<code class="fe na nb nc nd b">ProcessPoolExecutor</code>(即多进程)运行上述相同的进程，您认为速度会大于还是小于1.38秒？</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者Github要点</p></figure><p id="8d7f" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">如果你猜大于1.38秒，你就对了！由于<code class="fe na nb nc nd b">download_image</code>功能主要由I/O操作组成，我们在等待这些操作完成时，大大节省了时间。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ne"><img src="../Images/f784d17e226bf8f5b261cb572d74929e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*3UHj7DLOsHLIdt2YiOoZ3w.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">多进程性能—作者GIF</p></figure><p id="c195" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">尽管如此，多重处理仍然允许我们在3.34秒内相当快地下载80张图片，尽管这更加占用内存。这是因为Python多处理在进程间传递对象时使用<em class="le"> pickle </em>来序列化对象，要求每个进程创建自己的数据副本，这增加了大量的内存使用，更不用说昂贵的反序列化了。</p><h1 id="ec1b" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">关键要点</h1><ol class=""><li id="621b" class="nh ni it lf b lg mu lj mv lz oh ma oi mb oj ly ok nn no np bi translated">Python不是单线程语言。</li><li id="aa49" class="nh ni it lf b lg nq lj nr lz ns ma nt mb nu ly ok nn no np bi translated">由于GIL，Python进程通常使用单线程。</li><li id="f829" class="nh ni it lf b lg nq lj nr lz ns ma nt mb nu ly ok nn no np bi translated">尽管有GIL，但执行计算繁重任务的库，如<em class="le"> numpy、scipy </em>和<em class="le"> pytorch </em>利用基于C的实现，允许使用多个内核。</li><li id="b18e" class="nh ni it lf b lg nq lj nr lz ns ma nt mb nu ly ok nn no np bi translated">根据经验，大部分I/O受限的进程受益于多线程，而计算量大的任务受益于多处理。</li></ol><h1 id="2841" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">最后的想法</h1><p id="c524" class="pw-post-body-paragraph lc ld it lf b lg mu ju li lj mv jx ll lz mw lo lp ma mx ls lt mb my lw lx ly im bi translated">感谢您的阅读，如果您发现任何错误，一定要让我知道！</p><p id="846e" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated"><strong class="lf iu"> <em class="le">支持我！</em> </strong> —如果你喜欢我的内容并且<em class="le">没有</em>订阅Medium，请考虑支持我并通过我在这里的推荐链接<a class="ae ky" href="https://davidcjw.medium.com/membership" rel="noopener">订阅</a> ( <em class="le">注意:你的一部分会员费将作为推荐费分摊给我</em>)。</p><h1 id="5837" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">参考</h1><p id="e9d4" class="pw-post-body-paragraph lc ld it lf b lg mu ju li lj mv jx ll lz mw lo lp ma mx ls lt mb my lw lx ly im bi translated">[1] <a class="ae ky" href="https://en.wikipedia.org/wiki/Abraham_Silberschatz" rel="noopener ugc nofollow" target="_blank">亚伯拉罕·西尔伯沙茨</a>；格雷格·卡涅；高尔文，彼得·贝尔(2004)。“第四章。流程”。<em class="le">操作系统概念与Java </em>(第六版。).<a class="ae ky" href="https://en.wikipedia.org/wiki/John_Wiley_%26_Sons" rel="noopener ugc nofollow" target="_blank">约翰·威利&amp;儿子们</a>。国际标准书号0–471–48905–0</p><p id="e5e7" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">[2]瓦哈里亚，乌雷什(1996年)。“第二章。过程和内核”。<a class="ae ky" href="https://archive.org/details/unixinternalsnew00vaha" rel="noopener ugc nofollow" target="_blank"> <em class="le"> UNIX内部:新前沿</em> </a>。普伦蒂斯-霍尔公司<a class="ae ky" href="https://en.wikipedia.org/wiki/ISBN_(identifier)" rel="noopener ugc nofollow" target="_blank">国际标准书号</a><a class="ae ky" href="https://en.wikipedia.org/wiki/Special:BookSources/0-13-101908-2" rel="noopener ugc nofollow" target="_blank">0–13–101908–2</a>。</p><p id="345c" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">[3] <a class="ae ky" href="https://en.wikipedia.org/wiki/Multithreading_(computer_architecture)" rel="noopener ugc nofollow" target="_blank">多线程(计算机体系结构)</a></p><p id="12fa" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">[4]拉杰·拉贾戈帕尔(1999年)。<a class="ae ky" href="https://books.google.com/books?id=kUJnHJJlnpUC&amp;pg=PA4" rel="noopener ugc nofollow" target="_blank"> <em class="le">微软Windows NT集群服务器简介:编程与管理</em> </a>。CRC出版社。第4页。<a class="ae ky" href="https://en.wikipedia.org/wiki/ISBN_(identifier)" rel="noopener ugc nofollow" target="_blank">国际标准书号</a><a class="ae ky" href="https://en.wikipedia.org/wiki/Special:BookSources/978-1-4200-7548-9" rel="noopener ugc nofollow" target="_blank">978–1–4200–7548–9</a></p><p id="2e60" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">[5]迈克·埃伯斯；约翰·凯特纳；韦恩·奥布莱恩；比尔·奥格登(2012)。<a class="ae ky" href="https://books.google.com/books?id=c-a1AgAAQBAJ&amp;pg=PA96" rel="noopener ugc nofollow" target="_blank"> <em class="le">新主机介绍:z/OS基础知识</em> </a>。IBM。第96页。<a class="ae ky" href="https://en.wikipedia.org/wiki/ISBN_(identifier)" rel="noopener ugc nofollow" target="_blank">国际标准书号</a>T34】978–0–7384–3534–3</p><p id="db4a" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">[6] Youtube: <a class="ae ky" href="https://www.youtube.com/watch?v=m2yeB94CxVQ" rel="noopener ugc nofollow" target="_blank"> Python不是单线程的(以及如何绕过GIL) </a></p></div></div>    
</body>
</html>