<html>
<head>
<title>Best Practices for R Programming</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">R编程的最佳实践</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/best-practices-for-r-programming-ec0754010b5a?source=collection_archive---------22-----------------------#2021-04-26">https://towardsdatascience.com/best-practices-for-r-programming-ec0754010b5a?source=collection_archive---------22-----------------------#2021-04-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/ee111baf5e2b415eae60d7ae281f5b32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*l7dZRIdLUx9broC4"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">摄影:<a class="ae kf" href="https://unsplash.com/@karsten_wuerth" rel="noopener ugc nofollow" target="_blank">@ karst en _ wuerth</a>—Unplash.com</p></figure><p id="61bc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi le translated"><span class="l lf lg lh bm li lj lk ll lm di">作为一个有统计学背景的人，我承认我必须不断提高我的计算机科学和工程技能，几乎每天都是如此。虽然在分析数据时考虑分布、统计和其他关键概念对我来说是很自然的，但编写高效、干净的代码却不是。</span></p><p id="84f9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">幸运的是，我有机会与许多工程师一起工作，他们教导并解释了为什么代码需要干净和高效——如果我可以用一句话来总结这一需求，最好的一句话来自约翰·多恩的诗(这句话几乎有400年的历史了！):<strong class="ki iu"><em class="ln">‘没有人是孤岛’。</em> </strong></p><p id="26b4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">说到开发我们的代码和脚本，我们不是一个孤岛。当作为一名数据科学家、分析师(或几乎任何其他职业)工作时，协作是最重要的技能之一——如果你想以分析数据为职业，未来有人不得不查看你的代码的概率可能是99.99%。您的代码组织得越好，将来就越容易被人查看、调试和改进。而且这并不排斥你可能必须去做的其他人，它也将为你未来的自己省去很多麻烦(那些从来没有看着自己的代码并想:“<strong class="ki iu">我到底在这个函数中做了什么？</strong>))</p><p id="dde3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，让我们直接进入R编程的一些常见的最佳实践(有些有争议，有些被社区广泛接受)！</p></div><div class="ab cl lo lp hx lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="im in io ip iq"><h2 id="bfe8" class="lv lw it bd lx ly lz dn ma mb mc dp md kr me mf mg kv mh mi mj kz mk ml mm mn bi translated">图书馆第一</h2><p id="e249" class="pw-post-body-paragraph kg kh it ki b kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">应该放入R脚本的第一件事是你的库——你的代码的依赖关系应该在一开始就明确。这将避免有人在运行代码时感到惊讶，因为其中一个导入隐藏在代码中间，而用户没有为此准备好环境。</p><p id="b6d7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">大多数风格指南都同意这一建议，您应该避免这样做:</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="3e58" class="lv lw it my b gy nc nd l ne nf">my_vector &lt;- c(1,2,3)</span><span id="126b" class="lv lw it my b gy ng nd l ne nf">library(readxl)</span><span id="1230" class="lv lw it my b gy ng nd l ne nf">read_excel(path_file)</span></pre><p id="cb7e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在导入库<em class="ln"> readxl — </em>之前，创建一个向量<em class="ln"> my_vector </em>，这通常是一个不好的做法。</p><p id="f8b7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我发现唯一可以打破这一规则的地方是在教学过程中——例如，当一个人在一个依赖于库的讲座中引入一个新概念时——可以在脚本中间加载该库，以便学生保留正在使用的函数和包含该段代码的库的可视引用。</p><h2 id="5226" class="lv lw it bd lx ly lz dn ma mb mc dp md kr me mf mg kv mh mi mj kz mk ml mm mn bi translated">硬编码变量次之</h2><p id="8ce8" class="pw-post-body-paragraph kg kh it ki b kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">另一个普遍接受的规则是硬编码的变量，如访问数据库的路径或配置文件(如果您有密码，最好看看这篇文章来管理机密:<a class="ae kf" href="https://cran.r-project.org/web/packages/httr/vignettes/secrets.html" rel="noopener ugc nofollow" target="_blank">https://cran . r-project . org/web/packages/httr/vignettes/secrets . html</a>)在脚本的开头，在导入库之后。</p><p id="e1e4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">许多脚本都使用csv或xlsx文件中的数据，因此一般最佳做法是执行以下操作:</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="d847" class="lv lw it my b gy nc nd l ne nf">library(readxl)</span><span id="6266" class="lv lw it my b gy ng nd l ne nf">path_file &lt;- <!-- -->"data/data.csv"</span><span id="a581" class="lv lw it my b gy ng nd l ne nf">my_df &lt;- read_excel(path_file)</span></pre><p id="2e36" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这样，无论谁读了你的代码，都有两个重要的信息:</p><ul class=""><li id="6d7a" class="nh ni it ki b kj kk kn ko kr nj kv nk kz nl ld nm nn no np bi translated"><strong class="ki iu">你的代码依赖于哪些库。</strong></li><li id="647c" class="nh ni it ki b kj nq kn nr kr ns kv nt kz nu ld nm nn no np bi translated"><strong class="ki iu">源文件夹结构应该包含哪些文件和文件夹。</strong></li></ul><p id="365c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">哦，关于文件路径..</p><h2 id="5fad" class="lv lw it bd lx ly lz dn ma mb mc dp md kr me mf mg kv mh mi mj kz mk ml mm mn bi translated">绝对路径上的相对路径</h2><p id="a684" class="pw-post-body-paragraph kg kh it ki b kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">绝对路径从来都不是应该走的路。当您在操作系统<em class="ln">用户</em>结构中的文件夹上工作时，这一点尤其重要。</p><p id="5331" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">绝对路径如下所示:</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="c6a4" class="lv lw it my b gy nc nd l ne nf">"C:\Users\ivopb\My Documents\R Project\data\data.csv"</span></pre><p id="1a59" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我把我的代码传递给需要在他们机器上运行它的人，除非他们有用户名<strong class="ki iu"> <em class="ln"> ivopb，</em> </strong>否则他们永远也不能在我们使用这个文件的地方运行代码。即使他们在相同的文件夹结构(My Documents/R Project/等)中运行它。).</p><p id="9c76" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">哦，即使碰巧他们是用户<strong class="ki iu"><em class="ln">【ivopb】，</em> </strong>但是他们的硬盘中映射了另一个字母，不是<strong class="ki iu"><em class="ln">C:</em></strong>祝你执行代码好运！</p><p id="5568" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">通常，相对路径总是首选的:</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="cee6" class="lv lw it my b gy nc nd l ne nf">"data\data.csv"</span></pre><p id="78ce" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这将迫使您将工作目录设置为您正在工作的文件夹，或者从文件夹中打开脚本——这确实比调试和更改脚本中的大量路径要好得多！</p><h2 id="3434" class="lv lw it bd lx ly lz dn ma mb mc dp md kr me mf mg kv mh mi mj kz mk ml mm mn bi translated">命名约定—文件名</h2><p id="9e74" class="pw-post-body-paragraph kg kh it ki b kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">对于文件名，总是使用易于理解的文件名，不要在文件名中使用空格(我实际上在我的课程脚本中犯了这个错误，试图匹配Udemy上的讲座名称，我将来可能会改变这一点)——一个好的和坏的例子:</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="52b2" class="lv lw it my b gy nc nd l ne nf"># Good example<br/>my_file.R</span><span id="a4c2" class="lv lw it my b gy ng nd l ne nf"># Bad example<br/>My File.R</span></pre><p id="5337" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，在脚本名称中尽量使用小写字母。例如，如果您的脚本的目标是在csv文件中创建一些特定数据的聚合，请使用与脚本总体目标相关的名称:</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="4fb5" class="lv lw it my b gy nc nd l ne nf">aggregating_data.R</span></pre><h2 id="8128" class="lv lw it bd lx ly lz dn ma mb mc dp md kr me mf mg kv mh mi mj kz mk ml mm mn bi translated">命名约定—对象和函数</h2><p id="c594" class="pw-post-body-paragraph kg kh it ki b kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">这在任何编码语言中都是一个热门话题——人们倾向于争论哪种命名约定是最好的。</p><p id="63cb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">除了你选择的命名约定之外，一定要在整个脚本中遵循相同的命名约定——对我来说，这是一个通用的黄金法则。</p><p id="f3b1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我喜欢用蛇皮箱(使用<em class="ln"> _ </em>)作为物件，用骆驼或蛇皮箱作为功能，但这有待讨论。一个例子:</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="d56c" class="lv lw it my b gy nc nd l ne nf"># Good<br/>my_vector &lt;- c(1,2,3)</span><span id="4dac" class="lv lw it my b gy ng nd l ne nf"># Bad<br/>myvector &lt;- c(1,2,3)</span><span id="eca1" class="lv lw it my b gy ng nd l ne nf"># Good<br/>ThisFunction()<br/>this_function()</span><span id="b4d9" class="lv lw it my b gy ng nd l ne nf"># Bad<br/>thisfunction() </span></pre><p id="bfc0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，您的对象和函数名称应该尽可能明确和简短，想象一个接受一个元素并计算一个数的幂的函数:</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="8544" class="lv lw it my b gy nc nd l ne nf">ComputePowerOfBaseWithExponent &lt;- function (base, exponent) {<br/>  return (base**exponent)<br/>}</span></pre><p id="586f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">函数名确实很长，所以我们可以缩短它，通常建议这样做:</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="11a3" class="lv lw it my b gy nc nd l ne nf">ComputePower &lt;- function (base, exponent) {<br/>  return (base**exponent)<br/>}</span></pre><p id="a01a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">再说一遍，我唯一的黄金法则是在整个剧本中保持风格一致。</p><h2 id="87a0" class="lv lw it bd lx ly lz dn ma mb mc dp md kr me mf mg kv mh mi mj kz mk ml mm mn bi translated">返回</h2><p id="2b6d" class="pw-post-body-paragraph kg kh it ki b kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">这与变量和函数的命名一样，是社区中最有争议的话题之一(看一下这个帖子来检查争论的双方——<a class="ae kf" href="https://stackoverflow.com/questions/11738823/explicitly-calling-return-in-a-function-or-not" rel="noopener ugc nofollow" target="_blank">https://stack overflow . com/questions/11738823/explicitly-calling-return-in-a-function-or-not</a></p><p id="a4bc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">每个函数末尾的R中的Return语句增加了冗余—这是事实。注意，我在上面的例子中使用了显式返回:</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="dbda" class="lv lw it my b gy nc nd l ne nf">ComputePower &lt;- function (base, exponent) {<br/>  return (base**exponent)<br/>}</span></pre><p id="195e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">可以从函数中删除<em class="ln">返回</em>语句，从显式返回改为隐式返回:</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="ab9b" class="lv lw it my b gy nc nd l ne nf">ComputePower &lt;- function (base, exponent) {<br/>  base**exponent<br/>}</span></pre><p id="d6c7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用显式返回对代码的速度有一点点影响——增加了一点点(它通常非常小，几乎无法辨认)。</p><p id="7d15" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我倾向于认为显式返回对于所有级别的R程序员都更容易，因为显式返回让初学者更容易理解代码的流程。但这主要是程序员的选择——当谈到这一点时，人们往往会站在两边，我个人的观点是，我认为指责任何使用隐式或显式回报的人都是不公平的。</p><h2 id="81c1" class="lv lw it bd lx ly lz dn ma mb mc dp md kr me mf mg kv mh mi mj kz mk ml mm mn bi translated">在循环中显式</h2><p id="030c" class="pw-post-body-paragraph kg kh it ki b kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">在对象上进行循环时，一件重要的事情是显式命名正在循环的元素。</p><p id="14e3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们想象下面的练习:你有一个特定人群的年龄向量，你想用“主要”或“次要”来分类，你使用for循环(为了讨论，让我们忽略我们可以使用的更好实现的其他方法):</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="1042" class="lv lw it my b gy nc nd l ne nf">ages_people = c(10, 20, 20, 30, 40)</span><span id="42df" class="lv lw it my b gy ng nd l ne nf">ClassifyAge &lt;- function (ages) {<br/>  age_class &lt;- c()<br/>  for (age in ages) {<br/>    if (age &lt; 18) {<br/>      age_class &lt;- c(age_class, 'Minor')<br/>    }<br/>    else {<br/>      age_class &lt;- c(age_class, 'Major')<br/>    }<br/>  }<br/>  age_class<br/>}</span></pre><p id="66e0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们将for循环中的<strong class="ki iu"> <em class="ln"> age </em> </strong>称为<strong class="ki iu"> <em class="ln"> i </em> </strong> <em class="ln"> </em>或<strong class="ki iu"> <em class="ln">元素:</em> </strong></p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="2f6f" class="lv lw it my b gy nc nd l ne nf">ages_people = c(10, 20, 20, 30, 40)</span><span id="98a6" class="lv lw it my b gy ng nd l ne nf">ClassifyAge &lt;- function (ages) {<br/>  age_class &lt;- c()<br/>  for (i in ages) {<br/>    if (i &lt; 18) {<br/>      age_class &lt;- c(age_class, 'Minor')<br/>    }<br/>    else {<br/>      age_class &lt;- c(age_class, 'Major')<br/>    }<br/>  }<br/>  age_class<br/>}</span></pre><p id="6a3d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">通常最好是显式命名循环的元素——在上面的例子中，我们是基于一个<strong class="ki iu"> <em class="ln">年龄</em> </strong>来做一些事情，因此最好将循环元素命名为<strong class="ki iu"> <em class="ln">年龄</em> </strong>而不是<strong class="ki iu"> <em class="ln"> i、元素</em> </strong>或<em class="ln"/>。这将使不熟悉代码的人更容易理解代码在功能级别上做什么。</p><h2 id="4258" class="lv lw it bd lx ly lz dn ma mb mc dp md kr me mf mg kv mh mi mj kz mk ml mm mn bi translated">对对象赋值使用</h2><p id="ff9c" class="pw-post-body-paragraph kg kh it ki b kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">这是社区上的另一个热门话题——在创建对象或函数时，我倾向于使用<strong class="ki iu">-&lt;-</strong>，尽管在这种情况下<strong class="ki iu"> = </strong>的表现完全相同。大多数风格指南同意这一点，但没有一个放之四海而皆准的意见。</p><p id="4252" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一个普遍接受的规则是，当你使用</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="c552" class="lv lw it my b gy nc nd l ne nf"># Good example<br/>my_vector &lt;- c(1, 2, 3)</span><span id="77ca" class="lv lw it my b gy ng nd l ne nf"># Bad example<br/>my_vector&lt;-c(1, 2, 3)</span></pre><p id="902e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Of course, as I intertwine a lot between Python and R scripts, sometimes the naughty <strong class="ki iu"> = </strong>的时候就完成了赋值:-)</p><h2 id="33ee" class="lv lw it bd lx ly lz dn ma mb mc dp md kr me mf mg kv mh mi mj kz mk ml mm mn bi translated">线长度</h2><p id="16ee" class="pw-post-body-paragraph kg kh it ki b kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">避免每行超过80个字符，以便您的代码可以适合大多数IDE窗口。这也是其他编程语言(如Python)的最佳实践。您希望避免脚本的读者来回使用水平滚动条(这是一个容易迷失在代码中的方法)。</p><p id="b6a7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">想象一个函数，用很长的参数调用:</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="64b8" class="lv lw it my b gy nc nd l ne nf">CalculatesMeaningOfLife('This is a really long argument','This is another really long argument','This is a third really long argument!') </span></pre><p id="103e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">调用此代码时的一般最佳做法是执行以下操作:</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="7896" class="lv lw it my b gy nc nd l ne nf">CalculatesMeaningOfLife(<br/>  'This is a really long argument',<br/>  'This is another really long argument',<br/>  'This is a third really long argument!'<br/>)</span></pre><p id="e893" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">R Studio有一些自动缩进，当你在逗号后按回车键。这是一个简洁的特性，它使得我们的代码更容易保持整洁。</p><h2 id="8314" class="lv lw it bd lx ly lz dn ma mb mc dp md kr me mf mg kv mh mi mj kz mk ml mm mn bi translated">间隔</h2><p id="4c43" class="pw-post-body-paragraph kg kh it ki b kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">当调用函数或索引对象时，在每个<strong class="ki iu">、</strong>之后提供一个空格总是一个好主意。这使得代码可读性更好，避免了“压缩代码”的想法。压缩代码是当我们有如下:</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="e96a" class="lv lw it my b gy nc nd l ne nf">my_array = array(1:10,c(2,5))<br/>my_array[,c(1,2)]</span></pre><p id="f3c4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">代码可以工作，但是所有的代码都被捆绑在一起，没有空格。从视觉上看，很难理解哪个位是指数组中的第一维还是第二维。</p><p id="dd59" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">更干净的方法是执行以下操作:</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="7805" class="lv lw it my b gy nc nd l ne nf">my_array = array(1:10, c(2, 5))<br/>my_array[, c(1, 2)]</span></pre><p id="fc30" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">请注意我是如何在代码中的每个逗号后添加一个空格的。这就是人们通常所说的让代码呼吸— <strong class="ki iu">你可以更容易地理解你在每个维度上索引了什么，以及你的函数调用的每个参数包含了什么。</strong></p><h2 id="4bc3" class="lv lw it bd lx ly lz dn ma mb mc dp md kr me mf mg kv mh mi mj kz mk ml mm mn bi translated">不要重复自己的话</h2><p id="8914" class="pw-post-body-paragraph kg kh it ki b kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">任何编程语言(至少是函数式语言)中最重要的概念之一是<strong class="ki iu"> DRY的概念。</strong>一条普遍的黄金法则是，当你发现自己复制并粘贴了大量代码时，这是一个函数的好用法。</p><p id="afe9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">举一个非常简单的例子，假设我们想用R:</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="ec6a" class="lv lw it my b gy nc nd l ne nf">paste('Hello','John')<br/>paste('Hello','Susan')<br/>paste('Hello','Matt')<br/>paste('Hello','Anne')<br/>paste('Hello','Joe')<br/>paste('Hello','Tyson')<br/>paste('Hello','Julia')<br/>paste('Hello','Cathy')</span></pre><p id="c60d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您多次重复相同的代码，只是更改了学生的姓名。在您看来，这应该会立即引发使用功能的需求:</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="4e64" class="lv lw it my b gy nc nd l ne nf">GreetStudent &lt;- function(name) {<br/> paste(‘Hello’,name)<br/>}</span><span id="e629" class="lv lw it my b gy ng nd l ne nf">class_names &lt;- c(‘John’, ‘Susan’, ‘Matt’ ,’Anne’,<br/>              ‘Joe’, ‘Tyson’, ‘Julia’, ‘Cathy’)</span><span id="499c" class="lv lw it my b gy ng nd l ne nf">for (student in class_names){<br/> print(GreetStudent(student))<br/>}</span></pre><p id="8d0f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">酷的是，现在您可以向我们的class_names向量添加更多的学生，并且您可以避免多次重复粘贴命令！</strong></p><p id="1b0c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">函数确实是r中最强大的概念之一。人们应该多次依赖它们，因为它们将使我们的代码高效且可测试。</p></div><div class="ab cl lo lp hx lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="im in io ip iq"><p id="c857" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">就是这样！你还有什么要补充吗？</p><p id="bb4f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里有很多我没有涉及的最佳实践，可能还有很多我自己都不知道的。开源语言让我着迷的是它们发展的速度有多快，以及社区如何在开发更好的程序和脚本以实现更高的生产力方面相互支持。</p><p id="a6b2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后一点，记住学习一门新的语言是一项需要时间的技能，对一个人来说成为万事通几乎是不可能的。你周围的每个人，不管他们是多么高级的语言，总是有东西要学，学习的心态是成为一个更好的专业人士和普通人的最佳心态。</p><p id="5660" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">随时伸出手如果你想了解更多关于R的知识，可以在这里加入我的R编程课程:<a class="ae kf" href="https://www.udemy.com/course/r-for-absolute-beginners/?couponCode=LEARN_R" rel="noopener ugc nofollow" target="_blank"> <strong class="ki iu"> <em class="ln">绝对初学者R编程课程</em> </strong> </a></p><blockquote class="nv nw nx"><p id="70e9" class="kg kh ln ki b kj kk kl km kn ko kp kq ny ks kt ku nz kw kx ky oa la lb lc ld im bi translated">感谢您花时间阅读这篇文章！随意在LinkedIn上加我(<a class="ae kf" href="https://www.linkedin.com/in/ivobernardo/" rel="noopener ugc nofollow" target="_blank"><em class="it">https://www.linkedin.com/in/ivobernardo/</em></a><em class="it">)查看我公司网站(</em><a class="ae kf" href="https://daredata.engineering/home" rel="noopener ugc nofollow" target="_blank"><em class="it">https://daredata.engineering/home</em></a><em class="it">)。</em></p><p id="0372" class="kg kh ln ki b kj kk kl km kn ko kp kq ny ks kt ku nz kw kx ky oa la lb lc ld im bi translated">如果你有兴趣接受分析和数据科学方面的培训，你也可以访问我在Udemy(<a class="ae kf" href="https://www.udemy.com/user/ivo-bernardo/" rel="noopener ugc nofollow" target="_blank">https://www.udemy.com/user/ivo-bernardo/</a>)上的页面</p></blockquote><p id="4cc3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu"> <em class="ln">这个讲座摘自我在Udemy平台上的</em> </strong> <a class="ae kf" href="https://www.udemy.com/course/r-for-absolute-beginners/?couponCode=LEARN_R" rel="noopener ugc nofollow" target="_blank"> <strong class="ki iu"> <em class="ln"> R编程课程</em></strong></a><strong class="ki iu"><em class="ln">——该课程适合初学者和想学习R编程基础的人。该课程还包含50多个编码练习，使您能够在学习新概念的同时进行练习。</em> </strong></p></div></div>    
</body>
</html>