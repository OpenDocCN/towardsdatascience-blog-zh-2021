<html>
<head>
<title>Docker Compose for absolute beginners — how does it work and how to use it (+ examples)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Docker Compose面向绝对初学者——它是如何工作的以及如何使用它(+示例)</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/docker-compose-for-absolute-beginners-how-does-it-work-and-how-to-use-it-examples-733ca24c5e6c?source=collection_archive---------0-----------------------#2021-06-19">https://towardsdatascience.com/docker-compose-for-absolute-beginners-how-does-it-work-and-how-to-use-it-examples-733ca24c5e6c?source=collection_archive---------0-----------------------#2021-06-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="eb0d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">定义和运行多容器Docker应用程序</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/1f23c333afbff21293409f61acf5c96f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*PcwvAtwow0B-Pfgx"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">将你的容器演奏成一首美妙的交响乐(图片由<a class="ae ky" href="https://www.pexels.com/@gabrielsantosfotografia" rel="noopener ugc nofollow" target="_blank">加布里埃尔·桑托斯</a>在<a class="ae ky" href="https://www.pexels.com/photo/man-performing-on-stage-2102568/" rel="noopener ugc nofollow" target="_blank">像素</a>上提供)</p></figure><p id="4d6d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第1部分:Docker的<a class="ae ky" href="https://mikehuls.medium.com/docker-for-absolute-beginners-what-is-docker-and-how-to-use-it-examples-3d3b11efd830" rel="noopener">基础知识</a>中，我们着重于建立Docker形象。从该映像创建容器非常简单，只需执行一条命令。Docker-compose进一步自动化了这一点。在本文中，我们将创建一个包含多个容器的运行配置的文件。然后，我们可以用一个命令构建所有的图像并运行所有的容器！</p><p id="eb0c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将借助一个多容器应用程序的详细示例来探索compose。我们将旋转多个相互连接的容器。您可以将本演练用作自己项目的指南。在本文结束时，您将能够:</p><ul class=""><li id="9156" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">了解Docker Compose是什么以及它是如何工作的</li><li id="a730" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">了解Docker Compose为Docker增加了哪些优势，让您的生活更加轻松</li><li id="7ae7" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">了解何时使用Docker撰写</li><li id="6779" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">能够使用Compose启动和管理多个容器</li><li id="9de7" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">能够吹嘘您的许多基础架构实现了自动化</li></ul><p id="2c81" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<a class="ae ky" href="https://mikehuls.medium.com/docker-for-absolute-beginners-what-is-docker-and-how-to-use-it-examples-3d3b11efd830" rel="noopener"> <strong class="lb iu">这篇文章</strong> </a> <strong class="lb iu"> </strong>中，我们探讨了Docker的基础知识；如果对Docker不熟悉，建议先看一下。它详细介绍了如何创建Docker图像以及如何和何时使用这些图像。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><p id="1c15" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们要看看Compose的优点；我们为什么需要这个工具，它能为我们提供什么？然后我们将有一个真实的代码示例，向您展示如何使用Compose。</p><h1 id="a52d" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">1.为什么使用docker compose？</h1><p id="def9" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">在这一部分，我们将讨论使用Compose的主要原因。</p><h2 id="326b" class="nn mr it bd ms no np dn mw nq nr dp na li ns nt nc lm nu nv ne lq nw nx ng ny bi translated">一个文件中的所有配置</h2><p id="b1b8" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">Compose围绕着一个名为<code class="fe nz oa ob oc b">docker-compose.yml</code>的配置文件。在其中，我们定义了我们所有的服务。将服务视为应用程序的一部分；例如数据库或API。我们所有的服务都依赖于我们用来创建容器的图像。旋转容器可以有多种选择；这些选项的配置方式将存储在yml文件中。</p><p id="d1fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些运行选项的一个例子是我们在<a class="ae ky" href="https://mikehuls.medium.com/docker-for-absolute-beginners-what-is-docker-and-how-to-use-it-examples-3d3b11efd830" rel="noopener">第1部分</a>中定义的端口映射。我们不得不在我们的终端打电话给<code class="fe nz oa ob oc b">docker run —publish 5000:5000 python-docker</code>。Compose允许我们在一个文件中定义这些选项。稍后我们会看到一个这样的例子。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/073ec6e07449a9e432aebb8625496b7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*DkNIDz6r2Q-8WHL9"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Compose在容器中组织我们所有的服务(图片由Tom Fisk提供)</p></figure><p id="cf8a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将我们所有的服务及其相应的构建选项放在一个文件中的另一个好处是，我们可以通过调用<code class="fe nz oa ob oc b">docker-compose up</code>一次构建并运行我们所有的服务！</p><h2 id="54d4" class="nn mr it bd ms no np dn mw nq nr dp na li ns nt nc lm nu nv ne lq nw nx ng ny bi translated">使用环境变量</h2><p id="7b6e" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">使用环境变量可以更灵活地运行我们的容器。我们可以为<code class="fe nz oa ob oc b">docker-compose up</code>命令提供一个包含一些环境变量的文件。这样，我们可以安全地提供密码，而不必将它们硬编码到配置文件中。</p><p id="fdd2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个例子:我们将创建一个名为<code class="fe nz oa ob oc b">.env</code>的文件，它包含<code class="fe nz oa ob oc b">DBPASSWORD=secretpass</code>。然后我们可以使用DBPASSWORD作为<code class="fe nz oa ob oc b">docker-compose.yml</code>中的变量。</p><p id="f6a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为此，我们在调用docker-compose: <code class="fe nz oa ob oc b">docker-compose --env-file .env up</code>时指定我们的env文件。这使得我们的密码不在我们的库和docker-compose.yml中，而且它提供了更多的灵活性和更整洁的项目，因为我们的密码不再是硬编码的了。</p><h2 id="bf4d" class="nn mr it bd ms no np dn mw nq nr dp na li ns nt nc lm nu nv ne lq nw nx ng ny bi translated">共享集装箱网络</h2><p id="7d65" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">当我们使用Compose构建容器时，它定义了一个所有服务共享的网络。这意味着所有服务都可以在内部通信。</p><p id="ad09" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们用一个例子来说明这一点。假设我们将应用程序托管在beersnob.com上。当我们的API需要与我们的数据库通信时，它不需要通过beersnob.com:5432连接，而是可以在内部调用数据库。这对于安全性来说非常重要，因为这意味着只有我们的服务可以访问我们的数据库，客户端无法从应用程序外部访问服务。</p><h2 id="50a0" class="nn mr it bd ms no np dn mw nq nr dp na li ns nt nc lm nu nv ne lq nw nx ng ny bi translated">可移植性和版本控制</h2><p id="0056" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">因为我们把所有的配置都放在一个文件中，所以我们可以通过Git这样的版本控制系统轻松地共享这个文件。用户只需拉出docker-compose.yml和源代码，他们就可以运行所有的容器了！一个额外的好处是，我们保留了对我们的配置所做的所有更改的完整历史，以便我们可以随时恢复以前的版本。这也使得为这个应用程序建立CI/CD管道变得更加容易，我们将在以后的部分中讨论这一点。</p><h2 id="c705" class="nn mr it bd ms no np dn mw nq nr dp na li ns nt nc lm nu nv ne lq nw nx ng ny bi translated">灵活性</h2><p id="7a05" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">因为我们所有的服务都是彼此完全隔离的，所以我们可以很容易地添加新的服务。也许将来我们的应用程序需要一些缓存→只需旋转一个Redis容器！像我们的API这样的其他服务可以很容易地通过内部网络连接到新的Redis服务。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="f9d2" class="mq mr it bd ms mt oe mv mw mx of mz na jz og ka nc kc oh kd ne kf oi kg ng nh bi translated">2.Docker如何工作:创建我们的第一个容器</h1><p id="d385" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">好了，说够了；让我们看看一些代码！为了真正理解Compose如何工作以及如何使用它，我们将构建一个容器化的应用程序。</p><h2 id="1ce5" class="nn mr it bd ms no np dn mw nq nr dp na li ns nt nc lm nu nv ne lq nw nx ng ny bi translated">2.1.目标</h2><p id="71d4" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">我们正在创建一个名为<strong class="lb iu"> BeerSnob </strong>的应用程序；一个专门为喝优质啤酒的人建立的网站。它允许用户分享关于他们在特定场所喝的啤酒的评论；在提供价格和口味信息的同时，对场地和啤酒进行评级。</p><p id="8bb5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个应用程序需要一个网站，一个API和一个数据库。在<a class="ae ky" href="https://mikehuls.medium.com/version-control-your-database-part-1-creating-migrations-and-seeding-992d86c90170" rel="noopener"> <strong class="lb iu">这篇文章</strong> </a>中，我们创建了一个具有迁移功能的数据库模型，在<a class="ae ky" href="https://mikehuls.medium.com/version-control-your-database-part-2-migrations-and-seeds-for-table-relations-d4fb185d95d8" rel="noopener"> <strong class="lb iu">这篇文章</strong> </a>中，我们为该应用创建了一个API。现在让我们继续创建运行这些服务的基础设施。</p><h2 id="cfe4" class="nn mr it bd ms no np dn mw nq nr dp na li ns nt nc lm nu nv ne lq nw nx ng ny bi translated">2.2概述</h2><p id="145e" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">首先，我们将看看这张我们希望BeerSnob的建筑看起来是什么样的美丽图表:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/474563a693c6e4160c9b59f48aa205cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Rxn8EYsPUwlj2B65FpUXew.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">我们的目标概述:我们在Docker中的应用(图片由<a class="ae ky" href="http://mikehuls.medium.com" rel="noopener">作者</a>提供)</p></figure><p id="d6fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么这一切意味着什么呢？首先要注意的是，我们现在有多个互连的服务运行在我们的单个服务器上。这本身就令人印象深刻，但它会变得更好。让我们先走过所有的街区:</p><p id="5ae5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将从包含所有其他内容的大<strong class="lb iu">灰色块</strong>开始。这是一个网络，在这个网络中，我们的所有服务(其他块)都位于我们的服务器上。请注意，只有两种方法可以进入我们的网络；通过端口80 (http)、端口443 (https)和端口54321从外部访问数据库。我们稍后会进入访问</p><p id="652c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">橙色块</strong>:这是我们的web服务器和反向代理。<br/>网络服务器保存我们的网站文件，并通过http和https向全世界发布；默认端口。<br/>反向代理负责传递请求。例如，我们捕捉<code class="fe nz oa ob oc b">beersnob.com/api</code>并将每个请求传递给蓝色块中的API服务，其他请求则传递给web服务器。</p><p id="3c91" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">蓝块</strong>:我们的API负责我们的web服务器和数据库之间的通信。注意，我们的web服务器可以在内部执行请求；它不一定要调用<code class="fe nz oa ob oc b">beersnob.com/api/users </code>比如用<code class="fe nz oa ob oc b">apicontainer/users</code>直接调用API容器就可以了。这提供了灵活性和安全性。</p><p id="b2c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">红色块</strong>:我们的数据库，保存着我们所有的数据。注意两件事:我们的web服务器和我们的数据库之间没有连接；这都是通过我们的API来处理的。第二件事是我们可以从网络外部访问我们的数据库。通过这种方式，我们可以连接到我们的数据库管理系统(例如PgAdmin)中的数据库，并处理我们数据库中的数据，导出数据，导入数据或制作存储过程等。</p><p id="400f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">查看本文 中关于如何容器化Postgres数据库的实用示例。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/74f49caf85c1678a126938e3d1a8f182.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wpt6ODtekC4P27d7"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">这个人非常想写一篇啤酒评论(图片由<a class="ae ky" href="https://www.pexels.com/@cottonbro" rel="noopener ugc nofollow" target="_blank"> Cottonbro </a>在<a class="ae ky" href="https://www.pexels.com/photo/photo-of-man-drinking-whiskey-7265878/" rel="noopener ugc nofollow" target="_blank"> Pexels </a>上提供)</p></figure><h2 id="77c8" class="nn mr it bd ms no np dn mw nq nr dp na li ns nt nc lm nu nv ne lq nw nx ng ny bi translated">3.创建docker-compose.yml</h2><p id="5fe2" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">我们将在docker-compose.yml中定义我们所有的服务和连接。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="9b94" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这区区50多行代码中，Docker编排了我们整个应用程序的所有容器。不过，我可以想象，如果你不熟悉作曲，可能会有点困惑，所以让我们从头到尾看一遍。您会看到定义了三个服务；一个数据库，API和web服务器。让我们一个一个地过一遍。</p><h2 id="0c93" class="nn mr it bd ms no np dn mw nq nr dp na li ns nt nc lm nu nv ne lq nw nx ng ny bi translated">3.1数据库</h2><p id="4922" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">查看我们的数据库容器的配置。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi om"><img src="../Images/529afa42593460fda5213e49d1fe27ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:728/format:webp/1*Z1pSjC6hpGyjhHMoUeUQYA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">服务1:我们应用程序的数据库</p></figure><p id="677b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> container_name </strong>:我们给容器起的名字。否则将生成一个随机名称</p><p id="3cee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">主机名</strong>:我们的容器可以通过这个主机名在内部网络上访问。请将此视为一种域名(http://beersnob_database)</p><p id="c53e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">图片</strong>:将要安装到容器中的软件。在这种情况下，它是默认的Postgres图像。</p><p id="c402" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">卷:卷是保存数据的一种方式。当我们运行这个映像时，Postgres被构建在容器中。然后我们可以在里面放一些数据。如果我们移除容器，我们的数据也会消失。卷允许我们将容器中的数据复制到主机。卷也可以由多个容器共享。我们还可以将源代码放在卷中，这样当我们在主机上编辑代码时，更改就会反映在容器中。</p><p id="bea4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">环境</strong>:这些是容器的设置。这里我们提供了两个数据库名，一个用户名和一个密码，这样Postgres可以设置我们的第一个数据库和第一个用户</p><p id="e330" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">端口:默认情况下，我们无法访问容器中的数据库。通过这个端口映射，我们可以接入数据库。如果我们转到localhost:54321，那么主机(Docker运行的地方)将容器内的网络连接到端口5432；我们的数据库就在那里运行。</p><p id="cb96" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">重启</strong>:如果我们的容器崩溃了会怎么样？我们选择了“除非-停止”，但我们也可以“总是”重启、不重启(“否”)和“失败时”重启。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h2 id="47ab" class="nn mr it bd ms no np dn mw nq nr dp na li ns nt nc lm nu nv ne lq nw nx ng ny bi translated">3.2 API</h2><p id="35ff" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">我们现在将检查API的所有配置，跳过我们已经在数据库中介绍过的部分。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi on"><img src="../Images/a102c8130eed62b0241a665de32a6c99.png" data-original-src="https://miro.medium.com/v2/resize:fit:648/format:webp/1*KTqaEjEwgS-lv8OIKt9s1w.png"/></div></figure><p id="6b3d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">构建:在数据库中，我们可以只传递一个图像，但是当涉及到我们的API时，我们必须做一些额外的工作。我们用包含dockerfile的<strong class="lb iu">上下文</strong>来引用名为“beersnob_api”的文件夹。在这个docker文件中，我们提取一个节点映像，安装我们的依赖项，并将我们的源代码复制到容器中。</p><p id="e17b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">卷</strong>:你可以看到我们将源代码(在<code class="fe nz oa ob oc b">./beersnob_api/src</code>中)镜像到容器中。如果我们在宿主中修改了源代码，那么一旦我们重新运行它，这个修改就会反映在容器中。</p><p id="788d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">环境</strong>:我们在node中的源代码需要用一个环境变量来调用(或者是“开发”或者是“生产”)。这是通过env文件完成的。在本文的后面部分会有更多的介绍。</p><p id="1d2f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">依赖于</strong>:一旦数据库启动并运行，就启动这个API容器。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h2 id="9a2a" class="nn mr it bd ms no np dn mw nq nr dp na li ns nt nc lm nu nv ne lq nw nx ng ny bi translated">3.3网络服务器</h2><p id="2fe4" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">网络服务器将保存我们网站的源代码(通过卷)。还要注意，我们在这个容器中映射了2个端口:80和443 (http和https)。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h2 id="57db" class="nn mr it bd ms no np dn mw nq nr dp na li ns nt nc lm nu nv ne lq nw nx ng ny bi translated">3.4内部集装箱网络</h2><p id="02e0" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">请注意，我们的容器化应用程序现在有了自己的内部网络，我们的服务可以用它来相互通信。想象一下，我们把应用程序放在beersnob.com。我们的网站不必调用<code class="fe nz oa ob oc b">http://beersnob.com/api/users</code>来从数据库中请求用户信息，相反，它可以只使用API的内部主机名(<code class="fe nz oa ob oc b">http://beersnob_api/api/users</code>)。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oo"><img src="../Images/de28ae55e03c5adeefcf81f5ffbeb7e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*T_e-bqQpoeTnSRE8"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">我们的容器就像互相堆叠的积木(图片由<a class="ae ky" href="https://www.pexels.com/@suzyhazelwood" rel="noopener ugc nofollow" target="_blank">苏西·黑兹尔伍德</a>在<a class="ae ky" href="https://www.pexels.com/photo/conceptual-photo-of-word-play-spelled-by-wooden-blocks-1275235/" rel="noopener ugc nofollow" target="_blank"> Pexels </a>上拍摄)</p></figure><h2 id="8665" class="nn mr it bd ms no np dn mw nq nr dp na li ns nt nc lm nu nv ne lq nw nx ng ny bi translated">4.环境文件</h2><p id="5b2e" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">还记得本文前面的环境文件吗？查看docker-compose.yml中的第33行；上面写着<code class="fe nz oa ob oc b">NODE_ENV=${BEERSNOB_ENVIRONMENT}</code>。这意味着我们必须为BEERSNOB_ENVIRONMENT变量提供一个env文件。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h2 id="887c" class="nn mr it bd ms no np dn mw nq nr dp na li ns nt nc lm nu nv ne lq nw nx ng ny bi translated">5.旋转我们的容器</h2><p id="542e" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">让我们旋转我们的容器！不用担心复制合成文件或没有所有数据；查看<a class="ae ky" href="https://github.com/mike-huls/beersnob_compose" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">这个链接</strong> </a>，在这里您可以克隆存储库并在您的机器上旋转容器。</p><p id="ed1c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">导航到包含docker-compose.yml的文件夹并调用<code class="fe nz oa ob oc b">docker-compose --env-file ./config/.env_dev up</code>。就是这样！这个命令提供了环境变量，复制了我们的源代码，安装了我们的依赖项，创建了所有的映像，最后启动了我们的网络和容器。让我们来测试一下！</p><ul class=""><li id="b739" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">去<code class="fe nz oa ob oc b"><a class="ae ky" href="http://localhost:54322/api/test" rel="noopener ugc nofollow" target="_blank">localhost</a>:54322/api/test</code>测试API。</li><li id="8903" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">转到本地主机或<code class="fe nz oa ob oc b">localhost:80</code>来测试web服务器</li><li id="8585" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">使用数据库管理系统(如PgAdmin)通过docker-compose.yml(第12–14行)中的凭证连接到我们在<code class="fe nz oa ob oc b">localhost:54321</code>上的数据库</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/5cf122e889f83b69fed2b9ea211703f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*cikHknUQ5PqTCNiT"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">我们的容器像时钟中的齿轮一样一起工作(图片由<a class="ae ky" href="https://www.pexels.com/@felixmittermeier" rel="noopener ugc nofollow" target="_blank"> Felix Mittermeier </a>在<a class="ae ky" href="https://www.pexels.com/photo/close-up-of-watch-against-black-background-325845/" rel="noopener ugc nofollow" target="_blank"> Pexels </a>上拍摄)</p></figure><h1 id="2bc4" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">结论</h1><p id="615f" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">正如我们所见，Compose增加了许多自动化、灵活性和标准化。就我个人而言，我认为以这样一种自动化的方式来处理基础设施是令人惊奇的。我们保持我们的服务解耦，我们的源代码隔离，我们的基础设施版本受控。希望这篇文章对您的应用程序容器化有所帮助。</p><p id="2db3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Docker提供了更多的功能。请继续关注下一部分，我们将在其中介绍在容器化应用程序中实现CI/CD、实现Docker Swarm以及Docker提供的更多特性。<a class="ae ky" href="https://mikehuls.medium.com/membership" rel="noopener">关注我</a>保持关注！</p><p id="cba4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望这篇文章是清楚的，但如果你有建议/澄清，请评论，以便我可以做出改进。同时，请查看我的<a class="ae ky" href="http://mikehuls.com/articles" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">关于各种编程相关主题的其他文章</strong> </a>，例如:</p><ul class=""><li id="4392" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><a class="ae ky" href="https://mikehuls.medium.com/docker-for-absolute-beginners-what-is-docker-and-how-to-use-it-examples-3d3b11efd830" rel="noopener"> Docker适合绝对初学者</a></li><li id="480b" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://mikehuls.medium.com/turn-your-code-into-a-real-program-packaging-running-and-distributing-scripts-using-docker-9ccf444e423f" rel="noopener">把你的代码变成一个真正的程序:使用Docker打包、运行和分发脚本</a></li><li id="1421" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://mikehuls.medium.com/why-is-python-so-slow-and-how-to-speed-it-up-485b5a84154e" rel="noopener">Python为什么慢，如何加速</a></li><li id="9c8a" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://mikehuls.medium.com/advanced-multi-tasking-in-python-applying-and-benchmarking-threadpools-and-processpools-90452e0f7d40" rel="noopener">Python中的高级多任务处理:应用线程池和进程池并进行基准测试</a></li><li id="d713" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://mikehuls.medium.com/write-your-own-c-extension-to-speed-up-python-x100-626bb9d166e7" rel="noopener">编写自己的C扩展来加速Python x100 </a></li><li id="7772" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">【Cython入门:如何在Python中执行&gt;每秒17亿次计算</li><li id="cc71" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://mikehuls.medium.com/create-a-fast-auto-documented-maintainable-and-easy-to-use-python-api-in-5-lines-of-code-with-4e574c00f70e" rel="noopener">用FastAPI用5行代码创建一个快速自动归档、可维护且易于使用的Python API</a></li></ul><p id="8e6b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">编码快乐！—迈克</p><p id="709a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">又及:喜欢我正在做的事吗？<a class="ae ky" href="https://mikehuls.medium.com/membership" rel="noopener">跟我来</a>！</p><div class="oq or gp gr os ot"><a href="https://mikehuls.medium.com/membership" rel="noopener follow" target="_blank"><div class="ou ab fo"><div class="ov ab ow cl cj ox"><h2 class="bd iu gy z fp oy fr fs oz fu fw is bi translated">通过我的推荐链接加入媒体-迈克·赫斯</h2><div class="pa l"><h3 class="bd b gy z fp oy fr fs oz fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="pb l"><p class="bd b dl z fp oy fr fs oz fu fw dk translated">mikehuls.medium.com</p></div></div><div class="pc l"><div class="pd l pe pf pg pc ph ks ot"/></div></div></a></div></div></div>    
</body>
</html>