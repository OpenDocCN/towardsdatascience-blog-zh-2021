<html>
<head>
<title>Time Series Forecasting with PyCaret Regression Module</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用PyCaret回归模块进行时间序列预测</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/time-series-forecasting-with-pycaret-regression-module-237b703a0c63?source=collection_archive---------4-----------------------#2021-04-14">https://towardsdatascience.com/time-series-forecasting-with-pycaret-regression-module-237b703a0c63?source=collection_archive---------4-----------------------#2021-04-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/9567a5d3c4c820427d3bc6795f37a155.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*6t7FzC-AdfDlA9LI"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">卢卡斯·布拉塞克在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><h1 id="0154" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">PyCaret</h1><p id="a72a" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">PyCaret是一个开源的低代码机器学习库和端到端的模型管理工具，内置于Python中，用于自动化机器学习工作流。它因其易用性、简单性以及快速有效地构建和部署端到端ML原型的能力而广受欢迎。</p><p id="4779" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">PyCaret是一个替代的低代码库，可以用来用几行代码替换数百行代码。这使得实验周期成倍地快速和有效。</p><p id="1bf9" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">py caret<strong class="ld ir">简单</strong> <strong class="ld ir">好用</strong>。PyCaret中执行的所有操作都顺序存储在一个<strong class="ld ir">管道</strong>中，该管道对于<strong class="ld ir">部署是完全自动化的。</strong>无论是输入缺失值、一键编码、转换分类数据、特征工程，甚至是超参数调整，PyCaret都能实现自动化。要了解PyCaret的更多信息，请观看这段1分钟的视频。</p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="mi mj l"/></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">py caret——Python中的开源、低代码机器学习库</p></figure><p id="7510" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">本教程假设您对PyCaret有一定的了解和经验。如果您以前没有使用过，没关系，您可以通过这些教程快速入门:</p><ul class=""><li id="2b9d" class="mk ml iq ld b le lz li ma lm mm lq mn lu mo ly mp mq mr ms bi translated"><a class="ae kc" rel="noopener" target="_blank" href="/pycaret-2-2-is-here-whats-new-ad7612ca63b"> PyCaret 2.2已经发布——新功能</a></li><li id="99ee" class="mk ml iq ld b le mt li mu lm mv lq mw lu mx ly mp mq mr ms bi translated"><a class="ae kc" rel="noopener" target="_blank" href="/announcing-pycaret-2-0-39c11014540e">宣布PyCaret 2.0 </a></li><li id="64ac" class="mk ml iq ld b le mt li mu lm mv lq mw lu mx ly mp mq mr ms bi translated">关于PyCaret你不知道的五件事</li></ul><h1 id="e209" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">正在安装PyCaret</h1><p id="9ab1" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">安装PyCaret非常容易，只需要几分钟。我们强烈建议使用虚拟环境来避免与其他库的潜在冲突。</p><p id="1e4a" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">PyCaret的默认安装是pycaret的精简版本，它只安装这里列出的<a class="ae kc" href="https://github.com/pycaret/pycaret/blob/master/requirements.txt" rel="noopener ugc nofollow" target="_blank">硬依赖项</a>。</p><pre class="me mf mg mh gt my mz na nb aw nc bi"><span id="8041" class="nd ke iq mz b gy ne nf l ng nh"><strong class="mz ir"># install slim version (default)<br/></strong>pip install pycaret</span><span id="44af" class="nd ke iq mz b gy ni nf l ng nh"><strong class="mz ir"># install the full version</strong><br/>pip install pycaret[full]</span></pre><p id="9b34" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">当你安装pycaret的完整版本时，这里列出的所有可选依赖项<a class="ae kc" href="https://github.com/pycaret/pycaret/blob/master/requirements-optional.txt" rel="noopener ugc nofollow" target="_blank"/>也会被安装。</p><h1 id="43da" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">👉PyCaret回归模块</h1><p id="7b1b" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">PyCaret <strong class="ld ir">回归模块</strong>是一个受监督的机器学习模块，用于估计一个<strong class="ld ir">因变量</strong>(通常称为“结果变量”，或“目标”)和一个或多个<strong class="ld ir">自变量</strong>(通常称为“特征”，或“预测器”)之间的关系。</p><p id="6503" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">回归的目标是预测连续值，如销售额、数量、温度、客户数量等。PyCaret中的所有模块都提供了许多<a class="ae kc" href="https://www.pycaret.org/preprocessing" rel="noopener ugc nofollow" target="_blank">预处理</a>功能，通过<a class="ae kc" href="https://www.pycaret.org/setup" rel="noopener ugc nofollow" target="_blank">设置</a>功能为建模准备数据。它有超过25个现成的算法和几个图来分析训练模型的性能。</p><h1 id="df12" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">👉具有PyCaret回归模块的时间序列</h1><p id="25b8" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">时间序列预测可以大致分为以下几类:</p><ul class=""><li id="7961" class="mk ml iq ld b le lz li ma lm mm lq mn lu mo ly mp mq mr ms bi translated"><strong class="ld ir">经典/统计模型</strong> —移动平均、指数平滑、ARIMA、萨里玛、TBATS</li><li id="961e" class="mk ml iq ld b le mt li mu lm mv lq mw lu mx ly mp mq mr ms bi translated"><strong class="ld ir">机器学习</strong> —线性回归、XGBoost、随机森林或任何具有归约方法的ML模型</li><li id="a555" class="mk ml iq ld b le mt li mu lm mv lq mw lu mx ly mp mq mr ms bi translated"><strong class="ld ir">深度学习</strong>—LSTM RNN</li></ul><p id="9367" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">本教程主要关注第二类，即<em class="nj">机器学习</em>。</p><p id="9c36" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">PyCaret的回归模块默认设置对于时序数据来说并不理想，因为它涉及的数据准备步骤很少，而这些步骤对于有序数据(<em class="nj">数据和时序数据</em>等序列)是无效的。</p><p id="57ae" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">例如，将数据集分成训练集和测试集是随机进行的。这对于时间序列数据没有意义，因为您不希望最近的日期包含在训练集中，而历史日期是测试集的一部分。</p><p id="4e63" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">时间序列数据也需要不同类型的交叉验证，因为它需要考虑日期的顺序。评估模型时，PyCaret回归模块默认使用k倍随机交叉验证。默认的交叉验证设置不适用于时序数据。</p><p id="1ec8" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">本教程的下一节将演示如何轻松更改PyCaret回归模块中的默认设置，使其适用于时间序列数据。</p><h1 id="23ec" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">👉资料组</h1><p id="813c" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">出于本教程的目的，我使用了美国航空公司的乘客数据集。你可以从<a class="ae kc" href="https://www.kaggle.com/chirag19/air-passengers" rel="noopener ugc nofollow" target="_blank"> Kaggle </a>下载数据集。</p><pre class="me mf mg mh gt my mz na nb aw nc bi"><span id="84bc" class="nd ke iq mz b gy ne nf l ng nh"><strong class="mz ir"># read csv file<br/></strong>import pandas as pd<br/>data = pd.read_csv('AirPassengers.csv')<br/>data['Date'] = pd.to_datetime(data['Date'])<br/>data.head()</span></pre><figure class="me mf mg mh gt jr gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/ed037ac162b9a722b28b74eba87cdfe2.png" data-original-src="https://miro.medium.com/v2/resize:fit:494/format:webp/1*9Gn9v-CWD3Eca3V92edtDw.png"/></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">样本行</p></figure><pre class="me mf mg mh gt my mz na nb aw nc bi"><span id="ab5d" class="nd ke iq mz b gy ne nf l ng nh"><strong class="mz ir"># create 12 month moving average<br/></strong>data['MA12'] = data['Passengers'].rolling(12).mean()</span><span id="337b" class="nd ke iq mz b gy ni nf l ng nh"><strong class="mz ir"># plot the data and MA<br/></strong>import plotly.express as px<br/>fig = px.line(data, x="Date", y=["Passengers", "MA12"], template = 'plotly_dark')<br/>fig.show()</span></pre><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nl"><img src="../Images/20969ee22e159c2dae977e7752844391.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vXL7m7exxTid0kGcU9jGUA.png"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">美国航空公司乘客数据集时间序列图，移动平均值= 12</p></figure><p id="91fd" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">由于算法不能直接处理日期，所以让我们从日期(如月和年)中提取一些简单的特征，并删除原始的日期列。</p><pre class="me mf mg mh gt my mz na nb aw nc bi"><span id="83ef" class="nd ke iq mz b gy ne nf l ng nh"><strong class="mz ir"># extract month and year from dates</strong><br/>data['Month'] = [i.month for i in data['Date']]<br/>data['Year'] = [i.year for i in data['Date']]</span><span id="b73e" class="nd ke iq mz b gy ni nf l ng nh"><strong class="mz ir"># create a sequence of numbers<br/></strong>data['Series'] = np.arange(1,len(data)+1)</span><span id="daff" class="nd ke iq mz b gy ni nf l ng nh"><strong class="mz ir"># drop unnecessary columns and re-arrange<br/></strong>data.drop(['Date', 'MA12'], axis=1, inplace=True)<br/>data = data[['Series', 'Year', 'Month', 'Passengers']] </span><span id="6cc5" class="nd ke iq mz b gy ni nf l ng nh"><strong class="mz ir"># check the head of the dataset</strong><br/>data.head()</span></pre><figure class="me mf mg mh gt jr gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/a19d0937623e241a359520b18bfb4844.png" data-original-src="https://miro.medium.com/v2/resize:fit:672/format:webp/1*T4xXVYhrfIyB35EDjl645A.png"/></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">提取要素后的样本行</p></figure><pre class="me mf mg mh gt my mz na nb aw nc bi"><span id="acef" class="nd ke iq mz b gy ne nf l ng nh"><strong class="mz ir"># split data into train-test set<br/></strong>train = data[data['Year'] &lt; 1960]<br/>test = data[data['Year'] &gt;= 1960]</span><span id="fc93" class="nd ke iq mz b gy ni nf l ng nh"><strong class="mz ir"># check shape<br/></strong>train.shape, test.shape<br/>&gt;&gt;&gt; ((132, 4), (12, 4))</span></pre><p id="a855" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">在初始化<code class="fe nn no np mz b">setup</code>之前，我已经手动分割了数据集。另一种方法是将整个数据集传递给PyCaret，让它处理拆分，在这种情况下，您必须在<code class="fe nn no np mz b">setup</code>函数中传递<code class="fe nn no np mz b">data_split_shuffle = False</code>，以避免在拆分前打乱数据集。</p><h1 id="3964" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">👉<strong class="ak">初始化设置</strong></h1><p id="79ca" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">现在是初始化<code class="fe nn no np mz b">setup</code>函数的时候了，在这里我们将使用<code class="fe nn no np mz b">fold_strategy</code>参数显式地传递训练数据、测试数据和交叉验证策略。</p><pre class="me mf mg mh gt my mz na nb aw nc bi"><span id="761a" class="nd ke iq mz b gy ne nf l ng nh"><strong class="mz ir"># import the regression module</strong><br/>from pycaret.regression import *</span><span id="f1f2" class="nd ke iq mz b gy ni nf l ng nh"><strong class="mz ir"># initialize setup</strong><br/>s = setup(data = train, test_data = test, target = 'Passengers', fold_strategy = 'timeseries', numeric_features = ['Year', 'Series'], fold = 3, transform_target = True, session_id = 123)</span></pre><h1 id="8d90" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">👉<strong class="ak">培训和评估所有模型</strong></h1><pre class="me mf mg mh gt my mz na nb aw nc bi"><span id="e1c9" class="nd ke iq mz b gy ne nf l ng nh">best = compare_models(sort = 'MAE')</span></pre><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nq"><img src="../Images/5b5c247ad0c01a54831824e818cd8f37.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Mnqplw1KbJYm9fxyH-46Tg.png"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">比较模型的结果</p></figure><p id="d898" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">基于交叉验证的MAE的最佳模型是<strong class="ld ir">最小角度回归</strong> (MAE: 22.3)。让我们检查一下测试集上的分数。</p><pre class="me mf mg mh gt my mz na nb aw nc bi"><span id="c555" class="nd ke iq mz b gy ne nf l ng nh">prediction_holdout = predict_model(best);</span></pre><figure class="me mf mg mh gt jr gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/e0d26cc809a0fe2387760343f347e8f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1352/format:webp/1*Us888u-jaVQzasN8Kn3z6A.png"/></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">预测模型(最佳)函数的结果</p></figure><p id="a441" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">测试集上的MAE比交叉验证的MAE高12%。不太好，但我们会努力的。让我们画出实际的和预测的线来可视化拟合。</p><pre class="me mf mg mh gt my mz na nb aw nc bi"><span id="9acb" class="nd ke iq mz b gy ne nf l ng nh"><strong class="mz ir"># generate predictions on the original dataset</strong><br/>predictions = predict_model(best, data=data)</span><span id="6627" class="nd ke iq mz b gy ni nf l ng nh"><strong class="mz ir"># add a date column in the dataset</strong><br/>predictions['Date'] = pd.date_range(start='1949-01-01', end = '1960-12-01', freq = 'MS')</span><span id="4a4e" class="nd ke iq mz b gy ni nf l ng nh"><strong class="mz ir"># line plot</strong><br/>fig = px.line(predictions, x='Date', y=["Passengers", "Label"], template = 'plotly_dark')</span><span id="7d7a" class="nd ke iq mz b gy ni nf l ng nh"><strong class="mz ir"># add a vertical rectange for test-set separation</strong><br/>fig.add_vrect(x0="1960-01-01", x1="1960-12-01", fillcolor="grey", opacity=0.25, line_width=0)</span><span id="8cae" class="nd ke iq mz b gy ni nf l ng nh">fig.show()</span></pre><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ns"><img src="../Images/711448f7828c7a393a026a0b66349a65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BlfRbXuxwcgvs-zrpK8C0Q.png"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">实际和预测的美国航空乘客(1949-1960)</p></figure><p id="5a8c" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">接近尾声的灰色背景是测试期(即1960年)。现在让我们最终确定模型，即在整个数据集(这次包括测试集)上训练最佳模型，即<em class="nj">最小角度回归</em>。</p><pre class="me mf mg mh gt my mz na nb aw nc bi"><span id="48b7" class="nd ke iq mz b gy ne nf l ng nh">final_best = finalize_model(best)</span></pre><h1 id="53c3" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">👉创建未来评分数据集</h1><p id="0256" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">现在，我们已经在整个数据集(1949年到1960年)上训练了我们的模型，让我们预测到1964年的未来五年。要使用我们的最终模型来生成未来预测，我们首先需要创建一个数据集，该数据集由未来日期的月、年、系列列组成。</p><pre class="me mf mg mh gt my mz na nb aw nc bi"><span id="6251" class="nd ke iq mz b gy ne nf l ng nh">future_dates = pd.date_range(start = '1961-01-01', end = '1965-01-01', freq = 'MS')</span><span id="3a1e" class="nd ke iq mz b gy ni nf l ng nh">future_df = pd.DataFrame()</span><span id="65c1" class="nd ke iq mz b gy ni nf l ng nh">future_df['Month'] = [i.month for i in future_dates]<br/>future_df['Year'] = [i.year for i in future_dates]    <br/>future_df['Series'] = np.arange(145,(145+len(future_dates)))</span><span id="d14e" class="nd ke iq mz b gy ni nf l ng nh">future_df.head()</span></pre><figure class="me mf mg mh gt jr gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/749621912848d837eed2300b7db932f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:476/format:webp/1*KD4G6VVmbuq-w_6088Vl8Q.png"/></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">future_df中的示例行</p></figure><p id="5fcc" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">现在，让我们使用<code class="fe nn no np mz b">future_df</code>来评分并生成预测。</p><pre class="me mf mg mh gt my mz na nb aw nc bi"><span id="c962" class="nd ke iq mz b gy ne nf l ng nh">predictions_future = predict_model(final_best, data=future_df)<br/>predictions_future.head()</span></pre><figure class="me mf mg mh gt jr gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/a34d82440df3ece1c83c3f3a5e0809d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:676/format:webp/1*5mqx2Qi2En2VPq9zNZG87g.png"/></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">预测中的样本行_未来</p></figure><p id="cc50" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">我们来画一下。</p><pre class="me mf mg mh gt my mz na nb aw nc bi"><span id="dc42" class="nd ke iq mz b gy ne nf l ng nh">concat_df = pd.concat([data,predictions_future], axis=0)<br/>concat_df_i = pd.date_range(start='1949-01-01', end = '1965-01-01', freq = 'MS')<br/>concat_df.set_index(concat_df_i, inplace=True)</span><span id="9e73" class="nd ke iq mz b gy ni nf l ng nh">fig = px.line(concat_df, x=concat_df.index, y=["Passengers", "Label"], template = 'plotly_dark')<br/>fig.show()</span></pre><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nv"><img src="../Images/f4923fdb31e0798417d0662e0fe086fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IjglwJEeU2hZMsjxM8yPbg.png"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">实际(1949-1960年)和预测(1961-1964年)美国航空乘客</p></figure><p id="4318" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">那不是很容易吗？</p></div><div class="ab cl nw nx hu ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="ij ik il im in"><p id="0a8e" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">使用Python中的这个轻量级工作流自动化库，您可以实现的目标是无限的。如果你觉得这很有用，请不要忘记给我们GitHub库上的⭐️。</p><p id="69e2" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">要了解更多关于PyCaret的信息，请关注我们的LinkedIn和Youtube。</p><p id="dd8d" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">加入我们的休闲频道。此处邀请链接<a class="ae kc" href="https://join.slack.com/t/pycaret/shared_invite/zt-p7aaexnl-EqdTfZ9U~mF0CwNcltffHg" rel="noopener ugc nofollow" target="_blank">。</a></p><h1 id="f7e7" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">您可能还对以下内容感兴趣:</h1><p id="66c3" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated"><a class="ae kc" rel="noopener" target="_blank" href="/build-your-own-automl-in-power-bi-using-pycaret-8291b64181d">使用PyCaret 2.0 </a> <br/> <a class="ae kc" rel="noopener" target="_blank" href="/deploy-machine-learning-pipeline-on-cloud-using-docker-container-bec64458dc01">在Power BI中构建您自己的AutoML使用Docker </a> <br/> <a class="ae kc" rel="noopener" target="_blank" href="/deploy-machine-learning-model-on-google-kubernetes-engine-94daac85108b">在Azure上部署机器学习管道在Google Kubernetes引擎上部署机器学习管道</a> <br/> <a class="ae kc" rel="noopener" target="_blank" href="/deploy-machine-learning-pipeline-on-aws-fargate-eb6e1c50507">在AWS Fargate上部署机器学习管道</a> <br/> <a class="ae kc" rel="noopener" target="_blank" href="/build-and-deploy-your-first-machine-learning-web-app-e020db344a99">构建和部署您的第一个机器学习web应用</a> <br/> <a class="ae kc" rel="noopener" target="_blank" href="/deploy-pycaret-and-streamlit-app-using-aws-fargate-serverless-infrastructure-8b7d7c0584c2">使用AWS Fargate无服务器</a> <br/> <a class="ae kc" rel="noopener" target="_blank" href="/build-and-deploy-machine-learning-web-app-using-pycaret-and-streamlit-28883a569104">构建和部署机器</a></p><h1 id="3c01" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">重要链接</h1><p id="229f" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated"><a class="ae kc" href="https://pycaret.readthedocs.io/en/latest/installation.html" rel="noopener ugc nofollow" target="_blank">文档</a> <br/> <a class="ae kc" href="https://medium.com/@moez_62905" rel="noopener">博客</a><br/><a class="ae kc" href="http://www.github.com/pycaret/pycaret" rel="noopener ugc nofollow" target="_blank">GitHub</a><br/><a class="ae kc" href="https://stackoverflow.com/questions/tagged/pycaret" rel="noopener ugc nofollow" target="_blank">stack overflow</a><br/><a class="ae kc" href="https://pycaret.readthedocs.io/en/latest/installation.html" rel="noopener ugc nofollow" target="_blank">安装PyCaret <br/> </a> <a class="ae kc" href="https://pycaret.readthedocs.io/en/latest/tutorials.html" rel="noopener ugc nofollow" target="_blank">笔记本教程<br/> </a> <a class="ae kc" href="https://pycaret.readthedocs.io/en/latest/contribute.html" rel="noopener ugc nofollow" target="_blank">投稿于PyCaret </a></p><h1 id="a057" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">想了解某个特定模块？</h1><p id="2896" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">单击下面的链接查看文档和工作示例。</p><p id="09ad" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated"><a class="ae kc" href="https://pycaret.readthedocs.io/en/latest/api/classification.html" rel="noopener ugc nofollow" target="_blank">分类<br/></a>T3】回归T5】T6】聚类 <br/> <a class="ae kc" href="https://pycaret.readthedocs.io/en/latest/api/anomaly.html" rel="noopener ugc nofollow" target="_blank">异常检测</a> <br/> <a class="ae kc" href="https://pycaret.readthedocs.io/en/latest/api/nlp.html" rel="noopener ugc nofollow" target="_blank">自然语言处理<br/> </a> <a class="ae kc" href="https://pycaret.readthedocs.io/en/latest/api/arules.html" rel="noopener ugc nofollow" target="_blank">关联规则挖掘</a></p></div></div>    
</body>
</html>