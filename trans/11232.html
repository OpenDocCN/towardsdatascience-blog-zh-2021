<html>
<head>
<title>SQL Puzzle Optimization: The UDTF Approach for a Decay Function</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SQL 难题优化:衰减函数的 UDTF 方法</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/sql-puzzle-optimization-the-udtf-approach-for-a-decay-function-4b4b3cdc8596?source=collection_archive---------16-----------------------#2021-11-03">https://towardsdatascience.com/sql-puzzle-optimization-the-udtf-approach-for-a-decay-function-4b4b3cdc8596?source=collection_archive---------16-----------------------#2021-11-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="5196" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">在 SQL 中构建一个衰减函数并不简单，但是很有趣。到目前为止，最好的答案是使用窗口函数，但我们能在雪花中使用 JS UDTF 做得更好吗？在此查找结果</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/36db23ec5b22b8c6ac37ca4f3f760597.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x-blONRBPeihxuJ5JBanaQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">一个 UDTF 解决了衰减分数 SQL 难题(图片由作者提供)</p></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="kv kw l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kx" href="https://www.youtube.com/watch?v=xydidZrKGII" rel="noopener ugc nofollow" target="_blank">在 YouTube 上观看</a></p></figure><p id="e4cf" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated"><a class="lu lv ep" href="https://medium.com/u/6363936853d?source=post_page-----4b4b3cdc8596--------------------------------" rel="noopener" target="_blank">布列塔尼·贝内特</a>和<a class="lu lv ep" href="https://medium.com/u/6aceb4900e59?source=post_page-----4b4b3cdc8596--------------------------------" rel="noopener" target="_blank">克莱尔·卡罗尔</a> <a class="ae kx" href="https://xkcd.com/356/" rel="noopener ugc nofollow" target="_blank">用</a><a class="ae kx" href="https://invincible-failing-289.notion.site/SQL-Puzzle-Calculating-engagement-with-a-decay-function-661cda4a4e754cbaa45f42a5356138e7" rel="noopener ugc nofollow" target="_blank">一个有趣的 SQL 谜题</a>剪贴数据-推特。几个小时后，Benn Eifert 用 SQL 窗口函数<a class="ae kx" href="https://twitter.com/bennpeifert/status/1453003455325421583" rel="noopener ugc nofollow" target="_blank">提出了一个很棒的解决方案。然后</a><a class="lu lv ep" href="https://medium.com/u/eb13b4c116f4?source=post_page-----4b4b3cdc8596--------------------------------" rel="noopener" target="_blank"> TJ Murphy </a>在雪花中测试了一下，解释了为什么窗口函数比 joins 好。现在，轮到我上场了。用 JavaScript UDTF 我能做得更好吗？找到下面的结果。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lw kw l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lw kw l"/></div></figure><h1 id="1f51" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">为什么要用 UDTF？</h1><p id="1fa6" class="pw-post-body-paragraph ky kz iq la b lb mp jr ld le mq ju lg lh mr lj lk ll ms ln lo lp mt lr ls lt ij bi translated">让我们首先来看看窗口纯 SQL 解决方案:</p><pre class="kg kh ki kj gt mu mv mw mx aw my bi"><span id="36d1" class="mz ly iq mv b gy na nb l nc nd">with t as (<br/>    select *<br/>        , row_number() over (<br/>            partition by name order by week desc<br/>        ) as week_count<br/>    from decay_puzzle_10m<br/>),</span><span id="419e" class="mz ly iq mv b gy ne nb l nc nd">select *<br/>    , points_this_week * power(0.9, week_count - 1) as decayed_points<br/>    , sum(decayed_points) over (<br/>        partition by name order by week rows between unbounded preceding and current row<br/>    ) as decayed_points_cumulative<br/>    , decayed_points_cumulative / power(0.9, week_count - 1) as score_this_week_calc<br/>from t<br/>;</span></pre><p id="7fe3" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">优点:它很聪明，效率也很高。</p><p id="7d21" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated"><strong class="la ir">缺点</strong>:难以理解、解析、修改和复用。</p><p id="dd81" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">与此同时一个<a class="ae kx" href="https://docs.snowflake.com/en/developer-guide/udf/javascript/udf-javascript-tabular-functions.html" rel="noopener ugc nofollow" target="_blank"> <strong class="la ir"> JS 表格 UDF </strong> </a>正好可以做这个问题所需要的:</p><ul class=""><li id="09e0" class="nf ng iq la b lb lc le lf lh nh ll ni lp nj lt nk nl nm nn bi translated">作为一个表格 UDF，它将<strong class="la ir">接收整个表格并逐行查看</strong>。</li><li id="d0ca" class="nf ng iq la b lb no le np lh nq ll nr lp ns lt nk nl nm nn bi translated">由于它可以对在之前看到的行进行<strong class="la ir">存储，因此它可以为所需的衰减数学积累数据。</strong></li><li id="4873" class="nf ng iq la b lb no le np lh nq ll nr lp ns lt nk nl nm nn bi translated">由于它允许<strong class="la ir">分区</strong>，先前行的内存可以为每个段拆分。</li><li id="2f0c" class="nf ng iq la b lb no le np lh nq ll nr lp ns lt nk nl nm nn bi translated">随着每一行被处理，它可以<strong class="la ir">输出每一行的正确结果</strong>。</li></ul><h1 id="122a" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">天真的 UDTF</h1><p id="e4d2" class="pw-post-body-paragraph ky kz iq la b lb mp jr ld le mq ju lg lh mr lj lk ll ms ln lo lp mt lr ls lt ij bi translated">这是 Claire &amp; Brittany 针对该问题发布的原始 Python 逻辑:</p><pre class="kg kh ki kj gt mu mv mw mx aw my bi"><span id="88f0" class="mz ly iq mv b gy na nb l nc nd">for n in range(number_of_weeks):<br/>    sum = 0<br/>    for i in range(n+1):<br/>        sum += points[i] * pow(0.9, n-i)<br/>    print(f"Score: {sum}")</span></pre><p id="beb8" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">让我们把它翻译成一个 JS UDTF:</p><pre class="kg kh ki kj gt mu mv mw mx aw my bi"><span id="0a90" class="mz ly iq mv b gy na nb l nc nd">create or replace function decay_udtf_v1(points float)<br/>returns table (output_col float)<br/>language javascript<br/>as $$<br/>{<br/>    processRow: function f(row, rowWriter, context){<br/>        this.pointarr.unshift(row.POINTS); // store history<br/>        sum = 0;<br/>        this.pointarr.forEach(function (item, index) {<br/>            sum += item * Math.pow(0.9, index);<br/>        })<br/>        rowWriter.writeRow({OUTPUT_COL: sum});<br/>    }        <br/>    , initialize: function(argumentInfo, context) {<br/>         this.pointarr = [];<br/>         this.counter = 0;<br/>    }<br/>}<br/>$$;</span></pre><p id="9f3a" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">这基本上是用<code class="fe nt nu nv mv b">processRow</code>处理每一行，将前面的行值存储到数组<code class="fe nt nu nv mv b">pointarr</code>中。它对衰减值进行<code class="fe nt nu nv mv b">forEach</code>到<code class="fe nt nu nv mv b">sum</code>，并输出结果。</p><p id="dccc" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">使用它既简单又干净:</p><pre class="kg kh ki kj gt mu mv mw mx aw my bi"><span id="eb22" class="mz ly iq mv b gy na nb l nc nd">select output_col, a.*<br/>from decay_puzzle_10m a<br/>    , table(decay_udtf_v1(points_this_week::float) over(partition by name order by week));</span></pre><p id="3d4f" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">但是这比窗口函数快吗？我们来测试一下。</p><h1 id="0a25" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">基准测试天真的 JS UDTF 与窗口函数</h1><p id="a19c" class="pw-post-body-paragraph ky kz iq la b lb mp jr ld le mq ju lg lh mr lj lk ll ms ln lo lp mt lr ls lt ij bi translated">首先，让我们从 Claire &amp; Brittany 给我们的 4 个样本行中创建一个 1000 万行的表:</p><pre class="kg kh ki kj gt mu mv mw mx aw my bi"><span id="a8f3" class="mz ly iq mv b gy na nb l nc nd">create table decay_puzzle as</span><span id="b5e4" class="mz ly iq mv b gy ne nb l nc nd">select 'claire' as name, '2021-10-04'::date as week, 3 as points_this_week, 3.00 as score_this_week<br/>union all select 'claire', '2021-10-11'::date, 1, 3.70<br/>union all select 'claire', '2021-10-18'::date, 2, 5.33<br/>union all select 'claire', '2021-10-25'::date, 0, 4.797<br/>;</span><span id="6774" class="mz ly iq mv b gy ne nb l nc nd">create or replace table decay_puzzle_10m as</span><span id="8734" class="mz ly iq mv b gy ne nb l nc nd">select name ||  seq8() % 25000 name, week+seq8()%100 week, points_this_week, score_this_week<br/>from decay_puzzle, table(generator(rowcount =&gt; 100000)) g1, table(generator(rowcount =&gt; 25)) g2<br/>;</span></pre><p id="5658" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">这创建了 1000 万行，有 25，000 个不同的名称，每个名称有 400 周。日期需要清理，但这与我们的目的无关。</p><p id="858c" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">现在是时候对我们的 1000 万行样本进行基准测试了，将窗口函数解决方案与 XL 仓库中的 JS UDTF 朴素解决方案进行对比。获胜者是…</p><ul class=""><li id="d1ce" class="nf ng iq la b lb lc le lf lh nh ll ni lp nj lt nk nl nm nn bi translated">车窗功能:46s</li><li id="50fb" class="nf ng iq la b lb no le np lh nq ll nr lp ns lt nk nl nm nn bi translated">JS 天真的 UDTF: 36s</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nw"><img src="../Images/d866c771064edbd4b6a884069d3bb37b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gS-9QMOkfoNTGClWoVkUOA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">窗口函数 vs JS UDTF 超过 10M 行——天真的 JS UDTF 赢了(图片由作者提供)</p></figure><p id="87bc" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">我们有赢家了！但这还不是全部。你可能已经注意到了，我一直称 UDTF 为“天真”。事实证明，如果我们在其中优化 JS，结果会更好:</p><ul class=""><li id="2ff0" class="nf ng iq la b lb lc le lf lh nh ll ni lp nj lt nk nl nm nn bi translated">车窗功能:46s</li><li id="2eff" class="nf ng iq la b lb no le np lh nq ll nr lp ns lt nk nl nm nn bi translated">JS 天真的 UDTF: 36s</li><li id="6b87" class="nf ng iq la b lb no le np lh nq ll nr lp ns lt nk nl nm nn bi translated">JS 优化的 UDTF: 9s</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nx"><img src="../Images/a96f4527c49ecafe105cd224ca62b740.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PtAhmhVD7T5pm95XaNtL9w.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">窗口函数与超过 10M 行的 JS UDTF 的对比——优化的 JS UDTF 胜出(图片由作者提供)</p></figure><p id="3e05" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">优化 JS 代码是一个巨大的胜利——原来我们的原始代码相当低效。稍后我会在这里分享它的代码，但首先我想看一些更有趣的东西:当我们从 10M 行增加到 100M 行时会发生什么？</p><h1 id="8854" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">用 100M 行对简单的 JS UDTF 和窗口函数进行基准测试</h1><p id="22f3" class="pw-post-body-paragraph ky kz iq la b lb mp jr ld le mq ju lg lh mr lj lk ll ms ln lo lp mt lr ls lt ij bi translated">要生成 1 亿行，我们可以使用类似的 SQL:</p><pre class="kg kh ki kj gt mu mv mw mx aw my bi"><span id="3ddb" class="mz ly iq mv b gy na nb l nc nd">create or replace table decay_puzzle_100m<br/>as<br/>select name ||  seq8() % 25000 name, week+seq8()%100 week, points_this_week, score_this_week<br/>from decay_puzzle, table(generator(rowcount =&gt; 1000000)) g1, table(generator(rowcount =&gt; 25)) g2<br/>;</span></pre><p id="5211" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">仍然有 25，000 个不同的名字，但是现在每个名字有 4，000 周(而不是 400 周)。</p><p id="6ad5" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">如果我们再次尝试我们的 3 个解决方案，结果令人惊讶:</p><ul class=""><li id="ba97" class="nf ng iq la b lb lc le lf lh nh ll ni lp nj lt nk nl nm nn bi translated">车窗功能:16s</li><li id="4b0f" class="nf ng iq la b lb no le np lh nq ll nr lp ns lt nk nl nm nn bi translated">JS naive: 378s</li><li id="3ac9" class="nf ng iq la b lb no le np lh nq ll nr lp ns lt nk nl nm nn bi translated">JS 优化:95s</li></ul><p id="8a52" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">真有意思！由于每个名字的观察次数增加了 10 倍，JS 解决方案的时间也增加了 10 倍。但是 SQL 窗口函数变得更快了！这是 1/3 时间内的 10x 行。</p><p id="b94c" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">我们在这里看到的是并行化的力量，以及 SQL 优化器在根据输入和可用资源的大小决定路径时所做的假设。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ny"><img src="../Images/b0bcce25466761c98ed31e44b0d57dff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FiX81LmtSaIIEWXlnuYswA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">10 倍的数据，1/3 的时间—使用 SQL 中的窗口函数(图片由作者提供)</p></figure><h1 id="cb05" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">优化的 JS UDTF 代码</h1><p id="4144" class="pw-post-body-paragraph ky kz iq la b lb mp jr ld le mq ju lg lh mr lj lk ll ms ln lo lp mt lr ls lt ij bi translated">让我们回到 JS 代码，以及为什么它可以被优化以 1/4 的时间运行:</p><ul class=""><li id="a982" class="nf ng iq la b lb lc le lf lh nh ll ni lp nj lt nk nl nm nn bi translated"><code class="fe nt nu nv mv b">Array.push()</code>要求增加分配给数组的内存。如果我们知道输入的大小，我们可以预先分配一块连续的内存。</li><li id="f28a" class="nf ng iq la b lb no le np lh nq ll nr lp ns lt nk nl nm nn bi translated"><code class="fe nt nu nv mv b">reduce()</code>似乎比<code class="fe nt nu nv mv b">foreach()</code>跑得快</li><li id="1b00" class="nf ng iq la b lb no le np lh nq ll nr lp ns lt nk nl nm nn bi translated"><code class="fe nt nu nv mv b">power(0.9, week_count — 1)</code>运行太多次，我们可以预先计算它——特别是如果我们知道输入的大小。如果我们不这样做，我们可以做一些懒惰的评估。</li></ul><p id="9deb" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">优化的 JS UDTF:</p><pre class="kg kh ki kj gt mu mv mw mx aw my bi"><span id="9a5b" class="mz ly iq mv b gy na nb l nc nd">create or replace function decay_udtf_optimized(points float)<br/>returns table (output_col float)<br/>language javascript<br/>as $$<br/>{<br/>    processRow: function f(row, rowWriter, context){<br/>        this.pointarr[this.counter]=row.POINTS;<br/>        reduce_func = function(prev, curr, idx, arr) {<br/>            return prev + curr * this.precalc[this.counter - idx];<br/>        };<br/>        sum = this.pointarr.reduce(<br/>            reduce_func.bind({precalc: this.precalc, counter: this.counter}), 0<br/>        );<br/>        rowWriter.writeRow({OUTPUT_COL: sum});<br/>        this.counter++;<br/>    }        <br/>    , initialize: function(argumentInfo, context) {<br/>        var preoptimized = 4000 // testing for 400|4000<br/>        this.pointarr = Array(preoptimized);<br/>        this.precalc = Array(preoptimized);<br/>        this.precalc[0]=1;<br/>        for (let i = 1; i &lt; preoptimized; i++) {<br/>            this.precalc[i] = this.precalc[i-1]*0.9;<br/>        }<br/>        this.counter = 0;<br/>    }<br/>}<br/>$$;</span></pre><p id="5bc0" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">附加说明:如果我们去掉乘法，用一个<code class="fe nt nu nv mv b">prev + curr</code>代替<code class="fe nt nu nv mv b">prev + curr * this.precalc[this.counter — idx]</code>，那么处理 1 亿行的时间从 95 秒减少到 75 秒。这不是我们想要计算的，但是它显示了通过优化 JS 中的数学可以节省多少时间。</p><h1 id="ec33" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">我们学到了什么</h1><ul class=""><li id="aaa8" class="nf ng iq la b lb mp le mq lh nz ll oa lp ob lt nk nl nm nn bi translated">UDTFs 是实现逻辑的一种自然方式，就像 Claire &amp; Brittany 提出的难题中所要求的那样</li><li id="859b" class="nf ng iq la b lb no le np lh nq ll nr lp ns lt nk nl nm nn bi translated">这个 UDTF 不仅使用起来更优雅，而且在对 10M 行进行基准测试时，它比纯 SQL 更快。</li><li id="2cb5" class="nf ng iq la b lb no le np lh nq ll nr lp ns lt nk nl nm nn bi translated">在 JS UDF 中优化数学可以带来巨大的性能提升。</li><li id="1216" class="nf ng iq la b lb no le np lh nq ll nr lp ns lt nk nl nm nn bi translated">SQL 窗口函数很酷，并由 SQL 优化器进行了优化。</li><li id="f4e8" class="nf ng iq la b lb no le np lh nq ll nr lp ns lt nk nl nm nn bi translated">可伸缩性以奇怪的方式工作:有时增加 10 倍的数据会使整个事情花费的时间减少 3 倍。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/8f9634c708cbd09f27596a3a8a28e25a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1170/format:webp/1*lWVrziNSEYLfNyDK9Lvv9A.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">对于 10 倍的数据，JS UDTFs 花费了 10 倍的时间，但是 SQL 窗口函数花费了 1/3 的时间(图片由作者提供)</p></figure><h1 id="aa06" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">后续步骤</h1><ul class=""><li id="9034" class="nf ng iq la b lb mp le mq lh nz ll oa lp ob lt nk nl nm nn bi translated">爪哇 UDTF 的表现会更好吗？<a class="ae kx" href="https://www.snowflake.com/snowday/" rel="noopener ugc nofollow" target="_blank">雪花发生了很多事情</a>，包括 UDF。敬请关注。</li></ul><div class="od oe gp gr of og"><a rel="noopener follow" target="_blank" href="/the-most-popular-languages-on-reddit-analyzed-with-snowflake-and-a-java-udtf-4e58c8ba473c"><div class="oh ab fo"><div class="oi ab oj cl cj ok"><h2 class="bd ir gy z fp ol fr fs om fu fw ip bi translated">Reddit 上最流行的语言，用雪花和 Java UDTF 分析</h2><div class="on l"><h3 class="bd b gy z fp ol fr fs om fu fw dk translated">Reddit 上最流行的语言(除了英语)会让你大吃一惊。为了制作这张图表，我分析了几乎一个…</h3></div><div class="oo l"><p class="bd b dl z fp ol fr fs om fu fw dk translated">towardsdatascience.com</p></div></div><div class="op l"><div class="oq l or os ot op ou kp og"/></div></div></a></div><ul class=""><li id="a4ca" class="nf ng iq la b lb lc le lf lh nh ll ni lp nj lt nk nl nm nn bi translated">检查衰减评分函数的真实用例，如轨道模型中的<a class="ae kx" href="https://github.com/orbit-love/orbit-model#Activity-Decay" rel="noopener ugc nofollow" target="_blank">所示。</a></li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ov"><img src="../Images/bfb890303982806855da8edb41361e25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AQ7GbR82LhoXf6B7ZWmzHA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kx" href="https://github.com/orbit-love/orbit-model#Activity-Decay" rel="noopener ugc nofollow" target="_blank">轨道模型</a>中的衰变计分。</p></figure><ul class=""><li id="cb72" class="nf ng iq la b lb lc le lf lh nh ll ni lp nj lt nk nl nm nn bi translated">布列塔尼深入轨道模型:</li></ul><div class="od oe gp gr of og"><a href="https://www.brittanybennett.com/post/replicating-the-orbit-model-an-exercise-in-measuring-movement-power" rel="noopener  ugc nofollow" target="_blank"><div class="oh ab fo"><div class="oi ab oj cl cj ok"><h2 class="bd ir gy z fp ol fr fs om fu fw ip bi translated">复制轨道模型:测量运动能力的练习🚀</h2><div class="on l"><h3 class="bd b gy z fp ol fr fs om fu fw dk translated">由于克莱尔·卡罗尔的推荐，我最近发现了轨道模型。轨道模型是一个自我…</h3></div><div class="oo l"><p class="bd b dl z fp ol fr fs om fu fw dk translated">www.brittanybennett.com</p></div></div><div class="op l"><div class="ow l or os ot op ou kp og"/></div></div></a></div><ul class=""><li id="2675" class="nf ng iq la b lb lc le lf lh nh ll ni lp nj lt nk nl nm nn bi translated"><a class="lu lv ep" href="https://medium.com/u/eb13b4c116f4?source=post_page-----4b4b3cdc8596--------------------------------" rel="noopener" target="_blank"> TJ 墨菲</a>第一反应:</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lw kw l"/></div></figure><h1 id="cea1" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">想要更多吗？</h1><ul class=""><li id="bd91" class="nf ng iq la b lb mp le mq lh nz ll oa lp ob lt nk nl nm nn bi translated">用一个<a class="ae kx" href="http://bit.ly/sf-free-trial" rel="noopener ugc nofollow" target="_blank">雪花免费试用</a>账户试试吧——你只需要一个电子邮件地址就可以开始了。</li></ul><p id="91f2" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">我是 Felipe Hoffa，雪花的数据云倡导者。谢谢你和我一起冒险。你可以在推特和<a class="ae kx" href="https://www.linkedin.com/in/hoffa/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上关注我。查看 reddit.com/r/snowflake<a class="ae kx" href="https://www.reddit.com/r/snowflake/" rel="noopener ugc nofollow" target="_blank">的最有趣的雪花新闻。</a></p></div></div>    
</body>
</html>