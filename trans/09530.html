<html>
<head>
<title>What if I tell you RDBMS can handle time-series data?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如果我告诉你RDBMS可以处理时序数据会怎么样？</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/what-if-i-tell-you-rdbms-can-handle-time-series-data-77a5bb43da06?source=collection_archive---------13-----------------------#2021-09-04">https://towardsdatascience.com/what-if-i-tell-you-rdbms-can-handle-time-series-data-77a5bb43da06?source=collection_archive---------13-----------------------#2021-09-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="bcdd" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">本文旨在简化您的数据堆栈。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/0f3a68efc15aee4723254104919ff032.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UA5lwZwb90R7rScybNsDdw.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">在<a class="ae kv" href="https://unsplash.com/s/photos/time?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae kv" href="https://unsplash.com/@abdullishere?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Abdul A </a>拍摄的照片</p></figure><p id="5841" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">今天，有大量的NoSQL数据库可用于处理时间序列数据。毫无疑问，它们解决了许多用例，并且还提供了与可视化工具的现成集成，但是在向数据架构添加新组件(<em class="ls">假设它是处理时序数据</em>的新组件)之前，让我们退一步分析一下，这真的有必要吗？从长远来看，每个新组件都有自己的运营挑战。</p><p id="c17b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">本文旨在简化您的数据堆栈。假设您的用例围绕关系数据库，现在您必须处理时间序列数据，以便可以对这些数据进行接近实时的查询。你会添加一个新的组件吗？</p><p id="560f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">嗯，答案可能取决于很多原因，但是不要排除关系数据库。请继续阅读，了解如何在关系数据库中处理时间序列数据，并做出相应的决定。</p><p id="8b5e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">说到这里，我们先来了解一下什么是时序数据。</p><h1 id="872b" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">时序数据</h1><blockquote class="ml mm mn"><p id="d254" class="kw kx ls ky b kz la jr lb lc ld ju le mo lg lh li mp lk ll lm mq lo lp lq lr ij bi translated">在时间维度上捕获的数据(事实)是时间序列数据，因此该数据的一个轴将始终是时间。该数据通常但不一定是(近)实时捕获的。<em class="iq">它帮助我们回答如下问题:</em></p></blockquote><ul class=""><li id="f8c0" class="mr ms iq ky b kz la lc ld lf mt lj mu ln mv lr mw mx my mz bi translated">每分钟有多少用户访问应用程序？</li><li id="9bd8" class="mr ms iq ky b kz na lc nb lf nc lj nd ln ne lr mw mx my mz bi translated">每小时销售多少产品？</li><li id="736c" class="mr ms iq ky b kz na lc nb lf nc lj nd ln ne lr mw mx my mz bi translated">下个月的预测销售额是多少？</li></ul><p id="f615" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，这些时间序列数据需要以一种能够提供有意义结果的方式被接收、存储和转换。为了有效处理，对于时间序列数据有几个注意事项:</p><ul class=""><li id="0cb9" class="mr ms iq ky b kz la lc ld lf mt lj mu ln mv lr mw mx my mz bi translated">它几乎是实时摄入的。</li><li id="bccf" class="mr ms iq ky b kz na lc nb lf nc lj nd ln ne lr mw mx my mz bi translated">用于实时报告。一般来说，近实时总量是根据这些数据计算出来的。对它的聚合查询本质上是临时的，因此在数据上定义的任何聚合都会随着数据的到来而改变。</li><li id="ec0b" class="mr ms iq ky b kz na lc nb lf nc lj nd ln ne lr mw mx my mz bi translated">它是仅附加数据，但可能具有较高的接收率，因此需要支持快速写入。</li><li id="6a31" class="mr ms iq ky b kz na lc nb lf nc lj nd ln ne lr mw mx my mz bi translated">可以分析历史趋势来预测未来的指标。像ARIMA这样的机器学习算法被用来做时间序列预测。</li></ul><p id="3533" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在问题来了，我们如何在RDBMS中设计这些数据？</p></div><div class="ab cl nf ng hu nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="ij ik il im in"><p id="393d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">考虑到高摄取率和接近实时的聚合，关系数据库无法直接处理上述数据考虑事项。但是给<em class="ls">关系数据库</em>添加一些<em class="ls">填充</em>，我们可以让它变得非常强大，以便处理时序数据。我们现在要讨论的关系数据库是<em class="ls"> postgresql </em>，所涉及的填充是它的<em class="ls">扩展</em>。</p><p id="de66" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将在下面讨论两个这样的扩展。</p><h1 id="a40a" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">时间刻度数据库</h1><p id="b77c" class="pw-post-body-paragraph kw kx iq ky b kz nm jr lb lc nn ju le lf no lh li lj np ll lm ln nq lp lq lr ij bi translated">时间刻度数据库是PostgreSQL的开源扩展。由于它是作为postgresql的扩展捆绑在一起的，所以它可以支持postgresql的所有功能，如关系查询、完整的sql支持(<em class="ls">而不是类似sql的</em>)以及实时查询支持。</p><h2 id="d5f1" class="nr lu iq bd lv ns nt dn lz nu nv dp md lf nw nx mf lj ny nz mh ln oa ob mj oc bi translated">timescaledb如何处理时序数据</h2><p id="776a" class="pw-post-body-paragraph kw kx iq ky b kz nm jr lb lc nn ju le lf no lh li lj np ll lm ln nq lp lq lr ij bi translated">它有一个超表的概念，超表是简单的时间数据块，存储在标准表中。这些超表是用户的抽象层，用户可以像在普通表上一样简单地在这个表上进行查询、连接或其他任何操作。</p><p id="7fcf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对这些超表的摄取是非常快的。根据文档，它支持每台服务器每秒接收超过150万个指标。</p><p id="60c0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，对于连续聚合，可以在这些超表上创建物化视图，以便聚合接近实时可用。在内部，时间刻度数据库有后台进程负责刷新视图，并且刷新间隔和参数是可配置的。它还提供了与Kafka、kinesis等的集成，用于数据摄取。</p><blockquote class="ml mm mn"><p id="53e8" class="kw kx ls ky b kz la jr lb lc ld ju le mo lg lh li mp lk ll lm mq lo lp lq lr ij bi translated">一个<strong class="ky ir">物化视图</strong>是一个包含查询结果的数据库对象</p></blockquote><h2 id="d256" class="nr lu iq bd lv ns nt dn lz nu nv dp md lf nw nx mf lj ny nz mh ln oa ob mj oc bi translated">如何创建这个时间序列数据的实时可视化？</h2><p id="7c14" class="pw-post-body-paragraph kw kx iq ky b kz nm jr lb lc nn ju le lf no lh li lj np ll lm ln nq lp lq lr ij bi translated">物化视图有助于提供实时聚合，也可用于创建实时可视化。由于该扩展与PostgreSQL捆绑在一起，因此它可以与Graphana等任何可视化工具集成，并刷新连续聚合。</p><p id="f585" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，有了这个简单的架构，你就知道如何获取时间序列数据，甚至创建可视化数据，这样就可以在办公室的大显示器上演示了(<em class="ls">好吧，如果我们去办公室，就祈祷吧</em>)。很简单，不是吗？只有一个关系层？</p><p id="1485" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">除此之外，它还有预测时间序列数据的方法！timescaledb的<a class="ae kv" href="https://www.timescale.com/" rel="noopener ugc nofollow" target="_blank">文档</a>非常丰富，可以跟着做概念验证。</p><h1 id="4a94" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">管道数据库</h1><p id="70ae" class="pw-post-body-paragraph kw kx iq ky b kz nm jr lb lc nn ju le lf no lh li lj np ll lm ln nq lp lq lr ij bi translated">Pipeline DB是PostgreSQL支持的另一个扩展，它也可用于实时报告，与timescaledb类似，它支持对时序数据的物化视图进行实时聚合。</p><p id="2d2c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">关于pipeline DB需要注意的是，它的效率来自于它不存储原始数据，所以如果您需要存储原始数据(IMO，它应该总是被存储)。但是它看起来也很有前途，并且是非常值得一提的用例。</p></div><div class="ab cl nf ng hu nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="ij ik il im in"><p id="f8f9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">嗯，就是这样。我想到写这篇文章是因为我非常喜欢将关系和时间序列捆绑在一起以简化堆栈的想法，以及完整的SQL支持。类似SQL的查询的问题是，加入它仍然需要时间，而完整的SQL也允许轻松加入堆栈。</p><p id="fb27" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在您知道了，如何在PostgreSQL中添加cape并使其成为一个超级数据库。好吧，玩笑归玩笑，在做任何设计决定之前理解所有的概念是很重要的，我希望这篇文章能帮助你获得一些理解。</p><p id="1f1a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><br/>下次见JD</p></div></div>    
</body>
</html>