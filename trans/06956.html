<html>
<head>
<title>Which Python Data Structure Should You Use?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">应该使用哪种Python数据结构？</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/which-python-data-structure-should-you-use-fa1edd82946c?source=collection_archive---------5-----------------------#2021-06-24">https://towardsdatascience.com/which-python-data-structure-should-you-use-fa1edd82946c?source=collection_archive---------5-----------------------#2021-06-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="301f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">列表、元组、集合、字典...什么时候使用哪种内置数据结构？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/3fa10071fd7811cf1f32f8aecaa5f69d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*fcMxpM2JzDSLbdlt"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@victoriano?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">维多利亚诺·伊斯基耶多</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="9ad2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Python是一种面向对象的编程(OOP)语言。类和对象用于结构化和模块化代码，以便可重用和易于修改。OOP要求使用<strong class="lb iu">数据结构</strong>来组织和存储数据，以一种可以被有效访问的方式。</p><p id="974d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Python有<strong class="lb iu">原语</strong>(或基本)数据结构，如浮点、整数、字符串和布尔。Python还有<strong class="lb iu">非原语</strong>数据结构，比如列表、元组、字典和集合。非原始数据结构存储各种格式的值的集合，而不是单个值。有些可以在数据结构中保存数据结构，从而增加了数据存储能力的深度和复杂性。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lv"><img src="../Images/40f03ebabed7158a5257189e0231b3aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2JFd94q0vzsEcr-LB-220g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者照片</p></figure><p id="2ed7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将研究每种内置数据结构，以决定何时使用一种结构优于另一种结构。</p><h2 id="7372" class="lw lx it bd ly lz ma dn mb mc md dp me li mf mg mh lm mi mj mk lq ml mm mn mo bi translated">什么是可变性？</h2><p id="c140" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">可变性意味着数据结构中的数据在创建后可以被修改(添加、删除或更改)。可变性是选择数据结构时要考虑的一个重要因素。如果你知道你不需要改变内部状态，考虑使用一个不可变的对象来确保它是线程安全的，并且没有任何东西可以覆盖你的数据。</p><h1 id="fa51" class="mu lx it bd ly mv mw mx mb my mz na me jz nb ka mh kc nc kd mk kf nd kg mn ne bi translated">列表</h1><p id="7fdc" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">为了表示按整数位置索引的项目序列，可以使用的一种数据结构是列表。列表包含零个或多个元素，并且可以包含不同类型的元素(甚至是对象！).这使得列表非常强大，因为它们允许您创建深度和复杂的数据结构。</p><p id="6448" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">列表是<em class="nf">可变的</em>，这意味着您可以灵活地添加、删除或更改元素。另一种顺序数据结构是一个<strong class="lb iu">元组</strong>；这两者的区别在于元组是不可变的。</p><p id="58ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为列表有一个顺序元素:如果你只想跟踪唯一的<em class="nf">值而不关心顺序，使用Python <strong class="lb iu"> set </strong>。</em></p><p id="43e3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<code class="fe ng nh ni nj b">[]</code>或<code class="fe ng nh ni nj b">list()</code>创建列表。使用<code class="fe ng nh ni nj b">list()</code>进行类型转换。</p><h2 id="d2fd" class="lw lx it bd ly lz ma dn mb mc md dp me li mf mg mh lm mi mj mk lq ml mm mn mo bi translated">一些值得注意的方法和技巧</h2><p id="1f0e" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated"><strong class="lb iu">获取列表项:<br/> </strong> <code class="fe ng nh ni nj b">my_list[0]</code>通过偏移获取列表项。像字符串一样，负索引可以用来从末尾向后计数。<br/> <code class="fe ng nh ni nj b">my_list[0] = ‘new item'</code>通过偏移改变列表项。<br/> <code class="fe ng nh ni nj b">my_list[0:2]</code>通过偏移切片来提取项目。该示例返回<code class="fe ng nh ni nj b">my_list</code>的前两个元素。</p><p id="e503" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">添加列表项:<br/> </strong> <code class="fe ng nh ni nj b">append()</code>在列表末尾添加一项。<br/> <code class="fe ng nh ni nj b">extend()</code>或<code class="fe ng nh ni nj b">+=</code>将一个列表合并到另一个列表中。<br/> <code class="fe ng nh ni nj b">insert()</code>在任何偏移前添加一项。</p><p id="bc43" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">删除列表项目:</strong> <br/> <code class="fe ng nh ni nj b">remove()</code>从列表中删除项目值。<br/> <code class="fe ng nh ni nj b">pop()</code>删除最后一个(或指定的)元素，同时返回值。<br/> <code class="fe ng nh ni nj b">del</code>根据项目在列表中的位置删除项目。<code class="fe ng nh ni nj b">del</code>是Python语句，不是list方法。</p><p id="3ef3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ng nh ni nj b">join()</code>返回组合列表项的字符串。<code class="fe ng nh ni nj b">join()</code>的参数是一个字符串或任何可迭代的字符串序列。<br/> <code class="fe ng nh ni nj b">len()</code>返回列表中的项数。<code class="fe ng nh ni nj b">count()</code>返回指定值出现的次数。</p><h1 id="bc88" class="mu lx it bd ly mv mw mx mb my mz na me jz nb ka mh kc nc kd mk kf nd kg mn ne bi translated">元组</h1><p id="7ad8" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">元组也是一种有序的数据结构，就像列表一样。但是，元组是<em class="nf">不可变的；</em>创建元组后，不能添加、删除或更改项目。元组不同于列表，它的函数要少得多，因为它们在定义后不能修改。元组包含零个或多个元素，并且可以包含不同的不可变类型的元素。</p><p id="0f8e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">元组相对于列表的优势:</p><ul class=""><li id="4291" class="nk nl it lb b lc ld lf lg li nm lm nn lq no lu np nq nr ns bi translated">元组使用更少的空间</li><li id="aa8e" class="nk nl it lb b lc nt lf nu li nv lm nw lq nx lu np nq nr ns bi translated">不变性防止错误地更改元组项</li><li id="25c2" class="nk nl it lb b lc nt lf nu li nv lm nw lq nx lu np nq nr ns bi translated">元组可以用作字典键</li><li id="5765" class="nk nl it lb b lc nt lf nu li nv lm nw lq nx lu np nq nr ns bi translated">函数参数作为元组传递</li></ul><p id="c98a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<code class="fe ng nh ni nj b">()</code>或没有括号的逗号分隔的元素列表创建元组。使用<code class="fe ng nh ni nj b">tuple()</code>进行类型转换。</p><h2 id="9b1f" class="lw lx it bd ly lz ma dn mb mc md dp me li mf mg mh lm mi mj mk lq ml mm mn mo bi translated">一些值得注意的方法和技巧</h2><p id="ead1" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated"><code class="fe ng nh ni nj b">count()</code>返回一个元素在元组中被找到的次数<br/> <code class="fe ng nh ni nj b">index()</code>返回一个元素的索引位置</p><h1 id="2be3" class="mu lx it bd ly mv mw mx mb my mz na me jz nb ka mh kc nc kd mk kf nd kg mn ne bi translated">字典</h1><p id="bd56" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">字典不使用偏移量，而是使用<em class="nf">键</em>来关联每个值。这意味着顺序是不可跟踪的，如果你打算使用字典的话，这并不重要。字典键是不可变的和唯一的，然而，字典是可变的。可以添加、删除或更改键值元素。简而言之，字典非常类似于<em class="nf">散列表</em>。</p><p id="2429" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<code class="fe ng nh ni nj b">{}</code>创建字典。使用<code class="fe ng nh ni nj b">dict()</code>进行类型转换。</p><h2 id="f8fc" class="lw lx it bd ly lz ma dn mb mc md dp me li mf mg mh lm mi mj mk lq ml mm mn mo bi translated">一些值得注意的方法和技巧</h2><p id="e197" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated"><code class="fe ng nh ni nj b">my_dict[‘key’]</code>通过键获取一个项目<br/> <code class="fe ng nh ni nj b">my_dict['key'] = ‘value'</code>使用一个键添加(或改变，如果它已经存在)一个值。<br/> <code class="fe ng nh ni nj b">update()</code>将一个字典的键和值合并到另一个字典中。<br/> <code class="fe ng nh ni nj b">del</code>按提供的键删除项目。<code class="fe ng nh ni nj b">del</code>是Python语句，不是字典方法。<br/> <code class="fe ng nh ni nj b">keys()</code>返回所有字典键。<code class="fe ng nh ni nj b">values()</code>返回字典中的所有值。<code class="fe ng nh ni nj b">items()</code>返回所有字典键值对。</p><h1 id="c8a7" class="mu lx it bd ly mv mw mx mb my mz na me jz nb ka mh kc nc kd mk kf nd kg mn ne bi translated">设置</h1><p id="fd1e" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">集合就像一本字典，只有关键字，没有值。这意味着集合是唯一的，而不是连续的(无序存储)。集合也是可变的。集合包含零个或多个元素，并且可以包含不同的不可变类型的元素。</p><p id="2ff5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本质上，当你想知道某样东西是否存在，而对它一无所知时，就要用到集合。如果跟踪值的顺序或存储相同值的倍数很重要，考虑使用空间友好的<strong class="lb iu">元组</strong>来代替。</p><p id="3dd0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<code class="fe ng nh ni nj b">set()</code>创建器械包。使用<code class="fe ng nh ni nj b">set()</code>进行类型转换。</p><h2 id="b351" class="lw lx it bd ly lz ma dn mb mc md dp me li mf mg mh lm mi mj mk lq ml mm mn mo bi translated">一些值得注意的方法和技巧</h2><p id="3836" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated"><code class="fe ng nh ni nj b">add()</code>向集合中添加不存在的项目<br/> <code class="fe ng nh ni nj b">clear()</code>从集合中删除所有项目<br/> <code class="fe ng nh ni nj b">intersect()</code>返回两个集合的交集<br/> <code class="fe ng nh ni nj b">union()</code>返回两个集合的并集</p><h1 id="e643" class="mu lx it bd ly mv mw mx mb my mz na me jz nb ka mh kc nc kd mk kf nd kg mn ne bi translated">概括起来</h1><ul class=""><li id="c615" class="nk nl it lb b lc mp lf mq li ny lm nz lq oa lu np nq nr ns bi translated">如果需要跟踪排序，使用<strong class="lb iu">列表</strong>或<strong class="lb iu">元组</strong></li><li id="8aa8" class="nk nl it lb b lc nt lf nu li nv lm nw lq nx lu np nq nr ns bi translated">如果你只想跟踪<em class="nf">唯一的</em>值，而不关心顺序，使用Python <strong class="lb iu"> set </strong></li><li id="66aa" class="nk nl it lb b lc nt lf nu li nv lm nw lq nx lu np nq nr ns bi translated">如果一旦定义了对象就不需要修改，那么使用一个<strong class="lb iu">元组</strong>来节省空间并确保没有东西会覆盖你的数据</li><li id="bf1a" class="nk nl it lb b lc nt lf nu li nv lm nw lq nx lu np nq nr ns bi translated">如果你需要跟踪和修改键值对结构的数据，使用<strong class="lb iu">字典</strong></li></ul></div></div>    
</body>
</html>