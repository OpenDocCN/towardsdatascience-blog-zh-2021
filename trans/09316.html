<html>
<head>
<title>How Does Python Garbage Collection Work?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python垃圾收集是如何工作的？</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-does-python-garbage-collection-work-a5dc544d880d?source=collection_archive---------10-----------------------#2021-08-29">https://towardsdatascience.com/how-does-python-garbage-collection-work-a5dc544d880d?source=collection_archive---------10-----------------------#2021-08-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/38ed314af73b2ca91b9a29c420be99f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R_oW7RroQB6Fy5cSFjX_JA.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">不幸的是，此时此地，我在Pixabay 的旅程结束了</p></figure><div class=""/><div class=""><h2 id="4de7" class="pw-subtitle-paragraph kg ji jj bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dk translated">保持Python对象被引用，否则它们将被释放到内存中。</h2></div><p id="dccc" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">每种编程语言都有其特定的垃圾收集机制。这是指那些未使用的变量，它们仍然占据内存中的一些空间，最终将被删除。这对于更有效地利用存储空间是很重要的。</p><p id="34c1" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你有没有想过Python垃圾收集是如何工作的？特别是，Python如何知道一个对象变得无用？在本文中，我将演示这种机制。将使用一些内置功能，如<code class="fe lu lv lw lx b">id()</code>和<code class="fe lu lv lw lx b">getrefcount()</code>。</p><h1 id="b319" class="ly lz jj bd ma mb mc md me mf mg mh mi kp mj kq mk ks ml kt mm kv mn kw mo mp bi translated">显示内存地址</h1><figure class="mq mr ms mt gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/dbc3bcf25a7c5ecb8efd265843f9958e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EGmj9rsf96Ef1hIsjA8hgg.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">图片来自<a class="ae jg" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=6569156" rel="noopener ugc nofollow" target="_blank"> Pixabay </a></p></figure><p id="b12a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在我们继续垃圾收集机制之前，有必要建立内存地址的概念。别担心，不一定要深潜。我将演示如何使用<code class="fe lu lv lw lx b">id()</code>函数，这就足够了。</p><p id="cffe" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">首先，让我们定义两个Python列表。就内容而言，它们可以完全相同。</p><pre class="mq mr ms mt gt mu lx mv mw aw mx bi"><span id="3d3d" class="my lz jj lx b gy mz na l nb nc">a = [1, 2, 3]<br/>b = [1, 2, 3]</span></pre><figure class="mq mr ms mt gt iv gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/afa70381fa4e1261cfc9d012a55f4f41.png" data-original-src="https://miro.medium.com/v2/resize:fit:446/format:webp/1*JGItX3x-QjqcvF3AmgxTHg.png"/></div></figure><p id="00ec" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">显然，变量a和b是一样的。但是，这是否意味着这两个变量指向同一个内存地址呢？不。我们来验证一下。</p><pre class="mq mr ms mt gt mu lx mv mw aw mx bi"><span id="c2ac" class="my lz jj lx b gy mz na l nb nc">id(a)<br/>id(b)</span></pre><figure class="mq mr ms mt gt iv gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/f7eb7d90a051eb56cea4f73691af023c.png" data-original-src="https://miro.medium.com/v2/resize:fit:498/format:webp/1*hTFnL2TRp0r9uk_46e07tg.png"/></div></figure><p id="4103" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe lu lv lw lx b">id()</code>函数会给我们一个对象的“身份”，用整数表示。如图所示，整数是不同的。所以，变量a和b指向不同的内存地址，尽管此刻它们是相同的。</p><p id="4640" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我们创建另一个变量a1，并让a1 = a，就不会创建新的对象。相反，a1将指向与a相同的内存地址。</p><figure class="mq mr ms mt gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nf"><img src="../Images/a6951bac718dcafda70fb92fd7e93496.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oU0C41v8dyGjjP1I1WwZCg.png"/></div></div></figure><p id="4fb1" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">有道理，这就是为什么当我们改变a时，a1也会被更新。</p><figure class="mq mr ms mt gt iv gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/c7befdd047c52b3405752a5fd72d461d.png" data-original-src="https://miro.medium.com/v2/resize:fit:542/format:webp/1*YcL_LBNxLqKWcvrPzEv14w.png"/></div></figure><h1 id="d49f" class="ly lz jj bd ma mb mc md me mf mg mh mi kp mj kq mk ks ml kt mm kv mn kw mo mp bi translated">参考计数</h1><figure class="mq mr ms mt gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/210b41a5c8cf2957d36520a25491b9eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iJkjNAvDDM38QhzaQ946Sw.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">图片来自<a class="ae jg" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=5419527" rel="noopener ugc nofollow" target="_blank"> Pixabay </a></p></figure><p id="d853" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在我们可以讨论最重要的概念——引用计数。</p><p id="8d44" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">基本上Python中的<strong class="la jk">引用计数</strong>表示对某个对象的引用次数。这很重要，因为垃圾收集机制依赖引用计数来决定对象是应该保留在内存中还是应该释放在内存中。</p><p id="798b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">也就是说，当对象的引用计数等于零时，它将被释放。非常直观合理的，当一个对象没有任何引用的时候，就意味着这个对象被抛弃了，没有用了。</p><p id="0ae1" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">那么我们如何获得引用计数呢？事实上，它可以被设计成一个内部机制，而不是简单地向开发者展示。但是，Python实际上在<code class="fe lu lv lw lx b">sys</code>模块中提供了一个名为<code class="fe lu lv lw lx b">getrefcount()</code>的内置函数，可以方便地查询对象的引用计数。</p><p id="73a6" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">要使用这个功能，我们需要从<code class="fe lu lv lw lx b">sys</code>模块中导入它。这是Python 3的任何版本都内置的，所以您不需要下载或安装任何东西就可以使用它。</p><pre class="mq mr ms mt gt mu lx mv mw aw mx bi"><span id="2128" class="my lz jj lx b gy mz na l nb nc">from sys import getrefcount</span></pre><p id="8699" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后，让我们使用这个函数来查询引用计数。</p><pre class="mq mr ms mt gt mu lx mv mw aw mx bi"><span id="77c2" class="my lz jj lx b gy mz na l nb nc">a = [1, 2, 3]<br/>print(getrefcount(a))</span></pre><figure class="mq mr ms mt gt iv gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/dc2b50c45003465ec95d62e5fb6ee414.png" data-original-src="https://miro.medium.com/v2/resize:fit:570/format:webp/1*F3OPpDnFdMZ5mFgZkrR7Xw.png"/></div></figure><p id="2450" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这个例子中，我创建了一个变量<code class="fe lu lv lw lx b">a</code>，并为它分配了一个简单的Python列表。然后，<code class="fe lu lv lw lx b">getrefcount()</code>函数显示这个对象的引用计数是2。</p><p id="1477" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是等等，为什么是2？请看看下面的图表。</p><figure class="mq mr ms mt gt iv gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/4f92a0e82fe036d56b565587e88d7aea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1124/format:webp/1*Zp4DUcx37_PImr49iBpC7g.png"/></div></figure><p id="3924" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">事实上，当我们使用<code class="fe lu lv lw lx b">getrefcount()</code>函数查询一个对象的引用计数时，该函数必须建立对该对象的引用。这就是引用计数为2的原因。表示变量<code class="fe lu lv lw lx b">a</code>和函数<code class="fe lu lv lw lx b">getrefcount()</code>都在引用列表<code class="fe lu lv lw lx b">[1, 2, 3]</code>。</p><h1 id="011e" class="ly lz jj bd ma mb mc md me mf mg mh mi kp mj kq mk ks ml kt mm kv mn kw mo mp bi translated">什么会增加引用计数？</h1><figure class="mq mr ms mt gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/e3fe8bce9af87f5223ef98949cbb8c14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_kFQMBxq6TiqTFW6JyTi7Q.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">图片来自<a class="ae jg" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=1452219" rel="noopener ugc nofollow" target="_blank">Pixabay</a>s . Hermann&amp;f . Richter</p></figure><p id="a9c9" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在我们已经了解了引用计数以及如何查询一个对象的引用计数，但是什么会导致引用计数发生变化呢？以下操作将使引用计数增加1。</p><p id="7fac" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk"> 1。创建对象并将其赋给一个变量。</strong></p><p id="dfb9" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这已经在前面的部分中演示过了。当我们创建Python列表对象<code class="fe lu lv lw lx b">[1, 2, 3]</code>并将其赋给变量<code class="fe lu lv lw lx b">a</code>时，列表对象<code class="fe lu lv lw lx b">[1, 2, 3]</code>的引用计数被设置为1。</p><p id="db4b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk"> 2。该对象被分配给另一个变量。</strong></p><p id="53e5" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当对象被赋给另一个变量时，引用计数将加1。但是，请注意，这并不意味着以下内容。</p><pre class="mq mr ms mt gt mu lx mv mw aw mx bi"><span id="68e8" class="my lz jj lx b gy mz na l nb nc">a = [1, 2, 3]<br/>b = [1, 2, 3]  # This will NOT increase the reference count</span></pre><p id="a709" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这已在第1节中讨论过。虽然列表相同，但它们是不同的对象。要增加引用计数，我们可以执行以下操作。</p><pre class="mq mr ms mt gt mu lx mv mw aw mx bi"><span id="ee4f" class="my lz jj lx b gy mz na l nb nc">a = [1, 2, 3]<br/>b = a</span></pre><figure class="mq mr ms mt gt iv gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/ad8ab41bdb2e11529a4d35cc4be05170.png" data-original-src="https://miro.medium.com/v2/resize:fit:528/format:webp/1*ZNHPH4vifgAfCv-jliU5YQ.png"/></div></figure><p id="7da1" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk"> 3。对象作为参数在函数中传递。</strong></p><p id="7ca0" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当我们使用函数<code class="fe lu lv lw lx b">getrefcount(a)</code>时，情况正是如此。变量<code class="fe lu lv lw lx b">a</code>作为参数被传递到函数中，因此它肯定会被引用。</p><p id="c84f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk"> 4。对象被追加到容器类型中。</strong></p><p id="50b8" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">容器类型可以是列表、字典或元组，如下例所示。</p><pre class="mq mr ms mt gt mu lx mv mw aw mx bi"><span id="295a" class="my lz jj lx b gy mz na l nb nc">my_list = [a]</span></pre><figure class="mq mr ms mt gt iv gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/8e0898544aa19aea0a82fd49f4c5147f.png" data-original-src="https://miro.medium.com/v2/resize:fit:486/format:webp/1*goZKBqCml7CNVbXboqn79w.png"/></div></figure><h1 id="dc34" class="ly lz jj bd ma mb mc md me mf mg mh mi kp mj kq mk ks ml kt mm kv mn kw mo mp bi translated">什么会减少引用计数？</h1><figure class="mq mr ms mt gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/6e442d3c84c81e57db305d05239607d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RQAOGhcNs3w2QWkI9cNy5w.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">图片来自<a class="ae jg" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=463928" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>的<a class="ae jg" href="https://pixabay.com/users/blickpixel-52945/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=463928" rel="noopener ugc nofollow" target="_blank">迈克尔·施瓦森伯格</a></p></figure><p id="a01b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，让我们来看看将减少引用计数的场景。</p><p id="2c6c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk"> 1。该对象已从函数范围中删除。这通常发生在函数完成执行时。</strong></p><p id="0f32" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我们尝试在函数执行期间打印引用计数，就可以验证这一点。所以，我们可以这样设计实验。</p><pre class="mq mr ms mt gt mu lx mv mw aw mx bi"><span id="934f" class="my lz jj lx b gy mz na l nb nc">def my_func(var):<br/>    print('Function executing: ', getrefcount(var))</span><span id="aaff" class="my lz jj lx b gy nl na l nb nc">my_func(a)<br/>print('Function executed', getrefcount(a))</span></pre><figure class="mq mr ms mt gt iv gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/3dca0e120bdb4e0dc30ce3e506438340.png" data-original-src="https://miro.medium.com/v2/resize:fit:996/format:webp/1*Adrt3yceAWj8IIBS2jXbIA.png"/></div></figure><p id="d401" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是为什么引用计数是4而不是3呢？这就涉及到Python的另一个概念，就是“调用栈”。</p><blockquote class="nn no np"><p id="c091" class="ky kz nq la b lb lc kk ld le lf kn lg nr li lj lk ns lm ln lo nt lq lr ls lt im bi translated">当在Python中调用一个函数时，一个新的帧被推送到调用栈上用于它的本地执行，并且每次函数调用返回时，它的帧被弹出调用栈。</p></blockquote><p id="1d46" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个概念不在本文中展开，因为它超出了讨论范围。如果您不熟悉调用堆栈，我可以告诉您的是，您看到的带有回溯和行号的错误消息正是来自调用堆栈。</p><figure class="mq mr ms mt gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nu"><img src="../Images/2b7b49d8347beb53a561402691f2d4d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MrXlgokBt7ncxi7rEfICwQ.png"/></div></div></figure><p id="7d31" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，在执行<code class="fe lu lv lw lx b">my_func()</code>期间，引用计数为4。在它被执行之后，引用计数被减少回2。</p><p id="b1b8" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk"> 2。当引用对象的变量被删除时。</strong></p><p id="3b4a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个很好理解。当我们使用<code class="fe lu lv lw lx b">del</code>命令删除变量时，该变量将不再引用该对象。</p><figure class="mq mr ms mt gt iv gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/22732d21ad7c8bfaa22d860d79302a28.png" data-original-src="https://miro.medium.com/v2/resize:fit:566/format:webp/1*QlDIW2Pq1Ip4KacKduR5UA.png"/></div></figure><p id="f60e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请注意，如果我们在这种情况下删除变量<code class="fe lu lv lw lx b">a</code>，对象的引用计数将变为0。这正是垃圾收集将释放该对象的场景。然而，这也意味着我们不能再使用<code class="fe lu lv lw lx b">getrefcount()</code>函数来检查引用计数。</p><p id="2f0b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk"> 3。当引用该对象的变量被赋予另一个对象时。</strong></p><p id="b950" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这种情况可能会更频繁地发生。当一个变量被赋予另一个对象时，当前对象的引用计数将减一。当然，新对象的引用计数会增加。</p><figure class="mq mr ms mt gt iv gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/b0d457339772b07b552811c718431f54.png" data-original-src="https://miro.medium.com/v2/resize:fit:500/format:webp/1*j0jfUbPHybkE56ajKtnZgw.png"/></div></figure><p id="9869" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk"> 4。当对象从容器中移除时。</strong></p><p id="7295" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当对象被追加到容器中时，引用计数将+1。相反，当它被移除时，引用计数将为-1。</p><figure class="mq mr ms mt gt iv gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/c089b58de6042b239f04d42e39e87464.png" data-original-src="https://miro.medium.com/v2/resize:fit:518/format:webp/1*XnZTtEA3TprxJlie5Q-Dug.png"/></div></figure><p id="7bd6" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当然，如果我们删除容器，引用计数也会减少。</p><figure class="mq mr ms mt gt iv gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/60a94483af40e4880fa4c5aaf9d29110.png" data-original-src="https://miro.medium.com/v2/resize:fit:524/format:webp/1*39PCd5dlKBRhNt5luu-hLA.png"/></div></figure><h1 id="9381" class="ly lz jj bd ma mb mc md me mf mg mh mi kp mj kq mk ks ml kt mm kv mn kw mo mp bi translated">一个特例</h1><p id="ea09" class="pw-post-body-paragraph ky kz jj la b lb nz kk ld le oa kn lg lh ob lj lk ll oc ln lo lp od lr ls lt im bi translated">请注意，只有一般对象可以通过这种方式进行调查。这意味着当值是一个文字常量，比如数字<code class="fe lu lv lw lx b">123</code>或字符串<code class="fe lu lv lw lx b">'abc'</code>时，我们确实有特殊的情况。</p><figure class="mq mr ms mt gt iv gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/ca58870fd7e82e4631ab746d92beca1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:394/format:webp/1*6PdGiKek3glqreyPXiB-Eg.png"/></div></figure><p id="5ad9" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如上所示，引用计数可能是意外的。在我的例子中，我使用Google Colab，这样环境可以被共享，这导致了如此大的引用计数。</p><p id="9fcd" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">另一个值得一提的重要因素是，文字常量保证位于相同的内存位置。</p><figure class="mq mr ms mt gt iv gh gi paragraph-image"><div class="gh gi of"><img src="../Images/954f88ee210bb7da097a45104a69d662.png" data-original-src="https://miro.medium.com/v2/resize:fit:472/format:webp/1*qmt_6_cmmeA9QqPNIqVlbw.png"/></div></figure><p id="23fc" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，只要在某处使用了数字<code class="fe lu lv lw lx b">123</code>，引用计数就可能增加。即使我们只有一个变量引用它，引用计数也可能更多。</p><h1 id="e91d" class="ly lz jj bd ma mb mc md me mf mg mh mi kp mj kq mk ks ml kt mm kv mn kw mo mp bi translated">摘要</h1><figure class="mq mr ms mt gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/573e470325b543ae27acb10e65780ee1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kXwCtbUJA7l0IW6h1sti_g.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">图片来自<a class="ae jg" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=6521720" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>的<a class="ae jg" href="https://pixabay.com/users/innovalabs-22783312/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=6521720" rel="noopener ugc nofollow" target="_blank"> Innova Labs </a></p></figure><p id="ecf0" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在本文中，我介绍了Python中的垃圾收集机制。这是对象的引用计数。</p><p id="dcad" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">以下操作将增加对象的引用计数:</p><ol class=""><li id="ec7c" class="og oh jj la b lb lc le lf lh oi ll oj lp ok lt ol om on oo bi translated">创建对象并将其赋给一个变量。</li><li id="92e8" class="og oh jj la b lb op le oq lh or ll os lp ot lt ol om on oo bi translated">该对象被分配给另一个变量。</li><li id="8bb8" class="og oh jj la b lb op le oq lh or ll os lp ot lt ol om on oo bi translated">对象作为参数在函数中传递。</li><li id="3642" class="og oh jj la b lb op le oq lh or ll os lp ot lt ol om on oo bi translated">对象被追加到容器类型中。</li></ol><p id="590b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">相反，以下操作将减少对象的引用计数:</p><ol class=""><li id="7d50" class="og oh jj la b lb lc le lf lh oi ll oj lp ok lt ol om on oo bi translated">该对象已从函数范围中删除。这通常发生在函数完成执行时。</li><li id="bfa1" class="og oh jj la b lb op le oq lh or ll os lp ot lt ol om on oo bi translated">当引用对象的变量被删除时。</li><li id="d115" class="og oh jj la b lb op le oq lh or ll os lp ot lt ol om on oo bi translated">当引用该对象的变量被赋予另一个对象时。</li><li id="4936" class="og oh jj la b lb op le oq lh or ll os lp ot lt ol om on oo bi translated">当对象从容器中移除时。</li></ol><div class="is it gp gr iu ou"><a href="https://medium.com/@qiuyujx/membership" rel="noopener follow" target="_blank"><div class="ov ab fo"><div class="ow ab ox cl cj oy"><h2 class="bd jk gy z fp oz fr fs pa fu fw ji bi translated">通过我的推荐链接加入Medium克里斯托弗·陶</h2><div class="pb l"><h3 class="bd b gy z fp oz fr fs pa fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="pc l"><p class="bd b dl z fp oz fr fs pa fu fw dk translated">medium.com</p></div></div><div class="pd l"><div class="pe l pf pg ph pd pi ja ou"/></div></div></a></div><p id="3728" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你觉得我的文章有帮助，请考虑加入Medium会员来支持我和成千上万的其他作者！(点击上面的链接)</p></div></div>    
</body>
</html>