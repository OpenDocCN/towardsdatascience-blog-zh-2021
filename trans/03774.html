<html>
<head>
<title>A Tutorial On Creating Data Pipeline For Object Detection Using PyTorch And Fastai</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用PyTorch和Fastai创建对象检测数据管道的教程</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/a-tutorial-on-creating-data-pipeline-for-object-detection-using-pytorch-and-fastai-eae20a4e8472?source=collection_archive---------7-----------------------#2021-03-29">https://towardsdatascience.com/a-tutorial-on-creating-data-pipeline-for-object-detection-using-pytorch-and-fastai-eae20a4e8472?source=collection_archive---------7-----------------------#2021-03-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="29b5" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph">PyTorch中的数据管道</h2><div class=""/><div class=""><h2 id="85e4" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">一种构建数据管道的通用方法</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/d248d56f7e908400d8bd41fe3b96b873.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CWXzONZGPbcf3WJr_E0Y0Q.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">作者图片</p></figure><p id="0120" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">大多数时候，你开始使用预处理数据集(如Sklearn的数据集)进行机器学习，以实现机器学习算法，但随着你转向更新颖的机器学习项目，数据集通常是原始格式，可能具有非常松散的结构。</p><p id="aecd" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">我在这里分享一个我开发的通用方法，从这些原始数据集开始，在PyTorch中构建一个数据集管道。</p><p id="0bbd" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">我们要使用的数据集是象棋数据集，这是一个对象检测数据集，您可以使用链接<a class="ae ma" href="https://public.roboflow.com/object-detection/chess-full/23" rel="noopener ugc nofollow" target="_blank">https://public.roboflow.com/object-detection/chess-full/23</a>下载数据集，在本教程中，我们将使用Yolo v5 PyTorch版本的数据集。</p><p id="622f" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">使用<a class="ae ma" href="https://github.com/Varun9213/Blog_machine_learing/blob/main/Dataset_pipeline_blog_1.ipynb" rel="noopener ugc nofollow" target="_blank">https://github . com/varun 9213/Blog _ machine _ learing/blob/main/Dataset _ pipeline _ Blog _ 1 . ipynb</a>下载教程的笔记本</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mb"><img src="../Images/5d7930a6f6b595c8d314150c5fd21581.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FkAz8Zl2ekIxTtbE9zmGag.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">作者图片</p></figure><p id="2c86" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">您可以直接从笔记本上下载带有网站生成的链接的数据集。本文的其余部分将由小节组成，这些小节将构建一个创建PyTorch数据集管道的逐步方法。</p></div><div class="ab cl mc md hu me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ij ik il im in"><h1 id="186e" class="mj mk iq bd ml mm mn mo mp mq mr ms mt kf mu kg mv ki mw kj mx kl my km mz na bi translated">数据集中的一般结构和文件扩展名</h1><p id="49bc" class="pw-post-body-paragraph le lf iq lg b lh nb ka lj lk nc kd lm ln nd lp lq lr ne lt lu lv nf lx ly lz ij bi translated">原始数据集通常看起来像复杂的谜题。第一次打开一个非常原始的数据集时，我也不知所措，但后来我仔细查看了一段时间，然后将问题分解成更小的部分，它开始变得有意义了。将拼图分成小块总是一个好主意。</p><p id="62f7" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">一般来说，你会遇到两种形式的结构化方案。</p><p id="d5be" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">更常见的结构是根据标签将图像划分到单独的文件夹中。父文件夹的名称是这些图像所属的标签。另一种常见的结构是将所有图像放在一个文件夹和一个单独的文件中。csv，。txt，。json等。)保存标签，其索引或文件名是图像和相应标签的名称。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/11b29cc73f0647488ba2f859e3a25602.png" data-original-src="https://miro.medium.com/v2/resize:fit:686/format:webp/1*f-IGb3j4qlYHY5Rz0-qBNw.png"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">作者图片</p></figure><p id="d3a7" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">Chess数据集包含三个文件夹train、valid和test，每个文件夹都有一个images文件夹和labels文件夹。有两个自述文件和一个名为data.yaml的YAML文件。我们的数据集属于第二种类型，其中类和边界框位于单独的。txt文件，这是您通常会在对象检测数据集中找到的结构。</p><p id="2755" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">现在，我们已经研究了结构并查看了我们正在处理的文件的扩展名，让我们打开这些文件，以便更好地理解我们接下来需要采取的步骤。</p><h1 id="3c61" class="mj mk iq bd ml mm nh mo mp mq ni ms mt kf nj kg mv ki nk kj mx kl nl km mz na bi translated">打开并浏览数据集中的文件</h1><p id="0949" class="pw-post-body-paragraph le lf iq lg b lh nb ka lj lk nc kd lm ln nd lp lq lr ne lt lu lv nf lx ly lz ij bi translated">开始时，你会经常遇到你从未处理过的文件类型，这似乎是一件复杂的事情，但是，大多数情况下，这只是一个五分钟的谷歌搜索，并不像一开始看起来那么复杂。</p><p id="75a5" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">该数据集有3种类型的文件。jpg，。大多数读者可能熟悉前两种文件类型，虽然yaml对一些读者来说可能是新的，但YAML只是一种类似于JSON的序列化标准，主要用于存储配置。在大多数情况下，您不需要了解文件类型遵循的协议，您只需要知道如何在python中打开这些文件并从中提取数据。</p><p id="36b8" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">我们将从研究YAML档案开始。你可以点击链接<a class="ae ma" href="https://stackabuse.com/reading-and-writing-yaml-to-a-file-in-python/" rel="noopener ugc nofollow" target="_blank">https://stack abuse . com/read-and-write-YAML-to-a-file-in-python/</a>了解如何处理YAML文件。它几乎涵盖了在python中处理YAML文件所需的所有工具。</p><p id="bece" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">让我们从安装和导入本教程所需的所有库开始。</p><pre class="kp kq kr ks gt nm nn no np aw nq bi"><span id="2172" class="nr mk iq nn b gy ns nt l nu nv">!pip install fastai --upgrade<br/>!pip install pyyaml</span><span id="e694" class="nr mk iq nn b gy nw nt l nu nv">from fastai import *<br/>from fastai.vision.all import *<br/>from fastai.imports import *<br/>import yaml, cv2, os<br/>from torchvision import transforms as T</span><span id="7f8f" class="nr mk iq nn b gy nw nt l nu nv">root = Path("/content/data")</span></pre><p id="9e45" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">路径是fastai中的一个对象，它让你的生活变得更加容易，你可以在fastai网站【https://course19.fast.ai/part2】的<a class="ae ma" href="https://docs.fast.ai/" rel="noopener ugc nofollow" target="_blank"> docs.fast.ai </a>上阅读fastai library提供的路径和其他非常方便的工具，我也强烈推荐Jeremy在fastai网站<a class="ae ma" href="https://course19.fast.ai/part2" rel="noopener ugc nofollow" target="_blank">上的免费fastai深度学习课程。</a></p><p id="1aec" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">现在让我们看一下data.yaml文件。</p><pre class="kp kq kr ks gt nm nn no np aw nq bi"><span id="3d6f" class="nr mk iq nn b gy ns nt l nu nv">with open(root/"data.yaml") as file:<br/>data = yaml.load(file)<br/>data</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/4039f641775b2dd1d5e7288347e98a6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:846/format:webp/1*vIlzlZRc3JkmlyYYpiZ_nA.png"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">作者图片</p></figure><p id="3adc" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">这是一个字典，包含标签名称、类别数量以及训练和验证文件夹的路径。为了构建管道，我们可以忽略这个文件。</p><p id="2c89" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">接下来，让我们看看图片</p><pre class="kp kq kr ks gt nm nn no np aw nq bi"><span id="f24e" class="nr mk iq nn b gy ns nt l nu nv">path_train = Path("/content/data/train")<br/>path_val = Path("/content/data/valid")<br/>path_test = Path("/content/data/test")</span><span id="346d" class="nr mk iq nn b gy nw nt l nu nv">train_images = get_image_files(path_train/"images")</span><span id="4594" class="nr mk iq nn b gy nw nt l nu nv">img = cv2.imread(str(train_images[-1]), cv2.IMREAD_UNCHANGED)<br/>img = cv2.cvtColor(img, cv2.COLOR_RGB2BGR)<br/>plt.imshow(img)</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/b4adf20fb98cb669ee230e2879ba1c5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1324/format:webp/1*FqACt2d4v-p9ymqvIBxavg.png"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">作者图片</p></figure><p id="5164" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">get_image_files()是另一个非常方便的fastai方法，可以获取所有常见格式的图像，如jpg、png等。从所有子目录中。返回的列表不包含图像本身，而是包含所有图像的路径。</p><blockquote class="nz oa ob"><p id="697e" class="le lf oc lg b lh li ka lj lk ll kd lm od lo lp lq oe ls lt lu of lw lx ly lz ij bi translated"><strong class="lg ja">注意</strong>注意<strong class="lg ja"> </strong>图像的分辨率是1371 x 2048，这是相当高的，大多数对象检测算法，如yolo，允许矩形图像，但是当使用高分辨率图像时，训练自然会慢一些。因此，我们可能希望将这些图像调整到较低的分辨率。然而，与分类任务相反，在对象检测中，目标对于分辨率不是不变的，因为如果图像被调整大小，边界框也必须被调整大小。</p></blockquote><p id="66de" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">让我们最后打开相应的标签。</p><pre class="kp kq kr ks gt nm nn no np aw nq bi"><span id="5f81" class="nr mk iq nn b gy ns nt l nu nv">f = train_images[-1].name[:-4] + ".txt"<br/>with open(root/"train"/"labels"/f, 'r') as file:<br/>  targets = file.read()<br/>targets = targets.split("\n")<br/>targets</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi og"><img src="../Images/1b65ed05e57ed8e12ce7e5b6a82fa65d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1272/format:webp/1*NKornfiIVUfLfxh52MSqOg.png"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">作者图片</p></figure><p id="5ed5" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">样本的第一个条目显然是类，接下来的4个条目定义了边界框。边界框的格式对于不同的算法是不同的，Yolo的边界框格式是[ center_x，center_y，width，height]<a class="ae ma" rel="noopener" target="_blank" href="/image-data-labelling-and-annotation-everything-you-need-to-know-86ede6c684b1">https://towards data sciences . com/image-data-label-and-annotation-you-the-knowledge-86 ed 6 c 684 b 1</a>如果你想更深入地探讨这个主题，这是一个很好的资源。</p><h1 id="4922" class="mj mk iq bd ml mm nh mo mp mq ni ms mt kf nj kg mv ki nk kj mx kl nl km mz na bi translated">准备数据帧以有效访问图像标签</h1><p id="1ed5" class="pw-post-body-paragraph le lf iq lg b lh nb ka lj lk nc kd lm ln nd lp lq lr ne lt lu lv nf lx ly lz ij bi translated">这个步骤非常主观，每个人都有自己的偏好，我喜欢在创建PyTorch数据集对象之前，将数据编译到一个数据框中。</p><blockquote class="nz oa ob"><p id="8b51" class="le lf oc lg b lh li ka lj lk ll kd lm od lo lp lq oe ls lt lu of lw lx ly lz ij bi translated"><strong class="lg ja"> <em class="iq">注</em> </strong> <em class="iq">此步骤无必要且可跳过。然而，在我看来，只需少量的工作和几行代码，就可以大大简化数据集构建步骤。话虽如此，任何方法中最重要的是来自实践的熟悉，所以我强烈建议您找出一个您熟悉的通用方法，并尽可能多地坚持下去。</em></p></blockquote><p id="9994" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">让我们从选择一个样本开始，并为这个样本制作一个数据框。数据框将具有图像的名称、类和边界框坐标。</p><pre class="kp kq kr ks gt nm nn no np aw nq bi"><span id="963b" class="nr mk iq nn b gy ns nt l nu nv">col = ["name", "class", "center_x", "center_y", "width", "height"]<br/>train_df = pd.DataFrame(columns= col)<br/>train_df</span><span id="ea06" class="nr mk iq nn b gy nw nt l nu nv">row = {}<br/>row[col[0]] = f[:-4]<br/>for i,t in enumerate(targets[0].split(" ")):<br/>  row[col[i+1]] = float(t)<br/>row</span><span id="7047" class="nr mk iq nn b gy nw nt l nu nv">train_df.append(row, ignore_index=True)</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oh"><img src="../Images/5d127c6827f7c3c655605d20fc731cef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4DKirBi-3Zuiv1_J5L2_Fw.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">作者形象</p></figure><blockquote class="nz oa ob"><p id="3f93" class="le lf oc lg b lh li ka lj lk ll kd lm od lo lp lq oe ls lt lu of lw lx ly lz ij bi translated"><strong class="lg ja">注意</strong>通常最好从整个数据集中抽取一个样本，并使用该样本。这有两个优点，一是速度快得多，尤其是在数据集非常大的情况下，二是处理单个样本比处理整个数据集容易得多。<em class="iq">这种做法极大地提高了我高效准备数据集管道的能力。</em></p></blockquote><p id="6089" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">最后，我们将把这些单独的命令转换成函数，将整个数据集转换成一个数据框架</p><pre class="kp kq kr ks gt nm nn no np aw nq bi"><span id="a499" class="nr mk iq nn b gy ns nt l nu nv">def get_targets(image_path):<br/>  f = image_path.name[:-4] + ".txt"<br/>  with open((image_path.parent).parent/"labels"/f, 'r') as file:<br/>    targets = file.read()<br/>  return targets.split("\n")</span><span id="4e77" class="nr mk iq nn b gy nw nt l nu nv">def get_row(image_path, target, col): <br/>  row = {}<br/>  row[col[0]] = image_path.name[:-4]<br/>  for i,t in enumerate(target.split(" ")):<br/>    try:<br/>      row[col[i+1]] = float(t)<br/>    except:<br/>      print("Could not convert {} to float".format(t))<br/>  return row</span><span id="8009" class="nr mk iq nn b gy nw nt l nu nv">def add_targets_to_df(df, image_path):<br/>  targets = get_targets(image_path)<br/>  df_new = df<br/>  for target in targets:<br/>    row = get_row(image_path, target, df.columns)<br/>    df_new = df_new.append(row, ignore_index = True)<br/>  return df_new</span><span id="3a57" class="nr mk iq nn b gy nw nt l nu nv">def create_df(cols, images_paths):<br/>  df = pd.DataFrame(columns=cols)<br/>  for path in images_paths:<br/>    df = add_targets_to_df(df, path)<br/>  return df</span></pre><p id="c10f" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">将复杂的任务分解成更小的部分并将每个部分包装成一个函数总是一个好的做法，它简化了问题并产生了更可读的代码，这使得故障诊断比将所有事情都塞进一个函数中更容易。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oi"><img src="../Images/5e0472616672e169f3f4b291a6722a31.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RUH2aAvWlUMIvGYVLRR5tg.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">作者形象</p></figure><pre class="kp kq kr ks gt nm nn no np aw nq bi"><span id="0c95" class="nr mk iq nn b gy ns nt l nu nv">final_df = create_df(col, train_images)<br/>final_df.head()</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oj"><img src="../Images/c33341597cca700d700e7153b6c2c9fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lYBnPSEhuUYImZQyhuouDg.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">作者形象</p></figure><p id="9354" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">现在，最后一步是创建PyTorch数据集对象，这将是最后一部分。</p><h1 id="fdb2" class="mj mk iq bd ml mm nh mo mp mq ni ms mt kf nj kg mv ki nk kj mx kl nl km mz na bi translated">创建Pytorch数据集</h1><p id="f323" class="pw-post-body-paragraph le lf iq lg b lh nb ka lj lk nc kd lm ln nd lp lq lr ne lt lu lv nf lx ly lz ij bi translated">Pytorch和Tensorflow是最受欢迎的深度学习图书馆，PyTorch因其提供的灵活性最近在研究人员中变得更受欢迎。</p><p id="a7f7" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">让我们从为象棋数据集构建数据集管道开始。</p><pre class="kp kq kr ks gt nm nn no np aw nq bi"><span id="2b37" class="nr mk iq nn b gy ns nt l nu nv">def get_target_ds(name, df):</span><span id="244a" class="nr mk iq nn b gy nw nt l nu nv">  rows = df[df["name"] == name[:-4]]<br/>  return rows["class"].values, rows[bboxes_cols].values</span><span id="35fc" class="nr mk iq nn b gy nw nt l nu nv">class ChessDataset(torch.utils.data.Dataset):<br/>  <br/>  def __init__(self, images_path, df):<br/>    super(ChessDataset, self).__init__()<br/>    self.images_path = images_path<br/>    self.df = df</span><span id="9e79" class="nr mk iq nn b gy nw nt l nu nv">  def __len__(self):<br/>    return len(self.images_path)</span><span id="2f03" class="nr mk iq nn b gy nw nt l nu nv">  def __getitem__(self,idx):<br/>    img_path = self.images_path[idx]<br/>    img = cv2.imread(str(img_path), cv2.IMREAD_UNCHANGED)<br/>    target = {}<br/>    labels, boxes = get_target_ds(img_path.name, self.df)<br/>    areas = boxes[:,2] * boxes[:,3]<br/>    iscrowd = torch.zeros((boxes.shape[0],))<br/>    image_id = torch.tensor([idx])<br/>    labels = torch.as_tensor(labels, dtype=torch.float32)<br/>    boxes = torch.as_tensor(boxes, dtype=torch.float32)<br/>    areas = torch.as_tensor(areas, dtype=torch.float32)<br/>    target["boxes"] = boxes<br/>    target["labels"] = labels<br/>    target["areas"] = areas<br/>    target["iscrowd"] = iscrowd<br/>    target["image_id"] = image_id</span><span id="0d34" class="nr mk iq nn b gy nw nt l nu nv">    img = F.to_tensor(img)</span><span id="79c1" class="nr mk iq nn b gy nw nt l nu nv">    return img, target</span></pre><p id="a642" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">ChessDataset类从PyTorch继承torch.utils.data.Dataset类，我们需要为其定义__init__()、__len__()和__getitem__()函数，以更深入地了解如何创建PyTorch自定义数据集。</p><p id="6bcf" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">最后，让我们通过创建一个实例来测试我们的类，并通过调用__getitem__()来获得一个样本，以查看它是否正常工作。</p><pre class="kp kq kr ks gt nm nn no np aw nq bi"><span id="a502" class="nr mk iq nn b gy ns nt l nu nv">dataset = ChessDataset(train_images, final_df)</span><span id="1a82" class="nr mk iq nn b gy nw nt l nu nv">img , target = dataset.__getitem__(1)<br/>size = img.shape<br/>print(img.shape, target["boxes"], target["labels"])</span><span id="9db0" class="nr mk iq nn b gy nw nt l nu nv">plt.imshow(img.permute(1,2,0))</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ok"><img src="../Images/e550b2c09b012295f5ab75727dcb907f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CTfs9Y0LLvMeFFqUpLF0aA.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">作者图片</p></figure><p id="a144" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">您的数据集可以与PyTorch的数据加载器一起使用了！！</p><h1 id="fb92" class="mj mk iq bd ml mm nh mo mp mq ni ms mt kf nj kg mv ki nk kj mx kl nl km mz na bi translated">结论</h1><p id="c891" class="pw-post-body-paragraph le lf iq lg b lh nb ka lj lk nc kd lm ln nd lp lq lr ne lt lu lv nf lx ly lz ij bi translated">这里的想法是有一系列的步骤，对大多数数据集来说足够宽泛。为训练准备数据集也是一项技能，正如任何技能练习都是胜任的关键一样，我强烈建议你继续Kaggle，用看起来复杂的数据集打开封闭的比赛，并尝试为这些比赛建立一个数据集管道，然后使用人们为这些比赛发布的内核来排除故障，数据集越让你不舒服，你就越能从练习中学到更多。</p><p id="34d8" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">最后，我希望这篇文章为所有读者提供一些见解，我计划继续发表这篇文章，讨论相同的数据集，包括各种绘图函数和策略，在PyTorch中挑选和训练预训练的模型，以及其他任何可能与主题相关的内容，敬请关注，谢谢。</p></div></div>    
</body>
</html>