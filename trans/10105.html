<html>
<head>
<title>Build NLP Pipelines With HuggingFace Datasets</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用HuggingFace数据集构建NLP管道</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/build-nlp-pipelines-with-huggingface-datasets-d597ff5f68ad?source=collection_archive---------13-----------------------#2021-09-24">https://towardsdatascience.com/build-nlp-pipelines-with-huggingface-datasets-d597ff5f68ad?source=collection_archive---------13-----------------------#2021-09-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f47e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">NLP实践者的宝库和无与伦比的管道工具</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/a76d4971aa87fa9288f3087e9a9f3b9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ek_GrL0ijydLG45eKLOMTA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="0226" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi lu translated"><span class="l lv lw lx bm ly lz ma mb mc di"> H </span> F Datasets是NLP从业者的必备工具——托管超过1.4K <em class="md">(主要是)</em>高质量的以语言为中心的数据集和易于使用的函数宝库，用于构建高效的预处理管道。</p><p id="5dbd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">本文将研究可用的大规模数据集存储库，并探索该库出色的数据处理能力。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="me mf l"/></div></figure></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="df69" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">数据集</h1><p id="e4df" class="pw-post-body-paragraph ky kz it la b lb nf ju ld le ng jx lg lh nh lj lk ll ni ln lo lp nj lr ls lt im bi translated">我们将从探索数据集开始。正如我们所说的——有大量的数据集可用，其中许多是由社区上传的。我经常使用的两个数据集是OSCAR和SQuAD数据集。</p><p id="2a11" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">SQuAD是一个用于训练问答变压器模型的出色数据集，通常无与伦比。HF数据集实际上允许我们从跨越几种语言的几个不同的队数据集中进行选择:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk mf l"/></div></figure><p id="f798" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当微调问答的transformer模型时，我们只需要这些数据集中的一个。</p><p id="bee5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">另一个数据集OSCAR可能是现有的最令人印象深刻的语言数据集之一。它由超过166种不同的语言数据集组成，包含从网络上搜集的非结构化文本。</p><p id="f587" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">其中一些数据集很小，如11KB的Nahuatl语言，但其他数据集很大，如106GB的日语或1.2TB的英语。这使得OSCAR成为预训练transformer模型的理想选择。</p><h2 id="186f" class="nl mo it bd mp nm nn dn mt no np dp mx lh nq nr mz ll ns nt nb lp nu nv nd nw bi translated">访问和查看数据集</h2><p id="245f" class="pw-post-body-paragraph ky kz it la b lb nf ju ld le ng jx lg lh nh lj lk ll ni ln lo lp nj lr ls lt im bi translated">在查看哪些数据集可用时，我们可以采用两种方法。使用<a class="ae nx" href="https://huggingface.co/datasets/viewer/" rel="noopener ugc nofollow" target="_blank">在线数据集查看器应用</a>或直接使用Python。</p><p id="e6ad" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在线数据集查看器相当简单，因此我建议您点击了解它是如何工作的。在这里，我们将重点放在Python方面。</p><p id="194f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们希望从导入和查看所有可用的数据集开始。有很多，所以如果你在寻找一个特定的数据集——比如<code class="fe ny nz oa ob b">squad</code>——提前知道会很有帮助。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk mf l"/></div></figure><p id="baf9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了加载数据集，我们使用了<code class="fe ny nz oa ob b">datasets.load_dataset</code>函数。默认情况下，这会将整个数据集下载到文件中，这对于小队来说是可以的。但如果我们考虑到1.2TB大小的英语奥斯卡，这可能是一个糟糕的想法…😅</p><p id="a6d9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，我们可以不使用默认行为，而是通过设置<code class="fe ny nz oa ob b">streaming=True</code>，在需要时迭代下载数据集的大块内容。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk mf l"/></div></figure><p id="b2ef" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以看到，<code class="fe ny nz oa ob b">squad</code>数据集包含两个子集，<code class="fe ny nz oa ob b">train</code>和<code class="fe ny nz oa ob b">validation</code>。如果愿意，我们可以指定只使用其中的一个:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk mf l"/></div></figure><p id="2e29" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">尽管我们将坚持使用整个数据集。要查看数据集的大小、描述和特性，我们可以分别访问<code class="fe ny nz oa ob b">dataset_size</code>、<code class="fe ny nz oa ob b">description</code>和<code class="fe ny nz oa ob b">features</code>属性。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk mf l"/></div></figure><p id="2e3d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果使用<code class="fe ny nz oa ob b">streaming=False</code>，可以使用像<code class="fe ny nz oa ob b">dataset['train'][0]</code>这样的语法来访问数据集中的特定记录——但是因为我们有<code class="fe ny nz oa ob b">streaming=True</code>，所以我们必须遍历数据集。</p><p id="a597" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这意味着，如果我们想查看记录以了解内容的类型(除了由<code class="fe ny nz oa ob b">dataset['train'].features</code>显示的内容之外)，我们可以写:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk mf l"/></div></figure><p id="91ff" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这样，我们对可用的数据集有了一个很好的概念，并理解了它们的目的和内容。在下一节中，我们将继续讨论<code class="fe ny nz oa ob b">datasets</code>提供的处理方法。</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="fe75" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">数据集预处理</h1><p id="98d8" class="pw-post-body-paragraph ky kz it la b lb nf ju ld le ng jx lg lh nh lj lk ll ni ln lo lp nj lr ls lt im bi translated">而<code class="fe ny nz oa ob b">datasets</code>值得使用，因为它可以方便地访问如此多的高质量数据集。它还附带了许多令人惊叹的预处理功能。当使用<code class="fe ny nz oa ob b">streaming=True</code>时，这些变得更加有用，因为我们可以迭代地转换我们的数据，而不需要下载所有东西。</p><h2 id="ce85" class="nl mo it bd mp nm nn dn mt no np dp mx lh nq nr mz ll ns nt nb lp nu nv nd nw bi translated">修改特征</h2><p id="7dea" class="pw-post-body-paragraph ky kz it la b lb nf ju ld le ng jx lg lh nh lj lk ll ni ln lo lp nj lr ls lt im bi translated">我们将从修改队伍数据中的<code class="fe ny nz oa ob b">answers</code>特征开始。在Q &amp; A中，我们通常需要一个答案<em class="md">起始位置</em>和<em class="md">结束位置</em>。小队已经包含了<code class="fe ny nz oa ob b">answer_start</code>，但是我们必须使用这个和答案<code class="fe ny nz oa ob b">text</code>长度来创建我们自己在<code class="fe ny nz oa ob b">answers</code>特征中的<code class="fe ny nz oa ob b">answer_end</code>值。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk mf l"/></div></figure><p id="ae76" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">修改现有特征(和创建新特征)最常用的方法是<code class="fe ny nz oa ob b">map</code>功能。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk mf l"/></div></figure><blockquote class="oc od oe"><p id="8e1c" class="ky kz md la b lb lc ju ld le lf jx lg of li lj lk og lm ln lo oh lq lr ls lt im bi translated">请注意，当<code class="fe ny nz oa ob b">streaming=True</code>时，我们必须将<em class="it">中的每个</em>特征都包含在<code class="fe ny nz oa ob b">map</code>中，否则它们会在映射后消失。当<code class="fe ny nz oa ob b"><em class="it">streaming=False</em></code>时情况并非如此，我们将在后面看到。</p></blockquote><p id="423d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当我们定义这个转换时，它不会立即执行。相反，它是作为调用数据集时要执行的<em class="md">‘指令’</em>添加的。这意味着我们仍然没有在内存中存储任何数据集。</p><p id="976f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">该指令用于在需要时仅转换数据集样本<em class="md"/>——也称为<em class="md">惰性加载(一个通用术语，不特定于HF甚至ML) </em>。如果我们再次遍历几个样本，我们会看到转换得到了应用。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk mf l"/></div></figure><p id="cb2d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们还可以看到，如果我们故意在<code class="fe ny nz oa ob b">map</code>函数中创建一个错误，这是延迟加载的，因为在我们遍历数据集之前，错误不会出现。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk mf l"/></div></figure><p id="ad7b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们将在后面介绍<code class="fe ny nz oa ob b">filter</code> w方法，它只能在<code class="fe ny nz oa ob b">streaming=False</code>时使用——所以我们将在没有流的情况下重新加载我们的数据<em class="md">,并在本文的剩余部分使用它。</em></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk mf l"/></div></figure><blockquote class="oc od oe"><p id="b117" class="ky kz md la b lb lc ju ld le lf jx lg of li lj lk og lm ln lo oh lq lr ls lt im bi translated">使用<code class="fe ny nz oa ob b">streaming=False</code>,我们可以使用列表索引直接访问数据集中的记录。</p></blockquote><p id="945d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们不再需要在<code class="fe ny nz oa ob b">map</code>函数中包含每一个特性。当<code class="fe ny nz oa ob b">streaming=False</code>时，我们只包括我们正在修改(或创建)的特征。</p><h2 id="6762" class="nl mo it bd mp nm nn dn mt no np dp mx lh nq nr mz ll ns nt nb lp nu nv nd nw bi translated">定量</h2><p id="6fce" class="pw-post-body-paragraph ky kz it la b lb nf ju ld le ng jx lg lh nh lj lk ll ni ln lo lp nj lr ls lt im bi translated">我们几乎总是会执行的另一个操作是将文本标记化为标记id。对于SQuAD，这要求我们将<code class="fe ny nz oa ob b">question</code>和<code class="fe ny nz oa ob b">context</code>字符串传递给一个记号赋予器，记号赋予器将输出三个张量(对于Bert)——<code class="fe ny nz oa ob b">input_ids</code>、<code class="fe ny nz oa ob b">token_type_ids</code>和<code class="fe ny nz oa ob b">attention_mask</code>。</p><p id="d13b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一般来说，这个过程在批量执行时要快得多。幸运的是，<code class="fe ny nz oa ob b">map</code>方法允许我们使用<code class="fe ny nz oa ob b">batched=True</code>批量转换，甚至指定<code class="fe ny nz oa ob b">batch_size</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk mf l"/></div></figure><h2 id="aba5" class="nl mo it bd mp nm nn dn mt no np dp mx lh nq nr mz ll ns nt nb lp nu nv nd nw bi translated">重命名功能</h2><p id="a803" class="pw-post-body-paragraph ky kz it la b lb nf ju ld le ng jx lg lh nh lj lk ll ni ln lo lp nj lr ls lt im bi translated">有时我们可能需要重命名特性，通常是为了将特性名称与模型所期望的输入名称对齐。</p><p id="9477" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这种情况下，我们只是迂腐。我想将主题功能从<code class="fe ny nz oa ob b">title</code>重命名为<code class="fe ny nz oa ob b">topic</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk mf l"/></div></figure><h2 id="38f7" class="nl mo it bd mp nm nn dn mt no np dp mx lh nq nr mz ll ns nt nb lp nu nv nd nw bi translated">过滤</h2><p id="1c24" class="pw-post-body-paragraph ky kz it la b lb nf ju ld le ng jx lg lh nh lj lk ll ni ln lo lp nj lr ls lt im bi translated">这是一个非常漂亮的特性。我们可以根据样本是否满足某种条件来过滤掉数据集中的样本。</p><p id="e1fa" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们已经返回了数据集的前几个样本，都是关于<code class="fe ny nz oa ob b">University_of_Notre_Dame</code>的主题——假设我们不想在我们的数据集中包含<code class="fe ny nz oa ob b">University_of_Notre_Dame</code>样本。</p><p id="232c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们需要做的就是把它们拿出来:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk mf l"/></div></figure><p id="4441" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这样，我们只保留了<em class="md">中<code class="fe ny nz oa ob b">topic</code>不等于</em>和<code class="fe ny nz oa ob b">University_of_Notre_Dame</code>的样本。另外需要注意的是，我们<em class="md">不能用</em> <code class="fe ny nz oa ob b"><em class="md">filter</em></code> <em class="md">当</em> <code class="fe ny nz oa ob b"><em class="md">streaming=True</em></code>。</p><h2 id="81da" class="nl mo it bd mp nm nn dn mt no np dp mx lh nq nr mz ll ns nt nb lp nu nv nd nw bi translated">删除功能</h2><p id="858c" class="pw-post-body-paragraph ky kz it la b lb nf ju ld le ng jx lg lh nh lj lk ll ni ln lo lp nj lr ls lt im bi translated">我们已经完成了处理，并且我们决定——实际上——我们不需要大多数特性。事实上，对于问答推理，我们只需要<code class="fe ny nz oa ob b">input_ids</code>、<code class="fe ny nz oa ob b">token_type_ids</code>、<code class="fe ny nz oa ob b">attention_mask</code>。</p><p id="427b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，对于我们的最终转换，让我们继续前进，并删除所有这三个功能。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk mf l"/></div></figure></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><p id="7131" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们到了。我们已经学会了如何找到并下载(或流式传输)一些在线可用的最佳数据集。然后，我们探索了HF的<code class="fe ny nz oa ob b">datasets</code>中打包的一些最重要的数据处理功能。</p><p id="eda7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我希望你喜欢它！如果你有任何问题，请通过<a class="ae nx" href="https://twitter.com/jamescalam" rel="noopener ugc nofollow" target="_blank">推特</a>或者在下面的评论中告诉我。如果你想要更多这样的内容，我也会在YouTube上发布。</p><p id="e1dd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">感谢阅读！</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><p id="d89a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><a class="ae nx" href="https://bit.ly/nlp-transformers" rel="noopener ugc nofollow" target="_blank">🤖《变形金刚》课程NLP的70%折扣</a></p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><p id="6d89" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="md">*所有图片均由作者提供，除非另有说明</em></p></div></div>    
</body>
</html>