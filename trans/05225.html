<html>
<head>
<title>Simplify Polylines with the Douglas Peucker Algorithm</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用道格拉斯·普克算法简化折线</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/simplify-polylines-with-the-douglas-peucker-algorithm-ac8ed487a4a1?source=collection_archive---------7-----------------------#2021-05-08">https://towardsdatascience.com/simplify-polylines-with-the-douglas-peucker-algorithm-ac8ed487a4a1?source=collection_archive---------7-----------------------#2021-05-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="295a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">一种减少折线中数据点数量的算法</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/3175997672eaf33f4ecf272d7c855972.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ya9c9WySUuHJUupSePsA8A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><h1 id="4963" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">一.动机</h1><p id="2f77" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">在开发路径跟踪应用和文档扫描应用时，我惊讶地发现这两个应用都需要某种折线简化算法。第一种方法需要算法来减少要保存到数据库中的路线点(纬度、经度)的数量，而后者使用该算法来拟合分割掩模中白色像素周围的四点多边形。虽然这两个应用程序是在两个不同的框架(Flutter和Android Native)中编写的，但在这两个实例中，我最终都使用了道格拉斯·普克算法的实现。因此，在这篇文章中，我想把重点放在这个有趣而简单的算法上，并提供该算法在Python中的一个“从头开始”的实现。</p><blockquote class="mm mn mo"><p id="1809" class="lq lr mp ls b lt mq ju lv lw mr jx ly ms mt mb mc mu mv mf mg mw mx mj mk ml im bi translated">对于那些好奇的人，我使用的Flutter实现是由<a class="ae my" href="https://github.com/darwin-morocho/douglas-peucker-dart" rel="noopener ugc nofollow" target="_blank"> darwin-morocho </a>提供的，Android原生实现是由OpenCV在其<a class="ae my" href="https://docs.opencv.org/3.4/javadoc/org/opencv/imgproc/Imgproc.html#approxPolyDP(org.opencv.core.MatOfPoint2f,org.opencv.core.MatOfPoint2f,double,boolean)" rel="noopener ugc nofollow" target="_blank"> approxPolyDP函数</a>中提供的。</p></blockquote><h1 id="5cc4" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">二。道格拉斯·普克算法</h1><blockquote class="mm mn mo"><p id="1150" class="lq lr mp ls b lt mq ju lv lw mr jx ly ms mt mb mc mu mv mf mg mw mx mj mk ml im bi translated">该算法也被称为Ramer-Douglas-Peucker算法，因为早在一年前的1972年，Urs Ramer在其题为“平面曲线多边形近似的迭代程序”(Ramer，1972)的论文中重复了类似的思想。</p></blockquote><p id="5267" class="pw-post-body-paragraph lq lr it ls b lt mq ju lv lw mr jx ly lz mt mb mc md mv mf mg mh mx mj mk ml im bi translated">1973年，David H. Douglas和Thomas K. Peucker发表了一篇题为“减少表示数字化线或其漫画所需点数的算法”的论文(Douglas &amp; Peucker，1973)。其中他们引入了两种算法。其中一种算法已经被广泛实施，通常被称为道格拉斯·普克算法。该算法的目的是产生一个简化的折线，它比原始折线具有更少的点，但仍然保持原始折线的特征/形状。为了理解算法是如何工作的，我们可以一步一步地看看它是如何在图1中的四点折线上运行的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mz"><img src="../Images/0c91319413178695ecfac0fc6167de22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ei2_05AY3fxJpgyXDoIHSw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图1:原始折线。作者图片</p></figure><h2 id="770c" class="na kz it bd la nb nc dn le nd ne dp li lz nf ng lk md nh ni lm mh nj nk lo nl bi translated">第一步</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mz"><img src="../Images/c6a43398167a0b782ca3cd7d024bf6e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x87l_YFeshQl7J1gmzoR2Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图2:B和C到AD线的距离。作者图片</p></figure><p id="2b41" class="pw-post-body-paragraph lq lr it ls b lt mq ju lv lw mr jx ly lz mt mb mc md mv mf mg mh mx mj mk ml im bi translated">该算法从识别折线的起点和终点开始。在他们的论文中，Douglas &amp; Peucker (1972)将这两个点分别称为锚点和浮点。在我们的例子中，这些点是<em class="mp"> A </em>(开始)和<em class="mp"> D </em>(结束)。对于折线中既不是起点也不是终点的其他点(<em class="mp"> B </em>和<em class="mp"> C </em>，它计算从该点到起点和终点形成的直线的“垂直距离”。这就给了我们<em class="mp"> d(B，AD) = 1 </em>和<em class="mp"> d(C，AD) = 0.3 </em>。</p><h2 id="26c8" class="na kz it bd la nb nc dn le nd ne dp li lz nf ng lk md nh ni lm mh nj nk lo nl bi translated">第二步</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mz"><img src="../Images/89157ebefbb7c90435c4bab5e1e6c6a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7qrwwfbQ0eYV5c1uSNP86w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图3: B离AD线最远。作者图片</p></figure><p id="f897" class="pw-post-body-paragraph lq lr it ls b lt mq ju lv lw mr jx ly lz mt mb mc md mv mf mg mh mx mj mk ml im bi translated">然后该算法选择最远的点。在我们例子中，点是b。我们称这个点为最大值<em class="mp">。然后，它将<em class="mp"> d(B，AD) </em>与epsilon ( <em class="mp"> ε </em>)值进行比较(在我们的示例中为0.5)。由于<em class="mp"> d(B，AD) </em> &gt; <em class="mp"> ε </em>，该算法将折线分为两个子线段。一段由<em class="mp">最大值</em> ( <em class="mp"> A </em>和<em class="mp"> B </em>)左侧的所有点组成，另一段由<em class="mp">最大值</em> ( <em class="mp"> B </em>、<em class="mp"> C </em>、<em class="mp"> </em>和<em class="mp"> D </em>)右侧的所有点组成。</em></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mz"><img src="../Images/163c1b26b29d06cfba6ecb6638d2bca5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hW5Q8PB0bnFlMWu81WO2Sg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图4:原始折线被分成两段。作者图片</p></figure><h2 id="f5d8" class="na kz it bd la nb nc dn le nd ne dp li lz nf ng lk md nh ni lm mh nj nk lo nl bi translated">第三步</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mz"><img src="../Images/c4251d21f240d5517f81f0d0ce9122d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u7Z58QkTzLA4Clsp9sepqQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图5:第一部分。作者图片</p></figure><p id="a831" class="pw-post-body-paragraph lq lr it ls b lt mq ju lv lw mr jx ly lz mt mb mc md mv mf mg mh mx mj mk ml im bi translated">该算法然后在第一段上再次执行步骤1。它将起点和终点分别标识为<em class="mp"> A </em>和<em class="mp"> B </em>。然而，与之前的迭代不同的是，在这个片段中只有两个点。在这种情况下，该算法不能进一步减少点数，因为直线是任何折线的最简单近似。因此，<em class="mp"> A </em>和<em class="mp"> B </em>被保留。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mz"><img src="../Images/cde17c59d0f035333bb3c04485c140fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UdF1zrWwTIAFakX6m07c5g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图6:从第一个片段中选择的点。作者图片</p></figure><h2 id="fac9" class="na kz it bd la nb nc dn le nd ne dp li lz nf ng lk md nh ni lm mh nj nk lo nl bi translated">第四步</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mz"><img src="../Images/93fcb8e4c0d12ba0f4306f7f14e229b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Bu_LGN8m5CoY0hV8eehDTA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图7:第二部分。作者图片</p></figure><p id="a8af" class="pw-post-body-paragraph lq lr it ls b lt mq ju lv lw mr jx ly lz mt mb mc md mv mf mg mh mx mj mk ml im bi translated">类似地，对于第二段，算法执行步骤1以将<em class="mp"> B </em>和<em class="mp"> D </em>识别为起点和终点，并计算所有剩余点(在我们的示例中只有<em class="mp"> C </em>)与由<em class="mp"> B </em>和<em class="mp"> D </em>形成的直线之间的垂直距离。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mz"><img src="../Images/f1c2cb0e1f7a46d2ba60f52ffec4e123.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7AyzhBDJ-ZFmNLqHCdTlrQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图8:从C到BD线的距离。作者图片</p></figure><p id="0bdf" class="pw-post-body-paragraph lq lr it ls b lt mq ju lv lw mr jx ly lz mt mb mc md mv mf mg mh mx mj mk ml im bi translated">由于除了<em class="mp"> B </em>和<em class="mp"> D </em>之外剩下的唯一一个点就是<em class="mp"> C </em>，所以它是距离最远的点。因此，该算法将<em class="mp"> d(C，AB) </em>与<em class="mp"> ε </em>进行比较。与第一次迭代不同，<em class="mp"> d(C，AB) </em> &lt; <em class="mp"> ε </em>。因此，该段可以去掉点<em class="mp"> C </em>，只保留<em class="mp"> B </em>和<em class="mp"> D </em>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mz"><img src="../Images/190886245652f8ff16be9d01b5e5415a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rHF9yTUfU1G1fQzVoz6mkQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图8:从第二段中选择的点。作者图片</p></figure><h2 id="f967" class="na kz it bd la nb nc dn le nd ne dp li lz nf ng lk md nh ni lm mh nj nk lo nl bi translated">第五步</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mz"><img src="../Images/ab0bcce952dd0271159b6f177bcbc2da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uTyDm-3Cll8-XGwUCGK3hw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图9:算法的结果。作者图片</p></figure><p id="056d" class="pw-post-body-paragraph lq lr it ls b lt mq ju lv lw mr jx ly lz mt mb mc md mv mf mg mh mx mj mk ml im bi translated">在第一段和第二段上完成所有迭代后，该算法将所有结果组合在一起，以创建原始折线的简化版本。</p><h1 id="7d92" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">三。代码</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/bff15d36d61e90483a35d50a37c5224b.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/1*6p8sFADiCzNj7gdcvGB-eA.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图10:示例代码的输出</p></figure><p id="eaed" class="pw-post-body-paragraph lq lr it ls b lt mq ju lv lw mr jx ly lz mt mb mc md mv mf mg mh mx mj mk ml im bi translated">下面的代码是我实现的最简单形式的道格拉斯普克算法。我的实现基于这个主题的维基百科页面提供的伪代码。我确信还有更有效实现。然而，我相信下面的代码足以理解算法的基本思想。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><h1 id="f6ab" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">四。结论</h1><p id="e9df" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">在这篇文章中，我们学习了一个有用而简单的算法来减少折线中的点数。除了我在这篇文章的介绍中给出的例子，这种算法可以应用于更多真实世界的应用，从加速地图渲染，改善物联网设备之间的通信等。我希望这篇文章能帮助你理解这个算法，并把它应用到更多有用的应用中。</p></div><div class="ab cl np nq hx nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="im in io ip iq"><p id="60f2" class="pw-post-body-paragraph lq lr it ls b lt mq ju lv lw mr jx ly lz mt mb mc md mv mf mg mh mx mj mk ml im bi translated"><em class="mp">喜欢这篇文章，想表示你的支持？关注我或者给我买咖啡</em></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><a href="https://www.buymeacoffee.com/socretlee"><div class="gh gi nw"><img src="../Images/69716627feab2505c60838bbd29241a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gS6Sh6i8g535gOafY4Wl1w.png"/></div></a></figure><h1 id="16e3" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">参考</h1><p id="f131" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">道格拉斯，D. H .，&amp;普克，T. K. (1973)。减少表示数字化线或其漫画所需点数的算法。<em class="mp">制图:国际地理信息和地理可视化杂志，10 </em> (2)，112–122。doi:10.3138/fm57–6770-u75u-7727</p><p id="fcde" class="pw-post-body-paragraph lq lr it ls b lt mq ju lv lw mr jx ly lz mt mb mc md mv mf mg mh mx mj mk ml im bi translated">拉默，U. (1972)。平面曲线多边形逼近的迭代程序。<em class="mp">计算机图形与图像处理，</em> <em class="mp"> 1 </em> (3)，244–256。doi:10.1016/s 0146–664 x(72)80017–0</p><p id="a7bc" class="pw-post-body-paragraph lq lr it ls b lt mq ju lv lw mr jx ly lz mt mb mc md mv mf mg mh mx mj mk ml im bi translated">编码列车。(2019年10月24日)。<em class="mp">编码挑战#152 : RDP线简化算法</em>【视频】。YouTube。<a class="ae my" href="https://www.youtube.com/watch?v=nSYw9GrakjY" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=nSYw9GrakjY</a></p></div></div>    
</body>
</html>