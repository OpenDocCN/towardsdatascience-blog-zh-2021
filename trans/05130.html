<html>
<head>
<title>How to Accelerate Expensive Algorithms</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何加速昂贵的算法</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-accelerate-expensive-algorithms-aa497631abbd?source=collection_archive---------29-----------------------#2021-05-05">https://towardsdatascience.com/how-to-accelerate-expensive-algorithms-aa497631abbd?source=collection_archive---------29-----------------------#2021-05-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="542d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">通过记忆提高递归函数的性能</h2></div><p id="ec16" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">作者:<a class="ae le" href="https://www.linkedin.com/in/edkrueger/" rel="noopener ugc nofollow" target="_blank">爱德华·克鲁格</a>和<a class="ae le" href="https://www.linkedin.com/in/dougaf/" rel="noopener ugc nofollow" target="_blank">道格拉斯·富兰克林</a>。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi lf"><img src="../Images/927b2cf5cfcfa0afa05338e2d404b24d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s3Qt2INFQNsLcQKInGiIRg.jpeg"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">照片由Florian Krumm在Unsplash上拍摄</p></figure><h1 id="494e" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">什么是记忆化？</h1><p id="1b0b" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated"><strong class="kk iu">记忆化</strong>是一种缓存类型，用于存储确定性函数的结果。更具体地说，记忆化是一种优化技术，用于通过存储函数调用的结果并在出现冗余输入时返回缓存的结果来加速程序。</p><p id="bcb8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">换句话说，记忆防止程序两次运行相同的计算。</p><p id="17fc" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们用一个人为缓慢的Python函数来看看这种行为。</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="ms mt l"/></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">慢速_函数. py</p></figure><p id="1c6a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当我们运行<code class="fe mu mv mw mx b">slow_func.py</code>时，我们得到以下输出:</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi my"><img src="../Images/d31d1ebfcf5743ce982117f38020f369.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DnHFx709QdJapSTA7WUvqw.png"/></div></div></figure><p id="1977" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">请注意，有两个多余的计算；每增加一秒我们的执行时间。现在让我们编写这个函数的新版本来说明记忆化。</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="ms mt l"/></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">memoized_slow_func.py</p></figure><p id="84e8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在第三行，我们添加了一个空字典作为缓存。现在，在第7–8行，我们检查缓存以查看<code class="fe mu mv mw mx b">slow_func</code>之前是否已经看到它的当前输入，如果存在则返回结果。第13行存储任何新的数字，它在缓存中是平方。</p><p id="1880" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，当我们运行<code class="fe mu mv mw mx b">memoized_slow_func.py</code>时，我们的输出如下所示:</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi mz"><img src="../Images/114fe08d73891f47abf7450e5570cd7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fQWv5z6QKCOoNLBcCWue0w.png"/></div></div></figure><p id="463e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注意，对于两个冗余输入，计算步骤已经被跳过，有效地将我们的运行时间减少了一半。现在你已经理解了记忆化的目的，让我们继续看一些更复杂的例子。</p><h1 id="4390" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">什么是斐波那契数列？</h1><div class="lg lh li lj gt ab cb"><figure class="na lk nb nc nd ne nf paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><img src="../Images/fcc5bffbabbb9bf47003cecf7c7085aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1060/format:webp/1*JjNSYG93BhY2hoARsj5yLQ.jpeg"/></div></figure><figure class="na lk ng nc nd ne nf paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><img src="../Images/e05299bf4af70b768c8ce412d42d7424.png" data-original-src="https://miro.medium.com/v2/resize:fit:942/format:webp/1*kPwBLk6q0Q-TkcI6gWe4PQ.jpeg"/></div><p class="lr ls gj gh gi lt lu bd b be z dk nh di ni nj translated"><strong class="bd nk">Paul Milasan和Aaron Burden在Unsplash上拍摄的照片</strong></p></figure></div><p id="0741" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">斐波那契数列是一系列数字:</p><p id="9f21" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi">0, 1, 1, 2, 3, 5, 8, 13, 21, 34, …</p><p id="75a1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下一个数字是通过将它前面的两个数字相加得到的。</p><blockquote class="nl"><p id="f51c" class="nm nn it bd no np nq nr ns nt nu ld dk translated"><strong class="ak"> f(n) = f(n-1) + f(n-2) </strong></p></blockquote><p id="c3f2" class="pw-post-body-paragraph ki kj it kk b kl nv ju kn ko nw jx kq kr nx kt ku kv ny kx ky kz nz lb lc ld im bi translated">该序列的一个重要特征是，序列中任何一个数字与前一个数字之间的比率都趋向于一个明确定义的值:1.618……这就是黄金分割率或黄金分割率φ (Phi)，它经常自然出现。</p><p id="57a9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">观察植物、花或果实的几何形状，很容易识别重复结构和形式的存在。例如，斐波那契数列在叶序中起着至关重要的作用，叶序研究植物中叶子、树枝、花或种子的排列。</p><p id="4cf3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">就我们的目的而言，斐波那契数列非常重要，因为它可以递归计算。随着输入大小的增加，递归函数的计算开销会变得非常大。</p><h2 id="4328" class="oa lw it bd lx ob oc dn mb od oe dp mf kr of og mh kv oh oi mj kz oj ok ml ol bi translated">Python中的斐波那契</h2><p id="1c7e" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">斐波纳契数可以通过迭代计算<strong class="kk iu">:</strong></p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="ms mt l"/></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">迭代计算</p></figure><p id="77f8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">或者<strong class="kk iu">递归</strong>:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="ms mt l"/></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">递归计算</p></figure><p id="bdc3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">迭代计算将从斐波那契数列的开头开始，向上计数，直到到达输入索引。</p><p id="2efa" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">递归计算模仿数学符号，这样做时，递归地调用自身。这意味着对于传递给<code class="fe mu mv mw mx b">fibo_rec</code>的每个值，都要调用两次函数。这些调用还会产生更多对该函数的调用。因此，这是一个<strong class="kk iu">昂贵的</strong>计算。</p><p id="ba74" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们看看在有记忆和没有记忆的情况下，迭代和递归函数是如何执行的。</p><h1 id="0124" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">比较计算速度</h1><p id="e20b" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated"><em class="om">我们在本节中使用的计时和跟踪装饰器(@tracefunc和@timefunc)可以在本文中找到。</em></p><div class="on oo gp gr op oq"><a rel="noopener follow" target="_blank" href="/a-deeper-dive-into-decoration-ca4334ca5cf8"><div class="or ab fo"><div class="os ab ot cl cj ou"><h2 class="bd iu gy z fp ov fr fs ow fu fw is bi translated">对装饰的深入探究</h2><div class="ox l"><h3 class="bd b gy z fp ov fr fs ow fu fw dk translated">如何用Python编写灵活的、可重用的装饰器</h3></div><div class="oy l"><p class="bd b dl z fp ov fr fs ow fu fw dk translated">towardsdatascience.com</p></div></div><div class="oz l"><div class="pa l pb pc pd oz pe lp oq"/></div></div></a></div><p id="b042" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我们深入研究每个函数的性能之前，让我们回顾一下与渐近时间复杂性相关的语言。</p><h2 id="605d" class="oa lw it bd lx ob oc dn mb od oe dp mf kr of og mh kv oh oi mj kz oj ok ml ol bi translated">渐近复杂性</h2><p id="a17a" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">渐近计算复杂性是使用渐近分析来估计算法和计算问题的计算复杂性，通常与“big-O”符号相关联。</p><p id="d3a4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">换句话说，使用渐近分析，我们可以根据输入大小了解算法的性能。在这样做的时候，我们应该找到运行时间和输入大小之间的关系，用“O”表示。</p><p id="4ab7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们的斐波纳契计算是O(n)和O(2^n).</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi pf"><img src="../Images/ad90e8147020db6a648b1d28a7f206b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7rpe2ZsrIbp3Kv--GTPCSg.png"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">渐近复杂性或Big-O符号</p></figure><h2 id="b191" class="oa lw it bd lx ob oc dn mb od oe dp mf kr of og mh kv oh oi mj kz oj ok ml ol bi translated">递归斐波那契</h2><p id="75d8" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">回想一下，这是我们的昂贵计算。它的渐近复杂性是O(2^n).</p><p id="751b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里有一个<code class="fe mu mv mw mx b">traced_fibo_rec(8)</code>的痕迹。注意有多少冗余输入，以及必须完成多少次函数调用才能返回一个输出。O(2^n)指的是2⁸或256个打给<code class="fe mu mv mw mx b">fibo_rec</code>的电话。</p><div class="lg lh li lj gt ab cb"><figure class="na lk pg nc nd ne nf paragraph-image"><img src="../Images/6704f657efc81c6968670a4451830f94.png" data-original-src="https://miro.medium.com/v2/resize:fit:762/format:webp/1*9fRrJHEQ8UygDDNAplLxdw.png"/></figure><figure class="na lk ph nc nd ne nf paragraph-image"><img src="../Images/5c5af628c21ad541e87346780d652400.png" data-original-src="https://miro.medium.com/v2/resize:fit:786/format:webp/1*G6siXNzGDZ7wpU1b0mKWVQ.png"/><p class="lr ls gj gh gi lt lu bd b be z dk pi di pj nj translated">跟踪fibo _ rec→大量计算</p></figure></div><p id="2835" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">通话<code class="fe mu mv mw mx b">fibo_rec(8)</code>计算在千分之一秒多一点。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi pk"><img src="../Images/c6bac562b48c57eaf9a732dabf30e4bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*klv6XMIiwOqVWm0iso4u-Q.png"/></div></div></figure><h2 id="58a4" class="oa lw it bd lx ob oc dn mb od oe dp mf kr of og mh kv oh oi mj kz oj ok ml ol bi translated">递归函数的问题:回忆深度</h2><p id="8ede" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">当你给Python中的递归函数提供大的输入时，你会得到一个错误。这是为了避免堆栈溢出。Python解释器限制了递归限制，从而避免了无限递归。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi pl"><img src="../Images/253b1f6b3dc193ab857dd28a075d314e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tUWhvwRuiB_LgD4n8XQhaQ.png"/></div></div></figure><p id="be60" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">值得一提的是，您可以用<code class="fe mu mv mw mx b">sys</code>模块改变最大递归深度限制。</p><h2 id="2cc4" class="oa lw it bd lx ob oc dn mb od oe dp mf kr of og mh kv oh oi mj kz oj ok ml ol bi translated">记忆递归斐波那契</h2><p id="ae4b" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">现在让我们将记忆应用到我们昂贵的计算中。</p><p id="2b75" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里是<code class="fe mu mv mw mx b">cached_fibo_rec(8)</code>的轨迹。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi pm"><img src="../Images/f47fc2e565b2f0ba4e34b3e11a162dd6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2tOrE3sf6pFxzaRNW2mheA.png"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">更少计算</p></figure><p id="4f43" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注意对函数的调用减少了多少！这导致了更快的执行时间。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi pn"><img src="../Images/5e7e52a719b5c504f75191de04084c31.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wRufXL-tj17-UP0V52nZaQ.png"/></div></div></figure><p id="5272" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有了缓存，递归Fibonacci计算的速度提高了133倍。这是因为我们的函数只需要计算每个输出值一次。当出现冗余输入时，该函数从缓存中提取输出，而不是生成另一个深度递归堆栈！</p><p id="dc99" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">通过给这个函数添加记忆化，我们把它的big-O符号从O(2^n)改成了O(n)。这是算法性能的巨大提高。</p><h2 id="f46a" class="oa lw it bd lx ob oc dn mb od oe dp mf kr of og mh kv oh oi mj kz oj ok ml ol bi translated">迭代斐波那契</h2><p id="318a" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">这个函数O(n)的渐近复杂度。这是因为它在斐波纳契数列中从0到n循环。</p><p id="9bde" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以看到，调用<code class="fe mu mv mw mx b">fibo_iter(8)</code>的计算时间不到万分之一秒。这个函数的运行速度与我们记忆化的递归版本基本相同，因为它们具有相同的渐近复杂度。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi po"><img src="../Images/fb73cbc308f8dd4d699b1725d577f6a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RirEIlkxvtyidS0zDVLrkA.png"/></div></div></figure><p id="d1dc" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">值得注意的是，由于前面提到的最大递归深度限制，迭代Fibonacci算法可以计算比递归算法更大的序列号。</p><h2 id="5311" class="oa lw it bd lx ob oc dn mb od oe dp mf kr of og mh kv oh oi mj kz oj ok ml ol bi translated">记忆迭代斐波那契</h2><p id="9e6e" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">最后，让我们将记忆化应用到迭代函数中，看看性能是否有变化。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi pp"><img src="../Images/5c877b9edebf119ee4960dc06ae826ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zuRRR0GzcHy42Wcjocr5_w.png"/></div></div></figure><p id="47cf" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于这个算法，无论有没有缓存，我们看到的执行时间基本上是相同的。这表明记忆化对于快速函数(具有更好的O符号的函数)可能是无用的。也许对于这样的函数，计算输出的计算成本与访问缓存值的计算成本相同。对于非常快的函数，缓存访问甚至比计算冗余值还要慢！</p><h1 id="b2a9" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">结论</h1><p id="18cd" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">内存化是一种有用的缓存方法，可以优化具有冗余输入的昂贵函数调用的性能。在某些情况下，记忆化可以提高算法的渐近复杂性，这在递归或动态编程算法中很常见。例如，当我们将记忆化应用于具有O(2^n复杂度的递归算法时，我们看到了巨大的性能提升。在这种情况下，访问缓存比重复计算要快得多。</p><p id="ef63" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">记忆化允许我们使用递归斐波那契算法。不过迭代计算还是比较优越的。</p></div></div>    
</body>
</html>