<html>
<head>
<title>Data scientist’s guide to efficient coding in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数据科学家的Python高效编码指南</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/data-scientists-guide-to-efficient-coding-in-python-670c78a7bf79?source=collection_archive---------1-----------------------#2021-07-31">https://towardsdatascience.com/data-scientists-guide-to-efficient-coding-in-python-670c78a7bf79?source=collection_archive---------1-----------------------#2021-07-31</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="8486" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">更好的程序员</h2><div class=""/><div class=""><h2 id="cf71" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">我每天用来编写干净代码的技巧和窍门</h2></div><p id="b950" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">在这篇文章中，我想分享一些我在过去一年里学到的编写更简洁代码的技巧——主要来自结对编程。总的来说，将它们作为我日常编码程序的一部分，帮助我生成了高质量的Python脚本，随着时间的推移，这些脚本易于维护和扩展。</p><blockquote class="ln lo lp"><p id="5953" class="kr ks lq kt b ku kv kd kw kx ky kg kz lr lb lc ld ls lf lg lh lt lj lk ll lm im bi translated">想过为什么高级开发人员的代码比初级开发人员的代码看起来好得多吗？继续读下去，弥合差距…</p></blockquote><p id="a942" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">我将给出真实的编码场景，而不是给出如何使用这些技术的一般例子，在这些场景中，我已经<em class="lq">实际上</em>使用了它们！这是Jupyter Colab笔记本如果你想跟着去的话！</p><h2 id="d7b6" class="lv lw it bd lx ly lz dn ma mb mc dp md la me mf mg le mh mi mj li mk ml mm iz bi translated">1.使用<code class="fe mn mo mp mq b">for </code>回路时使用<code class="fe mn mo mp mq b">tqdm</code>。</h2><p id="4fb6" class="pw-post-body-paragraph kr ks it kt b ku mr kd kw kx ms kg kz la mt lc ld le mu lg lh li mv lk ll lm im bi translated">想象一下在一个<em class="lq">大的</em> iterable(列表、字典、元组、集合)上循环，并且不知道代码是否已经运行完毕！<em class="lq">倒霉蛋</em>，<em class="lq">右</em>！在这种情况下，确保使用<code class="fe mn mo mp mq b">tqdm</code>结构在旁边显示一个进度条。</p><p id="d65f" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">例如，当我通读44个不同目录中的所有文件时，为了显示进度(这些文件的路径已经存储在一个名为<code class="fe mn mo mp mq b">fpaths</code>的列表中):</p><pre class="mw mx my mz gt na mq nb nc aw nd bi"><span id="82a8" class="lv lw it mq b gy ne nf l ng nh">from tqdm import tqdm</span><span id="2973" class="lv lw it mq b gy ni nf l ng nh">files = list()<br/>fpaths = ["dir1/subdir1", "dir2/subdir3", ......]</span><span id="cde6" class="lv lw it mq b gy ni nf l ng nh">for fpath in tqdm(fpaths, desc="Looping over fpaths")):<br/>         files.extend(os.listdir(fpath))</span></pre><figure class="mw mx my mz gt nk gh gi paragraph-image"><div role="button" tabindex="0" class="nl nm di nn bf no"><div class="gh gi nj"><img src="../Images/8d41c039bfd22b0893d90edd9ceb7e73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5YzB1ok6hkRiM7wFcKtpHA.png"/></div></div><p class="nr ns gj gh gi nt nu bd b be z dk translated">将tqdm与“for”循环一起使用</p></figure><p id="3a81" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><em class="lq">注意:使用</em> <code class="fe mn mo mp mq b"><em class="lq">desc</em></code> <em class="lq">参数为循环指定一个小的描述。</em></p><h2 id="c31f" class="lv lw it bd lx ly lz dn ma mb mc dp md la me mf mg le mh mi mj li mk ml mm iz bi translated">2.使用<code class="fe mn mo mp mq b">type hinting when writing functions.</code></h2><p id="d527" class="pw-post-body-paragraph kr ks it kt b ku mr kd kw kx ms kg kz la mt lc ld le mu lg lh li mv lk ll lm im bi translated">简单地说，这意味着在Python函数定义中明确声明所有参数的类型。</p><p id="1631" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">当我在工作中使用类型提示时，我希望我能提供一些具体的用例来强调这一点，但事实是，我经常使用它们。</p><p id="2b74" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">这里有一个函数<code class="fe mn mo mp mq b">update_df()</code>的假设例子。它通过追加包含来自模拟运行的有用信息的行来更新给定的数据框，例如所使用的分类器、准确度得分、训练测试分割大小以及该特定运行的附加备注。</p><pre class="mw mx my mz gt na mq nb nc aw nd bi"><span id="be18" class="lv lw it mq b gy ne nf l ng nh">def update_df(<strong class="mq jd">df: pd.DataFrame</strong>, <br/>              <strong class="mq jd">clf: str</strong>, <br/>              <strong class="mq jd">acc: float</strong>,<br/>              <strong class="mq jd">split:float </strong>= 0.5,<br/>              <strong class="mq jd">remarks: List[str] = []</strong><br/>              ) -&gt; <strong class="mq jd">pd.DataFrame</strong>:</span><span id="71af" class="lv lw it mq b gy ni nf l ng nh">    new_row = {'Classifier':clf, <br/>               'Accuracy':acc, <br/>               'split_size':split,<br/>               'Remarks':remarks}</span><span id="1882" class="lv lw it mq b gy ni nf l ng nh">    df = df.append(new_row, ignore_index=True)<br/>    return df</span></pre><figure class="mw mx my mz gt nk gh gi paragraph-image"><div role="button" tabindex="0" class="nl nm di nn bf no"><div class="gh gi nv"><img src="../Images/d376034cbac2feb02211643143e3e8a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vdSi1N6dkoGcqrUI6abAZg.png"/></div></div></figure><p id="f5e0" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">需要注意的几件事:</p><ul class=""><li id="e175" class="nw nx it kt b ku kv kx ky la ny le nz li oa lm ob oc od oe bi translated">函数定义(<code class="fe mn mo mp mq b">def update_df(.......) <strong class="kt jd">-&gt;</strong> pd.DataFrame</code>)中<code class="fe mn mo mp mq b">-&gt;</code>符号后面的数据类型表示函数返回值的类型，即本例中的熊猫数据帧。</li><li id="496a" class="nw nx it kt b ku of kx og la oh le oi li oj lm ob oc od oe bi translated">默认值(如果有的话)可以像往常一样以<code class="fe mn mo mp mq b">param:type = value</code>的形式指定。(例如:<code class="fe mn mo mp mq b">split: float = 0.5</code>)</li><li id="999a" class="nw nx it kt b ku of kx og la oh le oi li oj lm ob oc od oe bi translated">如果一个函数不返回任何东西，请随意使用<code class="fe mn mo mp mq b">None</code>。例如:<code class="fe mn mo mp mq b">def func(a: str, b: int) -&gt; None: print(a,b)</code></li><li id="4d9c" class="nw nx it kt b ku of kx og la oh le oi li oj lm ob oc od oe bi translated">例如，要返回混合类型的值，假设一个函数可以在设置了标志<code class="fe mn mo mp mq b">option</code>的情况下打印一条语句，或者在没有设置标志的情况下返回一条<code class="fe mn mo mp mq b">int</code>:</li></ul><pre class="mw mx my mz gt na mq nb nc aw nd bi"><span id="1cf1" class="lv lw it mq b gy ne nf l ng nh"><strong class="mq jd">from typing import Union</strong><br/><em class="lq">def</em> dummy_args(*<em class="lq">args</em>: list[int], <em class="lq">option</em> = True) -&gt; <strong class="mq jd">Union[None, int]</strong>:</span><span id="710c" class="lv lw it mq b gy ni nf l ng nh">     if <em class="lq">option</em>:</span><span id="5056" class="lv lw it mq b gy ni nf l ng nh">          print(<em class="lq">args</em>)</span><span id="21d0" class="lv lw it mq b gy ni nf l ng nh">     else:</span><span id="773f" class="lv lw it mq b gy ni nf l ng nh">          return 10</span></pre><p id="1f1b" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><em class="lq">注意:从Python 3.10开始，</em> <code class="fe mn mo mp mq b"><em class="lq">Union</em></code> <em class="lq">就不需要了，可以简单的做:</em></p><pre class="mw mx my mz gt na mq nb nc aw nd bi"><span id="59e6" class="lv lw it mq b gy ne nf l ng nh"><em class="lq">def</em> dummy_args(*<em class="lq">args</em>: list[int], <em class="lq">option</em> = True) -&gt; <strong class="mq jd">None | int</strong>:</span><span id="27ba" class="lv lw it mq b gy ni nf l ng nh">     if <em class="lq">option</em>:</span><span id="d3d8" class="lv lw it mq b gy ni nf l ng nh">          print(<em class="lq">args</em>)</span><span id="b260" class="lv lw it mq b gy ni nf l ng nh">     else:</span><span id="f958" class="lv lw it mq b gy ni nf l ng nh">          return 10</span></pre><ul class=""><li id="a455" class="nw nx it kt b ku kv kx ky la ny le nz li oa lm ob oc od oe bi translated">在定义参数类型时，您可以想怎么具体就怎么具体，就像我们对<code class="fe mn mo mp mq b">remarks: List[str]</code>所做的那样。我们不仅指定它应该是一个<code class="fe mn mo mp mq b">List</code>，而且它应该只是一个<code class="fe mn mo mp mq b">str</code>的列表。<br/>为了好玩，试着在调用函数时向<code class="fe mn mo mp mq b">remarks</code>传递一个整数列表。您将不会看到任何错误返回！为什么会这样？因为Python解释器不会基于你的类型提示强制执行任何类型检查。</li></ul><blockquote class="ok"><p id="01d4" class="ol om it bd on oo op oq or os ot lm dk translated">除了添加文档之外，类型提示对你的代码没有任何影响。</p></blockquote><p id="c8c0" class="pw-post-body-paragraph kr ks it kt b ku ou kd kw kx ov kg kz la ow lc ld le ox lg lh li oy lk ll lm im bi translated">但是，包含它仍然是一个很好的实践！我觉得写函数的时候更清晰。此外，当有人调用这样一个函数时，他们会看到一个漂亮的提示，要求输入参数。</p><figure class="mw mx my mz gt nk gh gi paragraph-image"><div role="button" tabindex="0" class="nl nm di nn bf no"><div class="gh gi oz"><img src="../Images/af9f76414e4cf3f59bf0cde7c852c621.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XkpeluOSuW9T5gzTwKIIpA.png"/></div></div><p class="nr ns gj gh gi nt nu bd b be z dk translated">调用带有类型提示的函数时提示</p></figure><h2 id="cb95" class="lv lw it bd lx ly lz dn ma mb mc dp md la me mf mg le mh mi mj li mk ml mm iz bi translated">3.对于参数数量未知的函数使用args和kwargs<code class="fe mn mo mp mq b">.</code></h2><p id="2c5e" class="pw-post-body-paragraph kr ks it kt b ku mr kd kw kx ms kg kz la mt lc ld le mu lg lh li mv lk ll lm im bi translated">想象一下:您想要编写一个函数，将一些目录路径作为输入，并打印每个目录路径中的文件数量。问题是，我们不知道用户会输入多少路径！可能是2也可能是20！所以我们不确定在函数定义中应该定义多少个参数。显然，编写像<code class="fe mn mo mp mq b">def count_files(file1, file2, file3, …..file20)</code>这样的函数是愚蠢的。在这种情况下，<code class="fe mn mo mp mq b">args</code>和(有时是<code class="fe mn mo mp mq b">kwargs</code>)就派上用场了！</p><blockquote class="ln lo lp"><p id="cb0e" class="kr ks lq kt b ku kv kd kw kx ky kg kz lr lb lc ld ls lf lg lh lt lj lk ll lm im bi translated"><strong class="kt jd"> Args </strong>用于指定未知数量的<strong class="kt jd">位置</strong>参数。<br/> <strong class="kt jd"> Kwargs </strong>用于指定未知数量的<strong class="kt jd">关键字</strong>参数。</p></blockquote><h2 id="8646" class="lv lw it bd lx ly lz dn ma mb mc dp md la me mf mg le mh mi mj li mk ml mm iz bi translated">一个参数名</h2><p id="c020" class="pw-post-body-paragraph kr ks it kt b ku mr kd kw kx ms kg kz la mt lc ld le mu lg lh li mv lk ll lm im bi translated">下面是一个函数<code class="fe mn mo mp mq b">count_files_in_dir()</code>的例子，它接受<code class="fe mn mo mp mq b">project_root_dir</code>和任意数量的文件夹路径(在函数定义中使用<code class="fe mn mo mp mq b">*fpaths</code>)。作为输出，它打印每个文件夹中的文件数量。</p><pre class="mw mx my mz gt na mq nb nc aw nd bi"><span id="96db" class="lv lw it mq b gy ne nf l ng nh">def count_files_in_dir(project_root_dir, *fpaths: str):</span><span id="8d36" class="lv lw it mq b gy ni nf l ng nh">       for path in fpaths:</span><span id="1a92" class="lv lw it mq b gy ni nf l ng nh">            rel_path = os.path.join(project_root_dir, path)<br/>            print(path, ":", len(os.listdir(rel_path)))</span></pre><figure class="mw mx my mz gt nk gh gi paragraph-image"><div role="button" tabindex="0" class="nl nm di nn bf no"><div class="gh gi pa"><img src="../Images/daf641d98739a7d77cf301ede7c7b686.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A66kBdVI76lA_BPCd239xw.png"/></div></div><p class="nr ns gj gh gi nt nu bd b be z dk translated">统计Google Colab目录中的文件数量</p></figure><p id="deb9" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">在函数调用中，我们传入5个参数。由于函数定义期望一个<em class="lq">必需的</em>位置参数，即<code class="fe mn mo mp mq b">project_root_dir</code>，它自动知道<code class="fe mn mo mp mq b">"../usr"</code>必须是它。所有剩余的参数(本例中为4个)被<code class="fe mn mo mp mq b">*fpaths</code>吸收，并用于计算文件数。</p><p id="8379" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><em class="lq">注意:这种吸收技术的正确术语是“参数打包”，即剩余的参数被打包到</em> <code class="fe mn mo mp mq b"><em class="lq">*fpaths</em></code> <em class="lq">。</em></p><h2 id="5aad" class="lv lw it bd lx ly lz dn ma mb mc dp md la me mf mg le mh mi mj li mk ml mm iz bi translated">夸尔斯</h2><p id="1abd" class="pw-post-body-paragraph kr ks it kt b ku mr kd kw kx ms kg kz la mt lc ld le mu lg lh li mv lk ll lm im bi translated">让我们看看必须接受未知数量的<em class="lq">关键字</em>参数的函数。在这种情况下，我们必须使用<code class="fe mn mo mp mq b">kwargs</code>而不是<code class="fe mn mo mp mq b">args</code>。这里有一个简短(无用)的例子:</p><pre class="mw mx my mz gt na mq nb nc aw nd bi"><span id="916d" class="lv lw it mq b gy ne nf l ng nh">def print_results(**results):</span><span id="ce8e" class="lv lw it mq b gy ni nf l ng nh">     for key, val in results.items():<br/>        print(key, val)</span></pre><figure class="mw mx my mz gt nk gh gi paragraph-image"><div role="button" tabindex="0" class="nl nm di nn bf no"><div class="gh gi pb"><img src="../Images/23fff6741af99f6b25ac56e23f9ed745.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uFQXHHEVT53m0xTjjeWKUQ.png"/></div></div></figure><p id="cf18" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">用法与<code class="fe mn mo mp mq b">*args</code>非常相似，但是现在我们能够向函数传递任意数量的<em class="lq">关键字</em>参数。这些参数作为键值对存储在<code class="fe mn mo mp mq b">**results</code>字典中。从现在开始，使用<code class="fe mn mo mp mq b">.items()</code>很容易访问该字典中的条目。</p><p id="6e06" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">我在工作中发现了<code class="fe mn mo mp mq b">kwargs</code>的两个主要应用:</p><ul class=""><li id="e9e3" class="nw nx it kt b ku kv kx ky la ny le nz li oa lm ob oc od oe bi translated">合并字典(<em class="lq">有用但没那么有趣</em>)</li></ul><pre class="mw mx my mz gt na mq nb nc aw nd bi"><span id="a8e8" class="lv lw it mq b gy ne nf l ng nh">dict1 = {'a':2 , 'b': 20}<br/>dict2 = {'c':15 , 'd': 40}</span><span id="d8ac" class="lv lw it mq b gy ni nf l ng nh">merged_dict = {**dict1, **dict2}</span><span id="6525" class="lv lw it mq b gy ni nf l ng nh">*************************<br/>{'a': 2, 'b': 20, 'c': 15, 'd': 40}</span></pre><ul class=""><li id="fadb" class="nw nx it kt b ku kv kx ky la ny le nz li oa lm ob oc od oe bi translated">扩展一个现有的方法(<em class="lq">更有趣</em>)</li></ul><pre class="mw mx my mz gt na mq nb nc aw nd bi"><span id="4972" class="lv lw it mq b gy ne nf l ng nh">def myfunc(a, b, flag, **kwargs):</span><span id="78d0" class="lv lw it mq b gy ni nf l ng nh">       if flag:<br/>           a, b = do_some_computation(a,b)<br/>        <br/>       actual_function(a,b, **kwargs)</span></pre><p id="6860" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><em class="lq">注:check out</em><a class="ae lu" href="https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html#matplotlib-pyplot-plot" rel="noopener ugc nofollow" target="_blank"><em class="lq">matplotlib的plot函数使用</em> </a> <code class="fe mn mo mp mq b"><a class="ae lu" href="https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html#matplotlib-pyplot-plot" rel="noopener ugc nofollow" target="_blank"><em class="lq">kwargs</em></a></code> <em class="lq">为一个图指定可选的修饰，如线宽和标签。</em></p><p id="75ff" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">下面是我最近的一个项目中使用<code class="fe mn mo mp mq b">**kwargs</code>扩展方法的一个实际用例:<br/>我们经常使用Sklearn的<code class="fe mn mo mp mq b">train_test_split()</code>来拆分<code class="fe mn mo mp mq b">X</code>和<code class="fe mn mo mp mq b">y</code>。在GANs项目中的一个项目中，我必须将生成的合成图像分割成<em class="lq">相同的</em>训练测试分割，用于分割真实图像及其各自的标签。此外，我还希望能够传递通常会传递给<code class="fe mn mo mp mq b">train_test_split()</code>的任何其他参数。最后，<code class="fe mn mo mp mq b">stratify</code>必须总是被通过，因为我正在处理一个人脸识别问题(并且希望所有的标签都出现在训练集和测试集中)。</p><p id="5b71" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">为了实现这一点，我们创建了一个名为<code class="fe mn mo mp mq b">custom_train_test_split()</code>的函数。我已经包括了一堆打印语句来显示到底发生了什么(为了简洁省略了一些片段)。</p><pre class="mw mx my mz gt na mq nb nc aw nd bi"><span id="8f0e" class="lv lw it mq b gy ne nf l ng nh">def custom_train_test_split(clf, y, *X, stratify, **split_args):</span><span id="31ed" class="lv lw it mq b gy ni nf l ng nh">    <em class="lq">print("Classifier used: ", classifier)<br/>    print("Keys:", split_args.keys())<br/>    print("Values: ", split_args.values())<br/>    print(X)<br/>    print(y)<br/>    print("Length of passed keyword arguments: ", len(split_args))</em></span><span id="2f4e" class="lv lw it mq b gy ni nf l ng nh">    trainx,testx,*synthetic,trainy,testy = train_test_split(<br/>                                               *X,<br/>                                               y,<br/>                                               stratify=stratify,<br/>                                               **split_args<br/>                                               )</span><span id="f83c" class="lv lw it mq b gy ni nf l ng nh"><em class="lq">    ######### OMITTED CODE SNIPPET #############<br/>    # Train classifier on train and synthetic ims<br/>    # Calculate accuracy on testx, testy<br/>    ############################################</em></span><span id="6fbd" class="lv lw it mq b gy ni nf l ng nh">    <em class="lq">print("trainx: ", trainx, "trainy: ",trainy, '\n',  "testx: ", <br/>    testx, "testy:", testy)</em></span><span id="f6a7" class="lv lw it mq b gy ni nf l ng nh"><em class="lq">    print("synthetic: ", *synthetic)</em></span></pre><p id="a57c" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><em class="lq">注意:在调用这个函数时，为了便于理解，我没有使用实际的图像向量和标签(见下图)，而是用虚拟数据来代替。然而，该代码也应该适用于真实图像！</em></p><figure class="mw mx my mz gt nk gh gi paragraph-image"><div role="button" tabindex="0" class="nl nm di nn bf no"><div class="gh gi pc"><img src="../Images/7b418dc334f2d4be9a93e3240c968e2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ynjH1ZsPERllTqBk3RajYQ.png"/></div></div><p class="nr ns gj gh gi nt nu bd b be z dk translated">图A在函数定义中使用kwargs调用函数</p></figure><p id="02ed" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">一些需要注意的事情:</p><ul class=""><li id="00bc" class="nw nx it kt b ku kv kx ky la ny le nz li oa lm ob oc od oe bi translated">函数调用语句中使用的所有<em class="lq">关键字</em>参数(除 <code class="fe mn mo mp mq b">stratify</code>外的<strong class="kt jd">)(如<code class="fe mn mo mp mq b">train_size</code>和<code class="fe mn mo mp mq b">random_state</code>)将作为键值对存储在<code class="fe mn mo mp mq b">**split_args</code>字典中。(要进行验证，请检查蓝色的输出。)<br/>你可能会问，为什么不是<code class="fe mn mo mp mq b">stratify</code>？这是因为根据函数定义，它是一个<em class="lq">必需的</em>关键字专用的<em class="lq"> </em>参数，而不是一个<em class="lq">可选的</em>参数。</strong></li><li id="6c8d" class="nw nx it kt b ku of kx og la oh le oi li oj lm ob oc od oe bi translated">函数调用中传递的所有<em class="lq">非关键字</em>(即位置)<em class="lq"> </em>参数(如<code class="fe mn mo mp mq b">"SVM"</code>、<code class="fe mn mo mp mq b">labels</code>等)。)将存储在函数定义中的前三个参数中，即<code class="fe mn mo mp mq b">clf</code>、<code class="fe mn mo mp mq b">y</code>和<code class="fe mn mo mp mq b">*X</code>(是的，它们的传递顺序很重要)。然而，我们在函数调用中有四个参数，即<code class="fe mn mo mp mq b">"SVM"</code>、<code class="fe mn mo mp mq b">labels</code>、<code class="fe mn mo mp mq b">ims</code>和<code class="fe mn mo mp mq b">synthetic_ims</code>。我们将第四个存储在哪里？ <br/>记住我们在函数定义中使用<code class="fe mn mo mp mq b">*X</code>作为第三个参数，因此传递给函数的前两个参数之后的所有参数都被<em class="lq">打包</em>(浸泡)到<code class="fe mn mo mp mq b">*X</code>。(要进行验证，请检查绿色输出)。</li><li id="0b22" class="nw nx it kt b ku of kx og la oh le oi li oj lm ob oc od oe bi translated">当在我们的函数中调用<code class="fe mn mo mp mq b">train_test_split()</code>方法时，我们实际上是<em class="lq">使用<code class="fe mn mo mp mq b">*</code>操作符(<code class="fe mn mo mp mq b">*X</code>和<code class="fe mn mo mp mq b">**split_args</code>)将<code class="fe mn mo mp mq b">X</code>和<code class="fe mn mo mp mq b">split_args</code>参数解包</em>，这样它的所有元素都可以作为不同的参数传递。</li></ul><p id="8b6c" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">也就是说，</p><pre class="mw mx my mz gt na mq nb nc aw nd bi"><span id="dea4" class="lv lw it mq b gy ne nf l ng nh">train_test_split(*X, y, stratify = stratify, **split_args)</span></pre><p id="9adf" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">相当于写作</p><pre class="mw mx my mz gt na mq nb nc aw nd bi"><span id="948c" class="lv lw it mq b gy ne nf l ng nh">train_test_split(ims, synthetic_ims, y, stratify = stratify, train_size = 0.6, random_state = 50)</span></pre><ul class=""><li id="bb56" class="nw nx it kt b ku kv kx ky la ny le nz li oa lm ob oc od oe bi translated">当存储来自<code class="fe mn mo mp mq b">train_test_split()</code>方法的结果时，我们再次<em class="lq">将<code class="fe mn mo mp mq b">synthetic_train</code>和<code class="fe mn mo mp mq b">synthetic_test</code>集合打包到单个<code class="fe mn mo mp mq b">*synthetic</code>变量中。</em></li></ul><figure class="mw mx my mz gt nk gh gi paragraph-image"><div role="button" tabindex="0" class="nl nm di nn bf no"><div class="gh gi pd"><img src="../Images/c6d1264abcbed9e9bc5382453a2e5b7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ITUBHI06luwNUEpgLdGxdg.png"/></div></div></figure><p id="c308" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">为了检查里面有什么，我们可以使用<code class="fe mn mo mp mq b">*</code>操作符再次打开它(查看粉红色的输出)。</p><p id="6493" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><em class="lq">注意:如果你想深入研究使用</em> <code class="fe mn mo mp mq b"><em class="lq">*</em></code> <em class="lq">操作符进行打包&amp;的话，一定要看看这篇</em> <a class="ae lu" href="https://realpython.com/python-kwargs-and-args/" rel="noopener ugc nofollow" target="_blank"> <em class="lq">文章</em> </a> <em class="lq">。</em></p><h2 id="74e3" class="lv lw it bd lx ly lz dn ma mb mc dp md la me mf mg le mh mi mj li mk ml mm iz bi translated">4.使用预提交挂钩<code class="fe mn mo mp mq b">.</code></h2><p id="483b" class="pw-post-body-paragraph kr ks it kt b ku mr kd kw kx ms kg kz la mt lc ld le mu lg lh li mv lk ll lm im bi translated">我们写的代码通常是混乱的，并且缺乏适当的格式，例如尾随空格、尾随逗号、未排序的导入语句、缩进中的空格等。</p><p id="0b29" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">虽然手动修复所有这些是可能的，但是使用<a class="ae lu" href="https://pre-commit.com/" rel="noopener ugc nofollow" target="_blank">预提交钩子</a>，您将会节省自己大量的时间。更简单地说，这些钩子可以通过一行命令— <code class="fe mn mo mp mq b">pre-commit run</code>为您执行自动格式化。</p><p id="0c84" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">下面是一些来自官方文档的<a class="ae lu" href="https://pre-commit.com/#install" rel="noopener ugc nofollow" target="_blank">简单步骤</a>来开始使用，<a class="ae lu" href="https://pre-commit.com/index.html#2-add-a-pre-commit-configuration" rel="noopener ugc nofollow" target="_blank">创建一个</a> <code class="fe mn mo mp mq b"><a class="ae lu" href="https://pre-commit.com/index.html#2-add-a-pre-commit-configuration" rel="noopener ugc nofollow" target="_blank">.pre-commit-config.yaml</a></code> <a class="ae lu" href="https://pre-commit.com/index.html#2-add-a-pre-commit-configuration" rel="noopener ugc nofollow" target="_blank">文件</a>。它将包含<a class="ae lu" href="https://pre-commit.com/hooks.html" rel="noopener ugc nofollow" target="_blank">钩子</a>来处理你所关心的所有格式问题！</p><p id="96ab" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">作为一个纯粹的个人偏好，我倾向于保持我的<code class="fe mn mo mp mq b">.pre-commit-config.yaml</code>配置文件简单，坚持使用<a class="ae lu" href="https://black.readthedocs.io/en/stable/integrations/source_version_control.html" rel="noopener ugc nofollow" target="_blank"> Black的</a>预提交配置。</p><p id="279c" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><em class="lq">注意:需要记住的一点是，在您执行</em> <code class="fe mn mo mp mq b"><em class="lq">pre-commit run</em></code> <em class="lq">之前，文件必须被暂存，即</em> <code class="fe mn mo mp mq b"><em class="lq">git add .</em></code> <em class="lq">，否则，您会看到所有文件都将被跳过:</em></p><figure class="mw mx my mz gt nk gh gi paragraph-image"><div role="button" tabindex="0" class="nl nm di nn bf no"><div class="gh gi pe"><img src="../Images/3492d17aa71ad1277c14f75c3426676b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iUsNL1lmzGLcvsdU8ifGug.png"/></div></div></figure><h2 id="5b77" class="lv lw it bd lx ly lz dn ma mb mc dp md la me mf mg le mh mi mj li mk ml mm iz bi translated">5.使用。存储常数的yml配置文件<code class="fe mn mo mp mq b">.</code></h2><p id="ba5b" class="pw-post-body-paragraph kr ks it kt b ku mr kd kw kx ms kg kz la mt lc ld le mu lg lh li mv lk ll lm im bi translated">如果您的项目包含许多配置变量，如数据库主机名、密码、AWS凭证等。使用一个<code class="fe mn mo mp mq b">.yml</code>文件来跟踪所有这些。您以后可以在任何Jupyter笔记本或脚本中使用该文件。</p><p id="d359" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">鉴于我的大部分工作旨在为客户提供一个模型框架，以便他们可以在自己的数据集上再次训练它，我通常使用配置文件来存储文件夹和文件的路径。这也是一个很好的方法，可以确保客户端在运行您的脚本时只对一个文件进行更改。</p><p id="7fd7" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">让我们继续在项目目录中创建一个<code class="fe mn mo mp mq b">fpaths.yml</code>文件。我们将存储图像必须存储的根目录。此外，文件名、标签、属性等的路径。最后，我们还存储合成图像的路径。</p><pre class="mw mx my mz gt na mq nb nc aw nd bi"><span id="7d58" class="lv lw it mq b gy ne nf l ng nh">image_data_dir: path/to/img/dir</span><span id="6012" class="lv lw it mq b gy ni nf l ng nh"><em class="lq"># the following paths are relative to images_data_dir</em></span><span id="5b01" class="lv lw it mq b gy ni nf l ng nh">fnames:</span><span id="7d17" class="lv lw it mq b gy ni nf l ng nh">      fnames_fname: fnames.txt</span><span id="10b7" class="lv lw it mq b gy ni nf l ng nh">      fnames_label: labels.txt</span><span id="2e8a" class="lv lw it mq b gy ni nf l ng nh">      fnames_attr: attr.txt</span><span id="9dde" class="lv lw it mq b gy ni nf l ng nh">synthetic:</span><span id="81c1" class="lv lw it mq b gy ni nf l ng nh">       edit_method: interface_edits</span><span id="9a4d" class="lv lw it mq b gy ni nf l ng nh">       expression: smile.pkl</span><span id="213e" class="lv lw it mq b gy ni nf l ng nh">       pose: pose.pkl</span></pre><p id="db92" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">您可以像这样阅读该文件:</p><pre class="mw mx my mz gt na mq nb nc aw nd bi"><span id="8801" class="lv lw it mq b gy ne nf l ng nh"># open the yml file</span><span id="6370" class="lv lw it mq b gy ni nf l ng nh">with open(CONFIG_FPATH) as f:<br/>     dictionary = yaml.safe_load(f)</span><span id="8b8c" class="lv lw it mq b gy ni nf l ng nh"># print elements in dictionary</span><span id="457a" class="lv lw it mq b gy ni nf l ng nh">for key, value in dictionary.items():<br/>     print(key + " : " + str(value))<br/>     print()</span></pre><p id="664b" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><em class="lq">注:如果你想深入了解，这里有一个精彩的</em> <a class="ae lu" href="https://www.cloudbees.com/blog/yaml-tutorial-everything-you-need-get-started" rel="noopener ugc nofollow" target="_blank"> <em class="lq">教程</em> </a> <em class="lq">让你开始使用yaml。</em></p><h2 id="3bec" class="lv lw it bd lx ly lz dn ma mb mc dp md la me mf mg le mh mi mj li mk ml mm iz bi translated">6.额外收获:有用的VS代码扩展<code class="fe mn mo mp mq b">.</code></h2><p id="7d79" class="pw-post-body-paragraph kr ks it kt b ku mr kd kw kx ms kg kz la mt lc ld le mu lg lh li mv lk ll lm im bi translated">虽然对于Python编辑器来说确实有很多不错的选择，但我必须说VSCode无疑是我迄今为止看到的最好的(<em class="lq">抱歉，Pycharm </em>)。为了更好地利用它，可以考虑从市场上安装这些扩展:</p><ul class=""><li id="e774" class="nw nx it kt b ku kv kx ky la ny le nz li oa lm ob oc od oe bi translated"><a class="ae lu" href="https://marketplace.visualstudio.com/items?itemName=CoenraadS.bracket-pair-colorizer" rel="noopener ugc nofollow" target="_blank">括号对上色器</a> —允许用颜色识别匹配的括号。</li></ul><figure class="mw mx my mz gt nk gh gi paragraph-image"><div role="button" tabindex="0" class="nl nm di nn bf no"><div class="gh gi pf"><img src="../Images/cc66e49695fd9547e3893eccbb1892e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PQa37cPob3zadE_P85CPsw.png"/></div></div></figure><ul class=""><li id="d3ad" class="nw nx it kt b ku kv kx ky la ny le nz li oa lm ob oc od oe bi translated"><a class="ae lu" href="https://marketplace.visualstudio.com/items?itemName=christian-kohler.path-intellisense" rel="noopener ugc nofollow" target="_blank">路径智能感知</a> —允许自动完成文件名。</li></ul><figure class="mw mx my mz gt nk gh gi paragraph-image"><div role="button" tabindex="0" class="nl nm di nn bf no"><div class="gh gi pg"><img src="../Images/715eef32b28a047434f14f10c95fe047.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Fe_vKzNeJ-eupwj0HngZZw.png"/></div></div></figure><ul class=""><li id="1792" class="nw nx it kt b ku kv kx ky la ny le nz li oa lm ob oc od oe bi translated"><a class="ae lu" href="https://marketplace.visualstudio.com/items?itemName=njpwerner.autodocstring" rel="noopener ugc nofollow" target="_blank">Python Dockstring generator</a>—允许为Python函数生成文档字符串。</li></ul><figure class="mw mx my mz gt nk gh gi paragraph-image"><div role="button" tabindex="0" class="nl nm di nn bf no"><div class="gh gi ph"><img src="../Images/659b43f17545b7f354542e5e4fb8e6e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*5cHUB1yqHgLoBdYX.jpg"/></div></div><p class="nr ns gj gh gi nt nu bd b be z dk translated">使用VScode扩展生成文档字符串</p></figure><p id="b8d9" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><em class="lq"> Pro-tip:生成docstring(使用</em> <code class="fe mn mo mp mq b"><em class="lq">"""</em></code> <em class="lq"> ) </em> <strong class="kt jd"> <em class="lq">在</em> </strong> <em class="lq">之后你已经使用类型提示编写了函数。这样，生成的docstring将包含更丰富的信息，如默认值、参数类型等。(见右上图)。</em></p><ul class=""><li id="f3fe" class="nw nx it kt b ku kv kx ky la ny le nz li oa lm ob oc od oe bi translated"><a class="ae lu" href="https://marketplace.visualstudio.com/items?itemName=KevinRose.vsc-python-indent" rel="noopener ugc nofollow" target="_blank"> Python缩进</a>——(<em class="lq">我的最爱；由</em>发布由<a class="ae lu" href="https://marketplace.visualstudio.com/publishers/KevinRose" rel="noopener ugc nofollow" target="_blank">凯文·罗斯</a>发布)允许对多行运行的代码/括号进行适当的缩进。</li></ul><figure class="mw mx my mz gt nk gh gi paragraph-image"><div class="gh gi pi"><img src="../Images/bf57d3c55215fc055219f229ceca3202.png" data-original-src="https://miro.medium.com/v2/resize:fit:1264/0*XpslsIPxTdiHnycr.gif"/></div><p class="nr ns gj gh gi nt nu bd b be z dk translated">来源:<a class="ae lu" href="https://marketplace.visualstudio.com/items?itemName=KevinRose.vsc-python-indent" rel="noopener ugc nofollow" target="_blank"> VSCode扩展市场</a></p></figure><ul class=""><li id="d7e0" class="nw nx it kt b ku kv kx ky la ny le nz li oa lm ob oc od oe bi translated"><a class="ae lu" href="https://marketplace.visualstudio.com/items?itemName=njqdev.vscode-python-typehint" rel="noopener ugc nofollow" target="_blank"> Python类型提示</a> —允许在编写函数时自动完成类型提示。</li></ul><figure class="mw mx my mz gt nk gh gi paragraph-image"><div role="button" tabindex="0" class="nl nm di nn bf no"><div class="gh gi pj"><img src="../Images/0fbdf27a96d81bc773660ee640745607.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*no9Fut43SVXK4K8jaIwarw.png"/></div></div></figure><ul class=""><li id="2fce" class="nw nx it kt b ku kv kx ky la ny le nz li oa lm ob oc od oe bi translated"><a class="ae lu" href="https://marketplace.visualstudio.com/items?itemName=Gruntfuggly.todo-tree" rel="noopener ugc nofollow" target="_blank">待办事项树</a> : ( <em class="lq">第二喜欢的</em>)在一个地方记录所有在编写脚本时插入的<code class="fe mn mo mp mq b">TODO</code>。</li></ul><figure class="mw mx my mz gt nk gh gi paragraph-image"><div role="button" tabindex="0" class="nl nm di nn bf no"><div class="gh gi pk"><img src="../Images/7388ff399aeb8136e602531acb8246ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bv_0qKgTY2NkWI0PjRjnoA.png"/></div></div><p class="nr ns gj gh gi nt nu bd b be z dk translated">跟踪插入到项目中的所有TODO注释</p></figure><ul class=""><li id="e3f8" class="nw nx it kt b ku kv kx ky la ny le nz li oa lm ob oc od oe bi translated"><a class="ae lu" href="https://marketplace.visualstudio.com/items?itemName=ms-python.vscode-pylance" rel="noopener ugc nofollow" target="_blank"> Pylance </a> —允许代码完成、参数建议(以及更快地编写代码)。</li></ul><p id="e388" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">恭喜你离专业Python开发人员又近了一步。当我学到更多酷的技巧时，我打算继续更新这篇文章。一如既往，如果有更简单的方法来做我在本文中提到的一些事情，请让我知道。</p><p id="0492" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">直到下次:)</p></div><div class="ab cl pl pm hx pn" role="separator"><span class="po bw bk pp pq pr"/><span class="po bw bk pp pq pr"/><span class="po bw bk pp pq"/></div><div class="im in io ip iq"><p id="b353" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><em class="lq">我喜欢写循序渐进的初学者指南、操作指南、面试问题、解码ML/AI中使用的术语等。如果你想完全访问我的所有文章(以及其他媒体上的文章)，那么你可以使用</em> <a class="ae lu" href="https://varshitasher.medium.com/membership" rel="noopener"> <strong class="kt jd"> <em class="lq">我的链接</em></strong></a><strong class="kt jd"><em class="lq"/></strong><em class="lq">这里</em> <strong class="kt jd"> <em class="lq">注册。</em>T19】</strong></p><div class="ps pt gp gr pu pv"><a rel="noopener follow" target="_blank" href="/understanding-python-imports-init-py-and-pythonpath-once-and-for-all-4c5249ab6355"><div class="pw ab fo"><div class="px ab py cl cj pz"><h2 class="bd jd gy z fp qa fr fs qb fu fw jc bi translated">了解Python导入，__init__。py和pythonpath —一劳永逸</h2><div class="qc l"><h3 class="bd b gy z fp qa fr fs qb fu fw dk translated">了解如何导入包和模块(以及两者之间的区别)</h3></div><div class="qd l"><p class="bd b dl z fp qa fr fs qb fu fw dk translated">towardsdatascience.com</p></div></div><div class="qe l"><div class="qf l qg qh qi qe qj np pv"/></div></div></a></div><div class="ps pt gp gr pu pv"><a rel="noopener follow" target="_blank" href="/end-to-end-deep-learning-project-part-1-930af1e1e191"><div class="pw ab fo"><div class="px ab py cl cj pz"><h2 class="bd jd gy z fp qa fr fs qb fu fw jc bi translated">端到端深度学习项目:第1部分</h2><div class="qc l"><h3 class="bd b gy z fp qa fr fs qb fu fw dk translated">用Keras实现迁移学习的高效网络图像分类模型</h3></div><div class="qd l"><p class="bd b dl z fp qa fr fs qb fu fw dk translated">towardsdatascience.com</p></div></div><div class="qe l"><div class="qk l qg qh qi qe qj np pv"/></div></div></a></div><div class="ps pt gp gr pu pv"><a rel="noopener follow" target="_blank" href="/interviewers-favorite-question-how-would-you-scale-your-ml-model-56e4fa40071b"><div class="pw ab fo"><div class="px ab py cl cj pz"><h2 class="bd jd gy z fp qa fr fs qb fu fw jc bi translated">面试官最喜欢的问题-你会如何“扩展你的ML模型？”</h2><div class="qc l"><h3 class="bd b gy z fp qa fr fs qb fu fw dk translated">您正在构建一个生产就绪的ML模型吗？</h3></div><div class="qd l"><p class="bd b dl z fp qa fr fs qb fu fw dk translated">towardsdatascience.com</p></div></div><div class="qe l"><div class="ql l qg qh qi qe qj np pv"/></div></div></a></div><div class="ps pt gp gr pu pv"><a rel="noopener follow" target="_blank" href="/time-series-analysis-using-pandas-in-python-f726d87a97d8"><div class="pw ab fo"><div class="px ab py cl cj pz"><h2 class="bd jd gy z fp qa fr fs qb fu fw jc bi translated">使用Python中的Pandas进行时间序列分析</h2><div class="qc l"><h3 class="bd b gy z fp qa fr fs qb fu fw dk translated">对季节性、趋势、自相关等关键词的额外介绍。</h3></div><div class="qd l"><p class="bd b dl z fp qa fr fs qb fu fw dk translated">towardsdatascience.com</p></div></div><div class="qe l"><div class="qm l qg qh qi qe qj np pv"/></div></div></a></div><div class="ps pt gp gr pu pv"><a href="https://podurama.com/" rel="noopener  ugc nofollow" target="_blank"><div class="pw ab fo"><div class="px ab py cl cj pz"><h2 class="bd jd gy z fp qa fr fs qb fu fw jc bi translated">Podurama:播客播放器</h2><div class="qc l"><h3 class="bd b gy z fp qa fr fs qb fu fw dk translated">iOS、Android、Web、Windows和MacOS的无限设备之间的免费同步。阿米莉亚·汤普森这是……</h3></div><div class="qd l"><p class="bd b dl z fp qa fr fs qb fu fw dk translated">podurama.com</p></div></div><div class="qe l"><div class="qn l qg qh qi qe qj np pv"/></div></div></a></div><div class="ps pt gp gr pu pv"><a href="https://varshitasher.medium.com/membership" rel="noopener follow" target="_blank"><div class="pw ab fo"><div class="px ab py cl cj pz"><h2 class="bd jd gy z fp qa fr fs qb fu fw jc bi translated">阅读瓦希塔·谢尔博士的每一个故事(以及媒体上成千上万的其他作家)</h2><div class="qc l"><h3 class="bd b gy z fp qa fr fs qb fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="qd l"><p class="bd b dl z fp qa fr fs qb fu fw dk translated">varshitasher.medium.com</p></div></div><div class="qe l"><div class="qo l qg qh qi qe qj np pv"/></div></div></a></div></div></div>    
</body>
</html>