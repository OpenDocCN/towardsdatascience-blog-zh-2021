<html>
<head>
<title>Introducing Skippa</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">介绍 Skippa</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/introducing-skippa-bab260acf6a7?source=collection_archive---------9-----------------------#2021-12-15">https://towardsdatascience.com/introducing-skippa-bab260acf6a7?source=collection_archive---------9-----------------------#2021-12-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="75d6" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">sci kit-了解熊猫的预处理管道</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/c3964c5dee4496820dfc276cf592393e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*R0tvOUoOb9CJGOeo"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">由<a class="ae kv" href="https://unsplash.com/@marco_midmore?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Marco Midmore </a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h1 id="f93c" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">摘要</h1><p id="0b73" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">任何一个数据科学家大概都很熟悉<code class="fe mk ml mm mn b">pandas</code>和<code class="fe mk ml mm mn b">scikit-learn</code>。通常的工作流程需要在 pandas 中清理数据，并再次使用<code class="fe mk ml mm mn b">pandas</code>或<code class="fe mk ml mm mn b">scikit-learn</code>转换器如<code class="fe mk ml mm mn b">StandardScaler</code>、<code class="fe mk ml mm mn b">OneHotEncoder</code>等进行进一步的预处理。之后，机器学习算法被拟合(再次来自<code class="fe mk ml mm mn b">scikit-learn</code>)。</p><p id="c530" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mq lz ma mb mr md me mf ms mh mi mj ij bi translated">这种方法存在一些问题:</p><p id="6f6c" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mq lz ma mb mr md me mf ms mh mi mj ij bi translated">1.开发工作流相当复杂，需要大量代码😰</p><p id="0bf5" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mq lz ma mb mr md me mf ms mh mi mj ij bi translated">2.很难在部署中重现预测工作流😩</p><p id="3b94" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mq lz ma mb mr md me mf ms mh mi mj ij bi translated">3.减轻这些问题的现有解决方案根本不够好😞</p><p id="322e" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mq lz ma mb mr md me mf ms mh mi mj ij bi translated"><strong class="lq ir"> Skippa </strong>是一款旨在:</p><ul class=""><li id="fb0a" class="mt mu iq lq b lr mo lu mp lx mv mb mw mf mx mj my mz na nb bi translated">✨ <em class="nc">大幅</em>简化开发</li><li id="22fa" class="mt mu iq lq b lr nd lu ne lx nf mb ng mf nh mj my mz na nb bi translated">📦将所有数据清理、预处理以及模型算法打包/序列化到一个管道文件中</li><li id="668d" class="mt mu iq lq b lr nd lu ne lx nf mb ng mf nh mj my mz na nb bi translated">😌重用您已经熟悉的<code class="fe mk ml mm mn b">pandas</code> &amp; <code class="fe mk ml mm mn b">scikit-learn</code>中的接口/组件</li></ul><p id="1040" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mq lz ma mb mr md me mf ms mh mi mj ij bi translated">Skippa 帮助您在<code class="fe mk ml mm mn b">pandas</code> <code class="fe mk ml mm mn b">DataFrame</code>上轻松定义数据清理和预处理操作，并将其与<code class="fe mk ml mm mn b">scikit-learn</code>模型/算法组合成一个可执行的管道。它大致是这样工作的:</p><pre class="kg kh ki kj gt ni mn nj nk aw nl bi"><span id="245d" class="nm kx iq mn b gy nn no l np nq">from skippa import Skippa, columns<br/>from sklearn.linear_model import LogisticRegression</span><span id="8b3e" class="nm kx iq mn b gy nr no l np nq">X, y = get_training_data(...)</span><span id="5d4c" class="nm kx iq mn b gy nr no l np nq">pipeline = (<br/>    Skippa()<br/>    .impute(columns(dtype_include='object'), strategy='most_frequent')<br/>    .impute(columns(dtype_include='number'), strategy='median')<br/>    .scale(columns(dtype_include='number'), type='standard')<br/>    .onehot(columns(['category1', 'category2']))<br/>    .model(LogisticRegression())<br/>)<br/>pipeline.fit(X, y)</span><span id="60f3" class="nm kx iq mn b gy nr no l np nq">predictions = pipeline.predict_proba(X)</span></pre><blockquote class="ns nt nu"><p id="1580" class="lo lp nc lq b lr mo jr lt lu mp ju lw nv mq lz ma nw mr md me nx ms mh mi mj ij bi translated">☝️·斯基帕并不假定能解决所有问题，也不涵盖你可能需要的所有功能，也不是一个高度可扩展的解决方案，但它应该能够为超过 80%的常规基于 pandas/sklearn 的机器学习项目提供大规模简化。</p></blockquote><h2 id="9dec" class="nm kx iq bd ky ny nz dn lc oa ob dp lg lx oc od li mb oe of lk mf og oh lm oi bi translated">链接</h2><ul class=""><li id="37f2" class="mt mu iq lq b lr ls lu lv lx oj mb ok mf ol mj my mz na nb bi translated"><a class="ae kv" href="https://github.com/data-science-lab-amsterdam/skippa" rel="noopener ugc nofollow" target="_blank">📂Github </a></li><li id="f285" class="mt mu iq lq b lr nd lu ne lx nf mb ng mf nh mj my mz na nb bi translated"><a class="ae kv" href="https://pypi.org/project/skippa/" rel="noopener ugc nofollow" target="_blank">📦pypi </a></li><li id="34ad" class="mt mu iq lq b lr nd lu ne lx nf mb ng mf nh mj my mz na nb bi translated"><a class="ae kv" href="https://skippa.readthedocs.io/" rel="noopener ugc nofollow" target="_blank">📝阅读文档</a></li></ul></div><div class="ab cl om on hu oo" role="separator"><span class="op bw bk oq or os"/><span class="op bw bk oq or os"/><span class="op bw bk oq or"/></div><div class="ij ik il im in"><p id="7ca1" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mq lz ma mb mr md me mf ms mh mi mj ij bi translated">⏩<a class="ae kv" href="#fd0c" rel="noopener ugc nofollow"> <em class="nc">跳过短文直接上趣味 par </em> </a> <em class="nc"> t </em></p><h1 id="fb50" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">为什么需要 Skippa</h1><h2 id="bd16" class="nm kx iq bd ky ny nz dn lc oa ob dp lg lx oc od li mb oe of lk mf og oh lm oi bi translated">问题 1:代码太多…</h2><p id="dfb0" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">对于概念上非常简单的任务—输入缺失值、一次性编码分类值、选择列的子集、缩放等。—你需要相当多的代码。如果通常您从一个由各种数据类型的列组成的<code class="fe mk ml mm mn b">pandas</code>数据帧开始，那么您需要对不同的列进行不同的转换，并且您的许多代码涉及选择列子集和合并转换后的数据。</p><p id="b157" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mq lz ma mb mr md me mf ms mh mi mj ij bi translated">你想要的基本上是一组步骤，你说:我想把这个转换应用到这些列中。要是有一个软件包能让你用这样的习惯用法编码就好了…</p><h2 id="ad74" class="nm kx iq bd ky ny nz dn lc oa ob dp lg lx oc od li mb oe of lk mf og oh lm oi bi translated">问题 2:复制和部署</h2><p id="671e" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">如果您想要部署您的模型，您需要能够重现您的预处理代码，以便在预测上下文中使用。此外，除了您的酸洗模型文件，您还需要为您的拟合定标器、拟合一键编码器和其他可能的转换生成酸洗文件，因为它们是生成新数据预测所必需的！这很快变得难以维持。如果您能将所有这些逻辑保存到一个文件中就好了…</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ot"><img src="../Images/ece25751d2393a065ff94527a35cd1b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iG2Cy3UiQy6hs2o0T7cpFg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><h2 id="6271" class="nm kx iq bd ky ny nz dn lc oa ob dp lg lx oc od li mb oe of lk mf og oh lm oi bi translated">问题 3:现有的解决方案不够好</h2><p id="0543" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">现在，在这个课题上已经做了很多工作。在<code class="fe mk ml mm mn b">scikit-learn</code>你有</p><ul class=""><li id="9d13" class="mt mu iq lq b lr mo lu mp lx mv mb mw mf mx mj my mz na nb bi translated">你可以用这个<code class="fe mk ml mm mn b">Pipeline</code>将某些变形金刚链接到你的算法中</li><li id="c788" class="mt mu iq lq b lr nd lu ne lx nf mb ng mf nh mj my mz na nb bi translated">和<code class="fe mk ml mm mn b">ColumnTransformer</code>，您可以用它来定义不同列组上变压器的管道。</li></ul><p id="16ff" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mq lz ma mb mr md me mf ms mh mi mj ij bi translated">虽然我觉得这很麻烦。看看这个例子:</p><pre class="kg kh ki kj gt ni mn nj nk aw nl bi"><span id="5a30" class="nm kx iq mn b gy nn no l np nq">import numpy as np<br/>import pandas as pd<br/><br/>from sklearn.compose import ColumnTransformer<br/>from sklearn.impute import SimpleImputer<br/>from sklearn.pipeline import Pipeline<br/>from sklearn.preprocessing import OneHotEncoder<br/>from sklearn.tree import DecisionTreeClassifier<br/><br/><em class="nc"># this is the input dataframe</em><br/>df <strong class="mn ir">=</strong> pd<strong class="mn ir">.</strong>DataFrame({<br/>    'favorite_color':['blue','green','red','green','blue'],<br/>    'age': [10,15,10,np<strong class="mn ir">.</strong>nan,10],<br/>    'target':[1,0,1,0,1]<br/>})<br/><br/><em class="nc"># define individual transformers in a pipeline</em><br/>categorical_preprocessing <strong class="mn ir">=</strong> Pipeline([('ohe', OneHotEncoder())])<br/>numerical_preprocessing <strong class="mn ir">=</strong> Pipeline([('imputation', SimpleImputer())])<br/><br/><em class="nc"># define which transformer applies to which columns</em><br/>preprocess <strong class="mn ir">=</strong> ColumnTransformer([<br/>    ('categorical_preprocessing', categorical_preprocessing, ['favorite_color']),<br/>    ('numerical_preprocessing', numerical_preprocessing, ['age'])<br/>])<br/><br/><em class="nc"># create the final pipeline with preprocessing steps and </em><br/><em class="nc"># the final classifier step</em><br/>pipeline <strong class="mn ir">=</strong> Pipeline([<br/>    ('preprocess', preprocess),<br/>    ('clf', DecisionTreeClassifier())<br/>])<br/><br/><em class="nc"># now fit the pipeline using the whole dataframe</em><br/>df_features <strong class="mn ir">=</strong> df[['favorite_color','age']]<br/>df_target <strong class="mn ir">=</strong> df['target']<br/><br/><em class="nc"># call fit on the dataframes</em><br/>pipeline<strong class="mn ir">.</strong>fit(df_features, df_target)</span></pre><p id="de5d" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mq lz ma mb mr md me mf ms mh mi mj ij bi translated">这确实有用，但是</p><ul class=""><li id="b833" class="mt mu iq lq b lr mo lu mp lx mv mb mw mf mx mj my mz na nb bi translated">使用起来相当复杂和麻烦</li><li id="e04b" class="mt mu iq lq b lr nd lu ne lx nf mb ng mf nh mj my mz na nb bi translated">如果需要对多组列进行串行转换，就会遇到限制，因为每个转换器的输出是一个<code class="fe mk ml mm mn b">numpy</code>数组，而不是一个<code class="fe mk ml mm mn b">pandas</code>数据帧</li></ul><p id="5e95" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mq lz ma mb mr md me mf ms mh mi mj ij bi translated">有一个包<code class="fe mk ml mm mn b"><a class="ae kv" href="https://github.com/scikit-learn-contrib/sklearn-pandas" rel="noopener ugc nofollow" target="_blank">sklearn-pandas</a></code>是一个高尚的努力来补救这些问题。虽然它确实解决了一些问题，但我并不满意。</p><h1 id="2064" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">斯基帕的设计和原则</h1><p id="547f" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">skippa 最重要的设计原则是转换的输出总是一个<code class="fe mk ml mm mn b">pandas DataFrame</code>。为什么？因为从概念上讲，您从一个<code class="fe mk ml mm mn b">DataFrame</code>开始，它由不同数据类型的不同列组成，需要不同的转换。使用 sklearn，转换的输出是一个<code class="fe mk ml mm mn b">numpy</code>数组。这通常意味着您丢失了列名和数据类型(一切都变成了浮点型)。从概念上讲，当将管道链接在一起时，您希望使用列的名称和/或数据类型来引用列。只有当<code class="fe mk ml mm mn b">DataFrame</code>在整个管道中始终用作中央数据表示时，这才是可能的。</p><p id="0081" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mq lz ma mb mr md me mf ms mh mi mj ij bi translated">Skippa 通过实现现有转换的定制版本来实现这个结果。现在，这种方法当然有一个缺点:这些转换不能直接使用，需要实现一个特定的包装器。这总是意味着开发成本和可维护性成本。我希望 Skippa 提供的好处能够抵消这个成本。</p><p id="1284" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mq lz ma mb mr md me mf ms mh mi mj ij bi translated">其他设计考虑:</p><ul class=""><li id="692e" class="mt mu iq lq b lr mo lu mp lx mv mb mw mf mx mj my mz na nb bi translated">Skippa 的目标是拥有一种语法，它是定义转换的最简单的方式。</li><li id="acab" class="mt mu iq lq b lr nd lu ne lx nf mb ng mf nh mj my mz na nb bi translated">Skippa 并不支持您可能需要的所有功能。目的是为<em class="nc">大多数</em>用例提供附加值，<em class="nc">不是所有</em>用例。但是仍然有一个后备方法来定义任意转换！</li><li id="5bb1" class="mt mu iq lq b lr nd lu ne lx nf mb ng mf nh mj my mz na nb bi translated">是的，你需要学习一种稍微新的“语言”(即<code class="fe mk ml mm mn b">Skippa</code>方法)，但是我觉得这很简单，对于任何熟悉<code class="fe mk ml mm mn b">pandas</code>和<code class="fe mk ml mm mn b">scikit-learn</code>的人来说都很容易学会。</li></ul><h1 id="fd0c" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">Skippa 的工作原理</h1><p id="8068" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">所以，在所有这些抱怨和自以为聪明之后，让我们展示一下 Skippa 的能力吧！</p><p id="fff5" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mq lz ma mb mr md me mf ms mh mi mj ij bi translated">安装只是通过<a class="ae kv" href="https://pypi.org/project/skippa/" rel="noopener ugc nofollow" target="_blank"> pypi </a>:</p><pre class="kg kh ki kj gt ni mn nj nk aw nl bi"><span id="2bc9" class="nm kx iq mn b gy nn no l np nq">$ pip install skippa</span></pre><p id="df70" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mq lz ma mb mr md me mf ms mh mi mj ij bi translated">导入<code class="fe mk ml mm mn b">Skippa</code>对象和<code class="fe mk ml mm mn b">columns</code>辅助函数:</p><pre class="kg kh ki kj gt ni mn nj nk aw nl bi"><span id="eca7" class="nm kx iq mn b gy nn no l np nq">from skippa import Skippa, columns</span></pre><p id="e4eb" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mq lz ma mb mr md me mf ms mh mi mj ij bi translated">这个想法是你从一个<code class="fe mk ml mm mn b">pandas DataFrame</code>开始。然后启动一个 Skippa 管道，然后使用链接命令来定义需要应用于某些列的转换。最后一步通常是来自<code class="fe mk ml mm mn b">scikit-learn</code>的模型估计器(如分类器、回归器、聚类器)。</p><pre class="kg kh ki kj gt ni mn nj nk aw nl bi"><span id="1313" class="nm kx iq mn b gy nn no l np nq">X, y = get_training_data(...)</span><span id="f070" class="nm kx iq mn b gy nr no l np nq">pipeline = (<br/>    Skippa()<br/>    .<em class="nc">&lt;transformation-1&gt;</em>(<em class="nc">&lt;column-definition&gt;</em>, <em class="nc">&lt;optional-args&gt;</em>)<br/>    .<em class="nc">&lt;transformation-2&gt;</em>(<em class="nc">&lt;column-definition&gt;</em>, <em class="nc">&lt;optional-args&gt;</em>)<br/>    ...<br/>    .model(<em class="nc">&lt;model-estimator&gt;</em>(<em class="nc">&lt;optional-args&gt;</em>))<br/>)<br/>pipeline.fit(X, y)<br/>pipeline.save('./models/mypipeline')</span></pre><p id="ae2b" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mq lz ma mb mr md me mf ms mh mi mj ij bi translated">好，现在举个具体的例子。我们有一个<code class="fe mk ml mm mn b">pandas</code> <code class="fe mk ml mm mn b">DataFrame</code> <code class="fe mk ml mm mn b">X</code>有 10 列:</p><ul class=""><li id="a90c" class="mt mu iq lq b lr mo lu mp lx mv mb mw mf mx mj my mz na nb bi translated">4 个浮点列、2 个整数列、3 个分类列和 1 个日期列</li><li id="0d6e" class="mt mu iq lq b lr nd lu ne lx nf mb ng mf nh mj my mz na nb bi translated">浮点列和分类列中有缺失值</li></ul><p id="b306" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mq lz ma mb mr md me mf ms mh mi mj ij bi translated">我们有一组标签<code class="fe mk ml mm mn b">y</code>(0 或 1)</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ou"><img src="../Images/a2b8dfb9f3e2b9804f003b44981d44c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FoT99c0K0INHse-oDaGlNg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">X 和 y 的控制台输出(图片由作者提供)</p></figure><p id="0722" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mq lz ma mb mr md me mf ms mh mi mj ij bi translated">我们想做的如下</p><ul class=""><li id="2dcd" class="mt mu iq lq b lr mo lu mp lx mv mb mw mf mx mj my mz na nb bi translated">删除一堆我们不需要的列</li><li id="6e2f" class="mt mu iq lq b lr nd lu ne lx nf mb ng mf nh mj my mz na nb bi translated">估算缺失值(数值列的中值，分类列的最常见值)</li><li id="5795" class="mt mu iq lq b lr nd lu ne lx nf mb ng mf nh mj my mz na nb bi translated">一键编码分类列</li><li id="54ff" class="mt mu iq lq b lr nd lu ne lx nf mb ng mf nh mj my mz na nb bi translated">缩放数字列</li><li id="007d" class="mt mu iq lq b lr nd lu ne lx nf mb ng mf nh mj my mz na nb bi translated">拟合逻辑回归模型</li></ul><p id="f7a4" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mq lz ma mb mr md me mf ms mh mi mj ij bi translated">我们可以用几行代码来实现:</p><pre class="kg kh ki kj gt ni mn nj nk aw nl bi"><span id="2b83" class="nm kx iq mn b gy nn no l np nq">pipe = (<br/>    Skippa()<br/>    .select(columns(exclude=['a', 'f', 'i', 'j']))<br/>    .impute(columns(dtype_include='number'), strategy='median')<br/>    .impute(columns(dtype_include='object'), strategy='most_frequent')<br/>    .scale(columns(dtype_include='number'), type='standard')<br/>    .onehot(columns(['g', 'h']))<br/>    .model(LogisticRegression())<br/>)<br/>pipe.fit(X, y)<br/>pipeline.save('./models/mypipeline')</span></pre><p id="e785" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mq lz ma mb mr md me mf ms mh mi mj ij bi translated">我们保存的文件是一个<code class="fe mk ml mm mn b">SkippaPipeline</code>，它是<code class="fe mk ml mm mn b">scikit-learn</code>的<code class="fe mk ml mm mn b">Pipeline</code>的子类。它包含预处理和逻辑回归的整个流水线。易于部署和重用:</p><pre class="kg kh ki kj gt ni mn nj nk aw nl bi"><span id="6e72" class="nm kx iq mn b gy nn no l np nq">df_scoring = get_scoring_data(...)</span><span id="7c31" class="nm kx iq mn b gy nr no l np nq">my_pipeline = Skippa.load_pipeline('./models/mypipeline')</span><span id="f64b" class="nm kx iq mn b gy nr no l np nq">predictions = my_pipeline.predict_proba(df_scoring)</span></pre><p id="94a3" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mq lz ma mb mr md me mf ms mh mi mj ij bi translated">因为 Skippa 管道是一个常规的<code class="fe mk ml mm mn b">scikit-learn</code> <code class="fe mk ml mm mn b">Pipeline</code>对象，所以你可以使用所有的标准方法，比如<code class="fe mk ml mm mn b">.fit</code>、<code class="fe mk ml mm mn b">.transform</code>、<code class="fe mk ml mm mn b">.predict</code>、<code class="fe mk ml mm mn b">.predict_proba</code>等等。</p><h1 id="1ec4" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">如果我只想要预处理呢？</h1><p id="5391" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">如果您只是对处理数据感兴趣，而不希望用建模算法完成流水线，这是完全可行的。或者，您可能只是想检查进入算法的最终数据集。使用<code class="fe mk ml mm mn b">.build()</code>方法是可能的:</p><pre class="kg kh ki kj gt ni mn nj nk aw nl bi"><span id="2b79" class="nm kx iq mn b gy nn no l np nq">pipe = (<br/>    Skippa()<br/>    .select(columns(exclude=['a', 'f', 'i', 'j']))<br/>    .impute(columns(dtype_include='number'), strategy='median')<br/>    .impute(columns(dtype_include='object'), strategy='most_frequent')<br/>    .scale(columns(dtype_include='number'), type='standard')<br/>    .onehot(columns(['g', 'h']))<br/>    .build()<br/>)<br/>df_processed = pipe.fit_transform(X)<br/>df_processed.info()</span></pre><h1 id="93ba" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">关于选择列</h1><p id="8114" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">使用<code class="fe mk ml mm mn b">columns()</code>函数来定义转换的列子集。有几种方法可以使用它。例如，包括或排除列名列表:</p><ul class=""><li id="24b7" class="mt mu iq lq b lr mo lu mp lx mv mb mw mf mx mj my mz na nb bi translated"><code class="fe mk ml mm mn b">columns(['a', 'b'])</code>简单定义一个列名列表</li><li id="cc64" class="mt mu iq lq b lr nd lu ne lx nf mb ng mf nh mj my mz na nb bi translated"><code class="fe mk ml mm mn b">columns(include=['a', 'b'])</code>这相当于</li><li id="2471" class="mt mu iq lq b lr nd lu ne lx nf mb ng mf nh mj my mz na nb bi translated"><code class="fe mk ml mm mn b">columns(exclude=['a', 'b'])</code>类似地，您可以取消选择列</li></ul><p id="5f6c" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mq lz ma mb mr md me mf ms mh mi mj ij bi translated">您也可以使用<code class="fe mk ml mm mn b">sklearn</code>的<code class="fe mk ml mm mn b">make_column_selector()</code>功能中的<code class="fe mk ml mm mn b">dtype_include</code>、<code class="fe mk ml mm mn b">dtype_exclude</code>和<code class="fe mk ml mm mn b">pattern</code>。</p><ul class=""><li id="b0df" class="mt mu iq lq b lr mo lu mp lx mv mb mw mf mx mj my mz na nb bi translated"><code class="fe mk ml mm mn b">columns(dtype_include='float')</code>选择所有浮动列</li><li id="c4f3" class="mt mu iq lq b lr nd lu ne lx nf mb ng mf nh mj my mz na nb bi translated"><code class="fe mk ml mm mn b">columns(dtype_exclude='number')</code>取消选择所有数字列</li><li id="1c82" class="mt mu iq lq b lr nd lu ne lx nf mb ng mf nh mj my mz na nb bi translated"><code class="fe mk ml mm mn b">columns(pattern='myprefix_*')</code>选择从<code class="fe mk ml mm mn b">myprefix_</code>开始的所有列</li></ul><p id="14f8" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mq lz ma mb mr md me mf ms mh mi mj ij bi translated">还可以加减多个列选择器！</p><ul class=""><li id="1feb" class="mt mu iq lq b lr mo lu mp lx mv mb mw mf mx mj my mz na nb bi translated"><code class="fe mk ml mm mn b">columns(dtype_include='object') — columns(['c', ‘d'])</code>选择除<code class="fe mk ml mm mn b">c</code>和<code class="fe mk ml mm mn b">d</code>之外的所有对象列。</li></ul><h1 id="e574" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">支持的变压器</h1><p id="08a0" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">这些是 Skippa 支持的转换。如果需要的话，它们可以是现有的<code class="fe mk ml mm mn b">scikit-learn</code>转换器、现有的<code class="fe mk ml mm mn b">pandas.DataFrame</code>方法或者定制实现的包装器。</p><ul class=""><li id="5880" class="mt mu iq lq b lr mo lu mp lx mv mb mw mf mx mj my mz na nb bi translated"><code class="fe mk ml mm mn b">.impute()</code><br/>sklearn 的<code class="fe mk ml mm mn b">SimpleImputer</code>周围的包装纸。<br/>例子:<code class="fe mk ml mm mn b">.impute(columns(dtype_include='int'), method='medium')</code></li><li id="1b04" class="mt mu iq lq b lr nd lu ne lx nf mb ng mf nh mj my mz na nb bi translated"><code class="fe mk ml mm mn b">.scale()</code> <br/>包裹住 sklearn 的<code class="fe mk ml mm mn b">StandardScaler</code>(如果<code class="fe mk ml mm mn b">type='standard'</code>)或者<code class="fe mk ml mm mn b">MinMaxScaler</code>(如果<code class="fe mk ml mm mn b">type='minmax'</code>)。<br/>举例:<code class="fe mk ml mm mn b">.scale(columns(dtype_include='numeric'), 'minmax')</code></li><li id="bac3" class="mt mu iq lq b lr nd lu ne lx nf mb ng mf nh mj my mz na nb bi translated"><code class="fe mk ml mm mn b">.onehot()</code><br/>sk learn 的<code class="fe mk ml mm mn b">OneHotEncoder</code>周围的 Wrapper。<br/>例如:<code class="fe mk ml mm mn b">.onehot(columns(dtype_include='category'))</code></li><li id="44c3" class="mt mu iq lq b lr nd lu ne lx nf mb ng mf nh mj my mz na nb bi translated"><code class="fe mk ml mm mn b">.encode_date()</code> <br/>自定义转换器，用于创建特性的过时值。它应用 pandas 的<code class="fe mk ml mm mn b">pd.to_datetime()</code>并使用结果<code class="fe mk ml mm mn b">.dt</code>对象的属性。<br/>示例:<code class="fe mk ml mm mn b">.encode_date(columns(['mydate']), {'year': False, 'month': True, 'day': True})</code></li><li id="eb06" class="mt mu iq lq b lr nd lu ne lx nf mb ng mf nh mj my mz na nb bi translated"><code class="fe mk ml mm mn b">.cast()</code>T42<code class="fe mk ml mm mn b">pandas.DataFrame.astype()</code>裹尸布。它有别名<code class="fe mk ml mm mn b">.astype()</code>和<code class="fe mk ml mm mn b">.as_type()</code>。<br/>例如:<code class="fe mk ml mm mn b">.cast(columns(dtype_include='int'), 'float')</code></li><li id="0c2b" class="mt mu iq lq b lr nd lu ne lx nf mb ng mf nh mj my mz na nb bi translated"><code class="fe mk ml mm mn b">.rename()</code> <br/>外裹<code class="fe mk ml mm mn b">pandas.DataFrame.rename()</code>。<br/>注意:<em class="nc">没有</em>有列说明符吗！<br/>例如:<code class="fe mk ml mm mn b">.rename({'a': 'name', 'b': 'age'})</code></li><li id="4c63" class="mt mu iq lq b lr nd lu ne lx nf mb ng mf nh mj my mz na nb bi translated"><code class="fe mk ml mm mn b">.assign()</code> <br/>外裹<code class="fe mk ml mm mn b">pandas.DataFrame.assign()</code>。<br/>注意:<em class="nc">不是</em>有列说明符吗！<br/>例如:<code class="fe mk ml mm mn b">.assign(y_sq=lambda df: df['y']*df['y'])</code></li><li id="cd66" class="mt mu iq lq b lr nd lu ne lx nf mb ng mf nh mj my mz na nb bi translated"><code class="fe mk ml mm mn b">.apply()</code> <br/>包装轮<code class="fe mk ml mm mn b">pandas.DataFrame.apply()</code>。<br/>例如:<code class="fe mk ml mm mn b">.apply(np.log)</code></li><li id="7019" class="mt mu iq lq b lr nd lu ne lx nf mb ng mf nh mj my mz na nb bi translated"><code class="fe mk ml mm mn b">.select()</code> <br/>简单地选择列的子集。<br/>举例:<code class="fe mk ml mm mn b">.select(columns(dtype_exclude='object'))</code></li><li id="1c9f" class="mt mu iq lq b lr nd lu ne lx nf mb ng mf nh mj my mz na nb bi translated"><code class="fe mk ml mm mn b">.model()</code> <br/>不是变压器而是估算器。只能作为你管道的最后一步。提供一个<code class="fe mk ml mm mn b">sklearn</code>估算器作为参数。<br/>例子:<code class="fe mk ml mm mn b">.model(RandomForestClassifier(n_estimators=200, max_depth=5))</code></li><li id="c36f" class="mt mu iq lq b lr nd lu ne lx nf mb ng mf nh mj my mz na nb bi translated"><code class="fe mk ml mm mn b">.concat()</code> <br/>将另一个并行管道连接到当前管道。这将连接这些管线的结果要素集。<br/>例如:<br/>T4】</li></ul><blockquote class="ns nt nu"><p id="b822" class="lo lp nc lq b lr mo jr lt lu mp ju lw nv mq lz ma nw mr md me nx ms mh mi mj ij bi translated">☝️:我们的想法是继续添加变形器来获得额外的功能，但是对于任何不被支持的功能，总是可以选择使用<code class="fe mk ml mm mn b">.assign</code>或<code class="fe mk ml mm mn b">.apply</code>方法来应用任何变形。</p></blockquote><p id="c907" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mq lz ma mb mr md me mf ms mh mi mj ij bi translated">我渴望收到关于您的体验、意见和功能需求的反馈，所以请在 Github 中留下您的反馈或创建一个问题！</p><p id="ac98" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mq lz ma mb mr md me mf ms mh mi mj ij bi translated">跳绳快乐！</p><h2 id="d26e" class="nm kx iq bd ky ny nz dn lc oa ob dp lg lx oc od li mb oe of lk mf og oh lm oi bi translated">链接</h2><ul class=""><li id="1253" class="mt mu iq lq b lr ls lu lv lx oj mb ok mf ol mj my mz na nb bi translated"><a class="ae kv" href="https://github.com/data-science-lab-amsterdam/skippa" rel="noopener ugc nofollow" target="_blank">📂Github </a></li><li id="ecc6" class="mt mu iq lq b lr nd lu ne lx nf mb ng mf nh mj my mz na nb bi translated"><a class="ae kv" href="https://pypi.org/project/skippa/" rel="noopener ugc nofollow" target="_blank">📦pypi </a></li><li id="9c16" class="mt mu iq lq b lr nd lu ne lx nf mb ng mf nh mj my mz na nb bi translated"><a class="ae kv" href="https://skippa.readthedocs.io/" rel="noopener ugc nofollow" target="_blank">📝阅读文档</a></li></ul></div></div>    
</body>
</html>