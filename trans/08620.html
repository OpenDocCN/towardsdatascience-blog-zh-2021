<html>
<head>
<title>Search Algorithm — Depth-first search, with Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">搜索算法-深度优先搜索，使用Python</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/search-algorithm-depth-first-search-with-python-1f10da161980?source=collection_archive---------18-----------------------#2021-08-09">https://towardsdatascience.com/search-algorithm-depth-first-search-with-python-1f10da161980?source=collection_archive---------18-----------------------#2021-08-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d0d1" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">从头开始Python实现</h2></div><p id="c8c4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我将介绍一种叫做深度优先搜索(DFS)的基础搜索算法。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi le"><img src="../Images/89187db19ce47177eb024ea1deda3c06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*YkhG8zLIiytcW73I"/></div></div><p class="lq lr gj gh gi ls lt bd b be z dk translated">丹尼尔·勒曼在<a class="ae lu" href="https://unsplash.com/?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="4421" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">搜索算法是一种检索存储在某些数据结构中的信息的算法，或者是在问题域的搜索空间中计算的信息[1]。通过选择节点扩展的顺序来定义搜索策略。可以从以下几个方面评估战略:</p><ol class=""><li id="323c" class="lv lw it kk b kl km ko kp kr lx kv ly kz lz ld ma mb mc md bi translated">完整性:如果存在的话，它是否总能找到解决方案？</li><li id="3e47" class="lv lw it kk b kl me ko mf kr mg kv mh kz mi ld ma mb mc md bi translated">时间复杂性:找到解决方案需要多长时间？</li><li id="838e" class="lv lw it kk b kl me ko mf kr mg kv mh kz mi ld ma mb mc md bi translated">空间复杂度:内存中的最大节点数</li><li id="a9b6" class="lv lw it kk b kl me ko mf kr mg kv mh kz mi ld ma mb mc md bi translated">最优性:它总能找到最佳(最低成本)的解决方案吗？</li></ol><h1 id="1760" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">定义</h1><p id="a61d" class="pw-post-body-paragraph ki kj it kk b kl nb ju kn ko nc jx kq kr nd kt ku kv ne kx ky kz nf lb lc ld im bi translated">深度优先搜索是一种遍历或搜索树或图数据结构的算法[2]。在解释DFS算法之前，我们先介绍一下图形数据结构。一个<strong class="kk iu">图</strong> G是一个对(V，E)，其中V是一个有限集，E是V上的一组二元关系</p><p id="8644" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">❖ V被称为<em class="ng">顶点集</em>，它的元素是<em class="ng">顶点</em>。</p><p id="a011" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">❖ E被称为<em class="ng">边集</em>，它的元素被称为<em class="ng">边</em>。一条边由一对顶点表示。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi nh"><img src="../Images/572b9956b778f70a817d9fcb65e542b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*hQrlbnE4yu3Gy-3U.png"/></div></div><p class="lq lr gj gh gi ls lt bd b be z dk translated">图形数据结构的例子[3]</p></figure><p id="5cb2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">该图是顶点为V={1，2，3，4，5，6}，E={{1，2}，{1，5}，{2，3}，{2，5}，{3，4}，{4，5}，{4，6}}的图形的示意图</p></div><div class="ab cl ni nj hx nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="im in io ip iq"><h1 id="f457" class="mj mk it bd ml mm np mo mp mq nq ms mt jz nr ka mv kc ns kd mx kf nt kg mz na bi translated">深度优先搜索</h1><p id="bc2a" class="pw-post-body-paragraph ki kj it kk b kl nb ju kn ko nc jx kq kr nd kt ku kv ne kx ky kz nf lb lc ld im bi translated">现在，让我们开始详细解释DFS。它从根节点开始，扩展最深的未扩展节点，仅在不再扩展时回溯。让我们通过下图来看一个例子:</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi nu"><img src="../Images/656f17e7e5d1374b0ee6a4787b85ca0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u-PFWPmF11YPPkbrPWPFvg.png"/></div></div><p class="lq lr gj gh gi ls lt bd b be z dk translated">通过DFS的示例图。图片作者。</p></figure><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi nv"><img src="../Images/9ecfece7110ccb31ffce5a4f9a6e0568.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NKIqcb-mfqRisqvx6AZiIA.png"/></div></div><p class="lq lr gj gh gi ls lt bd b be z dk translated">DFS算法，逐步扩展。图片作者。</p></figure><p id="0d04" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">从上面的逐步展开图中，我们可以看到，DFS算法沿路径优先选择边来执行搜索。</p><p id="1267" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，让我们评估这个算法:<br/>将<strong class="kk iu"> m </strong>表示为状态空间的最大深度，将<strong class="kk iu"> b </strong>表示为搜索树或图的最大分支因子</p><ol class=""><li id="e7e6" class="lv lw it kk b kl km ko kp kr lx kv ly kz lz ld ma mb mc md bi translated">完备性:<br/>无限深度空间:否<br/>有循环的有限深度空间:否<br/>有重复状态检查的有限深度空间:是<br/>无循环的有限深度空间:是</li><li id="20bf" class="lv lw it kk b kl me ko mf kr mg kv mh kz mi ld ma mb mc md bi translated">时间复杂度:O( <strong class="kk iu"> bᵐ </strong></li><li id="2375" class="lv lw it kk b kl me ko mf kr mg kv mh kz mi ld ma mb mc md bi translated">空间复杂度:O( <strong class="kk iu"> bm </strong></li><li id="a45f" class="lv lw it kk b kl me ko mf kr mg kv mh kz mi ld ma mb mc md bi translated">最优性:否</li></ol></div><div class="ab cl ni nj hx nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="im in io ip iq"><h1 id="6a88" class="mj mk it bd ml mm np mo mp mq nq ms mt jz nr ka mv kc ns kd mx kf nt kg mz na bi translated">代码实现</h1><p id="dcd8" class="pw-post-body-paragraph ki kj it kk b kl nb ju kn ko nc jx kq kr nd kt ku kv ne kx ky kz nf lb lc ld im bi translated">让我们用上面的例子用Python实现DFS算法。</p><p id="1ee4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">该图是具有顶点V={A，B，C，D，E，F，G，H，I，J，K，L，M}，E={{A，B}，{A，C}，{B，D}，{B，E}，{C，F}，{C，G}，{D，H}，{D，I}，{E，J}，{E，K}，{F，L}，{F，M}}的图形的示意图</p><ol class=""><li id="ef24" class="lv lw it kk b kl km ko kp kr lx kv ly kz lz ld ma mb mc md bi translated">创建接收图的边的函数，输出无向图的邻接表</li></ol><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="nw nx l"/></div></figure><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/7afb36d3a2d0ce625d65c5c5f21cab2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:686/format:webp/1*w-vdVoJQQxlaLTYU7J2deA.png"/></div><p class="lq lr gj gh gi ls lt bd b be z dk translated">代码的输出。图片作者。</p></figure><p id="e5b1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">2.创建接收邻接表的函数和输出DFS搜索序列的起始顶点</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="nw nx l"/></div></figure><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/2b984dbd53be4a649400c67babb9c3f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1294/format:webp/1*BBkPth5uZE5HDgf_glmm3w.png"/></div><p class="lq lr gj gh gi ls lt bd b be z dk translated">代码的输出。图片作者。</p></figure></div><div class="ab cl ni nj hx nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="im in io ip iq"><h1 id="5525" class="mj mk it bd ml mm np mo mp mq nq ms mt jz nr ka mv kc ns kd mx kf nt kg mz na bi translated">参考</h1><p id="0dca" class="pw-post-body-paragraph ki kj it kk b kl nb ju kn ko nc jx kq kr nd kt ku kv ne kx ky kz nf lb lc ld im bi translated">[1] <a class="ae lu" href="https://en.wikipedia.org/wiki/Search_algorithm" rel="noopener ugc nofollow" target="_blank">搜索算法—维基百科</a></p><p id="27e5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">[2] <a class="ae lu" href="https://en.wikipedia.org/wiki/Depth-first_search" rel="noopener ugc nofollow" target="_blank">深度优先搜索——维基百科</a></p><p id="1b3b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">[3] <a class="ae lu" href="https://en.wikipedia.org/wiki/Graph_(discrete_mathematics)" rel="noopener ugc nofollow" target="_blank">图(离散数学)—维基百科</a></p></div></div>    
</body>
</html>