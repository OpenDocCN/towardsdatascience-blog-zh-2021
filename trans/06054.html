<html>
<head>
<title>Getting Started with Breakpoints Analysis in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python断点分析入门</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/getting-started-with-breakpoints-analysis-in-python-124471708d38?source=collection_archive---------6-----------------------#2021-05-31">https://towardsdatascience.com/getting-started-with-breakpoints-analysis-in-python-124471708d38?source=collection_archive---------6-----------------------#2021-05-31</a></blockquote><div><div class="fc ik il im in io"/><div class="ip iq ir is it"><h2 id="697f" class="iu iv iw bd b dl ix iy iz ja jb jc dk jd translated" aria-label="kicker paragraph">数据分析</h2><div class=""/><div class=""><h2 id="2ccb" class="pw-subtitle-paragraph kc jf iw bd b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt dk translated">一个现成的教程，比较Python中断点分析的breakes和Jenkspy库</h2></div><figure class="kv kw kx ky gu kz gi gj paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="gi gj ku"><img src="../Images/4bc5d97896309bb23eddc108588ec349.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZmK4ms4cdpf2ySVNr3MKqA.png"/></div></div><p class="lg lh gk gi gj li lj bd b be z dk translated">作者图片</p></figure><p id="9298" class="pw-post-body-paragraph lk ll iw lm b ln lo kg lp lq lr kj ls lt lu lv lw lx ly lz ma mb mc md me mf ip bi translated">在处理时间序列时，识别断点非常重要。事实上，在执行预测时，数据中断点的存在可能会导致错误和模型不稳定。</p><blockquote class="mg mh mi"><p id="aa07" class="lk ll mj lm b ln lo kg lp lq lr kj ls mk lu lv lw ml ly lz ma mm mc md me mf ip bi translated">断点是数据中的结构变化，如异常或预期事件。</p></blockquote><p id="8d76" class="pw-post-body-paragraph lk ll iw lm b ln lo kg lp lq lr kj ls lt lu lv lw lx ly lz ma mb mc md me mf ip bi translated">存在许多识别断点的技术。一般来说，这些技术可以分为两类:</p><ul class=""><li id="473e" class="mn mo iw lm b ln lo lq lr lt mp lx mq mb mr mf ms mt mu mv bi translated"><strong class="lm jg">检测</strong> —检测一个或多个断点</li><li id="0e60" class="mn mo iw lm b ln mw lq mx lt my lx mz mb na mf ms mt mu mv bi translated"><strong class="lm jg">测试</strong> —给定一个点，检查它是否是断点。这一类技术包括著名的<a class="ae nb" href="https://en.wikipedia.org/wiki/Chow_test" rel="noopener ugc nofollow" target="_blank">周试</a>。</li></ul><p id="2440" class="pw-post-body-paragraph lk ll iw lm b ln lo kg lp lq lr kj ls lt lu lv lw lx ly lz ma mb mc md me mf ip bi translated">在这个简短的教程中，我将重点放在第一类断点上，并比较了两个用于断点分析的Python库:<code class="fe nc nd ne nf b">ruptures</code>和<code class="fe nc nd ne nf b">jenkspy</code>。</p><p id="e4d5" class="pw-post-body-paragraph lk ll iw lm b ln lo kg lp lq lr kj ls lt lu lv lw lx ly lz ma mb mc md me mf ip bi translated">代码以Jupyter笔记本的形式提供，可以从我的<a class="ae nb" href="https://github.com/alod83/data-science/tree/master/DataAnalysis/BreakpointAnalysis" rel="noopener ugc nofollow" target="_blank"> Github库</a>下载。</p><h1 id="a859" class="ng nh iw bd ni nj nk nl nm nn no np nq kl nr km ns ko nt kp nu kr nv ks nw nx bi translated">加载数据</h1><p id="5c0b" class="pw-post-body-paragraph lk ll iw lm b ln ny kg lp lq nz kj ls lt oa lv lw lx ob lz ma mb oc md me mf ip bi translated">首先，我加载数据集作为一个<code class="fe nc nd ne nf b">pandas</code>数据帧。作为数据集，我利用了从2015年到2020年的观众趋势。Giallozafferano是一个非常著名的意大利美食博客。数据是从一个分析意大利互联网使用的意大利网站Audiweb中提取的，然后通过我的一个学生开发的一个名为LEX的软件进行加工。LEX是一个非常有用的软件，它可以将微软Excel中的多个文件，按日期划分，转换成一个CSV文件。如果你想了解这个软件，请给我留言:)</p><pre class="kv kw kx ky gu od nf oe of aw og bi"><span id="3681" class="oh nh iw nf b gz oi oj l ok ol">import pandas as pd</span><span id="7def" class="oh nh iw nf b gz om oj l ok ol">df = pd.read_csv('GialloZafferano.csv')<br/>df.head()</span></pre><figure class="kv kw kx ky gu kz gi gj paragraph-image"><div class="gi gj on"><img src="../Images/3ad553589d8265b6c81fc062078ac792.png" data-original-src="https://miro.medium.com/v2/resize:fit:696/format:webp/1*f-tAU12iPDma2ONuK6nApw.png"/></div><p class="lg lh gk gi gj li lj bd b be z dk translated">作者图片</p></figure><p id="5ee4" class="pw-post-body-paragraph lk ll iw lm b ln lo kg lp lq lr kj ls lt lu lv lw lx ly lz ma mb mc md me mf ip bi translated">现在我把数据帧转换成时间序列。这可以分三步完成:</p><ul class=""><li id="01e1" class="mn mo iw lm b ln lo lq lr lt mp lx mq mb mr mf ms mt mu mv bi translated">将<code class="fe nc nd ne nf b">data</code>字段转换为日期时间</li><li id="c2f1" class="mn mo iw lm b ln mw lq mx lt my lx mz mb na mf ms mt mu mv bi translated">将日期列设置为时间序列的索引</li><li id="216b" class="mn mo iw lm b ln mw lq mx lt my lx mz mb na mf ms mt mu mv bi translated">将该列值分配给一个名为<code class="fe nc nd ne nf b">ts</code>的新变量。</li></ul><pre class="kv kw kx ky gu od nf oe of aw og bi"><span id="59c4" class="oh nh iw nf b gz oi oj l ok ol">df['date'] = pd.to_datetime(df['date'])<br/>df.set_index(df['date'], inplace = True)<br/>ts = df['audience']</span></pre><p id="b0ee" class="pw-post-body-paragraph lk ll iw lm b ln lo kg lp lq lr kj ls lt lu lv lw lx ly lz ma mb mc md me mf ip bi translated">我画出了时间序列。我开发了<code class="fe nc nd ne nf b">matplotlib</code>库。</p><figure class="kv kw kx ky gu kz gi gj paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="gi gj ku"><img src="../Images/9c2126a18417ef147bce60f2dcadef16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cfhPsAfubDd4AKrai2gGRg.png"/></div></div><p class="lg lh gk gi gj li lj bd b be z dk translated">作者图片</p></figure><p id="4b17" class="pw-post-body-paragraph lk ll iw lm b ln lo kg lp lq lr kj ls lt lu lv lw lx ly lz ma mb mc md me mf ip bi translated">看这个图表，我注意到有三个主要的转折点。因此，我决定寻找3个突破口。</p><figure class="kv kw kx ky gu kz gi gj paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="gi gj ku"><img src="../Images/4bc5d97896309bb23eddc108588ec349.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZmK4ms4cdpf2ySVNr3MKqA.png"/></div></div><p class="lg lh gk gi gj li lj bd b be z dk translated">作者图片</p></figure><pre class="kv kw kx ky gu od nf oe of aw og bi"><span id="fb40" class="oh nh iw nf b gz oi oj l ok ol">n_breaks = 3</span></pre><p id="4ffe" class="pw-post-body-paragraph lk ll iw lm b ln lo kg lp lq lr kj ls lt lu lv lw lx ly lz ma mb mc md me mf ip bi translated">我准备数据作为测试库的输入。我把时间序列转换成数组。</p><pre class="kv kw kx ky gu od nf oe of aw og bi"><span id="5c5b" class="oh nh iw nf b gz oi oj l ok ol">import numpy as np</span><span id="a24e" class="oh nh iw nf b gz om oj l ok ol">y = np.array(ts.tolist())</span></pre><h1 id="0e6b" class="ng nh iw bd ni nj nk nl nm nn no np nq kl nr km ns ko nt kp nu kr nv ks nw nx bi translated">断裂</h1><p id="b13e" class="pw-post-body-paragraph lk ll iw lm b ln ny kg lp lq nz kj ls lt oa lv lw lx ob lz ma mb oc md me mf ip bi translated">第一个断点检测库是<a class="ae nb" href="https://pypi.org/project/ruptures/" rel="noopener ugc nofollow" target="_blank">breaks</a>，可以通过命令<code class="fe nc nd ne nf b">pip install rupture</code>安装。</p><p id="ab6c" class="pw-post-body-paragraph lk ll iw lm b ln lo kg lp lq lr kj ls lt lu lv lw lx ly lz ma mb mc md me mf ip bi translated">中断提供了六种不同的模式来检测断点:<code class="fe nc nd ne nf b">Dynp</code>、<code class="fe nc nd ne nf b">KernelCPD</code>、<code class="fe nc nd ne nf b">Pelt</code>、<code class="fe nc nd ne nf b">Binseg</code>、<code class="fe nc nd ne nf b">BottomUp</code>、<code class="fe nc nd ne nf b">Window</code>。每个模型都必须被构建、训练(通过<code class="fe nc nd ne nf b">fit()</code>函数)，然后用于预测。<code class="fe nc nd ne nf b">predict()</code>功能接收待识别断点的数量(减1)作为输入。在这个例子中，我利用了<code class="fe nc nd ne nf b">Dynp</code>模型，它对应于动态编程。</p><pre class="kv kw kx ky gu od nf oe of aw og bi"><span id="b017" class="oh nh iw nf b gz oi oj l ok ol">import ruptures as rpt</span><span id="cc48" class="oh nh iw nf b gz om oj l ok ol">model = rpt.Dynp(model="l1")<br/>model.fit(y)<br/>breaks = model.predict(n_bkps=n_breaks-1)</span></pre><p id="720d" class="pw-post-body-paragraph lk ll iw lm b ln lo kg lp lq lr kj ls lt lu lv lw lx ly lz ma mb mc md me mf ip bi translated">因为<code class="fe nc nd ne nf b">ruptures</code>返回发生结构变化的索引，所以我从原始时间序列<code class="fe nc nd ne nf b">ts</code>中检索日期。</p><pre class="kv kw kx ky gu od nf oe of aw og bi"><span id="5745" class="oh nh iw nf b gz oi oj l ok ol">breaks_rpt = []<br/>for i in breaks:<br/>    breaks_rpt.append(ts.index[i-1])<br/>breaks_rpt = pd.to_datetime(breaks_rpt)<br/>breaks_rpt</span></pre><p id="24b5" class="pw-post-body-paragraph lk ll iw lm b ln lo kg lp lq lr kj ls lt lu lv lw lx ly lz ma mb mc md me mf ip bi translated">它产生以下输出:</p><pre class="kv kw kx ky gu od nf oe of aw og bi"><span id="5b60" class="oh nh iw nf b gz oi oj l ok ol">DatetimeIndex(['2016-03-01', '2018-04-01', '2020-11-01'], dtype='datetime64[ns]', freq=None)</span></pre><p id="9c12" class="pw-post-body-paragraph lk ll iw lm b ln lo kg lp lq lr kj ls lt lu lv lw lx ly lz ma mb mc md me mf ip bi translated">现在我绘制结果。</p><pre class="kv kw kx ky gu od nf oe of aw og bi"><span id="21f3" class="oh nh iw nf b gz oi oj l ok ol">plt.plot(ts, label='data')<br/>plt.title('Audience')<br/>print_legend = True<br/>for i in breaks_rpt:<br/>    if print_legend:<br/>        plt.axvline(i, color='red',linestyle='dashed', label='breaks')<br/>        print_legend = False<br/>    else:<br/>        plt.axvline(i, color='red',linestyle='dashed')<br/>plt.grid()<br/>plt.legend()<br/>plt.show()</span></pre><figure class="kv kw kx ky gu kz gi gj paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="gi gj oo"><img src="../Images/3e395bdc1aaa50ef9c973b592879030d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6ofmM3IpahKIMTQ1JFe6AA.png"/></div></div><p class="lg lh gk gi gj li lj bd b be z dk translated">作者图片</p></figure><h1 id="7db0" class="ng nh iw bd ni nj nk nl nm nn no np nq kl nr km ns ko nt kp nu kr nv ks nw nx bi translated">詹克斯比</h1><p id="3fa1" class="pw-post-body-paragraph lk ll iw lm b ln ny kg lp lq nz kj ls lt oa lv lw lx ob lz ma mb oc md me mf ip bi translated">第二个断点检测库是<a class="ae nb" href="https://pypi.org/project/jenkspy/" rel="noopener ugc nofollow" target="_blank"> Jenkspy </a>，可以通过以下命令安装:<code class="fe nc nd ne nf b">pip install jenkspy</code>。这个库根据Fisher-Jenks算法计算数组中的自然断点。</p><p id="0cb6" class="pw-post-body-paragraph lk ll iw lm b ln lo kg lp lq lr kj ls lt lu lv lw lx ly lz ma mb mc md me mf ip bi translated">我导入库(<code class="fe nc nd ne nf b">import jenkspy</code>)，然后调用<code class="fe nc nd ne nf b">jenks_breaks()</code>函数，该函数接收值数组和要检测的断点数量作为输入。作为输出，该函数返回与所标识的中断相对应的值。提醒断裂，相反，返回断裂索引。</p><pre class="kv kw kx ky gu od nf oe of aw og bi"><span id="115b" class="oh nh iw nf b gz oi oj l ok ol">import jenkspy</span><span id="928c" class="oh nh iw nf b gz om oj l ok ol">breaks = jenkspy.jenks_breaks(y, nb_class=n_breaks-1)</span></pre><p id="cf55" class="pw-post-body-paragraph lk ll iw lm b ln lo kg lp lq lr kj ls lt lu lv lw lx ly lz ma mb mc md me mf ip bi translated">我通过循环遍历<code class="fe nc nd ne nf b">breaks</code>数组来计算breaks索引。</p><pre class="kv kw kx ky gu od nf oe of aw og bi"><span id="30fb" class="oh nh iw nf b gz oi oj l ok ol">breaks_jkp = []<br/>for v in breaks:<br/>    idx = ts.index[ts == v]<br/>    breaks_jkp.append(idx)<br/>breaks_jkp</span></pre><p id="ee32" class="pw-post-body-paragraph lk ll iw lm b ln lo kg lp lq lr kj ls lt lu lv lw lx ly lz ma mb mc md me mf ip bi translated">它产生以下输出:</p><pre class="kv kw kx ky gu od nf oe of aw og bi"><span id="fdac" class="oh nh iw nf b gz oi oj l ok ol">[DatetimeIndex(['2017-07-01'], dtype='datetime64[ns]', name='date', freq=None),<br/> DatetimeIndex(['2018-04-01'], dtype='datetime64[ns]', name='date', freq=None),<br/> DatetimeIndex(['2020-04-01'], dtype='datetime64[ns]', name='date', freq=None)]</span></pre><p id="12bc" class="pw-post-body-paragraph lk ll iw lm b ln lo kg lp lq lr kj ls lt lu lv lw lx ly lz ma mb mc md me mf ip bi translated">我画出结果。</p><pre class="kv kw kx ky gu od nf oe of aw og bi"><span id="cbd8" class="oh nh iw nf b gz oi oj l ok ol">plt.plot(ts, label='data')<br/>plt.title('Audience')<br/>print_legend = True<br/>for i in breaks_jkp:<br/>    if print_legend:<br/>        plt.axvline(i, color='red',linestyle='dashed', label='breaks')<br/>        print_legend = False<br/>    else:<br/>        plt.axvline(i, color='red',linestyle='dashed')<br/>plt.grid()<br/>plt.legend()<br/>plt.show()</span></pre><figure class="kv kw kx ky gu kz gi gj paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="gi gj op"><img src="../Images/81eec59c418c996b9e57b4937e246eb9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JJHWFQeHMzKhur2fx8zkAQ.png"/></div></div><p class="lg lh gk gi gj li lj bd b be z dk translated">作者图片</p></figure><h1 id="8050" class="ng nh iw bd ni nj nk nl nm nn no np nq kl nr km ns ko nt kp nu kr nv ks nw nx bi translated">比较结果</h1><p id="069c" class="pw-post-body-paragraph lk ll iw lm b ln ny kg lp lq nz kj ls lt oa lv lw lx ob lz ma mb oc md me mf ip bi translated">最后，我比较了两个库产生的结果。我进行了视觉对比。</p><p id="ee8b" class="pw-post-body-paragraph lk ll iw lm b ln lo kg lp lq lr kj ls lt lu lv lw lx ly lz ma mb mc md me mf ip bi translated">我计算了理想情况，两种算法产生相同的结果。</p><pre class="kv kw kx ky gu od nf oe of aw og bi"><span id="e711" class="oh nh iw nf b gz oi oj l ok ol">x_ideal = ts.index<br/>y_ideal = x_ideal</span></pre><p id="cfd2" class="pw-post-body-paragraph lk ll iw lm b ln lo kg lp lq lr kj ls lt lu lv lw lx ly lz ma mb mc md me mf ip bi translated">我通过散点图来比较这两种算法。理想情况用红色标出。我注意到只有一个普通的断裂(穿过理想情况的那个)。第一个断点很不一样，第三个断点很像。</p><pre class="kv kw kx ky gu od nf oe of aw og bi"><span id="edac" class="oh nh iw nf b gz oi oj l ok ol">plt.figure(figsize=(5, 5), dpi=80)<br/>plt.scatter(breaks_rpt,breaks_jkp)<br/>plt.xlabel('Ruptures')<br/>plt.ylabel('Jenkspy')<br/>plt.title('Jenskpy VS Ruptures')<br/>plt.xlim(ts.index[0], ts.index[len(ts)-1])<br/>plt.ylim(ts.index[0], ts.index[len(ts)-1])<br/>plt.plot(x_ideal,y_ideal, color='r', linestyle='dashed')<br/>plt.grid()<br/>plt.show()</span></pre><figure class="kv kw kx ky gu kz gi gj paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="gi gj oq"><img src="../Images/40d289a1a7c6ef3c63658146c11d6e65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Jn7URononQxa3L9glVEY6Q.png"/></div></div><p class="lg lh gk gi gj li lj bd b be z dk translated">作者图片</p></figure><h1 id="3349" class="ng nh iw bd ni nj nk nl nm nn no np nq kl nr km ns ko nt kp nu kr nv ks nw nx bi translated">摘要</h1><p id="6a16" class="pw-post-body-paragraph lk ll iw lm b ln ny kg lp lq nz kj ls lt oa lv lw lx ob lz ma mb oc md me mf ip bi translated">在本教程中，我用两个库说明了如何在Python中检测断点:<code class="fe nc nd ne nf b">ruptures</code>和<code class="fe nc nd ne nf b">jenkspy</code>。这两个库产生不同的输出。将输出与可视断点进行比较，在这个特定示例中，Jenkspy算法似乎优于动态编程。</p><p id="2369" class="pw-post-body-paragraph lk ll iw lm b ln lo kg lp lq lr kj ls lt lu lv lw lx ly lz ma mb mc md me mf ip bi translated">如果你想了解我的研究和其他活动的最新情况，你可以在<a class="ae nb" href="https://twitter.com/alod83" rel="noopener ugc nofollow" target="_blank"> Twitter </a>、<a class="ae nb" href="https://www.youtube.com/channel/UC4O8-FtQqGIsgDW_ytXIWOg?view_as=subscriber" rel="noopener ugc nofollow" target="_blank"> Youtube </a>和<a class="ae nb" href="https://github.com/alod83" rel="noopener ugc nofollow" target="_blank"> Github </a>上关注我。</p><h1 id="83be" class="ng nh iw bd ni nj nk nl nm nn no np nq kl nr km ns ko nt kp nu kr nv ks nw nx bi translated">相关文章</h1><div class="or os gq gs ot ou"><a rel="noopener follow" target="_blank" href="/how-to-detect-outliers-with-python-pyod-aa7147359e4b"><div class="ov ab fp"><div class="ow ab ox cl cj oy"><h2 class="bd jg gz z fq oz fs ft pa fv fx jf bi translated">如何用Python pyod检测异常值</h2><div class="pb l"><h3 class="bd b gz z fq oz fs ft pa fv fx dk translated">关于pyod库使用的快速教程。</h3></div><div class="pc l"><p class="bd b dl z fq oz fs ft pa fv fx dk translated">towardsdatascience.com</p></div></div><div class="pd l"><div class="pe l pf pg ph pd pi le ou"/></div></div></a></div><div class="or os gq gs ot ou"><a rel="noopener follow" target="_blank" href="/4-different-approaches-for-time-series-analysis-7e2364fadcb9"><div class="ov ab fp"><div class="ow ab ox cl cj oy"><h2 class="bd jg gz z fq oz fs ft pa fv fx jf bi translated">4种不同的时间序列分析方法</h2><div class="pc l"><p class="bd b dl z fq oz fs ft pa fv fx dk translated">towardsdatascience.com</p></div></div><div class="pd l"><div class="pj l pf pg ph pd pi le ou"/></div></div></a></div><div class="or os gq gs ot ou"><a rel="noopener follow" target="_blank" href="/a-complete-data-analysis-workflow-in-python-and-scikit-learn-9a77f7c283d3"><div class="ov ab fp"><div class="ow ab ox cl cj oy"><h2 class="bd jg gz z fq oz fs ft pa fv fx jf bi translated">Python和scikit中的完整数据分析工作流程-学习</h2><div class="pc l"><p class="bd b dl z fq oz fs ft pa fv fx dk translated">towardsdatascience.com</p></div></div><div class="pd l"><div class="pk l pf pg ph pd pi le ou"/></div></div></a></div></div></div>    
</body>
</html>