<html>
<head>
<title>Affimer Proteins: Next Generation Sequencing Data Analysis (Part 2)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">亲和蛋白质:下一代测序数据分析(第二部分)</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/affimer-proteins-next-generation-sequencing-data-analysis-part-2-8ebc0e90f460?source=collection_archive---------32-----------------------#2021-07-20">https://towardsdatascience.com/affimer-proteins-next-generation-sequencing-data-analysis-part-2-8ebc0e90f460?source=collection_archive---------32-----------------------#2021-07-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/feebf09380700188fa167bdfdd87f9b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XO919YVgQ2UmquivvgCpjA.jpeg"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">路易斯·里德在<a class="ae jd" href="https://unsplash.com/s/photos/science?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><h2 id="ee1e" class="je jf jg bd b dl jh ji jj jk jl jm dk jn translated" aria-label="kicker paragraph">亲和蛋白质类</h2><div class=""/><div class=""><h2 id="66ee" class="pw-subtitle-paragraph km jp jg bd b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dk translated"><em class="le">氨基酸翻译和寻找亲和环区</em></h2></div><p id="50c1" class="pw-post-body-paragraph lf lg jg lh b li lj kq lk ll lm kt ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">在第1部分中，我们看了什么是亲和分子，并开始看与DNA序列相关的R中的基本数据分析。接下来，我们将更深入地研究数据，搜索特定的亲和分子环，并查看不同的“阅读框架”如何影响特定序列的搜索。</p><h1 id="09b6" class="mb mc jg bd md me mf mg mh mi mj mk ml kv mm kw mn ky mo kz mp lb mq lc mr ms bi translated">DNA -&gt;氨基酸</h1><p id="e0e2" class="pw-post-body-paragraph lf lg jg lh b li mt kq lk ll mu kt ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">最终，我们实际上对亲和结合物的DNA序列并不感兴趣。相反，我们感兴趣的是氨基酸(AA)序列。其原因是，正是氨基酸形成了蛋白质，进而产生了亲和分子(特别是环区)的物理特征(和结合特性)。</p><p id="d5f2" class="pw-post-body-paragraph lf lg jg lh b li lj kq lk ll lm kt ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">DNA到AA <a class="ae jd" href="https://en.wikipedia.org/wiki/Translation_(biology)" rel="noopener ugc nofollow" target="_blank"> <strong class="lh jq"> <em class="my">翻译</em> </strong> </a>的物理过程是从一个叫做<a class="ae jd" href="https://en.wikipedia.org/wiki/Transcription_(biology)" rel="noopener ugc nofollow" target="_blank"> <strong class="lh jq"> <em class="my">转录</em> </strong> </a>的过程开始的。首先，一种叫做<a class="ae jd" href="https://en.wikipedia.org/wiki/RNA_polymerase" rel="noopener ugc nofollow" target="_blank"> <strong class="lh jq"> <em class="my"> RNA聚合酶</em> </strong> </a>的酶解开DNA分子的双螺旋结构，露出DNA碱基。接下来，该酶创建了一个互补的单链分子，称为<a class="ae jd" href="https://en.wikipedia.org/wiki/Messenger_RNA" rel="noopener ugc nofollow" target="_blank"><strong class="lh jq"><em class="my">messenger-RNA</em></strong></a>(mRNA)，这意味着DNA链上的每个C都变成了mRNA链上的G，每个G都变成了C，每个T变成了A，每个A变成了A，每个A变成了U(注意，U取代了DNA中的T)。</p><p id="8ed2" class="pw-post-body-paragraph lf lg jg lh b li lj kq lk ll lm kt ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">进一步的步骤使这种“前mRNA”成熟为mRNA的最终形式，然后mRNA序列被称为<a class="ae jd" href="https://en.wikipedia.org/wiki/Ribosome" rel="noopener ugc nofollow" target="_blank"> <strong class="lh jq"> <em class="my">核糖体</em> </strong> </a>的结构读取。这种阅读过程是通过一次查看3个碱基(称为<strong class="lh jq">密码子</strong>)来进行的，每个碱基要么编码一个氨基酸，要么告诉核糖体停止(称为终止密码子)。氨基酸链继续构建，直到到达终止密码子，由此产生的分子链就是最终生成的蛋白质。</p><p id="e64e" class="pw-post-body-paragraph lf lg jg lh b li lj kq lk ll lm kt ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">令人难以置信的是，取决于氨基酸转换是从第一、第二还是第三个碱基开始，你最终可以得到完全不同的3碱基集合，因此完全不同的氨基酸和因此完全不同的蛋白质。这些被称为<strong class="lh jq">阅读框架</strong>，我们稍后将回到它们。</p><p id="d87a" class="pw-post-body-paragraph lf lg jg lh b li lj kq lk ll lm kt ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">下面是密码子到氨基酸转换的示意图(从中间开始向外移动，选择3个氨基酸)。请注意，不同的DNA组合可以导致相同的氨基酸，DNA -&gt; AA翻译是直接的，但AA -&gt; DNA翻译是不可能的(因为没有办法知道哪个DNA序列在给定的AA后面)。这对数据管理有影响，即AA序列和它们的潜在DNA序列必须总是以某种方式保留和连接。</p><figure class="na nb nc nd gt is gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/a184db40eaaffc86461acd5f938b55a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1218/format:webp/0*0gulG4iNTUhO-eBW.png"/></div><p class="iz ja gj gh gi jb jc bd b be z dk translated"><a class="ae jd" href="https://en.wikipedia.org/wiki/DNA_and_RNA_codon_tables" rel="noopener ugc nofollow" target="_blank">图像参考</a></p></figure><p id="8560" class="pw-post-body-paragraph lf lg jg lh b li lj kq lk ll lm kt ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">现在让我们使用<strong class="lh jq">翻译</strong>函数将DNA翻译成AA。这个函数应用于每个DNA序列，然后数据被组合成一个data frame(R中常用的2D数据结构)，</p><pre class="na nb nc nd gt ne nf ng nh aw ni bi"><span id="c331" class="nj mc jg nf b gy nk nl l nm nn"><em class="my">#AA translation</em><br/>aa_1 = translate(dna_1) <em class="my">#Translate</em><br/>aa_1_dt = as.data.frame(aa_1) <em class="my">#Add to a dataframe</em><br/> <br/>aa_2 = translate(dna_2) <em class="my">#Translate</em><br/>aa_2_dt = as.data.frame(aa_2) <em class="my">#Add to a dataframe</em><br/> <br/><em class="my">#Create a label for the direction,</em><br/>aa_1_dt$read_direction = ‘F’<br/>aa_2_dt$read_direction = ‘R’<br/> <br/><em class="my">#Combine the two dataframes,</em><br/>aa_all = rbind(aa_1_dt, aa_2_dt)<br/>colnames(aa_all) = c(‘amino_acid_seq’, ‘read_direction’)</span></pre><p id="28b1" class="pw-post-body-paragraph lf lg jg lh b li lj kq lk ll lm kt ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">这是我们现在拥有的(前6项)，</p><pre class="na nb nc nd gt ne nf ng nh aw ni bi"><span id="9ecc" class="nj mc jg nf b gy nk nl l nm nn">head(aa_all)</span><span id="49af" class="nj mc jg nf b gy no nl l nm nn">## amino_acid_seq                            read_direction<br/> ## 1 YGKLEAVQYKTQVLANINETYNINESTNYYIKVRAGDNKYMHLKVFNGPFI F<br/> ## 2 YGKLEAVQYKTQVLANINETYNINESTNYYIKVRAGDNKYMHLKVFNGPFI F<br/> ## 3 YGKLEAVQYKTQVLAEIGHTYTHREESTNYYIKVRAGDNKYMHLKVFNGPT F<br/> ## 4 YGKLEAVQYKTQVLATWENTYSTNYYIKVRAGDNKYMHLKVFNGPFIFTYN F<br/> ## 5 YGKLEAVQYKTQVLANINETYNINESTNYYIKVRAGDNKYMHLKVFNGPTH F<br/> ## 6 YGKLEAVQYKTQVLATWENTYSTNYYIKVRAGDNKYMHLKVFNGPNINETY F</span></pre><p id="d47d" class="pw-post-body-paragraph lf lg jg lh b li lj kq lk ll lm kt ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我们还可以看到一些相反的顺序(最后6项)，</p><pre class="na nb nc nd gt ne nf ng nh aw ni bi"><span id="c5cc" class="nj mc jg nf b gy nk nl l nm nn">tail(aa_all)</span><span id="7a60" class="nj mc jg nf b gy no nl l nm nn">## amino_acid_seq                              read_direction<br/> ## 995 VESTNYYIKVRAGDNKYMHLKVFNGPTHIRTYFIVEADRVLTGYQVDKNKD R<br/> ## 996 ESTNYYIKVRAGDNKYMHLKVFNGPNINETYSEVENADRVLTGYQVDKNKD R<br/> ## 997 ESTNYYIKVRAGDNKYMHLKVFNGPNINETYSEVENADRVLTGYQVDKNKD R<br/> ## 998 ESTNYYIKVRAGDNKYMHLKVFNGPNINETYSEVENADRVLTGYQVDKNKD R<br/> ## 999 VESTNYYIKVRAGDNKYMHLKVFNGPTHIRTYFIVEADRVLTGYQVDKNKD R<br/> ## 1000 ESTNYYIKVRAGDNKYMHLKVFNGPNINETYSEVENADRVLTGYQVDKNKD R</span></pre><p id="2a8c" class="pw-post-body-paragraph lf lg jg lh b li lj kq lk ll lm kt ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我们的DNA序列现在是AA序列，我们已经将它们标记为“正向”或“反向”(我们稍后会用到)。</p><h1 id="2d8c" class="mb mc jg bd md me mf mg mh mi mj mk ml kv mm kw mn ky mo kz mp lb mq lc mr ms bi translated">环路搜索</h1><p id="f943" class="pw-post-body-paragraph lf lg jg lh b li mt kq lk ll mu kt ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">下一个问题是，你如何在这些长长的氨基酸序列中找到两个环区？答案是每个亲和分子(从进入噬菌体的起始DNA开始)都编码了特定的短序列，就像环的路标一样。在两个循环的每一个之前和之后有一个，即总共4个。让我们在数据帧中定义这些“环垫”,</p><pre class="na nb nc nd gt ne nf ng nh aw ni bi"><span id="818c" class="nj mc jg nf b gy nk nl l nm nn">loop_pads = data.frame(type = ‘demo’,<br/>                       l2_before =’KTQVLA’,<br/>                       l2_after = ‘STNYYI’,<br/>                       l4_before = ‘KVFNGP’,<br/>                       l4_after = ‘ADRVLT’)<br/> <br/>loop_pads</span><span id="5810" class="nj mc jg nf b gy no nl l nm nn">## type l2_before l2_after l4_before l4_after<br/>## 1 demo KTQVLA STNYYI KVFNGP ADRVLT</span></pre><p id="54e6" class="pw-post-body-paragraph lf lg jg lh b li lj kq lk ll lm kt ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">(请注意，我将这些称为“演示”，因为我们正在查看演示数据集)。</p><p id="0928" class="pw-post-body-paragraph lf lg jg lh b li lj kq lk ll lm kt ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">让我们搜索一下，看看能否找到第一个循环垫。下面我们将搜索模式设置为“循环2之前”循环垫，主题为数据帧中的第一个序列。</p><pre class="na nb nc nd gt ne nf ng nh aw ni bi"><span id="19c5" class="nj mc jg nf b gy nk nl l nm nn">matchPattern(pattern = loop_pads$l2_before, <br/>             subject = aa_all$amino_acid_seq[1])</span><span id="410d" class="nj mc jg nf b gy no nl l nm nn">## Views on a 51-letter BString subject<br/>## subject: YGKLEAVQYKTQVLANINETYNINESTNYYIKVRAGDNKYMHLKVFNGPFI<br/>## views:<br/>## start end width<br/>## [1] 10 15 6 [KTQVLA]</span></pre><p id="5a3b" class="pw-post-body-paragraph lf lg jg lh b li lj kq lk ll lm kt ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">它找到了，从位置10开始，到位置15结束。“后循环2”循环垫呢？</p><pre class="na nb nc nd gt ne nf ng nh aw ni bi"><span id="7cc4" class="nj mc jg nf b gy nk nl l nm nn">matchPattern(pattern = loop_pads$l2_after, <br/>             subject = aa_all$amino_acid_seq[1])</span><span id="56bc" class="nj mc jg nf b gy no nl l nm nn">## Views on a 51-letter BString subject<br/>## subject: YGKLEAVQYKTQVLANINETYNINESTNYYIKVRAGDNKYMHLKVFNGPFI<br/>## views:<br/>## start end width<br/>## [1] 26 31 6 [STNYYI]</span></pre><p id="05dd" class="pw-post-body-paragraph lf lg jg lh b li lj kq lk ll lm kt ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">又找到了。</p><p id="c107" class="pw-post-body-paragraph lf lg jg lh b li lj kq lk ll lm kt ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我们现在知道“环2”区域在位置16(第一个环填充结束后的一个)和位置25(第二个环填充开始前的一个)之间，</p><figure class="na nb nc nd gt is gh gi paragraph-image"><div class="gh gi np"><img src="../Images/19ce6b7050ddf3062672f003052bf43c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1308/format:webp/1*p4vo769jcHbz0tIztNw0pw.png"/></div></figure><p id="921d" class="pw-post-body-paragraph lf lg jg lh b li lj kq lk ll lm kt ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">然后很容易提取这个循环，使用<strong class="lh jq"> substr </strong>函数并指定开始和结束位置，</p><pre class="na nb nc nd gt ne nf ng nh aw ni bi"><span id="25ad" class="nj mc jg nf b gy nk nl l nm nn">substr(aa_all$amino_acid_seq[1], 16, 25)</span><span id="dce0" class="nj mc jg nf b gy no nl l nm nn">## [1] “NINETYNINE”</span></pre><p id="e7a3" class="pw-post-body-paragraph lf lg jg lh b li lj kq lk ll lm kt ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">如你所见，我们找到了单词“999”。这显然是我们的演示数据的产物，但在真实的数据集中，这将是我们的“环2”氨基酸序列。</p><h1 id="e088" class="mb mc jg bd md me mf mg mh mi mj mk ml kv mm kw mn ky mo kz mp lb mq lc mr ms bi translated">阅读框架</h1><p id="c162" class="pw-post-body-paragraph lf lg jg lh b li mt kq lk ll mu kt ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">如上所述，DNA使用三个核苷酸(密码子)来编码氨基酸。其结果是转录可以从第一、第二或第三个核苷酸开始，导致三个所谓的<strong class="lh jq">阅读框</strong>。至关重要的是，每个阅读框架将导致完全不同的氨基酸被翻译。</p><p id="0c8e" class="pw-post-body-paragraph lf lg jg lh b li lj kq lk ll lm kt ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">起始密码子，或告诉RNA聚合酶从哪里开始的密码子，决定了从哪个密码子开始，导致了所谓的<strong class="lh jq">开放框架</strong>，或导致翻译成氨基酸和蛋白质的阅读框架。有时，插入或缺失会导致所谓的“移码突变”，这是许多严重疾病的原因。</p><p id="ada2" class="pw-post-body-paragraph lf lg jg lh b li lj kq lk ll lm kt ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">在我们的数据中，重要的是确定哪个阅读框编码所需的亲和蛋白序列。让我们来看看实际情况。首先，我们将创建一个随机的DNA序列，</p><pre class="na nb nc nd gt ne nf ng nh aw ni bi"><span id="e531" class="nj mc jg nf b gy nk nl l nm nn">dna_eg = DNAString(‘TGATATACGGATCGATGCATTCAGGACGCTCTGCTGGATAAGAACACCCTGTGGAAAACCATGTACTACCTGACC’)</span><span id="5143" class="nj mc jg nf b gy no nl l nm nn">dna_eg</span><span id="c430" class="nj mc jg nf b gy no nl l nm nn">## 75-letter DNAString object<br/>## seq: TGATATACGGATCGATGCATTCAGGACGCTCTGCTGGATAAGAACACCCTGTGGAAAACCATGTACTACCTGACC</span></pre><p id="5df1" class="pw-post-body-paragraph lf lg jg lh b li lj kq lk ll lm kt ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">接下来，我们会像之前一样把它翻译成氨基酸，</p><pre class="na nb nc nd gt ne nf ng nh aw ni bi"><span id="eee0" class="nj mc jg nf b gy nk nl l nm nn">aa_eg_frame1 = translate(dna_eg) <em class="my">#Translate, frame 1</em><br/>aa_eg_frame1</span><span id="7545" class="nj mc jg nf b gy no nl l nm nn">## 25-letter AAString object<br/>## seq: *YTDRCIQDALLDKNTLWKTMYYLT</span></pre><p id="6b4d" class="pw-post-body-paragraph lf lg jg lh b li lj kq lk ll lm kt ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我们从75个字母的DNA序列到25个字母的AA序列(如预期的那样)。现在，假设我们的循环垫是序列“ENHV”。下面我们将在我们的AA序列中搜索它，</p><pre class="na nb nc nd gt ne nf ng nh aw ni bi"><span id="43f0" class="nj mc jg nf b gy nk nl l nm nn">matchPattern(pattern = ‘ENHV’, <br/>             subject = as.character(aa_eg_frame1))</span><span id="4b12" class="nj mc jg nf b gy no nl l nm nn">## Views on a 25-letter BString subject<br/>## subject: *YTDRCIQDALLDKNTLWKTMYYLT<br/>## views: NONE</span></pre><p id="96fd" class="pw-post-body-paragraph lf lg jg lh b li lj kq lk ll lm kt ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">什么也没找到。接下来，让我们去掉第一个核苷酸，重新翻译，</p><pre class="na nb nc nd gt ne nf ng nh aw ni bi"><span id="b575" class="nj mc jg nf b gy nk nl l nm nn"><em class="my">#trim first base from sequence<br/></em>aa_eg_frame2 &lt;- DNAStringSet(dna_eg, start=2)</span><span id="0a9c" class="nj mc jg nf b gy no nl l nm nn"><em class="my">#Translate, frame 1<br/></em>aa_eg_frame2 = translate(aa_eg_frame2)</span><span id="82c0" class="nj mc jg nf b gy no nl l nm nn">## Warning in .Call2(“DNAStringSet_translate”, x, skip_code,<br/>## dna_codes[codon_alphabet], : last 2 bases were ignored</span><span id="3525" class="nj mc jg nf b gy no nl l nm nn">aa_eg_frame2</span><span id="8088" class="nj mc jg nf b gy no nl l nm nn">## AAStringSet object of length 1:<br/>## width seq<br/>## [1] 24 DIRIDAFRTLCWIRTPCGKPCTT*</span></pre><p id="53f8" class="pw-post-body-paragraph lf lg jg lh b li lj kq lk ll lm kt ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我们现在得到了一个完全不同的氨基酸序列。注意，translate函数也给了我们一个警告，指出最后两个碱基被忽略了。这是有意义的，因为我们在开始时去掉了一个碱基，不再有3的倍数的DNA序列长度。接下来我们将再次搜索，</p><pre class="na nb nc nd gt ne nf ng nh aw ni bi"><span id="bd2e" class="nj mc jg nf b gy nk nl l nm nn">matchPattern(pattern = ‘ENHV’, <br/>             subject = as.character(aa_eg_frame2))</span><span id="02f9" class="nj mc jg nf b gy no nl l nm nn">## Views on a 24-letter BString subject<br/>## subject: DIRIDAFRTLCWIRTPCGKPCTT*<br/>## views: NONE</span></pre><p id="fe3a" class="pw-post-body-paragraph lf lg jg lh b li lj kq lk ll lm kt ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">还是一无所获。最后，我们会去掉最初的两个碱基，然后重做所有的东西，</p><pre class="na nb nc nd gt ne nf ng nh aw ni bi"><span id="f82c" class="nj mc jg nf b gy nk nl l nm nn"><em class="my">#trim first base from sequence<br/></em>aa_eg_frame3 &lt;- DNAStringSet(dna_eg, start=3)</span><span id="2e65" class="nj mc jg nf b gy no nl l nm nn"><em class="my">#Translate, frame <br/>1</em>aa_eg_frame3 = translate(aa_eg_frame3)</span><span id="56fa" class="nj mc jg nf b gy no nl l nm nn">## Warning in .Call2(“DNAStringSet_translate”, x, skip_code,<br/>## dna_codes[codon_alphabet], : last base was ignored</span><span id="748a" class="nj mc jg nf b gy no nl l nm nn">aa_eg_frame3</span><span id="b7e2" class="nj mc jg nf b gy no nl l nm nn">## AAStringSet object of length 1:<br/>## width seq<br/>## [1] 24 IYGSMHSGRSAG*EHPVENHVLPD</span></pre><p id="c505" class="pw-post-body-paragraph lf lg jg lh b li lj kq lk ll lm kt ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">现在我们看到一个关于单个拖尾基座的警告。最后，我们再次搜索，</p><pre class="na nb nc nd gt ne nf ng nh aw ni bi"><span id="3522" class="nj mc jg nf b gy nk nl l nm nn">matchPattern(pattern = ‘ENHV’, <br/>             subject = as.character(aa_eg_frame3))</span><span id="8131" class="nj mc jg nf b gy no nl l nm nn">## Views on a 24-letter BString subject<br/>## subject: IYGSMHSGRSAG*EHPVENHVLPD<br/>## views:<br/>## start end width<br/>## [1] 18 21 4 [ENHV]</span></pre><p id="d3b8" class="pw-post-body-paragraph lf lg jg lh b li lj kq lk ll lm kt ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">这一次序列找到了。换句话说，亲和分子序列在第三个阅读框<em class="my">中编码。这突出了一个事实，即当从DNA序列开始搜索氨基酸序列时，阅读框架是绝对关键的。</em></p><h1 id="edc4" class="mb mc jg bd md me mf mg mh mi mj mk ml kv mm kw mn ky mo kz mp lb mq lc mr ms bi translated">摘要</h1><p id="d46c" class="pw-post-body-paragraph lf lg jg lh b li mt kq lk ll mu kt ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">在这篇文章中，我们进一步分析了基本数据，寻找循环，并看到了使用正确阅读框架的重要性。在第三篇<a class="ae jd" rel="noopener" target="_blank" href="/affimer-proteins-next-generation-sequencing-data-analysis-part-3-90b4304413b5">也是最后一篇</a>文章中，我们将看到“独特的分子标识符”如何帮助消除NGS读数错误，Affimer环频率如何在几轮“摇摄”中发生变化，并以Affimer蛋白质应用为结尾。</p></div></div>    
</body>
</html>