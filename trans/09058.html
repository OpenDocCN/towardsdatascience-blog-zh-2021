<html>
<head>
<title>Artificial Neural Network Using PySpark</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用PySpark的人工神经网络</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/artificial-neural-network-using-pyspark-324cf47e8d0a?source=collection_archive---------15-----------------------#2021-08-21">https://towardsdatascience.com/artificial-neural-network-using-pyspark-324cf47e8d0a?source=collection_archive---------15-----------------------#2021-08-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="232e" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用PySpark实现用于二进制类预测用例的神经网络</h2></div><p id="e566" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">简介</strong> : <br/>这是Pyspark博客系列的延续。之前我已经分享了使用PySpark实现一个基本的<a class="ae lb" rel="noopener" target="_blank" href="/machine-learning-linear-regression-using-pyspark-9d5d5c772b42">线性回归</a>。在这篇博客中，我将展示另一个有趣的神经网络实现，它使用PySpark作为二进制类预测用例。这篇博客不会有很多预处理步骤，但是会给你一个实现分布式环境的想法，特别是当你在数据块中的集群中运行代码的时候。对于Databricks环境，如果您想利用TensorFlow，<a class="ae lb" href="https://docs.databricks.com/applications/machine-learning/train-model/distributed-training/horovod-runner.html" rel="noopener ugc nofollow" target="_blank"> horovod </a>对此太方便了，或者您也可以参考<a class="ae lb" href="https://www.tensorflow.org/guide/distributed_training" rel="noopener ugc nofollow" target="_blank">分布式tensorflow </a>。但是如果你在业界工作的时候在GPU集群上面使用Horovod还是推荐的。然而，我将使这篇博客过于精确，以至于读者无法理解pyspark的神经网络实现方式。</p><h1 id="6e4e" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">欢迎，让我们深入主题。</h1><p id="d5c8" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">我拍了一张<a class="ae lb" href="https://github.com/someshkr/MultiLyerPerceptron-/blob/main/data_banknote_authentication.csv" rel="noopener ugc nofollow" target="_blank">钞票认证数据集</a>。数据集中有5列，如f1、F2、F3、F4作为特征，Class作为标签。</p><h2 id="4347" class="lz ld iq bd le ma mb dn li mc md dp lm ko me mf lo ks mg mh lq kw mi mj ls mk bi translated">多层感知器分类器:</h2><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi ml"><img src="../Images/d4ad0595d6c0e41d33e9f63fc52fd597.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0t-yjUci3dMx9zfIlVorhQ.png"/></div></div><p class="mx my gj gh gi mz na bd b be z dk translated"><a class="ae lb" href="https://media.istockphoto.com/vectors/neural-network-model-with-thin-synapses-between-neurons-vector-id1156059931?k=6&amp;m=1156059931&amp;s=612x612&amp;w=0&amp;h=rRq6-bwqo1B2tpudH6YcG28sMYTyu8bUEZ6-PiZ4Ypo=" rel="noopener ugc nofollow" target="_blank"> media.istockphoto </a></p></figure><p id="656d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了在PySpark中实现一个神经网络，我们可以使用<a class="ae lb" href="https://spark.apache.org/docs/latest/ml-classification-regression.html#multilayer-perceptron-classifier" rel="noopener ugc nofollow" target="_blank">多层感知器分类器。</a>超级好用，从<strong class="kh ir"> pyspark.ml.classification导入即可</strong>基于<a class="ae lb" href="https://en.wikipedia.org/wiki/Feedforward_neural_network" rel="noopener ugc nofollow" target="_blank">前馈人工神经网络</a>。输入层中的节点表示输入数据。其余节点通过输入与节点权重<code class="fe nb nc nd ne b"><strong class="kh ir">w</strong></code>和偏差<code class="fe nb nc nd ne b"><strong class="kh ir">b</strong></code> <strong class="kh ir"> </strong>的线性组合以及应用激活函数，将输入映射到输出。这可以表示为:</p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/b99e3042986cf6667d29d5254c0ee2de.png" data-original-src="https://miro.medium.com/v2/resize:fit:818/format:webp/1*XbqmcXHsqYycgYnjAh_tug.png"/></div><p class="mx my gj gh gi mz na bd b be z dk translated"><a class="ae lb" href="https://spark.apache.org/docs/latest/ml-classification-regression.html#multilayer-perceptron-classifier" rel="noopener ugc nofollow" target="_blank">具有K+1层的MLPC的矩阵形式</a></p></figure><h2 id="90f0" class="lz ld iq bd le ma mb dn li mc md dp lm ko me mf lo ks mg mh lq kw mi mj ls mk bi translated">特点:</h2><ol class=""><li id="b516" class="ng nh iq kh b ki lu kl lv ko ni ks nj kw nk la nl nm nn no bi translated">它基于多层感知器。</li></ol><p id="dafa" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">2.Sigmoid激活函数用于每一层，Softmax激活函数用于输出层。</p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi np"><img src="../Images/b66288a1edf43a8b5d9b13ad2e0896e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Fp_6ZSmHQoxYUNJYOKu9cA.png"/></div></div><p class="mx my gj gh gi mz na bd b be z dk translated"><a class="ae lb" href="https://spark.apache.org/docs/latest/ml-classification-regression.html#multilayer-perceptron-classifier" rel="noopener ugc nofollow" target="_blank"> N表示类别的数量</a></p></figure><p id="b36b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">3.它使用逻辑损失函数进行优化，使用求解器L-BFGS进行优化。但是你可以另一个像<strong class="kh ir"> <em class="nq"> gd这样的求解器。</em> </strong></p><blockquote class="nr ns nt"><p id="1675" class="kf kg nq kh b ki kj jr kk kl km ju kn nu kp kq kr nv kt ku kv nw kx ky kz la ij bi translated">gd代表梯度下降算法。</p><p id="aa4b" class="kf kg nq kh b ki kj jr kk kl km ju kn nu kp kq kr nv kt ku kv nw kx ky kz la ij bi translated">l-bdgs代表有限内存Broyden–Fletcher–gold farb–Shanno算法</p></blockquote><p id="5c45" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">缺点:</p><p id="5de1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当您使用Tensorflow或PyTorch定义ann时，它缺少定制功能。</p><p id="bda7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae lb" href="https://scikit-learn.org/stable/modules/generated/sklearn.neural_network.MLPClassifier.html" rel="noopener ugc nofollow" target="_blank">阅读更多关于scikit learn实施的信息。</a></p><p id="3b5f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">实施</strong></p><p id="c4a6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">加载数据集:</p><pre class="mm mn mo mp gt nx ne ny nz aw oa bi"><span id="f026" class="lz ld iq ne b gy ob oc l od oe">dataset = spark.read.csv(“data_banknote_authentication.csv”,header=True)</span></pre><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div class="gh gi of"><img src="../Images/61bb461e0a8866219eba160ed2a15c9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:984/format:webp/1*BnBzyevxwbgcTubqJqYNJQ.png"/></div><p class="mx my gj gh gi mz na bd b be z dk translated">我的电脑</p></figure><p id="1554" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通常，当您使用pyspark导入数据时，如果模式不是预定义的，它将采用string类型。现在让我们将列类型转换为double类型。</p><pre class="mm mn mo mp gt nx ne ny nz aw oa bi"><span id="0e9b" class="lz ld iq ne b gy ob oc l od oe">for col in dataset.columns:<br/>    dataset = dataset.withColumn(col,dataset[col].cast('double'))</span></pre><p id="8d38" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有几个空值。所以让我们用平均值来估算。</p><pre class="mm mn mo mp gt nx ne ny nz aw oa bi"><span id="a654" class="lz ld iq ne b gy ob oc l od oe">imputed_col = ['f_{}'.format(i+1) for i in range(len(input_cols))]</span><span id="d5ea" class="lz ld iq ne b gy og oc l od oe">model = Imputer(strategy='mean',missingValue=None,inputCols=input_cols,outputCols=imputed_col).fit(dataset)<br/>impute_data = model.transform(dataset)</span></pre><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi oh"><img src="../Images/4859a0e63e6705ae77a3929fffeb118f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dydKeAKx3HNPUfo9iMmT7A.png"/></div></div><p class="mx my gj gh gi mz na bd b be z dk translated">我的电脑</p></figure><p id="2057" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在PySpark中，在将数据输入模型之前，我们用向量来表示数据。想法是以矩阵格式表示数据，并在0，1之间缩放数据。</p><pre class="mm mn mo mp gt nx ne ny nz aw oa bi"><span id="0f7a" class="lz ld iq ne b gy ob oc l od oe">assemble = VectorAssembler(inputCols=imputed_col, outputCol='assembled_features', handleInvalid='error')<br/>a_data = assemble.transform(impute_data)</span><span id="439e" class="lz ld iq ne b gy og oc l od oe">scaler = MinMaxScaler(min=0.0, max=1.0, inputCol='assembled_features', outputCol='features')<br/>s_data = scaler.fit(a_data).transform(a_data)</span></pre><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/93e38e078e0e09e7724de04e7f707981.png" data-original-src="https://miro.medium.com/v2/resize:fit:610/format:webp/1*8z8hUQ49ibOo__ZYzI9uXA.png"/></div><p class="mx my gj gh gi mz na bd b be z dk translated">我的电脑</p></figure><p id="5b6f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，让我们将数据分为训练和测试数据集，定义模型，并将训练数据放入模型中。我用过的网络层是4，16，2</p><p id="aea9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">4是因为有4个不同的输入要素，2是输出图层，因为它是二元分类。</p><pre class="mm mn mo mp gt nx ne ny nz aw oa bi"><span id="5c0a" class="lz ld iq ne b gy ob oc l od oe">train_df,test_df = s_data.select('Class ','features').randomSplit([0.7,0.3],1213)</span><span id="20e6" class="lz ld iq ne b gy og oc l od oe"><br/>mlpc=MultilayerPerceptronClassifier( featuresCol=’features’,labelCol=’Class ‘,layers = [4,16,2],\<br/> maxIter=1000,blockSize=8,seed=7,solver=’gd’)</span><span id="2da0" class="lz ld iq ne b gy og oc l od oe">ann = mlpc.fit(train_df)</span></pre><p id="14ba" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦完成。你可以检查一下准确性。使用方法multiclasssclassificationevaluator()。</p><p id="31bc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在转换测试数据，并在evaluator方法中定义精度，如f1、精度等等。</p><pre class="mm mn mo mp gt nx ne ny nz aw oa bi"><span id="4627" class="lz ld iq ne b gy ob oc l od oe">pred = ann.transform(test_df)<br/>evaluator = MulticlassClassificationEvaluator(labelCol='Class ',predictionCol='prediction',metricName='f1')<br/>ann_f1 = evaluator.evaluate(pred)<br/>ann_f1</span></pre><p id="8104" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">运行1000次迭代后，f1值为0.8309986610958963。</p><p id="56bf" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">结论</strong>:</p><p id="cb3a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">尝试使用不同的数据集，如带超参数调整的mnist数据集，并检查模型性能。请在评论区告诉我你的想法。你可以在这里访问代码和数据集<a class="ae lb" href="https://github.com/someshkr/MultiLyerPerceptron-" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="7daa" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我会带着另一个有趣的话题回来，在那之前祝你阅读愉快！</p><p id="cb54" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请在评论区分享你的想法。你可以在<a class="ae lb" href="https://www.linkedin.com/in/somesh-kumar-routray/" rel="noopener ugc nofollow" target="_blank"> Linkedln </a>、<a class="ae lb" href="http://somesh.routray11@gmail.com" rel="noopener ugc nofollow" target="_blank"> Gmail </a>上帮我联系。</p></div></div>    
</body>
</html>