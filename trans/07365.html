<html>
<head>
<title>5 things that make my job as a Data Scientist easier</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让我作为数据科学家的工作更轻松的5件事</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/5-things-that-make-my-job-as-a-data-scientist-easier-dc0820f0f136?source=collection_archive---------1-----------------------#2021-07-05">https://towardsdatascience.com/5-things-that-make-my-job-as-a-data-scientist-easier-dc0820f0f136?source=collection_archive---------1-----------------------#2021-07-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="e516" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/office-hours" rel="noopener" target="_blank">办公时间</a></h2><div class=""/><div class=""><h2 id="1e9c" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">在作为一名数据科学家工作了一年之后，我在这里分享我一路走来学到的一些东西，我觉得这些东西很有帮助，并且提高了我的效率。希望这些建议能对你的旅程有所帮助:)</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/b44188372c35d62b712636246e355574.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*EUxUnZHWnkDLir9G"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated"><a class="ae le" href="https://unsplash.com/@writecodenow?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">博伊图梅洛·菲特拉</a>在<a class="ae le" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><ol class=""><li id="d3f9" class="lf lg iq lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated"><strong class="lh ja">熊猫的时间序列数据处理</strong></li></ol><p id="8951" class="pw-post-body-paragraph lx ly iq lh b li lj ka lz lk ll kd ma lm mb mc md lo me mf mg lq mh mi mj ls ij bi translated">如果您使用时间序列数据，那么您可能已经花费了大量的时间来计算缺失的记录，或者通过SQL查询或编写自定义函数以特定的时间粒度来聚合数据。Pandas有一个非常高效的<a class="ae le" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.resample.html" rel="noopener ugc nofollow" target="_blank">重采样函数</a>，它可以帮助您以特定的频率处理数据，只需将DataFrame索引设置为时间戳列。</p><p id="6e27" class="pw-post-body-paragraph lx ly iq lh b li lj ka lz lk ll kd ma lm mb mc md lo me mf mg lq mh mi mj ls ij bi translated">我将使用房间占用率数据集来举例说明这个函数。你可以在这里找到数据集<a class="ae le" href="https://archive.ics.uci.edu/ml/datasets/Occupancy+Detection+" rel="noopener ugc nofollow" target="_blank"/>。这个数据集记录了分钟级别的观察结果。</p><pre class="kp kq kr ks gt mk ml mm mn aw mo bi"><span id="2411" class="mp mq iq ml b gy mr ms l mt mu">import pandas as pd<br/>data = pd.read_csv('occupancy_data/datatest.txt').reset_index(drop = True)<br/>data.head(5)</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mv"><img src="../Images/826818cbd83e23d20b7e68de8396462d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S6GxZvmrDtzG_edBoxFuaA.png"/></div></div></figure><p id="d06b" class="pw-post-body-paragraph lx ly iq lh b li lj ka lz lk ll kd ma lm mb mc md lo me mf mg lq mh mi mj ls ij bi translated">首先，我展示了一个简单的聚合，可以每小时获取一次指标。</p><pre class="kp kq kr ks gt mk ml mm mn aw mo bi"><span id="51cf" class="mp mq iq ml b gy mr ms l mt mu">data.index = pd.to_datetime(data['date'])<br/>pd.DataFrame(data.resample('H').agg({'Temperature':'mean',<br/>                                     'Humidity':'mean',<br/>                                     'Light':'last',<br/>                                     'CO2':'last',<br/>                                     'HumidityRatio' : 'mean',<br/>                                     'Occupancy' : 'mean'})).head(5)</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mw"><img src="../Images/1fff4eb7618f24d5f5f960586f99451c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TAsnRClU9YebVz0OLu3xjA.png"/></div></div></figure><p id="d3c0" class="pw-post-body-paragraph lx ly iq lh b li lj ka lz lk ll kd ma lm mb mc md lo me mf mg lq mh mi mj ls ij bi translated">尽管这个数据集并不稀疏，但在现实世界中，人们经常会遇到缺少记录的数据。考虑这些记录很重要，因为如果没有记录，您可能希望输入0值，或者使用上一个或下一个时间步长进行插补。下面，我删除了第15小时的记录，以展示如何使用第14小时的时间戳来估算缺失值:</p><pre class="kp kq kr ks gt mk ml mm mn aw mo bi"><span id="f413" class="mp mq iq ml b gy mr ms l mt mu">data = pd.read_csv('occupancy_data/datatest.txt').reset_index(drop = True)</span><span id="2e43" class="mp mq iq ml b gy mx ms l mt mu">data_missing_records = data[~(pd.to_datetime(data.date).dt.hour == 15)].reset_index(drop = True)</span><span id="30b3" class="mp mq iq ml b gy mx ms l mt mu">data_missing_records.index = pd.to_datetime(data_missing_records['date'])</span><span id="192a" class="mp mq iq ml b gy mx ms l mt mu">data_missing_records.resample('H', base = 1).agg({'Temperature':'mean',<br/>        'Humidity':'mean',<br/>        'Light':'last',<br/>        'CO2':'last',<br/>        'HumidityRatio' : 'mean',<br/>         'Occupancy' : 'mean'}).fillna(method  = 'ffill').head(5)</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi my"><img src="../Images/8b996f61a19ee5bb970ad06ad4f9d3e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8SW7d7V-vMkfIIexGavlZg.png"/></div></div></figure><p id="5e89" class="pw-post-body-paragraph lx ly iq lh b li lj ka lz lk ll kd ma lm mb mc md lo me mf mg lq mh mi mj ls ij bi translated">2.<strong class="lh ja">通过Plotly Express实现快速可视化</strong></p><p id="ff4a" class="pw-post-body-paragraph lx ly iq lh b li lj ka lz lk ll kd ma lm mb mc md lo me mf mg lq mh mi mj ls ij bi translated">从分析到模型训练到模型报告，经常需要可视化。特别是对于时间序列图，我注意到我花了很多时间试图在matplotlib中定制我的x轴刻度的大小和角度。在我改用Plotly Express后，我减少了大约70%的制作图表的时间。如果我想在我的视觉效果中实现特定的细节，我仍然可以通过使用Plotly Graph对象来实现。此外，Plotly通过Express提供了许多简单的选项，如在绘图中设置组颜色，从而产生更强大的可视化效果。</p><pre class="kp kq kr ks gt mk ml mm mn aw mo bi"><span id="0997" class="mp mq iq ml b gy mr ms l mt mu">import plotly.express as px<br/>data['Temp_Bands'] = np.round(data['Temperature'])<br/>fig = px.line(data, x = 'date',<br/>              y = 'HumidityRatio',<br/>              color = 'Temp_Bands',<br/>             title = 'Humidity Ratio across dates as a function of<br/>             Temperature Bands',<br/>             labels = {'date' : 'Time Stamp',<br/>                      'HumidityRatio' : 'Humidity Ratio',<br/>                      'Temp_Bands' : 'Temperature Band'})<br/>fig.show()</span></pre><p id="35fe" class="pw-post-body-paragraph lx ly iq lh b li lj ka lz lk ll kd ma lm mb mc md lo me mf mg lq mh mi mj ls ij bi translated">使用上面提到的占用数据集，我使用Plotly Express创建了带有颜色分组的线图。我们可以看到只用两个函数创建这些图是多么容易。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mz"><img src="../Images/1e66cf008cfda9d1040c9f3ce50175db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*elZVadm-L3cRyaN1MDTRsw.png"/></div></div></figure><p id="797f" class="pw-post-body-paragraph lx ly iq lh b li lj ka lz lk ll kd ma lm mb mc md lo me mf mg lq mh mi mj ls ij bi translated">3.<strong class="lh ja">通过Swifter加速熊猫申请()</strong></p><p id="6c37" class="pw-post-body-paragraph lx ly iq lh b li lj ka lz lk ll kd ma lm mb mc md lo me mf mg lq mh mi mj ls ij bi translated">我有时在处理pandas列时会遇到很长的等待时间，即使是在有大型实例的笔记本上运行代码。取而代之的是一个简单的单词添加，可以用来加速pandas数据框架中的应用功能。人们只需要更快地导入库。</p><pre class="kp kq kr ks gt mk ml mm mn aw mo bi"><span id="13d5" class="mp mq iq ml b gy mr ms l mt mu">def custom(num1, num2):<br/>    <br/>    if num1 &gt; num2:<br/>        if num1 &lt; 0:<br/>            return "Greater Negative"<br/>        else:<br/>            return "Greater Positive"<br/>    elif num2 &gt; num1:<br/>        if num2 &lt; 0:<br/>            return "Less Negative"<br/>        else:<br/>            return "Less Positive"<br/>    else:<br/>        return "Rare Equal"</span><span id="3fc9" class="mp mq iq ml b gy mx ms l mt mu">import swifter <br/>import pandas as pd<br/>import numpy as np</span><span id="7f22" class="mp mq iq ml b gy mx ms l mt mu">data_sample = pd.DataFrame(np.random.randint(-10000, 10000, size = (50000000, 2)), columns = list('XY'))</span></pre><p id="8b28" class="pw-post-body-paragraph lx ly iq lh b li lj ka lz lk ll kd ma lm mb mc md lo me mf mg lq mh mi mj ls ij bi translated">我创建了一个5000万行的数据帧，并比较了通过更快的apply()和普通的apply()处理它所需的时间。我还创建了一个带有简单if else条件的虚拟函数来测试这两种方法。</p><pre class="kp kq kr ks gt mk ml mm mn aw mo bi"><span id="8811" class="mp mq iq ml b gy mr ms l mt mu">%%time</span><span id="9aec" class="mp mq iq ml b gy mx ms l mt mu">results_arr = data_sample.apply(lambda x : custom(x['X'], x['Y']), axis = 1)</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi na"><img src="../Images/fc222fc52b2899e2310c1675a32b3640.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ni1QpCjoKiJTYYfAhJzLXw.png"/></div></div></figure><pre class="kp kq kr ks gt mk ml mm mn aw mo bi"><span id="ce5e" class="mp mq iq ml b gy mr ms l mt mu">%%time</span><span id="d2ba" class="mp mq iq ml b gy mx ms l mt mu">results_arr = data_sample.swifter.apply(lambda x : custom(x['X'], x['Y']), axis = 1)</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nb"><img src="../Images/2e854bfe69efaf85d916c6dddb7516d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lv_NfCZHFyyB1XbXiG6zEw.png"/></div></div></figure><p id="45d4" class="pw-post-body-paragraph lx ly iq lh b li lj ka lz lk ll kd ma lm mb mc md lo me mf mg lq mh mi mj ls ij bi translated">我们能够将处理时间减少64.4%，从7分53秒减少到2分38秒。</p><p id="6712" class="pw-post-body-paragraph lx ly iq lh b li lj ka lz lk ll kd ma lm mb mc md lo me mf mg lq mh mi mj ls ij bi translated">4.<strong class="lh ja">Python中的多重处理</strong></p><p id="2e79" class="pw-post-body-paragraph lx ly iq lh b li lj ka lz lk ll kd ma lm mb mc md lo me mf mg lq mh mi mj ls ij bi translated">虽然我们的主题是降低时间复杂度，但我经常以处理我希望在多个粒度上处理的数据集而告终。在python中使用多处理可以帮助我通过利用多个工作者来节省时间。</p><p id="50b1" class="pw-post-body-paragraph lx ly iq lh b li lj ka lz lk ll kd ma lm mb mc md lo me mf mg lq mh mi mj ls ij bi translated">我使用上面创建的相同的5000万行数据框架来演示多处理的有效性。除了这次我添加了一个分类变量，它是从一组元音中选择的随机值。</p><pre class="kp kq kr ks gt mk ml mm mn aw mo bi"><span id="f57f" class="mp mq iq ml b gy mr ms l mt mu">import pandas as pd<br/>import numpy as np<br/>import random</span><span id="2f71" class="mp mq iq ml b gy mx ms l mt mu">string =  'AEIOU'</span><span id="b672" class="mp mq iq ml b gy mx ms l mt mu">data_sample = pd.DataFrame(np.random.randint(-10000, 10000, size = (50000000, 2)), columns = list('XY'))<br/>data_sample['random_char'] = random.choices(string, k = data_sample.shape[0])<br/>unique_char = data_sample['random_char'].unique()</span></pre><p id="51c8" class="pw-post-body-paragraph lx ly iq lh b li lj ka lz lk ll kd ma lm mb mc md lo me mf mg lq mh mi mj ls ij bi translated">我使用了一个for循环和concurrent.futures中的进程池执行器来演示我们可以实现的运行时减少。</p><pre class="kp kq kr ks gt mk ml mm mn aw mo bi"><span id="5359" class="mp mq iq ml b gy mr ms l mt mu">%%time</span><span id="935d" class="mp mq iq ml b gy mx ms l mt mu">arr = []</span><span id="77a7" class="mp mq iq ml b gy mx ms l mt mu">for i in range(len(data_sample)):<br/>    <br/>    num1 = data_sample.X.iloc[i]<br/>    num2 = data_sample.Y.iloc[i]<br/>    <br/>    if num1 &gt; num2:<br/>        if num1 &lt; 0:<br/>            arr.append("Greater Negative")<br/>        else:<br/>            arr.append("Greater Positive")<br/>    elif num2 &gt; num1:<br/>        if num2 &lt; 0:<br/>            arr.append("Less Negative")<br/>        else:<br/>            arr.append("Less Positive")<br/>    else:<br/>        arr.append("Rare Equal")</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nc"><img src="../Images/5dc146f4757b1bd0844388b969ea17c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RyiANqsRAmQLWQclut5R6w.png"/></div></div></figure><pre class="kp kq kr ks gt mk ml mm mn aw mo bi"><span id="4a3c" class="mp mq iq ml b gy mr ms l mt mu">def custom_multiprocessing(i):<br/>    <br/>    sample = data_sample[data_sample['random_char'] == \<br/>    unique_char[i]]<br/>    <br/>    arr = []<br/>    <br/>    for j in range(len(sample)):<br/>        if num1 &gt; num2:<br/>            if num1 &lt; 0:<br/>                arr.append("Greater Negative")<br/>            else:<br/>                arr.append("Greater Positive")<br/>        elif num2 &gt; num1:<br/>            if num2 &lt; 0:<br/>                arr.append("Less Negative")<br/>            else:<br/>                arr.append("Less Positive")<br/>        else:<br/>            arr.append("Rare Equal")<br/>            <br/>    sample['values'] = arr<br/>    <br/>    return sample</span></pre><p id="560e" class="pw-post-body-paragraph lx ly iq lh b li lj ka lz lk ll kd ma lm mb mc md lo me mf mg lq mh mi mj ls ij bi translated">我创建了一个函数，允许我分别处理每个元音分组:</p><pre class="kp kq kr ks gt mk ml mm mn aw mo bi"><span id="bb9f" class="mp mq iq ml b gy mr ms l mt mu"><br/>%%time <br/>import concurrent</span><span id="65a0" class="mp mq iq ml b gy mx ms l mt mu">def main():<br/>    aggregated = pd.DataFrame()<br/>    <br/>    with concurrent.futures.ProcessPoolExecutor(max_workers = 5) as executor:<br/>        results = executor.map(custom_multiprocessing, range(len(unique_char)))</span><span id="0e58" class="mp mq iq ml b gy mx ms l mt mu">if __name__ == '__main__':<br/>    main()</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nd"><img src="../Images/f83cd5c364413e384e64a91fff221373.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FLZihJGsx3OhMv00gBKZNw.png"/></div></div></figure><p id="ef07" class="pw-post-body-paragraph lx ly iq lh b li lj ka lz lk ll kd ma lm mb mc md lo me mf mg lq mh mi mj ls ij bi translated">我们看到CPU时间减少了99.3%。尽管必须记住小心使用这些方法，因为它们不会序列化输出，因此通过分组使用它们是利用这种能力的好方法。</p><p id="b94a" class="pw-post-body-paragraph lx ly iq lh b li lj ka lz lk ll kd ma lm mb mc md lo me mf mg lq mh mi mj ls ij bi translated">5.<strong class="lh ja">作为公制的梅斯</strong></p><p id="176b" class="pw-post-body-paragraph lx ly iq lh b li lj ka lz lk ll kd ma lm mb mc md lo me mf mg lq mh mi mj ls ij bi translated">随着使用机器学习和深度学习方法进行时间序列预测的兴起，使用仅仅基于预测值和实际值之间的距离的度量标准<strong class="lh ja">而不是</strong>是必不可少的。预测模型的度量还应该使用时间趋势的误差来评估模型的性能，而不仅仅是时间点的误差估计。输入<a class="ae le" href="https://robjhyndman.com/publications/another-look-at-measures-of-forecast-accuracy/" rel="noopener ugc nofollow" target="_blank">平均绝对刻度误差</a>！该指标考虑了如果我们使用随机游走方法(上一个时间戳的值将是下一个时间戳的预测值)时会出现的误差。它将模型的误差与简单预测的误差进行比较。</p><pre class="kp kq kr ks gt mk ml mm mn aw mo bi"><span id="9dd5" class="mp mq iq ml b gy mr ms l mt mu">def MASE(y_train, y_test, pred): <br/>  <br/>    naive_error = np.sum(np.abs(np.diff(y_train)))/(len(y_train)-1)        <br/>    model_error = np.mean(np.abs(y_test - pred))</span><span id="0ea9" class="mp mq iq ml b gy mx ms l mt mu">return model_error/naive_error</span></pre><p id="68b1" class="pw-post-body-paragraph lx ly iq lh b li lj ka lz lk ll kd ma lm mb mc md lo me mf mg lq mh mi mj ls ij bi translated">如果MASE &gt; 1，则该模型的表现比随机漫步差。MASE越接近0，预测模型越好。</p></div><div class="ab cl ne nf hu ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ij ik il im in"><p id="5c5b" class="pw-post-body-paragraph lx ly iq lh b li lj ka lz lk ll kd ma lm mb mc md lo me mf mg lq mh mi mj ls ij bi translated">在本文中，我们介绍了一些我经常使用的技巧，让我作为一名数据科学家的生活变得更加轻松。评论分享一些你的小技巧吧！我很想了解更多其他数据科学家在工作中使用的技巧。</p><p id="d305" class="pw-post-body-paragraph lx ly iq lh b li lj ka lz lk ll kd ma lm mb mc md lo me mf mg lq mh mi mj ls ij bi translated">这也是我的第一篇媒体文章，我觉得我在对虚无说话，所以如果你有任何反馈要分享，请随时批评和联系:)</p></div></div>    
</body>
</html>