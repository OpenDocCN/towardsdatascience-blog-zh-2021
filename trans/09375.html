<html>
<head>
<title>Hidden Markov Models: an Overview</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">隐马尔可夫模型:综述</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/hidden-markov-models-an-overview-98926404da0e?source=collection_archive---------15-----------------------#2021-08-31">https://towardsdatascience.com/hidden-markov-models-an-overview-98926404da0e?source=collection_archive---------15-----------------------#2021-08-31</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="d045" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/hands-on-tutorials" rel="noopener" target="_blank">实践教程</a>、<a class="ae ep" href="https://towardsdatascience.com/tagged/notes-from-industry" rel="noopener" target="_blank">行业笔记</a></h2><div class=""/><p id="d8ce" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">有许多工具可用于分析顺序数据。隐马尔可夫模型(HMMs)是最简单、最灵活、最经得起时间考验的模型之一。它们最初是为信号处理而开发的，现在在生物信息学中无处不在。</p><p id="4867" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">在数据科学社区中，有一种倾向是支持像LSTMs这样的机器学习选项。虽然这些工具非常强大，但它们也是出了名的复杂和难以理解。因此，你经常会看到数据科学家努力使用复杂的方法，而简单的方法会更好。</p><p id="8302" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">本文旨在解决这一问题，让技术人员了解经常被忽视的HMM的概念和应用。在<a class="ae ku" href="https://www.zeitworks.com/" rel="noopener ugc nofollow" target="_blank"> Zeitworks </a>我们非常依赖最先进的机器学习技术，但作为经验丰富的数据科学家，我们也知道有时HMM是这项工作的工具。</p><h1 id="3a4e" class="kv kw iq bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">激发真实世界的例子</h1><p id="c63f" class="pw-post-body-paragraph jw jx iq jy b jz lt kb kc kd lu kf kg kh lv kj kk kl lw kn ko kp lx kr ks kt ij bi translated">以下是我使用hmm解决的一些问题:</p><ol class=""><li id="5f34" class="ly lz iq jy b jz ka kd ke kh ma kl mb kp mc kt md me mf mg bi translated">在<a class="ae ku" href="http://www.zeitworks.com" rel="noopener ugc nofollow" target="_blank">zei networks</a>我们使用计算机事件日志研究人类工作流程。其中一部分是获取用户的原始事件日志(击键、访问的URL等。)并确定他们每次都在做什么(背景研究、文档审查等)。).有时你可以孤立地从一个事件中猜测，但通常你也需要看看前后的事件才能有信心。</li><li id="b455" class="ly lz iq jy b jz mh kd mi kh mj kl mk kp ml kt md me mf mg bi translated">你有一本小说中某一页的照片，你想将文本数字化。照片已经被分割成单词的图像。大部分都可以用OCR解码，但是有些字因为原页面上的污垢而模糊不清(那是“快”还是“嘎嘎”？).你想用周围的词来挑选最佳选项。</li><li id="1885" class="ly lz iq jy b jz mh kd mi kh mj kl mk kp ml kt md me mf mg bi translated">当一个人在玩电子游戏时，你有一系列每秒钟拍摄的大脑扫描。在游戏中，他们的化身在建筑物中进进出出，你的目标是仅使用大脑扫描来猜测它是在室内还是室外。任何给定的扫描都是非常不明确的，但是头像通常会在里面/外面停留几秒钟。你预计化身在(外)侧的时间跨度很大，大脑扫描平均看起来稍微更偏向(外)侧。</li></ol><p id="fa2c" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">为这些问题中的每一个建立一个定制的解决方案是可能的，但是这是一个非常大的任务，有脆弱或易受攻击的风险。通常，特别是如果工作部分是探索性的，你想要更轻的东西。hmm提供了一个框架，它足够通用，可以涵盖所有这些情况，足够灵活，可以包含大量领域知识，并且足够简单，可以理解。</p><h1 id="9c68" class="kv kw iq bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">数学模型</h1><p id="cda7" class="pw-post-body-paragraph jw jx iq jy b jz lt kb kc kd lu kf kg kh lv kj kk kl lw kn ko kp lx kr ks kt ij bi translated">让我们从商业现实过渡到数学理想化。上述业务问题有几个共同点:</p><ol class=""><li id="9353" class="ly lz iq jy b jz ka kd ke kh ma kl mb kp mc kt md me mf mg bi translated">有一个离散的潜在现实世界的“状态”，随着时间的推移而变化。在示例(1)和(3)中，状态很少改变。在示例(2)中，状态是页面上的单词，并且它几乎在每个时间步都发生变化。我们把这个现实世界的状态叫做s。</li><li id="f652" class="ly lz iq jy b jz mh kd mi kh mj kl mk kp ml kt md me mf mg bi translated">在每个时间步长，您都有一个“观察”，可以用来以一定的置信度猜测状态(对于OCR示例，置信度通常很高，但是对于大脑扫描，置信度很低)。让我们把这个观测称为O。注意，虽然状态S是离散的，O可以是离散的，也可以是连续的。</li><li id="dd5f" class="ly lz iq jy b jz mh kd mi kh mj kl mk kp ml kt md me mf mg bi translated">这个想法是使用时间T时的观察值O来猜测状态S，然后使用T前后的观察值来改进我们的猜测。</li></ol><p id="1606" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">整体情况看起来是这样的，状态一个接一个，每一个都产生一个观察结果:</p><figure class="mo mp mq mr gt ms gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi mn"><img src="../Images/6f9aee343738514901a89c980e7a705b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iUZV_Bqjcu6YDb9Q_2vfbw.png"/></div></div><p class="mz na gj gh gi nb nc bd b be z dk translated">HMM中状态和观察值之间的依赖结构</p></figure><p id="7688" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">具体来说，在你的头脑中保持下面的画面。状态S是可以掷出的骰子，观察值O是哪一面出现。为简单起见，假设有两个骰子，其中一个是公平的，另一个有50%的机会是6。掷出公平骰子后，有10%的几率我会换到另一个骰子，在掷出装载的骰子后，有20%的几率我会换。我做了很多次掷骰子——从来没有告诉你我用的是哪个骰子——而你的工作就是猜测骰子什么时候是公平的或者是装满的。你需要的最后一条信息是，在第一次掷骰子时，我使用公平骰子还是装载骰子的可能性有多大；让我们称之为50/50。这种情况可以归纳为三个表格:</p><figure class="mo mp mq mr gt ms gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi nd"><img src="../Images/49f4ae48b9c5c2d75fb5ad808bfd669d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-o0JpFaypSrvvypgP_wFdQ.png"/></div></div><p class="mz na gj gh gi nb nc bd b be z dk translated">一个简单的HMM的数学描述与骰子，一个加载和一个公平。</p></figure><p id="85f5" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">为了用数学术语表达这一点，我们需要:</p><ul class=""><li id="a31e" class="ly lz iq jy b jz ka kd ke kh ma kl mb kp mc kt ne me mf mg bi translated">每个州的初始概率，P[S⁰=s].这个矢量通常被称为π。</li><li id="81ce" class="ly lz iq jy b jz mh kd mi kh mj kl mk kp ml kt ne me mf mg bi translated">转移概率矩阵</li></ul><figure class="mo mp mq mr gt ms gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/df55f349f1ac332b9f5493b6e9256bf9.png" data-original-src="https://miro.medium.com/v2/resize:fit:648/format:webp/1*0aTSSqoNoPlhsF0bBACiHQ.png"/></div></figure><p id="1ed2" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">为了简单起见，我称之为<em class="mm"> Pr[a → b] </em>。</p><ul class=""><li id="01e2" class="ly lz iq jy b jz ka kd ke kh ma kl mb kp mc kt ne me mf mg bi translated">给定状态下观察值的概率分布，Pr[O=o|S=s]。因为骰子O是离散的，概率分布放在一个表格里。但是数学上O可以是任何东西；对于算法，我们只需要一个函数，它接受状态(从1到k的整数)和观察值(可以是任何值)并返回一个非负数。</li></ul><p id="b6d2" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">我应该指出，如果我们忘记观察，状态S构成一个更简单的模型，称为“马尔可夫链”。几乎随机分析中的所有东西要么是马尔可夫链，要么是马尔可夫链的变体；hmm是一种变体，其中链的状态对我们的知识是隐藏的(因此得名)，并且必须通过不完美的观察来猜测。</p><h1 id="5f2c" class="kv kw iq bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">hmm的局限性及优化</h1><p id="4d8b" class="pw-post-body-paragraph jw jx iq jy b jz lt kb kc kd lu kf kg kh lv kj kk kl lw kn ko kp lx kr ks kt ij bi translated">我想讨论一下HMM模型中一些很少是100%真实的理想化情况，以及对此你能做些什么。如果您只想了解如何使用HMMs，可以跳过这一部分:)</p><p id="cfc6" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">最大的理想化是所谓的“马尔可夫假设”，即下一个状态只依赖于当前状态。我喜欢把它比作一只患了健忘症的青蛙，在睡莲叶间跳跃；他不知道他在当前的发射台呆了多久，也不知道他之前在哪里，所以他只根据他从当前位置看到的东西来选择下一个发射台(或者根本不跳)。您可以通过一个n阶马尔可夫链来部分解决这个问题，其中您的“状态”实际上是一个滑动窗口，覆盖了包括当前状态在内的最后n个状态。在自然语言中使用hmm时，你会经常看到这种情况。这在计算上变得有风险，因为你现在要跟踪k^n不同的“州”。</p><p id="8a2d" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">HMMs的下一个假设是状态是真正离散的。通常情况下，状态是由人来决定的，地面上的现实可能并不完全符合其中一种状态。hmm没有混合状态的概念，但是它们支持关于状态的<em class="mm">不确定性</em>；当模型表明两种状态的可能性相当时，可能是信号很弱，但也可能是世界不适合我们的盒子。</p><p id="2600" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">最后是最重要的Pr[O|S],给定潜在状态下你观察到的概率。在我们的玩具骰子示例中，它只是一个查找表。不过，在我引用的现实世界的例子中，制作Pr[O|S]本身就是一个项目，包括建模假设和拟合历史数据。HMM对Pr[O|S]的复杂程度没有限制，但它确实假设O仅<em class="mm">依赖于当前的S，而不依赖于任何先前的S或O。这一假设当然不成立——因为S中没有捕捉到真实世界的动态，所以观察值通常是相关的——但在实践中这很少会有问题。</em></p><h1 id="7790" class="kv kw iq bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">计算状态:维特比算法</h1><p id="0cd9" class="pw-post-body-paragraph jw jx iq jy b jz lt kb kc kd lu kf kg kh lv kj kk kl lw kn ko kp lx kr ks kt ij bi translated">现在让我们把这个模型付诸实践吧！你可以用HMM做很多事情，但是在商业中90%的时间是这样的:<em class="mm">给定一系列N次观察，猜猜状态是什么</em>。为此，我们使用著名的维特比算法，该算法计算给定我们的观察的基础状态的最优序列。</p><p id="8cf7" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">当我说“最优”时，我指的是“最有可能”——1)从基础马尔可夫链中获得状态序列，然后2)该序列生成已知观察值的概率。</p><p id="4cdf" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">为了做到这一点，考虑一个相关的子问题:找到直到时间步i <em class="mm">的最佳序列，该时间步I<em class="mm">在特定状态s </em>结束。让我们定义σ(i，s)为该序列的概率。想想骰子的例子:关键的见解是，直到i+1结束的最佳序列是公平的，或者是{直到I结束的最佳序列是公平的}+{公平}，或者是{直到I结束的最佳序列是装载的}+{公平}。如果我们知道到时间I为止的最佳序列，那么i+1就很容易了！在数学中，这告诉我们:</em></p><figure class="mo mp mq mr gt ms gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi ng"><img src="../Images/20fe0d9f5b028d35d459c57b284739cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DaDwkMd-E0dj-MVzAhQK7A.png"/></div></div></figure><p id="eb00" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">我们可以将所有σ(i，s)排列在一个表格中，如下所示:</p><figure class="mo mp mq mr gt ms gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi nh"><img src="../Images/a6cda51a7bc7caa60476865cfae65763.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E2HBY_bZ7KGcrnF8oWJx3g.png"/></div></div></figure><p id="94a9" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">一旦这个表被填充，我们几乎完成了维特比算法！我们可以通过查看哪个s最大化σ(N，s)来找到最优序列中的最后一个状态。然后我们逆向工作——在计算σ(N，s)时，我们用哪个x来表示σ(N-1，x)？您可以通过画一个从σ(i，s)到σ(i-1，x)的箭头来形象化这个过程，如下所示:</p><figure class="mo mp mq mr gt ms gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi ni"><img src="../Images/c1b0c6097a73a5bff8810b427b22f7a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nayWbeNp2D2jkMsyP_1NpA.png"/></div></div></figure><p id="7874" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">这样，我们可以重建整个最佳序列。如果我们想表达这是伪代码，我们可以写:</p><figure class="mo mp mq mr gt ms gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi nj"><img src="../Images/5e346f218cd55e62b0f161ebc993d199.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4HVV9jPYGxnMFcnj2oF93g.png"/></div></div></figure><p id="a118" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">只有一个小的实现细节我必须注意。所述的算法将会遇到数值问题，因为概率变得如此之小。这很容易通过对概率的对数进行操作，并计算Log[σ(i，s)]而不是σ(i，s)的表来解决。最大化Log[σ(i，s)]等价于最大化σ(i，s)。</p><h1 id="2b98" class="kv kw iq bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">离别赠言</h1><p id="9f9b" class="pw-post-body-paragraph jw jx iq jy b jz lt kb kc kd lu kf kg kh lv kj kk kl lw kn ko kp lx kr ks kt ij bi translated">当我告诉科技行业的人我们在Zeitworks做什么时，我得到的典型回应是“哦，你可以用LSTM来做这个！”。虽然这些现在确实很流行，但是还有很多分析序列数据的工具，它们各有所长。</p><p id="7328" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">lst ms——以及其他深度学习模型——在现实世界模式不可理解的情况下大放异彩。这些是“数据驱动”的工具；有了足够的数据来训练，有了足够的旋钮来转动，它们可以学习模仿人类从未记录下来的复杂模式。作为交换，它们很难解释，如果问题发生变化也很难概括，并且依赖于大量的数据。</p><p id="43c4" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">hmm则相反。它们是“模型驱动的”:一种对人类友好的世界叙事，被浓缩成方程式。这些方程中的参数符合数据，但它们是有意义的数字，有现实世界的解释，而不是一个数字巫术。模型驱动的工具不如数据驱动的工具强大，但是作为交换，它们训练起来很便宜，很容易理解，而且你可以把专业知识融入其中。</p><p id="11f5" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">数据驱动和模型驱动工具是互补的，而不是对立的。它们是解决不同问题的理想选择，在Zeitworks，我们将两者结合在一起。但是做到这一点取决于批判性地思考你的武器库中所有工具的能力，理解它们的优势，以便你可以将它们与正确的任务相匹配。</p><p id="23b6" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">我在本文中的目标是让您理解hmm。它们是强大的模型——尽管在数据科学界经常被低估——它们通常是这项工作的最佳工具。</p><p id="e4ec" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated"><strong class="jy ja">下一篇</strong> : <a class="ae ku" href="https://medium.com/@field.cady/training-hidden-markov-models-831c1bdec27d" rel="noopener">训练嗯</a></p></div></div>    
</body>
</html>