<html>
<head>
<title>sort() vs orderBy() in Spark</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Spark中的sort()与orderBy()</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/sort-vs-orderby-in-spark-8a912475390?source=collection_archive---------6-----------------------#2021-05-16">https://towardsdatascience.com/sort-vs-orderby-in-spark-8a912475390?source=collection_archive---------6-----------------------#2021-05-16</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="a0df" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">Apache Spark中sort()和orderBy()有什么区别</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/65969e374626ac77cc570cdd7e4de045.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3dpNRKGWKCUlDcEVILVYpg.jpeg"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">米凯尔·克里斯滕森在<a class="ae kz" href="https://unsplash.com/s/photos/order?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h2 id="f5e4" class="la lb iu bd lc ld le dn lf lg lh dp li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">介绍</h2><p id="0e16" class="pw-post-body-paragraph lw lx iu ly b lz ma jv mb mc md jy me lj mf mg mh ln mi mj mk lr ml mm mn mo in bi translated">对Spark数据帧进行排序可能是最常用的操作之一。您可以使用<code class="fe mp mq mr ms b">sort()</code>或<code class="fe mp mq mr ms b">orderBy()</code>内置函数对至少一列的特定数据帧进行升序或降序排序。尽管这两个函数都应该对Spark数据帧中的数据进行排序，但它们有一个显著的区别。</p><p id="d7ac" class="pw-post-body-paragraph lw lx iu ly b lz mt jv mb mc mu jy me lj mv mg mh ln mw mj mk lr mx mm mn mo in bi translated">在今天的文章中，我们将讨论<code class="fe mp mq mr ms b">sort()</code>和<code class="fe mp mq mr ms b">orderBy()</code>的区别，并了解何时使用其中一个。</p></div><div class="ab cl my mz hy na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="in io ip iq ir"><p id="46ef" class="pw-post-body-paragraph lw lx iu ly b lz mt jv mb mc mu jy me lj mv mg mh ln mw mj mk lr mx mm mn mo in bi translated">首先，让我们创建一个示例数据框架，它将在整篇文章中用来演示<code class="fe mp mq mr ms b">sort()</code>和<code class="fe mp mq mr ms b">orderBy()</code>是如何工作的。注意，我将使用Python API，但是我们今天讨论的内容也适用于Scala。</p><pre class="kk kl km kn gu nf ms ng nh aw ni bi"><span id="24ce" class="la lb iu ms b gz nj nk l nl nm">df = spark.createDataFrame(<br/>   [<br/>      ('Andrew', 'Johnson', 'Engineering', 'UK', 34),<br/>      ('Maria', 'Brown', 'Finance', 'US', 41),<br/>      ('Michael', 'Stevenson', 'Sales', 'US', 31),<br/>      ('Mark', 'Anderson', 'Engineering', 'Ireland', 28),<br/>      ('Jen', 'White', 'Engineering', 'UK', 29)<br/>  ],<br/>  ['first_name', 'last_name', 'department', 'country', 'age']<br/>)<br/>df.show(truncate=False)</span><span id="a345" class="la lb iu ms b gz nn nk l nl nm">+----------+---------+-----------+--------+---+<br/>|first_name|last_name| department||country|age|<br/>+----------+---------+-----------+--------+---+<br/>|    Andrew|  Johnson|Engineering|      UK| 34|<br/>|     Maria|    Brown|    Finance|      US| 41|<br/>|   Michael|Stevenson|      Sales|      US| 31|<br/>|      Mark| Anderson|Engineering| Ireland| 28|<br/>|       Jen|    White|Engineering|      UK| 29|<br/>+----------+---------+-----------+--------+---+</span></pre></div><div class="ab cl my mz hy na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="in io ip iq ir"><h2 id="c000" class="la lb iu bd lc ld le dn lf lg lh dp li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">排序()</h2><p id="7d63" class="pw-post-body-paragraph lw lx iu ly b lz ma jv mb mc md jy me lj mf mg mh ln mi mj mk lr ml mm mn mo in bi translated">现在，我们可以使用<code class="fe mp mq mr ms b">sort()</code>方法根据雇员的国家和年龄对数据帧<code class="fe mp mq mr ms b">df</code>进行升序排序。</p><pre class="kk kl km kn gu nf ms ng nh aw ni bi"><span id="8c36" class="la lb iu ms b gz nj nk l nl nm">df.sort('country', 'age').show(truncate=False)</span><span id="d16d" class="la lb iu ms b gz nn nk l nl nm">+----------+---------+-----------+--------+---+<br/>|first_name|last_name| department||country|age|<br/>+----------+---------+-----------+--------+---+<br/>|      Mark| Anderson|Engineering| Ireland| 28|<br/>|       Jen|    White|Engineering|      UK| 29|<br/>|    Andrew|  Johnson|Engineering|      UK| 34|<br/>|   Michael|Stevenson|      Sales|      US| 31|<br/>|     Maria|    Brown|    Finance|      US| 41|<br/>+----------+---------+-----------+--------+---+</span></pre><p id="ba01" class="pw-post-body-paragraph lw lx iu ly b lz mt jv mb mc mu jy me lj mv mg mh ln mw mj mk lr mx mm mn mo in bi translated">但是请注意，<code class="fe mp mq mr ms b">sort()</code>方法将对每个分区中的记录进行排序，然后返回最终输出，这意味着<strong class="ly iv">输出数据的顺序无法保证</strong>，因为数据是在分区级别上排序的，但是您的数据帧可能有数千个分区分布在集群中。由于数据没有被收集到一个单独的执行器中，所以<code class="fe mp mq mr ms b">sort()</code>方法是有效的，因此当排序对您的用例不重要时更合适。</p><p id="56d2" class="pw-post-body-paragraph lw lx iu ly b lz mt jv mb mc mu jy me lj mv mg mh ln mw mj mk lr mx mm mn mo in bi translated">例如，如果雇员<code class="fe mp mq mr ms b">Jen</code>和<code class="fe mp mq mr ms b">Andrew</code>存储在不同的分区上，那么最终的顺序可能是错误的，例如:</p><pre class="kk kl km kn gu nf ms ng nh aw ni bi"><span id="a4e2" class="la lb iu ms b gz nj nk l nl nm">+----------+---------+-----------+--------+---+<br/>|first_name|last_name| department||country|age|<br/>+----------+---------+-----------+--------+---+<br/>|      Mark| Anderson|Engineering| Ireland| 28|<br/>|    Andrew|  Johnson|Engineering|      UK| 34|<br/>|       Jen|    White|Engineering|      UK| 29|<br/>|   Michael|Stevenson|      Sales|      US| 31|<br/>|     Maria|    Brown|    Finance|      US| 41|<br/>+----------+---------+-----------+--------+---+</span></pre></div><div class="ab cl my mz hy na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="in io ip iq ir"><h2 id="20dc" class="la lb iu bd lc ld le dn lf lg lh dp li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">orderBy()</h2><p id="7837" class="pw-post-body-paragraph lw lx iu ly b lz ma jv mb mc md jy me lj mf mg mh ln mi mj mk lr ml mm mn mo in bi translated">同样，我们可以使用<code class="fe mp mq mr ms b">orderBy()</code>根据雇员的国家和年龄以升序排列数据框:</p><pre class="kk kl km kn gu nf ms ng nh aw ni bi"><span id="c252" class="la lb iu ms b gz nj nk l nl nm">df.orderBy(<!-- -->'country', 'age'<!-- -->).show(truncate=False)</span><span id="9fa2" class="la lb iu ms b gz nn nk l nl nm">+----------+---------+-----------+--------+---+<br/>|first_name|last_name| department||country|age|<br/>+----------+---------+-----------+--------+---+<br/>|      Mark| Anderson|Engineering| Ireland| 28|<br/>|       Jen|    White|Engineering|      UK| 29|<br/>|    Andrew|  Johnson|Engineering|      UK| 34|<br/>|   Michael|Stevenson|      Sales|      US| 31|<br/>|     Maria|    Brown|    Finance|      US| 41|<br/>+----------+---------+-----------+--------+---+</span></pre><p id="5abb" class="pw-post-body-paragraph lw lx iu ly b lz mt jv mb mc mu jy me lj mv mg mh ln mw mj mk lr mx mm mn mo in bi translated">与<code class="fe mp mq mr ms b">sort()</code>不同，<code class="fe mp mq mr ms b"><strong class="ly iv">orderBy()</strong></code> <strong class="ly iv">功能保证输出中的总顺序。</strong>发生这种情况是因为数据将被收集到单个执行器中以便进行排序。这意味着<code class="fe mp mq mr ms b">orderBy()</code>比<code class="fe mp mq mr ms b">sort()</code>效率更低。</p></div><div class="ab cl my mz hy na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="in io ip iq ir"><h2 id="3bf0" class="la lb iu bd lc ld le dn lf lg lh dp li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">最后一句话</h2><p id="6b2e" class="pw-post-body-paragraph lw lx iu ly b lz ma jv mb mc md jy me lj mf mg mh ln mi mj mk lr ml mm mn mo in bi translated"><code class="fe mp mq mr ms b">sort()</code>和<code class="fe mp mq mr ms b">orderBy()</code>功能均可用于对至少一列的火花数据帧进行排序，排序顺序为任意顺序，即升序或降序。</p><p id="7d1e" class="pw-post-body-paragraph lw lx iu ly b lz mt jv mb mc mu jy me lj mv mg mh ln mw mj mk lr mx mm mn mo in bi translated"><code class="fe mp mq mr ms b">sort()</code>比<code class="fe mp mq mr ms b">orderBy()</code>更有效，因为数据在每个分区上单独排序，这就是为什么输出数据的顺序不能保证。</p><p id="0f8a" class="pw-post-body-paragraph lw lx iu ly b lz mt jv mb mc mu jy me lj mv mg mh ln mw mj mk lr mx mm mn mo in bi translated">另一方面，<code class="fe mp mq mr ms b">orderBy()</code>将所有数据收集到一个执行器中，然后对它们进行排序。这意味着输出数据的顺序得到保证，但这可能是一个非常昂贵的操作。</p><p id="40dd" class="pw-post-body-paragraph lw lx iu ly b lz mt jv mb mc mu jy me lj mv mg mh ln mw mj mk lr mx mm mn mo in bi translated">因此，如果您需要对顺序不太重要的数据帧进行排序，同时您希望它尽可能快，那么<code class="fe mp mq mr ms b">sort()</code>更合适。如果顺序很重要，确保使用<code class="fe mp mq mr ms b">orderBy()</code>来保证输出数据根据用户参数排序。</p></div><div class="ab cl my mz hy na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="in io ip iq ir"><h2 id="29a9" class="la lb iu bd lc ld le dn lf lg lh dp li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">你可能也喜欢</h2><div class="no np gq gs nq nr"><a rel="noopener follow" target="_blank" href="/distinct-vs-dropduplicates-in-spark-3e28af1f793c"><div class="ns ab fp"><div class="nt ab nu cl cj nv"><h2 class="bd iv gz z fq nw fs ft nx fv fx it bi translated">Spark中的distinct()与dropDuplicates()</h2><div class="ny l"><h3 class="bd b gz z fq nw fs ft nx fv fx dk translated">Spark中distinct()和dropDuplicates()有什么区别？</h3></div><div class="nz l"><p class="bd b dl z fq nw fs ft nx fv fx dk translated">towardsdatascience.com</p></div></div><div class="oa l"><div class="ob l oc od oe oa of kt nr"/></div></div></a></div><div class="no np gq gs nq nr"><a rel="noopener follow" target="_blank" href="/sparksession-vs-sparkcontext-vs-sqlcontext-vs-hivecontext-741d50c9486a"><div class="ns ab fp"><div class="nt ab nu cl cj nv"><h2 class="bd iv gz z fq nw fs ft nx fv fx it bi translated">spark session vs spark context vs SQLContext vs hive context</h2><div class="ny l"><h3 class="bd b gz z fq nw fs ft nx fv fx dk translated">SparkSession、SparkContext HiveContext和SQLContext有什么区别？</h3></div><div class="nz l"><p class="bd b dl z fq nw fs ft nx fv fx dk translated">towardsdatascience.com</p></div></div><div class="oa l"><div class="og l oc od oe oa of kt nr"/></div></div></a></div><div class="no np gq gs nq nr"><a rel="noopener follow" target="_blank" href="/how-to-efficiently-re-partition-spark-dataframes-c036e8261418"><div class="ns ab fp"><div class="nt ab nu cl cj nv"><h2 class="bd iv gz z fq nw fs ft nx fv fx it bi translated">如何有效地重新划分火花数据帧</h2><div class="ny l"><h3 class="bd b gz z fq nw fs ft nx fv fx dk translated">如何增加或减少火花数据帧的数量</h3></div><div class="nz l"><p class="bd b dl z fq nw fs ft nx fv fx dk translated">towardsdatascience.com</p></div></div><div class="oa l"><div class="oh l oc od oe oa of kt nr"/></div></div></a></div></div></div>    
</body>
</html>