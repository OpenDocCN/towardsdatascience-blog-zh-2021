<html>
<head>
<title>An Overview of the scikit-learn Clustering Package</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">scikit-learn 集群包概述</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/an-overview-of-the-scikit-learn-clustering-package-d39a0499814?source=collection_archive---------23-----------------------#2021-11-23">https://towardsdatascience.com/an-overview-of-the-scikit-learn-clustering-package-d39a0499814?source=collection_archive---------23-----------------------#2021-11-23</a></blockquote><div><div class="fc ik il im in io"/><div class="ip iq ir is it"><h2 id="c6d2" class="iu iv iw bd b dl ix iy iz ja jb jc dk jd translated" aria-label="kicker paragraph">机器学习</h2><div class=""/><div class=""><h2 id="b7c6" class="pw-subtitle-paragraph kc jf iw bd b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt dk translated">scikit-learn 系列的第二集，解释了用于机器学习的著名 Python 库</h2></div><figure class="kv kw kx ky gu kz gi gj paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="gi gj ku"><img src="../Images/f635d4472addc909ff17aaef23490cc4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RfpD9c8z224J2qCRPR1y_g.jpeg"/></div></div><p class="lg lh gk gi gj li lj bd b be z dk translated">作者图片</p></figure><p id="5dbb" class="pw-post-body-paragraph lk ll iw lm b ln lo kg lp lq lr kj ls lt lu lv lw lx ly lz ma mb mc md me mf ip bi translated">聚类是一种无监督的机器学习技术，其中既没有训练集，也没有预定义的类。当有许多记录时使用聚类，这些记录应该根据相似性标准(如距离)进行分组。</p><p id="de19" class="pw-post-body-paragraph lk ll iw lm b ln lo kg lp lq lr kj ls lt lu lv lw lx ly lz ma mb mc md me mf ip bi translated"><strong class="lm jg">聚类算法将数据集作为输入，并返回标签列表作为输出，这些标签对应于相关的聚类。</strong></p><p id="d19e" class="pw-post-body-paragraph lk ll iw lm b ln lo kg lp lq lr kj ls lt lu lv lw lx ly lz ma mb mc md me mf ip bi translated">聚类分析是一个迭代过程，其中，在每一步，当前迭代被评估，并被用于反馈到下一次迭代中对算法的改变，直到获得期望的结果。</p><p id="2062" class="pw-post-body-paragraph lk ll iw lm b ln lo kg lp lq lr kj ls lt lu lv lw lx ly lz ma mb mc md me mf ip bi translated">scikit-learn 库提供了一个名为<code class="fe mg mh mi mj b"><a class="ae mk" href="https://scikit-learn.org/stable/modules/classes.html#module-sklearn.cluster" rel="noopener ugc nofollow" target="_blank">sklearn.cluster</a></code>的子包，它提供了最常见的聚类算法。</p><p id="546e" class="pw-post-body-paragraph lk ll iw lm b ln lo kg lp lq lr kj ls lt lu lv lw lx ly lz ma mb mc md me mf ip bi translated">在这篇文章中，我描述了:</p><ul class=""><li id="2c0d" class="ml mm iw lm b ln lo lq lr lt mn lx mo mb mp mf mq mr ms mt bi translated"><code class="fe mg mh mi mj b">sklearn.cluster</code>提供的类和功能</li><li id="7405" class="ml mm iw lm b ln mu lq mv lt mw lx mx mb my mf mq mr ms mt bi translated">调谐参数</li><li id="a978" class="ml mm iw lm b ln mu lq mv lt mw lx mx mb my mf mq mr ms mt bi translated">聚类算法的评价指标</li></ul><h1 id="630e" class="mz na iw bd nb nc nd ne nf ng nh ni nj kl nk km nl ko nm kp nn kr no ks np nq bi translated">1 类和功能</h1><p id="cd08" class="pw-post-body-paragraph lk ll iw lm b ln nr kg lp lq ns kj ls lt nt lv lw lx nu lz ma mb nv md me mf ip bi translated"><code class="fe mg mh mi mj b">sklearn.cluster</code>子包定义了两种应用聚类算法的方式:类和函数。</p><h2 id="d705" class="nw na iw bd nb nx ny dn nf nz oa dp nj lt ob oc nl lx od oe nn mb of og np jc bi translated">1.1 类别</h2><p id="f03d" class="pw-post-body-paragraph lk ll iw lm b ln nr kg lp lq ns kj ls lt nt lv lw lx nu lz ma mb nv md me mf ip bi translated">在类策略中，您应该通过指定类参数来创建所需聚类类算法的实例。然后用数据拟合算法，最后，可以使用拟合的模型来预测分类:</p><pre class="kv kw kx ky gu oh mj oi oj aw ok bi"><span id="9c95" class="nw na iw mj b gz ol om l on oo"><strong class="mj jg">from</strong> <strong class="mj jg">sklearn.cluster</strong> <strong class="mj jg">import</strong> AffinityPropagation</span><span id="d9a7" class="nw na iw mj b gz op om l on oo">model = AffinityPropagation()<br/>model.fit(X)<br/>labels = model.predict(X)</span></pre><h2 id="47b0" class="nw na iw bd nb nx ny dn nf nz oa dp nj lt ob oc nl lx od oe nn mb of og np jc bi translated">1.2 功能</h2><p id="a6d4" class="pw-post-body-paragraph lk ll iw lm b ln nr kg lp lq ns kj ls lt nt lv lw lx nu lz ma mb nv md me mf ip bi translated">除了类定义之外，Scikit-learn 还提供了执行模型拟合的函数。关于类，当只有一个数据集时，可以使用函数，该数据集必须在一个点上只分析一次。</p><p id="4c17" class="pw-post-body-paragraph lk ll iw lm b ln lo kg lp lq lr kj ls lt lu lv lw lx ly lz ma mb mc md me mf ip bi translated">在这种情况下，调用函数就足够了，以便获得集群化的数据:</p><pre class="kv kw kx ky gu oh mj oi oj aw ok bi"><span id="7146" class="nw na iw mj b gz ol om l on oo"><strong class="mj jg">from</strong> <strong class="mj jg">sklearn.cluster</strong> <strong class="mj jg">import </strong>affinity_propagation</span><span id="fa96" class="nw na iw mj b gz op om l on oo">result = affinity_propagatiom(X)</span></pre><h1 id="4884" class="mz na iw bd nb nc nd ne nf ng nh ni nj kl nk km nl ko nm kp nn kr no ks np nq bi translated">2 个调谐参数</h1><p id="ea96" class="pw-post-body-paragraph lk ll iw lm b ln nr kg lp lq ns kj ls lt nt lv lw lx nu lz ma mb nv md me mf ip bi translated">根据要调整的主要参数，聚类算法可以分为两大类:</p><ul class=""><li id="d257" class="ml mm iw lm b ln lo lq lr lt mn lx mo mb mp mf mq mr ms mt bi translated">要在数据中发现的聚类数</li><li id="1816" class="ml mm iw lm b ln mu lq mv lt mw lx mx mb my mf mq mr ms mt bi translated">观测值之间的最小距离。</li></ul><h2 id="97ba" class="nw na iw bd nb nx ny dn nf nz oa dp nj lt ob oc nl lx od oe nn mb of og np jc bi translated">2.1 要发现的集群数量</h2><p id="7fd3" class="pw-post-body-paragraph lk ll iw lm b ln nr kg lp lq ns kj ls lt nt lv lw lx nu lz ma mb nv md me mf ip bi translated">通常，在这组聚类算法中，<strong class="lm jg">你至少要调优最大数量的聚类才能找到</strong>。在<code class="fe mg mh mi mj b">scikit-learn</code>中，通常这个参数被称为<code class="fe mg mh mi mj b">n_clusters</code>。</p><p id="2d4e" class="pw-post-body-paragraph lk ll iw lm b ln lo kg lp lq lr kj ls lt lu lv lw lx ly lz ma mb mc md me mf ip bi translated"><code class="fe mg mh mi mj b">sklearn.cluster</code>包提供了以下属于该类别的聚类算法(为每个提供的算法显示了类和函数):</p><ul class=""><li id="8ba6" class="ml mm iw lm b ln lo lq lr lt mn lx mo mb mp mf mq mr ms mt bi translated"><code class="fe mg mh mi mj b"><a class="ae mk" href="https://scikit-learn.org/stable/modules/generated/sklearn.cluster.AgglomerativeClustering.html#sklearn.cluster.AgglomerativeClustering" rel="noopener ugc nofollow" target="_blank"><strong class="lm jg">AgglomerativeClustering</strong></a></code></li><li id="7c2e" class="ml mm iw lm b ln mu lq mv lt mw lx mx mb my mf mq mr ms mt bi translated"><code class="fe mg mh mi mj b"><a class="ae mk" href="https://scikit-learn.org/stable/modules/generated/sklearn.cluster.Birch.html#sklearn.cluster.Birch" rel="noopener ugc nofollow" target="_blank"><strong class="lm jg">Birch</strong></a></code></li><li id="9d5e" class="ml mm iw lm b ln mu lq mv lt mw lx mx mb my mf mq mr ms mt bi translated"><code class="fe mg mh mi mj b"><a class="ae mk" href="https://scikit-learn.org/stable/modules/generated/sklearn.cluster.FeatureAgglomeration.html#sklearn.cluster.FeatureAgglomeration" rel="noopener ugc nofollow" target="_blank"><strong class="lm jg">FeatureAgglomeration</strong></a></code></li><li id="2087" class="ml mm iw lm b ln mu lq mv lt mw lx mx mb my mf mq mr ms mt bi translated"><code class="fe mg mh mi mj b"><a class="ae mk" href="https://scikit-learn.org/stable/modules/generated/sklearn.cluster.KMeans.html#sklearn.cluster.KMeans" rel="noopener ugc nofollow" target="_blank"><strong class="lm jg">KMeans</strong></a></code><strong class="lm jg">/</strong>T4】</li><li id="513e" class="ml mm iw lm b ln mu lq mv lt mw lx mx mb my mf mq mr ms mt bi translated"><code class="fe mg mh mi mj b"><a class="ae mk" href="https://scikit-learn.org/stable/modules/generated/sklearn.cluster.MiniBatchKMeans.html#sklearn.cluster.MiniBatchKMeans" rel="noopener ugc nofollow" target="_blank"><strong class="lm jg">MiniBatchKMeans</strong></a></code></li><li id="5625" class="ml mm iw lm b ln mu lq mv lt mw lx mx mb my mf mq mr ms mt bi translated"><code class="fe mg mh mi mj b"><a class="ae mk" href="https://scikit-learn.org/stable/modules/generated/sklearn.cluster.SpectralClustering.html#sklearn.cluster.SpectralClustering" rel="noopener ugc nofollow" target="_blank"><strong class="lm jg">SpectralClustering</strong></a></code><strong class="lm jg">/</strong>T7】</li><li id="689d" class="ml mm iw lm b ln mu lq mv lt mw lx mx mb my mf mq mr ms mt bi translated"><code class="fe mg mh mi mj b"><a class="ae mk" href="https://scikit-learn.org/stable/modules/generated/sklearn.cluster.SpectralBiclustering.html#sklearn.cluster.SpectralBiclustering" rel="noopener ugc nofollow" target="_blank"><strong class="lm jg">SpectralBiclustering</strong></a></code></li><li id="885a" class="ml mm iw lm b ln mu lq mv lt mw lx mx mb my mf mq mr ms mt bi translated"><code class="fe mg mh mi mj b"><a class="ae mk" href="https://scikit-learn.org/stable/modules/generated/sklearn.cluster.SpectralCoclustering.html#sklearn.cluster.SpectralCoclustering" rel="noopener ugc nofollow" target="_blank"><strong class="lm jg">SpectralCoclustering</strong></a></code></li></ul><p id="fd55" class="pw-post-body-paragraph lk ll iw lm b ln lo kg lp lq lr kj ls lt lu lv lw lx ly lz ma mb mc md me mf ip bi translated">对于这类算法，主要的问题是找到最佳的聚类数。可以使用不同的方法，例如<strong class="lm jg">弯头法。</strong></p><p id="7fba" class="pw-post-body-paragraph lk ll iw lm b ln lo kg lp lq lr kj ls lt lu lv lw lx ly lz ma mb mc md me mf ip bi translated">在肘形法中，计算并绘制出数量不断增加的聚类的<em class="oq">平方和</em>(例如从 1 到 20)。最佳的聚类数对应于斜率像弯头一样变化的点。</p><p id="750f" class="pw-post-body-paragraph lk ll iw lm b ln lo kg lp lq lr kj ls lt lu lv lw lx ly lz ma mb mc md me mf ip bi translated">存在许多其他技术来计算最佳聚类数。<a class="or os ep" href="https://medium.com/u/459e62b88a2a?source=post_page-----d39a0499814--------------------------------" rel="noopener" target="_blank"> Matt.0 </a>在他的一篇非常有趣的文章中阐述了它们，这篇文章名为<a class="ae mk" rel="noopener" target="_blank" href="/10-tips-for-choosing-the-optimal-number-of-clusters-277e93d72d92">选择最佳聚类数的 10 个技巧</a>。</p><h2 id="d46e" class="nw na iw bd nb nx ny dn nf nz oa dp nj lt ob oc nl lx od oe nn mb of og np jc bi translated">2.2 观测值之间的最小距离</h2><p id="c117" class="pw-post-body-paragraph lk ll iw lm b ln nr kg lp lq ns kj ls lt nt lv lw lx nu lz ma mb nv md me mf ip bi translated">在这类聚类算法中，最重要的调整参数是<strong class="lm jg">距离。</strong>在 scikit-learn 中，与距离相关的参数名称取决于算法。因此，我建议阅读与所选算法相关的文档，以发现距离参数的确切名称。</p><p id="784d" class="pw-post-body-paragraph lk ll iw lm b ln lo kg lp lq lr kj ls lt lu lv lw lx ly lz ma mb mc md me mf ip bi translated"><code class="fe mg mh mi mj b">sklearn.cluster</code>包提供了以下属于这个类别的聚类算法(括号中是距离参数的名称):</p><ul class=""><li id="3e86" class="ml mm iw lm b ln lo lq lr lt mn lx mo mb mp mf mq mr ms mt bi translated"><code class="fe mg mh mi mj b"><a class="ae mk" href="https://scikit-learn.org/stable/modules/generated/sklearn.cluster.AffinityPropagation.html#sklearn.cluster.AffinityPropagation" rel="noopener ugc nofollow" target="_blank"><strong class="lm jg">AffinityPropagation</strong></a><strong class="lm jg">(damping)</strong></code><strong class="lm jg">/</strong>T2】</li><li id="4888" class="ml mm iw lm b ln mu lq mv lt mw lx mx mb my mf mq mr ms mt bi translated"><code class="fe mg mh mi mj b"><a class="ae mk" href="https://scikit-learn.org/stable/modules/generated/sklearn.cluster.DBSCAN.html#sklearn.cluster.DBSCAN" rel="noopener ugc nofollow" target="_blank"><strong class="lm jg">DBSCAN</strong></a><strong class="lm jg">(eps)</strong></code><strong class="lm jg">/</strong>T4】</li><li id="563c" class="ml mm iw lm b ln mu lq mv lt mw lx mx mb my mf mq mr ms mt bi translated"><code class="fe mg mh mi mj b"><a class="ae mk" href="https://scikit-learn.org/stable/modules/generated/sklearn.cluster.MeanShift.html#sklearn.cluster.MeanShift" rel="noopener ugc nofollow" target="_blank"><strong class="lm jg">MeanShift</strong></a><strong class="lm jg">(bandwidth)</strong></code> <strong class="lm jg"> / </strong> <code class="fe mg mh mi mj b"><strong class="lm jg">mean_shift()</strong></code></li><li id="722e" class="ml mm iw lm b ln mu lq mv lt mw lx mx mb my mf mq mr ms mt bi translated"><code class="fe mg mh mi mj b"><a class="ae mk" href="https://scikit-learn.org/stable/modules/generated/sklearn.cluster.OPTICS.html#sklearn.cluster.OPTICS" rel="noopener ugc nofollow" target="_blank"><strong class="lm jg">OPTICS</strong></a><strong class="lm jg">(max_eps)</strong></code><strong class="lm jg">/</strong><code class="fe mg mh mi mj b"><strong class="lm jg">cluster_optics_xi()</strong></code><strong class="lm jg">——</strong><code class="fe mg mh mi mj b"><strong class="lm jg">cluster_optics_dbscan()</strong></code></li></ul><p id="03db" class="pw-post-body-paragraph lk ll iw lm b ln lo kg lp lq lr kj ls lt lu lv lw lx ly lz ma mb mc md me mf ip bi translated">这类聚类算法的主要挑战是找到最佳距离值。一种可能的解决方案是用不同的距离值测试算法，并选择与最佳性能相关联的值。</p><h1 id="d4c3" class="mz na iw bd nb nc nd ne nf ng nh ni nj kl nk km nl ko nm kp nn kr no ks np nq bi translated">3 项评估指标</h1><p id="3a2f" class="pw-post-body-paragraph lk ll iw lm b ln nr kg lp lq ns kj ls lt nt lv lw lx nu lz ma mb nv md me mf ip bi translated"><code class="fe mg mh mi mj b"><a class="ae mk" href="https://scikit-learn.org/stable/modules/classes.html#module-sklearn.metrics.cluster" rel="noopener ugc nofollow" target="_blank">sklearn.metrics.cluster</a></code>子包包含了用于评估聚类分析的指标。</p><p id="a13e" class="pw-post-body-paragraph lk ll iw lm b ln lo kg lp lq lr kj ls lt lu lv lw lx ly lz ma mb mc md me mf ip bi translated">评估聚类算法的性能并不是一件容易的事情，因为<strong class="lm jg">它应该验证每条记录都被分配了正确的聚类</strong> r，即每条记录与属于其聚类的记录的相似度要比与属于其他聚类的记录的相似度高得多。</p><p id="94dc" class="pw-post-body-paragraph lk ll iw lm b ln lo kg lp lq lr kj ls lt lu lv lw lx ly lz ma mb mc md me mf ip bi translated">关于集群评估的更多细节可以在<a class="ae mk" href="https://www.sciencedirect.com/topics/computer-science/clustering-quality" rel="noopener ugc nofollow" target="_blank">这篇有趣的文章</a>中找到。</p><p id="7064" class="pw-post-body-paragraph lk ll iw lm b ln lo kg lp lq lr kj ls lt lu lv lw lx ly lz ma mb mc md me mf ip bi translated">有两种评价:</p><ul class=""><li id="28f8" class="ml mm iw lm b ln lo lq lr lt mn lx mo mb mp mf mq mr ms mt bi translated">基于监督的评估</li><li id="c448" class="ml mm iw lm b ln mu lq mv lt mw lx mx mb my mf mq mr ms mt bi translated">基于无监督的评估</li></ul><h2 id="af99" class="nw na iw bd nb nx ny dn nf nz oa dp nj lt ob oc nl lx od oe nn mb of og np jc bi translated">3.1 基于监督的评估</h2><p id="4967" class="pw-post-body-paragraph lk ll iw lm b ln nr kg lp lq ns kj ls lt nt lv lw lx nu lz ma mb nv md me mf ip bi translated">基于监督的方法(也称为<strong class="lm jg">外在方法</strong>)利用<strong class="lm jg">基础事实</strong>来执行评估。其思想是将基本事实与聚类算法的结果进行比较，以计算得分。</p><p id="7427" class="pw-post-body-paragraph lk ll iw lm b ln lo kg lp lq lr kj ls lt lu lv lw lx ly lz ma mb mc md me mf ip bi translated">Scikit-learn 提供以下基于监督的方法:</p><ul class=""><li id="fa22" class="ml mm iw lm b ln lo lq lr lt mn lx mo mb mp mf mq mr ms mt bi translated"><code class="fe mg mh mi mj b"><a class="ae mk" href="https://scikit-learn.org/stable/modules/generated/sklearn.metrics.adjusted_mutual_info_score.html#sklearn.metrics.adjusted_mutual_info_score" rel="noopener ugc nofollow" target="_blank"><strong class="lm jg">adjusted_mutual_info_score</strong></a></code></li><li id="6523" class="ml mm iw lm b ln mu lq mv lt mw lx mx mb my mf mq mr ms mt bi translated"><code class="fe mg mh mi mj b"><a class="ae mk" href="https://scikit-learn.org/stable/modules/generated/sklearn.metrics.adjusted_rand_score.html#sklearn.metrics.adjusted_rand_score" rel="noopener ugc nofollow" target="_blank"><strong class="lm jg">adjusted_rand_score</strong></a></code></li><li id="e6aa" class="ml mm iw lm b ln mu lq mv lt mw lx mx mb my mf mq mr ms mt bi translated"><code class="fe mg mh mi mj b"><a class="ae mk" href="https://scikit-learn.org/stable/modules/generated/sklearn.metrics.completeness_score.html#sklearn.metrics.completeness_score" rel="noopener ugc nofollow" target="_blank"><strong class="lm jg">completeness_score</strong></a></code></li><li id="3021" class="ml mm iw lm b ln mu lq mv lt mw lx mx mb my mf mq mr ms mt bi translated"><code class="fe mg mh mi mj b"><a class="ae mk" href="https://scikit-learn.org/stable/modules/generated/sklearn.metrics.fowlkes_mallows_score.html#sklearn.metrics.fowlkes_mallows_score" rel="noopener ugc nofollow" target="_blank"><strong class="lm jg">fowlkes_mallows_score</strong></a></code></li><li id="e5cf" class="ml mm iw lm b ln mu lq mv lt mw lx mx mb my mf mq mr ms mt bi translated"><code class="fe mg mh mi mj b"><a class="ae mk" href="https://scikit-learn.org/stable/modules/generated/sklearn.metrics.homogeneity_score.html#sklearn.metrics.homogeneity_score" rel="noopener ugc nofollow" target="_blank"><strong class="lm jg">homogeneity_score</strong></a></code></li><li id="083e" class="ml mm iw lm b ln mu lq mv lt mw lx mx mb my mf mq mr ms mt bi translated"><code class="fe mg mh mi mj b"><a class="ae mk" href="https://scikit-learn.org/stable/modules/generated/sklearn.metrics.mutual_info_score.html#sklearn.metrics.mutual_info_score" rel="noopener ugc nofollow" target="_blank"><strong class="lm jg">mutual_info_score</strong></a></code></li><li id="a820" class="ml mm iw lm b ln mu lq mv lt mw lx mx mb my mf mq mr ms mt bi translated"><code class="fe mg mh mi mj b"><a class="ae mk" href="https://scikit-learn.org/stable/modules/generated/sklearn.metrics.normalized_mutual_info_score.html#sklearn.metrics.normalized_mutual_info_score" rel="noopener ugc nofollow" target="_blank"><strong class="lm jg">normalized_mutual_info_score</strong></a></code></li><li id="9c17" class="ml mm iw lm b ln mu lq mv lt mw lx mx mb my mf mq mr ms mt bi translated"><code class="fe mg mh mi mj b"><a class="ae mk" href="https://scikit-learn.org/stable/modules/generated/sklearn.metrics.rand_score.html#sklearn.metrics.rand_score" rel="noopener ugc nofollow" target="_blank"><strong class="lm jg">rand_score</strong></a></code></li></ul><p id="efa3" class="pw-post-body-paragraph lk ll iw lm b ln lo kg lp lq lr kj ls lt lu lv lw lx ly lz ma mb mc md me mf ip bi translated">对于所有前面的函数，您应该至少提供两个参数:<code class="fe mg mh mi mj b">labels_true</code>(地面真实类标签)和<code class="fe mg mh mi mj b">labels_pred</code>(要评估的聚类标签)。</p><h2 id="22e1" class="nw na iw bd nb nx ny dn nf nz oa dp nj lt ob oc nl lx od oe nn mb of og np jc bi translated">3.2 基于无监督的评估</h2><p id="74b3" class="pw-post-body-paragraph lk ll iw lm b ln nr kg lp lq ns kj ls lt nt lv lw lx nu lz ma mb nv md me mf ip bi translated">基于非监督的方法(也称为内在方法)通过分析分类的分离程度和分类的紧密程度来评估聚类算法。</p><p id="5ad0" class="pw-post-body-paragraph lk ll iw lm b ln lo kg lp lq lr kj ls lt lu lv lw lx ly lz ma mb mc md me mf ip bi translated">Scikit-learn 为聚类评估提供了以下固有方法:</p><ul class=""><li id="c718" class="ml mm iw lm b ln lo lq lr lt mn lx mo mb mp mf mq mr ms mt bi translated"><code class="fe mg mh mi mj b"><a class="ae mk" href="https://scikit-learn.org/stable/modules/generated/sklearn.metrics.calinski_harabasz_score.html#sklearn.metrics.calinski_harabasz_score" rel="noopener ugc nofollow" target="_blank"><strong class="lm jg">calinski_harabasz_score</strong></a></code></li><li id="6119" class="ml mm iw lm b ln mu lq mv lt mw lx mx mb my mf mq mr ms mt bi translated"><code class="fe mg mh mi mj b"><a class="ae mk" href="https://scikit-learn.org/stable/modules/generated/sklearn.metrics.davies_bouldin_score.html#sklearn.metrics.davies_bouldin_score" rel="noopener ugc nofollow" target="_blank"><strong class="lm jg">davies_bouldin_score</strong></a></code></li><li id="592e" class="ml mm iw lm b ln mu lq mv lt mw lx mx mb my mf mq mr ms mt bi translated"><code class="fe mg mh mi mj b"><a class="ae mk" href="https://scikit-learn.org/stable/modules/generated/sklearn.metrics.silhouette_score.html#sklearn.metrics.silhouette_score" rel="noopener ugc nofollow" target="_blank"><strong class="lm jg">silhouette_score</strong></a></code></li><li id="f2bd" class="ml mm iw lm b ln mu lq mv lt mw lx mx mb my mf mq mr ms mt bi translated"><code class="fe mg mh mi mj b"><a class="ae mk" href="https://scikit-learn.org/stable/modules/generated/sklearn.metrics.v_measure_score.html#sklearn.metrics.v_measure_score" rel="noopener ugc nofollow" target="_blank"><strong class="lm jg">v_measure_score</strong></a></code></li></ul><p id="fe93" class="pw-post-body-paragraph lk ll iw lm b ln lo kg lp lq lr kj ls lt lu lv lw lx ly lz ma mb mc md me mf ip bi translated">这类函数至少接受两个参数作为输入:<code class="fe mg mh mi mj b">X</code>(样本之间成对距离的数组)和<code class="fe mg mh mi mj b">labels</code>(每个样本的标签值)。</p><h1 id="ec8f" class="mz na iw bd nb nc nd ne nf ng nh ni nj kl nk km nl ko nm kp nn kr no ks np nq bi translated">摘要</h1><p id="eb0c" class="pw-post-body-paragraph lk ll iw lm b ln nr kg lp lq ns kj ls lt nt lv lw lx nu lz ma mb nv md me mf ip bi translated">在本文中，我描述了由 Scikit-learn 库提供的 sklearn.cluster 子包，以及用于评估集群算法质量的评估指标。</p><p id="ae6f" class="pw-post-body-paragraph lk ll iw lm b ln lo kg lp lq lr kj ls lt lu lv lw lx ly lz ma mb mc md me mf ip bi translated">有关集群的更多信息，您可以阅读<a class="ae mk" href="https://scikit-learn.org/stable/modules/clustering.html#clustering" rel="noopener ugc nofollow" target="_blank"> Scikit-learn 官方文档</a>。</p><p id="e2bc" class="pw-post-body-paragraph lk ll iw lm b ln lo kg lp lq lr kj ls lt lu lv lw lx ly lz ma mb mc md me mf ip bi translated">如果你想发现 Scikit-learn 提供的其他类和函数，你可以<a class="ae mk" href="https://alod83.medium.com/" rel="noopener">关注我</a>、<a class="ae mk" href="https://alod83.medium.com/subscribe" rel="noopener">订阅我的邮件列表</a>，敬请关注。</p><p id="d078" class="pw-post-body-paragraph lk ll iw lm b ln lo kg lp lq lr kj ls lt lu lv lw lx ly lz ma mb mc md me mf ip bi translated">如果你已经走了这么远来阅读，对我来说今天已经很多了。谢谢！你可以在<a class="ae mk" href="https://alod83.medium.com/which-topics-would-you-like-to-read-c68314dc6813" rel="noopener">这篇文章</a>里读到更多关于我的内容。</p><h1 id="64c7" class="mz na iw bd nb nc nd ne nf ng nh ni nj kl nk km nl ko nm kp nn kr no ks np nq bi translated">相关文章</h1><div class="ot ou gq gs ov ow"><a rel="noopener follow" target="_blank" href="/an-overview-of-the-scikit-learn-library-episode-1-preprocessing-9b17ab4dde4f"><div class="ox ab fp"><div class="oy ab oz cl cj pa"><h2 class="bd jg gz z fq pb fs ft pc fv fx jf bi translated">Scikit-learn 库概述—第 1 集预处理</h2><div class="pd l"><h3 class="bd b gz z fq pb fs ft pc fv fx dk translated">著名的用于机器学习的 Python 库的剧集中的描述。第一集讲的是…</h3></div><div class="pe l"><p class="bd b dl z fq pb fs ft pc fv fx dk translated">towardsdatascience.com</p></div></div><div class="pf l"><div class="pg l ph pi pj pf pk le ow"/></div></div></a></div><div class="ot ou gq gs ov ow"><a rel="noopener follow" target="_blank" href="/how-to-improve-the-performance-of-a-supervised-machine-learning-algorithm-c9f9f2705a5c"><div class="ox ab fp"><div class="oy ab oz cl cj pa"><h2 class="bd jg gz z fq pb fs ft pc fv fx jf bi translated">如何提高(监督)机器学习算法的性能</h2><div class="pd l"><h3 class="bd b gz z fq pb fs ft pc fv fx dk translated">如今，每个数据科学家都能够编写代码来训练机器学习算法:加载一个代码就足够了</h3></div><div class="pe l"><p class="bd b dl z fq pb fs ft pc fv fx dk translated">towardsdatascience.com</p></div></div><div class="pf l"><div class="pl l ph pi pj pf pk le ow"/></div></div></a></div><div class="ot ou gq gs ov ow"><a rel="noopener follow" target="_blank" href="/how-to-balance-a-dataset-in-python-36dff9d12704"><div class="ox ab fp"><div class="oy ab oz cl cj pa"><h2 class="bd jg gz z fq pb fs ft pc fv fx jf bi translated">如何在 Python 中平衡数据集</h2><div class="pd l"><h3 class="bd b gz z fq pb fs ft pc fv fx dk translated">本教程属于如何提高机器学习算法的性能系列。在本教程中，我…</h3></div><div class="pe l"><p class="bd b dl z fq pb fs ft pc fv fx dk translated">towardsdatascience.com</p></div></div><div class="pf l"><div class="pm l ph pi pj pf pk le ow"/></div></div></a></div></div></div>    
</body>
</html>