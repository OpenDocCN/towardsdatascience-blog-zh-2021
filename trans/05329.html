<html>
<head>
<title>PyOD: a Unified Python Library for Anomaly Detection</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">PyOD:用于异常检测的统一Python库</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/pyod-a-unified-python-library-for-anomaly-detection-3608ec1fe321?source=collection_archive---------8-----------------------#2021-05-11">https://towardsdatascience.com/pyod-a-unified-python-library-for-anomaly-detection-3608ec1fe321?source=collection_archive---------8-----------------------#2021-05-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d71c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用于异常检测机器学习任务的scikit-learn</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/697a5c9e7b53c5a8756496352e83206b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lZMilge-3nAvSeco3mc3tg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://www.flickr.com/photos/puliarfanita/" rel="noopener ugc nofollow" target="_blank">安妮塔·里泰诺尔</a>在<a class="ae ky" href="https://www.flickr.com/photos/puliarfanita/24860619467" rel="noopener ugc nofollow" target="_blank"> flickr </a>拍摄</p></figure><p id="4351" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b"><a class="ae ky" href="https://pyod.readthedocs.io/en/latest/index.html" rel="noopener ugc nofollow" target="_blank">PyOD</a></code>是一个Python库，具有一套全面的可扩展、最先进的(SOTA)算法，用于检测多元数据中的异常数据点。这项任务通常被称为<a class="ae ky" href="https://en.wikipedia.org/wiki/Anomaly_detection" rel="noopener ugc nofollow" target="_blank">异常检测</a>或<a class="ae ky" href="https://en.wikipedia.org/wiki/Anomaly_detection" rel="noopener ugc nofollow" target="_blank">异常检测</a>。</p><blockquote class="lz"><p id="9005" class="ma mb it bd mc md me mf mg mh mi lu dk translated"><em class="mj">异常值检测任务旨在识别偏离给定数据的“正常”或一般分布的罕见项目、事件或观察值。</em></p></blockquote><p id="b0bb" class="pw-post-body-paragraph kz la it lb b lc mk ju le lf ml jx lh li mm lk ll lm mn lo lp lq mo ls lt lu im bi translated">我最喜欢的定义:<strong class="lb iu">异常是指让人怀疑它是由不同的数据生成机制生成的</strong></p><p id="be67" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">离群点检测的常见应用包括欺诈检测、数据错误检测、网络安全中的入侵检测以及机械中的故障检测。</p><h1 id="5878" class="mp mq it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">为什么要使用特定的异常检测算法？</h1><p id="04a8" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">实际上，异常检测最好是作为一种无监督或半监督的任务，在这种情况下，您试图识别数据中的异常观察。</p><p id="2f7e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">离群值(异常数据)与内标值(正常数据)的标签通常不可用且难以获得。</strong>即使标签确实存在，它们通常也是不够的。一种异常可能只有少数几种标记。其他类型的异常可能以前从未发生过，因此您无法训练监督算法来发现它们。</p><p id="16c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">“离群值”的定义可能是主观的。</strong>什么被视为“异常”取决于应用，但它通常意味着数据错误或欺诈或犯罪活动。</p><p id="3660" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">专用的异常值检测算法提供了一种可靠地对大量未标记数据执行模式识别的方法。</p><div class="nm nn gp gr no np"><a href="https://pub.towardsai.net/why-outlier-detection-is-hard-94386578be6c" rel="noopener  ugc nofollow" target="_blank"><div class="nq ab fo"><div class="nr ab ns cl cj nt"><h2 class="bd iu gy z fp nu fr fs nv fu fw is bi translated">为什么异常值检测很难</h2><div class="nw l"><h3 class="bd b gy z fp nu fr fs nv fu fw dk translated">异常检测机器学习任务的考虑因素</h3></div><div class="nx l"><p class="bd b dl z fp nu fr fs nv fu fw dk translated">pub.towardsai.net</p></div></div><div class="ny l"><div class="nz l oa ob oc ny od ks np"/></div></div></a></div><h1 id="a036" class="mp mq it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated"><strong class="ak">关键</strong>特性</h1><p id="467c" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">PyOD拥有一套30多种检测算法，从隔离森林等经典算法到最新的深度学习方法，再到<a class="ae ky" rel="noopener" target="_blank" href="/fast-accurate-anomaly-detection-based-on-copulas-copod-3133ce9041fa"> COPOD </a> ( <a class="ae ky" href="https://arxiv.org/abs/2009.09463" rel="noopener ugc nofollow" target="_blank">论文</a>)等新兴算法。PyOD算法已经得到很好的确立，在文献中被大量引用，并且非常有用。</p><p id="a7e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">PyOD为所有算法、技术文档和示例提供了统一的API，易于使用。</p><h2 id="80a0" class="oe mq it bd mr of og dn mv oh oi dp mz li oj ok nb lm ol om nd lq on oo nf op bi translated">统一的API</h2><p id="12bf" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">所有探测器都用<code class="fe lv lw lx ly b">contamination</code>参数初始化。<code class="fe lv lw lx ly b">contamination</code>是数据中异常值的预期比例，用于在模型拟合期间设置异常值阈值。默认情况下，<code class="fe lv lw lx ly b">contamination=0.1</code>和必须在0和0.5之间。</p><p id="70a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">探测器具有以下功能:</p><ul class=""><li id="6226" class="oq or it lb b lc ld lf lg li os lm ot lq ou lu ov ow ox oy bi translated"><code class="fe lv lw lx ly b">fit(data)</code>:安装探测器。使用训练数据计算任何必要的统计数据。与<code class="fe lv lw lx ly b">scikit-learn</code>中的监督模型不同，<code class="fe lv lw lx ly b">PyOD</code>中的拟合方法不需要目标标签的<code class="fe lv lw lx ly b">y</code>参数。</li><li id="adcb" class="oq or it lb b lc oz lf pa li pb lm pc lq pd lu ov ow ox oy bi translated"><code class="fe lv lw lx ly b">decision_function(data)</code>:使用合适的检测器计算新数据的原始异常值。<em class="pe">(注意:一些探测器在没有预先安装的情况下仍然工作良好)</em></li><li id="9f0d" class="oq or it lb b lc oz lf pa li pb lm pc lq pd lu ov ow ox oy bi translated"><code class="fe lv lw lx ly b">predict(data)</code>:返回每个输入样本对应的二进制标签(离群/正常)。在底层，该函数将拟合步骤中生成的阈值应用于<code class="fe lv lw lx ly b">decision_function</code>返回的异常分数。</li><li id="7cb1" class="oq or it lb b lc oz lf pa li pb lm pc lq pd lu ov ow ox oy bi translated"><code class="fe lv lw lx ly b">predict_proba(data)</code>:使用标准化或统一化返回作为概率缩放的异常分数。</li></ul><p id="4600" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦安装，探测器包含属性<code class="fe lv lw lx ly b">decision_scores_</code>、<code class="fe lv lw lx ly b">labels_</code>和<code class="fe lv lw lx ly b">threshold_</code>。</p><ul class=""><li id="421d" class="oq or it lb b lc ld lf lg li os lm ot lq ou lu ov ow ox oy bi translated"><code class="fe lv lw lx ly b">decision_scores_ </code> —训练数据的异常值分数。分数越高，表明数据越不规则</li><li id="36a0" class="oq or it lb b lc oz lf pa li pb lm pc lq pd lu ov ow ox oy bi translated"><code class="fe lv lw lx ly b">threshold_</code> —根据拟合时初始化的<code class="fe lv lw lx ly b">contamination</code>确定阈值。它根据<code class="fe lv lw lx ly b">decision_scores_</code>中的<code class="fe lv lw lx ly b">n_samples * contamination</code>最高分数设定。</li><li id="5274" class="oq or it lb b lc oz lf pa li pb lm pc lq pd lu ov ow ox oy bi translated"><code class="fe lv lw lx ly b">labels_</code> —训练数据的二进制异常标签。0表示观察值是内部值，1表示外部值。它是通过将<code class="fe lv lw lx ly b">threshold_</code>应用于<code class="fe lv lw lx ly b">decision_scores_</code>而生成的。</li></ul><h2 id="f856" class="oe mq it bd mr of og dn mv oh oi dp mz li oj ok nb lm ol om nd lq on oo nf op bi translated">API演示</h2><p id="1deb" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">这里有一个API的快速说明。</p><p id="0b41" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，加载或生成异常值检测数据。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pf pg l"/></div></figure><p id="de55" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，我使用PyOD的<code class="fe lv lw lx ly b">generate_data</code>函数生成一个包含200个训练样本和100个测试样本的合成数据集。<em class="pe">正态样本由多元高斯分布生成；异常样本是使用均匀分布生成的。</em></p><p id="d53a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">训练和测试数据集都有5个特征，10%的行被标记为异常。我给数据添加了一点随机噪声，使其更难完美区分正常点和异常点。</p><p id="5de7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我对训练数据拟合ABOD(基于角度的离群点检测器),并对测试数据进行评估。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pf pg l"/></div></figure><p id="7caa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对相同的数据测试不同的PyOD算法很容易。在下一段代码中，我将展示如何训练和评估COPOD。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pf pg l"/></div></figure><p id="98d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在合成数据集上，COPOD比ABOD有更好的ROC-AUC精度分数。</p><h2 id="ff25" class="oe mq it bd mr of og dn mv oh oi dp mz li oj ok nb lm ol om nd lq on oo nf op bi translated">关于异常检测器评估的两点注意事项</h2><ol class=""><li id="337d" class="oq or it lb b lc nh lf ni li ph lm pi lq pj lu pk ow ox oy bi translated">如果没有任何基本事实标签(内层与外层)，就无法测量检测机的性能。</li><li id="3ea2" class="oq or it lb b lc oz lf pa li pb lm pc lq pd lu pk ow ox oy bi translated"><a class="ae ky" href="https://developers.google.com/machine-learning/crash-course/classification/roc-and-auc" rel="noopener ugc nofollow" target="_blank"> ROC-AUC </a>得分对于阈值选择是稳健的——如果AUC较高，则您的模型性能对您选择的阈值不太敏感。</li></ol><h1 id="96a7" class="mp mq it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">离群点检测算法的类型</h1><p id="aeaa" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">有几种异常值检测算法。这里介绍的分类法反映了PyOD分类法。</p><h2 id="ec9d" class="oe mq it bd mr of og dn mv oh oi dp mz li oj ok nb lm ol om nd lq on oo nf op bi translated">线性模型</h2><p id="d2a2" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">异常值检测的线性模型使用线性模型，如<a class="ae ky" href="https://en.wikipedia.org/wiki/Principal_component_analysis" rel="noopener ugc nofollow" target="_blank"> PCA </a>和<a class="ae ky" href="http://rvlasveld.github.io/blog/2013/07/12/introduction-to-one-class-support-vector-machines/" rel="noopener ugc nofollow" target="_blank">单类支持向量机</a>来分离正常和异常值观察值。</p><h2 id="d8b3" class="oe mq it bd mr of og dn mv oh oi dp mz li oj ok nb lm ol om nd lq on oo nf op bi translated">基于邻近的</h2><p id="ff53" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">用于离群点检测的基于邻近度的模型，例如K- <a class="ae ky" href="https://scikit-learn.org/stable/modules/neighbors.html" rel="noopener ugc nofollow" target="_blank">最近邻居</a>和<a class="ae ky" href="https://scikit-learn.org/stable/auto_examples/neighbors/plot_lof_outlier_detection.html?highlight=local%20outlier%20factor" rel="noopener ugc nofollow" target="_blank">局部离群因子</a>，使用数据点之间的距离来度量相似性。彼此高度接近的观察值更可能是正常的。距离较远的观测值更有可能是异常值</p><h2 id="dbe6" class="oe mq it bd mr of og dn mv oh oi dp mz li oj ok nb lm ol om nd lq on oo nf op bi translated">盖然论的</h2><p id="2567" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">异常值检测的概率模型依赖于统计分布来发现异常值。概率检测器包括<a class="ae ky" href="https://en.wikipedia.org/wiki/Median_absolute_deviation" rel="noopener ugc nofollow" target="_blank">中位数绝对偏差</a>(MAD)<a class="ae ky" rel="noopener" target="_blank" href="/fast-accurate-anomaly-detection-based-on-copulas-copod-3133ce9041fa">基于Copula的离群点检测</a> (COPOD)，以及<a class="ae ky" href="https://www.dbs.ifi.lmu.de/Publikationen/Papers/KDD2008.pdf" rel="noopener ugc nofollow" target="_blank">基于角度的离群点检测</a> (ABOD)。</p><h2 id="c23a" class="oe mq it bd mr of og dn mv oh oi dp mz li oj ok nb lm ol om nd lq on oo nf op bi translated">离群系综</h2><p id="c219" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">离群值集成依赖于模型集成来隔离离群点。算法包括<a class="ae ky" href="https://scikit-learn.org/stable/modules/generated/sklearn.ensemble.IsolationForest.html" rel="noopener ugc nofollow" target="_blank">隔离森林</a>(也有<code class="fe lv lw lx ly b">scikit-learn</code>)和<a class="ae ky" href="https://link.springer.com/content/pdf/10.1007%2Fs10994-015-5521-0.pdf" rel="noopener ugc nofollow" target="_blank"> LODA </a>(轻型异常在线检测器)。</p><h2 id="707d" class="oe mq it bd mr of og dn mv oh oi dp mz li oj ok nb lm ol om nd lq on oo nf op bi translated">神经网络</h2><p id="2bdb" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">神经网络也可以被训练来识别异常。</p><p id="5fae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://en.wikipedia.org/wiki/Autoencoder" rel="noopener ugc nofollow" target="_blank">自动编码器</a>(以及变化的自动编码器)网络架构可以被训练来识别异常，而无需标记实例。自动编码器学习压缩和重建数据中的信息。重建误差然后被用作异常分数。</p><p id="3f3c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最近，已经提出了几种用于异常检测的GAN架构(例如<a class="ae ky" href="https://pyod.readthedocs.io/en/latest/pyod.models.html#module-pyod.models.mo_gaal" rel="noopener ugc nofollow" target="_blank"> MO_GAAL </a>)。</p><h1 id="3a5a" class="mp mq it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">哪种算法最好？</h1><p id="ca7a" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">没有一种检测算法能统治所有人。不同的算法会做得更好，这取决于任务。</p><h2 id="4dfc" class="oe mq it bd mr of og dn mv oh oi dp mz li oj ok nb lm ol om nd lq on oo nf op bi translated">算法基准</h2><p id="9e7d" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">PyOD针对来自<a class="ae ky" href="http://odds.cs.stonybrook.edu/#table1" rel="noopener ugc nofollow" target="_blank"> ODDS </a>的17个异常检测基准数据集评估了其算法子集(10种方法)。</p><p id="2f42" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我从最新基准测试结果中得出的结论在PyOD <a class="ae ky" href="https://pyod.readthedocs.io/en/latest/benchmark.html" rel="noopener ugc nofollow" target="_blank">文档</a>中给出:</p><ul class=""><li id="949e" class="oq or it lb b lc ld lf lg li os lm ot lq ou lu ov ow ox oy bi translated"><strong class="lb iu">所有算法都快！</strong>即使是最大的数据集，运行时间也不超过1分钟(最长的数据集有49k行；最宽的数据集有274列)。</li><li id="c94a" class="oq or it lb b lc oz lf pa li pb lm pc lq pd lu ov ow ox oy bi translated"><strong class="lb iu">在一个数据集上表现很好的算法可能在另一个数据集上表现很差</strong>。例如，对于<code class="fe lv lw lx ly b">vowels</code>数据集，ABOD是第二好的检测器，但是对于<code class="fe lv lw lx ly b">musk</code>数据集，它是最差的检测器。</li></ul><h2 id="0afd" class="oe mq it bd mr of og dn mv oh oi dp mz li oj ok nb lm ol om nd lq on oo nf op bi translated">定制探测器套装</h2><p id="d231" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">构建更健壮的离群点检测模型(并且避免选择单个模型)的一种方法是将模型组合成定制的集成。这可以通过组合多个异常检测器的异常分数以及使用汇总分数对数据进行评分来完成。</p><p id="d3f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">PyOD为<code class="fe lv lw lx ly b"><a class="ae ky" href="https://pyod.readthedocs.io/en/latest/pyod.models.html#module-pyod.models.combination" rel="noopener ugc nofollow" target="_blank">pyod.models.combination</a></code>模块中的模型组合提供了几个实用功能:</p><ul class=""><li id="4a93" class="oq or it lb b lc ld lf lg li os lm ot lq ou lu ov ow ox oy bi translated"><code class="fe lv lw lx ly b"><a class="ae ky" href="https://pyod.readthedocs.io/en/latest/pyod.models.html#pyod.models.combination.average" rel="noopener ugc nofollow" target="_blank">average</a></code> —对集合中检测器的得分进行平均</li><li id="3028" class="oq or it lb b lc oz lf pa li pb lm pc lq pd lu ov ow ox oy bi translated"><code class="fe lv lw lx ly b"><a class="ae ky" href="https://pyod.readthedocs.io/en/latest/pyod.models.html#pyod.models.combination.maximization" rel="noopener ugc nofollow" target="_blank">maximization</a> </code> —集合中探测器的最高分</li><li id="841e" class="oq or it lb b lc oz lf pa li pb lm pc lq pd lu ov ow ox oy bi translated"><code class="fe lv lw lx ly b"><a class="ae ky" href="https://pyod.readthedocs.io/en/latest/pyod.models.html#pyod.models.combination.aom" rel="noopener ugc nofollow" target="_blank">aom</a></code>(最大值的平均值)—将基础检测器划分为子组，取每个子组的最大值，并对子组得分取平均值。</li><li id="33c7" class="oq or it lb b lc oz lf pa li pb lm pc lq pd lu ov ow ox oy bi translated"><code class="fe lv lw lx ly b"><a class="ae ky" href="https://pyod.readthedocs.io/en/latest/pyod.models.html#pyod.models.combination.moa" rel="noopener ugc nofollow" target="_blank">moa</a></code>(平均值的最大值)—将基本检测器分成子组，取每个子组的平均分数，并返回最大子组分数。</li><li id="af1b" class="oq or it lb b lc oz lf pa li pb lm pc lq pd lu ov ow ox oy bi translated"><code class="fe lv lw lx ly b"><a class="ae ky" href="https://pyod.readthedocs.io/en/latest/pyod.models.html#pyod.models.combination.majority_vote" rel="noopener ugc nofollow" target="_blank">majority_vote </a></code> —通过多数投票合并分数</li><li id="60aa" class="oq or it lb b lc oz lf pa li pb lm pc lq pd lu ov ow ox oy bi translated"><code class="fe lv lw lx ly b"><a class="ae ky" href="https://pyod.readthedocs.io/en/latest/pyod.models.html#pyod.models.combination.median" rel="noopener ugc nofollow" target="_blank">median</a></code> —来自集合中检测器的中值分数</li></ul><p id="dd1b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，异常分数在合并之前必须标准化，因为检测器不会返回相同级别的异常分数。</p><p id="3df8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">点击<a class="ae ky" href="https://pyod.readthedocs.io/en/latest/example.html" rel="noopener ugc nofollow" target="_blank">此处</a>查看探测器组合指南。</p><h1 id="89be" class="mp mq it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">想了解更多？</h1><p id="ffdb" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">如果您有兴趣了解更多关于异常检测的信息，请查看PyOD Github知识库的<a class="ae ky" href="https://github.com/yzhao062/anomaly-detection-resources" rel="noopener ugc nofollow" target="_blank">异常检测资源</a>页面。这个页面非常全面，并且随着新研究的发布而不断更新。</p><p id="0f71" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你喜欢这篇文章，你可能也会喜欢这些类似的帖子。</p><div class="nm nn gp gr no np"><a rel="noopener follow" target="_blank" href="/fast-accurate-anomaly-detection-based-on-copulas-copod-3133ce9041fa"><div class="nq ab fo"><div class="nr ab ns cl cj nt"><h2 class="bd iu gy z fp nu fr fs nv fu fw is bi translated">基于COPOD的快速准确异常检测</h2><div class="nx l"><p class="bd b dl z fp nu fr fs nv fu fw dk translated">towardsdatascience.com</p></div></div><div class="ny l"><div class="pl l oa ob oc ny od ks np"/></div></div></a></div><div class="nm nn gp gr no np"><a href="https://pub.towardsai.net/an-in-depth-guide-to-local-outlier-factor-lof-for-outlier-detection-in-python-5a6f128e5871" rel="noopener  ugc nofollow" target="_blank"><div class="nq ab fo"><div class="nr ab ns cl cj nt"><h2 class="bd iu gy z fp nu fr fs nv fu fw is bi translated">Python中离群点检测的局部离群点因子(LOF)深度指南</h2><div class="nw l"><h3 class="bd b gy z fp nu fr fs nv fu fw dk translated">理论直觉、数学定义和实际代码示例</h3></div><div class="nx l"><p class="bd b dl z fp nu fr fs nv fu fw dk translated">pub.towardsai.net</p></div></div><div class="ny l"><div class="pm l oa ob oc ny od ks np"/></div></div></a></div><div class="nm nn gp gr no np"><a href="https://medium.com/geekculture/replace-outlier-detection-by-simple-statistics-with-ecod-f95a7d982f79" rel="noopener follow" target="_blank"><div class="nq ab fo"><div class="nr ab ns cl cj nt"><h2 class="bd iu gy z fp nu fr fs nv fu fw is bi translated">用ECOD简单统计取代异常值检测</h2><div class="nw l"><h3 class="bd b gy z fp nu fr fs nv fu fw dk translated">一种新的基于python的、简单的、无参数的、可解释的无监督异常检测方法</h3></div><div class="nx l"><p class="bd b dl z fp nu fr fs nv fu fw dk translated">medium.com</p></div></div><div class="ny l"><div class="pn l oa ob oc ny od ks np"/></div></div></a></div><div class="nm nn gp gr no np"><a rel="noopener follow" target="_blank" href="/sktime-a-unified-python-library-for-time-series-machine-learning-3c103c139a55"><div class="nq ab fo"><div class="nr ab ns cl cj nt"><h2 class="bd iu gy z fp nu fr fs nv fu fw is bi translated">Sktime:用于时间序列机器学习的统一Python库</h2><div class="nw l"><h3 class="bd b gy z fp nu fr fs nv fu fw dk translated">用于时间序列预测、分类和回归的“sklearn”</h3></div><div class="nx l"><p class="bd b dl z fp nu fr fs nv fu fw dk translated">towardsdatascience.com</p></div></div><div class="ny l"><div class="po l oa ob oc ny od ks np"/></div></div></a></div><h2 id="5edd" class="oe mq it bd mr of og dn mv oh oi dp mz li oj ok nb lm ol om nd lq on oo nf op bi translated">不是中等会员？今天就加入！</h2><div class="nm nn gp gr no np"><a href="https://alexandra-amidon.medium.com/membership" rel="noopener follow" target="_blank"><div class="nq ab fo"><div class="nr ab ns cl cj nt"><h2 class="bd iu gy z fp nu fr fs nv fu fw is bi translated">阅读亚历山德拉·阿米登(以及媒体上成千上万的其他作家)的每一个故事</h2><div class="nw l"><h3 class="bd b gy z fp nu fr fs nv fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="nx l"><p class="bd b dl z fp nu fr fs nv fu fw dk translated">alexandra-amidon.medium.com</p></div></div></div></a></div><h1 id="5aa7" class="mp mq it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">参考</h1><pre class="kj kk kl km gt pp ly pq pr aw ps bi"><span id="e69e" class="oe mq it ly b gy pt pu l pv pw">Zhao, Y., Nasrullah, Z. <strong class="ly iu">and</strong> Li, Z., 2019. <a class="ae ky" href="https://www.jmlr.org/papers/volume20/19-011/19-011.pdf" rel="noopener ugc nofollow" target="_blank">PyOD: A Python Toolbox <strong class="ly iu">for</strong> Scalable Outlier Detection</a>. Journal of machine learning research (JMLR), 20(96), pp.1-7.</span></pre><p id="3aaa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">【github.com】yzhao 062/pyod:(JMLR ' 19)一个用于可扩展异常值检测(异常检测)的Python工具箱</p><p id="d107" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://pyod.readthedocs.io/en/latest/index.html" rel="noopener ugc nofollow" target="_blank">欢迎使用PyOD文档！— pyod 0.8.9文档</a></p></div></div>    
</body>
</html>