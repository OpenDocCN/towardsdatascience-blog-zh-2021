<html>
<head>
<title>Julia’s Fantastic CUDA Implementation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Julia神奇的CUDA实现</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/julias-fantastic-cuda-implementation-and-why-it-is-better-than-python-s-ca76e575c526?source=collection_archive---------21-----------------------#2021-04-05">https://towardsdatascience.com/julias-fantastic-cuda-implementation-and-why-it-is-better-than-python-s-ca76e575c526?source=collection_archive---------21-----------------------#2021-04-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="562e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用CUDA.jl包探索简单并行计算的真正力量。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/aef0d959ee3a0c6978a8dec4dc8d0fcd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1268/format:webp/1*2O_ADg2mSggwSwZOzZjQGg.jpeg"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated"><a class="ae ku" href="https://unsplash.com/photos/0F2tAwBmBjo" rel="noopener ugc nofollow" target="_blank">https://unsplash.com/photos/0F2tAwBmBjo</a></p></figure><h1 id="7ddc" class="kv kw it bd kx ky kz la lb lc ld le lf jz lg ka lh kc li kd lj kf lk kg ll lm bi translated">介绍</h1><p id="3dc2" class="pw-post-body-paragraph ln lo it lp b lq lr ju ls lt lu jx lv lw lx ly lz ma mb mc md me mf mg mh mi im bi translated">由于许多不同的原因，包括速度、科学的语法和易用性，Julia语言已经进入了数据科学领域的前沿。然而，Julia语言的一个被大大低估的特性是它在并行计算方面的非凡能力。Julia的设计初衷是并行计算。这与Python之类的语言有很大的不同，在Python中，这些实现是后来才添加到语言中的，在很多情况下都没有很好地实现。</p><p id="a4a8" class="pw-post-body-paragraph ln lo it lp b lq mj ju ls lt mk jx lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated">当然，总的来说，Julia也是一种速度较快的语言。因此，将这两种属性结合在一起，肯定能让朱莉娅站在一些最快计算的前沿。我认为这非常令人兴奋，因为Julia真的是第一个以这种方式构建的科学计算语言。这个实现的另一个优点是使用起来非常简单。</p></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h1 id="f78d" class="kv kw it bd kx ky mv la lb lc mw le lf jz mx ka lh kc my kd lj kf mz kg ll lm bi translated">CUDA.jl</h1><p id="cd8a" class="pw-post-body-paragraph ln lo it lp b lq lr ju ls lt lu jx lv lw lx ly lz ma mb mc md me mf mg mh mi im bi translated">在今天的文章中，我将重点介绍CUDA.jl包，因为我没有太多使用AMD卡和并行计算的经验。然而，在生态系统中确实有一些包是为那些拥有红队卡片的人持续维护的。不管你有什么样的卡，你都不太可能在Julia的并行计算中被蒙在鼓里，除非你使用的是I-GPU。</p><p id="a7ec" class="pw-post-body-paragraph ln lo it lp b lq mj ju ls lt mk jx lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated">CUDA.jl包是一个相对简单的包，它充满了对各种不同包的调度。我们将在后面更多地讨论这个调度意味着什么。我们当然可以使用Pkg添加这个包，就像我们添加任何其他的Julia包一样:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="5dda" class="nf kw it nb b gy ng nh l ni nj">julia &gt; ]<br/>pkg &gt; add CUDA</span></pre><blockquote class="nk"><p id="7080" class="nl nm it bd nn no np nq nr ns nt mi dk translated">或者</p></blockquote><pre class="nu nv nw nx ny na nb nc nd aw ne bi"><span id="caf7" class="nf kw it nb b gy ng nh l ni nj">using Pkg<br/>Pkg.add("CUDA")</span></pre><p id="24ea" class="pw-post-body-paragraph ln lo it lp b lq mj ju ls lt mk jx lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated">这个包的使用实际上非常简单，我们会解释为什么会这样——但是现在，我想说明一下它实际上有多简单。考虑添加这两个数组:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="83bc" class="nf kw it nb b gy ng nh l ni nj">x = [5, 10, 15, 20]<br/>y = [5, 10, 15, 20]</span><span id="8954" class="nf kw it nb b gy nz nh l ni nj">x .+ y</span></pre><p id="76b3" class="pw-post-body-paragraph ln lo it lp b lq mj ju ls lt mk jx lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated">使用CUDA包，我们可以简单地将CuArray类型转换为两个数组。这将使它们成为CuArray类型，这意味着当它们被添加时，算法将在GPU和CPU之间分割。很酷，对吧？</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="bc81" class="nf kw it nb b gy ng nh l ni nj">using CUDA<br/>x = CuArray([5, 10, 15, 20])<br/>y = CuArray([5, 10, 15, 20])</span><span id="ecd1" class="nf kw it nb b gy nz nh l ni nj">x .+ y</span></pre><h1 id="50a0" class="kv kw it bd kx ky kz la lb lc ld le lf jz lg ka lh kc li kd lj kf lk kg ll lm bi translated">CUDA调度</h1><p id="1fae" class="pw-post-body-paragraph ln lo it lp b lq lr ju ls lt lu jx lv lw lx ly lz ma mb mc md me mf mg mh mi im bi translated">和大多数Julia程序员可用的包一样，这个包利用了Julia的多重调度。如果您想了解更多关于多重分派的一般知识，以及为什么多重分派是我最喜欢的计算机编程方式，我写了一整篇文章，都是关于它在Julia编程语言中的实现，您可以在这里查看:</p><div class="oa ob gp gr oc od"><a rel="noopener follow" target="_blank" href="/why-multiple-dispatch-is-my-favorite-way-to-program-786bf78f4878"><div class="oe ab fo"><div class="of ab og cl cj oh"><h2 class="bd iu gy z fp oi fr fs oj fu fw is bi translated">为什么多重分派是我最喜欢的编程方式</h2><div class="ok l"><h3 class="bd b gy z fp oi fr fs oj fu fw dk translated">多种调度的优势概述，以及我为什么这么喜欢它。</h3></div><div class="ol l"><p class="bd b dl z fp oi fr fs oj fu fw dk translated">towardsdatascience.com</p></div></div><div class="om l"><div class="on l oo op oq om or ko od"/></div></div></a></div><p id="5872" class="pw-post-body-paragraph ln lo it lp b lq mj ju ls lt mk jx lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated">对Julia来说，这个CUDA.jl包最酷的地方在于，它真正利用了多分派的概念，通过扩展基本函数来产生许多调用，这些调用实际上与它们的常规内存和处理器对应部分相同，同时仍然利用了CUDA的优势。这意味着在很多情况下，算法可以像没有CUDA时一样正常执行。换句话说，我们获得了CUDA的好处，而没有这种努力通常会引起的任何头痛。我认为这真的很酷，因为我真的从未使用过如此强大的并行处理平台的如此易用的实现。对于任何热爱技术和寻求更快编译时间的人，我当然会推荐看看这个实现，这样你就可以看到在Julia中使用CuArrays实际上是多么容易！</p></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h1 id="9210" class="kv kw it bd kx ky mv la lb lc mw le lf jz mx ka lh kc my kd lj kf mz kg ll lm bi translated">结论</h1><p id="72fe" class="pw-post-body-paragraph ln lo it lp b lq lr ju ls lt lu jx lv lw lx ly lz ma mb mc md me mf mg mh mi im bi translated">在能够利用CUDA并行处理技术的一长串编程语言中，我认为Julia无疑是最无缝实现的佼佼者。这个实现真正酷的地方在于它没有使用任何Julia语言独有的东西。事实上，Julia最酷的一点是，函数经常在整个包的范围内简单地循环使用，只是为了保存不同的类型而被分派。</p><p id="e451" class="pw-post-body-paragraph ln lo it lp b lq mj ju ls lt mk jx lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated">不管语言本身的编译速度有多快，尽管这也令人印象深刻，但CUDA在Julia语言中的实现将为这些程序的编程过程节省大量时间。非常感谢您阅读我的文章，我真的希望它点燃了您对并行计算的内心之火。我想说的是，这个CUDA实现也是非常容易实现的，所以没有理由不去尝试一下！</p></div></div>    
</body>
</html>