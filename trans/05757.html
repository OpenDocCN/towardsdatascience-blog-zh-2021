<html>
<head>
<title>Creating Containerized Workflows with Argo</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Argo创建容器化的工作流</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/creating-containerized-workflows-with-argo-ec1011b04370?source=collection_archive---------9-----------------------#2021-05-23">https://towardsdatascience.com/creating-containerized-workflows-with-argo-ec1011b04370?source=collection_archive---------9-----------------------#2021-05-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/e5be3d8f194c16b47e52f81ddd3f526d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W86RRRirCxsPxFxAs7ah_Q.jpeg"/></div></div></figure><div class=""/><div class=""><h2 id="0cc7" class="pw-subtitle-paragraph kb jd je bd b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks dk translated">Kubernetes上的Argo工作流入门</h2></div><h2 id="4585" class="kt ku je bd kv kw kx dn ky kz la dp lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">探索Argo工作流的核心概念</h2><p id="2aeb" class="pw-post-body-paragraph lp lq je lr b ls lt kf lu lv lw ki lx lc ly lz ma lg mb mc md lk me mf mg mh im bi translated">在<a class="ae mi" rel="noopener" target="_blank" href="/machine-learning-pipelines-with-kubeflow-4c59ad05522">的上一篇文章</a>中，我探索了Kubeflow管道，并完成了创建和执行一个简单的机器学习管道的过程。在本文中，我将仔细研究Argo，这是一个开源的工作流编排引擎，它被用作Kubeflow管道的默认编排平台。</p><h1 id="b206" class="mj ku je bd kv mk ml mm ky mn mo mp lb kk mq kl lf kn mr ko lj kq ms kr ln mt bi translated">建立Kubernetes集群</h1><p id="1ba3" class="pw-post-body-paragraph lp lq je lr b ls lt kf lu lv lw ki lx lc ly lz ma lg mb mc md lk me mf mg mh im bi translated">为了开始玩Argo，我们首先需要一个正在运行的Kubernetes集群。我将使用EKS，AWS上的托管Kubernetes服务，并通过所需的步骤让Argo在EKS上运行。只要部署了Argo并且拥有在集群上运行工作流所需的权限，任何Kubernetes集群都可以工作。</p><p id="36ab" class="pw-post-body-paragraph lp lq je lr b ls mu kf lu lv mv ki lx lc mw lz ma lg mx mc md lk my mf mg mh im bi translated">开始使用EKS最简单的方法是使用<em class="mz"> eksctl </em>命令行工具。安装<em class="mz"> eksctl </em>的说明可以在这里找到:<a class="ae mi" href="https://github.com/weaveworks/eksctl/blob/main/README.md" rel="noopener ugc nofollow" target="_blank">https://github.com/weaveworks/eksctl/blob/main/README.md</a></p><p id="aa4e" class="pw-post-body-paragraph lp lq je lr b ls mu kf lu lv mv ki lx lc mw lz ma lg mx mc md lk my mf mg mh im bi translated">一旦安装了eksctl，我们将通过运行以下命令来创建Kubernetes集群:</p><pre class="na nb nc nd gt ne nf ng nh aw ni bi"><span id="546b" class="kt ku je nf b gy nj nk l nl nm">eksctl create cluster</span></pre><p id="a0c6" class="pw-post-body-paragraph lp lq je lr b ls mu kf lu lv mv ki lx lc mw lz ma lg mx mc md lk my mf mg mh im bi translated"><strong class="lr jf">注意</strong>:上面的命令创建了AWS资源，这将在您的账户上产生费用。默认情况下，<code class="fe nn no np nf b">eksctl create cluster</code>命令创建一个包含2个m5.large类型EC2实例的Kubernetes集群，在撰写本文时，每个实例的成本约为每小时0.10美元。</p><p id="e91f" class="pw-post-body-paragraph lp lq je lr b ls mu kf lu lv mv ki lx lc mw lz ma lg mx mc md lk my mf mg mh im bi translated">此命令可能需要15–20分钟来完成群集资源调配。一旦完成，我们要做的第一件事就是创建一个命名空间来存放我们的Argo资源。我们将使用<code class="fe nn no np nf b">kubectl</code>来做到这一点:</p><pre class="na nb nc nd gt ne nf ng nh aw ni bi"><span id="d24b" class="kt ku je nf b gy nj nk l nl nm">kubectl create namespace argo</span></pre><p id="af21" class="pw-post-body-paragraph lp lq je lr b ls mu kf lu lv mv ki lx lc mw lz ma lg mx mc md lk my mf mg mh im bi translated">接下来，我们将从Argo GitHub库下载Argo安装清单:</p><pre class="na nb nc nd gt ne nf ng nh aw ni bi"><span id="1659" class="kt ku je nf b gy nj nk l nl nm">wget <a class="ae mi" href="https://raw.githubusercontent.com/argoproj/argo-workflows/master/manifests/install.yaml" rel="noopener ugc nofollow" target="_blank">https://raw.githubusercontent.com/argoproj/argo-workflows/stable/manifests/install.yaml</a> .</span></pre><p id="ad07" class="pw-post-body-paragraph lp lq je lr b ls mu kf lu lv mv ki lx lc mw lz ma lg mx mc md lk my mf mg mh im bi translated">这将下载一个名为install.yaml的YAML清单文件，它描述了我们启动和运行Argo所需的所有Kubernetes资源。</p><p id="4f4f" class="pw-post-body-paragraph lp lq je lr b ls mu kf lu lv mv ki lx lc mw lz ma lg mx mc md lk my mf mg mh im bi translated">为了访问Argo服务器用户界面，我们必须对这个文件做一些修改。</p><ol class=""><li id="a44c" class="nq nr je lr b ls mu lv mv lc ns lg nt lk nu mh nv nw nx ny bi translated">将<em class="mz"> argo-server </em>服务更新为<em class="mz">负载平衡器类型。</em>这将在AWS中提供一个网络负载平衡器，将请求路由到<em class="mz"> argo-server </em>服务。生成的资源定义应该如下所示:</li></ol><figure class="na nb nc nd gt iv"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="badb" class="pw-post-body-paragraph lp lq je lr b ls mu kf lu lv mv ki lx lc mw lz ma lg mx mc md lk my mf mg mh im bi translated">2.更新argo-server部署，添加一个名为<em class="mz"> BASE_HREF </em>的环境变量，其值为“/”。结果应该如下所示(为简洁起见，资源定义被截断):</p><figure class="na nb nc nd gt iv"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="df7b" class="pw-post-body-paragraph lp lq je lr b ls mu kf lu lv mv ki lx lc mw lz ma lg mx mc md lk my mf mg mh im bi translated">完成这些修改后，我们可以创建清单中定义的资源:</p><pre class="na nb nc nd gt ne nf ng nh aw ni bi"><span id="ffad" class="kt ku je nf b gy nj nk l nl nm">kubectl apply -n argo -f install.yaml</span></pre><p id="d78c" class="pw-post-body-paragraph lp lq je lr b ls mu kf lu lv mv ki lx lc mw lz ma lg mx mc md lk my mf mg mh im bi translated">接下来，我们需要创建一个入口资源:</p><figure class="na nb nc nd gt iv"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="6e8b" class="pw-post-body-paragraph lp lq je lr b ls mu kf lu lv mv ki lx lc mw lz ma lg mx mc md lk my mf mg mh im bi translated">最后，为了让Argo能够访问其他Kubernetes资源，我们需要为Argo服务帐户分配一个角色。在实际的生产集群中，我们希望将这个服务帐户分配给一个具有特定有限权限的角色，但是现在，我们只授予这个帐户admin访问权限。我们可以使用以下命令来实现这一点:</p><pre class="na nb nc nd gt ne nf ng nh aw ni bi"><span id="b0ef" class="kt ku je nf b gy nj nk l nl nm">kubectl -n argo create rolebinding default-admin --clusterrole=admin --serviceaccount=argo:default</span></pre><p id="5690" class="pw-post-body-paragraph lp lq je lr b ls mu kf lu lv mv ki lx lc mw lz ma lg mx mc md lk my mf mg mh im bi translated">这就是我们开始之前需要完成的所有设置。现在，我们将通过运行以下命令来获取Argo服务器UI的公共URL:</p><pre class="na nb nc nd gt ne nf ng nh aw ni bi"><span id="b4b4" class="kt ku je nf b gy nj nk l nl nm">kubectl get svc argo-server -n argo</span></pre><p id="8a05" class="pw-post-body-paragraph lp lq je lr b ls mu kf lu lv mv ki lx lc mw lz ma lg mx mc md lk my mf mg mh im bi translated">该命令将在EXTERNAL-IP列中返回公共URL。应该以<em class="mz">. elb . Amazon AWS . com</em>结尾</p><p id="85d7" class="pw-post-body-paragraph lp lq je lr b ls mu kf lu lv mv ki lx lc mw lz ma lg mx mc md lk my mf mg mh im bi translated">现在打开浏览器，导航到:<a class="ae mi" rel="noopener ugc nofollow" target="_blank" href="/{YOUR_EXTERNAL_IP}:2746"><em class="mz">https://{ YOUR _ EXTERNAL _ IP }:2746</em></a></p><p id="1a47" class="pw-post-body-paragraph lp lq je lr b ls mu kf lu lv mv ki lx lc mw lz ma lg mx mc md lk my mf mg mh im bi translated"><strong class="lr jf">注意</strong>:如果你在MacOS上使用Chrome，并且在导航到Argo服务器UI时很难绕过浏览器发出的安全警告，Chrome中有一个隐藏的解决方法:只需单击浏览器窗口中的任意位置以确保窗口处于焦点状态，然后键入<em class="mz">this insural。</em>有关此变通办法的更多详细信息，请参见<a class="ae mi" href="https://deployhappiness.com/this-is-unsafe-bypassing-the-google-chrome-your-connection-is-not-private-warning/" rel="noopener ugc nofollow" target="_blank">这是不安全的——绕过谷歌浏览器的“您的连接不是私人的”警告</a></p><p id="a3c2" class="pw-post-body-paragraph lp lq je lr b ls mu kf lu lv mv ki lx lc mw lz ma lg mx mc md lk my mf mg mh im bi translated">如果一切正常，您应该会看到一个Argo服务器登录页面，如下所示:</p><figure class="na nb nc nd gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ob"><img src="../Images/5edbb7647862a06c5541df8c19ed5586.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CLeIZPXzJis_AcCmEmPbgw.jpeg"/></div></div><p class="oc od gj gh gi oe of bd b be z dk translated">Argo服务器用户界面登录页面</p></figure><h1 id="9eaf" class="mj ku je bd kv mk ml mm ky mn mo mp lb kk mq kl lf kn mr ko lj kq ms kr ln mt bi translated">执行您的第一个工作流程</h1><p id="2d76" class="pw-post-body-paragraph lp lq je lr b ls lt kf lu lv lw ki lx lc ly lz ma lg mb mc md lk me mf mg mh im bi translated">设置完成后，让我们执行Argo的第一个工作流。</p><p id="8c4f" class="pw-post-body-paragraph lp lq je lr b ls mu kf lu lv mv ki lx lc mw lz ma lg mx mc md lk my mf mg mh im bi translated">导航至<strong class="lr jf">工作流</strong>(这是侧边栏中的顶部图标)&gt; <strong class="lr jf">提交新工作流&gt;使用完整工作流选项编辑</strong></p><p id="97a3" class="pw-post-body-paragraph lp lq je lr b ls mu kf lu lv mv ki lx lc mw lz ma lg mx mc md lk my mf mg mh im bi translated">这将打开工作流创建体验，其中包括一个填充了基本工作流YAML清单的文本编辑器，以及工作流参数和元数据的附加选项卡。</p><figure class="na nb nc nd gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi og"><img src="../Images/09905f72e6fd5dbc002e819e9dc9e5e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TAQP_B7ZLDWWRvBlM2dnMQ.jpeg"/></div></div><p class="oc od gj gh gi oe of bd b be z dk translated">Argo工作流创建</p></figure><p id="eb79" class="pw-post-body-paragraph lp lq je lr b ls mu kf lu lv mv ki lx lc mw lz ma lg mx mc md lk my mf mg mh im bi translated">让我们用一个运行如下所示的<a class="ae mi" href="https://hub.docker.com/r/docker/whalesay/" rel="noopener ugc nofollow" target="_blank"> Whalesay </a>容器的简单工作流来替换这个默认工作流清单，然后单击<strong class="lr jf"> Create </strong>来运行工作流:</p><figure class="na nb nc nd gt iv"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="2c63" class="pw-post-body-paragraph lp lq je lr b ls mu kf lu lv mv ki lx lc mw lz ma lg mx mc md lk my mf mg mh im bi translated">一旦您开始工作流程，您将看到一个工作流程图，它将随着工作流程的进展而更新(在这种情况下，它只是一个单独的步骤)。在此页面中，您将能够查看工作流的详细信息、输入、输出和日志。在我们的准系统Hello World工作流程中，这里没有太多可看的，但是你可以导航到<strong class="lr jf">主日志</strong>来确认Whalesay ASCII艺术被记录。</p><figure class="na nb nc nd gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oh"><img src="../Images/798888074f1e49c48ec9574b9740cc3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5tG9rB6M0qr9p_Olio6oVA.jpeg"/></div></div><p class="oc od gj gh gi oe of bd b be z dk translated">简单的Argo工作流程图</p></figure><h1 id="248e" class="mj ku je bd kv mk ml mm ky mn mo mp lb kk mq kl lf kn mr ko lj kq ms kr ln mt bi translated">了解工作流清单</h1><p id="7249" class="pw-post-body-paragraph lp lq je lr b ls lt kf lu lv lw ki lx lc ly lz ma lg mb mc md lk me mf mg mh im bi translated">现在我们知道了如何执行工作流，让我们仔细看看我们用来定义工作流的YAML清单。</p><h2 id="6e17" class="kt ku je bd kv kw kx dn ky kz la dp lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">[计]元数据</h2><p id="06cc" class="pw-post-body-paragraph lp lq je lr b ls lt kf lu lv lw ki lx lc ly lz ma lg mb mc md lk me mf mg mh im bi translated">清单的前几行定义了工作流元数据，特别是<em class="mz"> generateName </em>字段，它将与一个随机生成的字符串组合起来形成我们工作流的名称(我们也可以使用<em class="mz"> name </em>字段来显式定义名称，但是这个名称必须是唯一的)，以及<em class="mz"> namespace </em>字段，它定义了工作流将在其中执行的Kubernetes名称空间。</p><h2 id="0ee1" class="kt ku je bd kv kw kx dn ky kz la dp lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">工作流规范</h2><p id="3700" class="pw-post-body-paragraph lp lq je lr b ls lt kf lu lv lw ki lx lc ly lz ma lg mb mc md lk me mf mg mh im bi translated">清单的其余部分定义了工作流规范，这是定义实际工作流逻辑的地方。在上例中，工作流规范有两个顶级字段:</p><ul class=""><li id="1fe3" class="nq nr je lr b ls mu lv mv lc ns lg nt lk nu mh oi nw nx ny bi translated"><em class="mz">入口点</em>:指定首先执行的模板。</li><li id="052d" class="nq nr je lr b ls oj lv ok lc ol lg om lk on mh oi nw nx ny bi translated"><em class="mz">模板</em>:定义工作流程中使用的所有模板。正如我们将很快看到的，<em class="mz">模板</em>在Argo中是一个加载的术语，但在这里模板只是表示工作流执行的一个单元。在我们的Whalesay工作流中，我们只有一个名为<strong class="lr jf"> whalesay </strong>的类型为<strong class="lr jf">的容器模板。</strong>由于这个模板定义了一个要执行的容器，我们指定了要使用的容器图像、要执行的命令和要传入的参数。</li></ul><h1 id="3c42" class="mj ku je bd kv mk ml mm ky mn mo mp lb kk mq kl lf kn mr ko lj kq ms kr ln mt bi translated">创建多步骤工作流</h1><p id="5146" class="pw-post-body-paragraph lp lq je lr b ls lt kf lu lv lw ki lx lc ly lz ma lg mb mc md lk me mf mg mh im bi translated">现在让我们介绍一个更复杂的工作流，它按顺序执行几个不同的步骤。这个工作流将接受2个参数、一个称呼和一个用户名，它将通过使用提供的参数执行Whalesay容器来创建一个问候消息来结束。</p><p id="6759" class="pw-post-body-paragraph lp lq je lr b ls mu kf lu lv mv ki lx lc mw lz ma lg mx mc md lk my mf mg mh im bi translated">虽然我们可以很容易地用Whalesay容器来实现这一点，但是为了展示Argo提供的其他一些特性，我们将采取一种更迂回的方法。</p><p id="2f54" class="pw-post-body-paragraph lp lq je lr b ls mu kf lu lv mv ki lx lc mw lz ma lg mx mc md lk my mf mg mh im bi translated">这是我们新工作流程的YAML清单:</p><figure class="na nb nc nd gt iv"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="fc5a" class="pw-post-body-paragraph lp lq je lr b ls mu kf lu lv mv ki lx lc mw lz ma lg mx mc md lk my mf mg mh im bi translated">让我们来分解一下:</p><ul class=""><li id="dc93" class="nq nr je lr b ls mu lv mv lc ns lg nt lk nu mh oi nw nx ny bi translated">您会注意到的第一个区别是在第6行添加了<em class="mz">参数</em>字段。这是我们定义将被传递到我们的工作流中的<em class="mz">称呼</em>和<em class="mz">用户名</em>参数的地方。</li><li id="56d7" class="nq nr je lr b ls oj lv ok lc ol lg om lk on mh oi nw nx ny bi translated">这个工作流中定义的第一个模板在第14行。这个模板名为<em class="mz">问候语</em>，接受名为<em class="mz">问候语</em>的参数，类型为Script。脚本模板类似于容器模板，因为它们需要容器图像和命令；然而，脚本模板允许我们传入一个内联脚本来在容器上执行。该模板执行一个简单的Python脚本，该脚本检索<em class="mz"> salutation </em>参数的值，然后将其打印出来。</li><li id="e84a" class="nq nr je lr b ls oj lv ok lc ol lg om lk on mh oi nw nx ny bi translated">下一个模板叫做<em class="mz">用户</em>，也是脚本类型。这个模板就像salutation模板一样，只是这个模板使用了一个shell脚本而不是Python脚本(这里没有特别的理由不使用Python；这只是为了说明我们并不局限于Python作为我们的脚本语言)。</li><li id="d5a6" class="nq nr je lr b ls oj lv ok lc ol lg om lk on mh oi nw nx ny bi translated">第三个模板与我们之前使用的Whalesay容器模板相同，只是现在它接受两个参数，<em class="mz">问候语</em>和<em class="mz">用户名</em>，并使用这些参数创建问候语。</li><li id="2042" class="nq nr je lr b ls oj lv ok lc ol lg om lk on mh oi nw nx ny bi translated">第四个模板是一个步骤模板。步骤模板允许我们将一系列其他模板链接在一起，创建一个多步骤工作流，其中一个模板的输出可以用作另一个模板的输入。第一步使用<em class="mz">问候语</em>模板并传入工作流参数<em class="mz">问候语</em>，第二步使用<em class="mz">用户</em>模板并传入工作流参数<em class="mz">用户名</em>，最终模板使用<em class="mz"> whalesay </em>模板并传入前两步的输出。</li></ul><p id="d551" class="pw-post-body-paragraph lp lq je lr b ls mu kf lu lv mv ki lx lc mw lz ma lg mx mc md lk my mf mg mh im bi translated">以下是此工作流程的工作流程图:</p><figure class="na nb nc nd gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ob"><img src="../Images/031e9035b73212d2687ca301918cec2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QIpXZlKrFdk6_HMbo8PYuw.jpeg"/></div></div><p class="oc od gj gh gi oe of bd b be z dk translated">多步骤工作流程图</p></figure><p id="3edb" class="pw-post-body-paragraph lp lq je lr b ls mu kf lu lv mv ki lx lc mw lz ma lg mx mc md lk my mf mg mh im bi translated"><strong class="lr jf">注意</strong>:如果你执行了这个工作流程(或者只是仔细看了一下这个图)，你可能已经注意到<em class="mz">获取标题</em>和<em class="mz">获取问候</em>步骤是并行执行的，然后在两个步骤都完成<em class="mz">之后，再运行</em>步骤。这是因为步骤模板实际上接受步骤列表的列表。内部列表中的步骤将并行运行，外部列表中的步骤将按顺序运行。例如，上面工作流的列表结构如下所示:</p><pre class="na nb nc nd gt ne nf ng nh aw ni bi"><span id="ae22" class="kt ku je nf b gy nj nk l nl nm">[[get-title, get-greeting], [whalesay]]</span></pre><p id="84fd" class="pw-post-body-paragraph lp lq je lr b ls mu kf lu lv mv ki lx lc mw lz ma lg mx mc md lk my mf mg mh im bi translated">这就是为什么<em class="mz"> get-title </em>和<em class="mz"> get-greeting </em>并行运行，而<em class="mz"> whalesay </em>在两者完成后运行。</p><h2 id="7f6a" class="kt ku je bd kv kw kx dn ky kz la dp lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">重用工作流步骤</h2><p id="f9bd" class="pw-post-body-paragraph lp lq je lr b ls lt kf lu lv lw ki lx lc ly lz ma lg mb mc md lk me mf mg mh im bi translated">工作流编排平台最重要的特性之一是能够跨多个工作流共享常用步骤。这允许平台的用户通过使用其他用户已经实施的通用步骤库来快速开始创建工作流。例如，您可以为常见的数据转换或与外部服务的集成创建可重用的步骤。</p><p id="2173" class="pw-post-body-paragraph lp lq je lr b ls mu kf lu lv mv ki lx lc mw lz ma lg mx mc md lk my mf mg mh im bi translated">Argo中表示可重用步骤(或一组步骤)的结构称为工作流模板。这不要与我们之前在定义工作流YAML清单时讨论的模板相混淆。为清楚起见，区别如下:</p><ul class=""><li id="1ca1" class="nq nr je lr b ls mu lv mv lc ns lg nt lk nu mh oi nw nx ny bi translated">模板:表示工作流中的单个执行单元。有许多不同类型的模板，包括<em class="mz">容器</em>、<em class="mz">脚本</em>和<em class="mz">步骤</em>。</li><li id="e1a8" class="nq nr je lr b ls oj lv ok lc ol lg om lk on mh oi nw nx ny bi translated">工作流模板:保存在集群中的工作流定义，可以作为独立工作流或任何其他工作流的一部分执行。</li></ul><p id="fadb" class="pw-post-body-paragraph lp lq je lr b ls mu kf lu lv mv ki lx lc mw lz ma lg mx mc md lk my mf mg mh im bi translated">让我们创建一个工作流模板来看看它是如何工作的。我们的工作流模板将是一个随机数生成器，它接受最小值和最大值，并返回指定范围内的随机整数。</p><p id="67de" class="pw-post-body-paragraph lp lq je lr b ls mu kf lu lv mv ki lx lc mw lz ma lg mx mc md lk my mf mg mh im bi translated">Argo服务器UI中的工作流模板选项卡是我们可以查看和创建工作流模板的地方。</p><figure class="na nb nc nd gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ob"><img src="../Images/1c6347a3f26b8c5928363bfee0112a4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q8xW0bxzMhf4-Read9D-lw.jpeg"/></div></div><p class="oc od gj gh gi oe of bd b be z dk translated">Argo用户界面-工作流模板</p></figure><p id="8d1d" class="pw-post-body-paragraph lp lq je lr b ls mu kf lu lv mv ki lx lc mw lz ma lg mx mc md lk my mf mg mh im bi translated">创建工作流模板与创建工作流非常相似，只是当我们创建工作流模板时，它会被保存以供以后使用，而不是像工作流那样立即执行。</p><p id="0fe6" class="pw-post-body-paragraph lp lq je lr b ls mu kf lu lv mv ki lx lc mw lz ma lg mx mc md lk my mf mg mh im bi translated">以下是我们将使用的工作流模板的YAML清单:</p><figure class="na nb nc nd gt iv"><div class="bz fp l di"><div class="nz oa l"/></div><p class="oc od gj gh gi oe of bd b be z dk translated">工作流模板清单</p></figure><p id="3969" class="pw-post-body-paragraph lp lq je lr b ls mu kf lu lv mv ki lx lc mw lz ma lg mx mc md lk my mf mg mh im bi translated">正如您所看到的，这个清单就像我们之前创建的工作流清单一样:它接受两个参数，<em class="mz"> min </em>和<em class="mz"> max </em>，并且有一个Python脚本模板，该模板在指定的范围内生成一个随机数。</p><p id="602f" class="pw-post-body-paragraph lp lq je lr b ls mu kf lu lv mv ki lx lc mw lz ma lg mx mc md lk my mf mg mh im bi translated">创建此工作流模板后，我们将能够从UI中的“工作流模板”选项卡查看它，并通过选择它并单击<strong class="lr jf">提交</strong>将其作为独立工作流提交</p><figure class="na nb nc nd gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ob"><img src="../Images/4b8fbb01b067a14050c58666e6b5276c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e4RT7r9lAwuOtpZRvP4BYg.jpeg"/></div></div><p class="oc od gj gh gi oe of bd b be z dk translated">将工作流模板作为独立工作流提交</p></figure><p id="9e3d" class="pw-post-body-paragraph lp lq je lr b ls mu kf lu lv mv ki lx lc mw lz ma lg mx mc md lk my mf mg mh im bi translated">我们也可以在其他工作流中使用此工作流模板。让我们看看这是如何工作的。我们将返回工作流选项卡，选择<strong class="lr jf">提交新工作流</strong>，然后输入以下YAML清单:</p><figure class="na nb nc nd gt iv"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="f6bb" class="pw-post-body-paragraph lp lq je lr b ls mu kf lu lv mv ki lx lc mw lz ma lg mx mc md lk my mf mg mh im bi translated">这个工作流很像我们已经讨论过的多步骤工作流，只是这次步骤模板不仅仅是将在这个工作流中直接定义的模板链接在一起。步骤模板中的第一步(上面的第19行)使用<code class="fe nn no np nf b">templateRef</code>字段而不是<code class="fe nn no np nf b">template</code>字段来引用工作流模板中定义的模板。在这个特殊的例子中，我们引用了在<code class="fe nn no np nf b">random-number-generator</code>工作流模板中定义的<code class="fe nn no np nf b">generator</code>模板。</p><p id="a7c9" class="pw-post-body-paragraph lp lq je lr b ls mu kf lu lv mv ki lx lc mw lz ma lg mx mc md lk my mf mg mh im bi translated">如果这仍然有点混乱，下面的图表说明了本例中工作流、工作流模板和模板之间的关系:</p><figure class="na nb nc nd gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oo"><img src="../Images/ececc0da839f53ac8924a4c2f5826a18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sPuH1aEnDH2KhtOHI-FNEA.png"/></div></div></figure><p id="7f11" class="pw-post-body-paragraph lp lq je lr b ls mu kf lu lv mv ki lx lc mw lz ma lg mx mc md lk my mf mg mh im bi translated">当我们执行这个工作流时，<em class="mz">call-random-number-generator</em>步骤将像它是一个直接在工作流中定义的模板一样运行，而实际上它的实现被封装在<em class="mz">random-number-generator</em>工作流模板中。</p><figure class="na nb nc nd gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ob"><img src="../Images/4565c54119c372579e79055a29199836.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iQ9hMZ4UlpahhaS8gelC3g.jpeg"/></div></div><p class="oc od gj gh gi oe of bd b be z dk translated">从工作流中引用工作流模板</p></figure><p id="f956" class="pw-post-body-paragraph lp lq je lr b ls mu kf lu lv mv ki lx lc mw lz ma lg mx mc md lk my mf mg mh im bi translated">这意味着我们可以创建许多其他工作流(或其他工作流模板)来使用该功能，而无需考虑其实现的细节，如果我们需要修改该功能(例如，当前随机范围不包括<em class="mz"> max </em>值，这可能是也可能不是期望的行为；或者，我们可能希望将它重构到一个容器映像中，而不是一个内联脚本中，以便更容易地测试该功能)，我们可以在工作流模板中这样做，因为我们知道所有的消费者都将开始使用这些修改，而无需在他们端做任何额外的工作。</p><h2 id="16c5" class="kt ku je bd kv kw kx dn ky kz la dp lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">结论</h2><p id="55db" class="pw-post-body-paragraph lp lq je lr b ls lt kf lu lv lw ki lx lc ly lz ma lg mb mc md lk me mf mg mh im bi translated">在本文中，我们看到了如何通过创建几个简单的工作流来开始使用Argo工作流。我们研究了如何在工作流中的多个模板之间传递参数，以及如何使用工作流模板封装共享逻辑。</p><p id="97fc" class="pw-post-body-paragraph lp lq je lr b ls mu kf lu lv mv ki lx lc mw lz ma lg mx mc md lk my mf mg mh im bi translated">虽然我们在这里探索的例子非常简单，但是这些相同的核心概念可以用来在Kubernetes上构建和执行强大的容器化工作流，如果您决定继续探索Argo必须提供的其他功能，它们将成为一个强大的基础。</p><p id="72a9" class="pw-post-body-paragraph lp lq je lr b ls mu kf lu lv mv ki lx lc mw lz ma lg mx mc md lk my mf mg mh im bi translated">你可以在【https://github.com/gnovack/argo-workflows-getting-started】的<em class="mz">Argo-workflows-getting-started</em>库中找到我们创建的所有YAML清单</p><h2 id="34f4" class="kt ku je bd kv kw kx dn ky kz la dp lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">参考资料:</h2><ul class=""><li id="20ce" class="nq nr je lr b ls lt lv lw lc op lg oq lk or mh oi nw nx ny bi translated"><a class="ae mi" href="https://argoproj.github.io/argo-workflows/quick-start/" rel="noopener ugc nofollow" target="_blank">https://argoproj.github.io/argo-workflows/quick-start/</a></li><li id="63f3" class="nq nr je lr b ls oj lv ok lc ol lg om lk on mh oi nw nx ny bi translated"><a class="ae mi" href="https://www.eksworkshop.com/advanced/410_batch/" rel="noopener ugc nofollow" target="_blank">https://www.eksworkshop.com/advanced/410_batch/</a></li></ul><p id="6790" class="pw-post-body-paragraph lp lq je lr b ls mu kf lu lv mv ki lx lc mw lz ma lg mx mc md lk my mf mg mh im bi translated">感谢阅读。如有任何问题或意见，请随时联系我们。</p></div></div>    
</body>
</html>