<html>
<head>
<title>AI Planning Using Constraint Satisfaction Problems</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">利用约束满足问题的人工智能规划</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/ai-planning-using-constraint-satisfaction-problems-eb1be5466af6?source=collection_archive---------7-----------------------#2021-04-03">https://towardsdatascience.com/ai-planning-using-constraint-satisfaction-problems-eb1be5466af6?source=collection_archive---------7-----------------------#2021-04-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="5ed9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">利用约束满足问题解决人工智能规划问题。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/5f49b1b394f05f16013bf491936f920e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*b45ii02RbLBqdqi-"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">马库斯·温克勒在<a class="ae le" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><h1 id="b750" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">介绍</h1><p id="b488" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">就像AI规划作为可满足性一样，我们可以使用一种现有的技术——约束满足问题来帮助我们解决AI规划问题。这样我们就可以使用现有的成熟的求解CSP的算法来解决我们的AI规划问题。</p><p id="d896" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们将首先介绍CSP的概况。然后我们继续看如何将人工智能规划问题编码到CSP中。最后，我们使用CSP回溯算法来解决我们的问题。我们将通过在Python中实现它们来证明所有这些理论。</p><h1 id="51eb" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">约束满足问题</h1><p id="4b4f" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">来自维基百科，</p><blockquote class="mi mj mk"><p id="cad2" class="jq jr ml js b jt ju jv jw jx jy jz ka mm kc kd ke mn kg kh ki mo kk kl km kn im bi translated">CSP是定义为一组对象的数学问题，这些对象的状态必须满足一些约束。</p></blockquote><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/e25de03efca8ab742966931fc22453f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:288/format:webp/1*ZTyFiNTNYxiyOI1ULn8NtA.png"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">约束满足问题(作者图片)</p></figure><p id="a793" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这幅图描绘了有限域上的CSP。我们有一组变量——X，一组域列表——D，和一组约束——c。</p><p id="3dba" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">赋给X中变量的值必须是它们在d中的定义域之一。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/57e60723c4f99643c2e89f8d9e49e01a.png" data-original-src="https://miro.medium.com/v2/resize:fit:122/format:webp/1*rEJSptnjhmCUfhtSiKzmxw.png"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">变量和域(图片由作者提供)</p></figure><p id="d56e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">约束限制了来自x的变量子集的可能值。</p><h2 id="5735" class="mr lg it bd lh ms mt dn ll mu mv dp lp kb mw mx lt kf my mz lx kj na nb mb nc bi translated">例子</h2><p id="d606" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">一个很好的例子是<a class="ae le" href="https://docs.ocean.dwavesys.com/en/stable/examples/map_coloring.html" rel="noopener ugc nofollow" target="_blank">地图着色问题</a>。你可以点击链接看地图。在这个问题中，我们有<strong class="js iu">变量</strong>，它们是区域，<strong class="js iu">域</strong>是我们可以分配给变量的颜色(红色、绿色、黄色、蓝色)；在这个例子中，所有变量都有相同的域。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/218eb92e1b64adb99a0f06c796ae3048.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*VEpuwI0QmUsjJHsDn3cDWA.png"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">地图着色变量和域(图片由作者提供)</p></figure><p id="2817" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">约束条件是分配给一个区域的颜色不能分配给相邻的区域。</p><p id="110e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有限域上的CSP通常使用某种搜索算法来解决。既然我们理解了什么是有限域上的CSP，我们可以开始研究如何将规划问题编码到CSP中。</p><h1 id="9e8e" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">将规划问题编码到CSP中</h1><p id="e5e5" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">就像“作为可满足性的规划”一样，我们将规划问题编码到命题可满足性问题中，我们可以用这种方法做同样的事情。</p><p id="2371" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们将有界规划问题——计划长度固定的约束规划问题编码为约束满足问题。完全编码有四个步骤。下面我们会一一看到。</p><h2 id="3a10" class="mr lg it bd lh ms mt dn ll mu mv dp lp kb mw mx lt kf my mz lx kj na nb mb nc bi translated">CSP变量和域</h2><p id="20f4" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">在第一步中，我们想要创建CSP变量及其对应的CSP域。我们需要将两个组件转换为CSP变量，它们是:</p><ul class=""><li id="964c" class="ne nf it js b jt ju jx jy kb ng kf nh kj ni kn nj nk nl nm bi translated">断言</li><li id="0284" class="ne nf it js b jt nn jx no kb np kf nq kj nr kn nj nk nl nm bi translated">行动</li></ul><p id="3196" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于谓词，我们为每个步骤实例化所有谓词。记住我们有一个固定长度的计划(<em class="ml"> k </em>)。</p><p id="f989" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">例如，假设我们有一个简单的规划域，其中只有一个机器人和两个位置，如下面的pddl文件所示。我们的有界规划问题的长度是1。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ns nt l"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">简单域(作者代码)</p></figure><p id="dbdc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们可以将规划领域编码为以下CSP变量和领域:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/f16adec8c9390d6de495a079a6b12419.png" data-original-src="https://miro.medium.com/v2/resize:fit:410/format:webp/1*7gyxMz7NjeC-z-t2Qwy7hQ.png"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">CSP变量和域—谓词(图片由作者提供)</p></figure><p id="6642" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">数字表示步骤，因此对于从0到有界规划问题长度的每一步，我们将枚举所有可能的谓词。在这个例子中，我们有两个变量，其中每个变量都有相同的域<em class="ml"> {loc1，loc2} </em>。</p><p id="d883" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">类似地，对于动作，我们从步长0到步长-1进行实例化。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/2f54ca2c9d844927948a31fab2dcf9cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1042/format:webp/1*WeDhUJO_JTmTx8kVJhmy2Q.png"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">CSP变量和域操作(图片由作者提供)</p></figure><p id="c9f7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于我们的简单域，我们只有一个action变量，它是<em class="ml"> act(0) </em>，在其域中有两个可能的值。但是另外，我们将需要添加一个无操作动作(无操作动作)到域。这是一个没有先决条件也没有效果的行动。</p><p id="3ff9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，我们有了CSP变量和相应的域，在接下来的步骤中，我们将有CSP约束。</p><h2 id="bb1f" class="mr lg it bd lh ms mt dn ll mu mv dp lp kb mw mx lt kf my mz lx kj na nb mb nc bi translated">CSP对初始状态和目标状态的约束</h2><p id="c8f8" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">在这一步中，我们将初始状态和目标状态编码到CSP约束中。对于我们的例子，我们将使用下面pddl文件中表示的简单规划领域的规划问题。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ns nt l"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">简单规划问题(由作者编写代码)</p></figure><p id="04d0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在初始状态，我们的机器人处于<em class="ml">位置1 </em>，在目标状态，它处于<em class="ml">位置2 </em>。这真的很简单。</p><p id="8649" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这一步非常简单。我们只需要将初始状态和目标状态转换成一元约束，每个受影响的变量被赋予一个来自其定义域的值。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/03f9b16b3b7f19c909ca605fc52e538c.png" data-original-src="https://miro.medium.com/v2/resize:fit:286/format:webp/1*pMumOmq4GSDHmxoktv1Tkg.png"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">CSP对初始和目标状态的约束(图片由作者提供)</p></figure><p id="fd13" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这意味着在步骤0，机器人的位置被限制在<em class="ml">位置1 </em>，在步骤1，机器人的位置被限制在<em class="ml">位置2 </em>。</p><h2 id="77ee" class="mr lg it bd lh ms mt dn ll mu mv dp lp kb mw mx lt kf my mz lx kj na nb mb nc bi translated">CSP对行动的约束</h2><p id="69b3" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">在这一步中，我们将动作转换成二元约束。我们如下写约束集。</p><p id="84cc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">前提条件:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/9d0a14627aae70bde09b5cb966716e6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1022/format:webp/1*jQh028eiqMGdvBpLMo3HPQ.png"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">前提条件约束集构建器(图片由作者提供)</p></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/f34bd7be83b10971525bbbcc4bf2592b.png" data-original-src="https://miro.medium.com/v2/resize:fit:870/format:webp/1*cF-yis0HNb910xQtNu7JeQ.png"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">前提条件约束示例(图片由作者提供)</p></figure><p id="7f9a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">效果:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/6d786ac1b63058742747d836f5fe3289.png" data-original-src="https://miro.medium.com/v2/resize:fit:1112/format:webp/1*DfaY6EF9O8iy-icPVbW4DA.png"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">效果约束集生成器(图片由作者提供)</p></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/30154b5f9259aaf0d7ed67dee024e109.png" data-original-src="https://miro.medium.com/v2/resize:fit:870/format:webp/1*2wXwDrYvYnhfRhfyzBAHUg.png"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">效果约束示例(图片由作者提供)</p></figure><p id="96d9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这些约束是为了确保变量被正确赋值。如果<em class="ml"> act(0) </em>已经赋值给<em class="ml"> move(rob，loc1，loc2) </em>，<em class="ml"> atl(0，rob) </em>只能是<em class="ml"> loc1 </em>。</p><h2 id="123f" class="mr lg it bd lh ms mt dn ll mu mv dp lp kb mw mx lt kf my mz lx kj na nb mb nc bi translated">框架公理的CSP约束</h2><p id="1716" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">框架公理约束是说，在动作效果中没有被显式修改(或也称为不变量)的变量保持不变。举例来说，我们需要向我们的规划域添加另一个谓词。假设我们有一个新的谓词<em class="ml"> loaded(r)={cont，nil} </em>，它表示机器人是否装载了一个容器。这个谓词不受<em class="ml"> move(r，l，m) </em>动作的影响，因此它在执行<em class="ml"> move(r，l，m) </em>动作前后保持不变。我们将这一事实表述如下。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/8689ca4b41a4e730b65a65f4347d5e75.png" data-original-src="https://miro.medium.com/v2/resize:fit:1302/format:webp/1*PbBKozv5qGEBhqJeKKbG5w.png"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">框架公理约束示例(图片由作者提供)</p></figure><p id="3bc4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">从上面的例子中，我们可以看出，在执行移动动作后，机器人根据其初始状态保持空载/负载状态。</p><h1 id="fd62" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">求解CSP的算法</h1><p id="6a62" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">我们现在有了我们的有界规划问题——具有固定长度的人工智能规划问题<em class="ml"> k </em>，被编码成一个约束满足问题。我们可以使用现有的解析器来求解CSP。</p><p id="2732" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果有解，解算器将返回指定的变量(参见上一节中的CSP变量)。我们对<em class="ml">行动CSP变量</em>特别感兴趣，以便我们提取计划。</p><p id="db69" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后，我们可以基于该步骤对提取的<em class="ml">动作CSP变量</em>进行排序，并拥有我们的计划。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/32ed0f6f6d8f3a6f55192ae5e97c013d.png" data-original-src="https://miro.medium.com/v2/resize:fit:462/format:webp/1*t3cEuwjlYDWBC-bgC8XGnA.png"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">有序计划(图片由作者提供)</p></figure><h2 id="a59f" class="mr lg it bd lh ms mt dn ll mu mv dp lp kb mw mx lt kf my mz lx kj na nb mb nc bi translated">求解CSP的搜索算法</h2><p id="a7ae" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">常见的求解器是回溯搜索算法，如下所示。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/5a3ac2881751cf65c6ff4c86b2bb08dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:674/format:webp/1*rsFvE7wb7wRrhednPAYRkA.png"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">回溯搜索算法(作者图片)</p></figure><p id="36a2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个算法很简单。它接收σ中的部分解和x中的未赋值变量。</p><p id="dfe7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果所有变量都已赋值，这意味着我们有了解，算法返回σ。</p><p id="342b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">否则，它将选择一个变量为其赋值。然后，它继续从域d中删除不一致的值。</p><p id="9148" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后给它赋值，然后递归调用自己。如果在某一点失败，它会回溯并在“选择vi ∈ Di”处选择另一个值。</p><p id="7d79" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当我们用Python实现这个算法时，它会更容易阅读。</p><h1 id="a170" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">Python中的结论和代码</h1><p id="f74a" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">在这篇文章中，我们学习了如何使用现有的技术——CSP，通过将经典的规划问题表示编码为有界规划问题和约束满足问题，来找到规划问题的解决方案。</p><p id="0fa9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后，我们使用经典的CSP回溯算法来解决我们的CSP。</p><p id="b23f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这种方法的一个限制是我们需要指定计划的长度，这意味着我们可能需要尝试几次才能知道我们的问题是否存在解决方案。</p><p id="a95c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我用Python写了编码和CSP回溯算法。CSP回溯算法取自以下链接:</p><div class="od oe gp gr of og"><a href="https://freecontent.manning.com/constraint-satisfaction-problems-in-python/" rel="noopener  ugc nofollow" target="_blank"><div class="oh ab fo"><div class="oi ab oj cl cj ok"><h2 class="bd iu gy z fp ol fr fs om fu fw is bi translated">Python - Manning中的约束满足问题</h2><div class="on l"><h3 class="bd b gy z fp ol fr fs om fu fw dk translated">从经典的计算机科学问题，在Python中由大卫科佩卡大量的问题，计算工具…</h3></div><div class="oo l"><p class="bd b dl z fp ol fr fs om fu fw dk translated">freecontent.manning.com</p></div></div><div class="op l"><div class="oq l or os ot op ou ky og"/></div></div></a></div><p id="aa66" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">…因为我发现使用函数比使用上一节算法中的元组集更容易理解和实现CSP约束。</p><p id="14f4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您对代码感兴趣，请从这里获取:</p><div class="od oe gp gr of og"><a href="https://github.com/debbynirwan/planning_csps" rel="noopener  ugc nofollow" target="_blank"><div class="oh ab fo"><div class="oi ab oj cl cj ok"><h2 class="bd iu gy z fp ol fr fs om fu fw is bi translated">debbynirwan/planning _ CSP</h2><div class="on l"><h3 class="bd b gy z fp ol fr fs om fu fw dk translated">具有约束满足问题的人工智能规划。- debbynirwan/planning_csps</h3></div><div class="oo l"><p class="bd b dl z fp ol fr fs om fu fw dk translated">github.com</p></div></div><div class="op l"><div class="ov l or os ot op ou ky og"/></div></div></a></div></div></div>    
</body>
</html>