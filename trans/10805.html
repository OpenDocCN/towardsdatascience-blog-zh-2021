<html>
<head>
<title>Top 6 Python Tips for Data Scientists</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数据科学家的6大Python技巧</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/top-6-python-tips-for-data-scientists-4f4a25e44d15?source=collection_archive---------14-----------------------#2021-10-19">https://towardsdatascience.com/top-6-python-tips-for-data-scientists-4f4a25e44d15?source=collection_archive---------14-----------------------#2021-10-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5143" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">来自我日常分析项目的实用技巧和诀窍</h2></div><p id="831e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">编码现在是，并将继续是数据科学的重要组成部分！据说数据科学家接近70%的时间都花在了编码上，我也不例外。在本文中，我将分享6个最有用和实用的Python片段，它们是我在日常工作中解决实际分析问题时收集的。</p><p id="203e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，让我们开始吧！</p><ol class=""><li id="0ac6" class="le lf it kk b kl km ko kp kr lg kv lh kz li ld lj lk ll lm bi translated"><strong class="kk iu">使用exec()动态执行</strong></li></ol><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi ln"><img src="../Images/e29fbc752c3adc7745c7909321d640d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EIzFMWbiwSDLox1qq4jgtw.jpeg"/></div></div><p class="lz ma gj gh gi mb mc bd b be z dk translated">动态执行(<a class="ae md" href="https://www.freepik.com/free-vector/javascript-frameworks-concept-illustration_11905945.htm#page=1&amp;query=code&amp;position=18&amp;from_view=search" rel="noopener ugc nofollow" target="_blank">图像源</a>)</p></figure><p id="248b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="me">场景</em>:你从一个同事那里继承了一个Python项目，并且立即注意到那些脚本都有5000多行代码。相同的代码块被多次复制和粘贴！那么，有没有更有效的方法来实现代码的可重用性呢？</p><p id="f22c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们来探索一下Python中的<code class="fe mf mg mh mi b"> <strong class="kk iu">exec()</strong> </code>函数。简单地说，它接受一个字符串或目标代码，并执行它，如下例所示，</p><figure class="lo lp lq lr gt ls"><div class="bz fp l di"><div class="mj mk l"/></div></figure><pre class="lo lp lq lr gt ml mi mm mn aw mo bi"><span id="4719" class="mp mq it mi b gy mr ms l mt mu">a = 4 and b = 5<br/>a+b = 9</span></pre><p id="3b70" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">更加得心应手？我们可以使用<code class="fe mf mg mh mi b"><strong class="kk iu">exec(open().read()) </strong></code>在Python解释器中调用和执行文件。举个例子，</p><figure class="lo lp lq lr gt ls"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="8665" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有了这个强大的一行程序，数据科学家可以保存将作为独立文件重用的程序，并在需要时在主程序中执行它们。再也不用复制和粘贴代码了！</p><p id="9e79" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">作为Python中一个很酷的功能，<code class="fe mf mg mh mi b"> <strong class="kk iu">exec()</strong> </code>有一个需要避免的缺陷——它不返回任何值，</p><figure class="lo lp lq lr gt ls"><div class="bz fp l di"><div class="mj mk l"/></div></figure><pre class="lo lp lq lr gt ml mi mm mn aw mo bi"><span id="df11" class="mp mq it mi b gy mr ms l mt mu">a = 4 and b = 5<br/>a+b = 9<br/>** Is the return from exec() is None? True **</span></pre><p id="ee9d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以看到，<code class="fe mf mg mh mi b"><strong class="kk iu">exec()</strong></code>函数的输出是<strong class="kk iu">None</strong>；因此，它不能用来存储任何值，这相当于r中的<code class="fe mf mg mh mi b"><a class="ae md" href="https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/source" rel="noopener ugc nofollow" target="_blank"><strong class="kk iu">sounce()</strong></a></code>函数</p><p id="5918" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"><em class="me">* * *加入我们的YouTube社区🎦</em> </strong> <a class="ae md" href="https://www.youtube.com/channel/UCbGx9Om38Ywlqi0x8RljNdw" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu"> <em class="me">【数据说话带吉】</em> </strong> </a> <strong class="kk iu"> <em class="me">😄</em> </strong></p><figure class="lo lp lq lr gt ls"><div class="bz fp l di"><div class="mv mk l"/></div></figure><p id="b786" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> 2。使用{os}和{shutil}的操作系统命令</strong></p><p id="b69f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">场景:从我们之前的技巧继续，现在你想在执行之前检查脚本。不要一路双击鼠标来打开文件？没问题，你可以直接用Python轻松实现这个，不打断你的思路。</p><figure class="lo lp lq lr gt ls"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="becb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这里，<code class="fe mf mg mh mi b"><strong class="kk iu">os.startfile()</strong></code>功能允许用户打开任何类型的文件，包括MS文档、电子表格、R和SQL脚本。</p><p id="369d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">同样，我们也可以使用<code class="fe mf mg mh mi b"><strong class="kk iu">os.remove(“myFullFileName.ANYFORMAT”)</strong></code>删除文件</p><p id="2249" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">或者使用<code class="fe mf mg mh mi b"><strong class="kk iu">shutil.rmtree(“folderToBeRemoved”)</strong></code>删除整个目录。其中{shutil}是一个Python模块，提供了许多高级文件操作，尤其是文件复制和删除操作。</p><p id="dfab" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，如果你没有使用过除了<code class="fe mf mg mh mi b"><strong class="kk iu">os.getcwd()</strong></code>或<code class="fe mf mg mh mi b"><strong class="kk iu">os.chdir()</strong></code>之外的{ <a class="ae md" href="https://docs.python.org/3/library/os.html" rel="noopener ugc nofollow" target="_blank"> os </a>，或者如果{ <a class="ae md" href="https://docs.python.org/3/library/shutil.html" rel="noopener ugc nofollow" target="_blank"> shutil </a> }听起来很陌生，那么是时候检查一下他们的文档了。您肯定会找到有用的命令或文件系统方法，使您的编码更容易。这里列出了一些我最喜欢的，</p><ul class=""><li id="6b98" class="le lf it kk b kl km ko kp kr lg kv lh kz li ld mw lk ll lm bi translated"><code class="fe mf mg mh mi b"><strong class="kk iu">os.listdir()</strong></code>或<code class="fe mf mg mh mi b"><strong class="kk iu">os.listdir(“someDirectory”)</strong></code> —分别列出当前工作目录或任意用户指定目录下的所有文件；</li><li id="5998" class="le lf it kk b kl mx ko my kr mz kv na kz nb ld mw lk ll lm bi translated"><code class="fe mf mg mh mi b"><strong class="kk iu">os.path.join()</strong></code> —自动创建一个包含参数元素的路径，以备后用，例如<code class="fe mf mg mh mi b"><strong class="kk iu">os.path.join(‘D’, ‘Medium’, ‘New Folder’)</strong></code>将返回</li></ul><pre class="lo lp lq lr gt ml mi mm mn aw mo bi"><span id="95db" class="mp mq it mi b gy mr ms l mt mu"> ‘D\\Medium\\New Folder’</span></pre><ul class=""><li id="3441" class="le lf it kk b kl km ko kp kr lg kv lh kz li ld mw lk ll lm bi translated"><code class="fe mf mg mh mi b"><strong class="kk iu">os.makedirs()</strong></code> —创建目录；</li><li id="f7f3" class="le lf it kk b kl mx ko my kr mz kv na kz nb ld mw lk ll lm bi translated"><code class="fe mf mg mh mi b"><strong class="kk iu">shutil.copy2(“sourcePath”, “destinationPath”)</strong></code>或<code class="fe mf mg mh mi b"><strong class="kk iu">shutil.move(“sourcePath”, “destinationPath”)</strong></code> <strong class="kk iu"> </strong> —分别复制或剪切一个文件。</li></ul><p id="32b9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> 3。一行程序:嵌套列表理解以摆脱for循环</strong></p><p id="560a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="me">场景</em>:我们遇到的这个“简单”的任务是将几个列表合并成一个大的长列表，</p><figure class="lo lp lq lr gt ls"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="d9b5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当然，我们可以为循环编写五个嵌套的<strong class="kk iu">来将每个子列表添加到最终的输出列表中。但是更聪明的做法是以最简洁的方式理解嵌套列表，</strong></p><figure class="lo lp lq lr gt ls"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="aec1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> 4。计时器被包装成装饰器</strong></p><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi ln"><img src="../Images/fb8826148a422ef19b4edb3ab7ba77de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EmQ1U5zJZ202NiZmAJvZpw.jpeg"/></div></div><p class="lz ma gj gh gi mb mc bd b be z dk translated">计时器作为装饰器(<a class="ae md" href="https://www.freepik.com/free-vector/time-management-concept_14449321.htm#page=1&amp;query=timer&amp;position=7&amp;from_view=keyword" rel="noopener ugc nofollow" target="_blank">图像源</a>)</p></figure><p id="6bb7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="me">场景</em>:虽然Python被公认为最有效的编程语言之一，但数据科学家仍然需要检查我们程序的运行时。</p><p id="7460" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们只是为想要监控的每个函数实现一个基本的Python定时器，这并不是最难的事情。然而，如果我们把它编码成一个装饰器，我们会使我们的定时器更容易被版本控制和重用！</p><p id="6157" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里是如何，</p><figure class="lo lp lq lr gt ls"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="952f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这个片段中，</p><ul class=""><li id="8b7f" class="le lf it kk b kl km ko kp kr lg kv lh kz li ld mw lk ll lm bi translated">计时器被包装在一个<code class="fe mf mg mh mi b"><strong class="kk iu">timerWrapper</strong> </code>函数中，该函数被用作在main函数之前调用的装饰器；</li><li id="873f" class="le lf it kk b kl mx ko my kr mz kv na kz nb ld mw lk ll lm bi translated">示例的主要功能是返回一个连接到URL的请求，这是我以前的博客之一<a class="ae md" rel="noopener" target="_blank" href="/6-sql-tricks-every-data-scientist-should-know-f84be499aea5">。</a></li></ul><p id="8b58" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">运行这段代码可以得到经过的时间，</p><pre class="lo lp lq lr gt ml mi mm mn aw mo bi"><span id="81dd" class="mp mq it mi b gy mr ms l mt mu">Current function: getArtile<br/> Run Time: 1.6542516000008618</span><span id="ba69" class="mp mq it mi b gy nc ms l mt mu">Out[101]: &lt;Response [200]&gt;</span></pre><p id="0242" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，为了给另一个函数计时，我们需要做的就是把<code class="fe mf mg mh mi b"><strong class="kk iu"><em class="me">@timeWrapper</em></strong></code>放在函数前面，</p><figure class="lo lp lq lr gt ls"><div class="bz fp l di"><div class="mj mk l"/></div></figure><pre class="lo lp lq lr gt ml mi mm mn aw mo bi"><span id="fc5f" class="mp mq it mi b gy mr ms l mt mu">getMultiplication(3)<br/>10<br/>10000000000<br/>10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<br/>Current function: getMultiplication<br/> Run Time: 0.00014700000065204222</span></pre><p id="c61a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> 5。利用</strong> <code class="fe mf mg mh mi b"><strong class="kk iu">options</strong></code> <strong class="kk iu">系统定制您的显示器</strong></p><p id="c261" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="me">场景</em>:作为数据科学家，我们每天用{pandas}和{numpy}分析数据。当我第一次学习Python编码时，在将我的数据读入IDE后，我很沮丧地看到了这一点，</p><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/92521bbd7fc7795a699d4553ac251db1.png" data-original-src="https://miro.medium.com/v2/resize:fit:588/format:webp/1*pgU6nQiReQEqwnKvosSWiQ.png"/></div></figure><p id="112d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">显然，数据显示在行方向和列方向都被截断了，下面的代码可以修复这个问题，</p><figure class="lo lp lq lr gt ls"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="d70c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里，我们明确地设置了在控制台中显示/打印的最大列数、行数和列宽。{pandas}中有很多可定制的<a class="ae md" href="https://pandas.pydata.org/docs/user_guide/options.html" rel="noopener ugc nofollow" target="_blank">选项和设置</a>，类似的操作在<a class="ae md" href="https://numpy.org/doc/stable/reference/generated/numpy.set_printoptions.html" rel="noopener ugc nofollow" target="_blank"> {numpy} </a>中也有，针对数组和矩阵，</p><figure class="lo lp lq lr gt ls"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="466e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> 6。重现你的机器学习模型结果？设定种子！</strong></p><p id="9735" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="me">场景</em>:由于机器学习建模过程的随机性，我们都遇到过机器学习的不确定性。这种随机性导致我们很难在不同的运行中重现相同的结果。因此，很难确定性能指标的改进是成功的模型调整的结果，还是仅仅是不同的随机训练/测试样本。</p><p id="0f24" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">幸运的是，只要你做得正确，通过<strong class="kk iu">在整个模型管道中设置随机种子</strong>，就可以实现再现性！你见过多少次堆栈溢出时弹出“尽管定义了随机种子，但得到了不同的结果”这样的问题？嗯，如何恰当地设置种子应该在文档的第一页，但我花了一些时间来挖掘它。</p><p id="a723" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我发现在{numpy}、{sklearn}、{tensorflow}或{torch}中，并不是每个种子的定义都一样。因此，最好的做法是使用一个明确的函数，为所有的框架设置所有的种子。举个例子，</p><figure class="lo lp lq lr gt ls"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="e045" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">将这种战术性的<code class="fe mf mg mh mi b"><strong class="kk iu">reset_random_seed()</strong></code>功能添加到你工作流程的所有必要步骤中，比如训练-测试分割、模型编译/训练和解释，将会使你达到完全的可再现性。对你的实验更详细的了解将会完成后半部分！</p></div><div class="ab cl ne nf hx ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="im in io ip iq"><p id="3462" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">希望你已经学到了一些新的功能，或者重新发现了一些你以前可能忽略的功能。如果您受到启发，想在自己的代码中使用其中的一个或几个，那就太棒了！如果你知道Python的其他隐藏的瑰宝，请在下面留下评论。😃</p><p id="a09b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> <em class="me">想要更多的数据科学和编程技巧？使用</em> </strong> <a class="ae md" href="https://yilistats.medium.com/membership" rel="noopener"> <strong class="kk iu"> <em class="me">我的链接</em> </strong> </a> <strong class="kk iu"> <em class="me">注册Medium，获得我所有内容的完全访问权限。</em> </strong></p><p id="28f0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> <em class="me">还订阅我新创建的YouTube频道</em> </strong> <a class="ae md" href="https://www.youtube.com/channel/UCbGx9Om38Ywlqi0x8RljNdw" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu"> <em class="me">【数据谈吉】</em></strong></a><strong class="kk iu"><em class="me"/></strong></p><figure class="lo lp lq lr gt ls"><div class="bz fp l di"><div class="mv mk l"/></div></figure><h2 id="7759" class="mp mq it bd nl nm nn dn no np nq dp nr kr ns nt nu kv nv nw nx kz ny nz oa ob bi translated">进一步阅读</h2><div class="oc od gp gr oe of"><a rel="noopener follow" target="_blank" href="/3-common-sql-errors-to-spot-an-inexperienced-data-scientist-310b3e98842f"><div class="og ab fo"><div class="oh ab oi cl cj oj"><h2 class="bd iu gy z fp ok fr fs ol fu fw is bi translated">发现缺乏经验的数据科学家的3个常见SQL错误</h2><div class="om l"><h3 class="bd b gy z fp ok fr fs ol fu fw dk translated">以下是修复它们的方法</h3></div><div class="on l"><p class="bd b dl z fp ok fr fs ol fu fw dk translated">towardsdatascience.com</p></div></div><div class="oo l"><div class="op l oq or os oo ot lx of"/></div></div></a></div><div class="oc od gp gr oe of"><a href="https://levelup.gitconnected.com/6-hilarious-programmers-data-scientists-jokes-to-kick-start-2021-187f86dd6a4c" rel="noopener  ugc nofollow" target="_blank"><div class="og ab fo"><div class="oh ab oi cl cj oj"><h2 class="bd iu gy z fp ok fr fs ol fu fw is bi translated">6个令人捧腹的程序员/数据科学家笑话开启2021年</h2><div class="om l"><h3 class="bd b gy z fp ok fr fs ol fu fw dk translated">做好准备:这些愚蠢的老笑话会让你捧腹大笑😁</h3></div><div class="on l"><p class="bd b dl z fp ok fr fs ol fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="oo l"><div class="ou l oq or os oo ot lx of"/></div></div></a></div></div></div>    
</body>
</html>