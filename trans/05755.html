<html>
<head>
<title>How Much Memory is your ML Code Consuming?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你的ML代码消耗了多少内存？</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-much-memory-is-your-ml-code-consuming-98df64074c8f?source=collection_archive---------7-----------------------#2021-05-23">https://towardsdatascience.com/how-much-memory-is-your-ml-code-consuming-98df64074c8f?source=collection_archive---------7-----------------------#2021-05-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4c7b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解如何通过一行命令快速检查机器学习功能/模块的内存占用。生成一个好的报告。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d403d4fa9c0f1ff82bd4a45fd49a6fb4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xZne_oOiNwAqpxWFp2voxA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源:<a class="ae ky" href="https://pixabay.com/photos/hourglass-clock-time-period-hours-2910951/" rel="noopener ugc nofollow" target="_blank"> Pixabay </a></p></figure><h1 id="da46" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">为什么要分析内存使用情况？</h1><p id="8420" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">假设你已经编写了一个很酷的机器学习(ML)应用程序，或者创建了一个闪亮的神经网络模型。现在，您希望在某个web服务或REST API上部署这个模型。</p><p id="62c8" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">或者，您可能已经基于来自制造工厂的工业传感器的数据流开发了该模型，现在您必须将该模型部署在一台工业控制电脑上，以便根据持续输入的数据做出决策。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/2ad433a4403036c5595d6d2a98541f58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CxbPEy00b0523cIeawFE3A.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">“很高兴开发出闪亮的ML模型”。图片来源:<a class="ae ky" href="https://pixabay.com/photos/children-win-success-video-game-593313/" rel="noopener ugc nofollow" target="_blank"> Pixabay </a></p></figure><p id="a47b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">作为一名数据科学家，你可能期望工程/平台团队提出的一个极其常见的问题是“<strong class="lt iu"> <em class="ms">”你的模型/代码有多少内存占用？</em> </strong>或<strong class="lt iu"> <em class="ms">在给定的数据负载下运行时，您的代码的内存使用峰值是多少？</em> </strong></p><p id="a347" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这是很自然的，因为<strong class="lt iu">硬件资源可能是有限的</strong>并且一个单独的ML模块不应该占用系统的所有内存。对于边缘计算场景来说，这一点<strong class="lt iu">尤其正确，即ML应用可能在边缘上运行，例如在工业PC上的虚拟化容器内。</strong></p><p id="18e0" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">此外，您的型号可能是运行在该硬件上的数百种型号中的一种，您必须<strong class="lt iu">对内存使用峰值有所了解</strong>，因为如果大量型号同时出现内存使用峰值，可能会导致系统崩溃。</p><p id="82ef" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这让你很好奇，不是吗？</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/b294fad1843cb943fe8e97d331b19987.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uzKuxzSicYPpwC9txjdG0w.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源:<a class="ae ky" href="https://pixabay.com/photos/child-surprise-think-interactivity-2800835/" rel="noopener ugc nofollow" target="_blank"> Pixabay </a></p></figure><blockquote class="mt"><p id="3921" class="mu mv it bd mw mx my mz na nb nc mm dk translated"><strong class="ak"> …硬件资源可能是有限的</strong>，单个ML模块不应该占用系统的所有内存。对于边缘计算场景来说，<strong class="ak">尤其如此……</strong></p></blockquote><h2 id="1c5f" class="nd la it bd lb ne nf dn lf ng nh dp lj ma ni nj ll me nk nl ln mi nm nn lp no bi translated">不要犯这个根本性的错误</h2><p id="6e05" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">注意，我们讨论的是整个代码的运行时内存配置文件(一个动态量)。这与您的ML模型的大小或压缩无关(您可能已经将它作为特殊对象保存在磁盘上，例如<a class="ae ky" href="https://scikit-learn.org/stable/modules/model_persistence.html" rel="noopener ugc nofollow" target="_blank"> Scikit-learn Joblib dump </a>，一个简单的Python Pickle dump，一个<a class="ae ky" href="https://www.tensorflow.org/tutorials/keras/save_and_load" rel="noopener ugc nofollow" target="_blank"> TensorFlow HFD5 </a>，等等)。</p><h1 id="5a46" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">Scalene:一个小巧的内存/CPU/GPU分析器</h1><p id="5f96" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">这里有一篇文章介绍了一些与Python一起使用的旧内存分析器。</p><div class="np nq gp gr nr ns"><a href="https://www.pluralsight.com/guides/profiling-memory-usage-in-python" rel="noopener  ugc nofollow" target="_blank"><div class="nt ab fo"><div class="nu ab nv cl cj nw"><h2 class="bd iu gy z fp nx fr fs ny fu fw is bi translated">如何在Python | Pluralsight | Pluralsight中管理内存</h2><div class="nz l"><h3 class="bd b gy z fp nx fr fs ny fu fw dk translated">Luke Lee Python使开发比C和C++之类的语言更快更容易的方法之一是内存管理…</h3></div><div class="oa l"><p class="bd b dl z fp nx fr fs ny fu fw dk translated">www.pluralsight.com</p></div></div></div></a></div><p id="1ff0" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在本文中，我们将讨论<strong class="lt iu">Scalene</strong>——您可以一站式回答工程团队提出的这些问题。</p><p id="a56a" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">根据其<a class="ae ky" href="https://github.com/plasma-umass/scalene" rel="noopener ugc nofollow" target="_blank"> GitHub页面</a> , " <em class="ms"> Scalene是一个用于Python的高性能CPU、GPU和内存分析器，它可以做许多其他Python分析器不能做的事情。它的运行速度比其他分析器快几个数量级，同时提供更详细的信息。</em>”</p><p id="5287" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">它是由马萨诸塞大学开发的。查看此视频，了解全面的介绍。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><h2 id="feee" class="nd la it bd lb ne od dn lf ng oe dp lj ma of nj ll me og nl ln mi oh nn lp no bi translated">安装</h2><p id="21a0" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">毕竟是Python包。所以，通常安装，</p><pre class="kj kk kl km gt oi oj ok ol aw om bi"><span id="29d8" class="nd la it oj b gy on oo l op oq"><strong class="oj iu">pip install scalene</strong></span></pre><p id="30b5" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">目前，仅适用于Linux操作系统。我没有在Windows 10上测试它。</p><h2 id="94f6" class="nd la it bd lb ne od dn lf ng oe dp lj ma of nj ll me og nl ln mi oh nn lp no bi translated">在CLI或Jupyter笔记本中使用</h2><p id="4dca" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">不等边三角形的使用非常直接，</p><pre class="kj kk kl km gt oi oj ok ol aw om bi"><span id="a368" class="nd la it oj b gy on oo l op oq"><strong class="oj iu">scalene &lt;yourapp.py&gt;</strong></span></pre><p id="c6b7" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">或者，您可以在Jupyter笔记本中使用这个神奇的命令，</p><pre class="kj kk kl km gt oi oj ok ol aw om bi"><span id="9674" class="nd la it oj b gy on oo l op oq"><strong class="oj iu">%load_ext scalene</strong></span></pre><h2 id="bc23" class="nd la it bd lb ne od dn lf ng oe dp lj ma of nj ll me og nl ln mi oh nn lp no bi translated">示例输出</h2><p id="f80b" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">下面是一个输出示例。我们将很快对此进行更深入的研究。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi or"><img src="../Images/62e166c67b75979da67849c9fa284eba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pykrsdprNMudWWaaGEnImw.png"/></div></div></figure><h2 id="bb59" class="nd la it bd lb ne od dn lf ng oe dp lj ma of nj ll me og nl ln mi oh nn lp no bi translated">特征</h2><p id="71f3" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">以下是Scalene的一些很酷的特性。大多数都是不言自明的，可以从上面的截图中判断出来，</p><ul class=""><li id="9a64" class="os ot it lt b lu mn lx mo ma ou me ov mi ow mm ox oy oz pa bi translated"><strong class="lt iu">行或函数</strong>:报告整个函数和每个独立代码行的信息</li><li id="c5d5" class="os ot it lt b lu pb lx pc ma pd me pe mi pf mm ox oy oz pa bi translated"><strong class="lt iu">线程</strong>:支持Python线程。</li><li id="a008" class="os ot it lt b lu pb lx pc ma pd me pe mi pf mm ox oy oz pa bi translated"><strong class="lt iu">多重处理</strong>:支持使用<code class="fe pg ph pi oj b">multiprocessing</code>库</li><li id="daf9" class="os ot it lt b lu pb lx pc ma pd me pe mi pf mm ox oy oz pa bi translated"><strong class="lt iu"> Python与C的时间对比</strong> : Scalene显示了Python与本机代码(如库)的时间对比</li><li id="3b56" class="os ot it lt b lu pb lx pc ma pd me pe mi pf mm ox oy oz pa bi translated"><strong class="lt iu">系统时间</strong>:区分系统时间(如睡眠或执行I/O操作)</li><li id="32e2" class="os ot it lt b lu pb lx pc ma pd me pe mi pf mm ox oy oz pa bi translated"><strong class="lt iu"> GPU </strong>:它还可以报告花费在NVIDIA GPU上的时间(如果有的话)</li><li id="f0ae" class="os ot it lt b lu pb lx pc ma pd me pe mi pf mm ox oy oz pa bi translated"><strong class="lt iu">复制量</strong>:报告每秒复制的数据量</li><li id="2ad2" class="os ot it lt b lu pb lx pc ma pd me pe mi pf mm ox oy oz pa bi translated"><strong class="lt iu">检测泄漏</strong> : Scalene可以自动查明可能导致内存泄漏的线路！</li></ul><h1 id="ad4f" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">一个具体的机器学习代码示例</h1><p id="381b" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">让我们言归正传，将Scalene用于内存分析标准机器学习代码。我们将研究两种不同类型的ML模型——原因将很快阐明。我们将对所有三个模型使用Scikit-learn库，并利用其合成数据生成功能来创建我们的数据集。</p><ul class=""><li id="f941" class="os ot it lt b lu mn lx mo ma ou me ov mi ow mm ox oy oz pa bi translated">多元线性回归模型</li><li id="6f49" class="os ot it lt b lu pb lx pc ma pd me pe mi pf mm ox oy oz pa bi translated">具有相同数据集的深度神经网络模型</li></ul><p id="d3c4" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">所有三个模型的建模代码都遵循完全相同的结构。下图中还显示了外部I/O操作，因为我们将看到，根据型号的类型，它们可能会也可能不会主导内存配置文件。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pj"><img src="../Images/35680dc5e2ff08c1d34b0b06afbc47b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6rTDpcXSfrIQqZN-rCtOrw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源:作者出品(拥有版权)</p></figure><h2 id="78f4" class="nd la it bd lb ne od dn lf ng oe dp lj ma of nj ll me og nl ln mi oh nn lp no bi translated">线性回归模型</h2><p id="a320" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">代码文件在我的GitHub repo 中的<a class="ae ky" href="https://github.com/tirthajyoti/Machine-Learning-with-Python/blob/master/Memory-profiling/Scalene/linearmodel.py" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="291d" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们使用标准导入和两个变量<code class="fe pg ph pi oj b">NUM_FEATURES</code>和<code class="fe pg ph pi oj b">NUM_SMPLES</code>来做一些实验。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pk"><img src="../Images/c4e599dd6fcb8840cbba3c109d929fb3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1172/format:webp/1*NetQpTPiN03q7ChfFq26Ow.png"/></div></figure><p id="bd8f" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们没有展示数据生成和模型拟合代码。它们相当标准，可以在这里看到<a class="ae ky" href="https://github.com/tirthajyoti/Machine-Learning-with-Python/blob/master/Memory-profiling/Scalene/linearmodel.py" rel="noopener ugc nofollow" target="_blank"/>。我们将拟合的模型保存为一个pickled dump，并加载它和一个用于推理的测试CSV文件。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pl"><img src="../Images/8a2bfe34859b042a003c5551ca927962.png" data-original-src="https://miro.medium.com/v2/resize:fit:1160/format:webp/1*CkrLolWSMtr-jUMqQ9p2bA.png"/></div></figure><p id="b9e0" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">为了清晰起见，我们在一个<code class="fe pg ph pi oj b">main</code>循环下运行所有东西，执行和报告都是不规则的(你很快就会明白)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pm"><img src="../Images/053834a3c420363fa956494fcf00b824.png" data-original-src="https://miro.medium.com/v2/resize:fit:1234/format:webp/1*1ED3S_JTDFvvIsW9kwXRyg.png"/></div></figure><p id="545e" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">当我们运行该命令时，</p><pre class="kj kk kl km gt oi oj ok ol aw om bi"><span id="1053" class="nd la it oj b gy on oo l op oq">$ scalene linearmodel.py --html &gt;&gt; linearmodel-scalene.html</span></pre><p id="b0e5" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们得到这些结果作为输出。<strong class="lt iu">注意，这里我使用了</strong> <code class="fe pg ph pi oj b"><strong class="lt iu">--html</strong></code> <strong class="lt iu">标志，并将输出传输到一个HTML文件中，以便于报告</strong>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pn"><img src="../Images/c2f243cc3354b2a033d0d9e1a34e2cc7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RSP91deNYnS4Cug1o6-hHA.png"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi po"><img src="../Images/5d09df79ef24f34477aab0a3245da1ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RYc7X90ODFVQtJcg7OTA-g.png"/></div></div></figure><h2 id="3326" class="nd la it bd lb ne od dn lf ng oe dp lj ma of nj ll me og nl ln mi oh nn lp no bi translated"><strong class="ak">那么，这个结果有什么惊人之处呢？</strong></h2><p id="c7b9" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">内存占用几乎完全由外部I/O(如Pandas和Scikit-learn estimator加载)控制，少量内存用于将测试数据写入磁盘上的CSV文件。</p><p id="1933" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">实际的ML建模、Numpy或Pandas操作以及推理根本不会影响内存！</p><h2 id="0d94" class="nd la it bd lb ne od dn lf ng oe dp lj ma of nj ll me og nl ln mi oh nn lp no bi translated">当模型和数据缩放时会发生什么？</h2><p id="79dd" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我们可以调整数据集大小(行数)和模型复杂性(要素数)，并运行相同的内存分析来记录各种操作在内存消耗方面的表现。结果如下所示。</p><p id="390a" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这里的<strong class="lt iu"> X轴表示一对</strong>的特征数量/数据点数量。请注意，此图描绘的是百分比而非绝对值，以展示各种类型操作的相对重要性。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pp"><img src="../Images/29cb3d092a95e53ab03d902e5194c4cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9jwRevcOCWctABUWVietEQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源:作者出品(拥有版权)</p></figure><h2 id="9baf" class="nd la it bd lb ne od dn lf ng oe dp lj ma of nj ll me og nl ln mi oh nn lp no bi translated">所以，对于线性回归模型…</h2><p id="4494" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">从这些实验中，我们得出结论，Scikit-learn线性回归估计器非常有效，并且<strong class="lt iu">不会为实际的模型拟合或推断</strong>消耗太多内存。</p><p id="d403" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">然而，就代码而言，它确实有一个固定的内存足迹，并且在加载时会消耗那么多内存。然而，随着数据大小和模型复杂性的增加，代码占用的百分比总体上是下降的。</p><p id="73e4" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">因此，如果您正在使用这样一个<strong class="lt iu">小型线性模型，那么您可能想要关注数据文件I/O来优化您的代码</strong>以获得更好的内存性能。</p><h2 id="5663" class="nd la it bd lb ne od dn lf ng oe dp lj ma of nj ll me og nl ln mi oh nn lp no bi translated">深度神经网络会发生什么？</h2><p id="b4d5" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">如果我们用一个2隐藏层的神经网络(每个隐藏层有50个神经元)运行类似的实验，那么结果看起来如下。<a class="ae ky" href="https://github.com/tirthajyoti/Machine-Learning-with-Python/blob/master/Memory-profiling/Scalene/mlp.py" rel="noopener ugc nofollow" target="_blank">代码文件在这里</a>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pp"><img src="../Images/43c227f6218def5671e0252fc21ab30c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9NaZoSLXGJsvKClnOtLHjQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源:作者出品(拥有版权)</p></figure><p id="5486" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">显然，<strong class="lt iu">神经网络模型在训练/拟合步骤消耗大量内存，不像线性回归模型</strong>。但是，对于少量要素和大数据量，拟合占用的内存量很少。</p><p id="38b1" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">您还可以试验各种架构和超参数，并记录内存使用情况，以获得适合您的情况的设置。</p><h1 id="8dbb" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">遵循实验方法</h1><p id="e593" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">如果您使用相同的<a class="ae ky" href="https://github.com/tirthajyoti/Machine-Learning-with-Python/tree/master/Memory-profiling/Scalene" rel="noopener ugc nofollow" target="_blank">代码文件</a>重复实验，结果将会根据您的硬件、磁盘/ CPU/ GPU/内存类型而有很大差异。本文的目的不是关注实际值，甚至不是关注趋势。我想让你拿走为你自己的代码做内存分析实验的方法。</p><h2 id="9cd2" class="nd la it bd lb ne od dn lf ng oe dp lj ma of nj ll me og nl ln mi oh nn lp no bi translated">一些重要的建议</h2><ul class=""><li id="f4c9" class="os ot it lt b lu lv lx ly ma pq me pr mi ps mm ox oy oz pa bi translated">最好在你的代码中编写专注于一个单一任务的小函数</li><li id="1333" class="os ot it lt b lu pb lx pc ma pd me pe mi pf mm ox oy oz pa bi translated">保留一些<strong class="lt iu">自由变量</strong>,比如特性的数量和数据点的数量，这样当数据/模型扩展时，您可以运行相同的代码文件进行最小的修改来检查内存配置文件</li><li id="1017" class="os ot it lt b lu pb lx pc ma pd me pe mi pf mm ox oy oz pa bi translated">如果你正在比较一个ML算法和另一个，试着保持<strong class="lt iu">结构和整个代码的流程尽可能的一致</strong>以减少混乱。更好的是，只需更改估计器类并比较内存配置文件。</li><li id="b4c3" class="os ot it lt b lu pb lx pc ma pd me pe mi pf mm ox oy oz pa bi translated"><strong class="lt iu">根据您的建模场景，数据和模型I/O </strong>(导入语句，模型在磁盘上的持久性)在内存占用方面可能令人惊讶地占主导地位。做优化的时候千万不要忽略它们。</li><li id="3093" class="os ot it lt b lu pb lx pc ma pd me pe mi pf mm ox oy oz pa bi translated">出于上述同样的原因，考虑比较来自多个实现/包的<strong class="lt iu"> same算法的内存配置文件(例如Keras vs. PyTorch vs. Scikit-learn)。如果内存优化是您的主要目标，那么您可能需要寻找一种内存占用最少但能够令人满意地完成工作的实现，即使它在功能或性能方面不是绝对最好的。</strong></li><li id="1e39" class="os ot it lt b lu pb lx pc ma pd me pe mi pf mm ox oy oz pa bi translated">如果数据I/O成为瓶颈，探索<strong class="lt iu">更快的选项或其他存储类型</strong>，例如用拼花文件和Apache Arrow存储替换Pandas CSV。查看这篇文章，</li></ul><div class="np nq gp gr nr ns"><a rel="noopener follow" target="_blank" href="/how-fast-is-reading-parquet-file-with-arrow-vs-csv-with-pandas-2f8095722e94"><div class="nt ab fo"><div class="nu ab nv cl cj nw"><h2 class="bd iu gy z fp nx fr fs ny fu fw is bi translated">熊猫读拼花文件(带箭头)vs. CSV多快？</h2><div class="nz l"><h3 class="bd b gy z fp nx fr fs ny fu fw dk translated">重点研究使用PyArrow读取拼花文件与使用…读取相同CSV文件的速度比较</h3></div><div class="oa l"><p class="bd b dl z fp nx fr fs ny fu fw dk translated">towardsdatascience.com</p></div></div><div class="pt l"><div class="pu l pv pw px pt py ks ns"/></div></div></a></div><h2 id="44eb" class="nd la it bd lb ne od dn lf ng oe dp lj ma of nj ll me og nl ln mi oh nn lp no bi translated">使用Scalene可以做的其他事情</h2><p id="fccb" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在本文中，我们刚刚讨论了最低限度的内存分析，重点是规范的ML建模代码。您可以利用Scalene CLI的其他选项，</p><ul class=""><li id="de39" class="os ot it lt b lu mn lx mo ma ou me ov mi ow mm ox oy oz pa bi translated">仅分析CPU时间，不分析内存</li><li id="e7f0" class="os ot it lt b lu pb lx pc ma pd me pe mi pf mm ox oy oz pa bi translated">仅使用非零内存占用量减少分析</li><li id="3a2c" class="os ot it lt b lu pb lx pc ma pd me pe mi pf mm ox oy oz pa bi translated">指定CPU和内存分配最小阈值</li><li id="a1ad" class="os ot it lt b lu pb lx pc ma pd me pe mi pf mm ox oy oz pa bi translated">设置CPU采样率</li><li id="291b" class="os ot it lt b lu pb lx pc ma pd me pe mi pf mm ox oy oz pa bi translated">多线程并检查差异</li></ul><h2 id="2669" class="nd la it bd lb ne od dn lf ng oe dp lj ma of nj ll me og nl ln mi oh nn lp no bi translated">最终验证有时是必要的</h2><p id="c655" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">对于资源不足的情况，托管一个验证环境/服务器将是一个好主意，它将接受给定的建模代码(当开发时)并通过这样的内存分析器运行它以创建运行时统计信息。如果它通过了预先确定的内存占用标准，那么只有建模代码才会被接受用于进一步的部署。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pz"><img src="../Images/dddb2e29c1a1b3b1f1c8eec7be27f72b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bXfYGupY5gxdwvqkmZs8tA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源:作者出品(拥有版权)</p></figure><blockquote class="mt"><p id="7ad4" class="mu mv it bd mw mx my mz na nb nc mm dk translated">如果内存优化是您的主要目标，那么您可能需要寻找一种具有最小内存占用量但又能令人满意地完成工作的实现。</p></blockquote><h1 id="3b7b" class="kz la it bd lb lc ld le lf lg lh li lj jz qa ka ll kc qb kd ln kf qc kg lp lq bi translated">摘要</h1><p id="289a" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在本文中，我们讨论了对ML代码进行内存分析的重要性，以便与将代码部署到服务/机器上的平台/工程团队进行顺畅、轻松的交互。剖析内存还可以向您展示基于您正在处理的特定数据和算法优化代码的惊人方法。</p><p id="0747" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们展示了一个典型的ML建模代码示例，它是用一个强大而轻量级的Python库Scalene进行剖析的。我们用线性回归和神经网络模型展示了一些有代表性的结果，并提供了一些一般性的建议。</p><p id="8912" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">希望您在使用这些工具和技术将您的ML代码实现和部署到产品中时获得更多的成功。</p></div><div class="ab cl qd qe hx qf" role="separator"><span class="qg bw bk qh qi qj"/><span class="qg bw bk qh qi qj"/><span class="qg bw bk qh qi"/></div><div class="im in io ip iq"><p id="5bdb" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi qk translated"><span class="l ql qm qn bm qo qp qq qr qs di"> L </span> <em class="ms">喜欢这篇文章？成为</em> <a class="ae ky" href="https://medium.com/@tirthajyoti/membership" rel="noopener"> <strong class="lt iu"> <em class="ms">中等成员</em> </strong> </a> <em class="ms">继续</em> <strong class="lt iu"> <em class="ms">无限制学习</em> </strong> <em class="ms">。如果你使用下面的链接，我会收到你的一部分会员费，</em> <strong class="lt iu"> <em class="ms">而不需要你额外付费</em> </strong> <em class="ms">。</em></p><div class="np nq gp gr nr ns"><a href="https://medium.com/@tirthajyoti/membership" rel="noopener follow" target="_blank"><div class="nt ab fo"><div class="nu ab nv cl cj nw"><h2 class="bd iu gy z fp nx fr fs ny fu fw is bi translated">通过我的推荐链接加入媒体</h2><div class="nz l"><h3 class="bd b gy z fp nx fr fs ny fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="oa l"><p class="bd b dl z fp nx fr fs ny fu fw dk translated">medium.com</p></div></div><div class="pt l"><div class="qt l pv pw px pt py ks ns"/></div></div></a></div></div></div>    
</body>
</html>