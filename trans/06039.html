<html>
<head>
<title>Why Floats Are Inaccurate</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么浮动不准确</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/why-floats-are-inaccurate-2a785649c73d?source=collection_archive---------23-----------------------#2021-05-30">https://towardsdatascience.com/why-floats-are-inaccurate-2a785649c73d?source=collection_archive---------23-----------------------#2021-05-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="22af" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">关于浮点值为何不准确的详细对话。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/4d14c0598d4f7ba0e3825ed2a746eb02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7GS8bris6FppVyhgW1D7uw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(https://pixabay.com/images/id-3456722/</p></figure><h1 id="3b39" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">介绍</h1><p id="bc91" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi mn translated"><span class="l mo mp mq bm mr ms mt mu mv di">在</span>计算中，小数值的概念相当普遍。在科学计算中更是如此，数据通常存储在浮点数据类型的小数值中。有很多关于浮点操作错误的讨论，以及对于计算机来说，浮点是否天生难以处理。即使具有科学和数字能力的语言也有浮点问题，有时会计算不准确。考虑以下两个浮点数的简单加法:</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="3665" class="nb la it mx b gy nc nd l ne nf">0.1 + 0.2</span></pre><p id="4e9b" class="pw-post-body-paragraph lr ls it lt b lu ng ju lw lx nh jx lz ma ni mc md me nj mg mh mi nk mk ml mm im bi translated">这真的很简单，你在第一阶段思考的头脑大概马上就想出了答案。一加二等于三，所以十分之一加十分之二必须加起来是十分之三。当然这是正确的，我们可以用下面的数学表达式来证明:</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="66e8" class="nb la it mx b gy nc nd l ne nf">0.1 + 0.2 == .3</span></pre><p id="9d49" class="pw-post-body-paragraph lr ls it lt b lu ng ju lw lx nh jx lz ma ni mc md me nj mg mh mi nk mk ml mm im bi translated">所以这种数学毫无疑问是正确的，但有趣的是当我们在Python中使用float数据类型做同样的事情时会发生什么。以下是Python REPL中使用相同数学方法:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/ead4a671c6d923b7b1e4a69de91a2edb.png" data-original-src="https://miro.medium.com/v2/resize:fit:662/format:webp/1*3GnLXMGuXxmQb1XD6yje_Q.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="68fc" class="nb la it mx b gy nc nd l ne nf">0.1 + 0.2</span><span id="5009" class="nb la it mx b gy nm nd l ne nf">0.30000000000000004</span></pre><p id="830b" class="pw-post-body-paragraph lr ls it lt b lu ng ju lw lx nh jx lz ma ni mc md me nj mg mh mi nk mk ml mm im bi translated">当然，我们毫无疑问地知道这不是真的。我们的大脑很容易区分这一点</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="5ec2" class="nb la it mx b gy nc nd l ne nf">0.1 + 0.2 == .3<br/>0.1 + 0.2 != 0.30000000000000004</span></pre><p id="dc42" class="pw-post-body-paragraph lr ls it lt b lu ng ju lw lx nh jx lz ma ni mc md me nj mg mh mi nk mk ml mm im bi translated">但很明显，电脑似乎认为它有。我们看到，如果我们把这两个语句放入我们的Python REPL，我们会看到两个都是假的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/add134c0ec2536e72d7a51f908330222.png" data-original-src="https://miro.medium.com/v2/resize:fit:1292/format:webp/1*k-0TlH5bgnzJr-B6OegxnQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="a7c5" class="pw-post-body-paragraph lr ls it lt b lu ng ju lw lx nh jx lz ma ni mc md me nj mg mh mi nk mk ml mm im bi translated">这到底是怎么回事？为什么Python不如我们的大脑准确？</p></div><div class="ab cl no np hx nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="im in io ip iq"><h1 id="09c9" class="kz la it bd lb lc nv le lf lg nw li lj jz nx ka ll kc ny kd ln kf nz kg lp lq bi translated">位</h1><p id="0d2f" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">为了理解为什么我们的计算机可能对这个简单的计算有问题，我们需要考虑计算机是如何存储浮点数的。根据您的系统和安装，Python可能为您的浮点数存储32位或64位签名。我们会假设大部分阅读器的系统架构很可能不是i386，我认为这是一个有效的假设，大部分阅读器很可能是64位系统。</p><p id="998e" class="pw-post-body-paragraph lr ls it lt b lu ng ju lw lx nh jx lz ma ni mc md me nj mg mh mi nk mk ml mm im bi translated">有一种方法可以让我们实际看到在Python中用来存储数据的位，这就是我要用的方法，来演示到底是什么导致了我们的操作错误。我将使用struct模块来实现这一点。struct模块有一个采用两个参数的pack()方法。第一个论点是要解释我们想要包装什么样的类型。为此，我将使用<code class="fe oa ob oc mx b">“&gt;d”</code>。大于号用来表示人类书写数学的方式，大端。d代表双精度浮点数64。让我们看一下我们刚才看到的所有数字的打印输出:</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="261e" class="nb la it mx b gy nc nd l ne nf">&gt;&gt;&gt; o1 = struct.pack("&gt;d", .1)<br/>&gt;&gt;&gt; o2 = struct.pack("&gt;d", .2)<br/>&gt;&gt;&gt; o3 = struct.pack("&gt;d", .3)<br/>&gt;&gt;&gt; print("".join(f"{w:08b}" for w in o1))<br/>0011111110111001100110011001100110011001100110011001100110011010<br/>&gt;&gt;&gt; print("".join(f"{w:08b}" for w in o2))<br/>0011111111001001100110011001100110011001100110011001100110011010<br/>&gt;&gt;&gt; print("".join(f"{w:08b}" for w in o3))<br/>0011111111010011001100110011001100110011001100110011001100110011<br/>&gt;&gt;&gt;</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/63e4a340ce4ae2a4e8c6e8a714ee7eb1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1-9oo8ronmbZ4tG89BVaHQ.png"/></div></div></figure><p id="e667" class="pw-post-body-paragraph lr ls it lt b lu ng ju lw lx nh jx lz ma ni mc md me nj mg mh mi nk mk ml mm im bi translated">现在，让我们以0.1为例，将这几组位稍微分解一下。第一位是一个符号位，这意味着它决定了我们数字的正性，0代表正，1代表负。接下来是11位，在计算机用来表示浮点数的公式中用作指数。这很像科学记数法。让我们使用一个快速for循环来分解这两个值。</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="2009" class="nb la it mx b gy nc nd l ne nf">&gt;&gt;&gt; bits = "".join(f"{w:08b}" for w in o1)<br/>&gt;&gt;&gt; count = 0<br/>&gt;&gt;&gt; signbit = []<br/>&gt;&gt;&gt; exponenetbits = []<br/>&gt;&gt;&gt; fractionalbits = []<br/>&gt;&gt;&gt; for bit in bits:<br/>...     count += 1<br/>...     if count == 1:<br/>...         signbit.append(bit)<br/>...     if count &gt; 1 and count &lt; 13:<br/>...         exponenetbits.append(bit)<br/>...     if count &gt; 12:<br/>...         fractionalbits.append(bit)</span></pre><p id="7e85" class="pw-post-body-paragraph lr ls it lt b lu ng ju lw lx nh jx lz ma ni mc md me nj mg mh mi nk mk ml mm im bi translated">现在让我们按顺序把每个部分打印出来。不要问我为什么不小心输入了“Expo net…”我也不知道发生了什么。</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="576c" class="nb la it mx b gy nc nd l ne nf">&gt;&gt;&gt; print(signbit)<br/>['0']<br/>&gt;&gt;&gt; print(exponentbits)<br/>Traceback (most recent call last):<br/>  File "&lt;stdin&gt;", line 1, in &lt;module&gt;<br/>NameError: name 'exponentbits' is not defined<br/>&gt;&gt;&gt; print(exponenetbits)<br/>['0', '1', '1', '1', '1', '1', '1', '1', '0', '1', '1']<br/>&gt;&gt;&gt; print(fractionalbits)<br/>['1', '0', '0', '1', '1', '0', '0', '1', '1', '0', '0', '1', '1', '0', '0', '1', '1', '0', '0', '1', '1', '0', '0', '1', '1', '0', '0', '1', '1', '0', '0', '1', '1', '0', '0', '1', '1', '0', '0', '1', '1', '0', '0', '1', '1', '0', '0', '1', '1', '0', '1', '0']<br/>&gt;&gt;&gt;</span></pre><p id="7979" class="pw-post-body-paragraph lr ls it lt b lu ng ju lw lx nh jx lz ma ni mc md me nj mg mh mi nk mk ml mm im bi translated">是的，我确实尝试过键入指数位。我们将这些值代入以下公式:</p><p id="5d7d" class="pw-post-body-paragraph lr ls it lt b lu ng ju lw lx nh jx lz ma ni mc md me nj mg mh mi nk mk ml mm im bi translated">(-1) ^符号* 2^e-1023 * 1 .分数</p><p id="c42d" class="pw-post-body-paragraph lr ls it lt b lu ng ju lw lx nh jx lz ma ni mc md me nj mg mh mi nk mk ml mm im bi translated">在这个公式中，每当我们将十分之一和十分之二相加时，我们的小数会被截掉，并在某一点四舍五入。这解释了为什么会出现这种现象，因为一个简单的舍入误差。</p><h1 id="2c8d" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">结论</h1><p id="b046" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我们喜欢认为计算机非常聪明，非常精确，但事实并非如此。在一天结束时，理解计算机如何在这种水平上工作真的会证明为什么计算机会犯这样的简单错误。归根结底，它仍然是一个复杂的unicode和bits系统，共同创建我们编写的表达式。感谢你阅读这篇文章，我希望你学到了一些关于双打的新知识！</p></div></div>    
</body>
</html>