<html>
<head>
<title>3 Reasons Why Jupyter Notebook Is Steering Your Team the Wrong Way</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Jupyter Notebook将您的团队引向歧途的3个原因</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/3-reasons-why-jupyter-notebook-is-steering-your-team-the-wrong-way-abb53cc46823?source=collection_archive---------10-----------------------#2021-09-04">https://towardsdatascience.com/3-reasons-why-jupyter-notebook-is-steering-your-team-the-wrong-way-abb53cc46823?source=collection_archive---------10-----------------------#2021-09-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="c20e" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">意见</h2><div class=""/><div class=""><h2 id="c3ae" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">从人工智能开发者的角度来看</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/f8412688fbc71c6553ccf6569077eae0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wU9TrtoOfZ6hEv3q"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">照片由<a class="ae lh" href="https://unsplash.com/@bdchu614?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">布伦丹·丘奇</a>在<a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="a33b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">过去几年见证了MLOps实践的出现，因为公司开始意识到，要制作一个ML项目，需要的不仅仅是机器学习(ML)模型。有时，这些实践，如确保可重复性、监控和治理，可能比创建模型更复杂。从高层次来看，MLOps旨在使从开发阶段到生产阶段的过渡更加平稳。这种转换的成功通常与源代码的质量有关。因此，仔细选择有助于开发健壮软件的工具非常重要。</p><p id="66e9" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">Jupyter笔记本仍然是许多数据科学团队的首选工具。它用于简单的数据探索，也用于创建数据处理管道和模型训练。一些云解决方案甚至允许您将笔记本电脑部署到生产环境中。我同意这是一个很好的工具，可以探索新的数据集，分析结果，更容易地创建和交互图表。然而，在这篇文章中，我将试着解释为什么Jupyter Notebook不适合你，如果你的目标是构建高质量的软件。</p><h1 id="4ece" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">它鼓励不良的编码习惯</h1><p id="6943" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">软件最佳实践之一是将源代码分成多个文件。这使得代码更容易使用、调试和维护。然而，由于将一个笔记本导入到另一个笔记本中是非常有限的，所以整个代码通常都在一个笔记本中结束。这促进了代码的重复，使得代码库难以维护。</p><p id="65c7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">此外，代码被安排到单元中，而不是定义具有清晰名称和单一职责的小功能的类。这导致了多个问题。首先，在笔记本电脑的生命周期中，要么单元变得非常长，要么同一部分逻辑分布在多个单元中。例如，您会发现在单元号5、10和17中处理的预处理逻辑。第二，测试要么受限，要么几乎不可能。在某些情况下，测试包括运行整个笔记本，没有异常意味着测试成功。其他情况下使用一些原始的pytest端口，其中笔记本需要包含测试。</p><p id="440b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">最后，生成图的代码通常与代码库的其余部分高度耦合。这种耦合使得理解代码和进行更新变得困难。</p><p id="6a35" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">虽然我只触及了潜在问题的表面，但很容易看出这会导致严重的长期问题。首先，由于维护占据了软件项目成本的70%以上，使得代码难以维护将会增加这一比例，或者在最坏的情况下导致完全重写。第二，如果你第一次接触编写源代码是在笔记本上，那么以后要改变这些坏习惯就很难了。</p><h1 id="7c48" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated"><strong class="ak">版本控制是一场噩梦</strong></h1><p id="2b34" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">我们都同意版本控制是强制性的，尤其是对于大型团队。所以，你使用的工具不应该妨碍你的项目的正确版本控制，Jupyter Notebook就不是这样。在引擎盖下，笔记本是包含源代码、绘图数据和Jupyter元数据的大型JSON文件。这使得版本控制成为一场真正的噩梦，因为:</p><ul class=""><li id="e89d" class="nb nc it lk b ll lm lo lp lr nd lv ne lz nf md ng nh ni nj bi translated">检查同一文档的两个版本之间的差异是很困难的。你不能依赖github来做你的拉取请求(PR)，你必须试着找一个第三方库来“尝试”做这件事。</li><li id="a894" class="nb nc it lk b ll nk lo nl lr nm lv nn lz no md ng nh ni nj bi translated">做三路合并是不可能的。您需要打开笔记本并手动进行所有更改。</li><li id="894e" class="nb nc it lk b ll nk lo nl lr nm lv nn lz no md ng nh ni nj bi translated">Jupyter元数据污染了diff历史，使得很难区分代码更新和元数据更改，如单元运行顺序。</li></ul><h1 id="52d2" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">小工具生态系统</h1><p id="1c73" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">工具在任何现代软件开发环境中都扮演着重要的角色。然而，Jupyter笔记本电脑要么功能有限，难以使用，要么根本不存在。例如，如果你想使用<a class="ae lh" href="https://pylint.org" rel="noopener ugc nofollow" target="_blank"> pylint </a>，你需要将你的笔记本导出到一个python脚本，然后运行pylint，之后修复笔记本中的问题并重做。你不能让它像过去10年中的任何IDE一样运行，这适用于大多数静态代码检查器。此外，像自动完成这样的智能感知功能对于现实世界的项目是不可用的。至于调试，通常用prints或原始的pdb来完成，或者使用一个<a class="ae lh" href="https://blog.jupyter.org/a-visual-debugger-for-jupyter-914e61716559" rel="noopener ugc nofollow" target="_blank">扩展</a>来让你有一个可视化的调试器。然而，它并不适用于所有的内核，而且功能非常有限。例如，截至2020年3月，扩展没有几十年前引入的条件断点。</p><h1 id="b508" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">结论</h1><p id="75e2" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">对于Jupyter笔记本用户来说，我知道使用相同的工具进行所有的开发会更容易。然而，我认为你应该为每项任务准备一套合适的工具。你以后会感谢自己的。此外，我知道一些库或工具解决了或将解决我在这篇文章中提到的问题。但是你需要问问你自己，你是否愿意花时间去寻找这些工具，或者使用一些由软件开发人员完善的、开箱即用的工具来为你的项目带来更多的价值。</p><h1 id="5b40" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">在你走之前</h1><p id="b69e" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">在Twitter上关注我，我经常在Twitter上发布关于软件开发和机器学习的消息。</p></div></div>    
</body>
</html>