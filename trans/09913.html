<html>
<head>
<title>Function Decorators in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的函数装饰器</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/function-decorators-in-python-a17958b9d618?source=collection_archive---------6-----------------------#2021-09-18">https://towardsdatascience.com/function-decorators-in-python-a17958b9d618?source=collection_archive---------6-----------------------#2021-09-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d3f3" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">为什么您可能需要它们以及如何实现一个定制的</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/3e87b3046e57e556b740062e7e49247c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Vyy7N0awIHsrIyyZ7MsjzQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">约翰·安维克在Unsplash<a class="ae ky" href="https://unsplash.com/s/photos/prism?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">上的照片</a></p></figure><p id="8db9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">装饰者在第一次与它们打交道时可能会显得有点神秘，但毫无疑问，这是增强功能行为的一个很好的工具。</p><p id="5740" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事实上，Python中有两种类型的装饰器——类装饰器和函数装饰器——但我在这里将重点介绍函数装饰器。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="d5a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们进入基本装饰器如何工作以及如何实现你自己的装饰器的有趣细节之前，让我们先看看为什么我们需要它们。在一些情况下，装饰者会有很大的帮助。</p><p id="3866" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">他们可以添加日志记录或工具代码，并以封装的方式从应用程序组件中提取各种<a class="ae ky" rel="noopener" target="_blank" href="/profiling-in-python-83415daa844c">指标</a>，例如计时。</p><p id="eb9c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Decorators可能是验证输入的完美机制，这在使用像Python这样的动态类型的语言时尤其重要。</p><p id="7b12" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">内置装饰器在Python库中被广泛使用。典型的例子包括web框架中用于路由和授权的decorator，例如，<a class="ae ky" href="https://flask.palletsprojects.com/en/2.0.x/quickstart/" rel="noopener ugc nofollow" target="_blank"> Flask </a>中的<code class="fe mc md me mf b"><a class="ae ky" href="https://flask.palletsprojects.com/en/2.0.x/api/#flask.Flask.route" rel="noopener ugc nofollow" target="_blank">@route()</a></code> decorator。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="a4bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">既然我们看到了学习编写和应用装饰器是一个好主意，那么让我们弄清楚什么是装饰器，以及如果需要的话，如何实现自定义装饰器。</p><p id="e1c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了使用decorators，你需要知道的基本知识是，函数也是Python中的对象，它们可以作为参数传递给其他函数，就像其他对象一样，比如字符串。所以Python中的函数是<em class="mg">一级对象</em>。</p><p id="8a49" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以其他函数为自变量返回一个函数的函数是<a class="ae ky" href="https://en.wikipedia.org/wiki/Higher-order_function" rel="noopener ugc nofollow" target="_blank"> <em class="mg">高阶函数</em> </a>。这就是Python decorators的情况。</p><p id="2936" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个函数可以在另一个函数中定义。在这种情况下，它被称为<em class="mg">嵌套</em>函数。另一个与嵌套函数直接相关并且你需要理解的概念是<a class="ae ky" href="https://en.wikipedia.org/wiki/Closure_(computer_programming)" rel="noopener ugc nofollow" target="_blank"> <em class="mg">闭包</em></a>——一个“记住”数据的函数对象，例如来自其封闭范围的变量及其值。这将是我们稍后将看到的装饰器示例中的<code class="fe mc md me mf b">wrapper()</code>函数。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="24a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">装饰器通常被定义为<em class="mg">一个修改另一个函数</em>行为的函数。最常见的情况是，装饰者给参数函数的行为添加了一些东西。重要的是要记住，装饰器只是在一定程度上改变被装饰函数的行为，而不是永久地或完全地改变它。这就是为什么有时人们更喜欢将装饰器定义为一个函数，这个函数扩展了另一个更准确的函数的行为。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="b514" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，让我们看一个装饰函数的例子。假设我们有一个简单的函数，它返回两个整数的和:</p><pre class="kj kk kl km gt mh mf mi mj aw mk bi"><span id="aae6" class="ml mm it mf b gy mn mo l mp mq">def sum_up(n, m):<br/>    return n + m</span></pre><p id="773c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么我们可以这样运行它:</p><pre class="kj kk kl km gt mh mf mi mj aw mk bi"><span id="2d20" class="ml mm it mf b gy mn mo l mp mq">print(sum_up(3, 7))</span></pre><p id="dcd9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出:</p><pre class="kj kk kl km gt mh mf mi mj aw mk bi"><span id="d8b9" class="ml mm it mf b gy mn mo l mp mq">10</span></pre><p id="7540" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，假设我们想要记录代码库的这一部分发生了什么——为了便于练习，我们将简单地把它打印到控制台上。我们可以为此编写一个装饰器:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mr"><img src="../Images/eb68d577535956ad08edff418f79404e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jJdwJCddI4qa_HsBLoHTkw.png"/></div></div></figure><p id="6d1a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们需要将装饰器添加到代码库中的函数中:</p><pre class="kj kk kl km gt mh mf mi mj aw mk bi"><span id="6945" class="ml mm it mf b gy mn mo l mp mq"><a class="ae ky" href="http://twitter.com/log_computation" rel="noopener ugc nofollow" target="_blank">@log_computation</a><br/>def sum_up(n, m):<br/>    return n + m</span></pre><p id="0352" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，当我们在代码中调用此函数时，我们将在控制台中看到以下输出:</p><pre class="kj kk kl km gt mh mf mi mj aw mk bi"><span id="2bf6" class="ml mm it mf b gy mn mo l mp mq">Adding up 3 and 7. The result equals to 10.</span></pre><p id="0e55" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们一行一行地分解它，以理解装饰器中发生了什么。</p><p id="4794" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第1行，decorator方法的签名显示它接受一个函数作为参数。在第2行，我们定义了一个嵌套的包装函数，它将调用修饰函数并在第6行返回它的输出。在第3行，我们获得了修饰函数的输出。在第4行和第5行，装饰者的修改行为开始生效:在这里，它使输出更加冗长。在第7行，装饰者返回包装器。</p><p id="c303" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们不知道修饰函数的参数的很多细节怎么办？如果我们想概括装饰者呢？</p><p id="c487" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以使用<code class="fe mc md me mf b"> *<a class="ae ky" href="https://docs.python.org/3.7/glossary.html?highlight=kwarg#term-parameter" rel="noopener ugc nofollow" target="_blank">args</a></code>和/或<code class="fe mc md me mf b">**<a class="ae ky" href="https://docs.python.org/3.7/glossary.html?highlight=kwarg#term-parameter" rel="noopener ugc nofollow" target="_blank">kwargs</a></code>来实现:</p><pre class="kj kk kl km gt mh mf mi mj aw mk bi"><span id="1ff9" class="ml mm it mf b gy mn mo l mp mq">def log_computation(func):<br/>    def wrapper(*args):<br/>        numbers = args<br/>        res = func(*args)<br/>        print('Adding up the following numbers:\n'<br/>        '{}\n'<br/>        'The result equals to {}.'.format(numbers, res))<br/>        return res<br/>    return wrapper</span></pre><p id="1ff5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，如果将<code class="fe mc md me mf b">sum_up()</code>函数推广到累加任意数量的整数，我们的装饰器仍然可以工作:</p><pre class="kj kk kl km gt mh mf mi mj aw mk bi"><span id="7d4c" class="ml mm it mf b gy mn mo l mp mq">sum_up(3, 7, 11, 50)</span></pre><p id="fae6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出:</p><pre class="kj kk kl km gt mh mf mi mj aw mk bi"><span id="93e1" class="ml mm it mf b gy mn mo l mp mq">Adding up the following numbers:<br/>(3, 7, 11, 50)<br/>The result equals to 71.</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="0179" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个自定义装饰的基本模板。自定义装饰器可能要复杂得多。嵌套函数可以不接受参数，也可以接受位置参数、关键字参数或两者都接受。他们可以在调用main函数之前完成一些步骤，以确保它可以被安全地调用，或者在调用之后完成(就像我们的例子一样)，或者两者都完成(例如，在记录函数的执行或计时时)。我们也可以对一个函数应用多个装饰器——这被称为<em class="mg">链接</em>装饰器。</p><p id="ebcd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Decorators是使您的代码更健壮(特别是如果您将它们用于验证目的的话)并且更简单、更通用的好帮手。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="32fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你对使用decorators来跟踪你的Python代码的性能感兴趣，可以随意查看我关于<a class="ae ky" rel="noopener" target="_blank" href="/optimizing-your-python-code-156d4b8f4a29">代码优化</a>和<a class="ae ky" rel="noopener" target="_blank" href="/concurrency-and-parallelism-in-python-bbd7af8c6625">并发和并行</a>的帖子。</p></div></div>    
</body>
</html>