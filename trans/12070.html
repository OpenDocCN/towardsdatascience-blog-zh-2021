<html>
<head>
<title>You Must Know Python JSON Dumps, But Maybe Not All Aspects</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你一定知道Python JSON转储，但可能不是所有方面</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/you-must-know-python-json-dumps-but-maybe-not-all-aspects-fa8d98a76aa0?source=collection_archive---------7-----------------------#2021-12-06">https://towardsdatascience.com/you-must-know-python-json-dumps-but-maybe-not-all-aspects-fa8d98a76aa0?source=collection_archive---------7-----------------------#2021-12-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/694104156e4d743a0ce68ac369cf1256.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oRXwKEY936R59enMEWROQw.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">图片来自<a class="ae jg" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=1213008" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>的<a class="ae jg" href="https://pixabay.com/users/luboshouska-198496/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=1213008" rel="noopener ugc nofollow" target="_blank"> Lubos Houska </a></p></figure><div class=""/><div class=""><h2 id="2adc" class="pw-subtitle-paragraph kg ji jj bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dk translated">关于Python JSON模块的dump(s)方法的一些技巧</h2></div><p id="e187" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Python通过其“json”模块内置了对JSON文档的支持。我敢打赌，我们大多数人都用过，有些人用得很多。我们知道可以使用<code class="fe lu lv lw lx b">json.dumps()</code>方法轻松地将Python dictionary对象转换成JSON字符串。然而，这种方法并不像大多数开发人员想象的那么简单。</p><p id="d022" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在本文中，我将通过例子介绍这个<code class="fe lu lv lw lx b">json.dumps()</code>方法。用法的复杂和稀有是由浅入深的。</p><p id="8d7d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在我们应该开始了。不需要下载任何东西，你的Python 3.x必须自带JSON模块。</p><pre class="ly lz ma mb gt mc lx md me aw mf bi"><span id="3598" class="mg mh jj lx b gy mi mj l mk ml">import json</span></pre><h2 id="2d5d" class="mg mh jj bd mm mn mo dn mp mq mr dp ms lh mt mu mv ll mw mx my lp mz na nb nc bi translated">目录</h2><p id="1835" class="pw-post-body-paragraph ky kz jj la b lb nd kk ld le ne kn lg lh nf lj lk ll ng ln lo lp nh lr ls lt im bi translated"><a class="ae jg" href="#61c8" rel="noopener ugc nofollow"> 1。漂亮输出的自动缩进</a> <br/> <a class="ae jg" href="#7e31" rel="noopener ugc nofollow"> 2。自定义分隔符</a> <br/> <a class="ae jg" href="#e117" rel="noopener ugc nofollow"> 3。排序键</a> <br/> <a class="ae jg" href="#94e3" rel="noopener ugc nofollow"> 4。跳过非基本键类型</a> <br/> <a class="ae jg" href="#aede" rel="noopener ugc nofollow"> 5。非ASCII字符</a> <br/> <a class="ae jg" href="#e0a0" rel="noopener ugc nofollow"> 6。循环检查</a> <br/> <a class="ae jg" href="#2b4e" rel="noopener ugc nofollow"> 7。允楠</a> <br/> <a class="ae jg" href="#4a4d" rel="noopener ugc nofollow"> 8(不是一个数)。定制的JSON编码器</a></p><h1 id="a0c6" class="ni mh jj bd mm nj nk nl mp nm nn no ms kp np kq mv ks nq kt my kv nr kw nb ns bi translated">0.“转储”和“转储”的区别</h1><p id="3bb5" class="pw-post-body-paragraph ky kz jj la b lb nd kk ld le ne kn lg lh nf lj lk ll ng ln lo lp nh lr ls lt im bi translated">万一有些新手在读这篇文章，大概有必要提一下，JSON模块中有两个类似的方法——<code class="fe lu lv lw lx b">dump()</code>和<code class="fe lu lv lw lx b">dumps()</code>。</p><p id="dd00" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这两种方法有几乎相同的签名，但是<code class="fe lu lv lw lx b">dump()</code>将转换后的JSON字符串写入一个流(通常是一个文件)，而<code class="fe lu lv lw lx b">dumps()</code>只将字典转换成JSON字符串。</p><p id="69b0" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">假设我们有一个简单的字典如下。</p><pre class="ly lz ma mb gt mc lx md me aw mf bi"><span id="6368" class="mg mh jj lx b gy mi mj l mk ml">my_dict = {<br/>    'name': 'Chris',<br/>    'age': 33<br/>}</span></pre><p id="7d57" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我们想将其转换成格式化的JSON字符串并写入文件，可以使用<code class="fe lu lv lw lx b">dumps()</code>。</p><pre class="ly lz ma mb gt mc lx md me aw mf bi"><span id="161c" class="mg mh jj lx b gy mi mj l mk ml">with open('my.json', 'w') as f:<br/>    json.dump(my_dict, f)</span></pre><figure class="ly lz ma mb gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nt"><img src="../Images/4af64454a80c58f1ddfbe7e095e0580a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E_fxp3-zWgQbx0P4e4i1dw.png"/></div></div></figure><p id="537e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后，如果我们检查工作目录，文件<code class="fe lu lv lw lx b">my.json</code>应该在那里，包含转换后的JSON字符串。</p><figure class="ly lz ma mb gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nu"><img src="../Images/29a777173e2f4434e1741100ee638e4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wQ5ycWfER9QomfWa3dFGMA.png"/></div></div></figure><p id="26e5" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我们使用<code class="fe lu lv lw lx b">dumps()</code>，它只是将字典转储到一个字符串中。</p><pre class="ly lz ma mb gt mc lx md me aw mf bi"><span id="55fa" class="mg mh jj lx b gy mi mj l mk ml">json.dumps(my_dict)</span></pre><figure class="ly lz ma mb gt iv gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/1ef887453cfa148b409a31444ceecdcd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1272/format:webp/1*drhZcNaSCWfX3EVlf89Exw.png"/></div></figure><p id="8d10" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">由于这两个方法具有相同的签名，本文将只关注<code class="fe lu lv lw lx b">dumps()</code>，因为所有这些技巧都适用于另一个方法。</p><h1 id="61c8" class="ni mh jj bd mm nj nk nl mp nm nn no ms kp np kq mv ks nq kt my kv nr kw nb ns bi translated">1.漂亮输出的自动缩进</h1><p id="400e" class="pw-post-body-paragraph ky kz jj la b lb nd kk ld le ne kn lg lh nf lj lk ll ng ln lo lp nh lr ls lt im bi translated">看到由<code class="fe lu lv lw lx b">dumps()</code>方法输出字符串了吗？它不适合阅读。如果我们有一个非常大的JSON文档，所有内容都将在一行中输出。</p><p id="f8fa" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了以漂亮的格式输出JSON字符串，我们可以很容易地添加一个参数“indent”。它接受一个整数作为参数。</p><pre class="ly lz ma mb gt mc lx md me aw mf bi"><span id="084c" class="mg mh jj lx b gy mi mj l mk ml">json.dumps(my_dict, indent=2)<br/># OR<br/>json.dumps(my_dict, indent=4)</span></pre><figure class="ly lz ma mb gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nw"><img src="../Images/40a1fecdea074eb263e6d0ab0268d351.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*waRbGSC5TuU-upWU9_SGBQ.png"/></div></div></figure><h1 id="7e31" class="ni mh jj bd mm nj nk nl mp nm nn no ms kp np kq mv ks nq kt my kv nr kw nb ns bi translated">2.定制的分离器</h1><p id="d248" class="pw-post-body-paragraph ky kz jj la b lb nd kk ld le ne kn lg lh nf lj lk ll ng ln lo lp nh lr ls lt im bi translated">JSON遵循一种非常严格的格式，例如，同一级别的项目必须用逗号分隔，并且在键和值之间必须使用分号。因此，默认情况下，项目分隔符和键分隔符将是<code class="fe lu lv lw lx b">, </code>和<code class="fe lu lv lw lx b">: </code>。</p><p id="d50f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然而，如果我们想输出一个紧凑的JSON字符串，我们可以通过参数<code class="fe lu lv lw lx b">separators</code>改变这些分隔符。我们必须同时传递元组中的两个分隔符。</p><pre class="ly lz ma mb gt mc lx md me aw mf bi"><span id="8160" class="mg mh jj lx b gy mi mj l mk ml">json.dumps(my_dict, separators=(',', ':'))</span></pre><figure class="ly lz ma mb gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nx"><img src="../Images/658a6277ccc946ba79bf445797da26f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kM3OiOAzWOzVFCxcBR_uHA.png"/></div></div></figure><p id="b6a8" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我们不必将JSON字符串用作JSON，我们也可以将分隔符修改为我们想要的任何值。例如，我们可以让它变成PHP样式，如下所示。</p><pre class="ly lz ma mb gt mc lx md me aw mf bi"><span id="88ae" class="mg mh jj lx b gy mi mj l mk ml">json.dumps(<br/>  my_dict, <br/>  separators=('', ' =&gt; '), <br/>  indent=2<br/>)</span></pre><figure class="ly lz ma mb gt iv gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/28feed4f3050e5dab7cbf518eb29e6ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1340/format:webp/1*MfLKMVEzoIadmVjDy_ZjqQ.png"/></div></figure><h1 id="e117" class="ni mh jj bd mm nj nk nl mp nm nn no ms kp np kq mv ks nq kt my kv nr kw nb ns bi translated">3.排序关键字</h1><p id="e385" class="pw-post-body-paragraph ky kz jj la b lb nd kk ld le ne kn lg lh nf lj lk ll ng ln lo lp nh lr ls lt im bi translated">JSON通常不关心项目的顺序。因此，当我们将Python字典转储到JSON字符串时，条目的顺序将保持不变。</p><pre class="ly lz ma mb gt mc lx md me aw mf bi"><span id="706e" class="mg mh jj lx b gy mi mj l mk ml">json.dumps({<br/>    'c': 1,<br/>    'b': 2,<br/>    'a': 3<br/>})</span></pre><figure class="ly lz ma mb gt iv gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/b4baafb4a26483f370588dbfe1771182.png" data-original-src="https://miro.medium.com/v2/resize:fit:1176/format:webp/1*MkD4vHsbwXr2ZKf0FI336A.png"/></div></figure><p id="8086" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是，如果我们确实想通过项目键对转换后的JSON字符串进行排序，我们可以很容易地将<code class="fe lu lv lw lx b">sort_keys</code>参数设置为<code class="fe lu lv lw lx b">True</code>。</p><pre class="ly lz ma mb gt mc lx md me aw mf bi"><span id="d837" class="mg mh jj lx b gy mi mj l mk ml">json.dumps({<br/>    'c': 1,<br/>    'b': 2,<br/>    'a': 3<br/>}, sort_keys=True)</span></pre><figure class="ly lz ma mb gt iv gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/60d8a4e052690bf75feb6381e3e9884a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1096/format:webp/1*bliZu9LKZu4nMXDhAOkrdA.png"/></div></figure><p id="b101" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">该键将按字母顺序排序。</p><h1 id="94e3" class="ni mh jj bd mm nj nk nl mp nm nn no ms kp np kq mv ks nq kt my kv nr kw nb ns bi translated">4.跳过非基本键类型</h1><p id="087d" class="pw-post-body-paragraph ky kz jj la b lb nd kk ld le ne kn lg lh nf lj lk ll ng ln lo lp nh lr ls lt im bi translated">JSON只支持几种类型的对象作为项目键，分别是<code class="fe lu lv lw lx b">str</code>、<code class="fe lu lv lw lx b">int</code>、<code class="fe lu lv lw lx b">float</code>、<code class="fe lu lv lw lx b">bool</code>和<code class="fe lu lv lw lx b">None</code>。这些类型被称为基本类型。如果我们试图用非基本类型的键转换字典，就会抛出一个<code class="fe lu lv lw lx b">TypeError</code>。</p><pre class="ly lz ma mb gt mc lx md me aw mf bi"><span id="c980" class="mg mh jj lx b gy mi mj l mk ml">json.dumps({<br/>    'name': 'Chris',<br/>    (1,2): 'I am a tuple'<br/>})</span></pre><figure class="ly lz ma mb gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ob"><img src="../Images/ccd8ec43c811b0b41ebf53fcc21c6e3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aGCMlnMP33ws-ejEfktq8g.png"/></div></div></figure><p id="5f28" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是有意义的，因为JSON不支持集合类型作为键。然而，如果我们想跳过这些毫无意义的类型，我们可以将<code class="fe lu lv lw lx b">skip_keys</code>设置为true来隐藏这些项目。</p><pre class="ly lz ma mb gt mc lx md me aw mf bi"><span id="8d44" class="mg mh jj lx b gy mi mj l mk ml">json.dumps({<br/>    'name': 'Chris',<br/>    (1,2): 'I am a list'<br/>}, skipkeys=True)</span></pre><figure class="ly lz ma mb gt iv gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/6f4b248835a4f7a43fdbcc95d00a130b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1164/format:webp/1*330hyU3TvbA3c1wdPMQR3g.png"/></div></figure><h1 id="aede" class="ni mh jj bd mm nj nk nl mp nm nn no ms kp np kq mv ks nq kt my kv nr kw nb ns bi translated">5.非ASCII字符</h1><p id="c4f4" class="pw-post-body-paragraph ky kz jj la b lb nd kk ld le ne kn lg lh nf lj lk ll ng ln lo lp nh lr ls lt im bi translated">非ASCII字符不能保证在所有平台上都能很好地显示，而且还可能在传输JSON字符串时造成麻烦。因此，在将它们转换成JSON字符串时，Python会对其进行如下编码。</p><pre class="ly lz ma mb gt mc lx md me aw mf bi"><span id="eb82" class="mg mh jj lx b gy mi mj l mk ml">json.dumps({<br/>    'name': 'Chris',<br/>    'desc': 'There is a special char -&gt; ¢'<br/>})</span></pre><figure class="ly lz ma mb gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi od"><img src="../Images/eb1e8691f22b09e9a79e91c3fe39401e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vz9_bJydsBY2SzYLqmoeLg.png"/></div></div></figure><p id="405d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是，如果我们不想对这些特殊字符进行编码，我们可以将<code class="fe lu lv lw lx b">ensure_ascii</code>设置为<strong class="la jk"> false </strong>。</p><pre class="ly lz ma mb gt mc lx md me aw mf bi"><span id="cc34" class="mg mh jj lx b gy mi mj l mk ml">json.dumps({<br/>    'name': 'Chris',<br/>    'desc': 'There is a special char -&gt; ¢'<br/>}, ensure_ascii=False)</span></pre><figure class="ly lz ma mb gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oe"><img src="../Images/d3dc0ec00d8b365b04aa74a57c6ace98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6q55jSD7-tn1J5Eniw3piQ.png"/></div></div></figure><h1 id="e0a0" class="ni mh jj bd mm nj nk nl mp nm nn no ms kp np kq mv ks nq kt my kv nr kw nb ns bi translated">6.循环检查</h1><p id="3d80" class="pw-post-body-paragraph ky kz jj la b lb nd kk ld le ne kn lg lh nf lj lk ll ng ln lo lp nh lr ls lt im bi translated">在Python中，可以用循环引用定义一个字典。举个例子，我们用一个名为“dictionary”的键定义一个字典，值暂时为<code class="fe lu lv lw lx b">None</code>。</p><pre class="ly lz ma mb gt mc lx md me aw mf bi"><span id="c52e" class="mg mh jj lx b gy mi mj l mk ml">my_dict = {<br/>    'dictionary': None<br/>}</span></pre><p id="577b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后，我们把字典本身赋值为键“dictionary”的值。</p><pre class="ly lz ma mb gt mc lx md me aw mf bi"><span id="507d" class="mg mh jj lx b gy mi mj l mk ml">my_dict['dictionary'] = my_dict</span></pre><p id="ce28" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，如果我们试图输出这个字典，Python将显示<code class="fe lu lv lw lx b">...</code>，因为有一个循环引用。</p><figure class="ly lz ma mb gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi of"><img src="../Images/f9411c8809ca430be16cd48346f9b287.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iMXc3WlIsG3JTS5H6xJXmA.png"/></div></div></figure><p id="86ce" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我们试图从这样的字典中转储JSON字符串，循环引用将被检测到并抛出一个错误。</p><figure class="ly lz ma mb gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi og"><img src="../Images/c46cccc325febaff784455779a66ede9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9oDv0aFyubTVwIO4z5tz4g.png"/></div></div></figure><p id="0ed0" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是，如果我们不想检测循环引用，就让它过去，我们可以将参数<code class="fe lu lv lw lx b">check_circular</code>设置为false。</p><pre class="ly lz ma mb gt mc lx md me aw mf bi"><span id="ce07" class="mg mh jj lx b gy mi mj l mk ml">json.dumps(my_dict, check_circular=False)</span></pre><figure class="ly lz ma mb gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oh"><img src="../Images/9602c535be89f4cb293835b69d42a2de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2ZR5nQtmfHWA_3SBgIAa3w.png"/></div></div></figure><p id="d9ad" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">唯一的区别是，后者将真正尝试逐层转储循环引用的字典，直到它溢出。这样做也许没有什么好处。即使你想用这个特性来达到别的目的(我找不到例子……)，也一定有比这更好的方法。</p><h1 id="2b4e" class="ni mh jj bd mm nj nk nl mp nm nn no ms kp np kq mv ks nq kt my kv nr kw nb ns bi translated">7.允许NaN(非数字)</h1><p id="beb9" class="pw-post-body-paragraph ky kz jj la b lb nd kk ld le ne kn lg lh nf lj lk ll ng ln lo lp nh lr ls lt im bi translated">默认情况下，当转换带有无效数字(如<code class="fe lu lv lw lx b">nan</code>、<code class="fe lu lv lw lx b">inf</code>和<code class="fe lu lv lw lx b">-inf</code>)的字典时，它会保持原样。</p><pre class="ly lz ma mb gt mc lx md me aw mf bi"><span id="4f5f" class="mg mh jj lx b gy mi mj l mk ml">import numpy as np</span><span id="99ab" class="mg mh jj lx b gy oi mj l mk ml">json.dumps({<br/>    'my_number': np.nan<br/>})</span></pre><figure class="ly lz ma mb gt iv gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/4089ff87b6d6502dbf3d2da652c852d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1044/format:webp/1*DT-yXp8P3DlkfGBymm7uMw.png"/></div></figure><p id="0ed2" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我们试图将“JSON字符串”用于其他目的，这会导致一些问题，因为它不再是有效的JSON字符串。<code class="fe lu lv lw lx b">NaN</code>不是有效的JSON值类型。</p><p id="1f86" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我们想避免这种情况，或者至少让问题早点暴露出来，我们可以将参数<code class="fe lu lv lw lx b">allow_nan</code>设置为<strong class="la jk"> false </strong>。当有一个NaN时，将会抛出一个错误。</p><pre class="ly lz ma mb gt mc lx md me aw mf bi"><span id="38e7" class="mg mh jj lx b gy mi mj l mk ml">json.dumps({<br/>    'my_number': np.nan<br/>}, allow_nan=False)</span></pre><figure class="ly lz ma mb gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi og"><img src="../Images/976d8886942c91d4637a6ae9d9a37c07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I8tw8PgnOgTZTGSUbUybTA.png"/></div></div></figure><h1 id="4a4d" class="ni mh jj bd mm nj nk nl mp nm nn no ms kp np kq mv ks nq kt my kv nr kw nb ns bi translated">8.定制的JSON编码器</h1><p id="14a8" class="pw-post-body-paragraph ky kz jj la b lb nd kk ld le ne kn lg lh nf lj lk ll ng ln lo lp nh lr ls lt im bi translated">最后但同样重要的是，让我们看看如何定制JSON编码器。我们可以轻松地调整JSON <code class="fe lu lv lw lx b">dumps()</code>方法的行为，而不是让一切都默认。</p><p id="040e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如，我们有如下这样的词典。它有一个datetime对象作为项目中的值。</p><pre class="ly lz ma mb gt mc lx md me aw mf bi"><span id="058b" class="mg mh jj lx b gy mi mj l mk ml">from datetime import datetime</span><span id="0d75" class="mg mh jj lx b gy oi mj l mk ml">my_dict = {<br/>    'alarm_name': 'get up',<br/>    'alarm_time': datetime(2021, 12, 3, 7)<br/>}</span></pre><p id="bee2" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这种情况下，如果我们试图将字典转储到JSON中，将会抛出一个类型错误。</p><figure class="ly lz ma mb gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ok"><img src="../Images/474765281cbfb8b72c3b94b9608c3f80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Hv5qneUs1ZDN5MrhlAl_6w.png"/></div></div></figure><p id="2164" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我们想在转储字典时解析datetime对象怎么办？我们可以创建一个继承类<code class="fe lu lv lw lx b">json.JSONEncoder</code>的子类，然后实现<code class="fe lu lv lw lx b">default</code>方法。</p><pre class="ly lz ma mb gt mc lx md me aw mf bi"><span id="8031" class="mg mh jj lx b gy mi mj l mk ml">class DateTimeEncoder(json.JSONEncoder):<br/>    def default(self, obj):<br/>        if isinstance(obj, datetime):<br/>            return obj.strftime('%Y-%m-%d %H:%M:%S')<br/>        return json.JSONEncoder.default(self, obj)</span></pre><p id="5ab1" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在上面的代码中，我们检查对象是否是日期时间对象。如果是这样，我们将日期时间转换成一个字符串，然后返回它。否则，就使用<code class="fe lu lv lw lx b">JSONEncoder.default()</code>方法。</p><p id="3dd7" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一旦我们得到了这个定制的编码器类，我们可以将它传递给<code class="fe lu lv lw lx b">dumps</code>方法中的<code class="fe lu lv lw lx b">cls</code>参数。它的行为将会改变。</p><pre class="ly lz ma mb gt mc lx md me aw mf bi"><span id="78b6" class="mg mh jj lx b gy mi mj l mk ml">json.dumps(my_dict, cls=DateTimeEncoder, indent=2)</span></pre><figure class="ly lz ma mb gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ol"><img src="../Images/5759a4cedfcab1ddbb3d1af48959d533.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XGTasGLUQQv8Xwsimg6XJg.png"/></div></div></figure><h1 id="6193" class="ni mh jj bd mm nj nk nl mp nm nn no ms kp np kq mv ks nq kt my kv nr kw nb ns bi translated">摘要</h1><figure class="ly lz ma mb gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/83b49a232d770e52d55faa1243354c0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iu42hbX-6EErq-88tGp9CA.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">图片由<a class="ae jg" href="https://pixabay.com/users/visionpics-4638469/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=6795381" rel="noopener ugc nofollow" target="_blank">亚历山大·巴甫洛夫·波德瓦尔尼</a>从<a class="ae jg" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=6795381" rel="noopener ugc nofollow" target="_blank">皮克斯拜</a>拍摄</p></figure><p id="87af" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在本文中，我只介绍了Python中的一种方法— <code class="fe lu lv lw lx b">json.dumps()</code>。对于像这样的内置方法，我们通常会大量使用它们，但是我们可能不知道它的每一个方面。强烈建议调查我们熟悉的方法，而不是继续寻找那些很少使用的方法，因为前者可能会让我们花的时间更有价值。</p><div class="is it gp gr iu om"><a href="https://medium.com/@qiuyujx/membership" rel="noopener follow" target="_blank"><div class="on ab fo"><div class="oo ab op cl cj oq"><h2 class="bd jk gy z fp or fr fs os fu fw ji bi translated">通过我的推荐链接加入灵媒-陶</h2><div class="ot l"><h3 class="bd b gy z fp or fr fs os fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="ou l"><p class="bd b dl z fp or fr fs os fu fw dk translated">medium.com</p></div></div><div class="ov l"><div class="ow l ox oy oz ov pa ja om"/></div></div></a></div><p id="948c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你觉得我的文章有帮助，请考虑加入Medium会员来支持我和其他成千上万的作者！(点击上面的链接)</p></div></div>    
</body>
</html>