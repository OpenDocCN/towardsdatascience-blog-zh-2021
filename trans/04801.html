<html>
<head>
<title>C++ Basics: Moving Resources</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">C++基础:移动资源</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/c-basics-moving-resources-4bd58bc5e6c8?source=collection_archive---------26-----------------------#2021-04-26">https://towardsdatascience.com/c-basics-moving-resources-4bd58bc5e6c8?source=collection_archive---------26-----------------------#2021-04-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5027" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">什么时候应该写自己的move构造函数和move赋值操作符？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/370af33488cf3eca008f8b5f29457cd1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3c796xvM6CQ246wz"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae ky" href="https://unsplash.com/@ffstop?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Fotis Fotopoulos </a>拍摄</p></figure><h1 id="c15b" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">简介—为什么要移动资源</h1><p id="723e" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在编写程序时，你会遇到需要将(大量)资源从一个对象转移到另一个对象的情况。</p><p id="a6f7" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在C++中，我们有移动语义，这是一种移动资源的方式，以避免在内存中进行复制，这不仅会使我们的程序变慢，而且会使用更多不必要的空间。</p><p id="d8e4" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们在这里不讨论移动语义，因为你可以在互联网上找到很多解释右值和移动语义的资源。</p><p id="43a5" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">不太明显的是，什么时候我们可以依靠编译器来帮助我们移动资源，什么时候我们必须编写自己的移动构造函数和移动赋值操作符。</p><p id="ee30" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们将在下面的章节中看到一些例子。当然，要求你使用现代c++，至少是c++11。</p><h1 id="e316" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">隐式声明和定义的特殊成员函数</h1><p id="ff0d" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">如果我们创建一个像下面这样的简单结构，编译器会隐式地为我们生成一些特殊的函数，这样我们就不用写冗长的代码了。我们将由编译器生成以下函数:</p><ul class=""><li id="69b4" class="ms mt it lt b lu mn lx mo ma mu me mv mi mw mm mx my mz na bi translated">默认构造函数</li><li id="35a0" class="ms mt it lt b lu nb lx nc ma nd me ne mi nf mm mx my mz na bi translated">复制ctor</li><li id="ab6b" class="ms mt it lt b lu nb lx nc ma nd me ne mi nf mm mx my mz na bi translated">移动构造函数</li><li id="ab49" class="ms mt it lt b lu nb lx nc ma nd me ne mi nf mm mx my mz na bi translated">复制赋值运算符</li><li id="8c7f" class="ms mt it lt b lu nb lx nc ma nd me ne mi nf mm mx my mz na bi translated">移动赋值运算符</li><li id="82c9" class="ms mt it lt b lu nb lx nc ma nd me ne mi nf mm mx my mz na bi translated">破坏者</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="9d41" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">了解这一点对于我们理解在管理(大量)资源时是否需要编写它们是很重要的。</p><h1 id="cf27" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">移动资源</h1><p id="304a" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我们可以用多种方式管理资源，最常见的方式是使用std::vector，但在其他情况下，我们可能希望使用原始指针或智能指针。</p><p id="258b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们可能还需要在创建包装器时管理操作系统的资源，例如像Linux中的套接字句柄。</p><h2 id="d1c9" class="ni la it bd lb nj nk dn lf nl nm dp lj ma nn no ll me np nq ln mi nr ns lp nt bi translated">用std::vector管理资源</h2><p id="e392" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在编写管理向量的类时，我们不必专门编写move构造函数和move赋值操作符，因为std::vector已经为我们实现了。请看下面的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="5151" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在我们的<strong class="lt iu"> <em class="nu">数据</em> </strong>类中，我们只实现了一个默认的构造函数，仅此而已。但是正如你看到的，我们可以复制和移动我们的资源。</p><pre class="kj kk kl km gt nv nw nx ny aw nz bi"><span id="492f" class="ni la it nw b gy oa ob l oc od">Data data2 = data;</span></pre><p id="9f61" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">上面一行调用复制构造函数，下面一行调用移动构造函数。</p><pre class="kj kk kl km gt nv nw nx ny aw nz bi"><span id="a50d" class="ni la it nw b gy oa ob l oc od">Data data3 = std::move(data);</span></pre><p id="e6bd" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">如果我们看到程序的输出，我们会看到类似这样的内容:</p><pre class="kj kk kl km gt nv nw nx ny aw nz bi"><span id="6264" class="ni la it nw b gy oa ob l oc od">Data's internalData is at: 0x558d72e74eb0<br/>Data2's internalData is at: 0x558d72e75460<br/>Data3's internalData is at: 0x558d72e74eb0<br/>data is now empty</span></pre><p id="fa42" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们可以看到<strong class="lt iu"> <em class="nu">数据2 </em> </strong>具有不同的地址，这是因为资源被复制到内存中的新空间，而<strong class="lt iu"> <em class="nu">数据3 </em> </strong>与<strong class="lt iu"> <em class="nu">数据</em> </strong>具有相同的地址，因为资源刚刚被移动。结果，<strong class="lt iu"> <em class="nu">数据</em> </strong>变空，因为它的资源已经从中释放。</p><h2 id="bdad" class="ni la it bd lb nj nk dn lf nl nm dp lj ma nn no ll me np nq ln mi nr ns lp nt bi translated">智能指针呢？</h2><p id="6db1" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">有共享指针和唯一指针，但我们在这里将重点放在共享指针上，因为唯一指针不允许你复制它，因为它必须是唯一的:)，它只能移动。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="03e3" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这个程序的输出是:</p><pre class="kj kk kl km gt nv nw nx ny aw nz bi"><span id="7adb" class="ni la it nw b gy oa ob l oc od">Data's internalData is at: 0x5599c3db8ec0<br/>Number of owners: 1<br/>Data2's internalData is at: 0x5599c3db8ec0<br/>Number of owners: 2<br/>Data3's internalData is at: 0x5599c3db8ec0<br/>Number of owners: 2<br/>data is now null</span></pre><p id="90f4" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在这种情况下，我们的地址都是一样的，这是因为<strong class="lt iu"> <em class="nu"> shared_ptr </em> </strong>是为了共享资源，所以当你通过调用这行代码进行复制时:</p><pre class="kj kk kl km gt nv nw nx ny aw nz bi"><span id="2a02" class="ni la it nw b gy oa ob l oc od">Data data2 = data;</span></pre><p id="8ecd" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">资源没有被复制，但是它们现在是共享的，这可以从所有者的计数中看出，在那一行之后变为2。</p><p id="a949" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">现在如果我们调用下面的行:</p><pre class="kj kk kl km gt nv nw nx ny aw nz bi"><span id="9920" class="ni la it nw b gy oa ob l oc od">Data data3 = std::move(data);</span></pre><p id="02bf" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">调用move构造函数，<strong class="lt iu"> <em class="nu"> data3的</em> </strong> internalData指向与<strong class="lt iu"> <em class="nu"> data2的</em> </strong> internalData相同的地址，但是现在<strong class="lt iu"> <em class="nu"> data </em> </strong>已经无法访问这些资源，因为它们已经被转移到<strong class="lt iu"> <em class="nu"> data3 </em> </strong>。</p><p id="4c4f" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在这种情况下，我们也可以依靠编译器来完成它的工作，为我们实现move构造函数(以及所有其他特殊的成员函数)。</p><h2 id="40ad" class="ni la it bd lb nj nk dn lf nl nm dp lj ma nn no ll me np nq ln mi nr ns lp nt bi translated">原始指针呢？</h2><p id="c2f6" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在某些情况下，我们可能想要管理原始指针，让我们看一个例子。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="3ca6" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">就像前面的例子一样，我们试图依靠编译器来完成它的工作。该程序的输出如下:</p><pre class="kj kk kl km gt nv nw nx ny aw nz bi"><span id="7496" class="ni la it nw b gy oa ob l oc od">Data's internalData is at: 0x5565b0edaeb0<br/>Data2's internalData is at: 0x5565b0edaeb0<br/>Data3's internalData is at: 0x5565b0edaeb0</span></pre><p id="63f0" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">它们都指向同一个地址，这里有点不对劲。至少我们期望<strong class="lt iu"> <em class="nu"> Data2的internalData </em> </strong>指向不同的地址，因为它应该复制。</p><p id="bcdf" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这显然行不通。原因是隐式生成的复制构造函数对成员进行了<em class="nu">成员式复制，所以复制的是地址，而不是数据。</em></p><p id="9ca8" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">代码中缺少的另一件重要的事情是，当对象被销毁时，我们没有释放内存，这将导致<strong class="lt iu"> <em class="nu">内存泄漏</em> </strong>。所以我们需要写自己的析构函数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="d0f1" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在我们添加了析构函数之后，会发生什么呢，当我们执行它的时候，这个程序会崩溃。</p><pre class="kj kk kl km gt nv nw nx ny aw nz bi"><span id="e6f0" class="ni la it nw b gy oa ob l oc od">Data's internalData is at: 0x5632d3066eb0<br/>Data2's internalData is at: 0x5632d3066eb0<br/>Data3's internalData is at: 0x5632d3066eb0<br/>double free or corruption (!prev)<br/>Aborted (core dumped)</span></pre><p id="be43" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这是因为我们没有正确实现下面的特殊成员函数:</p><ul class=""><li id="1e5f" class="ms mt it lt b lu mn lx mo ma mu me mv mi mw mm mx my mz na bi translated">复制构造函数</li><li id="0163" class="ms mt it lt b lu nb lx nc ma nd me ne mi nf mm mx my mz na bi translated">移动构造函数</li><li id="9eb6" class="ms mt it lt b lu nb lx nc ma nd me ne mi nf mm mx my mz na bi translated">复制赋值运算符</li><li id="6dcd" class="ms mt it lt b lu nb lx nc ma nd me ne mi nf mm mx my mz na bi translated">移动赋值运算符</li></ul><p id="c981" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">现在让我们将完整的实现编写如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="db4e" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">输出将是正确的，如下所示:</p><pre class="kj kk kl km gt nv nw nx ny aw nz bi"><span id="3580" class="ni la it nw b gy oa ob l oc od">Data's internalData is at: 0x5638e02c2eb0<br/>Data2's internalData is at: 0x5638e02c4270<br/>Data3's internalData is at: 0x5638e02c2eb0<br/>Data is now empty</span></pre><p id="6e3d" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><strong class="lt iu"> <em class="nu"> Data2 </em> </strong>的<strong class="lt iu"> <em class="nu"> internalData </em> </strong>现在指向不同的地址，有自己的数据副本，而<strong class="lt iu"> <em class="nu"> Data </em> </strong>在其<strong class="lt iu"> <em class="nu"> internalData </em> </strong>被移动到<strong class="lt iu"> <em class="nu"> Data3 </em> </strong>后变为空。</p><h1 id="4912" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">结论</h1><p id="1bf1" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在试验了上面的不同场景后，我们现在可以得出结论，当我们的类管理原始资源(如原始指针)和操作系统句柄(如套接字)时，我们只需要编写自己的移动构造函数和移动赋值操作符。否则，我们可以依靠编译器为我们生成它们。</p><h2 id="a7ec" class="ni la it bd lb nj nk dn lf nl nm dp lj ma nn no ll me np nq ln mi nr ns lp nt bi translated">三/五法则</h2><p id="95d1" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">要记住的一件重要事情是三法则，它说:</p><blockquote class="oe of og"><p id="d9fa" class="lr ls nu lt b lu mn ju lw lx mo jx lz oh mp mc md oi mq mg mh oj mr mk ml mm im bi translated">如果您需要显式声明析构函数、复制构造函数或复制赋值操作符，您可能需要显式声明这三者。</p></blockquote><p id="121c" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">对于现代C++来说，我们需要增加两个函数，即移动构造函数和移动赋值操作符，这就是五的规则。</p><p id="c2b8" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在上面的例子中，我们需要编写析构函数，所以我们需要所有五个特殊的成员函数。</p></div></div>    
</body>
</html>