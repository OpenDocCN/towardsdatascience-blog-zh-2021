<html>
<head>
<title>How to set up a deep learning project in Pytorch</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Pytorch中建立深度学习项目</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-set-up-a-deep-learning-project-in-pytorch-d1b9ac4b70a3?source=collection_archive---------35-----------------------#2021-06-24">https://towardsdatascience.com/how-to-set-up-a-deep-learning-project-in-pytorch-d1b9ac4b70a3?source=collection_archive---------35-----------------------#2021-06-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5b70" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在Pytorch中建立深度学习项目的3个步骤</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c59f8325222db2588365b6d2c9450a3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*897OMrwAfZbKDxLK"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Graham Holtshausen 在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="04a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，我将解释如何在PyTorch中建立一个深度学习项目。</p><p id="ad62" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">任何PyTorch深度学习项目通常由3个基本步骤组成:</p><ol class=""><li id="6546" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">设置数据集</li><li id="17b2" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">创建数据加载器</li><li id="40a5" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">创建培训、验证和测试循环</li></ol><p id="9845" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我不会讲述如何建立一个实际的模型，因为它相当简单，因任务而异，而且网上已经有很多资源可以学习如何做这件事。</p><h2 id="71bd" class="mj mk it bd ml mm mn dn mo mp mq dp mr li ms mt mu lm mv mw mx lq my mz na nb bi translated">1.设置数据集</h2><p id="1a61" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">为了创建可以与数据加载器一起工作的数据集，以创建可以发送到实际模型中的数据批，PyTorch要求您为数据集创建一个特定的类，并覆盖它的两个函数:__getitem__()函数和__len__()函数。</p><p id="24a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在大多数机器学习项目中，在数据实际发送到模型之前，通常需要对数据进行一些预处理。例如，在自然语言处理任务中，这可能涉及对文本进行标记并将其转换成数字格式。为此，我在同一个类中创建可以完成所有这些过程的函数，如build_dataset()或preprocess()函数，并将所有预处理数据存储在一个单独的文件中。</p><p id="6be3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">getitem和len函数只是数据加载器用来构建小批量数据的函数。在下一节中，您将看到数据加载器如何使用和需要一个数据集对象/类，该数据集对象/类作为参数正确地覆盖了getitem和len函数，因此正确地实现这两个函数非常重要。</p><p id="09e3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">getitem函数相当简单。想象您的数据集正在被索引。例如，如果您正在执行一项图像识别任务，并且正在处理图像，则每个图像都将从0到数据集大小/数据集中的图像数量进行索引。对于getitem函数，您所要做的就是，给定一个索引，返回存在于该特定索引的数据的x，y对(或输入输出对)。因此，重要的是要记住，您可能应该将数据存储在索引数据集中，如列表中，这样您就可以轻松地访问特定索引处的元素。len函数只是一个返回数据集长度的函数。以前面将数据存储为列表的例子为例，您只需返回列表的长度。</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="dcb9" class="mj mk it ni b gy nm nn l no np">class MyDataset:<br/>   def __getitem__(self, index):<br/>       return self.input[index], self.label[index]<br/>   def __len__(self):<br/>       return len(self.input)</span></pre><p id="80a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">需要注意的是，getitem函数中的数据不一定是元组。您可以用任何类型的数据结构返回数据。如果您的模型有多个输入，您可以将数据作为字典返回。如果只有一个输入，可以将其作为元组返回。这真的没有关系，因为在训练循环中，您只需正确地从数据结构中检索输入。</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="f883" class="mj mk it ni b gy nm nn l no np">class MyDataset:<br/>   def __getitem__(self, index):<br/>       return {"Input_1": self.input1[index], <br/>               "Input_2": self.input2[index], <br/>               "Input_3": self.input3[index], <br/>               "Label": self.label[index]}<br/>   def __len__(self):<br/>       return len(self.input1)</span></pre><h2 id="0f3c" class="mj mk it bd ml mm mn dn mo mp mq dp mr li ms mt mu lm mv mw mx lq my mz na nb bi translated">2.创建数据加载器</h2><p id="0116" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">DataLoader是Pytorch提供的一个工具，它使得创建批量数据并将其发送到模型中变得非常容易。它使用我们在上一部分中创建的dataset类，以及其他一些东西来创建批处理。下面是你如何编码它们:</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="138e" class="mj mk it ni b gy nm nn l no np">from torch.utils.data import DataLoader<br/>data = MyDataset(parameters here)<br/>data.build_dataset()## A helper function to do the preprocessing</span><span id="ac6d" class="mj mk it ni b gy nq nn l no np">dataloader = DataLoader(dataset = data, batch_size = batchsize, shuffle=True)</span></pre><p id="27ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">数据加载器提供的一个非常重要的功能是，它们允许我们在将每批数据发送到模型之前，对每批数据应用特定的函数。他们通过collate类来实现这一点。collate是一个一次接收一批数据的类，可以修改该批数据并对数据执行任何特定于批的功能。它是这样工作的:</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="4927" class="mj mk it ni b gy nm nn l no np">class MyCollate():<br/>  def __call__(self, batch):<br/>    ## do whatever operations you want here<br/>    ## return the new batch of data</span></pre><p id="f109" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了正确地创建collate类，您必须重写__call__()函数。调用函数将接收一批数据，并返回一批新的、修改过的数据。collate中__call__()函数的输入批处理只是一个通过多次调用数据集中的getitem函数构建的列表，这是由数据加载器完成的。列表中的每个项目都是数据集中的一个项目或x，y对，可以从数据集类中的__getitem__()函数中检索到。批处理的输出必须以稍微不同的方式构建。当您将一批数据发送到模型中时，例如，如果您的批量大小为16，则模型的输入张量将被构造为一个列表/张量中的16个单独的输入，而标签/输出张量将是16个单独的标签。因为我们覆盖了collate函数，所以我们必须手动完成这个过程。如果我们没有覆盖collate函数，那么Dataloader将通过默认的collate函数自动完成这项工作。</p><p id="70df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">collate函数的输入结构如下:</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="6f05" class="mj mk it ni b gy nm nn l no np">(input1, label1), <br/>(input2, label2), <br/>(input3, label3), <br/>(input4, label4), <br/>(input5, label5)</span></pre><p id="ee81" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果批量大小为5。我们从collate函数返回的输出应该是这样的结构:</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="eb58" class="mj mk it ni b gy nm nn l no np">(input1, input2, input3, input4, input5), <br/>(label1, label2, label3, label4, label5)</span></pre><p id="cf1e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我正在做一个NLP任务。如果我试图将一批中的标记化句子填充到相同的长度(假设是该批中最长句子的长度)，那么我会这样做:</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="f280" class="mj mk it ni b gy nm nn l no np">class MyCollate():<br/>  def __call__(self, batch):<br/>    ## find maximum length of a sentence<br/>    max_len = 0<br/>    for item in batch:<br/>       max_len = max(max_len, len(item[0]))<br/>    new_input = []<br/>    new_label = [] <br/>    for item in batch:<br/>       ## pad all items in batch to max_len<br/>       val = item[0]<br/>       val = pad(val, max_len) <br/>       ##pad is the function you should create<br/>       new_input.append(val)<br/>       new_label.append(item[1])<br/>    new_input = torch.tensor(new_input)<br/>    new_label = torch.tensor(new_label)<br/>    return new_input, new_label</span></pre><p id="96f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要将校对功能与您的数据加载器集成，只需执行以下操作:</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="69d9" class="mj mk it ni b gy nm nn l no np">data = MyDataSet(parameters here)<br/>data.build_dataset()</span><span id="9e20" class="mj mk it ni b gy nq nn l no np">dataloader = DataLoader(dataset = data, batch_size = batchsize, shuffle=True, collate_fn = MyCollate())</span></pre><p id="5dd8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">shuffle=true参数只是在创建批处理之前随机打乱数据集中的数据。通常的做法是混洗训练数据加载器的数据，而不是验证和测试数据加载器的数据。关于所有PyTorch机器学习项目，需要记住的一点是，模型只能接受张量形式的输入，这就是我在上面的代码片段中返回输入和标签列表之前，将它们都转换为张量的原因。</p><p id="d51e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">需要记住的重要一点是，用于在getitem函数和collate中存储数据的数据结构必须相同，并且它们的大小也必须相同。如果在getitem函数中返回一个包含5个键值对的字典，则必须在collate中返回相同的键。这些值会有所不同，因为您已经对该批数据做了一些预处理。正如我之前提到的，返回的批次的结构会有所不同。如果在getitem函数中使用了字典，调用函数的输入将是</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="4cfd" class="mj mk it ni b gy nm nn l no np">{keys:values}, <br/>{keys:values}, <br/>{keys:values}, <br/>{keys:values}, <br/>{keys:values}</span></pre><p id="047d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果批量大小为5。每批的密钥都是相同的。返回的输出结构将是</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="0792" class="mj mk it ni b gy nm nn l no np">{key1: all values for key1}, <br/>{key2: all values for key2},<br/>{key3: all values for key3},<br/>{key4: all values for key4},<br/>{key5: all values for key5}</span></pre></div><div class="ab cl nr ns hx nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="im in io ip iq"><p id="40e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在大多数机器学习项目中，您通常需要三个不同的数据加载器:一个用于训练循环、验证循环和测试循环。在PyTorch中实现这一点非常简单:</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="1fdd" class="mj mk it ni b gy nm nn l no np">from torch.utils.data.dataset import random_split</span><span id="0ea6" class="mj mk it ni b gy nq nn l no np">data = MyDataset()<br/>data.build_dataset()</span><span id="83c4" class="mj mk it ni b gy nq nn l no np">train_len = int(0.7 * len(dataset))<br/>test_len = len(dataset) - train_len<br/>train_data, test_data = random_split(dataset, (train_len, test_len))<br/>val_len = int(0.33 * len(test_data))<br/>test_len = len(test_data) - val_len<br/>test_data, val_data = random_split(test_data, (test_len, val_len))</span><span id="aa46" class="mj mk it ni b gy nq nn l no np">train_loader = DataLoader(dataset = train_data, batch_size = batchsize, shuffle = True, collate_fn = MyCollate())</span><span id="31d1" class="mj mk it ni b gy nq nn l no np">test_loader = DataLoader(dataset = test_data, batch_size = batchsize, shuffle = False, collate_fn = MyCollate())</span><span id="34ed" class="mj mk it ni b gy nq nn l no np">val_loader = DataLoader(dataset = val_data, batch_size = batchsize, shuffle = False, collate_fn = MyCollate())</span></pre><p id="7e78" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您只需使用PyTorch提供的random_split函数将原始数据集分割成任意数量的部分。我将上面的数据集分成70%的训练、20%的测试和10%的验证。在创建每个数据集之后，您可以简单地将它们传递给自己的数据加载器，并定期使用它们。</p><h2 id="cbe8" class="mj mk it bd ml mm mn dn mo mp mq dp mr li ms mt mu lm mv mw mx lq my mz na nb bi translated">3.创建培训、验证和测试循环</h2><p id="7b90" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">PyTorch中的训练、验证和测试循环相当简单，也很相似。以下是创建训练循环的方法:</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="8bce" class="mj mk it ni b gy nm nn l no np">model = model.to(device)<br/>model = model.train()<br/>for index, batch in enumerate(train_loader):<br/>    x = batch[0].to(device)<br/>    y = batch[1].to(device)<br/>    optimizer.zero_grad()<br/>    output = model(x).to(device)<br/>    loss = criterion(output, y).to(device)<br/>    loss.backward()<br/>    optimizer.step()</span></pre><p id="28b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是如何创建一个验证/测试循环(它们是同一个东西，但是有不同的数据加载器)。</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="4938" class="mj mk it ni b gy nm nn l no np">model = model.to(device)<br/>model = model.eval()</span><span id="df4c" class="mj mk it ni b gy nq nn l no np">with torch.no_grad():<br/>    for index, batch in enumerate(train_loader):<br/>        x = batch[0].to(device)<br/>        y = batch[1].to(device)<br/>        output = model(x).to(device)<br/>        loss = criterion(output, y).to(device)<br/>    </span></pre><p id="1153" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">优化器是你选择的优化器(我通常选择Adam)，准则是我通常给我的损失函数起的名字。您必须预先对它们进行初始化，以下是您的操作方法:</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="077c" class="mj mk it ni b gy nm nn l no np">import torch.optim as optim<br/>import torch.nn as nn</span><span id="3ceb" class="mj mk it ni b gy nq nn l no np">learning_rate = 1e-3</span><span id="88fc" class="mj mk it ni b gy nq nn l no np">optimizer = optim.Adam(model.parameters(), lr = learning_rate)<br/>criterion = nn.BCEwithLogitsLoss()##you can use any loss function</span></pre><p id="94a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们必须在验证/测试循环中指定with torch.no_grad()，以确保PyTorch不会计算反向传播的梯度，因为我们在这里不进行反向传播。如果你不包含这段代码，你的程序仍然可以工作，但是它将消耗更多的内存，因为PyTorch将计算和存储我们甚至不会使用的模型的梯度。</p><p id="6ed9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关于训练和测试循环，需要指出的一件重要的事情是，即使我将x = batch[0]和y = batch[1]，您也不需要像这样明确地构造模型的输入(作为一个元组)，特别是如果您使用了不同的数据结构。您只需要确保从在collate中的getitem函数和call函数中使用的数据结构中正确地检索数据。需要注意的一点是，某些损失函数需要输出的特定形状/尺寸和y/标签，因此在从模型中获得输出后，请确保对其进行整形，然后将其发送到损失函数或我在上面命名的标准中。</p><p id="8099" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还有一件重要的事情要记住，你需要把。除了优化器和训练循环中的损失。这将把你的张量和数据放到你指定的设备上。如果您不知道如何创建设备，以下是方法:</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="993c" class="mj mk it ni b gy nm nn l no np">device = torch.device('cuda' if torch.cuda.is_available() else "cpu")</span></pre><p id="0e90" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你有一个GPU，那么设备将自动成为一个GPU。不然就是CPU了。</p></div><div class="ab cl nr ns hx nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="im in io ip iq"><p id="b569" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">完成PyTorch项目设置的最后一步是将前面的三个步骤结合起来。创建一个初始化所有需要的东西的函数，一个训练模型的函数，一个评估模型的函数。然后你只需要把所有的东西组合在一起，这相对来说比较简单。</p><p id="2090" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您还应该记得将模型权重保存到文件中。除了将模型权重保存到文件中，我还保存了优化器权重。您可以像这样保存模型/优化器权重:</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="473f" class="mj mk it ni b gy nm nn l no np">model = Model(parameters here<br/>optimizer = optim.Adam(model.parameters(), lr = learning_rate)<br/>save_dict = {'Optimizer_state_dict': optimizer.state_dict(), <br/>             'Model_state_dict': model.state_dict()}<br/>torch.save(save_dict, file_path)</span></pre><p id="fdfe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">加载模型也非常容易。</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="0a85" class="mj mk it ni b gy nm nn l no np">load_dict = torch.load(file_path)<br/>model.load_state_dict(load_dict['Model_state_dict'])<br/>optimizer.load_state_dict(load_dict['Optimizer_state_dict'])</span></pre></div><div class="ab cl nr ns hx nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="im in io ip iq"><p id="f5b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望你觉得这篇文章简单易懂，内容丰富。如果你有任何问题，请在下面的评论中提出。</p></div></div>    
</body>
</html>