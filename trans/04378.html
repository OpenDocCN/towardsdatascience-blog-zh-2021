<html>
<head>
<title>data.table speed with dplyr syntax: Yes we can!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用dplyr语法的data.table speed with！</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/data-table-speed-with-dplyr-syntax-yes-we-can-51ef9aaed585?source=collection_archive---------37-----------------------#2021-04-13">https://towardsdatascience.com/data-table-speed-with-dplyr-syntax-yes-we-can-51ef9aaed585?source=collection_archive---------37-----------------------#2021-04-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="d5e9" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">当你可以同时拥有速度和可读性时，为什么要在两者之间选择呢？</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/fa4aa5a7ca4898e82188327aeeb8a1a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*aqtGS9rnstzcjloM"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">萨姆·皮尔斯-瓦里洛在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><p id="a8d2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">r有很多很棒的数据辩论工具。其中两个是<em class="ls"> dplyr </em>和<em class="ls">数据表</em>包。虽然dplyr具有非常灵活和直观的语法，但data.table在某些情况下可以快几个数量级。</p><p id="8d5a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">其中一个场景是在大量组上执行操作时。例如，在处理CRM数据时会发生这种情况，其中每一行都描述了一个接触点或交易，并且人们对计算每个客户的行数、每个客户的所有交易的货币价值等感兴趣。</p><p id="6e37" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最近Rstudio <a class="ae kv" href="https://www.tidyverse.org/blog/2019/11/dtplyr-1-0-0/" rel="noopener ugc nofollow" target="_blank">发布了</a> <em class="ls"> dtplyr </em>包版本1.0.0，为<em class="ls"> dplyr </em>提供了<em class="ls">数据表</em>后端。</p><p id="8751" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用<em class="ls"> dtplyr </em>几乎不需要学习额外的代码。使用<code class="fe lt lu lv lw b">lazy_dt</code>函数启动<em class="ls">数据表</em>序列，之后写入常规<em class="ls"> dplyr </em>代码。只有在调用<code class="fe lt lu lv lw b">as_tibble</code>(或<code class="fe lt lu lv lw b">as.data.frame</code>等)时，代码才会执行。</p><p id="dc81" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，举例来说，一个利用<em class="ls"> dtplyr </em>进行多组操作的简单管道应该是这样的:</p><pre class="kg kh ki kj gt lx lw ly lz aw ma bi"><span id="4e70" class="mb mc iq lw b gy md me l mf mg">mtcars %&gt;%<br/>  lazy_dt() %&gt;%<br/>  filter(wt &lt; 5) %&gt;%<br/>  mutate(l100k = 235.21 / mpg) %&gt;% <em class="ls"># liters / 100 km</em><br/>  group_by(cyl) %&gt;%<br/>  summarise(l100k = mean(l100k))</span><span id="9668" class="mb mc iq lw b gy mh me l mf mg">## Source: local data table [?? x 2]<br/>## Call:   `_DT1`[wt &lt; 5][, `:=`(l100k = 235.21/mpg)][, .(l100k = mean(l100k)), <br/>##     keyby = .(cyl)]<br/>## <br/>##     cyl l100k<br/>##   &lt;dbl&gt; &lt;dbl&gt;<br/>## 1     4  9.05<br/>## 2     6 12.0 <br/>## 3     8 14.9 <br/>## <br/>## # Use as.data.table()/as.data.frame()/as_tibble() to access results</span></pre><p id="98b8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">唯一的警告是，和所有其他类似接口一样，一些更复杂的操作可能不被支持。</p><p id="12f1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有趣的是，虽然data.table有很多基准测试，但我找不到任何关于<em class="ls"> dtplyr </em>的基准测试。所以我决定自己进行一个快速的基准测试。</p><p id="66c6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这篇文章中，我将检查<em class="ls"> dtplyr </em>相对于<em class="ls"> dplyr </em>改进了多少，以及它的性能是否足够接近<em class="ls">数据表</em>以被视为有效的替代方案。</p><p id="70ed" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为此，我将重现data.table作者Matt Dowle在2018年12月完成的一些<a class="ae kv" href="https://github.com/Rdatatable/data.table/wiki/Benchmarks-%3A-Grouping" rel="noopener ugc nofollow" target="_blank">基准测试</a>。</p><p id="8287" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">基准点包括:</p><ul class=""><li id="97f6" class="mi mj iq ky b kz la lc ld lf mk lj ml ln mm lr mn mo mp mq bi translated">5简单的查询:不同类型的不同列上的大组和小组。类似于数据分析师在实践中可能做的事情；即当数据被探索和调查时的各种特别聚集。</li><li id="a79a" class="mi mj iq ky b kz mr lc ms lf mt lj mu ln mv lr mn mo mp mq bi translated">每个包都在其自己的新会话中单独测试。为此，我在为每个包运行基准代码之前重启了我的机器。</li><li id="968d" class="mi mj iq ky b kz mr lc ms lf mt lj mu ln mv lr mn mo mp mq bi translated">每个查询立即重复一次。这是为了隔离缓存效应并确认第一次计时。绘制了第一和第二总经过时间。</li></ul><p id="bd47" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我的分析在以下几个方面与原文不同:</p><ol class=""><li id="ff82" class="mi mj iq ky b kz la lc ld lf mk lj ml ln mm lr mw mo mp mq bi translated">我来对比一下<em class="ls">数据表</em>、<em class="ls"> dtyplr </em>和<em class="ls"> dplyr </em>。我还将检查用<code class="fe lt lu lv lw b">data.table</code>而不是<code class="fe lt lu lv lw b">data.frame</code>启动<em class="ls"> dtplyr </em>管道如何影响性能(下面称为<em class="ls"> dt_dtplyr </em>)</li><li id="f424" class="mi mj iq ky b kz mr lc ms lf mt lj mu ln mv lr mw mo mp mq bi translated">我将使用我的个人笔记本电脑，而不是运行虚拟机</li><li id="b575" class="mi mj iq ky b kz mr lc ms lf mt lj mu ln mv lr mw mo mp mq bi translated">我正在生成一个更小的数据集(~4.9 Gb)。我认为这代表了我在内存中处理过的一些较大的数据集(对于较大的数据集，我通常会切换到Spark)。</li></ol><p id="352c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">除此之外，代码基本相同。你可以在这篇文章的底部找到它。</p><p id="45e9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，事不宜迟，让我们来看看结果:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mx"><img src="../Images/056e232afa65822c07244893eaedfff2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YwQ6q4jL7yt9FWRpLcdzTg.png"/></div></div></figure><p id="203b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以看到，使用<em class="ls"> dtplyr </em>大大提高了性能，尽管仍然没有<em class="ls"> data.table </em>快。然而，看起来最大的区别是需要将<code class="fe lt lu lv lw b">data.frame</code>对象转换成<code class="fe lt lu lv lw b">data.table</code>对象。例如，在读取文件时，可以这样做一次。因此，最终牺牲性能来获得整洁语法的额外好处(对于那些喜欢整洁的人来说)似乎并不太糟糕。</p><p id="3139" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">就我个人而言，我迷上了tidyverse，而<em class="ls"> dtplyr </em>包只是继续使用它的另一个原因，即使是对大量组的操作。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="my mz l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">dtplyr基准代码</p></figure><h1 id="1c24" class="na mc iq bd nb nc nd ne nf ng nh ni nj jw nk jx nl jz nm ka nn kc no kd np nq bi translated">会话信息</h1><pre class="kg kh ki kj gt lx lw ly lz aw ma bi"><span id="6981" class="mb mc iq lw b gy md me l mf mg">sessionInfo()</span><span id="844a" class="mb mc iq lw b gy mh me l mf mg">## R version 3.6.2 (2019-12-12)<br/>## Platform: x86_64-apple-darwin15.6.0 (64-bit)<br/>## Running under: macOS Mojave 10.14.6<br/>## <br/>## Matrix products: default<br/>## BLAS:   /Library/Frameworks/R.framework/Versions/3.6/Resources/lib/libRblas.0.dylib<br/>## LAPACK: /Library/Frameworks/R.framework/Versions/3.6/Resources/lib/libRlapack.dylib<br/>## <br/>## locale:<br/>## [1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8<br/>## <br/>## attached base packages:<br/>## [1] stats     graphics  grDevices utils     datasets  methods   base     <br/>## <br/>## other attached packages:<br/>##  [1] data.table_1.12.8 pander_0.6.3      dtplyr_1.0.0      forcats_0.4.0    <br/>##  [5] stringr_1.4.0     dplyr_0.8.5       purrr_0.3.4       readr_1.3.1      <br/>##  [9] tidyr_1.0.3       tibble_3.0.1      ggplot2_3.3.0     tidyverse_1.3.0  <br/>## [13] pacman_0.5.1     <br/>## <br/>## loaded via a namespace (and not attached):<br/>##  [1] tidyselect_1.1.0 xfun_0.12        haven_2.2.0      lattice_0.20-38 <br/>##  [5] colorspace_1.4-1 vctrs_0.3.0      generics_0.0.2   htmltools_0.4.0 <br/>##  [9] yaml_2.2.1       utf8_1.1.4       rlang_0.4.6      pillar_1.4.4    <br/>## [13] glue_1.4.1       withr_2.1.2      DBI_1.1.0        dbplyr_1.4.2    <br/>## [17] modelr_0.1.5     readxl_1.3.1     lifecycle_0.2.0  munsell_0.5.0   <br/>## [21] blogdown_0.17    gtable_0.3.0     cellranger_1.1.0 rvest_0.3.5     <br/>## [25] evaluate_0.14    labeling_0.3     knitr_1.27       fansi_0.4.1     <br/>## [29] broom_0.5.3      Rcpp_1.0.4.6     scales_1.1.0     backports_1.1.5 <br/>## [33] jsonlite_1.6.1   farver_2.0.3     fs_1.4.1         hms_0.5.3       <br/>## [37] digest_0.6.25    stringi_1.4.6    bookdown_0.17    grid_3.6.2      <br/>## [41] cli_2.0.2        tools_3.6.2      magrittr_1.5     crayon_1.3.4    <br/>## [45] pkgconfig_2.0.3  ellipsis_0.3.1   xml2_1.2.2       reprex_0.3.0    <br/>## [49] lubridate_1.7.8  assertthat_0.2.1 rmarkdown_2.0    httr_1.4.1      <br/>## [53] rstudioapi_0.11  R6_2.4.1         nlme_3.1-143     compile</span></pre></div><div class="ab cl nr ns hu nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="ij ik il im in"><p id="4947" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ls">原载于</em><a class="ae kv" href="https://iyarlin.github.io/2019/10/17/automatic_dag_learning_part_1/" rel="noopener ugc nofollow" target="_blank"><em class="ls">https://iyarlin . github . io</em></a><em class="ls">2020年5月26日</em></p></div></div>    
</body>
</html>