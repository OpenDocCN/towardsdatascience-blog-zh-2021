<html>
<head>
<title>Master Label Processing In Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的主标注处理</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/essential-python-string-processing-techniques-aa5be43a4f1f?source=collection_archive---------13-----------------------#2021-04-17">https://towardsdatascience.com/essential-python-string-processing-techniques-aa5be43a4f1f?source=collection_archive---------13-----------------------#2021-04-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="141b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">关于在Python中处理字符串类型数据的完整教程。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d44c2b625a4f9e16d429ed5f637483aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OqHZYzoJDg_APUI7M0XIrA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://pixabay.com/images/id-173588/" rel="noopener ugc nofollow" target="_blank">图像来源</a></p></figure><h1 id="14ef" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">介绍</h1><p id="2485" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi mn translated"><span class="l mo mp mq bm mr ms mt mu mv di">在</span>数据科学和计算机编程的广阔世界中，有许多不同的数据类型都需要以某种方式来处理。在计算中，我们非常习惯于频繁地与数字和数学打交道来完成目标。然而，虽然计算机可能会用数字说话，但人类不会，包含字符的数据在计算机编程中被称为字符串数据类型。</p><p id="389a" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">字符串数据类型可用于表示任何类型的值。这可以是整个段落，例如元代码，或者甚至只是一个单词或字符。也就是说，string数据类型对于促进这类数据是完全必要的，这类数据是数据生态系统的重要组成部分。通常，在处理数据时，我们需要大规模地操纵数据，以便实际使用数据，这一点在字符串的例子中最为明显。</p><p id="6372" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">幸运的是，Pythonic的str类实际上非常容易使用，甚至可以使最复杂的操作看起来简单！在编程中，字符串和其他数据类型的一个很大区别是，计算机本身并不真正理解字符串。计算机在数字中工作，所有的字符串都是在没有这些数字的高层次上呈现的，但在幕后，我们可以使用很多技术来转换这些字符串，使其更容易被计算机解释。</p><blockquote class="nb"><p id="04d4" class="nc nd it bd ne nf ng nh ni nj nk mm dk translated"><a class="ae ky" href="https://github.com/emmettgb/Emmetts-DS-NoteBooks/blob/master/Python3/mastering%20string%20manipulation.ipynb" rel="noopener ugc nofollow" target="_blank">笔记本</a></p></blockquote></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><h1 id="3f51" class="kz la it bd lb lc ns le lf lg nt li lj jz nu ka ll kc nv kd ln kf nw kg lp lq bi translated">str类</h1><p id="18b4" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">str类是Python命名字符串的奇怪方式，它提供了一些很好的功能来简化字符串操作。重要的是要记住，Python语言的一大优势是其数据和脚本的高级接口，这一点从第一天起就备受推崇。当然，为了打开文件、编写文本和处理数据，数据类型必须便于适当地处理字符串和IO。因此，str类实际上非常善于管理其中的字符数据。然而，为了正确理解str类，对它进行一点解构可能是个好主意。</p><h2 id="6727" class="nx la it bd lb ny nz dn lf oa ob dp lj ma oc od ll me oe of ln mi og oh lp oi bi translated">创建字符串</h2><p id="4f67" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">每当我们在数据上使用断言操作符时，Python都会检查它的基本数据类型，以便为所提供的数据找到准确的匹配。这当然是true或string，可以这样构造:</p><pre class="kj kk kl km gt oj ok ol om aw on bi"><span id="dd92" class="nx la it ok b gy oo op l oq or">string = "Hello, my name is Emmett :)"</span></pre><p id="5538" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">现在让我们来看看这个新字符串的类型:</p><pre class="kj kk kl km gt oj ok ol om aw on bi"><span id="a71c" class="nx la it ok b gy oo op l oq or">type(string)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi os"><img src="../Images/e6cc07aeb6136c8fe81b8c7b28c342d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:302/format:webp/1*NhK_0-uBN1XDlYG-i2Ehkg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><h2 id="ed24" class="nx la it bd lb ny nz dn lf oa ob dp lj ma oc od ll me oe of ln mi og oh lp oi bi translated">循环</h2><p id="213b" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">首先，需要注意的是，这种类型实际上是可迭代的。一个字符串只是一个按顺序显示的字符列表，和列表一样，我们可以称之为字符串的索引。这也意味着我们可以使用将iterable作为str对象的参数的方法，例如len():</p><pre class="kj kk kl km gt oj ok ol om aw on bi"><span id="eaaa" class="nx la it ok b gy oo op l oq or">string[1]<br/>string[0]<br/>len(string)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/902942fc52fb20fedea9233421a78831.png" data-original-src="https://miro.medium.com/v2/resize:fit:494/format:webp/1*6CA23d5ADU0DaLd5rI3VZg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="6048" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">这也意味着我们可以在常规的for循环中使用这个对象。</p><pre class="kj kk kl km gt oj ok ol om aw on bi"><span id="705c" class="nx la it ok b gy oo op l oq or">for char in string:<br/>    print(char)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/0376f95a398659a9562573ae19c341d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:754/format:webp/1*Wu5nBUq3W4WsyHw7TxpWVA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><h2 id="6a99" class="nx la it bd lb ny nz dn lf oa ob dp lj ma oc od ll me oe of ln mi og oh lp oi bi translated">功能</h2><p id="186e" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">如您所料，str类还包含许多函数，可以非常有效地用来操作字符串中包含的字符。当然，可能要花很长时间才能真正看完它们，但我会展示我发现最有用的几个！列表中第一个是strip()函数。这个函数用于从字符串中删除前后的空格。考虑以下字符串:</p><pre class="kj kk kl km gt oj ok ol om aw on bi"><span id="b497" class="nx la it ok b gy oo op l oq or">h = "    This string starts and ends with spaaaace               "</span></pre><p id="8783" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">这个字符串本身前后都有很多空格，如果我们试图使用这个字符串来处理一个模型，这可能会很成问题！通过使用strip()函数删除所有多余的空白，我们可以非常简单快速地解决这个问题。</p><pre class="kj kk kl km gt oj ok ol om aw on bi"><span id="f7a2" class="nx la it ok b gy oo op l oq or">print(h.strip())</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ov"><img src="../Images/2d6567a0592a4b7276116adff43bec31.png" data-original-src="https://miro.medium.com/v2/resize:fit:788/format:webp/1*0Orw6hMhrZltNBMo5IFLZg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="4422" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">这个类中另一个很酷的函数是replace()函数。这用于将某些字符组合替换为其他字符组合。看看这个:</p><pre class="kj kk kl km gt oj ok ol om aw on bi"><span id="56fb" class="nx la it ok b gy oo op l oq or">ex = "I love Data Science"<br/>ex.replace("Data", "Biological")</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ow"><img src="../Images/b3745f363a246c3c6ced166b4de5918c.png" data-original-src="https://miro.medium.com/v2/resize:fit:558/format:webp/1*d1SOqNWJG5g2i-QitbLekA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="699e" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">isalnum()和isalpha()分别是一组方便的方法，可以用来探索字符串类型的数据。这两个函数可用于返回一个布尔值，该值将区分字符串是否包含数字。还有一些类似的方法可以用来判断一个字符串实际上是浮点数还是整数，但是现在，让我们来看看这两种方法的用法:</p><pre class="kj kk kl km gt oj ok ol om aw on bi"><span id="fc9b" class="nx la it ok b gy oo op l oq or">numbers = “2”<br/>nonumbs = “two”<br/>print(numbers.isalpha())<br/>print(nonumbs.isalpha())<br/>print(numbers.isalnum())<br/>print(nonumbs.isalnum())</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ox"><img src="../Images/d755f16db74f90ed174e745b74a03f3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:616/format:webp/1*WiyAr2tCwhw71ztblRsXDQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="3ca3" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">我发现自己经常使用的另一个很酷的功能是rfind()。这个函数返回一个字符串的索引，在这个字符串中找到一组给定的字符。考虑下面的例子，它详细描述了我如何假设我可能会喜欢一种我从未尝试过的食物:</p><pre class="kj kk kl km gt oj ok ol om aw on bi"><span id="d57d" class="nx la it ok b gy oo op l oq or">txt = "I like fish. I like tacos. So I like fish tacos!"</span><span id="7b84" class="nx la it ok b gy oy op l oq or">x = txt.rfind("fish")<br/>z = txt.rfind("like")<br/>print(x, z)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oz"><img src="../Images/41a263639b0d402fe2a0ae674d7ee897.png" data-original-src="https://miro.medium.com/v2/resize:fit:1030/format:webp/1*untq2Ul5p0idm66J61Qw3w.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="def4" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">Python类中另一个很棒的字符串函数的例子是partition()方法。这个函数可以用来根据一个逻辑中心将一个字符串分成三个独立的部分。在我们的鱼玉米卷的例子中，我把这个应用到中间的句子，我喜欢玉米卷，让我们看看产生了什么结果:</p><pre class="kj kk kl km gt oj ok ol om aw on bi"><span id="e253" class="nx la it ok b gy oo op l oq or">fish1, fish2, fish3 = txt.partition("I like tacos.")<br/>print(fish1)<br/>print(fish2)<br/>print(fish3)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pa"><img src="../Images/f0c954f6d797f7847661f06333d3d315.png" data-original-src="https://miro.medium.com/v2/resize:fit:676/format:webp/1*rdbiE38tj-j6D2tBOnErJQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="c2ee" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">使用index()函数，我们还可以获得任何给定字符集的索引。在本例中，我使用它分别打印出fish的字符，方法是在基于这两个值对字符串进行索引之前获取索引和长度，以便只接收我们最初索引的字符串:</p><pre class="kj kk kl km gt oj ok ol om aw on bi"><span id="cbec" class="nx la it ok b gy oo op l oq or">searchingfor = "fish"<br/>print(txt.index("fish"))<br/>start = txt.index("fish")<br/>sl = len(searchingfor)<br/>for i in range(start, start + sl):<br/>    print(txt[i])</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pb"><img src="../Images/b6474ff9055a1001384582be2bcc1a06.png" data-original-src="https://miro.medium.com/v2/resize:fit:810/format:webp/1*Hznwc7e_X5bCouxiqA6HKw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><h2 id="2c71" class="nx la it bd lb ny nz dn lf oa ob dp lj ma oc od ll me oe of ln mi og oh lp oi bi translated">一张便条</h2><p id="ee01" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我们刚刚看到的所有这些函数都很棒，但是在数据科学中，我们实际上使用单个大字符串的频率有多高呢？正确的答案是根本不经常，所以知道如何将这些技术应用于整个字符串列表而不仅仅是单个字符串是很重要的。为此，我们通常使用Pandas apply()函数，该函数将获取一个lambda表达式，并将其应用于整个系列或数据帧类型。</p><pre class="kj kk kl km gt oj ok ol om aw on bi"><span id="1bd8" class="nx la it ok b gy oo op l oq or">import pandas as pd<br/>listofstr = ["Hello", "Hi", "Hello", "Hi"]<br/>nums = [5, 10, 15, 20]<br/>df = pd.DataFrame({"A" : listofstr, "B" : nums})<br/>df["A"] = df["A"].apply(lambda x: x.replace("H", "W"))<br/>df.head(5)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pc"><img src="../Images/63dc4fc353c31dee661bc0ce5e8c62ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:450/format:webp/1*1PctNIkYgcdh2BoUWlqInw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><h2 id="5624" class="nx la it bd lb ny nz dn lf oa ob dp lj ma oc od ll me oe of ln mi og oh lp oi bi translated">正则表达式</h2><p id="26c8" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">关于str类和字符串，我想谈的另一件事是正则表达式的概念。正则表达式是编译器的上下文调用，允许程序员扩展字符串的功能。也就是说，它们在某种程度上对于用字符串编程的坚实基础是必不可少的，但只是作为一个例子，我将演示\n，\n是一个用于创建新行的正则表达式。有很多正则表达式可以放在字符串中来改变它们的行为方式，当然这只是处理字符串的冰山一角。</p><pre class="kj kk kl km gt oj ok ol om aw on bi"><span id="a019" class="nx la it ok b gy oo op l oq or">poem = """I tried a career called data science,\n Then befriended a colony of ants\n<br/>The ants ate my sugar,\n<br/>so i took my cooler,\n<br/>and flooded, so harshly, their pants"""<br/>print(poem)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pd"><img src="../Images/ceced4ad4c29b05989fc9bfcfabd7dd2.png" data-original-src="https://miro.medium.com/v2/resize:fit:772/format:webp/1*xcc_3WotDeVfg6aTykPoDg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><h1 id="d6c2" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">编码</h1><p id="dd1b" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">字符串是一种很好的数据形式，但是就计算机语言而言，它们对计算机来说毫无意义。计算机将字符和文本解释为用Unicode或ANSI表示的任意浮点数。由于这些字符对计算机来说是完全任意的，对我们来说是主观的，为了实际使用这些数据进行机器学习，甚至统计，我们需要对其进行编码。编码是将任意字符转换成没有任何意义的真实数据的好方法。有许多类型的编码器，但主要使用的三种是标签编码器，普通编码器和一个酒店编码器。</p><p id="fcbc" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">Onehotencoding通过将每个单独的类别作为布尔型特征来扩展字符串的维度。这可能是积极的，也可能是消极的，取决于应用程序，因为有时这种更高的维度会导致一些严重的问题，但有时它会非常有帮助。如果您的要素是一个很小的类子集，那么这一点尤其正确，在这种情况下，维度的权衡将不会像仅使用少量维度那样明显。我们可以使用Sklearn附带的Onehotencoder来实现这一目标:</p><pre class="kj kk kl km gt oj ok ol om aw on bi"><span id="8ed5" class="nx la it ok b gy oo op l oq or">from sklearn.preprocessing import OneHotEncoder</span></pre><p id="b344" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">现在让我们用一些基于类的字符串制作一个数据框架:</p><pre class="kj kk kl km gt oj ok ol om aw on bi"><span id="c523" class="nx la it ok b gy oo op l oq or">df = pd.DataFrame({"Danger_Level": ["A", "A", "C", "D", "C", "A", "B"],<br/>                   "Layer_Count": [5, 6, 12, 19, 13, 6, 9]})</span></pre><p id="5d33" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">现在，我们将通过调用不带参数的构造函数来初始化编码器:</p><pre class="kj kk kl km gt oj ok ol om aw on bi"><span id="c968" class="nx la it ok b gy oo op l oq or">encoder = OneHotEncoder()</span></pre><p id="40df" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">接下来，我们需要让我们的单个特征改变它的形状。这是因为SkLearn更喜欢我们处理矩阵，而不是数据帧中的一维数组。通常，在矩阵中，特征是通过垂直方向的观察而不是水平方向的观察列出的。因此，我们的特性看起来像是一堆不同的特性，每个特性只有一个样本——但事实并非如此。为了解决这个问题，我们需要将它转换成一个NumPy数组，然后对它进行整形:</p><pre class="kj kk kl km gt oj ok ol om aw on bi"><span id="3ad0" class="nx la it ok b gy oo op l oq or">import numpy as np<br/>dl = np.array(df["Danger_Level"]).reshape(-1, 1)</span></pre><p id="4e51" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">现在，我们可以在编码器中调用fit_transform()方法，以便对新的dl NumPy数组进行编码:</p><pre class="kj kk kl km gt oj ok ol om aw on bi"><span id="ae14" class="nx la it ok b gy oo op l oq or">output = encoder.fit_transform(dl)</span></pre><p id="af79" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">普通编码器也可以这样做。OrdinalEncoder不同于OneHot编码器，它保留了我们的特征的维度。编码器只是将类映射到整数值，然后在匹配时替换数据中的这些值:</p><pre class="kj kk kl km gt oj ok ol om aw on bi"><span id="15ba" class="nx la it ok b gy oo op l oq or">from sklearn.preprocessing import OrdinalEncoder<br/>encoder = OrdinalEncoder()<br/>encoder.fit_transform(dl)</span></pre><p id="1053" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">我们要看的最后一种编码器是浮点或标签编码器。这种编码器通常用于矢量化和自然语言处理，但当应用于分类问题时，本质上与顺序编码器一样，只是使用字符中的浮点组合作为映射数。</p><pre class="kj kk kl km gt oj ok ol om aw on bi"><span id="9a91" class="nx la it ok b gy oo op l oq or">from sklearn.preprocessing import LabelEncoder<br/>encoder = LabelEncoder()<br/>encoder.fit_transform(dl)</span></pre></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><h1 id="ae3a" class="kz la it bd lb lc ns le lf lg nt li lj jz nu ka ll kc nv kd ln kf nw kg lp lq bi translated">结论</h1><p id="15d5" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">字符串可能是一种有趣的数据类型，因为它们对人类来说是主观经验，而对计算机来说是不存在的，但尽管如此，它们对数据科学家经常处理的许多数据来说肯定非常重要。幸运的是，Python拥有处理这些数据类型的非常坚实的基础，了解这方面的正确方法可以节省大量时间！非常感谢你的阅读，祝你好运！</p></div></div>    
</body>
</html>