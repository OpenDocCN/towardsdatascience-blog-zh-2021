<html>
<head>
<title>20+ helpful Python syntax patterns for coding interviews</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">20多个有用的Python语法模式，用于编写访谈</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/19-helpful-python-syntax-patterns-for-coding-interviews-3704c15b758f?source=collection_archive---------3-----------------------#2021-05-31">https://towardsdatascience.com/19-helpful-python-syntax-patterns-for-coding-interviews-3704c15b758f?source=collection_archive---------3-----------------------#2021-05-31</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5f46" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">通过学习Python中这些常见的编码面试模式，在面试中获得更多自信并节省时间</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/8156100ef69681e3ec727c0a98904ad1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*faHUgLDOUxGHK-IE9lkthw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">第一课:使用列表理解！</p></figure><p id="b5cd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在现实生活中编码时，我有时会忘记语法，需要求助于Google。遗憾的是，这种奢侈在编码面试中是没有的。为了解决这个问题，我一直在回顾Python中用于编码面试的常见语法模式。语法并没有理解核心算法和数据结构概念那么重要，但是对我来说，回顾语法可以给我的代码注入信心，并为我节省宝贵的时间。我希望它对你也一样。</p><h1 id="f88a" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">第1部分:列表</h1><h2 id="53ce" class="mm lv it bd lw mn mo dn ma mp mq dp me lh mr ms mg ll mt mu mi lp mv mw mk mx bi translated">1.整理</h2><ul class=""><li id="e828" class="my mz it la b lb na le nb lh nc ll nd lp ne lt nf ng nh ni bi translated"><code class="fe nj nk nl nm b">sorted(numbers)</code>将按升序返回排序后的数字，并保持原始数字不变。你也可以使用<code class="fe nj nk nl nm b">numbers.sort()</code>,它对数字进行就地排序，并对<code class="fe nj nk nl nm b">numbers</code>进行就地变异</li><li id="0008" class="my mz it la b lb nn le no lh np ll nq lp nr lt nf ng nh ni bi translated"><code class="fe nj nk nl nm b">sorted</code>有两个可选参数，<code class="fe nj nk nl nm b">key</code>和<code class="fe nj nk nl nm b">reverse</code>。<code class="fe nj nk nl nm b">key</code>允许您修改用于比较的值。所以<code class="fe nj nk nl nm b">sorted(..., key=str.lower)</code>排序不区分大小写。<code class="fe nj nk nl nm b">reverse</code>让你按降序排序，所以<code class="fe nj nk nl nm b">sorted(..., reverse=True)</code>是降序。</li><li id="2178" class="my mz it la b lb nn le no lh np ll nq lp nr lt nf ng nh ni bi translated"><code class="fe nj nk nl nm b">sorted</code>使用具有<code class="fe nj nk nl nm b">O(nlogn)</code>平均和最坏情况时间复杂度的Timsort，使用<code class="fe nj nk nl nm b">O(n)</code>空间(类似于合并排序)，具有最好情况<code class="fe nj nk nl nm b">O(n)</code>时间复杂度(类似于插入排序)。</li></ul><h2 id="1fa8" class="mm lv it bd lw mn mo dn ma mp mq dp me lh mr ms mg ll mt mu mi lp mv mw mk mx bi translated"><strong class="ak"> 2。列表切片语法</strong></h2><ul class=""><li id="074a" class="my mz it la b lb na le nb lh nc ll nd lp ne lt nf ng nh ni bi translated">一般语法是<code class="fe nj nk nl nm b">iterable[start:stop:step]</code></li><li id="94f5" class="my mz it la b lb nn le no lh np ll nq lp nr lt nf ng nh ni bi translated"><code class="fe nj nk nl nm b">list[i:j]</code>从索引<code class="fe nj nk nl nm b">i</code>返回，直到<strong class="la iu">但不包括</strong> <code class="fe nj nk nl nm b">j</code></li><li id="9cfb" class="my mz it la b lb nn le no lh np ll nq lp nr lt nf ng nh ni bi translated"><code class="fe nj nk nl nm b">list[i:]</code>从索引<code class="fe nj nk nl nm b">i</code>开始返回，直到结束</li><li id="612e" class="my mz it la b lb nn le no lh np ll nq lp nr lt nf ng nh ni bi translated"><code class="fe nj nk nl nm b">list[:j]</code>从起点返回，直到指数<code class="fe nj nk nl nm b">j</code></li><li id="f4d6" class="my mz it la b lb nn le no lh np ll nq lp nr lt nf ng nh ni bi translated"><code class="fe nj nk nl nm b">list[::2]</code>返回列表中的所有其他元素(索引<code class="fe nj nk nl nm b">0, 2, ..</code></li><li id="0bad" class="my mz it la b lb nn le no lh np ll nq lp nr lt nf ng nh ni bi translated"><code class="fe nj nk nl nm b">list[::-1]</code>反转列表— <a class="ae ns" href="https://www.geeksforgeeks.org/python-reversed-vs-1-which-one-is-faster/" rel="noopener ugc nofollow" target="_blank">虽然list.reversed()更快</a></li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/8daf05fc5fb75e84003b41dc70c5ed42.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/0*GX_ox93PlDmAgcPA"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">列表切片的真实演示</p></figure><h2 id="03ba" class="mm lv it bd lw mn mo dn ma mp mq dp me lh mr ms mg ll mt mu mi lp mv mw mk mx bi translated">3.列表理解(即Pythonic地图和过滤器)</h2><ul class=""><li id="4abd" class="my mz it la b lb na le nb lh nc ll nd lp ne lt nf ng nh ni bi translated">通用语法是<code class="fe nj nk nl nm b">expression for member in iterable [if conditon]</code></li><li id="2de5" class="my mz it la b lb nn le no lh np ll nq lp nr lt nf ng nh ni bi translated">例如，<code class="fe nj nk nl nm b">[element * 2 for element in list if element % 2 == 0]</code>将返回一个新列表，其中每个偶数元素都是原始列表的两倍</li><li id="9f6a" class="my mz it la b lb nn le no lh np ll nq lp nr lt nf ng nh ni bi translated">用这个代替<code class="fe nj nk nl nm b">map</code>和<code class="fe nj nk nl nm b">filter</code>以获得更好的可读性</li></ul><h2 id="3a94" class="mm lv it bd lw mn mo dn ma mp mq dp me lh mr ms mg ll mt mu mi lp mv mw mk mx bi translated"><strong class="ak"> 4。使用范围</strong></h2><ul class=""><li id="3c43" class="my mz it la b lb na le nb lh nc ll nd lp ne lt nf ng nh ni bi translated">一般语法是<code class="fe nj nk nl nm b">range(start, stop, step)</code></li><li id="2f38" class="my mz it la b lb nn le no lh np ll nq lp nr lt nf ng nh ni bi translated"><code class="fe nj nk nl nm b">range(n)</code>用于从<code class="fe nj nk nl nm b">0</code>到<code class="fe nj nk nl nm b">n — 1</code>的迭代</li><li id="fc3e" class="my mz it la b lb nn le no lh np ll nq lp nr lt nf ng nh ni bi translated"><code class="fe nj nk nl nm b">range(i, j)</code>适用于从<code class="fe nj nk nl nm b">i</code>到<code class="fe nj nk nl nm b">j</code>的迭代，但不包括<code class="fe nj nk nl nm b">j</code></li><li id="4168" class="my mz it la b lb nn le no lh np ll nq lp nr lt nf ng nh ni bi translated"><code class="fe nj nk nl nm b">range(i, j, n)</code>同上，但每第n个元素。请注意，如果您想使用<code class="fe nj nk nl nm b">step</code> — <code class="fe nj nk nl nm b">range(10, step=2)</code>会导致错误，那么请改为使用<code class="fe nj nk nl nm b">range(0, 10, 2)</code>—阅读<a class="ae ns" href="https://stackoverflow.com/questions/15875188/the-strange-arguments-of-range" rel="noopener ugc nofollow" target="_blank">此</a>以了解关于为什么<code class="fe nj nk nl nm b">range</code>不支持关键字参数的更多信息</li></ul><h2 id="400a" class="mm lv it bd lw mn mo dn ma mp mq dp me lh mr ms mg ll mt mu mi lp mv mw mk mx bi translated"><strong class="ak"> 5。创建大小为N的列表</strong></h2><ul class=""><li id="cc75" class="my mz it la b lb na le nb lh nc ll nd lp ne lt nf ng nh ni bi translated">你可以使用range并转换成一个列表(例如，如果你喜欢的话，可以使用<code class="fe nj nk nl nm b">list(range(N))</code>或<code class="fe nj nk nl nm b">[*range(N)]</code>)</li><li id="02f6" class="my mz it la b lb nn le no lh np ll nq lp nr lt nf ng nh ni bi translated">对于所有相同的元素使用<code class="fe nj nk nl nm b">[element] * N</code></li><li id="2657" class="my mz it la b lb nn le no lh np ll nq lp nr lt nf ng nh ni bi translated">例如，<code class="fe nj nk nl nm b">[0] * 10</code>是10个零的列表，<code class="fe nj nk nl nm b">[None] * 5</code>是5个零的列表<code class="fe nj nk nl nm b">Nones</code></li><li id="f390" class="my mz it la b lb nn le no lh np ll nq lp nr lt nf ng nh ni bi translated">对于2维或更多维，<strong class="la iu">不要</strong>做<code class="fe nj nk nl nm b">[[0] * 5] * 10</code>。这10行只是对具有5个值的一行的引用，因此编辑一行将会改变其他9行。反而做，<code class="fe nj nk nl nm b">[[0 for i in range(5)] for j in range(10)]</code>。</li></ul><h1 id="15f2" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated"><strong class="ak">第2部分:迭代</strong></h1><h2 id="6134" class="mm lv it bd lw mn mo dn ma mp mq dp me lh mr ms mg ll mt mu mi lp mv mw mk mx bi translated"><strong class="ak"> 6。使用枚举</strong></h2><pre class="kj kk kl km gt nu nm nv nw aw nx bi"><span id="9173" class="mm lv it nm b gy ny nz l oa ob"># Use enumerate to get index and element<br/># from an iterable<br/>for index, element in enumerate(list):<br/>  print(element + ' is at index ' + str(index))</span></pre><h2 id="f7b9" class="mm lv it bd lw mn mo dn ma mp mq dp me lh mr ms mg ll mt mu mi lp mv mw mk mx bi translated"><a class="ae ns" href="https://www.educative.io/edpresso/how-to-emulate-a-do-while-loop-in-python" rel="noopener ugc nofollow" target="_blank">7<strong class="ak">。</strong> </a>如何写一篇‘边做边看’</h2><p id="ce8c" class="pw-post-body-paragraph ky kz it la b lb na ju ld le nb jx lg lh oc lj lk ll od ln lo lp oe lr ls lt im bi translated">像其他语言一样的陈述—</p><pre class="kj kk kl km gt nu nm nv nw aw nx bi"><span id="b17c" class="mm lv it nm b gy ny nz l oa ob">do {<br/>  # Write code here<br/>} while (condition)</span></pre><p id="1f54" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是用Python写的吗(不是我最喜欢的语法，但有时需要这样做)—</p><pre class="kj kk kl km gt nu nm nv nw aw nx bi"><span id="e69b" class="mm lv it nm b gy ny nz l oa ob">while True:<br/>  # Write code here<br/>  if condition:<br/>    break</span></pre><h2 id="62fd" class="mm lv it bd lw mn mo dn ma mp mq dp me lh mr ms mg ll mt mu mi lp mv mw mk mx bi translated">8.如何使用发电机</h2><p id="46fa" class="pw-post-body-paragraph ky kz it la b lb na ju ld le nb jx lg lh oc lj lk ll od ln lo lp oe lr ls lt im bi translated">我发现生成器在查找任何图类型结构的DFS或BFS问题的邻居时最有用。以<a class="ae ns" href="https://leetcode.com/problems/number-of-islands/" rel="noopener ugc nofollow" target="_blank"> Leetcode 200 —岛屿数量</a>为例。我们可以创建一个返回生成器的<code class="fe nj nk nl nm b">getNeighbors</code>辅助函数。这看起来像</p><pre class="kj kk kl km gt nu nm nv nw aw nx bi"><span id="47ca" class="mm lv it nm b gy ny nz l oa ob">def numIslands(grid) -&gt; int:        <br/><strong class="nm iu">  def getNeighbors(i, j):<br/>    for di, dj in [(1, 0), (-1, 0), (0, 1), (0, -1)]:<br/>      ni, nj = i + di, j + dj<br/>      if 0 &lt;= ni &lt; len(grid) and 0 &lt;= nj &lt; len(grid[i]):<br/>        yield ni, nj</strong><br/>            <br/>  def dfs(i, j):            <br/>    grid[i][j] = "-1"<br/>    <strong class="nm iu">for new_i, new_j in getNeighbors(i, j):</strong><br/>      if grid[new_i][new_j] == "1":<br/>        dfs(new_i, new_j)<br/>        <br/>  islands = 0<br/>  for i in range(len(grid)):<br/>    for j in range(len(grid[0])):<br/>       if grid[i][j] == "1":<br/>         islands += 1<br/>         dfs(i, j)<br/>        <br/>  return islands</span></pre><h1 id="3ef6" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">第三部分。高阶函数</h1><h2 id="9a13" class="mm lv it bd lw mn mo dn ma mp mq dp me lh mr ms mg ll mt mu mi lp mv mw mk mx bi translated">9.使用列表理解，而不是“映射”或“过滤”</h2><pre class="kj kk kl km gt nu nm nv nw aw nx bi"><span id="0381" class="mm lv it nm b gy ny nz l oa ob">list = list(range(10)) # [0, 1, ..., 9]</span><span id="d8ca" class="mm lv it nm b gy of nz l oa ob"><strong class="nm iu"># Not very Pythonic 👎<br/></strong>evens = filter(lambda x : x % 2 == 0, list) # [0, 2, ..., 8]<br/>evens_doubled = map(lambda x : x*2, events) # [0, 4, ..., 16]</span><span id="9bb2" class="mm lv it nm b gy of nz l oa ob"><strong class="nm iu"># Using list comprehension is Pythonic 👍<br/></strong>evens_doubled = [x*2 for x in list if x % 2 == 0]</span></pre><h2 id="1068" class="mm lv it bd lw mn mo dn ma mp mq dp me lh mr ms mg ll mt mu mi lp mv mw mk mx bi translated">10.谨慎使用reduce</h2><p id="772b" class="pw-post-body-paragraph ky kz it la b lb na ju ld le nb jx lg lh oc lj lk ll od ln lo lp oe lr ls lt im bi translated">谨慎使用reduce—<code class="fe nj nk nl nm b">sum</code>、<code class="fe nj nk nl nm b">math.prod</code>、<code class="fe nj nk nl nm b">all</code>和<code class="fe nj nk nl nm b">any</code>可读性更好，值得为比这更复杂的东西编写一个可读性更好的<code class="fe nj nk nl nm b">for</code>循环。<a class="ae ns" href="https://www.artima.com/weblogs/viewpost.jsp?thread=98196" rel="noopener ugc nofollow" target="_blank">连Guido(Python的创造者)自己都这么想</a>，这也是reduce被从内置库降格为<code class="fe nj nk nl nm b">functools</code>库的原因。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi og"><img src="../Images/9e4e68de6f4e4b191899747e547818d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:854/0*k7QPYlTfkW-4gNET"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">倒一个出来做内置还原</p></figure><p id="cb9e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">尽管如此，还是很高兴知道。语法是<code class="fe nj nk nl nm b">functools.reduce(function, iterable[, initializer])</code>。下面是一些例子</p><pre class="kj kk kl km gt nu nm nv nw aw nx bi"><span id="6bbc" class="mm lv it nm b gy ny nz l oa ob">from functools import reduce<br/>nums = [1, 2, 3, 4, 5]<br/>bools = [True, False, True, False, True]</span><span id="a409" class="mm lv it nm b gy of nz l oa ob"># sum<br/>reduce(lambda a, b: a + b, nums, 0) # 15</span><span id="e319" class="mm lv it nm b gy of nz l oa ob"># math.prod<br/>reduce(lambda a, b: a * b, nums, 1) # 120</span><span id="6525" class="mm lv it nm b gy of nz l oa ob"># min<br/>reduce(lambda a, b: a if a &lt; b else b, nums) # 1</span><span id="fbf9" class="mm lv it nm b gy of nz l oa ob"># max<br/>reduce(lambda a, b: a if a &gt; b else b, nums) # 5</span><span id="5b5f" class="mm lv it nm b gy of nz l oa ob"># any<br/>reduce(lambda a, b: a or b, bools) # true</span><span id="9993" class="mm lv it nm b gy of nz l oa ob"># all<br/>reduce(lambda a, b: a and b, bools) # false</span></pre><h2 id="4bad" class="mm lv it bd lw mn mo dn ma mp mq dp me lh mr ms mg ll mt mu mi lp mv mw mk mx bi translated">11.使用zip、zip_longest和zip_shortest</h2><p id="2ecf" class="pw-post-body-paragraph ky kz it la b lb na ju ld le nb jx lg lh oc lj lk ll od ln lo lp oe lr ls lt im bi translated"><code class="fe nj nk nl nm b">zip</code>让你同时遍历列表</p><pre class="kj kk kl km gt nu nm nv nw aw nx bi"><span id="a2e0" class="mm lv it nm b gy ny nz l oa ob">list_a = [1, 2, 3, 4]<br/>list_b = [10, 20, 30, 40]</span><span id="29de" class="mm lv it nm b gy of nz l oa ob">list_sum = [a + b for a, b in <strong class="nm iu">zip(list_a, list_b)</strong>]<br/># OR<br/>list_sum = []<br/>for a, b in zip(list_a, list_b):<br/>  list_sum.append(a + b)</span><span id="5930" class="mm lv it nm b gy of nz l oa ob">print(list_sum) # [11, 22, 33, 44]</span></pre><p id="d765" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于长度不等的列表，<code class="fe nj nk nl nm b">zip</code>将输出截断为最短的列表。<code class="fe nj nk nl nm b">itertools</code>库中的<code class="fe nj nk nl nm b">zip_longest</code>让你用一个<code class="fe nj nk nl nm b">fill_value</code>填充较小的列表，这样你就可以<code class="fe nj nk nl nm b">zip</code>好像它们是等长的。</p><pre class="kj kk kl km gt nu nm nv nw aw nx bi"><span id="548b" class="mm lv it nm b gy ny nz l oa ob">from itertools import zip_longest, zip_shortest</span><span id="9ba6" class="mm lv it nm b gy of nz l oa ob">short = [1, 2]<br/>long = [10, 20, 30, 40]</span><span id="5ea6" class="mm lv it nm b gy of nz l oa ob">zip_short = [a + b for a, b in <strong class="nm iu">zip(short, long)</strong>]<br/>print(zip_short) # [11, 22]<br/>zip_long = [a + b for a, b in <strong class="nm iu">zip_longest(short, long, fillvalue=0)</strong>]<br/>print(zip_long) # [11, 22, 30, 40]</span></pre><h1 id="60cd" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">第四部分。数据结构</h1><h2 id="eeb7" class="mm lv it bd lw mn mo dn ma mp mq dp me lh mr ms mg ll mt mu mi lp mv mw mk mx bi translated">12.Python字典方法</h2><ul class=""><li id="c280" class="my mz it la b lb na le nb lh nc ll nd lp ne lt nf ng nh ni bi translated">要检查一个关键字是否在字典中，使用<code class="fe nj nk nl nm b">key in my_dict</code></li><li id="de65" class="my mz it la b lb nn le no lh np ll nq lp nr lt nf ng nh ni bi translated"><code class="fe nj nk nl nm b">my_dict[key]</code>访问字典中的一个条目，如果字典中没有这个键，则返回一个<code class="fe nj nk nl nm b">KeyError</code>。为了避免错误，使用<code class="fe nj nk nl nm b">my_dict.get(key, default_value=None)</code>,如果键不在字典中，它将返回<code class="fe nj nk nl nm b">default_value</code>而不是错误</li><li id="5a43" class="my mz it la b lb nn le no lh np ll nq lp nr lt nf ng nh ni bi translated">如果您知道<code class="fe nj nk nl nm b">key</code>在<code class="fe nj nk nl nm b">my_dict</code>中，那么使用<code class="fe nj nk nl nm b">del my_dict[key]</code>从字典中删除一个键。否则，使用<code class="fe nj nk nl nm b">my_dict.pop(key, None)</code>，如果<code class="fe nj nk nl nm b">key</code>不在<code class="fe nj nk nl nm b">my_dict</code>中，它将返回<code class="fe nj nk nl nm b">None</code></li><li id="6342" class="my mz it la b lb nn le no lh np ll nq lp nr lt nf ng nh ni bi translated"><code class="fe nj nk nl nm b">my_dict.setdefault(key, default_value)</code>如果在<code class="fe nj nk nl nm b">my_dict</code>中则返回<code class="fe nj nk nl nm b">key</code>的当前值，如果不在，则设置为<code class="fe nj nk nl nm b">default_value</code>并返回</li><li id="2738" class="my mz it la b lb nn le no lh np ll nq lp nr lt nf ng nh ni bi translated"><code class="fe nj nk nl nm b">setdefault</code>对于计算元素来说<strong class="la iu">特别有用</strong>，你可以做类似<code class="fe nj nk nl nm b">counts[element] = counts.setdefault(element, 0) + 1</code>的事情</li><li id="505b" class="my mz it la b lb nn le no lh np ll nq lp nr lt nf ng nh ni bi translated"><code class="fe nj nk nl nm b">my_dict.keys()</code>、<code class="fe nj nk nl nm b">my_dict.values()</code>和<code class="fe nj nk nl nm b">my_dict.items()</code>将分别从字典中返回<code class="fe nj nk nl nm b">(key, value)</code>的键、值和元组的列表(这些有助于迭代)</li><li id="4180" class="my mz it la b lb nn le no lh np ll nq lp nr lt nf ng nh ni bi translated">您可以使用字典理解来创建新的字典，就像列表理解一样</li></ul><pre class="kj kk kl km gt nu nm nv nw aw nx bi"><span id="1509" class="mm lv it nm b gy ny nz l oa ob">my_basket = {'apple': 2, 'banana': 3, 'starfruit': 1}<br/>double_my_basket = {k:v*2 for (k, v) in my_basket.items()}<br/>print(double_my_basket) # {'apple': 4, 'banana': 6, 'starfruit': 2}</span></pre><ul class=""><li id="d1e4" class="my mz it la b lb lc le lf lh oh ll oi lp oj lt nf ng nh ni bi translated">对于集合和字典，您可以分别使用合并和更新操作符<code class="fe nj nk nl nm b">|</code>和<code class="fe nj nk nl nm b">|=</code>来添加键和值(仅适用于Python 3.9版的字典)</li></ul><pre class="kj kk kl km gt nu nm nv nw aw nx bi"><span id="0092" class="mm lv it nm b gy ny nz l oa ob">a = {1, 2, 3} # New set<br/>a += {4} # ❌ Returns a `TypeError`<br/>a |= {4} # ✅ {1, 2, 3, 4}</span></pre><h2 id="9614" class="mm lv it bd lw mn mo dn ma mp mq dp me lh mr ms mg ll mt mu mi lp mv mw mk mx bi translated">13.使用OrderedDict</h2><ul class=""><li id="ebfa" class="my mz it la b lb na le nb lh nc ll nd lp ne lt nf ng nh ni bi translated"><code class="fe nj nk nl nm b">OrderedDict</code>不经常使用，但是它可以使一些问题变得微不足道，例如<a class="ae ns" href="https://leetcode.com/problems/lru-cache/" rel="noopener ugc nofollow" target="_blank">实现LRU缓存</a>。一个<code class="fe nj nk nl nm b">OrderedDict</code>实际上是一个结合了双向链表的字典，用于排序</li><li id="2ede" class="my mz it la b lb nn le no lh np ll nq lp nr lt nf ng nh ni bi translated"><code class="fe nj nk nl nm b">OrderedDict</code>有一个<code class="fe nj nk nl nm b">.popitem()</code>方法，可以让你以后进先出的顺序移除物品(<code class="fe nj nk nl nm b">popitem(last=False)</code>会以先进先出的顺序移除物品)。</li><li id="7401" class="my mz it la b lb nn le no lh np ll nq lp nr lt nf ng nh ni bi translated">另外<code class="fe nj nk nl nm b">.move_to_end(item_key)</code>让我们将一个条目移动到字典的末尾(这样它可以在下一个弹出)。<code class="fe nj nk nl nm b">.move_to_end(item_key, last=False)</code>让您将项目移到开头。</li></ul><h2 id="8c10" class="mm lv it bd lw mn mo dn ma mp mq dp me lh mr ms mg ll mt mu mi lp mv mw mk mx bi translated">14。使用集合。计数器</h2><ul class=""><li id="8612" class="my mz it la b lb na le nb lh nc ll nd lp ne lt nf ng nh ni bi translated">通常，面试问题涉及到向散列图添加计数。为此，您可以像下面这样使用<code class="fe nj nk nl nm b">collections.Counter</code>。一个<code class="fe nj nk nl nm b">Counter</code>是一个<code class="fe nj nk nl nm b">dict</code>的子类，你可以像它是一个子类一样与之交互。</li></ul><pre class="kj kk kl km gt nu nm nv nw aw nx bi"><span id="9842" class="mm lv it nm b gy ny nz l oa ob">things = ['a', 'a', 'b', 'c', 'b', 'b']<br/>counts = collections.Counter(things)<br/>print(counts) # Counter({'b': 3, 'a': 2, 'c': 1})</span></pre><h2 id="23c2" class="mm lv it bd lw mn mo dn ma mp mq dp me lh mr ms mg ll mt mu mi lp mv mw mk mx bi translated">15。使用heapq </h2><ul class=""><li id="4289" class="my mz it la b lb na le nb lh nc ll nd lp ne lt nf ng nh ni bi translated">不要用<code class="fe nj nk nl nm b">queue.PriorityQueue</code>，<code class="fe nj nk nl nm b">heapq</code>更灵活</li><li id="dfa1" class="my mz it la b lb nn le no lh np ll nq lp nr lt nf ng nh ni bi translated">通读<a class="ae ns" href="https://docs.python.org/3/library/heapq.html" rel="noopener ugc nofollow" target="_blank">官方heapq文档</a>——下面的一些标注</li><li id="80f4" class="my mz it la b lb nn le no lh np ll nq lp nr lt nf ng nh ni bi translated"><code class="fe nj nk nl nm b">heapify</code>就位，那么<code class="fe nj nk nl nm b">heapify(list)</code>就会把<code class="fe nj nk nl nm b">list</code>变成一堆</li><li id="b720" class="my mz it la b lb nn le no lh np ll nq lp nr lt nf ng nh ni bi translated"><code class="fe nj nk nl nm b">heapq</code>仅支持最小堆，对于最大堆，在堆之前将所有值乘以<code class="fe nj nk nl nm b">-1</code>，在弹出后乘以<code class="fe nj nk nl nm b">-1</code>(我知道这很烦人)</li><li id="53e9" class="my mz it la b lb nn le no lh np ll nq lp nr lt nf ng nh ni bi translated">如果你想为对象创建一个堆，你应该用<code class="fe nj nk nl nm b">(priority, counter, object)</code>把它们作为一个元组添加。<code class="fe nj nk nl nm b">counter</code>是一个唯一的数字，用于打破优先级的界限(否则会出现错误)。我从0开始<code class="fe nj nk nl nm b">counter</code>,每当我压入堆时就递增。</li></ul><h2 id="2fd5" class="mm lv it bd lw mn mo dn ma mp mq dp me lh mr ms mg ll mt mu mi lp mv mw mk mx bi translated">16.实现树</h2><ul class=""><li id="6cce" class="my mz it la b lb na le nb lh nc ll nd lp ne lt nf ng nh ni bi translated">在<a class="ae ns" href="https://docs.python.org/3.9/library/index.html" rel="noopener ugc nofollow" target="_blank"> Python的标准库</a>中没有任何有助于面试的树形数据结构，所以你需要实现你自己的</li><li id="5460" class="my mz it la b lb nn le no lh np ll nq lp nr lt nf ng nh ni bi translated">对于二叉树，可以创建一个具有左右节点属性的节点类。确保跟踪代码中的“头”节点。</li><li id="d304" class="my mz it la b lb nn le no lh np ll nq lp nr lt nf ng nh ni bi translated">对于非二叉树，可以为子树使用数组或字典。如果您不希望孩子有重复的值，并且想要<code class="fe nj nk nl nm b">O(1)</code>查找，字典可能会更好。</li></ul><pre class="kj kk kl km gt nu nm nv nw aw nx bi"><span id="6354" class="mm lv it nm b gy ny nz l oa ob"># Binary Tree Node<br/>class Node:<br/>  def __init__(value):<br/>    self.value = value<br/>    self.left = None<br/>    self.right = None</span><span id="5961" class="mm lv it nm b gy of nz l oa ob"># Non-Binary Tree Node<br/>class Node:<br/>  def __init__(value):<br/>    self.value = value<br/>    self.children = [] # or self.children = {} for dict</span></pre><h2 id="0504" class="mm lv it bd lw mn mo dn ma mp mq dp me lh mr ms mg ll mt mu mi lp mv mw mk mx bi translated"><strong class="ak"> 17。实施Trie </strong></h2><ul class=""><li id="aef7" class="my mz it la b lb na le nb lh nc ll nd lp ne lt nf ng nh ni bi translated">Python的标准库中没有Trie，但是您可以很容易地实现一个。这里有一个只有<code class="fe nj nk nl nm b">insert</code>和<code class="fe nj nk nl nm b">search</code>功能的，你可以在此基础上构建额外的功能。</li></ul><pre class="kj kk kl km gt nu nm nv nw aw nx bi"><span id="9436" class="mm lv it nm b gy ny nz l oa ob">class TrieNode:<br/>    def __init__(self):<br/>        self.is_complete_word = False<br/>        self.children = {}</span><span id="8fe4" class="mm lv it nm b gy of nz l oa ob">class Trie:<br/>    def __init__(self):<br/>        # Blank Trie<br/>        self.root = TrieNode()<br/>        <br/>    def insert(self, word: str) -&gt; None:<br/>        """<br/>        Insert a word:<br/>        — Iterate through all characters in the word<br/>        - If we we encounter a char we don't have a<br/>          node for, create a new node<br/>        - Mark the last node as a complete word<br/>        """<br/>        curr = self.root<br/>        for char in word:<br/>            curr = curr.children.setdefault(char, TrieNode())    <br/>        curr.is_complete_word = True<br/>        <br/>    def search(self, word: str) -&gt; bool:<br/>        """<br/>        Search for a word:<br/>        — Iterate through all characters in the word<br/>        - If we we encounter a char we don't have a<br/>          node for, return False<br/>        - At the last node, return whether the word<br/>          is a complete word in our Trie<br/>        """<br/>        curr = self.root<br/>        for char in word:<br/>            if char not in curr.children:<br/>                return False<br/>            curr = curr.children[char] <br/>        return curr.is_complete_word</span></pre><h1 id="7002" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">第4部分:递归和动态编程</h1><h2 id="ae68" class="mm lv it bd lw mn mo dn ma mp mq dp me lh mr ms mg ll mt mu mi lp mv mw mk mx bi translated">18.使用装饰器来记忆</h2><p id="24fa" class="pw-post-body-paragraph ky kz it la b lb na ju ld le nb jx lg lh oc lj lk ll od ln lo lp oe lr ls lt im bi translated">只需添加<code class="fe nj nk nl nm b">@cache</code>装饰器</p><pre class="kj kk kl km gt nu nm nv nw aw nx bi"><span id="0b80" class="mm lv it nm b gy ny nz l oa ob"># No memoization O(2**N) time complexity<br/>def fib(n):<br/>  return fib(n - 1) + fib(n - 2) if n &gt; 1 else n</span><span id="69dd" class="mm lv it nm b gy of nz l oa ob"># Memoized, now O(N) time complexity<br/><strong class="nm iu">from functools import cache<br/>@cache</strong><br/>def fib(n):<br/>  return fib(n - 1) + fib(n - 2) if n &gt; 1 else n</span><span id="0977" class="mm lv it nm b gy of nz l oa ob"># Similar to doing this<br/>memo = {}<br/>def fib(n):<br/>  return memo.setdefault(n, fib(n - 1) + fib(n - 2) if n &gt; 1 else n)</span><span id="ec78" class="mm lv it nm b gy of nz l oa ob"># You can limit the memo size to N<br/># using lru_cache (here N = 64)<br/><strong class="nm iu">from functools import lru_cache<br/>@lru_cache(64)</strong><br/>def fib(n):<br/>  return fib(n - 1) + fib(n - 2) if n &gt; 1 else n</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/4a63979ae7fc1e35cb05db25b899158a.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/0*UsS7kQNw4MrUzD6t"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">谁知道记忆这么容易！</p></figure><h2 id="c650" class="mm lv it bd lw mn mo dn ma mp mq dp me lh mr ms mg ll mt mu mi lp mv mw mk mx bi translated">19.使递归程序迭代</h2><p id="8f0f" class="pw-post-body-paragraph ky kz it la b lb na ju ld le nb jx lg lh oc lj lk ll od ln lo lp oe lr ls lt im bi translated">这里有一个使用制表(<code class="fe nj nk nl nm b">O(n)</code>空间复杂度)制作迭代斐波那契函数的例子。</p><pre class="kj kk kl km gt nu nm nv nw aw nx bi"><span id="56d5" class="mm lv it nm b gy ny nz l oa ob">def fib(n):<br/>  fibs = [None] * n<br/>  fibs[0], fibs[1] = 0, 1<br/>  for i in range(2, n):<br/>    fib[i] = fib[i - 1] + fib[i - 2]<br/>  return fib[i]</span></pre><p id="4978" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里有一个<code class="fe nj nk nl nm b">O(1)</code>空间复杂度版本。</p><pre class="kj kk kl km gt nu nm nv nw aw nx bi"><span id="5833" class="mm lv it nm b gy ny nz l oa ob">def fib(n):<br/>  if n &lt;= 1:<br/>    return n<br/>  first, second = 0, 1<br/>  for i in range(2, n + 1):<br/>    first, second = second, first + second<br/>  return second</span></pre><p id="09c8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">另一个让程序迭代的方法是创建你自己的栈。【StackOverflow的这个回答很好地解释了为什么。</p><h1 id="8c2e" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated"><strong class="ak">第四部分:杂项</strong></h1><h2 id="5594" class="mm lv it bd lw mn mo dn ma mp mq dp me lh mr ms mg ll mt mu mi lp mv mw mk mx bi translated">20.三元if运算符</h2><ul class=""><li id="ad0b" class="my mz it la b lb na le nb lh nc ll nd lp ne lt nf ng nh ni bi translated">其他语言中的<code class="fe nj nk nl nm b">condition ? a : b</code>是Python中的<code class="fe nj nk nl nm b">a if condition else b</code></li></ul><h2 id="fec4" class="mm lv it bd lw mn mo dn ma mp mq dp me lh mr ms mg ll mt mu mi lp mv mw mk mx bi translated">21。操作二进制字符串</h2><ul class=""><li id="124b" class="my mz it la b lb na le nb lh nc ll nd lp ne lt nf ng nh ni bi translated">通过切片去掉使用<code class="fe nj nk nl nm b">bin</code>后烦人的<code class="fe nj nk nl nm b">0b</code>前缀——比如<code class="fe nj nk nl nm b">bin(7) = "0b111</code> so <code class="fe nj nk nl nm b">bin(7)[2:] = "111"</code></li><li id="3a1c" class="my mz it la b lb nn le no lh np ll nq lp nr lt nf ng nh ni bi translated">要将前导零添加到N位数，添加<code class="fe nj nk nl nm b">2**N</code>，然后切片——例如，用零填充<code class="fe nj nk nl nm b">111</code>，直到它的长度为5位数，执行<code class="fe nj nk nl nm b">bin(2**5 + 7)[3:] = “00111”</code>(注意<code class="fe nj nk nl nm b">2**N &gt; num</code>可以工作)</li></ul><h2 id="27a2" class="mm lv it bd lw mn mo dn ma mp mq dp me lh mr ms mg ll mt mu mi lp mv mw mk mx bi translated">22.可变对象与不可变对象</h2><p id="457c" class="pw-post-body-paragraph ky kz it la b lb na ju ld le nb jx lg lh oc lj lk ll od ln lo lp oe lr ls lt im bi translated">可变对象可以被改变，而不可变对象不能。这里列出了内置类型以及它们是否是不可变的。自定义类通常是可变的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/2a6a1ba10fb3126a4a26e1e65eb43955.png" data-original-src="https://miro.medium.com/v2/resize:fit:1316/format:webp/0*_6TO3ArTABXVh5Oy.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来源:<a class="ae ns" href="https://medium.com/@meghamohan/mutable-and-immutable-side-of-python-c2145cf72747" rel="noopener">Python的可变和不可变的一面</a></p></figure><p id="5bf0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这只是意味着您需要小心地从可变对象的现有变量中创建变量。您可能会无意中更改现有对象！</p><pre class="kj kk kl km gt nu nm nv nw aw nx bi"><span id="9f9a" class="mm lv it nm b gy ny nz l oa ob">ones = [1] * 3<br/>twos = ones<br/>for i, _ in enumerate(twos):<br/>  twos[i] = 2<br/>print(twos) # [2, 2, 2]<br/>print(ones) # Also [2, 2, 2]!</span></pre><p id="18cf" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了避免这种情况，您需要从变量创建一个副本。</p><pre class="kj kk kl km gt nu nm nv nw aw nx bi"><span id="cdf2" class="mm lv it nm b gy ny nz l oa ob">ones = [1] * 3<br/><strong class="nm iu">twos = list(ones) # Creates a copy instead</strong><br/>for i, _ in enumerate(twos):<br/>  twos[i] = 2<br/>print(twos) # [2, 2, 2]<br/>print(ones) # [1, 1, 1]</span><span id="a2c6" class="mm lv it nm b gy of nz l oa ob"><strong class="nm iu"># or using list comprehension<br/></strong>twos = [2 for i in ones]<br/>print(twos) # [2, 2, 2]<br/>print(ones) # [1, 1, 1]</span></pre><p id="ea81" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你有任何问题或额外的建议，请评论，祝你面试的人好运！</p></div></div>    
</body>
</html>