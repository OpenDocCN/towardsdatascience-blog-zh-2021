<html>
<head>
<title>Reflinks vs Symlinks vs Hard Links, and How They Can Help Machine Learning Projects</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">参考链接与符号链接与硬链接，以及它们如何帮助机器学习项目</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/reflinks-vs-symlinks-vs-hard-links-and-how-they-can-help-machine-learning-projects-b77b89cdbab1?source=collection_archive---------19-----------------------#2021-04-28">https://towardsdatascience.com/reflinks-vs-symlinks-vs-hard-links-and-how-they-can-help-machine-learning-projects-b77b89cdbab1?source=collection_archive---------19-----------------------#2021-04-28</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><h2 id="67b4" class="is it iu bd b dl iv iw ix iy iz ja dk jb translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/notes-from-industry" rel="noopener" target="_blank">行业笔记</a></h2><div class=""/><figure class="gm go kb kc kd ke gi gj paragraph-image"><div class="gi gj ka"><img src="../Images/21ecf1fdd04071514567fa35552a17de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1262/format:webp/0*JIb9wedw_C5dTinx.png"/></div><p class="kh ki gk gi gj kj kk bd b be z dk translated">作者图片</p></figure><p id="03e9" class="pw-post-body-paragraph kl km iu kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li in bi translated">硬链接和符号链接自古以来就有了，我们无时无刻不在使用它们，甚至连想都没想过。在机器学习项目中，当建立新的实验时，它们可以帮助我们在机器学习项目中快速有效地重新排列数据文件。然而，对于传统的链接，我们冒着错误编辑污染数据文件的风险。在这篇博文中，我们将回顾使用链接的细节，现代文件系统中一些很酷的新东西(引用链接)，以及DVC(数据版本控制，<a class="ae lj" href="https://dvc.org/" rel="noopener ugc nofollow" target="_blank">https://dvc.org/</a>)如何利用这一点的例子。</p><p id="0756" class="pw-post-body-paragraph kl km iu kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li in bi translated">当我在学习机器学习时，我希望有一个工具能让我们像检查常规软件工程项目一样检查ML项目。也就是说，在任何给定的时间检索项目的状态，基于项目的早期状态创建分支或标签(用Git ),处理与同事的协作，等等。让ML项目与众不同的是巨大的数据量，数以千计的图像、音频或视频文件，经过训练的模型，以及使用Git等常规工具管理这些文件的难度。在我之前的文章中，我解释了为什么<a class="ae lj" rel="noopener" target="_blank" href="/why-git-and-git-lfs-is-not-enough-to-solve-the-machine-learning-reproducibility-crisis-f733b49e96e8"> Git本身是不够的</a>，为什么Git-LFS不是机器学习项目的解决方案，以及一些看起来对管理ML项目的工具有用的<a class="ae lj" href="https://dev.to/robogeek/principled-machine-learning-4eho" rel="noopener ugc nofollow" target="_blank">原则</a>。</p><p id="984c" class="pw-post-body-paragraph kl km iu kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li in bi translated">事实证明，DVC非常擅长管理ML项目数据集和工作流程。它与Git协同工作，可以显示与任何Git提交相对应的数据集的状态。只需签出一个提交，DVC就可以重新安排数据文件，使其与提交时的数据完全匹配。</p><p id="be4a" class="pw-post-body-paragraph kl km iu kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li in bi translated">考虑到潜在的数十亿字节的数据几乎在瞬间被重新排列，这个速度是相当神奇的。所以我在想:DVC是如何完成这个魔术的？</p><h1 id="036f" class="ll lm iu bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">重新排列千兆字节训练数据的诀窍</h1><p id="bb02" class="pw-post-body-paragraph kl km iu kn b ko mj kq kr ks mk ku kv kw ml ky kz la mm lc ld le mn lg lh li in bi translated">事实证明，DVC像Git一样快速地重新排列数据和模型文件的秘诀是链接文件而不是复制文件。当然，Git在检查提交时会将文件复制到位，但是Git通常处理相对较小的文本文件，而不是ML项目中使用的大型二进制blobs。像DVC那样链接一个文件，速度快得令人难以置信，可以在眨眼之间重新排列任何数量的文件，同时避免复制，从而节省磁盘空间。</p><p id="a2fa" class="pw-post-body-paragraph kl km iu kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li in bi translated">实际上，使用文件链接技术对这个领域来说并不新鲜。一些数据科学团队使用符号链接来节省空间并避免复制大型数据集。但是符号链接并不是唯一可以使用的链接。我们将从将文件复制到适当位置的策略开始，然后使用硬链接和符号链接，最后使用一种新类型的链接reflinks，它在文件系统中实现了<a class="ae lj" href="https://en.wikipedia.org/wiki/Copy-on-write" rel="noopener ugc nofollow" target="_blank">写时复制功能</a>。我们将以DVC为例，说明工具如何使用不同的链接策略。</p><h1 id="83f8" class="ll lm iu bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">测试设置</h1><p id="6f9b" class="pw-post-body-paragraph kl km iu kn b ko mj kq kr ks mk ku kv kw ml ky kz la mm lc ld le mn lg lh li in bi translated">因为我们将测试不同的链接策略，所以我们需要一个样例工作空间。工作区设置在我的笔记本电脑上，一台MacBook Pro，主驱动器用APFS T4文件系统格式化。进一步的测试是在用<a class="ae lj" href="https://en.wikipedia.org/wiki/XFS" rel="noopener ugc nofollow" target="_blank"> XFS </a>格式化的Linux驱动器上进行的。</p><p id="ccee" class="pw-post-body-paragraph kl km iu kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li in bi translated">使用的数据是从两个不同的日子检索的维基百科网站的两个“存根文章”转储。每个都是大约38 GB的XML，给我们足够的数据来类似于一个ML项目。然后我们建立一个Git/DVC工作区，在这里可以通过检查不同的Git提交在这两个文件之间切换。</p><pre class="mo mp mq mr gu ms mt mu mv aw mw bi"><span id="c4a9" class="mx lm iu mt b gz my mz l na nb">$ ls -hl wikidatawiki-20190401-stub-articles.xml<br/>-rw-r--r--  1 david  staff    35G Jul 20 21:35 wikidatawiki-20190401-stub-articles.xml<br/>$ time cp wikidatawiki-20190401-stub-articles.xml wikidatawiki-stub-articles.xml</span><span id="0aca" class="mx lm iu mt b gz nc mz l na nb">real    14m16.918s<br/>...</span></pre><p id="7238" class="pw-post-body-paragraph kl km iu kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li in bi translated">作为一项基本措施，我们将注意到，将这些文件复制到工作区大约需要15分钟。很明显，如果在存储库中切换提交需要15分钟，那么ML研究员的生活不会很愉快。</p><p id="f6cb" class="pw-post-body-paragraph kl km iu kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li in bi translated">相反，我们将探索DVC和其他一些工具使用的另一种技术——链接。现代操作系统支持两种类型的链接:硬链接和符号链接。一种新的链接类型，Reflink(写时复制)，开始在Mac OS X和Linux的新版本中可用(为此需要所需的文件系统驱动程序)。我们将依次使用它们，看看它们的效果如何。</p><p id="9c4a" class="pw-post-body-paragraph kl km iu kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li in bi translated">DVC在其文档中讨论了与三种链接类型相对应的四种策略(第四种策略是复制文件)。所使用的策略取决于文件系统的功能，以及“<code class="fe nd ne nf mt b">dvc config cache.type</code>”命令是否更改了配置。</p><p id="3a8c" class="pw-post-body-paragraph kl km iu kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li in bi translated">DVC默认使用引用链接，如果不可用，就退回到文件复制。它避免使用符号链接和硬链接，因为存在意外缓存或存储库损坏的风险。我们将在接下来的章节中看到所有这些。</p><h1 id="d2c1" class="ll lm iu bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">使用文件复制的版本化数据集</h1><p id="681e" class="pw-post-body-paragraph kl km iu kn b ko mj kq kr ks mk ku kv kw ml ky kz la mm lc ld le mn lg lh li in bi translated">在签出Git标记时将文件复制到适当位置的基本(或幼稚)策略相当于以下命令:</p><pre class="mo mp mq mr gu ms mt mu mv aw mw bi"><span id="db62" class="mx lm iu mt b gz my mz l na nb">$ rm data/wikidatawiki-stub-articles.xml<br/>$ cp .dvc/cache/40/58c95964df74395df6e9e8e1aa6056 data/wikidatawiki-stub-articles.xml</span></pre><p id="2e48" class="pw-post-body-paragraph kl km iu kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li in bi translated">这可以在任何文件系统上运行，但是复制文件需要很长时间，并且会消耗两倍的磁盘空间。</p><p id="720f" class="pw-post-body-paragraph kl km iu kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li in bi translated">奇怪的文件名是怎么回事？它是DVC缓存中的文件名，十六进制数字是MD5校验和。DVC缓存中的文件通过该校验和进行索引，允许同一文件有多个版本。<a class="ae lj" href="https://dvc.org/doc/user-guide/dvc-files-and-directories#structure-of-cache-directory" rel="noopener ugc nofollow" target="_blank"> DVC文档</a>包含了更多关于DVC缓存实现的细节。</p><p id="ca57" class="pw-post-body-paragraph kl km iu kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li in bi translated">实际上，DVC是这样运作的:</p><figure class="mo mp mq mr gu ke gi gj paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gi gj ng"><img src="../Images/e47f204eb9b5f92f8489c402555a054a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*IW4EqQ3Di_bAO0gJ.gif"/></div></div><p class="kh ki gk gi gj kj kk bd b be z dk translated">作者图片</p></figure><p id="6dce" class="pw-post-body-paragraph kl km iu kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li in bi translated">为了设置工作空间，我们创建了两个Git标记，每个标记对应于我们下载的一个文件。关于版本化数据集的<a class="ae lj" href="https://dvc.org/doc/get-started/example-versioning" rel="noopener ugc nofollow" target="_blank"> DVC示例</a> ( <a class="ae lj" href="https://techsparx.com/software-development/ai/dvc/versioning-example.html" rel="noopener ugc nofollow" target="_blank">或本替代教程</a>)应该会让您对设置工作空间涉及的内容有所了解。为了测试不同的文件复制/链接模式，我们首先更改DVC配置，然后检查给定的Git提交。运行“<code class="fe nd ne nf mt b">dvc checkout</code>”会将相应的数据文件插入到目录中。</p><p id="3b10" class="pw-post-body-paragraph kl km iu kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li in bi translated">哦，伙计，那确实花了很长时间。这个的Git部分非常快，但是DVC花了很长时间。这是意料之中的，因为我们告诉DVC执行文件复制，我们已经知道使用<code class="fe nd ne nf mt b">cp</code>命令复制文件大约需要16分钟。</p><p id="eae9" class="pw-post-body-paragraph kl km iu kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li in bi translated">至于磁盘空间，显然现在有数据文件的两个副本。一个拷贝在DVC缓存目录中，另一个拷贝在工作区中。</p><figure class="mo mp mq mr gu ke gi gj paragraph-image"><div class="gi gj nl"><img src="../Images/34c4903b77a5a48ad6eca1fff4dd6aa3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1046/format:webp/0*ERm3hQBbfj2H9OuM.png"/></div><p class="kh ki gk gi gj kj kk bd b be z dk translated">来源:<a class="ae lj" href="https://www.xkcd.com/981/" rel="noopener ugc nofollow" target="_blank">https://www.xkcd.com/981/</a>(知识共享)</p></figure><h1 id="ff14" class="ll lm iu bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">使用硬链接和符号链接的版本化数据集</h1><p id="4fe3" class="pw-post-body-paragraph kl km iu kn b ko mj kq kr ks mk ku kv kw ml ky kz la mm lc ld le mn lg lh li in bi translated">显然，复制文件来处理数据集版本是缓慢的，并且是对磁盘空间的低效使用。在类Unix环境中，一个自古以来就存在的选项是硬链接和符号链接。虽然Windows历史上不支持文件链接，但“<code class="fe nd ne nf mt b">mklink</code>”也可以支持这两种类型的链接。</p><figure class="mo mp mq mr gu ke gi gj paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gi gj nm"><img src="../Images/61785e75506734301b1835b6004178e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*4_0Hfk8ZRh8kkuEF.png"/></div></div><p class="kh ki gk gi gj kj kk bd b be z dk translated">作者图片</p></figure><p id="a25e" class="pw-post-body-paragraph kl km iu kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li in bi translated">硬链接是Unix文件系统模型的副产品。我们所认为的文件名实际上只是目录文件中的一个条目。目录文件条目包含文件名和“inode number ”,它只是inode表中的一个索引。Inode表条目是包含文件属性和指向实际数据的指针的数据结构。硬链接只是两个具有相同索引节点号的目录条目。实际上，它是出现在文件系统中两个位置的完全相同的文件。硬链接只能在给定的装入卷中进行。</p><p id="4d39" class="pw-post-body-paragraph kl km iu kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li in bi translated">符号链接是一个特殊的文件，其属性包含指定链接目标的路径名。因为它包含路径名，所以符号链接可以指向文件系统中的任何文件，甚至可以跨已挂载的卷或跨网络文件系统。</p><p id="968e" class="pw-post-body-paragraph kl km iu kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li in bi translated">这种情况下的等效命令是:</p><pre class="mo mp mq mr gu ms mt mu mv aw mw bi"><span id="c209" class="mx lm iu mt b gz my mz l na nb">$ rm data/wikidatawiki-stub-articles.xml<br/>$ ln .dvc/cache/40/58c95964df74395df6e9e8e1aa6056 data/wikidatawiki-stub-articles.xml</span></pre><p id="4245" class="pw-post-body-paragraph kl km iu kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li in bi translated">这是一个硬链接。对于符号链接，使用“<code class="fe nd ne nf mt b">ln -s</code>”。</p><p id="d615" class="pw-post-body-paragraph kl km iu kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li in bi translated">然后执行硬链接场景:</p><figure class="mo mp mq mr gu ke gi gj paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gi gj ng"><img src="../Images/5f7f22449e1dff608fc2e29dc67d9172.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Vv_yZy96wdNflb2c.gif"/></div></div><p class="kh ki gk gi gj kj kk bd b be z dk translated">作者图片</p></figure><p id="cbce" class="pw-post-body-paragraph kl km iu kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li in bi translated">符号链接场景是相同的，但是将<code class="fe nd ne nf mt b">cache.type</code>设置为<code class="fe nd ne nf mt b">symlink</code>。两种情况下的时间是相似的。</p><p id="3c6c" class="pw-post-body-paragraph kl km iu kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li in bi translated">两秒钟(或更短)肯定比复制文件所需的16分钟要快得多。它发生得如此之快，以至于我们用了“瞬间”这个词。文件链接比到处复制文件要快得多。这是一个巨大的胜利。</p><p id="fd47" class="pw-post-body-paragraph kl km iu kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li in bi translated">至于磁盘空间消耗，请考虑以下情况:</p><pre class="mo mp mq mr gu ms mt mu mv aw mw bi"><span id="5e8e" class="mx lm iu mt b gz my mz l na nb">$ ls -l data/<br/>total 8<br/>lrwxr-xr-x  1 david  staff   70 Jul 21 18:43 wikidatawiki-stub-articles.xml -&gt; /Users/david/dvc/linktest/.dvc/cache/2c/82d0130fb32a17d58e2b5a884cd3ce</span></pre><p id="03fc" class="pw-post-body-paragraph kl km iu kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li in bi translated">该链接占用的磁盘空间可以忽略不计。但是有一个问题需要考虑。</p><p id="ffd4" class="pw-post-body-paragraph kl km iu kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li in bi translated">好吧，看起来不错，对吧？快速，没有额外的空间消耗…但是，让我们想想如果你在工作区编辑<code class="fe nd ne nf mt b">data/wikidatawiki-stub-articles.xml</code>会发生什么。因为该文件链接到DVC缓存中的文件，所以缓存中的文件会被更改，从而污染缓存。你需要采取额外的措施，并学会如何避免这个问题。<a class="ae lj" href="https://dvc.org/doc/user-guide/update-tracked-file" rel="noopener ugc nofollow" target="_blank"> DVC文档</a>中有使用DVC时避免该问题的说明。这意味着永远记住使用一个特定的过程来编辑数据文件，虽然不是一个交易破坏者，但不太方便。不过更好的选择是使用reflinks。</p><h1 id="3659" class="ll lm iu bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">使用引用链接的版本化数据集</h1><p id="5818" class="pw-post-body-paragraph kl km iu kn b ko mj kq kr ks mk ku kv kw ml ky kz la mm lc ld le mn lg lh li in bi translated">硬链接和符号链接在Unix/Linux生态系统中已经存在很长时间了。我第一次使用符号链接是在1984年的4.2BSD上，硬链接可以追溯到更早。硬链接和符号链接都可以用来做DVC做的事情，即快速重新安排工作目录中的数据文件。但是在过去的35年多时间里，文件系统肯定有了一两个进步吧？</p><figure class="mo mp mq mr gu ke gi gj paragraph-image"><div class="gi gj nn"><img src="../Images/1889d54d7092a775ad08e9664f02ee93.png" data-original-src="https://miro.medium.com/v2/resize:fit:974/format:webp/0*t39G_jTa6nQJRpnu.png"/></div><p class="kh ki gk gi gj kj kk bd b be z dk translated">作者图片</p></figure><p id="203c" class="pw-post-body-paragraph kl km iu kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li in bi translated">确实有，Mac OS X的“<code class="fe nd ne nf mt b">clonefile</code>”和Linux的“<code class="fe nd ne nf mt b">reflink</code>”功能就是例子。</p><p id="e912" class="pw-post-body-paragraph kl km iu kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li in bi translated">写链接时复制，也称为引用链接，提供了一种快速将文件链接到工作区的解决方案，同时避免了污染缓存的任何风险。硬链接和符号链接方法因其速度而大获全胜，但这样做有污染缓存的风险。使用引用链接，写时复制行为意味着如果有人修改数据文件，缓存中的副本不会被污染。这意味着我们将拥有与传统链接相同的性能优势，以及额外的数据安全性优势。</p><p id="e31c" class="pw-post-body-paragraph kl km iu kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li in bi translated">也许，你和我一样，不知道什么是reflink。这种技术意味着在磁盘上复制一个文件，这样“副本”就是一个类似于硬链接的“克隆”。与两个目录条目引用同一个索引节点条目的硬链接不同，引用链接有两个索引节点条目，共享的是数据块。它和硬链接一样快，但是有一个重要的区别。对克隆文件的任何写入都会导致分配新的数据块来保存该数据。克隆的文件看起来发生了变化，而原始文件未被修改。克隆非常适合复制数据集的情况，允许在不污染原始数据集的情况下修改数据集。</p><p id="a89b" class="pw-post-body-paragraph kl km iu kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li in bi translated">与硬链接一样，引用链接仅在给定的已装入卷内起作用。</p><p id="24d1" class="pw-post-body-paragraph kl km iu kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li in bi translated">参考链接在Mac OS X上很容易找到，在Linux上也很容易找到。此功能仅在某些文件系统上受支持:</p><ul class=""><li id="9e45" class="no np iu kn b ko kp ks kt kw nq la nr le ns li nt nu nv nw bi translated">Linux: BTRFS，XFS，OCFS2</li><li id="1f25" class="no np iu kn b ko nx ks ny kw nz la oa le ob li nt nu nv nw bi translated">麦克·OS X:APFS</li></ul><p id="2ec1" class="pw-post-body-paragraph kl km iu kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li in bi translated">APFS在macOS上是开箱即用的，苹果强烈建议我们使用它。对于Linux，XFS是最容易设置的，如本教程所示。</p><p id="7078" class="pw-post-body-paragraph kl km iu kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li in bi translated">对于APFS，等效的命令是:</p><pre class="mo mp mq mr gu ms mt mu mv aw mw bi"><span id="9864" class="mx lm iu mt b gz my mz l na nb">$ rm data/wikidatawiki-stub-articles.xml<br/>$ cp -c .dvc/cache/40/58c95964df74395df6e9e8e1aa6056 data/wikidatawiki-stub-articles.xml</span></pre><p id="4c3b" class="pw-post-body-paragraph kl km iu kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li in bi translated">使用<code class="fe nd ne nf mt b">-c</code>选项，macOS <code class="fe nd ne nf mt b">cp</code>命令使用<code class="fe nd ne nf mt b">clonefile(2)</code>系统调用。<code class="fe nd ne nf mt b">clonefile</code>函数设置命名文件的reflink克隆。在Linux上，<code class="fe nd ne nf mt b">cp</code>命令使用<code class="fe nd ne nf mt b">--reflink</code>选项。</p><p id="a143" class="pw-post-body-paragraph kl km iu kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li in bi translated">然后运行测试:</p><figure class="mo mp mq mr gu ke gi gj paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gi gj ng"><img src="../Images/c5d916072bd807b5736e98e8586f7a02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*w8aCbeBL22dH_tSJ.gif"/></div></div><p class="kh ki gk gi gj kj kk bd b be z dk translated">作者图片</p></figure><p id="27e9" class="pw-post-body-paragraph kl km iu kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li in bi translated">正如预期的那样，性能类似于硬链接和符号链接策略。我们了解到引用链接和硬链接、符号链接一样快，磁盘空间消耗也可以忽略不计。</p><p id="dcd9" class="pw-post-body-paragraph kl km iu kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li in bi translated">这个链接很酷的一点是，即使文件是连接的，你也可以编辑文件，而不用修改缓存中的文件。被改变的数据在幕后被复制。</p><p id="1328" class="pw-post-body-paragraph kl km iu kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li in bi translated">在Linux上，相同的场景以相似的性能运行。</p><h1 id="35cf" class="ll lm iu bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">结论</h1><figure class="mo mp mq mr gu ke gi gj paragraph-image"><div class="gi gj ka"><img src="../Images/344e468fa7de69f2a41aa685fa4c2e41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1262/format:webp/0*KIrBdwcqDR310xOu.png"/></div><p class="kh ki gk gi gj kj kk bd b be z dk translated">来源——DVC</p></figure><p id="39e4" class="pw-post-body-paragraph kl km iu kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li in bi translated">我们已经了解了如何有效地管理大型数据集，就像机器学习项目中的典型情况一样。如果我们需要重新访问此类项目中的任何开发阶段，我们将需要一个系统来有效地重新安排大型数据集以匹配每个阶段。</p><p id="2025" class="pw-post-body-paragraph kl km iu kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li in bi translated">我们已经看到，在任何Git提交时保存文件列表是可能的。有了这个列表，我们可以将这些文件链接或复制到工作目录中。这正是DVC在项目中管理数据文件的方式。使用链接，而不是文件复制，让我们快速有效地在项目的不同版本之间切换。</p><p id="fb9d" class="pw-post-body-paragraph kl km iu kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li in bi translated">Reflinks是文件系统的一个有趣的新特性，非常适合这个场景。Reflinks创建起来和传统的硬链接和符号链接一样快，让我们可以快速复制一个文件，或者整个目录结构，而消耗的额外空间可以忽略不计。而且，由于reflinks在链接的文件中保存修改，它们给了我们比传统链接更多的可能性。在本文中，我们研究了在机器学习项目中使用引用链接，但它们也用于其他类型的应用程序。例如，一些数据库系统利用它们来更有效地管理磁盘上的数据。现在你已经了解了引用链接，你将如何使用它们呢？</p><p id="06d2" class="pw-post-body-paragraph kl km iu kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li in bi translated"><em class="lk">此文最初发布于</em> <a class="ae lj" href="https://dev.to/robogeek/reflinks-vs-symlinks-vs-hard-links-and-how-they-can-help-machine-learning-projects-1cj4" rel="noopener ugc nofollow" target="_blank"> <em class="lk"> dev.to </em> </a></p></div></div>    
</body>
</html>