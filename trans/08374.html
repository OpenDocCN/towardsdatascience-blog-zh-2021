<html>
<head>
<title>Type safety in data parsers using PySpark</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用PySpark的数据分析器中的类型安全</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/type-safety-in-data-parsers-using-pyspark-a81093b4fe03?source=collection_archive---------37-----------------------#2021-08-01">https://towardsdatascience.com/type-safety-in-data-parsers-using-pyspark-a81093b4fe03?source=collection_archive---------37-----------------------#2021-08-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="ff2c" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用Apache PySpark解析数据时确保类型安全</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/c78b77f4cd7db843797be7eb61ad0cad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Tc6AkmUBrGcxriIh"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图为<a class="ae kv" href="https://unsplash.com/@thommilkovic?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">托姆·米尔科维奇</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></p></figure><p id="2f05" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">数据工程师的主要任务之一是从多个来源获取数据。这些来源可能是API端点、流服务、将文件上传到云的cron作业等。从这些来源获取的数据被转储到数据湖中，随后用于解析和下游业务逻辑的ETL。</p><p id="acba" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是这里的问题是:当涉及到源系统产生的字段的数据类型时，我们能依赖源系统，尤其是第三方吗？</p><p id="a028" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最好不要依赖这些来源，而是在消费级别卸载类型检查和类型转换的过程，即让数据消费者根据自己的需要定义目标数据类型。</p><p id="ca8d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">本文介绍了一种确保解析器类型安全的方法及其优缺点。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="ef19" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">方法</h1><p id="68fc" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">以JavaScript Object Notation (JSON)格式的数据为例，JSON中的字段可以有多种类型。有时，我们甚至可能不知道哪些字段具有哪些数据类型，这使得跟踪和确保正确维护各个字段的类型变得极其困难。</p><p id="6b2c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，在JSON模式包含的所有字段中实施统一性是至关重要的。最安全的方法是在模式树的所有叶节点上强制执行<code class="fe mw mx my mz b">StringType</code>。<strong class="ky ir"> <em class="na">叶节点</em> </strong>是一个字段，可以是字符串、bigint或时间戳等。类型，但不是结构类型或数组类型。</p><p id="fd5d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们来看看这是如何做到的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nb nc l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">在JSON数据中强制使用StringType</p></figure><p id="27c5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">假设您已经将JSON数据加载到一个dataframe中，JSON列以名称<code class="fe mw mx my mz b">json</code>出现。</p><p id="169a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，模式是从json列中推断出来的。然后，<code class="fe mw mx my mz b">enforce_stringtype</code>函数对从Spark推断的模式中检索到的模式元数据执行深度优先搜索(DFS)。它检查模式元数据中的特定字段是否是叶。如果是叶字段，它将所有叶字段(不是struct或array类型的字段)转换为string并返回else，它在struct或array字段内部遍历并将所有叶字段转换为string类型。</p><p id="7543" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，模式元数据被转换回StructType，用于在json列上强制执行更改后的模式。</p><p id="bd1d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，可以将所需的转换应用于可以从<code class="fe mw mx my mz b">type_safe_json</code>列获得的字段，以转换为数据消费者指定的目标数据类型。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="54ba" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">赞成的意见</h1><p id="f9b3" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">这种方法有几个优点。</p><ol class=""><li id="ea22" class="nd ne iq ky b kz la lc ld lf nf lj ng ln nh lr ni nj nk nl bi translated">转换为StringType不会导致任何数据丢失，也不会在摄取后和消费前过程中删除行。</li><li id="718f" class="nd ne iq ky b kz nm lc nn lf no lj np ln nq lr ni nj nk nl bi translated">数据源对JSON中的字段进行的任何数据类型更改，例如从整数到双精度，都是通过这种方法处理的。</li><li id="2d21" class="nd ne iq ky b kz nm lc nn lf no lj np ln nq lr ni nj nk nl bi translated">强制StringType后完成的转换可以确保特定字段具有一组数据类型。</li></ol></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="001b" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">骗局</h1><p id="eb1d" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">尽管这种方法有几个优点，但它也有一些缺点。</p><ol class=""><li id="3542" class="nd ne iq ky b kz la lc ld lf nf lj ng ln nh lr ni nj nk nl bi translated">强制StringType后应用于字段的转换是一项额外的计算。此外，如果源系统是可靠的，这些字段可能已经固有了目标数据类型。因为它们被转换成字符串，然后再转换回目标数据类型，这意味着一个冗余的计算。</li><li id="a13b" class="nd ne iq ky b kz nm lc nn lf no lj np ln nq lr ni nj nk nl bi translated">为要应用转换的字段设置目标数据类型是手工操作。如果有大量的字段要进行转换，这可能会变得很乏味。</li><li id="fac9" class="nd ne iq ky b kz nm lc nn lf no lj np ln nq lr ni nj nk nl bi translated">向下转换将导致数据丢失(如double到int)，这必须由使用者解决。</li></ol><p id="8524" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">总之，信任源系统保留每个字段的相同数据类型是有问题的。这种方法可以用来确保安全，避免由源系统引起的任何类型的数据类型冲突，但它有上述明显的缺点。将指定目标数据类型的过程转移给消费者，使得解析器独立于任何数据类型检查。这也符合在消费数据时决定模式的情况。</p></div></div>    
</body>
</html>