<html>
<head>
<title>A Benchmark of Spring Annotations vs Kotlin DSL</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Spring注释与Kotlin DSL的对比基准</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/a-benchmark-of-spring-annotations-vs-kotlin-dsl-209f54294325?source=collection_archive---------6-----------------------#2021-04-16">https://towardsdatascience.com/a-benchmark-of-spring-annotations-vs-kotlin-dsl-209f54294325?source=collection_archive---------6-----------------------#2021-04-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ca38" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">为什么您应该考虑迁移到Springboot的新Kotlin DSL</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f045439424109e6be908024b5853f268.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*lHhMiml61P21NzzE"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@bradencollum?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">布拉登·科拉姆</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="db06" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Spring的5.0版本引入了Kotlin DSL(领域特定语言)来定义<a class="ae ky" href="https://docs.spring.io/spring-framework/docs/current/reference/html/languages.html#kotlin-web" rel="noopener ugc nofollow" target="_blank">路由</a>和<a class="ae ky" href="https://docs.spring.io/spring-framework/docs/current/reference/html/languages.html#kotlin-bean-definition-dsl" rel="noopener ugc nofollow" target="_blank">bean</a>。</p><p id="36c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用DSL，<strong class="lb iu">你不需要支付不确定性</strong>来知道你是否正确地连接了东西。</p><p id="2cd6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您是否曾经花费数小时进行调试，只是为了发现您将bean放在了一个没有被扫描的包中？或者您没有通过某些注释属性？或者你的pom中缺少了一些<code class="fe lv lw lx ly b">spring-boot-starter-<em class="lz">something</em></code>？</p><p id="4959" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">别提了。如果DSL可以编译，那么可以肯定spring正在解析您的beans！</p><p id="9841" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用DSL还有第二大优势。<a class="ae ky" href="https://docs.spring.io/spring-framework/docs/current/reference/html/languages.html#kotlin-bean-definition-dsl" rel="noopener ugc nofollow" target="_blank">来自spring文档</a></p><blockquote class="ma mb mc"><p id="a426" class="kz la lz lb b lc ld ju le lf lg jx lh md lj lk ll me ln lo lp mf lr ls lt lu im bi translated">他的机制非常有效，因为它不需要任何反射或CGLIB代理</p></blockquote><p id="b768" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">太棒了。但是<strong class="lb iu">有多高效</strong>？我做了一些基准测试，我将展示结果。</p><h1 id="dd1d" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">评估方法</h1><p id="0cdc" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">基准的源代码在这里是<a class="ae ky" href="https://github.com/lucapiccinelli/springboot-dsl-benchmark" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="7b2b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我创建了两个maven模块进行测试:</p><ul class=""><li id="5ff9" class="nd ne it lb b lc ld lf lg li nf lm ng lq nh lu ni nj nk nl bi translated"><strong class="lb iu"> nodsl </strong>:带有经典注释的spring应用程序。</li><li id="69ff" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">dsl1 :带dsl初始化的spring应用。</li></ul><p id="ee76" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注释模块具有以下类层次结构:</p><pre class="kj kk kl km gt nr ly ns nt aw nu bi"><span id="90fb" class="nv mh it ly b gy nw nx l ny nz">Controller<br/>|__ Service<br/>    |__ Repository (using JPA)</span></pre><p id="df9f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">DSL模块代之以另一个层次结构:</p><pre class="kj kk kl km gt nr ly ns nt aw nu bi"><span id="5def" class="nv mh it ly b gy nw nx l ny nz">Router<br/>|__ Handler<br/>    |__ Repository (without JPA)</span></pre><p id="a31a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我用<a class="ae ky" href="https://kotlinlang.org/docs/kapt.html" rel="noopener ugc nofollow" target="_blank"> Kapt </a>创建了一个注释处理器来复制这些结构。我用每种结构的1000个复制品做了测试。每个副本都有自己的包。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/b95dd04b8b17105230ae2b52f49388fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-7O2EZEQLsiO3L9205IseQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">自动生成的包装结构</p></figure><p id="b2dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">控制器的层次结构在Spring上下文中注册，带有典型的注释<code class="fe lv lw lx ly b">@RestController, @Service, @Repository, @Entity, @Component</code>。路由器的层次结构注册如下:</p><pre class="kj kk kl km gt nr ly ns nt aw nu bi"><span id="00fd" class="nv mh it ly b gy nw nx l ny nz">@HowManyRoutes(1000)<br/>@SpringBootApplication(scanBasePackages = [])<br/>class DslApplication<br/><br/>fun main(args: Array&lt;String&gt;) {<br/>    <em class="lz">runApplication</em>&lt;DslApplication&gt;(*args)<strong class="ly iu">{<br/>        addInitializers(<em class="lz">allBeans</em>())</strong><br/>    <strong class="ly iu">}<br/></strong>}</span><span id="bce6" class="nv mh it ly b gy ob nx l ny nz">fun allBeans(): BeanDefinitionDsl {<br/>   return beans {<br/>      beans1(this) <br/>      beans2(this)<br/>      ...<br/>      beans1000(this)<br/>   }<br/>}</span><span id="ced6" class="nv mh it ly b gy ob nx l ny nz">public fun beans1(dsl: BeanDefinitionDsl): Unit {<br/>  dsl.bean&lt;HelloHandler1&gt;()<br/>  dsl.bean&lt;InMemoryCustomerRepository1&gt;()<br/>  dsl.bean(::helloRouter1)<br/>}</span><span id="4df2" class="nv mh it ly b gy ob nx l ny nz">public fun helloRouter1(handler: HelloHandler1) = <em class="lz">router </em><strong class="ly iu">{<br/>    </strong>"hello1".<em class="lz">nest </em><strong class="ly iu">{<br/>        </strong>GET("", handler::hello)<br/>    <strong class="ly iu">}<br/>}</strong></span></pre><h1 id="413e" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">结果</h1><p id="b703" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">您可以在存储库的根目录中找到应用程序启动的日志:</p><ul class=""><li id="7a3d" class="nd ne it lb b lc ld lf lg li nf lm ng lq nh lu ni nj nk nl bi translated"><a class="ae ky" href="https://github.com/lucapiccinelli/springboot-dsl-benchmark/blob/master/result-dsl.txt" rel="noopener ugc nofollow" target="_blank">结果-dsl.txt </a></li><li id="5d61" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated"><a class="ae ky" href="https://github.com/lucapiccinelli/springboot-dsl-benchmark/blob/master/result-no-dsl.txt" rel="noopener ugc nofollow" target="_blank"> result-no-dsl.txt </a></li></ul><p id="903f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是第一次运行的结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/a28d97bfa30f6e924b9c7bf9a2641546.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Gis5OJiVTOUHyzGDYHSfuQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">第一轮测试的结果</p></figure><p id="0064" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">乍一看，它很有希望。这种差异在上下文的初始化和总的开始时间方面都很显著。</p><p id="8caa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我必须指出，对于DSL，我没有使用JPA。在“无DSL”的情况下，存储库扫描需要22.185秒。在启动(<code class="fe lv lw lx ly b">spring.jpa.hibernate.ddl-auto=none</code>)期间，我没有在数据库中创建表</p><p id="2422" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我<strong class="lb iu">删除JPA </strong>同时保留依赖结构，会发生什么？我用普通的<code class="fe lv lw lx ly b">@Component</code>替换了<code class="fe lv lw lx ly b">@Repository</code>，去掉了<code class="fe lv lw lx ly b">spring-boot-starter-data-jpa</code>。你可以在Github上的资源库的<a class="ae ky" href="https://github.com/lucapiccinelli/springboot-dsl-benchmark/tree/no-jpa" rel="noopener ugc nofollow" target="_blank">分支</a> <code class="fe lv lw lx ly b">no-jpa</code>中找到代码。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/ce6879ee903577965c1118bbdd4ba195.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s_HNpRDIxhxF-6HO4syxmg.png"/></div></div></figure><p id="7d85" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些结果让我大吃一惊。<strong class="lb iu">如果JPA没有到位，使用DSL与否几乎没有区别</strong>。初始化上下文所需的时间略有不同，但总的启动时间几乎相同。</p><h1 id="9ce7" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">讨论</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/f8ae164c4328cc3c38d0e2c9e338cfec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*xcwj3woz0acnwUzo"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@icons8?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Icons8团队</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="e539" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我通过询问DSL <strong class="lb iu">会在多大程度上改善Springboot应用程序的启动时间来开始这个基准测试。基准测试之后，我可以说DSL本身<strong class="lb iu">没有直接的好处</strong>。</strong></p><p id="8569" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">JPA使用CGLIB代码生成，这个基准测试证明它对引导性能有巨大的影响。另外，使用<code class="fe lv lw lx ly b">@Transanctional</code>注释会导致将bean包装在一个CGLIB代理中。</p><p id="c5ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想使用Springboot并保持可接受的引导时间，那么你应该<strong class="lb iu">避免Spring用CGLIB </strong>代理你的beans。这意味着避免JPA、<code class="fe lv lw lx ly b">@Transactional</code>注释，以及在 <code class="fe lv lw lx ly b"><a class="ae ky" href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factorybeans-annotations" rel="noopener ugc nofollow" target="_blank">@Configuration</a></code>中声明的<code class="fe lv lw lx ly b"><a class="ae ky" href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factorybeans-annotations" rel="noopener ugc nofollow" target="_blank">@Bean</a></code> <a class="ae ky" href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factorybeans-annotations" rel="noopener ugc nofollow" target="_blank">工厂方法。</a></p><p id="3001" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">即使在这个基准测试之前，我也不喜欢JPA。现在我又多了一个避免它的理由。</p><p id="f0cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我已经在我的个人积压给一个尝试<a class="ae ky" href="https://github.com/JetBrains/Exposed" rel="noopener ugc nofollow" target="_blank">科特林暴露</a>。这是替代JPA和Hibernate的一个很好的选择。暴露，与避免“<a class="ae ky" href="https://docs.spring.io/spring-framework/docs/3.0.0.M3/reference/html/ch16s10.html" rel="noopener ugc nofollow" target="_blank">约定优于配置</a>”的Spring DSL方向相同。</p><h1 id="834c" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">结论</h1><p id="33c3" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">在扫描和注入beans的时间方面，DSL并没有真正的好处。无论如何，前提是它提高了性能，因为<strong class="lb iu">它不使用CGLIB和反射</strong>。</p><p id="85d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了这个基准，我证明了CGLIB的影响有多大。然后，使用一种强制您避免它的编码风格，具有改善引导启动时间的间接好处。</p><p id="f716" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">“<a class="ae ky" href="https://docs.spring.io/spring-framework/docs/3.0.0.M3/reference/html/ch16s10.html" rel="noopener ugc nofollow" target="_blank">约定胜于配置</a>”第一次尝试的时候，听起来很迷人，很神奇。不幸的是，当你不得不调试复杂的情况时，它会变得像魔咒一样快。</p><p id="5e59" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">采用声明式方法可以节省你调试的时间。有编译器作为编码伴侣，让你对你写的东西更有信心。这也是一个优势，因为以错误的方式使用工具的机会要少得多。</p><p id="6367" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我很确定在我的下一个项目中，我会尝试DSL，并且避免JPA和Hibernate。</p><p id="21f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我知道你对放弃JPA、Hibernate和“约定胜于配置”的感觉。它让你害怕，还是让你兴奋？</p><p id="36b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢您的阅读。</p></div></div>    
</body>
</html>