<html>
<head>
<title>Time series classification using Dynamic Time Warping</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于动态时间弯曲的时间序列分类</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/time-series-classification-using-dynamic-time-warping-61dcd9e143f6?source=collection_archive---------2-----------------------#2021-09-14">https://towardsdatascience.com/time-series-classification-using-dynamic-time-warping-61dcd9e143f6?source=collection_archive---------2-----------------------#2021-09-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="44bb" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">结合动态时间弯曲(DTW)和k近邻(KNN)的快速可伸缩时间序列分类</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/20b7e94b32ba1bd0773f803f65c9a4a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*4udcrUDQsH3CyAhP"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">内森·杜姆劳在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="ae4a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">时间序列分类是一项常见的任务，在IOT(物联网)、信号处理、人类活动识别等众多领域有着广泛的应用。目标是训练一个模型，在给定带有标记时间序列的数据集的情况下，该模型可以准确预测时间序列的类别。</p><p id="ed96" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">解决这个问题的一种流行方法是使用<strong class="lb iu">K-最近邻算法</strong>，但不是使用经典的欧几里德距离，而是采用<strong class="lb iu">动态时间弯曲(DTW) </strong>度量。DTW考虑到了这样一个事实，即被比较的两个时间序列在长度和速度上可能不同。</p><p id="6ed2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种方法虽然在实践中简单且有效，但实际上相当难以捉摸，这主要归因于DTW。初学者最常见的错误是在KNN上执行超参数调谐，而完全忽略了DTW部分。DTW的主要缺点是时间复杂性:对于具有长序列的大型数据集，可能无法在合理的时间内训练模型。幸运的是，通过理解DTW的基本概念，有可能执行必要的调整以显著加快算法的速度。</p><p id="a5e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> DTW:工作原理</strong></p><p id="74ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本质上，DTW是一个动态规划算法。这些算法递归地将问题分解成子问题(如果适用)，存储结果，并在以后需要时使用这些结果，而不是重新计算它们。帮助你记住使用动态编程的好处的一个窍门是引用乔治·桑塔亚纳的一句话(这也是我的教授在相应课程的课堂上说的话) :</p><blockquote class="lv lw lx"><p id="a0b9" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">忘记过去的人注定要重蹈覆辙。</p></blockquote><p id="cef7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要进一步深入动态编程和时间扭曲的世界，这些资源[1]，[2]是一个很好的起点。由于本文关注的是数据科学部分，我们将使用Python来快速掌握算法是如何工作的。作为开始的例子，我们将使用<a class="ae ky" href="https://dtaidistance.readthedocs.io/en/latest/index.html" rel="noopener ugc nofollow" target="_blank"> dtaidistance </a>库并计算两个相移正弦波之间的距离:</p><pre class="kj kk kl km gt mc md me mf aw mg bi"><span id="b90e" class="mh mi it md b gy mj mk l ml mm">from dtaidistance import dtw<br/>from dtaidistance import dtw_visualisation as dtwvis<br/>import random<br/>import numpy as np</span><span id="770c" class="mh mi it md b gy mn mk l ml mm">x = np.arange(0, 20, .5)<br/>s1 = np.sin(x)<br/>s2 = np.sin(x - 1)<br/>path = dtw.warping_path(s1, s2)<br/>dtwvis.plot_warping(s1, s2, path)<br/>distance = dtw.distance(s1, s2)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/3fff7314f0ebdcc36a1ded4302f3f02e.png" data-original-src="https://miro.medium.com/v2/resize:fit:868/format:webp/1*vIZBSsrPOHohbODjlP66kQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图1:2个系列之间的最佳弯曲距离</p></figure><p id="cc74" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">图1 </strong>显示了两个正弦波所有点之间的最佳距离。我们还可以绘制动态规划矩阵(或累计成本矩阵),显示所有的变形路径。如图<strong class="lb iu">图二</strong>所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mp"><img src="../Images/47bc458a4a35c34bed1c11ec3f533003.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NXwhcdz36bt0FgkjhmRAyg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图2:成本矩阵</p></figure><p id="e473" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果这种类型的矩阵是熟悉的，你是对的！当实现<a class="ae ky" href="https://en.wikipedia.org/wiki/Needleman%E2%80%93Wunsch_algorithm" rel="noopener ugc nofollow" target="_blank">needle man–Wunsch</a>算法(核苷酸序列比对)和<a class="ae ky" href="https://en.wikipedia.org/wiki/Levenshtein_distance" rel="noopener ugc nofollow" target="_blank"> Levenshtein距离</a>时，构建类似的矩阵，这两种算法都属于动态规划算法家族。</p><p id="f68f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">图2 中<strong class="lb iu">的每个单元格实际上是一个数字，代表正在比较的两个数据点之间的距离，每个序列一个。颜色越深，距离越小。构造完矩阵后，提取最优翘曲路径(红线)。</strong></p><p id="b206" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一方面，时间复杂度是<em class="ly"> O(M，N) </em>其中<em class="ly"> M，N </em>是各个序列的长度——一个二次成本！考虑到序列可能很大(在现实世界的例子中并不少见)以及KNN之后仍然必须运行的事实，模型很可能需要太长时间来训练。</p><p id="ad27" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">幸运的是，现在我们知道了DTW是如何工作的以及问题的背景，优化整个执行是可能的。<strong class="lb iu">图2 </strong>中的一个关键观察结果是，最佳弯曲路径大多沿着主对角线。大多数情况下都会出现这种情况。对于第<em class="ly"> i </em>行中的单元格，随着索引从对角线向第<em class="ly"> j </em>列移动，成本开始上升。直觉上，真实世界的数据集中不太可能存在大规模相移。作为数据集探索的一部分，还可以用傅立叶变换提取重要的频率，并确保没有任何问题。</p><p id="337a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">前面提到的库通过<em class="ly">窗口</em>参数给了我们这个能力。我们还添加了<em class="ly"> use_pruning=True : </em></p><pre class="kj kk kl km gt mc md me mf aw mg bi"><span id="acbf" class="mh mi it md b gy mj mk l ml mm">d, paths = dtw.warping_paths(s1, s2, window=20, use_pruning=True )<br/>best_path = dtw.best_path(paths)<br/>dtwvis.plot_warpingpaths(s1, s2, paths, best_path)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mp"><img src="../Images/f4aa5a9e9667ac73becd58ff63dd90fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V3tbdvl_R2TiiofFywRMmw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图3:修剪后的DTW</p></figure><p id="390e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">图3 中的空白单元格被算法跳过，因为最大位移为20。为了更好地演示这种优化，我们将使用一个真实的数据集。</p><p id="a4b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">真实案例场景</strong></p><p id="4507" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将使用来自<a class="ae ky" href="https://archive.ics.uci.edu/ml/datasets/human+activity+recognition+using+smartphones" rel="noopener ugc nofollow" target="_blank"> UCI </a>的流行的HAR(人类活动识别)数据集，其中包含带标签的时间序列。具体来说，该数据集的一个实例是一个戴着智能手机的人，该智能手机在执行以下活动之一(行走、上楼、下楼、坐着、站着、躺着)时捕捉线加速度和角速度。因此，每个观察都是一个561特征向量，具有时间/频率域变量和描述人的活动的标签，目标是建立一个模型，使用来自智能手机的转换后的反馈来准确预测活动。</p><pre class="kj kk kl km gt mc md me mf aw mg bi"><span id="28b6" class="mh mi it md b gy mj mk l ml mm">x_train_file = open(r'UCI HAR Dataset/train/X_train.txt', 'r')<br/>y_train_file = open(r'UCI HAR Dataset/train/y_train.txt', 'r')</span><span id="ec8b" class="mh mi it md b gy mn mk l ml mm">x_test_file = open(r'UCI HAR Dataset/test/X_test.txt', 'r')<br/>y_test_file = open(r'UCI HAR Dataset/test/y_test.txt', 'r')</span><span id="05c6" class="mh mi it md b gy mn mk l ml mm"># Create empty lists<br/>x_train = []<br/>y_train = []<br/>x_test = []<br/>y_test = []</span><span id="426f" class="mh mi it md b gy mn mk l ml mm"># Mapping table for classes<br/>labels = {1:'WALKING', 2:'WALKING UPSTAIRS', 3:'WALKING DOWNSTAIRS',<br/>          4:'SITTING', 5:'STANDING', 6:'LAYING'}</span><span id="5666" class="mh mi it md b gy mn mk l ml mm"># Loop through datasets<br/>for x in x_train_file:<br/>    x_train.append([float(ts) for ts in x.split()])<br/>    <br/>for y in y_train_file:<br/>    y_train.append(int(y.rstrip('\n')))<br/>    <br/>for x in x_test_file:<br/>    x_test.append([float(ts) for ts in x.split()])<br/>    <br/>for y in y_test_file:<br/>    y_test.append(int(y.rstrip('\n')))<br/>    <br/># Convert to numpy for efficiency<br/>x_train = np.array(x_train)<br/>y_train = np.array(y_train)<br/>x_test = np.array(x_test)<br/>y_test = np.array(y_test)</span><span id="7073" class="mh mi it md b gy mn mk l ml mm">colors = ['#D62728','#2C9F2C','#FD7F23','#1F77B4','#9467BD',<br/>          '#8C564A','#7F7F7F','#1FBECF','#E377C2','#BCBD27']</span></pre><p id="9e67" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们计算一下计算训练集的第一个时间序列和测试集中的所有序列之间的距离所需的时间:</p><pre class="kj kk kl km gt mc md me mf aw mg bi"><span id="e617" class="mh mi it md b gy mj mk l ml mm">%%time<br/>idx=0<br/>for r in range(len(x_test)):<br/>    distance = dtw.distance(x_train[idx], x_test[r], window=20, use_pruning='True')</span><span id="373d" class="mh mi it md b gy mn mk l ml mm">#Output<br/>Wall time: 1min 42s</span><span id="05b8" class="mh mi it md b gy mn mk l ml mm">for r in range(len(x_test)):<br/>    distance = dtw.distance(x_train[idx], x_test[r])</span><span id="5e0d" class="mh mi it md b gy mn mk l ml mm">#Output<br/>Wall time: 25min 16s</span></pre><p id="ca19" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">显然，加速效果非常显著！最后，通过应用KNN算法对实例进行了总结。上述所有示例都使用k=20作为KNN，使用窗口大小=20作为DTW函数。<em class="ly"> idx </em>变量只是测试集中时间序列的索引:</p><pre class="kj kk kl km gt mc md me mf aw mg bi"><span id="9aef" class="mh mi it md b gy mj mk l ml mm"># function that takes as input the number of neigbors of KNN and the # index of the time series in the test set, and returns one of the <br/># labels: WALKING, WALKING_UPSTAIRS, WALKING_DOWNSTAIRS, SITTING, <br/># STANDING, LAYING</span><span id="7072" class="mh mi it md b gy mn mk l ml mm">def classifyNN(k:int, idx:int) -&gt; str:<br/>    <br/>    idxs=range(0,x_train.shape[0])<br/>    n=x_train.shape[0]<br/>    distances=[]<br/>    counters={}<br/>    c=1;<br/>    max_value=0</span><span id="d293" class="mh mi it md b gy mn mk l ml mm">for r in range(n):<br/>        distances.append(dtw.distance(x_test[idx], x_train[idxs[r]],window=10,use_pruning=True))</span><span id="ae47" class="mh mi it md b gy mn mk l ml mm">NN=sorted(range(len(distances)), key=lambda i: distances[i], reverse=False)[:k]<br/>    <br/>    for l in labels.values():<br/>        counters[l]=0</span><span id="a64d" class="mh mi it md b gy mn mk l ml mm">for r in NN:<br/>        l=labels[y_train[r]]<br/>        counters[l]+=1<br/>        if (counters[l])&gt;max_value:<br/>            max_value=counters[l]<br/>        #print('NN(%d) has label %s' % (c,l))<br/>        c+=1<br/>    <br/>    # find the label(s) with the highest frequency<br/>    keys = [k for k in counters if counters[k] == max_value]<br/>    <br/>    # in case of a tie, return one at random<br/>    return (sample(keys,1)[0])</span></pre><p id="51bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们测试几个案例:</p><p id="ebec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">例一:</strong>级<em class="ly">‘站着’</em></p><pre class="kj kk kl km gt mc md me mf aw mg bi"><span id="8b3f" class="mh mi it md b gy mj mk l ml mm">k=20<br/>idx=3</span><span id="c4bd" class="mh mi it md b gy mn mk l ml mm">plt.plot(x_test[idx], label=labels[y_test[idx]], color=colors[y_test[idx]-1], linewidth=2)<br/>plt.xlabel('Samples <a class="ae ky" href="http://twitter.com/50Hz" rel="noopener ugc nofollow" target="_blank">@50Hz</a>')<br/>plt.legend(loc='upper left')<br/>plt.tight_layout()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/81fecb4b3935d66ea79cd31317deac7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:848/format:webp/1*NhflP_6SpoP35BzKTOEaNg.png"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mr"><img src="../Images/d1a79339d8b08a540eb4a5b2f4b9aadc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8mgzbhRdn5oA78vgQJQLrA.png"/></div></div></figure><p id="c1be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">例2: </strong>类<em class="ly">‘坐’</em></p><pre class="kj kk kl km gt mc md me mf aw mg bi"><span id="4117" class="mh mi it md b gy mj mk l ml mm">k=20<br/>idx=200</span><span id="ad67" class="mh mi it md b gy mn mk l ml mm">plt.plot(x_test[idx], label=labels[y_test[idx]], color=colors[y_test[idx]-1], linewidth=2)<br/>plt.xlabel('Samples <a class="ae ky" href="http://twitter.com/50Hz" rel="noopener ugc nofollow" target="_blank">@50Hz</a>')<br/>plt.legend(loc='upper left')<br/>plt.tight_layout()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/30d9229f28d217062010a8d7405f4b77.png" data-original-src="https://miro.medium.com/v2/resize:fit:848/format:webp/1*SWXJH84qcvOibsYcd6H6wg.png"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ms"><img src="../Images/cba575c9e57e4fd84f184642748f8563.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Xm3k7LrFXc73IecK1enDhQ.png"/></div></div></figure><p id="77ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">例3: </strong>类<em class="ly">‘行走’</em></p><pre class="kj kk kl km gt mc md me mf aw mg bi"><span id="5a97" class="mh mi it md b gy mj mk l ml mm">k=20<br/>idx=401</span><span id="28e4" class="mh mi it md b gy mn mk l ml mm">plt.plot(x_test[idx], label=labels[y_test[idx]], color=colors[y_test[idx]-1], linewidth=2)<br/>plt.xlabel('Samples <a class="ae ky" href="http://twitter.com/50Hz" rel="noopener ugc nofollow" target="_blank">@50Hz</a>')<br/>plt.legend(loc='upper left')<br/>plt.tight_layout()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/ac0d59d9a1a525092166fa373c61f080.png" data-original-src="https://miro.medium.com/v2/resize:fit:848/format:webp/1*AG7lRGwLYspxgHdaOdAT0A.png"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mt"><img src="../Images/091dd65a9aa6aa8c006ba5455c563a42.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AXnjTCe1vkH5LlFhi76BLg.png"/></div></div></figure><p id="bdd9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">显然，所有的例子都被正确地分类了。总的来说，该算法执行得非常好。值得一提的是，如果我们没有添加启用修剪的<em class="ly">窗口</em>参数，该模型将需要几天的时间来训练！(更改classifyNN()函数中的<em class="ly">窗口</em>参数，自己看看)</p><p id="8b1c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">平行化呢？</p><p id="3571" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来想到的是是否有可能通过应用<strong class="lb iu">并行化来进一步加速DTW的执行。</strong>不幸的是，对于当前形式的DTW来说，这是非常棘手的，然而，通过对算法进行一些修改，还有一些其他实现，时间复杂度甚至变成线性。尽管这些实现并不总是提供最佳的解决方案。另一方面，通过并行计算数据集中所有时间序列的<strong class="lb iu"> DTW成对距离</strong>，可以整体加速执行。当我们想要快速构建距离矩阵时，这也是非常有用的。您可能已经猜到了，这种技术通过使用<strong class="lb iu">层次聚类</strong>在时间序列聚类中找到了应用。<a class="ae ky" href="https://dtaidistance.readthedocs.io/en/latest/index.html" rel="noopener ugc nofollow" target="_blank"> dtaidistance </a>库包含函数<em class="ly">distance _ matrix _ fast</em>(<em class="ly">序列列表</em>)返回一个距离矩阵并并行运行。</p><p id="4314" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">结束语</strong></p><p id="6a2e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">DTW和KNN的结合对于时间序列分类是非常有效的。虽然关于时间复杂性有一个警告，但是我们已经展示了如何优化搜索空间和加速执行。除了分类之外，当在时间序列中应用聚类时，DTW也被用作距离度量，因此了解这种技术是如何工作的是非常必要的。最后，关于分类，在这个领域中还有其他算法，如时间序列森林分类器，它通常在需要可解释性时使用(特征重要性提取，如随机森林)。</p><p id="d872" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">参考文献</strong></p><p id="89bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">[1]<a class="ae ky" href="https://en.wikipedia.org/wiki/Dynamic_time_warping" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Dynamic_time_warping</a></p><p id="043d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">[2]<a class="ae ky" href="https://en.wikipedia.org/wiki/Dynamic_programming" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Dynamic_programming</a></p></div></div>    
</body>
</html>