<html>
<head>
<title>23 Efficient Ways of Subsetting a Pandas DataFrame</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">熊猫数据框架子集的23种有效方法</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/23-efficient-ways-of-subsetting-a-pandas-dataframe-6264b8000a77?source=collection_archive---------2-----------------------#2021-06-04">https://towardsdatascience.com/23-efficient-ways-of-subsetting-a-pandas-dataframe-6264b8000a77?source=collection_archive---------2-----------------------#2021-06-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="30ca" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated"><strong class="ak">选择</strong>、<strong class="ak">切片</strong>、<strong class="ak">标引</strong>和<strong class="ak">过滤</strong></h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/0a02a0c073f6efd7f8d3cab264e62921.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HYLiBIsmj-DWq2Xbbhpk7A.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@sloppyperfectionist?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Hans-Peter Gauster </a>在<a class="ae ky" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="1b13" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<a class="ae ky" href="https://medium.com/codex/10-efficient-ways-for-inspecting-a-pandas-dataframe-object-3f66563e2f2" rel="noopener">第1部分</a>和<a class="ae ky" href="https://medium.com/codex/9-efficient-ways-for-describing-and-summarizing-a-pandas-dataframe-316234f46e6" rel="noopener">第2部分</a>中，我们学习了如何检查、描述和总结熊猫数据帧。今天，我们将学习如何提取熊猫数据帧的子集。这非常有用，因为我们经常想对数据子集执行操作。有许多不同的方法对熊猫数据框架进行分组。您可能需要选择包含所有行的特定列。有时，您希望选择包含所有列的特定行，或选择符合特定标准的行和列等。</p><p id="8c28" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所有不同的子集化方式可分为4类:<strong class="lb iu">选择</strong>、<strong class="lb iu">切片</strong>、<strong class="lb iu">索引</strong>和<strong class="lb iu">过滤</strong>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lv"><img src="../Images/b9f63988490935336ce1b1ce468626e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*axeZUlYKsiodCHPwp1vYag.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(作者图片)</p></figure><p id="f38f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您继续阅读本文时，您将了解这些类别之间的差异。</p><p id="9f4c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在讨论数据框的任何子集方法之前，值得区分<em class="lw">熊猫系列对象</em>和<em class="lw">熊猫数据框对象</em>。</p><h1 id="8d36" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">熊猫系列和数据框架对象</h1><p id="6cbe" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated"><strong class="lb iu"> <em class="lw">系列</em> </strong>和<strong class="lb iu"> <em class="lw">数据框</em> </strong>是大熊猫的两种主要数据结构。简单地说，一个<strong class="lb iu"> <em class="lw">系列</em> </strong> <em class="lw"> s </em>类似于单个数据列，而一个<strong class="lb iu"> <em class="lw">数据框</em> </strong>类似于有行和列的表格。请看下图:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mu"><img src="../Images/37e0ad62279a5475d277b54e8f253ca9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qddO5FQpTk9noHYgphAbGw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(作者图片)</p></figure><p id="c22b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如你所见，一个<strong class="lb iu"> <em class="lw">系列</em> </strong>是一维的，一个<strong class="lb iu"> <em class="lw">数据框</em> </strong>是二维的。如果我们把两个或多个<strong class="lb iu"> <em class="lw">系列对象</em> </strong>组合在一起，就可以得到一个<strong class="lb iu"> <em class="lw">数据框对象</em> </strong>。让我们看看<strong class="lb iu"> <em class="lw">系列</em> </strong>物体的实际视图。</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="4fc0" class="na ly it mw b gy nb nc l nd ne">import numpy as np<br/>import pandas as pd</span><span id="87eb" class="na ly it mw b gy nf nc l nd ne">data = np.array([85, 90, 70, 80])<br/>series = pd.Series(data=data, <br/>                   name="marks")<br/>print(series)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/dfe8a59c682589e8aac1b85388f72a0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:922/format:webp/1*1T-yxYBs14snoX6GMiu2Og.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(作者图片)</p></figure><p id="7ec9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个<strong class="lb iu"> <em class="lw">序列</em> </strong>由两部分组成:<strong class="lb iu">一维数据值</strong>和<strong class="lb iu">索引</strong>。索引为每个数据值提供了有意义的标签。用户可以使用该索引来选择值。默认情况下，索引从0开始。</p><p id="e7da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来看看一个<strong class="lb iu"> <em class="lw"> DataFrame </em> </strong>对象的实际视图。</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="377c" class="na ly it mw b gy nb nc l nd ne">import numpy as np<br/>import pandas as pd</span><span id="8385" class="na ly it mw b gy nf nc l nd ne">data = np.array([[25, 85],<br/>                 [25, 90],<br/>                 [26, 70],<br/>                 [24, 80]])</span><span id="c922" class="na ly it mw b gy nf nc l nd ne">dataframe = pd.DataFrame(data=data, <br/>                         columns=["age", "marks"])<br/>print(dataframe)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/47bf24179240170addaeab81e104dc9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1262/format:webp/1*nucEC4khFixN_92W3Mjq8A.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="e319" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个<strong class="lb iu"> <em class="lw">数据帧</em> </strong>由三部分组成:<strong class="lb iu">二维数据值</strong>、<strong class="lb iu">行索引</strong>和<strong class="lb iu">列索引</strong>。这些索引为行和列提供了有意义的标签。用户可以使用这些索引来选择行和列。默认情况下，索引从0开始。</p><p id="3fb6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们讨论给熊猫数据帧设置子集的不同方法。出于解释的目的，我将使用<strong class="lb iu">“葡萄酒数据集”</strong>。这是其中的一部分。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/448c5d612d07a7cd29c62e5698a4f488.png" data-original-src="https://miro.medium.com/v2/resize:fit:1048/format:webp/1*FxtIhoUhlXwypGkXtD2BiA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">葡萄酒数据集的一部分</p></figure><h1 id="f694" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated"><strong class="ak">选择</strong></h1><p id="6e21" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">当我们抓取整个列时，它被称为<strong class="lb iu"> <em class="lw">选择</em> </strong>。<strong class="lb iu"> </strong>所选列包含所有行。</p><h2 id="6ddd" class="na ly it bd lz nj nk dn md nl nm dp mh li nn no mj lm np nq ml lq nr ns mn nt bi translated">方法1:使用列名选择单个列</h2><p id="af19" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">我们可以使用列名选择Pandas数据帧中的一列。如果数据帧被称为<strong class="lb iu"> <em class="lw"> df </em> </strong>，一般语法为:</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="a6fc" class="na ly it mw b gy nb nc l nd ne">df['column_name']<br/># Or<br/>df.column_name # Only for single column selection</span></pre><p id="ac86" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出是一个单列的熊猫系列！</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="d78f" class="na ly it mw b gy nb nc l nd ne"># Load some data<br/>import pandas as pd<br/>from sklearn.datasets import load_wine<br/>wine = load_wine()<br/>df = pd.DataFrame(data=wine.data,<br/>                  columns=wine.feature_names)</span><span id="355f" class="na ly it mw b gy nf nc l nd ne"># Select the 'alcohol column'<br/>print(df['alcohol'])<br/>print(type(df['alcohol']))</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/9bc6267c11de1475bc25867d20d92c99.png" data-original-src="https://miro.medium.com/v2/resize:fit:688/format:webp/1*iVEyp9uG-m3TiONh57XFAQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><h2 id="0f59" class="na ly it bd lz nj nk dn md nl nm dp mh li nn no mj lm np nq ml lq nr ns mn nt bi translated">方法2:使用列名选择多个列</h2><p id="2480" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">我们可以使用列名选择熊猫数据帧的多列。我们可以在列表中定义列名:</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="1149" class="na ly it mw b gy nb nc l nd ne">['column_1', 'column_2', ...]</span></pre><p id="d921" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们可以将这个列表包含到<strong class="lb iu"> df[] </strong>中。一般语法是:</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="c7a8" class="na ly it mw b gy nb nc l nd ne">df[['column_1', 'column_2', ...]]</span></pre><p id="0b05" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这一次，输出的是一个熊猫数据帧！</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="a492" class="na ly it mw b gy nb nc l nd ne">df[['alcohol', 'ash', 'hue']]</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/ec138b01f684a46b57237852d4967b46.png" data-original-src="https://miro.medium.com/v2/resize:fit:440/format:webp/1*9U2Qievz_r3T__Da7Y_BuQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><h2 id="1a48" class="na ly it bd lz nj nk dn md nl nm dp mh li nn no mj lm np nq ml lq nr ns mn nt bi translated">方法3:使用。loc属性</h2><p id="acf6" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">使用<strong class="lb iu">可以获得与方法1相同的结果。loc </strong>属性，通过标签(列名)选择熊猫数据<em class="lw">。</em></p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="bb27" class="na ly it mw b gy nb nc l nd ne">df.loc[:, 'alcohol']</span></pre><h2 id="6172" class="na ly it bd lz nj nk dn md nl nm dp mh li nn no mj lm np nq ml lq nr ns mn nt bi translated">方法4:使用。loc属性</h2><p id="ad2a" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">使用<strong class="lb iu">可以获得与方法2相同的结果。loc </strong>属性，通过标签(列名)选择熊猫数据<em class="lw">。</em></p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="789f" class="na ly it mw b gy nb nc l nd ne">df.loc[:, ['alcohol', 'ash', 'hue']]</span></pre><p id="88ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">的一般语法。loc </strong>属性为:</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="da35" class="na ly it mw b gy nb nc l nd ne">df.loc['row_label', 'column_label']</span></pre><p id="2a55" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果有多个标签，应该在列表中指定它们:</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="e53a" class="na ly it mw b gy nb nc l nd ne">df.loc[['row_1', 'row_2'], <br/>       ['column_1', 'column_2']]</span></pre><p id="6d27" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们想选择所有的行或列，可以使用:symbol。<strong class="lb iu">最重要的一点。loc </strong>属性是通过标签选择熊猫数据<em class="lw">。</em></p><h2 id="04c9" class="na ly it bd lz nj nk dn md nl nm dp mh li nn no mj lm np nq ml lq nr ns mn nt bi translated">方法5:使用。iloc属性</h2><p id="7b0a" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">使用<strong class="lb iu">可以获得与方法1相同的结果。iloc </strong>属性，通过位置(列索引)选择熊猫数据<em class="lw">。</em></p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="79c3" class="na ly it mw b gy nb nc l nd ne">df.iloc[:, 0]</span></pre><p id="31b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lw">酒精</em>变量在位置0(第一个变量)。</p><h2 id="320e" class="na ly it bd lz nj nk dn md nl nm dp mh li nn no mj lm np nq ml lq nr ns mn nt bi translated">方法6:使用。iloc属性</h2><p id="0214" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">使用<strong class="lb iu">可以获得与方法2相同的结果。iloc </strong>属性，通过位置(列索引)选择熊猫数据<em class="lw">。</em></p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="f9b4" class="na ly it mw b gy nb nc l nd ne">df.iloc[:, [0, 2, 10]]</span></pre><p id="db39" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">的一般语法。iloc </strong>的属性是:</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="018a" class="na ly it mw b gy nb nc l nd ne">df.iloc['row_index', 'column_index']</span></pre><p id="e70d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果有多个标签，应该在列表中指定它们:</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="fb27" class="na ly it mw b gy nb nc l nd ne">df.iloc[['row_index_1', 'row_index_2'], <br/>       ['column_index_1', 'column_index_2']]</span></pre><p id="b660" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们想选择所有的行或列，可以用<strong class="lb iu"> : </strong>符号来完成。<strong class="lb iu">最重要的一点。iloc </strong>属性是它使用数字索引通过位置选择熊猫数据<em class="lw">。</em></p><h2 id="0e97" class="na ly it bd lz nj nk dn md nl nm dp mh li nn no mj lm np nq ml lq nr ns mn nt bi translated">方法7:使用。iloc属性(简单的方法)</h2><p id="2a93" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">我们可以选择<em class="lw"> df </em>的前5列如下:</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="f6b3" class="na ly it mw b gy nb nc l nd ne">df.iloc[:, [0, 1, 2, 3, 4]]</span></pre><p id="aee7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们也可以用下面的简单方法来获得同样的结果。</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="ecf7" class="na ly it mw b gy nb nc l nd ne">df.iloc[:, 0:5]</span></pre><p id="775f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要使用此功能，立柱应连续放置<em class="lw"/>。0:5范围包括0(第一列)，不包括5(第六列)，并选择该范围内的每一列。</p><h2 id="828c" class="na ly it bd lz nj nk dn md nl nm dp mh li nn no mj lm np nq ml lq nr ns mn nt bi translated">方法8:选择最后一列</h2><p id="7b18" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">在许多情况下，选择最后一列通常很有用。有两种方法:</p><p id="d174" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们可以使用<strong class="lb iu">来计算数据帧中的列数。形状</strong>属性。</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="b15e" class="na ly it mw b gy nb nc l nd ne">df.shape<br/># Output: (178, 13)</span></pre><p id="c276" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后一列是可以通过索引12访问的第13列。通过使用<strong class="lb iu">。iloc </strong>，</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="0580" class="na ly it mw b gy nb nc l nd ne">df.iloc[:, 12]</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/24264c4e1d80483e11ddce6e18898ef8.png" data-original-src="https://miro.medium.com/v2/resize:fit:696/format:webp/1*Ktx8rYtzE3DC3ZvW3SSkGQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">葡萄酒数据集的最后一列(图片由作者提供)</p></figure><p id="24d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第二种方法简单得多。这里，我们不需要知道数据框中的列数。</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="8e91" class="na ly it mw b gy nb nc l nd ne">df.iloc[:, -1]</span></pre><p id="5f19" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> -1 </strong>表示最后一列。</p><h1 id="a307" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">限幅</h1><p id="99db" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">当我们想从数据帧中提取某些行时，就称之为<strong class="lb iu"> <em class="lw">切片</em> </strong>。提取的行称为<em class="lw">切片</em> <strong class="lb iu"> <em class="lw"> </em> </strong>，包含所有列。</p><h2 id="19a6" class="na ly it bd lz nj nk dn md nl nm dp mh li nn no mj lm np nq ml lq nr ns mn nt bi translated">方法9:使用。iloc属性</h2><p id="d440" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">提取单行的最简单方法是使用<strong class="lb iu">中的行索引。iloc </strong>属性。一般语法是:</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="c1b4" class="na ly it mw b gy nb nc l nd ne">df.iloc[row_index]</span></pre><p id="95b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出是包含行值的Pandas系列。</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="bcf4" class="na ly it mw b gy nb nc l nd ne">df.iloc[0]</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/528d901d35ea771e6a317c114346c49b.png" data-original-src="https://miro.medium.com/v2/resize:fit:654/format:webp/1*5z3mhSy6sV4ey4rUyChCCg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="56e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">外观有点混乱，因为输出是一个熊猫系列。如果您希望它本身作为一行，只需使用列表中的索引值，如下所示:</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="065d" class="na ly it mw b gy nb nc l nd ne">df.iloc[[0]]</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ny"><img src="../Images/8568cb6070beed8bd09c6e149423af23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X2NdwrJ5nvujWdfVhzWfKQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="5bc1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个熊猫数据框，包含1行和所有的列！</p><h2 id="da5f" class="na ly it bd lz nj nk dn md nl nm dp mh li nn no mj lm np nq ml lq nr ns mn nt bi translated">方法10:使用。iloc属性</h2><p id="5efe" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">我们可以使用Pandas数据帧的行索引来提取其中的多行。我们在列表中包含行索引:</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="4129" class="na ly it mw b gy nb nc l nd ne">[row_index_1, row_index_2, ...]</span></pre><p id="6077" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们把这个列表包含在<strong class="lb iu"> df.iloc[] </strong>里面。</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="1f39" class="na ly it mw b gy nb nc l nd ne">df.iloc[[row_index_1, row_index_2, ...]]</span></pre><p id="923b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出是一个熊猫数据帧。</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="5cec" class="na ly it mw b gy nb nc l nd ne">df.iloc[[0, 25, 100]]</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/bca7ed0784e1300fdacd081236a2607d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gIq7_qyAKX2bszfaH_B-mQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><h2 id="f37d" class="na ly it bd lz nj nk dn md nl nm dp mh li nn no mj lm np nq ml lq nr ns mn nt bi translated">方法11:选择最后几行</h2><p id="81bb" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">负索引从底部开始计算行数。</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="ad04" class="na ly it mw b gy nb nc l nd ne">df.iloc[[-1, -2, -3, -4, -5]]</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/2d7a26cf1d36a0a70b7b591df794ce85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4VpgrDZi7yeGnhfvQ8uCZw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><h1 id="3f38" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">索引</h1><p id="5e01" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">当我们将列选择和行切片结合起来时，称为<strong class="lb iu"> <em class="lw">索引</em> </strong>。在这里，我们可以使用<strong class="lb iu">。锁定</strong>和<strong class="lb iu">。熊猫数据帧的属性。</strong></p><h2 id="d1e3" class="na ly it bd lz nj nk dn md nl nm dp mh li nn no mj lm np nq ml lq nr ns mn nt bi translated">方法12:使用。iloc属性</h2><p id="3ce5" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">如果我们指定单行和单列，那么交集就是一个值！</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="110b" class="na ly it mw b gy nb nc l nd ne">df.iloc[0, 0]</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/49f21b96c275f54489f7e29baa666019.png" data-original-src="https://miro.medium.com/v2/resize:fit:320/format:webp/1*GqRLlDMHMrdf-gQVrYhk8A.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="8243" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请记住，我们不能在<strong class="lb iu">中使用列名或行名。iloc[] </strong>。只能使用索引号。</p><h2 id="de82" class="na ly it bd lz nj nk dn md nl nm dp mh li nn no mj lm np nq ml lq nr ns mn nt bi translated">方法13:使用。loc属性</h2><p id="56c8" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">这里我们可以在<strong class="lb iu">中使用行或列名。loc[] </strong>。还要记住，在我们的数据中，行标签与行索引相同。下面的代码给出了与方法12相同的结果。</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="74d6" class="na ly it mw b gy nb nc l nd ne">df.loc[0, 'alcohol']</span></pre><h2 id="1f8f" class="na ly it bd lz nj nk dn md nl nm dp mh li nn no mj lm np nq ml lq nr ns mn nt bi translated">方法14:使用。iloc属性</h2><p id="b8e8" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">一般语法是:</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="4550" class="na ly it mw b gy nb nc l nd ne">df.iloc[[row_index_1, row_index_2, ...],<br/>        [column_index_1, column_index_2, ...]]</span></pre><p id="7436" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出是一个熊猫数据帧。</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="ce1c" class="na ly it mw b gy nb nc l nd ne">df.iloc[[0, 5, 100], [0, 3, 7]]</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/fc8c30444887d4656227fd62802063ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:890/format:webp/1*sqO43n4OLE5KrA2EDw-3Pg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><h2 id="c8f3" class="na ly it bd lz nj nk dn md nl nm dp mh li nn no mj lm np nq ml lq nr ns mn nt bi translated">方法15:使用。loc属性</h2><p id="061c" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">一般语法是:</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="210c" class="na ly it mw b gy nb nc l nd ne">df.loc[[row_name, row_name_2, ...],<br/>        [column_name_1, column_name_2, ...]]</span></pre><p id="9094" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出是一个熊猫数据帧。</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="e479" class="na ly it mw b gy nb nc l nd ne">df.loc[[0, 5, 100], ['alcohol', 'ash', 'hue']]</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi od"><img src="../Images/07f98d800d81404d26bdbdf683cf3a99.png" data-original-src="https://miro.medium.com/v2/resize:fit:434/format:webp/1*kkkAsQovYSywlm0256lDqw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="192d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我们可以在<strong class="lb iu">中使用行或列名。loc[] </strong>。还要记住，在我们的数据中，行名与行索引相同。</p><h2 id="af45" class="na ly it bd lz nj nk dn md nl nm dp mh li nn no mj lm np nq ml lq nr ns mn nt bi translated">方法16:使用。loc和。iloc属性(简单的方法)</h2><p id="c0d7" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">这可以很容易地用<strong class="lb iu"> : </strong>符号来完成。为此，行和列应连续定位<em class="lw"/>。</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="5248" class="na ly it mw b gy nb nc l nd ne">df.iloc[0:6, 0:5]</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/096f0df8f536a8fa1a99d03831f6d804.png" data-original-src="https://miro.medium.com/v2/resize:fit:944/format:webp/1*vbk9_33tUgluP2joIxpOCw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="6743" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一个例子是:</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="445a" class="na ly it mw b gy nb nc l nd ne">df.loc[0:6, ['alcohol', 'ash']]</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi of"><img src="../Images/bd14e4cf1811eeff4b23f00347d4e027.png" data-original-src="https://miro.medium.com/v2/resize:fit:298/format:webp/1*TCwr7qN7GNqAO7HbpvvX6g.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><h1 id="b53c" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">过滤</h1><p id="0560" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">当我们根据特定的标准或条件选择行和列时，称为<strong class="lb iu"><em class="lw"/></strong>。我们也可以将上面讨论的方法与此结合。</p><h2 id="e685" class="na ly it bd lz nj nk dn md nl nm dp mh li nn no mj lm np nq ml lq nr ns mn nt bi translated">方法17:基于单一标准对所有列进行筛选</h2><p id="c5ea" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">让我们把我们的数据子集当<strong class="lb iu">酒精&gt; 14.3 </strong>时。在这里，我们选择所有的列当<strong class="lb iu">酒精&gt; 14.3 </strong>时。</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="e3d8" class="na ly it mw b gy nb nc l nd ne">df['alcohol'] &gt; 14.3</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi og"><img src="../Images/1ec0fa1760a56d801cad08e7ca9c47f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:646/format:webp/1*aOtgaQ_Ku5MYl2jCeY7CgQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="0a4f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个熊猫系列的布尔数据类型。我们可以使用这个系列来获得所需的数据子集。</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="dd61" class="na ly it mw b gy nb nc l nd ne">df[df['alcohol'] &gt; 14.3]</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/357ab28e29017bd040e7b19a5a86bc52.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RQojE0S2djzt6lCxc3sO-g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><h2 id="1bec" class="na ly it bd lz nj nk dn md nl nm dp mh li nn no mj lm np nq ml lq nr ns mn nt bi translated">方法18:基于具有几列的单一标准进行过滤</h2><p id="db48" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">让我们把我们的数据子集当<strong class="lb iu">酒精&gt; 14.3 </strong>时。这一次，当<strong class="lb iu">酒精&gt; 14.3 </strong>时，我们只选择3列。为此，我们可以将上述过滤技术与<strong class="lb iu">相结合。loc[] </strong>。</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="eabc" class="na ly it mw b gy nb nc l nd ne">df.loc[df['alcohol'] &gt; 14.3, <br/>      ['alcohol', 'ash', 'hue']]</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/128e81440ff04979e73421ba41ebc58a.png" data-original-src="https://miro.medium.com/v2/resize:fit:452/format:webp/1*baP9rsssZkD09aPTJ_aZiQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><h2 id="04a9" class="na ly it bd lz nj nk dn md nl nm dp mh li nn no mj lm np nq ml lq nr ns mn nt bi translated">方法19:使用AND运算符基于两个标准进行筛选(同一列)</h2><p id="374a" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">当<strong class="lb iu">酒精&gt;为14.3，酒精&lt;为14.6 </strong>时，让我们对数据进行子集化。这里，我们使用两个条件，并用<strong class="lb iu">和</strong>操作符将它们组合起来。每个条件都应该用括号括起来。</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="0c25" class="na ly it mw b gy nb nc l nd ne">df[(df['alcohol'] &gt; 14.3) &amp; (df['alcohol'] &lt; 14.6)]</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/352c90ed3d89a536f4d1a2cd0c1787e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7zYteGMtnbvCuR4nGQw5ag.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><h2 id="664c" class="na ly it bd lz nj nk dn md nl nm dp mh li nn no mj lm np nq ml lq nr ns mn nt bi translated">方法20:使用between()方法基于两个标准进行过滤</h2><p id="1904" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">使用<strong class="lb iu"> between() </strong>方法可以实现方法19中讨论的类似类型的过滤。</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="dc03" class="na ly it mw b gy nb nc l nd ne">df[df['alcohol'].between(14.3, 14.6)]</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/23d5c1e166d2f7f1d5e7a27d5bf22770.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ND2VPS8pbCo-C5TYHZFWrQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="7c8a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，输出有一点不同，因为默认情况下，()方法中的<strong class="lb iu">包含了下界(14.3)和上界(14.6)的值。然而，如果我们不想要包含选择，我们可以通过<em class="lw"> inclusive=False </em>。</strong></p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="609f" class="na ly it mw b gy nb nc l nd ne">df[df['alcohol'].between(14.3, 14.6,<br/>                         inclusive=False)]</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ok"><img src="../Images/d94480e58c81a5c006c2bea155044246.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9O0ayUFNf4elYdqUHLRSYg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="e701" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该子集与方法19中获得的子集完全相同。</p><h2 id="9066" class="na ly it bd lz nj nk dn md nl nm dp mh li nn no mj lm np nq ml lq nr ns mn nt bi translated">方法21:使用AND运算符基于两个标准进行筛选(不同的列)</h2><p id="ff97" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">这里，这两个条件是使用两个不同的列生成的:<strong class="lb iu">酒精</strong>和<strong class="lb iu">色调</strong>。</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="dfc3" class="na ly it mw b gy nb nc l nd ne">df[(df['alcohol'] &gt; 14.3) &amp; (df['hue'] &gt; 1.0)]</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ol"><img src="../Images/8375a848dd1a893db66a421ced924578.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mn81zsG1GXJnsK9OsWD4Cg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><h2 id="6b2f" class="na ly it bd lz nj nk dn md nl nm dp mh li nn no mj lm np nq ml lq nr ns mn nt bi translated">方法22:使用OR运算符基于两个标准进行筛选</h2><p id="3b18" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">当我们使用<strong class="lb iu">和</strong>运算符时，过滤发生在考虑<em class="lw">和</em>两个条件都为真的情况下。如果我们希望<em class="lw">至少有一个</em>条件为真，我们可以使用<strong class="lb iu">或</strong>操作符。</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="f79f" class="na ly it mw b gy nb nc l nd ne">df[(df['alcohol'] &gt; 14.5) | (df['hue'] &gt; 1.4)]</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi om"><img src="../Images/2fe2579bb8bd45295669647293ce1e18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xipAtp5XVx3U38CuvXBlkA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><h2 id="88b1" class="na ly it bd lz nj nk dn md nl nm dp mh li nn no mj lm np nq ml lq nr ns mn nt bi translated">方法23:基于最小值和最大值进行过滤</h2><p id="e8cf" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">让我们根据<em class="lw">酒精</em>变量的最小值和最大值对数据进行分组。首先，我们得到最小值和最大值的指数:</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="bf86" class="na ly it mw b gy nb nc l nd ne">df['alcohol'].idxmin() # Min value index<br/>df['alcohol'].idxmax() # Max value index</span></pre><p id="7687" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们用<strong class="lb iu">。iloc[] </strong>。</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="224c" class="na ly it mw b gy nb nc l nd ne">df.iloc[[df['alcohol'].idxmin(),<br/>         df['alcohol'].idxmax()]]</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi on"><img src="../Images/54a0d167f22a68a37d8ec13a5b9a0265.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gZAull7r8BHLM01djzP1nw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><h1 id="2411" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">摘要</h1><p id="7f0e" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">这些并不是熊猫数据帧子集的唯一方式。还有很多。对于复杂的子集，我们可以结合多种方法。这篇文章帮助你熟悉子集化语法。另外，您现在已经熟悉了术语<strong class="lb iu">选择</strong>、<strong class="lb iu">切片</strong>、<strong class="lb iu">索引</strong>和<strong class="lb iu">过滤</strong>。另外，请记住<strong class="lb iu">。iloc </strong>需要整数值(<strong class="lb iu"> i </strong>为整数)，而<strong class="lb iu">需要整数值。loc </strong>需要标签值。</p></div><div class="ab cl oo op hx oq" role="separator"><span class="or bw bk os ot ou"/><span class="or bw bk os ot ou"/><span class="or bw bk os ot"/></div><div class="im in io ip iq"><p id="0f0a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">今天的帖子到此结束。我的读者可以通过下面的链接注册成为会员，以获得我写的每个故事的全部信息，我将收到你的一部分会员费。</p><p id="2bd5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">报名链接:</strong><a class="ae ky" href="https://rukshanpramoditha.medium.com/membership" rel="noopener">https://rukshanpramoditha.medium.com/membership</a></p><p id="2b63" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">非常感谢你一直以来的支持！下一个故事再见。祝大家学习愉快！</p><p id="39ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">特别要感谢Unsplash上的<strong class="lb iu">汉斯-彼得·高斯特</strong>、<strong class="lb iu"> </strong>为我提供了这篇文章的漂亮封面图片。</p><p id="b262" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ov ow ep" href="https://medium.com/u/f90a3bb1d400?source=post_page-----6264b8000a77--------------------------------" rel="noopener" target="_blank">鲁克山普拉莫迪塔</a><br/><strong class="lb iu">2021–06–04</strong></p></div></div>    
</body>
</html>