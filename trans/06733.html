<html>
<head>
<title>NaN, None and Experimental NA</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">NaN、None和实验NA</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/nan-none-and-experimental-na-d1f799308dd5?source=collection_archive---------21-----------------------#2021-06-17">https://towardsdatascience.com/nan-none-and-experimental-na-d1f799308dd5?source=collection_archive---------21-----------------------#2021-06-17</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><div class=""/><div class=""><h2 id="3ea9" class="pw-subtitle-paragraph jo iq ir bd b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf dk translated">熊猫价值观缺失的图解指南</h2></div><p id="b8f7" class="pw-post-body-paragraph kg kh ir ki b kj kk js kl km kn jv ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">现代技术创新经常涉及处理和分析带有<em class="lc">缺失值</em>的数据集。而且，为了有效地处理这些数据集，不同的库选择以不同的方式表示缺失的值。鉴于它们的重要性和频繁出现，我们将从当前的艺术状态开始，讨论它们的属性，然后按时间顺序说明在<em class="lc">熊猫</em>中使用的可用缺失值惯例。</p><figure class="le lf lg lh gu li gi gj paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="gi gj ld"><img src="../Images/da4464c506b058968677a73c4f60a0be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zwJDqxQXLMVeIt2_FNmcGA.png"/></div></div><p class="lp lq gk gi gj lr ls bd b be z dk translated">图片由作者制作，使用<a class="ae lt" href="https://apps.diagrams.net" rel="noopener ugc nofollow" target="_blank">图</a>。</p></figure><p id="a81c" class="pw-post-body-paragraph kg kh ir ki b kj kk js kl km kn jv ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">为了让<strong class="ki is">表示缺失值</strong>，我们看到<strong class="ki is">有两种方法</strong>，它们通常应用于表格或数据帧中的数据。第一种方法包含一个<em class="lc">掩码</em>来指出缺失值，而第二种方法使用特定于数据类型的<em class="lc">标记值</em>来表示缺失值。</p><p id="7d08" class="pw-post-body-paragraph kg kh ir ki b kj kk js kl km kn jv ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">当<strong class="ki is">屏蔽</strong>时，<em class="lc">屏蔽</em>可以是全局屏蔽，也可以是局部屏蔽。全局掩码由每个数据数组的一个单独的布尔数组组成(图1)，而局部掩码利用元素的逐位表示中的一位。例如，一个<em class="lc">有符号整数</em>也保留了一个单独的位，用作本地掩码来指示整数的正/负<em class="lc">符号</em>。</p><figure class="le lf lg lh gu li gi gj paragraph-image"><div class="gi gj lu"><img src="../Images/6ee37703b5ff0966300d1f287e16058f.png" data-original-src="https://miro.medium.com/v2/resize:fit:588/format:webp/1*FBjMa_uvjTe_QiHeQuZfmQ.png"/></div><p class="lp lq gk gi gj lr ls bd b be z dk translated">图1:全局布尔掩码方法。请注意，MV表示缺失值。图片由作者使用<a class="ae lt" href="https://apps.diagrams.net" rel="noopener ugc nofollow" target="_blank">图</a>制作。</p></figure><p id="a2f3" class="pw-post-body-paragraph kg kh ir ki b kj kk js kl km kn jv ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">另一方面，在<strong class="ki is">标记</strong>方法中，定义了特定于数据类型的<em class="lc">标记值</em>。这可以是基于最佳实践的典型值，也可以是唯一定义的逐位表示。对于浮点类型的缺失值，库通常会选择标准的<a class="ae lt" href="https://en.wikipedia.org/wiki/IEEE_754" rel="noopener ugc nofollow" target="_blank"> IEEE 754 </a>浮点表示，称为<a class="ae lt" href="https://en.wikipedia.org/wiki/NaN" rel="noopener ugc nofollow" target="_blank"> NaN </a>(不是数字)，例如，参见图2。类似地，有些库也为其他数据类型定义了独特的位模式，例如<em class="lc"> R </em>。</p><figure class="le lf lg lh gu li gi gj paragraph-image"><div class="gi gj lv"><img src="../Images/fa156593f8f99337f05989a77e4ecd7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:818/format:webp/1*7Z8CtZUCsfy0YXLs8w0lmQ.png"/></div><p class="lp lq gk gi gj lr ls bd b be z dk translated">图2:说明了一个逐位的IEEE 754单精度(32位)NaN表示。根据维基百科，<a class="ae lt" href="https://en.wikipedia.org/wiki/IEEE_754" rel="noopener ugc nofollow" target="_blank">IEEE 754</a>nan编码为指数字段填充1(类似于无穷大值表示)，有效位字段中有一些非零数字“x”(“x”等于零表示无穷大)。这允许多个不同的NaN值，具体取决于有效位域中设置了哪些位，但也取决于前导符号位“s”的值。<a class="ae lt" href="https://stackoverflow.com/questions/19800415/why-does-ieee-754-reserve-so-many-nan-values" rel="noopener ugc nofollow" target="_blank">似乎</a>IEEE 754标准将16，777，214 ( ⁴-2)浮点值定义为NaNs，或所有可能值的0.4%。减去的两个值是正无穷大和负无穷大。另请注意，x的第一位用于确定NaN的类型:“安静NaN”或“发信号NaN”。其余位用于编码有效载荷(在应用中最常被忽略)。图片由作者提供，使用<a class="ae lt" href="https://apps.diagrams.net" rel="noopener ugc nofollow" target="_blank">图</a>制作。</p></figure><p id="fcd5" class="pw-post-body-paragraph kg kh ir ki b kj kk js kl km kn jv ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">尽管上述<strong class="ki is">屏蔽和哨兵方法</strong>被广泛采用，但它们也有各自的<strong class="ki is">权衡</strong>。单独的全局布尔<em class="lc">掩码</em>在存储和计算方面增加了额外的负担；然而，位样式的<em class="lc">标记</em>限制了可能丢失条目的有效值的范围。除此之外，用于标记的类型特定的逐位模式也需要实现附加的逻辑来执行比特级操作。</p><p id="6def" class="pw-post-body-paragraph kg kh ir ki b kj kk js kl km kn jv ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">由于<strong class="ki is"> <em class="lc"> pandas </em> </strong>是基于NumPy构建的，所以它只是将IEEE标准<em class="lc"> NaN </em>值合并为浮点数据类型的<em class="lc"> sentinel值</em>。然而，NumPy没有针对非浮点数据类型的内置<em class="lc">标记</em>。因此，这意味着<em class="lc">熊猫</em>可以利用<em class="lc">掩码</em>或者<em class="lc">哨兵</em>来处理非浮点类型。也就是说，<em class="lc"> pandas </em>既可以有一个全局布尔掩码，也可以在元素的逐位表示中本地保留一位，或者有唯一的特定类型的逐位表示，比如IEEE的<em class="lc"> NaN </em>。</p><p id="d9cc" class="pw-post-body-paragraph kg kh ir ki b kj kk js kl km kn jv ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">然而，如前所述，上述三种可能性[ <em class="lc">布尔掩码、位级掩码和哨兵码</em> ( <em class="lc">位模式</em> )]中的每一种都是有代价的。说到利用全局布尔掩码，<em class="lc">熊猫</em>可以基于NumPy的<em class="lc">掩码数组</em> ( <em class="lc"> ma </em>)模块。但是，所需的代码库维护、内存分配和计算工作量使其不太实用。类似地，在本地级别上，<em class="lc"> pandas </em>也可以在其元素的每个位表示中保留一个位。但话说回来，对于较小的8位数据单元，丢失一位用作本地掩码将显著减少它可以存储的值的范围。因此，认为全局和局部<em class="lc">屏蔽</em>是不利的。也就是说，这让我们想到了第三个选项，即特定类型的<em class="lc"> sentinels </em>。虽然这是一个可能的解决方案，但是熊猫对NumPy的依赖使得特定类型的哨兵变得不可行。例如，该包支持14种不同的整数类型，包括精度、字符顺序和有符号性。因此，如果要为NumPy支持的所有不同数据类型指定和维护独特的类似IEEE的标准位表示，那么<em class="lc"> pandas </em>将再次面临艰巨的开发任务。</p><p id="198d" class="pw-post-body-paragraph kg kh ir ki b kj kk js kl km kn jv ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated"><a class="ae lt" href="https://pandas.pydata.org/docs/user_guide/gotchas.html#nan-integer-na-values-and-na-type-promotions" rel="noopener ugc nofollow" target="_blank">由于上述实际考虑，并且作为计算效率和维护</a>之间的良好折衷，<strong class="ki is"> <em class="lc">熊猫</em>利用两个</strong>现有的<strong class="ki is"> Python哨兵来表示空</strong>。分别是IEEE的标准浮点值<strong class="ki is"> <em class="lc"> NaN </em> </strong>(可用<em class="lc"> </em>作为<em class="lc"> numpy.nan </em>)，Python的<a class="ae lt" href="https://en.wikipedia.org/wiki/Singleton_pattern" rel="noopener ugc nofollow" target="_blank">singleton</a>object<strong class="ki is"><em class="lc">None</em></strong>(如Python代码中所用)。</p><p id="fb93" class="pw-post-body-paragraph kg kh ir ki b kj kk js kl km kn jv ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">然而，<strong class="ki is">从v1.0 </strong>开始，在【2020年1月 <em class="lc">熊猫</em>为<em class="lc">标量</em>缺失值引入了一个内部<strong class="ki is"> <em class="lc">实验NA </em> </strong>值(单例对象)🎉<a class="ae lt" href="https://pandas.pydata.org/pandas-docs/stable/user_guide/missing_data.html#missing-data-na" rel="noopener ugc nofollow" target="_blank">根据文档</a>，这个新<strong class="ki is">的目标是<em class="lc">熊猫。NA </em> </strong> <a class="ae lt" href="https://en.wikipedia.org/wiki/Singleton_pattern" rel="noopener ugc nofollow" target="_blank"> singleton </a>提供了一个通用的“缺失值”指示器，可以在所有数据类型中一致使用。也就是用<em class="lc">熊猫。那</em>总的来说不是跳来跳去的<em class="lc">numpy nan</em>、<em class="lc"> None </em>或<em class="lc">熊猫。NaT </em>，这是特定于类型的。注意<em class="lc">熊猫。NaT </em>用于表示<em class="lc"> datetime </em>缺失值。</p><p id="ec09" class="pw-post-body-paragraph kg kh ir ki b kj kk js kl km kn jv ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">说到<em class="lc"> NaN </em>和<em class="lc"> None </em>，<em class="lc"> pandas </em>就是为了在这两个哨兵之间方便地切换(转换)，在需要的时候。例如，在下图中，我们从包含一个缺失值的<strong class="ki is">浮点值</strong>的列表中构造了一个简单的数据帧，我们用<em class="lc"> numpy.nan </em>或<em class="lc"> None、</em>来表示</p><figure class="le lf lg lh gu li gi gj paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="gi gj lw"><img src="../Images/9dc6aa07a2a6aebe475e04833c66d1a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CPs9nRyRzMQW6UZLqblPqw.png"/></div></div><p class="lp lq gk gi gj lr ls bd b be z dk translated">图3:说明了一个简单的单列数据帧，它由一个包含一个缺失值的浮点值列表构成。注意，默认情况下，pandas将浮点值推断为float64。图片由作者提供，使用<a class="ae lt" href="https://apps.diagrams.net" rel="noopener ugc nofollow" target="_blank">图</a>。</p></figure><p id="40a6" class="pw-post-body-paragraph kg kh ir ki b kj kk js kl km kn jv ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">虽然我们知道浮点缺失值将使用<em class="lc"> numpy.nan </em>来表示，但是为了方便起见，我们也可以使用<em class="lc"> None </em>来表示缺失值。在这种情况下，如上图所示，<em class="lc"> pandas </em>隐式地从<em class="lc"> None </em>切换到<em class="lc"> NaN </em>值。</p><p id="9476" class="pw-post-body-paragraph kg kh ir ki b kj kk js kl km kn jv ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">类似地，让我们考虑另一个例子，其中我们从一列<strong class="ki is">整数</strong>中构造一个数据帧，只缺少一个值，见下文。</p><figure class="le lf lg lh gu li gi gj paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="gi gj lw"><img src="../Images/84d8fe7bc52232fd71b416f053b3e7db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Rabm6ueUJdLEQ9Dh_emPDw.png"/></div></div><p class="lp lq gk gi gj lr ls bd b be z dk translated">图4:说明了一个简单数据帧中隐含的int到float类型转换现象，该数据帧由一个包含缺失值的整数列表构成。图片由作者提供，使用<a class="ae lt" href="https://apps.diagrams.net" rel="noopener ugc nofollow" target="_blank">图表</a>。</p></figure><p id="ae1b" class="pw-post-body-paragraph kg kh ir ki b kj kk js kl km kn jv ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">上图中有两件事需要注意。首先，在使用<em class="lc"> numpy.nan </em>、<em class="lc">熊猫</em>表示整数型缺失值时，将整数型数据(默认推断为<em class="lc"> int64 </em>)类型强制转换为浮点型数据(默认为<em class="lc"> float64 </em>)。其次，<em class="lc"> pandas </em>再次允许我们利用两个哨兵中的任何一个来表示整数类型的缺失值。也就是说，当<em class="lc"> None </em>用于表示缺失值时，它会隐式地将其转换为浮点值<em class="lc"> NaN </em>，参见上面的结果数据帧。然而，将整数自动类型转换为浮点值并不总是很方便。尤其是当我们希望整数保持为整数的时候。因为有时整数也作为标识符用于索引目的。别担心😉因为熊猫已经解决了这个问题😎</p><p id="81a7" class="pw-post-body-paragraph kg kh ir ki b kj kk js kl km kn jv ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">再次截止到2020年1月发布的<strong class="ki is"> v1.0 </strong>中，所有<em class="lc">熊猫【</em>现有的<em class="lc">可空整数</em>dtype，如(<a class="ae lt" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.UInt64Dtype.html" rel="noopener ugc nofollow" target="_blank"><em class="lc"/></a>)<a class="ae lt" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Int64Dtype.html" rel="noopener ugc nofollow" target="_blank"><em class="lc">int 64</em></a>，使用新的实验用<em class="lc">熊猫。NA </em>作为缺失值指示器，代替<em class="lc"> NaN </em>值。这太棒了😃因为通过使用任何<em class="lc"> pandas的</em>扩展integer类型，我们可以在需要时避免整型到浮点型的类型转换。请注意，为了区别于NumPy的整数类型，例如“int64”，extension-dtypes的字符串别名中的第一个字母是大写的，例如“Int64”。因此，作为一个例子，让我们使用扩展类型<em class="lc"> Int64 </em>和包含缺失值的一列<strong class="ki is">整数</strong>来构造一个简单的数据帧，见下文</p><figure class="le lf lg lh gu li gi gj paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="gi gj lw"><img src="../Images/3b49292e9eff3fb8c8a049df4ebfd4fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OXGNDdg4IJ03rYyB7Z65Ug.png"/></div></div><p class="lp lq gk gi gj lr ls bd b be z dk translated">图5:展示了一个单列数据帧，它由包含缺失值的整数列表构成，使用Int64扩展类型作为推断的数据类型。注意，您也可以将dtype别名“Int64”指定为pd。Int64Dtype()。此外，您还可以使用更小的位大小变量，如Int16或Int8。图片由作者提供，使用<a class="ae lt" href="https://apps.diagrams.net" rel="noopener ugc nofollow" target="_blank">图表</a>。</p></figure><p id="a02d" class="pw-post-body-paragraph kg kh ir ki b kj kk js kl km kn jv ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">如上图所示，当<em class="lc"> Int64 </em>被指定为<em class="lc"> dtype </em>时，<em class="lc"> pandas </em>不会将整数类型转换为浮点数据，它使用新的实验<em class="lc"> NA </em>值来表示所有标量缺失值，而不是<em class="lc"> NaN </em>。</p><p id="b416" class="pw-post-body-paragraph kg kh ir ki b kj kk js kl km kn jv ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated"><strong class="ki is">1.0</strong>版本还为我们提供了两种新的实验性扩展类型，类似于<em class="lc">整数&lt;位长&gt; Dtype </em>。这些是完全专用于字符串和布尔数据的<em class="lc">字符串</em>和<em class="lc">可空布尔</em>数据类型。新的Dtype可用作<a class="ae lt" href="https://pandas.pydata.org/pandas-docs/stable/whatsnew/v1.0.0.html#dedicated-string-data-type" rel="noopener ugc nofollow" target="_blank"><em class="lc">string type</em></a>和<a class="ae lt" href="https://pandas.pydata.org/pandas-docs/stable/whatsnew/v1.0.0.html#boolean-data-type-with-missing-values-support" rel="noopener ugc nofollow" target="_blank"> <em class="lc"> BooleanDtype </em> </a>以及它们相应的别名“string”和“boolean”。作为一个例子，下面我们举例说明一个简单的数据帧，该数据帧是使用新的实验扩展类型<a class="ae lt" href="https://pandas.pydata.org/pandas-docs/stable/whatsnew/v1.0.0.html#dedicated-string-data-type" rel="noopener ugc nofollow" target="_blank"><em class="lc">string type</em></a>以及一列带有缺失值的<strong class="ki is">字符串</strong>构建的，</p><figure class="le lf lg lh gu li gi gj paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="gi gj lw"><img src="../Images/3b02baf3eb43ad89f666062717891342.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*frSo0SQ7R_yyFeVr9Ei5mg.png"/></div></div><p class="lp lq gk gi gj lr ls bd b be z dk translated">图6:展示了一个使用pd从包含缺失值的字符串列表构建的单列数据帧。<a class="ae lt" href="https://pandas.pydata.org/pandas-docs/stable/whatsnew/v1.0.0.html#dedicated-string-data-type" rel="noopener ugc nofollow" target="_blank">string type</a>()扩展数据类型别名“string”。图片由作者使用<a class="ae lt" href="https://apps.diagrams.net" rel="noopener ugc nofollow" target="_blank">图</a>制作。</p></figure><p id="1c2a" class="pw-post-body-paragraph kg kh ir ki b kj kk js kl km kn jv ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">即使对于新的扩展<em class="lc">字符串</em>类型，当我们使用<em class="lc"> numpy.nan </em>或<em class="lc"> None </em>来表示一个缺失值时，<em class="lc"> pandas </em>会隐式地将其转换为结果数据帧中新的实验<em class="lc"> NA </em>标量值。是从<a class="ae lt" href="https://pandas.pydata.org/pandas-docs/stable/whatsnew/v1.1.0.html#all-dtypes-can-now-be-converted-to-stringdtype" rel="noopener ugc nofollow" target="_blank"> <strong class="ki is"> v1.1 </strong> </a>开始，在<strong class="ki is"><em class="lc">2020年7月</em> </strong>发布，这里所有的Dtype都可以转换成<em class="lc">string type</em>。</p><p id="da2d" class="pw-post-body-paragraph kg kh ir ki b kj kk js kl km kn jv ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">类似地，如图6所示，我们也可以使用新的扩展类型<a class="ae lt" href="https://pandas.pydata.org/pandas-docs/stable/whatsnew/v1.0.0.html#dedicated-string-data-type" rel="noopener ugc nofollow" target="_blank"><em class="lc">BooleanDtype</em></a><em class="lc"/>从一列<strong class="ki is"> bool </strong>和缺失值中构造一个dataframe，如下所示</p><figure class="le lf lg lh gu li gi gj paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="gi gj lw"><img src="../Images/2f484425aa4a666f9abc2556b27a8869.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J-k1pcBC-gkAJvjlLAWJcQ.png"/></div></div><p class="lp lq gk gi gj lr ls bd b be z dk translated">图7:展示了一个使用新扩展pd从一列bool和缺失值构建的单列数据帧。BooleanDtype() dtype别名“boolean”。图片由作者使用<a class="ae lt" href="https://apps.diagrams.net" rel="noopener ugc nofollow" target="_blank">图</a>制作。</p></figure><p id="c861" class="pw-post-body-paragraph kg kh ir ki b kj kk js kl km kn jv ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">并且，截至【2020年12月随着<a class="ae lt" href="https://pandas.pydata.org/pandas-docs/stable/whatsnew/v1.2.0.html?highlight=float64dtype#experimental-nullable-data-types-for-float-data" rel="noopener ugc nofollow" target="_blank">发布<em class="lc"> </em> <strong class="ki is"> v1.2 </strong> </a>，<em class="lc"> pandas </em>支持两个额外的实验性<em class="lc">float 32d type</em>/<em class="lc">float 64d type</em>扩展数据类型，它们完全专用于浮点数据。两种<em class="lc">可空浮动</em>类型都可以容纳实验用的<em class="lc">熊猫。NA </em>值。虽然NumPy的<em class="lc"> float </em>使用<em class="lc"> NaN </em>值来表示一个缺失值，但是这些新的扩展<em class="lc">dtype</em>现在与已经存在的<em class="lc">可空整数</em>和<em class="lc">布尔</em>dtype内联。下面的例子展示了工作中的<em class="lc">可空float</em>d type<em class="lc">float 64</em>，</p><figure class="le lf lg lh gu li gi gj paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="gi gj lw"><img src="../Images/89382c6dedac9675b694fc39ddc5cc5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vYLp3LE3jYGcPB7GLDJpTQ.png"/></div></div><p class="lp lq gk gi gj lr ls bd b be z dk translated">图8:说明了使用pd的数据帧结构。Float64Dtype()别名Float64，它是NumPy的float64数据类型的扩展，支持pd。不单身。注意，作为一种选择，只有一种更小的位尺寸变体可用，即Float32。图片由作者提供，使用<a class="ae lt" href="https://apps.diagrams.net" rel="noopener ugc nofollow" target="_blank">图表</a>。</p></figure><p id="b85e" class="pw-post-body-paragraph kg kh ir ki b kj kk js kl km kn jv ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">除了上面提到的扩展数据类型，即<em class="lc">可空整数</em>、<em class="lc">、布尔</em>、<em class="lc">、浮点</em>和<em class="lc">字符串</em> dtype、<em class="lc">熊猫</em>也带有它们对应的扩展<em class="lc">数组</em>数据类型。这些是<a class="ae lt" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.arrays.IntegerArray.html" rel="noopener ugc nofollow" target="_blank"> <em class="lc"> IntegerArray </em> </a>(自<em class="lc"> v0.24起可用，</em>更新于<em class="lc"> v1.0 </em>)，<a class="ae lt" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.arrays.StringArray.html" rel="noopener ugc nofollow" target="_blank"><em class="lc">string array</em></a>(<em class="lc">v 1.0</em>)，<a class="ae lt" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.arrays.BooleanArray.html" rel="noopener ugc nofollow" target="_blank"><em class="lc">boolean array</em></a>(<em class="lc">v 1.0</em>)，以及<em class="lc"> FloatingArray </em>()因此，当<em class="lc"> dtype </em>被指定为“boolean”时，所有<em class="lc"> BooleanDtype </em>数据都存储在一个<em class="lc"> BooleanArray </em>中。类似地，当要推断的<em class="lc"> dtype </em>被指定为“Int64”时，它将所有的<em class="lc"> Integer64Dtype </em>数据存储在一个<em class="lc"> IntegerArray </em>中。</p><p id="7ba3" class="pw-post-body-paragraph kg kh ir ki b kj kk js kl km kn jv ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">仔细观察，使用扩展数据类型作为其推断的<em class="lc"> dtype </em>构造的dataframe实际上使用相应的扩展数组数据类型来存储(系列)数据。实际上，这些扩展数组数据类型由两个NumPy数组表示，见图1。第一个用于存储数据，而第二个用作<em class="lc">全局布尔掩码</em>，指示第一个数组中缺失的值(布尔值<em class="lc">真</em>表示缺失)。但是，请注意，<em class="lc"> StringArray </em>只存储<em class="lc">string type</em>对象，没有第二个NumPy数组用作布尔掩码。另一方面，请注意，当扩展数组数据类型不用于构建数据帧时，默认情况下，所有带有缺失值的类似数组的数据都使用默认NumPy <em class="lc"> float </em> -或<em class="lc"> object </em> -dtype NumPy数组进行存储。这些数组使用<em class="lc"> NaN </em>或<em class="lc"> None </em>来表示缺失的值。因此，下面我们列出了<em class="lc">熊猫</em>中所有缺失的价值观惯例，</p><figure class="le lf lg lh gu li gi gj paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="gi gj lx"><img src="../Images/ff47f1604855df752190bc0b0b5b2718.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aH4ZLVLW9J2HLSYWmlfoaw.png"/></div></div><p class="lp lq gk gi gj lr ls bd b be z dk translated">表1:熊猫缺失的价值观。请注意，可空和字符串dtype是一种扩展数据类型。字符串通常存储在object-dtype NumPy数组中，这里读<a class="ae lt" href="https://stackoverflow.com/questions/21018654/strings-in-a-dataframe-but-dtype-is-object" rel="noopener ugc nofollow" target="_blank"/>。然而，随着string dtype的引入，它们现在可以存储在StringArray中，参见这里的<a class="ae lt" href="https://pandas.pydata.org/pandas-docs/stable/user_guide/text.html#" rel="noopener ugc nofollow" target="_blank"/>。图片由作者提供，使用<a class="ae lt" href="https://apps.diagrams.net" rel="noopener ugc nofollow" target="_blank">图</a>制作。</p></figure><p id="dfc2" class="pw-post-body-paragraph kg kh ir ki b kj kk js kl km kn jv ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">这就是我们的结局。希望上面的讨论和插图系统地展示了<em class="lc">熊猫</em>中常规的和实验性的缺失值表示。虽然新的<em class="lc">熊猫。NA </em>标量值被标记为实验性的，最近发布的特性和增强确实显示了库的驱动力和制造<em class="lc">熊猫的意图。NA </em>通用缺失值指示器。谢谢，继续和熊猫们玩得开心😃 🙏</p></div><div class="ab cl ly lz hv ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ik il im in io"><h2 id="4043" class="mf mg ir bd mh mi mj dn mk ml mm dp mn kp mo mp mq kt mr ms mt kx mu mv mw mx bi translated">构建数据帧的另一种方式</h2><p id="c182" class="pw-post-body-paragraph kg kh ir ki b kj my js kl km mz jv ko kp na kr ks kt nb kv kw kx nc kz la lb ik bi translated">我们也可以使用传统的<em class="lc"> pandas.arrays() </em>来构建数据帧，而不是使用缺失值的数据列表和指定的特定(扩展)数据类型来进行推断。从<strong class="ki is"> v1.0 </strong>，<a class="ae lt" href="https://pandas.pydata.org/docs/reference/api/pandas.array.html" rel="noopener ugc nofollow" target="_blank"><em class="lc">pandas . arrays()</em></a>开始，默认情况下，为整数、布尔值、字符串、浮点数等类似数组的输入推断扩展dtype，参见<a class="ae lt" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.array.html" rel="noopener ugc nofollow" target="_blank">这里的</a>。</p><h2 id="c01d" class="mf mg ir bd mh mi mj dn mk ml mm dp mn kp mo mp mq kt mr ms mt kx mu mv mw mx bi translated">进一步阅读</h2><ul class=""><li id="9533" class="nd ne ir ki b kj my km mz kp nf kt ng kx nh lb ni nj nk nl bi translated"><a class="ae lt" href="https://pandas.pydata.org/docs/user_guide/gotchas.html#nan-integer-na-values-and-na-type-promotions" rel="noopener ugc nofollow" target="_blank">熊猫价值观缺失背后的原因</a></li><li id="76f9" class="nd ne ir ki b kj nm km nn kp no kt np kx nq lb ni nj nk nl bi translated"><a class="ae lt" href="https://pandas.pydata.org/docs/user_guide/missing_data.html" rel="noopener ugc nofollow" target="_blank">处理缺失数据</a></li><li id="81c7" class="nd ne ir ki b kj nm km nn kp no kt np kx nq lb ni nj nk nl bi translated"><a class="ae lt" href="https://pandas.pydata.org/pandas-docs/stable/user_guide/text.html#" rel="noopener ugc nofollow" target="_blank">处理文本数据</a></li></ul></div></div>    
</body>
</html>