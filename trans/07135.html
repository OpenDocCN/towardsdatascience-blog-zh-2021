<html>
<head>
<title>How to troubleshoot memory problems in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何解决Python中的内存问题</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-troubleshoot-memory-problems-in-python-93ea0f62296d?source=collection_archive---------27-----------------------#2021-06-28">https://towardsdatascience.com/how-to-troubleshoot-memory-problems-in-python-93ea0f62296d?source=collection_archive---------27-----------------------#2021-06-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="9342" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/notes-from-industry" rel="noopener" target="_blank">行业笔记</a></h2><div class=""/><div class=""><h2 id="b85a" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">一个在生产环境中使用开源工具修复泄漏程序的真实例子。</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/a5d6082207dfca67894ad0fe43eadeca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*BW7yZrPwTaFXfOA4"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">致谢:<a class="ae lh" href="https://unsplash.com/@harrisonbroadbent" rel="noopener ugc nofollow" target="_blank">哈里森·布罗德本特</a>在<a class="ae lh" href="https://unsplash.com/photos/ING1Uf1Fc30" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></p></figure><p id="2035" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">发现应用程序内存不足是开发人员可能遇到的最糟糕的情况之一。一般来说，内存问题很难诊断和修复，但我认为在Python中更难。Python的自动垃圾收集功能使得使用这种语言变得很容易，但是它太擅长于置身事外了，以至于当它不像预期的那样工作时，开发人员会不知如何识别和修复问题。</p><p id="5713" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在这篇文章中，我将展示我们如何诊断和修复由Alteryx创新实验室开发的开源AutoML库<a class="ae lh" href="https://github.com/alteryx/evalml" rel="noopener ugc nofollow" target="_blank"> EvalML </a>中的内存问题。没有解决内存问题的神奇秘方，但是我希望开发人员，尤其是Python开发人员，能够了解在将来遇到这类问题时可以利用的工具和最佳实践。</p><p id="192a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">读完这篇博文后，你应该会有如下收获:</p><ol class=""><li id="4194" class="me mf it lk b ll lm lo lp lr mg lv mh lz mi md mj mk ml mm bi translated">为什么发现并修复程序中的内存问题很重要，</li><li id="19e1" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md mj mk ml mm bi translated">什么是循环引用，为什么它们会导致Python中的内存泄漏，以及</li><li id="f5cb" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md mj mk ml mm bi translated">Python内存分析工具的知识，以及您可以用来识别内存问题原因的一些步骤。</li></ol><h1 id="8f87" class="ms mt it bd mu mv mw mx my mz na nb nc ki nd kj ne kl nf km ng ko nh kp ni nj bi translated"><strong class="ak">设置舞台</strong></h1><p id="0570" class="pw-post-body-paragraph li lj it lk b ll nk kd ln lo nl kg lq lr nm lt lu lv nn lx ly lz no mb mc md im bi translated">在发布新版本的包之前，EvalML团队运行了一套性能测试，以捕捉任何性能退化。这些性能测试包括在各种数据集上运行我们的AutoML算法，测量我们的算法获得的分数以及运行时间，并将这些指标与我们之前发布的版本进行比较。</p><p id="587b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">一天，我正在运行测试，突然应用程序崩溃了。发生了什么事？</p><h1 id="f5fc" class="ms mt it bd mu mv mw mx my mz na nb nc ki nd kj ne kl nf km ng ko nh kp ni nj bi translated"><strong class="ak">步骤0 —什么是内存，什么是泄漏？</strong></h1><p id="ef9b" class="pw-post-body-paragraph li lj it lk b ll nk kd ln lo nl kg lq lr nm lt lu lv nn lx ly lz no mb mc md im bi translated">任何编程语言最重要的功能之一是它在计算机内存中存储信息的能力。每次你的程序创建一个新的变量，它会分配一些内存来存储变量的内容。</p><p id="33d8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">内核为程序定义了一个接口来访问计算机的CPU、内存、磁盘存储等等。每种编程语言都提供了要求内核分配和释放内存块的方法，以供正在运行的程序使用。</p><p id="8292" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">当一个程序要求内核留出一块内存来使用时，就会发生内存泄漏，但由于一个错误或崩溃，程序永远不会告诉内核它何时用完了那块内存。在这种情况下，内核将继续认为正在运行的程序仍在使用被遗忘的内存块，其他程序将无法访问这些内存块。</p><p id="55c7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果在运行程序时重复出现相同的泄漏，被遗忘内存的总大小会变得很大，以至于它会消耗计算机内存的很大一部分！在这种情况下，如果一个程序试图请求更多的内存，内核将引发“内存不足”错误，程序将停止运行，或者换句话说，“崩溃”</p><p id="0d46" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">因此，在您编写的程序中找到并修复内存泄漏是非常重要的，因为如果您不这样做，您的程序最终可能会耗尽内存并崩溃，或者会导致其他程序崩溃。</p><h1 id="9653" class="ms mt it bd mu mv mw mx my mz na nb nc ki nd kj ne kl nf km ng ko nh kp ni nj bi translated"><strong class="ak">步骤1:确定是内存问题</strong></h1><p id="9483" class="pw-post-body-paragraph li lj it lk b ll nk kd ln lo nl kg lq lr nm lt lu lv nn lx ly lz no mb mc md im bi translated">应用程序崩溃的原因有很多——可能是运行代码的服务器崩溃了，也可能是代码本身有逻辑错误——所以确定眼前的问题是内存问题非常重要。</p><p id="2514" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">EvalML性能测试以一种异常安静的方式崩溃了。突然，服务器停止记录进度，作业悄悄地完成了。服务器日志会显示由编码错误引起的任何堆栈跟踪，所以我有预感这个无声的崩溃是由使用所有可用内存的作业引起的。</p><p id="6adf" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我再次运行了性能测试，但是这次启用了Python的<a class="ae lh" href="https://pypi.org/project/memory-profiler/" rel="noopener ugc nofollow" target="_blank">内存分析器</a>来获得一段时间内的内存使用情况。测试再次崩溃，当我查看内存图时，我看到了这个:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi np"><img src="../Images/f9aa3b93d92263ec3d1977a5794d6592.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dlwfT5iFK86jfzfebrXQmg.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">EvalML性能测试的内存配置文件。作者创建的图像。</p></figure><p id="fe71" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">随着时间的推移，我们的内存使用量保持稳定，但后来达到了8gb！我知道我们的应用服务器有8g的RAM，所以这个配置文件证实了我们的内存不足。此外，当内存稳定时，我们使用大约4 GB的内存，但我们以前版本的EvalML使用大约2 GB的内存。因此，出于某种原因，当前版本使用的内存是正常情况下的两倍。</p><p id="a113" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在我需要找出原因。</p><h1 id="e0a4" class="ms mt it bd mu mv mw mx my mz na nb nc ki nd kj ne kl nf km ng ko nh kp ni nj bi translated"><strong class="ak">第二步:用一个最小的例子在本地重现内存问题</strong></h1><p id="4b7f" class="pw-post-body-paragraph li lj it lk b ll nk kd ln lo nl kg lq lr nm lt lu lv nn lx ly lz no mb mc md im bi translated">查明内存问题的原因需要大量的实验和反复，因为答案通常不是显而易见的。如果是，你可能就不会把它写进代码了！出于这个原因，我认为用尽可能少的代码行重现问题是很重要的。这个最小的例子使您可以在修改代码时，在一个分析器下快速运行它，以查看您是否取得了进展。</p><p id="8394" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在我的例子中，我从经验中得知，我们的应用程序在我看到峰值的时候运行了一个有150万行的出租车数据集。我把我们的应用程序精简到只有运行这个数据集的<a class="ae lh" href="https://gist.github.com/freddyaboulton/66159137063d01f3ee9cfb84b0ac2aaa" rel="noopener ugc nofollow" target="_blank">部分</a>。我看到了一个类似于我上面描述的尖峰，但这一次，内存使用量达到了10gb！</p><p id="8683" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">看到这个之后，我知道有一个足够好的最小的例子来深入研究。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nq"><img src="../Images/34d7459595ee3b296b7f56548b6e52d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S_9cq7dg1WRmnb6ULdgIMQ.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">出租车数据集中本地再现器的内存占用。作者创建的图像。</p></figure><h1 id="df6d" class="ms mt it bd mu mv mw mx my mz na nb nc ki nd kj ne kl nf km ng ko nh kp ni nj bi translated"><strong class="ak">第三步:找到分配最多内存的代码行</strong></h1><p id="d4d5" class="pw-post-body-paragraph li lj it lk b ll nk kd ln lo nl kg lq lr nm lt lu lv nn lx ly lz no mb mc md im bi translated">一旦我们将问题隔离到尽可能小的代码块中，我们就可以看到程序在哪里分配了最多的内存。这可能是你需要重构代码和修复问题的确凿证据。</p><p id="c2e1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我认为<a class="ae lh" href="https://pypi.org/project/filprofiler/" rel="noopener ugc nofollow" target="_blank"> filprofiler </a>是一个很好的Python工具。它显示应用程序中每行代码在内存使用峰值点的内存分配。这是我的本地示例的输出:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nr"><img src="../Images/8ba1e44a8d4a257b0f75e5241f1b8c2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MSQsKkgBa0P2x-h0Y5ZswA.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">fil-profile输出。作者创建的图像。</p></figure><p id="a08f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">filprofiler根据内存分配对应用程序中的代码行(以及依赖项的代码)进行排序。线越长越红，分配的内存就越多。</p><p id="1797" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">分配最多内存的行正在创建pandas数据帧(pandas/core/algorithms.py和pandas/core/internal/managers . py ),数据量达到4gb！我在这里截断了filprofiler的输出，但是它能够在创建pandas数据帧的EvalML中跟踪pandas代码。</p><p id="9435" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">看到这个有点令人费解。是的，EvalML创建了pandas数据帧，但是这些数据帧在整个AutoML算法中是短暂的，一旦不再使用就应该被释放。因为事实并非如此，而且这些数据帧仍然在内存中存在足够长的时间，所以我认为最新版本引入了<a class="ae lh" href="https://en.wikipedia.org/wiki/Memory_leak" rel="noopener ugc nofollow" target="_blank">内存泄漏</a>。</p><h1 id="5f87" class="ms mt it bd mu mv mw mx my mz na nb nc ki nd kj ne kl nf km ng ko nh kp ni nj bi translated"><strong class="ak">步骤4:识别泄漏物体</strong></h1><p id="9b6e" class="pw-post-body-paragraph li lj it lk b ll nk kd ln lo nl kg lq lr nm lt lu lv nn lx ly lz no mb mc md im bi translated">在Python的上下文中，泄漏对象是指在使用完之后不会被Python的垃圾收集器释放的对象。由于Python使用<a class="ae lh" href="https://en.wikipedia.org/wiki/Reference_counting" rel="noopener ugc nofollow" target="_blank">引用计数</a>作为其主要的垃圾收集算法之一，这些泄漏的对象通常是由于对象持有对它们的引用的时间超过了它们应该持有的时间。</p><p id="d2d4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这些类型的对象很难找到，但是有一些Python工具可以让搜索变得容易处理。第一个工具是<a class="ae lh" href="https://docs.python.org/3/library/gc.html#gc.DEBUG_SAVEALL" rel="noopener ugc nofollow" target="_blank"> gc。垃圾收集器的DEBUG_SAVEALL </a>标志。通过设置这个标志，垃圾收集器将在gc.garbage列表中存储不可到达的对象。这将让您进一步研究这些对象。</p><p id="3f4e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">第二个工具是<a class="ae lh" href="https://pypi.org/project/objgraph/" rel="noopener ugc nofollow" target="_blank"> objgraph </a>库。一旦对象出现在gc.garbage列表中，我们就可以将这个列表过滤为pandas数据帧，并使用objgraph查看还有哪些对象正在引用这些数据帧并将它们保存在内存中。通过阅读这篇奥赖利<a class="ae lh" href="https://www.oreilly.com/library/view/python-cookbook/0596001673/ch14s10.html" rel="noopener ugc nofollow" target="_blank">的博客文章</a>，我得到了这个方法的灵感。</p><p id="c74e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这是我在可视化其中一个数据帧时看到的对象图的子集:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ns"><img src="../Images/84ca6219c968a2d3679d5d0e96d0df91.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nNe4-2YejPm_lAZTAAYYIg.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">pandas数据帧使用的内存图，显示了导致内存泄漏的循环引用。作者创建的图像。</p></figure><p id="327b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这就是我一直在寻找的确凿证据！dataframe通过一个叫PandasTableAccessor的东西对自己进行引用，这就创建了一个<a class="ae lh" href="https://en.wikipedia.org/wiki/Circular_reference" rel="noopener ugc nofollow" target="_blank">循环引用</a>，所以这将把对象保存在内存中，直到Python的垃圾收集器运行并能够释放它。(可以通过dict、PandasTableAccessor、dict、_dataframe来追踪循环。)这对EvalML来说是个问题，因为垃圾收集器将这些数据帧保存在内存中的时间太长了，以至于我们耗尽了内存！</p><p id="24b7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我能够追踪PandasTableAccessor到<a class="ae lh" href="https://woodwork.alteryx.com/en/stable/" rel="noopener ugc nofollow" target="_blank">木工</a>库，并把这个<a class="ae lh" href="https://github.com/alteryx/woodwork/issues/880" rel="noopener ugc nofollow" target="_blank">问题</a>提交给维护人员。他们能够在新版本中修复它，并向pandas知识库提交相关的<a class="ae lh" href="https://github.com/pandas-dev/pandas/issues/41357" rel="noopener ugc nofollow" target="_blank">问题</a>——这是开源生态系统中可能的合作的一个很好的例子。</p><p id="9c7d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">木工更新发布后，我可视化了同一个数据帧的对象图，循环消失了！</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/578f2caf12c274f0554c0e26b266f395.png" data-original-src="https://miro.medium.com/v2/resize:fit:1376/format:webp/1*cSLbDMRcV1ICTQQohVYjsw.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">木制品升级后的熊猫数据框对象图。不再有周期！作者创建的图像。</p></figure><h1 id="330d" class="ms mt it bd mu mv mw mx my mz na nb nc ki nd kj ne kl nf km ng ko nh kp ni nj bi translated">步骤5 —验证修复是否有效</h1><p id="3831" class="pw-post-body-paragraph li lj it lk b ll nk kd ln lo nl kg lq lr nm lt lu lv nn lx ly lz no mb mc md im bi translated">当我在EvalML中升级了木制品版本后，我测量了我们的应用程序的内存占用，我很高兴地报告说，现在的内存使用不到以前的一半！</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nu"><img src="../Images/21afa7238b352d6669bc038f42e4f670.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UJ7c-2no3GPRVcAb9dzFYQ.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">修复后性能测试的记忆。作者创建的图像。</p></figure><h1 id="5c74" class="ms mt it bd mu mv mw mx my mz na nb nc ki nd kj ne kl nf km ng ko nh kp ni nj bi translated"><strong class="ak">结束语</strong></h1><p id="f8a5" class="pw-post-body-paragraph li lj it lk b ll nk kd ln lo nl kg lq lr nm lt lu lv nn lx ly lz no mb mc md im bi translated">正如我在本文开头所说的，没有解决内存问题的神奇方法，但是这个案例研究提供了一个通用的框架和一套工具，如果您将来遇到这种情况，您可以利用这些工具。我发现memory-profiler和filprofiler是调试Python中内存泄漏的有用工具。</p><p id="77c3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我还想强调的是，Python中的循环引用会增加应用程序的内存占用。垃圾收集器最终会释放内存，但是，正如我们在本例中所看到的，也许直到为时已晚！</p><p id="c253" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在Python中，循环引用非常容易被无意引入。我能够在EvalML中找到一个<a class="ae lh" href="https://github.com/alteryx/evalml/issues/2226" rel="noopener ugc nofollow" target="_blank">无意的一个</a>、<a class="ae lh" href="https://github.com/scikit-optimize/scikit-optimize/issues/1028" rel="noopener ugc nofollow" target="_blank"> scikit-optimize </a>和<a class="ae lh" href="https://github.com/scipy/scipy/issues/13986" rel="noopener ugc nofollow" target="_blank"> scipy </a>。我鼓励你擦亮你的眼睛，如果你在野外看到一个循环引用，开始一个对话，看看它是否真的需要！</p><p id="3f6c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><em class="nv">原贴于Alteryx创新实验室</em> <a class="ae lh" href="https://innovation.alteryx.com/how-to-troubleshoot-memory-problems-in-python/" rel="noopener ugc nofollow" target="_blank"> <em class="nv">博客</em> </a></p></div></div>    
</body>
</html>