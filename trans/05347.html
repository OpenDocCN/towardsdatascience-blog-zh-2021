<html>
<head>
<title>Quick Guide to Graph Traversal Analysis</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">图形遍历分析快速指南</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/quick-guide-to-graph-traversal-analysis-1d510a5d05b5?source=collection_archive---------26-----------------------#2021-05-11">https://towardsdatascience.com/quick-guide-to-graph-traversal-analysis-1d510a5d05b5?source=collection_archive---------26-----------------------#2021-05-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9746" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">分析图表来寻找最佳路径并不困难</h2></div><p id="525f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">图是由一组对象(<em class="le">节点</em>)组成的数据结构，这些对象之间有连接(<em class="le">边</em>)。如果连接从一个节点定向到另一个节点(例如<em class="le">爱丽丝欠鲍勃的钱)，则图可以是<strong class="kk iu">定向的</strong>，或者如果定向不相关并且连接仅表示关系(例如<em class="le">爱丽丝和鲍勃是朋友)，则图可以是<strong class="kk iu">无向的</strong>。如果一个图的所有节点都互相连接，那么这个图就是完整的。没有回路的有向图被称为<em class="le">无回路。</em>树<em class="le">是无向图，其中任意两个节点通过<em class="le">恰好一条</em>边连接。树中的初始节点称为<em class="le">根</em>，末端节点(<em class="le">即没有下游连接节点的</em>节点)称为<em class="le">叶</em>。</em></em></em></p><p id="bc42" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">图表的几个实际例子是<a class="ae lf" href="https://www.databentobox.com/2019/07/28/facebook-friend-graph/" rel="noopener ugc nofollow" target="_blank">友谊网络</a>(社交媒体上的<em class="le">例如</em>)<a class="ae lf" href="https://www.lucidchart.com/blog/how-to-make-a-family-tree-chart" rel="noopener ugc nofollow" target="_blank">家谱(家族)树</a>，<a class="ae lf" href="https://en.wikipedia.org/wiki/Molecular_graph" rel="noopener ugc nofollow" target="_blank">分子</a>，<a class="ae lf" href="https://en.wikipedia.org/wiki/Feynman_diagram" rel="noopener ugc nofollow" target="_blank">大型强子对撞机</a>产生的粒子，一张<a class="ae lf" href="https://en.wikipedia.org/wiki/Organizational_chart" rel="noopener ugc nofollow" target="_blank">公司的组织图</a>。你能说出它们属于哪一类图形吗？</p><h2 id="845f" class="lg lh it bd li lj lk dn ll lm ln dp lo kr lp lq lr kv ls lt lu kz lv lw lx ly bi translated">主要的图遍历算法</h2><p id="362e" class="pw-post-body-paragraph ki kj it kk b kl lz ju kn ko ma jx kq kr mb kt ku kv mc kx ky kz md lb lc ld im bi translated">遍历一个图意味着通过根据一些系统规则访问节点来探索它的结构。最有效的规则取决于图表的类型和手头的问题，所以不可能做出真正通用的陈述。由于计算机科学中的许多数据结构都有一个基础图，即树，所以值得花些精力来更好地理解探索这种图的策略，以便找到满足手头问题条件的路径或节点。</p><p id="5435" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在许多情况下，问题可以归结为一种陈述，例如“找到节点<em class="le"> A </em>和<em class="le"> B </em>之间的路径，使得某个量被优化”。该数量可以是例如边的数量(<em class="le">即</em>路径的长度)，或者与每个节点相关联的某个特征(可能是二进制的)的总和。</p><p id="66ce" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">两种主要的方法叫做<strong class="kk iu">深度优先搜索</strong> (DFS)和<strong class="kk iu">广度优先搜索</strong> (BFS)。</p><ul class=""><li id="2647" class="me mf it kk b kl km ko kp kr mg kv mh kz mi ld mj mk ml mm bi translated"><strong class="kk iu">在BFS方法</strong>中，相同深度级别的节点被顺序探测，直到满足停止条件。它利用一个<em class="le">队列</em>通过<em class="le">迭代</em>方法找到最短路径。BFS通常会占用大量内存，因为需要维护一个额外的数据结构，其中包含有待探索的节点，通常以“已经访问过的”布尔变量的形式存在。当树的深度不平衡或者如果搜索节点离根不太远(“浅树”)时，BFS通常是最佳方法。一个典型的例子是<em class="le">社交网络</em>，在这里我们想要搜索与某个特定的人有相似兴趣的人。目标节点很有可能是直接的朋友或朋友的朋友，<em class="le">即</em>根节点可以有许多分支，但目标节点之间只有几条边。</li><li id="682b" class="me mf it kk b kl mn ko mo kr mp kv mq kz mr ld mj mk ml mm bi translated"><strong class="kk iu">DFS算法</strong>通过从根到叶子来探索图形，并重复该操作，直到满足条件。它利用一个<em class="le">堆栈</em>来寻找最短路径。如果一个给定的分支没有满足请求，算法“回溯”到更高的级别，然后沿着另一条路径前进。如果使用<em class="le">递归</em>方法，则需要更少的内存，因为不必跟踪已经“访问”过的节点。在树代表一系列决策和/或目标叶远离根的情况下，DFS通常是一种有效的方法。一个典型的用例例子是游戏的<em class="le">模拟，比如国际象棋，在每次迭代中，可能性很少，但每个决策在下一步中都走得很远。</em></li></ul><h2 id="62c6" class="lg lh it bd li lj lk dn ll lm ln dp lo kr lp lq lr kv ls lt lu kz lv lw lx ly bi translated">代码示例</h2><p id="7333" class="pw-post-body-paragraph ki kj it kk b kl lz ju kn ko ma jx kq kr mb kt ku kv mc kx ky kz md lb lc ld im bi translated">几行代码通常比大量文本更具说明性。在下文中，我们将探索一个由6个节点和5条边组成的简单图形。</p><figure class="mt mu mv mw gt mx gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/016fc3bf7c9422737f208a41c285be7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:722/format:webp/1*H56fpFFiTRtPfgOaBaUTfg.png"/></div><p class="na nb gj gh gi nc nd bd b be z dk translated">以下示例中使用的图表结构</p></figure><p id="256a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">深度优先搜索</strong></p><figure class="mt mu mv mw gt mx"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="1aa5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">预期产出:</p><pre class="mt mu mv mw gt ng nh ni nj aw nk bi"><span id="8b97" class="lg lh it nh b gy nl nm l nn no">A<br/>A -&gt; B<br/>B -&gt; D<br/>B -&gt; E<br/>A -&gt; C<br/>C -&gt; F</span></pre><p id="b8e6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">广度优先搜索</strong></p><figure class="mt mu mv mw gt mx"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="0859" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">预期产出:</p><pre class="mt mu mv mw gt ng nh ni nj aw nk bi"><span id="33a8" class="lg lh it nh b gy nl nm l nn no">A B C D E F</span></pre></div><div class="ab cl np nq hx nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="im in io ip iq"><h2 id="e000" class="lg lh it bd li lj lk dn ll lm ln dp lo kr lp lq lr kv ls lt lu kz lv lw lx ly bi translated">经验法则</h2><ol class=""><li id="0d9f" class="me mf it kk b kl lz ko ma kr nw kv nx kz ny ld nz mk ml mm bi translated">简单图上的最短路径-&gt; BFS</li><li id="858f" class="me mf it kk b kl mn ko mo kr mp kv mq kz mr ld nz mk ml mm bi translated">低宽度，大深度-&gt; BFS</li><li id="d654" class="me mf it kk b kl mn ko mo kr mp kv mq kz mr ld nz mk ml mm bi translated">大宽度、低深度-&gt; DFS(递归堆栈不会溢出)</li><li id="bad1" class="me mf it kk b kl mn ko mo kr mp kv mq kz mr ld nz mk ml mm bi translated">扫描所有可能的结果-&gt; DFS</li></ol></div></div>    
</body>
</html>