<html>
<head>
<title>Export Datastores from multiple projects to BigQuery</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将多个项目中的数据存储导出到BigQuery</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/export-datastores-from-multiple-projects-to-bigquery-3da9c92a4b8f?source=collection_archive---------20-----------------------#2021-06-19">https://towardsdatascience.com/export-datastores-from-multiple-projects-to-bigquery-3da9c92a4b8f?source=collection_archive---------20-----------------------#2021-06-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/7a88f0d783ac2b6f9182e814d054ec07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ie7aS6fZ7QOX19th"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">Nieuwpoort(作者)</p></figure><div class=""/><div class=""><h2 id="8762" class="pw-subtitle-paragraph kc je jf bd b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt dk translated">如何使用Google Dataflow从多个项目中导出数据存储——对实体进行额外过滤。</h2></div><p id="4144" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">这是对我之前的<a class="ae lq" rel="noopener" target="_blank" href="/export-datastore-to-bigquery-using-google-dataflow-1801c25ae482">故事</a>的一个简短扩展，在那里我描述了如何将数据从Datastore增量导出到BigQuery。在这里，我将讨论如何将前面的解决方案扩展到在多个项目中拥有数据存储的情况。目标保持不变，我们希望在BigQuery中获得数据。</p><div class="ip iq gp gr ir lr"><a rel="noopener follow" target="_blank" href="/export-datastore-to-bigquery-using-google-dataflow-1801c25ae482"><div class="ls ab fo"><div class="lt ab lu cl cj lv"><h2 class="bd jg gy z fp lw fr fs lx fu fw je bi translated">使用Google数据流将数据存储导出到BigQuery</h2><div class="ly l"><h3 class="bd b gy z fp lw fr fs lx fu fw dk translated">如何使用Google Dataflow将数据存储导出到BigQuery，并对实体进行额外过滤。</h3></div><div class="lz l"><p class="bd b dl z fp lw fr fs lx fu fw dk translated">towardsdatascience.com</p></div></div><div class="ma l"><div class="mb l mc md me ma mf ix lr"/></div></div></a></div><p id="e72c" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">总的来说，这个问题可以用下图来表示</p><figure class="mh mi mj mk gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mg"><img src="../Images/c916f673c9cf0bbc21529e94c4c442d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zrZ_xTK3didXwrG-LvqKkA.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">建筑草图(作者)</p></figure><p id="1d78" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">数据流过程可以存在于一个源项目中，也可以放在一个单独的项目中——我将把数据流过程放在一个单独的项目中。结果可以存储在BigQuery中，该big query可以位于与数据流流程相同的项目中，也可以位于另一个项目中。</p><h1 id="bef4" class="ml mm jf bd mn mo mp mq mr ms mt mu mv kl mw km mx ko my kp mz kr na ks nb nc bi translated">一般化</h1><p id="ccc6" class="pw-post-body-paragraph ku kv jf kw b kx nd kg kz la ne kj lc ld nf lf lg lh ng lj lk ll nh ln lo lp ij bi translated">让我们从概括开始。首先，我用两个新字段扩展了配置文件:<code class="fe ni nj nk nl b">SourceProjectIDs</code>它只不过是源GCP项目的列表，而<code class="fe ni nj nk nl b">Destination</code>定义了输出BigQuery数据集的位置。</p><pre class="mh mi mj mk gt nm nl nn no aw np bi"><span id="d471" class="nq mm jf nl b gy nr ns l nt nu">SourceProjectIDs:<br/>  - project-a<br/>  - project-b<br/>  - project-c<br/>Destination:<br/>  ProjectID: dataflow-streaming<br/>  Dataset: datastore_dev</span></pre><p id="788d" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">扩展数据流管道定义如下:</p><pre class="mh mi mj mk gt nm nl nn no aw np bi"><span id="c7ab" class="nq mm jf nl b gy nr ns l nt nu">rows = (<br/>    p<br/>    | <strong class="nl jg">'projects' </strong>&gt;&gt; beam.Create(project_ids)<br/>    | <strong class="nl jg">'get all kinds' </strong>&gt;&gt; beam.ParDo(GetAllKinds(prefix_of_kinds_to_ignore))<br/>    | <strong class="nl jg">'create queries' </strong>&gt;&gt; beam.ParDo(CreateQuery(entity_filtering))<br/>    | <strong class="nl jg">'read from datastore' </strong>&gt;&gt; beam.ParDo(ReadFromDatastore._QueryFn())<br/>    | <strong class="nl jg">'convert entities' </strong>&gt;&gt; beam.Map(entity_to_json)<br/>)</span></pre><p id="ad34" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">它被扩展了一个额外的步骤<code class="fe ni nj nk nl b">projects</code>，这个步骤产生了带有一个源项目列表的<code class="fe ni nj nk nl b">PCollection</code>(来自配置文件)。需要对<code class="fe ni nj nk nl b">get all kinds</code>步骤做一点小小的改动。<code class="fe ni nj nk nl b">GetAllKinds</code>被改为PTransform步骤，为每个项目创建一个元组列表<code class="fe ni nj nk nl b">(project_id, kind_name)</code>。</p><p id="ff7b" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">DoFn的<code class="fe ni nj nk nl b">process</code>方法接受元组作为任何其他可序列化的对象。至此，下一步<code class="fe ni nj nk nl b">create queries</code>创建查询，从特定的<code class="fe ni nj nk nl b">kind_name</code>获取记录，这些记录保存在<code class="fe ni nj nk nl b">project_id</code>的数据存储中。</p><pre class="mh mi mj mk gt nm nl nn no aw np bi"><span id="abee" class="nq mm jf nl b gy nr ns l nt nu">def process(self, project_kind_name, **kwargs):<br/>    <em class="nv">"""<br/>    :param **kwargs:<br/>    :param project_kind_name: a tuple with project_id, kind_name<br/>    :return: [Query]<br/>    """<br/><br/>    </em>project_id, kind_name = project_kind_name</span></pre><p id="7151" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">这个步骤产生的查询已经包含了<code class="fe ni nj nk nl b">project_id</code>，所以我们不再需要传递项目id。</p><p id="a4d4" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">存储在BigQuery中的JSON对象的模式在<code class="fe ni nj nk nl b">__key__</code>字段中还包含一个属性<code class="fe ni nj nk nl b">project</code>。BigQuery中输出表的名称是通过在<code class="fe ni nj nk nl b">kind_name</code>前面加上<code class="fe ni nj nk nl b">project_id</code>来构造的。</p><h1 id="4b67" class="ml mm jf bd mn mo mp mq mr ms mt mu mv kl mw km mx ko my kp mz kr na ks nb nc bi translated">都是权限的问题</h1><p id="4329" class="pw-post-body-paragraph ku kv jf kw b kx nd kg kz la ne kj lc ld nf lf lg lh ng lj lk ll nh ln lo lp ij bi translated">所提出的解决方案的线索在于权限。数据流使用两个服务帐户(SA)，一个在作业创建期间使用，另一个由工作实例用来访问资源。</p><p id="977b" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">我们对工人使用的SA感兴趣。默认情况下，当为您的项目启用计算引擎API时，会自动创建此服务帐户，并有一个标准名称<code class="fe ni nj nk nl b">&lt;project-number&gt;-compute@developer.gserviceaccount.com</code></p><p id="bdff" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">因此，让您的数据流管道访问不同项目中的数据存储。因此，在每个源项目中，将帐户<code class="fe ni nj nk nl b">&lt;project-number&gt;-compute@developer.gserviceaccount.com</code>添加到角色为<code class="fe ni nj nk nl b">role/datastore.viewer</code>的项目中。</p><figure class="mh mi mj mk gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nw"><img src="../Images/dd35fd09b2430a38194565eb792035c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IeQbcncufsJTI_jbpN8aKQ.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">源项目之一中的IAM权限(按作者)</p></figure><p id="7b67" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">仅此而已——管道按预期工作:</p><figure class="mh mi mj mk gt is gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/82a43142328d38316833fed9172a00af.png" data-original-src="https://miro.medium.com/v2/resize:fit:878/format:webp/1*oSU2TNWj-okzfKsY5Rw7rg.png"/></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">具有项目步骤的扩展管道(作者)</p></figure></div><div class="ab cl ny nz hu oa" role="separator"><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od"/></div><div class="ij ik il im in"><p id="2375" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">数据流是自动化ETL过程的强大工具。正如你所看到的，它可以很容易地推广到与不需要与数据流过程存在于同一个项目中的源一起工作。</p></div><div class="ab cl ny nz hu oa" role="separator"><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od"/></div><div class="ij ik il im in"><p id="2d43" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">这个故事的灵感来自于安德鲁·弗莱舍提出的问题——谢谢！</p><p id="5012" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">我希望你喜欢这个故事，它会对你的日常工作有所帮助。如果您有任何问题或建议，请随时通过<a class="ae lq" href="https://twitter.com/MrTheodor" rel="noopener ugc nofollow" target="_blank"> Twitter </a>或<a class="ae lq" href="https://www.linkedin.com/in/jkrajniak/" rel="noopener ugc nofollow" target="_blank"> Linkedin </a>联系我。</p></div></div>    
</body>
</html>