<html>
<head>
<title>Feature selection with Random Forest</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">随机森林特征选择</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/feature-selection-with-random-forest-3e1979b3a2dc?source=collection_archive---------27-----------------------#2021-10-11">https://towardsdatascience.com/feature-selection-with-random-forest-3e1979b3a2dc?source=collection_archive---------27-----------------------#2021-10-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5cde" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">让我们看看如何使用随机森林进行特征选择</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/00b1488a634bc85500153ad99840561e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*1x6qI89TXH5UA8hV"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">史蒂文·卡梅纳在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="2e32" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">特征选择一直是机器学习中的一大难题。根据我的经验，我可以说这是数据科学项目中最重要的一部分，因为它帮助我们降低数据集的维度，去除无用的变量。幸运的是，有一些模型可以帮助我们计算特性的重要性，这有助于我们忽略不太有用的特性。随机森林就是这样一个模型。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="6d96" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">什么是随机森林？</h1><p id="ffa7" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">随机森林是一个监督模型，实现了决策树和bagging方法。其思想是根据一个称为“引导”的过程对训练数据集进行重新采样。每个样本都包含原始列的一个随机子集，用于拟合决策树。模型的数量和列的数量是要优化的超参数。</p><p id="68ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，将树的预测混合在一起，计算平均值(用于回归)或使用软投票(用于分类)。</p><p id="207b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">bagging的思想是，通过平均单个决策树的输出，根据偏差-方差权衡，标准误差减小，模型的方差也减小。这就是为什么兰登森林在最近几年变得非常有名。</p><h1 id="2087" class="mc md it bd me mf mz mh mi mj na ml mm jz nb ka mo kc nc kd mq kf nd kg ms mt bi translated">随机森林如何计算特征重要性？</h1><p id="b709" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">随机森林的每棵树可以根据其增加叶子纯度的能力来计算特征的重要性。这是一个关于分类和回归树(CART)如何工作的话题。叶子纯度的增量越高，该特征的重要性越高。对每棵树都这样做，然后在所有树中平均，最后归一化为1。因此，由随机森林计算的重要性分数之和是1。</p><h1 id="0976" class="mc md it bd me mf mz mh mi mj na ml mm jz nb ka mo kc nc kd mq kf nd kg ms mt bi translated">使用递归特征消除的特征选择</h1><p id="6609" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">一旦我们知道了每个特征的重要性，我们就使用一个叫做递归特征消除的过程来执行特征选择。在本文中，我将讨论利用k-fold交叉验证的版本。</p><p id="cae2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">想法是拟合模型，然后移除不太相关的特征，并计算CV中某些性能指标的平均值。然后，我们删除倒数第二个重要特征，再次拟合模型，并计算平均性能。我们一直这样做，直到没有特征剩下。最大化CV性能的特性集是我们必须使用的特性集。请注意，整个过程需要对超参数使用相同的值。</p><h1 id="360d" class="mc md it bd me mf mz mh mi mj na ml mm jz nb ka mo kc nc kd mq kf nd kg ms mt bi translated">Python中使用随机森林的特征选择</h1><p id="b77d" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">既然理论已经很清楚了，那我们就用sklearn在Python中应用一下吧。对于本例，我将使用波士顿数据集，这是一个回归数据集。</p><p id="0389" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们首先导入我们需要的所有对象，即我们的数据集、随机森林回归器和将使用CV执行RFE的对象。最后，matplotlib用于可视化我们的结果。</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="daf8" class="nj md it nf b gy nk nl l nm nn">import numpy as np from sklearn.datasets <br/>import load_boston from sklearn.ensemble <br/>import RandomForestRegressor from sklearn.model_selection <br/>import train_test_split from sklearn.feature_selection <br/>import RFECV import matplotlib.pyplot as plt</span></pre><p id="e7a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，让我们加载数据集。</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="85a3" class="nj md it nf b gy nk nl l nm nn">X,y = load_boston(return_X_y=True) <br/>features = load_boston()['feature_names']</span></pre><p id="0020" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们可以把它分成训练和测试。</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="6cf4" class="nj md it nf b gy nk nl l nm nn">X_train, X_test, y_train, y_test = train_test_split( X, y, test_size=0.33, random_state=42)</span></pre><p id="f0cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们可以拟合我们的随机森林回归量。在实际项目中，我们必须优化超参数的值。对于这个例子，我将使用默认值。我将只设置随机状态，以使结果可重复。</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="6aca" class="nj md it nf b gy nk nl l nm nn">rf = RandomForestRegressor(random_state=0) <br/>rf.fit(X_train,y_train)</span></pre><p id="e40e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">拟合回归变量后，特征的重要性存储在估计器实例的<em class="no"> feature_importances_ </em>属性中。</p><p id="6b4e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，让我们画一个条形图，按照从最重要到不太重要的顺序排列特性。我们必须创建一个元组列表。元组的第一个元素是特征名，第二个元素是重要性。然后，我们根据重要性值对列表进行排序，并绘制一个水平条形图。</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="2862" class="nj md it nf b gy nk nl l nm nn">f_i = list(zip(features,rf.feature_importances_)) <br/>f_i.sort(key = lambda x : x[1]) </span><span id="a0ba" class="nj md it nf b gy np nl l nm nn">plt.barh([x[0] for x in f_i],[x[1] for x in f_i]) <br/>plt.show()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/e5fd3935cabf06a2ad5546add920b5e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:804/format:webp/0*CH9kQZgOxRRINprF.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="b9bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们所看到的，LSTAT特性是最重要的，其次是RM、DIS和其他特性。水平条形图是表示特性重要性的非常有用的图表。</p><p id="6a2c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们根据交叉验证的RFE，使用特征重要性来选择最佳特征集。对于本例，我们试图优化的指标是负均方误差。我们将使用5个折叠进行交叉验证，这是一个非常好的值。</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="23c4" class="nj md it nf b gy nk nl l nm nn">rfe = RFECV(rf,cv=5,scoring="neg_mean_squared_error") <br/>rfe.fit(X_train,y_train)</span></pre><p id="a2be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">整套功能包括:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nr"><img src="../Images/d3a2d2d405e126557ad14d49351ac140.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*5hRgNuGleOLla8xj.png"/></div></div></figure><p id="b9c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所选功能包括:</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="25ff" class="nj md it nf b gy nk nl l nm nn">selected_features = np.array(features)[rfe.get_support()]</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ns"><img src="../Images/b732612a307604f6af639953a38d16ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*rRZeT4jfPMyu3edG.png"/></div></div></figure><p id="07f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们所看到的，RFE忽略了不太相关的特性(CHAS)。</p><h1 id="9076" class="mc md it bd me mf mz mh mi mj na ml mm jz nb ka mo kc nc kd mq kf nd kg ms mt bi translated">结论</h1><p id="77f4" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">随机森林对于回归和分类都是一个非常强大的模型。它还可以给出它自己对特征重要性的解释，这可以被绘制并用于根据例如递归特征消除过程来选择信息最丰富的特征集。正确使用，特性重要性可以给我们很好的和容易理解的可交付物(条形图)和有效的优化(特性选择)。这就是为什么我认为特征重要性是每个机器学习项目的必要组成部分。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="a7ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">www.yourdatateacher.com<em class="no">上</em> <a class="ae ky" href="http://www.yourdatateacher.com/" rel="noopener ugc nofollow" target="_blank"> <em class="no">教授机器学习和数据科学的数据科学家吉安卢卡·马拉托。</em></a></p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="5138" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="no">原载于2021年10月11日https://www.yourdatateacher.com</em><a class="ae ky" href="https://www.yourdatateacher.com/2021/10/11/feature-selection-with-random-forest/" rel="noopener ugc nofollow" target="_blank"><em class="no"/></a><em class="no">。</em></p></div></div>    
</body>
</html>