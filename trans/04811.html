<html>
<head>
<title>Shogun: An Underrated Python Machine-learning Package</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">幕府将军:一个被低估的Python机器学习包</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/shogun-an-underrated-python-machine-learning-package-d306ac07b0e0?source=collection_archive---------36-----------------------#2021-04-26">https://towardsdatascience.com/shogun-an-underrated-python-machine-learning-package-d306ac07b0e0?source=collection_archive---------36-----------------------#2021-04-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="23c3" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">看看Python的幕府包，以及为什么它是Python中机器学习的一个很少使用的库</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/392a81aff5f35b5cc3bea79947b7a7d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VNayE37GDwtSM31om6ZRDA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(src =<a class="ae ky" href="https://pixabay.com/images/id-1556912/" rel="noopener ugc nofollow" target="_blank">https://pixabay.com/images/id-1556912/</a></p></figure><h1 id="9b38" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">介绍</h1><p id="2823" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi mn translated"><span class="l mo mp mq bm mr ms mt mu mv di">在Python这个奇妙的世界中，有许多选项可以用来完成机器学习的任务。流行的例子通常包括使用SkLearn和Tensorflow这样的模块。SkLearn是一个有用的模块，因为它可以用来解决预建机器学习模型的许多问题，这些模型试图通过使用一致的超参数来避免黑箱问题。然而，在这方面，SkLearn肯定不是以这种方式有效解决问题的唯一解决方案。</span></p><p id="49a8" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">虽然我们经常认为这是理所当然的，但是Pythonic包生态系统绝对是巨大的。当我们想以一种新的方式处理模型，或者只是从一个不同的API处理模型时，这就很方便了。我遇到的SkLearn包的最酷的替代品之一是一个叫做幕府将军的模块。幕府将军是一个基于C++的库，使用与SkLearn相同的预构建概念。</p></div><div class="ab cl nb nc hx nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="im in io ip iq"><h1 id="67d4" class="kz la it bd lb lc ni le lf lg nj li lj jz nk ka ll kc nl kd ln kf nm kg lp lq bi translated">为什么用幕府？</h1><p id="d317" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">当然，由于幕府的用户群和维护者列表较小，使用这个包会有一些主要的缺点。文档就是一个很好的例子。没有文档，有效地使用任何用于机器学习的软件都是非常困难的，不管是不是最先进的。在幕府文档中已经投入了大量的工作，但是这将永远无法达到技术写作和组织的水平，像SkLearn这样一个得到良好支持的库已经工作了十多年了。由于缺乏文档和更大的用户群，另一个问题是缺乏支持。幕府将军类中可能会有抛出返回不等于零的东西，而没有关于为什么会发生异常的详细信息。当在SkLearn这样的包中发生这种情况时，可以很容易地搜索throw并找出您的代码到底有什么问题。另一方面，对于幕府将军来说，情况往往不是这样。</p><p id="775a" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">使用幕府将军而不是SkLearn的一个优点是，该库在语言方面更加成熟，这使得跨平台和在通常不能使用SkLearn的不同应用程序中更容易访问。Python、Javascript、C++、R、Ruby、C# mono等语言都有实现，这使得幕府将军这个包更有可能被移植到任何其他可能需要使用的语言中。另一方面，SkLearn主要是专门为Python用C编写的。当然，这意味着在大多数C衍生语言中都有通向该语言的桥梁，例如C++或C#，但它也不能与幕府将军在这方面的能力所提供的可访问性相提并论。考虑到这一点，可能需要注意的是，SkLearn主要是为Pythonic数据科学家服务的，并且可能是他们个人的最佳选择。也就是说，我仍然认为交替使用两个包和它们的代码库是有好处的。</p><h1 id="1d60" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">使用幕府将军</h1><p id="6c8a" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">为了使用幕府包，我们当然需要安装PIP。我使用的是Ubuntu，以下是我个人的安装过程。我首先需要添加幕府工具PPA:</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="f84a" class="ns la it no b gy nt nu l nv nw">sudo add-apt-repository ppa:shogun-toolbox/stable<br/>sudo apt-get update</span></pre><p id="a878" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">之后我分别装了lib幕府18，然后python-幕府。</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="d0b1" class="ns la it no b gy nt nu l nv nw">sudo apt-get install libshogun18<br/>sudo apt-get install python-shogun</span></pre><p id="00ea" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">关于机器学习对幕府的实际使用，首先要注意的是幕府是非常基于类型的，比SkLearn更是如此，例如，在SkLearn中，通常使用已经包含在其他模块(如NumPy或Pandas)中的类型。这是一个重要的区别，很可能源于幕府将军在C++中的独创性。此外，我认为这肯定有助于从如此多的不同API使用幕府将军，因为它真的不需要担心从许多不同的语言促进类型，而是更担心与自己的泛型类型工作。</p><p id="4ddd" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">对于今天的例子，我真的想展示一些我们在Python中使用的其他机器学习包并不普遍可用的东西。很可能大多数SkLearn用户都熟悉决策树和随机森林分类器的概念，它们使用gini杂质来计算模型的下一次分裂。幕府包中的一个非常酷的替代品是CHAID，或者卡方自动交互检测器，tree。CHAID树没有使用基尼指数，而是使用卡方检验来计算每一个分裂。这就是为什么我选择这个模型来进行讨论，因为它是不同的，它显示了你可以用幕府将军做很多用SkLearn做不到的事情。当然，为了开始这个项目，我们将在Python中引入科学计算的动态二重奏:</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="1acd" class="ns la it no b gy nt nu l nv nw">import pandas as pd<br/>import numpy as np</span></pre><p id="6ceb" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">我还将使用SkLearn中的train-test-split方法和Ordinal Encoder类，以便准备我的数据用于这些类型和这个模型。</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="831d" class="ns la it no b gy nt nu l nv nw">from sklearn.preprocessing import OrdinalEncoder<br/>from sklearn.model_selection import train_test_split</span></pre><p id="ebcc" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">现在是时候准备我的数据，把它放入新的幕府类型，然后把它传递到我的模型。我不打算过多地描述我用于处理数据的代码，但是您可以随意检查我做了什么:</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="b1d0" class="ns la it no b gy nt nu l nv nw">df = pd.read_csv("LatheBooks/atlcrime.csv")<br/>df.head()<br/>df = df.dropna()<br/>target = "neighborhood"<br/>feature = "feat"<br/>encoder = OrdinalEncoder()<br/>df["feat"] = encoder.fit_transform(np.array(df["npu"]).reshape(-1, 1))<br/>train, test = train_test_split(df)<br/>trainX = train[feature]<br/>trainy = train[target]<br/>testX = test[feature]<br/>testy = test[target]</span></pre><p id="0961" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">现在我们需要将这些数据放入新的特征类型中，然后我们就可以最终拟合我们的Chi树了！</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="cf21" class="ns la it no b gy nt nu l nv nw">features_train = RealFeatures(f_feats_train)<br/>features_test = RealFeatures(f_feats_test)<br/>labels_train = MulticlassLabels(f_labels_train)<br/>labels_test = MulticlassLabels(f_labels_test)</span></pre><p id="7ff4" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">接下来，我们需要设置我们的特征类型。这方面有三种选择:</p><ul class=""><li id="3580" class="nx ny it lt b lu mw lx mx ma nz me oa mi ob mm oc od oe of bi translated">0 —标称值</li><li id="7989" class="nx ny it lt b lu og lx oh ma oi me oj mi ok mm oc od oe of bi translated">1-序数</li><li id="6783" class="nx ny it lt b lu og lx oh ma oi me oj mi ok mm oc od oe of bi translated">2-连续</li></ul><p id="9153" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">如果我们要处理多个特性，我们将需要设置许多特性类型，但是因为我们只处理一个顺序编码的特性，我们可以只提供一个顺序为1的迭代列表。</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="d3b9" class="ns la it no b gy nt nu l nv nw">ft = [1]</span></pre><p id="0e0e" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">现在我们可以初始化新的CHAID树了:</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="b5b6" class="ns la it no b gy nt nu l nv nw">classifier = CHAIDTree(0, ft, 10)<br/>classifier.set_labels(labels_train)</span></pre><p id="586d" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">然后训练和预测:</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="d078" class="ns la it no b gy nt nu l nv nw">classifier.train(features_train)<br/>labels_predict = classifier.apply_multiclass(features_test)</span></pre><h1 id="9648" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">结论</h1><p id="7a10" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">幕府将军是一个非常棒的Python机器学习包。也就是说，我当然可以理解为什么与Python中的许多主流解决方案相比，它很少被使用。不管怎样，我很高兴能把这个包中的知识带回C++中，并从这个包中得到一点乐趣。值得添加到您的Python安装中吗？有一些很酷的模型，我认为很难在其他地方找到，我认为可能对某些事情有好处。许可证也是GPL3，它可能会阻止这个包在某些情况下被使用。话虽如此，我认为这是一个很酷的包检查出来！非常感谢您的阅读，我希望这篇文章影响了更多的探索！</p></div></div>    
</body>
</html>