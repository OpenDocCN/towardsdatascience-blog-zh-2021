<html>
<head>
<title>Lightning Fast Video Reading in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的闪电般快速视频阅读</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/lightning-fast-video-reading-in-python-c1438771c4e6?source=collection_archive---------3-----------------------#2021-03-28">https://towardsdatascience.com/lightning-fast-video-reading-in-python-c1438771c4e6?source=collection_archive---------3-----------------------#2021-03-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="fdc3" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">让你的视频阅读代码更快</h2><div class=""/><div class=""><h2 id="80dc" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">如果您在计算机视觉中处理视频，这些库可能会帮助您只用几行代码就使代码更高效。</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/290c763cb94155e98173359158aa940a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7CyIx_JabgWzgL_A"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">费利克斯·米特迈尔在Unsplash<a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">拍摄的照片</a></p></figure><h1 id="b737" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">用Python阅读视频的典型方式</h1><p id="82ae" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">用Python阅读视频的典型模式是使用OpenCV:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="71a2" class="pw-post-body-paragraph ma mb it mc b md my kd mf mg mz kg mi mj na ml mm mn nb mp mq mr nc mt mu mv im bi translated">这种方法有什么问题吗？它完全是功能性的，但是有一些限制:</p><ul class=""><li id="9861" class="nd ne it mc b md my mg mz mj nf mn ng mr nh mv ni nj nk nl bi translated">它没有针对速度进行优化</li><li id="c7a9" class="nd ne it mc b md nm mg nn mj no mn np mr nq mv ni nj nk nl bi translated">OpenCV不是作为媒体库设计的。这一个可能会让你吃惊(它确实让我吃惊！)但开发者最初只是出于“演示目的”增加了阅读此类视频的能力</li></ul><blockquote class="nr ns nt"><p id="a2d4" class="ma mb nu mc b md my kd mf mg mz kg mi nv na ml mm nw nb mp mq nx nc mt mu mv im bi translated">OpenCV库的主要目的与媒体I/O库的目标并不高度相关。视频I/O和图像I/O最初是为了演示的目的加入OpenCV的。来源:OpenCV项目<a class="ae lh" href="https://github.com/opencv/opencv/issues/9053#issuecomment-346439490" rel="noopener ugc nofollow" target="_blank">的<a class="ae lh" href="https://sourceforge.net/p/opencvlibrary/wiki/Home/" rel="noopener ugc nofollow" target="_blank">管理员</a>亚历山大·阿莱克辛</a></p></blockquote><p id="3045" class="pw-post-body-paragraph ma mb it mc b md my kd mf mg mz kg mi mj na ml mm mn nb mp mq mr nc mt mu mv im bi translated">由于不是为视频操作而设计的，它不具备，也许永远也不会具备精确查找精确帧的能力(即，如果您认为<code class="fe ny nz oa ob b">cap.set()</code>方法可以安全地用于设置帧数，请注意<em class="nu">不能</em>，请参见此<a class="ae lh" href="https://github.com/opencv/opencv/issues/9053#" rel="noopener ugc nofollow" target="_blank">公开错误通知</a>)。</p><h1 id="f95f" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">拯救视频阅读图书馆</h1><p id="9c18" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">好消息是有大量的开源库可以解决这些问题。如果你需要精确的帧搜索，那么像<a class="ae lh" href="https://github.com/dmlc/decord" rel="noopener ugc nofollow" target="_blank"> Decord </a>这样的库会非常有用。对于以效率为中心设计的全功能视频处理框架，您可以查看<a class="ae lh" href="https://pypi.org/project/vidgear/" rel="noopener ugc nofollow" target="_blank"> VidGears </a>(它有一个名为CamGears的库，用于视频阅读)。</p><p id="a812" class="pw-post-body-paragraph ma mb it mc b md my kd mf mg mz kg mi mj na ml mm mn nb mp mq mr nc mt mu mv im bi translated">OpenCV读取视频本质上是作为<code class="fe ny nz oa ob b">ffmpeg</code>的包装器，但是如果你想控制用来读取视频的底层<code class="fe ny nz oa ob b">ffmpeg</code>命令，那么你可以使用像<a class="ae lh" href="https://pyav.org/docs/stable/" rel="noopener ugc nofollow" target="_blank"> PyAV </a>或<a class="ae lh" href="https://github.com/kkroening/ffmpeg-python" rel="noopener ugc nofollow" target="_blank"> ffmpeg-python </a>这样的库。<code class="fe ny nz oa ob b"><a class="ae lh" href="https://github.com/jrosebr1/imutils" rel="noopener ugc nofollow" target="_blank">imutils</a></code>是OpenCV视频阅读器类上的一个轻量级包装器，它是多线程的。</p><p id="626d" class="pw-post-body-paragraph ma mb it mc b md my kd mf mg mz kg mi mj na ml mm mn nb mp mq mr nc mt mu mv im bi translated">但是哪个最快呢？我做了一些实验来寻找答案，你可以在这里找到完整的源代码和图表<a class="ae lh" href="https://github.com/bml1g12/benchmarking_video_reading_python" rel="noopener ugc nofollow" target="_blank">。事实证明，答案在很大程度上取决于很多因素。例如:</a></p><ul class=""><li id="0c5e" class="nd ne it mc b md my mg mz mj nf mn ng mr nh mv ni nj nk nl bi translated">您的视频有多大——原因在于，它会影响解码压缩视频所需的CPU使用量，还会影响需要从磁盘读取的数据量。</li><li id="ba8d" class="nd ne it mc b md nm mg nn mj no mn np mr nq mv ni nj nk nl bi translated">你的软件是否能在阅读视频的同时做有用的工作——然后是CPU繁重的工作还是仅仅需要时间(I/O受限)。这很重要，因为一个高效的视频阅读库将开始在后台准备下一帧，所以你的软件正在做的事情会对这个后台过程产生很大的影响。</li></ul><p id="fda3" class="pw-post-body-paragraph ma mb it mc b md my kd mf mg mz kg mi mj na ml mm mn nb mp mq mr nc mt mu mv im bi translated">我将其分为三个使用案例:</p><ol class=""><li id="494c" class="nd ne it mc b md my mg mz mj nf mn ng mr nh mv oc nj nk nl bi translated">"<strong class="mc jd">解除阻止</strong> " —这意味着您的软件可以将其所有资源用于读取视频，而不会同时尝试做任何事情。</li><li id="23e5" class="nd ne it mc b md nm mg nn mj no mn np mr nq mv oc nj nk nl bi translated">"<strong class="mc jd"> IO受限</strong> " —这对应于当你想让你的软件做些别的事情，但不是CPU繁重的时候，我通过添加一个简单的<code class="fe ny nz oa ob b">time.sleep()</code>阻塞调用来模拟这种情况</li><li id="e15c" class="nd ne it mc b md nm mg nn mj no mn np mr nq mv oc nj nk nl bi translated">“<strong class="mc jd"> CPU受限</strong>”—这对应于计算机视觉、图像处理和机器学习管道中的一个非常典型的用例，其中您的软件在读取每一帧之间使用CPU—我对此进行了模拟，我添加了一个阻塞调用，在每次视频读取之间执行固定次数的乘法。</li></ol><p id="7f8f" class="pw-post-body-paragraph ma mb it mc b md my kd mf mg mz kg mi mj na ml mm mn nb mp mq mr nc mt mu mv im bi translated">对于每个使用案例，我对低分辨率(480x270)视频、中分辨率(720x480)视频和高分辨率(1920x1080)视频的速度进行了基准测试。由于结果因情况而异，我鼓励您查看报告中的<a class="ae lh" href="https://github.com/bml1g12/benchmarking_video_reading_python" rel="noopener ugc nofollow" target="_blank">图表，找出最符合您的使用案例的图表。</a></p><p id="92f5" class="pw-post-body-paragraph ma mb it mc b md my kd mf mg mz kg mi mj na ml mm mn nb mp mq mr nc mt mu mv im bi translated">对于本文，我只展示中等质量的视频(720x480)。在这些基准测试中，我包括了<code class="fe ny nz oa ob b">max_possible_fps</code>，这是一个不读取视频的控制基准测试——只做计时和添加任何阻塞调用。我还添加了<code class="fe ny nz oa ob b">baseline</code>，这是一个使用简单的基于OpenCV的库的控制基准，所以我们希望比基线更快地得到结果。</p><p id="f7e9" class="pw-post-body-paragraph ma mb it mc b md my kd mf mg mz kg mi mj na ml mm mn nb mp mq mr nc mt mu mv im bi translated">首先，让我们来看看“<strong class="mc jd">未阻塞</strong>”的情况，这是一种可能有点不寻常的情况，只是阅读一个视频，并不实际在你的软件中做任何其他事情。<code class="fe ny nz oa ob b">max_possible_fps</code>太高了，在这里毫无意义，因为它所做的只是初始化定时器，也就是说，没有视频读取，也没有阻塞呼叫。我们发现基线OpenCV实际上优于所有这些媒体库，几乎以与<code class="fe ny nz oa ob b">imutils</code>和<code class="fe ny nz oa ob b">camgears_with_queue</code>相同的速度出现，但随着我们转向更常见的软件用例，这种情况将会改变，实际上除了阅读视频之外，你的软件还会做其他事情。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi od"><img src="../Images/6b6ea434fa2b28186afdb0392583bdb1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hBigT612UJliFFqIxHlg9Q.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">“<strong class="bd oe">未阻止</strong>”用例，即您的软件除了视频阅读之外什么也不做。(<a class="ae lh" href="https://github.com/bml1g12/benchmarking_video_reading_python" rel="noopener ugc nofollow" target="_blank">来源</a>，作者创作)</p></figure><p id="5e65" class="pw-post-body-paragraph ma mb it mc b md my kd mf mg mz kg mi mj na ml mm mn nb mp mq mr nc mt mu mv im bi translated">下图所示的“<strong class="mc jd"> IO受限</strong>”情况完全不同；我们现在看到，通过使用一个可以在后台准备帧的库，我们可以从基线OpenCV实现中获得30%的加速。<code class="fe ny nz oa ob b">camgears</code>和<code class="fe ny nz oa ob b">imutils </code>显然是这里的赢家。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi od"><img src="../Images/4b28683f86e7075b0336e90f4e9dd18f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZoCpBeNlwhx0jNtuPR7idQ.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">"<strong class="bd oe"> IO受限</strong>"用例，即您的软件在读取帧之间做一些非CPU密集型的事情。(<a class="ae lh" href="https://github.com/bml1g12/benchmarking_video_reading_python" rel="noopener ugc nofollow" target="_blank">来源</a>，作者创作)</p></figure><p id="47e7" class="pw-post-body-paragraph ma mb it mc b md my kd mf mg mz kg mi mj na ml mm mn nb mp mq mr nc mt mu mv im bi translated">最后，“<strong class="mc jd"> CPU有限</strong>案例如下图所示。我们看到两个库之间的差异较小，但是<code class="fe ny nz oa ob b">imutils</code>再次胜出，速度与<code class="fe ny nz oa ob b">camgears_with_queue</code>基本相同，都比OpenCV快6%。</p><p id="a0fb" class="pw-post-body-paragraph ma mb it mc b md my kd mf mg mz kg mi mj na ml mm mn nb mp mq mr nc mt mu mv im bi translated">您可能会注意到<code class="fe ny nz oa ob b">camgears_with_queue</code>明显优于<code class="fe ny nz oa ob b">camgears</code>——实际上，作为撰写本文的一部分，我为<code class="fe ny nz oa ob b">camgears </code> repo做出了贡献，以优化队列实现[ <a class="ae lh" href="https://github.com/abhiTronix/vidgear/pull/196/commits/3f7a6fd9efc456fbdbbb3a9394c816641701e8cf" rel="noopener ugc nofollow" target="_blank"> 1 </a> ][ <a class="ae lh" href="https://github.com/abhiTronix/vidgear/pull/192" rel="noopener ugc nofollow" target="_blank"> 2 </a> ]，但在撰写本文时它还没有发布；<code class="fe ny nz oa ob b">camgears</code>是在撰写本文时的正式实现，<code class="fe ny nz oa ob b">camgears_with_queue</code>是将在未来发布的优化实现——如果你想看看区别，在这个回购中代码是<a class="ae lh" href="https://github.com/bml1g12/benchmarking_video_reading_python/tree/main/video_reading_benchmarks/camgear" rel="noopener ugc nofollow" target="_blank">。</a></p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi od"><img src="../Images/06a9d673f5daa2db107d173055bf6adc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1U1jxU3bFSSu4TLC4fuUhQ.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">“<strong class="bd oe"> CPU受限</strong>”用例，即您的软件在读取帧之间执行一些CPU密集型操作。(<a class="ae lh" href="https://github.com/bml1g12/benchmarking_video_reading_python" rel="noopener ugc nofollow" target="_blank">来源</a>，作者创作)</p></figure><p id="3425" class="pw-post-body-paragraph ma mb it mc b md my kd mf mg mz kg mi mj na ml mm mn nb mp mq mr nc mt mu mv im bi translated">如果您正在处理高分辨率视频，加速会变得更加极端，在IO受限的情况下速度几乎翻倍。如果你正在处理许多视频文件，你应该<a class="ae lh" href="https://medium.com/me/stories/public" rel="noopener">看看我的文章</a>来优化它。</p><h1 id="6c37" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">带回家的点数</h1><ul class=""><li id="b308" class="nd ne it mc b md me mg mh mj of mn og mr oh mv ni nj nk nl bi translated">OpenCV视频阅读器并不适合所有情况；选择合适的视频阅读库以获得最佳性能和效果</li><li id="fca4" class="nd ne it mc b md nm mg nn mj no mn np mr nq mv ni nj nk nl bi translated">如果你想要精确的帧搜索，不要尝试在OpenCV中这样做，使用像<a class="ae lh" href="https://github.com/dmlc/decord" rel="noopener ugc nofollow" target="_blank"> decord </a>这样的库。</li><li id="c06f" class="nd ne it mc b md nm mg nn mj no mn np mr nq mv ni nj nk nl bi translated">如果你想用Python高效地阅读视频，使用像<a class="ae lh" href="https://pypi.org/project/vidgear/" rel="noopener ugc nofollow" target="_blank">vigears</a>/CamGears或者i <a class="ae lh" href="https://github.com/jrosebr1/imutils" rel="noopener ugc nofollow" target="_blank"> mutils </a>这样的库。</li></ul></div></div>    
</body>
</html>