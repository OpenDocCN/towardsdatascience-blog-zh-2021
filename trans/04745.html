<html>
<head>
<title>Advanced Random Sampling in BigQuery SQL</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">BigQuery SQL中的高级随机采样</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/advanced-random-sampling-in-bigquery-sql-7d4483b580bb?source=collection_archive---------13-----------------------#2021-04-25">https://towardsdatascience.com/advanced-random-sampling-in-bigquery-sql-7d4483b580bb?source=collection_archive---------13-----------------------#2021-04-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4cbb" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解如何以可重现的方式对BigQuery表中的行进行采样</h2></div><p id="a82e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi le translated"><span class="l lf lg lh bm li lj lk ll lm di">做</span>你想知道如何在BigQuery SQL 中<strong class="kk iu">采样吗？在这里，我将向您展示如何在Google BigQuery中以一种可以重现结果的方式进行随机采样。我还将向您展示如何同时获取<strong class="kk iu">多个样本</strong>并计算后面的更好的统计数据。</strong></p><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi ln"><img src="../Images/10d29dd5b057df4f713b250280a5adc6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Vw3grT3jNY2g9K9Vshq-RA.jpeg"/></div></div><p class="lz ma gj gh gi mb mc bd b be z dk translated">我在为BigQuery寻找一些大的东西… |照片由<a class="ae md" href="https://unsplash.com/@pawel_czerwinski?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">paweczerwi324ski</a>在<a class="ae md" href="https://unsplash.com/s/photos/big?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><p id="ad76" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="ml">我确实有一些关于BigQuery的其他文章，所以请查看我的个人资料以获得更多BQ阅读:</em></p><div class="mm mn gp gr mo mp"><a href="https://niczky12.medium.com" rel="noopener follow" target="_blank"><div class="mq ab fo"><div class="mr ab ms cl cj mt"><h2 class="bd iu gy z fp mu fr fs mv fu fw is bi translated">Bence Komarniczky -培养基</h2><div class="mw l"><h3 class="bd b gy z fp mu fr fs mv fu fw dk translated">学习所有的连接——内连接、外连接、交叉连接和半连接。我们为什么要这么做？还有…</h3></div><div class="mx l"><p class="bd b dl z fp mu fr fs mv fu fw dk translated">niczky12.medium.com</p></div></div><div class="my l"><div class="mz l na nb nc my nd lx mp"/></div></div></a></div></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><blockquote class="ne"><p id="c9f6" class="nf ng it bd nh ni nj nk nl nm nn ld dk translated">要获得所有媒体文章的完整访问权限，包括我的文章，请考虑在此订阅<a class="ae md" href="https://niczky12.medium.com/membership" rel="noopener"/>。</p></blockquote><h1 id="2c6b" class="no np it bd nq nr ns nt nu nv nw nx ny jz nz ka oa kc ob kd oc kf od kg oe of bi translated">生成一些数据</h1><p id="ce85" class="pw-post-body-paragraph ki kj it kk b kl og ju kn ko oh jx kq kr oi kt ku kv oj kx ky kz ok lb lc ld im bi translated">BigQuery 中有一些很棒的开放数据集，但是它们相当大，所以如果你不够小心的话，你很容易因为查询它们而被收费。我鼓励你去看看这些数据集，但是这里我将<strong class="kk iu">生成一个很小的数据集</strong>，只是为了确保我不会因为任何查询而被计费(BQ有1TB/月的免费trier限制)。</p><figure class="lo lp lq lr gt ls"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="3904" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这将给出2组(a和b ),第一组在5和15之间具有<strong class="kk iu">均匀随机分布</strong>,第二组在2和9之间具有均匀随机分布。</p><blockquote class="ne"><p id="22ca" class="nf ng it bd nh ni nj nk nl nm nn ld dk translated">您可以使用此方法从任意两个数字之间的均匀随机分布中生成一个数字列表。</p></blockquote><p id="deb5" class="pw-post-body-paragraph ki kj it kk b kl on ju kn ko oo jx kq kr op kt ku kv oq kx ky kz or lb lc ld im bi translated">我们将在整个教程中使用这个数据集，所以我建议您<strong class="kk iu">将它保存为数据集</strong>——我将它保存为<code class="fe os ot ou ov b">ds.random_table</code>，这是我在后面的查询中引用它的方式。</p><h2 id="ff32" class="ow np it bd nq ox oy dn nu oz pa dp ny kr pb pc oa kv pd pe oc kz pf pg oe ph bi translated">查询解释—请随意跳过</h2><p id="85e6" class="pw-post-body-paragraph ki kj it kk b kl og ju kn ko oh jx kq kr oi kt ku kv oj kx ky kz ok lb lc ld im bi translated">如果您还不熟悉BQ中的数组或随机函数，下面是上面查询中发生的情况:</p><ul class=""><li id="8602" class="pi pj it kk b kl km ko kp kr pk kv pl kz pm ld pn po pp pq bi translated">我们创建一个从1到1000的数组。</li><li id="9201" class="pi pj it kk b kl pr ko ps kr pt kv pu kz pv ld pn po pp pq bi translated">对于a组，我们将这个数组扩展为每行一个数字(unnest)</li><li id="f0f1" class="pi pj it kk b kl pr ko ps kr pt kv pu kz pv ld pn po pp pq bi translated">我们为这一千行中的每一行添加一个标志<code class="fe os ot ou ov b">group_a</code>和一个随机数。</li><li id="dc3c" class="pi pj it kk b kl pr ko ps kr pt kv pu kz pv ld pn po pp pq bi translated">我们对<code class="fe os ot ou ov b">group_b</code>重复同样的事情，用<code class="fe os ot ou ov b">union all</code>把它加到上表的末尾。</li></ul><h1 id="582f" class="no np it bd nq nr ns nt nu nv nw nx ny jz pw ka oa kc px kd oc kf py kg oe of bi translated">简单抽样</h1><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi pz"><img src="../Images/4e8fef089bc69c3d15bd2ea38fbd4c12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EHFYS_NbMOwVgzOSRB-qqA.jpeg"/></div></div><p class="lz ma gj gh gi mb mc bd b be z dk translated">照片由<a class="ae md" href="https://unsplash.com/@loic?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Djim Loic </a>在<a class="ae md" href="https://unsplash.com/s/photos/changing?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="3caf" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">网上有一些关于随机抽样的SQL教程，提倡使用<code class="fe os ot ou ov b">RAND()</code>函数。让我们看看这是如何工作的，以及为什么你不应该使用它😉。</p><p id="0395" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们将随机抽取20个id，然后取<code class="fe os ot ou ov b">v</code>数的平均值以及<code class="fe os ot ou ov b">group_a</code>和<code class="fe os ot ou ov b">group_b</code>观察值的计数。</p><p id="0801" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们如何做到这一点？我们<strong class="kk iu">为每个项目</strong>生成一个介于0和1之间的随机数，<strong class="kk iu">根据这个随机数对行</strong>进行排序，然后<strong class="kk iu">可以将前20行</strong>作为我们的样本。</p><figure class="lo lp lq lr gt ls"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="1408" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，给定这个样本表，我们计算我们的统计数据:</p><figure class="lo lp lq lr gt ls"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="bf6a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我得到以下结果:</p><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi qa"><img src="../Images/6ffca65d1fd94aa5da8bc0465b8d76b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s4AsWGnsIkls8x7is0nI8g.png"/></div></div><p class="lz ma gj gh gi mb mc bd b be z dk translated">从BigQuery UI捕获的图像</p></figure><p id="fbc2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在让我们再运行一次:</p><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi qb"><img src="../Images/453f68d70f0cc09ce9de652390748b9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yDMc1Sqjkf7trfRDejdMJQ.png"/></div></div><p class="lz ma gj gh gi mb mc bd b be z dk translated">从BigQuery UI捕获的图像</p></figure><p id="a688" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">哇，这不一样。😱</p><figure class="lo lp lq lr gt ls"><div class="bz fp l di"><div class="qc om l"/></div><p class="lz ma gj gh gi mb mc bd b be z dk translated">Gif来自<a class="ae md" href="https://giphy.com/gifs/mrw-show-remote-HUkOv6BNWc1HO/links" rel="noopener ugc nofollow" target="_blank"> GIPHY </a>。</p></figure><p id="d4a4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这并不十分理想，因为我想确保我在BQ中所做的任何计算都能被我的数据科学家同事复制<strong class="kk iu">。让我们看看你如何做到这一点。</strong></p><h1 id="a5f8" class="no np it bd nq nr ns nt nu nv nw nx ny jz pw ka oa kc px kd oc kf py kg oe of bi translated">哈希可重复采样</h1><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi qd"><img src="../Images/4d62f89405c0eb6e25a32ad415fc7646.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E_iUTD09VK587UrocyPWRQ.jpeg"/></div></div><p class="lz ma gj gh gi mb mc bd b be z dk translated">照片由<a class="ae md" href="https://unsplash.com/@socialcut?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">S O C I A L C U T</a>在<a class="ae md" href="https://unsplash.com/s/photos/hashtag?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="23d3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">函数<code class="fe os ot ou ov b">RAND()</code>的问题在于它<strong class="kk iu">在每次执行</strong>时都会创建新的随机数。因此，第一行可能在第一次运行时得到0.2，但在第二次运行时得到0.99。我们想要实现的是为每一行获得相同的随机数。</p><p id="90be" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这就是散列变得有用的地方。哈希函数接受一个字符串或数字，并返回一个随机但一致的字符串或数字。<a class="ae md" href="https://cloud.google.com/bigquery/docs/reference/standard-sql/hash_functions#farm_fingerprint" rel="noopener ugc nofollow" target="_blank">在BQ </a>中最容易使用的散列函数是<code class="fe os ot ou ov b">farm_fingerprint</code>。这个函数总是为相同的输入返回相同的整数，它可以接受字符串作为输入。让我们看看它与没有输入的<code class="fe os ot ou ov b">RAND()</code>相比如何。</p><figure class="lo lp lq lr gt ls"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="9089" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">结果是:</p><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi qe"><img src="../Images/75876e85aae95df0d2372261acbb1d0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ChM4TKpBJgWhOX1T49sQhA.png"/></div></div><p class="lz ma gj gh gi mb mc bd b be z dk translated">从BigQuery UI捕获的图像</p></figure><p id="761d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可以看到，我们的两个Alberts具有相同的farm_fingerprint值，而我们的rand函数返回了不同的值。更好的是，<code class="fe os ot ou ov b">farm_fingerprint</code>将在每次运行时产生相同的数字。</p><blockquote class="ne"><p id="ed0c" class="nf ng it bd nh ni nj nk nl nm nn ld dk translated">继续尝试吧，上面的查询在BQ中没有任何成本，因为我们在查询时生成所有的数据。</p></blockquote><p id="d22c" class="pw-post-body-paragraph ki kj it kk b kl on ju kn ko oo jx kq kr op kt ku kv oq kx ky kz or lb lc ld im bi translated">有了这个新的闪亮的函数，是时候修改我们原来的采样查询并使它完全可再现了。</p><figure class="lo lp lq lr gt ls"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="84f7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里发生了什么事？</p><ol class=""><li id="8763" class="pi pj it kk b kl km ko kp kr pk kv pl kz pm ld qf po pp pq bi translated">我们使用<code class="fe os ot ou ov b">row_number</code>函数创建了一个名为<code class="fe os ot ou ov b">rn</code>的整数列</li><li id="b2ce" class="pi pj it kk b kl pr ko ps kr pt kv pu kz pv ld qf po pp pq bi translated">我们将它们转换为字符串，因为<code class="fe os ot ou ov b">farm_fingerprint</code>需要一个字符串或字节输入。</li><li id="1f1c" class="pi pj it kk b kl pr ko ps kr pt kv pu kz pv ld qf po pp pq bi translated">然后，代替<code class="fe os ot ou ov b">rand()</code>,我们使用<code class="fe os ot ou ov b">farm_fingerprint</code>函数来生成一些我们可以排序的随机数。</li></ol><p id="415b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">无论运行多少次查询，我都会得到以下结果。(您可能会得到稍微不同的结果，因为我们的原始表是由<code class="fe os ot ou ov b">rand()</code>生成的，所以您的基本数字可能会有所不同)。</p><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi qg"><img src="../Images/a064061fcd756ae55d5d7b9c72a3b8c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JVcdVAY5F61Pl-oqHZAkrw.png"/></div></div></figure><p id="0c6c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在真实的场景中，您可能已经有一个与您的数据相关联的<strong class="kk iu">行id或用户id </strong>。在这种情况下，您可以随意将其作为输入传递到<code class="fe os ot ou ov b">farm_fingerprint</code>中。只是<strong class="kk iu">注意重复的id</strong>，因为这些重复的id将具有相同的散列！这可能是你在某些情况下想要的。</p><h1 id="c4b4" class="no np it bd nq nr ns nt nu nv nw nx ny jz pw ka oa kc px kd oc kf py kg oe of bi translated">模数采样比</h1><p id="b9f1" class="pw-post-body-paragraph ki kj it kk b kl og ju kn ko oh jx kq kr oi kt ku kv oj kx ky kz ok lb lc ld im bi translated">我们现在知道如何重复采样值。但是对于大型数据集，对整个表进行排序，然后取前n行可能会有问题。我们如何在不点餐的情况下占桌子的x%?</p><p id="897e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们的散列函数总是返回一个整数。那个整数有时能被10整除，有时不能。因为<strong class="kk iu">散列函数将观察值相当均匀地分布在整数</strong>上，我们希望10个散列中有1个(10%)能被10整除。类似地，平均来说，1%的数字应该能被100整除。我们可以利用这一点来决定是否要保留一个数字。</p><p id="cd74" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了抽取15%的样本，我们将散列的模取100，然后选择模小于15的所有数字。</p><blockquote class="qh qi qj"><p id="5895" class="ki kj ml kk b kl km ju kn ko kp jx kq qk ks kt ku ql kw kx ky qm la lb lc ld im bi translated">这里有一个陷阱！BQ模运算符可以为负整数返回负数。所以必须先取绝对值。</p></blockquote><figure class="lo lp lq lr gt ls"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="8319" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以上比之前复杂了一点。这是因为我们想要使用一个<code class="fe os ot ou ov b">where</code>语句，并且不能包含一个<code class="fe os ot ou ov b">row_number()</code>函数——或者任何带有<code class="fe os ot ou ov b">over()</code>部分的东西。所以我们<strong class="kk iu">首先创建行号</strong>，然后使用<code class="fe os ot ou ov b">farm_fingerprint</code>获取样本。</p><blockquote class="qh qi qj"><p id="a418" class="ki kj ml kk b kl km ju kn ko kp jx kq qk ks kt ku ql kw kx ky qm la lb lc ld im bi translated">当您像这样采样时，在SQL代码中添加注释，因为新数据科学家可能会发现很难理解您将要采样的比率！</p></blockquote><h2 id="3ce3" class="ow np it bd nq ox oy dn nu oz pa dp ny kr pb pc oa kv pd pe oc kz pf pg oe ph bi translated">多个样本</h2><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi qn"><img src="../Images/66873ed0a0cb4ee44d133a852f7840e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uBcDhN8e61Edx-TvVaKW_A.jpeg"/></div></div><p class="lz ma gj gh gi mb mc bd b be z dk translated">Miguel Orós 在<a class="ae md" href="https://unsplash.com/s/photos/more?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="5e02" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">作为我们的最后一步，我们将采取<strong class="kk iu">多个样本</strong>，然后计算每组的样本平均值。这会变得很有趣，所以系好安全带！</p><p id="d3e7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是我们要做的:</p><ol class=""><li id="18d7" class="pi pj it kk b kl km ko kp kr pk kv pl kz pm ld qf po pp pq bi translated">创建一个长度为<code class="fe os ot ou ov b">n</code>的数组，其中<code class="fe os ot ou ov b">n</code>是我们想要采样的次数。我们称这个数字为<code class="fe os ot ou ov b">sample_id</code>。</li><li id="189b" class="pi pj it kk b kl pr ko ps kr pt kv pu kz pv ld qf po pp pq bi translated">将我们的数组<code class="fe os ot ou ov b">sample_id</code>交叉连接到原始数据集，以复制每个项目<code class="fe os ot ou ov b">n</code>次。</li><li id="ec54" class="pi pj it kk b kl pr ko ps kr pt kv pu kz pv ld qf po pp pq bi translated">将<code class="fe os ot ou ov b">sample_id</code>和行号组合起来，为每一行获得一个惟一的id，我们可以用它来处理<code class="fe os ot ou ov b">farm_fingerprint</code>。</li><li id="5110" class="pi pj it kk b kl pr ko ps kr pt kv pu kz pv ld qf po pp pq bi translated">使用模方法获得所有观察值的15%—平均每个<code class="fe os ot ou ov b">sample_id</code>将获得每个观察值的15%。</li><li id="b0ad" class="pi pj it kk b kl pr ko ps kr pt kv pu kz pv ld qf po pp pq bi translated">根据<code class="fe os ot ou ov b">sample_id</code>和组id获取平均值。</li></ol><figure class="lo lp lq lr gt ls"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="a36d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您绘制结果，您将得到以下结果:</p><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi qo"><img src="../Images/ef955a04c9bada736a1459ba365b5833.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X7y8YZuGDact05JkiPOBww.png"/></div></div><p class="lz ma gj gh gi mb mc bd b be z dk translated">是的，这是从谷歌床单。随便你怎么评价我，我都懒得读成Python。|来源:作者创作</p></figure><p id="ef57" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这给了我们<strong class="kk iu">非常好的估计</strong>——和两个漂亮的钟形曲线——对于我们两个不同的组。没错，这就是<a class="ae md" href="https://www.onlinestatbook.com/stat_sim/normal_approx/clt.html" rel="noopener ugc nofollow" target="_blank">中心极限定理</a>在起作用。<em class="ml">回到最初的数据生成步骤，看看这是否正确估计了我们的人口均值！</em></p><p id="c063" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">记住BigQuery是按查询的字节收费的，而我们<strong class="kk iu">只查询了一次我们的原始数据</strong>。我们只是碰巧把它交叉连接到一堆整数上来复制我们的采样1000次！🎉</p><blockquote class="qh qi qj"><p id="3b7d" class="ki kj ml kk b kl km ju kn ko kp jx kq qk ks kt ku ql kw kx ky qm la lb lc ld im bi translated">现在，您可以使用数组、farm_fingerprint和mod，通过便宜的BigQuery获得更好的统计估计！</p></blockquote><h1 id="6dc5" class="no np it bd nq nr ns nt nu nv nw nx ny jz pw ka oa kc px kd oc kf py kg oe of bi translated">结论</h1><p id="f2fc" class="pw-post-body-paragraph ki kj it kk b kl og ju kn ko oh jx kq kr oi kt ku kv oj kx ky kz ok lb lc ld im bi translated">感谢阅读到最后！🙏</p><p id="534f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，您知道了如何使用Google BigQuery中一些方便的函数在SQL中进行采样。你已经学会了:</p><ul class=""><li id="af55" class="pi pj it kk b kl km ko kp kr pk kv pl kz pm ld pn po pp pq bi translated">如何免费生成一些均匀分布的哑数据？</li><li id="fc6c" class="pi pj it kk b kl pr ko ps kr pt kv pu kz pv ld pn po pp pq bi translated">为什么不应该使用<code class="fe os ot ou ov b">rand()</code>函数来采样</li><li id="044e" class="pi pj it kk b kl pr ko ps kr pt kv pu kz pv ld pn po pp pq bi translated">那个<code class="fe os ot ou ov b">farm_fingerprint</code>接受字符串或字节，给你散列的整数。</li><li id="8c6b" class="pi pj it kk b kl pr ko ps kr pt kv pu kz pv ld pn po pp pq bi translated">如何使用模函数进行采样？</li><li id="0a74" class="pi pj it kk b kl pr ko ps kr pt kv pu kz pv ld pn po pp pq bi translated">如何通过与整数列表交叉连接来获取多个样本？</li></ul></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><p id="bf14" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">通过阅读更多内容，让您的BigQuery技能更上一层楼😅：</p><div class="mm mn gp gr mo mp"><a rel="noopener follow" target="_blank" href="/loops-in-bigquery-db137e128d2d"><div class="mq ab fo"><div class="mr ab ms cl cj mt"><h2 class="bd iu gy z fp mu fr fs mv fu fw is bi translated">BigQuery中的循环</h2><div class="mw l"><h3 class="bd b gy z fp mu fr fs mv fu fw dk translated">了解如何使用BigQuery脚本来计算斐波那契数</h3></div><div class="mx l"><p class="bd b dl z fp mu fr fs mv fu fw dk translated">towardsdatascience.com</p></div></div><div class="my l"><div class="qp l na nb nc my nd lx mp"/></div></div></a></div><div class="mm mn gp gr mo mp"><a rel="noopener follow" target="_blank" href="/fizzbuzz-in-bigquery-e0c4fbc1d195"><div class="mq ab fo"><div class="mr ab ms cl cj mt"><h2 class="bd iu gy z fp mu fr fs mv fu fw is bi translated">BigQuery中的FizzBuzz</h2><div class="mw l"><h3 class="bd b gy z fp mu fr fs mv fu fw dk translated">BigQuery中的FizzBuzz，而不是BigQuery中的Java或Python。使用SQL，为什么不呢？</h3></div><div class="mx l"><p class="bd b dl z fp mu fr fs mv fu fw dk translated">towardsdatascience.com</p></div></div><div class="my l"><div class="qq l na nb nc my nd lx mp"/></div></div></a></div><div class="mm mn gp gr mo mp"><a rel="noopener follow" target="_blank" href="/load-files-faster-into-bigquery-94355c4c086a"><div class="mq ab fo"><div class="mr ab ms cl cj mt"><h2 class="bd iu gy z fp mu fr fs mv fu fw is bi translated">将文件更快地加载到BigQuery中</h2><div class="mw l"><h3 class="bd b gy z fp mu fr fs mv fu fw dk translated">针对摄取的CSV、GZIP、AVRO和拼花文件类型进行基准测试</h3></div><div class="mx l"><p class="bd b dl z fp mu fr fs mv fu fw dk translated">towardsdatascience.com</p></div></div><div class="my l"><div class="qr l na nb nc my nd lx mp"/></div></div></a></div></div></div>    
</body>
</html>