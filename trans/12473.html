<html>
<head>
<title>How to Use an Autoregressive (AR) Model For Time Series Analysis</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用自回归(AR)模型进行时间序列分析</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-use-an-autoregressive-ar-model-for-time-series-analysis-bb12b7831024?source=collection_archive---------2-----------------------#2021-12-21">https://towardsdatascience.com/how-to-use-an-autoregressive-ar-model-for-time-series-analysis-bb12b7831024?source=collection_archive---------2-----------------------#2021-12-21</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="750c" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">python 中使用自回归模型进行预测的初学者指南</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/fc0c4d54c94b9cb91d5a66e449028b40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*lU6gqONqyAbKZAhW"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">由<a class="ae kz" href="https://unsplash.com/@agebarros?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">阿格巴洛斯</a>在<a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="f28a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在处理时间序列数据时，可以使用自回归模型来预测未来值。预测背后的概念是使用以前的数据点来计算未来的数据点。</p><p id="eb81" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在这个简短的初学者友好指南中，你将学习如何创建一个自回归模型，并用它来预测未来的价值。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h2 id="afd1" class="md me iu bd mf mg mh dn mi mj mk dp ml lj mm mn mo ln mp mq mr lr ms mt mu mv bi translated">例子</h2><p id="22af" class="pw-post-body-paragraph la lb iu lc b ld mw jv lf lg mx jy li lj my ll lm ln mz lp lq lr na lt lu lv in bi translated"><strong class="lc iv">举个简单的例子，</strong>可以让你知道它是如何工作的:<br/>现在是下午 2 点，我们想预测下午 3 点的值。为了做到这一点，我们可以使用已知的 2pm 和 1pm 的值。从数学上讲，它可能如下所示:</p><blockquote class="nb"><p id="833a" class="nc nd iu bd ne nf ng nh ni nj nk lv dk translated">x(t) = b0 + b1*x(t-1) + b2*x(t-2)</p></blockquote><p id="9b9c" class="pw-post-body-paragraph la lb iu lc b ld nl jv lf lg nm jy li lj nn ll lm ln no lp lq lr np lt lu lv in bi translated">是我们希望对其进行预测的时间。<em class="nq"> t-1 </em>是前一个时间点，而<em class="nq"> t-2 </em>是向后两个时间点。</p><p id="ab37" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><em class="nq"> b </em>值是通过拟合数据集的自回归模型得到的权重。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h2 id="a5c7" class="md me iu bd mf mg mh dn mi mj mk dp ml lj mm mn mo ln mp mq mr lr ms mt mu mv bi translated">术语</h2><p id="4d32" class="pw-post-body-paragraph la lb iu lc b ld mw jv lf lg mx jy li lj my ll lm ln mz lp lq lr na lt lu lv in bi translated"><strong class="lc iv">滞后:</strong>处理时间序列数据时，每个跨时间的数据点称为一个滞后。</p><p id="7163" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><strong class="lc iv">偏差或权重:</strong>上例中的<em class="nq"> b </em>值为权重。它们是描述输入变量和我们预测的变量之间的相关性的值。如果权重为正，也称为正相关，这意味着输入变量与预测变量的移动方向相同。相反，如果权重为负，那么它会向预测变量的相反方向移动。</p><p id="f628" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">例如，值为<em class="nq"> 10 </em>(正值)的输入变量上的权重<em class="nq"> -0，7 </em>会将<em class="nq"> -7 </em>加到输出值上，从而对其产生负面影响。</p><p id="9b13" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果权重值非常接近<em class="nq"> 0 </em>，则表明变量的先前值和未来值之间可能没有相关性，因此无法进行预测。高于<em class="nq"> 0.5 </em>或低于- <em class="nq"> 0.5 </em>的值表示强相关。</p><p id="d781" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><strong class="lc iv">自相关:</strong>当输出变量本身与其早期变量之间计算相关性时，预测变量与输入变量之间的关系或相关性称为自相关。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h2 id="3294" class="md me iu bd mf mg mh dn mi mj mk dp ml lj mm mn mo ln mp mq mr lr ms mt mu mv bi translated">数据集</h2><p id="c2a4" class="pw-post-body-paragraph la lb iu lc b ld mw jv lf lg mx jy li lj my ll lm ln mz lp lq lr na lt lu lv in bi translated">在本指南中，我们将使用澳大利亚墨尔本的数据集，其中包含了 10 年间的最低日温度。该数据集是由澳大利亚气象局创建的。</p><p id="d95b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果你想按照这个指南编码，那么你可以在这里找到数据<a class="ae kz" href="https://gist.github.com/JacobToftgaardRasmussen/78cac8b522ce6d8cab4fc80f7de48ee9" rel="noopener ugc nofollow" target="_blank">。</a></p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h2 id="a793" class="md me iu bd mf mg mh dn mi mj mk dp ml lj mm mn mo ln mp mq mr lr ms mt mu mv bi translated">寻找自相关</h2><p id="f15f" class="pw-post-body-paragraph la lb iu lc b ld mw jv lf lg mx jy li lj my ll lm ln mz lp lq lr na lt lu lv in bi translated">为了找出哪些滞后与预测值有很强的相关性，我们可以使用 statstmodels 模块中的<code class="fe nr ns nt nu b">plot_acf()</code>函数。这将创建一个图表，显示每个先前的滞后对未来滞后的影响程度。</p><p id="6bd1" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如上所述，高于<em class="nq"> 0.5 </em>或低于<em class="nq"> -0.5 </em>的值被认为具有高相关性，因此在查看曲线图时，我们可以使用这些值作为阈值来决定是包括还是忽略特定的滞后。</p><p id="c7c2" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">下面的代码块创建了这个图，我在<br/> <em class="nq"> y = 0.5 </em>处添加了一条垂直线，以便于查看哪些滞后符合<em class="nq"> 0.5 </em>阈值。</p><blockquote class="nv nw nx"><p id="d08c" class="la lb nq lc b ld le jv lf lg lh jy li ny lk ll lm nz lo lp lq oa ls lt lu lv in bi translated">请注意，我将 y 轴限制在 0 到 1 的范围内。您通常不应该这样做，因为相关性也可能是负的。我这样做是为了提高图的可读性，只是因为我已经知道所有的滞后都是正相关的。</p></blockquote><pre class="kk kl km kn gu ob nu oc od aw oe bi"><span id="637a" class="md me iu nu b gz of og l oh oi">import pandas as pd<br/>import matplotlib.pyplot as plt<br/>from statsmodels.graphics.tsaplots import plot_acf<br/>import numpy as np</span><span id="5005" class="md me iu nu b gz oj og l oh oi">df = pd.read_csv('australia_temp_data.csv')</span><span id="c254" class="md me iu nu b gz oj og l oh oi">fig, ax = plt.subplots(figsize=(16,8))<br/>plot_acf(df['Temp'], lags=50, ax=ax)<br/>plt.ylim([0,1])<br/>plt.yticks(np.arange(0.1, 1.1, 0.1))<br/>plt.xticks(np.arange(1, 51, 1))<br/>plt.axhline(y=0.5, color="green")<br/>plt.show()</span></pre><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj ok"><img src="../Images/b2663807bca0277e6fe91750513c5a50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pJ1-nmnsMd9fTCOI1uAtAg.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">作者创建的 acf 图</p></figure><p id="92b2" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在分析剧情的时候，我们可以看到第一个滞后对我们未来的价值有非常强的相关性。滞后 22 是明显高于绿色阈值线的最后一个滞后。因此，我们现在知道使用 22 个滞后来创建我们的自回归模型。</p><h2 id="96e2" class="md me iu bd mf mg mh dn mi mj mk dp ml lj mm mn mo ln mp mq mr lr ms mt mu mv bi translated">将数据分成训练和测试数据集</h2><p id="06ed" class="pw-post-body-paragraph la lb iu lc b ld mw jv lf lg mx jy li lj my ll lm ln mz lp lq lr na lt lu lv in bi translated">为了能够评估我们的模型，一旦我们训练了它，我们需要一些数据来测试它。因此，我们将使用数据集中的一些最新值作为测试数据。</p><p id="a683" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">从上面代码块中的代码继续，我们可以按如下方式分割数据:</p><pre class="kk kl km kn gu ob nu oc od aw oe bi"><span id="36c3" class="md me iu nu b gz of og l oh oi">df_train = df['Temp'].iloc[:-5]<br/>df_test = df['Temp'].iloc[-5:]</span></pre><p id="82db" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这使得训练集由整个数据集的最后<em class="nq"> 5 </em>个值组成，并且训练集是直到最后<em class="nq"> 5 </em>的所有值。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h2 id="2246" class="md me iu bd mf mg mh dn mi mj mk dp ml lj mm mn mo ln mp mq mr lr ms mt mu mv bi translated">创建和拟合模型</h2><p id="9045" class="pw-post-body-paragraph la lb iu lc b ld mw jv lf lg mx jy li lj my ll lm ln mz lp lq lr na lt lu lv in bi translated">既然我们已经将训练和测试数据分开，并且我们知道在我们的模型中要考虑多少滞后，我们就拥有了创建模型所需的一切。</p><p id="d21f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们使用 statsmodels 模块(版本 0.13.1)中的<code class="fe nr ns nt nu b">AutoReg</code>类。</p><blockquote class="nv nw nx"><p id="6a2a" class="la lb nq lc b ld le jv lf lg lh jy li ny lk ll lm nz lo lp lq oa ls lt lu lv in bi translated">如果您使用的是 Google Colab 笔记本，那么您可能没有安装最新版本的 statsmodels。您很可能安装了 0.10.2 版本，而我将使用 0.13.1。要得到这个版本，你可以调用<code class="fe nr ns nt nu b">pip install statsmodels==0.13.1</code>，然后重启笔记本的运行时间。</p></blockquote><pre class="kk kl km kn gu ob nu oc od aw oe bi"><span id="ea43" class="md me iu nu b gz of og l oh oi">from statsmodels.tsa.ar_model import AutoReg<br/>model = AutoReg(df_train, lags=22).fit()</span></pre><p id="0492" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">现在已经创建了模型，并对训练数据进行了拟合。接下来，是时候进行一些预测，并通过与测试值进行比较来评估准确性。</p><h2 id="13d6" class="md me iu bd mf mg mh dn mi mj mk dp ml lj mm mn mo ln mp mq mr lr ms mt mu mv bi translated">预测和评估</h2><pre class="kk kl km kn gu ob nu oc od aw oe bi"><span id="1c8e" class="md me iu nu b gz of og l oh oi">forecasts = model.forecast(5).tolist()<br/>test_values = df_test.tolist()<br/>for index in range(len(forecasts)):<br/>  difference = forecasts[index] - test_values[index]<br/>  print(forecasts[index], test_values[index], difference)</span></pre><p id="16a0" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">为了进行预测，我们简单地调用模型上的<code class="fe nr ns nt nu b">forecast()</code>函数，并向它传递我们想要预测的滞后量。这将返回一个熊猫系列对象，我们可以使用它的<code class="fe nr ns nt nu b">tolist()</code>函数将它转换成一个列表。</p><p id="8979" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在循环中，我们在测试数据集中的实际值旁边打印预测，以及它们之间的差异。打印结果如下所示。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj ol"><img src="../Images/3677979e6c8150c11ea245e7aac3de75.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fdpxgH7xyarRmPew4BGeOQ.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">作者创建的预测值、测试值以及它们之间的差异</p></figure><p id="4285" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">为了获得可用于评估模型性能的单个数字指标，我们可以计算两个值列表之间的均方误差。这可以通过使用 scikit-learn 模块中的<code class="fe nr ns nt nu b">mean_squared_error()</code>功能来完成，如下所示。</p><pre class="kk kl km kn gu ob nu oc od aw oe bi"><span id="ecf9" class="md me iu nu b gz of og l oh oi">from sklearn.metrics import mean_squared_error<br/>print(mean_squared_error(test_values, forecasts))</span><span id="ba03" class="md me iu nu b gz oj og l oh oi">&gt;&gt; 1.181958471550279</span></pre><p id="fecb" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">结果显示，我们的预测平均误差约 1.2 摄氏度。为了直观地了解预测的准确性，我们还可以在同一个图中绘制预测和测试数据。</p><pre class="kk kl km kn gu ob nu oc od aw oe bi"><span id="6944" class="md me iu nu b gz of og l oh oi">fig = plt.subplots(figsize=(12,8))<br/>plt.plot(forecasts, color="green")<br/>plt.plot(test_values,color="blue")<br/>plt.xticks(np.arange(0,6,1))<br/>plt.yticks(np.arange(12.5, 17, 0.5))<br/>plt.show()</span></pre><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj om"><img src="../Images/a37d2665a67241a78fa906802b27e6ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*231jPJktt7hUsRi1e23EKw.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">作者创建的预测和测试数据图</p></figure><p id="cc3d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这里我们可以清楚地看到，在滞后 4 时(x 轴上的 3)，距离很远。然而，其他预测实际上相当不错。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h2 id="e796" class="md me iu bd mf mg mh dn mi mj mk dp ml lj mm mn mo ln mp mq mr lr ms mt mu mv bi translated">摘要</h2><p id="a39d" class="pw-post-body-paragraph la lb iu lc b ld mw jv lf lg mx jy li lj my ll lm ln mz lp lq lr na lt lu lv in bi translated">在这篇简短的指南中，您学习了自回归背后的重要背景理论，包括一些数学知识和术语。您学习了使用 acf 图来查找用于创建模型的滞后量。接下来，您将数据集分为训练和测试数据子集。最后，您了解了如何进行预测以及评估其性能的一些方法。</p><p id="2dd1" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我希望你喜欢这个指南，并学到一些有用的东西！</p><p id="f480" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">感谢阅读。</p><h2 id="b932" class="md me iu bd mf mg mh dn mi mj mk dp ml lj mm mn mo ln mp mq mr lr ms mt mu mv bi translated"><em class="on">学分</em></h2><p id="38a1" class="pw-post-body-paragraph la lb iu lc b ld mw jv lf lg mx jy li lj my ll lm ln mz lp lq lr na lt lu lv in bi translated">[1](本文的数据和灵感来源)——Jason Brownlee，<em class="nq">用 Python 进行时间序列预测的自回归模型</em>，机器学习掌握，可从<a class="ae kz" href="https://machinelearningmastery.com/autoregression-models-time-series-forecasting-python/" rel="noopener ugc nofollow" target="_blank">https://Machine Learning Mastery . com/auto regression-Models-Time-Series-Forecasting-Python/</a>获取，2021 年 12 月 20 日。</p></div></div>    
</body>
</html>