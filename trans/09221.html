<html>
<head>
<title>Esoteric Sort Algorithms and How to Implement Them in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">深奥的排序算法以及如何用Python实现它们</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/esoteric-sort-algorithms-and-how-to-implement-them-in-python-96c663fa6ae5?source=collection_archive---------16-----------------------#2021-08-26">https://towardsdatascience.com/esoteric-sort-algorithms-and-how-to-implement-them-in-python-96c663fa6ae5?source=collection_archive---------16-----------------------#2021-08-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="4fe3" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">代码？</h2><div class=""/><div class=""><h2 id="308a" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">当快速排序太快时</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/38f483b589529aa0f9c331be683201b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*MrsjUIQLqwgBpa3J"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">卢卡斯·乔治·温迪特在<a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="0673" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi me translated"><span class="l mf mg mh bm mi mj mk ml mm di"> W </span>当你听到排序算法的时候，你脑海中首先想到的是哪一个？快速排序？合并排序？冒泡排序？</p><p id="a4a5" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">回到大学，我的一位教授总是告诉全班同学，快速排序就像排序世界的苹果，因为他们非常擅长营销。通过将其命名为“quick”，人们将它们与最快的排序算法联系在一起，即使对于一般情况来说合并排序实际上更快。</p><p id="a643" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">撇开虚假广告不谈，我很肯定你听说过这些算法。让我们继续看最近的。</p><p id="cef3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">Python使用的是<a class="ae lh" href="https://www.geeksforgeeks.org/timsort/" rel="noopener ugc nofollow" target="_blank"> <em class="mn"> Timsort </em> </a>，一种由归并排序和插入排序衍生而来的混合算法。Timsort这个名字来自作者Tim Peter，他在2002年为Python创建了这个名字。</p><p id="494e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">对于特定的正数，我们有<a class="ae lh" href="https://www.geeksforgeeks.org/radix-sort/" rel="noopener ugc nofollow" target="_blank"> <em class="mn">基数排序</em> </a> <em class="mn">。</em>它是计数排序和黑魔法的组合，管理复杂度为O(d*(n+b))，其中d是列表中的位数，n是列表中的元素数，b是使用的基数，通常为基数10。</p><p id="bd15" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">最近在2020年，一种叫做<a class="ae lh" href="https://github.com/scandum/quadsort" rel="noopener ugc nofollow" target="_blank"> <em class="mn">四分类</em> </a>的新算法出现了。这是一个超优化合并排序的1500行实现，能够在多种情况下击败Timsort。作者好心地为我们这些凡人提供了<a class="ae lh" href="https://github.com/scandum/quadsort#visualization" rel="noopener ugc nofollow" target="_blank">可视化</a>和<a class="ae lh" href="https://github.com/scandum/quadsort#benchmark-quadsort-vs-stdstable_sort-vs-timsort" rel="noopener ugc nofollow" target="_blank">基准</a>。</p><p id="6eb3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">您可能认为我们将深入研究Quadsort的1500行代码，但是您错了。我们在这里看一看更有趣的排序算法。</p><blockquote class="mo"><p id="5df5" class="mp mq it bd mr ms mt mu mv mw mx md dk translated">深奥的ɛsəˈtɛrɪk非常不寻常，只有少数人理解或喜欢，尤其是那些有专门知识的人</p></blockquote><h1 id="c63d" class="my mz it bd na nb nc nd ne nf ng nh ni ki nj kj nk kl nl km nm ko nn kp no np bi translated">博戈索特</h1><p id="f3b7" class="pw-post-body-paragraph li lj it lk b ll nq kd ln lo nr kg lq lr ns lt lu lv nt lx ly lz nu mb mc md im bi translated">复杂度:O(n * n！)</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="bcf6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">经典的排序算法有许多别名，其中包括排列排序、愚蠢排序、慢速排序和猴子排序。</p><p id="5653" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">该算法的主要思想是随机打乱列表中的元素，直到它被排序。多亏了Python内置的<code class="fe nx ny nz oa b">random</code>模块，我们只用几行代码就可以实现它。与实现快速排序或合并排序相比，这无疑要容易得多。</p><p id="5e6a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这意味着有n个！可能的组合，并且因为对于每一次迭代，我们将花费O(n)时间来混洗列表，并且另外花费O(n)时间来检查列表是否被排序，我们最终得到O(n * n！)对于复杂性。</p><h1 id="9ca4" class="my mz it bd na nb nc nd ne nf ng nh ni ki ob kj nk kl oc km nm ko od kp no np bi translated">Bogobogosort</h1><p id="52b6" class="pw-post-body-paragraph li lj it lk b ll nq kd ln lo nr kg lq lr ns lt lu lv nt lx ly lz nu mb mc md im bi translated">复杂:O(我的天)</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="70f4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">Bogosort的高级变体。Bogobogosort认为最初的bogosort算法效率太高，这就是为什么它引入了额外的步骤，使算法更加复杂。</p><p id="0c67" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">Bogobogosort将使用bogosort对列表中的前两个元素进行排序，并继续向上排序，直到所有元素都排序完毕。在每个bogosort之后，它将检查下一个元素是否已经处于正确的顺序。如果顺序不正确，我们将列表随机化，并再次返回到前两个元素。</p><p id="7a2b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">要看原描述和详细分析，可以访问<a class="ae lh" href="https://www.dangermouse.net/esoteric/bogobogosort.html" rel="noopener ugc nofollow" target="_blank">这个页面</a>。</p><h1 id="68e8" class="my mz it bd na nb nc nd ne nf ng nh ni ki ob kj nk kl oc km nm ko od kp no np bi translated">量子Bogosort</h1><p id="9eca" class="pw-post-body-paragraph li lj it lk b ll nq kd ln lo nr kg lq lr ns lt lu lv nt lx ly lz nu mb mc md im bi translated">复杂度:O(n)</p><p id="3d8c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">也被称为<em class="mn">多元宇宙分类</em>，这是最终的博戈索特变异。不幸的是，我们找不到这种变化的Python代码，但这里有伪代码。(<a class="ae lh" href="http://wiki.c2.com/?QuantumBogoSort" rel="noopener ugc nofollow" target="_blank">来源</a>)</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="4380" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">理论上，创造n！宇宙分支的成本为O(1)。O(n)复杂度来自于检查列表是否排序。我们假设破坏包含未排序列表的宇宙的成本也是O(1)。</p><h1 id="e63b" class="my mz it bd na nb nc nd ne nf ng nh ni ki ob kj nk kl oc km nm ko od kp no np bi translated">奇迹排序</h1><p id="9caf" class="pw-post-body-paragraph li lj it lk b ll nq kd ln lo nr kg lq lr ns lt lu lv nt lx ly lz nu mb mc md im bi translated">复杂度:O(？？？)</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="9115" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">请看下面StackOverflow答案启发的排序算法。直接忽略讨论的标题，不相关。</p><div class="oe of gp gr og oh"><a href="https://stackoverflow.com/a/6947808" rel="noopener  ugc nofollow" target="_blank"><div class="oi ab fo"><div class="oj ab ok cl cj ol"><h2 class="bd jd gy z fp om fr fs on fu fw jc bi translated">还有比Bogosort(又名猴子排序)更糟糕的排序算法吗？</h2><div class="oo l"><h3 class="bd b gy z fp om fr fs on fu fw dk translated">问关闭。这个问题需要更加专注。它目前不接受回答。想改善这一点…</h3></div><div class="op l"><p class="bd b dl z fp om fr fs on fu fw dk translated">stackoverflow.com</p></div></div><div class="oq l"><div class="or l os ot ou oq ov lb oh"/></div></div></a></div><blockquote class="mo"><p id="365b" class="mp mq it bd mr ms ow ox oy oz pa md dk translated">"最终，阿尔法粒子翻转内存芯片中的位应该会导致成功的排序."</p></blockquote><p id="e5ff" class="pw-post-body-paragraph li lj it lk b ll pb kd ln lo pc kg lq lr pd lt lu lv pe lx ly lz pf mb mc md im bi translated">我为奇迹等待时间实现了一个<em class="mn">补偿</em>机制，以增加在检查列表是否排序之间奇迹发生的机会。</p><p id="3d92" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">使用上面的代码，我已经确认了这种排序算法确实有效。对于已经排序的列表，它在O(n)时间内返回。尽管如此，我仍然在等待未排序列表的奇迹。</p><p id="d83e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">专业提示:实际上你可以用某种祈祷来代替<code class="fe nx ny nz oa b">"Waiting for miracle..."</code>信息，称之为祈祷类。</p><h1 id="612c" class="my mz it bd na nb nc nd ne nf ng nh ni ki ob kj nk kl oc km nm ko od kp no np bi translated">斯大林式的</h1><p id="9b6b" class="pw-post-body-paragraph li lj it lk b ll nq kd ln lo nr kg lq lr ns lt lu lv nt lx ly lz nu mb mc md im bi translated">复杂度:O(n)</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="2737" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">啊，一种运行在O(n)中的高级排序算法，灵感来自非营利社交媒体乳齿象的这条“推特”。</p><div class="oe of gp gr og oh"><a href="https://mastodon.social/@mathew/100958177234287431" rel="noopener  ugc nofollow" target="_blank"><div class="oi ab fo"><div class="oj ab ok cl cj ol"><h2 class="bd jd gy z fp om fr fs on fu fw jc bi translated">马修·✅</h2><div class="oo l"><h3 class="bd b gy z fp om fr fs on fu fw dk translated">我想出了一个单程O(n)排序算法，我称之为斯大林排序。您向下迭代元素列表，检查是否…</h3></div><div class="op l"><p class="bd b dl z fp om fr fs on fu fw dk translated">乳齿象.社会</p></div></div><div class="oq l"><div class="pg l os ot ou oq ov lb oh"/></div></div></a></div><blockquote class="mo"><p id="e5e4" class="mp mq it bd mr ms ow ox oy oz pa md dk translated">“……任何无序的元素都将被删除……”</p></blockquote><p id="d71a" class="pw-post-body-paragraph li lj it lk b ll pb kd ln lo pc kg lq lr pd lt lu lv pe lx ly lz pf mb mc md im bi translated">该算法将遍历列表一次，并删除任何无序的元素—升序或降序。它将总是在O(n)时间内产生一个排序列表，尽管可能会丢失一些元素。</p><p id="4675" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">谢天谢地，有一个Stalin排序的<a class="ae lh" href="https://www.geeksforgeeks.org/add-elements-in-start-to-sort-the-array-variation-of-stalin-sort/" rel="noopener ugc nofollow" target="_blank">变体，它实际上将所有项目都保留在列表中。这个想法是把不按顺序的元素推到列表的前面，然后重复这个步骤，直到列表被排序。不幸的是，它没有运行O(n)时间，这意味着它比原来的斯大林排序差。</a></p><h1 id="ca2d" class="my mz it bd na nb nc nd ne nf ng nh ni ki ob kj nk kl oc km nm ko od kp no np bi translated">灭霸排序</h1><p id="6ea0" class="pw-post-body-paragraph li lj it lk b ll nq kd ln lo nr kg lq lr ns lt lu lv nt lx ly lz nu mb mc md im bi translated">复杂度:O(n log n)</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="09cc" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">一个比较现代的排序算法，灵感来自漫威的灭霸哲学。我们实现了一个名为<code class="fe nx ny nz oa b">snap()</code>的特殊函数来随机删除列表中的一半成员。</p><p id="4580" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这个想法是检查列表是否排序。如果没有，我们将抓取列表，然后再次检查列表是否已经排序。重复此操作，直到列表真正排序完毕。</p><p id="0a69" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">检查列表将花费O(n)时间，由于<code class="fe nx ny nz oa b">snap()</code>函数每次将元素减半，每次迭代将花费O(log n)时间。考虑到这两点，该算法的复杂度为O(n log n)。</p><p id="f8a5" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">灭霸排序的一种变体是真正的灭霸排序，在这种排序中，我们只进行一次<code class="fe nx ny nz oa b">snap()</code>函数调用，而不检查列表是否已排序。该操作将元素数量减半，有助于将来的排序。</p><h1 id="0e8f" class="my mz it bd na nb nc nd ne nf ng nh ni ki ob kj nk kl oc km nm ko od kp no np bi translated">智能设计排序</h1><p id="9b04" class="pw-post-body-paragraph li lj it lk b ll nq kd ln lo nr kg lq lr ns lt lu lv nt lx ly lz nu mb mc md im bi translated">复杂度:O(1)</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="99ed" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><a class="ae lh" href="http://wikipedia.org/wiki/Intelligent_design" rel="noopener ugc nofollow" target="_blank">智能设计</a>是一种信仰，认为造物主通过设计创造了宇宙内部的某些事物或事件。</p><p id="0184" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">假设列表中的所有元素都是唯一的，那么有n个！可能的组合，其中n是列表中元素的数量。这意味着当前顺序只出现在n中的1！案例。</p><p id="e2f3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">智能设计排序认为，这种情况意味着造物主以这样一种方式排序列表，它超越了我们对升序和降序的理解。</p><p id="f702" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">智能设计的其他命名和哲学变化如下。</p><ul class=""><li id="4783" class="ph pi it lk b ll lm lo lp lr pj lv pk lz pl md pm pn po pp bi translated"><strong class="lk jd">禅宗排序</strong>:当你意识到这个阵法，像所有的事物一样，是短暂的，它的顺序是无足轻重的，所以你就这样离开它，转而追求开悟。(<a class="ae lh" href="https://www.reddit.com/r/ProgrammerHumor/comments/9s9kgn/nononsense_sorting_algorithm/e8netnn?utm_source=share&amp;utm_medium=web2x&amp;context=3" rel="noopener ugc nofollow" target="_blank">来源</a>)</li><li id="158a" class="ph pi it lk b ll pq lo pr lr ps lv pt lz pu md pm pn po pp bi translated"><strong class="lk jd"> Trump Sort </strong>:数组总是排序的。任何不这么说的人都是假新闻。(<a class="ae lh" href="https://www.reddit.com/r/ProgrammerHumor/comments/9s9kgn/nononsense_sorting_algorithm/e8na95p?utm_source=share&amp;utm_medium=web2x&amp;context=3" rel="noopener ugc nofollow" target="_blank">来源</a>)</li></ul><h1 id="179a" class="my mz it bd na nb nc nd ne nf ng nh ni ki ob kj nk kl oc km nm ko od kp no np bi translated">睡眠排序</h1><p id="b70c" class="pw-post-body-paragraph li lj it lk b ll nq kd ln lo nr kg lq lr ns lt lu lv nt lx ly lz nu mb mc md im bi translated">复杂度:O(最大(输入)+ n)</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="b314" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">另一个经典的臭名昭著的排序算法。主要思想是通过将值分配给睡眠定时器来对列表进行排序。当计时器结束时，它会将值添加到结果列表中。</p><p id="43cf" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">较大的值将具有较长的睡眠计时器，因此它们将被添加到较小的值之后，从而产生一个按升序排序的列表。如果我们需要一个降序列表，我们可以使用<code class="fe nx ny nz oa b">result[::-1]</code>简单地颠倒列表顺序</p><p id="dfaf" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">缺点是这只适用于数字列表。哦，如果你试图对非常大的数字进行排序，它也可以运行好几年。</p><h1 id="5d23" class="my mz it bd na nb nc nd ne nf ng nh ni ki ob kj nk kl oc km nm ko od kp no np bi translated">堆栈排序</h1><p id="3842" class="pw-post-body-paragraph li lj it lk b ll nq kd ln lo nr kg lq lr ns lt lu lv nt lx ly lz nu mb mc md im bi translated">复杂度:O(取决于)</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pv"><img src="../Images/6cd92ac0b3001e7a0fbfb6254565b808.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0y3uFPrWFO1GZCl6oCQY1g.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">作者<a class="ae lh" href="https://gkoberger.github.io/stacksort/" rel="noopener ugc nofollow" target="_blank">https://gkoberger.github.io/stacksort/</a>截图</p></figure><p id="d891" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">没有，这个没有代码，但是你可以访问<a class="ae lh" href="https://gkoberger.github.io/stacksort/" rel="noopener ugc nofollow" target="_blank">这个页面</a>自己试试。现在，你可能会认为这个算法以某种方式使用了一个堆栈来根据元素的名称对元素进行排序。这是不正确的。</p><p id="c566" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">名称中的Stack是StackOverflow的简称。是的，没错，堆栈排序会随机抓取带有<code class="fe nx ny nz oa b">javascript</code>和<code class="fe nx ny nz oa b">sort</code>标签的StackOverflow问题的顶部答案</p><p id="ea18" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果你访问<a class="ae lh" href="https://gkoberger.github.io/stacksort/" rel="noopener ugc nofollow" target="_blank">堆栈排序页面</a>，它会尝试从StackOverflow答案中提取一个函数，编译它，然后尝试用那个函数对输入进行排序。最精彩的部分？你不需要编码，它会告诉你实际使用的是哪个答案。</p><p id="32ab" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">复杂程度取决于你对爬虫的运气。我很幸运地使用<a class="ae lh" href="https://stackoverflow.com/questions/3730510/javascript-sort-array-and-return-an-array-of-indices-that-indicates-the-positio#3730579" rel="noopener ugc nofollow" target="_blank">这个答案</a>和<a class="ae lh" href="http://stackoverflow.com/questions/3579486/#3579651" rel="noopener ugc nofollow" target="_blank">另一个答案</a>成功排序，尽管后者返回的是字符串列表而不是整数列表。一些代码成功编译，但仍然无法排序。</p></div><div class="ab cl pw px hx py" role="separator"><span class="pz bw bk qa qb qc"/><span class="pz bw bk qa qb qc"/><span class="pz bw bk qa qb"/></div><div class="im in io ip iq"><p id="f855" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><em class="mn">代码？是一系列与数据科学和编程相关的幽默。它们可能对你的日常工作没什么用，但它们可能会让你微笑。</em> <a class="ae lh" href="https://chandraseta.medium.com/subscribe" rel="noopener"> <em class="mn">定期更新</em> </a> <em class="mn">新故事和</em> <a class="ae lh" href="https://chandraseta.medium.com/membership" rel="noopener"> <em class="mn">成为中等会员</em> </a> <em class="mn">阅读无限故事。</em></p><div class="oe of gp gr og oh"><a href="https://chandraseta.medium.com/membership" rel="noopener follow" target="_blank"><div class="oi ab fo"><div class="oj ab ok cl cj ol"><h2 class="bd jd gy z fp om fr fs on fu fw jc bi translated">成为媒体成员—里奥纳尔迪·钱德拉塞塔</h2><div class="oo l"><h3 class="bd b gy z fp om fr fs on fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事</h3></div><div class="op l"><p class="bd b dl z fp om fr fs on fu fw dk translated">chandraseta.medium.com</p></div></div><div class="oq l"><div class="qd l os ot ou oq ov lb oh"/></div></div></a></div></div></div>    
</body>
</html>