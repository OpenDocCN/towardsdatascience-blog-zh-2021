<html>
<head>
<title>LSTM for Predictive Maintenance on Pump Sensor Data</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用于泵传感器数据预测性维护的LSTM</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/lstm-for-predictive-maintenance-on-pump-sensor-data-b43486eb3210?source=collection_archive---------0-----------------------#2021-08-10">https://towardsdatascience.com/lstm-for-predictive-maintenance-on-pump-sensor-data-b43486eb3210?source=collection_archive---------0-----------------------#2021-08-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="38ed" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">在本文中，我们希望通过一些时间序列分析来解释预测性维护案例中的思维过程</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/f3a148f60c57b20086d1f18eb5d15df3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JFjPaBMk8UB2TcJkt2W4LA.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">坎凯奥·维莱辛在<a class="ae kv" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h1 id="e532" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">内容列表</h1><p id="adc0" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated"><strong class="lq ir">前提<br/>介绍<br/>数据</strong> <br/> —整体第一眼<br/> —目标数据(y) <br/> <strong class="lq ir">清理数据<br/> </strong> —移除nan<br/><strong class="lq ir">进一步选项</strong> <br/> —异常值移除<br/> —特征工程<br/> —特征选择<br/> <strong class="lq ir">为LSTM准备数据<br/> </strong> —创建时间序列<br/> —将数据拆分为训练验证测试集<br/> —标准化/规范化数据<br/> —使用简单的LSTM <br/> 对<br/> <strong class="lq ir">进行整形和一次性编码——T30】</strong></p></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="d486" class="kw kx iq bd ky kz mr lb lc ld ms lf lg jw mt jx li jz mu ka lk kc mv kd lm ln bi translated">先决条件</h1><p id="8777" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">所有代码都可以在<a class="ae kv" href="https://github.com/JanderHungrige/PumpSensor" rel="noopener ugc nofollow" target="_blank">这个Git-repo </a>中找到<br/>要重新创建这篇文章，你可以在这里找到<a class="ae kv" href="https://ga-data-cases.s3.eu-central-1.amazonaws.com/pump_sensor.zip" rel="noopener ugc nofollow" target="_blank">数据集</a></p><p id="ed11" class="pw-post-body-paragraph lo lp iq lq b lr mw jr lt lu mx ju lw lx my lz ma mb mz md me mf na mh mi mj ij bi translated">我建议使用<a class="ae kv" href="https://www.anaconda.com/" rel="noopener ugc nofollow" target="_blank"> anaconda </a>创建一个Python 3.6环境并安装Python包:</p><p id="5c2b" class="pw-post-body-paragraph lo lp iq lq b lr mw jr lt lu mx ju lw lx my lz ma mb mz md me mf na mh mi mj ij bi translated">tensor flow(pip install tensor flow)<br/>Pandas(pip install Pandas)<br/>Numpy pip install Numpy)<br/>Scikit-learn(pip install Scikit-learn)<br/>Matplotlib(pip install Matplotlib)</p></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="1cd3" class="kw kx iq bd ky kz mr lb lc ld ms lf lg jw mt jx li jz mu ka lk kc mv kd lm ln bi translated">介绍</h1><p id="9c87" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">在本文中，我们将探讨泵传感器数据的预测性维护。我们的方法对于时间序列分析来说是非常通用的，即使在你自己的项目中每一步看起来都有细微的不同。这个想法是给你一个关于一般思维过程的想法，以及你将如何解决这样一个问题。关于步骤的完整概述，请参见文章末尾的图(可能在阅读时并行打开)。它应该有助于按逻辑顺序组织所有步骤。如果你有一个类似的项目，并且只是在寻找一个演练，你可以在Github 上查看<a class="ae kv" href="https://github.com/JanderHungrige/PumpSensor" rel="noopener ugc nofollow" target="_blank">代码，并根据你的需要进行修改。</a></p><p id="a8a7" class="pw-post-body-paragraph lo lp iq lq b lr mw jr lt lu mx ju lw lx my lz ma mb mz md me mf na mh mi mj ij bi translated">限制文章篇幅，当然很多点只是提一下，不深究。但是，我们指出细节上的相关文章。我们希望给出的信息能帮助你理解时间序列分析的一般方法。</p><h1 id="4ab4" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">数据</h1><h2 id="6a77" class="nb kx iq bd ky nc nd dn lc ne nf dp lg lx ng nh li mb ni nj lk mf nk nl lm nm bi translated">第一眼</h2><blockquote class="nn no np"><p id="263d" class="lo lp nq lq b lr mw jr lt lu mx ju lw nr my lz ma ns mz md me nt na mh mi mj ij bi translated">我们首先检查数据的总体情况。我们面前是什么？我们有多少数据？数据是如何组织的？每一部分都是什么类型的数据？</p></blockquote><p id="3a43" class="pw-post-body-paragraph lo lp iq lq b lr mw jr lt lu mx ju lw lx my lz ma mb mz md me mf na mh mi mj ij bi translated">因此，我们用pandas中的一行来读取数据，并通过简单的打印语句来获得一些概述。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nu nv l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">按作者</p></figure><p id="b85e" class="pw-post-body-paragraph lo lp iq lq b lr mw jr lt lu mx ju lw lx my lz ma mb mz md me mf na mh mi mj ij bi translated">从这些照片中，我们可以得出以下信息:</p><p id="bbc8" class="pw-post-body-paragraph lo lp iq lq b lr mw jr lt lu mx ju lw lx my lz ma mb mz md me mf na mh mi mj ij bi translated">CSV文件包含55列，每列超过200K个条目。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nw"><img src="../Images/10885bbfc8ecbb6f31ff91d4d636ccc4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1190/format:webp/1*MrgLGXvv3aB9UkP0ZolGIg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">按作者</p></figure><p id="6120" class="pw-post-body-paragraph lo lp iq lq b lr mw jr lt lu mx ju lw lx my lz ma mb mz md me mf na mh mi mj ij bi translated">数据被分成52个<em class="nq">传感器</em>列、一个<em class="nq">机器状态</em>(目标/结果)列、一个<em class="nq">时间戳</em>列和一个<em class="nq">未命名</em>列，后者只是原始索引列。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/7447cdb22c7962dcbd539d0fe86a16e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1184/format:webp/1*4ZjusrC0adBURQ28KpFZMg.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">按作者</p></figure><p id="86aa" class="pw-post-body-paragraph lo lp iq lq b lr mw jr lt lu mx ju lw lx my lz ma mb mz md me mf na mh mi mj ij bi translated">从时间戳中，我们可以看到数据是以1分钟为单位记录的。快速浏览一下，我们会发现传感器数据是float32格式，具有不同的幅度，时间戳是yyyy-MM-dd HH:mm:ss格式。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ny"><img src="../Images/af7a5bc7632943ccafb4b9f073d801d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1182/format:webp/1*V4sHaIH27aCS9J4y8p9uMw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">按作者</p></figure><h2 id="3d58" class="nb kx iq bd ky nc nd dn lc ne nf dp lg lx ng nh li mb ni nj lk mf nk nl lm nm bi translated">目标数据(y)</h2><blockquote class="nn no np"><p id="a15e" class="lo lp nq lq b lr mw jr lt lu mx ju lw nr my lz ma ns mz md me nt na mh mi mj ij bi translated">下面，在第一眼之后，对我来说第二重要的事情就是看一眼目标数据(y数据/结果)。这将为解决方案策略提供一些指示。</p></blockquote><p id="9b4e" class="pw-post-body-paragraph lo lp iq lq b lr mw jr lt lu mx ju lw lx my lz ma mb mz md me mf na mh mi mj ij bi translated">现在，在第一次浏览数据后，我们必须检查提供了什么结果(称为目标),我们稍后可以使用这些结果来确定/定义我们的预测性维护目标/路径。在键入代码以提取目标数据时，我会问自己一些问题</p><ul class=""><li id="e597" class="nz oa iq lq b lr mw lu mx lx ob mb oc mf od mj oe of og oh bi translated"><em class="nq">我们是否有目标信息，或者这将是一项无人监管的任务？</em></li><li id="9cc8" class="nz oa iq lq b lr oi lu oj lx ok mb ol mf om mj oe of og oh bi translated"><em class="nq">目标数据是连续数据还是布尔值？</em></li><li id="adb0" class="nz oa iq lq b lr oi lu oj lx ok mb ol mf om mj oe of og oh bi translated"><em class="nq">目标是什么数据类型？值，文本，… </em></li><li id="09b6" class="nz oa iq lq b lr oi lu oj lx ok mb ol mf om mj oe of og oh bi translated"><em class="nq">目标以什么间隔记录？每个传感器条目都有一个条目，还是被分组？</em></li><li id="aa36" class="nz oa iq lq b lr oi lu oj lx ok mb ol mf om mj oe of og oh bi translated"><em class="nq">是每个传感器都有自己的目标(一台机器—一个传感器)，还是所有传感器都有一个目标(一台机器—多个传感器)？</em></li><li id="389a" class="nz oa iq lq b lr oi lu oj lx ok mb ol mf om mj oe of og oh bi translated"><em class="nq">目标是描述性的，还是我们必须确定哪些是不符合标准的，哪些是正常的？</em></li><li id="9bd8" class="nz oa iq lq b lr oi lu oj lx ok mb ol mf om mj oe of og oh bi translated"><em class="nq">目标信息是否完整有用？</em></li><li id="e07b" class="nz oa iq lq b lr oi lu oj lx ok mb ol mf om mj oe of og oh bi">…</li></ul><p id="cfe8" class="pw-post-body-paragraph lo lp iq lq b lr mw jr lt lu mx ju lw lx my lz ma mb mz md me mf na mh mi mj ij bi translated">为了得到一些答案，我们将得到唯一的类，看看每个类有多少个值。发现标签是char格式(文本),我们知道，我们必须在某个时候将它们转换成整数值，以便我们以后的Ml算法使用。要将它们转换成相应的整数值，可以使用scikit-learn中的mapper函数。如果您有映射的目标，我们应该绘制它，以了解何时发生了什么。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nu nv l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">获取目标数据的信息[来自作者]</p></figure><p id="54fe" class="pw-post-body-paragraph lo lp iq lq b lr mw jr lt lu mx ju lw lx my lz ma mb mz md me mf na mh mi mj ij bi translated">因此，我们看到，数据集中有三个类。如前所述，它们是文本形式的，已经给了我们一个很好的提示。在其他情况下，您可能只会收到一个状态[A、B、C]或类似的状态。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi on"><img src="../Images/505b6f44b3f93cbc12830290c52f0dcc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1172/format:webp/1*fwFWAYu3LOtaFg3NHhFNSQ.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">可用的类[来自作者]</p></figure><p id="92f9" class="pw-post-body-paragraph lo lp iq lq b lr mw jr lt lu mx ju lw lx my lz ma mb mz md me mf na mh mi mj ij bi translated">在对每个类中的值进行计数后，我们看到大多数类为"<em class="nq"> Normal </em>"，这是意料之中的，因为机器应该在大多数时间正常运行。<em class="nq">恢复</em>、<em class="nq">破碎</em>班为少数民族班。我们直接看到，我们最有可能无法使用中断的类，因为七个值不足以学习任何模式。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/7b60567e0aa1f616aafb49324dd49ff6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1198/format:webp/1*kadmHdDf2BpLki6lqH6DAg.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">每个类的值的数量[按作者]</p></figure><p id="72f5" class="pw-post-body-paragraph lo lp iq lq b lr mw jr lt lu mx ju lw lx my lz ma mb mz md me mf na mh mi mj ij bi translated">我们还看到，通过对这些值进行合计，我们得到了与现有行相同的数量。这意味着目标数据中没有缺失值(NaN)(当然也可以用<em class="nq"> isna() </em>函数来检查)。</p><p id="df57" class="pw-post-body-paragraph lo lp iq lq b lr mw jr lt lu mx ju lw lx my lz ma mb mz md me mf na mh mi mj ij bi translated">目标的曲线向我们显示，故障部分并不在例如末端处聚集，而是分散在整个数据长度上。这对于以后分割成训练集和测试集是很有趣的。我们还看到，<em class="nq">恢复</em>类总是跟随<em class="nq">损坏</em>类。这意味着只有7个条目的<em class="nq">损坏的</em>类不成问题，因为我们只需预测恢复阶段就能得到<em class="nq">损坏的</em>类。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi op"><img src="../Images/410dc6c3516039ebafe9eadc6a11fec4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ur9H7JsK6zTCzKeRYLIJow.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">目标数据[按作者]</p></figure><p id="905d" class="pw-post-body-paragraph lo lp iq lq b lr mw jr lt lu mx ju lw lx my lz ma mb mz md me mf na mh mi mj ij bi translated">为了回答一些早期的想法:我们有良好和完整的目标数据。每一行都有一个条目，这就形成了一个单机:多传感器的监督学习任务。</p><h2 id="cc54" class="nb kx iq bd ky nc nd dn lc ne nf dp lg lx ng nh li mb ni nj lk mf nk nl lm nm bi translated">清理数据</h2><blockquote class="nn no np"><p id="92eb" class="lo lp nq lq b lr mw jr lt lu mx ju lw nr my lz ma ns mz md me nt na mh mi mj ij bi translated">既然我们理解了数据，我们将不得不寻找传感器数据的质量，并且最有可能操纵/修复/增加数据以用于以后的训练。</p></blockquote><h2 id="5f9c" class="nb kx iq bd ky nc nd dn lc ne nf dp lg lx ng nh li mb ni nj lk mf nk nl lm nm bi translated">移除NaNs</h2><p id="02d0" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">数据清理的第一步是检查NaN值。因此，在某些情况下，传感器不会发送任何数据。不要与零值混淆，零值实际上可能意味着值为零(数据集中的大量零使其成为稀疏数据集)。这些问题是</p><ul class=""><li id="c2db" class="nz oa iq lq b lr mw lu mx lx ob mb oc mf od mj oe of og oh bi translated"><em class="nq">有多少数据是NaN的？</em></li><li id="e0d2" class="nz oa iq lq b lr oi lu oj lx ok mb ol mf om mj oe of og oh bi translated"><em class="nq">是只有少数传感器，还是大部分都有nan？</em></li><li id="8647" class="nz oa iq lq b lr oi lu oj lx ok mb ol mf om mj oe of og oh bi translated"><em class="nq">是否有些传感器的nan比其他传感器多得多？</em></li><li id="09fa" class="nz oa iq lq b lr oi lu oj lx ok mb ol mf om mj oe of og oh bi translated">NaNs是聚集在一起还是分散开来？</li><li id="6e38" class="nz oa iq lq b lr oi lu oj lx ok mb ol mf om mj oe of og oh bi translated">我们可以填充nan还是必须删除它们？</li></ul><p id="a67f" class="pw-post-body-paragraph lo lp iq lq b lr mw jr lt lu mx ju lw lx my lz ma mb mz md me mf na mh mi mj ij bi translated">所以我们首先检查、打印和绘制它们。我们马上注意到，<em class="nq"> Sensor_15 </em>完全是空的，因此我们将他移除以更好地缩放数据。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oq"><img src="../Images/6e8327cca782604f1685f01f15f8249f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AJZIfRrS_8fiGhPrp-r1ng.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">显示NaNs，传感器掉落_ 15[作者]</p></figure><p id="def2" class="pw-post-body-paragraph lo lp iq lq b lr mw jr lt lu mx ju lw lx my lz ma mb mz md me mf na mh mi mj ij bi translated">我们现在可以简单地从数据中删除所有的nan，但是，我们会丢失大约77000个时间步长，大约是35%。因此，我们尝试逐个传感器地移除尽可能多的NaNs传感器。</p><p id="2544" class="pw-post-body-paragraph lo lp iq lq b lr mw jr lt lu mx ju lw lx my lz ma mb mz md me mf na mh mi mj ij bi translated">如果我们看看NaNs的第二大持有者，我们会看到传感器50和51。我们可以看到几样东西。首先，传感器50只是在某个点失效。因此我们将移除传感器50。这里的另一个选项是从时间步长~140000年起删除所有传感器的所有数据…所以这不是一个真正的选项(在其他情况下，这可能是唯一的选项)。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi or"><img src="../Images/5851a79632e0e15709d9bba2f5b75a27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oP1vaEw-SD0qP7JgC6LHrQ.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">比较sensor_50和sensor _ 51[作者]</p></figure><p id="b90b" class="pw-post-body-paragraph lo lp iq lq b lr mw jr lt lu mx ju lw lx my lz ma mb mz md me mf na mh mi mj ij bi translated">第二，两个传感器具有非常相似的振幅和值范围。更有甚者，黄色标注的部分其实非常相似。我们在其他传感器(见下文)中看到，几乎所有传感器都出现了140000点的下降。传感器51似乎也在其数据间隙后立即显示这种下降。因此，我们决定用50来修复51。不是最干净的方式，但绝对有可能。</p><p id="5655" class="pw-post-body-paragraph lo lp iq lq b lr mw jr lt lu mx ju lw lx my lz ma mb mz md me mf na mh mi mj ij bi translated">删除sensor_50后，我们看到sensor_00和06–09之间的传感器显示大多数nan。现在是检查方差的好时机，方差显示了信号从其自身的平均值得到了多少。意思是，这个信号以任何方式移动吗？如果我们想检测一个趋势或类的变化，如果信号显示方差是好的。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi os"><img src="../Images/bbd0db456501580196d35c57de902993.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uVkkeW88snsOkzUlNOYW_Q.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">传感器和传感器数据的差异[作者]</p></figure><p id="3bc7" class="pw-post-body-paragraph lo lp iq lq b lr mw jr lt lu mx ju lw lx my lz ma mb mz md me mf na mh mi mj ij bi translated">正如我们在标记部分看到的，传感器00、06–09没有显示出很大的差异。因此，我们允许我们删除这些，因为我们认为它们不会增加足够多的有价值的信息，与我们丢失的总信号数量相比。</p><p id="8281" class="pw-post-body-paragraph lo lp iq lq b lr mw jr lt lu mx ju lw lx my lz ma mb mz md me mf na mh mi mj ij bi translated">跌落后，剩余的传感器确实显示一些nan。现在我们尝试通过将限制设置为30的<em class="nq"> fillna() </em>函数来填充它们。也就是说，最多填充30个连续的NaN值。这导致两个传感器剩下大约200纳。最后，我们只是删除那些，因为它只代表0.09%。</p><p id="3517" class="pw-post-body-paragraph lo lp iq lq b lr mw jr lt lu mx ju lw lx my lz ma mb mz md me mf na mh mi mj ij bi translated"><em class="nq">旁注:</em> <a class="ae kv" href="https://stackoverflow.com/questions/41190852/most-efficient-way-to-forward-fill-nan-values-in-numpy-array" rel="noopener ugc nofollow" target="_blank"> <em class="nq">这里有一个不错的Stackoverflow讨论</em> </a> <em class="nq">关于如何最有效地填充NaNs。</em></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ot"><img src="../Images/d405b1c5a0e3fa53aa8c9cb4416cc7bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PIFVQWJ8NBDCzXxY32aNXQ.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">填充连续的NaNs按作者]</p></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nu nv l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">移除NaNs[来自作者]</p></figure><h1 id="40ff" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">更多选项</h1><blockquote class="nn no np"><p id="2b07" class="lo lp nq lq b lr mw jr lt lu mx ju lw nr my lz ma ns mz md me nt na mh mi mj ij bi translated">你总是可以做更多的准备。为了进行概念验证，我建议继续使用NaN免费数据，并在建立基线模型性能后再回来进行进一步的数据预处理。</p></blockquote><p id="fe29" class="pw-post-body-paragraph lo lp iq lq b lr mw jr lt lu mx ju lw lx my lz ma mb mz md me mf na mh mi mj ij bi translated">现在，被机器学习使用的第一步完成了。最基本的是，这些数据可以被读取并用于训练机器学习网络。然而，对于一个良好运行的解决方案来说，有更多的选项可以优化，包括所需的数据拆分和后期的缩放。</p><p id="d9eb" class="pw-post-body-paragraph lo lp iq lq b lr mw jr lt lu mx ju lw lx my lz ma mb mz md me mf na mh mi mj ij bi translated">进一步优化的最常见步骤是:</p><ul class=""><li id="7c73" class="nz oa iq lq b lr mw lu mx lx ob mb oc mf od mj oe of og oh bi translated">异常值去除/噪声降低</li><li id="8976" class="nz oa iq lq b lr oi lu oj lx ok mb ol mf om mj oe of og oh bi translated">特征工程</li><li id="8430" class="nz oa iq lq b lr oi lu oj lx ok mb ol mf om mj oe of og oh bi translated">特征选择</li></ul><p id="b1ee" class="pw-post-body-paragraph lo lp iq lq b lr mw jr lt lu mx ju lw lx my lz ma mb mz md me mf na mh mi mj ij bi translated">在简短地探讨了这个话题之后，我们将继续讨论实际状态下的信号。第一个目标应该是获得一个运行中的概念证明 (POC)。优化应该随后进行，继续信号清理、特征创建等。一切正常。</p><h2 id="920e" class="nb kx iq bd ky nc nd dn lc ne nf dp lg lx ng nh li mb ni nj lk mf nk nl lm nm bi translated">异常值去除/噪声降低</h2><p id="922d" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">离群点去除意味着识别和去除对模式识别没有贡献或者甚至扰乱算法的信号部分。这可以通过不同的已经建立的算法来完成。在下面的文章中可以找到一个很好的概述:</p><div class="ou ov gp gr ow ox"><a rel="noopener follow" target="_blank" href="/ways-to-detect-and-remove-the-outliers-404d16608dba"><div class="oy ab fo"><div class="oz ab pa cl cj pb"><h2 class="bd ir gy z fp pc fr fs pd fu fw ip bi translated">检测和移除异常值的方法</h2><div class="pe l"><h3 class="bd b gy z fp pc fr fs pd fu fw dk translated">在从事数据科学项目时，你在寻找什么？EDA最重要的部分是什么…</h3></div><div class="pf l"><p class="bd b dl z fp pc fr fs pd fu fw dk translated">towardsdatascience.com</p></div></div><div class="pg l"><div class="ph l pi pj pk pg pl kp ox"/></div></div></a></div><p id="fbc4" class="pw-post-body-paragraph lo lp iq lq b lr mw jr lt lu mx ju lw lx my lz ma mb mz md me mf na mh mi mj ij bi translated">需要记住的一点是，除了降噪之外，异常值的去除是信号的这些部分实际上可能是有价值的信息。因此，盲目地忽略它们并自动移除异常值和噪声可能不会破坏您的算法，但可能会降低其性能。这尤其适用于降噪。匆忙执行降噪会威胁到您的分析。</p><p id="c52f" class="pw-post-body-paragraph lo lp iq lq b lr mw jr lt lu mx ju lw lx my lz ma mb mz md me mf na mh mi mj ij bi translated">提高信噪比的一般方法是移动平均或卡尔曼滤波策略。</p><h2 id="f866" class="nb kx iq bd ky nc nd dn lc ne nf dp lg lx ng nh li mb ni nj lk mf nk nl lm nm bi translated">特征工程</h2><p id="4498" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">在我们的例子中，我们可以直接使用信号传感器信号作为特征输入。然而，如果您的问题更复杂，信号不稳定、有噪声且高度不稳定，那么您需要利用您对该问题的了解。这种知识，或通常良好的工程特征，通常会导致更好的模型性能。不同的表述，好的特征减少了完美模型的必要性。</p><p id="024f" class="pw-post-body-paragraph lo lp iq lq b lr mw jr lt lu mx ju lw lx my lz ma mb mz md me mf na mh mi mj ij bi translated">这个话题是另一篇文章的内容，因此我们不会深入讨论，但会给你一篇由<em class="nq">杰森·布朗利写的很棒的文章:</em></p><div class="ou ov gp gr ow ox"><a href="https://machinelearningmastery.com/discover-feature-engineering-how-to-engineer-features-and-how-to-get-good-at-it/" rel="noopener  ugc nofollow" target="_blank"><div class="oy ab fo"><div class="oz ab pa cl cj pb"><h2 class="bd ir gy z fp pc fr fs pd fu fw ip bi translated">发现特征工程，如何工程化特征以及如何擅长它-机器学习…</h2><div class="pe l"><h3 class="bd b gy z fp pc fr fs pd fu fw dk translated">特征工程是一个非正式的话题，但绝对是众所周知的，并同意是成功的关键应用…</h3></div><div class="pf l"><p class="bd b dl z fp pc fr fs pd fu fw dk translated">machinelearningmastery.com</p></div></div><div class="pg l"><div class="pm l pi pj pk pg pl kp ox"/></div></div></a></div><h2 id="4e80" class="nb kx iq bd ky nc nd dn lc ne nf dp lg lx ng nh li mb ni nj lk mf nk nl lm nm bi translated">特征选择</h2><p id="5e75" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">此外，这个主题本身需要一篇文章，我们将简要解释关于我们的数据集的几点，并指出更多由<em class="nq">杰森·布朗利</em>撰写的文献供您深入研究。</p><div class="ou ov gp gr ow ox"><a href="https://machinelearningmastery.com/feature-selection-with-optimization/" rel="noopener  ugc nofollow" target="_blank"><div class="oy ab fo"><div class="oz ab pa cl cj pb"><h2 class="bd ir gy z fp pc fr fs pd fu fw ip bi translated">基于随机优化算法的特征选择——机器学习掌握</h2><div class="pe l"><h3 class="bd b gy z fp pc fr fs pd fu fw dk translated">通常，可以通过移除输入特征(列)来开发更简单、性能更好的机器学习模型…</h3></div><div class="pf l"><p class="bd b dl z fp pc fr fs pd fu fw dk translated">machinelearningmastery.com</p></div></div><div class="pg l"><div class="pn l pi pj pk pg pl kp ox"/></div></div></a></div><p id="f139" class="pw-post-body-paragraph lo lp iq lq b lr mw jr lt lu mx ju lw lx my lz ma mb mz md me mf na mh mi mj ij bi translated">特征选择已经完成，因为冗余数据、坏数据或无信息数据会阻碍而不是提高你的机器学习性能。我们总是认为，数据越多越好，但更准确地说应该是:<em class="nq">好特性的数据越多越好。<br/> </em>通过特征选择，我们帮助算法预先整理出哪个特征会加入来解决问题。</p><p id="77c0" class="pw-post-body-paragraph lo lp iq lq b lr mw jr lt lu mx ju lw lx my lz ma mb mz md me mf na mh mi mj ij bi translated"><strong class="lq ir"> <em class="nq">一个经验法则是</em> </strong> <em class="nq">，像K-NN这样越简单的算法越能从特征选择中受益，否则它将很难从冗余特征中分离出有意义的特征(淹没在特征中)。更复杂的算法，如随机森林和人工神经网络，能够找到自己的最佳特征。这里，我们“只是”通过先前的特征选择来减少计算量。</em></p><p id="8b26" class="pw-post-body-paragraph lo lp iq lq b lr mw jr lt lu mx ju lw lx my lz ma mb mz md me mf na mh mi mj ij bi translated">只是提一下，正则化在某些情况下可以代替特征选择。关于L1正则化和特征选择的有趣讨论可以在<a class="ae kv" href="https://stats.stackexchange.com/questions/149446/do-we-still-need-to-do-feature-selection-while-using-regularization-algorithms" rel="noopener ugc nofollow" target="_blank">这里</a>找到。好的描述可以看<a class="ae kv" href="https://jermwatt.github.io/machine_learning_refined/notes/9_Feature_engineer_select/9_7_Regularization.html" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><p id="c2e4" class="pw-post-body-paragraph lo lp iq lq b lr mw jr lt lu mx ju lw lx my lz ma mb mz md me mf na mh mi mj ij bi translated">当查看我们所有的传感器时，我们可以看到有几组传感器看起来非常相似(在下图中按颜色分组)。这意味着通过相关方法或主成分分析(PCA)减少输入传感器将会很好地工作。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi po"><img src="../Images/be58a466b048be9f7d57d5bb7426b21b.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/1*0MD732MJgDwVyp3OyT3Gtw.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">分组传感器信号[按作者]</p></figure><h1 id="8fc9" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">训练模型</h1><p id="507d" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">由于数据是基数准备的，我们现在可以选择一种算法类型来解决预测问题。根据数据量、问题的复杂性、最终运行的硬件以及其他考虑因素，您可以在不同的算法之间进行选择。</p><p id="6098" class="pw-post-body-paragraph lo lp iq lq b lr mw jr lt lu mx ju lw lx my lz ma mb mz md me mf na mh mi mj ij bi translated">由于我们没有进行特征选择，我们应该使用随机森林分类器/预测器或一种人工神经网络，因为两者都作为集成的特征选择器工作。</p><p id="43e5" class="pw-post-body-paragraph lo lp iq lq b lr mw jr lt lu mx ju lw lx my lz ma mb mz md me mf na mh mi mj ij bi translated">我们选择了一个LSTM来测试它在嵌入式硬件上的支持。</p><h1 id="f5c1" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">为LSTM准备数据</h1><blockquote class="nn no np"><p id="67de" class="lo lp nq lq b lr mw jr lt lu mx ju lw nr my lz ma ns mz md me nt na mh mi mj ij bi translated">选择预测方法后，必须再次准备数据以适合特定的方法。经典的ML和ann数据准备基本相似，但在小细节上有所不同(如输入维度)。</p></blockquote><h2 id="4ba2" class="nb kx iq bd ky nc nd dn lc ne nf dp lg lx ng nh li mb ni nj lk mf nk nl lm nm bi translated">创建时间序列</h2><p id="5e40" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">当前形式的数据可用于训练实际类的分类器。但是，我们希望根据实际值来预测未来的类。因此，我们需要根据目标来移动数据，以创建一个时间间隔。在此再次感谢<em class="nq">杰森·布朗利</em>关于这个话题的<a class="ae kv" href="https://machinelearningmastery.com/convert-time-series-supervised-learning-problem-python/" rel="noopener ugc nofollow" target="_blank">精彩文章。</a></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pp"><img src="../Images/f7e4cb9569880fed49a15b3daa6fa28c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KQCRJrJZae64BC9YGHbTAw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">移位x[作者]</p></figure><p id="1d4c" class="pw-post-body-paragraph lo lp iq lq b lr mw jr lt lu mx ju lw lx my lz ma mb mz md me mf na mh mi mj ij bi translated">下面的代码逐块显示:</p><ul class=""><li id="b500" class="nz oa iq lq b lr mw lu mx lx ob mb oc mf od mj oe of og oh bi translated"><strong class="lq ir"> n_in </strong>:预测多少时间步。<strong class="lq ir"> n_out </strong>:用n_in预测多少个目标。<strong class="lq ir"> n_out &gt; 1 </strong>表示预测一系列目标值。两者都可以用来展望未来。我们这里只用n_out=1。</li><li id="040c" class="nz oa iq lq b lr oi lu oj lx ok mb ol mf om mj oe of og oh bi translated"><strong class="lq ir">第6–7行</strong>，根据n_in量产生移位输入。因此，如果例如n_in=3，那么对于剩余的46个传感器中的每一个，在数据帧中创建3个移位信号和相应的名称。</li><li id="a763" class="nz oa iq lq b lr oi lu oj lx ok mb ol mf om mj oe of og oh bi translated"><strong class="lq ir">第10–15行</strong>，向前移动创建一个目标序列。</li><li id="0132" class="nz oa iq lq b lr oi lu oj lx ok mb ol mf om mj oe of og oh bi translated"><strong class="lq ir">第17–18行</strong>，将所有内容组合在一个数据帧中</li><li id="877a" class="nz oa iq lq b lr oi lu oj lx ok mb ol mf om mj oe of og oh bi translated"><strong class="lq ir">第20–22行</strong>，删除轮班产生的nan</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nu nv l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">为时间序列预测创建移位信号[作者]</p></figure><p id="0960" class="pw-post-body-paragraph lo lp iq lq b lr mw jr lt lu mx ju lw lx my lz ma mb mz md me mf na mh mi mj ij bi translated">该函数返回一个包含原始值和移位值的数据帧(如下图所示)。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pq"><img src="../Images/d94376c810bb60275ffa687933f23d9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DSW1CCLObWLIMry1RQpDIA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">带有x(t)和x(t-1)的数据帧[作者]</p></figure><p id="75bc" class="pw-post-body-paragraph lo lp iq lq b lr mw jr lt lu mx ju lw lx my lz ma mb mz md me mf na mh mi mj ij bi translated">我们现在必须删除我们不想要的价值观。在我们的情况下会是这样吗</p><ul class=""><li id="8018" class="nz oa iq lq b lr mw lu mx lx ob mb oc mf od mj oe of og oh bi translated">x(t)处的传感器</li><li id="6272" class="nz oa iq lq b lr oi lu oj lx ok mb ol mf om mj oe of og oh bi translated">在x(t-n)处的传感器，其中n几乎都是期望的偏移值，</li><li id="997e" class="nz oa iq lq b lr oi lu oj lx ok mb ol mf om mj oe of og oh bi translated">以及在x(t-n # a3)处的传感器_44(目标)。</li></ul><p id="df5f" class="pw-post-body-paragraph lo lp iq lq b lr mw jr lt lu mx ju lw lx my lz ma mb mz md me mf na mh mi mj ij bi translated">因此，我们将剩下所需的移位数据和未移位的目标。我们现在必须删除我们不想要的价值观。</p><ul class=""><li id="56b2" class="nz oa iq lq b lr mw lu mx lx ob mb oc mf od mj oe of og oh bi translated"><strong class="lq ir">第1行，</strong>设定展望未来的步骤</li><li id="c009" class="nz oa iq lq b lr oi lu oj lx ok mb ol mf om mj oe of og oh bi translated"><strong class="lq ir">第2行</strong>，首先调用<em class="nq"> series_to_supervise() </em>创建移位数据。</li><li id="a047" class="nz oa iq lq b lr oi lu oj lx ok mb ol mf om mj oe of og oh bi translated"><strong class="lq ir">第3行</strong>，获取所有未换班人员的姓名</li><li id="d469" class="nz oa iq lq b lr oi lu oj lx ok mb ol mf om mj oe of og oh bi translated"><strong class="lq ir">第4行</strong>，获取除了我们要用于预测的时间步长距离之外的所有移位值的名称(<em class="nq">未来</em>值)。<em class="nq">这个其实没必要。保留所有移位的值可能会提高性能。在您自己的项目中测试差异。</em></li><li id="237a" class="nz oa iq lq b lr oi lu oj lx ok mb ol mf om mj oe of og oh bi translated"><strong class="lq ir">第6–8行</strong>，取出目标数据并删除收集到的名称。</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nu nv l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">删除不需要的数据[按作者]</p></figure><p id="4fc9" class="pw-post-body-paragraph lo lp iq lq b lr mw jr lt lu mx ju lw lx my lz ma mb mz md me mf na mh mi mj ij bi translated">现在我们有移位的X数据和未移位的Y数据。</p><h2 id="ec3b" class="nb kx iq bd ky nc nd dn lc ne nf dp lg lx ng nh li mb ni nj lk mf nk nl lm nm bi translated">将数据分成训练验证测试集</h2><p id="61da" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">下一步是将数据分成训练验证和测试集。通常，这是通过<code class="fe pr ps pt pu b"><a class="ae kv" href="https://scikit-learn.org/stable/modules/generated/sklearn.model_selection.train_test_split.html" rel="noopener ugc nofollow" target="_blank"><em class="nq">sklearn.model_selection.train_test_split()</em></a><em class="nq"> </em></code>或<code class="fe pr ps pt pu b"><a class="ae kv" href="https://scikit-learn.org/stable/modules/generated/sklearn.model_selection.StratifiedKFold.html" rel="noopener ugc nofollow" target="_blank">sklearn.model_selection.StratifiedKFold</a><em class="nq">() </em></code>功能完成的。然而，为了我们的概念验证，我们手动分割以获得更多的控制。我们选择:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pv"><img src="../Images/05f8aab7580effeda9625913813e78cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dZcJzyevJBj3tn-kai6IhA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">手动分隔数据[按作者]</p></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nu nv l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">拆分数据[按作者]</p></figure><p id="f69f" class="pw-post-body-paragraph lo lp iq lq b lr mw jr lt lu mx ju lw lx my lz ma mb mz md me mf na mh mi mj ij bi translated">现在我们已经准备好了布景。同样，对于正确的k倍分析，这不应该手动完成，而应该使用<code class="fe pr ps pt pu b"><a class="ae kv" href="https://scikit-learn.org/stable/modules/generated/sklearn.model_selection.KFold.html" rel="noopener ugc nofollow" target="_blank">sklearn.model_selection.KFold()</a> </code>或<code class="fe pr ps pt pu b"><a class="ae kv" href="https://scikit-learn.org/stable/modules/generated/sklearn.model_selection.StratifiedKFold.html" rel="noopener ugc nofollow" target="_blank">sklearn.model_selection.StratifiedKFold</a><em class="nq">()</em></code>函数(分层意味着每个选择中所有类别的数量相等)。</p><h2 id="b916" class="nb kx iq bd ky nc nd dn lc ne nf dp lg lx ng nh li mb ni nj lk mf nk nl lm nm bi translated">标准化/规范化</h2><p id="b9cd" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">下一步是标准化数据。如果不同的输入特征(这里是传感器)具有不同的幅度范围，则数据的标准化是必要的。否则，在使用机器学习方法时，值会被歪曲。机器学习方法主要使用函数内的乘法。一个大值的乘法导致更大的值，这将被误解为“重要性”。在例如[0，1]之间缩放所有值是中性比较的基础。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nu nv l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">缩放数据[来自作者]</p></figure><h2 id="d7c9" class="nb kx iq bd ky nc nd dn lc ne nf dp lg lx ng nh li mb ni nj lk mf nk nl lm nm bi translated">整形和一次热编码</h2><p id="f49d" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">在最后两个步骤中，我们必须按照LSTM(我们将选择它)期望的输入形式[样本、时间步长、要素]对数据进行整形。</p><p id="ca73" class="pw-post-body-paragraph lo lp iq lq b lr mw jr lt lu mx ju lw lx my lz ma mb mz md me mf na mh mi mj ij bi translated">并且，当我们寻找分类时，我们必须在训练之前对我们的目标进行一次热编码，以便softmax激活正确地解释分类，而不会将分类顺序(0，1，2)误解为等级或重要性。这很容易用<code class="fe pr ps pt pu b">sk<a class="ae kv" href="https://scikit-learn.org/stable/modules/generated/sklearn.model_selection.KFold.html" rel="noopener ugc nofollow" target="_blank">learn.preprocessing.OneHotEncode()</a></code>函数来完成。</p><p id="ff91" class="pw-post-body-paragraph lo lp iq lq b lr mw jr lt lu mx ju lw lx my lz ma mb mz md me mf na mh mi mj ij bi translated">两者结合在一个功能中:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="86f8" class="pw-post-body-paragraph lo lp iq lq b lr mw jr lt lu mx ju lw lx my lz ma mb mz md me mf na mh mi mj ij bi translated">现在我们已经准备好在不同的类上训练一个算法。我们会选择LSTM。</p><h1 id="1843" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">使用简单的LSTM</h1><h2 id="f8d5" class="nb kx iq bd ky nc nd dn lc ne nf dp lg lx ng nh li mb ni nj lk mf nk nl lm nm bi translated">层和单元的问题</h2><p id="78f0" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">所以我们首先为自己建立一个简单的LSTM模型。深度神经网络，主要有两个问题:<strong class="lq ir">每层有多少个隐藏单元</strong>(神经元，滤波器，…)<strong class="lq ir">和多少层</strong>。关于模型应该有多深的问题，经验法则是:</p><blockquote class="nn no np"><p id="650e" class="lo lp nq lq b lr mw jr lt lu mx ju lw nr my lz ma ns mz md me nt na mh mi mj ij bi translated">如果您构建了自己的模型(非预训练)，从一层或两层开始，在比较性能的同时逐渐添加更多层。</p></blockquote><p id="3472" class="pw-post-body-paragraph lo lp iq lq b lr mw jr lt lu mx ju lw lx my lz ma mb mz md me mf na mh mi mj ij bi translated">总的来说，对于LSTMs，你可能会问更多的层是否意味着更多的长期记忆。这里有一篇来自<em class="nq">杰森·布朗利</em>T3的关于这个话题的有趣的<a class="ae kv" href="https://machinelearningmastery.com/stacked-long-short-term-memory-networks/" rel="noopener ugc nofollow" target="_blank">文章。总的来说，似乎更多的LSTM层提供了不同的时间缩放，因此具有更好的时间分辨率/更好的性能。这相当于CNN有更多层时分辨率更高。<strong class="lq ir">注意:更多的层意味着更多的复杂性，通常会导致过度拟合。</strong> <br/>另一方面，隐单元(神经元、滤波器、…)的数量在CNN内部是不同的。CNN的经验法则是增加每层的数字，因为需要分析更详细的信息。在LSTMs中，就分析时间序列而言，存储单元的数量不如层数重要。这里的经验法则是<strong class="lq ir">比输入特征</strong>更少的隐藏单元(存储单元)。开始时很小，例如2，然后慢慢增加。所以尝试不同的价值观，但不要太强调它们。这里我们选择42；-).</a></p><h2 id="7885" class="nb kx iq bd ky nc nd dn lc ne nf dp lg lx ng nh li mb ni nj lk mf nk nl lm nm bi translated">简单的模型</h2><p id="8bb7" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">我们尝试用于概念验证的模型如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pw"><img src="../Images/584af335ca5ff8e2fb42af6e6fac32e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-623G5eaxNZFBKmC1RjgMg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">模型[作者]</p></figure><p id="b08a" class="pw-post-body-paragraph lo lp iq lq b lr mw jr lt lu mx ju lw lx my lz ma mb mz md me mf na mh mi mj ij bi translated">两个LSTM层，每个层有42个隐藏单元和两个输出层。您可以在这里使用一个简单的单输出序列模型。我们有两个as，我们想展示不同的使用情形。signal_out是一个密集层，其中一个单元为我们提供预测信号，而class_out是一个密集层，其中3个单元和softmax激活为我们提供预测类别<em class="nq">、【正常】、<em class="nq">恢复</em>和<em class="nq">损坏</em>。</em></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nu nv l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">模型[作者]</p></figure><p id="3616" class="pw-post-body-paragraph lo lp iq lq b lr mw jr lt lu mx ju lw lx my lz ma mb mz md me mf na mh mi mj ij bi translated">signal_out在这里似乎没有太大的意义，但是我们想展示如何使用这种方法来增加预测(参见结果)并预测信号而不是类。</p><p id="5805" class="pw-post-body-paragraph lo lp iq lq b lr mw jr lt lu mx ju lw lx my lz ma mb mz md me mf na mh mi mj ij bi translated">现在让我们训练模型:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nu nv l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">火车模型[作者]</p></figure><h1 id="76f8" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">结果</h1><p id="3f72" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">训练指标看起来很有希望。验证(此处标记为<em class="nq">测试</em>)损失和准确性看起来不错。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi px"><img src="../Images/b3957a64b99ea07808c77ac7f212c5bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6OSK3RGE8wCp7clU8GTkMA.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">准确性和损失[按作者]</p></figure><p id="5b6d" class="pw-post-body-paragraph lo lp iq lq b lr mw jr lt lu mx ju lw lx my lz ma mb mz md me mf na mh mi mj ij bi translated">但是我们看到了一件事。尽管预测的信号，如下所示，并不完美，但验证准确率显示为99%。这是为什么不对不平衡数据集使用精度的一个很好的例子。仅仅通过将所有事物归类为多数类，我们就已经达到了很高的准确度。因此，最好对不平衡数据集实施Kappa统计、ROC、F1、Anova等测量。为了做到科学上的滴水不漏，要使用不止一种测量方法，并进行k倍交叉验证。</p><p id="d8db" class="pw-post-body-paragraph lo lp iq lq b lr mw jr lt lu mx ju lw lx my lz ma mb mz md me mf na mh mi mj ij bi translated">现在运行推论。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nu nv l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">运行推论[按作者]</p></figure><p id="c0c3" class="pw-post-body-paragraph lo lp iq lq b lr mw jr lt lu mx ju lw lx my lz ma mb mz md me mf na mh mi mj ij bi translated">最后，让我们绘制目标和预测目标的相互关系图:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi op"><img src="../Images/9187411cbd74cbd7b49c1ddfd3a412f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dBBR18WKXP5JxuA46KK5ZA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">预测目标与原始目标[作者]</p></figure><p id="6f18" class="pw-post-body-paragraph lo lp iq lq b lr mw jr lt lu mx ju lw lx my lz ma mb mz md me mf na mh mi mj ij bi translated">您可以看到，故障情节没有被直接分类(由于只有7个样本要处理)，但是，恢复阶段被很好地检测到，在这种情况下，提前10分钟。作为一个工程问题，这就足够了，因为我们积极地检测故障事件的开始和结束，并有时间作出反应(关闭、转移到另一个泵、降低速度等)。如果你需要提前更多的时间，从<em class="nq"> series_to_supervised() </em>函数中增加<em class="nq"> n_in </em>变量。然而，移位后的数据帧变得非常大，我的笔记本电脑再也无法处理它了。是时候搬到Azure了。</p><p id="e6ec" class="pw-post-body-paragraph lo lp iq lq b lr mw jr lt lu mx ju lw lx my lz ma mb mz md me mf na mh mi mj ij bi translated">如果我们将预测类(模型的signal_out输出)绘制为连续信号而不是最大类，我们可以看到，如果我们为例如输出设置简单的阈值或者我们对计算的方差设置阈值，这可能会导致更稳定的分类。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi op"><img src="../Images/163df0bba9d9b2d5f8bd8d956042c00f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rTalyLYUwAsKm0wReYe7JA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作为连续信号的预测目标与作为二进制信号的原始目标[作者]</p></figure><p id="119e" class="pw-post-body-paragraph lo lp iq lq b lr mw jr lt lu mx ju lw lx my lz ma mb mz md me mf na mh mi mj ij bi translated">一般来说，用这种输出方法，可以预测一个信号。这意味着，您可以使用一些传感器数据来预测另一个传感器即将到来的数据。对于这种方法，您唯一需要更改的是使用您想要预测的信号作为目标，而不是类(例如，Sensor_42的数据现在是目标)。</p><h1 id="2acd" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">更多选项</h1><p id="4439" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">如果你的项目结果不令人满意，下面的选项是可用的(可能我错过了很多):</p><ul class=""><li id="b707" class="nz oa iq lq b lr mw lu mx lx ob mb oc mf od mj oe of og oh bi translated">玩弄超参数</li><li id="49fc" class="nz oa iq lq b lr oi lu oj lx ok mb ol mf om mj oe of og oh bi translated">添加更多层</li><li id="495e" class="nz oa iq lq b lr oi lu oj lx ok mb ol mf om mj oe of og oh bi translated">使用上述信号处理/清洁步骤</li><li id="1905" class="nz oa iq lq b lr oi lu oj lx ok mb ol mf om mj oe of og oh bi translated">使用轻量级的“经典”机器学习</li><li id="8dae" class="nz oa iq lq b lr oi lu oj lx ok mb ol mf om mj oe of og oh bi translated">使用新型变压器模型</li><li id="5b78" class="nz oa iq lq b lr oi lu oj lx ok mb ol mf om mj oe of og oh bi translated">合成更多的少数民族国家与甘，SMOTE，ADASYN，…</li><li id="ddad" class="nz oa iq lq b lr oi lu oj lx ok mb ol mf om mj oe of og oh bi translated">重量少数级惩罚</li><li id="8173" class="nz oa iq lq b lr oi lu oj lx ok mb ol mf om mj oe of og oh bi">…</li></ul></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="851a" class="kw kx iq bd ky kz mr lb lc ld ms lf lg jw mt jx li jz mu ka lk kc mv kd lm ln bi translated">步骤总结</h1><p id="6d7b" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">这是相当长的，也许令人困惑。因此，我们再次总结我们对每一章的所有想法。这会让你很容易地重建思路。<br/>请重用这张图片，但别忘了引用它。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi py"><img src="../Images/f1a93a66b1058c47bf4c9c6325d14b6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1256/format:webp/1*Z3MY_QiwKNZ_4Ok0SLpmmw.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">思路[作者]</p></figure></div></div>    
</body>
</html>