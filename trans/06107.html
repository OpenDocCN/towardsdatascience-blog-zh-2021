<html>
<head>
<title>Here’s what I’ve learnt about Sklearn.resample</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">以下是我对Sklearn.resample的了解</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/heres-what-i-ve-learnt-about-sklearn-resample-ab735ae1abc4?source=collection_archive---------8-----------------------#2021-06-01">https://towardsdatascience.com/heres-what-i-ve-learnt-about-sklearn-resample-ab735ae1abc4?source=collection_archive---------8-----------------------#2021-06-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="b03f" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">解释上采样、下采样和一些要避免的错误</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/1c016401d10af8c71819b19f337b803a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*oI68Xx5Mj_i4qXyJ"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">安德里亚斯·布鲁恩在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="05a2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于数据科学家来说，处理不平衡的数据集可能是一个棘手的问题。处理不平衡数据集的方法之一是使用<em class="ls"> sklearn.resample </em>进行重采样，即向上采样少数类或向下采样多数类。</p><blockquote class="lt"><p id="9172" class="lu lv iq bd lw lx ly lz ma mb mc lr dk translated"><em class="md"> Sklearn.resample </em>是Scikit learn用于上采样/下采样的函数。</p></blockquote><p id="3663" class="pw-post-body-paragraph kw kx iq ky b kz me jr lb lc mf ju le lf mg lh li lj mh ll lm ln mi lp lq lr ij bi translated">根据sklearn文档，函数sklearn.resample，r <em class="ls">以一致的方式对数组或稀疏矩阵进行采样，默认策略实现引导程序</em>的一个步骤。简单来说，<em class="ls"> sklearn.resample </em>不仅仅是神奇地为数据集生成额外的数据点，它基本上是为你的数据集创建一个<em class="ls">随机重采样(有/无替换)。这种均衡过程防止机器学习模型倾向于数据集中的多数类。</em></p><p id="b32b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，我在一个例子中展示了上采样。在下面的例子中，我们创建了一个包含3列的数据框架:<strong class="ky ir">年龄、性别和商店。</strong></p><pre class="kg kh ki kj gt mj mk ml mm aw mn bi"><span id="7e66" class="mo mp iq mk b gy mq mr l ms mt">#import libraries<br/>import pandas as pd<br/>from sklearn.utils import resample,shuffle</span><span id="1e18" class="mo mp iq mk b gy mu mr l ms mt">#create a dataframe<br/>df = {'age':['a','b','c','a','b'],'sex':['e','f','g','f','e'],'store':[1,2,3,3,2]}</span><span id="6803" class="mo mp iq mk b gy mu mr l ms mt">df = pd.DataFrame(df)</span><span id="9add" class="mo mp iq mk b gy mu mr l ms mt">df.head()</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/272efa8267c4853e2b4494278e4e1e30.png" data-original-src="https://miro.medium.com/v2/resize:fit:572/format:webp/1*Z9gzg_XGNIEq9hTOztPdug.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">df.head()</p></figure><p id="4d67" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们首先分离少数民族阶层，然后对少数民族阶层进行抽样。少数民族班级的人数被上采样到其他班级的人数。</p><pre class="kg kh ki kj gt mj mk ml mm aw mn bi"><span id="5026" class="mo mp iq mk b gy mq mr l ms mt">#set the minority class to a seperate dataframe</span><span id="8033" class="mo mp iq mk b gy mu mr l ms mt">df_1 = df[df['store'] == 1]</span><span id="34d7" class="mo mp iq mk b gy mu mr l ms mt">#set other classes to another dataframe</span><span id="d396" class="mo mp iq mk b gy mu mr l ms mt">other_df = df[df['store'] != 1]  </span><span id="ccb6" class="mo mp iq mk b gy mu mr l ms mt">#upsample the minority class<br/>df_1_upsampled = resample(df_1,random_state=42,n_samples=2,replace=True)</span><span id="39e6" class="mo mp iq mk b gy mu mr l ms mt">#concatenate the upsampled dataframe<br/>df_upsampled = pd.concat([df_1_upsampled,other_df])<br/>df_upsampled</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/225d6d1338ddd77fa41a7cbbc79ffc68.png" data-original-src="https://miro.medium.com/v2/resize:fit:612/format:webp/1*mvB0cqkZ6rF537VjWup5PQ.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">df _上采样</p></figure><p id="b8f2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">多酷啊！😉 😊现在我们有更多的数据来训练我们的模型。此外，当我们训练模型时，可以观察到数据中的<strong class="ky ir"> <em class="ls"> 3个商店类别(1、2和3) </em> </strong>中的每个类别的数量相等。</p><p id="9818" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，当您进行上采样或下采样时，请避免这些错误！</p><ol class=""><li id="5315" class="mx my iq ky b kz la lc ld lf mz lj na ln nb lr nc nd ne nf bi translated">在机器学习问题中，确保只有在分成训练、测试(如果你愿意，还可以验证)之后，才进行上采样/下采样<strong class="ky ir">。如果您在拆分为定型和测试之前对数据集进行了向上采样，那么您的模型很有可能会出现数据泄漏。参见下面的示例。</strong></li></ol><pre class="kg kh ki kj gt mj mk ml mm aw mn bi"><span id="c607" class="mo mp iq mk b gy mq mr l ms mt">from sklearn.model_selection import train_test_split</span><span id="9e58" class="mo mp iq mk b gy mu mr l ms mt">X = df_upsampled.drop('store',axis=1)<br/>y = df_upsampled.store</span><span id="c783" class="mo mp iq mk b gy mu mr l ms mt">X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=1,shuffle=True)</span><span id="deb0" class="mo mp iq mk b gy mu mr l ms mt">X_train.head()</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/b1de8639d547aae88a9f46d9336890bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:396/format:webp/1*arTbc8t-nl4tjnhuVIObTA.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">x _火车</p></figure><pre class="kg kh ki kj gt mj mk ml mm aw mn bi"><span id="3332" class="mo mp iq mk b gy mq mr l ms mt">X_test.head()</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/de92ce01b51de78de7525dd60ca05cc4.png" data-original-src="https://miro.medium.com/v2/resize:fit:412/format:webp/1*3vExiP6YqKH9RMI757HVDg.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">x _测试</p></figure><p id="ef13" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ls">注意数据泄露！</em>我们在<strong class="ky ir"> X_train </strong>和<strong class="ky ir"> X_test </strong>中有完全相同的数据点。这样做可能会让我们对我们的<strong class="ky ir"> <em class="ls">机器学习</em> </strong>模型的实际表现产生错误的认识。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ni"><img src="../Images/99883b2fa841b5ad21315c969216afde.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*VOQyO97mEA-DPEsW"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Claudio Schwarz | @purzlbaum 在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="e163" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">2.在您的机器学习模型建立之后，建议在您的<strong class="ky ir">非上采样</strong>训练数据集上测试您的指标。在<strong class="ky ir">非上采样</strong>数据集上测试你的指标，比在<strong class="ky ir">上采样</strong>数据集上测试它，给你一个更真实的模型评估。就我个人而言，我总是喜欢保留一个未经上采样的训练数据集版本。</p><p id="8ed8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">结论:<br/>上采样/下采样</strong>是处理不平衡数据的非常好的方法。然而，重要的是要了解它们是如何工作的，以便能够正确使用它们。还要注意，由于额外的信息，上采样机制会在系统中引入偏差。</p><p id="56be" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">还可以了解一下imbean库的<strong class="ky ir"> <em class="ls"> SMOTE </em> </strong>操作符。它基于<strong class="ky ir"><em class="ls">knarestneighbors</em></strong>算法工作，综合生成落在已经存在的寡不敌众的组附近的数据点。点击阅读更多信息<a class="ae kv" href="https://www.analyticsvidhya.com/blog/2020/11/handling-imbalanced-data-machine-learning-computer-vision-and-nlp/#:~:text=Upsampling%20is%20a%20procedure%20where,inclining%20towards%20the%20majority%20class." rel="noopener ugc nofollow" target="_blank">。</a></p><p id="d868" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我希望这对你有帮助。期待您的评论，同时您也可以在<a class="ae kv" href="https://twitter.com/samsonafo" rel="noopener ugc nofollow" target="_blank"> twitter </a>和<a class="ae kv" href="https://www.linkedin.com/in/samson-afolabi/" rel="noopener ugc nofollow" target="_blank"> Linkedin </a>上关注我。</p><p id="9a8a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你喜欢这篇文章，你可以考虑给我买杯☕️.咖啡</p><p id="2e03" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">谢谢😊</p></div></div>    
</body>
</html>