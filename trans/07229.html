<html>
<head>
<title>Python Pandas vs. R Dplyr</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python熊猫vs. R Dplyr</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/python-pandas-vs-r-dplyr-5b5081945ccb?source=collection_archive---------4-----------------------#2021-07-01">https://towardsdatascience.com/python-pandas-vs-r-dplyr-5b5081945ccb?source=collection_archive---------4-----------------------#2021-07-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="de38" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">完整的备忘单</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ab96d1190ee3b7d5607d7f976a80f77e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bOpIJmOBhrlxLYTItidlvw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由作者根据<a class="ae ky" href="https://allisonhorst.github.io/" rel="noopener ugc nofollow" target="_blank">https://allisonhorst.github.io/</a>的Dplyr标志和<a class="ae ky" href="https://pandas.pydata.org/about/citing.html" rel="noopener ugc nofollow" target="_blank">https://pandas.pydata.org/about/citing.html</a>的熊猫标志制作</p></figure><h1 id="0ea3" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">期待什么</h1><p id="24b1" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">对于许多数据科学家来说，<strong class="lt iu"> Pandas </strong> for Python和<strong class="lt iu"> Dplyr </strong> for R是两个最流行的处理表格/结构化数据的库。关于哪个框架更好，总会有一些激烈的讨论。老实说，这真的重要吗？最后，这是关于完成工作，熊猫和dplyr都提供了很好的数据争论工具。<strong class="lt iu">不用担心，这篇文章并不是另一个试图证明任何一个库的观点的比较！</strong>因此，本条的目的是:</p><ul class=""><li id="1a39" class="mn mo it lt b lu mp lx mq ma mr me ms mi mt mm mu mv mw mx bi translated">帮助其他人从一种语言/框架过渡到另一种语言/框架</li><li id="626d" class="mn mo it lt b lu my lx mz ma na me nb mi nc mm mu mv mw mx bi translated">探索可以作为数据科学家增加技能的新工具</li><li id="81af" class="mn mo it lt b lu my lx mz ma na me nb mi nc mm mu mv mw mx bi translated">创建一个参考备忘单，以防您需要查找两种语言中最常用的数据争论函数</li></ul><h1 id="ec6d" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated"><strong class="ak">数据</strong></h1><p id="65ab" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在本教程中，我们将使用<strong class="lt iu"> iris </strong>数据集，它是Pythons sklearn和base R的一部分。</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="892a" class="ni la it ne b gy nj nk l nl nm">Sepal_length  Sepal_width  Petal_length     Petal_width  Species<br/>          5.1         3.5           1.4             0.2   setosa<br/>          4.9         3.0           1.4             0.2   setosa<br/>          4.7         3.2           1.3             0.2   setosa<br/>          4.6         3.1           1.5             0.2   setosa<br/>          5.0         3.6           1.4             0.2   setosa</span></pre><h1 id="f5e6" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">小抄</h1><p id="c5d3" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">免责声明:长阅读</p><h2 id="8cb1" class="ni la it bd lb nn no dn lf np nq dp lj ma nr ns ll me nt nu ln mi nv nw lp nx bi translated">选择列</h2><p id="7305" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">这里已经变得令人困惑了。首先，在每个框架中，如何从数据框架中选择列有多种方法。在Pandas中，您可以简单地传递带有列名的列表，或者使用<strong class="lt iu"> filter() </strong>方法。这令人困惑，因为dplyr中的<strong class="lt iu"> filter() </strong>函数用于根据条件而不是根据列对行进行子集化！在dplyr中，我们使用<strong class="lt iu"> select() </strong>函数来代替:</p><p id="c546" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma ny mc md me nz mg mh mi oa mk ml mm im bi translated">熊猫</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="c0c0" class="ni la it ne b gy nj nk l nl nm">#Pass columns as list<br/>dataframe[[“Sepal_width”, “Petal_width”]]<br/></span><span id="9977" class="ni la it ne b gy ob nk l nl nm">#Use Filter Function<br/>dataframe.filter(items=['Sepal_width', 'Petal_width'])</span></pre><p id="b953" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma ny mc md me nz mg mh mi oa mk ml mm im bi translated"><strong class="lt iu"> Dplyr </strong></p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="fc83" class="ni la it ne b gy nj nk l nl nm">dataframe %&gt;% select(Sepal_width, Petal_width)</span></pre></div><div class="ab cl oc od hx oe" role="separator"><span class="of bw bk og oh oi"/><span class="of bw bk og oh oi"/><span class="of bw bk og oh"/></div><div class="im in io ip iq"><h2 id="4c9e" class="ni la it bd lb nn no dn lf np nq dp lj ma nr ns ll me nt nu ln mi nv nw lp nx bi translated">基于条件的过滤</h2><p id="fe29" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">同样，有多种方法可以根据一列或多列的条件过滤数据帧中的记录。</p><p id="d2b2" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma ny mc md me nz mg mh mi oa mk ml mm im bi translated">熊猫</p><p id="a2dd" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma ny mc md me nz mg mh mi oa mk ml mm im bi translated">在Pandas中，你可以使用索引方法或者尝试方便的查询API，这是我个人更喜欢的。</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="933f" class="ni la it ne b gy nj nk l nl nm">#indexing<br/>dataframe[(dataframe["Sepal_width"] &gt; 3.5) &amp; (dataframe["Petal_width"] &lt; 0.3)]<br/></span><span id="b6ae" class="ni la it ne b gy ob nk l nl nm">#query API<br/>dataframe.query("Sepal_width &gt; 3.5 &amp; Petal_width &lt; 0.3")</span></pre><p id="d169" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma ny mc md me nz mg mh mi oa mk ml mm im bi translated"><strong class="lt iu"> Dplyr </strong></p><p id="e60d" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma ny mc md me nz mg mh mi oa mk ml mm im bi translated">在<strong class="lt iu"> dplyr </strong>中过滤记录的标准方式是通过filter <strong class="lt iu">函数()</strong>。</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="5d42" class="ni la it ne b gy nj nk l nl nm">dataframe %&gt;% filter(Sepal_width &gt; 3.5 &amp; Petal_width &lt; 0.3)</span></pre></div><div class="ab cl oc od hx oe" role="separator"><span class="of bw bk og oh oi"/><span class="of bw bk og oh oi"/><span class="of bw bk og oh"/></div><div class="im in io ip iq"><h2 id="c96f" class="ni la it bd lb nn no dn lf np nq dp lj ma nr ns ll me nt nu ln mi nv nw lp nx bi translated">重命名单列</h2><p id="4abb" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">重命名听起来像是一个简单的任务，但是要小心，注意这里的细微差别。如果我们想在熊猫中将我们的列<strong class="lt iu">从物种重命名为类</strong>，我们提供一个字典，上面写着<strong class="lt iu">{‘物种’:‘类’}</strong>，而在Dplyr中正好相反<strong class="lt iu">类=物种</strong>:</p><p id="d699" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma ny mc md me nz mg mh mi oa mk ml mm im bi translated"><strong class="lt iu">熊猫</strong></p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="1559" class="ni la it ne b gy nj nk l nl nm">dataframe.rename(columns = {'Species': 'Class'}, inplace = True)</span></pre><p id="7c27" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma ny mc md me nz mg mh mi oa mk ml mm im bi translated"><strong class="lt iu"> Dplyr </strong></p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="7559" class="ni la it ne b gy nj nk l nl nm">dataframe &lt;- dataframe %&gt;% rename(Class=Species)</span></pre></div><div class="ab cl oc od hx oe" role="separator"><span class="of bw bk og oh oi"/><span class="of bw bk og oh oi"/><span class="of bw bk og oh"/></div><div class="im in io ip iq"><h2 id="9dbe" class="ni la it bd lb nn no dn lf np nq dp lj ma nr ns ll me nt nu ln mi nv nw lp nx bi translated">根据条件重命名多个列</h2><p id="ff9f" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">假设我们想根据一个条件一次重命名多个列。例如，将我们所有的特征列(萼片长度、萼片宽度、花瓣长度、花瓣宽度)转换为大写。在Python中，这实际上相当复杂，您需要首先导入另一个库，并手动迭代每一列。在Dplyr中，如果您想根据条件访问/更改多个列，有一个更简洁的界面。</p><p id="d81f" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma ny mc md me nz mg mh mi oa mk ml mm im bi translated"><strong class="lt iu">熊猫</strong></p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="1c90" class="ni la it ne b gy nj nk l nl nm">import re</span><span id="ed10" class="ni la it ne b gy ob nk l nl nm">#prepare pattern that columns have to match to be converted to upper case<br/>pattern = re.compile(r".*(length|width)")</span><span id="4085" class="ni la it ne b gy ob nk l nl nm">#iterate over columns and covert to upper case if pattern matches.<br/>for col in dataframe.columns:<br/>  if bool((pattern.match(col))):<br/>    dataframe.rename(columns = {col: col.upper()}, inplace = True)</span></pre><p id="c3ee" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma ny mc md me nz mg mh mi oa mk ml mm im bi translated"><strong class="lt iu"> Dplyr </strong></p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="4911" class="ni la it ne b gy nj nk l nl nm">dataframe &lt;- dataframe %&gt;% rename_with(toupper, matches("length|width"))</span></pre><p id="66c0" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma ny mc md me nz mg mh mi oa mk ml mm im bi translated"><strong class="lt iu">结果</strong></p><p id="d33f" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma ny mc md me nz mg mh mi oa mk ml mm im bi translated">请注意大写特征列名:</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="e93d" class="ni la it ne b gy nj nk l nl nm">SEPAL_LENGTH  SEPAL_WIDTH  PETAL_LENGTH     PETAL_WIDTH  Species<br/>          5.1         3.5           1.4             0.2   setosa<br/>          4.9         3.0           1.4             0.2   setosa</span></pre></div><div class="ab cl oc od hx oe" role="separator"><span class="of bw bk og oh oi"/><span class="of bw bk og oh oi"/><span class="of bw bk og oh"/></div><div class="im in io ip iq"><h2 id="93bc" class="ni la it bd lb nn no dn lf np nq dp lj ma nr ns ll me nt nu ln mi nv nw lp nx bi translated">根据条件改变单元格值</h2><p id="33f8" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">假设我们想要基于条件重新编码/改变单元格值:在我们的示例中，我们将尝试将物种字符串“setosa，versicolor和virginica”重新编码为从0到2的整数:</p><p id="274f" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma ny mc md me nz mg mh mi oa mk ml mm im bi translated"><strong class="lt iu">熊猫</strong></p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="abe3" class="ni la it ne b gy nj nk l nl nm">dataframe.loc[dataframe['Species'] == 'setosa', "Species"] = 0<br/>dataframe.loc[dataframe['Species'] == 'versicolor', "Species"] = 1<br/>dataframe.loc[dataframe['Species'] == 'virginica', "Species"] = 2</span></pre><p id="2f00" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma ny mc md me nz mg mh mi oa mk ml mm im bi translated"><strong class="lt iu"> Dplyr </strong></p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="dc1a" class="ni la it ne b gy nj nk l nl nm">dataframe &lt;- dataframe %&gt;%<br/>  mutate(Species = case_when(Species == 'setosa' ~ 0,<br/>                             Species == 'versicolor' ~ 1,<br/>                             Species == 'virginica' ~ 2))</span></pre></div><div class="ab cl oc od hx oe" role="separator"><span class="of bw bk og oh oi"/><span class="of bw bk og oh oi"/><span class="of bw bk og oh"/></div><div class="im in io ip iq"><h2 id="32bb" class="ni la it bd lb nn no dn lf np nq dp lj ma nr ns ll me nt nu ln mi nv nw lp nx bi translated">每列的不同值</h2><p id="ca36" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">有时我们想看看一列中有哪些不同的/唯一的值。请注意这两个框架中的函数调用有多么不同:Pandas使用<strong class="lt iu"> unique() </strong>方法，dplyr()使用<strong class="lt iu"> distinct() </strong>函数来获得相同的结果:</p><p id="1aa1" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma ny mc md me nz mg mh mi oa mk ml mm im bi translated">熊猫</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="857d" class="ni la it ne b gy nj nk l nl nm">dataframe.Species.unique()</span><span id="dd78" class="ni la it ne b gy ob nk l nl nm">#array(['setosa', 'versicolor', 'virginica'], dtype=object)</span></pre><p id="8197" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma ny mc md me nz mg mh mi oa mk ml mm im bi translated"><strong class="lt iu"> Dplyr </strong></p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="afaa" class="ni la it ne b gy nj nk l nl nm">dataframe %&gt;% select(Species) %&gt;% distinct()</span><span id="d671" class="ni la it ne b gy ob nk l nl nm"># Species   <br/># setosa    <br/># versicolor<br/># virginica</span></pre></div><div class="ab cl oc od hx oe" role="separator"><span class="of bw bk og oh oi"/><span class="of bw bk og oh oi"/><span class="of bw bk og oh"/></div><div class="im in io ip iq"><h2 id="4127" class="ni la it bd lb nn no dn lf np nq dp lj ma nr ns ll me nt nu ln mi nv nw lp nx bi translated">记录计数(每组)</h2><p id="338b" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">如果您想计算数据帧中总共有多少个条目，或者获取某个组的计数，您可以执行以下操作:</p><p id="9213" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma ny mc md me nz mg mh mi oa mk ml mm im bi translated">熊猫</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="c00e" class="ni la it ne b gy nj nk l nl nm"># Total number of records in dataframe<br/>len(dataframe)</span><span id="4f2c" class="ni la it ne b gy ob nk l nl nm">#150<br/></span><span id="6b3e" class="ni la it ne b gy ob nk l nl nm"># Number of records per Group<br/>dataframe.value_counts('Species')</span><span id="1fc5" class="ni la it ne b gy ob nk l nl nm">#Species<br/>#virginica     50<br/>#versicolor    50<br/>#setosa        50</span><span id="74e2" class="ni la it ne b gy ob nk l nl nm"># Note that you can also use the .groupby() method followed by size()<br/>dataframe.groupby(['Species']).size()<br/></span></pre><p id="b620" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma ny mc md me nz mg mh mi oa mk ml mm im bi translated"><strong class="lt iu"> Dplyr </strong></p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="d24b" class="ni la it ne b gy nj nk l nl nm"># Total number of records in dataframe<br/>dataframe %&gt;% nrow()</span><span id="8de8" class="ni la it ne b gy ob nk l nl nm">#[1] 150<br/></span><span id="3ae4" class="ni la it ne b gy ob nk l nl nm"># Number of records per Group (count and tally are interchangeable)<br/>dataframe %&gt;% group_by(Species) %&gt;% count()<br/>dataframe %&gt;% group_by(Species) %&gt;% tally()</span><span id="728f" class="ni la it ne b gy ob nk l nl nm">#  Species        n<br/>#  &lt;fct&gt;      &lt;int&gt;<br/>#1 setosa        50<br/>#2 versicolor    50<br/>#3 virginica     50</span></pre></div><div class="ab cl oc od hx oe" role="separator"><span class="of bw bk og oh oi"/><span class="of bw bk og oh oi"/><span class="of bw bk og oh"/></div><div class="im in io ip iq"><h2 id="589a" class="ni la it bd lb nn no dn lf np nq dp lj ma nr ns ll me nt nu ln mi nv nw lp nx bi translated">对整个列进行汇总/聚合</h2><p id="e6a3" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">如果要为数据框中的一列或多列创建描述性统计数据，可执行以下操作:</p><p id="bf12" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma ny mc md me nz mg mh mi oa mk ml mm im bi translated"><strong class="lt iu">熊猫</strong></p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="bc6c" class="ni la it ne b gy nj nk l nl nm">#get mean and min for each column<br/>dataframe.agg(['mean', 'min'])</span><span id="fc2b" class="ni la it ne b gy ob nk l nl nm">#      Sepal_length  Sepal_width  Petal_length  Petal_width Species<br/>#mean      5.843333     3.057333         3.758     1.199333     NaN<br/>#min       4.300000     2.000000         1.000     0.100000  setosa</span></pre><p id="f6d1" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma ny mc md me nz mg mh mi oa mk ml mm im bi translated"><strong class="lt iu"> Dplyr </strong></p><p id="f070" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma ny mc md me nz mg mh mi oa mk ml mm im bi translated">不幸的是，我没有找到如何一次在多个列上使用多个聚合函数的方法。这就是为什么您需要多次调用summarise函数来获得相同的结果:</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="cb01" class="ni la it ne b gy nj nk l nl nm">#first aggregation over all columns using mean<br/>dataframe %&gt;% summarise(across(everything(), mean))</span><span id="7aa1" class="ni la it ne b gy ob nk l nl nm">#  Sepal_length Sepal_width Petal_length Petal_width Species<br/>#         5.84        3.06         3.76        1.20      NA</span><span id="1b5b" class="ni la it ne b gy ob nk l nl nm">#second aggregation over all columns using min<br/>dataframe %&gt;% summarise(across(everything(), min))</span><span id="df99" class="ni la it ne b gy ob nk l nl nm">#Sepal_length Sepal_width Petal_length Petal_width Species<br/>#        5.84        3.06         3.76        1.20      NA</span></pre></div><div class="ab cl oc od hx oe" role="separator"><span class="of bw bk og oh oi"/><span class="of bw bk og oh oi"/><span class="of bw bk og oh"/></div><div class="im in io ip iq"><h2 id="78b4" class="ni la it bd lb nn no dn lf np nq dp lj ma nr ns ll me nt nu ln mi nv nw lp nx bi translated">按组汇总/汇总</h2><p id="0789" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">如果想要在数据集中按组聚集统计数据，必须使用Pandas中的<strong class="lt iu"> groupby() </strong>方法和Dplyr中的<strong class="lt iu"> group_by() </strong>函数。您可以对所有列或特定列执行此操作:</p><p id="3299" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma ny mc md me nz mg mh mi oa mk ml mm im bi translated"><strong class="lt iu">熊猫</strong></p><p id="1776" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma ny mc md me nz mg mh mi oa mk ml mm im bi translated">请注意Pandas如何使用多级索引来清晰地显示结果:</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="8f99" class="ni la it ne b gy nj nk l nl nm"># aggregation by group for all columns<br/>dataframe.groupby(['Species']).agg(['mean', 'min'])</span><span id="7280" class="ni la it ne b gy ob nk l nl nm">#                 Sepal_length      Sepal_width       ...<br/>#                   mean  min        mean min         ...<br/>#Species                                                         <br/>#setosa            5.01  4.3       3.43             ...<br/>#versicolor        5.94  4.9       2.77             ...<br/>#virginica         6.59  4.9       2.97             ...</span><span id="1525" class="ni la it ne b gy ob nk l nl nm"><br/># aggregation by group for a specific column<br/>dataframe.groupby(['Species']).agg({'Sepal_length':['mean']})</span><span id="4857" class="ni la it ne b gy ob nk l nl nm">#   Sepal_length<br/>#                   mean<br/>#Species                <br/>#setosa            5.01<br/>#versicolor        5.94<br/>#virginica         6.59</span></pre><p id="1e51" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma ny mc md me nz mg mh mi oa mk ml mm im bi translated"><strong class="lt iu"> Dplyr </strong></p><p id="d88a" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma ny mc md me nz mg mh mi oa mk ml mm im bi translated">由于Dplyr不支持多级索引，所以第一次调用的输出与Pandas相比看起来有点乱。在此输出中，显示了第一个函数的统计数据(mean-fn1)，然后是第二个函数的统计数据(min-fn2)。</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="a26e" class="ni la it ne b gy nj nk l nl nm"># aggregation by group for all columns<br/>dataframe %&gt;% group_by(Species) %&gt;% summarise_all(list(mean,min))</span><span id="2552" class="ni la it ne b gy ob nk l nl nm">Species    Sepal_length_fn1  Sepal_width_fn1         ...<br/>setosa                 5.01            3.43          ...<br/>versicolor             5.94            2.77          ...         <br/>virginica              6.59            2.97          ...<br/></span><span id="b952" class="ni la it ne b gy ob nk l nl nm"># aggregation by group for a specific column<br/>dataframe %&gt;% group_by(Species) %&gt;% summarise(mean=mean(Sepal_length))</span><span id="37cf" class="ni la it ne b gy ob nk l nl nm">#Species     mean<br/># setosa      5.01<br/># versicolor  5.94<br/># virginica   6.59</span></pre></div><div class="ab cl oc od hx oe" role="separator"><span class="of bw bk og oh oi"/><span class="of bw bk og oh oi"/><span class="of bw bk og oh"/></div><div class="im in io ip iq"><h2 id="67d0" class="ni la it bd lb nn no dn lf np nq dp lj ma nr ns ll me nt nu ln mi nv nw lp nx bi translated">列数学/添加新列</h2><p id="9cf8" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">有时，您希望创建一个新列，并通过某种数学运算将两个或多个现有列的值组合起来。以下是如何在熊猫和Dplyr中做到这一点:</p><p id="e89f" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma ny mc md me nz mg mh mi oa mk ml mm im bi translated">熊猫</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="8934" class="ni la it ne b gy nj nk l nl nm">dataframe["New_feature"] = dataframe["Petal_width"]* dataframe["Petal_length"] / 2</span></pre><p id="fbc3" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma ny mc md me nz mg mh mi oa mk ml mm im bi translated"><strong class="lt iu"> Dplyr </strong></p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="3f86" class="ni la it ne b gy nj nk l nl nm">dataframe &lt;- dataframe %&gt;% mutate(New_feature= Petal_width*Petal_length/2)</span></pre></div><div class="ab cl oc od hx oe" role="separator"><span class="of bw bk og oh oi"/><span class="of bw bk og oh oi"/><span class="of bw bk og oh"/></div><div class="im in io ip iq"><h2 id="f7a1" class="ni la it bd lb nn no dn lf np nq dp lj ma nr ns ll me nt nu ln mi nv nw lp nx bi translated">删除列</h2><p id="5474" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">为了清理数据帧，删除列有时会非常方便:</p><p id="ad74" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma ny mc md me nz mg mh mi oa mk ml mm im bi translated"><strong class="lt iu">熊猫</strong></p><p id="0559" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma ny mc md me nz mg mh mi oa mk ml mm im bi translated">在Pandas中，你可以用<strong class="lt iu"> drop() </strong>删除一列。您也可以使用<strong class="lt iu"> inplace=True </strong>来覆盖当前数据帧。</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="8a20" class="ni la it ne b gy nj nk l nl nm">dataframe.drop("New_feature", axis=1, inplace=True)</span></pre><p id="ed26" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma ny mc md me nz mg mh mi oa mk ml mm im bi translated"><strong class="lt iu"> Dplyr </strong></p><p id="5685" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma ny mc md me nz mg mh mi oa mk ml mm im bi translated">在Dplyr中，您可以在select()函数中使用前导的<strong class="lt iu">减号来指定要删除的列名。</strong></p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="a0a6" class="ni la it ne b gy nj nk l nl nm">dataframe &lt;- dataframe %&gt;% select(-New_feature)</span></pre></div><div class="ab cl oc od hx oe" role="separator"><span class="of bw bk og oh oi"/><span class="of bw bk og oh oi"/><span class="of bw bk og oh"/></div><div class="im in io ip iq"><h2 id="0673" class="ni la it bd lb nn no dn lf np nq dp lj ma nr ns ll me nt nu ln mi nv nw lp nx bi translated">按值对记录排序</h2><p id="f7ea" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">要对值进行排序，您可以在Pandas中使用<strong class="lt iu"> sort_values() </strong>，在Dplyr中使用<strong class="lt iu"> arrange() </strong>。两者的默认排序都是升序。请注意每个函数调用在降序排序方面的差异:</p><p id="3a8f" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma ny mc md me nz mg mh mi oa mk ml mm im bi translated"><strong class="lt iu">熊猫</strong></p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="3752" class="ni la it ne b gy nj nk l nl nm">dataframe.sort_values('Petal_width', ascending=0)</span></pre><p id="75cf" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma ny mc md me nz mg mh mi oa mk ml mm im bi translated"><strong class="lt iu"> Dplyr </strong></p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="17ab" class="ni la it ne b gy nj nk l nl nm">dataframe %&gt;% arrange(desc(Petal_width))</span></pre></div><div class="ab cl oc od hx oe" role="separator"><span class="of bw bk og oh oi"/><span class="of bw bk og oh oi"/><span class="of bw bk og oh"/></div><div class="im in io ip iq"><h2 id="5cd6" class="ni la it bd lb nn no dn lf np nq dp lj ma nr ns ll me nt nu ln mi nv nw lp nx bi translated">重命名单列</h2><p id="ec72" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">重命名听起来像是一个简单的任务，但是要小心，注意这里的细微差别。如果我们想在Pandas中将我们的列<strong class="lt iu">从Species重命名为Class </strong>，我们提供一个字典，上面写着<strong class="lt iu"> {'Species': 'Class'} </strong>，而在Dplyr中，情况正好相反<strong class="lt iu"> Class=Species </strong>:</p><p id="878f" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma ny mc md me nz mg mh mi oa mk ml mm im bi translated">熊猫</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="bf04" class="ni la it ne b gy nj nk l nl nm">dataframe.rename(columns = {'Species': 'Class'}, inplace = True)</span></pre><p id="dd86" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma ny mc md me nz mg mh mi oa mk ml mm im bi translated"><strong class="lt iu"> Dplyr </strong></p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="c71b" class="ni la it ne b gy nj nk l nl nm">dataframe %&gt;% relocate(Species)<br/>dataframe %&gt;% relocate(Species, .before=Sepal_width)</span></pre></div><div class="ab cl oc od hx oe" role="separator"><span class="of bw bk og oh oi"/><span class="of bw bk og oh oi"/><span class="of bw bk og oh"/></div><div class="im in io ip iq"><h2 id="61f4" class="ni la it bd lb nn no dn lf np nq dp lj ma nr ns ll me nt nu ln mi nv nw lp nx bi translated">更改列的顺序</h2><p id="8101" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我不经常使用这个功能，但是如果我想为一个演示创建一个表格，并且列的排序没有逻辑意义，这个功能有时会很方便。以下是如何移动列:</p><p id="4327" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma ny mc md me nz mg mh mi oa mk ml mm im bi translated"><strong class="lt iu">熊猫</strong></p><p id="e65e" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma ny mc md me nz mg mh mi oa mk ml mm im bi translated">在Python Pandas中，您需要通过使用列表来重新索引您的列。假设我们想将列物种移到前面。</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="9000" class="ni la it ne b gy nj nk l nl nm">#change order of columns<br/>dataframe.reindex(['Species','Petal_length','Sepal_length','Sepal_width','Petal_Width'], axis=1)</span></pre><p id="7d0a" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma ny mc md me nz mg mh mi oa mk ml mm im bi translated"><strong class="lt iu"> Dplyr </strong></p><p id="6cfa" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma ny mc md me nz mg mh mi oa mk ml mm im bi translated">在Dplyr中，您可以使用方便的<strong class="lt iu"> relocate() </strong>函数。同样，假设我们想将列物种移到前面。</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="542f" class="ni la it ne b gy nj nk l nl nm">dataframe %&gt;% relocate(Species)</span><span id="62c3" class="ni la it ne b gy ob nk l nl nm">#Note that you can use .before or .after to place a columne before or after another specified column - very handy!<br/>dataframe %&gt;% relocate(Species, .before=SEPAL_WIDTH)</span></pre></div><div class="ab cl oc od hx oe" role="separator"><span class="of bw bk og oh oi"/><span class="of bw bk og oh oi"/><span class="of bw bk og oh"/></div><div class="im in io ip iq"><h1 id="5223" class="kz la it bd lb lc oj le lf lg ok li lj jz ol ka ll kc om kd ln kf on kg lp lq bi translated">限幅</h1><p id="c575" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">切片本身就是一个完整的主题，有很多方法可以实现。下面让我们来看一下最常用的切片操作:</p><h2 id="e538" class="ni la it bd lb nn no dn lf np nq dp lj ma nr ns ll me nt nu ln mi nv nw lp nx bi translated">按行切片</h2><p id="227d" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">有时您知道想要提取的确切行号。虽然Dplyr和Pandas中的过程非常相似<strong class="lt iu">，但是请注意Python中的索引从0开始，而R中的索引从1开始。</strong></p><p id="e7ff" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma ny mc md me nz mg mh mi oa mk ml mm im bi translated"><strong class="lt iu">熊猫</strong></p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="36b4" class="ni la it ne b gy nj nk l nl nm">dataframe.iloc[[49,50]]</span><span id="1e33" class="ni la it ne b gy ob nk l nl nm">#  Sepal_length  Sepal_width  Petal_length  Petal_width    Species<br/>#          5.0          3.3           1.4          0.2      setosa<br/>#          7.0          3.2           4.7          1.4  versicolor</span></pre><p id="35fe" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma ny mc md me nz mg mh mi oa mk ml mm im bi translated"><strong class="lt iu"> Dplyr </strong></p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="5362" class="ni la it ne b gy nj nk l nl nm">dataframe %&gt;% slice(50,51)</span><span id="0ac7" class="ni la it ne b gy ob nk l nl nm">#  Sepal_length Sepal_width Petal_length Petal_width Species     <br/>#1            5         3.3          1.4         0.2 setosa    <br/>#2            7         3.2          4.7         1.4 versicolor</span></pre></div><div class="ab cl oc od hx oe" role="separator"><span class="of bw bk og oh oi"/><span class="of bw bk og oh oi"/><span class="of bw bk og oh"/></div><div class="im in io ip iq"><h2 id="8e28" class="ni la it bd lb nn no dn lf np nq dp lj ma nr ns ll me nt nu ln mi nv nw lp nx bi translated">分割第一个和最后一个记录(头/尾)</h2><p id="ba28" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">有时我们希望看到数据帧中的第一条或最后一条记录。这可以通过提供一个<strong class="lt iu">固定数量n </strong>或一个<strong class="lt iu">比例prop </strong>值来实现。</p><p id="3175" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma ny mc md me nz mg mh mi oa mk ml mm im bi translated"><strong class="lt iu">熊猫</strong></p><p id="6fbd" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma ny mc md me nz mg mh mi oa mk ml mm im bi translated">在Pandas中，您可以使用<strong class="lt iu"> head() </strong>或<strong class="lt iu"> tail() </strong>方法来获取固定数量的记录。如果你想提取一个比例，你必须自己计算一下:</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="3150" class="ni la it ne b gy nj nk l nl nm">#returns the first 5 records<br/>dataframe.head(n=5)</span><span id="8ad6" class="ni la it ne b gy ob nk l nl nm">#returns the last 10% of total records<br/>dataframe.tail(n=len(dataframe)*0.1)</span></pre><p id="83e3" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma ny mc md me nz mg mh mi oa mk ml mm im bi translated"><strong class="lt iu"> Dplyr </strong></p><p id="c338" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma ny mc md me nz mg mh mi oa mk ml mm im bi translated">在Dplyr中，有两个为这个用例指定的函数:<strong class="lt iu"> slice_head() </strong>和<strong class="lt iu"> slice_tail() </strong>。请注意如何指定固定数量或比例:</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="b7b4" class="ni la it ne b gy nj nk l nl nm">#returns the first 5 records<br/>dataframe %&gt;% slice_head(n=5)</span><span id="dbbd" class="ni la it ne b gy ob nk l nl nm">#returns the last 10% of total records<br/>dataframe %&gt;% slice_tail(prop=0.1)</span></pre></div><div class="ab cl oc od hx oe" role="separator"><span class="of bw bk og oh oi"/><span class="of bw bk og oh oi"/><span class="of bw bk og oh"/></div><div class="im in io ip iq"><h2 id="5e26" class="ni la it bd lb nn no dn lf np nq dp lj ma nr ns ll me nt nu ln mi nv nw lp nx bi translated">按值对第一条和最后一条记录进行切片</h2><p id="a600" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">有时，选择每列具有最高或最低值的记录很有用。同样，这可以通过提供固定的数量或比例来实现。</p><p id="fa6f" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma ny mc md me nz mg mh mi oa mk ml mm im bi translated"><strong class="lt iu">熊猫</strong></p><p id="4505" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma ny mc md me nz mg mh mi oa mk ml mm im bi translated">对于熊猫来说，这比Dplyr更棘手。例如，假设您想要20个具有最长“花瓣长度”的记录，或者10%的总记录具有最短的“花瓣长度”。要在Python中进行第二个操作，我们必须做一些数学计算，首先对我们的值进行排序:</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="d711" class="ni la it ne b gy nj nk l nl nm">#returns 20 records with the longest Petal_length (for returning the shortest you can use the function nsmallest)<br/>dataframe.nlargest(20, 'Petal_length')</span><span id="48cc" class="ni la it ne b gy ob nk l nl nm">#returns 10% of total records with the shortest Petal_length<br/>prop = 0.1 <br/>dataframe.sort_values('Petal_length', ascending=1).head(int(len(dataframe)*prop))</span></pre><p id="6b2b" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma ny mc md me nz mg mh mi oa mk ml mm im bi translated"><strong class="lt iu"> Dplyr </strong></p><p id="68bc" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma ny mc md me nz mg mh mi oa mk ml mm im bi translated">在Dplyr中，这要简单得多，因为此用例有指定的函数:</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="2d8b" class="ni la it ne b gy nj nk l nl nm">#returns 20 records with the longest Petal_length<br/>dataframe %&gt;% slice_max(Petal_length, n = 20)</span><span id="f034" class="ni la it ne b gy ob nk l nl nm">#returns 10% of total records with the shortest Petal_lengthdataframe %&gt;% slice_min(Petal_length, prop = 0.1)</span></pre></div><div class="ab cl oc od hx oe" role="separator"><span class="of bw bk og oh oi"/><span class="of bw bk og oh oi"/><span class="of bw bk og oh"/></div><div class="im in io ip iq"><h2 id="8af4" class="ni la it bd lb nn no dn lf np nq dp lj ma nr ns ll me nt nu ln mi nv nw lp nx bi translated">按值和组对第一条和最后一条记录进行切片</h2><p id="6f40" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">有时，选择每列具有最高或最低值的记录<strong class="lt iu">，但由组</strong>分隔，这很有用。同样，这可以通过提供固定的数量或比例来实现。想象一下，例如我们想要3个每个物种花瓣长度最短的记录。</p><p id="c7b8" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma ny mc md me nz mg mh mi oa mk ml mm im bi translated"><strong class="lt iu">熊猫</strong></p><p id="7704" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma ny mc md me nz mg mh mi oa mk ml mm im bi translated">对熊猫来说，这也比Dplyr更棘手。我们首先按照物种对数据帧进行分组，然后应用一个<strong class="lt iu"> lambda </strong>函数，该函数利用了上述的<strong class="lt iu"> nsmallest() </strong>或<strong class="lt iu"> nlargest() </strong>函数:</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="e541" class="ni la it ne b gy nj nk l nl nm">#returns 3 records with the shortest Petal_length per Species<br/>(dataframe.groupby('Species',group_keys=False)<br/>        .apply(lambda x: x.nsmallest(3, 'Petal_length')))</span><span id="396d" class="ni la it ne b gy ob nk l nl nm">#Sepal_length  Sepal_width  Petal_length  Petal_width     Species<br/>#        4.6          3.6           1.0          0.2      setosa<br/>#        4.3          3.0           1.1          0.1      setosa<br/>#        5.8          4.0           1.2          0.2      setosa<br/>#        5.1          2.5           3.0          1.1  versicolor<br/>#        4.9          2.4           3.3          1.0  versicolor<br/>#        5.0          2.3           3.3          1.0  versicolor<br/>#        4.9          2.5           4.5          1.7   virginica<br/>#        6.2          2.8           4.8          1.8   virginica<br/>#        6.0          3.0           4.8          1.8   virginica</span><span id="1a9f" class="ni la it ne b gy ob nk l nl nm">#returns 5% of total records with the longest Petal_length per Species<br/>prop = 0.05<br/>(dataframe.groupby('Species',group_keys=False)<br/>        .apply(lambda x: x.nlargest(int(len(x) * prop), 'Petal_length')))</span><span id="a709" class="ni la it ne b gy ob nk l nl nm">#Sepal_length  Sepal_width  Petal_length  Petal_width     Species<br/>#         4.8          3.4           1.9          0.2      setosa<br/>#         5.1          3.8           1.9          0.4      setosa<br/>#         6.0          2.7           5.1          1.6  versicolor<br/>#         6.7          3.0           5.0          1.7  versicolor<br/>#         7.7          2.6           6.9          2.3   virginica<br/>#         7.7          3.8           6.7          2.2   virginica</span></pre><p id="876d" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma ny mc md me nz mg mh mi oa mk ml mm im bi translated"><strong class="lt iu"> Dplyr </strong></p><p id="c306" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma ny mc md me nz mg mh mi oa mk ml mm im bi translated">在Dplyr中，这要简单得多，因为这个用例有指定的函数。注意如何提供<strong class="lt iu"> with_ties=FALSE </strong>来指定是否应该返回ties(具有相等值的记录)。</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="281f" class="ni la it ne b gy nj nk l nl nm">#returns 3 records with the shortest Petal_length per Species<br/>dataframe %&gt;% group_by(Species) %&gt;% slice_min(Petal_length, n = 3, with_ties = FALSE)</span><span id="62df" class="ni la it ne b gy ob nk l nl nm">#returns 5% of total records with the longest Petal_length per Species<br/>dataframe %&gt;% group_by(Species) %&gt;% slice_max(Petal_length, prop = 0.05, with_ties=FALSE)</span></pre></div><div class="ab cl oc od hx oe" role="separator"><span class="of bw bk og oh oi"/><span class="of bw bk og oh oi"/><span class="of bw bk og oh"/></div><div class="im in io ip iq"><h2 id="f7f5" class="ni la it bd lb nn no dn lf np nq dp lj ma nr ns ll me nt nu ln mi nv nw lp nx bi translated">切片随机记录(每组)—抽样</h2><p id="63d6" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">对随机记录进行切片也可以称为抽样。这也可以通过证明一个固定的数字或比例来实现。此外，这可以在整个数据集上进行，也可以基于组平均分布。因为这是一个相当频繁的用例，所以在两个框架中都有这样的函数:</p><p id="485f" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma ny mc md me nz mg mh mi oa mk ml mm im bi translated"><strong class="lt iu">熊猫</strong></p><p id="659e" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma ny mc md me nz mg mh mi oa mk ml mm im bi translated">在Pandas中，您可以使用<strong class="lt iu"> sample() </strong>函数，或者指定<strong class="lt iu"> n </strong>为固定数量的记录，或者指定<strong class="lt iu"> frac </strong>为一定比例的记录。此外，您可以指定<strong class="lt iu">替换</strong>来允许或不允许对同一行进行多次采样。</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="674d" class="ni la it ne b gy nj nk l nl nm">#returns 20 random samples<br/>dataframe.sample(n=20)</span><span id="5464" class="ni la it ne b gy ob nk l nl nm">#return 20% of total records<br/>dataframe.sample(frac=0.2, replace=True)</span><span id="64d7" class="ni la it ne b gy ob nk l nl nm">#returns 10% of total records split by group<br/>dataframe.groupby('Species').sample(frac=0.1)</span></pre><p id="3923" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma ny mc md me nz mg mh mi oa mk ml mm im bi translated"><strong class="lt iu"> Dplyr </strong></p><p id="5a73" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma ny mc md me nz mg mh mi oa mk ml mm im bi translated">Dplyr中的界面非常相似。您可以使用<strong class="lt iu"> slice_sample() </strong>函数，或者为固定数量的记录指定<strong class="lt iu"> n </strong>，或者为一定比例的记录指定<strong class="lt iu"> prop </strong>。此外，您可以指定<strong class="lt iu">替换</strong>以允许或不允许对同一行进行多次采样。</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="24c8" class="ni la it ne b gy nj nk l nl nm">#returns 20 random samples<br/>dataframe %&gt;% slice_sample(n=20)</span><span id="6bb8" class="ni la it ne b gy ob nk l nl nm">#return 20% of total records<br/>dataframe %&gt;% slice_sample(prop=0.2, replace=True)</span><span id="fb0a" class="ni la it ne b gy ob nk l nl nm">#returns 10% of total records split by group<br/>dataframe %&gt;% group_by(Species) %&gt;% slice_sample(prop=0.1)</span></pre></div><div class="ab cl oc od hx oe" role="separator"><span class="of bw bk og oh oi"/><span class="of bw bk og oh oi"/><span class="of bw bk og oh"/></div><div class="im in io ip iq"><h2 id="50ae" class="ni la it bd lb nn no dn lf np nq dp lj ma nr ns ll me nt nu ln mi nv nw lp nx bi translated">连接</h2><p id="8352" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">连接数据框架也是一个常见的用例。(join操作范围很广，但我不打算在此详述)</p><p id="407f" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma ny mc md me nz mg mh mi oa mk ml mm im bi translated">但是，随后您将学习如何在Pandas和Dplyr中执行完全(外部)连接。</p><p id="1cef" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma ny mc md me nz mg mh mi oa mk ml mm im bi translated">图像您有两个共享一个公共变量“key”的数据帧:</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="5ab8" class="ni la it ne b gy nj nk l nl nm">#Python Pandas<br/>A = dataframe[[“Species”, “Sepal_width”]]<br/>B = dataframe[[“Species”, “Sepal_length”]]</span><span id="b4dc" class="ni la it ne b gy ob nk l nl nm">#R Dplyr:<br/>A &lt;- dataframe %&gt;% select(Species, Sepal_width)<br/>B &lt;- dataframe %&gt;% select(Species, Sepal_length)</span></pre><p id="aff2" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma ny mc md me nz mg mh mi oa mk ml mm im bi translated"><strong class="lt iu">熊猫</strong></p><p id="769c" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma ny mc md me nz mg mh mi oa mk ml mm im bi translated">对于所有的加入操作，你可以使用Pandas中的“<a class="ae ky" href="https://pandas.pydata.org/pandas-docs/stable/user_guide/merging.html" rel="noopener ugc nofollow" target="_blank">合并</a>”功能，并指定你想加入什么，如何加入(外部，内部，左侧，右侧，..)您想加入哪个键:</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="8684" class="ni la it ne b gy nj nk l nl nm">#Join dataframe A and B (WHAT), with a full join (HOW) by making use of the key "Species" (ON) <br/>pd.merge(A, B, how="outer", on="Species")</span></pre><p id="7fbb" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma ny mc md me nz mg mh mi oa mk ml mm im bi translated"><strong class="lt iu"> Dplyr </strong></p><p id="7d14" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma ny mc md me nz mg mh mi oa mk ml mm im bi translated">在Dplyr中，语法非常相似，但是，对于每种连接类型，都有<a class="ae ky" href="https://dplyr.tidyverse.org/reference/join.html" rel="noopener ugc nofollow" target="_blank">单独的函数。在本例中，我们将再次使用<strong class="lt iu"> full_join() </strong>函数执行完全连接:</a></p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="f90d" class="ni la it ne b gy nj nk l nl nm">#Join dataframe A and B (WHAT), with a full join (HOW) by making use of the key "Species" (ON)<br/>A %&gt;% full_join(B, by="Species")</span></pre></div><div class="ab cl oc od hx oe" role="separator"><span class="of bw bk og oh oi"/><span class="of bw bk og oh oi"/><span class="of bw bk og oh"/></div><div class="im in io ip iq"><h2 id="df75" class="ni la it bd lb nn no dn lf np nq dp lj ma nr ns ll me nt nu ln mi nv nw lp nx bi translated">连接/绑定行和列</h2><p id="b356" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">有时我们不想连接我们的数据帧，而只是通过行或列附加两个现有的数据帧。熊猫和Dplyr都有一个很好的界面来实现这一点:</p><p id="b883" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma ny mc md me nz mg mh mi oa mk ml mm im bi translated">熊猫</p><p id="df4a" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma ny mc md me nz mg mh mi oa mk ml mm im bi translated">在Pandas中，可以用<strong class="lt iu"> concat() </strong>方法连接两个数据帧。默认值按行连接数据帧。通过指定轴(例如轴= 1)，可以通过列连接两个数据帧。</p><p id="b6cb" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma ny mc md me nz mg mh mi oa mk ml mm im bi translated">请注意，如果某个值没有出现在其中一个数据帧中，它会自动填充NA。</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="9374" class="ni la it ne b gy nj nk l nl nm">#Concatenate by rows<br/>pd.concat([A,B])</span><span id="d796" class="ni la it ne b gy ob nk l nl nm">#       Species  Sepal_width  Sepal_length<br/>#0       setosa          3.5           NaN<br/>#1       setosa          3.0           NaN<br/>#2       setosa          3.2           NaN<br/>#3       setosa          3.1           NaN<br/># ...</span><span id="41b4" class="ni la it ne b gy ob nk l nl nm"><br/>#Concatenate by columns <br/>pd.concat([A,B], axis=1)</span><span id="109a" class="ni la it ne b gy ob nk l nl nm">#       Species  Sepal_width    Species  Sepal_length<br/>#0       setosa          3.5     setosa           5.1<br/>#1       setosa          3.0     setosa           4.9<br/>#2       setosa          3.2     setosa           4.7<br/>#3       setosa          3.1     setosa           4.6<br/># ...</span></pre><p id="19ca" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma ny mc md me nz mg mh mi oa mk ml mm im bi translated"><strong class="lt iu"> Dplyr </strong></p><p id="5a52" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma ny mc md me nz mg mh mi oa mk ml mm im bi translated">在Dplyr中，有两个独立的函数用于绑定数据帧:<strong class="lt iu"> bind_rows() </strong>和<strong class="lt iu"> bind_columns()。</strong></p><p id="3b3e" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma ny mc md me nz mg mh mi oa mk ml mm im bi translated">请注意，如果某个值没有出现在其中一个数据帧中，那么在应用bind_rows()时，它会自动填充NA。另外，请注意R如何自动更改列名(以避免重复)。使用<strong class="lt iu">可以改变这种行为。name_repair参数。</strong></p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="31be" class="ni la it ne b gy nj nk l nl nm">#Bind by rows<br/>A %&gt;% bind_rows(B)</span><span id="3c62" class="ni la it ne b gy ob nk l nl nm">#   Species Sepal_width Sepal_length<br/># 1 setosa          3.5           NA<br/># 2 setosa          3             NA<br/># 3 setosa          3.2           NA<br/># 4 setosa          3.1           NA<br/># ...</span><span id="37a3" class="ni la it ne b gy ob nk l nl nm">#Bind by columns<br/>A %&gt;% bind_cols(B)</span><span id="eae7" class="ni la it ne b gy ob nk l nl nm">#  Species...1 Sepal_width Species...3 Sepal_length<br/># 1 setosa              3.5 setosa               5.1<br/># 2 setosa              3   setosa               4.9<br/># 3 setosa              3.2 setosa               4.7</span></pre></div><div class="ab cl oc od hx oe" role="separator"><span class="of bw bk og oh oi"/><span class="of bw bk og oh oi"/><span class="of bw bk og oh"/></div><div class="im in io ip iq"><p id="3578" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma ny mc md me nz mg mh mi oa mk ml mm im bi translated">Pfew！恭喜你！你可能是第一个读到这篇文章/备忘单结尾的人。您可以通过给我鼓掌或在下面给我留言来获得奖励:)</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oo op l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来自<a class="ae ky" href="http://gph.is/13EZhH1" rel="noopener ugc nofollow" target="_blank"> Giphy </a></p></figure></div></div>    
</body>
</html>