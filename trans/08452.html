<html>
<head>
<title>Reproducible Work in R</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">R中的可复制作品</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/reproducible-work-in-r-e7d160d5d198?source=collection_archive---------12-----------------------#2021-08-04">https://towardsdatascience.com/reproducible-work-in-r-e7d160d5d198?source=collection_archive---------12-----------------------#2021-08-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="b890" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">为什么以及如何在日常工作流程中使用Docker</h2></div><h1 id="0a63" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">疼痛源</h1><ul class=""><li id="20ca" class="kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">作为数据科学家，我们在处理生产级代码库时面临的最大挑战之一是确保端到端的可重复性和长期稳定性。</li><li id="36de" class="kx ky iq kz b la lp lc lq le lr lg ls li lt lk ll lm ln lo bi translated">这也会延伸到学术界，但我不是院士。</li><li id="50ff" class="kx ky iq kz b la lp lc lq le lr lg ls li lt lk ll lm ln lo bi translated">基本的R setup没有内置的功能来存储包版本和依赖关系(例如，不像在conda环境中运行)。</li><li id="3092" class="kx ky iq kz b la lp lc lq le lr lg ls li lt lk ll lm ln lo bi translated">如果你的默认库是CRAN，这是一个大问题，因为CRAN每天都在更新。</li><li id="a155" class="kx ky iq kz b la lp lc lq le lr lg ls li lt lk ll lm ln lo bi translated">我发现像<code class="fe lu lv lw lx b">pkgdown</code>这样的解决方案用起来太麻烦了。我甚至尝试过在conda环境下工作，但我不是一个粉丝。</li><li id="f28b" class="kx ky iq kz b la lp lc lq le lr lg ls li lt lk ll lm ln lo bi translated">数据科学家之间的团队合作增加了额外的复杂性。根据我的经验:</li><li id="09ca" class="kx ky iq kz b la lp lc lq le lr lg ls li lt lk ll lm ln lo bi translated">一个团队中的成员可以拥有所有东西的不同版本——OS、R内核、包、库、环境变量…!</li><li id="00f0" class="kx ky iq kz b la lp lc lq le lr lg ls li lt lk ll lm ln lo bi translated">一些人在升级他们的系统上是保守的；其他人很乐意尝试新版本的软件包</li><li id="c18b" class="kx ky iq kz b la lp lc lq le lr lg ls li lt lk ll lm ln lo bi translated">跨操作系统工作经常会带来意想不到的问题(IME，特别是那些允许并行计算的函数<code class="fe lu lv lw lx b">mcapply</code>、<code class="fe lu lv lw lx b">future</code>)。)</li><li id="634f" class="kx ky iq kz b la lp lc lq le lr lg ls li lt lk ll lm ln lo bi translated">当在本地系统(可能是Windows)上开发代码库，但在另一个环境(可能是Linux)中部署代码库时，这就成了问题</li></ul><h1 id="57b1" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">解决办法</h1><p id="a9f0" class="pw-post-body-paragraph ly lz iq kz b la lb jr ma lc ld ju mb le mc md me lg mf mg mh li mi mj mk lk ij bi translated">根据我的经验，我下面概述的解决方案为我提供了一个长期可再现性和代码稳定性的优秀方法:</p><ol class=""><li id="8e92" class="kx ky iq kz b la ml lc mm le mn lg mo li mp lk mq lm ln lo bi translated">使用MRAN快照锁定您的R包版本</li><li id="f613" class="kx ky iq kz b la lp lc lq le lr lg ls li lt lk mq lm ln lo bi translated">使用Docker图像锁定您的工作环境</li><li id="0ba9" class="kx ky iq kz b la lp lc lq le lr lg ls li lt lk mq lm ln lo bi translated">在Docker容器中进行所有开发</li><li id="76d7" class="kx ky iq kz b la lp lc lq le lr lg ls li lt lk mq lm ln lo bi translated">为所有项目附上Docker图像</li></ol><p id="2dfb" class="pw-post-body-paragraph ly lz iq kz b la ml jr ma lc mm ju mb le mr md me lg ms mg mh li mt mj mk lk ij bi translated">这非常有效，我已经有半年多没有在本地机器上使用R/Rstudio了。</p><h1 id="a4a0" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">1.MRAN时间机器</h1><p id="3c4a" class="pw-post-body-paragraph ly lz iq kz b la lb jr ma lc ld ju mb le mc md me lg mf mg mh li mi mj mk lk ij bi translated">微软R应用网(MRAN)提供了一款“<a class="ae mu" href="https://mran.microsoft.com/timemachine" rel="noopener ugc nofollow" target="_blank">时光机</a>”。这项服务为<a class="ae mu" href="http://cran.r-project.org" rel="noopener ugc nofollow" target="_blank"> CRAN仓库</a>仓库拍摄每日快照，时间可以追溯到2014年9月。您可以在他们的页面上浏览快照:</p><figure class="mw mx my mz gt na gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi mv"><img src="../Images/d240e5a8fd2090507d347d26a62791bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*qACVGWPraWOMRUQw.png"/></div></div><p class="nh ni gj gh gi nj nk bd b be z dk translated">MRAN网站截图。来自作者。</p></figure><p id="3211" class="pw-post-body-paragraph ly lz iq kz b la ml jr ma lc mm ju mb le mr md me lg ms mg mh li mt mj mk lk ij bi translated">MRAN快照使用日期作为“索引”，帮助我们锁定软件包版本。例如，运行:</p><pre class="mw mx my mz gt nl lx nm nn aw no bi"><span id="31b1" class="np kg iq lx b gy nq nr l ns nt">install.packages("lattice", <br/>                 repos = "https://mran.microsoft.com/snapshot/2020-10-01")</span></pre><p id="f919" class="pw-post-body-paragraph ly lz iq kz b la ml jr ma lc mm ju mb le mr md me lg ms mg mh li mt mj mk lk ij bi translated">将于2020年10月1日安装<code class="fe lu lv lw lx b">{lattice}</code>版本。</p><p id="5fda" class="pw-post-body-paragraph ly lz iq kz b la ml jr ma lc mm ju mb le mr md me lg ms mg mh li mt mj mk lk ij bi translated">现在，这种方法并没有使选择随时间发布的包<em class="nu">的<em class="nu">特定版本</em>变得更容易，而是允许您锁定一个日期，只获得在所选日期可用的那些版本。这意味着在10月1日之后的任何一天运行“更新包”都不会改变你的包配置。</em></p><pre class="mw mx my mz gt nl lx nm nn aw no bi"><span id="8ef0" class="np kg iq lx b gy nq nr l ns nt">&gt; options(repos = "https://mran.microsoft.com/snapshot/2020-10-01")<br/>&gt; getOption("repos")<br/>[1] "https://mran.microsoft.com/snapshot/2020-10-01"</span></pre><h1 id="0f94" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">2.Docker图像</h1><h1 id="47f8" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">文档文件</h1><p id="a619" class="pw-post-body-paragraph ly lz iq kz b la lb jr ma lc ld ju mb le mc md me lg mf mg mh li mi mj mk lk ij bi translated"><code class="fe lu lv lw lx b">Dockerfile</code>保存了如何构建docker映像的定义。我用来维护这个博客的Dockerfile保存在<a class="ae mu" href="https://github.com/rsangole/blog/blob/master/docker/Dockerfile" rel="noopener ugc nofollow" target="_blank">这里</a>。它也在hub.docker.com举办。</p><p id="d3b8" class="pw-post-body-paragraph ly lz iq kz b la ml jr ma lc mm ju mb le mr md me lg ms mg mh li mt mj mk lk ij bi translated">下面是对该文件的快速解释。要更深入地了解Dockerfiles，网上有很多资源<a class="ae mu" href="https://rollout.io/blog/a-beginners-guide-to-the-dockerfile/" rel="noopener ugc nofollow" target="_blank"> 1 </a>、<a class="ae mu" href="https://linuxhint.com/understand_dockerfile/" rel="noopener ugc nofollow" target="_blank"> 2 </a>、<a class="ae mu" href="https://blog.hipolabs.com/understanding-docker-without-losing-your-shit-cf2b30307c63" rel="noopener ugc nofollow" target="_blank"> 3 </a>。</p><h2 id="0967" class="np kg iq bd kh nv nw dn kl nx ny dp kp le nz oa kr lg ob oc kt li od oe kv of bi translated">从</h2><p id="8d86" class="pw-post-body-paragraph ly lz iq kz b la lb jr ma lc ld ju mb le mc md me lg mf mg mh li mi mj mk lk ij bi translated">我使用的是<code class="fe lu lv lw lx b">rocker/tidyverse:4.0.0</code> <a class="ae mu" href="https://hub.docker.com/layers/rocker/tidyverse/4.0.0/images/sha256-b5dca99adfd18ae14ba50dcbc4aaaec2674138bc75015104a77a9805694c157a?context=explore" rel="noopener ugc nofollow" target="_blank">图像</a>，它提供了一个很好的起点。它预装了R 4 . 0 . 0版和tidyverse包。</p><pre class="mw mx my mz gt nl lx nm nn aw no bi"><span id="2e86" class="np kg iq lx b gy nq nr l ns nt">FROM rocker/tidyverse:4.0.0</span></pre><h2 id="b765" class="np kg iq bd kh nv nw dn kl nx ny dp kp le nz oa kr lg ob oc kt li od oe kv of bi translated">奔跑</h2><p id="4577" class="pw-post-body-paragraph ly lz iq kz b la lb jr ma lc ld ju mb le mc md me lg mf mg mh li mi mj mk lk ij bi translated">这将安装后续R包工作所需的许多linux库。我还安装了一些有用的实用软件包，如<code class="fe lu lv lw lx b">curl</code>、<code class="fe lu lv lw lx b">jq</code>和<code class="fe lu lv lw lx b">vim</code>。</p><pre class="mw mx my mz gt nl lx nm nn aw no bi"><span id="0091" class="np kg iq lx b gy nq nr l ns nt">RUN apt-get update &amp;&amp; apt-get install -y --no-install-recommends \<br/>        libgit2-dev \<br/>        libxml2-dev \<br/>        ... \<br/>        ... \<br/>        curl \<br/>        tree \<br/>        jq \<br/>        htop \<br/>        texinfo \<br/>        vim \<br/>        man-db \<br/>        less</span></pre><h2 id="b3da" class="np kg iq bd kh nv nw dn kl nx ny dp kp le nz oa kr lg ob oc kt li od oe kv of bi translated">环境+ R PKG安装</h2><p id="a50a" class="pw-post-body-paragraph ly lz iq kz b la lb jr ma lc ld ju mb le mc md me lg mf mg mh li mi mj mk lk ij bi translated">我在这里设置MRAN的构建日期，然后安装我需要的R包，使用<code class="fe lu lv lw lx b">install2.r</code>和<code class="fe lu lv lw lx b">-r</code>参数指向MRAN时间机器而不是CRAN。</p><pre class="mw mx my mz gt nl lx nm nn aw no bi"><span id="2ecb" class="np kg iq lx b gy nq nr l ns nt">ENV MRAN_BUILD_DATE=2020-09-01</span><span id="b9c2" class="np kg iq lx b gy og nr l ns nt"># Install Basic Utility R Packages<br/>RUN install2.r -r https://cran.microsoft.com/snapshot/${MRAN_BUILD_DATE} \<br/>    --error \<br/>    rgl \<br/>    data.table \<br/>    reprex \<br/>    # ~ 30 more R Packages<br/>    ... \<br/>    ... </span></pre><h2 id="48d3" class="np kg iq bd kh nv nw dn kl nx ny dp kp le nz oa kr lg ob oc kt li od oe kv of bi translated">构建和推送</h2><p id="0f41" class="pw-post-body-paragraph ly lz iq kz b la lb jr ma lc ld ju mb le mc md me lg mf mg mh li mi mj mk lk ij bi translated">构建docker映像并将其推送到<code class="fe lu lv lw lx b">hub.docker.com</code>。</p><pre class="mw mx my mz gt nl lx nm nn aw no bi"><span id="9cbc" class="np kg iq lx b gy nq nr l ns nt">docker build . -t hatmatrix/blog:latest<br/>docker push hatmatrix/blog:latest</span></pre><p id="765c" class="pw-post-body-paragraph ly lz iq kz b la ml jr ma lc mm ju mb le mr md me lg ms mg mh li mt mj mk lk ij bi translated">你的docker图片现在可以在线提供给任何运行你的项目的人。</p><h1 id="ec9c" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">3.在Docker中开发</h1><p id="c05d" class="pw-post-body-paragraph ly lz iq kz b la lb jr ma lc ld ju mb le mc md me lg mf mg mh li mi mj mk lk ij bi translated">现在我有了一个稳定的docker图片，可以用在这个博客上。我可以用这个shell命令运行映像:</p><pre class="mw mx my mz gt nl lx nm nn aw no bi"><span id="28f2" class="np kg iq lx b gy nq nr l ns nt">docker run <br/>    -d <br/>    -e PASSWORD=1234 <br/>    -v ~/github/:/home/rstudio/projects/ <br/>    -p 3838:3838 <br/>    -p 8787:8787 <br/>    hatmatrix/blog:latest</span></pre><p id="55b9" class="pw-post-body-paragraph ly lz iq kz b la ml jr ma lc mm ju mb le mr md me lg ms mg mh li mt mj mk lk ij bi translated">该命令的组成部分包括:</p><ul class=""><li id="5443" class="kx ky iq kz b la ml lc mm le mn lg mo li mp lk ll lm ln lo bi translated"><code class="fe lu lv lw lx b">docker run</code>:运行docker镜像…</li><li id="cb88" class="kx ky iq kz b la lp lc lq le lr lg ls li lt lk ll lm ln lo bi translated"><code class="fe lu lv lw lx b">-d</code>:在分离模式下，即一旦图像在后台运行，您将得到您的shell提示</li><li id="f96f" class="kx ky iq kz b la lp lc lq le lr lg ls li lt lk ll lm ln lo bi translated"><code class="fe lu lv lw lx b">-e PASSWORD=1234</code> : <code class="fe lu lv lw lx b">-e</code>是附加参数。这里，我们将Rstudio密码设置为1234</li><li id="4bc3" class="kx ky iq kz b la lp lc lq le lr lg ls li lt lk ll lm ln lo bi translated"><code class="fe lu lv lw lx b">-v</code>:这将我本地机器上的<code class="fe lu lv lw lx b">~/github/</code>映射到docker容器中的<code class="fe lu lv lw lx b">~/home/rstudio/projects/</code></li><li id="1e9c" class="kx ky iq kz b la lp lc lq le lr lg ls li lt lk ll lm ln lo bi translated">这些参数将端口从我的本地机器映射到docker中的端口。我们需要一个用于rstudio (8787)的，一个用于我们从rstudio (3838)中启动的任何闪亮的应用程序</li><li id="d3b6" class="kx ky iq kz b la lp lc lq le lr lg ls li lt lk ll lm ln lo bi translated"><code class="fe lu lv lw lx b">hatmatrix/blog:latest</code>:这是docker图像的名称</li></ul><p id="94eb" class="pw-post-body-paragraph ly lz iq kz b la ml jr ma lc mm ju mb le mr md me lg ms mg mh li mt mj mk lk ij bi translated"><strong class="kz ir"/><code class="fe lu lv lw lx b"><strong class="kz ir">-v</strong></code><strong class="kz ir">:</strong>没有<code class="fe lu lv lw lx b">-v</code>你将无法访问docker容器中的任何本地文件。请记住，docker容器与您的本地机器完全隔离。此外，由于容器是短暂的(即短暂的&amp;临时的)，一旦容器关闭，您将永久丢失存储在其中的任何数据。映射到本地文件夹允许您处理本地存储在容器中的项目。</p><h1 id="81d1" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">4.Docker图像伴随R项目</h1><p id="fd56" class="pw-post-body-paragraph ly lz iq kz b la lb jr ma lc ld ju mb le mc md me lg mf mg mh li mi mj mk lk ij bi translated">只需在您的工作项目目录中创建一个<code class="fe lu lv lw lx b">/docker</code>文件夹，并保存您的docker文件。这里是我的博客的例子:<a class="ae mu" href="https://github.com/rsangole/blog/tree/master/docker" rel="noopener ugc nofollow" target="_blank">示例docker文件夹</a>。可选地，创建一个<code class="fe lu lv lw lx b">docker-build.sh</code>来节省一些输入。</p><h1 id="e4ba" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">就是这样！</h1><p id="20d6" class="pw-post-body-paragraph ly lz iq kz b la lb jr ma lc ld ju mb le mc md me lg mf mg mh li mi mj mk lk ij bi translated">这是一个轻量级的工作流程，无论我在哪个操作系统上工作，它都允许我保持完全的可再现性和代码稳定性。</p><h1 id="af4e" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">有用的链接</h1><ul class=""><li id="8690" class="kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated"><a class="ae mu" href="https://mran.microsoft.com/timemachine" rel="noopener ugc nofollow" target="_blank">https://mran.microsoft.com/timemachine</a></li><li id="1495" class="kx ky iq kz b la lp lc lq le lr lg ls li lt lk ll lm ln lo bi translated"><a class="ae mu" href="https://github.com/rocker-org/rocker" rel="noopener ugc nofollow" target="_blank">https://github.com/rocker-org/rocker</a></li></ul></div></div>    
</body>
</html>