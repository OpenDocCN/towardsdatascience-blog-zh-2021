<html>
<head>
<title>Dashboarding made easy using Python and Elasticsearch</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Python和Elasticsearch简化仪表板</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/kafka-elasticsearch-kibana-and-python-e6e72598c1f3?source=collection_archive---------11-----------------------#2021-06-02">https://towardsdatascience.com/kafka-elasticsearch-kibana-and-python-e6e72598c1f3?source=collection_archive---------11-----------------------#2021-06-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="bf2a" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用python、elasticsearch、apache Kafka和Kibana构建强大的仪表盘</h2></div><p id="6cf4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">流处理是一个非常强大的数据处理范例，它帮助我们以连续流的形式处理大量的数据点和记录，并允许我们实现实时处理速度。</p><blockquote class="lb lc ld"><p id="7d14" class="kf kg le kh b ki kj jr kk kl km ju kn lf kp kq kr lg kt ku kv lh kx ky kz la ij bi translated"><strong class="kh ir"> <em class="iq">阿帕奇卡夫卡</em> </strong>对于数据流来说是一个极其强大的工具。它具有高度的可扩展性和可靠性。[1]</p><p id="bfe5" class="kf kg le kh b ki kj jr kk kl km ju kn lf kp kq kr lg kt ku kv lh kx ky kz la ij bi translated"><strong class="kh ir"> <em class="iq"> Elasticsearch </em> </strong>是基于亮氨酸库的搜索引擎。它提供了一个分布式的全文搜索引擎，带有HTTP web接口和无模式的JSON文档。[2]</p><p id="2a63" class="kf kg le kh b ki kj jr kk kl km ju kn lf kp kq kr lg kt ku kv lh kx ky kz la ij bi translated">Kibana  是可视化我们的弹性搜索数据库/索引内容的优秀工具。它帮助我们非常快速地构建仪表板。[3]</p><p id="1f5e" class="kf kg le kh b ki kj jr kk kl km ju kn lf kp kq kr lg kt ku kv lh kx ky kz la ij bi translated">Python是每个人都喜欢的语言，因为它非常容易使用。</p></blockquote><p id="0b22" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这篇博客中，我们将看到如何利用上面的堆栈的力量，从真实数据中创建一个仪表板。</p><p id="0884" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了模拟一个流数据源，我们将使用一个包含随机系统日志的日志文件，我们将把这个信息推送到一个<strong class="kh ir"> <em class="le"> kafka </em> </strong>主题。图1给出了整个系统的架构</p><figure class="lj lk ll lm gt ln gh gi paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="gh gi li"><img src="../Images/8daafe90bda574f90b9602b07ea62b64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BywpkjXClKCh_47zwr0Eew.png"/></div></div><p class="lu lv gj gh gi lw lx bd b be z dk translated">图1:我们的流处理管道的架构图</p></figure><p id="921c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们从我们的<strong class="kh ir"> <em class="le">卡夫卡</em> </strong>制片人代码开始。让我们称这个为<strong class="kh ir"> <em class="le"> Producer.py. </em> </strong>在这个文件中，我们将执行以下操作→加载日志文件的内容并解析它，将数据推送到一个<strong class="kh ir"> <em class="le"> kafka </em> </strong>主题，供我们的另一个python程序使用，该程序将这些信息推送到<strong class="kh ir"><em class="le">elastic search</em></strong>。Kafka生产者代码块如下面的代码片段所示(图2)。生成器对象是在构造函数调用中创建的。<strong class="kh ir"> <em class="le">产生</em> </strong> <em class="le"> </em>方法获取一条消息，将其转换为<strong class="kh ir"> <em class="le"> json </em> </strong>并将其推送到指定的<strong class="kh ir"> <em class="le"> kafka </em> </strong>主题</p><figure class="lj lk ll lm gt ln gh gi paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="gh gi ly"><img src="../Images/a464138252564bd0ce394423c70f001f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i9J2JiWp1UJHHdBcbJfK1A.png"/></div></div><p class="lu lv gj gh gi lw lx bd b be z dk translated">图2: Kafka生产者代码块</p></figure><p id="1a39" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于这个程序，我使用的是<strong class="kh ir">confluent _ Kafka</strong><em class="le"/>python包。<strong class="kh ir"> Github链接→</strong><a class="ae lz" href="https://github.com/confluentinc/confluent-kafka-python" rel="noopener ugc nofollow" target="_blank"><strong class="kh ir"><em class="le">https://github.com/confluentinc/confluent-kafka-python</em></strong></a></p><p id="0d81" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在为日志文件编写解析器之前，让我们先看一下日志文件。下面的图3显示了日志文件中的一些行。</p><figure class="lj lk ll lm gt ln gh gi paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="gh gi ma"><img src="../Images/1a98f109406dc4bc18f17c86da12b637.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-i4Wgo_OcGnEgOVLlXeJpQ.png"/></div></div><p class="lu lv gj gh gi lw lx bd b be z dk translated">图3:日志文件内容</p></figure><p id="e046" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面给出了解析日志并以python字典格式返回消息的代码块(图4)。在检查日志文件时，我们注意到日志消息有以下类型→ <strong class="kh ir"> <em class="le"> ["信息"、"错误"、"严重"、"警告"] </em> </strong>。这些信息将有助于在<strong class="kh ir"> <em class="le"> Kibana </em> </strong>仪表盘上对我们的数据进行分类。</p><figure class="lj lk ll lm gt ln gh gi paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="gh gi mb"><img src="../Images/16a66984b720f6bc6141092c7ce8eaf2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nsx85sf12395AzT5TgI3Jw.png"/></div></div><p class="lu lv gj gh gi lw lx bd b be z dk translated">图4:我们日志文件的解析器</p></figure><p id="dd80" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">图4中的解析器类相当简单。我们有几个函数来加载日志文件，并使用<strong class="kh ir"> <em class="le"> iter </em> </strong>函数返回每一行。</p><p id="867c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦我们有了我们的日志文件解析器和<strong class="kh ir"> <em class="le"> kafka </em> </strong>生成器，我们就可以继续将日志消息发送到我们的<strong class="kh ir"> <em class="le"> kafka </em> </strong>主题。这些信息将会被消费者收集起来，并推送到<strong class="kh ir"><em class="le">elastic search</em></strong>。图5显示了我们如何调用方法将消息推入kafka主题。</p><figure class="lj lk ll lm gt ln gh gi paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="gh gi mc"><img src="../Images/0f5a88b6a3ca661e7d9d69397c588584.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EdM3WVqpCYmmmPZIhK2vDA.png"/></div></div><p class="lu lv gj gh gi lw lx bd b be z dk translated">图5:调用我们的解析器方法和生产者方法的主函数</p></figure><p id="4ca2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在运行主函数时，日志文件的内容被推送到<strong class="kh ir"> <em class="le"> kafka </em> </strong>主题，并由另一端的消费者接收。下面的图6给出了输出。</p><figure class="lj lk ll lm gt ln gh gi paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="gh gi md"><img src="../Images/2597aa31090f1c849c7c2f27920f68a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vnW-zenlf2tXRHp5alJ8bQ.png"/></div></div><p class="lu lv gj gh gi lw lx bd b be z dk translated">图6:日志生产者代码的输出</p></figure><p id="b7fc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们将继续编写将所有这些信息推送到<strong class="kh ir"><em class="le">elastic search</em></strong>上的部分，然后继续在<strong class="kh ir"> <em class="le"> Kibana上创建仪表板。</em> </strong></p><p id="5c6d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了用python连接到<strong class="kh ir"> Elasticsearch </strong>，我们将使用python的官方Elasticsearch库→<a class="ae lz" href="https://elasticsearch-py.readthedocs.io/en/v7.13.0/" rel="noopener ugc nofollow" target="_blank"><strong class="kh ir"><em class="le">https://elasticsearch-py.readthedocs.io/en/v7.13.0/</em></strong></a></p><p id="db25" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在图7中，我们有一个名为<strong class="kh ir"> Elastic </strong>的类，在这里我们连接到在端口<strong class="kh ir"> <em class="le"> 9200 </em> </strong>上运行的<strong class="kh ir"><em class="le">Elastic search</em></strong>实例。对于这个实验，我们使用一个<strong class="kh ir"><em class="le">docker-compose</em></strong>文件，其中包含了对<strong class="kh ir"><em class="le">elastic search</em></strong>和<em class="le"><em class="le">kibana</em>服务的配置。这个实验的GitHub repo中有<strong class="kh ir"><em class="le">docker-compose</em></strong>文件(博客末尾的链接)。一个简单的<strong class="kh ir"><em class="le">docker-compose up</em></strong>应该启动我们的<strong class="kh ir"><em class="le">elastic search</em></strong>和<strong class="kh ir"> <em class="le"> kibana </em> </strong>实例。</em></p><figure class="lj lk ll lm gt ln gh gi paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="gh gi me"><img src="../Images/aec977f9ce37c94d7d8a2bef580b2529.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WaUsnoCSZ3bhltSmzoJ-0w.png"/></div></div><p class="lu lv gj gh gi lw lx bd b be z dk translated">图7:连接到elasticsearch实例并推送数据的类</p></figure><p id="e3a7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir"> <em class="le"> Elasticsearch </em> </strong>用来存储数据的数据结构称为<strong class="kh ir"> <em class="le">倒排索引</em> </strong>。它具有快速识别每个单词的能力。因此，我们能够以实时速度执行搜索和查询。在我们的实验中，索引的名称是<strong class="kh ir"><em class="le">【new-relic-log】</em></strong></p><p id="924f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">图8中给出了Kafka消费者块，我们将使用它来读取来自<strong class="kh ir"> <em class="le"> kafka </em> </strong>主题的消息，生产者将所有日志消息发送到该主题。<strong class="kh ir"><em class="le">read _ messages</em></strong>方法让我们不断地轮询主题并寻找消息。</p><figure class="lj lk ll lm gt ln gh gi paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="gh gi mf"><img src="../Images/ca6540a14b2e74c60661df9de0291fa8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dVIXgkl1ksnEkTwNyL_QIg.png"/></div></div><p class="lu lv gj gh gi lw lx bd b be z dk translated">图8:卡夫卡消费区</p></figure><p id="56ae" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦我们有了来自消费者的消息，我们可以调用<strong class="kh ir"> <em class="le"> Elastic </em> </strong>类中的<strong class="kh ir"><em class="le">push _ to _ index</em></strong>方法将消息推送到Elasticsearch，如图9所示</p><figure class="lj lk ll lm gt ln gh gi paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="gh gi mg"><img src="../Images/cdf11fc82345fc21e6dee5e9867a581f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Kck4pRm7x1ttcuybm4p3ZA.png"/></div></div><p class="lu lv gj gh gi lw lx bd b be z dk translated">图9:向elastic发送数据</p></figure><p id="bf0f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面的图10显示了图9中命令的输出。写响应显示了我们将数据传输到elasticsearch的细节，包括索引细节和结果。</p><figure class="lj lk ll lm gt ln gh gi paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="gh gi mh"><img src="../Images/7a73732a766f16f574fa48854baa5396.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uDiP6r15tH-lLnLubcNkzQ.png"/></div></div><p class="lu lv gj gh gi lw lx bd b be z dk translated">图10: Elasticsearch数据推送输出</p></figure><p id="4fd5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在让我们看看数据是如何出现在Elasticsearch上的。为了访问我们的索引，我们将直接转到我们的<strong class="kh ir"> <em class="le"> Kibana </em> </strong>仪表盘。确保您的Kibana和Elasticsearch容器运行正常。前往<a class="ae lz" href="http://localhost:5601" rel="noopener ugc nofollow" target="_blank"><strong class="kh ir">http://localhost:5601</strong></a><em class="le">←</em>这是我的本地机器上运行<strong class="kh ir"> <em class="le"> Kibana </em> </strong>的端口。<strong class="kh ir"> <em class="le">基巴纳</em> </strong>的主屏幕如下图11所示</p><figure class="lj lk ll lm gt ln gh gi paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="gh gi mi"><img src="../Images/bdd2495a3df129bd1540a10c8d171cac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5s9iNxEkKZJw_LHg7DGR_A.png"/></div></div><p class="lu lv gj gh gi lw lx bd b be z dk translated">图11:基巴纳主屏幕</p></figure><p id="87fb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在检查数据是否正确地进入我们的<strong class="kh ir"> <em class="le">新遗迹日志</em> </strong>索引，点击<strong class="kh ir"> <em class="le">发现</em> </strong>按钮(左手边面板上的第二个按钮)，如图12所示。从下拉菜单中选择索引为<strong class="kh ir"><em class="le">new-relic-log</em></strong>，您应该会看到python发送的所有日志消息都显示在屏幕中央(图13)</p><figure class="lj lk ll lm gt ln gh gi paragraph-image"><div class="gh gi mj"><img src="../Images/2d1937c4a61026acb795f6ae85b50f5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:746/format:webp/1*uT3r6IVlmx_9m5IIgrA_SA.png"/></div><p class="lu lv gj gh gi lw lx bd b be z dk translated">图12:发现按钮和索引选择</p></figure><figure class="lj lk ll lm gt ln gh gi paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="gh gi mk"><img src="../Images/0e69a61b35bab6279f65e3a364088200.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XsdhRiHgGd-ZhOMqNKQ6BQ.png"/></div></div><p class="lu lv gj gh gi lw lx bd b be z dk translated">图13:在Kibana上注销</p></figure><p id="f755" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了过滤掉仅仅是<strong class="kh ir"> <em class="le"> INFO </em> </strong> <em class="le"> </em>日志或者是<strong class="kh ir"> <em class="le"> ERROR </em> </strong> <em class="le"> </em>日志，我们可以使用顶部的搜索栏，它为我们提供了许多过滤数据点的选项。<strong class="kh ir"> <em class="le">信息</em> </strong> <em class="le"> </em>日志过滤示例见下图14</p><figure class="lj lk ll lm gt ln gh gi paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="gh gi ml"><img src="../Images/9ef3426e87599138b69fd4a0dc4519de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Wr7MAfCxm5K28yx4Yak9ew.png"/></div></div><p class="lu lv gj gh gi lw lx bd b be z dk translated">图14:过滤的信息日志</p></figure><p id="2705" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，为了使我们的数据可视化并将其放在一个真实的仪表板上，我们必须准备一些图表。让我们从折线图开始。该折线图将汇总不同日志类型的计数并显示。</p><p id="66f0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">点击<strong class="kh ir"> <em class="le">可视化</em> </strong>按钮，在左侧面板的<strong class="kh ir"> <em class="le">发现</em> </strong>按钮的正下方(图15)。</p><figure class="lj lk ll lm gt ln gh gi paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="gh gi mm"><img src="../Images/01387648bd7e59b113c5aa01a85a247f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LHJDch75FE0s5DLFgYmNow.png"/></div></div><p class="lu lv gj gh gi lw lx bd b be z dk translated">图15:可视化选项卡</p></figure><p id="86aa" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">点击<strong class="kh ir"> <em class="le">新建可视化</em> </strong>按钮，会出现多种不同类型的图表选项(图16)。对于这个例子，我们将使用折线图</p><figure class="lj lk ll lm gt ln gh gi paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="gh gi mn"><img src="../Images/d01b1250e7a45ac240a5381da5ce9a10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9NGwNqVW9HLkcRE2BmaEUw.png"/></div></div><p class="lu lv gj gh gi lw lx bd b be z dk translated">图16:图表选项</p></figure><p id="d4c0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">选择了首选图表类型后，系统将提示您选择要从中读取数据的索引。这里，我们将选择新遗迹日志索引(图17)</p><figure class="lj lk ll lm gt ln gh gi paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="gh gi mo"><img src="../Images/1335e708d3e95773e1de6c9c6ca7d82c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Iy1ZU5ewPZgcIj6x4808eA.png"/></div></div><p class="lu lv gj gh gi lw lx bd b be z dk translated">图17:可视化的索引选择</p></figure><p id="354f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，我们将为折线图创建设置。在<strong class="kh ir"> <em class="le"> Y轴</em> </strong>上，我们将参数选择为<strong class="kh ir"> <em class="le">计数。</em> </strong>在X轴上我们将选择参数作为<strong class="kh ir"> <em class="le">时间戳</em> </strong>。Kibana还为我们提供了一个选项，可以在不同的键之间在同一X轴上分割图表。在我们的例子中，我们将可视化计数<strong class="kh ir"><em class="le">INFO</em></strong><em class="le"/>日志和<strong class="kh ir"><em class="le">ERROR</em></strong><em class="le"/>日志在同一图表上。设置分别如图18(a、b)和19所示。最终图表如图20所示。如您所见，我们对两种日志类型的时间戳进行了聚合。</p><figure class="lj lk ll lm gt ln gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/9924217b330551cbeeee84f0c6a1a9a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:584/format:webp/1*zM5TAuzxndCibwPe1yooUA.png"/></div><p class="lu lv gj gh gi lw lx bd b be z dk translated">图18 (a): X轴</p></figure><figure class="lj lk ll lm gt ln gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/cb62be771f5fc8a961fcfe1e8a3cfe10.png" data-original-src="https://miro.medium.com/v2/resize:fit:590/format:webp/1*zmJzCyN3w9GkPvzK3Q0CZg.png"/></div><p class="lu lv gj gh gi lw lx bd b be z dk translated">图18 (b):拆分系列选项</p></figure><figure class="lj lk ll lm gt ln gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/1ccad015e0040de1452a9a37e53862da.png" data-original-src="https://miro.medium.com/v2/resize:fit:674/format:webp/1*X1Dionpwwt9hP8ZZVGW8jg.png"/></div><p class="lu lv gj gh gi lw lx bd b be z dk translated">图19 : Y轴</p></figure><figure class="lj lk ll lm gt ln gh gi paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="gh gi ms"><img src="../Images/da4e82d9a7d6d38b106ceb072636eaea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EUsRC_v6H9yBL2hjsPE5iA.png"/></div></div><p class="lu lv gj gh gi lw lx bd b be z dk translated">图20:信息日志类型和错误日志类型的计数。</p></figure><p id="b81c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还创建了一个饼图来获得两种不同日志类型的总数(图21)。要创建饼图，只需选择可视化屏幕上的饼图选项，而不是折线图选项。</p><figure class="lj lk ll lm gt ln gh gi paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="gh gi mt"><img src="../Images/31493e2cf375622361254ae8abf840f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l0txgTOc8PWD36s77cT8Ug.png"/></div></div><p class="lu lv gj gh gi lw lx bd b be z dk translated">图21:日志类型计数的饼图</p></figure><p id="7c2b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，我们将创建我们的第一个基巴纳仪表盘。这一步再简单不过了。</p><p id="39e8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">点击<strong class="kh ir"> <em class="le">仪表板上<strong class="kh ir"> <em class="le">正下方的</em> </strong>按钮，可视化</em> </strong>按钮。点击<strong class="kh ir">顶部的<em class="le">添加</em>按钮→选择图表，完成。您已经准备好了您的仪表板(图22)</strong></p><figure class="lj lk ll lm gt ln gh gi paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="gh gi mu"><img src="../Images/020453a1107253b9841168b5287be21e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hani9ttdLyfn6TUahBWwFw.png"/></div></div><p class="lu lv gj gh gi lw lx bd b be z dk translated">图22:仪表板</p></figure><p id="83c0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我希望这篇博客有助于简要介绍我们如何利用这些开源工具来构建健壮的数据流管道。</p><p id="27ed" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Github项目链接→<a class="ae lz" href="https://github.com/AbhishekBose/kafka-es" rel="noopener ugc nofollow" target="_blank"><strong class="kh ir"><em class="le">https://github.com/AbhishekBose/kafka-es</em></strong></a></p><p id="671d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir"> <em class="le">参考文献:</em> </strong></p><p id="b3cf" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">[1]<a class="ae lz" href="https://en.wikipedia.org/wiki/Apache_Kafka" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Apache_Kafka</a></p><p id="c218" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae lz" href="https://www.elastic.co/" rel="noopener ugc nofollow" target="_blank">https://www.elastic.co/</a></p><p id="9184" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae lz" href="https://www.elastic.co/what-is/kibana" rel="noopener ugc nofollow" target="_blank">https://www.elastic.co/what-is/kibana</a></p></div></div>    
</body>
</html>