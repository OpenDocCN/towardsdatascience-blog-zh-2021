<html>
<head>
<title>Upgraded Marketing Mix Modeling in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中升级的营销组合建模</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/an-upgraded-marketing-mix-modeling-in-python-5ebb3bddc1b6?source=collection_archive---------1-----------------------#2021-09-23">https://towardsdatascience.com/an-upgraded-marketing-mix-modeling-in-python-5ebb3bddc1b6?source=collection_archive---------1-----------------------#2021-09-23</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><h2 id="5a39" class="is it iu bd b dl iv iw ix iy iz ja dk jb translated" aria-label="kicker paragraph"><a class="ae ep" href="https://medium.com/tag/marketing-analytics" rel="noopener">营销分析</a></h2><div class=""/><div class=""><h2 id="55de" class="pw-subtitle-paragraph ka jd iu bd b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr dk translated">让我平庸的营销组合模式更加强大</h2></div><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj ks"><img src="../Images/a8e132a6fcc2a5c832cdcd8b818faed4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*BJvBREjljN7FQ10G"/></div></div><p class="le lf gk gi gj lg lh bd b be z dk translated">照片由<a class="ae li" href="https://unsplash.com/@peterng1618?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">彼得·阮</a>在<a class="ae li" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><h1 id="e22c" class="lj lk iu bd ll lm ln lo lp lq lr ls lt kj lu kk lv km lw kn lx kp ly kq lz ma bi translated">闪回</h1><p id="3557" class="pw-post-body-paragraph mb mc iu md b me mf ke mg mh mi kh mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">在我的上一篇文章中，我向您介绍了营销组合建模的世界。如果您尚未阅读，请在继续之前阅读。</p><div class="mx my gq gs mz na"><a rel="noopener follow" target="_blank" href="/introduction-to-marketing-mix-modeling-in-python-d0dd81f4e794"><div class="nb ab fp"><div class="nc ab nd cl cj ne"><h2 class="bd je gz z fq nf fs ft ng fv fx jd bi translated">Python市场营销组合建模简介</h2><div class="nh l"><h3 class="bd b gz z fq nf fs ft ng fv fx dk translated">哪些广告支出真正推动了你的销售？</h3></div><div class="ni l"><p class="bd b dl z fq nf fs ft ng fv fx dk translated">towardsdatascience.com</p></div></div><div class="nj l"><div class="nk l nl nm nn nj no lc na"/></div></div></a></div><p id="0c73" class="pw-post-body-paragraph mb mc iu md b me np ke mg mh nq kh mj mk nr mm mn mo ns mq mr ms nt mu mv mw in bi translated">在那里，我们创建了一个<strong class="md je">线性</strong> <strong class="md je">回归</strong>模型，该模型能够根据几个广告渠道(如电视、广播和网络横幅广告)的原始广告支出来预测销售额。对于作为机器学习实践者的我来说，这样的模型本身就已经很好了。更好的是，它还让商界人士感到高兴，因为该模型让我们能够计算投资回报率，让我们能够判断每个渠道的表现如何。</p><p id="5812" class="pw-post-body-paragraph mb mc iu md b me np ke mg mh nq kh mj mk nr mm mn mo ns mq mr ms nt mu mv mw in bi translated">然而，我们上次的简单线性回归模型有一些问题，我们将在本文中解决。让我给你解释一下:</p><ol class=""><li id="ff83" class="nu nv iu md b me np mh nq mk nw mo nx ms ny mw nz oa ob oc bi translated">我们第一款产品的性能可能会更好。</li><li id="b92e" class="nu nv iu md b me od mh oe mk of mo og ms oh mw nz oa ob oc bi translated">我们的第一个模型表现得不真实。将支出增加到无穷大也会将销售额增加到无穷大，这毫无意义，因为人们只能在我们的产品上花有限的钱。</li><li id="43ab" class="nu nv iu md b me od mh oe mk of mo og ms oh mw nz oa ob oc bi translated">优化变得琐碎、无用、不切实际。为了在给定固定预算的情况下最大化销售额，我们现在将把所有资金投入到线性回归系数最高的渠道中。</li></ol><h1 id="61db" class="lj lk iu bd ll lm ln lo lp lq lr ls lt kj lu kk lv km lw kn lx kp ly kq lz ma bi translated">广告😉</h1><p id="987c" class="pw-post-body-paragraph mb mc iu md b me mf ke mg mh mi kh mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">我创建了一个小库，在这里我实现了本文其余部分的思想，甚至更多。通过<code class="fe oi oj ok ol b">pip install mamimo</code>安装，并在此查看如何使用:</p><div class="mx my gq gs mz na"><a rel="noopener follow" target="_blank" href="/a-small-python-library-for-marketing-mix-modeling-mamimo-100f31666e18"><div class="nb ab fp"><div class="nc ab nd cl cj ne"><h2 class="bd je gz z fq nf fs ft ng fv fx jd bi translated">一个用于营销组合建模的小型Python库:MaMiMo</h2><div class="nh l"><h3 class="bd b gz z fq nf fs ft ng fv fx dk translated">以scikit-learn方式创建营销组合模型</h3></div><div class="ni l"><p class="bd b dl z fq nf fs ft ng fv fx dk translated">towardsdatascience.com</p></div></div><div class="nj l"><div class="om l nl nm nn nj no lc na"/></div></div></a></div><h1 id="d48d" class="lj lk iu bd ll lm ln lo lp lq lr ls lt kj lu kk lv km lw kn lx kp ly kq lz ma bi translated">解决问题</h1><p id="03dc" class="pw-post-body-paragraph mb mc iu md b me mf ke mg mh mi kh mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">为了规避这些问题，我们可以做一些聪明的<strong class="md je">特征工程</strong>，允许我们将一些营销领域的知识整合到模型中。不要担心，理解这些概念不需要营销经验，因为它们很自然，因此很容易理解。以下技术将提高性能，并使模型更加真实。</p><h2 id="6d01" class="on lk iu bd ll oo op dn lp oq or dp lt mk os ot lv mo ou ov lx ms ow ox lz ja bi translated">广告股票</h2><p id="7127" class="pw-post-body-paragraph mb mc iu md b me mf ke mg mh mi kh mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">我们要做的这个特色工程是一个至关重要的组件，叫做<a class="ae li" href="https://en.wikipedia.org/wiki/Advertising_adstock" rel="noopener ugc nofollow" target="_blank"><strong class="md je"/></a><em class="oy">，</em>这是西蒙·布罗德本特发明的一个术语[1]。这是一个包含两个简单概念的奇特词汇:</p><ol class=""><li id="7bc1" class="nu nv iu md b me np mh nq mk nw mo nx ms ny mw nz oa ob oc bi translated">我们假设你花在广告上的钱越多，你的销售额就越高。然而，我们花得越多，增长就越弱。例如，将电视支出从0 €增加到100，000 €会大大增加我们的销售额，但将它从100，000，000 €增加到100，100，000 €就没有那么多了。这叫做<strong class="md je">饱和效应</strong>或<em class="oy"> </em> <strong class="md je">收益递减效应</strong> <em class="oy">。</em></li><li id="057f" class="nu nv iu md b me od mh oe mk of mo og ms oh mw nz oa ob oc bi translated">如果你在广告周花钱，人们通常不会立即购买你的产品，而是在几周之后。这是因为该产品可能很贵，人们希望仔细考虑它，或者将其与其他公司的类似产品进行比较。不管是什么原因，在第<em class="oy"> T + x </em>周的销售部分是由你在第<em class="oy"> T、</em>周播放的广告引起的，所以它也应该得到一些积分。这被称为<strong class="md je">遗留</strong>或<strong class="md je">滞后效应</strong>。</li></ol><p id="773e" class="pw-post-body-paragraph mb mc iu md b me np ke mg mh nq kh mj mk nr mm mn mo ns mq mr ms nt mu mv mw in bi translated">我认为这两个事实都很容易理解，商界人士也很喜欢。</p><blockquote class="oz"><p id="0e91" class="pa pb iu bd pc pd pe pf pg ph pi mw dk translated">我们的新模型仍然是线性的，但是用adstock特性代替原始支出作为输入。这使得模型更加强大，同时保持其可解释性。</p></blockquote><h2 id="a6c0" class="on lk iu bd ll oo pj dn lp oq pk dp lt mk pl ot lv mo pm ov lx ms pn ox lz ja bi translated">在scikit-learn中构建饱和度和结转效应</h2><p id="41c4" class="pw-post-body-paragraph mb mc iu md b me mf ke mg mh mi kh mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">对我们来说不幸的是，scikit-learn不包含这些转换，因为它们不是跨行业的兴趣。但是由于这两种转换都没有那么复杂，所以这是一个练习编写scikit-learn兼容估计器的好机会。</p><p id="0715" class="pw-post-body-paragraph mb mc iu md b me np ke mg mh nq kh mj mk nr mm mn mo ns mq mr ms nt mu mv mw in bi translated">如果你以前从未这样做过，你可以看看我的另一篇关于这个话题的文章。这篇文章是关于回归变量而不是变压器的，但是方法并没有太大的不同。</p><div class="mx my gq gs mz na"><a rel="noopener follow" target="_blank" href="/build-your-own-custom-scikit-learn-regression-5d0d718f289"><div class="nb ab fp"><div class="nc ab nd cl cj ne"><h2 class="bd je gz z fq nf fs ft ng fv fx jd bi translated">构建您自己的定制scikit-学习回归</h2><div class="nh l"><h3 class="bd b gz z fq nf fs ft ng fv fx dk translated">编写一个回归变量，并从scikit-learn生态系统的所有强大工具中受益，如管道、网格搜索…</h3></div><div class="ni l"><p class="bd b dl z fq nf fs ft ng fv fx dk translated">towardsdatascience.com</p></div></div><div class="nj l"><div class="po l nl nm nn nj no lc na"/></div></div></a></div><p id="f025" class="pw-post-body-paragraph mb mc iu md b me np ke mg mh nq kh mj mk nr mm mn mo ns mq mr ms nt mu mv mw in bi translated">所以，让我们从更简单的开始:饱和效应。</p><h2 id="8942" class="on lk iu bd ll oo op dn lp oq or dp lt mk os ot lv mo ou ov lx ms ow ox lz ja bi translated">产生饱和效果</h2><p id="f545" class="pw-post-body-paragraph mb mc iu md b me mf ke mg mh mi kh mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">我们希望创建一个具有以下属性的变换(=数学函数):</p><ol class=""><li id="92fd" class="nu nv iu md b me np mh nq mk nw mo nx ms ny mw nz oa ob oc bi translated">如果支出为0，则<em class="oy">饱和支出</em>也为0。</li><li id="8b12" class="nu nv iu md b me od mh oe mk of mo og ms oh mw nz oa ob oc bi translated">该转换是单调递增的，即输入支出越高，饱和输出支出越高。</li><li id="5df7" class="nu nv iu md b me od mh oe mk of mo og ms oh mw nz oa ob oc bi translated">饱和值不会增长到无穷大。相反，它们的上限是某个数，比如说1。</li></ol><p id="950d" class="pw-post-body-paragraph mb mc iu md b me np ke mg mh nq kh mj mk nr mm mn mo ns mq mr ms nt mu mv mw in bi translated"><strong class="md je">简而言之，我们想要这样的东西:</strong></p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj pp"><img src="../Images/78a8734ac92e7cf79ac100ac8da39159.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5I09TDswHmIJ76DlbaozAg.png"/></div></div><p class="le lf gk gi gj lg lh bd b be z dk translated">图片由作者提供。</p></figure><p id="205a" class="pw-post-body-paragraph mb mc iu md b me np ke mg mh nq kh mj mk nr mm mn mo ns mq mr ms nt mu mv mw in bi translated">有很多方法可以得到这样的函数，例如，在图片中你可以看到函数1-exp(-0.7 <em class="oy"> x </em>)。所以让我们使用这个函数模板，并将其推广到1-exp(-<em class="oy">ax</em>)for some<em class="oy">a</em>&gt;0。<em class="oy"> a </em>是一个超参数，我们可以随后进行调整，因为通常我们不知道饱和函数的形状。</p><blockquote class="pq pr ps"><p id="fb02" class="mb mc oy md b me np ke mg mh nq kh mj pt nr mm mn pu ns mq mr pv nt mu mv mw in bi translated">N <strong class="md je"> <em class="iu"> ote: </em> </strong> <em class="iu">还有许多更标准的饱和度函数，如</em><strong class="md je"><em class="iu">Adbudg</em></strong><em class="iu">和</em><strong class="md je"><em class="iu">Hill</em></strong><em class="iu">函数，但让我们坚持用</em> <strong class="md je"> <em class="iu">指数函数</em> </strong> <em class="iu">函数</em> <strong class="md je"> <em class="iu"> </em> </strong> <em class="iu">为</em></p></blockquote><p id="6434" class="pw-post-body-paragraph mb mc iu md b me np ke mg mh nq kh mj mk nr mm mn mo ns mq mr ms nt mu mv mw in bi translated">一个很好的副作用:我们最终能够输出饱和曲线，所以我们知道花更多的钱是否有意义，或者渠道是否已经饱和。比如从上图来看，投资8以上好像就没用了。</p><p id="890c" class="pw-post-body-paragraph mb mc iu md b me np ke mg mh nq kh mj mk nr mm mn mo ns mq mr ms nt mu mv mw in bi translated">所以，我们来编码一下。事实上，就是这个简单的小类:</p><pre class="kt ku kv kw gu pw ol px bn py pz bi"><span id="7022" class="qa lk iu ol b be qb qc l qd qe">class ExponentialSaturation:<br/>    def __init__(self, a=1.):<br/>        self.a = a<br/>        <br/>    def transform(self, X):<br/>        return 1 - np.exp(-self.a*X)</span></pre><p id="1245" class="pw-post-body-paragraph mb mc iu md b me np ke mg mh nq kh mj mk nr mm mn mo ns mq mr ms nt mu mv mw in bi translated">然而，我们将为输入添加一些健全性检查，以使其符合scikit-learn。这增加了一点代码，但这是我们必须付出的相对较小的代价。</p><pre class="kt ku kv kw gu pw ol px bn py pz bi"><span id="0110" class="qa lk iu ol b be qb qc l qd qe">from sklearn.base import BaseEstimator, TransformerMixin<br/>from sklearn.utils.validation import check_is_fitted, check_array<br/><br/>class ExponentialSaturation(BaseEstimator, TransformerMixin):<br/>    def __init__(self, a=1.):<br/>        self.a = a<br/>        <br/>    def fit(self, X, y=None):<br/>        X = check_array(X)<br/>        self._check_n_features(X, reset=True) # from BaseEstimator<br/>        return self<br/><br/>    def transform(self, X):<br/>        check_is_fitted(self)<br/>        X = check_array(X)<br/>        self._check_n_features(X, reset=False) # from BaseEstimator<br/>        return 1 - np.exp(-self.a*X)</span></pre><p id="460b" class="pw-post-body-paragraph mb mc iu md b me np ke mg mh nq kh mj mk nr mm mn mo ns mq mr ms nt mu mv mw in bi translated">它仍然不完美，因为我们还应该实现对大于零的<em class="oy"> a </em>的检查，但这是你可以自己轻松完成的事情。使用<code class="fe oi oj ok ol b">ExponentialSaturation</code>变压器，我们可以做到以下几点:</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div class="gi gj qf"><img src="../Images/093f6ec77731be13f0ea5d04d36fdd04.png" data-original-src="https://miro.medium.com/v2/resize:fit:904/format:webp/1*hgHVvbOuRoQyMxW2mUNZww.png"/></div><p class="le lf gk gi gj lg lh bd b be z dk translated">图片由作者提供。</p></figure><p id="4128" class="pw-post-body-paragraph mb mc iu md b me np ke mg mh nq kh mj mk nr mm mn mo ns mq mr ms nt mu mv mw in bi translated">这个不算太糟，对吧？现在让我们来看下一个效应。</p><h2 id="c1fd" class="on lk iu bd ll oo op dn lp oq or dp lt mk os ot lv mo ou ov lx ms ow ox lz ja bi translated">产生遗留效应</h2><p id="d826" class="pw-post-body-paragraph mb mc iu md b me mf ke mg mh mi kh mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">这个稍微复杂一点。让我用一个例子来说明我们想要达到的目标。随着时间的推移，我们会有一系列的支出，例如</p><blockquote class="oz"><p id="ff04" class="pa pb iu bd pc pd pe pf pg ph pi mw dk">(16, 0, 0, 0, 0, 4, 8, 0, 0, 0),</p></blockquote><p id="6cfc" class="pw-post-body-paragraph mb mc iu md b me qg ke mg mh qh kh mj mk qi mm mn mo qj mq mr ms qk mu mv mw in bi translated">这意味着我们在第一周花了16英镑，然后从第2周到第5周我们什么也没花，然后在第6周我们花了4英镑，等等。</p><p id="34a7" class="pw-post-body-paragraph mb mc iu md b me np ke mg mh nq kh mj mk nr mm mn mo ns mq mr ms nt mu mv mw in bi translated">我们现在希望一周的花费能以指数形式部分结转到下一周。这意味着:在第一周有16英镑的支出。那么我们携带超过50%,意思是</p><ul class=""><li id="876d" class="nu nv iu md b me np mh nq mk nw mo nx ms ny mw ql oa ob oc bi translated">0.5 * 16 = 8到第2周，</li><li id="ba03" class="nu nv iu md b me od mh oe mk of mo og ms oh mw ql oa ob oc bi translated">0.5 * 16 = 4到第3周，</li><li id="a81a" class="nu nv iu md b me od mh oe mk of mo og ms oh mw ql oa ob oc bi translated">0.5 * 16 = 2到第4周，</li><li id="1770" class="nu nv iu md b me od mh oe mk of mo og ms oh mw ql oa ob oc bi">…</li></ul><p id="3d15" class="pw-post-body-paragraph mb mc iu md b me np ke mg mh nq kh mj mk nr mm mn mo ns mq mr ms nt mu mv mw in bi translated">这引入了两个超参数:<strong class="md je">强度</strong>(有多少被结转？)和<strong class="md je">长度</strong>(多长时间结转？)的结转效应。如果我们使用50%的<strong class="md je">强度</strong>和2 的<strong class="md je">长度，则上面的支出顺序变为</strong></p><blockquote class="oz"><p id="eab6" class="pa pb iu bd pc pd pe pf pg ph pi mw dk">(16, 8, 4, 0, 0, 4, 10, 5, 2, 0).</p></blockquote><p id="81c0" class="pw-post-body-paragraph mb mc iu md b me qg ke mg mh qh kh mj mk qi mm mn mo qj mq mr ms qk mu mv mw in bi translated">我相信你可以写一些循环来实现这个行为，一个好的快速的方法是使用卷积。我就不详细解释了，就拿代码当礼物吧。我再次强调了真正重要的线。</p><pre class="kt ku kv kw gu pw ol px bn py pz bi"><span id="9405" class="qa lk iu ol b be qb qc l qd qe">from scipy.signal import convolve2d<br/>import numpy as np<br/><br/>class ExponentialCarryover(BaseEstimator, TransformerMixin):<br/>    def __init__(self, strength=0.5, length=1):<br/>        self.strength = strength<br/>        self.length = length<br/><br/>    def fit(self, X, y=None):<br/>        X = check_array(X)<br/>        self._check_n_features(X, reset=True)<br/>        self.sliding_window_ = (<br/>            self.strength ** np.arange(self.length + 1)<br/>        ).reshape(-1, 1)<br/>        return self<br/><br/>    def transform(self, X: np.ndarray):<br/>        check_is_fitted(self)<br/>        X = check_array(X)<br/>        self._check_n_features(X, reset=False)<br/>        convolution = convolve2d(X, self.sliding_window_)<br/>        if self.length &gt; 0:<br/>            convolution = convolution[: -self.length]<br/>        return convolution</span></pre><p id="2f49" class="pw-post-body-paragraph mb mc iu md b me np ke mg mh nq kh mj mk nr mm mn mo ns mq mr ms nt mu mv mw in bi translated">可以看到，上课是走强度和长度的。在拟合过程中，它会创建一个滑动窗口，由convolve2d函数使用，神奇地完成我们想要的工作。如果你知道CNN的卷积层，这就是这里发生的事情。从图形上看，它执行以下操作:</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div class="gi gj qm"><img src="../Images/67cc635f9ef678390addbd49a5facf8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1312/1*8AEZKG-bjymGEHHa-k-YuQ.gif"/></div><p class="le lf gk gi gj lg lh bd b be z dk translated">图片由作者提供。</p></figure><blockquote class="pq pr ps"><p id="da1c" class="mb mc oy md b me np ke mg mh nq kh mj pt nr mm mn pu ns mq mr pv nt mu mv mw in bi translated">N <strong class="md je"> <em class="iu">注:</em> </strong> <em class="iu">还有很多方法可以创建遗留问题。衰变不一定是指数的。也许广告效果的顶峰不是在花钱的那天，而是在下一周。您可以通过相应地更改滑动窗口来表达所有这些变化。</em></p></blockquote><p id="6af9" class="pw-post-body-paragraph mb mc iu md b me np ke mg mh nq kh mj mk nr mm mn mo ns mq mr ms nt mu mv mw in bi translated">让我们结合饱和效应和结转效应来创建一个更现实的营销组合模型。</p><h1 id="95a0" class="lj lk iu bd ll lm ln lo lp lq lr ls lt kj lu kk lv km lw kn lx kp ly kq lz ma bi translated">最终模型</h1><p id="6420" class="pw-post-body-paragraph mb mc iu md b me mf ke mg mh mi kh mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">我们将对每个渠道使用不同的饱和度和结转。这是有道理的，因为通常情况下，电视广告比你在网上看到的横幅广告在你脑海中停留的时间更长。从高层次的角度来看，该模型将如下所示:</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj qn"><img src="../Images/b24c2eeae0d2cb2d8ac4b52c59c8f057.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZitGnL3nODgKcdM7xKPqug.png"/></div></div><p class="le lf gk gi gj lg lh bd b be z dk translated">图片由作者提供。</p></figure><p id="76ec" class="pw-post-body-paragraph mb mc iu md b me np ke mg mh nq kh mj mk nr mm mn mo ns mq mr ms nt mu mv mw in bi translated">请注意，蓝色管道只是电视支出的函数，橙色管道是广播支出的函数，紫色管道是横幅广告支出的函数。我们可以使用<code class="fe oi oj ok ol b">ColumnTransformer</code>和<code class="fe oi oj ok ol b">Pipeline</code>类在scikit-learn中有效地实现这一点。<code class="fe oi oj ok ol b">ColumnTransformer</code>允许我们对每个广告渠道使用不同的转换，而<code class="fe oi oj ok ol b">Pipeline</code>允许我们对单个渠道进行连锁操作。花点时间理解下面的片段:</p><pre class="kt ku kv kw gu pw ol px bn py pz bi"><span id="2724" class="qa lk iu ol b be qb qc l qd qe">from sklearn.compose import ColumnTransformer<br/>from sklearn.pipeline import Pipeline<br/>from sklearn.linear_model import LinearRegression<br/><br/>adstock = ColumnTransformer(<br/>    [<br/>     ('tv_pipe', Pipeline([<br/>                           ('carryover', ExponentialCarryover()),<br/>                           ('saturation', ExponentialSaturation())<br/>     ]), ['TV']),<br/>     ('radio_pipe', Pipeline([<br/>                           ('carryover', ExponentialCarryover()),<br/>                           ('saturation', ExponentialSaturation())<br/>     ]), ['Radio']),<br/>     ('banners_pipe', Pipeline([<br/>                           ('carryover', ExponentialCarryover()),<br/>                           ('saturation', ExponentialSaturation())<br/>     ]), ['Banners']),<br/>    ],<br/>    remainder='passthrough'<br/>)<br/><br/>model = Pipeline([<br/>                  ('adstock', adstock),<br/>                  ('regression', LinearRegression())<br/>])</span></pre><p id="c584" class="pw-post-body-paragraph mb mc iu md b me np ke mg mh nq kh mj mk nr mm mn mo ns mq mr ms nt mu mv mw in bi translated">最难的部分是<code class="fe oi oj ok ol b">ColumnTransformer</code>，所以让我来解释一下如何阅读用粗体标记的<strong class="md je">电视块</strong>。它只是说:</p><blockquote class="oz"><p id="53d5" class="pa pb iu bd pc pd pe pf pg ph pi mw dk translated">将管道应用于“TV”列，并将此部分命名为“tv_pipe”。管道只是adstock转换。</p></blockquote><p id="c7d4" class="pw-post-body-paragraph mb mc iu md b me qg ke mg mh qh kh mj mk qi mm mn mo qj mq mr ms qk mu mv mw in bi translated">那里没有更多的事情发生。最后，我们使用这个大的预处理步骤，并在末尾添加一个简单的<code class="fe oi oj ok ol b">LinearRegression</code>来得到一个实际的回归变量。那么，让我们<a class="ae li" href="https://github.com/Garve/datasets/blob/4576d323bf2b66c906d5130d686245ad205505cf/mmm.csv" rel="noopener ugc nofollow" target="_blank"> <strong class="md je">再次加载数据</strong> </a>并做一些训练。</p><pre class="kt ku kv kw gu pw ol px bn py pz bi"><span id="e8f2" class="qa lk iu ol b be qb qc l qd qe">import pandas as pd<br/>from sklearn.model_selection import cross_val_score, TimeSeriesSplit<br/><br/>data = pd.read_csv(<br/>    'https://raw.githubusercontent.com/Garve/datasets/4576d323bf2b66c906d5130d686245ad205505cf/mmm.csv',<br/>    parse_dates=['Date'],<br/>    index_col='Date'<br/>)<br/><br/>X = data.drop(columns=['Sales'])<br/>y = data['Sales']<br/><br/>model.fit(X, y)<br/><br/>print(cross_val_score(model, X, y, cv=TimeSeriesSplit()).mean())<br/><br/># Output: ~0.55</span></pre><blockquote class="pq pr ps"><p id="a574" class="mb mc oy md b me np ke mg mh nq kh mj pt nr mm mn pu ns mq mr pv nt mu mv mw in bi translated"><strong class="md je"> <em class="iu">注:</em> </strong> <em class="iu">我们这里不使用标准的</em> k <em class="iu"> -fold交叉验证，因为我们处理的是时间序列数据。</em> <code class="fe oi oj ok ol b"><em class="iu">TimeSeriesSplit</em></code> <em class="iu">是比较合理的做法，这里</em>  <em class="iu">可以多了解一下</em> <a class="ae li" href="https://scikit-learn.org/stable/modules/cross_validation.html#time-series-split" rel="noopener ugc nofollow" target="_blank"> <em class="iu">。</em></a></p></blockquote><p id="0a6d" class="pw-post-body-paragraph mb mc iu md b me np ke mg mh nq kh mj mk nr mm mn mo ns mq mr ms nt mu mv mw in bi translated">有用！然而，该模型仍然相当糟糕，交叉验证的<em class="oy"> r </em>约为<strong class="md je"> 0.55，</strong>而旧的、更简单的模型为0.72。这是因为我们为每个通道使用了默认的非最佳参数，即饱和度的<em class="oy"> a </em> = 1，残留强度为0.5，长度为2。</p><p id="1354" class="pw-post-body-paragraph mb mc iu md b me np ke mg mh nq kh mj mk nr mm mn mo ns mq mr ms nt mu mv mw in bi translated">因此，让我们调整所有的adstock参数！</p><h2 id="bf2e" class="on lk iu bd ll oo op dn lp oq or dp lt mk os ot lv mo ou ov lx ms ow ox lz ja bi translated">超参数调谐</h2><p id="576f" class="pw-post-body-paragraph mb mc iu md b me mf ke mg mh mi kh mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">我将使用<a class="ae li" href="https://optuna.readthedocs.io/en/stable/" rel="noopener ugc nofollow" target="_blank"> Optuna </a>，一个用于优化任务的高级库。在许多其他的事情中，它提供了一个scikit-learn兼容的<code class="fe oi oj ok ol b">OptunaSearchCV</code>类，你可以把它看作是scikit-learn的<code class="fe oi oj ok ol b"><a class="ae li" href="https://scikit-learn.org/stable/modules/generated/sklearn.model_selection.GridSearchCV.html" rel="noopener ugc nofollow" target="_blank">GridSearchCV</a></code>和<code class="fe oi oj ok ol b"><a class="ae li" href="https://scikit-learn.org/stable/modules/generated/sklearn.model_selection.RandomizedSearchCV.html" rel="noopener ugc nofollow" target="_blank">RandomizedSearchCV</a></code>的替代物。</p><p id="147d" class="pw-post-body-paragraph mb mc iu md b me np ke mg mh nq kh mj mk nr mm mn mo ns mq mr ms nt mu mv mw in bi translated">简而言之，<code class="fe oi oj ok ol b">OptunaSearchCV</code>是<code class="fe oi oj ok ol b">RandomizedSearchCV</code>的更智能版本。虽然<code class="fe oi oj ok ol b">RandomizedSearchCV</code>只是随机走动，但是<code class="fe oi oj ok ol b">OptunaSearchCV</code>首先随机走动，然后检查看起来最有希望的超参数组合。</p><p id="4e88" class="pw-post-body-paragraph mb mc iu md b me np ke mg mh nq kh mj mk nr mm mn mo ns mq mr ms nt mu mv mw in bi translated">查看与您习惯用scikit编写的代码非常接近的代码——了解:</p><pre class="kt ku kv kw gu pw ol px bn py pz bi"><span id="7fde" class="qa lk iu ol b be qb qc l qd qe">from optuna.integration import OptunaSearchCV<br/>from optuna.distributions import UniformDistribution, IntUniformDistribution<br/><br/>tuned_model = OptunaSearchCV(<br/>    estimator=model,<br/>    param_distributions={<br/>        'adstock__tv_pipe__carryover__strength': UniformDistribution(0, 1),<br/>        'adstock__tv_pipe__carryover__length': IntUniformDistribution(0, 6),<br/>        'adstock__tv_pipe__saturation__a': UniformDistribution(0, 0.01),<br/>        'adstock__radio_pipe__carryover__strength': UniformDistribution(0, 1),<br/>        'adstock__radio_pipe__carryover__length': IntUniformDistribution(0, 6),<br/>        'adstock__radio_pipe__saturation__a': UniformDistribution(0, 0.01),<br/>        'adstock__banners_pipe__carryover__strength': UniformDistribution(0, 1),<br/>        'adstock__banners_pipe__carryover__length': IntUniformDistribution(0, 6),<br/>        'adstock__banners_pipe__saturation__a': UniformDistribution(0, 0.01),<br/>    },<br/>    n_trials=1000,<br/>    cv=TimeSeriesSplit(),<br/>    random_state=0<br/>)</span></pre><p id="4ade" class="pw-post-body-paragraph mb mc iu md b me np ke mg mh nq kh mj mk nr mm mn mo ns mq mr ms nt mu mv mw in bi translated">你告诉Optuna优化<code class="fe oi oj ok ol b">model</code>。它通过使用您在<code class="fe oi oj ok ol b">param_distributions</code>中指定的所有参数来实现。因为我们的模型是完全嵌套的，也就是说，列转换器中有管道，而列转换器本身又在管道中，所以我们必须准确地指定我们想要优化的超参数。这是通过诸如<code class="fe oi oj ok ol b">adstock__tv_pipe__carryover__strength</code>这样的字符串来完成的，其中<strong class="md je">两个下划线</strong>分隔了完整模型的不同层次。你发现<code class="fe oi oj ok ol b">adstock</code>、<code class="fe oi oj ok ol b">tv_pipe</code>、<code class="fe oi oj ok ol b">carryover</code>这几个字都在型号说明书里，而<code class="fe oi oj ok ol b">strength</code>是<code class="fe oi oj ok ol b">ExponentialCarryover</code>变压器的一个参数。</p><p id="2d6d" class="pw-post-body-paragraph mb mc iu md b me np ke mg mh nq kh mj mk nr mm mn mo ns mq mr ms nt mu mv mw in bi translated">然后，你找到一些分布。<code class="fe oi oj ok ol b">UniformDistribution(0, 1)</code>表示应该在0和1之间寻找<strong class="md je">浮点</strong>参数。按照同样的逻辑，<code class="fe oi oj ok ol b">IntUniformDistribution(0, 6)</code>搜索0到6之间的<strong class="md je">整数</strong>值(不是5！)，因此我们告诉模型只考虑结转长度小于或等于六周，这只是我们的一个选择。</p><p id="172b" class="pw-post-body-paragraph mb mc iu md b me np ke mg mh nq kh mj mk nr mm mn mo ns mq mr ms nt mu mv mw in bi translated">我们尝试<code class="fe oi oj ok ol b">n_trials=1000</code>不同的参数组合，并再次使用<code class="fe oi oj ok ol b">TimeSeriesSplit</code>进行评估。通过设置<code class="fe oi oj ok ol b">random_state=0</code>保持结果的可再现性。<em class="oy">搞定！</em>这应该足够理解代码了。</p><h2 id="4ebe" class="on lk iu bd ll oo op dn lp oq or dp lt mk os ot lv mo ou ov lx ms ow ox lz ja bi translated">性能检查</h2><p id="5509" class="pw-post-body-paragraph mb mc iu md b me mf ke mg mh mi kh mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">让我们使用这个名为<code class="fe oi oj ok ol b">tuned_model</code>的优化模型来检查性能。小心，这需要很长时间。你可以将<code class="fe oi oj ok ol b">n_trials</code>减少到100，以更快地得到一个更差的解。</p><pre class="kt ku kv kw gu pw ol px bn py pz bi"><span id="06f7" class="qa lk iu ol b be qb qc l qd qe">print(cross_val_score(tuned_model, X, y, cv=TimeSeriesSplit()))<br/><br/># Output: array([0.847353, 0.920507, 0.708728, 0.943805, 0.908159])</span></pre><p id="47b8" class="pw-post-body-paragraph mb mc iu md b me np ke mg mh nq kh mj mk nr mm mn mo ns mq mr ms nt mu mv mw in bi translated">平均交叉验证的<em class="oy"> r </em>为<strong class="md je"> 0.87，</strong>与未优化的模型(0.55)和我们上一篇文章中的旧平面线性模型(0.72)相比，这是一个很大的改进。让我们现在改装模型，看看它学到了什么。</p><pre class="kt ku kv kw gu pw ol px bn py pz bi"><span id="bcdf" class="qa lk iu ol b be qb qc l qd qe">tuned_model.fit(X, y)</span></pre><p id="2ea7" class="pw-post-body-paragraph mb mc iu md b me np ke mg mh nq kh mj mk nr mm mn mo ns mq mr ms nt mu mv mw in bi translated">最佳超参数如下:</p><pre class="kt ku kv kw gu pw ol px bn py pz bi"><span id="102f" class="qa lk iu ol b be qb qc l qd qe">print(tuned_model.best_params_)<br/>print(tuned_model.best_estimator_.named_steps['regression'].coef_)<br/>print(tuned_model.best_estimator_.named_steps['regression'].intercept_)<br/><br/># Output:<br/># Hyperparameters = {<br/># 'adstock__tv_pipe__carryover__strength': 0.5248878517291329<br/># 'adstock__tv_pipe__carryover__length': 4<br/># 'adstock__tv_pipe__saturation__a': 1.4649722346562529e-05<br/># 'adstock__radio_pipe__carryover__strength': 0.45523455448406197<br/># 'adstock__radio_pipe__carryover__length': 0<br/># 'adstock__radio_pipe__saturation__a': 0.0001974038926379962<br/># 'adstock__banners_pipe__carryover__strength': 0.3340342963936898<br/># 'adstock__banners_pipe__carryover__length': 0<br/># 'adstock__banners_pipe__saturation__a': 0.007256873558015173<br/># }<br/>#<br/># Coefficients = [27926.6810003   4114.46117033  2537.18883927]<br/># Intercept = 5348.966158957056</span></pre><h2 id="5897" class="on lk iu bd ll oo op dn lp oq or dp lt mk os ot lv mo ou ov lx ms ow ox lz ja bi translated">对新数据使用模型</h2><p id="f78a" class="pw-post-body-paragraph mb mc iu md b me mf ke mg mh mi kh mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">如果您想为新的支出表创建预测，可以按如下方式进行:</p><pre class="kt ku kv kw gu pw ol px bn py pz bi"><span id="7bbb" class="qa lk iu ol b be qb qc l qd qe">X_new = pd.DataFrame({<br/>    'TV': [10000, 0, 0],<br/>    'Radio': [0, 3000, 0],<br/>    'Banners': [1000, 1000, 1000]<br/>})<br/><br/>tuned_model.predict(X_new)</span></pre><p id="3700" class="pw-post-body-paragraph mb mc iu md b me np ke mg mh nq kh mj mk nr mm mn mo ns mq mr ms nt mu mv mw in bi translated">请注意，<strong class="md je">预测总是以零库存</strong>开始，即模型不知道过去的任何结转，除非您将它放入预测数据框架。例如，如果您想知道第<em class="oy">周到第</em>周的销售额，并且您只输入第<em class="oy">周到第</em>周的支出，那么它不会考虑之前第<em class="oy">周到第</em> -1周、<em class="oy">周到第</em> -2周的结转。如果你想让模型建立一个库存，你也必须包括之前的几周，即使你只对最后一次观察的预测感兴趣。</p><p id="d456" class="pw-post-body-paragraph mb mc iu md b me np ke mg mh nq kh mj mk nr mm mn mo ns mq mr ms nt mu mv mw in bi translated">你甚至可以用更多不花费的特性来扩展训练数据，所谓的<em class="oy">控制变量</em>。如果您没有在<code class="fe oi oj ok ol b">ColumnTransformer</code>对象中指定任何预处理，原始值将直接传递给<code class="fe oi oj ok ol b">LinearRegression</code>并被考虑用于训练和预测。</p><h1 id="8a85" class="lj lk iu bd ll lm ln lo lp lq lr ls lt kj lu kk lv km lw kn lx kp ly kq lz ma bi translated">解释模型</h1><p id="c5e1" class="pw-post-body-paragraph mb mc iu md b me mf ke mg mh mi kh mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">使用上面的数据，我们可以创建一些漂亮的图片，帮助我们从模型中获得洞察力。</p><h2 id="6254" class="on lk iu bd ll oo op dn lp oq or dp lt mk os ot lv mo ou ov lx ms ow ox lz ja bi translated">饱和效应</h2><p id="2352" class="pw-post-body-paragraph mb mc iu md b me mf ke mg mh mi kh mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">如果我们插入饱和变压器的值，我们会得到以下结果:</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj qo"><img src="../Images/2d085b91f559c1ee781fb3b2f5771744.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DDLH8iaJ7mYHqXAhfAotyw.png"/></div></div><p class="le lf gk gi gj lg lh bd b be z dk translated">图片由作者提供。</p></figure><ul class=""><li id="7797" class="nu nv iu md b me np mh nq mk nw mo nx ms ny mw ql oa ob oc bi translated">我们可以看到，该模型认为电视频道仍然非常<em class="oy">不饱和——</em>在这里花费更多可能有利于销售。注意，我们最大的电视支出大约是15000英镑。</li><li id="af3e" class="nu nv iu md b me od mh oe mk of mo og ms oh mw ql oa ob oc bi translated">广播看起来有点饱和，但增加这方面的支出似乎还是合理的。该渠道最高消费约7700。</li><li id="7047" class="nu nv iu md b me od mh oe mk of mo og ms oh mw ql oa ob oc bi translated">横幅看起来<em class="oy">过饱和</em>。这里最高消费2500左右，函数值已经接近1了。更高的支出似乎不会有太大的成效。</li></ul><h2 id="7d93" class="on lk iu bd ll oo op dn lp oq or dp lt mk os ot lv mo ou ov lx ms ow ox lz ja bi translated">遗留效应</h2><p id="ac4d" class="pw-post-body-paragraph mb mc iu md b me mf ke mg mh mi kh mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">如果我们插入延续变压器的值，我们会得到以下结果:</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj qp"><img src="../Images/51b6d9a07e5b5a8c89feca991cafc813.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7iIWN2Tb2BG3FJqmW6iKmw.png"/></div></div><p class="le lf gk gi gj lg lh bd b be z dk translated">图片由作者提供。</p></figure><p id="1e32" class="pw-post-body-paragraph mb mc iu md b me np ke mg mh nq kh mj mk nr mm mn mo ns mq mr ms nt mu mv mw in bi translated">似乎电视广告在最初消费4周后仍然对销售有影响。这比广播和网络横幅广告在同一周内迅速消失的效果要长得多。</p><h2 id="d84f" class="on lk iu bd ll oo op dn lp oq or dp lt mk os ot lv mo ou ov lx ms ow ox lz ja bi translated">渠道贡献</h2><p id="8b5e" class="pw-post-body-paragraph mb mc iu md b me mf ke mg mh mi kh mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">和上一篇文章一样，我们可以计算每个渠道对每天销售额的贡献。代码比以前稍微复杂一些，因为模型也变得更复杂了。无论如何，这里有一个工作版本:</p><pre class="kt ku kv kw gu pw ol px bn py pz bi"><span id="a805" class="qa lk iu ol b be qb qc l qd qe">adstock_data = pd.DataFrame(<br/>    tuned_model.best_estimator_.named_steps['adstock'].transform(X),<br/>    columns=X.columns,<br/>    index=X.index<br/>)<br/><br/>weights = pd.Series(<br/>    tuned_model.best_estimator_.named_steps['regression'].coef_,<br/>    index=X.columns<br/>)<br/><br/>base = tuned_model.best_estimator_.named_steps['regression'].intercept_<br/><br/>unadj_contributions = adstock_data.mul(weights).assign(Base=base)<br/>adj_contributions = (unadj_contributions<br/>                     .div(unadj_contributions.sum(axis=1), axis=0)<br/>                     .mul(y, axis=0)<br/>                    )<br/><br/>ax = (adj_contributions[['Base', 'Banners', 'Radio', 'TV']]<br/>      .plot.area(<br/>          figsize=(16, 10),<br/>          linewidth=1,<br/>          title='Predicted Sales and Breakdown',<br/>          ylabel='Sales',<br/>          xlabel='Date'<br/>      )<br/>     )<br/>    <br/>handles, labels = ax.get_legend_handles_labels()<br/>ax.legend(<br/>    handles[::-1], labels[::-1],<br/>    title='Channels', loc="center left",<br/>    bbox_to_anchor=(1.01, 0.5)<br/>)</span></pre><p id="55c1" class="pw-post-body-paragraph mb mc iu md b me np ke mg mh nq kh mj mk nr mm mn mo ns mq mr ms nt mu mv mw in bi translated">输出:</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj qq"><img src="../Images/ca5e3ee934b12617bc81d4033d43b098.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P8GhRUvumytu1op-hQ2rng.png"/></div></div><p class="le lf gk gi gj lg lh bd b be z dk translated">图片由作者提供。</p></figure><p id="7548" class="pw-post-body-paragraph mb mc iu md b me np ke mg mh nq kh mj mk nr mm mn mo ns mq mr ms nt mu mv mw in bi translated">与旧图相比，基线不再摇摆不定，因为该模型可以更好地解释给定渠道支出的销售情况。下面是<strong class="md je">老款</strong>的一款:</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj qq"><img src="../Images/9516074807646298d7d975e48d955778.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*jqL9gs9e3sVHZJtw.png"/></div></div><p class="le lf gk gi gj lg lh bd b be z dk translated"><strong class="bd qr">老</strong>型号。图片由作者提供。</p></figure><h1 id="1088" class="lj lk iu bd ll lm ln lo lp lq lr ls lt kj lu kk lv km lw kn lx kp ly kq lz ma bi translated"><strong class="ak">总结与展望</strong></h1><p id="2eee" class="pw-post-body-paragraph mb mc iu md b me mf ke mg mh mi kh mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">在本文中，我们采用了旧的简单线性模型，并通过不依赖原始渠道支出，而是依赖广告库存来改进它。广告库存是通过引入饱和效应和结转效应来更真实地反映现实世界的转换支出。</p><p id="dce2" class="pw-post-body-paragraph mb mc iu md b me np ke mg mh nq kh mj mk nr mm mn mo ns mq mr ms nt mu mv mw in bi translated">我们甚至对这两个概念做了简明的实现，可以在scikit-learn生态系统中以即插即用的方式使用。</p><p id="ccf3" class="pw-post-body-paragraph mb mc iu md b me np ke mg mh nq kh mj mk nr mm mn mo ns mq mr ms nt mu mv mw in bi translated">我们做的最后一件事是调整模型，然后看看它已经了解了什么。我们以人们容易理解的图片形式获得了一些有趣的见解，使这个模型既准确又可解释。</p><p id="ac8b" class="pw-post-body-paragraph mb mc iu md b me np ke mg mh nq kh mj mk nr mm mn mo ns mq mr ms nt mu mv mw in bi translated"><strong class="md je">然而，仍有一些未解决的问题:</strong></p><ol class=""><li id="ea5d" class="nu nv iu md b me np mh nq mk nw mo nx ms ny mw nz oa ob oc bi translated">我们已经讨论了优化支出，以及旧模式为何无法做到这一点。嗯，有了新的，但我不会在这里详细介绍。简而言之，对待我们的<code class="fe oi oj ok ol b">tuned_model</code>函数，用你选择的程序优化它，例如<strong class="md je"> Optuna </strong>或<strong class="md je">scipy . optimize . minimize</strong>。为优化添加一些预算约束，例如总支出应少于1，000，000。</li><li id="4418" class="nu nv iu md b me od mh oe mk of mo og ms oh mw nz oa ob oc bi translated">将<strong class="md je">非支出</strong>数据输入模型可能会进一步改善它。例如，以一周中的<strong class="md je">日</strong>、<strong class="md je">月</strong>，或者甚至是我们想要销售的产品的<strong class="md je">价格为例。尤其是价格是销售的一个重要驱动力:一部售价10000 €的普通iPhone不会产生多少销量，而一部售价100 €的iPhone会在一眨眼的功夫就脱销。对于季节性产品(如粉丝或热巧克力)来说，月份等及时功能可能很有意思。或者像圣诞节这样的特殊日子。收集你的想法，并确保添加所有能够影响销售的内容！</strong></li></ol><h1 id="32cd" class="lj lk iu bd ll lm ln lo lp lq lr ls lt kj lu kk lv km lw kn lx kp ly kq lz ma bi translated">参考</h1><p id="0753" class="pw-post-body-paragraph mb mc iu md b me mf ke mg mh mi kh mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">[1] S .布罗德本特，《电视广告的单向作用》(1979年)。<em class="oy">《市场研究学会杂志</em>，<em class="oy"> 21 </em> (3)，第139–166页。</p></div><div class="ab cl qs qt hy qu" role="separator"><span class="qv bw bk qw qx qy"/><span class="qv bw bk qw qx qy"/><span class="qv bw bk qw qx"/></div><div class="in io ip iq ir"><p id="ef04" class="pw-post-body-paragraph mb mc iu md b me np ke mg mh nq kh mj mk nr mm mn mo ns mq mr ms nt mu mv mw in bi translated">我希望你今天学到了新的、有趣的、有用的东西。感谢阅读！</p><p id="d1b9" class="pw-post-body-paragraph mb mc iu md b me np ke mg mh nq kh mj mk nr mm mn mo ns mq mr ms nt mu mv mw in bi translated"><strong class="md je">作为最后一点，如果你</strong></p><ol class=""><li id="e8f8" class="nu nv iu md b me np mh nq mk nw mo nx ms ny mw nz oa ob oc bi translated"><strong class="md je">想支持我多写点机器学习和</strong></li><li id="5f73" class="nu nv iu md b me od mh oe mk of mo og ms oh mw nz oa ob oc bi translated"><strong class="md je">无论如何都要计划获得中等订阅量，</strong></li></ol><p id="8543" class="pw-post-body-paragraph mb mc iu md b me np ke mg mh nq kh mj mk nr mm mn mo ns mq mr ms nt mu mv mw in bi translated"><strong class="md je">为什么不做</strong> <a class="ae li" href="https://dr-robert-kuebler.medium.com/membership" rel="noopener"> <strong class="md je">通过这个环节</strong> </a> <strong class="md je">？这将对我帮助很大！😊</strong></p><p id="badd" class="pw-post-body-paragraph mb mc iu md b me np ke mg mh nq kh mj mk nr mm mn mo ns mq mr ms nt mu mv mw in bi translated">透明地说，给你的价格不变，但大约一半的订阅费直接归我。</p><p id="e929" class="pw-post-body-paragraph mb mc iu md b me np ke mg mh nq kh mj mk nr mm mn mo ns mq mr ms nt mu mv mw in bi translated">非常感谢，如果你考虑支持我的话！</p><blockquote class="oz"><p id="7719" class="pa pb iu bd pc pd pe pf pg ph pi mw dk translated"><em class="qz">有问题就在</em><a class="ae li" href="https://www.linkedin.com/in/dr-robert-k%C3%BCbler-983859150/" rel="noopener ugc nofollow" target="_blank"><em class="qz">LinkedIn</em></a><em class="qz">上写我！</em></p></blockquote></div></div>    
</body>
</html>