<html>
<head>
<title>SQL Window Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SQL窗口函数</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/sql-window-functions-78593bcabf4?source=collection_archive---------8-----------------------#2021-04-04">https://towardsdatascience.com/sql-window-functions-78593bcabf4?source=collection_archive---------8-----------------------#2021-04-04</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><h2 id="05d0" class="ip iq ir bd b dl is it iu iv iw ix dk iy translated" aria-label="kicker paragraph">辅导的</h2><div class=""/><div class=""><h2 id="9298" class="pw-subtitle-paragraph jx ja ir bd b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko dk translated">爱恨交加的关系</h2></div><figure class="kq kr ks kt gu ku gi gj paragraph-image"><div class="gi gj kp"><img src="../Images/73b230033e6f1c91c14b9d7fa709417c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1326/format:webp/1*v2QfTCSKxE7QfduJzgGSiQ.jpeg"/></div></figure><blockquote class="kx ky kz"><p id="acbe" class="la lb lc ld b le lf kb lg lh li ke lj lk ll lm ln lo lp lq lr ls lt lu lv lw ik bi translated">我爱你，即使我恨你— <strong class="ld jb">亨利·利奥·苏贤</strong></p></blockquote><p id="7635" class="pw-post-body-paragraph la lb ir ld b le lf kb lg lh li ke lj lx ll lm ln ly lp lq lr lz lt lu lv lw ik bi translated">我一直对SQL窗口函数又爱又恨。当他们工作时，我爱他们，当他们不工作时，我恨他们。我会花上几个小时与他们争论和斗争，直到我沮丧地走开，或者通过蛮力让他们工作。这些努力前后矛盾，令人困惑。如此强大的力量，却又如此难以驾驭。喝了几个小时的咖啡，或许还说了一些不友好的话，我意识到我误解了驱动SQL窗口函数算法的核心元素。</p><h2 id="aa13" class="ma mb ir bd mc md me dn mf mg mh dp mi lx mj mk ml ly mm mn mo lz mp mq mr ix bi translated">基础知识</h2><p id="5b8f" class="pw-post-body-paragraph la lb ir ld b le ms kb lg lh mt ke lj lx mu lm ln ly mv lq lr lz mw lu lv lw ik bi translated">如果你处理过大数据，你很可能在Spark、Pandas、Tableau、MySQL、Postgres和Snowflake中遇到过窗口函数。如下表所示，窗口函数可以分为三种类型。</p><figure class="kq kr ks kt gu ku gi gj paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gi gj mx"><img src="../Images/65024dc13f635c2472386c9cb63ec7e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nGML2mjMAlH2JDnYEu6LGg.jpeg"/></div></div></figure><p id="62fe" class="pw-post-body-paragraph la lb ir ld b le lf kb lg lh li ke lj lx ll lm ln ly lp lq lr lz lt lu lv lw ik bi translated">在本<strong class="ld jb">教程中，</strong>我将重点介绍窗口函数的<strong class="ld jb">核心语法</strong>，即<code class="fe nc nd ne nf b">OVER()</code>、<code class="fe nc nd ne nf b">PARTITION BY</code>和<code class="fe nc nd ne nf b">ORDER BY</code>子句。这些元素是大多数窗口函数背后的<strong class="ld jb">驱动因素</strong>，所以如果你正在<strong class="ld jb">纠结</strong>如何应用一个窗口函数，这很可能与不理解窗口函数算法如何执行这些元素有关。理解这些工作方式将为实现所有窗口函数类型打开大门。在本教程中，我不涉及<code class="fe nc nd ne nf b">frame</code>条款。这是一个很大的话题，值得自己的教程。此外，它的实现因SQL平台而异。所以，我建议看平台的文档。</p><p id="f8bb" class="pw-post-body-paragraph la lb ir ld b le lf kb lg lh li ke lj lx ll lm ln ly lp lq lr lz lt lu lv lw ik bi translated"><strong class="ld jb">开始</strong>理解任何窗口功能都是语法。下图显示了窗口函数的基本语法，以及每个重要元素的描述。</p><figure class="kq kr ks kt gu ku gi gj paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gi gj ng"><img src="../Images/29a5e5fab047c0f8e182bb78ec7842e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dF6t8PKg3frFYQybks6THA.jpeg"/></div></div><p class="nh ni gk gi gj nj nk bd b be z dk translated">语法，窗口函数</p></figure><p id="9aed" class="pw-post-body-paragraph la lb ir ld b le lf kb lg lh li ke lj lx ll lm ln ly lp lq lr lz lt lu lv lw ik bi translated">在下面的教程中你会学到更多。同时，我建议复制一份语法以供将来参考。当您使用越来越多的窗口函数时，它可以作为快速复习工具。</p><h2 id="a36c" class="ma mb ir bd mc md me dn mf mg mh dp mi lx mj mk ml ly mm mn mo lz mp mq mr ix bi translated">窗函数算法</h2><p id="2c8e" class="pw-post-body-paragraph la lb ir ld b le ms kb lg lh mt ke lj lx mu lm ln ly mv lq lr lz mw lu lv lw ik bi translated">用于处理窗口函数的算法步骤因窗口函数、分区和子句排序而异。虽然对算法处理的深入探究超出了本教程的范围，但我发现将算法想象成从<code class="fe nc nd ne nf b">OVER()</code>子句开始，然后是<code class="fe nc nd ne nf b">PARTITION BY</code>和最后的<code class="fe nc nd ne nf b">ORDER BY</code>会很有帮助。</p><h2 id="ac67" class="ma mb ir bd mc md me dn mf mg mh dp mi lx mj mk ml ly mm mn mo lz mp mq mr ix bi translated">我们的SQL窗口函数</h2><p id="d98a" class="pw-post-body-paragraph la lb ir ld b le ms kb lg lh mt ke lj lx mu lm ln ly mv lq lr lz mw lu lv lw ik bi translated">本教程探索了<code class="fe nc nd ne nf b">RANK(sales_price) OVER(PARITITION BY city ORDERY BY sold_date [frame clause])</code>函数。<code class="fe nc nd ne nf b">RANK()</code>窗口函数确定一个值在一组值中的排名。该表显示了数据集。</p><figure class="kq kr ks kt gu ku gi gj paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gi gj nl"><img src="../Images/61bafa3aa92f99daef5bf0557e01ff5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9uSjzT2vOpPtSJ4cyJRA5A.jpeg"/></div></div></figure><p id="cc2f" class="pw-post-body-paragraph la lb ir ld b le lf kb lg lh li ke lj lx ll lm ln ly lp lq lr lz lt lu lv lw ik bi translated">使用<code class="fe nc nd ne nf b">sold_date</code>、<code class="fe nc nd ne nf b">city</code>和<code class="fe nc nd ne nf b">street_name</code>作为<code class="fe nc nd ne nf b">RANK()</code>窗口功能的输入来填充<code class="fe nc nd ne nf b">rank_sales_price</code>栏。您可能已经注意到<code class="fe nc nd ne nf b">rank_sales_price</code>列是空白的。别担心。我们将介绍对销售价格进行排序所需的步骤。</p><h2 id="3a51" class="ma mb ir bd mc md me dn mf mg mh dp mi lx mj mk ml ly mm mn mo lz mp mq mr ix bi translated">我们的数据</h2><p id="af5c" class="pw-post-body-paragraph la lb ir ld b le ms kb lg lh mt ke lj lx mu lm ln ly mv lq lr lz mw lu lv lw ik bi translated">我们示例中的数据来自我创建并填充到SQL Server表中的数据。在学习SQL窗口函数时，我鼓励您在电子表格中构建自己的示例，然后将它们导入到自己的SQL表中。另一种方法是使用现有的数据集，并将其导入SQL表。下面的SQL查询显示了我的数据表中的所有列函数以及我创建的窗口函数。</p><figure class="kq kr ks kt gu ku gi gj paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gi gj nl"><img src="../Images/70063542d0e21a4bb98310317fc38bd2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HcRart4OOwda8udR0T8CYg.jpeg"/></div></div></figure><p id="6b6b" class="pw-post-body-paragraph la lb ir ld b le lf kb lg lh li ke lj lx ll lm ln ly lp lq lr lz lt lu lv lw ik bi translated">除了<code class="fe nc nd ne nf b">RANK()</code>窗口功能外，<code class="fe nc nd ne nf b">SELECT</code>语句还可以支持额外的窗口功能。这是测试不同的<code class="fe nc nd ne nf b">PARTITION BY</code>和<code class="fe nc nd ne nf b">ORDER BY</code>子句的强大功能。<code class="fe nc nd ne nf b">OVER()</code>条款启用该功能。</p><h2 id="eeb3" class="ma mb ir bd mc md me dn mf mg mh dp mi lx mj mk ml ly mm mn mo lz mp mq mr ix bi translated">OVER()子句:总建筑师</h2><p id="4a86" class="pw-post-body-paragraph la lb ir ld b le ms kb lg lh mt ke lj lx mu lm ln ly mv lq lr lz mw lu lv lw ik bi translated"><code class="fe nc nd ne nf b">OVER()</code>条款就像建筑师设计住宅一样。家居设计通常包括卧室、浴室、厨房和几个其他房间；请参见下面的平面图。类似地，对于每个窗口，<code class="fe nc nd ne nf b">OVER()</code>子句为<code class="fe nc nd ne nf b">PARTITION BY</code>和<code class="fe nc nd ne nf b">ORDER BY</code>子句构建了一个单独的<strong class="ld jb">执行</strong>T21空间。</p><figure class="kq kr ks kt gu ku gi gj paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gi gj nm"><img src="../Images/c4bd116af6625a8b50c083c7a9e7c7f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mXSABFrpVbrHC2rJ3yPu4Q.jpeg"/></div></div></figure><p id="24dd" class="pw-post-body-paragraph la lb ir ld b le lf kb lg lh li ke lj lx ll lm ln ly lp lq lr lz lt lu lv lw ik bi translated">房子里的每个房间都有不同的功能。卧室是用来睡觉的，而厨房是用来做饭的。对于窗口类型，每个功能都有不同的用途。<code class="fe nc nd ne nf b">AVG</code>窗口函数返回平均值(算术平均值),而<code class="fe nc nd ne nf b">SUM</code>窗口函数返回输入列的总和。</p><p id="1a42" class="pw-post-body-paragraph la lb ir ld b le lf kb lg lh li ke lj lx ll lm ln ly lp lq lr lz lt lu lv lw ik bi translated">一个<code class="fe nc nd ne nf b">SELECT</code>语句中的窗口函数越多，创建执行空间的架构师、<code class="fe nc nd ne nf b">OVER</code>子句就越多。这就是<code class="fe nc nd ne nf b">OVER()</code>子句的强大之处，它<strong class="ld jb">消除了</strong>创建多个查询的需要。一条<code class="fe nc nd ne nf b">SELECT</code>语句可以返回多个结果。</p><h2 id="d4c4" class="ma mb ir bd mc md me dn mf mg mh dp mi lx mj mk ml ly mm mn mo lz mp mq mr ix bi translated">设计考虑</h2><p id="ee8b" class="pw-post-body-paragraph la lb ir ld b le ms kb lg lh mt ke lj lx mu lm ln ly mv lq lr lz mw lu lv lw ik bi translated">在查看窗口函数时，将<code class="fe nc nd ne nf b">PARTITION BY</code>子句视为列中数据的<strong class="ld jb">分组器</strong>并将<code class="fe nc nd ne nf b">ORDER BY</code>子句视为列中数据的<strong class="ld jb">组织器</strong>会很有帮助。作为<strong class="ld jb">分组器</strong>,<code class="fe nc nd ne nf b">PARTITION BY</code>对数据列中的相似值进行分组。作为<strong class="ld jb">组织者</strong>,<code class="fe nc nd ne nf b">ORDER BY</code>子句决定<strong class="ld jb">聚合排序或分析窗口函数如何应用于行数据。由于可选的默认设置，很容易忽略<code class="fe nc nd ne nf b">ORDER BY</code>子句，但这将是一个错误。条款很重要，理解它会让你省去几个小时的挫败感。我们稍后会深入探讨，但首先让我们更详细地看看条款。</strong></p><h2 id="a4b4" class="ma mb ir bd mc md me dn mf mg mh dp mi lx mj mk ml ly mm mn mo lz mp mq mr ix bi translated">分区依据子句</h2><p id="f101" class="pw-post-body-paragraph la lb ir ld b le ms kb lg lh mt ke lj lx mu lm ln ly mv lq lr lz mw lu lv lw ik bi translated">使用<code class="fe nc nd ne nf b">PARTITION BY</code>子句时，记住几条规则很有帮助:</p><ul class=""><li id="47ee" class="nn no ir ld b le lf lh li lx np ly nq lz nr lw ns nt nu nv bi translated"><code class="fe nc nd ne nf b">PARTITION BY</code>子句从左到右处理列。</li><li id="3cbc" class="nn no ir ld b le nw lh nx lx ny ly nz lz oa lw ns nt nu nv bi translated"><code class="fe nc nd ne nf b">PARTITION BY</code>子句对相似值进行分组，并根据差异进行拆分。</li></ul><p id="1641" class="pw-post-body-paragraph la lb ir ld b le lf kb lg lh li ke lj lx ll lm ln ly lp lq lr lz lt lu lv lw ik bi translated">我发现将<code class="fe nc nd ne nf b">PARTITION BY</code>子句想象成在移动到<code class="fe nc nd ne nf b">PARTITION</code>中的下一列之前扫描该列并对相同的值进行分组是很有用的。让我们看看下面的图片，了解它是如何工作的。</p><figure class="kq kr ks kt gu ku gi gj paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gi gj ob"><img src="../Images/584df8d96431d498d71d6b9833d26f6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*79vu0zll69SeLqykPs-Bww.jpeg"/></div></div><p class="nh ni gk gi gj nj nk bd b be z dk translated">分组和拆分，分区依据</p></figure><p id="d934" class="pw-post-body-paragraph la lb ir ld b le lf kb lg lh li ke lj lx ll lm ln ly lp lq lr lz lt lu lv lw ik bi translated">在<strong class="ld jb">步骤1中，</strong>处理从最左边的列<strong class="ld jb">城市</strong>开始。在城市列中有三个不同的值:<strong class="ld jb">埃塞克斯</strong>、<strong class="ld jb">绿色英亩</strong>和<strong class="ld jb">蓝色海洋</strong>。<strong class="ld jb">算法将具有相同值的行</strong>分组在一起，而<strong class="ld jb">将差异分割在</strong>上。结果是<strong class="ld jb">步骤2 </strong>中的三个结果集。处理在下一列<strong class="ld jb">街道名称</strong>中继续。窗口算法继续对差异进行分组和分割。在<strong class="ld jb">步骤2 </strong>中，以<strong class="ld jb">埃塞克斯</strong>为城市的数据不拆分。行值不存在差异。主街在两排。然而，街道名称中的一个<strong class="ld jb">差异</strong>导致数据分裂为绿色英亩和蓝色海洋的城市。图像显示了分组和分割<strong class="ld jb">步骤3 </strong>的结果。</p><h2 id="471d" class="ma mb ir bd mc md me dn mf mg mh dp mi lx mj mk ml ly mm mn mo lz mp mq mr ix bi translated">ORDER BY子句</h2><p id="02ef" class="pw-post-body-paragraph la lb ir ld b le ms kb lg lh mt ke lj lx mu lm ln ly mv lq lr lz mw lu lv lw ik bi translated">我认为<code class="fe nc nd ne nf b">ORDER BY</code>子句在编写<code class="fe nc nd ne nf b">SELECT</code>语句查询时存在镜像问题。您可能几个月都不需要使用SQL窗口函数，因此在使用SQL窗口函数时很容易被忽略——这是一个高级主题。然而，在编写<strong class="ld jb">窗口函数</strong>时，<code class="fe nc nd ne nf b">ORDER BY</code>子句是应用窗口函数结果的有力工具。它的排序属性(升序-降序)<strong class="ld jb">控制</strong>窗口函数如何应用于一行数据。</p><p id="ad7c" class="pw-post-body-paragraph la lb ir ld b le lf kb lg lh li ke lj lx ll lm ln ly lp lq lr lz lt lu lv lw ik bi translated">使用<code class="fe nc nd ne nf b">ORDER BY</code>子句时，记住几条规则很有帮助:</p><ul class=""><li id="cfdc" class="nn no ir ld b le lf lh li lx np ly nq lz nr lw ns nt nu nv bi translated"><code class="fe nc nd ne nf b">ORDER BY</code>子句从左到右处理列。</li><li id="b5bc" class="nn no ir ld b le nw lh nx lx ny ly nz lz oa lw ns nt nu nv bi translated">在<code class="fe nc nd ne nf b">ORDER BY</code>子句中，列处理<code class="fe nc nd ne nf b">PARTITION BY</code>子句中列的<strong class="ld jb">独立</strong>。在<code class="fe nc nd ne nf b">PARTITION BY</code>子句中使用的列不必在<code class="fe nc nd ne nf b">ORDER BY</code>子句中使用。</li><li id="10ea" class="nn no ir ld b le nw lh nx lx ny ly nz lz oa lw ns nt nu nv bi translated"><code class="fe nc nd ne nf b">ORDER BY</code>子句的sort属性决定了窗口函数如何应用于行数据。</li><li id="8805" class="nn no ir ld b le nw lh nx lx ny ly nz lz oa lw ns nt nu nv bi translated">在<code class="fe nc nd ne nf b">ORDER BY</code>子句中发现整数和日期数据类型列是很常见的。日期列可以是开始日期、结束日期等。而整数列可能是价格、大小或距离。窗口函数算法不会将<code class="fe nc nd ne nf b">ORDER BY</code>列限制为这些值或数据类型。这些示例旨在帮助理解用法。</li></ul><p id="50e8" class="pw-post-body-paragraph la lb ir ld b le lf kb lg lh li ke lj lx ll lm ln ly lp lq lr lz lt lu lv lw ik bi translated">我已经将<strong class="ld jb">和</strong>的<code class="fe nc nd ne nf b">Date Sold</code>和<code class="fe nc nd ne nf b">Rank</code>列添加到下面的数据中。<code class="fe nc nd ne nf b">Date Sold</code>列包含在<code class="fe nc nd ne nf b">ORDER BY</code>子句中使用的日期数据。<code class="fe nc nd ne nf b">Rank</code>列的值为空。<code class="fe nc nd ne nf b">ORDER BY</code>子句<strong class="ld jb">的<strong class="ld jb">排序属性</strong>设置</strong>列中的值。</p><figure class="kq kr ks kt gu ku gi gj paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gi gj oc"><img src="../Images/576ae08ad9fd916801020beda8e3cce5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Bgscej_F1tr6vU5u-HM6OA.jpeg"/></div></div></figure><p id="5c24" class="pw-post-body-paragraph la lb ir ld b le lf kb lg lh li ke lj lx ll lm ln ly lp lq lr lz lt lu lv lw ik bi translated">有两个<strong class="ld jb">路径，升序或降序，用于设置<code class="fe nc nd ne nf b">Rank</code>列中的值。</strong></p><ul class=""><li id="9f44" class="nn no ir ld b le lf lh li lx np ly nq lz nr lw ns nt nu nv bi translated">路径1:如果我将<code class="fe nc nd ne nf b">ORDER BY</code>子句中的<code class="fe nc nd ne nf b">Date Sold</code>列设置为<strong class="ld jb">升序</strong> <code class="fe nc nd ne nf b">(asc)</code>，它会将<code class="fe nc nd ne nf b">1</code>的<code class="fe nc nd ne nf b">RANK</code>值赋给第一条记录<code class="fe nc nd ne nf b">1/18/2017</code>。</li><li id="349c" class="nn no ir ld b le nw lh nx lx ny ly nz lz oa lw ns nt nu nv bi translated">路径2:如果我将<code class="fe nc nd ne nf b">ORDER BY</code>子句中的<code class="fe nc nd ne nf b">Date Sold</code>列设置为<strong class="ld jb">降序</strong> <code class="fe nc nd ne nf b"><strong class="ld jb">(desc)</strong></code>，它会将<code class="fe nc nd ne nf b">1</code>的<code class="fe nc nd ne nf b">RANK</code>值赋给最后一条记录<code class="fe nc nd ne nf b">1/20/2019</code>。</li></ul><p id="8d8a" class="pw-post-body-paragraph la lb ir ld b le lf kb lg lh li ke lj lx ll lm ln ly lp lq lr lz lt lu lv lw ik bi translated">因此，窗口函数通过<code class="fe nc nd ne nf b">ORDER BY</code>子句的<code class="fe nc nd ne nf b">asc</code>或<code class="fe nc nd ne nf b">desc</code>排序属性应用于记录。</p><h2 id="c544" class="ma mb ir bd mc md me dn mf mg mh dp mi lx mj mk ml ly mm mn mo lz mp mq mr ix bi translated">结论</h2><p id="38d5" class="pw-post-body-paragraph la lb ir ld b le ms kb lg lh mt ke lj lx mu lm ln ly mv lq lr lz mw lu lv lw ik bi translated">了解窗口算法如何处理<code class="fe nc nd ne nf b">OVER()</code>、<code class="fe nc nd ne nf b">PARTITION BY</code>和<code class="fe nc nd ne nf b">ORDER BY</code>子句是实现SQL窗口函数的关键。<code class="fe nc nd ne nf b">OVER</code>子句为<code class="fe nc nd ne nf b">PARTITION BY</code>和<code class="fe nc nd ne nf b">ORDER BY</code>子句创建执行空间。子句对值进行分组，并对差异进行拆分。<code class="fe nc nd ne nf b">ORDER BY</code>子句的sort属性决定了窗口函数如何应用于分区中的记录。</p><p id="3048" class="pw-post-body-paragraph la lb ir ld b le lf kb lg lh li ke lj lx ll lm ln ly lp lq lr lz lt lu lv lw ik bi translated"><strong class="ld jb"> <em class="lc">灵感:</em> </strong> <em class="lc">不要轻视微小的开端。随着每一课的分享，我记得和我妈妈在一个小房间里，一台唱机和字母表。她用简单的工具教两个小黑人读书、写字和思考。开始可能很卑微，但梦想可以很大。不断分享并激励他人变得比他们想象的更伟大。</em></p></div></div>    
</body>
</html>