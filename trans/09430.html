<html>
<head>
<title>10 Things to Know to Master Comprehensions in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">掌握Python语言理解的10件事</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/10-things-to-know-to-master-comprehensions-in-python-2f089ad9d3e?source=collection_archive---------28-----------------------#2021-09-01">https://towardsdatascience.com/10-things-to-know-to-master-comprehensions-in-python-2f089ad9d3e?source=collection_archive---------28-----------------------#2021-09-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7ed4" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">列表理解，字典理解，等等…</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/b8cb7cc25202c3ababac1d06743a8e4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*bKiAvi1XtoTJ5wCI"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Jay Patel 在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="c627" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们经常使用的一个重要Pythonic特性是理解。最值得注意的是列表理解——一种创建列表的简明方法。但是，这个特性可能会让初学者感到困惑。此外，除了列表理解，还有其他一些相关的基于理解的技术，如字典和集合理解。</p><p id="ce26" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事不宜迟，让我们开始吧——探索10个基本的构建模块来理解Python中的理解。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="b3be" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">1.列表理解的基本形式</h2><p id="fa37" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">让我们从语法开始。列表理解是从现有的<a class="ae ky" rel="noopener" target="_blank" href="/why-iterables-are-powerful-in-python-understand-these-5-distinct-usages-130f364bd0ba"> iterable </a>中创建列表的简洁方法。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="9b95" class="mc md it nb b gy nf ng l nh ni"># The syntax for list comprehension<br/>created_list = [expression for item in iterable]</span></pre><p id="9ddd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它所做的是依次将每一项应用到表达式，表达式将返回一个值，该值将作为一项进入创建的列表。为了帮助你理解它的意思，我们可以使用扩展的形式——一个<code class="fe nj nk nl nb b">for</code>循环来说明列表理解是如何工作的。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="9fe5" class="mc md it nb b gy nf ng l nh ni"># The expanded form using for loop<br/>created_list = []<br/>for item in iterable:<br/>    created_item = certain_expression_to_process_the_item<br/>    created_list.append(created_item)</span></pre><p id="dcf7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe nj nk nl nb b">for</code>循环中的<code class="fe nj nk nl nb b">created_list</code>将等同于从列表理解中创建的那个。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="8263" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">2.从Iterable创建列表</h2><p id="6ea7" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">最常见的用例是从现有的iterable创建一个list对象。需要注意的是，Python有很多种可迭代对象，比如字符串、列表、集合、字典、地图对象等等。任何iterable都可以用于列表理解。没有必要给你看所有的例子。因此，我将简单地向您展示来自集合、字典和元组的列表理解。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">列表理解(集合、字典和元组)</p></figure><p id="bd31" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您知道列表理解的语法，那么一切都应该很简单，除了<code class="fe nj nk nl nb b">dict</code>对象，我使用<code class="fe nj nk nl nb b">items</code>方法来检索键值对。在表达式中，<code class="fe nj nk nl nb b">key</code>和<code class="fe nj nk nl nb b">value</code>都可以用来为列表对象创建项目。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="300f" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">3.保存需要的物品</h2><p id="8b90" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">当我们使用列表理解时，我们并不总是想要将现有列表中的每一项都发送给表达式来创建新项。在这种情况下，我们可以应用条件评估来检查是否应该包含某个项目。一般形式如下:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="40d0" class="mc md it nb b gy nf ng l nh ni"># condition in a list comprehension<br/>items = [expression for item in iterable if condition]</span><span id="1800" class="mc md it nb b gy no ng l nh ni"># Equivalent for loop<br/>items = []<br/>for item in iterable:<br/>    if condition_of_the_item:<br/>        created_item = expression<br/>        items.append(created_item)</span></pre><p id="264c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是一个简单的例子，告诉你我们只保存3或5的倍数的斐波那契数列。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="1b02" class="mc md it nb b gy nf ng l nh ni">&gt;&gt;&gt; fibonacci = [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]<br/>&gt;&gt;&gt; squares_fib = [x*x for x in fibonacci if x%3 == 0 or x%5 == 0]<br/>&gt;&gt;&gt; squares_fib<br/>[0, 9, 25, 441]</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="1152" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">4.条件赋值(三元表达式)</h2><p id="bb18" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">Python中的一个特殊表达式是三元表达式。您可以使用一行代码，而不是编写多行版本的<code class="fe nj nk nl nb b">if…else…</code>语句。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="83f4" class="mc md it nb b gy nf ng l nh ni">a if condition else b</span></pre><p id="0329" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果条件为<code class="fe nj nk nl nb b">True</code>，则该表达式的计算结果为<code class="fe nj nk nl nb b">a</code>，如果条件为<code class="fe nj nk nl nb b">False</code>，则该表达式的计算结果为<code class="fe nj nk nl nb b">b</code>。我们可以在列表理解中应用三元表达式，它会对原列表的条目做条件赋值:<code class="fe nj nk nl nb b">[expr0 if condition else expr1 for item in iterable]</code>。应用此语法，我们有以下示例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">列表理解:三元表达式</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="eeb5" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">5.嵌套列表理解</h2><p id="2618" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">到目前为止，你应该明白，从某种角度来说，列表理解是一种代替<code class="fe nj nk nl nb b">for</code>循环来创建列表对象的方式。我们还知道我们可以嵌套for循环:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="ebf5" class="mc md it nb b gy nf ng l nh ni">for items in items_list:<br/>    for item in items:<br/>        expression</span></pre><p id="9929" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有没有可能把这种嵌套的for循环转化为列表理解？是的，我们可以使用嵌套列表理解。观察下面的例子。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">嵌套列表理解</p></figure><p id="7a4e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">觉得很难理解？你可以简单的从第一个for循环开始读，这是第一级，第二个for循环是内循环。有了这个，一切就好理解了。</p><p id="1ba5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从技术上讲，您可以为嵌套列表理解编写多个级别。然而，为了更好的可读性，我不认为有两个以上的层次是一个好主意。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="44b4" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">6.替换地图()</h2><p id="d949" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">内置的<code class="fe nj nk nl nb b"><a class="ae ky" href="https://docs.python.org/3/library/functions.html#map" rel="noopener ugc nofollow" target="_blank">map</a></code>函数将一个函数应用于iterable的每一项，创建另一个iterable——<code class="fe nj nk nl nb b">map</code>对象。如您所见，这与列表理解非常相似，在列表理解中，表达式应用于iterable的每个项目。因此，有些人使用<code class="fe nj nk nl nb b">map</code>来创建一个列表，如下所示。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="7a57" class="mc md it nb b gy nf ng l nh ni">&gt;&gt;&gt; animals = ['tiger', 'Lion', 'doG', 'CAT']<br/>&gt;&gt;&gt; uppercased_animals = list(map(str.upper, animals))<br/>&gt;&gt;&gt; uppercased_animals<br/>['TIGER', 'LION', 'DOG', 'CAT']</span></pre><p id="bde4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">需要注意的是，我们需要使用一个<code class="fe nj nk nl nb b">list</code>构造函数，其中我们传递了一个不同于<code class="fe nj nk nl nb b">list</code>对象的可迭代对象<code class="fe nj nk nl nb b">map</code>。我们可以使用列表理解来代替使用<code class="fe nj nk nl nb b">map</code>函数。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="1bc0" class="mc md it nb b gy nf ng l nh ni">&gt;&gt;&gt; [x.upper() for x in animals]<br/>['TIGER', 'LION', 'DOG', 'CAT']</span></pre><p id="2a41" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管<code class="fe nj nk nl nb b">map</code>函数有其他用途，但是当目标是创建一个列表对象时，列表理解通常更具可读性。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="1027" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">7.适用时使用列表构造函数</h2><p id="4b14" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">关于列表理解，要避免的一个误用是在适当的时候使用列表构造函数。什么是列表构造函数？所谓的<code class="fe nj nk nl nb b">list</code>功能。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="601a" class="mc md it nb b gy nf ng l nh ni"><em class="np">class </em><strong class="nb iu">list</strong>([<em class="np">iterable</em>])</span><span id="a524" class="mc md it nb b gy no ng l nh ni">Rather than being a function, <a class="ae ky" href="https://docs.python.org/3/library/stdtypes.html#list" rel="noopener ugc nofollow" target="_blank">list</a> is actually a mutable sequence type, as documented in <a class="ae ky" href="https://docs.python.org/3/library/stdtypes.html#typesseq-list" rel="noopener ugc nofollow" target="_blank">Lists</a> and <a class="ae ky" href="https://docs.python.org/3/library/stdtypes.html#typesseq" rel="noopener ugc nofollow" target="_blank">Sequence Types — list, tuple, range</a>.</span></pre><p id="0c5b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如函数签名所示，列表构造函数可以直接接受任何iterable。因此，当您不操作iterable中的项目时，您应该将它直接发送给list构造函数。考虑下面的代码片段来进行对比。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">列表理解与列表构造函数</p></figure><p id="02f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的例子只是提供了一个概念证明。要点是，除非你操作iterable的项(例如，应用一个函数)，否则你应该直接使用list构造函数。以下是另一个例子，供感兴趣的读者参考。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="4ee6" class="mc md it nb b gy nf ng l nh ni">&gt;&gt;&gt; numbers_dict = {1: 'one', 2: 'two'}<br/>&gt;&gt;&gt; <strong class="nb iu"># list comprehension</strong><br/>&gt;&gt;&gt; [(key, value) for key, value in numbers_dict.items()]<br/>[(1, 'one'), (2, 'two')]<br/>&gt;&gt;&gt; <strong class="nb iu"># list constructor</strong><br/>&gt;&gt;&gt; list(numbers_dict.items())<br/>[(1, 'one'), (2, 'two')]</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="f362" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">8.集合理解</h2><p id="426a" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">除了列表理解，我们还可以使用理解从现有的iterable: <code class="fe nj nk nl nb b">{expression for item in iterable}</code>创建一个集合。与列表理解相比，集合理解使用大括号而不是方括号。当我们使用集合理解时，还有两件事需要注意。</p><ul class=""><li id="b070" class="nq nr it lb b lc ld lf lg li ns lm nt lq nu lu nv nw nx ny bi translated">创建的集合中没有重复项。即使将从表达式中创建重复项，最终的set对象中也只会保留一个副本。</li><li id="d356" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu nv nw nx ny bi translated">按照设计，set对象只能存储可哈希的数据，比如字符串和整数，而不能存储列表和字典。</li></ul><p id="57b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面的代码向您展示了集合理解的一个用例。顺便提一下，集合理解也支持上面讨论的许多其他操作，比如条件赋值。感兴趣的读者可以探索一下这些特性。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="cc99" class="mc md it nb b gy nf ng l nh ni">&gt;&gt;&gt; numbers = [-3, -2, -1, 1, 2, 3, 4, 5]<br/>&gt;&gt;&gt; squares_set = {x*x for x in numbers}<br/>&gt;&gt;&gt; squares_set<br/>{1, 4, 9, 16, 25}</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="5af8" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">9.词典理解</h2><p id="3ea7" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">你可能已经猜到了，除了list和set comprehension，你不会惊讶地知道我们可以使用dict comprehension来创建一个<code class="fe nj nk nl nb b">dict</code>对象:<code class="fe nj nk nl nb b">{key_expr: value_expr for item in iterable}</code>。与其他两种理解不同，字典理解需要两个表达式，一个表示键，另一个表示值。需要注意的一点是字典键必须是可哈希的，所以<code class="fe nj nk nl nb b">key_expr</code>应该产生一个可哈希的对象。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="56eb" class="mc md it nb b gy nf ng l nh ni">&gt;&gt;&gt; numbers = [-3, -2, -1, 1, 2, 3, 4, 5]<br/>&gt;&gt;&gt; squares_dict = {x: x*x for x in numbers}<br/>&gt;&gt;&gt; squares_dict<br/>{-3: 9, -2: 4, -1: 1, 1: 1, 2: 4, 3: 9, 4: 16, 5: 25}</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="2905" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">10.生成器表达式</h2><p id="51fe" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">通常，最常用的内置数据容器是元组、列表、字典和集合。我们对后三种有所理解。有没有元组理解？可惜没有这回事。就潜在的语法而言，您可能会想到一个可能的实现:<code class="fe nj nk nl nb b">(expression for item in iterable)</code>。</p><p id="a66e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意圆括号的用法吗？就像元组一样。有趣的是，这种用法确实存在，但它不是创建一个元组对象。相反，它创建了一个<a class="ae ky" href="https://medium.com/swlh/generators-in-python-5-things-to-know-c76a1f60427a" rel="noopener">生成器</a>，这是一种特殊的迭代器，具有更好的内存效率。因为不像其他迭代器那样在内存中加载所有的项，生成器在需要的时候呈现一个项，这避免了加载所有项的开销。因此，当您处理大量数据时，可以考虑使用生成器而不是其他迭代器，比如列表或元组。下面的代码向您展示了首选生成器的用例。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="0c32" class="mc md it nb b gy nf ng l nh ni">&gt;&gt;&gt; numbers = list(range(10_000_000))<br/>&gt;&gt;&gt; <strong class="nb iu"># Creating a list of squares using list comprehension</strong><br/>&gt;&gt;&gt; squares = [x*x for x in numbers]<br/>&gt;&gt;&gt; squares.__sizeof__()<br/>89095144<br/>&gt;&gt;&gt; <strong class="nb iu"># Using generator instead</strong><br/>&gt;&gt;&gt; squares_gen = (x*x for x in numbers)<br/>&gt;&gt;&gt; squares_gen.__sizeof__()<br/>96<br/>&gt;&gt;&gt; # Having the same result<br/>&gt;&gt;&gt; sum(squares) == sum(squares_gen)<br/>True</span></pre><p id="620c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如您所看到的，中间步骤(list vs. generator)向您展示了一个从生成器表达式创建的生成器，与list对象相比，它的大小微不足道，突出了生成器的性能。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="8cf5" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">结论</h2><p id="aced" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">本文回顾了您需要了解的Python理解技巧的所有基本内容。这些技术是创建所需数据结构的简洁方法，只要适用，就应该使用它们。</p><p id="1221" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读这篇文章。通过<a class="ae ky" href="https://medium.com/subscribe/@yong.cui01" rel="noopener">注册我的简讯</a>保持联系。还不是中等会员？<a class="ae ky" href="https://medium.com/@yong.cui01/membership" rel="noopener">用我的会员链接</a>支持我的写作。</p></div></div>    
</body>
</html>