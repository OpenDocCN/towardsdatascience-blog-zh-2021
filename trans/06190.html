<html>
<head>
<title>Python Factories for Scalable, Reusable, and Elegant Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python工厂提供可伸缩、可重用和优雅的代码</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/python-factories-for-scalable-reusable-and-elegant-code-1358ea06936d?source=collection_archive---------4-----------------------#2021-06-03">https://towardsdatascience.com/python-factories-for-scalable-reusable-and-elegant-code-1358ea06936d?source=collection_archive---------4-----------------------#2021-06-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0e37" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">通过将行为(在工厂超类中定义)与对象创建(在子类中)分离，创建灵活、可扩展的代码</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/4f782d3b067c7da7097f57fef2dbda91.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vlrXhKoFqxQDNmsZ7rwxfQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">缺席84 /AdobeStock</p></figure><p id="fd1e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi lu translated">在现实生活中的工厂里，相同或相似物品的生产不是单独完成的，而是在装配线上进行的。类似地，工厂设计模式允许您创建不依赖于特定产品的软件，而是可以在许多类似的应用程序中重用。工厂模式是著名的Gof(四人帮)设计模式之一[1]。这是一种创造性的设计模式，它将对象创建封装在一个名为工厂的类中。这种模式通过从系统中分离出如何、何时以及由谁创建对象来提高系统的灵活性[6]。</p><p id="c767" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当您需要创建新类型的对象时，工厂特别有用。如果对象创建分散在整个代码中，那么您将不得不花费时间在代码中找到对象类型起作用的确切位置[2]。用软件工程的术语来说，这意味着你有大量的<em class="md">技术债务</em>要处理。在机器学习中尤其如此，如[4]中所解释的。机器学习会因数据依赖性、数据漂移和隐藏的反馈循环而导致巨大的维护成本。最近，通过创建<em class="md">功能商店</em>【3】【5】，工厂找到了进入机器学习的途径。特性存储可以是在线的，也可以是离线的，它们的主要目的是在数据转换应用于不同的特性时对其进行抽象，并以这种方式实现更快的开发、更好的协作、高效的模型部署和扩展[7]。</p><h2 id="c69e" class="me mf it bd mg mh mi dn mj mk ml dp mm lh mn mo mp ll mq mr ms lp mt mu mv mw bi translated">1.0 Python中工厂实现的示例</h2><p id="16d1" class="pw-post-body-paragraph ky kz it la b lb mx ju ld le my jx lg lh mz lj lk ll na ln lo lp nb lr ls lt im bi lu translated">现在让我们看一个如何在Python中使用工厂的具体例子。让我们假设，我们想为一个刚从大学毕业、在一家银行找到第一份工作——定量金融分析师——的儿子打造一个新衣柜。鉴于他精通Python，他决定实现一个虚拟衣柜索引。我们将帮助他为每套服装分配一个“正式等级”,因为他完全有能力穿着t恤和破洞牛仔裤出现在重要会议上。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl nc"><img src="../Images/ae58429e3b9213209d5797e4c92f77e5.png" data-original-src="https://miro.medium.com/v2/format:webp/1*IRi9Ouv_ApZ-KUDsoBgcEQ.jpeg"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">斯维塔/AdobeStock</p></figure><p id="2724" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如下图所示，虚拟衣柜索引从创建两个抽象的<em class="md">工厂</em>开始，一个是鞋类(<em class="md">鞋类</em>，另一个是服装(<em class="md">男装</em>)。这些是抽象类，它们只用于模板的目的。与Java不同，Python没有固有的抽象类类型。相反，它提供了一个名为<em class="md"> abc </em>的模块，该模块提供了抽象类基础设施。<em class="md">男装</em>类的<em class="md"> colort </em>和<em class="md"> colorb </em>变量代表上衣(衬衫、毛衣等)的颜色。)和下(裤)分别。注意我们给鞋子和顶部和底部的颜色分配了一个默认值<em class="md">“棕色”</em>(总是一个安全的颜色)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="72a6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在让我们通过定义具体的类<em class="md"> Boots </em>和<em class="md"> Loafers </em>来实现两种类型的鞋。我们从<em class="md">鞋类</em>类继承，然后覆盖它的<em class="md"> shoespecs() </em>方法来实现每个具体类的特定动作。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="bf7e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">类似地，我们创建了两个具体的类，分别继承自<em class="md">men swath</em>、<em class="md">sweater andurdoropants、</em>和<em class="md">buttondownshirtandresspants</em>。每个具体的类都覆盖了抽象类方法<em class="md"> clothespecs() </em>，以便为每个样式指定细节。请注意，<em class="md"> clothespecs() </em>方法接受一个<em class="md">鞋类</em>对象，以便将鞋类的颜色与裤子的颜色相匹配。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="e5e4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">抽象类<em class="md">装</em>下面是一个工厂，提供衣服和鞋子的选择方法，<em class="md">choose _ clothis()</em>和<em class="md"> choose_shoes() </em>分别是<em class="md">、</em>，并且有一个实例属性，<em class="md"> formality </em>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="00c0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面的具体类<em class="md">light color _ ColdAndCasualDay</em>继承了抽象类<em class="md"> Outfit </em>并有以下方法:</p><p id="b993" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">(A)指定<em class="md">形式</em>和<em class="md">名称</em>变量的构造函数。<em class="md">形式</em>变量继承自<em class="md">装备</em>。</p><p id="b3bf" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">(b)类<em class="md">装备</em>的<em class="md">choose _ ways()</em>方法的覆盖形式，返回一个<em class="md">SweaterAndCorduroyPants</em>对象。</p><p id="bdac" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">(c)一个被覆盖的<em class="md"> choose_shoes() </em>方法的形式，该方法返回一个<em class="md"> Boots </em>对象。</p><p id="bf21" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">正如我们所看到的，当我们在类的层次结构中向上移动时，事情变得更加具体，而较低级别的类，如<em class="md">鞋类</em>、<em class="md">男装</em>和<em class="md">服装</em>、<em class="md">是</em> <strong class="la iu"> <em class="md">不可知的子类，它们的对象是在哪里创建的，以及它们是如何聚集的</em> </strong> <em class="md">。</em>为下面的<em class="md">dark color</em>_<em class="md">WarmSemiFormalDay</em>类定义了类似的结构，该类定义了为衣服返回一个<em class="md">buttondownshirtandresspants</em>对象，为鞋类返回一个<em class="md">Loafers</em>对象<em class="md"> </em>的方法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="2ade" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对比抽象工厂，到目前为止我们看到，<em class="md">dark color _ WarmSemiFormalDay</em>和<em class="md">light color _ ColdAndCasualDay</em>是<em class="md">具体</em> <em class="md">工厂</em>。它们如何作为对象的工厂在下面的类<em class="md"> Look </em>的定义中说明。<strong class="la iu"> <em class="md">类Look是负责对象创建的编排类。</em> </strong>下面我们可以看到，它的构造函数以一个<em class="md">工厂</em>作为实参。在我们有限的衣柜里，工厂可以是一个<em class="md">浅色_冷色和浅色</em>或<em class="md">深色</em> _ <em class="md">暖色半正式</em>的物件。当我们创建一个类<em class="md"> Look </em>的对象时，工厂的<em class="md">choose _ ways()</em>和choose _ shoes()被调用，它们分别给实例变量<em class="md"> clo </em>和<em class="md"> sho </em>赋值。然后这些变量被用在<strong class="la iu"> <em class="md"> all-important dress()方法中，该方法将所有东西放在一起，创建完整的外观</em> </strong>！由于策略性地放置了对象创建封装和多态，这是可伸缩的、可重用的代码。 </p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="4b78" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在下面的代码片段中，我们可以看到我们的对象创建和对<em class="md"> dress() </em>方法的调用。注意，我们检查两个对象是否相等，或者对象<em class="md"> g2 </em>是否大于对象<em class="md"> g1 </em>。在上面的<em class="md"> Look </em>类的定义中，我们将<em class="md"> __eq__ </em>运算符的输出定义为两个对象的<em class="md">手续</em>的相等比较的输出。正如我们已经讨论过的，我们崭露头角的财务分析师对正式风格一无所知，所以我们需要以一种特定的方式告诉他(<em class="md">正式</em>评级)，这种方式在正式程度上被认为是等同的。所以，3是最高<em class="md">正式</em>(西装)，0是无<em class="md">正式</em> (T恤和球鞋)。下面的<em class="md">等于</em>运算返回<em class="md">假</em>，更大的<em class="md">运算返回<em class="md">真</em>，因为<em class="md"> g2 </em>比<em class="md"> g1 </em> (1)具有更高的<em class="md">形式</em>等级(2)。</em></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="f2c1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后，在下面的代码片段中，我们导入当前的虚拟衣柜，它作为一个字典存在于一个文本文件中，并将我们创建的两个新外观附加到它，以<em class="md">服装</em>对象的名称作为键，以<em class="md">正式度</em>作为值。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="36a8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你可以看到完整的代码，作为一个木星笔记本在我的github目录:<a class="ae nf" href="https://github.com/theomitsa/Python-factories" rel="noopener ugc nofollow" target="_blank">https://github.com/theomitsa/Python-factories</a></p><p id="bf7f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">感谢您的阅读！</p><h1 id="18d3" class="ng mf it bd mg nh ni nj mj nk nl nm mm jz nn ka mp kc no kd ms kf np kg mv nq bi translated">参考</h1><ol class=""><li id="34bf" class="nr ns it la b lb mx le my lh nt ll nu lp nv lt nw nx ny nz bi translated">Gamma，e .，Helm，r .，Johnson，和r .，J. Vlissides，<strong class="la iu">设计模式:可重用面向对象软件的元素</strong>，Addison-Wesley Professional，1994年10月。</li><li id="6260" class="nr ns it la b lb oa le ob lh oc ll od lp oe lt nw nx ny nz bi translated">埃凯尔，b .等人，<strong class="la iu"> Python 3模式、配方和习惯用法</strong>，阅读文档<a class="ae nf" href="https://freecomputerbooks.com/Python-3-Patterns-Recipes-and-Idioms.html" rel="noopener ugc nofollow" target="_blank">(电子书)</a></li><li id="78e2" class="nr ns it la b lb oa le ob lh oc ll od lp oe lt nw nx ny nz bi translated">飞，a .，<strong class="la iu"> </strong> <a class="ae nf" rel="noopener" target="_blank" href="/feature-stores-components-of-a-data-science-factory-f0f1f73d39b8"> <strong class="la iu">特征存储:一个数据科学工厂的组件，</strong> </a>媒介:走向数据科学，2019年9月。</li><li id="3f9b" class="nr ns it la b lb oa le ob lh oc ll od lp oe lt nw nx ny nz bi translated">Sculley，d .等人，<a class="ae nf" href="https://research.google/pubs/pub43146/" rel="noopener ugc nofollow" target="_blank"> <strong class="la iu">机器学习:技术债务的高息信用卡</strong> </a>，机器学习的软件工程，NIPS会议研讨会，2014年。</li><li id="884f" class="nr ns it la b lb oa le ob lh oc ll od lp oe lt nw nx ny nz bi translated">Taifi，<a class="ae nf" href="https://farmi.medium.com/ml-feature-stores-a-casual-tour-fc45a25b446a" rel="noopener"> <strong class="la iu"> ML特色店:一次休闲之旅1/3 </strong>，</a>中型，2020年4月。</li><li id="bdf2" class="nr ns it la b lb oa le ob lh oc ll od lp oe lt nw nx ny nz bi translated">Bishop，<strong class="la iu"> C# 3.0设计模式</strong>，奥赖利媒体，第336页，2007年。</li><li id="41b8" class="nr ns it la b lb oa le ob lh oc ll od lp oe lt nw nx ny nz bi translated">Hirschtein，a .，<a class="ae nf" rel="noopener" target="_blank" href="/what-are-feature-stores-and-why-are-they-critical-for-scaling-data-science-3f9156f7ab4"> <strong class="la iu">什么是特征库，为什么它们对扩展数据科学至关重要？</strong> </a>，中:走向数据科学，2020年4月。</li></ol></div></div>    
</body>
</html>