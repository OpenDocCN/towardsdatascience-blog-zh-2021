<html>
<head>
<title>Getting Your Software Architecture Right</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">获得正确的软件架构</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/difference-of-system-software-architecture-f800eab80f09?source=collection_archive---------22-----------------------#2021-04-12">https://towardsdatascience.com/difference-of-system-software-architecture-f800eab80f09?source=collection_archive---------22-----------------------#2021-04-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f670" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">复合组件架构:第一集——软件架构——幽灵的威胁</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f769106413fdc3fe4381b0fc3cf8926e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*caxf5iPsjKjmWcY1"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">约瑟夫·巴里恩托斯在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="f7fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以这个问题总是会出现，我会在本文最后给出我的答案。建议你先自己回答问题，再继续看文章。你会发现很难用一种容易理解的方式来定义这个术语。</p><p id="ab3e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">应用程序的架构是整个软件系统的结构。这将与一组规则一起构成，软件系统必须根据这些规则来实现。这样一套规则保证了与质量方面的一致性将推动项目走向长期的成功。在我看来，该架构包括以下元素:</p><ul class=""><li id="586d" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">模块化</li><li id="997b" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">模式的使用</li><li id="fc75" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">规则和准则</li><li id="c5cc" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">证明文件</li></ul><p id="ebd6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从内容上来说，这个答案是正确的。然而，它不能给出一个直截了当的答案。<em class="mj">软件开发中的架构</em>要么意味着一切，要么什么都不是。软件项目的结构发生在不同的层次上。首先，我们必须解释有哪些层次，然后是架构的类型。一旦介绍完毕，我们就可以查看各自的任务、目标和角色并给出答案。</p><h1 id="9070" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated"><strong class="ak">建筑等级</strong></h1><p id="b7b5" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">模块化是建筑最重要的目的之一。它一步一步地将软件系统划分为服务、层、组件、类、方法等等。</p><p id="16aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如图1所示，这创建了要开发的软件的层次树表示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/dbfb6e7bc368194ac76cc63286e19274.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/1*8L0HVaUD4zSVGUVD9U-uTA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图1一个人管理应用程序的模块化示例</p></figure><p id="16ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，树结构的每一层都可以分配给一个实现元素。例如，在编程语言中，子系统<em class="mj"> PersonManager </em>和<em class="mj"> CategoryManager </em>(图1)是类。</p><p id="fb08" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，每个级别都被赋予其实现元素的名称，结果就是所谓的级别模型，如图2所示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/1a7b7a3a9b307d1dcf77415a013239da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/1*f7Hl-s2bqBxQCeICMPMh5g.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图2:层模型(从图1的模块化结构转移而来)</p></figure><h1 id="83a6" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated"><strong class="ak">术语定义</strong></h1><p id="e47e" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">任何在书籍、文章或其他媒体中研究过建筑主题的人都知道可以使用各种类型的术语。这些术语包括系统架构、软件架构、服务架构、微观和宏观架构等等。</p><p id="e7b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我借此机会解释一下我在这个问题上的术语。我使用的术语是<em class="mj">系统架构</em>、<em class="mj">软件架构、</em>和<em class="mj">实现(设计&amp;编码)</em>。图2显示了这些术语位于我的哪个区域。</p><h2 id="a5a2" class="ni ml it bd mm nj nk dn mq nl nm dp mu li nn no mw lm np nq my lq nr ns na nt bi translated"><strong class="ak">系统架构</strong></h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nu"><img src="../Images/71b8e141ebcdbe1e00b61cf24a595b57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*FRHXW7YrSg80GYBM"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Alexandre Debiève 在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="7b0b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="mj">系统架构</em>定义了系统由哪些子系统组成；这些通常涉及服务(web)或外部系统，如打印机、数据库等。图1中的<em class="mj"> PersonManagerApp </em>由两个服务组成，一个web API和一个前端。</p><p id="f1eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在图2中,“定义范围”没有延伸到服务级别的中间:一个<em class="mj">系统架构</em>仅仅识别系统的服务，它们通信的方式，以及在那个级别使用的概念。然而，没有关于服务实现的规范。</p><p id="04cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为我们在这里只创建了应用程序的粗略结构，所以其他来源称之为“粗略架构”或“宏架构”。</p><p id="b570" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">没有建筑师为每个项目重新发明轮子，但是他们建立在已经在许多其他项目中被证明有价值的被证明的设计之上。我相信你对这些所谓的“模式”很熟悉。</p><p id="a4c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">系统架构主要负责可伸缩性、故障安全、互操作性等方面。因此，从长远来看，如果一个系统架构是未计划的和未实现的，或者是计划和实现不当的，那么在这些方面就存在问题的风险。</p><h2 id="886c" class="ni ml it bd mm nj nk dn mq nl nm dp mu li nn no mw lm np nq my lq nr ns na nt bi translated"><strong class="ak">软件架构</strong></h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nv"><img src="../Images/ade6c7ba24df453bb51fe7a36097f327.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Jb9MHayjc0cb8Yzd"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@heylagostechie?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">海拉戈斯蒂奇</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="d05f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我在图2中展示了软件架构的职责，它决定了软件系统的内部结构，就像图1中的单个服务一样。这里，指定了服务中的层和组件的结构，但是没有精确地描述组件的内部生命。</p><p id="e4af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就像<em class="mj">系统架构</em>一样，仍然有模式留给我们现成的解决方案:软件架构模式。例如:</p><ul class=""><li id="a099" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">庞然大物</li><li id="2745" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">插件</li><li id="2b8d" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">管道和过滤器</li><li id="9448" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">多层</li></ul><p id="218a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">类似于<em class="mj">系统架构</em> , <em class="mj">软件架构</em>也负责具体的定性方面，如可重用性、可互换性和可分析性。</p><p id="64eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个层次上，定性的方面包括可重用性、可互换性、可分析性、可测试性和可修改性。前两点用引号括起来是因为可重用性和可互换性通常发生在组件级别。因此，一个DLL文件<em class="mj">，</em>比一个类有更大的机会被重用。</p><h2 id="90f8" class="ni ml it bd mm nj nk dn mq nl nm dp mu li nn no mw lm np nq my lq nr ns na nt bi translated">实施(设计和编码)</h2><p id="6614" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">编程是图2中最后一个可见的阶段。在这个阶段，从语句、表达式和控制结构实现应用程序的逻辑。再读一遍前面的句子:这是逻辑编码的地方。</p><p id="6d1f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">是什么让它如此重要？想象一下使用Main()方法实现一个大型应用程序，比如Visual Studio。从纯技术角度来看，这不成问题；从实际的角度来看，很明显，这是不可能的。</p><p id="8908" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但它确实指出了一些非常重要的事情。如图3所示，直到实现级别的所有级别都是可选的，并且仅用于构建应用程序和使用定性方面。我们也可以在单元测试中看到这一点:我们编写这些来检查源代码级别——所有其他级别都不相关，因为它们对逻辑来说并不重要。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/481c76e93d9fe513c9a55a2bf80d3a7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/1*IV3TqZvQNm7C7Ekntv8W8g.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图3:应用程序的结构和逻辑</p></figure><p id="a148" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与前面的类型一样，实现模式是解决重复出现的问题的可用模式。例如:</p><ul class=""><li id="7c72" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">环</li><li id="d7de" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">分支</li><li id="5077" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">分配</li></ul><p id="551c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">鉴于这不再发生在“结构化”层面，所讨论的定性方面也减少了。例如，这将包括可分析性和可修改性。</p><h1 id="6ea1" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">那么什么是建筑呢？</h1><p id="dba7" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">也许我们在研究完这篇文章后，已经接近一个更清晰的答案了。在软件开发中，我编写了不同层的术语架构。因此:</p><p id="df4b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="mj">架构概述了软件系统的层次结构，以实现定性方面，从而实现项目的长期目标。</em></p><p id="c697" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，架构包括与结构相关的所有级别:</p><ul class=""><li id="8f4d" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">系统</li><li id="6bfd" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">服务</li><li id="591a" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">层</li><li id="378c" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">成分</li><li id="cad3" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">班级</li><li id="036c" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">方法</li></ul><p id="b6a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我根据系统架构类型、软件架构和设计来划分这些层。这涉及到系统和软件架构师和开发人员的角色。</p><h1 id="8853" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">结论</h1><p id="28cd" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">即使系统和软件架构师代表他们工作:架构是团队的事情。只有系统和软件架构师以及训练有素的开发人员才能实现一个结构合理的软件提案。</p><p id="2b8f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本期文章的目的是介绍“复合组件架构”，这是最新的软件架构版本。希望这第一集可以展示我们可以用它解决什么问题。</p></div><div class="ab cl nw nx hx ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="im in io ip iq"><h2 id="54f5" class="ni ml it bd mm nj nk dn mq nl nm dp mu li nn no mw lm np nq my lq nr ns na nt bi translated">为你选择阅读！</h2><div class="od oe gp gr of og"><a href="https://medium.com/nerd-for-tech/understand-typescript-after-a-3-minute-guide-06-ff2634dba57a" rel="noopener follow" target="_blank"><div class="oh ab fo"><div class="oi ab oj cl cj ok"><h2 class="bd iu gy z fp ol fr fs om fu fw is bi translated">3分钟指南后理解打字稿#06</h2><div class="on l"><h3 class="bd b gy z fp ol fr fs om fu fw dk translated">Typescript:提前验证您的JavaScript代码！</h3></div><div class="oo l"><p class="bd b dl z fp ol fr fs om fu fw dk translated">medium.com</p></div></div><div class="op l"><div class="oq l or os ot op ou ks og"/></div></div></a></div><div class="od oe gp gr of og"><a href="https://medium.com/next-level-source-code/forever-remember-object-oriented-programming-fae13462bb9f" rel="noopener follow" target="_blank"><div class="oh ab fo"><div class="oi ab oj cl cj ok"><h2 class="bd iu gy z fp ol fr fs om fu fw is bi translated">永远记住面向对象编程</h2><div class="on l"><h3 class="bd b gy z fp ol fr fs om fu fw dk translated">用一座你不会忘记的城堡解释面向对象编程。</h3></div><div class="oo l"><p class="bd b dl z fp ol fr fs om fu fw dk translated">medium.com</p></div></div><div class="op l"><div class="ov l or os ot op ou ks og"/></div></div></a></div><div class="od oe gp gr of og"><a href="https://medium.com/codex/5-methods-that-drastically-shorten-drastically-your-code-in-c-8-0-e7bc1ca1b480" rel="noopener follow" target="_blank"><div class="oh ab fo"><div class="oi ab oj cl cj ok"><h2 class="bd iu gy z fp ol fr fs om fu fw is bi translated">在C# 8.0中，5种方法可以大大缩短代码</h2><div class="on l"><h3 class="bd b gy z fp ol fr fs om fu fw dk translated">用这5个技巧节省时间和精力</h3></div><div class="oo l"><p class="bd b dl z fp ol fr fs om fu fw dk translated">medium.com</p></div></div><div class="op l"><div class="ow l or os ot op ou ks og"/></div></div></a></div><h1 id="16cd" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">参考</h1><p id="6c86" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">[1] <a class="ae ky" href="https://en.wikipedia.org/wiki/Software_architecture" rel="noopener ugc nofollow" target="_blank">软件架构</a><br/>【2】<a class="ae ky" href="https://martinfowler.com/architecture/" rel="noopener ugc nofollow" target="_blank">软件架构指南—马丁·福勒</a><br/>【3】<a class="ae ky" href="https://amzn.to/3dVWbYD" rel="noopener ugc nofollow" target="_blank">软件架构基础—马克·理查兹&amp;尼尔·福特</a></p></div></div>    
</body>
</html>