<html>
<head>
<title>Nearest neighbour with SQL and Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用SQL和Python的最近邻</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/nearest-neighbour-with-sql-and-python-78a1937d15b8?source=collection_archive---------27-----------------------#2021-04-02">https://towardsdatascience.com/nearest-neighbour-with-sql-and-python-78a1937d15b8?source=collection_archive---------27-----------------------#2021-04-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="0fe4" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">一个简单的算法来解决最近邻问题与任何语言和SQL和Python中的例子</h2></div><p id="7a45" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最近邻问题是空间分析中经常出现的问题之一。它是如此普遍，知道如何简单有效地解决它是根本。本文介绍了SQL和Python中的问题和解决方案。</p><h1 id="287a" class="lb lc iq bd ld le lf lg lh li lj lk ll jw lm jx ln jz lo ka lp kc lq kd lr ls bi translated">问题是</h1><p id="1995" class="pw-post-body-paragraph kf kg iq kh b ki lt jr kk kl lu ju kn ko lv kq kr ks lw ku kv kw lx ky kz la ij bi translated">这个问题很容易定义:给定空间中的两组物体，集合A和集合B，对于A(原点集合)中的每一个物体，在B(目的集合)中寻找最近的物体。</p><p id="59ed" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">假设A组代表图书馆，B组代表休闲中心，你想知道哪个休闲中心离每个图书馆最近。</p><h1 id="d253" class="lb lc iq bd ld le lf lg lh li lj lk ll jw lm jx ln jz lo ka lp kc lq kd lr ls bi translated">该算法</h1><p id="8fe7" class="pw-post-body-paragraph kf kg iq kh b ki lt jr kk kl lu ju kn ko lv kq kr ks lw ku kv kw lx ky kz la ij bi translated">这个问题的解决方案如下(图1):</p><ul class=""><li id="7228" class="ly lz iq kh b ki kj kl km ko ma ks mb kw mc la md me mf mg bi translated">组合集合A和B中的对象</li><li id="2c06" class="ly lz iq kh b ki mh kl mi ko mj ks mk kw ml la md me mf mg bi translated">测量每个组合的距离</li><li id="2ca4" class="ly lz iq kh b ki mh kl mi ko mj ks mk kw ml la md me mf mg bi translated">首先按(原点)中的对象，然后按距离对组合进行排序。</li><li id="f36f" class="ly lz iq kh b ki mh kl mi ko mj ks mk kw ml la md me mf mg bi translated">对于中的每个对象，选择应该是最短距离的第一个组合</li></ul><figure class="mn mo mp mq gt mr gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi mm"><img src="../Images/044b9dcb87cfce7442135028d8124daf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4JCRmqLv3kVb5wEgqNDizw.png"/></div></div><p class="my mz gj gh gi na nb bd b be z dk translated">图1:最近邻算法。图片作者。</p></figure><p id="1d0f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请注意，一个集合必须是起点，另一个集合必须是终点。这是因为原始集合中不应该有重复值，但是目标集合可以有重复值。B中的相同对象可能是a中不同对象的最近对象。以图书馆和休闲中心为例，两个图书馆可以拥有相同的休闲中心作为它们的最近对象(图2)。</p><figure class="mn mo mp mq gt mr gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi nc"><img src="../Images/5f3e04892b28d5e7c3931f3e3976012e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nFFS6dJpWD7RkDPGbau2Uw.png"/></div></div><p class="my mz gj gh gi na nb bd b be z dk translated">图2:两个起点共享一个目的地作为它们的最近点。图片作者。</p></figure><p id="1cbd" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该算法可以被修改以产生唯一的关系。换句话说，如果一个目的地是一个起点，那么算法可以为你提供下一个最近的起点。</p><h1 id="9a23" class="lb lc iq bd ld le lf lg lh li lj lk ll jw lm jx ln jz lo ka lp kc lq kd lr ls bi translated">数据</h1><p id="563e" class="pw-post-body-paragraph kf kg iq kh b ki lt jr kk kl lu ju kn ko lv kq kr ks lw ku kv kw lx ky kz la ij bi translated">我们在这篇文章中使用了两个数据集:一个是特拉福德的图书馆，一个是特拉福德数据实验室(2021)的休闲中心。您可以通过以下方式下载它们:</p><pre class="mn mo mp mq gt nd ne nf ng aw nh bi"><span id="0db1" class="ni lc iq ne b gy nj nk l nl nm">wget h<a class="ae nn" href="https://www.trafforddatalab.io/council_open_data/assets/leisure_centres/leisure_centres.geojson" rel="noopener ugc nofollow" target="_blank">ttps://www.trafforddatalab.io/council_open_data/assets/leisure_centres/leisure_centres.geojson</a> ; wget <a class="ae nn" href="https://www.trafforddatalab.io/council_open_data/assets/libraries/libraries.geojson" rel="noopener ugc nofollow" target="_blank">https://www.trafforddatalab.io/council_open_data/assets/libraries/libraries.geojson</a></span></pre><h1 id="6ab2" class="lb lc iq bd ld le lf lg lh li lj lk ll jw lm jx ln jz lo ka lp kc lq kd lr ls bi translated">SQL示例1:仅最近邻</h1><p id="9945" class="pw-post-body-paragraph kf kg iq kh b ki lt jr kk kl lu ju kn ko lv kq kr ks lw ku kv kw lx ky kz la ij bi translated">本文中的所有SQL示例都适用于postgreSQL (Postgresql.org，2019)数据库和PostGIS (PostGIS Developers，2020)。这些表名为“休闲中心”和“图书馆”，都存储在名为“trafford”的模式中，都有一个“id”列、“name”列和“geom”列。</p><p id="6cab" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">假设我们想知道每个图书馆最近的休闲中心，算法实现如下:</p><figure class="mn mo mp mq gt mr"><div class="bz fp l di"><div class="no np l"/></div><p class="my mz gj gh gi na nb bd b be z dk translated">代码片段SQL中的最近邻查询</p></figure><p id="962a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们分析一下查询的不同部分:</p><ul class=""><li id="f3f9" class="ly lz iq kh b ki kj kl km ko ma ks mb kw mc la md me mf mg bi translated">我们使用“选择”来选择我们想要的列</li><li id="ab05" class="ly lz iq kh b ki mh kl mi ko mj ks mk kw ml la md me mf mg bi translated">使用“DISTINCT ON”，我们指定不希望在表“A”的“id”列中出现重复的元素；它通过选择定义为“ORDER BY”的第一行来工作</li><li id="4116" class="ly lz iq kh b ki mh kl mi ko mj ks mk kw ml la md me mf mg bi translated">我们指定数据将来自两个表，即模式“trafford”中的“libraries”和“leisure_centres ”,并对这两个表应用别名，以避免在每一列前面重复表名</li><li id="9934" class="ly lz iq kh b ki mh kl mi ko mj ks mk kw ml la md me mf mg bi translated">没有连接表的“WHERE”条件会迫使SQL规划器组合两个表的元素</li><li id="fa1c" class="ly lz iq kh b ki mh kl mi ko mj ks mk kw ml la md me mf mg bi translated">然后，我们使用“ORDER BY”对值进行排序，这允许“DISTINCT ON”过滤掉最近的邻居</li></ul><p id="be72" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">表1和图3显示了图书馆和最近的休闲中心之间的一些联系。</p><figure class="mn mo mp mq gt mr gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi nc"><img src="../Images/fede808875a296367ec982332008de22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4j-NhaJnitNYXjd-GRshHg.png"/></div></div><p class="my mz gj gh gi na nb bd b be z dk translated">表1:使用SQL的离图书馆最近的休闲中心(未显示全部)</p></figure><figure class="mn mo mp mq gt mr gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi nq"><img src="../Images/23eaa76f2744a2648f0f96ef7088a650.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*COTCXDxutN9f9BBAcD5Dog.png"/></div></div><p class="my mz gj gh gi na nb bd b be z dk translated">图3:离图书馆最近的休闲中心(未全部显示)。图片作者。</p></figure><p id="8979" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">可以通过在QGis中运行前面查询的一个小修改来生成链接:</p><figure class="mn mo mp mq gt mr"><div class="bz fp l di"><div class="no np l"/></div><p class="my mz gj gh gi na nb bd b be z dk translated">代码片段2:以链接作为几何图形的SQL中的最近邻查询</p></figure><p id="4614" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个例子平均运行67毫秒，我将把它与Python版本进行比较。</p><h1 id="ece0" class="lb lc iq bd ld le lf lg lh li lj lk ll jw lm jx ln jz lo ka lp kc lq kd lr ls bi translated">SQL示例2: K个最近邻居</h1><p id="d831" class="pw-post-body-paragraph kf kg iq kh b ki lt jr kk kl lu ju kn ko lv kq kr ks lw ku kv kw lx ky kz la ij bi translated">在某些情况下，我们不仅对最近的邻居感兴趣，而且对一组最近的邻居感兴趣。我们可以通过简单修改代码来实现这一点。例如，如果我们对每个图书馆最近的两个休闲中心感兴趣，您可以使用:</p><figure class="mn mo mp mq gt mr"><div class="bz fp l di"><div class="no np l"/></div><p class="my mz gj gh gi na nb bd b be z dk translated">代码片段3:用SQL查询K个最近邻居</p></figure><p id="ae27" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">表2显示了输出。</p><figure class="mn mo mp mq gt mr gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi nc"><img src="../Images/a0a901e8e3170865a52894b239e91bc2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YF1y-12bO9hPl8XY3Gy_BQ.png"/></div></div><p class="my mz gj gh gi na nb bd b be z dk translated">表2:使用SQL查询离图书馆最近的两个休闲中心(未全部显示)</p></figure><p id="ba2b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该示例平均运行时间为108毫秒。</p><h1 id="7465" class="lb lc iq bd ld le lf lg lh li lj lk ll jw lm jx ln jz lo ka lp kc lq kd lr ls bi translated">Python示例1:仅使用Geopandas的最近邻</h1><p id="35fe" class="pw-post-body-paragraph kf kg iq kh b ki lt jr kk kl lu ju kn ko lv kq kr ks lw ku kv kw lx ky kz la ij bi translated">目标是使用Geopandas复制SQL示例1的输出(<em class="nr"> Jordahl </em> et al，2020)。算法是相同的，我们结合所有，计算距离，排序的价值，并选择最近的。</p><p id="ca4b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先让我们导入库并读取数据:</p><figure class="mn mo mp mq gt mr"><div class="bz fp l di"><div class="no np l"/></div><p class="my mz gj gh gi na nb bd b be z dk translated">代码片段4:将数据导入Geopandas</p></figure><p id="062e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">重要的部分是下一个函数，我们遵循算法的所有步骤:</p><figure class="mn mo mp mq gt mr"><div class="bz fp l di"><div class="no np l"/></div><p class="my mz gj gh gi na nb bd b be z dk translated">代码片段Python中的最近邻函数</p></figure><p id="e52e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们必须做两件事:首先，应用函数，这样我们就可以获得最近几何图形的标识符列表。其次，我们获取这些标识符的值。</p><p id="bb67" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该函数被编写为总是返回源和目的地的标识符，这样更安全，因为所有数据帧都有索引，但不是所有数据帧的列都有相同的名称。代码的第二部分将这些标识符转换成值:</p><figure class="mn mo mp mq gt mr"><div class="bz fp l di"><div class="no np l"/></div><p class="my mz gj gh gi na nb bd b be z dk translated">代码片段6:最近邻函数的实现</p></figure><p id="9ce4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">输出类似于SQL示例1:</p><figure class="mn mo mp mq gt mr gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi nc"><img src="../Images/fede808875a296367ec982332008de22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4j-NhaJnitNYXjd-GRshHg.png"/></div></div><p class="my mz gj gh gi na nb bd b be z dk translated">表3:离使用Geopandas的图书馆最近的休闲中心(未全部显示)</p></figure><p id="a2e6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">平均运行时间为5毫秒，这与SQL相比快得惊人。在这篇文章的最后，我将用一个更大的数据集进行比较。</p><h1 id="a941" class="lb lc iq bd ld le lf lg lh li lj lk ll jw lm jx ln jz lo ka lp kc lq kd lr ls bi translated">Python示例2:具有Geopandas的K个最近邻</h1><p id="5fbe" class="pw-post-body-paragraph kf kg iq kh b ki lt jr kk kl lu ju kn ko lv kq kr ks lw ku kv kw lx ky kz la ij bi translated">现在，让我们尝试使用Geopandas来查找K个最近的邻居，就像我们在SQL示例2中所做的那样。和以前一样，算法不变，只有实现。我们修改了函数，现在接受第三个变量k，它代表所需的最近邻数量:</p><figure class="mn mo mp mq gt mr"><div class="bz fp l di"><div class="no np l"/></div><p class="my mz gj gh gi na nb bd b be z dk translated">代码片段Python中的K近邻函数</p></figure><p id="6eff" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们调用该函数并获得输出(表4):</p><figure class="mn mo mp mq gt mr"><div class="bz fp l di"><div class="no np l"/></div><p class="my mz gj gh gi na nb bd b be z dk translated">代码片段8:K近邻函数的实现</p></figure><figure class="mn mo mp mq gt mr gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi nc"><img src="../Images/d63322889032b8cdc666c0792aae1175.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GgLTmchbLLkEntifGV3vcA.png"/></div></div><p class="my mz gj gh gi na nb bd b be z dk translated">表4:离使用Geopandas的图书馆最近的两个休闲中心(未全部显示)</p></figure><p id="68fb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个例子平均运行7毫秒。</p><h1 id="de77" class="lb lc iq bd ld le lf lg lh li lj lk ll jw lm jx ln jz lo ka lp kc lq kd lr ls bi translated">更大数据的性能</h1><p id="5ebb" class="pw-post-body-paragraph kf kg iq kh b ki lt jr kk kl lu ju kn ko lv kq kr ks lw ku kv kw lx ky kz la ij bi translated">到目前为止，所有的例子都是使用一对相当小的数据集完成的。一个是13行长，另一个是17行长。我将使用操作系统打开UPRN和代码点打开UPRN作为原点，重复练习1。</p><p id="c225" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这两个数据集都可以从https://osdatahub.os.uk/downloads/open(2021)下载。</p><p id="874c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我将表格简化为白马谷区域内的几何图形。这给了我们80347个UPRNs和4074个代码点。这些仍然是小数据集，我想说一个更真实的练习将涉及有数百万行或至少数十万行的表。不过，我将保持简单，只是为了演示性能上的差异。</p><p id="1d95" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在PostgreSQL中，有许多方面会影响Geopandas与SQL的性能:</p><ul class=""><li id="a713" class="ly lz iq kh b ki kj kl km ko ma ks mb kw mc la md me mf mg bi translated">Geopandas将数据存储在内存中，而PostgreSQL必须从磁盘中读取数据。这可以让熊猫更快，只要你有足够的内存，你愿意等待数据读入内存。</li><li id="c2ac" class="ly lz iq kh b ki mh kl mi ko mj ks mk kw ml la md me mf mg bi translated">PostgreSQL有一个计划器，它会尝试以最好的方式实现查询，这可能是相对于Python的一个优势。</li><li id="a1cd" class="ly lz iq kh b ki mh kl mi ko mj ks mk kw ml la md me mf mg bi translated">根据版本的不同，PostgreSQL可以对同一个查询使用多个CPU，而Pandas则仅限于单个CPU。</li><li id="a6a6" class="ly lz iq kh b ki mh kl mi ko mj ks mk kw ml la md me mf mg bi translated">通常PostgreSQL运行在一个比普通计算机有更多RAM和CPU的服务器上，但是你也可以在服务器上运行Geopandas，所以这完全取决于你的情况。</li><li id="a395" class="ly lz iq kh b ki mh kl mi ko mj ks mk kw ml la md me mf mg bi translated">PostgreSQL和Geopandas都使用索引来加快查询速度，但我发现PostgreSQL索引更加通用和强大。</li><li id="4f3c" class="ly lz iq kh b ki mh kl mi ko mj ks mk kw ml la md me mf mg bi translated">PostgreSQL的配置很重要，默认情况下，它会限制给查询的内存量。</li></ul><p id="a4b0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这种情况下，SQL和Python都在同一台笔记本电脑上运行，该笔记本电脑有16GB RAM和8个2.30 Ghz的CPU(对于数据库服务器来说不是很好)。</p><p id="c7f4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们需要做一些调整，以确保查询和函数不会被大型任务所阻塞。对于SQL，我们需要:</p><ul class=""><li id="082a" class="ly lz iq kh b ki kj kl km ko ma ks mb kw mc la md me mf mg bi translated">为两个表创建空间索引</li><li id="bf5a" class="ly lz iq kh b ki mh kl mi ko mj ks mk kw ml la md me mf mg bi translated">为要在“DISTINCT ON”中使用的列创建索引</li><li id="993a" class="ly lz iq kh b ki mh kl mi ko mj ks mk kw ml la md me mf mg bi translated">建立一个距离限制来减少组合的数量</li></ul><p id="b887" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果没有索引，SQL查询将需要很长时间。我使用的限制是5公里，因此距离超过5公里的所有组合都会被删除。</p><p id="538b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们创建索引，并用距离限制修改查询:</p><figure class="mn mo mp mq gt mr"><div class="bz fp l di"><div class="no np l"/></div><p class="my mz gj gh gi na nb bd b be z dk translated">代码片段9:最近邻查询的表索引</p></figure><figure class="mn mo mp mq gt mr"><div class="bz fp l di"><div class="no np l"/></div><p class="my mz gj gh gi na nb bd b be z dk translated">代码片段10:使用SQL的大型数据集的最近邻</p></figure><p id="c6b5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意，我没有调用输出，而是重定向到一个新表。输出可能很大，您肯定不希望第二次运行一个很长的查询。这个查询需要3分28秒。</p><p id="837f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于Geopandas，我们需要重写代码，以便从索引中获益。我们导入数据，定义新函数，并像这样实现它:</p><figure class="mn mo mp mq gt mr"><div class="bz fp l di"><div class="no np l"/></div><p class="my mz gj gh gi na nb bd b be z dk translated">代码片段11:使用Python的大型数据集的最近邻</p></figure><p id="e285" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该查询运行时间为35分42秒。</p><p id="7ee2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如您所见，在这种情况下，Geopandas并不比SQL运行得更快。</p><p id="431b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">还有另一种选择:由于两个表都是点，我们可以将几何图形表示为坐标，然后使用scikit-learn (Pedregosa等人，2011年)计算最近邻。这仅用了106毫秒。这种方法的唯一缺点是不能使用不同于点的几何图形:</p><figure class="mn mo mp mq gt mr"><div class="bz fp l di"><div class="no np l"/></div><p class="my mz gj gh gi na nb bd b be z dk translated">代码片段13:使用sklearn和geopandas的最近邻</p></figure><p id="4e99" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所有执行速度如表5所示:</p><figure class="mn mo mp mq gt mr gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi nc"><img src="../Images/65814ef15cfcbbccbe337f27413d8837.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4QlbakAvOsAyPrrePd9i0A.png"/></div></div><p class="my mz gj gh gi na nb bd b be z dk translated">表5:性能比较</p></figure><h1 id="5bb7" class="lb lc iq bd ld le lf lg lh li lj lk ll jw lm jx ln jz lo ka lp kc lq kd lr ls bi translated">结论</h1><p id="cc3e" class="pw-post-body-paragraph kf kg iq kh b ki lt jr kk kl lu ju kn ko lv kq kr ks lw ku kv kw lx ky kz la ij bi translated">最近邻问题是空间分析中的基本问题之一，它可以有一个简单的解决方案，但需要一个计算密集型的解决方案。</p><p id="a50b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我已经展示了使用SQL和Python的选项。更准确地说，我展示了PostGIS、Geopandas和Scikit-learn的选项。</p><p id="64f8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">很明显，当任务很小时，Geopandas是很棒的。当任务较大时，PostGIS做得更好，尤其是在服务器良好的情况下。Scikit-learn速度超快，但仅限于点数。</p><p id="d7c0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">性能不仅受您使用的语言的影响，还受硬件、配置、索引等整个环境的影响。</p><p id="0999" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我希望你喜欢这篇文章，但如果你有改进算法或代码的建议，请不要忘记评论。</p><h1 id="c3a3" class="lb lc iq bd ld le lf lg lh li lj lk ll jw lm jx ln jz lo ka lp kc lq kd lr ls bi translated">参考</h1><p id="f1dd" class="pw-post-body-paragraph kf kg iq kh b ki lt jr kk kl lu ju kn ko lv kq kr ks lw ku kv kw lx ky kz la ij bi translated">凯尔西·乔达尔、乔里斯·范登博舍、马丁·弗莱施曼、雅各布·乏色曼、詹姆斯·麦克布莱德、杰弗里·杰拉德……弗朗索瓦·勒布朗。(2020年7月15日)。geo pandas/geo pandas:v 0 . 8 . 1(v 0 . 8 . 1版)。芝诺多。可用时间:<a class="ae nn" href="http://doi.org/10.5281/zenodo.3946761" rel="noopener ugc nofollow" target="_blank"><em class="nr"/></a><em class="nr">。</em></p><p id="3df4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">osdatahub.os.uk. (2021)。<em class="nr"> OS数据中枢</em>。[在线]可从<a class="ae nn" href="https://osdatahub.os.uk/." rel="noopener ugc nofollow" target="_blank">https://osdatahub.os.uk/.</a>获得</p><p id="2690" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Pedregosa，f .，Varoquaux，g .，Gramfort，a .，Michel，v .，Thirion，b .，Grisel，o .，Blondel，m .，Prettenhofer，p .，Weiss，r .，Dubourg，v .，Vanderplas，j .，Passos，a .，Cournapeau，d .，Brucher，m .，佩罗特，m .和Duchesnay，e .(2011).sci kit-learn:Python中的机器学习。<em class="nr">机器学习研究杂志</em>，【在线】12(85)，第2825–2830页。可在:<a class="ae nn" href="https://jmlr.csail.mit.edu/papers/v12/pedregosa11a.html." rel="noopener ugc nofollow" target="_blank">https://jmlr.csail.mit.edu/papers/v12/pedregosa11a.html</a></p><p id="0be1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">后GIS开发者(2020)。<em class="nr">PostGIS—PostgreSQL的空间和地理对象</em>。[在线]Postgis.net。可在:<a class="ae nn" href="https://postgis.net/." rel="noopener ugc nofollow" target="_blank">https://postgis.net/.</a></p><p id="c820" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">‌Postgresql.org。(2019).<em class="nr"> PostgreSQL:全球最先进的开源数据库</em>。[在线]可在https://www.postgresql.org/.<a class="ae nn" href="https://www.postgresql.org/." rel="noopener ugc nofollow" target="_blank">的</a>找到</p><p id="c7f9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Trafforddatalab.io. 2021。<em class="nr">特拉福德数据实验室</em>。【在线】可在:<a class="ae nn" href="https://www.trafforddatalab.io/" rel="noopener ugc nofollow" target="_blank">https://www.trafforddatalab.io/</a>获得。</p></div></div>    
</body>
</html>