<html>
<head>
<title>Reusable Terms with spaCy Rule Matcher</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带有空间规则匹配器的可重用术语</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/reusable-terms-with-spacy-rule-matcher-5d60ae5697fe?source=collection_archive---------30-----------------------#2021-04-25">https://towardsdatascience.com/reusable-terms-with-spacy-rule-matcher-5d60ae5697fe?source=collection_archive---------30-----------------------#2021-04-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="75a3" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">匹配者的一个简单技巧</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/29f3a7f0abf8eea47107eedb82e879f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*SF5eLgxGGxmKMv9J"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Sheri Hooley 在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="1f12" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我不想撒谎，我真的很喜欢空间。它基于复杂的自然语言处理(NLP ),但使用起来非常简单。这是一个ML工程师的梦想(尽管这是一个多么奇怪的梦想)。另外，这也是数据科学家的梦想，因为如何增强底层的NLP(仍然是一个怪异的梦想)！我几乎每天都要使用它，在这一过程中，我学到了一些技巧，您可能会发现这些技巧很有帮助，第一个技巧涉及到可重用术语。</p><h2 id="030d" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">规则匹配器基础</h2><p id="6b12" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">spaCy(实际上是NLP)的核心思想之一是单词被分解成记号，这些记号可以被识别(例如，词性)或以各种方式使用。使用令牌的一种特定方式是根据显式标准对它们进行匹配。spaCy使用Python来实现这一点，可以创建模式，将其添加到spaCy Matcher对象中，然后对照文本来查找匹配。</p><p id="8540" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，假设我想找到“爱吃披萨”这几个词，通过研究我知道人们经常使用这个确切的短语，但是“爱披萨”、“爱披萨”、“挖披萨”、“吞食披萨”和“吃披萨”都表示爱披萨(因为每个吃披萨的人都爱披萨，对吗？).</p><p id="df8a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要为某样东西创建一个匹配模式，比如说“爱吃比萨饼”，我将编写以下代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="33d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mv mw mx my b">pattern</code>只是Python字典条目的列表(尽管字典条目非常特定于空间)。在我的代码中，<code class="fe mv mw mx my b">TEXT</code>指定了我要查找的内容，然后那个键的值就是字面的、区分大小写的文本。列表中字典元素的顺序很重要——换句话说，我不能用这种模式匹配“pizza loves”。然后我将这个模式添加到<code class="fe mv mw mx my b">matcher</code>对象(类型为<code class="fe mv mw mx my b">spacy.matcher.Matcher</code>)中，并给它一个标签(<code class="fe mv mw mx my b">PIZZA_RULE</code>)。然后在我的代码中，我展示了如何使用匹配器从一些文本中输出匹配。</p><p id="5e81" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mv mw mx my b">PIZZA_RULE loves pizza</code></p><h2 id="de70" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">前缀的问题是</h2><p id="f407" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">这里的问题是，我有一堆非常相关的短语要匹配——实际上只有第一个单词发生了变化，即前缀<em class="mz">和</em>。现在我<em class="mz">可以</em>为每一个写一个匹配器:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="069e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，这些模式只改变了第一个单词。这很管用。但是想象一下，我在许多应用程序中使用了这些模式，然后我意识到人们也经常说“崇拜比萨饼”？我可以继续添加更多的模式，但真的有更好的方法。</p><p id="daff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">确实有。</p><h2 id="ea69" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">可重用性第一部分</h2><p id="aba8" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">首先，spaCy中有一种机制，允许您在创建模式时使用<code class="fe mv mw mx my b">IN</code>属性从一个术语列表中进行选择。对于比萨饼模式，看起来像这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="3e29" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mv mw mx my b">IN</code>属性允许一个术语列表，这意味着列表中的任何一个单词以及单词“pizza”都是匹配的。非常酷，非常灵活。</p><h2 id="35b2" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">可重用性第二部分</h2><p id="3a41" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">现在想象一下，我有另外一系列前缀，它们是单词“order”的变体，表示短语“orders from Amazon”、“order Amazon”、“get from Amazon”、“procure from Amazon”(等等)。).现在想象我在“Amazon”之外的许多上下文中使用这个前缀(例如，“订购比萨饼”)。这种机制不够灵活，因为它是嵌入式模式的一部分。我需要一种方法将这些前缀从内嵌模式中去掉。</p><p id="a7de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里真正好的消息是，我可以依靠基本的Python来解决这个问题。鉴于<code class="fe mv mw mx my b">IN</code>属性只是一个Python列表，并且我可以在外部定义一个Python列表，整个事情变得非常简单。</p><p id="b60f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我创建了一个名为<code class="fe mv mw mx my b">reusable.py</code>的文件，其中包含了我所有“order”前缀的列表。它只有一行字:</p><p id="187d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mv mw mx my b">order_prefixes = [‘buy’, ‘get’, ‘order’, ‘orders’, ‘ordering’, ‘procure’, ‘procuring’, ‘purchase’, ‘purchases’]</code></p><p id="103c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我将新的<code class="fe mv mw mx my b">reusable.py</code>文件导入到我的主代码中，代码行如下:</p><p id="27db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mv mw mx my b">import reusable as terms</code></p><p id="2fb8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我将模式中的列表替换为从<code class="fe mv mw mx my b">reusable.py:</code>导入的名为<code class="fe mv mw mx my b">orders_prefices</code>的列表的引用</p><p id="aad3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mv mw mx my b">pattern = [{‘TEXT’: {‘IN’: terms.order_prefixes}}, {‘TEXT’: ‘from’}, {‘TEXT’: ‘Amazon’}]</code></p><p id="1102" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我修改了我最初的“pizza”代码，以处理来自Amazon的订单，因此我的最终代码如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="3107" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是输出结果:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><h2 id="878b" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">简单但强大</h2><p id="e011" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">这种可重用性“技巧”实现起来非常简单，但是对于在整个组织中创建匹配关键字来说却非常强大。我用Amazon显示了“order”前缀，但是我可以用它来处理任何东西，比如Nick和Vito's (pizza)。有了一个集中的术语库，添加/更改/删除它们以及在多种上下文中使用它们就容易多了。</p><p id="28d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还有谁不喜欢亚马逊和披萨？嘿…我可以从亚马逊买披萨吗？</p></div><div class="ab cl na nb hx nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="im in io ip iq"><p id="2118" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关于spaCy的更多基本设置，请访问spaCy网站。</p><h2 id="8e66" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">参考</h2><p id="c9e8" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">[1]空间，<a class="ae ky" href="https://spacy.io/usage/rule-based-matching" rel="noopener ugc nofollow" target="_blank">基于规则的匹配</a>(未标明)，空间. io</p></div></div>    
</body>
</html>