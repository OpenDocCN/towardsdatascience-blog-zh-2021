<html>
<head>
<title>Text Files Processing, Cleaning, and Classification of Documents in R</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">R语言中文本文件的处理、清理和分类</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/text-files-processing-cleaning-and-classification-of-documents-in-r-394c6b4f1504?source=collection_archive---------19-----------------------#2021-04-22">https://towardsdatascience.com/text-files-processing-cleaning-and-classification-of-documents-in-r-394c6b4f1504?source=collection_archive---------19-----------------------#2021-04-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/b66d1e82995c799dd545df898696fed2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*OvXO34PR1PGFnZHj"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">杰森·罗斯韦尔在<a class="ae jg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><div class=""/><div class=""><h2 id="4aae" class="pw-subtitle-paragraph kg ji jj bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dk translated">使用了一些很棒的包和K近邻分类器</h2></div><p id="aa62" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">随着文本文档数量的不断增加，文本文档分类已经成为数据科学中的一项重要任务。与此同时，机器学习和数据挖掘技术也在每天进步。Python和R编程语言都具有惊人的文本数据清理和分类功能。</p><p id="7936" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">本文将关注使用R库的文本文档处理和分类。</p><h2 id="0241" class="lu lv jj bd lw lx ly dn lz ma mb dp mc lh md me mf ll mg mh mi lp mj mk ml mm bi translated">问题陈述</h2><p id="37fc" class="pw-post-body-paragraph ky kz jj la b lb mn kk ld le mo kn lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">这里使用的数据是打包在名为20Newsgroups的文件夹中的文本文件。该文件夹有两个子文件夹。其中一个包含训练数据，另一个包含测试数据。每个子文件夹包含20个文件夹。这20个文件夹中的每一个都包含数百个不同主题的新闻文件。这个项目的目的是选择两个主题，并开发一个分类器，可以对这两个主题的文件进行分类。</p><p id="5941" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请随意从该链接下载数据集，并遵循:</p><p id="bf37" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><a class="ae jg" href="https://github.com/rashida048/Text-Files-Classification-in-R/blob/main/20Newsgroups.zip" rel="noopener ugc nofollow" target="_blank">https://github . com/rashida 048/Text-Files-Classification-in-R/blob/main/20 news groups . zip</a></p><h2 id="89eb" class="lu lv jj bd lw lx ly dn lz ma mb dp mc lh md me mf ll mg mh mi lp mj mk ml mm bi translated">数据准备</h2><p id="84b6" class="pw-post-body-paragraph ky kz jj la b lb mn kk ld le mo kn lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">我们将使用“tm”库，这是一个数据挖掘框架。这个框架内置了一个“文本”文件夹。让我们在电脑上找到“文本”文件夹的路径。</p><p id="7be4" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">首先，调用这个项目所需的所有库:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="e8ea" class="lu lv jj mx b gy nb nc l nd ne">library(tm) # Framework for text mining.<br/>library(SnowballC) # Provides wordStem() for stemming.<br/>library(dplyr) # Data preparation and pipes %&gt;%.<br/>library(ggplot2) # Plot word frequencies.<br/>library(scales) # Common data analysis activities.<br/>library(pdftools)</span></pre><p id="4777" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用system.file()函数，可以找到“文本”文件夹的路径:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="874a" class="lu lv jj mx b gy nb nc l nd ne">system.file("texts", package = "tm")</span></pre><p id="3ba2" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输出:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="c4fa" class="lu lv jj mx b gy nb nc l nd ne">[1] "C:/Users/User/Documents/R/win-library/4.0/tm/texts"</span></pre><p id="5760" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后我把“20个新闻组”文件夹放在“短信”文件夹里。现在，我们将逐一带来训练和测试数据。正如我在问题陈述中提到的，我们将只使用这个文件夹中20个主题中的两个。我选择了“rec”。汽车和科学。医学。以下是training文件夹中“rec.autos”文件夹的路径:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="2d02" class="lu lv jj mx b gy nb nc l nd ne">mac.path.loc = system.file("texts", "20Newsgroups", "20news-bydate-train", "rec.autos", package = "tm")<br/>mac.path.loc</span></pre><p id="91f6" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输出:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="14e6" class="lu lv jj mx b gy nb nc l nd ne">[1] "C:/Users/User/Documents/R/win-library/4.0/tm/texts/20Newsgroups/20news-bydate-train/rec.autos"</span></pre><p id="25e7" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">检查“rec.autos”文件夹中的内容是个好主意。将上面的路径传递给“DirSource”函数将为我们提供这些信息。</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="e53a" class="lu lv jj mx b gy nb nc l nd ne">mac.files = DirSource(mac.path.loc)<br/>mac.files</span></pre><p id="1c4f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">产量相当大。这里我展示了输出的一部分</p><p id="a200" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输出:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="d0b9" class="lu lv jj mx b gy nb nc l nd ne">$encoding<br/>[1] ""</span><span id="f7c6" class="lu lv jj mx b gy nf nc l nd ne">$length<br/>[1] 594</span><span id="c6ea" class="lu lv jj mx b gy nf nc l nd ne">$position<br/>[1] 0</span><span id="b776" class="lu lv jj mx b gy nf nc l nd ne">$reader<br/>function (elem, language, id) <br/>{<br/>    if (!is.null(elem$uri)) <br/>        id &lt;- basename(elem$uri)<br/>    PlainTextDocument(elem$content, id = id, language = language)<br/>}<br/>&lt;bytecode: 0x0000014ff238f130&gt;<br/>&lt;environment: namespace:tm&gt;</span><span id="dcdd" class="lu lv jj mx b gy nf nc l nd ne">$mode<br/>[1] "text"</span><span id="3ef2" class="lu lv jj mx b gy nf nc l nd ne">$filelist<br/>  [1] "C:/Users/User/Documents/R/win-library/4.0/tm/texts/20Newsgroups/20news-bydate-train/rec.autos/101551"<br/>  [2] "C:/Users/User/Documents/R/win-library/4.0/tm/texts/20Newsgroups/20news-bydate-train/rec.autos/101552"<br/>  [3] "C:/Users/User/Documents/R/win-library/4.0/tm/texts/20Newsgroups/20news-bydate-train/rec.autos/101553"<br/>  [4] "C:/Users/User/Documents/R/win-</span></pre><p id="2623" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输出顶部的$length变量显示594。这意味着“rec.autos”文件夹中有594个项目。这意味着594个文本文件。我如何知道它们是测试文件？在这里的输出中，$mode变量表示“文本”。之后，最后有一个594个文件的列表。但是为了节省空间，我只显示了4个。</p><p id="be8e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，我想创建一个名为“fun.corpus”的函数，它将从指定主题的训练和测试文件夹中获取指定数量的文件。我们将在函数之后解释更多关于函数的内容。</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="55de" class="lu lv jj mx b gy nb nc l nd ne">fun.corpus = function(t, f, n){<br/>  mac.path.loc = system.file("texts", "20Newsgroups", t, f, package = "tm")<br/>  mac.files = DirSource(mac.path.loc)<br/>  mac.corpus = VCorpus(URISource(mac.files$filelist[1:n]),<br/>                     readerControl = list(reader=readPlain))<br/>  return(mac.corpus)</span><span id="4762" class="lu lv jj mx b gy nf nc l nd ne">}</span></pre><p id="5b07" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">该函数有三个参数。“t”表示测试或培训文件夹，“f”表示主题(我们选择了“sci.med”或“rec”。autos’)，n表示我们想要分类的文件的数量。“VCorpus”功能将文件转换为语料库格式。如果这种形式对你来说是新的，随着我们继续前进，它会变得更加清晰。所以，不用担心。</p><p id="f93a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，使用这个功能，我从“sci.med”中获取了300个文件，从“rec”。培训文件夹中的“汽车”主题。对于测试文件夹，我从每个主题中拿出200个文件夹。</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="b70d" class="lu lv jj mx b gy nb nc l nd ne">rautos_train = fun.corpus("20news-bydate-train", "rec.autos", 300)<br/>smed_train = fun.corpus("20news-bydate-train", "sci.med", 300)</span><span id="bc87" class="lu lv jj mx b gy nf nc l nd ne">rautos_test = fun.corpus("20news-bydate-test", "rec.autos", 200)<br/>smed_test = fun.corpus("20news-bydate-test", "sci.med", 200)</span></pre><p id="7f75" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们检查一下我们刚刚创建的rautos_train语料库中的一个文件。</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="b65a" class="lu lv jj mx b gy nb nc l nd ne">inspect(rautos_train[[1]])</span></pre><p id="c6e8" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输出:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="2f0b" class="lu lv jj mx b gy nb nc l nd ne">&lt;&lt;PlainTextDocument&gt;&gt;<br/>Metadata:  7<br/>Content:  chars: 2589</span><span id="1a8a" class="lu lv jj mx b gy nf nc l nd ne">From: <a class="ae jg" href="mailto:cs012055@cs.brown.edu" rel="noopener ugc nofollow" target="_blank">cs012055@cs.brown.edu</a> (Hok-Chung Tsang)<br/>Subject: Re: Saturn's Pricing Policy<br/>Article-I.D.: cs.1993Apr5.230808.581<br/>Organization: Brown Computer Science Dept.<br/>Lines: 51</span><span id="7437" class="lu lv jj mx b gy nf nc l nd ne">In article &lt;<a class="ae jg" href="mailto:C4vIr5.L3r@shuksan.ds.boeing.com" rel="noopener ugc nofollow" target="_blank">C4vIr5.L3r@shuksan.ds.boeing.com</a>&gt;, fredd@shuksan (Fred Dickey) writes:<br/>|&gt; CarolinaFan@uiuc (<a class="ae jg" href="mailto:cka52397@uxa.cso.uiuc.edu" rel="noopener ugc nofollow" target="_blank">cka52397@uxa.cso.uiuc.edu</a>) wrote:<br/>|&gt; :  I have been active in defending Saturn lately on the net and would<br/>|&gt; : like to state my full opinion on the subject, rather than just reply to others'<br/>|&gt; : points.<br/>|&gt; :  <br/>|&gt; :  The biggest problem some people seem to be having is that Saturn<br/>|&gt; : Dealers make ~$2K on a car.  I think most will agree with me that the car is<br/>|&gt; : comparably priced with its competitors, that is, they aren't overpriced <br/>|&gt; : compared to most cars in their class.  I don't understand the point of <br/>|&gt; : arguing over whether the dealer makes the $2K or not?  <br/>|&gt; <br/>|&gt; I have never understood what the big deal over dealer profits is either.<br/>|&gt; The only thing that I can figure out is that people believe that if<br/>|&gt; they minimize the dealer profit they will minimize their total out-of-pocket<br/>|&gt; expenses for the car. While this may be true in some cases, I do not<br/>|&gt; believe that it is generally true. I bought a Saturn SL in January of '92.<br/>|&gt; AT THAT TIME, based on studying car prices, I decided that there was<br/>|&gt; no comparable car that was priced as cheaply as the Saturn. Sure, maybe I<br/>|&gt; could have talked the price for some other car to the Saturn price, but<br/>|&gt; my out-of-pocket expenses wouldn't have been any different. What's important<br/>|&gt; to me is how much money I have left after I buy the car. REDUCING DEALER PROFIT<br/>|&gt; IS NOT THE SAME THING AS SAVING MONEY! Show me how reducing dealer profit<br/>|&gt; saves me money, and I'll believe that it's important. My experience has<br/>|&gt; been that reducing dealer profit does not necessarily save me money.<br/>|&gt; <br/>|&gt; Fred</span><span id="cae1" class="lu lv jj mx b gy nf nc l nd ne">Say, you bought your Saturn at $13k, with a dealer profit of $2k.<br/>If the dealer profit is $1000, then you would only be paying $12k for<br/>the same car.  So isn't that saving money?</span><span id="b12c" class="lu lv jj mx b gy nf nc l nd ne">Moreover, if Saturn really does reduce the dealer profit margin by $1000, <br/>then their cars will be even better deals.  Say, if the price of a Saturn was<br/>already $1000 below market average for the class of cars, then after they<br/>reduce the dealer profit, it would be $2000 below market average.  It will:</span><span id="fc8c" class="lu lv jj mx b gy nf nc l nd ne">1) Attract even more people to buy Saturns because it would SAVE THEM MONEY.<br/> <br/>2) Force the competitors to lower their prices to survive.</span><span id="0f51" class="lu lv jj mx b gy nf nc l nd ne">Now, not only will Saturn owners benefit from a lower dealer profit, even <br/>the buyers for other cars will pay less.</span><span id="1cc2" class="lu lv jj mx b gy nf nc l nd ne">Isn't that saving money?</span><span id="19aa" class="lu lv jj mx b gy nf nc l nd ne">$0.02,<br/>doug.</span></pre><p id="201d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">看，在开始，我们有这个文本来自哪个电子邮件地址，组织名称，和主题。在本文的这一部分，我只使用了这三条信息来对文件进行分类。</p><blockquote class="ng"><p id="be95" class="nh ni jj bd nj nk nl nm nn no np lt dk translated">如果您愿意，可以随意使用整个文档。我也尝试了一下，在这个数据集上得到了类似的结果。</p></blockquote><p id="54e1" class="pw-post-body-paragraph ky kz jj la b lb nq kk ld le nr kn lg lh ns lj lk ll nt ln lo lp nu lr ls lt im bi translated">下面是“ext”函数，它将语料库和文件数量作为输入，并返回一个向量列表，其中只包含电子邮件地址、组织名称和文本文件的主题。在您看到该函数后，可以获得更多关于该函数的解释。</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="d5c0" class="lu lv jj mx b gy nb nc l nd ne">ext = function(corp, n){<br/>  meta.info = list()<br/>  for (i in 1:n){<br/>    g1 = grep("From: ", corp[[i]]$content)<br/>    g2 = grep("Organization: ", corp[[i]]$content)<br/>    g3 = grep("Subject: ", corp[[i]]$content)<br/>    each_c = c(corp[[i]]$content[g1], corp[[i]]$content[g2], corp[[i]]$content[g3])<br/>    meta.info[[i]] = each_c<br/>  }<br/>  return(meta.info)<br/>}</span></pre><p id="8a55" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">以下是对这里所做工作的解释。这个函数传递了两个参数。语料库和需要处理的文件数量。首先我浏览了文件。从每个文件中，我们提取包含字符串的文本片段:“发件人:”组织:”主题。只为每个语料库制作这三个信息的向量，并将其添加到列表中。使用这个函数，我们可以从之前创建的所有语料库中提取必要的信息。</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="0ddd" class="lu lv jj mx b gy nb nc l nd ne">sm_train = ext(smed_train, 300)<br/>sm_test = ext(smed_test, 200)</span><span id="137c" class="lu lv jj mx b gy nf nc l nd ne">ra_train = ext(rautos_train, 300)<br/>ra_test = ext(rautos_test, 200)</span></pre><p id="5302" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在合并所有的列表。</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="16cf" class="lu lv jj mx b gy nb nc l nd ne">merged = c(sm_train, ra_train, ra_test, sm_test)<br/>merged.vec = VectorSource(merged)</span></pre><p id="7644" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是一个很大的列表，其中有来自培训和测试文件夹的1000个对象。</p><p id="ae21" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">再次将“合并”列表转换成语料库。</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="49ae" class="lu lv jj mx b gy nb nc l nd ne">v = VCorpus(merged.vec)</span></pre><p id="7fbf" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">检查该语料库的一个元素:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="9de4" class="lu lv jj mx b gy nb nc l nd ne">inspect(v[[1]])</span></pre><p id="e073" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输出:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="c879" class="lu lv jj mx b gy nb nc l nd ne">&lt;&lt;PlainTextDocument&gt;&gt;<br/>Metadata:  7<br/>Content:  chars: 114</span><span id="cc77" class="lu lv jj mx b gy nf nc l nd ne">From: bed@intacc.uucp (Deb Waddington)<br/>Organization: Matrix Artists' Network<br/>Subject: INFO NEEDED: Gaucher's Disease</span></pre><p id="09a9" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">它有114个字符，包括我们提取的信息。所以，很完美！</p><h2 id="42d1" class="lu lv jj bd lw lx ly dn lz ma mb dp mc lh md me mf ll mg mh mi lp mj mk ml mm bi translated">数据清理</h2><p id="31c2" class="pw-post-body-paragraph ky kz jj la b lb mn kk ld le mo kn lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">数据清理非常重要。每次我处理文本数据时，它都显著提高了分类器的性能。很难找到完美的文本数据。所以，大部分时间我们都要清洗它们。</p><p id="b143" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们把每篇文章都做得很小。只有三条信息。我将删除电子邮件地址中的“@”符号，删除字符串中的“发件人:”、组织:”和“主题:”部分，因为这三部分信息不丰富，删除标点符号，并阻止数据。我将转换后的语料库保存在“temp.v”变量中。</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="9a27" class="lu lv jj mx b gy nb nc l nd ne">transform.words = content_transformer(function(x, from, to) gsub(from, to, x))<br/>temp.v = tm_map(v, transform.words, "@", " ")<br/>temp.v = tm_map(temp.v, transform.words, "From: |Organization: |Subject: ", "")<br/>temp.v = tm_map(temp.v, removePunctuation)<br/>temp.v = tm_map(temp.v, stemDocument, language = "english")</span></pre><p id="efef" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里transform.words函数使用content_transformer函数。它有三个参数，“x”是语料库，“from”是模式(在这种情况下是“@”符号或“From: |Organization: |Subject:”)，而“to”是替换(在这种情况下是空格或无)。</p><p id="4fe8" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">检查转换是否有效:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="dfda" class="lu lv jj mx b gy nb nc l nd ne">inspect(temp.v[[1]])</span></pre><p id="d91d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输出:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="9f3f" class="lu lv jj mx b gy nb nc l nd ne">&lt;&lt;PlainTextDocument&gt;&gt;<br/>Metadata:  7<br/>Content:  chars: 76</span><span id="7a86" class="lu lv jj mx b gy nf nc l nd ne">bed intaccuucp Deb Waddington<br/>Matrix Artist Network<br/>INFO NEEDED Gaucher Diseas</span></pre><p id="02c9" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">成功了！没有“@”符号，“发件人:”部分，“组织:”部分和“主题:”部分，没有标点符号。如果你仔细注意单词，有些单词是有词干的。</p><h2 id="9c0e" class="lu lv jj bd lw lx ly dn lz ma mb dp mc lh md me mf ll mg mh mi lp mj mk ml mm bi translated">开发和训练分类器</h2><p id="f163" class="pw-post-body-paragraph ky kz jj la b lb mn kk ld le mo kn lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">这是有趣的部分！我们需要一个文档术语矩阵。我将temp.v语料库转换为文档术语矩阵。因为分类器不接受语料库。矩阵是数据的正确格式。</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="e73c" class="lu lv jj mx b gy nb nc l nd ne">dtm = DocumentTermMatrix(temp.v, control = list(wordLengths = c(2, Inf), bound = list(global=c(5, Inf))))</span></pre><p id="e411" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请记住，当我们从文件夹中导入数据时，我们从training文件夹中提取了600个文件，从test文件夹中提取了400个文件。然后创建合并语料库，将训练语料库放在最上面。让我们从文档术语矩阵中分离出训练和测试数据。</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="1dbc" class="lu lv jj mx b gy nb nc l nd ne">dtm.train = dtm[1:600,]<br/>dtm.test = dtm[601:1000,]</span></pre><p id="edff" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了输入到分类器，需要数据的正确标签或标记来训练模型。这意味着哪个文件应该被标记为什么。测试数据也需要标签。因为我们预测完标签后，需要一个参照物来对比，找出预测的准确率。</p><p id="7ac2" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们知道数据的顺序。这是训练和测试数据的标签:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="ce60" class="lu lv jj mx b gy nb nc l nd ne">tags = factor(c(rep("smed", 300), rep("rauto", 300)))<br/>tags1 = factor(c(rep("rauto", 200), rep("smed", 200)))</span></pre><p id="6ee8" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">标签用于训练数据，标签1用于测试数据。</p><p id="ed5c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我使用了K近邻或KNN分类器。如果你还没有类库，你需要安装它。下面是分类器。它接受训练数据、测试数据、训练数据的标签和“k”值。</p><p id="b084" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">只是一个关于KNN分类器的高层次和简短的想法。该分类器首先使用训练数据和训练数据的标签来学习关于数据的趋势。当它得到新数据进行分类时，它会计算该数据与其他数据之间的距离。并根据距离将新数据标记为最近邻居。这里K的值开始起作用。如果K的值是5，它将新数据标记为五个最近的数据点。你需要找到一个合适的k值。</p><p id="238a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里我用K的值作为4。</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="2be6" class="lu lv jj mx b gy nb nc l nd ne">library(class)</span><span id="13db" class="lu lv jj mx b gy nf nc l nd ne">set.seed(245)<br/>prob.test = knn(dtm.train, dtm.test, tags, k=4, prob = TRUE)<br/>prob.test</span></pre><p id="702b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">以下是部分输出:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="f7c5" class="lu lv jj mx b gy nb nc l nd ne">[1] rauto rauto rauto rauto rauto smed  smed  smed  smed  smed  smed <br/> [12] rauto rauto smed  rauto rauto smed  rauto rauto rauto rauto rauto<br/> [23] smed  rauto rauto smed  rauto rauto rauto smed  smed  rauto smed <br/> [34] rauto rauto smed  rauto smed  smed  rauto smed  smed  rauto rauto<br/> [45] rauto rauto rauto smed  rauto smed  smed  smed  smed  smed  smed <br/> [56] smed  smed  rauto rauto smed  smed  rauto rauto rauto smed  rauto<br/> [67] smed  rauto rauto smed  smed  rauto rauto rauto rauto smed  rauto<br/> [78] smed  rauto rauto smed  rauto rauto rauto smed  smed  rauto rauto<br/> [89] rauto rauto smed  rauto rauto smed  rauto rauto smed  smed  smed</span></pre><p id="b2ab" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">它总共有400个预测。它学习训练数据和标签。并预测400个测试数据的标签。记住，我们有400个测试数据。</p><p id="f368" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，我将制作一个数据框。数据框中将有三列:601到1000的序列号、来自分类器的预测标签以及标签是否正确。</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="9adb" class="lu lv jj mx b gy nb nc l nd ne">a = 601:1000<br/>b = levels(prob.test)[prob.test]<br/>c = prob.test==tags1</span><span id="f2c5" class="lu lv jj mx b gy nf nc l nd ne">res = data.frame(SI = a, Predict = b, Correct = c)<br/>head(res)</span></pre><p id="c5fe" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输出:</p><figure class="ms mt mu mv gt iv gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/f056de8ee89b010ec36d38a1365f3812.png" data-original-src="https://miro.medium.com/v2/resize:fit:1072/format:webp/1*52JNCyGCK915ChOTCLa7qA.png"/></div></figure><p id="8025" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">以下是预测的准确性:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="a9c9" class="lu lv jj mx b gy nb nc l nd ne">sum(c)/length(tags1)</span></pre><p id="7b11" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输出:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="ba16" class="lu lv jj mx b gy nb nc l nd ne">[1] 0.685</span></pre><p id="293f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">所以，准确率是68.5%。但是这个准确率可能随着不同的k值而变化。我创建了一个函数，它将k值作为参数，并返回准确率。</p><p id="fac3" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面是函数:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="155d" class="lu lv jj mx b gy nb nc l nd ne">prob.t = function(n){<br/>  set.seed(245)<br/>  <br/>  prob.test = knn(dtm.train, dtm.test, tags, k=n, prob = TRUE)<br/>  a = 601:1000<br/>  b = levels(prob.test)[prob.test]<br/>  c = prob.test==tags1<br/>  <br/>  return(sum(c)/length(tags1))<br/>}</span></pre><p id="7ebe" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用此功能，可计算k值为1至12时的准确率:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="6121" class="lu lv jj mx b gy nb nc l nd ne">res.list = c()<br/>for (i in 1:12){<br/>  acc = prob.t(i)<br/>  res.list = append(res.list, acc)<br/>}<br/>res.list</span></pre><p id="753b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输出:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="cfc9" class="lu lv jj mx b gy nb nc l nd ne">[1] 0.7175 0.6875 0.7150 0.6850 0.6625 0.6050 0.6000 0.5850 0.5750<br/>[10] 0.5725 0.5675 0.5475</span></pre><p id="4a76" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">k值与准确度的散点图将显示准确度如何随k值变化的趋势。</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="8c5c" class="lu lv jj mx b gy nb nc l nd ne">ggplot(res.data, aes(x = K_values, y = res.list)) + geom_point()+<br/>  labs(<br/>    title="Accuracy vs k values",<br/>    x = "K Values",<br/>    y = "Accuracy"<br/>  ) + <br/>  scale_x_discrete(limits=1:12)</span></pre><p id="775c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输出:</p><figure class="ms mt mu mv gt iv gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/8a7e49226d3bc657cbbeb7fb24dced07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1278/format:webp/1*O_0liDFuDNk_SxQPJEMsPA.png"/></div></figure><p id="b021" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">k值为1时精度最高，k值为3时精度最高。之后就一直往下走。</p><h2 id="a563" class="lu lv jj bd lw lx ly dn lz ma mb dp mc lh md me mf ll mg mh mi lp mj mk ml mm bi translated">分级机效率的分析</h2><p id="8f23" class="pw-post-body-paragraph ky kz jj la b lb mn kk ld le mo kn lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">我使用1的k值再次创建了预测精度的数据框:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="df07" class="lu lv jj mx b gy nb nc l nd ne">set.seed(245)<br/>prob.test = knn(dtm.train, dtm.test, tags, k=1, prob = TRUE)<br/>a = 601:1000<br/>b = levels(prob.test)[prob.test]<br/>c = prob.test==tags1<br/>res = data.frame(SI = a, Predict = b, Correct = c)<br/>head(res)</span></pre><p id="4ac6" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输出:</p><figure class="ms mt mu mv gt iv gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/56778e7545ee50700bc49e29ea8a8bbd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1066/format:webp/1*pMMzlrrE29yassh5nwHh3g.png"/></div></figure><p id="0102" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">混淆矩阵提供了许多有助于评估分类器效率的信息。</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="049c" class="lu lv jj mx b gy nb nc l nd ne">library(e1071)<br/>library(caret)</span><span id="1549" class="lu lv jj mx b gy nf nc l nd ne">confusionMatrix(as.factor(b), as.factor(tags1), "smed")</span></pre><p id="4f04" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输出:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="516f" class="lu lv jj mx b gy nb nc l nd ne">Confusion Matrix and Statistics</span><span id="d65f" class="lu lv jj mx b gy nf nc l nd ne">Reference<br/>Prediction rauto smed<br/>     rauto   105   18<br/>     smed     95  182<br/>                                          <br/>               Accuracy : 0.7175          <br/>                 95% CI : (0.6706, 0.7611)<br/>    No Information Rate : 0.5             <br/>    P-Value [Acc &gt; NIR] : &lt; 2.2e-16       <br/>                                          <br/>                  Kappa : 0.435           <br/>                                          <br/> Mcnemar's Test P-Value : 8.711e-13       <br/>                                          <br/>            Sensitivity : 0.9100          <br/>            Specificity : 0.5250          <br/>         Pos Pred Value : 0.6570          <br/>         Neg Pred Value : 0.8537          <br/>             Prevalence : 0.5000          <br/>         Detection Rate : 0.4550          <br/>   Detection Prevalence : 0.6925          <br/>      Balanced Accuracy : 0.7175          <br/>                                          <br/>       'Positive' Class : smed</span></pre><p id="e9fd" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">看，分类器预测的105个“rec.autos”文件是正确的，而95个“rec.autos”文件被错误地预测为“sci.med”文件。另一方面，182个“sci.med”文件被分类器正确地标记，18个“sci.med”文件被错误地标记为“res.autos”文件。</p><p id="0a6b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">此外，灵敏度是0.91，这实际上是回忆。精度为0.657，即上面混淆矩阵结果中的“位置Pred值”。使用这两个数据，我们可以计算F1分数:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="129a" class="lu lv jj mx b gy nb nc l nd ne">F1 = (2*0.657*0.91) / (0.657 + 0.91)<br/>F1</span></pre><p id="28a3" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输出:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="5dea" class="lu lv jj mx b gy nb nc l nd ne">[1] 0.7630759</span></pre><p id="e978" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">F1分数是衡量模型效率的重要标准。F1值越接近1，模型越好。</p><p id="9779" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果精度、召回和F1分数对你来说是新的，这里有一个详细的讨论:</p><div class="is it gp gr iu ny"><a rel="noopener follow" target="_blank" href="/a-complete-understanding-of-precision-recall-and-f-score-concepts-23dc44defef6"><div class="nz ab fo"><div class="oa ab ob cl cj oc"><h2 class="bd jk gy z fp od fr fs oe fu fw ji bi translated">完全理解精确度、召回率和F分数的概念</h2><div class="of l"><h3 class="bd b gy z fp od fr fs oe fu fw dk translated">机器学习中如何处理倾斜数据集</h3></div><div class="og l"><p class="bd b dl z fp od fr fs oe fu fw dk translated">towardsdatascience.com</p></div></div><div class="oh l"><div class="oi l oj ok ol oh om ja ny"/></div></div></a></div><h2 id="cec8" class="lu lv jj bd lw lx ly dn lz ma mb dp mc lh md me mf ll mg mh mi lp mj mk ml mm bi translated">结论</h2><p id="d3b4" class="pw-post-body-paragraph ky kz jj la b lb mn kk ld le mo kn lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">我希望这个演示有所帮助。我提取了实验对象的数据并运行了分类器。但是请随意使用整个文本并自己再次运行分类器。这将只需要一些额外的时间，因为整个文本是大量的数据。此外，它可能需要更多的清洁。喜欢完整的文字会有很多停用词。你可以考虑把它们去掉，让文字变小一点。只是一个想法。还有，我只用了2组数据，做了二元分类。但是KNN分类器也适用于多类分类器。您可能想要选择更多的组。</p><p id="5736" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">欢迎在推特上关注我，喜欢我的T2脸书页面。</p><h2 id="87e4" class="lu lv jj bd lw lx ly dn lz ma mb dp mc lh md me mf ll mg mh mi lp mj mk ml mm bi translated">更多阅读:</h2><div class="is it gp gr iu ny"><a href="https://pub.towardsai.net/dissecting-1-way-anova-and-ancova-with-examples-in-r-a3a7da83d742" rel="noopener  ugc nofollow" target="_blank"><div class="nz ab fo"><div class="oa ab ob cl cj oc"><h2 class="bd jk gy z fp od fr fs oe fu fw ji bi translated">用R中的例子剖析单向方差分析和协方差分析</h2><div class="of l"><h3 class="bd b gy z fp od fr fs oe fu fw dk translated">通过分析方差得出的均值差异</h3></div><div class="og l"><p class="bd b dl z fp od fr fs oe fu fw dk translated">pub.towardsai.net</p></div></div><div class="oh l"><div class="on l oj ok ol oh om ja ny"/></div></div></a></div><div class="is it gp gr iu ny"><a rel="noopener follow" target="_blank" href="/detailed-guide-to-multiple-linear-regression-model-assessment-and-inference-in-r-146845067aa3"><div class="nz ab fo"><div class="oa ab ob cl cj oc"><h2 class="bd jk gy z fp od fr fs oe fu fw ji bi translated">多元线性回归模型、评估和推理的详细指南</h2><div class="of l"><h3 class="bd b gy z fp od fr fs oe fu fw dk translated">模型开发、解释、方差计算、f检验和t检验</h3></div><div class="og l"><p class="bd b dl z fp od fr fs oe fu fw dk translated">towardsdatascience.com</p></div></div><div class="oh l"><div class="oo l oj ok ol oh om ja ny"/></div></div></a></div><div class="is it gp gr iu ny"><a rel="noopener follow" target="_blank" href="/detail-explanation-of-simple-linear-regression-assessment-and-inference-with-anova-bb12ff4604d3"><div class="nz ab fo"><div class="oa ab ob cl cj oc"><h2 class="bd jk gy z fp od fr fs oe fu fw ji bi translated">简单线性回归的详细解释，评估，和用ANOVA的推断</h2><div class="of l"><h3 class="bd b gy z fp od fr fs oe fu fw dk translated">一步一步的讨论和例子，手动实现和R</h3></div><div class="og l"><p class="bd b dl z fp od fr fs oe fu fw dk translated">towardsdatascience.com</p></div></div><div class="oh l"><div class="op l oj ok ol oh om ja ny"/></div></div></a></div><div class="is it gp gr iu ny"><a href="https://medium.com/codex/complete-details-of-simple-logistic-regression-model-and-inference-in-r-eedb1c84b65f" rel="noopener follow" target="_blank"><div class="nz ab fo"><div class="oa ab ob cl cj oc"><h2 class="bd jk gy z fp od fr fs oe fu fw ji bi translated">R中简单逻辑回归模型和推论的完整细节</h2><div class="of l"><h3 class="bd b gy z fp od fr fs oe fu fw dk translated">举例演示</h3></div><div class="og l"><p class="bd b dl z fp od fr fs oe fu fw dk translated">medium.com</p></div></div><div class="oh l"><div class="oq l oj ok ol oh om ja ny"/></div></div></a></div><div class="is it gp gr iu ny"><a href="https://pub.towardsai.net/a-complete-guide-to-confidence-interval-t-test-and-z-test-in-r-for-data-scientists-cd16dd2d0eec" rel="noopener  ugc nofollow" target="_blank"><div class="nz ab fo"><div class="oa ab ob cl cj oc"><h2 class="bd jk gy z fp od fr fs oe fu fw ji bi translated">数据科学家置信区间、t检验和z检验完全指南</h2><div class="of l"><h3 class="bd b gy z fp od fr fs oe fu fw dk translated">大量的实践练习</h3></div><div class="og l"><p class="bd b dl z fp od fr fs oe fu fw dk translated">pub.towardsai.net</p></div></div><div class="oh l"><div class="or l oj ok ol oh om ja ny"/></div></div></a></div><div class="is it gp gr iu ny"><a rel="noopener follow" target="_blank" href="/a-complete-guide-to-time-series-data-visualization-in-python-da0ddd2cfb01"><div class="nz ab fo"><div class="oa ab ob cl cj oc"><h2 class="bd jk gy z fp od fr fs oe fu fw ji bi translated">Python时序数据可视化完全指南</h2><div class="of l"><h3 class="bd b gy z fp od fr fs oe fu fw dk translated">这应该给你足够的资源来制作时间序列数据的视觉效果</h3></div><div class="og l"><p class="bd b dl z fp od fr fs oe fu fw dk translated">towardsdatascience.com</p></div></div><div class="oh l"><div class="os l oj ok ol oh om ja ny"/></div></div></a></div></div></div>    
</body>
</html>