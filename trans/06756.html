<html>
<head>
<title>Understanding the Fundamentals of Git</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解Git的基础知识</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/understanding-the-fundamentals-of-git-25b5b7ded3c4?source=collection_archive---------12-----------------------#2021-06-18">https://towardsdatascience.com/understanding-the-fundamentals-of-git-25b5b7ded3c4?source=collection_archive---------12-----------------------#2021-06-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/376bdc7f245d0cb344da9088b5bd525f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*DOYlkv1P7bEF9Ydd"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">由<a class="ae jg" href="https://unsplash.com/@synkevych?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Roman Synkevych </a>在<a class="ae jg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><div class=""/><div class=""><h2 id="0bae" class="pw-subtitle-paragraph kg ji jj bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dk translated">理解在幕后操作的各种Git对象</h2></div><p id="dde3" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Git是一个强大的工具，但是它可能会让人不知所措，尤其是对于新手来说。即使对于有经验的开发人员来说，陷入合并或重定基础冲突也是很常见的。即使有大量的博客可用，有时也很难确定原因，最终会浪费我们的生产时间。</p><p id="12f3" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">已经有太多的教程了，但是大部分只是简单地谈论高级用户命令、语法以及如何使用它们，抽象出了大部分内部细节。</p><p id="4d82" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">本文试图揭示Git是如何工作的。但是我们为什么要为此烦恼呢？从头开始了解它是如何工作的对使用命令有很大帮助。因为它不是关于学习命令，而是关于学习概念模型。因此，我们将尝试理解命令是如何工作的，而不是学习一堆命令。一旦我们开始理解它，我们在使用命令时会越来越舒服和自信，最终，我们会开始喜欢它。此外，了解内部情况总有一种极客的快感。有了这些，我们来揭开git的神秘面纱。</p><h2 id="aa88" class="lu lv jj bd lw lx ly dn lz ma mb dp mc lh md me mf ll mg mh mi lp mj mk ml mm bi translated">git——一个愚蠢的内容跟踪器(如man git中所述)</h2><p id="f73f" class="pw-post-body-paragraph ky kz jj la b lb mn kk ld le mo kn lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">在其核心，git是一个简单的键值存储，一个将键映射到值的简单结构，这个结构是持久的，即它存储在我们的磁盘中。这些值只是字节序列。它可以是任何类型的内容，可以是文本文件或二进制文件等。我们可以向git提供一个值，git将为它计算一个惟一的键，稍后可以使用这个键来检索内容。</p><p id="69ea" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">作为演示，我们将使用<code class="fe ms mt mu mv b">hash-object</code>命令，该命令获取一些数据并返回唯一的密钥。由于<code class="fe ms mt mu mv b">hash-object</code>不直接操作字符串数据，我们必须通过管道输入并传递<code class="fe ms mt mu mv b">— stdin</code>标志让<code class="fe ms mt mu mv b">hash-object</code>知道。(<code class="fe ms mt mu mv b">hash-object</code>是管道命令之一，如果你以前没用过完全没问题)</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="c657" class="lu lv jj mv b gy ne nf l ng nh"><strong class="mv jk">$</strong> <strong class="mv jk">echo</strong> "Hello Sarah" <strong class="mv jk">| git hash-object</strong> --stdin<br/>0e170dcd3efae4d183c78dced6c5b9c7e13f70c5</span></pre><p id="0a87" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">上面生成的散列将被用作存储该内容的密钥。它是使用SHA1算法生成的。要深入了解SHA1，可以参考这里的<a class="ae jg" href="https://en.wikipedia.org/wiki/SHA-1" rel="noopener ugc nofollow" target="_blank"/>。需要注意的重要一点是，对于相同的字节序列，我们每次在每个操作系统上都将得到相同的散列。对于两个不同的内容，我们几乎不可能得到相同的散列。</p><p id="fbda" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，git存储库中的每一部分内容都有自己的散列。现在，让我们尝试将这些内容存储在git中，看看它是如何工作的。首先，我们必须初始化一个新的Git存储库:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="79a7" class="lu lv jj mv b gy ne nf l ng nh"><strong class="mv jk">$</strong> <strong class="mv jk">git</strong> <strong class="mv jk">init</strong> test<br/>Initialized empty Git repository in /workdir/test/.git/<br/><strong class="mv jk">$</strong> <strong class="mv jk">cd</strong> test<br/><strong class="mv jk">$</strong> <strong class="mv jk">ls</strong> <strong class="mv jk">-a</strong><br/><strong class="mv jk">.</strong>/    <strong class="mv jk">..</strong>/   <strong class="mv jk">.git</strong>/</span><span id="d145" class="lu lv jj mv b gy ni nf l ng nh"><strong class="mv jk">$</strong> <strong class="mv jk">ls</strong> .git/objects<br/><strong class="mv jk">info</strong>/  <strong class="mv jk">pack</strong>/</span></pre><p id="b250" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，我们有一个<code class="fe ms mt mu mv b">.git</code>目录来保存我们的内容。如果我们检查一下<code class="fe ms mt mu mv b">.git</code>目录，它有一个叫做<code class="fe ms mt mu mv b">objects</code>的子目录，叫做对象数据库。git在这里保存所有用于保存内容、文件、目录等的对象。</p><p id="a09e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">目前，除了作为初始化的一部分创建的<code class="fe ms mt mu mv b">pack</code>和<code class="fe ms mt mu mv b">info</code>子目录之外，没有其他对象。再次使用<code class="fe ms mt mu mv b">hash-object</code>和<code class="fe ms mt mu mv b">-w</code>标志不仅会返回密钥，还会将该对象写入<code class="fe ms mt mu mv b">.git</code>存储。</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="2f26" class="lu lv jj mv b gy ne nf l ng nh"><strong class="mv jk">$</strong> <strong class="mv jk">echo</strong> "Hello Sarah" | <strong class="mv jk">git</strong> <strong class="mv jk">hash-object</strong> <strong class="mv jk">-w --stdin</strong><br/>0e170dcd3efae4d183c78dced6c5b9c7e13f70c5</span><span id="9b10" class="lu lv jj mv b gy ni nf l ng nh"><strong class="mv jk">$</strong> <strong class="mv jk">ls</strong> .git/objects/<br/><strong class="mv jk">0e/   info/ pack/</strong></span><span id="2f66" class="lu lv jj mv b gy ni nf l ng nh"><strong class="mv jk">$</strong> <strong class="mv jk">find</strong> .git/objects <strong class="mv jk">-type</strong> f<br/>.git/objects/0e/170dcd3efae4d183c78dced6c5b9c7e13f70c5</span></pre><p id="b2ba" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以看到，git已经存储了我们的数据。目录由哈希的前两个十六进制数字(<code class="fe ms mt mu mv b">0e</code>)创建。其中存在一个文件，该文件包含哈希的剩余字符。这是git遵循的命名方案。我们原始数据存在于该文件中。这个文件被称为blob数据。</p><p id="47c8" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">blob是一段普通的内容。Git添加了一个小标题，并压缩了这个blob中的原始内容。我们可以用<code class="fe ms mt mu mv b">git cat-file</code>命令检查内容。传递<code class="fe ms mt mu mv b">-t</code>将告诉我们内容的类型，而<code class="fe ms mt mu mv b">-p</code>标志将打印该对象的内容。</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="5048" class="lu lv jj mv b gy ne nf l ng nh"><strong class="mv jk">$</strong> <strong class="mv jk">git cat-file</strong> 0e170dcd3efae4d183c78dced6c5b9c7e13f70c5 <strong class="mv jk">-t</strong><br/>blob<br/><strong class="mv jk">$</strong> <strong class="mv jk">git cat-file</strong> 0e170dcd3efae4d183c78dced6c5b9c7e13f70c5 <strong class="mv jk">-p</strong><br/>Hello Sarah</span></pre><p id="ad9c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，git可以获取任何内容，为其生成一个如散列中所示的键，然后将内容作为blob保存在存储库中。</p><h2 id="a4ae" class="lu lv jj bd lw lx ly dn lz ma mb dp mc lh md me mf ll mg mh mi lp mj mk ml mm bi translated">通过进行第一次提交来了解对象数据库</h2><p id="eedd" class="pw-post-body-paragraph ky kz jj la b lb mn kk ld le mo kn lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">我们现在将稍微深入一下对象数据库。我们将探索git存储的各种类型的对象是什么以及如何存储的。</p><p id="2066" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">git存储的对象主要有3种类型:</p><ul class=""><li id="f8f5" class="nj nk jj la b lb lc le lf lh nl ll nm lp nn lt no np nq nr bi translated"><strong class="la jk"> Blob </strong>:我们上面看到的这个对象存储了原始内容。</li><li id="d6a9" class="nj nk jj la b lb ns le nt lh nu ll nv lp nw lt no np nq nr bi translated">树:这个对象用于存储我们项目中的目录。</li><li id="4d20" class="nj nk jj la b lb ns le nt lh nu ll nv lp nw lt no np nq nr bi translated">提交(Commit):这个对象在每次提交时被创建，并提取这个特定提交的所有信息。</li></ul><p id="74cc" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们创建一个示例项目来深入理解每一个。一个<code class="fe ms mt mu mv b">app</code>项目。在它的根目录下，我们将有一个<code class="fe ms mt mu mv b">README.md</code>文件和一个<code class="fe ms mt mu mv b">src</code>目录。在<code class="fe ms mt mu mv b">src</code>目录中，我们有一个<code class="fe ms mt mu mv b">textfile</code>和<code class="fe ms mt mu mv b">hello_world.py</code>源文件。</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="8178" class="lu lv jj mv b gy ne nf l ng nh"><strong class="mv jk">$ git init</strong> app<br/><strong class="mv jk">$ cd</strong> app<br/><strong class="mv jk">$ echo</strong> "To demonstrate GIT objects" <strong class="mv jk">&gt;</strong> README.md<br/><strong class="mv jk">$ mkdir</strong> src<br/><strong class="mv jk">$ cd</strong> src<br/><strong class="mv jk">$</strong> <strong class="mv jk">echo</strong> "To demonstrate GIT objects" <strong class="mv jk">&gt;</strong> textfile<br/><strong class="mv jk">$</strong> <strong class="mv jk">echo</strong> "print('hello world')" <strong class="mv jk">&gt;</strong> hello_world.py</span><span id="f962" class="lu lv jj mv b gy ni nf l ng nh"><strong class="mv jk">$</strong> <strong class="mv jk">tree</strong> .<br/>.<strong class="mv jk"><br/></strong>├── README.md<br/>└── <strong class="mv jk">src<br/>    </strong>├── hello_world.py<br/>    └── textfile<br/>1 directory, 3 files</span></pre><p id="6b79" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">目前，我们的git存储库没有提交任何东西，所以让我们进行添加这些文件和目录的初始提交。提交完成后，我们将检查<code class="fe ms mt mu mv b">objects</code>目录，查看创建的各种对象。</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="60bf" class="lu lv jj mv b gy ne nf l ng nh"><strong class="mv jk">$</strong> <strong class="mv jk">ls</strong> <strong class="mv jk">-a</strong> .git/objects<br/><strong class="mv jk">./</strong>    <strong class="mv jk">../</strong>   <strong class="mv jk">info/</strong> <strong class="mv jk">pack/</strong></span><span id="92e2" class="lu lv jj mv b gy ni nf l ng nh"><strong class="mv jk">$ git add .</strong></span><span id="df55" class="lu lv jj mv b gy ni nf l ng nh"><strong class="mv jk">$ git status<br/></strong>On branch master</span><span id="241f" class="lu lv jj mv b gy ni nf l ng nh">No commits yet</span><span id="f499" class="lu lv jj mv b gy ni nf l ng nh">Changes to be committed:<br/>(use "git rm --cached &lt;file&gt;..." to unstage)</span><span id="78f1" class="lu lv jj mv b gy ni nf l ng nh">new file:   README.md<br/>new file:   src/hello_world.py<br/>new file:   src/textfile</span><span id="9f37" class="lu lv jj mv b gy ni nf l ng nh"><strong class="mv jk">$ git commit -m "</strong>inital commit, adding README and src dir<strong class="mv jk">"</strong></span><span id="7104" class="lu lv jj mv b gy ni nf l ng nh"><strong class="mv jk">$ git status<br/></strong>On branch master<br/>nothing to commit, working tree clean</span><span id="f4f9" class="lu lv jj mv b gy ni nf l ng nh"><strong class="mv jk">$ git log<br/></strong>commit 67e94955f7d3fffd307d0f070e17d652800b503e (<strong class="mv jk">HEAD -&gt; master</strong>)<br/>inital commit, adding README and src dir</span><span id="82bf" class="lu lv jj mv b gy ni nf l ng nh"><strong class="mv jk">$</strong> <strong class="mv jk">ls</strong> <strong class="mv jk">-a</strong> .git/objects<br/><strong class="mv jk">.</strong>/    <strong class="mv jk">..</strong>/   <strong class="mv jk">17</strong>/   <strong class="mv jk">63</strong>/   <strong class="mv jk">67</strong>/   <strong class="mv jk">75</strong>/   <strong class="mv jk">b9</strong>/   <strong class="mv jk">info</strong>/ <strong class="mv jk">pack</strong>/</span><span id="95e8" class="lu lv jj mv b gy ni nf l ng nh"><strong class="mv jk">$</strong> <strong class="mv jk">find</strong> .git/objects/ <strong class="mv jk">-type</strong> f<br/>.git/objects/67/e94955f7d3fffd307d0f070e17d652800b503e<br/>.git/objects/17/14900a9b496867b319101942b690af9e4d399e<br/>.git/objects/75/d9766db981cf4e8c59be50ff01e574581d43fc<br/>.git/objects/63/03057f97f1cb0222d3e916c3ab471e3c06b9b2<br/>.git/objects/b9/941014e9cc4cb12e3b1283de8846127f96e6d7</span></pre><p id="54dd" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们在提交历史中看到一个提交，但是在<code class="fe ms mt mu mv b">objects</code>目录中，我们看到正在创建各种对象。让我们使用<code class="fe ms mt mu mv b">git cat-file</code>命令逐个检查它们，从<code class="fe ms mt mu mv b">log</code>命令中查看的提交开始。</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="f799" class="lu lv jj mv b gy ne nf l ng nh"><strong class="mv jk">$ git cat-file </strong>67e949<strong class="mv jk"> -t<br/></strong>commit<strong class="mv jk"><br/>$</strong> <strong class="mv jk">git cat-file</strong> 67e949 -p<br/>tree 1714900a9b496867b319101942b690af9e4d399e<br/>author RachitTayal &lt;rachit.tayal@gmail.com&gt; 1624011001 +0530<br/>committer RachitTayal &lt;rachit.tayal@gmail.com&gt; 1624011001 +0530</span><span id="c044" class="lu lv jj mv b gy ni nf l ng nh">inital commit, adding README and src dir</span></pre><p id="ee0e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">正如我们在上面看到的，提交对象包含一段简单而简短的文本。每当进行一次提交(使用<code class="fe ms mt mu mv b">git commit</code>)，git就会生成这个文本，生成它的散列，然后像存储blob一样存储它。提交文本包含关于提交的所有元数据。除了作者、提交者、提交日期之外，它还有树对象的散列。这个提交(<code class="fe ms mt mu mv b">171490</code>)指向项目的根目录。让我们获取这个树对象的内容来进一步理解它。</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="5176" class="lu lv jj mv b gy ne nf l ng nh"><strong class="mv jk">$ git cat-file</strong> 171490 <strong class="mv jk">-t</strong><br/>tree<br/><strong class="mv jk">$ git cat-file</strong> 171490 <strong class="mv jk">-p</strong><br/>100644 <strong class="mv jk">blob</strong> 6303057f97f1cb0222d3e916c3ab471e3c06b9b2 README.md<br/>040000 <strong class="mv jk">tree</strong> b9941014e9cc4cb12e3b1283de8846127f96e6d7 src</span></pre><p id="3545" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">就像提交对象一样，树对象也是一段文本。它包含目录中的内容列表(由哈希表示)。在这种情况下，我们有一个blob和另一棵树以及它们相应的名称。blob是根目录中的<code class="fe ms mt mu mv b">README.md</code>文件，而树是根目录中的<code class="fe ms mt mu mv b">src</code>目录。</p><p id="84cc" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们再次使用<code class="fe ms mt mu mv b">git cat-file</code>来获取blob的内容。</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="ab08" class="lu lv jj mv b gy ne nf l ng nh"><strong class="mv jk">$ git cat-file</strong> 630305 <strong class="mv jk">-t</strong><br/>blob<br/><strong class="mv jk">$ git cat-file</strong> 630305 <strong class="mv jk">-p</strong><br/>To demonstrate GIT objects</span></pre><p id="2973" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，blob的内容与我们的<code class="fe ms mt mu mv b">README.md</code>文件中的内容相同。</p><p id="a626" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">总而言之，提交指向一棵树(表示根)，而这棵树指向一个blob ( <code class="fe ms mt mu mv b">README.md</code>文件)和另一棵树(<code class="fe ms mt mu mv b">src</code>目录)。blob只是存在于<code class="fe ms mt mu mv b">README.md</code>文件中的一段内容。让我们快速检查另一棵树。</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="e079" class="lu lv jj mv b gy ne nf l ng nh"><strong class="mv jk">$ git cat-file</strong> b99410 <strong class="mv jk">-t</strong><br/>tree<br/><strong class="mv jk">$ git cat-file</strong> b99410 <strong class="mv jk">-p</strong><br/>100644 blob 75d9766db981cf4e8c59be50ff01e574581d43fc hello_world.py<br/>100644 blob 6303057f97f1cb0222d3e916c3ab471e3c06b9b2 textfile</span></pre><p id="5d53" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">它有两个斑点。其中一个blobs存储了<code class="fe ms mt mu mv b">hello_world.py</code>文件的内容。而另一个blob存储<code class="fe ms mt mu mv b">textfile</code>的内容。需要注意的重要一点是<code class="fe ms mt mu mv b">textfile</code>和<code class="fe ms mt mu mv b">README.md</code>的blob具有相同的散列，因为两个文件的内容完全相同。因此，git将存储一个blob，而不是为同一个blob创建两个单独的副本。</p><p id="bab1" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">整个对象数据库可以描述如下:</p><figure class="mw mx my mz gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nx"><img src="../Images/5b8d651edb039652604a06e866add796.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*seNMQBn8Dnj0fuXo4Ytqiw.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">提交后对象的快照</p></figure><h2 id="6132" class="lu lv jj bd lw lx ly dn lz ma mb dp mc lh md me mf ll mg mh mi lp mj mk ml mm bi translated">第二次提交</h2><p id="6c07" class="pw-post-body-paragraph ky kz jj la b lb mn kk ld le mo kn lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">现在，让我们在<code class="fe ms mt mu mv b">README.md</code>文件中做一些更改，并进行第二次提交。</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="3d43" class="lu lv jj mv b gy ne nf l ng nh"><strong class="mv jk">$ echo</strong> "Added some change" <strong class="mv jk">&gt;&gt;</strong> README.md<br/><strong class="mv jk">$ git add</strong> README.md<br/><strong class="mv jk">$ git status</strong><br/>On branch master<br/>Changes to be committed:<br/>(use "git reset HEAD &lt;file&gt;..." to unstage)</span><span id="645c" class="lu lv jj mv b gy ni nf l ng nh"><strong class="mv jk">modified:   README.md</strong><br/><strong class="mv jk">$ git commit -m</strong> "updated README"<br/><strong class="mv jk">$ git log</strong><br/>commit 5abd2e3d6903385c2d7f646811f84decd41bcdc7 (<strong class="mv jk">HEAD -&gt; master</strong>)<br/>...<br/>commit 67e94955f7d3fffd307d0f070e17d652800b503e</span></pre><p id="4cc9" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们再次使用<code class="fe ms mt mu mv b">cat-file</code>命令来查看第二次提交的内部。</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="6d69" class="lu lv jj mv b gy ne nf l ng nh">$ <strong class="mv jk">git cat-file</strong> 5abd2e -t<br/>commit<br/>$ <strong class="mv jk">git cat-file</strong> 5abd2e -p<br/><strong class="mv jk">tree</strong> 62da8c3c87d1b7725dbcc4450d5ec25384a7614e<br/><strong class="mv jk">parent</strong> 67e94955f7d3fffd307d0f070e17d652800b503e<br/>author RachitTayal &lt;rachit.tayal@gmail.com&gt; 1624019462 +0530<br/>committer RachitTayal &lt;rachit.tayal@gmail.com&gt; 1624019462 +0530</span><span id="8752" class="lu lv jj mv b gy ni nf l ng nh">updated README</span></pre><p id="e86a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">除了显而易见的字段之外，它还有一个父提交，指向前一个散列的提交。提交以这种方式链接。大多数提交都有一个父级。(异常是第一次提交)。这个提交中存在的树的散列(<code class="fe ms mt mu mv b">62da8c</code>)不同于第一个提交所指向的，这意味着它指向一个新的树。</p><p id="bb0a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">检查新树的内容将得到:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="1802" class="lu lv jj mv b gy ne nf l ng nh">$ <strong class="mv jk">git cat-file</strong> 62da8c -p<br/>100644 blob 5ca3f4ffb43baf06df6e3fcb0a056cc6263cf32f README.md<br/>040000 tree b9941014e9cc4cb12e3b1283de8846127f96e6d7 src</span></pre><p id="77ac" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以看到，它有另一棵树(<code class="fe ms mt mu mv b">src</code>目录)和一个blob ( <code class="fe ms mt mu mv b">README.md</code>)文件。blob不具有与前一次提交相同的散列，因为我们已经对<code class="fe ms mt mu mv b">README.md</code>文件添加了更改。因此创建了新的斑点。</p><p id="f00b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然而，树对象与前一次提交具有相同的散列，因为没有进行任何更改，git将重用前一个树对象。第二次提交后，对象数据库的文件结构如下所示:</p><figure class="mw mx my mz gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ny"><img src="../Images/5b5296f91980fc5b443998faf83f9b7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LlaLxtGLZcCQfatxk3UCTw.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">第二次提交后对象目录的文件结构</p></figure><p id="5c38" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">至此，我们大致了解了git对象模型的工作原理。一旦理解了这一点，理解进一步的复杂操作，如合并、重定基础和分支策略就变得非常直观了。(我们将在下一篇文章中讨论)。</p><h2 id="1541" class="lu lv jj bd lw lx ly dn lz ma mb dp mc lh md me mf ll mg mh mi lp mj mk ml mm bi translated">总结:</h2><p id="2f30" class="pw-post-body-paragraph ky kz jj la b lb mn kk ld le mo kn lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">我们已经看到git是如何基于键值结构进行内容跟踪的。密钥基于SHA1算法生成的哈希。我们已经看到了各种管道命令，如<code class="fe ms mt mu mv b">git hash-object</code>和<code class="fe ms mt mu mv b">git cat-file</code>来分别生成散列和查看目标文件的内容。</p><p id="b73a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">接下来，我们看到了每当我们提交项目时，git对象数据库的幕后发生了什么。它强调了整个git对象模型、存储在git中的各种类型的对象(blobs、tree、commits)以及对象在进一步提交时是如何交织在一起的。这为理解分支和合并相关操作以及各种其他高级概念奠定了基础，我们将在下一篇文章中对此进行讨论。在那之前继续探索。</p></div></div>    
</body>
</html>