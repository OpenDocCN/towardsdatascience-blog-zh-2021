<html>
<head>
<title>Zeno’s Enduring Example</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">芝诺的不朽典范</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/zenos-illustrative-example-bb371b99f25a?source=collection_archive---------19-----------------------#2021-07-30">https://towardsdatascience.com/zenos-illustrative-example-bb371b99f25a?source=collection_archive---------19-----------------------#2021-07-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="36f1" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">2500年后解决了一个争议，现在作为一个参考框架的起源，几何级数是改善数学教育的关键吗？</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/485077cd56f577368bb94999df642a23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KV4QxatULP4b2QCcZlvHAQ.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">以利亚的芝诺展示了通往真理和谬误的大门。马德里<a class="ae kw" href="https://en.wikipedia.org/wiki/El_Escorial" rel="noopener ugc nofollow" target="_blank">埃斯科里亚尔</a>图书馆的壁画。(照片由佩莱格里诺·蒂巴尔迪拍摄——【https://commons.wikimedia.org/w/index.php?curid=8665907】http://web . madritel . es/personales 2/jcdc/presocraticos/pinac 06 _ zenon . htm、公共领域<a class="ae kw" href="https://commons.wikimedia.org/w/index.php?curid=8665907" rel="noopener ugc nofollow" target="_blank"/>)</p></figure><h1 id="5fd5" class="kx ky iq bd kz la lb lc ld le lf lg lh jw li jx lj jz lk ka ll kc lm kd ln lo bi translated">介绍</h1><p id="c96c" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx ly lz ma mb mc md me mf mg mh mi mj mk ij bi translated">2500年前，希腊数学家从一个地方走到另一个地方有一个问题。在身体上，他们能够像我们今天一样行走，甚至可能更好。然而，从逻辑上讲，他们认为每一个无限长的大于零的数字列表的总和都是无穷大。因此，当Elea (约公元前500年)的<a class="ae kw" href="https://en.wikipedia.org/wiki/Zeno_of_Elea" rel="noopener ugc nofollow" target="_blank">芝诺指出，为了从一个地方走到另一个地方，你首先必须走一半的距离，然后你必须走剩余距离的一半，然后你必须走剩余距离的一半，你继续无限次地将剩余距离减半，因为无论剩余距离有多小……你仍然必须走它的前半部分。在他的例子中，Elea的Zeno将一小段步行距离转换成一个无限长的列表，剩余距离减半，所有距离都大于零。这就是问题所在:一个距离怎么能在直接测量时是短的，而在其无穷的一半余数列表上求和时又是无限的呢？这一悖论揭示了当时希腊数学家普遍持有的假设有问题，即每一个无限长的大于零的数字列表的总和为无穷大。</a></p><p id="15ba" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">以利亚悖论的芝诺中使用的级数1/2 + 1/4 + 1/8 + 1/16 + 1/32 + …，现在被称为<a class="ae kw" href="https://en.wikipedia.org/wiki/Geometric_series" rel="noopener ugc nofollow" target="_blank">几何级数</a>，形式为<em class="mq">a</em>+<em class="mq">ar</em>+<em class="mq">ar</em>+<em class="mq">ar</em>+<em class="mq">ar</em>⁴+…，其中<em class="mq"> a </em>被称为<a class="ae kw" href="https://en.wikipedia.org/wiki/Coefficient" rel="noopener ugc nofollow" target="_blank">系数</a>将级数设置为等于总和<em class="mq"> S </em>并使用几何级数<br/><em class="mq">s</em>=<em class="mq">a</em>+<em class="mq">ar</em>+<em class="mq">ar</em>+<em class="mq">ar</em>+<em class="mq">ar</em>⁴+…的规格化形式<br/> <em class="mq"> S </em> / <em class="mq">a</em>= 1+<em class="mq">r</em>+<em class="mq">r</em>+<em class="mq">r</em>+<em class="mq">r</em>⁴+…或其规格化向量形式<br/><em class="mq">s</em>/<em class="mq">a</em>=【1 1 1 1 1 1 1 1……】<em class="mq">r</em>r<em class="mq">r</em><em class="mq">r</em>⁴…]ᵀ或其规格化部分数列 <em class="mq">a</em>= 1+<em class="mq">r</em>+<em class="mq">r</em>+<em class="mq">r</em>+…+<em class="mq">r</em>ⁿ，其中n为部分和<em class="mq"> S </em> ₙ.包含的最后一项的幂(或次数)</p><p id="61a4" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">在这篇文章中，我提出，2500年前解决了希腊数学家争论的那个几何级数现在是改进今天数学教育的关键。根据杰夫·霍金斯在他的书《一千个大脑<strong class="lr ir">—</strong>—<a class="ae kw" href="https://www.amazon.com/Thousand-Brains-New-Theory-Intelligence/dp/B08VWV2WDK/ref=sr_1_1?crid=2B1UXT4G47LB7&amp;keywords=a+thousand+brains&amp;qid=1638991469" rel="noopener ugc nofollow" target="_blank">一种新的智力理论</a>》第88页中的说法，“成为专家主要是为了找到一个好的参考框架来安排事实和观察。”在这篇文章中，几何级数是一个拟议的参考框架的来源，用于安排关于数学知识主体的事实和观察。</p><p id="52d8" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">根据维基百科的说法，短语“知识体”<a class="ae kw" href="https://en.wikipedia.org/wiki/Body_of_knowledge" rel="noopener ugc nofollow" target="_blank">的意思是“组成一个</a><a class="ae kw" href="https://en.wikipedia.org/wiki/Professional" rel="noopener ugc nofollow" target="_blank">专业</a>领域的一整套概念、术语和活动”考虑到数学知识体系涵盖了如此多的概念，很难想象出一个“好的参考框架来安排事实和观察结果”关于数学的“一整套概念、术语和活动”。在这篇文章中，我建议用一个多层建筑的平面图作为类比。具体来说，我为正式称为<a class="ae kw" href="https://en.wikipedia.org/wiki/Examples_of_vector_spaces#Polynomial_vector_spaces" rel="noopener ugc nofollow" target="_blank">多项式向量空间</a>(即所有可能的<a class="ae kw" href="https://en.wikipedia.org/wiki/Polynomial" rel="noopener ugc nofollow" target="_blank">多项式</a>的集合)提出了一个平面图，然后我试图证明这个多项式向量空间应该是数学所有其他层面的底层入口点。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mr"><img src="../Images/299a8b47ed1eb1c86886ac3953da350e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eeUK2xpLi0gaMaU5E3KZcg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">所有多项式函数空间的一个建议参考系。本文描述了标绘项目的列表及其在参考框架中的位置。</p></figure><p id="0074" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">虽然这篇文章关注的是多项式向量空间作为数学知识主体的底层，但是在这个建筑物的类比中，当然还有许多其他的层，每一层都有自己的度量单位来测量距离。例如，也许一个好的二楼可以容纳所有与概率和统计相关的概念。或许<a class="ae kw" href="https://en.wikipedia.org/wiki/Category_theory" rel="noopener ugc nofollow" target="_blank">范畴理论</a>可以用来揭示许多不同楼层之间的相似之处。然而，本文的重点只是多项式向量空间底层，如上图所示，其中对数对数图的原点是几何级数，到其他多项式向量空间界标(例如，复傅立叶级数)的距离是作为远离几何级数的自由度来测量的。</p><p id="013d" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">假设是，提供一个好的数学知识体系的参考框架将显著增加每个人对数学的理解。当然，一个假设需要被检验以使它不仅仅是一个假设。因此，本文的结论提出了检验假设的方法。在得出这个结论之前，这篇文章在提出的参考框架中定位了大约十几个里程碑，偶尔还会提到在<a class="ae kw" href="https://en.wikipedia.org/wiki/Neuroscience" rel="noopener ugc nofollow" target="_blank">神经科学</a>和<a class="ae kw" href="https://en.wikipedia.org/wiki/Psychology" rel="noopener ugc nofollow" target="_blank">心理学</a>领域的发现。为了清楚起见，那些提到神经科学和心理学的地方用斜体表示，并在左边空白处用竖线突出显示，如下所示。</p><blockquote class="ms mt mu"><p id="e3a2" class="lp lq mq lr b ls ml jr lu lv mm ju lx mv mn ma mb mw mo me mf mx mp mi mj mk ij bi translated">杰夫·霍金斯在他的书《一千个大脑<a class="ae kw" href="https://www.amazon.com/Thousand-Brains-New-Theory-Intelligence/dp/B08VWV2WDK/ref=sr_1_1?crid=2B1UXT4G47LB7&amp;keywords=a+thousand+brains&amp;qid=1638991469" rel="noopener ugc nofollow" target="_blank"/><strong class="lr ir">—</strong>—<a class="ae kw" href="https://www.amazon.com/Thousand-Brains-New-Theory-Intelligence/dp/B08VWV2WDK/ref=sr_1_1?crid=2B1UXT4G47LB7&amp;keywords=a+thousand+brains&amp;qid=1638991469" rel="noopener ugc nofollow" target="_blank">一种新的智力理论</a>》的第50页写道，“……我们需要把新大脑皮层看作主要处理参考框架。大部分电路用于创建参考框架和跟踪位置。感官输入当然是必不可少的。正如我将在接下来的章节中解释的那样，大脑通过将感官输入与参照系中的位置相关联来构建世界模型。</p><p id="596c" class="lp lq mq lr b ls ml jr lu lv mm ju lx mv mn ma mb mw mo me mf mx mp mi mj mk ij bi translated">为什么参考系如此重要？大脑从拥有它们中获得了什么？首先，参照系可以让大脑学习某个东西的结构。咖啡杯之所以是一个东西，是因为它是由一组在空间上相对于彼此排列的特征和表面组成的。同样，脸是相对位置排列的鼻子、眼睛和嘴巴。你需要一个参照系来确定物体的相对位置和结构。</p><p id="8bc9" class="lp lq mq lr b ls ml jr lu lv mm ju lx mv mn ma mb mw mo me mf mx mp mi mj mk ij bi translated">第二，通过使用参考系定义一个对象，大脑可以一次性操纵整个对象。例如，一辆汽车有许多相互关联的特征。一旦我们学会了一辆车，我们可以想象它从不同的角度看起来是什么样子，或者在一个维度上被拉伸。为了完成这些壮举，大脑只需旋转或拉伸参考框架，汽车的所有功能都随之旋转和拉伸。</p><p id="12d1" class="lp lq mq lr b ls ml jr lu lv mm ju lx mv mn ma mb mw mo me mf mx mp mi mj mk ij bi translated">第三，需要一个参照系来计划和创造动作。假设我的手指碰到了手机正面，我想按顶部的电源按钮。如果我的大脑知道我手指的当前位置和电源按钮的位置，那么它可以计算出将我的手指从当前位置移动到所需的新位置所需的移动。进行这种计算需要相对于电话的参考系。"</p></blockquote><p id="7bcd" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">除了在数学知识主体的底层表示参考系原点之外，几何级数还可以作为数学中许多不同抽象层的一致介绍，这些抽象层就是本文的结构:</p><ol class=""><li id="c3ac" class="my mz iq lr b ls ml lv mm ly na mc nb mg nc mk nd ne nf ng bi translated">数量，</li><li id="ff80" class="my mz iq lr b ls nh lv ni ly nj mc nk mg nl mk nd ne nf ng bi translated">数字，</li><li id="1f01" class="my mz iq lr b ls nh lv ni ly nj mc nk mg nl mk nd ne nf ng bi translated">代数，</li><li id="2d06" class="my mz iq lr b ls nh lv ni ly nj mc nk mg nl mk nd ne nf ng bi translated">几何学，</li><li id="ec3f" class="my mz iq lr b ls nh lv ni ly nj mc nk mg nl mk nd ne nf ng bi translated">功能，</li><li id="ce42" class="my mz iq lr b ls nh lv ni ly nj mc nk mg nl mk nd ne nf ng bi translated">向量空间，以及</li><li id="7fb9" class="my mz iq lr b ls nh lv ni ly nj mc nk mg nl mk nd ne nf ng bi translated">矩阵指数。</li></ol><p id="f884" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">为了简洁，这篇文章没有说明超过七层的抽象，但是它可以。同样为了简洁，本文中使用的软件是附录中的可选读物。然而，在拉丁谚语<a class="ae kw" href="https://en.wikipedia.org/wiki/Docendo_discimus" rel="noopener ugc nofollow" target="_blank"><strong class="lr ir"><em class="mq">Docendo discimus</em></strong></a>中有很多真理，意思是“通过教学，我们学习”，软件是“教”计算机完成任务的一种形式，经常暴露教师的许多最初被忽视的误解。因此，快速浏览附录可能是一个很好的练习。扩展附录中的代码来“教”你自己的计算机一些新的东西会更好。</p><p id="04eb" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">需要明确的是，我不是数学家、心理学家、教师或神经科学家。然而，作为一名软件工程师，我经常想知道为什么这么多人(包括我自己)觉得数学比其他学科更难学。如果学习数学的相对困难是由于它缺乏一个好的参考框架和/或它的许多抽象层，也许这篇文章提出的平面图类比及其在每个抽象层的介绍中使用几何级数作为一致和熟悉的立足点的方法可能是一个有助于学习数学的一般结构，特别是对于正在形成他们关于数学的心理模型的高中生。</p><p id="1c5b" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">理想情况下，这篇文章将吸引一些真正的数学家、心理学家、教师和神经科学家来测试这篇文章的假设(即，当向学生介绍数学概念时，一贯使用几何级数作为参照系原点将显著提高他们对这些主题的理解)是正确的...或者不是。然而，有历史证据表明持续的重复是有效的。</p><blockquote class="ms mt mu"><p id="5daa" class="lp lq mq lr b ls ml jr lu lv mm ju lx mv mn ma mb mw mo me mf mx mp mi mj mk ij bi translated">维基百科用这些例子描述了<a class="ae kw" href="https://en.wikipedia.org/wiki/Illusory_truth_effect#Examples" rel="noopener ugc nofollow" target="_blank">虚幻的真理效应</a>:“虽然真理效应只是在最近几年才得到科学证明，但它是一种人们已经熟悉了几千年的现象。一项研究指出，罗马政治家<a class="ae kw" href="https://en.wikipedia.org/wiki/Cato_the_Elder" rel="noopener ugc nofollow" target="_blank">卡托</a>在每次演讲结束时都呼吁摧毁<a class="ae kw" href="https://en.wikipedia.org/wiki/Carthage" rel="noopener ugc nofollow" target="_blank">迦太基</a>，他知道重复会产生一致意见，而且<a class="ae kw" href="https://en.wikipedia.org/wiki/Napoleon" rel="noopener ugc nofollow" target="_blank">拿破仑</a>据说“说在修辞学中只有一个非常重要的数字，即重复”，由此重复的肯定在头脑中“以某种方式固定下来，最终被接受为被证明的真理”。其他利用了真相效应的还有<a class="ae kw" href="https://en.wikipedia.org/wiki/Quintilian" rel="noopener ugc nofollow" target="_blank">昆体良</a>、<a class="ae kw" href="https://en.wikipedia.org/wiki/Ronald_Reagan" rel="noopener ugc nofollow" target="_blank">罗纳德里根</a>、<a class="ae kw" href="https://en.wikipedia.org/wiki/Bill_Clinton" rel="noopener ugc nofollow" target="_blank">比尔克林顿</a>、<a class="ae kw" href="https://en.wikipedia.org/wiki/George_W._Bush" rel="noopener ugc nofollow" target="_blank">小布什</a>、<a class="ae kw" href="https://en.wikipedia.org/wiki/Donald_Trump" rel="noopener ugc nofollow" target="_blank">唐纳德川普</a>、<a class="ae kw" href="https://en.wikipedia.org/wiki/Shakespeare" rel="noopener ugc nofollow" target="_blank">莎翁的</a> <a class="ae kw" href="https://en.wikipedia.org/wiki/Julius_Caesar_(play)" rel="noopener ugc nofollow" target="_blank"> <em class="iq">朱利叶斯凯撒</em> </a>中的<a class="ae kw" href="https://en.wikipedia.org/wiki/Marcus_Antonius" rel="noopener ugc nofollow" target="_blank">阿非利加努斯·戈狄亚努斯二世</a>。重复关于产品的毫无根据的说法的广告可能会促进销售，因为一些观众可能会认为他们是从客观的来源听到这些说法的。新闻媒体也使用真相效应，这也是政治宣传的一个主要内容。”</p><p id="c5f1" class="lp lq mq lr b ls ml jr lu lv mm ju lx mv mn ma mb mw mo me mf mx mp mi mj mk ij bi translated">鉴于我们都倾向于相信熟悉的事物(不幸的是，即使这种熟悉是由于重复错误的陈述)，为什么不采用同样的偏见来鼓励数学学生的信心呢？将当前完全不同的数学概念与相同的几何级数联系起来，会增加对不熟悉的数学主题的熟悉程度。</p></blockquote><h1 id="a61a" class="kx ky iq bd kz la lb lc ld le lf lg lh jw li jx lj jz lk ka ll kc lm kd ln lo bi translated">抽象层1:数量</h1><p id="b524" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx ly lz ma mb mc md me mf mg mh mi mj mk ij bi translated">在几何学中，当一个三角形的三个角与另一个三角形的三个角相同时，两个三角形<a class="ae kw" href="https://en.wikipedia.org/wiki/Similarity_(geometry)#Similar_triangles" rel="noopener ugc nofollow" target="_blank">相似</a>。这是通过用某个因子<em class="mq"> w </em>缩放一个三角形的三个边长来计算另一个三角形的边长。因为三角形的面积是<em class="mq"> A </em> = <em class="mq"> bh </em> /2，其中<em class="mq"> A </em>、<em class="mq"> b </em>和<em class="mq"> h </em>分别是三角形的面积、底边和高，所以边长由<em class="mq"> w </em>缩放的三角形的面积是<em class="mq">A</em>=(<em class="mq">WB</em>)(<em class="mq">wh</em>)/2 = .</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nm"><img src="../Images/136254d86a970ae81a2caa80e38bef16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pHrGmR99YWrApP-XP8QW-w.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图一。归一化几何级数(公比r=1/2)的项，显示为重叠相似三角形的面积。最大的三角形(即系列中的第一项)的底边被设置为2，使得代表第一项的三角形的面积等于其高度。</p></figure><p id="f565" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">在本文中，几何级数的每一项都表示为相似三角形的面积。因此，在本文中，一系列相似的三角形都具有相同的三个角，并且具有按公比<em class="mq"> r </em>递增的面积。为了用公比因子<em class="mq"> r </em>来说明相似三角形面积渐进变化，相似三角形的边长必须以因子<strong class="lr ir"> √ </strong> <em class="mq"> r、</em>渐进变化，因为<em class="mq">rA</em>=<em class="mq">rbh</em>/2 =(<em class="mq">WB</em>)(<em class="mq">wh</em>)/2 =<em class="mq">w</em><em class="mq">BH</em>/2</p><p id="a4eb" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">虽然将数量表示为面积(例如，饼图的切片)并不罕见，但将数量表示为部分重叠(或遮挡)的面积却不常见。例如，在图1中，红色大三角形的面积为1(归一化几何级数中第一项的值)，因为三角形的底边是<em class="mq"> b </em> =2，三角形的高度是<em class="mq"> h </em> =1，三角形的面积是<em class="mq"> A </em> = <em class="mq"> bh </em> /2 = 2/2 =1，但只有该区域最右边的1<strong class="lr ir">-</strong><em class="mq">r</em>可见。同样，下一个最大的(绿色)三角形的面积是<em class="mq"> r </em>(几何级数中第二项的值)因为三角形底是2 <strong class="lr ir"> √ </strong> <em class="mq"> r </em>，三角形高是<strong class="lr ir"> √ </strong> <em class="mq"> r </em>，三角形面积是<em class="mq">A</em>=<em class="mq">BH</em>/2 = 2<strong class="lr ir">√</strong><em class="mq">r</em>【t3t继续，下一个最大的(蓝色)三角形的面积是<em class="mq"> r </em>(几何级数中第三项的值)因为三角形底是2 <em class="mq"> r </em>，三角形高是<em class="mq"> r </em>，三角形面积是<em class="mq">A</em>=<em class="mq">BH</em>/2 = 2<em class="mq">RR</em>/2 =<em class="mq">r</em>，但只有最右边的<em class="mq"> r 【T57从最大到最小，每一个连续的几何相似三角形的面积以因子<em class="mq"> r </em>减少，因为三角形的底和高都以因子<strong class="lr ir">√</strong><em class="mq">r</em>减少。同样，面积<em class="mq"> r </em> ⁿ与面积<em class="mq"> r </em> ⁿ⁺的重叠只留下最右边的<em class="mq">r</em>ⁿ<strong class="lr ir"/><em class="mq"/></em></p><p id="551f" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">这篇文章使用重叠的相似三角形面积来表示几何级数项的值，乍一看似乎有些笨拙和不必要。然而，相似三角形的重叠是揭示几何级数的几个几何观点的基础。事实上，作为一个预览，这篇文章的其余部分基本上是关于操作这些重叠的相似三角形:</p><ul class=""><li id="a979" class="my mz iq lr b ls ml lv mm ly na mc nb mg nc mk nn ne nf ng bi translated">改变那些三角形区域的形状(即去除重叠)，</li><li id="18e4" class="my mz iq lr b ls nh lv ni ly nj mc nk mg nl mk nn ne nf ng bi translated">改变这些区域的方向(即，围绕基座旋转)，</li><li id="aca6" class="my mz iq lr b ls nh lv ni ly nj mc nk mg nl mk nn ne nf ng bi translated">改变这些区域的高度(即改变系数)，以及</li><li id="31ed" class="my mz iq lr b ls nh lv ni ly nj mc nk mg nl mk nn ne nf ng bi translated">为这些领域的总和提供了新的视角。</li></ul><blockquote class="ms mt mu"><p id="997c" class="lp lq mq lr b ls ml jr lu lv mm ju lx mv mn ma mb mw mo me mf mx mp mi mj mk ij bi translated">根据Scott Johnson在加州大学洛杉矶分校婴儿实验室的视觉感知发展<a class="ae kw" href="https://www.babylab.ucla.edu/wp-content/uploads/sites/8/2016/09/Johnson2010b.pdf" rel="noopener ugc nofollow" target="_blank"><strong class="lr ir"/></a>中的高级综述，“……新生儿无法感知闭塞，这种闭塞感知在出生后的最初几个月出现。有趣的是，婴儿的所有这些效应都依赖于遮光器后面移动的被遮挡刺激，而不像成年人即使有静态图像也能感知遮挡。”Johnson博士继续在一篇<a class="ae kw" href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC2562345/" rel="noopener ugc nofollow" target="_blank">发展心理学文章</a>中写道“……直到6-8个月之前，还没有观察到静态遮挡显示中的知觉完成。”</p><p id="2fbb" class="lp lq mq lr b ls ml jr lu lv mm ju lx mv mn ma mb mw mo me mf mx mp mi mj mk ij bi translated">尽管这篇文章将几何级数的项表示为部分遮挡区域是不寻常的，但识别现实世界中部分遮挡物体的问题非常重要，足以保证这种能力的早期开发(例如，6-8个月)。</p></blockquote><h1 id="11e1" class="kx ky iq bd kz la lb lc ld le lf lg lh jw li jx lj jz lk ka ll kc lm kd ln lo bi translated">抽象层2:数字</h1><p id="8068" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx ly lz ma mb mc md me mf mg mh mi mj mk ij bi translated">系数为<em class="mq"> a </em> =1/2，公比为<em class="mq"> r </em> =1/2的Elea几何级数的齐诺是数字计算机中<a class="ae kw" href="https://en.wikipedia.org/wiki/Binary_number#Fractions" rel="noopener ugc nofollow" target="_blank">分数</a>的二进制编码<a class="ae kw" href="https://en.wikipedia.org/wiki/Binary_number" rel="noopener ugc nofollow" target="_blank">逼近的基础。具体来说，以其归一化向量形式书写的几何级数是<em class="mq">s</em>/<em class="mq">a</em>=【1 1 1 1 1 1……】【1】r rt20】rt22】r⁴…]ᵀ.保持基函数[1<em class="mq">r r</em>r<em class="mq">r</em>r<em class="mq">r</em>⁴…]ᵀ的列向量不变，但推广行向量[t30】[1 1 1 1 1……]使得每个条目可以是0或1，这允许对任何分数进行近似编码。例如，值<em class="mq"> v </em> = 0.34375被编码为<br/><em class="mq">v</em>/<em class="mq">a</em>=【0 1 0 1 1 0……】【1<em class="mq">r</em><em class="mq">r</em><em class="mq">r</em>⁴<em class="mq">r</em>⁵…]ᵀ其中系数<em class="mq"> a </em> = 1/2，公比<em class="mq">r</em>= 1/1通常，行向量被写成更紧凑的二进制形式<em class="mq"> v </em> = 0.010110，即十进制的0.34375。</a></p><p id="80d1" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">同样，系数<em class="mq"> a </em> =1，公比<em class="mq"> r </em> =2的部分几何级数是数字计算机中二进制编码整数的基础。还是那句话，用其归一化向量形式写成的几何级数是<em class="mq">s</em>/<em class="mq">a</em>=<br/>【1 1 1 1 1 1……】【1】r r<em class="mq">r</em><em class="mq">r</em>⁴…]ᵀ.保持基函数的列向量<br/>【1<em class="mq">r r</em><em class="mq">r</em><em class="mq">r</em>⁴…]ᵀ不变，但是将行向量[1 1 1 1 1 1……]一般化，使得每个条目可以是0或1，从而允许任何整数的编码。例如:值<em class="mq"> v </em> = 151编码为<br/>v/<em class="mq">a</em>=【1 1 1 0 1 0 1 0 0 1 0……】【1<em class="mq">r</em>t31】rt33】r⁴<em class="mq">r</em>⁵<em class="mq">r</em>⁶<em class="mq">r</em>⁷<em class="mq">r</em>⁸…]ᵀ凡通常情况下，行向量以相反的顺序书写(因此最高有效位在前)，采用更紧凑的二进制形式<em class="mq"> v </em> = …010010111 = 10010111，即十进制的151。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi no"><img src="../Images/be8c906623ac3d47d10b6478c2bb5cbd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xqRzFOEN5jnh31toel2gNw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图2a。根据IEEE 754标准对32位浮点数进行编码的位字段。</p></figure><p id="0049" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">如下图所示，32位浮点数字的标准二进制编码是一个二进制编码的整数和一个二进制编码的分数的组合，从最高有效位开始</p><ul class=""><li id="52da" class="my mz iq lr b ls ml lv mm ly na mc nb mg nc mk nn ne nf ng bi translated">符号位，后面是</li><li id="d7fb" class="my mz iq lr b ls nh lv ni ly nj mc nk mg nl mk nn ne nf ng bi translated">8位整数指数字段，假设偏移量为127(因此值127表示指数值为0)，基数为2，表示指数值指定分数字段的位移，其后是</li><li id="264b" class="my mz iq lr b ls nh lv ni ly nj mc nk mg nl mk nn ne nf ng bi translated">一个23位的分数字段，假定但未编码为1，作为分数的最高有效非零位，如果被编码，它将位于第23位。</li></ul><p id="a731" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">基于具有二进制编码0.010110的0.34375的先前示例，浮点编码(根据IEEE 754标准)0.34375是</p><ul class=""><li id="7eeb" class="my mz iq lr b ls ml lv mm ly na mc nb mg nc mk nn ne nf ng bi translated">符号位为0，因为数字不是负数，</li><li id="020b" class="my mz iq lr b ls nh lv ni ly nj mc nk mg nl mk nn ne nf ng bi translated">8位整数指数字段，其必须指定对2位左移进行计数以获得从0.010110到1.0110的原始二进制编码的移位，并且恢复原始二进制编码的计数器移位是由指数值125指定的2位右移(因为125<strong class="lr ir">-</strong>127 =-2是2位右移)，其在二进制中是0111 1101，</li><li id="fcd0" class="my mz iq lr b ls nh lv ni ly nj mc nk mg nl mk nn ne nf ng bi translated">一个23位的分数字段:. 0110 0000 0000 0000 0000 000 000。</li></ul><p id="c676" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">虽然像这样手工编码浮点数是可能的，但让计算机来做更容易，也不容易出错。以下Julia代码确认了数字0.34375的手算浮点编码:</p><pre class="kg kh ki kj gt np nq nr ns aw nt bi"><span id="97ee" class="nu ky iq nq b gy nv nw l nx ny">julia&gt; bitstring(Float32(0.34375))<br/>"00111110101100000000000000000000"</span></pre><p id="5eb3" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated"><a class="ae kw" href="https://en.wikipedia.org/wiki/Decimal#Decimal_fractions" rel="noopener ugc nofollow" target="_blank">具有持续不断的重复模式的十进制分数</a>(例如，0.3333…或0.09090909…或0.12341234…)只能在编码为浮点数时进行近似，但它们总是可以精确地定义为两个整数的比率，并且这些整数可以使用几何级数进行计算。诀窍是使用几何级数的封闭形式即S =<em class="mq">a</em>/(1<strong class="lr ir"/><em class="mq">r</em>)当| <em class="mq"> r </em> | &lt; 1时。几何级数的封闭形式将在本文对抽象层3(代数)的讨论中导出，并在抽象层4(几何)的讨论中再次导出。然而，即使在这些推导之前，你也可以确认s/<em class="mq">a</em>= 1/(1<strong class="lr ir">-t14】r)= 1+<em class="mq">r</em>+<em class="mq">r</em>+<em class="mq">r</em>+<em class="mq">r</em>⁴+…当| <em class="mq"> r </em> | &lt; 1除以1(1<strong class="lr ir">-t28)</strong></strong></p><p id="1da5" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">举个用几何级数确定分子分母的例子，有理数0.3333…可以写成几何级数<em class="mq">S</em>= 0.3+0.3(1/10)+0.3(1/10)+0.3(1/10)+…其中系数<em class="mq"> a </em> = 0.3，公比<em class="mq"> r </em> = 1/10。因此，| <em class="mq"> r </em> | &lt; 1和<em class="mq">S</em>=<em class="mq">a</em>/(1<strong class="lr ir">-</strong>-<em class="mq">r</em>)=(3/10)/(1<strong class="lr ir">-</strong>(1/10))=(3/10)/(9/10)= 3/9 = 1/3 = 0.333…同样，0.09090909…可以写成几何级数S = 0.09+0.09(1/100)+0.09(1/100)+0.09(1/100)+…其中系数<em class="mq"> a </em> = 0.09，公比<em class="mq"> r </em> = 1/100，从而得到闭合形式S =<em class="mq">a</em>/(1<strong class="lr ir">-</strong></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图2b。图1所示的相同几何级数(系数a=1，公比=1/2)，但公比r乘以exp(i <em class="kv"> θ) </em>，导致几何级数(现在是一个复杂的几何级数)的各项以基频的整数倍旋转。(该动画的帧由附录c中列出的Julia代码生成。)</p></figure><p id="ceb0" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">除了能够计算出<a class="ae kw" href="https://en.wikipedia.org/wiki/Rational_number" rel="noopener ugc nofollow" target="_blank">有理数</a>的精确分子和分母，并且是大多数计算机使用的二进制编码的核心，几何级数还有另一个技巧:它的项可以以<a class="ae kw" href="https://en.wikipedia.org/wiki/Harmonic" rel="noopener ugc nofollow" target="_blank">谐波</a>频率旋转。如相邻动画所示，通过设置公比<strong class="lr ir"> <em class="mq"> r </em> </strong>为复数<strong class="lr ir"><em class="mq">r</em></strong>= |<strong class="lr ir"><em class="mq">r</em></strong>|eⁱᶿ，可以将几何级数扩展为<a class="ae kw" href="https://en.wikipedia.org/wiki/Complex_number" rel="noopener ugc nofollow" target="_blank">复数</a>的集合，其中| <strong class="lr ir"> <em class="mq"> r </em> </strong> |为该复数的幅值，θ为其在<a class="ae kw" href="https://en.wikipedia.org/wiki/Complex_plane" rel="noopener ugc nofollow" target="_blank">复平面</a>中的方向角。使公比<em class="mq"> r </em>变得复杂，通过添加一个在图1中指向屏幕外、在图2b中指向上的虚拟数字<a class="ae kw" href="https://en.wikipedia.org/wiki/Imaginary_number" rel="noopener ugc nofollow" target="_blank">的z轴，将图1从二维扩展到三维，从而yz平面是一个复平面。图1所示的量围绕图2b中的x轴旋转。使这种旋转特别有用的是，代表复杂几何级数项的相似三角形区域以不同的速度旋转，具体来说是以某个</a><a class="ae kw" href="https://en.wikipedia.org/wiki/Fundamental_frequency" rel="noopener ugc nofollow" target="_blank">基频</a>的整数倍旋转。每一个复几何级数的所有旋转项之和总是描出一个正圆，只要| <em class="mq"> r </em> | &lt; 1。</p><blockquote class="ms mt mu"><p id="5151" class="lp lq mq lr b ls ml jr lu lv mm ju lx mv mn ma mb mw mo me mf mx mp mi mj mk ij bi translated">人们思考各种各样的话题，从深奥的话题，如编码数字，到对思维机制本身的普遍好奇。在人类大脑中，<a class="ae kw" href="https://en.wikipedia.org/wiki/Neocortex" rel="noopener ugc nofollow" target="_blank">新皮层</a>是<a class="ae kw" href="https://en.wikipedia.org/wiki/Cerebral_cortex" rel="noopener ugc nofollow" target="_blank">大脑皮层</a>最外层和最大的部分，而<a class="ae kw" href="https://en.wikipedia.org/wiki/Cerebrum" rel="noopener ugc nofollow" target="_blank">大脑</a>是大脑最外层和最大的部分。大脑的进化在旧的部分上增加了新的部分，它们都相互影响。按体积计算，新大脑皮层约占人脑的70%。如果拉直，新大脑皮层只有大约2.5毫米(0.10英寸)厚，但它有许多折叠和折痕，可以将更多的自己装入头骨。</p></blockquote><h1 id="531c" class="kx ky iq bd kz la lb lc ld le lf lg lh jw li jx lj jz lk ka ll kc lm kd ln lo bi translated">抽象层3:代数</h1><p id="54c9" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx ly lz ma mb mc md me mf mg mh mi mj mk ij bi translated">除了前面提到的几何级数的规范化形式和部分级数形式之外，封闭形式非常实用，因为它们大大减少了计算级数所需的运算次数。众所周知的几何级数封闭形式的推导减去了许多内部项，如下所示:</p><p id="d289" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">sₙ/<em class="mq">a</em>= 1+<em class="mq">r</em>+<em class="mq">r</em>+<em class="mq">r</em>+…+<em class="mq">r</em>ⁿ⁻+<em class="mq">r</em>ⁿ，<br/><em class="mq">r</em>sₙ/<em class="mq">a</em>=<em class="mq">r</em>+<em class="mq">r</em>+<em class="mq">r</em>+…+<em class="mq">r<em class="mq"> <br/>sₙ/<em class="mq">a</em><strong class="lr ir"/><em class="mq">r</em>sₙ/<em class="mq">a</em>= 1<strong class="lr ir"/><em class="mq">r</em>ⁿ⁺、<br/>(1<strong class="lr ir"/><em class="mq">r</em>)sₙ/<em class="mq">a</em>= 1<strong class="lr ir"/>r</em>ⁿ⁺、<br/>sₙ/<em class="mq">a<em class="mq"> </em></em></em></p><p id="5be6" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">当<em class="mq"> r </em> &lt; 0时，部分级数的内项用加法而不是减法抵消。代入<em class="mq">p</em>=<strong class="lr ir">-</strong>-T76】r-T81】0(其中<em class="mq"> p </em>代表正值)有助于跟踪符号。</p><p id="b9a1" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">sₙ/<em class="mq">a</em>= 1<strong class="lr ir"/><em class="mq">p</em>+<em class="mq">p</em><strong class="lr ir">-</strong><em class="mq">p</em>+…<strong class="lr ir">-</strong>pⁿ⁻+<em class="mq">p</em>ⁿ(n为偶数时)、 <br/><em class="mq">p</em>sₙ/<em class="mq">a</em>=<em class="mq">p</em><strong class="lr ir">—<em class="mq">p</em>+<em class="mq">p</em><strong class="lr ir">—</strong>…+<em class="mq">p</em>ⁿ⁻<strong class="lr ir">—</strong><em class="mq">p</em>ⁿ<em class="mq">+p</em>ⁿ⁺(n为偶数时)<br/> Sₙ/ <em class="mq"> a </em> <br/>sₙ/<em class="mq">a</em>=(1+<em class="mq">p</em>ⁿ⁺)/(1<strong class="lr ir">+</strong><em class="mq">p</em>)(当n为偶数时)<br/>sₙ/<em class="mq">a</em>=(1<strong class="lr ir">-</strong><em class="mq">r</em>ⁿ⁺)/(1<strong class="lr ir">-</strong><em class="mq">r</em>)(图</strong></p><p id="36c0" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">同样的，</p><p id="f774" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">sₙ/<em class="mq">a</em>= 1<strong class="lr ir"/><em class="mq">p</em>+<em class="mq">p</em><strong class="lr ir">-<em class="mq">p</em>+<strong class="lr ir">+</strong><em class="mq">p</em>ⁿ⁻<strong class="lr ir">-</strong><em class="mq">p</em>ⁿ(n为奇数时)、 <br/><em class="mq">p</em>sₙ/<em class="mq">a</em>=<em class="mq">p</em><strong class="lr ir">—</strong>—t101】p+<em class="mq">p</em><strong class="lr ir">—</strong>…<strong class="lr ir">—</strong>—t109】pⁿ⁻<em class="mq">+p</em>ⁿ<strong class="lr ir">—</strong>—t115】p【t111 <br/>sₙ/<em class="mq">a</em>=(1<strong class="lr ir">-</strong><em class="mq">p</em>ⁿ⁺)/(1<strong class="lr ir">+</strong><em class="mq">p</em>)(n为奇数时)，<br/>sₙ/<em class="mq">a</em>=(1<strong class="lr ir">-</strong><em class="mq">r</em>ⁿ⁺)/(1<strong class="lr ir"/></strong></p><p id="9f8a" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">方便地说，sₙ/<em class="mq">a</em>=(1<strong class="lr ir">-</strong>-<em class="mq">r</em>ⁿ⁺)/(1<strong class="lr ir">-</strong>-<em class="mq">r</em>)是相同的结果</p><ul class=""><li id="67ea" class="my mz iq lr b ls ml lv mm ly na mc nb mg nc mk nn ne nf ng bi translated"><em class="mq">r</em>T186】0为偶数或奇数n、</li><li id="24f8" class="my mz iq lr b ls nh lv ni ly nj mc nk mg nl mk nn ne nf ng bi translated"><em class="mq">r</em>T187】0为偶数n，且</li><li id="3a72" class="my mz iq lr b ls nh lv ni ly nj mc nk mg nl mk nn ne nf ng bi translated"><em class="mq">r</em>T188】0为奇数n。</li></ul><p id="0279" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">要将部分和Sₙ/ <em class="mq"> a </em>扩展到全和S/ <em class="mq"> a </em>，请注意，当n趋近于无穷大时，<em class="mq"> r </em> ⁿ⁺趋近于0当且仅当| <em class="mq"> r </em> | &lt; 1。那么，几何级数的封闭形式是</p><p id="d055" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">s/<em class="mq">a</em>= 1/(1<strong class="lr ir">-</strong>-T180】r)<em class="mq">，</em>但仅限于范围| <em class="mq"> r </em> | &lt; 1内。</p><p id="7e7f" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">当公比<em class="mq"> r </em>为复数时，该封闭形式(及其证明)仍然适用。</p><blockquote class="ms mt mu"><p id="451b" class="lp lq mq lr b ls ml jr lu lv mm ju lx mv mn ma mb mw mo me mf mx mp mi mj mk ij bi translated">虽然新皮层约占大脑体积的70%,但另外30%是至关重要的，经常支配你的新皮层。例如，你的大脑皮层可能会说服你屏住呼吸。然而，对大多数人来说，大约一分钟后，脑干的自主呼吸功能就会显示出来，并让你的新大脑皮层停止让你屏住呼吸的想法。</p><p id="d1e1" class="lp lq mq lr b ls ml jr lu lv mm ju lx mv mn ma mb mw mo me mf mx mp mi mj mk ij bi translated"><a class="ae kw" href="https://en.wikipedia.org/wiki/Science%2C_technology%2C_engineering%2C_and_mathematics" rel="noopener ugc nofollow" target="_blank"> STEM </a>老师通常专注于训练学生的新皮层，而忽略了大脑中古老但至关重要的30%部分，它并不是新皮层。相比之下，广告商往往完全关注大脑古老的30%，操纵我们的偏见和情绪，以及我们对不寻常或意想不到的事物的迷恋。因此，大多数广告商比大多数STEM教师更有吸引力。</p></blockquote><h1 id="8b97" class="kx ky iq bd kz la lb lc ld le lf lg lh jw li jx lj jz lk ka ll kc lm kd ln lo bi translated">抽象层4:几何</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/66dbcbd8d72acaefebc3dd9fdab45ef6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1088/format:webp/1*f5dj3J0C8evEqrXIBOwjBw.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图4a。系数a = 4/9，公比r = 1/9的几何级数的几何透视。</p></figure><p id="d5f3" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">从稍微不同的角度观察一个数学问题偶尔会神奇地简化解决方案。比如，系数<em class="mq"> a </em> = 4/9，公比<em class="mq"> r </em> = 1/9的几何级数4/9 + 4/9 + 4/9 + 4/9⁴ + …，从级数的展开形式看，有一个和并不明显。但是，使用代数推导的几何级数闭合形式公式当| <em class="mq"> r </em> | &lt; 1时，4/9 + 4/9 + 4/9 + 4/9⁴ + …之和很容易计算为<br/>s =<em class="mq">a</em>/(1<strong class="lr ir">-</strong><em class="mq">r</em>)=(4/9)/(1–1/9)=(4/9)/(8/9)= 1/2。下图将该几何级数的每一项的值表示为一个紫色正方形的面积，展示了一个使4/9 + 4/9 + 4/9 + 4/9⁴ + …之和更容易计算的透视图。具体地，通过观察单位正方形由无限个L形区域组成，每个区域具有等量的紫色和黄色区域(即，每个L形区域中有4个紫色正方形和4个黄色正方形)，无限个紫色区域的总和必须是单位正方形面积的一半，即1/2(1) = 1/2。尽管图4a的几何透视有助于快速揭示系数为<em class="mq"> a </em> = 4/9且公比为<em class="mq"> r </em> = 1/9的特定几何级数的和，但几何级数闭合形式公式本身的几何透视将有助于可视化每个收敛的几何级数。为此，我们抛开正方形，回到几何级数项的类似三角形面积表示。</p><p id="c96d" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">去除图1所示的相似三角形之间的所有重叠，揭示了接近几何级数闭合形式的几何部分级数的简单几何解释:随着部分级数中的项数接近无穷大，表示级数和的面积接近三角形的面积。具体地说，每一项都可以表示为一个梯形的面积，这些梯形聚集成一个更大的梯形，随着更多项的增加，这个梯形收敛成一个三角形。学习几何级数封闭形式的几何解释有几个好处:</p><ul class=""><li id="44d0" class="my mz iq lr b ls ml lv mm ly na mc nb mg nc mk nn ne nf ng bi translated">梯形转化为三角形是对众所周知的几何级数收敛的代数解释的一种令人耳目一新的几何解释。</li><li id="3e12" class="my mz iq lr b ls nh lv ni ly nj mc nk mg nl mk nn ne nf ng bi translated">能够将聚集梯形末端的收缩三角形尖端视为部分几何级数近似误差(即，s<strong class="lr ir">-</strong>Sₙ，这是部分级数sₙ少于完整级数s的量)也很好。</li><li id="28fd" class="my mz iq lr b ls nh lv ni ly nj mc nk mg nl mk nn ne nf ng bi translated">能够从几何学上解释众所周知的几何级数的封闭形式，就像终于能够将一张脸与一个人的名字联系起来。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oc"><img src="../Images/e0c0288766fb3fc0b9b62a9c712b48ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LLbM7BQ5hTPsKcWuA2Nx3w.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图4b。举例说明0<r/></p></figure><p id="62c5" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">In the adjacent figure, the common ratio is in the range 0&lt;<em class="mq">r</em>T37】1的情况下，几何级数的封闭形式的三步几何证明。这个几何级数封闭形式的几何推导有三个主要步骤:</p><ol class=""><li id="5711" class="my mz iq lr b ls ml lv mm ly na mc nb mg nc mk nd ne nf ng bi translated">(顶部曲线)将<em class="mq"> S </em> ₙ/ <em class="mq"> a </em>的前n+1项表示为重叠的类似直角三角形的区域，如图1所示。</li><li id="0a50" class="my mz iq lr b ls nh lv ni ly nj mc nk mg nl mk nd ne nf ng bi translated">(中间图)按照从大到小的顺序，删除每个三角形的重叠区域，该区域始终是其面积的一小部分<em class="mq"> r </em>，并按1/(1<strong class="lr ir"/><em class="mq">r</em>的比例缩放该三角形的剩余1<strong class="lr ir"/><em class="mq">r</em>非重叠区域，这样以前重叠的三角形的面积(现在是非重叠梯形的面积)保持不变。</li><li id="87a3" class="my mz iq lr b ls nh lv ni ly nj mc nk mg nl mk nd ne nf ng bi translated">(底部绘图)将生成的n+1个非重叠梯形聚合成一个非重叠梯形，并计算其面积。聚合梯形的面积表示部分序列的值。那个面积等于最外面的三角形减去空三角形尖:<br/>sₙ/<em class="mq">a</em>=(1<strong class="lr ir">-</strong>t23】rⁿ⁺)/(1<strong class="lr ir">-</strong>-<em class="mq">r</em>)简化为s/<em class="mq">a</em>= 1/(1<strong class="lr ir">-</strong>r)当n趋近于无穷大时| <em class="mq"> r </em> | 【T38</li></ol><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oc"><img src="../Images/190957bbb3655fa91aff09f71d225b24.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EQJl3uLu1lHxWWo4PqI1sQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图4c。-1<r/></p></figure><p id="8551" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">当公比在范围<strong class="lr ir"/>1&lt;<em class="mq">r</em>&lt;0内时，类似的三角形区域在正负区域之间交替变化，如下图所示。将所有正面积相加得到一个公比为<em class="mq"> r </em>的几何级数。类似地，合计所有负面积也会产生一个具有公比<em class="mq"> r </em>的几何级数，但该级数也会按<em class="mq"> r </em>进行缩放。将针对0&lt;<em class="mq"/>&lt;1的情况导出的S/<em class="mq">a</em>= 1/(1<strong class="lr ir">-</strong>-r)应用于这两个具有公比<em class="mq"> r </em>的几何级数，得到S/<em class="mq">a</em>= 1/(1<strong class="lr ir">-</strong>-T24】r【T25)+<em class="mq">r</em>/(的总面积 =(1<strong class="lr ir">+</strong><em class="mq">r</em>)/(1<strong class="lr ir">-</strong><em class="mq">r</em>)= 1/(1<strong class="lr ir">-</strong><em class="mq">r</em>)对于<strong class="lr ir">-</strong>1&lt;<em class="mq">r</em>&lt;0的情况，与0&lt;<em class="mq">r</em>&lt;1】1的情况结果相匹配。 因此几何推导确认了几何级数的封闭形式的代数推导:<em class="mq">S</em>/<em class="mq">a</em>= 1/(1<strong class="lr ir">-</strong>-T56】r)当| <em class="mq"> r </em> | &lt; 1。顺便说一句，在几何推导中，当| <em class="mq"> r </em> |≥1时，代表部分数列的聚合梯形不再收敛于固定面积三角形。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi od"><img src="../Images/dcf04e93df4bcf282492d9366b5aede8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*mzCBTyq46O4tt5_ZO4jM0A.gif"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图4d。放大收敛的几何级数的项，表示为重叠的相似三角形的面积，或者等价地，非重叠的梯形的面积。</p></figure><p id="7cac" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">如邻图所示，几何级数的项表示为重叠相似三角形的面积，或者等价地，非重叠梯形的面积，放大后具有无限重复的<a class="ae kw" href="https://en.wikipedia.org/wiki/Self-similarity" rel="noopener ugc nofollow" target="_blank">自相似性</a>。换句话说，连续放大表示几何级数项的区域会发现，收敛的几何级数的较小项与较大项具有相同的形状(但比例不同)。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图4e。系数a=1和公比r=eⁱᶿ/2.的复几何级数</p></figure><p id="87d0" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">有了先前的几何证明，即重叠的相似三角形的区域(例如，图1)可以被变换成不重叠的梯形的区域(例如，图4b)，图2b的旋转相似三角形可以被变换成相邻图4d中的旋转梯形。注意，图4d中梯形的高度按0.5的比例缩放，使得旋转梯形符合图2b的相同绘图界限。因此，图4e中旋转梯形的高度实际上是图2b中旋转三角形高度的两倍。当然，旋转三角形和旋转梯形的面积是相同的，因为它们都表示复几何级数的相同项。</p><p id="e0bd" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">随着更多项的增加，图2b中旋转三角形的面积之和以及图4e中旋转梯形的面积之和描绘出更接近于正圆形的形状。<a class="ae kw" href="https://en.wikipedia.org/wiki/Inversive_geometry" rel="noopener ugc nofollow" target="_blank">反演几何</a>是一种优雅的方法，用来展示每个复杂的几何级数，<em class="mq">S</em>/<em class="mq">a</em>= 1/(1<strong class="lr ir">-</strong><em class="mq">r</em>)，当项数接近无穷大，<em class="mq"> r </em>是复数，| <em class="mq"> r </em> | &lt; 1时，都描绘了一个完美的圆。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oe"><img src="../Images/15c2c69be222ac376188e3e253abbc1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3X2nGJJxmB8vv1qrsOUv6g.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图4f。半径为1的反转圆(显示为红色)、以1+i0为中心的半径为1/2的圆(显示为绿色)以及该偏移圆的反转圆(显示为蓝色)的反转几何图。根据反演几何的定义，| OP | | OP ' | = | OQ | | OQ ' | = | OR | | OR ' | = 1。请注意，倒圆中样本的不均匀间距(蓝色所示)与图4c中的动画一致，其中手臂完全伸展时移动最快。</p></figure><p id="fb1e" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">在上图4e中，根据几何级数闭合形式公式，<em class="mq">s</em>/<em class="mq">a</em>= 1/(1<strong class="lr ir">-</strong>)eⁱᶿ/2).分母(即1<strong class="lr ir">—</strong>eⁱᶿ/2)清楚地描绘了一个半径为1/2的圆(下图中显示为绿色圆),当θ从0到2π变化时，该圆以1+i0为中心。逆几何证明那个(绿色)圆的逆也是圆(下图蓝色的圆)。在这种情况下，倒圆就是单位圆(下图中的红色圆)。非正式地说，反转将(红色)反转圆圈的内容翻转过来，</p><ul class=""><li id="980f" class="my mz iq lr b ls ml lv mm ly na mc nb mg nc mk nn ne nf ng bi translated">将红色圆圈外的点(例如，点P)映射到红色圆圈内的点(例如，点P’是点P逆的简称)，</li><li id="65bc" class="my mz iq lr b ls nh lv ni ly nj mc nk mg nl mk nn ne nf ng bi translated">将红色圆圈内的点(例如，点Q)映射到红色圆圈外的点(例如，点Q’是点Q逆的简称)，以及</li><li id="2a79" class="my mz iq lr b ls nh lv ni ly nj mc nk mg nl mk nn ne nf ng bi translated">将红色圆圈上的点(例如，点R)映射到它们自身，</li></ul><p id="4e4a" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">其中映射被约束为| OP | | OP ' | = | OQ | | OQ ' | = | OR | | OR ' | = 1。注意，这个约束是针对反转圆的归一化形式的。一般情况下，约束条件写成| op | | op ' | = | OQ | | OQ ' | = | or | | or ' | =<em class="mq">r</em>ᵢₙᵥ其中<em class="mq"> r </em> ᵢₙᵥ是反演圆的半径。还要注意，圆内反演的映射约束是几何平均的一种形式，可以表示为几何序列的一部分。例如，参考图4f，递增序列|OQ|，<em class="mq"> r </em> ᵢₙᵥ，|OQ'|可以写成<em class="mq"> r </em> ᵢₙᵥ/α，<em class="mq"> r </em> ᵢₙᵥ，α <em class="mq"> r </em> ᵢₙᵥ其中α &gt; 1等于比率|OQ'|/ <em class="mq"> r </em> ᵢₙᵥ，并且是该部分序列中的公比。为了简洁，这篇文章不包括逆几何的定理和证明。总的来说，那些由Kozai和Libeskind的<a class="ae kw" href="http://jwilson.coe.uga.edu/MATH7200/InversionCompanion/inversion/inversionSupplement.pdf" rel="noopener ugc nofollow" target="_blank">这篇论文</a>彻底涵盖的定理和证明，具有反复出现的主题<a class="ae kw" href="https://en.wikipedia.org/wiki/Similarity_(geometry)#Similar_triangles" rel="noopener ugc nofollow" target="_blank">相似三角形</a>和<a class="ae kw" href="https://en.wikipedia.org/wiki/Inscribed_angle" rel="noopener ugc nofollow" target="_blank">内切角</a>。</p><blockquote class="ms mt mu"><p id="b418" class="lp lq mq lr b ls ml jr lu lv mm ju lx mv mn ma mb mw mo me mf mx mp mi mj mk ij bi translated">这篇文章总体上强调几何级数的视觉几何解释，尽管可能有人更喜欢几何级数的代数解释，也可能有人视觉敏锐度较低。杰夫·霍金斯在他的新书《一千个大脑》<strong class="lr ir">—</strong>—<a class="ae kw" href="https://www.amazon.com/Thousand-Brains-New-Theory-Intelligence/dp/B08VWV2WDK/ref=sr_1_1?crid=2B1UXT4G47LB7&amp;keywords=a+thousand+brains&amp;qid=1638991469" rel="noopener ugc nofollow" target="_blank">《智力新理论》</a>第157页中写道:“大脑皮层的大小因人而异。例如，V1区域，主要的视觉区域，在某些人中可能是其他人的两倍大。每个人的V1厚度都是一样的，但是面积，也就是柱子的数量会有所不同。一个V1相对较小的人和一个V1相对较大的人都具有正常的视力，并且两个人都没有意识到这种差异。然而，这是有区别的；V1大的人有更高的敏锐度，这意味着他们能看到小东西。例如，如果你是一名钟表匠，这可能会很有用。”</p><p id="2035" class="lp lq mq lr b ls ml jr lu lv mm ju lx mv mn ma mb mw mo me mf mx mp mi mj mk ij bi translated">即使对于视力很差或没有视力的人来说，重叠的相似三角形转化为不重叠的梯形的概念在学习几何级数时也是一个有用的视角。</p></blockquote><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mr"><img src="../Images/d8b9e3dbb1e63dd077e1a09770d8753c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rA7b9-FqCcYq3e1g_800CA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图4g。数学知识体系的参考框架中的前几点。</p></figure><p id="4bd3" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">现在，我们已经讨论了编码数、几何级数和复几何级数，可以开始填充本文提出的数学知识体系的参考框架了，如下图所示。请注意，封闭形式是系列的约束版本。具体地，几何级数和复杂几何级数的闭合形式都要求| <em class="mq"> r </em> | &lt; 1，并且该图通过在表示级数的圆内绘制表示闭合形式的三角形来指示该约束。该图的图例描述了绘制的四个项目。连同它们标绘的位置，这四个项目在概念上类似于现实世界的地标，我们的大脑通过使用大脑<a class="ae kw" href="https://en.wikipedia.org/wiki/Hippocampus" rel="noopener ugc nofollow" target="_blank">海马</a>中的<a class="ae kw" href="https://en.wikipedia.org/wiki/Place_cell" rel="noopener ugc nofollow" target="_blank">位置细胞</a>来建模。与我们的大脑通过使用大脑<a class="ae kw" href="https://en.wikipedia.org/wiki/Entorhinal_cortex" rel="noopener ugc nofollow" target="_blank">内嗅皮层</a>中的<a class="ae kw" href="https://en.wikipedia.org/wiki/Grid_cell" rel="noopener ugc nofollow" target="_blank">网格细胞</a>来模拟真实世界的距离不同，图4g中的“距离”测量的是自由度。例如，几何级数的公比与复几何级数的公比相隔一个自由度的“距离”，因为几何级数的公比可以是来自实数线的任何数(即一个自由度或D.O.F .)，而复几何级数的公比可以是来自实数线的任何数和来自虚数线的任何数的组合(即两个自由度)。大脑如何模拟一种新型的距离？</p><blockquote class="ms mt mu"><p id="100e" class="lp lq mq lr b ls ml jr lu lv mm ju lx mv mn ma mb mw mo me mf mx mp mi mj mk ij bi translated">在第62页的 <a class="ae kw" href="https://www.amazon.com/Thousand-Brains-New-Theory-Intelligence/dp/B08VWV2WDK/ref=sr_1_1?crid=2B1UXT4G47LB7&amp;keywords=a+thousand+brains&amp;qid=1638991469" rel="noopener ugc nofollow" target="_blank">一千个大脑</a><strong class="lr ir"/><a class="ae kw" href="https://www.amazon.com/Thousand-Brains-New-Theory-Intelligence/dp/B08VWV2WDK/ref=sr_1_1?crid=2B1UXT4G47LB7&amp;keywords=a+thousand+brains&amp;qid=1638991469" rel="noopener ugc nofollow" target="_blank">一种新的智能理论</a>中，杰夫·霍金斯写道，“……为了学习一个事物的完整模型，你需要网格细胞和位置细胞。网格单元创建一个参考框架来指定位置和计划移动。但是您还需要由位置单元表示的感测信息，以便将感测输入与参考系中的位置相关联。</p><p id="0c29" class="lp lq mq lr b ls ml jr lu lv mm ju lx mv mn ma mb mw mo me mf mx mp mi mj mk ij bi translated">新大脑皮层中的映射机制并不是旧大脑中映射机制的精确复制。证据表明，新大脑皮层使用相同的基本神经机制，但在几个方面有所不同。这就好像大自然将海马体和内嗅皮层剥离到最小的形式，复制成千上万份，并将它们并排排列在皮层列中。成为了新大脑皮层。"</p></blockquote><h1 id="85c7" class="kx ky iq bd kz la lb lc ld le lf lg lh jw li jx lj jz lk ka ll kc lm kd ln lo bi translated">抽象层5:函数</h1><p id="fba7" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx ly lz ma mb mc md me mf mg mh mi mj mk ij bi translated">作为对本文到目前为止所涵盖的要点的快速回顾，</p><ul class=""><li id="7962" class="my mz iq lr b ls ml lv mm ly na mc nb mg nc mk nn ne nf ng bi translated">几何级数<em class="mq">a</em>+<em class="mq">ar</em>+<em class="mq">ar</em>+<em class="mq">ar</em>+<em class="mq">ar</em>⁴+…完全由两个参数规定:系数<em class="mq"> a </em>和公比<em class="mq"> r </em>，</li><li id="f498" class="my mz iq lr b ls nh lv ni ly nj mc nk mg nl mk nn ne nf ng bi translated">对于几何透视，几何级数的项可以被绘制为重叠的相似三角形的区域，</li><li id="1ca3" class="my mz iq lr b ls nh lv ni ly nj mc nk mg nl mk nn ne nf ng bi translated">那些重叠的相似三角形可以被转换成不重叠的梯形，当几何级数项的数量增加时，这些不重叠的梯形总体上汇聚成一个三角形，</li><li id="1af6" class="my mz iq lr b ls nh lv ni ly nj mc nk mg nl mk nn ne nf ng bi translated">使公比<em class="mq"> r </em>成为复数以谐波频率旋转复几何级数的项，</li><li id="138f" class="my mz iq lr b ls nh lv ni ly nj mc nk mg nl mk nn ne nf ng bi translated">这些旋转项可被绘制为重叠的相似三角形或围绕其底边旋转的不重叠的梯形，并且</li><li id="8b11" class="my mz iq lr b ls nh lv ni ly nj mc nk mg nl mk nn ne nf ng bi translated">假设| <em class="mq"> r </em> | &lt; 1，当<em class="mq"> r </em>的角度(在复平面中)从0度到360度移动时，表示复几何级数的项的那些有向和旋转面积的总和描绘出一个完美的圆。</li></ul><p id="01dd" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">通过对几何级数的所有这些扩展，系数<em class="mq"> a </em>没有被扩展...直到现在。允许几何级数的每一项的系数独立于其他系数而变化将几何级数变成了一个<a class="ae kw" href="https://en.wikipedia.org/wiki/Power_series" rel="noopener ugc nofollow" target="_blank">幂级数</a>并且可以写成<em class="mq">a</em>₀+<em class="mq">a</em>₁<em class="mq">r</em>+<em class="mq">a</em>₂<em class="mq">r</em>+<em class="mq">a</em>₃<em class="mq">r</em>+<em class="mq">a</em>₄<em class="mq">r</em>⁴+…</p><p id="809d" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">从几何学上讲，幂级数的各项仍然可以被认为是几何级数的重叠的相似三角形或非重叠的梯形，只是现在每一项的面积在高度上按其自己的系数缩放。对于复几何级数的情况，能够改变项系数允许复幂级数描绘比正圆更多的形状。请注意，如果所有项都以相同的速度旋转，即使系数不同，它们的总和仍然会描绘出一个完美的圆，但是，因为这些项以某个基频的整数倍旋转，所以复幂级数可以描绘出更多的圆，但不能描绘出任何任意形状。非正式地说，一个复杂的幂级数所能描绘的形状是蓬松的、云状的，当然包括圆形，当所有的系数都相同时，幂级数又变成了几何级数。</p><p id="7a01" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">需要扩展什么以使复幂级数可以追踪任意形状的问题可以归结为需要扩展什么以使复幂级数可以追踪直线段的问题。答案就在<a class="ae kw" href="https://en.wikipedia.org/wiki/Euler%27s_formula#Relationship_to_trigonometry" rel="noopener ugc nofollow" target="_blank">欧拉公式</a>中:</p><p id="bb3f" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">eⁱᶿ = cosθ + i sinθ，<br/>e⁻ⁱᶿ= cosθ<strong class="lr ir">—</strong>I sinθ，<br/> eⁱᶿ + e⁻ⁱᶿ = 2cosθ，<br/> cosθ = (eⁱᶿ + e⁻ⁱᶿ)/2.</p><p id="cff0" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">从几何学的角度来看，欧拉公式表明，两个相同的反向旋转的矢量之和描绘了一条线段。基本上，反向旋转抵消了复平面中运动的一个维度。移除所有项必须以相同方向旋转的约束以及移除所有项必须以相同方向(或相位)开始旋转的约束，使得复幂级数能够扩展到复傅立叶级数，该复傅立叶级数能够描绘任意二维闭合图形(即，在同一点开始和结束的图形)。</p><p id="78fc" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">代数上把复幂级数<em class="mq">a</em>₀+<em class="mq">a</em>₁<em class="mq">r</em>+<em class="mq">a</em>₂<em class="mq">r</em>+<em class="mq">a</em>₃<em class="mq">r</em>+<em class="mq">a</em>₄<em class="mq">r</em>⁴+…推广到复傅立叶级数f(θ， <strong class="lr ir">c</strong>)=…c₋₄e⁻ⁱ⁴ᶿ+c₋₃e⁻ⁱᶿ+c₋₂e⁻ⁱᶿ+c₋₁e⁻ⁱᶿ+c₀+<em class="mq"/>【c₁eⁱᶿ+c₂eⁱᶿ+<strong class="lr ir"><em class="mq"/></strong>【c₃eⁱᶿ+c】允许项在任一方向上旋转，并允许系数为复数，以便它们可以指定每个项旋转的起始方向或相位。 这些项的和可以写成f(θ，<strong class="lr ir"> C </strong>)来表示一个<a class="ae kw" href="https://en.wikipedia.org/wiki/Function_(mathematics)" rel="noopener ugc nofollow" target="_blank">函数</a> f，它根据旋转变量θ和变量<strong class="lr ir"> C </strong>映射到某个单值，变量<strong class="lr ir">C</strong>是可能的复系数的向量。因为f(θ，<strong class="lr ir"> C </strong>)在变量θ的每一次360度旋转中重复自身，所以f(θ，<strong class="lr ir"> C </strong>)是一个<a class="ae kw" href="https://en.wikipedia.org/wiki/Periodic_function" rel="noopener ugc nofollow" target="_blank">周期函数</a>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi of"><img src="../Images/5782cbf23dddc8f4b6105694c975a6d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uEFDZ8eJFM7hgw8tiCKTsw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图5a。周期T=1的复傅立叶级数方程。上面的等式描述了如何计算复函数f(t ),方法是对在基频的所有谐波(正负)下旋转的无限个复数加权向量求和。下面的等式描述了如何计算这些系数(即复数权重)。</p></figure><p id="a765" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">该复傅立叶级数以稍微不同的符号写在相邻图的顶部等式中。先将复傅立叶级数f(θ，<strong class="lr ir">c</strong>)=…c₋₄e⁻ⁱ⁴ᶿ+c₋₃e⁻ⁱᶿ+c₋₂e⁻ⁱᶿ+c₋₁e⁻ⁱᶿ+c₀+<em class="mq"/>c₁eⁱᶿ+c₂eⁱᶿ+<strong class="lr ir"><em class="mq"/></strong>c₃eⁱᶿ+c‖e‖t+…的展开形式缩短为∑<a class="ae kw" href="https://en.wikipedia.org/wiki/Summation" rel="noopener ugc nofollow" target="_blank">求和</a>记数法。第二，函数的输入是t而不是θ，但是θ等于2π <em class="mq"> f </em> ₀t，并且缩放后的输入对函数的输出没有影响。最后，为了稍微简化函数的<a class="ae kw" href="https://en.wikipedia.org/wiki/Parametrization_(geometry)" rel="noopener ugc nofollow" target="_blank">参数化</a>及其积分，周期t被任意设置为1，这意味着<em class="mq"> f </em> ₀ (=1/T)也是1。通过将展开形式的复傅立叶级数f(t)代入积分，并注意到所有旋转项积分为零，仅留下从时间0到1的常数cₙ的积分，即cₙ.，可以确认图5a的底部方程为真这个<a class="ae kw" href="https://youtu.be/r6sGWTCMz2k?t=991" rel="noopener ugc nofollow" target="_blank"> 3blue1brown视频</a>很好地说明了旋转项积分为零。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图5b。绘制字母“e”(代表指数)的复杂傅立叶级数的动画。附录B包含生成该动画的帧(和音频)的Julia代码列表。</p></figure><p id="aef8" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">作为复傅立叶级数追踪任何二维闭合形状的能力的示例，相邻的动画显示了复傅立叶级数收敛到字母“e”(代表指数)的图形。所有逆时针方向旋转的项，根据右手法则是正方向，聚合成一个右“臂”(延伸右“手”法则解剖学比喻)。类似地，所有顺时针方向旋转的术语都聚合到一个左臂中。右臂端点和左臂端点之和是复傅立叶级数的近似值，如动画中的符号“+”所示。从原点到“+”符号点的中途也是右臂端点和左臂端点之间的中途。双中点被绘制为符号“o ”,就像一只蜘蛛包裹着一个最近的受害者，动画的左臂和右臂围绕着“o”旋转。</p><p id="ccba" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">让两只手臂绘制图5b中的复傅立叶级数似乎是让一只手臂绘制图4e中的复几何级数的自然延伸。如图5b的后平面所示，将许多旋转向量聚集到两个臂中的替代方法是将它们聚集到单个臂中，其中相邻的段以之字形在顺时针旋转和逆时针旋转之间交替。双臂动画提供了一种透视，揭示了协调运动的内在顺序。例如，图5b中动画的参数化以逆时针方向穿过大的内弧，然后以顺时针方向穿过大的外弧。在逆时针方向穿过大的内弧时，左臂(负责顺时针旋转)保持静止。类似地，在顺时针方向穿过大的外弧时，右臂(负责逆时针旋转)保持静止。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi og"><img src="../Images/a3ab468f920aac756c534b0e03fcca9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*aGCDlqfjFCD3rYZbfdN2jA.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图5c。线性最小二乘误差拟合复傅立叶级数系数的幅度的对数，以从复傅立叶级数系数中提取“幻象”公比r。</p></figure><p id="b198" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">尽管复傅立叶级数的双臂动画可能看起来像是复几何级数的单臂动画的自然延伸，但复几何级数具有公比<em class="mq"> r </em>，而复傅立叶级数没有公比(即，在图5a中的复傅立叶级数方程中没有提到公比，并且公比定义了图5b中的旋转梯形区域的形状)。然而，如相邻图所示，通过对复傅立叶级数系数数据执行几何级数模型<em class="mq"> ar </em> ⁿ的最小平方误差拟合，可以计算复傅立叶级数的“虚公比”,不包括指定字母“e”任意位置的常数项的系数。这种扩展的回报是，它使单个3D图能够显示空间数据(字母“e”的轨迹)和频率数据(以不同速度旋转的梯形的高度)以及相位数据(这些旋转梯形的起始方向)的共享上下文。</p><blockquote class="ms mt mu"><p id="2b6d" class="lp lq mq lr b ls ml jr lu lv mm ju lx mv mn ma mb mw mo me mf mx mp mi mj mk ij bi translated">观察图5b中所有错综复杂的协调运动，会惊奇地发现所有的协调都是由图5a中的两个简单方程来解释和定义的。同样，在你的大脑中有许多复杂的协调工作:你的大脑大约有150，000个皮质柱，每个都由数百个“微柱”组成，每个微柱都包含略多于一百个神经元，每个神经元都有数千个，有时是数万个突触连接到其他神经元。然而对于人类大脑来说，我们还没有找到简单的原理来解释和定义这种复杂的协调。</p><p id="5116" class="lp lq mq lr b ls ml jr lu lv mm ju lx mv mn ma mb mw mo me mf mx mp mi mj mk ij bi translated">根据杰夫·霍金斯在他的书《一千个大脑》的第39页所说，“人们常说大脑是宇宙中最复杂的东西。他们由此得出结论，对于它是如何工作的，不会有一个简单的解释，或者说，也许我们永远也不会理解它。科学发现的历史表明他们是错误的。重大发现几乎总是以令人困惑的复杂观察为先导。有了正确的理论框架，复杂性并没有消失，但它似乎不再令人困惑或望而生畏。”</p></blockquote><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mr"><img src="../Images/99a6e36f03a941ddab81fb0624b98c96.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ye7lkgIBp4DGsFr347wu_Q.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图5d。将复傅立叶级数“地标”添加到数学知识主体的建议参考系“景观”中。</p></figure><p id="fab3" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">将复傅立叶级数“landmark”添加到本文提出的数学知识体系的参考框架中，相邻的图显示复傅立叶级数是距离复几何级数4n+1的自由度“距离”,其中n是部分复傅立叶级数中某项的最高幂。4n+1的自由度“距离”是因为复几何级数的系数是从实数行中选取的单个实数(即一个选择自由度)。相比之下，复傅立叶级数有2n+1项:n项正向旋转，n项负向旋转，一项根本不旋转。由于能够为每一项指定任何初始旋转相位，这2n+1项中的每一项都可以具有复系数，从而导致系数选择的2*(2n+1)个自由度。差值为2 *(2n+1)<strong class="lr ir"/>1 = 4n+1。</p><h1 id="363e" class="kx ky iq bd kz la lb lc ld le lf lg lh jw li jx lj jz lk ka ll kc lm kd ln lo bi translated">抽象层6:向量空间</h1><p id="f290" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx ly lz ma mb mc md me mf mg mh mi mj mk ij bi translated">(待办事项)</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oh"><img src="../Images/5d8d0023de8f3616672209d0cf0ec8bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oxZ2NKCL0u1vYFbYrtqPsw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图6a。归一化几何级数的向量形式</p></figure><p id="d069" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">如几何级数的归一化向量形式的邻图所示，列向量的项是与归一化的<a class="ae kw" href="https://en.wikipedia.org/wiki/Geometric_progression" rel="noopener ugc nofollow" target="_blank">几何序列</a>的项相匹配的基函数。与函数非常相似，行向量将多个输入量(列向量条目)映射到单个输出量(总和)。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oi"><img src="../Images/c1aa4775e591bc27e258d38fbf49a6bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0nDcXpjfj3n5uyZ2b03f-A.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图6b。幂级数的向量形式。</p></figure><p id="3474" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">去掉所有系数必须相同的约束，几何级数概括为下图中向量形式所示的幂级数，其中列向量变量从<em class="mq"> r </em>变为<em class="mq"> x </em>，因为该级数不再是具有公比<em class="mq"> r </em>的几何级数。任何多项式函数都可以用列向量中这些基函数的正确线性组合来指定。换句话说，图6b所示级数的函数空间是所有多项式函数的空间。一些函数在这个函数空间中，即使它们不具有多项式函数的典型外观(例如，3 <em class="mq"> x </em> +2 <em class="mq"> x </em> +7)。例如，定义函数eˣ的方法之一是使用多项式函数eˣ = 1 + <em class="mq"> x </em> /1！+ <em class="mq"> x </em> /2！+ <em class="mq"> x </em> /3！+ <em class="mq"> x </em> ⁴/4！+ … .然而，许多函数(例如，sin(x))不在该函数空间中，并且只能由多项式函数来近似。因此可能存在两个维度的近似:第一个维度是近似整个序列s的部分序列Sₙ，第二个维度是近似实际函数f的多项式函数空间(<em class="mq"> x </em>)。泰勒级数通过定义如何设置幂级数的系数以使多项式函数逼近实际函数f(x)来处理第二维近似。</p><p id="f5f7" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">要计算一个函数的泰勒级数系数，首先用多项式f(<em class="mq">x</em>)≈<em class="mq">c</em>₀+<em class="mq">c</em>₁<em class="mq">x</em>+<em class="mq">c</em>₂<em class="mq">x</em>+<em class="mq">c</em>₃<em class="mq">x</em>+…)的展开形式来逼近该函数，并设置<em class="mq"> x </em> =0来确定<em class="mq"> c 【T19然后取一阶导数f⁽⁾(<em class="mq">x</em>)≈<em class="mq">c</em>₁+2<em class="mq">c</em>₂<em class="mq">x</em>+3<em class="mq">c</em>₃<em class="mq">x</em>+…，设<em class="mq"> x </em> =0确定<em class="mq"> c </em> ₁≈f⁽ ⁾(0).然后取二阶导数f⁽⁾(<em class="mq">x</em>)≈2<em class="mq">c</em>₂+3！<em class="mq"> c </em> ₃ <em class="mq"> x </em> + …，设置<em class="mq"> x </em> =0来确定<em class="mq"> c </em> ₂≈f⁽ ⁾(0)/2.然后取三阶导数f⁽ ⁾( <em class="mq"> x </em> ) ≈ 3！<em class="mq"> c </em> ₃ + 4！<em class="mq"> c </em> ₄ <em class="mq"> x </em> …，设置<em class="mq"> x </em> =0确定<em class="mq"> c </em> ₃≈f⁽ ⁾(0)/3！。然后取四阶导数f⁽⁴⁾( <em class="mq"> x </em> ) ≈ 4！<em class="mq">₄+5！<em class="mq"> c </em> ₅ <em class="mq"> x </em> …，设置<em class="mq"> x </em> =0确定<em class="mq"> c </em> ₄≈f⁽⁴⁾(0)/4！。假设函数f(x)足够平滑，以使导数存在，以这种方式继续到k阶导数，以确定<em class="mq"> c </em> ₖ ≈ f⁽ᵏ⁾(0)/k！这是泰勒级数系数公式，用于逼近以<em class="mq"> x </em> =0为中心的f( <em class="mq"> x </em>)的一部分。</em></em></p><p id="e9f3" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">从技术上讲，这些系数被称为Maclaurin级数系数，因为它们近似f( <em class="mq"> x </em>)的一部分，该部分以<em class="mq"> x </em> =0为中心。很快，近似的中心点将移动到<em class="mq"> x </em> ₀，这些系数将被恰当地称为泰勒级数系数。但在此之前，以下是推导这些马克劳林级数系数的另一种方法。替代方法证明了导数和积分是多项式函数(即行向量中的系数)上的线性算子(即矩阵乘数)。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oj"><img src="../Images/fb94dda3f4880188cced7e15f003b955.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uKfe5nd46QOgJ501XRbwiQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图6c。导数d和反导数D⁻的幂级数和线性算子的向量形式。将eˣ的系数乘以d，以确认结果与eˣ.的系数相同，这是一项很有意义的工作</p></figure><p id="d47d" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">下图中最上面的等式显示了线性运算符L如何乘以行向量中的系数。接下来的两个方程是导数矩阵d和反导数矩阵D⁻。线性算子l可以是d，或者可以是D⁻，或者可以是它们或其他线性算子的某种组合。例如，L = D⁻ D = I是单位矩阵。当然，L = DD = D是二阶导数，L = D⁻ D⁻ = D⁻是二阶反导数，通常称为二阶积分。请注意，不定整数常数的生成是行向量前加1、列向量前加0的原因。还要注意，冒着引起混淆的风险，但按照惯例，不定积分常数用大写字母C表示，幂级数系数用小写字母C表示。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ok"><img src="../Images/6df0cdfeb3cd6177d365ac6349a3716e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BZNf6Tp9fXxZwW9TwgxkVg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图6d。几种导数的线性算子的向量形式。</p></figure><p id="cf06" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">类似于前面所示的Maclaurin级数系数的推导，从用幂级数的展开形式近似的函数开始，下面的矢量形式推导也是计算导数的练习。相邻图像中显示了几个导数运算符，它们是矩阵乘法的结果。将图6c的上等式中带有前缀1的行向量称为<strong class="lr ir"> R </strong>，将带有前缀0的列向量称为<strong class="lr ir"> X </strong>，Maclaurin级数系数的向量求导的起点是近似f( <em class="mq"> x </em> )≈ <strong class="lr ir"> RX </strong>，在<em class="mq"> x </em> =0处计算得到c₀≈f(0).一阶导数f⁽ ⁾( <em class="mq"> x </em> )≈ <strong class="lr ir"> RDX </strong>在<em class="mq"> x </em> =0处计算得出<em class="mq"> c </em> ₁≈f⁽ ⁾(0).二阶导数f⁽⁾(<em class="mq">x</em>)≈<strong class="lr ir">rd</strong><strong class="lr ir">x</strong>在<em class="mq"> x </em> =0处计算得出<em class="mq"> c </em> ₂≈f⁽ ⁾(0)/2.三阶导数f⁽⁾(<em class="mq">x</em>)≈<strong class="lr ir">rd</strong><strong class="lr ir">x</strong>在<em class="mq"> x </em> =0处求值得出<em class="mq"> c </em> ₃≈f⁽ ⁾(0)/6=f⁽ ⁾(0)/3！。四阶导数f⁽⁴⁾(<em class="mq">x</em>)≈<strong class="lr ir">rd</strong>⁴<strong class="lr ir">x</strong>在<em class="mq"> x </em> =0处求值得到<em class="mq">c</em>₄≈f⁽⁴⁾(0)/24=f⁽⁴⁾(0)/4！。再一次，假设函数f(x)足够平滑以至于导数存在，以这种方式继续到第k阶导数f⁽ᵏ⁾(<em class="mq">x</em>)≈<strong class="lr ir">rd</strong>ᵏ<strong class="lr ir">x</strong>以确定<em class="mq"> c </em> ₖ≈f⁽ᵏ⁾(0)/k！在<em class="mq"> x </em> =0时进行评估。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ol"><img src="../Images/d63b6f7003ae9d0a4da9c9013ffbd023.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nZILUa9CBHJYuHfjgaGM0Q.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图6e。关于点x= <em class="kv"> x </em> ₀.的泰勒级数近似的向量形式</p></figure><p id="348b" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">为了近似f(x)的一部分，而不是以<em class="mq"> x </em> = <em class="mq"> x </em> ₀为中心，定义一个新的函数g( <em class="mq"> x </em>，它等价于f( <em class="mq"> x </em>)，但是沿着<em class="mq"> x </em>轴移动，使得它的原点在f(<em class="mq">x</em>=<em class="mq">x</em>₀): g(<em class="mq">x</em>)= f(<em class="mq">x</em>+重复现在熟悉的计算多项式导数的练习，但是现在对于g( <em class="mq"> x </em>)，结果是cₖ≈g⁽ᵏ⁾(0)/k！但是g(0)=f( <em class="mq"> x </em> ₀)所以cₖ≈f⁽ᵏ⁾( <em class="mq"> x </em> ₀)/k！。与Maclaurin级数一样，泰勒级数中的多项式变量是距近似值中心点的距离，但是由于中心点向<em class="mq"> x </em> = <em class="mq"> x </em> ₀的移动，泰勒级数距中心点的距离是<em class="mq">x</em><strong class="lr ir">-</strong><em class="mq">x</em>₀，而不是<em class="mq"> x </em>。因此，矢量形式的泰勒级数近似是图6e中的方程。</p><p id="2b7f" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">(2021年12月11日注:这篇文章的其余部分正在变化，我希望在这个月的某个时候完成编辑……在今年年底。)</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="om oa l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图4c。收敛到封闭形式的几何级数。</p></figure><p id="e592" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">虽然几何级数的闭合形式(即<em class="mq">S</em>/<em class="mq">a</em>= 1/(1<strong class="lr ir">-</strong>-<em class="mq">r</em>)可以用代数和几何推导，但几何推导提供了收敛速度随公比<em class="mq"> r </em>变化的更好视角。下图中的动画显示了五个归一化的几何级数(公比<em class="mq">r</em>=<strong class="lr ir">-</strong>0.74，0.37，0，0.37，0.74)随着部分级数中项数的增加而收敛到闭合形式。不出所料，公比<em class="mq"> r </em> =0的几何级数只需要一项就能收敛。正如所料，梯形随着| <em class="mq"> r </em> |的增加而变细，这增加了收敛所需的项数。然而，鉴于动画中青色曲线<em class="mq">S</em>/<em class="mq">a</em>= 1/(1<strong class="lr ir">-</strong>-T24】r)的不对称性，关于收敛速度的<em class="mq"> r </em> =0的完美对称可能会令人惊讶。代数上，(s<strong class="lr ir">-</strong>sₙ)/s =<em class="mq">r</em>ⁿ⁺，当n是奇数时，不管<em class="mq"> r </em>的符号是什么，都是一样的。一种思考方式是，在接近<em class="mq"> r </em> =1时，这些项(幅度均小于1)构成一个无穷大的和，而在接近<em class="mq">r</em>=<strong class="lr ir">-</strong>1时，这些项(幅度也均小于1)构成一个无穷大的斜率。在n值较大的动画中，Sₙ/ <em class="mq"> a </em>太大，在<em class="mq"> r </em> =1附近不可见，但在<em class="mq">r</em>=<strong class="lr ir">-</strong>1 sₙ/<em class="mq">a</em>附近继续可见，您可以看到小尾巴来回翻转，越来越接近无限斜坡。</p><p id="fe25" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">尽管行向量乘以列向量形式的求和(例如，图6a)暗示了向量空间，并且具有无限数量的基函数的向量空间(例如，所有多项式函数的空间)比仅具有几个数字的基向量的向量空间稍微神秘一些，但是向量空间的固有神秘是由于定义根本没有指定任何特定的基。相反，向量空间需要满足八个公理:</p><ol class=""><li id="b22d" class="my mz iq lr b ls ml lv mm ly na mc nb mg nc mk nd ne nf ng bi translated">向量加法是结合式的(例如<strong class="lr ir">u</strong>+(<strong class="lr ir">v</strong>+<strong class="lr ir">w</strong>)=(<strong class="lr ir">u</strong>+<strong class="lr ir">v</strong>)+<strong class="lr ir">w</strong>)，</li><li id="e0d0" class="my mz iq lr b ls nh lv ni ly nj mc nk mg nl mk nd ne nf ng bi translated">向量加法是可交换的(如<strong class="lr ir">u</strong>+<strong class="lr ir">v</strong>=<strong class="lr ir">v</strong>+<strong class="lr ir">u</strong>)，</li><li id="16aa" class="my mz iq lr b ls nh lv ni ly nj mc nk mg nl mk nd ne nf ng bi translated">向量加法有单位元(如<strong class="lr ir">v</strong>+<strong class="lr ir">0</strong>=<strong class="lr ir">v</strong>)，</li><li id="06ea" class="my mz iq lr b ls nh lv ni ly nj mc nk mg nl mk nd ne nf ng bi translated">向量加法具有逆元素(例如，<strong class="lr ir">v</strong>+(<strong class="lr ir">v</strong>)=<strong class="lr ir">0</strong>)，</li><li id="dc53" class="my mz iq lr b ls nh lv ni ly nj mc nk mg nl mk nd ne nf ng bi translated">标量和场乘法兼容(例如，<em class="mq">a</em>(<em class="mq">b</em>v)=(<em class="mq">ab</em>)<strong class="lr ir">v</strong>)，</li><li id="d4e1" class="my mz iq lr b ls nh lv ni ly nj mc nk mg nl mk nd ne nf ng bi translated">标量乘法有单位元(如1 <strong class="lr ir"> v </strong> = <strong class="lr ir"> v </strong>)，</li><li id="1888" class="my mz iq lr b ls nh lv ni ly nj mc nk mg nl mk nd ne nf ng bi translated">标量乘法相对于向量加法是分布式的(例如，<em class="mq">a</em>(<strong class="lr ir">u</strong>+<strong class="lr ir">v</strong>)=<em class="mq">a</em><strong class="lr ir">u</strong>+<em class="mq">a</em><strong class="lr ir">v</strong>)，</li><li id="77e6" class="my mz iq lr b ls nh lv ni ly nj mc nk mg nl mk nd ne nf ng bi translated">标量乘法相对于场加法是分布式的(例如，(<em class="mq">a</em>+<em class="mq">b</em>)<strong class="lr ir">v</strong>=<em class="mq">a</em><strong class="lr ir">v</strong>+<em class="mq">b</em><strong class="lr ir">v</strong>)。</li></ol><p id="6985" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">作为大量可能的向量空间的一个例子，我目前正试图设计一个类别向量空间，作为一种新型字典的一部分。现在判断这次尝试是否会成功还为时过早。</p><blockquote class="ms mt mu"><p id="e3e7" class="lp lq mq lr b ls ml jr lu lv mm ju lx mv mn ma mb mw mo me mf mx mp mi mj mk ij bi translated">根据杰夫·霍金斯在他的书《一千个大脑》第88页中的说法，“成为专家主要是为了找到一个好的参考框架来安排事实和观察。阿尔伯特·爱因斯坦从和他同时代的人一样的事实出发。然而，他发现了一种更好的方法来排列它们，一种更好的参考框架，这使他能够看到相似之处并做出令人惊讶的预测。爱因斯坦与狭义相对论有关的发现最吸引人的是，他用来制作这些发现的参照系是日常用品。他想到了火车、人和手电筒。他从科学家的经验观察入手，比如绝对光速，用日常参考系推导狭义相对论的方程。正因为如此，几乎任何人都可以遵循他的逻辑，理解他是如何做出发现的。相比之下，爱因斯坦的广义相对论需要基于称为场方程的数学概念的参考系，而场方程不容易与日常物体联系起来。爱因斯坦和几乎所有其他人一样，觉得这很难理解。”</p></blockquote><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mr"><img src="../Images/4962a69ceb6ddcd626adc782ba18e49c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZPgpBfoRKXnE8IIZ9_si3w.png"/></div></div></figure><h1 id="e004" class="kx ky iq bd kz la lb lc ld le lf lg lh jw li jx lj jz lk ka ll kc lm kd ln lo bi translated">抽象层7:矩阵指数</h1><p id="8b7f" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx ly lz ma mb mc md me mf mg mh mi mj mk ij bi translated">(待办事项)</p><h1 id="1002" class="kx ky iq bd kz la lb lc ld le lf lg lh jw li jx lj jz lk ka ll kc lm kd ln lo bi translated">结论</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mr"><img src="../Images/299a8b47ed1eb1c86886ac3953da350e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eeUK2xpLi0gaMaU5E3KZcg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图8。展示数学知识体系参考框架的课堂海报。教师可能希望在海报上找到当前的课程，在便利贴上有一个“我们在这里”的箭头。</p></figure><p id="2a22" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">在1974年加州理工学院<a class="ae kw" href="https://calteches.library.caltech.edu/3043/1/CargoCult.pdf" rel="noopener ugc nofollow" target="_blank">的毕业典礼演讲</a>，<a class="ae kw" href="https://en.wikipedia.org/wiki/Richard_Feynman" rel="noopener ugc nofollow" target="_blank">理查德·费曼</a>(1965年诺贝尔物理学奖获得者)谈到了<a class="ae kw" href="https://en.wikipedia.org/wiki/Cargo_cult_science" rel="noopener ugc nofollow" target="_blank">货物邪教科学</a>，他用这个短语来描述一个关于伪科学的故事。<strong class="lr ir">“在南海有一群崇拜货物的人。在战争期间，他们看到飞机带着许多好材料着陆，他们希望同样的事情现在也能发生。所以他们安排做一些像跑道一样的东西，沿着跑道边生火，做一个供一个人坐的木头小屋，在他的头上有两个像耳机一样的木头，竹条像天线一样伸出来——他是控制器——他们等待飞机着陆。他们做得很好。形式很完美。它看起来和以前一模一样。但是不管用。没有飞机降落。所以我称这些东西为货物崇拜科学，因为它们遵循所有明显的规则和科学调查的形式，但它们遗漏了一些本质的东西，因为飞机没有着陆。</strong></p><p id="b897" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated"><strong class="lr ir">[……]我注意到货物崇拜科学中有一个普遍缺失的特征。[……]这是一种科学的完整性，一种与完全诚实相对应的科学思想原则——一种向后倾斜。例如，如果你正在做一个实验，你应该报告你认为可能使它无效的所有事情——不仅仅是你认为它是正确的:可能解释你的结果的其他原因；以及你认为已经通过其他实验消除的东西，以及它们是如何工作的——确保其他人能够知道它们已经被消除了。</strong></p><p id="d707" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">如果你知道的话，必须给出可能会对你的解释产生怀疑的细节。你必须尽你所能——如果你知道任何事情是错误的，或者可能是错误的——去解释它。例如，如果你提出一个理论，并宣传它，或者把它公布于众，那么你也必须写下所有不同意它的事实，以及同意它的事实。”</p><p id="03a3" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">“但后来我开始想，我们还相信什么？(然后我想到了巫医，通过发现没有任何东西真正起作用来检查他们是多么容易。)所以我发现了更多人相信的东西，比如我们有一些如何教育的知识。阅读方法和数学方法有很大的流派，等等，但是如果你注意的话，你会发现阅读分数一直在下降——或者几乎没有上升——尽管事实上我们一直在用同样的人来改进方法。[…] </p><p id="1654" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated"><strong class="lr ir">然而这些东西据说是科学的。我们研究它们。而且我觉得有常识性想法的普通人都被这种伪科学吓倒了。一个对如何教她的孩子阅读有一些好主意的老师被学校系统强迫用其他方法去做——或者甚至被学校系统愚弄，认为她的方法不一定是好方法。”</strong></p><p id="8af3" class="pw-post-body-paragraph lp lq iq lr b ls ml jr lu lv mm ju lx ly mn ma mb mc mo me mf mg mp mi mj mk ij bi translated">在这篇文章中，我提出了一个让数学更容易学习的方法。这个方法可能好，也可能不好。鉴于我们甚至还不了解大脑，每一项教育改进的提议都应该受到质疑。那么，如何测试这种提议的方法，以证明它确实有效，而不是又一个货物崇拜科学的例子呢？我认为调查它有两个要求:</p><ol class=""><li id="8932" class="my mz iq lr b ls ml lv mm ly na mc nb mg nc mk nd ne nf ng bi translated"><strong class="lr ir">不干涉。</strong>让参与调查的数学教师选择是否使用所提出的方法。提供一张大海报，展示数学知识体系的参考地图，张贴在教室的一侧，远离教师通常在课堂上讲话的地方。每当老师站在偏僻的海报旁边，智能手机就会自动录制被转录的视频。</li><li id="c791" class="my mz iq lr b ls nh lv ni ly nj mc nk mg nl mk nd ne nf ng bi translated"><strong class="lr ir">说明人的可变性。学生的能力范围很广。老师也是。为了建立教师和学生能力的统计基线，只有在同一所学校的同一个班级有至少五年教学经验的教师才应被纳入调查。然后将学生数学考试成绩的变化与建议参考图的参考数量(在转录的视频中)相关联。换句话说，拟议的调查将生成一个剂量反应图，就像药物调查一样，但这里的剂量是对拟议参考图的参考，而反应是数学测试的分数。</strong></li></ol><h1 id="b4ad" class="kx ky iq bd kz la lb lc ld le lf lg lh jw li jx lj jz lk ka ll kc lm kd ln lo bi translated">附录</h1><p id="0992" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx ly lz ma mb mc md me mf mg mh mi mj mk ij bi translated">编写或探索实现数学概念的算法通常会导致对该概念的更好理解。下面的附录列出了生成本文中的图形和动画帧的源代码。我最初使用GNU Octave来生成动画帧，源代码在附录a中。但是，为了利用其最先进的LLVM编译器的效率，该编译器生成动画帧的速度提高了四倍(例如，30分钟而不是120分钟)， 我将GNU Octave应用程序移植到Julia，用于生成复杂傅立叶级数动画帧的Julia源代码(使用Julia版本1.7.0测试)在附录b中。用于生成复杂几何级数动画帧的Julia源代码在附录c中。将复杂傅立叶级数动画帧生成分配到六个CPU内核的小Julia代码片段在附录d中。(这种并行处理将生成动画帧的时间减少到11.1分钟，是GNU Octave生成类似动画帧所用时间的十分之一。 )用于生成各种图(例如，几何级数自相似动画和数学知识体系的参考框架的图形)的Julia源代码在附录e中。用于生成二次和三次贝塞尔曲线的动画的Julia源代码在附录f中。</p><h2 id="e4ab" class="nu ky iq bd kz on oo dn ld op oq dp lh ly or os lj mc ot ou ll mg ov ow ln ox bi translated">附录A. GNU Octave源代码</h2><p id="538c" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx ly lz ma mb mc md me mf mg mh mi mj mk ij bi translated">下面的GNU Octave代码为字母“e”的复傅立叶级数绘制动画生成帧。</p><pre class="kg kh ki kj gt np nq nr ns aw nt bi"><span id="0289" class="nu ky iq nq b gy nv nw l nx ny">% define some plotting parameters <br/>nT = 801    % number of Time samples<br/>nTM = nT - 1;   % number of Time sample Midpoints<br/>T = linspace(0, 1, nT); % Time samples<br/>nT4 = nTM/4;<br/>dT = 1/nTM;    % difference between Time samples<br/>TM = T(1:end-1) + dT/2; % Time sample Midpoints<br/>THETAM = 2*pi*TM;  % angle samples<br/>XZ = zeros(1,nT);  % X Zeros<br/>CT = ['r'; 'g'; 'b'; 'y'; 'w'; 'k']; % Color Table</span><span id="9fd4" class="nu ky iq nq b gy oy nw l nx ny">trapScale = 0.5;  % trapezoid scale<br/>dCross = 0.15;   % diameter of '+' cross-hair<br/>yOffset = 0.5;   % y offset of F(t)<br/>nAng = 15;<br/>ANGDOT = linspace(0,2*pi,nAng);<br/>XDOT = zeros(1,nAng);<br/>YDOT = dCross/pi*cos(ANGDOT); <br/>ZDOT = dCross/pi*sin(ANGDOT);</span><span id="d575" class="nu ky iq nq b gy oy nw l nx ny">% define parameterized trapezoid<br/>wChar = 0.1; <br/>rInner = 0.5;<br/>rOuter = rInner+wChar;<br/>cy = 0.4;<br/>thetaChar = 7*pi/4;<br/>F = zeros(1, 2*nT); % left half real, right half imaginary<br/>M = zeros(2,1); % slope (Re and Im)</span><span id="be87" class="nu ky iq nq b gy oy nw l nx ny">P = zeros(1,7); % Perimeter segments<br/>P(1) = cy + rInner;<br/>P(2) = rInner * thetaChar;<br/>P(3) = wChar;<br/>P(4) = rOuter * thetaChar;<br/>P(5) = wChar;<br/>P(6) = cy + rOuter;<br/>P(7) = wChar;<br/>pSum = sum(P);<br/>TS = P/pSum; % Time Segments<br/>TSC = cumsum(TS); % Time Segments Cumulative</span><span id="b6f1" class="nu ky iq nq b gy oy nw l nx ny">V = zeros(2, 7); % Vertices<br/>V(1,1) = cy + rInner;<br/>V(2,1) = 0;<br/>V(1,2) = -rInner + rInner * cos(thetaChar);<br/>V(2,2) = rInner * sin(thetaChar);<br/>V(1,3) = wChar * cos(thetaChar);<br/>V(2,3) = wChar * sin(thetaChar);<br/>V(1,4) = -rOuter * cos(thetaChar) + rOuter; <br/>V(2,4) = -rOuter * sin(thetaChar);<br/>V(1,5) = 0;<br/>V(2,5) = -wChar;<br/>V(1,6) = -cy - rOuter;<br/>V(2,6) = 0;<br/>V(1,7) = 0;<br/>V(2,7) = wChar;<br/>VC = cumsum(V, 2); % Vertices Cumulative</span><span id="5076" class="nu ky iq nq b gy oy nw l nx ny">iSegment = 1;<br/>i0 = 1;<br/>tOffset = 0;<br/>nTS = 1 + floor(TS(1)/dT);<br/>i1 = i0 + nTS - 1;<br/>M = V(:,1) ./ TS(1);<br/>F(i0:i1) = M(1) * T(i0:i1);<br/>F(nT+i0:nT+i1) = 0;</span><span id="633d" class="nu ky iq nq b gy oy nw l nx ny">++iSegment; % 2<br/>i0 = i1 + 1;<br/>tOffset = T(i0) - TSC(1);<br/>nTS = 1 + floor((TS(2) - tOffset)/dT);<br/>i1 = i0 + nTS - 1;<br/>period = 8*TS(2)/7;<br/>THETA = 2*pi/period*(T(i0:i1) - TSC(1));<br/>F(i0:i1) = cy + rInner*cos(THETA);<br/>F(nT+i0:nT+i1) = rInner*sin(THETA);</span><span id="87e6" class="nu ky iq nq b gy oy nw l nx ny">++iSegment; % 3<br/>i0 = i1 + 1;<br/>tOffset = T(i0) - TSC(2);<br/>nTS = 1 + floor((TS(3) - tOffset)/dT);<br/>i1 = i0 + nTS - 1;<br/>M = V(:,3) ./ TS(3);<br/>F(i0:i1) = VC(1, 2) + M(1) * ...<br/> (T(i0:i1) - TSC(2)); <br/>F(nT+i0:nT+i1) = VC(2, 2) + M(2) * ...<br/> (T(i0:i1) - TSC(2));</span><span id="ba2e" class="nu ky iq nq b gy oy nw l nx ny">++iSegment; % 4<br/>i0 = i1 + 1;<br/>tOffset = T(i0) - TSC(3);<br/>nTS = 1 + floor((TS(4) - tOffset)/dT);<br/>i1 = i0 + nTS - 1;<br/>period = 8*TS(4)/7;<br/>THETA = thetaChar - 2*pi/period*(T(i0:i1) - TSC(3));<br/>F(i0:i1) = cy + rOuter*cos(THETA);<br/>F(nT+i0:nT+i1) = rOuter*sin(THETA);</span><span id="0228" class="nu ky iq nq b gy oy nw l nx ny">++iSegment; % 5<br/>i0 = i1 + 1;<br/>tOffset = T(i0) - TSC(4);<br/>nTS = 1 + floor((TS(5) - tOffset)/dT);<br/>i1 = i0 + nTS - 1;<br/>M = V(:,5) ./ TS(5);<br/>F(i0:i1) = VC(1, 4); <br/>F(nT+i0:nT+i1) = VC(2, 4) + M(2) * ...<br/> (T(i0:i1) - TSC(4));</span><span id="9876" class="nu ky iq nq b gy oy nw l nx ny">++iSegment; % 6<br/>i0 = i1 + 1;<br/>tOffset = T(i0) - TSC(5);<br/>nTS = 1 + floor((TS(6) - tOffset)/dT);<br/>i1 = i0 + nTS - 1;<br/>M = V(:,6) ./ TS(6);<br/>F(i0:i1) = VC(1, 5) + M(1) * ...<br/> (T(i0:i1) - TSC(5)); <br/>F(nT+i0:nT+i1) = VC(2, 5);</span><span id="c897" class="nu ky iq nq b gy oy nw l nx ny">++iSegment; % 7<br/>i0 = i1 + 1;<br/>tOffset = T(i0) - TSC(6);<br/>nTS = 1 + floor((TS(7) - tOffset)/dT);<br/>i1 = i0 + nTS - 1;<br/>M = V(:,7) ./ TS(7);<br/>F(i0:i1) = VC(1, 6);<br/>F(nT+i0:nT+i1) = VC(2, 6) + M(2) * ...<br/> (T(i0:i1) - TSC(6));</span><span id="ab15" class="nu ky iq nq b gy oy nw l nx ny">% apply y offset shift then take midpoints<br/>F(1:nT) += yOffset;<br/>FM = [ ...<br/> (F(1:nT-1) + F(2:nT))/2 ...<br/> (F(nT+1:end-1) + F(nT+2:end))/2 ];</span><span id="f57d" class="nu ky iq nq b gy oy nw l nx ny">% integrate complex coefficient<br/>NTERM = [1:8, 12:4:24];<br/>nTerm = size(NTERM,2)<br/>nTermMax = NTERM(end)<br/>FEM = zeros(1, 2*nTM);<br/>CR = zeros(5, 2*nTermMax+1); % coefficient Real component<br/>CI = zeros(5, 2*nTermMax+1); % coefficient Imag component<br/>iA = 0;<br/>for iTerm=-nTermMax:nTermMax<br/> iA++;<br/> EM = [cos(-iTerm*THETAM) sin(-iTerm*THETAM)];<br/> FEM(1:nTM) =  ... <br/>  FM(1:nTM) .* EM(1:nTM) - ...<br/>  FM(nTM+1:end) .* EM(nTM+1:end);<br/> FEM(nTM+1:end) =  ... <br/>  FM(1:nTM) .* EM(nTM+1:end) + ...<br/>  FM(nTM+1:end) .* EM(1:nTM);<br/> V = reshape(FEM .* dT, nTM, 2);<br/> VR = reshape(V(:,1),nT4,4);<br/> CR(1:4,iA) = (sum(VR))';<br/> VI = reshape(V(:,2),nT4,4);<br/> CI(1:4,iA) = (sum(VI))';<br/>endfor;<br/>CR(5,:) = sum(CR(1:4,:));<br/>CI(5,:) = sum(CI(1:4,:));</span><span id="0858" class="nu ky iq nq b gy oy nw l nx ny">% calculate common ratio r that best fits coefficients<br/>A = zeros(2, 1); % [a ccw terms; a cw terms]<br/>R = zeros(2, 1); % [r ccw terms; r cw terms]<br/>I_CMAG4 = zeros(2*nTermMax+1,5); % columns 3 thru 5 are for testing<br/>I_CMAG4(:,1) = -nTermMax:nTermMax;<br/>I_CMAG4(:,2) = sqrt(CR(5,:).^2 + CI(5,:).^2);<br/>X = [ones(nTermMax,1) I_CMAG4(nTermMax+2:end,1)];<br/>Y = log(I_CMAG4(nTermMax+2:end,2));<br/>PHI = (X'*X) \ (X'*Y); % is faster than PHI = inv(X'*X)*X'*Y<br/>EPHI = exp(PHI);<br/>A(1) = EPHI(1);<br/>R(1) = EPHI(2);<br/>X(:,2) = abs(I_CMAG4(1:nTermMax,1));<br/>Y = log(I_CMAG4(1:nTermMax,2));<br/>PHI = (X'*X) \ (X'*Y); % is faster than PHI = inv(X'*X)*X'*Y<br/>EPHI = exp(PHI);<br/>A(2) = EPHI(1);<br/>R(2) = EPHI(2);<br/>R</span><span id="7ab1" class="nu ky iq nq b gy oy nw l nx ny">clf;<br/>figure(1);<br/>plot(I_CMAG4(nTermMax+2:end,1), ...<br/> log(A(1)*R(1).^I_CMAG4(nTermMax+2:end,1)), ...<br/> 'k-');<br/>box off;<br/>grid on;<br/>hold on;<br/>plot(I_CMAG4(1:nTermMax,1), ... <br/> log(A(2)*R(2).^abs(I_CMAG4(1:nTermMax,1))), ... <br/> 'k-');<br/>ICOLOR = mod(abs(I_CMAG4(:,1)),3) == 0;<br/>plot(I_CMAG4(ICOLOR,1), log(I_CMAG4(ICOLOR,2)), ...<br/> 'ko', ...<br/> 'markerfacecolor', 'r', ...<br/> 'markersize', 5);<br/>ICOLOR = mod(abs(I_CMAG4(:,1)),3) == 1;<br/>plot(I_CMAG4(ICOLOR,1), log(I_CMAG4(ICOLOR,2)), ...<br/> 'ko', ...<br/> 'markerfacecolor', 'g', ...<br/> 'markersize', 5);<br/>ICOLOR = mod(abs(I_CMAG4(:,1)),3) == 2;<br/>plot(I_CMAG4(ICOLOR,1), log(I_CMAG4(ICOLOR,2)), ...<br/> 'ko', ...<br/> 'markerfacecolor', 'b', ...<br/> 'markersize', 5);<br/>xlabel("coefficient index n");<br/>ylabel("ln(coefficient magnitude)");<br/>strTitle1 = "LSE fit to coefficient magnitude data";<br/>strTitle2 = sprintf("+ index common ratio r = %.4f", R(1));<br/>strTitle3 = sprintf("- index common ratio r = %.4f", R(2));<br/>title({strTitle1, strTitle2, strTitle3});<br/>hold off;<br/>print("-dpng", "-r400", "-Farial:10", '_pco.png');</span><span id="478e" class="nu ky iq nq b gy oy nw l nx ny">% plot coefficient magnitudes as trapezoids<br/>SMB = zeros(2, 1); % Sum M*B; dims 1: +/- coefficients<br/>SB = zeros(2, 1); % Sum B; dims 1: +/- coefficients<br/>TH = zeros(2, nTermMax+1); % Trapezoid Height; dims 1: +/- coefficients; dims2: trapezoid height (1-based coefficient index)<br/>X = zeros(2, 2); % dims 1: +/- coefficients; dims 2: x of tall/short height<br/>M = zeros(2, 1); % trapezoid slope; dims 1: +/- coefficients<br/>B = zeros(2, 1); % trapezoid base width; dims 1: +/- coefficients</span><span id="d9c3" class="nu ky iq nq b gy oy nw l nx ny">X(:,2) = 2 * (1 .- R .^ 0.5);<br/>TH(:,1) = [I_CMAG4(nTermMax+1,2); I_CMAG4(nTermMax+1,2)] / 2; % split DC component into +/- coefficients<br/>TH(:,1) = TH(:,1) ./ (1 .- R); % trapezoid height: dims 1: +/- coefficients<br/>XTRAP = [ ...<br/> X(1,1); X(1,1); X(1,2); X(1,2); X(1,1); ...<br/> NaN; ...<br/> -X(2,1); -X(2,1); -X(2,2);, -X(2,2); -X(2,1)];<br/>YTRAP = [ ...<br/> 0; TH(1,1); TH(1,1)*R(1)^0.5; 0; 0; ...<br/> NaN; ...<br/> 0; TH(2,1); TH(2,1)*R(2)^0.5; 0; 0];<br/>I_CMAG4(nTermMax+1,3) = sum(TH(:,1) .* (1 .- R), 1);</span><span id="b017" class="nu ky iq nq b gy oy nw l nx ny">xlim([-2,2]);<br/>set(gca, 'xtick', -2:2:2);<br/>plot(XTRAP, YTRAP, 'r-');</span><span id="48f7" class="nu ky iq nq b gy oy nw l nx ny">box off;<br/>grid on;<br/>hold on;<br/>for jTerm=1:nTermMax<br/> iColor = mod(jTerm,3) + 1;</span><span id="ee92" class="nu ky iq nq b gy oy nw l nx ny"> X(:,1) = X(:,2);<br/> X(:,2) = 2 * (1 .- R .^ ((jTerm+1)/2));<br/> B = abs(diff(X, 1, 2));<br/> TH(:,jTerm+1) = [ ...<br/>  I_CMAG4(nTermMax+1+jTerm,2); ...<br/>  I_CMAG4(nTermMax+1-jTerm,2)] ./ ...<br/>  (R .^ (jTerm/2) .* (1 .- R));<br/> M = TH(:,jTerm+1) .* (R .- 1) ./ B;<br/> XTRAP = [ ...<br/>  X(1,1); X(1,1); X(1,2); X(1,2);, X(1,1);<br/>  NaN;<br/>  -X(2,1); -X(2,1); -X(2,2); -X(2,2); -X(2,1)];<br/> YTRAP = [ ...<br/>  0; TH(1,jTerm+1); TH(1,jTerm+1)*R(1)^0.5; 0; 0;<br/>  NaN;<br/>  0; TH(2,jTerm+1); TH(2,jTerm+1)*R(2)^0.5; 0; 0];<br/> plot(XTRAP, YTRAP, CT(iColor)); <br/> SB += B;<br/> SMB += M .* B;<br/> <br/> I_CMAG4(nTermMax+1+jTerm,3) = TH(1,jTerm+1) * R(1)^(jTerm/2) * (1 - R(1));<br/> I_CMAG4(nTermMax+1-jTerm,3) = TH(2,jTerm+1) * R(2)^(jTerm/2) * (1 - R(2));<br/>end</span><span id="a1d7" class="nu ky iq nq b gy oy nw l nx ny">MWA = SMB ./ SB % M (i.e., slope) Weighted Average<br/>X = [0; 2; NaN; 0; -2];<br/>Y = [-MWA(1)*2; 0; NaN; -MWA(2)*2; 0];<br/>plot(X, Y, ...<br/> 'color', [1.0, 0.65, 0]);<br/>hold off;<br/>print("-dpng", "-r400", "-Farial:10", '_pto.png');<br/>XMWA = [0, 2, NaN, 0, -2];<br/>YMWA = [-trapScale*MWA(1)*2, 0, NaN, -trapScale*MWA(2)*2, 0];<br/>ZMWA = [0, 0, NaN, 0, 0];</span><span id="905b" class="nu ky iq nq b gy oy nw l nx ny">% calculate partial series terms<br/>PS = zeros(2*nTermMax+1, 2*nTM); % Partial Sum<br/>iTerm0 = nTermMax + 1;<br/>PS(1,1:nTM) = CR(5,iTerm0); % DC component doesn't rotate<br/>PS(1,nTM+1:end) = CI(5,iTerm0); % DC component doesn't rotate<br/>for jTerm=1:nTermMax<br/> iPS = 2 * jTerm;<br/> iTerm = iTerm0 + jTerm;<br/> EM = [cos(jTerm*THETAM)' sin(jTerm*THETAM)']; % nTM x 2<br/> PS(iPS,1:nTM) = ...<br/>  CR(5,iTerm) .* EM(:,1) - ...<br/>  CI(5,iTerm) .* EM(:,2);<br/> PS(iPS,nTM+1:end) = ...<br/>  CI(5,iTerm) .* EM(:,1) + ...<br/>  CR(5,iTerm) .* EM(:,2);</span><span id="272f" class="nu ky iq nq b gy oy nw l nx ny"> iPS = 2 * jTerm + 1;<br/> iTerm = iTerm0 - jTerm;<br/> EM = [cos(jTerm*THETAM)' sin(-jTerm*THETAM)']; % nTM x 2<br/> PS(iPS,1:nTM) = ...<br/>  CR(5,iTerm) .* EM(:,1) - ...<br/>  CI(5,iTerm) .* EM(:,2);<br/> PS(iPS,nTM+1:end) = ...<br/>  CI(5,iTerm) .* EM(:,1) + ...<br/>  CR(5,iTerm) .* EM(:,2);<br/>endfor;<br/>PSC = cumsum(PS, 1);</span><span id="7050" class="nu ky iq nq b gy oy nw l nx ny">% split terms according to direction of rotation<br/>PSP = zeros(nTermMax+1, 2*nTM); % Partial Sum Positive rotation<br/>PSP(1,:) = PS(1,:) / 2;<br/>PSP(2:end,:) = PS(2:2:2*nTermMax+1,:);<br/>PSPC = cumsum(PSP); % Partial Sum Positive rotation Cumulative<br/>PSN = zeros(nTermMax+1, 2*nTM); % Partial Sum Negative rotation<br/>PSN(1,:) = PS(1,:) / 2;<br/>PSN(2:end,:) = PS(3:2:2*nTermMax+1,:);<br/>PSNC = cumsum(PSN); % Partial Sum Negative rotation Cumulative<br/>PST = PSP + PSN; % Partial Sum Total<br/>PSTC = cumsum(PST, 1); % Partial Sum Total Cumulative</span><span id="ac34" class="nu ky iq nq b gy oy nw l nx ny">% test PSP and PSN in column 4 of I_CMAG4<br/>kTM = 50;  % test should work for any value of kTM where 1&lt;=kTM&lt;=nTM<br/>I_CMAG4(nTermMax+1,4) =  (PSP(1,kTM)^2 + PSP(1,kTM+nTM)^2)^0.5;<br/>I_CMAG4(nTermMax+1,4) += (PSN(1,kTM)^2 + PSN(1,kTM+nTM)^2)^0.5;<br/>for jTerm=2:nTermMax+1<br/> I_CMAG4(nTermMax+jTerm,4) =   (PSP(jTerm,kTM)^2 + PSP(jTerm,kTM+nTM)^2)^0.5;<br/> I_CMAG4(nTermMax+2-jTerm,4) = (PSN(jTerm,kTM)^2 + PSN(jTerm,kTM+nTM)^2)^0.5;<br/>end</span><span id="32ec" class="nu ky iq nq b gy oy nw l nx ny">% animate<br/>figure(3, 'position', [600 400 800 450]);<br/>FRAME0 = nTM/2 * ones(nTerm, 1);<br/>FRAME0(1) = 0;<br/>FRAME0(9) *= 2;<br/>FRAME0 = cumsum(FRAME0, 1);<br/>iTerm = 0;<br/>for kTerm=NTERM<br/> iTerm++;<br/> iFrame = FRAME0(iTerm);<br/> for iTM=1:nTM</span><span id="86fc" class="nu ky iq nq b gy oy nw l nx ny">  % occasionally skip every other frame for speed<br/>  if ((kTerm!=8) &amp;&amp; (kTerm!=24))<br/>   if (mod(iTM,2)==0)<br/>    continue;<br/>   endif;<br/>  endif;<br/>  <br/>  % setup plot figure<br/>  clf;<br/>  figure(3, 'position', [600 400 800 450]);<br/>  daspect([0.5 0.4 4]);<br/>  xlim([-2 2]);<br/>  ylim([-1 2]);<br/>  zlim([-1 1]);<br/>  set(gca, "fontsize", 12);<br/>  set(gca, 'xtick', -2:2:2);<br/>  set(gca, 'ytick', -1:2);<br/>  set(gca, 'ztick', -1:1);<br/>  grid on;<br/>  hold on;<br/>  xlabel('trapezoid baseline');<br/>  ylabel('Re {\bfS_n}');<br/>  zlabel('Im {\bfS_n}');<br/>  axis('equal');<br/>  view([72.5 20]);<br/>  strTitle1 = sprintf( ...<br/>   "complex Fourier series drawing of 'e'");<br/>  strTitle2 = sprintf( ...<br/>   "(trapezoid scale=%.2f, t=%.4f, n=+/-%d)", ...<br/>   trapScale, iTM/nTM, kTerm);<br/>  title({strTitle1,strTitle2});</span><span id="0aaa" class="nu ky iq nq b gy oy nw l nx ny">  % plot 'e' (closed form) in x=-2 plane<br/>  plot3(XZ-2, F(1:nT), F(nT+1:end), 'c-');</span><span id="7f8d" class="nu ky iq nq b gy oy nw l nx ny">  % plot weighted average trapezoid slopes (MWA)<br/>  plot3(XMWA, YMWA, ZMWA, ':', ...<br/>   'color', [1.0, 0.65, 0]);</span><span id="4824" class="nu ky iq nq b gy oy nw l nx ny">  % plot zigzag aggregated vectors (x=-2 plane)<br/>  XVEC = [-2 -2];<br/>  YVEC = [0 PS(1,iTM)];<br/>  ZVEC = [0 PS(1,iTM+nTM)];<br/>  plot3(XVEC, YVEC, ZVEC, CT(1), ...<br/>   'linewidth', 1);<br/>  XVEC = [-2, -2, -2];<br/>  for iPS=2:2:2*kTerm<br/>   iColor = mod(floor(iPS/2),3) + 1;<br/>   YVEC = [PSC(iPS-1,iTM), PSC(iPS,iTM), PSC(iPS+1,iTM)];<br/>   ZVEC = [PSC(iPS-1,iTM+nTM), PSC(iPS,iTM+nTM), PSC(iPS+1,iTM+nTM)];<br/>   plot3(XVEC, YVEC, ZVEC, CT(iColor), ...<br/>    'linewidth', 1);<br/>  endfor;</span><span id="f61a" class="nu ky iq nq b gy oy nw l nx ny">  % plot axes<br/>  plot3(xlim(), [0 0], [0 0], '-', ...<br/>   'color', 0.85+[0  0 0]);<br/>  plot3([2 2], ylim(), [0 0], '-', ...<br/>   'color', 0.85+[0  0 0]);<br/>  plot3([2 2], [0 0], zlim(), '-', ...<br/>   'color', 0.85+[0  0 0]);</span><span id="4cc6" class="nu ky iq nq b gy oy nw l nx ny">  % plot trapezoids<br/>  for iPS=1:kTerm+1<br/>   iColor = mod(iPS-1,3) + 1;<br/>   S = R .^ ((iPS-1)/2) .* (1 .- R);</span><span id="19f6" class="nu ky iq nq b gy oy nw l nx ny">   % plot trapezoids (mid planes)<br/>   XTRAP = [ ...<br/>    2*(1-R(1)^((iPS-1)/2));<br/>    2*(1-R(1)^((iPS-1)/2));<br/>    2*(1-R(1)^(iPS/2));<br/>    2*(1-R(1)^(iPS/2));<br/>    2*(1-R(1)^((iPS-1)/2));<br/>    NaN;<br/>    -2*(1-R(2)^((iPS-1)/2));<br/>    -2*(1-R(2)^((iPS-1)/2));<br/>    -2*(1-R(2)^(iPS/2));<br/>    -2*(1-R(2)^(iPS/2));<br/>    -2*(1-R(2)^((iPS-1)/2))];<br/>   YTRAP = [ ...<br/>    0;<br/>    trapScale*PSP(iPS,iTM)/S(1);<br/>    trapScale*PSP(iPS,iTM)/S(1) * R(1);<br/>    0;<br/>    0;<br/>    NaN;<br/>    0;<br/>    trapScale*PSN(iPS,iTM)/S(2);<br/>    trapScale*PSN(iPS,iTM)/S(2) * R(2);<br/>    0;<br/>    0];<br/>   ZTRAP = [ ...<br/>    0;<br/>    trapScale*PSP(iPS,iTM+nTM)/S(1);<br/>    trapScale*PSP(iPS,iTM+nTM)/S(1) * R(1);<br/>    0;<br/>    0;<br/>    NaN;<br/>    0;<br/>    trapScale*PSN(iPS,iTM+nTM)/S(2);<br/>    trapScale*PSN(iPS,iTM+nTM)/S(2) * R(2);<br/>    0;<br/>    0];<br/>   plot3(XTRAP, YTRAP, ZTRAP, CT(iColor), ...<br/>    'linewidth', 0.3);<br/>    <br/>   % fill test column 5 of I_CMAG4<br/>   if ((kTerm == nTermMax) &amp;&amp; (iTM == 1))<br/>    B = 2 .* R.^(iPS-1) .* (1 .- R.^0.5);<br/>    I = [2; 8];<br/>    H = ((YTRAP(I).^2 + ZTRAP(I).^2).^0.5) ./ trapScale;<br/>    if (iPS &gt; 1)<br/>     I = [nTermMax+iPS; nTermMax+2-iPS];<br/>     I_CMAG4(I,5) = H .* R .^ ((iPS-1)/2) .* (1 .- R);<br/>    else<br/>     SDC = H .* B .* (1 .+ R.^0.5) ./ 2;<br/>     I_CMAG4(nTermMax+1,5) = sum(SDC);<br/>    end<br/>   end<br/>  endfor;</span><span id="2882" class="nu ky iq nq b gy oy nw l nx ny">  % plot 'e' (closed form) in x=2 plane<br/>  plot3(XZ+2, F(1:nT), F(nT+1:end), 'c-');</span><span id="2abc" class="nu ky iq nq b gy oy nw l nx ny">  % plot dotted trail of partial sum<br/>  if ((kTerm &gt;= 1) &amp;&amp; (kTerm &lt;= 10))<br/>   YVEC = PSTC(kTerm, 1:nTM);<br/>   ZVEC = PSTC(kTerm, nTM+1:end);<br/>   alpha = 0.8;<br/>   plot3(XZ(1:nTM)-2, YVEC, ZVEC, ':', ...<br/>    'color', [0 0 0]+alpha);<br/>   plot3(XZ(1:nTM)+2, YVEC, ZVEC, ':', ...<br/>    'color', [0 0 0]+alpha);<br/>  endif;<br/>  YVEC = PSTC(kTerm+1, 1:iTM);<br/>  ZVEC = PSTC(kTerm+1, nTM+1:nTM+iTM);<br/>  plot3(XZ(1:iTM)-2, YVEC, ZVEC, 'k:');<br/>  plot3(XZ(1:iTM)+2, YVEC, ZVEC, 'k:');</span><span id="1921" class="nu ky iq nq b gy oy nw l nx ny">  % plot aggregated vectors (x=2 plane)<br/>  XVEC = [2 2 NaN 2 2];<br/>  for iPS=1:kTerm+1<br/>   iColor = mod(iPS-1,3) + 1;</span><span id="bb4b" class="nu ky iq nq b gy oy nw l nx ny">   YVEC = [ ...<br/>    PSPC(iPS,iTM),<br/>    PSPC(iPS,iTM)-PSP(iPS,iTM),<br/>    NaN,<br/>    PSNC(iPS,iTM),<br/>    PSNC(iPS,iTM)-PSN(iPS,iTM)];<br/>   ZVEC = [ ...<br/>    PSPC(iPS,iTM+nTM),<br/>    PSPC(iPS,iTM+nTM)-PSP(iPS,iTM+nTM),<br/>    NaN,<br/>    PSNC(iPS,iTM+nTM),<br/>    PSNC(iPS,iTM+nTM)-PSN(iPS,iTM+nTM)];<br/>   plot3(XVEC, YVEC, ZVEC, CT(iColor), ...<br/>    'linewidth', 2);<br/>  endfor;</span><span id="1410" class="nu ky iq nq b gy oy nw l nx ny">  % plot '+' vector addition cross-hair<br/>  iPS = kTerm + 1;<br/>  YVEC = [ ...<br/>   PSTC(iPS,iTM)-dCross/2,<br/>   PSTC(iPS,iTM)+dCross/2,<br/>   NaN,<br/>   PSTC(iPS,iTM),<br/>   PSTC(iPS,iTM)];<br/>  ZVEC = [ ...<br/>   PSTC(iPS,iTM+nTM),<br/>   PSTC(iPS,iTM+nTM),<br/>   NaN,<br/>   PSTC(iPS,iTM+nTM)-dCross/2,<br/>   PSTC(iPS,iTM+nTM)+dCross/2];<br/>  plot3(XVEC-4, YVEC, ZVEC, 'k-', ...<br/>   'linewidth', 1);<br/>  plot3(XVEC, YVEC, ZVEC, 'k-', ...<br/>   'linewidth', 1);<br/>  plot3( ...<br/>   XDOT+2, ...<br/>   YDOT+PSTC(iPS,iTM)/2, ...<br/>   ZDOT+PSTC(iPS,iTM+nTM)/2, ...<br/>   'k-', ...<br/>   'linewidth', 1);</span><span id="7c26" class="nu ky iq nq b gy oy nw l nx ny">  % print scene's frames<br/>  hold off;<br/>  fname = sprintf("./cfsanim3B/frame%05d.png", ...<br/>   iFrame);<br/>  print("-dpng", "-r400", "-Farial:10", fname);<br/>  iFrame++;<br/> endfor; % iT=1:nT<br/>endfor; % for kTerm=NTERM</span><span id="de7d" class="nu ky iq nq b gy oy nw l nx ny">% plot _pceo.png (wher PCEO is Plot Coefficient Error in Octave)<br/>figure(4);<br/>X = I_CMAG4(:,1);<br/>Y = diff(I_CMAG4(:,2:5), 1, 2); % diff of 1 in horizontal direction<br/>plot(X, Y);<br/>print("-dpng", "-r400", "-Farial:10", "_pceo.png");<br/>I_CMAG4(nTermMax-4:nTermMax+6,:)</span><span id="1179" class="nu ky iq nq b gy oy nw l nx ny">% print 3 seconds of trailer still frames<br/>for i=1:60<br/> fname = sprintf("./cfsanim3B/frame%05d.png", ...<br/>  iFrame);<br/> print("-dpng", "-r400", "-Farial:10", fname);<br/> iFrame++;<br/>endfor;</span><span id="ef26" class="nu ky iq nq b gy oy nw l nx ny">% get final snapshot of side view<br/>PV = view(); % Plot View<br/>view([0 0]);<br/>drawnow();<br/>print("-dpng", "-r400", "-Farial:10", 'cfs3b3.png');<br/>view(PV);</span><span id="6e38" class="nu ky iq nq b gy oy nw l nx ny">% /tool/ffmpeg-4.3.1/bin/ffmpeg -f image2 -i frame%05d.png -vf scale=1080:-2,setsar=1:1 -f mp4 -q:v 0 -vcodec mpeg4 -r 20 _cfs3b.mp4<br/>% /tool/ffmpeg-4.3.1/bin/ffmpeg -i _cfs3b.mp4 -c:v libvpx-vp9 -crf 30 -b:v 4M  cfs3b.webm<br/>% see <a class="ae kw" href="https://trac.ffmpeg.org/wiki/Encode/VP9" rel="noopener ugc nofollow" target="_blank">https://trac.ffmpeg.org/wiki/Encode/VP9</a></span></pre><h2 id="d9e2" class="nu ky iq bd kz on oo dn ld op oq dp lh ly or os lj mc ot ou ll mg ov ow ln ox bi translated">附录B. Julia源代码</h2><p id="fe69" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx ly lz ma mb mc md me mf mg mh mi mj mk ij bi translated">下面的Julia代码为描绘字母“e”的复傅立叶级数的动画生成帧。</p><pre class="kg kh ki kj gt np nq nr ns aw nt bi"><span id="6607" class="nu ky iq nq b gy nv nw l nx ny"># file: cfse.jl (complex Fourier series tracing 'e')<br/># import Pkg; Pkg.add("Plots"); Pkg.add("PyPlot")<br/>using Plots, Printf<br/>pyplot()</span><span id="53ed" class="nu ky iq nq b gy oy nw l nx ny"># cfse: Complex Fourier Series animation tracing the letter 'e'<br/># - media_mask bit 0: set to disable generation of frames as .png images<br/># - media_mask bit 1: set to disable generation of audio  as .wav file(s)<br/># - iProc: 1-based index of CPU core<br/># - nProc: number of CPU cores<br/># example: cfse(1) # skips image frame generation<br/>function cfse(media_mask::Int64=0, iProc=1, nProc=1)<br/> <br/> # define some plotting parameters <br/> nT = Int32(801)   # number of Time samples<br/> nTM = nT - 1   # number of Time sample Midpoints<br/> T = range(0, stop=1, length=nT) # Time samples<br/> nT2 = Int32(nTM/2)<br/> nT4 = Int32(nTM/4)<br/> dT = 1/nTM    # difference between Time samples<br/> TM = T[1:nTM] .+ dT/2 # Time sample Midpoints<br/> THETAM = 2*pi*TM  # angle samples<br/> XZ = zeros(nT,1)  # X Zeros<br/> CSEQ = [:red, :green, :blue, :yellow, :white, :black] # Color SEQuence<br/> <br/> trapScale = 0.5   # trapezoid scale<br/> dCross = 0.15   # diameter of '+' cross-hair<br/> yOffset = 0.5   # y offset of F(t)<br/> nAudioBuf = 3530<br/> nAng = 15<br/> ANGDOT = range(0, stop=2*pi, length=nAng)<br/> XDOT = zeros(nAng, 1)<br/> YDOT = dCross/pi*cos.(ANGDOT) <br/> ZDOT = dCross/pi*sin.(ANGDOT)<br/> <br/> # parameterize function F for drawing letter 'e' <br/> wChar = 0.1<br/> rInner = 0.5<br/> rOuter = rInner+wChar<br/> cy = 0.4<br/> thetaChar = 7*pi/4<br/> F = zeros(1, 2*nT)  # left half real, right half imaginary<br/> M = zeros(2,1)   # slope (Re and Im)<br/> <br/> P = zeros(1,7)   # Perimeter segments<br/> P[1] = cy + rInner<br/> P[2] = rInner * thetaChar<br/> P[3] = wChar<br/> P[4] = rOuter * thetaChar<br/> P[5] = wChar<br/> P[6] = cy + rOuter<br/> P[7] = wChar<br/> pSum = sum(P)<br/> TS = P/pSum     # Time Segments<br/> TSC = cumsum(TS, dims=2)  # Time Segments Cumulative<br/> <br/> V = zeros(2, 7)    # Vertices<br/> V[1,1] = cy + rInner<br/> V[2,1] = 0<br/> V[1,2] = -rInner + rInner * cos.(thetaChar)<br/> V[2,2] = rInner * sin.(thetaChar)<br/> V[1,3] = wChar * cos.(thetaChar)<br/> V[2,3] = wChar * sin.(thetaChar)<br/> V[1,4] = -rOuter * cos.(thetaChar) + rOuter <br/> V[2,4] = -rOuter * sin.(thetaChar)<br/> V[1,5] = 0<br/> V[2,5] = -wChar<br/> V[1,6] = -cy - rOuter<br/> V[2,6] = 0<br/> V[1,7] = 0<br/> V[2,7] = wChar<br/> VC = cumsum(V, dims=2)   # Vertices Cumulative<br/> <br/> iSegment = 1    # segment 1<br/> i0 = Int32(1)<br/> tOffset = 0<br/> nTS = 1 + Int32(floor(TS[1]/dT))<br/> i1 = i0 + nTS - 1<br/> M = V[:,1] ./ TS[1]<br/> F[i0:i1] = M[1] * T[i0:i1]<br/> F[nT+i0:nT+i1] .= 0<br/> <br/> iSegment += 1     # segment 2<br/> i0 = i1 + 1<br/> tOffset = T[i0] - TSC[1]<br/> nTS = 1 + Int32(floor((TS[2] - tOffset)/dT))<br/> i1 = i0 + nTS - 1<br/> period = 8*TS[2]/7<br/> THETA = 2*pi/period*(T[i0:i1] .- TSC[1])<br/> F[i0:i1] = cy .+ rInner*cos.(THETA)<br/> F[nT+i0:nT+i1] = rInner*sin.(THETA)<br/> <br/> iSegment += 1     # segment 3<br/> i0 = i1 + 1<br/> tOffset = T[i0] - TSC[2]<br/> nTS = 1 + Int32(floor((TS[3] - tOffset)/dT))<br/> i1 = i0 + nTS - 1<br/> M = V[:,3] ./ TS[3]<br/> F[i0:i1] = VC[1, 2] .+ M[1] .* (T[i0:i1] .- TSC[2]) <br/> F[nT+i0:nT+i1] = VC[2, 2] .+ M[2] * (T[i0:i1] .- TSC[2]) <br/> <br/> iSegment += 1     # segment 4<br/> i0 = i1 + 1<br/> tOffset = T[i0] - TSC[3]<br/> nTS = 1 + Int32(floor((TS[4] - tOffset)/dT))<br/> i1 = i0 + nTS - 1<br/> period = 8*TS[4]/7<br/> THETA = thetaChar .- 2*pi/period*(T[i0:i1] .- TSC[3])<br/> F[i0:i1] = cy .+ rOuter*cos.(THETA)<br/> F[nT+i0:nT+i1] = rOuter*sin.(THETA)<br/> <br/> iSegment += 1     # segment 5<br/> i0 = i1 + 1<br/> tOffset = T[i0] - TSC[4]<br/> nTS = 1 + Int32(floor((TS[5] - tOffset)/dT))<br/> i1 = i0 + nTS - 1<br/> M = V[:,5] ./ TS[5]<br/> F[i0:i1] .= VC[1, 4] <br/> F[nT+i0:nT+i1] = VC[2, 4] .+ M[2] * (T[i0:i1] .- TSC[4]) <br/> <br/> iSegment += 1     # segment 6<br/> i0 = i1 + 1<br/> tOffset = T[i0] - TSC[5]<br/> nTS = 1 + Int32(floor((TS[6] - tOffset)/dT))<br/> i1 = i0 + nTS - 1<br/> M = V[:,6] ./ TS[6]<br/> F[i0:i1] = VC[1, 5] .+ M[1] * (T[i0:i1] .- TSC[5]) <br/> F[nT+i0:nT+i1] .= VC[2, 5]<br/> <br/> iSegment += 1     # segment 7<br/> i0 = i1 + 1<br/> tOffset = T[i0] - TSC[6]<br/> nTS = 1 + Int32(floor((TS[7] - tOffset)/dT))<br/> i1 = i0 + nTS - 1<br/> M = V[:,7] ./ TS[7]<br/> F[i0:i1] .= VC[1, 6]<br/> F[nT+i0:nT+i1] = VC[2, 6] .+ M[2] * (T[i0:i1] .- TSC[6])<br/> <br/> # apply y offset shift then take midpoints<br/> F[1:nT] .+= yOffset<br/> FM = [(F[1:nT-1]+F[2:nT])/2 (F[nT+1:end-1]+F[nT+2:end])/2]<br/> <br/> # integrate complex coefficient<br/> NTERM = [1:10; 12:2:22]<br/> nTerm = size(NTERM,1)<br/> nTermMax = last(NTERM)<br/> FEM = zeros(1, 2*nTM);<br/> CR = zeros(5, 2*nTermMax+1)<br/> CI = zeros(5, 2*nTermMax+1)<br/> for iTerm=-nTermMax:nTermMax<br/>  iA = iTerm + nTermMax + 1<br/>  EM = [cos.(-iTerm*THETAM) sin.(-iTerm*THETAM)]<br/>  FEM[1:nTM] = FM[1:nTM] .* EM[1:nTM] - <br/>   FM[nTM+1:end] .* EM[nTM+1:end]<br/>  FEM[nTM+1:end] = FM[1:nTM] .* EM[nTM+1:end] + <br/>   FM[nTM+1:end] .* EM[1:nTM]<br/>  V = reshape(FEM .* dT, (nTM, 2))<br/>  VR = reshape(V[:,1], (nT4, 4))<br/>  CR[1:4,iA] = sum(VR, dims=1)'<br/>  VI = reshape(V[:,2], (nT4, 4))<br/>  CI[1:4,iA] = sum(VI, dims=1)'<br/> end<br/> CR[5,:] = sum(CR[1:4,:], dims=1)<br/> CI[5,:] = sum(CI[1:4,:], dims=1)<br/> if (iProc == 1)<br/>  fp = open("ecoeff.dat", "w")<br/>  write(fp, CR[5,:])<br/>  write(fp, CI[5,:])<br/>  close(fp)<br/> end<br/> <br/> # calculate common ratio r that best fits coefficients<br/> A = zeros(2, 1) # (a ccw terms; a cw terms)<br/> R = zeros(2, 1) # [r ccw terms, r cw terms]<br/> I_CMAG4 = zeros(2*nTermMax+1, 5) # columns 3 thru 5 are for testing<br/> I_CMAG4[:,1] .= -nTermMax:nTermMax<br/> I_CMAG4[:,2] .= (CR[5,:].^2 + CI[5,:].^2).^0.5<br/> X = [ones(nTermMax,1) I_CMAG4[nTermMax+2:end,1]]<br/> Y = log.(I_CMAG4[nTermMax+2:end,2])<br/> PHI = (X'*X) \ (X'*Y) # is faster than PHI = inv(X'*X)*X'*Y<br/> EPHI = exp.(PHI)<br/> A[1] = EPHI[1]<br/> R[1] = EPHI[2]<br/> X = [ones(nTermMax,1) abs.(I_CMAG4[1:nTermMax,1])]<br/> Y = log.(I_CMAG4[1:nTermMax,2])<br/> PHI = (X'*X) \ (X'*Y) # is faster than PHI = inv(X'*X)*X'*Y<br/> EPHI = exp.(PHI)<br/> A[2] = EPHI[1]<br/> R[2] = EPHI[2]<br/> if (nProc == 1)<br/>  display("R"); display(R)<br/> end<br/> <br/> # plot L.S.E. fit to natural log of coefficient magnitudes<br/> plot(I_CMAG4[nTermMax+2:end,1], <br/>  log.(A[1]*R[1].^I_CMAG4[nTermMax+2:end,1]), <br/>  color = :black);<br/> plot!(I_CMAG4[1:nTermMax,1], <br/>  log.(A[2]*R[2].^abs.(I_CMAG4[1:nTermMax,1])), <br/>  color = :black);<br/> ICOLOR = mod.(abs.(I_CMAG4[:,1]),3) .== 0;<br/> plot!(I_CMAG4[ICOLOR,1], <br/>  log.(I_CMAG4[ICOLOR,2]), <br/>  seriestype = :scatter,<br/>  markersize = 8,<br/>  color = :red);<br/> ICOLOR = mod.(abs.(I_CMAG4[:,1]),3) .== 1;<br/> plot!(I_CMAG4[ICOLOR,1], <br/>  log.(I_CMAG4[ICOLOR,2]), <br/>  seriestype = :scatter,<br/>  markersize = 8,<br/>  color = :green);<br/> ICOLOR = mod.(abs.(I_CMAG4[:,1]),3) .== 2;<br/> plot!(I_CMAG4[ICOLOR,1], <br/>  log.(I_CMAG4[ICOLOR,2]), <br/>  seriestype = :scatter,<br/>  markersize = 8,<br/>  color = :blue);<br/> strTitleCoefficient = <a class="ae kw" href="http://twitter.com/sprintf" rel="noopener ugc nofollow" target="_blank">@sprintf</a>(<br/>  "%s\n+ index common ratio r = %.4f\n- index common ratio r = %.4f",<br/>  "LSE fit to coefficient magnitude data",<br/>  R[1], <br/>  R[2]);<br/> plot!(legend = false,<br/>  xlabel = "coefficient index n", <br/>  ylabel = "ln(coefficient magnitude)", <br/>  title = strTitleCoefficient);<br/> savefig("_pc.png")<br/> <br/> # plot coefficient magnitudes as trapezoids<br/> SMB = zeros(2, 1) # Sum M*B; dims 1: +/- coefficients<br/> SB = zeros(2, 1) # Sum B; dims 1: +/- coefficients<br/> TH = zeros(2, nTermMax+1) # Trapezoid Height; dims 1: +/- coefficients; dims2: trapezoid height (1-based coefficient index)<br/> X = zeros(2, 2) # dims 1: +/- coefficients; dims 2: x of tall/short height<br/> M = zeros(2, 1) # trapezoid slope; dims 1: +/- coefficients<br/> B = zeros(2, 1) # trapezoid base width; dims 1: +/- coefficients<br/> <br/> X[:,2] = 2 .* (1 .- R .^ 0.5)<br/> TH[:,1] = [I_CMAG4[nTermMax+1,2], I_CMAG4[nTermMax+1,2]] ./ 2 # split DC component into +/- coefficients<br/> TH[:,1] = TH[:,1] ./ (1 .- R) # trapezoid height: dims 1: +/- coefficients<br/> XTRAP = [<br/>  X[1,1], X[1,1], X[1,2], X[1,2], X[1,1],<br/>  NaN,<br/>  -X[2,1], -X[2,1], -X[2,2], -X[2,2], -X[2,1]]<br/> YTRAP = [<br/>  0, TH[1,1], TH[1,1]*R[1]^0.5, 0, 0,<br/>  NaN,<br/>  0, TH[2,1], TH[2,1]*R[2]^0.5, 0, 0]<br/> plot(XTRAP, YTRAP, <br/>  color = CSEQ[1], # coefficient 0<br/>  legend = false,<br/>  xlims = (-2,2),<br/>  xticks = -2:2:2)<br/> <br/> # SB += B        # intentionally skip inclusion of DC component<br/> # SMB += M .* B  # in calculation of weighted average slope<br/> I_CMAG4[nTermMax+1,3] = sum(TH[:,1] .* (1 .- R), dims=1)[1]<br/> <br/> for jTerm=1:nTermMax<br/>  iColor::Int16 = mod(jTerm,3) + 1;<br/>  <br/>  X[:,1] = X[:,2]<br/>  X[:,2] = 2 .* (1 .- R .^ ((jTerm+1)/2))<br/>  B = abs.(diff(X, dims=2))<br/>  TH[:,jTerm+1] = [<br/>   I_CMAG4[nTermMax+1+jTerm,2];<br/>   I_CMAG4[nTermMax+1-jTerm,2]] ./<br/>   (R .^ (jTerm/2) .* (1 .- R))<br/>  M = TH[:,jTerm+1] .* (R .- 1) ./ B<br/>  XTRAP = [<br/>   X[1,1], X[1,1], X[1,2], X[1,2], X[1,1],<br/>   NaN,<br/>   -X[2,1], -X[2,1], -X[2,2], -X[2,2], -X[2,1]]<br/>  YTRAP = [<br/>   0, TH[1,jTerm+1], TH[1,jTerm+1]*R[1]^0.5, 0, 0,<br/>   NaN,<br/>   0, TH[2,jTerm+1], TH[2,jTerm+1]*R[2]^0.5, 0, 0]<br/>  plot!(XTRAP, YTRAP, <br/>   color = CSEQ[iColor]) # coefficient +/- jTerm<br/>  SB += B<br/>  SMB += M .* B<br/>  <br/>  I_CMAG4[nTermMax+1+jTerm,3] = TH[1,jTerm+1] * R[1]^(jTerm/2) * (1 - R[1])<br/>  I_CMAG4[nTermMax+1-jTerm,3] = TH[2,jTerm+1] * R[2]^(jTerm/2) * (1 - R[2])<br/> end<br/> <br/> MWA = SMB ./ SB # M (i.e., slope) Weighted Average<br/> plot!(<br/>  [0, 2, NaN, 0, -2],<br/>  [-MWA[1]*2, 0, NaN, -MWA[2]*2, 0],<br/>  linestyle = :dot,<br/>  color = :orange)<br/> savefig("_pt.png")<br/> if (nProc == 1)<br/>  display("MWA"); display(MWA)<br/> end<br/> <br/> # calculate partial series terms<br/> PS = zeros(2*nTM, 2*nTermMax+1) # Partial Sum<br/> iTerm0 = nTermMax + 1<br/> PS[1:nTM,1] .= CR[5,iTerm0]<br/> PS[nTM+1:end,1] .= CI[5,iTerm0]<br/> for jTerm=1:nTermMax<br/>  iPS = 2 * jTerm<br/>  iTerm = iTerm0 + jTerm<br/>  EM = [cos.(jTerm*THETAM) sin.(jTerm*THETAM)] # nTM x 2<br/>  PS[1:nTM,iPS] = <br/>   CR[5,iTerm] .* EM[:,1] - <br/>   CI[5,iTerm] .* EM[:,2]<br/>  PS[nTM+1:end,iPS] = <br/>   CI[5,iTerm] .* EM[:,1] + <br/>   CR[5,iTerm] .* EM[:,2]</span><span id="d395" class="nu ky iq nq b gy oy nw l nx ny">iPS = 2 * jTerm + 1<br/>  iTerm = iTerm0 - jTerm<br/>  EM = [cos.(jTerm*THETAM) sin.(-jTerm*THETAM)] # nTM x 2<br/>  PS[1:nTM,iPS] = <br/>   CR[5,iTerm] .* EM[:,1] - <br/>   CI[5,iTerm] .* EM[:,2]<br/>  PS[nTM+1:end,iPS] = <br/>   CI[5,iTerm] .* EM[:,1] + <br/>   CR[5,iTerm] .* EM[:,2]<br/> end<br/> PSC = cumsum(PS, dims=2);<br/> <br/> # split terms according to direction of rotation<br/> PSP = zeros(2*nTM, nTermMax+1) # Partial Sum Positive rotation<br/> PSP[:,1] = PS[:,1] ./ 2<br/> PSP[:,2:end] = PS[:,2:2:2*nTermMax+1]<br/> PSPC = cumsum(PSP, dims=2) # Partial Sum Positive rotation Cumulative<br/> PSN = zeros(2*nTM, nTermMax+1) # Partial Sum Negative rotation<br/> PSN[:,1] = PS[:,1] ./ 2<br/> PSN[:,2:end] = PS[:,3:2:2*nTermMax+1]<br/> PSNC = cumsum(PSN, dims=2) # Partial Sum Negative rotation Cumulative<br/> PST = PSP + PSN # Partial Sum Total<br/> PSTC = cumsum(PST, dims=2) # Partial Sum Total Cumulative<br/> <br/> # test PSP and PSN in column 4 of I_CMAG4<br/> kTM = 100  # test should work for any value of kTM where 1&lt;kTM&lt;=nTM<br/> I_CMAG4[nTermMax+1,4] =  (PSP[kTM,1]^2 + PSP[kTM+nTM,1]^2)^0.5<br/> I_CMAG4[nTermMax+1,4] += (PSN[kTM,1]^2 + PSN[kTM+nTM,1]^2)^0.5<br/> for jTerm=2:nTermMax+1<br/>  I_CMAG4[nTermMax+jTerm,4] =   (PSP[kTM,jTerm]^2 + PSP[kTM+nTM,jTerm]^2)^0.5<br/>  I_CMAG4[nTermMax+2-jTerm,4] = (PSN[kTM,jTerm]^2 + PSN[kTM+nTM,jTerm]^2)^0.5<br/> end<br/> <br/> # calculate frame offsets where new terms are added to partial series<br/> FRAMEOFFSET = nTM/2 * ones(Int32, nTerm+1, 1)<br/> FRAMEOFFSET[1] = 0<br/> FRAMEOFFSET[nTerm+1] *= 2 # n=24 is slow motion<br/> FRAMEOFFSET = cumsum(FRAMEOFFSET, dims=1)<br/> <br/> # generate audio tracks<br/> # <a class="ae kw" href="https://isip.piconepress.com/projects/speech/software/tutorials/production/fundamentals/v1.0/section_02/s02_01_p05.html" rel="noopener ugc nofollow" target="_blank">https://isip.piconepress.com/projects/speech/software/tutorials/production/fundamentals/v1.0/section_02/s02_01_p05.html</a><br/> if ((media_mask&amp;0x2==0) &amp;&amp; (iProc==1))<br/>  io = open("./ez2armst/_ez2armst.wav", "w")<br/>  <br/>  # write 44 byte .WAV header<br/>  write(io, "RIFF")    # RIFF tag (4 bytes)<br/>  uival::UInt32 = 0  # (to be completed after writing of audio data)<br/>  write(io, uival) +  # tag block size (4 bytes)<br/>  write(io, "WAVE") +  # WAVE tag (4 bytes)<br/>  write(io, "fmt ")  # format description header (4 bytes)<br/>  uival = 16<br/>  write(io, uival)  # tag block size (4 bytes)<br/>  usval::UInt16 = 1<br/>  write(io, usval)  # specify PCM encoding (2 bytes)<br/>  usval = 2<br/>  write(io, usval)  # specify stereo sampling (2 bytes)<br/>  uival = 44100<br/>  write(io, uival)  # specify sampling rate (4 bytes)<br/>  uival *= 4<br/>  write(io, uival)  # specify bytes/second (4 bytes)<br/>  usval = 4<br/>  write(io, usval)  # specify  block alignment (2 bytes)<br/>  usval = 16<br/>  write(io, usval)  # specify bits per sample (2 bytes)<br/>  write(io, "data")   # data description header (4 bytes)<br/>  uival = 0    # (to be completed after writing of audio data)<br/>  write(io, uival)  # specify # bytes of audio data (4 bytes)<br/>  <br/>  # write audio track data (subtracting off DC offset in PSC[1,:]<br/>  AUDIO = zeros(Int16, nT4, 2)<br/>  AUDIO2 = zeros(Int16, nT4, 2)<br/>  maxPSC = maximum(abs.(PSC - repeat(PSC[:,1], outer=(1,2*nTermMax+1))))<br/>  if (nProc == 1)<br/>   display(maxPSC)<br/>  end<br/>  I = 1:4:nTM<br/>  J = 1:2:nT2<br/>  for iTerm = 1:nTerm<br/>   kTerm = NTERM[iTerm]<br/>   iPS = 2*kTerm + 1 # +1 to skip DC component in PS<br/>   if (iTerm != nTerm)<br/>    AUDIO[:,1] = Int16.(round.((PSC[I,iPS]-PSC[I,1]) .* <br/>     (0x7fff*0.8/maxPSC)))<br/>    AUDIO[:,2] = Int16.(round.((PSC[I.+nTM,iPS]-PSC[I.+nTM,1]) .* <br/>     (0x7fff*0.8/maxPSC)))<br/>    for iBuf=1:nAudioBuf<br/>     write(io, AUDIO'[:])<br/>    end<br/>   else<br/>    AUDIO[:,1] = Int16.(round.((PSC[J,iPS]-PSC[J,1]) .* <br/>     (0x7fff*0.8/maxPSC)))<br/>    AUDIO[:,2] = Int16.(round.((PSC[J.+nTM,iPS]-PSC[J.+nTM,1]) .* <br/>     (0x7fff*0.8/maxPSC)))<br/>    AUDIO2[:,1] = Int16.(round.((PSC[J.+nT2,iPS]-PSC[J.+nT2,1]) .* <br/>     (0x7fff*0.8/maxPSC)))<br/>    AUDIO2[:,2] = Int16.(round.((PSC[J.+(nTM+nT2),iPS]-PSC[J.+(nTM+nT2),1]) .* <br/>     (0x7fff*0.8/maxPSC)))<br/>    for iBuf=1:nAudioBuf<br/>     write(io, AUDIO'[:])<br/>     write(io, AUDIO2'[:])<br/>    end<br/>   end<br/>  end # for iTerm=1:nTerm<br/>  <br/>  # complete .WAV file header and close file<br/>  fsize::UInt32 = position(io)<br/>  seek(io, 4)<br/>  write(io, fsize - UInt32(8))<br/>  seek(io, 40)<br/>  write(io, fsize - UInt32(44))<br/>  close(io)<br/> end<br/> <br/> # animate<br/> if (media_mask&amp;0x1 == 0)<br/>  if (nProc == 1)<br/>   print("generating 3D animation frames ") # start progress report line<br/>  end<br/>  iTerm1 = 1 + div((iProc-1)*nTerm, nProc, RoundNearest)<br/>  iTerm2 = div(iProc*nTerm, nProc, RoundNearest)<br/>  if (nProc &gt; 1)<br/>   str = <a class="ae kw" href="http://twitter.com/sprintf" rel="noopener ugc nofollow" target="_blank">@sprintf</a>("partition %d:%d ", iTerm1, iTerm2)<br/>   print(str)<br/>  end<br/>  for iTerm = iTerm1:iTerm2 # partitioned loop<br/>#  for iTerm = 1:nTerm   # original unpartitioned loop<br/>   print(".") # progress report: one '.' for each processed term in NTERM<br/>   kTerm = NTERM[iTerm]<br/>   iFrame::Int32 = FRAMEOFFSET[iTerm]<br/>   for iTM = 1:nTM<br/>    <br/>    # typically skip every other frame for speed<br/>    if (iTerm != nTerm)<br/>     if (mod(iTM,2)==0)<br/>      continue;<br/>     end<br/>    end<br/>    <br/>    # restore background plot but with new title<br/>    X = 2*ones(nT, 1);<br/>    plot(X,F[1:nT],F[nT+1:2*nT], <br/>     color = :cyan)<br/>    plot!( # M (i.e., slope) Weighted Average<br/>     [0, 2, NaN, 0, -2],<br/>     [-trapScale*MWA[1]*2, 0, NaN, -trapScale*MWA[2]*2, 0],<br/>     [0, 0, NaN, 0, 0],<br/>     color = :orange,<br/>     linestyle = :dot,<br/>     linewidth = 0.5);<br/>    strTitle = <a class="ae kw" href="http://twitter.com/sprintf" rel="noopener ugc nofollow" target="_blank">@sprintf</a>("%s\n(%s=%.2f, %s=%4d,\nt=%.4f, n=+/-%d)",<br/>     "complex Fourier series tracing letter 'e'",<br/>     "trapezoid height scale",<br/>     trapScale,<br/>     "sound frequency scale",<br/>     nAudioBuf,<br/>     iTM/nTM,<br/>     kTerm)<br/>    plot!(background=:white,<br/>     camera = (73, 20),<br/>     xlabel = "trapezoid baseline     ", <br/>     ylabel = "Re Sn", <br/>     zlabel = "\n\nIm Sn",<br/>     title = strTitle);<br/>    plot!(legend = false,<br/>     xlims = (-2,2),<br/>     ylims = (-0.99,1.99),<br/>     zlims = (-1,1),<br/>     xticks = 0:2:2,<br/>     yticks = -1:1:2,<br/>     zticks = -1:1:1,<br/>     figsize = (800,450))<br/>    plot!([-2, 2], [0, 0], [0, 0], <br/>     color = RGB(0.82,0.82,0.82))<br/>    plot!(-X,F[1:nT],F[nT+1:2*nT], color="cyan")<br/>    <br/>    # plot zigzag aggregated vectors (x=-2 plane)<br/>    XVEC = [-2, -2]<br/>    YVEC = [0, PS[iTM,1]]<br/>    ZVEC = [0, PS[iTM+nTM,1]]<br/>    plot!(XVEC, YVEC, ZVEC, <br/>     color = CSEQ[1], <br/>     linewidth = 1);<br/>    XVEC = [-2, -2, -2]<br/>    for iPS=2:2:2*kTerm<br/>     iColor::Int16 = mod(floor(iPS/2),3) + 1;<br/>     YVEC = [PSC[iTM,iPS-1], PSC[iTM,iPS], PSC[iTM,iPS+1]]<br/>     ZVEC = [PSC[iTM+nTM,iPS-1], PSC[iTM+nTM,iPS], PSC[iTM+nTM,iPS+1]]<br/>     plot!(XVEC, YVEC, ZVEC, <br/>      color = CSEQ[iColor], <br/>      linewidth = 1);<br/>    end<br/>    <br/>    # plot axes<br/>    plot!(xlims(), [0, 0], [0, 0], <br/>     color = :gray85);<br/>    plot!([2, 2], [0, ylims()[2]], [0, 0], <br/>     color = :gray85);<br/>    <br/>    # plot trapezoids<br/>    for iPS=1:kTerm+1<br/>     iColor::Int16 = mod(iPS-1,3) + 1;<br/>     S = R .^ ((iPS-1)/2) .* (1 .- R)<br/>     <br/>     # plot trapezoids (mid planes)<br/>     XTRAP = [<br/>      2*(1-R[1]^((iPS-1)/2)),<br/>      2*(1-R[1]^((iPS-1)/2)),<br/>      2*(1-R[1]^(iPS/2)),<br/>      2*(1-R[1]^(iPS/2)),<br/>      2*(1-R[1]^((iPS-1)/2)),<br/>      NaN,<br/>      -2*(1-R[2]^((iPS-1)/2)),<br/>      -2*(1-R[2]^((iPS-1)/2)),<br/>      -2*(1-R[2]^(iPS/2)),<br/>      -2*(1-R[2]^(iPS/2)),<br/>      -2*(1-R[2]^((iPS-1)/2))]<br/>     YTRAP = [<br/>      0,<br/>      trapScale*PSP[iTM,iPS]/S[1],<br/>      trapScale*PSP[iTM,iPS]/S[1] * R[1]^0.5,<br/>      0,<br/>      0,<br/>      NaN,<br/>      0,<br/>      trapScale*PSN[iTM,iPS]/S[2],<br/>      trapScale*PSN[iTM,iPS]/S[2] * R[2]^0.5,<br/>      0,<br/>      0]<br/>     ZTRAP = [<br/>      0,<br/>      trapScale*PSP[iTM+nTM,iPS]/S[1],<br/>      trapScale*PSP[iTM+nTM,iPS]/S[1] * R[1]^0.5,<br/>      0,<br/>      0,<br/>      NaN,<br/>      0,<br/>      trapScale*PSN[iTM+nTM,iPS]/S[2],<br/>      trapScale*PSN[iTM+nTM,iPS]/S[2] * R[2]^0.5,<br/>      0,<br/>      0]<br/>     plot!(XTRAP, YTRAP, ZTRAP, <br/>      color = CSEQ[iColor],<br/>      linewidth = 0.3);<br/>     <br/>     ## fill test column 5 of I_CMAG4 ##<br/>     # left edge of trapezoid is<br/>     # x(i) = 2*(1 - r^(i/2))<br/>     #<br/>     # width of trapezoid base is<br/>     # b(i) = x(i+1) - x(i)<br/>     #      = 2*r^(i/2)*(1 - r^(1/2))<br/>     #<br/>     # given lefth height (h(i)), right height of trapezoid is<br/>     # h(i+1) = h(i)*r^(1/2)<br/>     #<br/>     # trapezoid area is<br/>     # |C| = h(i)*b(i) - 1/2(h(i) - h(i+1))*b(i)<br/>     #     = h(i)*r^(i/2)*(1 - r)<br/>     #<br/>     # where h is trapezoid height, r is common ratio,<br/>     # and i is the power of the term represented by<br/>     # the trapezoid area<br/>     if ((kTerm == nTermMax) &amp;&amp; (iTM == 1))<br/>      I = [2; 8]<br/>      H = ((YTRAP[I].^2 + ZTRAP[I].^2).^0.5) ./ trapScale<br/>      if (iPS &gt; 1)<br/>       I = [nTermMax+iPS; nTermMax+2-iPS]<br/>       I_CMAG4[I,5] = H .* R .^ ((iPS-1)/2) .* (1 .- R)<br/>      else<br/>       ADC = H .* (1 .- R) # Area of DC trapezoids<br/>       I_CMAG4[nTermMax+1,5] = sum(ADC, dims=1)[1]<br/>      end<br/>     end<br/>    end<br/>    <br/>    # plot dotted trail of partial sum<br/>    if ((kTerm &gt;= 1) &amp;&amp; (kTerm &lt;= 10))<br/>     YVEC = PSTC[1:nTM,kTerm]<br/>     ZVEC = PSTC[nTM+1:end,kTerm]<br/>     plot!(XZ[1:nTM] .- 2, YVEC, ZVEC, <br/>      linestyle = :dot,<br/>      color = :gray80)<br/>     plot!(XZ[1:nTM] .+ 2, YVEC, ZVEC, <br/>      linestyle = :dot,<br/>      color = :gray80)<br/>    end<br/>    YVEC = PSTC[1:iTM,kTerm+1]<br/>    ZVEC = PSTC[nTM+1:nTM+iTM,kTerm+1]<br/>    plot!(XZ[1:iTM] .- 2, YVEC, ZVEC, <br/>     linestyle = :dot,<br/>     color = :black)<br/>    plot!(XZ[1:iTM] .+ 2, YVEC, ZVEC, <br/>     linestyle = :dot,<br/>     color = :black)<br/>    <br/>    # plot 2-arm aggregated vectors (x=2 plane)<br/>    XVEC = [2, 2, NaN, 2, 2]<br/>    for iPS=1:kTerm+1<br/>     iColor::Int16 = mod(iPS-1,3) + 1<br/>     <br/>     YVEC = [PSPC[iTM,iPS],<br/>      PSPC[iTM,iPS]-PSP[iTM,iPS],<br/>      NaN,<br/>      PSNC[iTM,iPS],<br/>      PSNC[iTM,iPS]-PSN[iTM,iPS]]<br/>     ZVEC = [PSPC[iTM+nTM,iPS],<br/>      PSPC[iTM+nTM,iPS]-PSP[iTM+nTM,iPS],<br/>      NaN,<br/>      PSNC[iTM+nTM,iPS],<br/>      PSNC[iTM+nTM,iPS]-PSN[iTM+nTM,iPS]]<br/>     plot!(XVEC, YVEC, ZVEC, <br/>      color = CSEQ[iColor], <br/>      linewidth = 2)<br/>    end<br/>    <br/>    # plot '+' vector addition cross-hair<br/>    iPS = kTerm + 1<br/>    YVEC = [<br/>     PSTC[iTM,iPS]-dCross/2,<br/>     PSTC[iTM,iPS]+dCross/2,<br/>     NaN,<br/>     PSTC[iTM,iPS],<br/>     PSTC[iTM,iPS]]<br/>    ZVEC = [<br/>     PSTC[iTM+nTM,iPS],<br/>     PSTC[iTM+nTM,iPS],<br/>     NaN,<br/>     PSTC[iTM+nTM,iPS]-dCross/2,<br/>     PSTC[iTM+nTM,iPS]+dCross/2];<br/>    plot!(XVEC .- 4, YVEC, ZVEC, <br/>     color = :black,<br/>     linewidth = 1);<br/>    plot!(XVEC, YVEC, ZVEC, <br/>     color = :black,<br/>     linewidth = 1);<br/>    plot!(XDOT .+ 2, <br/>     YDOT .+ PSTC[iTM,iPS]/2,<br/>     ZDOT .+ PSTC[iTM+nTM,iPS]/2, <br/>     color = :black, <br/>     linewidth = 1);<br/>    <br/>    # print scene's frames<br/>    iFrame += 1<br/>    fname = <a class="ae kw" href="http://twitter.com/sprintf" rel="noopener ugc nofollow" target="_blank">@sprintf</a>("./ez2armst/frame%05d.png", iFrame);<br/>    savefig(fname)<br/>    # print("-dpng", "-r400", "-Farial:10", fname);<br/>   end # iT=1:nT<br/>  end # for kTerm=NTERM<br/>  print("\n") # end progress report line<br/> end # if (media_mask&amp;0x1 == 0)<br/> <br/> # plot _pce.png (where PCE is Plot Coefficient Error) to show <br/> #    consistency of calculated coefficient magnitude |C| values in I_CMAG4<br/> if (nProc == 1)<br/>  print("plotting (_pce.png) the numerical (e.g., trig approximation) errors in coefficient calculations ...\n")<br/>  X = I_CMAG4[:,1]<br/>  Y = diff(I_CMAG4[:,2:5], dims=2)<br/>  plot(X, Y)<br/>  savefig("_pce.png")<br/> # display("I_CMAG4[nTermMax+1-5:nTermMax+1+5,:]"); display(I_CMAG4[nTermMax+1-5:nTermMax+1+5,:])<br/> end<br/> <br/> # /tool/ffmpeg-4.3.1/bin/ffmpeg -f image2 -i frame%05d.png -i _ez2armst.mp3 -vf scale=1080:-2,setsar=1:1 -f mp4 -q:v 0 -vcodec mpeg4 -r 20 _ez2armst.mp4<br/> # /tool/ffmpeg-4.3.1/bin/ffmpeg -f image2 -i frame%05d.png -vf scale=1080:-2,setsar=1:1 -f mp4 -q:v 0 -vcodec mpeg4 -r 20 _ez2armst.mp4<br/> # /tool/ffmpeg-4.3.1/bin/ffmpeg -i _ez2armst.mp4 -c:v libvpx-vp9 -crf 30 -b:v 4M  _ez2armst.webm<br/> # see <a class="ae kw" href="https://trac.ffmpeg.org/wiki/Encode/VP9" rel="noopener ugc nofollow" target="_blank">https://trac.ffmpeg.org/wiki/Encode/VP9</a><br/>end</span></pre><h2 id="23b2" class="nu ky iq bd kz on oo dn ld op oq dp lh ly or os lj mc ot ou ll mg ov ow ln ox bi translated">附录C. Julia源代码</h2><p id="f9df" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx ly lz ma mb mc md me mf mg mh mi mj mk ij bi translated">下面的Julia代码生成复杂几何级数的动画帧。</p><pre class="kg kh ki kj gt np nq nr ns aw nt bi"><span id="1619" class="nu ky iq nq b gy nv nw l nx ny"># import Pkg; Pkg.add("Plots"); Pkg.add("PyPlot")<br/>using Plots, Printf<br/>pyplot()</span><span id="7c33" class="nu ky iq nq b gy oy nw l nx ny"># cgs: Complex Geometric Series <br/># isTrapezoid: 0/1 flag for rotating triangles/trapezoids<br/># a: coefficient<br/># r: common ratio<br/># n: power of last term in partial series<br/># nAudioBuf: audio buffer count per animated fundamental period<br/># example: cgs() <br/>function cgs(isTrapezoid::Int64=0,<br/> a::Float64=1.0, <br/> r::Float64=0.5, <br/> n::Int64=10, <br/> nAudioBuf::Int64=3530)<br/> <br/> # define some plotting parameters <br/> nT = Int32(400)   # # of non-repeated Time samples<br/> nT1 = nT + 1   # # of Time samples<br/> T = range(0, stop=1, length=nT1) # Time samples<br/> nT2 = Int32(nT/2)<br/> THETA = 2*pi*T   # angle samples of plot's 'o' symbol<br/> NTERM = 1:n<br/> nTerm = size(NTERM,1)<br/> nTermMax = last(NTERM)<br/> maxSum = a/(1-abs(r)) # for setting plot limits<br/> maxRadius = a*abs(r)/(1-r^2)<br/> dCross = 0.15   # diameter of '+' symbol<br/> trapScale = 0.5   # trapezoid scale<br/> CSEQ = [:red, :green, :blue, :yellow, :white, :black] # Color SEQuence<br/> <br/> # calculate partial series terms<br/> PS = zeros(2*nT, nTermMax+1) # Partial Sum<br/> PS[1:nT,1] .= a<br/> for jTerm=1:nTermMax<br/>  EM = [ sin.(jTerm*THETA)] # nT x 2<br/>  PS[1:nT,jTerm+1] = (a * r^jTerm) .* <br/>   cos.(jTerm*THETA[1:end-1])<br/>  PS[nT+1:end,jTerm+1] = (a * r^jTerm) .*<br/>   sin.(jTerm*THETA[1:end-1])<br/> end<br/> PSC = cumsum(PS, dims=2);<br/> <br/> # calculate frame offsets where new terms are added to partial series<br/> FRAMEOFFSET = nT * ones(Int32, nTerm+1, 1)<br/> FRAMEOFFSET[1] = 0<br/> FRAMEOFFSET = cumsum(FRAMEOFFSET, dims=1)<br/> <br/> # generate audio tracks<br/> io = open("./cgs/cgs.wav", "w")<br/> <br/> # write 44 byte .WAV header<br/> write(io, "RIFF")    # RIFF tag (4 bytes)<br/> uival::UInt32 = 0  # (to be completed after writing of audio data)<br/> write(io, uival) +  # tag block size (4 bytes)<br/> write(io, "WAVE") +  # WAVE tag (4 bytes)<br/> write(io, "fmt ")  # format description header (4 bytes)<br/> uival = 16<br/> write(io, uival)  # tag block size (4 bytes)<br/> usval::UInt16 = 1<br/> write(io, usval)  # specify PCM encoding (2 bytes)<br/> usval = 2<br/> write(io, usval)  # specify stereo sampling (2 bytes)<br/> uival = 44100<br/> write(io, uival)  # specify sampling rate (4 bytes)<br/> uival *= 4<br/> write(io, uival)  # specify bytes/second (4 bytes)<br/> usval = 4<br/> write(io, usval)  # specify  block alignment (2 bytes)<br/> usval = 16<br/> write(io, usval)  # specify bits per sample (2 bytes)<br/> write(io, "data")   # data description header (4 bytes)<br/> uival = 0    # (to be completed after writing of audio data)<br/> write(io, uival)  # specify # bytes of audio data (4 bytes)<br/> <br/> # write audio track data (subtracting off DC offset in PSC[1,:]<br/> AUDIO = zeros(Int16, nT2, 2)<br/> I = 1:2:nT<br/> for iTerm = 1:nTerm<br/>  kTerm = NTERM[iTerm]<br/>  if (mod(iTerm,2) == 0)  # if power of last term is even<br/>   minmaxmid = a*(1 - (abs(r))^(kTerm+2)) / (1 - (abs(r))^2)<br/>  else      # else power of last term is odd<br/>   minmaxmid = a*(1 - (abs(r))^(kTerm+1)) / (1 - (abs(r))^2)<br/>  end<br/>  AUDIO[:,1] = Int16.(round.((PSC[I,kTerm+1] .- minmaxmid) .* <br/>   (0x7fff*0.8/maxRadius)))<br/>  AUDIO[:,2] = Int16.(round.(PSC[I.+nT,kTerm+1] .* <br/>   (0x7fff*0.8/maxRadius)))<br/>  for iBuf=1:nAudioBuf<br/>   write(io, AUDIO'[:])<br/>  end<br/> end # for iTerm=1:nTerm<br/> <br/> # complete .WAV file header and close file<br/> fsize::UInt32 = position(io)<br/> seek(io, 4)<br/> write(io, fsize - UInt32(8))<br/> seek(io, 40)<br/> write(io, fsize - UInt32(44))<br/> close(io)<br/> <br/> # define circle traced by complex geometric series<br/> ycenter = a / (1 - r^2)<br/> zcenter = 0<br/> TH = range(0, stop=2*pi, length=nT1)<br/> XCIRC = 2*ones(nT1, 1)<br/> YCIRC = ycenter .+ maxRadius .* cos.(TH)<br/> ZCIRC = zcenter .+ maxRadius .* sin.(TH)<br/> <br/> # animate<br/> print("generating 3D animation frames ") # start progress report line<br/> PO = Vector{Plots.Plot{Plots.PyPlotBackend}}(undef,nTerm) # Plot Objects<br/> for iTerm = 1:nTerm<br/>  print(".") # progress report: one '.' for each processed term in NTERM<br/>  kTerm = NTERM[iTerm]<br/>  iFrame::Int32 = FRAMEOFFSET[iTerm]<br/>  for iT = 1:nT<br/>   <br/>   # restore background plot but with new title<br/>   if (isTrapezoid &gt; 0)<br/>    strTitle = <a class="ae kw" href="http://twitter.com/sprintf" rel="noopener ugc nofollow" target="_blank">@sprintf</a>(<br/>     "%s\n(%s=%.2f, %s=%.2fexp(iθ),\n%s=%.2f, %s=%d,\nt=%.4f, n=%d)",<br/>     "complex geometric series",<br/>     "coefficient a", a,<br/>     "common ratio r", r,<br/>     "trapezoid scale", trapScale,<br/>     "sound frequency scale", nAudioBuf,<br/>     (iT-1)/nT, <br/>     kTerm)<br/>   else<br/>    strTitle = <a class="ae kw" href="http://twitter.com/sprintf" rel="noopener ugc nofollow" target="_blank">@sprintf</a>(<br/>     "%s\n(%s=%.2f, %s=%.2fexp(iθ),\n%s=%d,\nt=%.4f, n=%d)",<br/>     "complex geometric series",<br/>     "coefficient a", a,<br/>     "common ratio r", r,<br/>     "sound frequency scale", nAudioBuf,<br/>     (iT-1)/nT, <br/>     kTerm)<br/>   end<br/>   PO[iTerm] = plot(background=:white,<br/>    camera = (73, 20),<br/>    xlabel = "x", <br/>    ylabel = "y", <br/>    zlabel = "z",<br/>    title = strTitle)<br/>   plot!(legend = false,<br/>    xlims = (0,2),<br/>    ylims = (-0.5,2.0),<br/>    zlims = (-0.85,0.85),<br/>    xticks = 0:2:2,<br/>    yticks = 0:1:2,<br/>    zticks = -1:1:1,<br/>    figsize = (800,450))<br/>   <br/>   # plot axes<br/>   plot!([2, 2], [0, ylims()[2]], [0, 0], <br/>    color = :gray85);<br/>   <br/>   # plot trapezoids or triangles<br/>   if (isTrapezoid &gt; 0)<br/>    # plot trapezoids<br/>    for iPS=1:kTerm+1<br/>     s = r ^ ((iPS-1)/2) * (1 - r)<br/>     iColor::Int16 = mod(iPS-1,3) + 1;<br/>     XTRAP = [<br/>      2*r^((iPS-1)/2),<br/>      2*r^((iPS-1)/2),<br/>      2*r^(iPS/2),<br/>      2*r^(iPS/2),<br/>      2*r^((iPS-1)/2)]<br/>     YTRAP = [<br/>      0,<br/>      trapScale*PS[iT,iPS]/s,<br/>      trapScale*PS[iT,iPS]/s * r^0.5,<br/>      0,<br/>      0]<br/>     ZTRAP = [<br/>      0,<br/>      trapScale*PS[iT+nT,iPS]/s,<br/>      trapScale*PS[iT+nT,iPS]/s * r^0.5,<br/>      0,<br/>      0]<br/>     plot!(XTRAP, YTRAP, ZTRAP, <br/>      color = CSEQ[iColor],<br/>      linewidth = 0.3);<br/>    end<br/>   else<br/>    # plot triangles<br/>    for iPS=1:kTerm+1<br/>     iColor::Int16 = mod(iPS-1,3) + 1;<br/>     XTRI = [<br/>      0,<br/>      2*r^((iPS-1)/2),<br/>      2*r^((iPS-1)/2),<br/>      0]<br/>     YTRI = [<br/>      0,<br/>      0,<br/>      2*PS[iT,iPS]/XTRI[3],<br/>      0]<br/>     ZTRI = [<br/>      0,<br/>      0,<br/>      2*PS[iT+nT,iPS]/XTRI[3],<br/>      0]<br/>     plot!(XTRI, YTRI, ZTRI, <br/>      color = CSEQ[iColor],<br/>      linewidth = 0.3);<br/>    end<br/>   end<br/>   plot!(XCIRC, YCIRC, ZCIRC, color="cyan")<br/>   <br/>   # plot dotted trail of partial sum<br/>   if ((kTerm &gt;= 1) &amp;&amp; (kTerm &lt;= 10))<br/>    YVEC = PSC[1:nT,kTerm]<br/>    ZVEC = PSC[nT+1:end,kTerm]<br/>    plot!(XCIRC[1:nT], YVEC, ZVEC, <br/>     linestyle = :dot,<br/>     color = :gray80)<br/>   end<br/>   YVEC = PSC[1:iT,kTerm+1]<br/>   ZVEC = PSC[nT+1:nT+iT,kTerm+1]<br/>   plot!(XCIRC[1:iT], YVEC, ZVEC, <br/>    linestyle = :dot,<br/>    color = :black)<br/>   <br/>   # plot 1-arm aggregated vectors (x=2 plane)<br/>   XVEC = [2, 2]<br/>   for iPS=1:kTerm+1<br/>    iColor::Int16 = mod(iPS-1,3) + 1<br/>    YVEC = [<br/>     PSC[iT,iPS],<br/>     PSC[iT,iPS]-PS[iT,iPS]]<br/>    ZVEC = [<br/>     PSC[iT+nT,iPS],<br/>     PSC[iT+nT,iPS]-PS[iT+nT,iPS]]<br/>    plot!(XVEC, YVEC, ZVEC, <br/>     color = CSEQ[iColor], <br/>     linewidth = 2)<br/>   end<br/>   <br/>   # print scene's frames<br/>   iFrame += 1<br/>   fname = <a class="ae kw" href="http://twitter.com/sprintf" rel="noopener ugc nofollow" target="_blank">@sprintf</a>("./cgs/frame%05d.png", iFrame);<br/>   savefig(fname)<br/>  end # iT=1:nT<br/> end # for kTerm=NTERM<br/> print("\n") # end progress report line<br/> <br/> # /tool/ffmpeg-4.3.1/bin/ffmpeg -f image2 -i frame%05d.png -i cgs.mp3 -vf scale=1080:-2,setsar=1:1 -f mp4 -q:v 0 -vcodec mpeg4 -r 20 cgs.mp4<br/> # /tool/ffmpeg-4.3.1/bin/ffmpeg -f image2 -i frame%05d.png -vf scale=1080:-2,setsar=1:1 -f mp4 -q:v 0 -vcodec mpeg4 -r 20 cgs.mp4<br/> # /tool/ffmpeg-4.3.1/bin/ffmpeg -i cgs.mp4 -c:v libvpx-vp9 -crf 30 -b:v 4M  cgs.webm<br/> # see <a class="ae kw" href="https://trac.ffmpeg.org/wiki/Encode/VP9" rel="noopener ugc nofollow" target="_blank">https://trac.ffmpeg.org/wiki/Encode/VP9</a><br/>end</span></pre><h2 id="66a4" class="nu ky iq bd kz on oo dn ld op oq dp lh ly or os lj mc ot ou ll mg ov ow ln ox bi translated">附录D. Julia源代码</h2><p id="1474" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx ly lz ma mb mc md me mf mg mh mi mj mk ij bi translated">下面的Julia代码将复杂的傅立叶级数动画帧生成分发到六个CPU内核，并在11.1分钟内完成，比GNU Octave生成动画帧所需的120分钟快10倍。</p><pre class="kg kh ki kj gt np nq nr ns aw nt bi"><span id="13bf" class="nu ky iq nq b gy nv nw l nx ny"># file: cfsed.jl (complex Fourier series tracing 'e' distributed)<br/># import Pkg.add("Distributed")<br/>using Distributed</span><span id="e638" class="nu ky iq nq b gy oy nw l nx ny">addprocs(4, exeflags="--project=.")<br/><a class="ae kw" href="http://twitter.com/everywhere" rel="noopener ugc nofollow" target="_blank">@everywhere</a> begin<br/> include("cfse.jl")<br/>end</span><span id="2a57" class="nu ky iq nq b gy oy nw l nx ny">nProc = 8<br/>pmap(1:nProc) do i<br/> cfse(0, i, nProc)<br/>end</span></pre><h2 id="9878" class="nu ky iq bd kz on oo dn ld op oq dp lh ly or os lj mc ot ou ll mg ov ow ln ox bi translated">附录E. Julia源代码</h2><p id="5dbb" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx ly lz ma mb mc md me mf mg mh mi mj mk ij bi translated">下面是Julia代码，它生成各种图形，包括几何级数自相似动画和一个几何级数图形，作为数学知识主体的参考系的原点。</p><pre class="kg kh ki kj gt np nq nr ns aw nt bi"><span id="42d6" class="nu ky iq nq b gy nv nw l nx ny"># file: some1.jl (miscellaneous code for Summer Of Math Exposition #1)<br/># import Pkg; Pkg.add("Plots"); Pkg.add("PyPlot")<br/>using Measures, Printf, LaTeXStrings, Plots<br/>pyplot(dpi=600)</span><span id="9f9e" class="nu ky iq nq b gy oy nw l nx ny">function tstplt6()<br/> a = 1:3<br/> b = [1, 2, 7]<br/> plot(a, b, <br/>  label = "randData", <br/>  xlabel = "numbers", <br/>  ylabel = "Rand data",<br/>  color = :red, <br/>  legend = :topleft,<br/>  tick_direction = :in,<br/>  grid = :on,<br/>  left_margin=2cm, right_margin=8cm, top_margin=2cm)<br/> p = twinx()<br/> plot!(p, a, log.(a), <br/>  label = "log(x)", <br/>  ylabel = "The right Y label",<br/>  color = :green,<br/>  legend = :topright,<br/>  tick_direction = :out,<br/>#  grid = :on,<br/>  left_margin=2cm, right_margin=8cm, top_margin=2cm,<br/>  box = :on)<br/> savefig("tstplt6.png")<br/>end</span><span id="17dc" class="nu ky iq nq b gy oy nw l nx ny">function tstplt7()<br/> a = 1:3<br/> b = [1, 2, 7]<br/> plot(a, b, <br/>  label = "randData", <br/>  xlabel = "numbers", <br/>  ylabel = "Rand data",<br/>  color = :red, <br/>  legend = :topleft,<br/>  grid = :on, left_margin=2cm, right_margin=8cm, top_margin=2cm)<br/> plot!(twinx(), a, log.(a), <br/>  label = "log(x)", <br/>  ylabel = "The right Y label",<br/>  color = :green,<br/>  legend = :bottomright,<br/>        grid = :on, left_margin=2cm, right_margin=8cm, top_margin=2cm)<br/> savefig("tstplt7.png")<br/>end</span><span id="9a0f" class="nu ky iq nq b gy oy nw l nx ny"># bok: Body Of Knowledge<br/># iPoint: index specifying last point to plot<br/># example: bok() <br/>function bok(iPoint::Int64=13)<br/> <br/> # initialize<br/> n = 12<br/> xmax = div(n^2,10,RoundUp) * 10<br/> ymax = div(4*n+2,10,RoundUp) * 10<br/> plot(seriestype = :scatter,<br/>  xaxis = :log10,<br/>  yaxis = :log10,  <br/>  xlims = (0.4, 180),<br/>  ylims = (0.8, 120),<br/>  xticks = ([0.5, 1, 2, 10, 100, n^2],<br/>   [latexstring(L"-\infty"),<br/>   latexstring(L"10^0"),<br/>   "2",<br/>   latexstring(L"10^1"),<br/>   latexstring(L"10^2"),<br/>   latexstring(L"n^2")]),<br/>  xlabel = latexstring("common ratio ", L"r", "\ndegrees of freedom"), <br/>  ylabel = latexstring("coefficient ", L"a", "\ndegrees of freedom"),<br/>  grid = :on,<br/>  left_margin=2cm, right_margin=8cm, top_margin=2cm) <br/> plot!(twinx(),<br/>  seriestype = :scatter,<br/>  xaxis = :log10,<br/>  yaxis = :log10,  <br/>  xlims = (0.4, 180),<br/>  ylims = (0.8, 120),<br/>  yticks = ([1, 6, 8, 10, n+1, 4*n+2, 100], <br/>   ["", <br/>   "6", <br/>   "8", <br/>   "", <br/>   latexstring(L"n+1"), <br/>   latexstring(L"4n+2"), <br/>   ""]),<br/>  grid = :on,<br/>  left_margin=2cm, right_margin=8cm, top_margin=2cm)</span><span id="95f7" class="nu ky iq nq b gy oy nw l nx ny"># geometric series<br/> A = [1]<br/> R = [1]<br/> plot!(R, A,<br/>  marker = :circle,<br/>  markersize = 16,<br/>  color = :white,<br/>  markerstrokecolor = :red,<br/>  label = "geometric series")<br/> <br/> # geometric series closed form<br/> A = [1]<br/> R = [1]<br/> plot!(R, A,<br/>  xaxis = :log10,<br/>  yaxis = :log10,  <br/>  marker = :utriangle,<br/>  markersize = 10,<br/>  color = :red,<br/>  linecolor = :white,<br/>  label = "geometric series closed form")<br/> if (iPoint &lt;= 2)<br/>  <a class="ae kw" href="http://twitter.com/goto" rel="noopener ugc nofollow" target="_blank">@goto</a> printplot<br/> end<br/> <br/> <br/> # complex geometric series<br/> A = [1]<br/> R = [2]<br/> plot!(R, A,<br/>  marker = :circle,<br/>  markersize = 16,<br/>  color = :white,<br/>  markerstrokecolor = :green,<br/>  label = "complex geometric series")<br/> <br/> # complex geometric series closed form<br/> A = [1]<br/> R = [2]<br/> plot!(R, A,<br/>  marker = :utriangle,<br/>  markersize = 10,<br/>  color = :green, <br/>  linecolor = :white,<br/>  label = "complex geometric series closed form")<br/> if (iPoint &lt;= 4)<br/>  <a class="ae kw" href="http://twitter.com/goto" rel="noopener ugc nofollow" target="_blank">@goto</a> printplot<br/> end<br/> <br/> <br/> # Laurent series<br/> A = [4*n+2]<br/> R = [2]<br/> plot!(R, A,<br/>  marker = :circle,<br/>  markersize = 16,<br/>  color = :white,<br/>  markerstrokecolor = :red,<br/>  label = "Laurent series")<br/> <br/> # complex Fourier series<br/> A = [4*n+2]<br/> R = [2]<br/> plot!(R, A,<br/>  marker = :pentagon,<br/>  markersize = 10,<br/>  color = :red,<br/>  linecolor = :white,<br/>  label = "complex Fourier series")<br/> if (iPoint &lt;= 6)<br/>  <a class="ae kw" href="http://twitter.com/goto" rel="noopener ugc nofollow" target="_blank">@goto</a> printplot<br/> end<br/> <br/> <br/> # power series<br/> A = [n+1]<br/> R = [1]<br/> plot!(R, A,<br/>  marker = :circle,<br/>  markersize = 16,<br/>  color = :white,<br/>  markerstrokecolor = :blue,<br/>  label = "power series")<br/> <br/> # Taylor series<br/> A = [n+1]<br/> R = [1]<br/> plot!(R, A,<br/>  marker = :square,<br/>  markersize = 10,<br/>  color = :blue,<br/>  linecolor = :white,<br/>  label = "Taylor series")<br/> if (iPoint &lt;= 8)<br/>  <a class="ae kw" href="http://twitter.com/goto" rel="noopener ugc nofollow" target="_blank">@goto</a> printplot<br/> end<br/> <br/> <br/> # binary encoded numbers<br/> A = [n+1]<br/> R = [0.5]<br/> plot!(R, A,<br/>  marker = :circle,<br/>  markersize = 12,<br/>  color = :white,<br/>  markerstrokecolor = :black,<br/>  markerstrokewidth = 3,<br/>  label = "binary encoded numbers")<br/> annotate!(0.65, 0.8, # impose text white background<br/>  text("█", <br/>   :white,<br/>   :center))<br/> annotate!(0.65, 0.8, # denote axis split<br/>  text("/ /",<br/>   :black,<br/>   :center))<br/> if (iPoint &lt;= 9)<br/>  <a class="ae kw" href="http://twitter.com/goto" rel="noopener ugc nofollow" target="_blank">@goto</a> printplot<br/> end</span><span id="3347" class="nu ky iq nq b gy oy nw l nx ny"># Bezier curves<br/> A = [6]<br/> R = [1]<br/> plot!(R, A,<br/>  marker = :utriangle,<br/>  markersize = 12,<br/>  color = :white,<br/>  markerstrokecolor = :black,<br/>  markerstrokewidth = 3,<br/>  label = "quadratic Bezier curves")<br/> A = [8]<br/> R = [1]<br/> plot!(R, A,<br/>  marker = :square,<br/>  markersize = 12,<br/>  color = :white,<br/>  markerstrokecolor = :black,<br/>  markerstrokewidth = 3,<br/>  label = "cubic Bezier curves")<br/> if (iPoint &lt;= 11)<br/>  <a class="ae kw" href="http://twitter.com/goto" rel="noopener ugc nofollow" target="_blank">@goto</a> printplot<br/> end<br/> <br/> <br/> # matrix polynomials<br/> A = [1]<br/> R = [n^2]<br/> plot!(R, A,<br/>  marker = :circle,<br/>  markersize = 16,<br/>  color = :white,<br/>  markerstrokecolor = :green,<br/>  label = "matrix polynomials")<br/> <br/> # matrix exponentials<br/> A = [1]<br/> R = [n^2]<br/> plot!(R, A,<br/>  marker = :hexagon,<br/>  markersize = 10,<br/>  color = :green,<br/>  linecolor = :white,<br/>  label = "matrix exponentials")<br/> <br/> <br/><a class="ae kw" href="http://twitter.com/label" rel="noopener ugc nofollow" target="_blank">@label</a> printplot<br/> if (iPoint &lt; 13)<br/>  fname = <a class="ae kw" href="http://twitter.com/sprintf" rel="noopener ugc nofollow" target="_blank">@sprintf</a>("bok%02d.png", iPoint)<br/> else<br/>  fname = "bok.png"<br/> end<br/> savefig(fname)<br/>end</span><span id="a320" class="nu ky iq nq b gy oy nw l nx ny">rectangle(w, h, x, y) = Shape(x .+ [0,w,w,0], y .+ [0,0,h,h])</span><span id="9385" class="nu ky iq nq b gy oy nw l nx ny">function fp32()<br/> # initialize<br/> nBit = 32<br/> x0 = 1<br/> x1 = 15<br/> y0 = 3<br/> y1 = 4<br/> plot(legend = false,<br/>  showaxis = false,<br/>  size = (800, 300),<br/>  ticks = false,<br/>  xlims = (0, 16),<br/>  ylims = (0, 6),<br/>  title = "binary32 IEEE 754 standard\n" *<br/>   "single-precision floating point number format")<br/> <br/> # color bit fields<br/> plot!(rectangle(23*(x1-x0)/nBit,1, x1-23*(x1-x0)/nBit,y0), <br/>  opacity = 0.3,<br/>  color = :red)<br/> plot!(rectangle(8*(x1-x0)/nBit,1, x0+(x1-x0)/nBit,y0), <br/>  opacity = 0.3,<br/>  color = :green)<br/> plot!(rectangle((x1-x0)/nBit,1, x0,y0), <br/>  opacity = 0.3,<br/>  color = :blue)<br/> <br/> # draw bit boundaries<br/> plot!([x0; x1], [y0; y0],<br/>  color = :black)<br/> plot!([x0; x1], [y1; y1],<br/>  color = :black)<br/> for iBit=0:nBit<br/>  x = x1 - iBit*(x1-x0)/nBit<br/>  plot!([x; x], [y0; y1], color = :black)<br/>  if (iBit &lt; nBit)<br/>   annotate!(x-(x1-x0)/(2*nBit), y1+0.5, <br/>    text(string(mod(iBit,10)), :black, :hcenter))<br/>  end<br/>  if (mod(iBit,10) == 0)<br/>   annotate!(x-(x1-x0)/(2*nBit), y1+1.2, <br/>    text(string(div(iBit,10)), :black, :hcenter))<br/>  end <br/> end<br/> <br/> # write labels<br/> annotate!(x0, y1+0.8, text("bit #:", :black, :right))<br/> annotate!(x1-23/2*(x1-x0)/nBit, y0-0.5, text("fraction (23 bits)", :black, :hcenter))<br/> annotate!(x0+(1+8/2)*(x1-x0)/nBit, y0-0.5, text("exponent (8 bits)", :black, :hcenter))<br/> annotate!(x0+(x1-x0)/(2*nBit), y0-0.7, text("sign", :center, rotation = 90))<br/> <br/> fname = "fp32.png"<br/> savefig(fname)<br/>end</span><span id="d11f" class="nu ky iq nq b gy oy nw l nx ny">trapezoid(x0, y0, x1, y1) = Shape([x0,x0,x1,x1], [0,y0,y1,0])</span><span id="80a6" class="nu ky iq nq b gy oy nw l nx ny">function selfsim()<br/> print("selfsim")<br/> <br/> # initialize<br/> CSEQ = [:red, :green, :blue] # Color SEQuence<br/> nTrap::Int32 = 25<br/> nFrame::Int32 = 80<br/> xmaxmax = 2.0<br/> xmaxmin = 1.0<br/> dgrid = 0.5<br/> r = (1/2)^(2/3)<br/> <br/> # for each animation frame<br/> for iFrame = 0:nFrame-1<br/> <br/>  # display progress<br/>  if (mod(iFrame+1,10) == 0)<br/>   print(".")<br/>  end<br/>  <br/>  # start plot of new frame<br/>  xmax = xmaxmax - (xmaxmax-xmaxmin)*iFrame/nFrame<br/>  # print("\n", xmax, "&gt;")<br/>  plot(legend = false,<br/>   box = true,<br/>   ticks = false,<br/>   aspect_ratio = :equal,<br/>   xlims = (0, xmax),<br/>   ylims = (0, 1.5*xmax))<br/>  <br/>  # prepare first (smallest) trapezoid<br/>  x0 = 2*r^(nTrap/2)<br/>  y0 = r^(nTrap/2)/(1-r)<br/>  x1 = 2*r^((nTrap-1)/2)<br/>  y1 = r^((nTrap-1)/2)/(1-r)<br/>  <br/>  # for each trapezoid<br/>  for iTrap = nTrap-1:-1:0<br/>   iColor::Int16 = mod(iTrap,3) + 1;<br/>   <br/>   # color trapezoid area<br/>   plot!(trapezoid(x0,y0, x1,y1),  <br/>    opacity = 0.3,<br/>    color = CSEQ[iColor])<br/>   <br/>   # prepare next trapezoid<br/>   x0 = x1<br/>   y0 = y1<br/>   x1 = 2*r^((iTrap-1)/2)<br/>   y1 = r^((iTrap-1)/2)/(1-r)<br/>  end<br/>  fname = <a class="ae kw" href="http://twitter.com/sprintf" rel="noopener ugc nofollow" target="_blank">@sprintf</a>("./selfsim/frame%05d.png", iFrame);<br/>  savefig(fname)<br/> end<br/> print("\n")<br/> <br/> # /tool/ffmpeg-4.3.1/bin/ffmpeg -i _selfsim.mp4 -r 12 _selfsim.gif<br/> # /tool/ffmpeg-4.3.1/bin/ffmpeg -f image2 -i frame%05d.png -vf scale=1080:-2,setsar=1:1 -f mp4 -q:v 0 -vcodec mpeg4 -r 20 _selfsim.mp4<br/> # see <a class="ae kw" href="https://trac.ffmpeg.org/wiki/Encode/VP9" rel="noopener ugc nofollow" target="_blank">https://trac.ffmpeg.org/wiki/Encode/VP9</a><br/>end</span><span id="9a78" class="nu ky iq nq b gy oy nw l nx ny"># tsa: Taylor Series Approximation <br/># nDegree: degree of last term in partial series<br/># example: tsa() <br/>function tsa(nDegree::Int64=19)<br/> <br/> # define coefficients (1-based index)<br/> C = [<br/>  0, 1/factorial(1),<br/>  0, -1/factorial(3),<br/>  0, 1/factorial(5),<br/>  0, -1/factorial(7),<br/>  0, 1/factorial(9),<br/>  0, -1/factorial(11),<br/>  0, 1/factorial(13),<br/>  0, -1/factorial(15),<br/>  0, 1/factorial(17),<br/>  0, -1/factorial(19)]<br/> if (nDegree &gt;= length(C))<br/>  <a class="ae kw" href="http://twitter.com/printf" rel="noopener ugc nofollow" target="_blank">@printf</a>("error: nDegree cannot be more than %d\n",<br/>   length(C)-1)<br/>  return<br/> end<br/> <br/> # define sin function<br/> nPoint = 201 <br/> X = LinRange(-1.0, 1.0, nPoint)<br/> F = sin.(X)<br/> <br/> # define Taylor series approximation<br/> TSF = zeros(nPoint, nDegree+1)<br/> for iDegree = 0:nDegree<br/>  TSF[:,iDegree+1] = C[iDegree+1] .* X .^ iDegree<br/> end<br/> TSFC = cumsum(TSF, dims=2)<br/> <br/> # show Taylor series approximation error<br/> p1 = plot(X, F,<br/>  legend = false)<br/> p2 = plot(X, TSFC[:,end] - F,<br/>  legend = false)<br/> M = maximum(abs.(TSFC-repeat(F,1,nDegree+1)), dims=1)<br/> display(M)<br/> p3 = plot(M',<br/>  legend = false,<br/>  yaxis = :log)<br/> plot(p1, p2, p3, layout=(3,1))<br/>end</span></pre></div></div>    
</body>
</html>