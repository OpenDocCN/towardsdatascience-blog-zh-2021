<html>
<head>
<title>Magic 8 Ball: An app to maximize wins in competitive pool matches (Part 2)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">魔术8球:一个应用程序，以最大限度地赢得竞争池比赛(第二部分)</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/magic-8-ball-an-app-to-maximize-wins-in-competitive-pool-matches-part-2-eb9d4793f98f?source=collection_archive---------49-----------------------#2021-05-31">https://towardsdatascience.com/magic-8-ball-an-app-to-maximize-wins-in-competitive-pool-matches-part-2-eb9d4793f98f?source=collection_archive---------49-----------------------#2021-05-31</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="da72" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">机器学习和SQL如何帮助你在连续团队游戏中智胜对手</h2></div><p id="c22e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">欢迎回到这个关于数据驱动池策略的三部分系列！</p><p id="d5ef" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<a class="ae lb" rel="noopener" target="_blank" href="/magic-8-ball-an-app-to-maximize-wins-in-competitive-pool-matches-part-1-e1d302b5507c">第1部分</a>中，我们探索了竞技团队台球的古怪之处，并确定台球游戏的玩家阵容选择可以通过数据科学来改进。我们开发了一个分类模型，根据过去的结果预测一个玩家击败另一个玩家的概率。在这里，在这一部分，我们将更进一步，<strong class="kh ir"> <em class="lc">使用</em> </strong>这些预测来实际上<strong class="kh ir"> <em class="lc">通知</em> </strong>策略来进行玩家选择。</p><p id="ce9d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae lb" rel="noopener" target="_blank" href="/magic-8-ball-an-app-to-maximize-wins-in-competitive-pool-matches-part-1-e1d302b5507c"> <strong class="kh ir">第1部分:简介和预测建模。</strong>T13】</a></p><p id="12dd" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">第2部分:使用SQL制定战略。</strong></p><p id="64b8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae lb" rel="noopener" target="_blank" href="/magic-8-ball-an-app-to-maximize-wins-in-competitive-pool-matches-part-3-d724fdd65d9"> <strong class="kh ir">第三部分:“封装”测试！</strong>T19】</a></p><h2 id="a5af" class="ld le iq bd lf lg lh dn li lj lk dp ll ko lm ln lo ks lp lq lr kw ls lt lu lv bi translated"><strong class="ak">比赛获胜概率</strong></h2><p id="a86c" class="pw-post-body-paragraph kf kg iq kh b ki lw jr kk kl lx ju kn ko ly kq kr ks lz ku kv kw ma ky kz la ij bi translated">在上一篇文章中，我们开发了一个逻辑回归模型，它使用历史表现统计来预测一个玩家击败另一个玩家的概率。</p><p id="d28d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">虽然我们可以使用我们的模型来预测每个可能的玩家配对的获胜概率，但我们真正感兴趣的是<strong class="kh ir">整体比赛获胜概率。</strong></p><p id="8fda" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">回想一下，在一场比赛中有5个！= 120种不同的可能排列组合；因此，<em class="lc">这些不同排列中的每一个将具有不同的相关匹配获胜概率</em>。</p><p id="2e5b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了从最好到最差排列，我们需要计算每个配对排列的个体概率。</p><p id="ff7e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这里，我们假设赢得整体比赛需要赢得五回合中的三回合<strong class="kh ir"/>；所以，对于每一个阵容排列，我们需要计算出<strong class="kh ir"> <em class="lc">至少三轮</em>的获胜概率。</strong>最少三次获胜的所有概率之和可通过以下等式获得:</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="gh gi mb"><img src="../Images/e78f323e5903bca3bf7b1f45e07f4b7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c99DLvVjNSyoV0B-FVS-mw.png"/></div></div></figure><p id="b143" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">假设每轮获胜的<em class="lc">概率是独立的</em>，我们可以通过计算下面的表达式来计算上面等式右边的每一项:</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/18b2a41280c459ac48c0a2a0778edfae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1156/format:webp/1*NjHCsrTMGUwMNdGdHerpaw.png"/></div></figure><p id="6829" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">其中<em class="lc"> p_i </em>是赢得回合<em class="lc"> i </em>的概率。恰好赢m轮的概率由<em class="lc"> P(m胜)</em>给出，即<em class="lc"> x^m </em>的系数，其中<em class="lc"> x </em>是虚拟变量。</p><p id="0f11" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lc">例如</em>为了计算<em class="lc"> P(4胜)</em>我们展开表达式的左侧，使用<em class="lc"> x^4 </em>的系数:</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="gh gi mo"><img src="../Images/15d321e9a14eb128779705af0bc8a3e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*USGgTv4Y_vnMkuNoSw9D-Q.png"/></div></div></figure><p id="7215" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir"> Python实现</strong></p><p id="af17" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们的逻辑回归模型将玩家配对的比赛保证金、技能保证金和获胜百分比保证金值作为输入，并返回玩家A将赢得这一轮的预测概率。我们可以在一个五行Python数据帧中存储一个比赛阵容，其中每行对应一个玩家配对。</p><p id="2a78" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们将我们的模型应用于队列数据帧，我们生成一个概率向量——每个配对一个概率。下面的函数采用这个概率向量，并使用上面的等式计算<em class="lc"> P(赢匹配)</em>。</p><figure class="mc md me mf gt mg"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="402c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">假设我们已经将所有阵容数据帧存储在一个名为<em class="lc">阵容</em>的列表中。我们现在可以将预测模型应用于每个阵容，并计算每个阵容排列的匹配获胜概率。</p><figure class="mc md me mf gt mg"><div class="bz fp l di"><div class="mp mq l"/></div></figure></div><div class="ab cl mr ms hu mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="ij ik il im in"><h2 id="4bc0" class="ld le iq bd lf lg lh dn li lj lk dp ll ko lm ln lo ks lp lq lr kw ls lt lu lv bi translated"><strong class="ak">组织比赛预测</strong></h2><p id="6206" class="pw-post-body-paragraph kf kg iq kh b ki lw jr kk kl lx ju kn ko ly kq kr ks lz ku kv kw ma ky kz la ij bi translated">队长轮流扮演首先选择球员的角色。在每轮比赛开始时，队长都要确保他们选择了最好的球员为他们的球队效力。因为我们的目标是部署一个用户友好的web应用程序，所以将每个排列的预测存储在一个<strong class="kh ir">关系数据库中是有意义的。有了这个数据库，我们只需要为每场比赛生成一次预测概率。在每一轮开始时，我们可以检索推荐的球员，作为可重用SQL查询的结果。<strong class="kh ir"> </strong>我们使用postgreSQL是因为它与Heroku等app部署平台无缝集成。</strong></p><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="gh gi my"><img src="../Images/fa2ecf78477e402f466ef8fb532d9fc6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*H-O8OXvQsx-OEBfy"/></div></div><p class="mz na gj gh gi nb nc bd b be z dk translated">图1:数据库模式。</p></figure><p id="131a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">图1显示了数据库中包含的每个表的模式:</p><ul class=""><li id="3c6d" class="nd ne iq kh b ki kj kl km ko nf ks ng kw nh la ni nj nk nl bi translated"><strong class="kh ir"> all_perms </strong>包含<strong class="kh ir"> player_a </strong>对<strong class="kh ir"> player_b、</strong>的预测获胜概率<strong class="kh ir">以及包含该配对的<strong class="kh ir">排列</strong>的数字id(从1-120)。</strong></li><li id="7468" class="nd ne iq kh b ki nm kl nn ko no ks np kw nq la ni nj nk nl bi translated"><strong class="kh ir"> perm_score </strong>包含每个<strong class="kh ir">排列</strong>的总匹配获胜<strong class="kh ir">概率</strong>。</li><li id="4f4c" class="nd ne iq kh b ki nm kl nn ko no ks np kw nq la ni nj nk nl bi translated"><strong class="kh ir"> team_a </strong>包含a队玩家的玩家id<strong class="kh ir">s、<strong class="kh ir"> name </strong> s、<strong class="kh ir"> skill_level </strong> s的列表。</strong></li><li id="caae" class="nd ne iq kh b ki nm kl nn ko no ks np kw nq la ni nj nk nl bi translated"><strong class="kh ir"> team_b </strong>包含b队玩家的<strong class="kh ir"> id </strong> s、<strong class="kh ir">名字</strong> s、<strong class="kh ir">技能等级</strong> s的列表</li><li id="9d0f" class="nd ne iq kh b ki nm kl nn ko no ks np kw nq la ni nj nk nl bi translated"><strong class="kh ir">随着比赛的展开，阵容</strong>会随着选定玩家的<strong class="kh ir"> id </strong> s和<strong class="kh ir">名称</strong> s不断更新。<strong class="kh ir"> pos </strong>是1-10之间的整数，表示在阵容中的位置，奇数对应于A队选择，偶数对应于B队选择。</li></ul><h2 id="d4eb" class="ld le iq bd lf lg lh dn li lj lk dp ll ko lm ln lo ks lp lq lr kw ls lt lu lv bi translated"><strong class="ak">球员选择策略——比赛示例:</strong></h2><p id="5e0b" class="pw-post-body-paragraph kf kg iq kh b ki lw jr kk kl lx ju kn ko ly kq kr ks lz ku kv kw ma ky kz la ij bi translated">现在我们有了两个队之间每个可能阵容的预测数据库，我们可以很容易地找出哪个阵容有最高的获胜概率。然而，由于我们不能确定每一轮对方队长会选择哪些球员，所以要达到这个目标还远不能保证。然而，有没有一种选择策略能始终产生接近最优的阵容？</p><p id="8d9a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">让我们站在队长的角度来打一场比赛</strong>。</p><p id="45af" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们面对的是蓝队队长Slick Jill，和我们一样，她会尽最大努力创造一个最大化她获胜机会的阵容。该模型已经被应用于预测我们的每个玩家(红队)对蓝队的每个玩家的获胜概率，如表1中所总结的。这些概率取自数据库中的<strong class="kh ir"> all_perms </strong>表。</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="gh gi nr"><img src="../Images/aaa8b3afc084190d9373f1f43fde09b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*cputnR_BTmSEFlVa"/></div></div><p class="mz na gj gh gi nb nc bd b be z dk translated">表1:A队(红色)的玩家对B队(蓝色)玩家的预测获胜概率。</p></figure><h2 id="c34a" class="ld le iq bd lf lg lh dn li lj lk dp ll ko lm ln lo ks lp lq lr kw ls lt lu lv bi translated"><strong class="ak">第一轮:回应对手的选择</strong></h2><p id="c72d" class="pw-post-body-paragraph kf kg iq kh b ki lw jr kk kl lx ju kn ko ly kq kr ks lz ku kv kw ma ky kz la ij bi translated">滑头吉尔赢得了掷硬币，并选择在第一轮选择第一。她把保罗叫到桌前玩。我们的应对策略是什么？</p><p id="5d10" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">看着矩阵并立即选择<strong class="kh ir"> Curtis </strong>来回应可能很有诱惑力。他赢的可能性最大，所以这很容易，对吗？使用这种逻辑的选择策略是贪婪算法的一种形式。在许多比赛中，这可能最终成为一种短视的策略。例如，<strong class="kh ir">泰莎</strong>击败<strong class="kh ir">保罗</strong>的几率几乎和<strong class="kh ir">柯蒂斯</strong>一样高，而<strong class="kh ir">柯蒂斯</strong>击败<strong class="kh ir">胡安娜</strong>的几率是迄今为止最高的。为这场可能的比赛保留他可能是谨慎的。也可能出现这样的情况，即“牺牲”一轮是有利的，如果这意味着团队有<em class="lc">更高的概率赢得更多的后续回合</em>。</p><p id="e4b0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">考虑到这一点，我们如何才能确信我们选择的是最好的球员，而不会让我们的大脑被各种不同的可能性淹没？</p><p id="e858" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们已经做了很多繁琐的工作，通过计算每一个可能的阵容赢得比赛的概率。这些匹配概率存储在我们数据库的<strong class="kh ir"> perm_score </strong>表中。是时候使用它们了！</p><p id="5b33" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，表2显示了一个<strong class="kh ir">新的</strong>匹配矩阵，其中这次的值表示包含该配对的所有阵容的<strong class="kh ir">平均匹配获胜概率。</strong></p><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="gh gi ns"><img src="../Images/36a6ba3eb68afd5752d8fe2226d8992c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*oHCB8BfLTmXJcfpP"/></div></div><p class="mz na gj gh gi nb nc bd b be z dk translated">表2:与表1相反，该匹配矩阵显示了包含该玩家配对的阵容排列的平均匹配获胜概率。</p></figure><p id="1a69" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对应于最佳阵容的配对以灰色突出显示。该阵容的比赛获胜概率为<strong class="kh ir"> 0.77，</strong>，相比之下，所有120种排列的平均比赛获胜概率为<strong class="kh ir"> 0.66 </strong>！</p><p id="18a6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们可以看到，平均而言，米尔顿和保罗的组合会比我们选择任何其他球员更有可能赢得比赛。从第一张桌子上看这一点都不明显！<strong class="kh ir">无论Slick Jill选择了谁，我们都可以用一名球员来应对，这将提高我们赢得比赛的可能性。</strong></p><p id="b953" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面的代码展示了我们如何用Python编写一个函数，使用对postgreSQL数据库的查询来生成类似表2的内容。该函数有两个参数:对应于Slick Jill选择的玩家ID，<em class="lc"> player_b_id </em>，以及到postgreSQL数据库的连接，<em class="lc"> con </em>。</p><figure class="mc md me mf gt mg"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="91bd" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有很多东西需要消化。第4行和第5行的两个Python函数检索当前的队列，这是使数据库被过滤为只包含活动排列所必需的。剩下的代码由一个检索最佳玩家选择的<strong class="kh ir"> SQL查询组成。让我们一行一行地解开它，按照执行<a class="ae lb" href="https://sqlbolt.com/lesson/select_queries_order_of_execution" rel="noopener ugc nofollow" target="_blank">代码</a>的顺序打印逐步输出。</strong></p><ol class=""><li id="7105" class="nd ne iq kh b ki kj kl km ko nf ks ng kw nh la nt nj nk nl bi translated">第11行:从<strong class="kh ir"> all_perms </strong>表中选择<em class="lc">活动排列</em>的所有id。“子句”是一个WHERE语句，它过滤掉由于前几轮完成而不再可能的排列。参见<a class="ae lb" href="https://github.com/cfodonnell/NAPA-Amateur-Pool/blob/master/napa_app/napa/analytics.py" rel="noopener ugc nofollow" target="_blank"> GitHub </a>中的完整代码。因为所有的排列仍然是可能的，所以返回一个表，<strong class="kh ir"> f </strong>，由包含数字1-120的一列组成。</li></ol><figure class="mc md me mf gt mg gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/19961289a1176248f0b82bb5ffa83edc.png" data-original-src="https://miro.medium.com/v2/resize:fit:306/0*GBRRdECr3yDXAYz-"/></div></figure><p id="aabb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">2.第12行:对<strong class="kh ir"> all_perms </strong>表的内部连接。同样，因为我们还没有排除任何可能的结果，所以这只是返回整个<strong class="kh ir"> all_perms </strong>表，其中有重复的置换列。</p><p id="cf36" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">3.第13行:将结果加入到<strong class="kh ir"> perm_score </strong>表中，以访问匹配的获胜概率。注意，a.probability指的是给定排列中单轮的<em class="lc">预测获胜概率，而s.probability指的是给定排列的<em class="lc">预测匹配获胜概率</em>。</em></p><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="gh gi nv"><img src="../Images/1cf3eafa646e0d9808956f2c0a8e0d3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7BoyxmgoC6ltbJFi"/></div></div></figure><p id="7b1a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">4.第14行:过滤表格，只包括可能的回合，包括B队(Chris)的选定玩家。</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="gh gi nw"><img src="../Images/95b83b4c4b9c316ce5361a3b27999072.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*0w0SimmLgjz-LcsK"/></div></div></figure><p id="1c14" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">5.第9、10、15行:这是组装最终表格的地方。我们将A组的玩家分组，计算包含这些可能配对的所有排列的平均获胜概率(AVG( <strong class="kh ir"> s.probability </strong>)为<strong class="kh ir"> avg_prob </strong>)。注意，虽然我们只需要按<strong class="kh ir"> a.id_a </strong>列分组，但是如果我们在SELECT语句中也包含这些列，我们需要在group by语句中包含<strong class="kh ir"> player_a </strong>和<strong class="kh ir"> player_b </strong>。</p><p id="e7c5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">6.第14行:最后，表格按降序排列<strong class="kh ir"> avg_prob </strong>。</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/9b671415421817ecce12abc972c68be5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1216/0*PuLiw0QD7VnioVM0"/></div></figure><p id="fcd9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦Judith v Chris配对被确认，我们可以将这些球员添加到我们数据库的<strong class="kh ir">阵容</strong>表中，并进入下一轮。</p><h2 id="15e8" class="ld le iq bd lf lg lh dn li lj lk dp ll ko lm ln lo ks lp lq lr kw ls lt lu lv bi translated"><strong class="ak">第二轮:轮到我们先挑了</strong></h2><p id="2eb8" class="pw-post-body-paragraph kf kg iq kh b ki lw jr kk kl lx ju kn ko ly kq kr ks lz ku kv kw ma ky kz la ij bi translated">当轮到我们先选择球员时，情况就有点复杂了，因为Slick Jill可以用她的选择作为回应，带来惊喜。尽管如此，我们还是可以制定一个策略，将Slick Jill可能对我们平均获胜概率造成的损害降到最低。<strong class="kh ir"> </strong>换句话说，<strong class="kh ir">我们想要做出一个玩家选择，这将导致最高可能的平均比赛获胜概率<em class="lc">，而不管Slick Jill选择谁作为响应</em>。</strong>这被称为<a class="ae lb" href="https://en.wikipedia.org/wiki/Minimax" rel="noopener ugc nofollow" target="_blank">马希民(minimax)策略。</a></p><p id="102f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们更新图3中的匹配矩阵。现在已经进行了一轮比赛，剩下的唯一可能的阵容是24种排列，其中包括米尔顿对保罗的配对。在表3中，在剩余的24个排列中，每个配对的平均匹配获胜概率被重新计算。</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="gh gi ny"><img src="../Images/9b96d9618e7199b4536ca38be78260a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*m7d1rQ3-J6WT_fI6"/></div></div><p class="mz na gj gh gi nb nc bd b be z dk translated">表3:第一轮比赛结束后更新的比赛矩阵。我们队的最小获胜概率是通过取各行的最小值得到的。</p></figure><p id="7421" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于对应红队玩家的每一行，以灰色突出显示的单元格对应该玩家最差的配对。如果Slick Jill的选择导致这些配对中的一个，那么我们的获胜前景将会急转直下！</p><p id="9f89" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，Tessa是第二轮最安全的选择，因为她有最高的最小获胜概率(0.66)。</p><p id="0899" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，对于Python/SQL实现:</p><figure class="mc md me mf gt mg"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="33e5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请注意，第11到16行中的子查询与我们在第一轮中使用的查询非常相似，唯一的区别是缺少WHERE子句，当我们考虑所有可能的配对时，这是不需要的，而且我们现在是按<strong class="kh ir"> player_b </strong> <em class="lc">然后是</em> <strong class="kh ir"> id_a </strong>分组，而不是反过来。</p><ol class=""><li id="c824" class="nd ne iq kh b ki kj kl km ko nf ks ng kw nh la nt nj nk nl bi translated">第12-15行:以与上一节相同的方式连接表格，但是这次唯一可能的排列是包含Milton v Paul的排列。</li></ol><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="gh gi nz"><img src="../Images/82d595916fb6ea9f06c1a6678f2fea8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*4WBibJgpV_LovMFM"/></div></div></figure><p id="6f3d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">2.第11、16行:按<strong class="kh ir"> player_b </strong>分组，然后按<strong class="kh ir"> id_a </strong>和<strong class="kh ir"> player_a </strong>分组，合计平均比赛获胜概率(AVG( <strong class="kh ir"> s.probability </strong>为<strong class="kh ir"> avg_prob </strong>)。这产生了前面表3中所示的矩阵的表格形式。</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/c846915415110e1f6a801669229cf092.png" data-original-src="https://miro.medium.com/v2/resize:fit:1216/0*YIeoDDEdQ2mTki6r"/></div></figure><p id="288d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">3.第9、10、17行:通过<strong class="kh ir"> id_a </strong>和<strong class="kh ir"> player_a，</strong>对匹配矩阵表进行分组，选择每组的最小平均匹配获胜概率(MIN( <strong class="kh ir"> avg_prob </strong>)作为<strong class="kh ir"> min_prob </strong>)。</p><p id="0c4d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">4.第16行:请注意，Paul的名字出现在图10的表格中，尽管事实上他已经在第一轮中玩过了！要删除不可能的玩家配对，有必要包含一个HAVING语句，过滤掉已经输入到<strong class="kh ir">阵容</strong>表中的玩家id。</p><p id="30ab" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">5.第11行:最后，聚集的行按降序排列<strong class="kh ir"> min_prob </strong>。</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/fb4b6d7a4228416b5ef75aebea1298d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:936/0*A9tdcrRo_tfdeKcf"/></div></figure><h2 id="c4d6" class="ld le iq bd lf lg lh dn li lj lk dp ll ko lm ln lo ks lp lq lr kw ls lt lu lv bi translated">将所有这些放在一起:</h2><p id="9959" class="pw-post-body-paragraph kf kg iq kh b ki lw jr kk kl lx ju kn ko ly kq kr ks lz ku kv kw ma ky kz la ij bi translated">我们现在已经拥有了构建应用程序所需的所有要素！让我们来看一下我们的示例比赛，看看我们的选择策略将我们引向什么阵容。如果Slick Jill进行随机选择，那么我们可能会以表4中的阵容结束。</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/66abe55e557fae10d5e35572a6e3eef0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1142/0*NjmBO0TWJ2CZyGO8"/></div><p class="mz na gj gh gi nb nc bd b be z dk translated">表4:一个可能的最终阵容，我们使用马希民策略，而Slick Jill随机选择。颜色表示每一轮哪个队先拔得头筹。概率栏显示每对红队玩家的获胜概率。</p></figure><p id="f486" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们非常有希望赢得五轮中的三轮，整体比赛获胜概率为<strong class="kh ir"> 0.76 </strong>。在所有120种可能的排列中，这个阵容实际上有第五高的获胜概率，所以我们不能给自己一个更好的机会了！</p><p id="57db" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">虽然看起来我们有在这场比赛中击败Slick Jill的神奇公式，但从单个数据点得出结论是不明智的做法。在下一部分中，将应用统计方法来量化选择过程的有效性。</p></div></div>    
</body>
</html>