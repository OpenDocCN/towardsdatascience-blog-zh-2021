<html>
<head>
<title>Everything You Need to Know about Push! in Julia</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关于 Push 你需要知道的一切！在朱莉娅</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/everything-you-need-to-know-about-push-in-julia-1f01891f1c0a?source=collection_archive---------19-----------------------#2021-12-29">https://towardsdatascience.com/everything-you-need-to-know-about-push-in-julia-1f01891f1c0a?source=collection_archive---------19-----------------------#2021-12-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2a3b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用力！()方法是你需要了解的 Julia 基础的重要部分。让我们来看看它能做什么。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/22b5429484d4faf7bddded228308afcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Xzvux26kCE8EXZDJN02aCA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由<a class="ae ky" href="https://unsplash.com/photos/zM9A6RTWUPE" rel="noopener ugc nofollow" target="_blank">蒂姆·莫斯霍尔德</a>在【Unsplash.com】T2 拍摄)</p></figure><p id="2a77" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Julia 编程语言有一个丰富和扩展的基础，它本身能够做很多事情。Julia 与许多其他编程语言的不同之处在于它健壮的类型系统。方法系统当然伴随着这个很好，然而类型系统才是真正的抢镜。还有一些很棒的方法可以处理 Julia 中的所有类型。如果您使用 Julia 已经有一段时间了，那么您很可能已经遇到了推送！()野外法。该方法很常用，因为它是 Julia 的核心特性。也就是说，那些对 Julia 感兴趣的人可能想获得一些使用它的经验。</p><p id="46de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Julia 语言的一个优点是一个方法定义本质上有无限的能力。这是一个非常朱利安的事情进口推动！()方法，并扩展它以处理您环境中的类型。方法中也有一些不规则和奇怪的东西，可能很重要，其中一些甚至是一些有经验的 Julian 程序员也没有经历过。今天，我们将从核心 Julia 数据类型的基础开始，介绍该方法的所有细微差别，然后我想介绍如何扩展该模块以使用类型的示例实例。这个项目还有一个笔记本，您可以在这里查看:</p><div class="lv lw gp gr lx ly"><a href="https://github.com/emmettgb/Emmetts-DS-NoteBooks/blob/master/Julia/Push%20in%20julia.ipynb" rel="noopener  ugc nofollow" target="_blank"><div class="lz ab fo"><div class="ma ab mb cl cj mc"><h2 class="bd iu gy z fp md fr fs me fu fw is bi translated">Emmetts-DS-NoteBooks/Push in Julia . ipynb at master emmett GB/Emmetts-DS-NoteBooks</h2><div class="mf l"><h3 class="bd b gy z fp md fr fs me fu fw dk translated">各种项目的随机笔记本。通过创建帐户，为 emmettgb/Emmetts-DS 笔记本电脑的开发做出贡献…</h3></div><div class="mg l"><p class="bd b dl z fp md fr fs me fu fw dk translated">github.com</p></div></div><div class="mh l"><div class="mi l mj mk ml mh mm ks ly"/></div></div></a></div></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="fa2b" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">用力！:基础知识</h1><p id="8fce" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">我们将从一个简单的数组开始:</p><pre class="kj kk kl km gt nr ns nt nu aw nv bi"><span id="3d11" class="nw mv it ns b gy nx ny l nz oa">example = [9, 7, 4, 28]</span></pre><p id="6a9b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关于数组，有一些特殊的事情需要注意:</p><ul class=""><li id="d6c3" class="ob oc it lb b lc ld lf lg li od lm oe lq of lu og oh oi oj bi translated">它们是可重复的。</li><li id="ec9a" class="ob oc it lb b lc ok lf ol li om lm on lq oo lu og oh oi oj bi translated">它们是 base Julia，所以 base-Julia 方法与它们一起工作。</li></ul><p id="7fbb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与许多其他语言不同，我们有一个相当健壮的索引接口。既然这些都是可重复的，只要一推！()方法知道如何处理我们传递的 iterable，它可以将我们想要的任何类型放入其中——这很方便，因为像 append！()方法只方便某些数据类型的使用。我们可以用？(推！)来了解关于这个函数的更多信息，这也将给出这个函数的所有不同调用:</p><pre class="kj kk kl km gt nr ns nt nu aw nv bi"><span id="25f8" class="nw mv it ns b gy nx ny l nz oa">?(push!)</span></pre><p id="347b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这在朱莉娅是一个很好的实践。那个？()方法允许我们尽可能深入地快速浏览文档。与传统上可能在 web 浏览器中查找一些文档相比，这种文档字符串系统有很多非常好的优点。实际上，我写了一整篇文章，更详细地讨论了 Juliahub 系统的文档，如果你不知道这两件事，你可能会感兴趣，下面是这个故事的链接:</p><div class="lv lw gp gr lx ly"><a rel="noopener follow" target="_blank" href="/julias-doc-string-system-is-awesome-and-here-is-why-197ba6a0236b"><div class="lz ab fo"><div class="ma ab mb cl cj mc"><h2 class="bd iu gy z fp md fr fs me fu fw is bi translated">Julia 的文档字符串系统非常棒，原因如下</h2><div class="mf l"><h3 class="bd b gy z fp md fr fs me fu fw dk translated">概述为什么我认为 Julian 文档优于大多数其他语言的方法</h3></div><div class="mg l"><p class="bd b dl z fp md fr fs me fu fw dk translated">towardsdatascience.com</p></div></div><div class="mh l"><div class="op l mj mk ml mh mm ks ly"/></div></div></a></div><p id="cb52" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从中我们可以看出一点，它将会变异成我们提供的第一个论点。在深入研究之前，我们可以立即指出这一点，因为这个方法在一个解释点结束。这是另一个深入到背后故事的很酷的故事:</p><div class="lv lw gp gr lx ly"><a rel="noopener follow" target="_blank" href="/the-real-meaning-behind-in-method-calls-b10772f0e30b"><div class="lz ab fo"><div class="ma ab mb cl cj mc"><h2 class="bd iu gy z fp md fr fs me fu fw is bi translated">背后的真正含义！在方法调用中</h2><div class="mf l"><h3 class="bd b gy z fp md fr fs me fu fw dk translated">当一个方法在一个解释点结束时意味着什么？</h3></div><div class="mg l"><p class="bd b dl z fp md fr fs me fu fw dk translated">towardsdatascience.com</p></div></div><div class="mh l"><div class="oq l mj mk ml mh mm ks ly"/></div></div></a></div><p id="adcf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">回到我们的笔记本，我们已经对这个方法有了很好的了解，但是让我们看看实际的文档能告诉我们什么。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi or"><img src="../Images/070c5d152e82b3e0a064899262c4346f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H6haoEIftZcU8Xe4Ehef6Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="791f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该文档为我们提供了一个 REPL 绑定的示例、详细描述的参数，甚至一些在不同情况下使用的其他方法。前面提到的追加！()在这里做了一个重要的注释，作为 append！如果追加是我们真正想要做的，那么()可能是某些结构的更好应用。我们将遵循这些参数，并为我们的旧示例数组加入一些新数据。</p><pre class="kj kk kl km gt nr ns nt nu aw nv bi"><span id="de2b" class="nw mv it ns b gy nx ny l nz oa">push!(example, 5)</span><span id="f579" class="nw mv it ns b gy os ny l nz oa">5-element Vector{Int64}:<br/>  9<br/>  7<br/>  4<br/> 28<br/>  5</span></pre><p id="c966" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将产生一个 5 元素的数组，一个整数向量，它将改变数组的维数和数组中的可迭代内容。奇怪的一点是，有一些细致入微的类型是不能推的。我们通常可以很好地将结构推进这里。然而，对于某些数据类型，甚至是构造类型，它将不起作用。</p><h1 id="42eb" class="mu mv it bd mw mx ot mz na nb ou nd ne jz ov ka ng kc ow kd ni kf ox kg nk nl bi translated">多带推！()</h1><p id="571e" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">正如我前面提到的推！()，当涉及到类型时，这个方法有一些细微的差别。我发现提供范围生成器的例子很奇怪:</p><pre class="kj kk kl km gt nr ns nt nu aw nv bi"><span id="4b65" class="nw mv it ns b gy nx ny l nz oa"><strong class="ns iu">push!(example, 1:5)</strong></span><span id="71c8" class="nw mv it ns b gy os ny l nz oa">MethodError: Cannot `convert` an object of type UnitRange{Int64} to an object of type Int64<br/>Closest candidates are:<br/>  convert(::Type{T}, ::T) where T&lt;:Number at number.jl:6<br/>  convert(::Type{T}, ::Number) where T&lt;:Number at number.jl:7<br/>  convert(::Type{T}, ::Base.TwicePrecision) where T&lt;:Number at twiceprecision.jl:250</span></pre><p id="559e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个很难辨别的错误，我觉得可能会让初学者感到困惑。这里的 stack-trace 并没有很好地展示出做错了什么，除非人们意识到这里的问题是键入。我们得到这个错误的原因是因为我们提供的类型是一个 UnitRange，但是每当它被添加到 vector 时，我们都会得到一个转换尝试。这是因为向量只能包含整数，因为它的类型是</p><pre class="kj kk kl km gt nr ns nt nu aw nv bi"><span id="5796" class="nw mv it ns b gy nx ny l nz oa">Vector{Int64}</span></pre><p id="e221" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们当然可以改变这一点。在 Julia 中，这可以通过将这个向量转换成一个可以包含任何类型的值的数组来实现。但是，这将改变行为，这可能是范围生成器所不希望的，例如:</p><pre class="kj kk kl km gt nr ns nt nu aw nv bi"><span id="ad2d" class="nw mv it ns b gy nx ny l nz oa">push!(Array{Any}(example), 1:5)</span><span id="dba8" class="nw mv it ns b gy os ny l nz oa">6-element Vector{Any}:<br/>  9<br/>  7<br/>  4<br/> 28<br/>  5<br/>   1:5</span></pre><p id="5ecc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们有一个 6 元素数组，里面有不同的类型，单位范围和那些整数在一起——我们可能期望在数组的末尾添加 1、2、3、4 和 5。这可能看起来更像是预期的行为，但通常这就是推动的方式！()方法会起作用。</p><h1 id="650d" class="mu mv it bd mw mx ot mz na nb ou nd ne jz ov ka ng kc ow kd ni kf ox kg nk nl bi translated">延伸推！()</h1><p id="196f" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">在一个真正的朱利安时尚，我们现在要延长推！()更好地配合我们的 UnitRange。每当我们想通过调度来扩展某种功能时，第一步就是直接导入它:</p><pre class="kj kk kl km gt nr ns nt nu aw nv bi"><span id="806b" class="nw mv it ns b gy nx ny l nz oa">import Base: push!</span></pre><p id="3e95" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你不知道如何扩展方法，就像这样，我就不在这里赘述了，但我有两篇文章，其中一篇有视频，在 Julia 中详细介绍了这一点:</p><div class="lv lw gp gr lx ly"><a href="https://medium.com/chifi-media/extending-julias-base-for-our-superframes-jl-package-4574555ff6ae" rel="noopener follow" target="_blank"><div class="lz ab fo"><div class="ma ab mb cl cj mc"><h2 class="bd iu gy z fp md fr fs me fu fw is bi translated">为我们的 SuperFrames.jl 包扩展 Julia 的基础</h2><div class="mf l"><h3 class="bd b gy z fp md fr fs me fu fw dk translated">通过扩展 Julia 的基础将索引添加到我们的 SuperFrames 包中。</h3></div><div class="mg l"><p class="bd b dl z fp md fr fs me fu fw dk translated">medium.com</p></div></div><div class="mh l"><div class="oy l mj mk ml mh mm ks ly"/></div></div></a></div><div class="lv lw gp gr lx ly"><a rel="noopener follow" target="_blank" href="/extending-julias-operators-with-amazing-results-96c042369349"><div class="lz ab fo"><div class="ma ab mb cl cj mc"><h2 class="bd iu gy z fp md fr fs me fu fw is bi translated">用惊人的结果扩展 Julia 的算子</h2><div class="mf l"><h3 class="bd b gy z fp md fr fs me fu fw dk translated">如何在 Julia 中加载和扩展方法，用一个真正激动人心的例子。</h3></div><div class="mg l"><p class="bd b dl z fp md fr fs me fu fw dk translated">towardsdatascience.com</p></div></div><div class="mh l"><div class="oz l mj mk ml mh mm ks ly"/></div></div></a></div><p id="38bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">希望现在这个概念在你的头脑中是新鲜和熟悉的，这将更容易理解我到底想做什么。我们的目标输入参数将是:</p><ul class=""><li id="db90" class="ob oc it lb b lc ld lf lg li od lm oe lq of lu og oh oi oj bi translated">我们的收藏</li><li id="014c" class="ob oc it lb b lc ok lf ol li om lm on lq oo lu og oh oi oj bi translated">单位范围</li></ul><p id="0afd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们想要的输出是集合中的所有元素。首先考虑我们的输入及其类型，让我们定义这个新函数:</p><pre class="kj kk kl km gt nr ns nt nu aw nv bi"><span id="9e07" class="nw mv it ns b gy nx ny l nz oa">function push!(collection::Vector{Int64}, range::UnitRange)<br/>    [push!(collection, i) for i in range]<br/>end</span></pre><blockquote class="pa pb pc"><p id="d737" class="kz la pd lb b lc ld ju le lf lg jx lh pe lj lk ll pf ln lo lp pg lr ls lt lu im bi translated">更快的方法可能是使用 collect()方法。</p></blockquote><p id="f029" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在函数内部，我有一个简单的迭代循环，它解包范围内的单个值，以便提供这个功能。每当将此新定义加载到环境中时，都可以将其添加到此方法定义的文档中:</p><pre class="kj kk kl km gt nr ns nt nu aw nv bi"><span id="a1bc" class="nw mv it ns b gy nx ny l nz oa">"""## push!(collection::Vector{Int64}, range::UnitRange)<br/>This method can be used to unpack a range generator and return its elements pushed into the collection. \<br/>```<br/>julia&gt; push!([2, 3] 1:2)</span><span id="1eaa" class="nw mv it ns b gy os ny l nz oa">4-element Vector{Int64}<br/>2<br/>3<br/>1<br/>2<br/>```</span><span id="aa22" class="nw mv it ns b gy os ny l nz oa">"""<br/>function push!(collection::Vector{Int64}, range::UnitRange)<br/>    [push!(collection, i) for i in range]<br/>end</span></pre><p id="52f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们看看我们的？()前一个示例的文档调用:</p><pre class="kj kk kl km gt nr ns nt nu aw nv bi"><span id="9abc" class="nw mv it ns b gy nx ny l nz oa">?(push!)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ph"><img src="../Images/6fd15c8bd0b24624c9d3bfc395ddac49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5VBAYEeTle5cn8iD9vfCVA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="81a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">幸运的是，我们的新定义被附加到其他文档中。我相信在这两组文档之间使用某种区分是有用的，因为 push！(::Vector{Int64}，::UnitRange)调用增加了一些不同的功能。这也是我们直接引用该调用的方式，例如:</p><pre class="kj kk kl km gt nr ns nt nu aw nv bi"><span id="b32b" class="nw mv it ns b gy nx ny l nz oa">?(push!(::Vector{Int64}, ::UnitRange))</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pi"><img src="../Images/5b9a32afee3c5e2c99ade2c80ed6ad5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1344/format:webp/1*yMCFbf4xEBM6rrME8z818g.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="bfda" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们最后使用这个函数，看看将要进行的最后一次调用:</p><pre class="kj kk kl km gt nr ns nt nu aw nv bi"><span id="37c0" class="nw mv it ns b gy nx ny l nz oa">push!(example, 1:5)</span><span id="a64b" class="nw mv it ns b gy os ny l nz oa">10-element Vector{Int64}:<br/>  9<br/>  7<br/>  4<br/> 28<br/>  5<br/>  1<br/>  2<br/>  3<br/>  4<br/>  5</span></pre><p id="1878" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这可能看起来工作量很大，为此要编写一个完整的方法扩展。然而，在您的编程语言中，在整个软件包生态系统中使用相同的方法调用简直令人惊奇。我们避免了命名冲突，并且能够根据类型反复使用相同的别名。虽然您可能希望编写一次 for 循环，但您可能不希望在这段代码的每个实例中反复编写它。也就是说，这就是函数的用途，把你的新函数写成一个众所周知的定义可能会让你的用户猜测如何更有效地使用你的包！</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="2080" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">结论</h1><p id="f31e" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi pj translated">右推！()挺牛逼的。这个方法的伟大之处在于它有许多不同类型的功能。我相信这是通过抽象来实现的，因为一般来说，Julia 中的大多数类型都是一个更大的类型层次结构的一部分，这个层次结构可以限制方法的行为。Julia 有很多优点，但有一点对我来说非常突出，那就是它的可扩展性。很少有人模仿 Julia 对多个分派和文档的处理，而且最重要的是，Julia 中的整个名称定义都可以重用和扩展。厉害！谢谢你的阅读，我希望你有一个可爱的一天！</p></div></div>    
</body>
</html>