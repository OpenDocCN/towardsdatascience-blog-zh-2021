<html>
<head>
<title>Image Classification with Early Stopping — A Quick Tutorial</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">提前停止的影像分类—快速教程</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/image-classification-with-early-stopping-a-quick-tutorial-58d3d346184c?source=collection_archive---------13-----------------------#2021-11-19">https://towardsdatascience.com/image-classification-with-early-stopping-a-quick-tutorial-58d3d346184c?source=collection_archive---------13-----------------------#2021-11-19</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="6d0a" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">用不到50行代码构建和训练一个Keras模型</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/6d65cae897fcf3eda951a55e09a457e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Ak5SOTDat9-2zCIM"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">由<a class="ae kz" href="https://unsplash.com/@alexpadurariu?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">亚历克斯·帕杜拉瑞</a>在<a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><p id="3883" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">Keras是一个深度学习库，作为数据科学家，我们可能会经常遇到。它是最容易实现和最容易学习的深度学习框架，如果这还不够，锦上添花的是，自从Tensorflow 2.0的发展以来，随着它与Tensorflow捆绑在一起，使用Keras学习和构建变得更加容易。</p><p id="846d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这篇文章描述了一个项目，它将帮助你明确基础知识，并迅速掌握它们。</p><p id="3c02" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">所以说，让我们着手建立一个深度神经网络，用于对新冠肺炎胸部X射线进行多类分类。</p><h1 id="2f9b" class="lw lx iu bd ly lz ma mb mc md me mf mg ka mh kb mi kd mj ke mk kg ml kh mm mn bi translated">数据</h1><p id="2fc3" class="pw-post-body-paragraph la lb iu lc b ld mo jv lf lg mp jy li lj mq ll lm ln mr lp lq lr ms lt lu lv in bi translated">我们将使用<a class="ae kz" href="https://www.kaggle.com/amanullahasraf/covid19-pneumonia-normal-chest-xray-pa-dataset" rel="noopener ugc nofollow" target="_blank">这个</a>数据集，可在Kaggle上获得，可在公共领域下获得，与我在上一部分提到的标题相同。</p><div class="mt mu gq gs mv mw"><a href="https://www.kaggle.com/amanullahasraf/covid19-pneumonia-normal-chest-xray-pa-dataset" rel="noopener  ugc nofollow" target="_blank"><div class="mx ab fp"><div class="my ab mz cl cj na"><h2 class="bd iv gz z fq nb fs ft nc fv fx it bi translated">COVID19 _肺炎_正常_胸部_x光_ PA _数据集</h2><div class="nd l"><h3 class="bd b gz z fq nb fs ft nc fv fx dk translated">肺炎和正常胸部x光(PA)数据集的COVID19</h3></div><div class="ne l"><p class="bd b dl z fq nb fs ft nc fv fx dk translated">www.kaggle.com</p></div></div><div class="nf l"><div class="ng l nh ni nj nf nk kt mw"/></div></div></a></div><p id="b122" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">对于分类问题，我们有三种类型的X射线——正常的、肺炎的和冠状的。我们的目标是快速开发一个模型，并利用它学习Keras深度学习库的基础知识。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj nl"><img src="../Images/932950b06062fbc8a2313e0947a49225.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ir79KBfe_Gm1ZqBVKwizlQ.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">来自<a class="ae kz" href="https://www.kaggle.com/amanullahasraf/covid19-pneumonia-normal-chest-xray-pa-dataset" rel="noopener ugc nofollow" target="_blank"> Kaggle </a>页面的数据集图像</p></figure><p id="448e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">为了方便起见，请将下载的数据保存在<code class="fe nm nn no np b"><strong class="lc iv">‘data/’</strong></code>文件夹下。</p><p id="1edc" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">让我们开始导入我们需要的包:</p><pre class="kk kl km kn gu nq np nr ns aw nt bi"><span id="3c09" class="nu lx iu np b gz nv nw l nx ny">from tensorflow.keras.layers import Conv2D, Flatten, Dense, MaxPooling2D, Dropout</span><span id="60fc" class="nu lx iu np b gz nz nw l nx ny">from tensorflow.keras.models import Sequential</span><span id="bc2f" class="nu lx iu np b gz nz nw l nx ny">from tensorflow.keras.preprocessing import image</span><span id="c4e4" class="nu lx iu np b gz nz nw l nx ny">from tensorflow.keras.callbacks import EarlyStopping</span><span id="c230" class="nu lx iu np b gz nz nw l nx ny">import os</span></pre><p id="625c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">通常，我们的项目会采用以下结构:</p><pre class="kk kl km kn gu nq np nr ns aw nt bi"><span id="dad8" class="nu lx iu np b gz nv nw l nx ny">image_classification_project/<br/>    classifier.ipynb<br/>    data/<br/>        train/<br/>             normal/<br/>             covid/<br/>             pneumonic/<br/>        valid/<br/>             normal/<br/>             covid/<br/>             pneumonic/<br/>        test/<br/>             normal/<br/>             covid/<br/>             pneumonic/</span></pre><p id="1cb7" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">现在，我们继续构建模型并导入数据。</p><h1 id="7029" class="lw lx iu bd ly lz ma mb mc md me mf mg ka mh kb mi kd mj ke mk kg ml kh mm mn bi translated">导入数据</h1><p id="2b78" class="pw-post-body-paragraph la lb iu lc b ld mo jv lf lg mp jy li lj mq ll lm ln mr lp lq lr ms lt lu lv in bi translated">启动您的本地环境，或者更好的是，运行时设置为“GPU”的colab笔记本。</p><p id="7aef" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">让我们从定义训练和测试数据生成器对象开始:</p><pre class="kk kl km kn gu nq np nr ns aw nt bi"><span id="e0c9" class="nu lx iu np b gz nv nw l nx ny"># Data Generators for some data preprocessing and augmentation</span><span id="5ee6" class="nu lx iu np b gz nz nw l nx ny">train_datagen = image.ImageDataGenerator(rescale = 1./255,</span><span id="356b" class="nu lx iu np b gz nz nw l nx ny">                shear_range = 0.2,</span><span id="45ff" class="nu lx iu np b gz nz nw l nx ny">                zoom_range = 0.2,</span><span id="c1d8" class="nu lx iu np b gz nz nw l nx ny">                horizontal_flip = True)</span><span id="fea9" class="nu lx iu np b gz nz nw l nx ny">test_datagen = image.ImageDataGenerator(rescale = 1./255)</span></pre><p id="caac" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><strong class="lc iv"> ImageDataGenerator </strong>类为我们的图像分类任务提供了一种简单的加载、预处理和批量扩充图像的方法。</p><p id="2490" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们现在继续从上一节定义的目录中导入数据:</p><pre class="kk kl km kn gu nq np nr ns aw nt bi"><span id="4147" class="nu lx iu np b gz nv nw l nx ny"># importing data</span><span id="155d" class="nu lx iu np b gz nz nw l nx ny">training_set= train_datagen.flow_from_directory(<strong class="np iv">os.path.join(data, "train"</strong>),</span><span id="3af5" class="nu lx iu np b gz nz nw l nx ny">     target_size = (128, 128),</span><span id="4283" class="nu lx iu np b gz nz nw l nx ny">     batch_size = 32,</span><span id="4ae2" class="nu lx iu np b gz nz nw l nx ny">     class_mode='binary')</span><span id="08b8" class="nu lx iu np b gz nz nw l nx ny"><br/>test_set = test_datagen.flow_from_directory(<strong class="np iv">os.path.join(data, "valid"</strong>),</span><span id="b968" class="nu lx iu np b gz nz nw l nx ny">     target_size = (128, 128),</span><span id="40a9" class="nu lx iu np b gz nz nw l nx ny">     batch_size = 32,</span><span id="5698" class="nu lx iu np b gz nz nw l nx ny">     class_mode='binary')</span></pre><p id="25dd" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果您正在使用不同的目录结构，请确保根据您自己的特定设置更改上面代码片段中的粗体部分。</p><p id="d74a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">执行上面几行代码后，您将得到以下输出:</p><pre class="kk kl km kn gu nq np nr ns aw nt bi"><span id="9c7b" class="nu lx iu np b gz nv nw l nx ny">Found 4830 images belonging to 3 classes. <br/>Found 1039 images belonging to 3 classes.</span></pre><p id="6a7a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">现在，我们准备检查我们的训练指数。</p><pre class="kk kl km kn gu nq np nr ns aw nt bi"><span id="82b1" class="nu lx iu np b gz nv nw l nx ny">print(training_set.class_indices, test_set.class_indices)</span></pre><p id="3eee" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">您将在执行时看到以下输出:</p><pre class="kk kl km kn gu nq np nr ns aw nt bi"><span id="5adf" class="nu lx iu np b gz nv nw l nx ny">({'covid': 0, 'normal': 1, 'pneumonia': 2},  {'covid': 0, 'normal': 1, 'pneumonia': 2})</span></pre><p id="af23" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这与我们的三个图像类可以在以后被引用的方式有关，它有助于看到它们对于训练集和测试集是相同的。</p><p id="edb8" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">现在，让我们开始建立模型！</p><h1 id="d0b7" class="lw lx iu bd ly lz ma mb mc md me mf mg ka mh kb mi kd mj ke mk kg ml kh mm mn bi translated">模型</h1><p id="d296" class="pw-post-body-paragraph la lb iu lc b ld mo jv lf lg mp jy li lj mq ll lm ln mr lp lq lr ms lt lu lv in bi translated">我们从<strong class="lc iv">序列</strong>对象开始，用32个3x3内核大小的过滤器(或神经元)添加2D卷积层。</p><p id="c79c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们对每张图片的输入形状是:128x128像素，3代表我们的图片是RGB。</p><p id="afb4" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们将激活函数定义为“ReLU”。</p><pre class="kk kl km kn gu nq np nr ns aw nt bi"><span id="6c40" class="nu lx iu np b gz nv nw l nx ny"># the model</span><span id="9e3b" class="nu lx iu np b gz nz nw l nx ny">model = Sequential()</span><span id="1edf" class="nu lx iu np b gz nz nw l nx ny">model.add(Conv2D(32, (3, 3), input_shape = (128, 128, 3), activation = 'relu'))</span><span id="9db5" class="nu lx iu np b gz nz nw l nx ny">model.add(MaxPooling2D(pool_size = (2, 2)))</span><span id="3ce3" class="nu lx iu np b gz nz nw l nx ny">model.add(Conv2D(32, (3, 3), input_shape = (128, 128, 3), activation = 'relu'))</span><span id="ccb9" class="nu lx iu np b gz nz nw l nx ny">model.add(Flatten())</span><span id="f8cb" class="nu lx iu np b gz nz nw l nx ny">model.add(Dense(units = 256, activation = 'relu'))</span><span id="7197" class="nu lx iu np b gz nz nw l nx ny">model.add(Dropout(0.5))</span><span id="0d5f" class="nu lx iu np b gz nz nw l nx ny">model.add(Dense(units = 128, activation = 'relu'))</span><span id="2bb1" class="nu lx iu np b gz nz nw l nx ny">model.add(Dense(units = 3, activation = 'softmax'))</span><span id="8e45" class="nu lx iu np b gz nz nw l nx ny">model.compile(optimizer = 'adam', loss =  'sparse_categorical_crossentropy', metrics = ['accuracy'])</span><span id="ec8a" class="nu lx iu np b gz nz nw l nx ny">model.summary()</span></pre><p id="d8bf" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">然后我们添加一个池<strong class="lc iv"> (MaxPooling2D </strong>)层，另一个卷积层和一个全连接(<strong class="lc iv">密集</strong>)层。<strong class="lc iv"> Dropout </strong>层旨在确保我们的模型不会过度拟合。</p><p id="bb88" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们的最后一层是另一个密集层，在<strong class="lc iv"> softmax </strong>激活函数的帮助下，也作为我们的输出层，输出3个加起来等于1的类概率。</p><h1 id="41f7" class="lw lx iu bd ly lz ma mb mc md me mf mg ka mh kb mi kd mj ke mk kg ml kh mm mn bi translated">提前停止</h1><p id="574d" class="pw-post-body-paragraph la lb iu lc b ld mo jv lf lg mp jy li lj mq ll lm ln mr lp lq lr ms lt lu lv in bi translated">Tensorflow文档将提前停止描述为:</p><blockquote class="oa ob oc"><p id="a15d" class="la lb od lc b ld le jv lf lg lh jy li oe lk ll lm of lo lp lq og ls lt lu lv in bi translated">当受监控的指标停止改善时，停止训练。</p></blockquote><p id="26c4" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">因为我们想最小化我们的<strong class="lc iv">验证损失</strong>，我们监控它，以便我们的<strong class="lc iv">耐心</strong>参数可以定义在哪个时期停止训练，以防它在许多时期都没有改善。</p><pre class="kk kl km kn gu nq np nr ns aw nt bi"><span id="acfa" class="nu lx iu np b gz nv nw l nx ny">early_stopping = EarlyStopping(monitor='val_loss', mode='min', verbose=1, patience=4)</span></pre><p id="280c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这是我们将在下一步拟合(或训练)模型时包括的回调。</p><h1 id="a66e" class="lw lx iu bd ly lz ma mb mc md me mf mg ka mh kb mi kd mj ke mk kg ml kh mm mn bi translated">训练模型</h1><p id="4df2" class="pw-post-body-paragraph la lb iu lc b ld mo jv lf lg mp jy li lj mq ll lm ln mr lp lq lr ms lt lu lv in bi translated">拟合模型很简单，只需用我们的必要参数调用模型上的拟合函数，例如用于随机梯度下降更新的<strong class="lc iv">批量大小</strong>，以及我们希望整个训练发生的时期数。</p><pre class="kk kl km kn gu nq np nr ns aw nt bi"><span id="68bd" class="nu lx iu np b gz nv nw l nx ny"># Model training</span><span id="3cda" class="nu lx iu np b gz nz nw l nx ny">classifier = model.fit(training_set,</span><span id="19ce" class="nu lx iu np b gz nz nw l nx ny">                       batch_size = 128,</span><span id="1fe4" class="nu lx iu np b gz nz nw l nx ny">                       epochs = 10,</span><span id="1491" class="nu lx iu np b gz nz nw l nx ny">                       validation_data = test_set,</span><span id="8e46" class="nu lx iu np b gz nz nw l nx ny">                       callbacks=[early_stopping])</span></pre><p id="9866" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">您会注意到，我们还将回调指定为我们之前定义的<strong class="lc iv">提前停止</strong>对象。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj oh"><img src="../Images/7d4468cf4adf4a298c87b00b61ccc518.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lHYPYCI6qAN76KEihDeXhA.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">详细的训练时期</p></figure><p id="85ba" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">正如你所看到的，我们的回调产生了必要的效果，没有过度训练我们的模型，并在第九纪元停止。</p><p id="234b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><strong class="lc iv">作为奖励</strong>，你现在可以用下面的Keras内置<strong class="lc iv">保存</strong>功能保存你的模型:</p><pre class="kk kl km kn gu nq np nr ns aw nt bi"><span id="4304" class="nu lx iu np b gz nv nw l nx ny">model_save_full_path = os.path.join(ROOT, 'saved_models', 'conv2d_version_1_acc_79_84')</span><span id="cf76" class="nu lx iu np b gz nz nw l nx ny">model.save(model_save_full_path)</span></pre><h1 id="4eed" class="lw lx iu bd ly lz ma mb mc md me mf mg ka mh kb mi kd mj ke mk kg ml kh mm mn bi translated">后续步骤</h1><p id="a54e" class="pw-post-body-paragraph la lb iu lc b ld mo jv lf lg mp jy li lj mq ll lm ln mr lp lq lr ms lt lu lv in bi translated">感谢您的阅读！</p><p id="441f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果你觉得这个教程很有帮助，并遵循了，下面是我建议在这个教程之后做的事情:</p><p id="116a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">—构建混淆矩阵，直观地表示正确和错误分类的标签数量。</p><p id="6f98" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">—探索用于评估模型的其他指标，如精确度、召回率和F1分数。</p><p id="a78e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">—衡量模型在测试数据集上的表现。</p></div><div class="ab cl oi oj hy ok" role="separator"><span class="ol bw bk om on oo"/><span class="ol bw bk om on oo"/><span class="ol bw bk om on"/></div><div class="in io ip iq ir"><p id="33a3" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果你想看本教程的下一部分，在其中我描述了上述进一步的步骤，甚至为分类器构建了一个前端，请关注我并保持关注！</p><p id="dfde" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><a class="ae kz" href="https://yashprakash13.gumroad.com/l/from-model-to-prod-handbook/Limited?_ga=2.51564846.609740814.1637425800-47624061.1637425800&amp;_gl=1*1ge51g1*_ga*NDc2MjQwNjEuMTYzNzQyNTgwMA..*_ga_6LJN6D94N6*MTYzNzQyNTgwMi4xLjEuMTYzNzQyNzM4MC4w" rel="noopener ugc nofollow" target="_blank">在这里获得我的免费“从模型到生产电子书”</a>,其中我教授了构建深度学习模型并将其部署为API的最快方法。</p><p id="badb" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">快乐学习！:)</p></div></div>    
</body>
</html>