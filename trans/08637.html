<html>
<head>
<title>Six Ways to Harden Your Model-Serving API with Tests &amp; Scans</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过测试和扫描强化模型服务API的六种方法</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/six-ways-to-harden-your-model-serving-api-with-tests-scans-b006b6137b19?source=collection_archive---------35-----------------------#2021-08-09">https://towardsdatascience.com/six-ways-to-harden-your-model-serving-api-with-tests-scans-b006b6137b19?source=collection_archive---------35-----------------------#2021-08-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/e2cb674b639b706fdb47b044218f24cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f-UC8hexSu-KijkB0_UK9w.jpeg"/></div></div></figure><div class=""/><div class=""><h2 id="6551" class="pw-subtitle-paragraph kb jd je bd b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks dk translated">去生产？利用这些免费资源强化您的API！</h2></div><p id="2dfd" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">你好，朋友们！我回来了！抱歉中断了两个月。我似乎总是在夏天失去发布新东西的动力，但现在我有了一台全新的Mac Mini来支持我的工作，我带着一些新鲜的新内容回来了。</p><p id="3887" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">作为一名财富50强公司的机器学习工程师，我的主要职责是将机器学习模型部署到生产中，供多个企业级系统使用。大多数部署都是以模型服务API的形式出现的。API接收一组数据，基于该数据生成一个推理，并将推理结果返回给调用者。</p><p id="6506" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">考虑到这些服务模型的API会接触到很多人，确保这些API以一种我们可以尝试保证100%正常运行的方式得到加强是非常重要的。为此，我们试图通过执行大量不同的测试和安全扫描来强化我们的API，这些测试和扫描表明我们在部署之前认真考虑了所有风险因素。此外，这些测试/扫描结果被保存到一个公共的存储库中，以防任何审计人员有兴趣看到这些API的“测试证据”。</p><p id="fea7" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">当然，有许多不同的工具和供应商解决方案来支持这项工作，但是对于这篇文章，我将重点关注免费资源。如果你是一家大型企业公司，我可能会鼓励你研究一些供应商的解决方案，但是这篇文章至少会提供一个在创建模型服务API时应该考虑的不同因素的入门。</p><p id="1723" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">在我们进入我们的资源之前，让我们先快速看一下我为支持这篇文章而创建的虚拟模型API。如果你想跟随我的代码，<a class="ae lp" href="https://github.com/dkhundley/ds-quick-tips/tree/master/013_fastapi_tests_scans" rel="noopener ugc nofollow" target="_blank">请在GitHub </a>找到它。</p><h1 id="9d23" class="lq lr je bd ls lt lu lv lw lx ly lz ma kk mb kl mc kn md ko me kq mf kr mg mh bi translated">API概述</h1><p id="2499" class="pw-post-body-paragraph kt ku je kv b kw mi kf ky kz mj ki lb lc mk le lf lg ml li lj lk mm lm ln lo im bi translated">对于这个项目，我针对流行的公共Iris数据集创建了一个非常简单的逻辑回归模型。因为我不一定关心为我们的项目创建一个花哨的预测模型，所以您会发现我没有做任何类似特殊功能工程或任何超参数调整的事情。在我下面的训练脚本中，你可以看到我正在做的唯一的事情是用Scikit-Learn加载数据集，从数据集分离目标<code class="fe mn mo mp mq b">y</code>值，将训练数据集馈送到Scikit-Learn <code class="fe mn mo mp mq b">LogisticRegression</code>模型，并将序列化的模型保存到名为<code class="fe mn mo mp mq b">iris_model.pkl</code>的pickle文件中。</p><pre class="mr ms mt mu gt mv mq mw mx aw my bi"><span id="9808" class="mz lr je mq b gy na nb l nc nd"># Importing the required Python libraries<br/>import numpy as np<br/>import pandas as pd<br/>import pickle<br/>from sklearn import datasets<br/>from sklearn.linear_model import LogisticRegression</span><span id="b300" class="mz lr je mq b gy ne nb l nc nd"># Loading the iris dataset from Scikit-Learn<br/>iris = datasets.load_iris()</span><span id="fe5e" class="mz lr je mq b gy ne nb l nc nd"># Converting the iris dataset into a Pandas DataFrame<br/>df_iris = pd.DataFrame(data = np.c_[iris['data'], iris['target']],<br/>            columns = iris['feature_names'] + ['target'])</span><span id="f8f8" class="mz lr je mq b gy ne nb l nc nd"># Separating the training dataset (X) from the predictor value (y)<br/>X = df_iris.drop(columns = ['target'])<br/>y = df_iris[['target']]</span><span id="1f20" class="mz lr je mq b gy ne nb l nc nd"># Instantiating a Logistic Regression (LR) model<br/>lr_model = LogisticRegression()</span><span id="c792" class="mz lr je mq b gy ne nb l nc nd"># Fitting the dataset to the LR model<br/>lr_model.fit(X, y)</span><span id="0004" class="mz lr je mq b gy ne nb l nc nd"># Saving the model to a serialized .pkl file<br/>pkl_filename = "../models/iris_model.pkl"<br/>with open(pkl_filename, 'wb') as file:<br/>    pickle.dump(lr_model, file)</span></pre><p id="67d2" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">创建好模型后，我就可以创建API了。作为下面脚本的一部分，您可以看到我正在使用FastAPI框架创建具有两个端点的模型服务API。第一个默认端点只是返回一个JSON消息，声明<code class="fe mn mo mp mq b">Hello friends!</code>。第二个端点<code class="fe mn mo mp mq b">/predict</code>是实际接收数据并从我们的模型返回推理结果的端点。同样，我们在这里做一些非常基础的东西。你实际的API可能会比这个复杂得多，但是我们在这里保持事情简单。</p><pre class="mr ms mt mu gt mv mq mw mx aw my bi"><span id="5a12" class="mz lr je mq b gy na nb l nc nd">import pandas as pd<br/>import pickle<br/>from fastapi import FastAPI, Request<br/>from fastapi.responses import JSONResponse</span><span id="5032" class="mz lr je mq b gy ne nb l nc nd">## API INSTANTIATION<br/>## ----------------------------------------------------------------<br/># Instantiating FastAPI<br/>api = FastAPI()</span><span id="0665" class="mz lr je mq b gy ne nb l nc nd"># Loading in model from serialized .pkl file<br/>pkl_filename = "../models/iris_model.pkl"<br/>with open(pkl_filename, 'rb') as file:<br/>    lr_model = pickle.load(file)</span><span id="3ff9" class="mz lr je mq b gy ne nb l nc nd">## API ENDPOINTS<br/>## ----------------------------------------------------------------<br/># Defining a test root path and message<br/><a class="ae lp" href="http://twitter.com/api" rel="noopener ugc nofollow" target="_blank">@api</a>.get('/')<br/>def root():<br/>    msg = {'message': 'Hello friends!'}<br/>    return JSONResponse(content = msg, status_code = 200)</span><span id="bcf7" class="mz lr je mq b gy ne nb l nc nd"># Defining the prediction endpoint<br/><a class="ae lp" href="http://twitter.com/api" rel="noopener ugc nofollow" target="_blank">@api</a>.post('/predict')<br/>async def predict(request: Request):</span><span id="9498" class="mz lr je mq b gy ne nb l nc nd">    # Getting the JSON from the body of the request<br/>    input_data = await request.json()</span><span id="2074" class="mz lr je mq b gy ne nb l nc nd">    # Converting JSON to Pandas DataFrame<br/>    input_df = pd.DataFrame([input_data])</span><span id="4771" class="mz lr je mq b gy ne nb l nc nd">    # Getting the prediction from the Logistic Regression model<br/>    pred = lr_model.predict(input_df)[0]</span><span id="a1d9" class="mz lr je mq b gy ne nb l nc nd">return JSONResponse(content = pred, status_code = 200)</span></pre><p id="07e9" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">最后，如果您想自己测试这个API，我创建了一些示例JSON数据，可以很好地满足这些目的。看起来是这样的:</p><pre class="mr ms mt mu gt mv mq mw mx aw my bi"><span id="8eba" class="mz lr je mq b gy na nb l nc nd">{"sepal_length":5.1,"sepal_width":3.5,"petal_length":1.4,"petal_width":0.2}</span></pre><p id="68e9" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">这就是这个API的大部分内容！既然我们已经为这篇文章的剩余部分打下了基础，现在让我们开始进入所有可以像这样强化API的方法。</p><h1 id="dbb0" class="lq lr je bd ls lt lu lv lw lx ly lz ma kk mb kl mc kn md ko me kq mf kr mg mh bi translated">1.使用Pytest进行单元测试</h1><p id="0d3d" class="pw-post-body-paragraph kt ku je kv b kw mi kf ky kz mj ki lb lc mk le lf lg ml li lj lk mm lm ln lo im bi translated">原因之一，这可能是你最熟悉的一个。即使您不习惯强化API，您也很可能已经为自己的健全性检查创建了一个单元测试。出于我们的目的，我们将使用<code class="fe mn mo mp mq b">pytest</code>和FastAPI测试客户端。安装<code class="fe mn mo mp mq b">pytest</code>非常容易。您只需运行以下命令:</p><p id="4564" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><code class="fe mn mo mp mq b">pip3 install pytest</code></p><p id="f89a" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">现在，为了在CLI中实际使用<code class="fe mn mo mp mq b">pytest</code>，我们将运行一个小的bash脚本，该脚本执行我们的测试文件并将输出写到<code class="fe mn mo mp mq b">reports</code>目录中。看起来是这样的:</p><pre class="mr ms mt mu gt mv mq mw mx aw my bi"><span id="00e5" class="mz lr je mq b gy na nb l nc nd">pytest --log-file=reports/unit_test_report.txt unit_testing/</span></pre><p id="11c1" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">好的，这很简单…但是它怎么知道要测试什么呢？注意在上面命令的末尾，我们让<code class="fe mn mo mp mq b">pytest</code>遍历<code class="fe mn mo mp mq b">unit_testing</code>目录下的所有文件。在我的<code class="fe mn mo mp mq b">unit_testing</code>目录中，我有一个Python脚本，它既设置单元测试客户端，又运行单元测试。完整的脚本如下所示:</p><pre class="mr ms mt mu gt mv mq mw mx aw my bi"><span id="b063" class="mz lr je mq b gy na nb l nc nd">import json<br/>from fastapi.testclient import TestClient<br/>from container.api import api</span><span id="9464" class="mz lr je mq b gy ne nb l nc nd">## PYTEST SETUP<br/>## --------------------------------------------------------------------------------------------------------------------<br/># Instantiating the test client from our container's API<br/>client = TestClient(api)</span><span id="d291" class="mz lr je mq b gy ne nb l nc nd"># Loading test JSON file<br/>with open('test_json/test_data.json', 'rb') as file:<br/>    test_json = json.load(file)</span><span id="8da2" class="mz lr je mq b gy ne nb l nc nd">## UNIT TEST CASES<br/>## --------------------------------------------------------------------------------------------------------------------<br/># Creating a unit test for the basic root path<br/>def test_root_message():<br/>    response = client.get("/")<br/>    assert response.status_code == 200<br/>    assert response.json() == {'message': 'Hello friends!'}</span><span id="a97a" class="mz lr je mq b gy ne nb l nc nd"># Creating a unit test for the prediction endpoint<br/>def test_predict():<br/>    response = client.post('/predict', json = test_json)<br/>    assert response.status_code == 200</span></pre><p id="cefe" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">在这里，你会注意到两个不同的部分。在“Pytest Setup”一节中，我们实际上是使用之前创建的同一个FastAPI脚本来实例化FastAPI测试客户端，然后加载少量的样本数据。在第二部分中，我们使用FastAPI测试客户端和样本数据来运行一些带有<code class="fe mn mo mp mq b">assert</code>语句的测试用例。注意，为了通过单元测试，这些<code class="fe mn mo mp mq b">assert</code>语句具有需要满足的特定条件。如果这些测试用例中的任何一个失败了，Pytest将会适当地记录下来，并简要解释失败的原因。在下面的截图中，看看当我有意改变单元测试look为“Hello friend！”而不是恰当的“你好朋友！”</p><figure class="mr ms mt mu gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nf"><img src="../Images/e275c463ae2cb32f3c35734580847bb0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1aPZCwagwiqHbzPMdS5dIw.jpeg"/></div></div><p class="ng nh gj gh gi ni nj bd b be z dk translated">作者截图</p></figure><p id="87ec" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">尽早设置单元测试是非常好的，因为您可以设置一个CI/CD管道，在您对API进行修改的任何时候都可以运行这个测试。如果你犯了一个错误，单元测试会发现它并让你知道问题。单元测试无疑让我避免了许多粗心的错误，所以一定要为您的模型服务API编写单元测试！</p><h1 id="d9c8" class="lq lr je bd ls lt lu lv lw lx ly lz ma kk mb kl mc kn md ko me kq mf kr mg mh bi translated">2.使用蝗虫进行性能测试</h1><p id="6af7" class="pw-post-body-paragraph kt ku je kv b kw mi kf ky kz mj ki lb lc mk le lf lg ml li lj lk mm lm ln lo im bi translated">由于API通常每天被调用数千次，如果不是数百万次的话，您肯定希望确保您的模型服务API能够适当地处理负载。为此，我们有一个名为蝗虫的工具来帮助我们。现在，我不打算在这个曾经的<a class="ae lp" rel="noopener" target="_blank" href="/performance-testing-an-ml-serving-api-with-locust-ecd98ab9b7f7">上花太多时间，因为我已经写了一个完整的帖子，更详细地介绍了蝗虫</a>。如果你想了解更多，我肯定会鼓励你去看看。这里我要注意的唯一一件事是，post主要关注在UI模型中使用Locust。在他们所谓的“无头”模式下，完全可以在没有用户界面的情况下运行它。下面是该命令的样子:</p><pre class="mr ms mt mu gt mv mq mw mx aw my bi"><span id="5d75" class="mz lr je mq b gy na nb l nc nd">locust — locustfile performance_testing/locustfile.py — headless — users 15 — spawn-rate 5 — run-time 30s — only-summary — csv reports/performance_test</span></pre><p id="a136" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">在运行该命令时，Locust将执行性能测试，然后将结果作为4个单独的CSV文件的一部分写出。老实说，我希望有一种方法可以将它作为一个单独的报告导出，但是我认为有总比没有好！同样，我们不打算深入讨论蝗虫命令是如何工作的，所以如果你想了解更多，我鼓励你看看我以前的帖子。</p><h1 id="fd05" class="lq lr je bd ls lt lu lv lw lx ly lz ma kk mb kl mc kn md ko me kq mf kr mg mh bi translated">3.安全的依赖性扫描</h1><p id="d4a7" class="pw-post-body-paragraph kt ku je kv b kw mi kf ky kz mj ki lb lc mk le lf lg ml li lj lk mm lm ln lo im bi translated">这个和下一个是齐头并进的，但是我们将从这个开始，因为它是两个中“不太健壮”的。当容器化您的模型服务API时，您肯定需要执行一个<code class="fe mn mo mp mq b">pip install</code>来安装您需要的所有Python库来支持您的工作。依赖项扫描将查看<code class="fe mn mo mp mq b">requirements.txt</code>文件中依赖项的所有固定版本，并让您知道哪些类型的漏洞与相应的Python库相关联。</p><p id="a27c" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">出于我们的目的，我们将使用一个名为Safety的免费工具。安全性非常简单易用。要安装安全，您只需运行以下命令:</p><pre class="mr ms mt mu gt mv mq mw mx aw my bi"><span id="dbe6" class="mz lr je mq b gy na nb l nc nd">pip install safety</span></pre><p id="d2aa" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">实际执行安全命令也同样简单。在下面的命令中，你会看到它直接指向我的<code class="fe mn mo mp mq b">requirements.txt</code>文件，然后适当地保存一个完整的输出报告。</p><pre class="mr ms mt mu gt mv mq mw mx aw my bi"><span id="a926" class="mz lr je mq b gy na nb l nc nd">safety check -r ../dependencies/requirements.txt --full-report -o reports/dependency_scan_report.txt</span></pre><p id="e2af" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">如果你不知道，有一个由美国国土安全部支持的名为CVE的开源数据库。<a class="ae lp" href="https://cve.mitre.org/" rel="noopener ugc nofollow" target="_blank"> CVE数据库</a>包含所有已知和常见的安全漏洞，包括一些如何修复适当的CVE的选项。现在，我正在努力将我的依赖关系与一些最新的Python库联系起来，但是只是为了演示当安全发现一些问题时它是如何工作的，让我们看看当我用一个非常旧版本的Uvicorn扫描一个<code class="fe mn mo mp mq b">requirements.txt</code>文件时会发生什么。(准确的说是uvicon 0 . 0 . 4):</p><figure class="mr ms mt mu gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nk"><img src="../Images/9983a28429225029fbc2202c1bf30f95.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B-q01K7rN5uv3nsCwY_pVQ.jpeg"/></div></div><p class="ng nh gj gh gi ni nj bd b be z dk translated">作者截图</p></figure><p id="27ab" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">如你所见，这个旧版本的Uvicorn有两个安全问题。它提供了一个很好的描述，也包括适当的CVE数。如果您想了解更多关于该漏洞的信息，您可以使用CVE号码进行搜索。例如，第一个漏洞记录了CVE-2020–7694。<a class="ae lp" href="https://nvd.nist.gov/vuln/detail/CVE-2020-7694" rel="noopener ugc nofollow" target="_blank">如果你去这个链接</a>，除了Safety提供的相对简短的描述，你还可以了解更多关于这个漏洞的信息。</p><p id="1226" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">这就是安全，但在继续之前，我觉得我应该提到使用供应商解决方案的价值高于安全，特别是如果你为一家大公司工作。Safety只查询政府的CVE数据库，该数据库并不总是与最新信息保持同步。供应商解决方案通常包含他们自己的数据库以及这些额外的漏洞问题，因此，如果您的公司特别关注安全性，我可能会建议您使用这些解决方案中的一种。</p><h1 id="ad34" class="lq lr je bd ls lt lu lv lw lx ly lz ma kk mb kl mc kn md ko me kq mf kr mg mh bi translated">4.用Docker扫描集装箱(Snyk)</h1><p id="9ece" class="pw-post-body-paragraph kt ku je kv b kw mi kf ky kz mj ki lb lc mk le lf lg ml li lj lk mm lm ln lo im bi translated">依赖扫描很棒，但是它的问题是，如果你要走容器化的路线(你可能会这样)，它不能得到与你使用的基本映像相关的所有东西。最近，Docker与一家名为Snyk的第三方公司合作，将一个容器扫描工具直接嵌入Docker CLI。它非常容易使用，并自动捆绑了最新版本的Docker。唯一的“问题”是，你需要一个Docker Hub帐户，但也可以自由创建。如果您以前没有这样做过，<a class="ae lp" href="https://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=&amp;ved=2ahUKEwjj59ykzaTyAhXgFVkFHbMXA08QFnoECAoQAw&amp;url=https%3A%2F%2Fhub.docker.com%2Fsignup&amp;usg=AOvVaw0ZK6uD6-fF7BcJCTMDsVuh" rel="noopener ugc nofollow" target="_blank">您可以在这里创建一个Docker Hub帐户</a>。</p><p id="750b" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">要在本地使用容器扫描，您需要做两件事。首先，你需要登录Docker Hub。为此，请运行以下命令:</p><pre class="mr ms mt mu gt mv mq mw mx aw my bi"><span id="ae4f" class="mz lr je mq b gy na nb l nc nd">docker login</span></pre><p id="bdb4" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">运行该命令将启动一些其他提示，要求您输入各自的Docker用户名和密码信息。当然，您需要做的下一件事是构建容器！出于我的目的，我通过如下方式构建我的容器，使事情变得非常简单:</p><pre class="mr ms mt mu gt mv mq mw mx aw my bi"><span id="e914" class="mz lr je mq b gy na nb l nc nd">docker build -t iris-api:dev .</span></pre><p id="af44" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">构建好容器并登录Docker后，我们就可以执行容器扫描了！该命令如下所示:</p><pre class="mr ms mt mu gt mv mq mw mx aw my bi"><span id="9995" class="mz lr je mq b gy na nb l nc nd">docker scan iris-api:dev | tee reports/container_scan_results.txt</span></pre><p id="be8a" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">现在，你可能想知道<code class="fe mn mo mp mq b">tee</code>在这里做什么。我们所有的其他工具都提供了某种输出结果的机制，但是<code class="fe mn mo mp mq b">docker scan</code>命令没有任何内置选项来导出结果。相反，输出仅直接显示在CLI中。<code class="fe mn mo mp mq b">tee</code>允许我们从命令行界面获取输出，并保存到文本文件中。如果你想在其他场合使用<code class="fe mn mo mp mq b">tee</code>，你完全可以。无论如何不仅限于<code class="fe mn mo mp mq b">docker scan</code>。以下是我的扫描结果:</p><figure class="mr ms mt mu gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nk"><img src="../Images/5822782adba720a558dbbbe46c0a550d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LSiEQDuGgFzA8mtpvVhmbA.jpeg"/></div></div><p class="ng nh gj gh gi ni nj bd b be z dk translated">作者截图</p></figure><p id="0e93" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">如您所见，它引发了相当多的漏洞，绝对超过了我们的依赖扫描。这是因为我使用的是<code class="fe mn mo mp mq b">python:3.9-slim-buster</code>，Snyk暴露了许多与Debian OS相关的漏洞。我实话实说:我不知道我是否同意所有这些发现，所以慎用。我认为Snyk是一家较新的公司，所以我乐观地认为他们会改进他们的流程，以正确反映适当的漏洞！</p><h1 id="6049" class="lq lr je bd ls lt lu lv lw lx ly lz ma kk mb kl mc kn md ko me kq mf kr mg mh bi translated">5.用Bandit进行静态代码扫描</h1><p id="86be" class="pw-post-body-paragraph kt ku je kv b kw mi kf ky kz mj ki lb lc mk le lf lg ml li lj lk mm lm ln lo im bi translated">我们在列表上的最后一次安全扫描着眼于您的Python代码的潜在漏洞，我们在一个名为Bandit的工具的支持下完成这项工作。对于这次扫描，我们将指向包含所有Python文件的目录，它将指出从纯Python的角度来看我们应该小心的事情。在我的例子中，我的所有Python文件(包括带有FastAPI的文件)都在一个名为<code class="fe mn mo mp mq b">container</code>的目录中，因此我们将使用以下命令让Bandit扫描那里:</p><pre class="mr ms mt mu gt mv mq mw mx aw my bi"><span id="1a62" class="mz lr je mq b gy na nb l nc nd">bandit --format=txt --output=reports/static_scan_report.txt -r ../container/</span></pre><p id="8572" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">在我们的场景中，Python代码非常简单，所以扫描并不明显。如果你好奇，下面是我的特定扫描的输出结果:</p><figure class="mr ms mt mu gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nk"><img src="../Images/2f04e6a8de7a1b72244e3a51f5bb7a6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*591HtF8aVWsqjWR9_txNDA.jpeg"/></div></div><p class="ng nh gj gh gi ni nj bd b be z dk translated">作者截图</p></figure><p id="eb61" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">如您所见，它正确地指出，我应该对导入pickle文件保持谨慎，因为有人将恶意软件打包成pickle文件的一部分并不罕见。在我们的例子中，我们知道我们构建了pickle文件，所以我们可以看着它说，“谢谢Bandit，但是我很好！”</p><h1 id="53df" class="lq lr je bd ls lt lu lv lw lx ly lz ma kk mb kl mc kn md ko me kq mf kr mg mh bi translated">6.用Pylint编码棉绒</h1><p id="1d66" class="pw-post-body-paragraph kt ku je kv b kw mi kf ky kz mj ki lb lc mk le lf lg ml li lj lk mm lm ln lo im bi translated">这最后一个是…我要说可选。(一会儿你就知道为什么了。)如果你回想起你的大学时代，你可能会想起你的教授让你用一种特殊的格式写论文，如MLA或APA格式。如果你不知道的话，编码界有一个非常相似的东西，叫做PEP-8。Pylint专门检查您的Python代码，以确保它遵循PEP-8标准以及其他一些标准。安装Pylint非常容易。只需运行以下命令:</p><pre class="mr ms mt mu gt mv mq mw mx aw my bi"><span id="41e1" class="mz lr je mq b gy na nb l nc nd">pip install pylint</span></pre><p id="71c5" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">为了针对您的代码运行linter，您需要做的就是以如下方式使用<code class="fe mn mo mp mq b">pylint</code>:</p><pre class="mr ms mt mu gt mv mq mw mx aw my bi"><span id="d064" class="mz lr je mq b gy na nb l nc nd">pylint ../container/ --reports=y --output=reports/linter_report.txt</span></pre><p id="8a08" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">该命令的输出将提供关于您如何改进的完整描述，并且还会提供……*战栗*…您的表现如何，满分为10分。(越高越好。)现在，让我们看看我的分数如何:</p><figure class="mr ms mt mu gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nl"><img src="../Images/668c31d80ef056187e341927fa6b88f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UqIvT0MR01_GnZaaWkf-ew.jpeg"/></div></div><p class="ng nh gj gh gi ni nj bd b be z dk translated">作者截图</p></figure><p id="1ac0" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">是的，你没看错。我得了满分10分的3.00分。请允许我发表一点小小的意见…亲爱的读者，你认为我的代码有那么糟糕吗？我因为提供有力的评论和把事情分成“部分”而臭名昭著，所以我接受乌姆里奇的说法，我只得到区区3.00分。但是，嘿，我在大学里也和教授们在APA格式上争论过，所以这是我的天性，在这些能力上与众不同。😂尽管如此，我觉得如果您的组织真的关心遵循PEP-8指南，这是值得一提的。</p></div><div class="ab cl nm nn hx no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="im in io ip iq"><p id="044c" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">这篇文章到此结束！回来的感觉真好。希望你喜欢这个，并期待在不久的将来会有更多精彩的内容。我已经在SageMaker，Terraform上发了帖子，还有更多正在制作中。会很好玩的！感谢阅读！</p></div></div>    
</body>
</html>