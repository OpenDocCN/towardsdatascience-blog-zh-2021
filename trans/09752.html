<html>
<head>
<title>SQL — Understand how indices work under the hood to speed up your queries</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SQL——了解索引如何在幕后加速您的查询</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/sql-understand-how-indices-work-under-the-hood-to-speed-up-your-queries-a7f07eef4080?source=collection_archive---------18-----------------------#2021-09-12">https://towardsdatascience.com/sql-understand-how-indices-work-under-the-hood-to-speed-up-your-queries-a7f07eef4080?source=collection_archive---------18-----------------------#2021-09-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0cbc" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">不再需要等待缓慢的查询完成</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/3fb6e31c2700227de7671e17cc18fb1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*soR7zXyE3ZJOwgW4"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">如何在这些记录行中快速找到我们的数据？(图片由<a class="ae ky" href="https://unsplash.com/@iammrcup" rel="noopener ugc nofollow" target="_blank">杨奇煜·巴拉尔</a>在<a class="ae ky" href="https://unsplash.com/photos/o6GEPQXnqMY" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄)</p></figure><p id="6698" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有没有想过数据库引擎如何快速返回你的查询数据<em class="lv">？它如何能在瞬间搜索许多表格和数百万条记录？本文探讨了数据库引擎是如何工作的，并揭示了如何以最佳方式设计表和索引。不再需要等待查询完成！</em></p><p id="d67f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">像往常一样，我们将首先建立一个示例，创建一些样本数据，这样我们就有东西可以使用了。然后，我们将了解数据库引擎在没有索引的情况下如何运行。然后我们将添加索引来加速我们的查询，演示您也可以这样做。在本文结束时，您将:</p><ul class=""><li id="a567" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated">了解什么是指数</li><li id="dd5c" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">理解指数的类型及其区别</li><li id="d6d4" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">理解指数是如何工作的</li><li id="f4a9" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">知道在什么情况下使用什么类型的索引</li></ul><p id="cb00" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，在本文中，我们使用的是SQL Server，但该原则适用于许多其他关系数据库，如Postgres和MySQL，例如语法可能会有所不同。让代码！</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h2 id="cd42" class="mr ms it bd mt mu mv dn mw mx my dp mz li na nb nc lm nd ne nf lq ng nh ni nj bi translated">设置</h2><p id="2b02" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">为了说明本文中的代码，我创建了一个很多应用程序都使用的表格。它拥有2000万条用户信息记录，可用于注册新用户、登录时检查密码以及更改用户信息。我已经用Python生成了这个表，使用了本文 中描述的超快速插入方法。创建表的代码如下所示:</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="45a1" class="mr ms it nq b gy nu nv l nw nx">CREATE TABLE [dbo].[Users] (<br/>   [Created] DATETIME NOT NULL DEFAULT GETUTCDATE()<br/>   , [Modified] DATETIME NOT NULL DEFAULT GETUTCDATE()<br/>   , [FirstName] NVARCHAR(100) NOT NULL<br/>   , [LastName] NVARCHAR(100) NOT NULL<br/>   , [UserName] NVARCHAR(100) NOT NULL<br/>   , [Password] NVARCHAR(100) NOT NULL<br/>   , [Age] INT NULL<br/>);</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ny"><img src="../Images/6c4f7dda7c1ed9f6faf324949f3c5231.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Bm5h12vHkuMp39Aeb5EiOg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">我们的用户表(图片由作者提供)</p></figure><p id="b23d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，它包含一些与用户相关的列(最后5列)和两个跟踪记录创建和更新时间的列。这张桌子有一些问题，我们将在这篇文章中解决。</p><p id="c157" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们的Users表用于像Reddit这样的网站。每次登录时，我们都需要检查用户名和密码。此外，有时用户改变他们的电子邮件，用户名或密码，所以我们也需要更新。此外，我们需要能够通过插入新记录来添加新用户。如何在这么大的表中进行快速查询？</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="cec3" class="nz ms it bd mt oa ob oc mw od oe of mz jz og ka nc kc oh kd nf kf oi kg ni oj bi translated">垃圾堆</h1><p id="a266" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">我们目前已经用最笨最慢的方式设计了我们的桌子。当我们寻找一个特定的用户时，我们的表必须查看表中的每一条记录。这种表称为<strong class="lb iu">堆表</strong>，检查表中的每条记录称为<strong class="lb iu">表扫描</strong>。想象一下，去一家酒店，检查每一个房间，然后确定哪一个是你的！非常低效。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/0ce3609b43ba2dd9631ecb1e5a64ed15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2HJXeOlUbMKf2g3u"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">堆的精确表示(图片由<a class="ae ky" href="https://unsplash.com/@neonbrand" rel="noopener ugc nofollow" target="_blank"> Neonbrand </a>在<a class="ae ky" href="https://unsplash.com/photos/8Yk4T-tDSYY" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄)</p></figure><h2 id="7b87" class="mr ms it bd mt mu mv dn mw mx my dp mz li na nb nc lm nd ne nf lq ng nh ni nj bi translated">询问</h2><p id="084f" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">让我们尝试按姓氏列查找记录:</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="855e" class="mr ms it nq b gy nu nv l nw nx">SELECT *<br/>FROM Med.dbo.UsersHeap WITH (NOLOCK)<br/>WHERE LastName = 'LastName123123'</span></pre><p id="2d86" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">执行上述查询将花费相当长的时间；数据库引擎必须扫描表中的每条记录。它不能在第一个找到的记录处停止，因为可能有更多的用户具有相同的姓氏。此外，数据是无序的，所以记录可以在任何位置(任何行号)。</p><p id="e398" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们分析一下执行计划:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/132c6057c437dcc3eef4e29655b87b42.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/format:webp/1*_-DFXsXlbUR8EXSC5fk6Tg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">从堆表中选择记录的执行计划(图片由作者提供)</p></figure><p id="0171" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您将看到数据库引擎执行了一次表扫描，这几乎花了一秒钟的时间！当您将鼠标悬停在最右侧的块上时，它会显示下图:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/c3ef662ff801a2caf90b11b29145b89e.png" data-original-src="https://miro.medium.com/v2/resize:fit:916/format:webp/1*u15mbqxywFlnh5Bcadh_dg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">执行计划详情(图片由作者提供)</p></figure><p id="f34d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您将看到它实际上读取了所有2000万条记录，但只返回了2条。这些类型的堆表和表扫描效率非常低，不应该使用。我们可以通过增加一个索引来提高很多。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="67b3" class="nz ms it bd mt oa ob oc mw od oe of mz jz og ka nc kc oh kd nf kf oi kg ni oj bi translated">聚集索引</h1><p id="c9ee" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">让我们向表中添加一个聚集索引:我们将向表中添加一个存储主键的新列；每行具有唯一值的整数。然后，这些值被分类并物理存储在一个树状结构中。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/435fb4367f4c4a476cf7a86d32533ceb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*XoPrEaXyUiVp6sQL"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">从根部开始，沿着这个树状结构向上(图片由<a class="ae ky" href="https://unsplash.com/@maxniceman" rel="noopener ugc nofollow" target="_blank"> Max Nayman </a>在<a class="ae ky" href="https://unsplash.com/photos/n93ugNYul3w" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上提供)</p></figure><h2 id="19d5" class="mr ms it bd mt mu mv dn mw mx my dp mz li na nb nc lm nd ne nf lq ng nh ni nj bi translated">它是如何工作的</h2><p id="626f" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">但是数据库引擎如何使用这个索引来更快地检索行呢？让我们再次使用酒店的例子:你需要找到房间E512。</p><ul class=""><li id="2336" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated">字母E表示你必须去酒店的东翼</li><li id="80b4" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">第一个数字(5)表示我们必须去5楼</li><li id="893e" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">一旦我们走出电梯，我们看到一个标志，上面写着1-20号房间在左边，21-40号房间在右边。因为房间已经订好了，所以我们找房间时不需要找太远！</li></ul><p id="7035" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">数据库引擎的工作方式很像这样。我们不需要访问酒店的每一个房间并检查是否是我们的，而是使用树状结构的索引来更快地引导我们到达目的地。唯一的区别是，数据库引擎使用更多的分支，而不是我们使用的三个分支(东翼，5楼，大厅右侧)。</p><h2 id="6cf1" class="mr ms it bd mt mu mv dn mw mx my dp mz li na nb nc lm nd ne nf lq ng nh ni nj bi translated">创建索引</h2><p id="e606" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">让我们来收拾桌子:</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="d106" class="mr ms it nq b gy nu nv l nw nx">CREATE TABLE [dbo].[Users] (<br/>   [Id] INTEGER IDENTITY PRIMARY KEY NOT NULL<br/>   , [Created] DATETIME NOT NULL DEFAULT GETUTCDATE()<br/>   , [Modified] DATETIME NOT NULL DEFAULT GETUTCDATE()<br/>   , [FirstName] NVARCHAR(100) NOT NULL<br/>   , [LastName] NVARCHAR(100) NOT NULL<br/>   , [UserName] NVARCHAR(100) NOT NULL<br/>   , [Password] NVARCHAR(100) NOT NULL<br/>   , [Age] INT NULL<br/>);</span></pre><p id="a137" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">神奇在二线；当您提供主键列时，数据库引擎会自动创建聚集索引。IDENTITY部分将为每个记录生成一个新的整数。我们的Id栏是新的。新表如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi om"><img src="../Images/8788e62bfa5781aa67c94ce68f08d82f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qxawChIPDBLAAMHVPpS2Tw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">带有聚集索引的用户表(作者图片)</p></figure><h2 id="febe" class="mr ms it bd mt mu mv dn mw mx my dp mz li na nb nc lm nd ne nf lq ng nh ni nj bi translated">询问</h2><p id="5acb" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">现在我们可以通过Id列检索记录。假设我们想要检索Id = 42的记录:</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="b57f" class="mr ms it nq b gy nu nv l nw nx">SELECT *<br/>FROM Med.dbo.Users WITH (NOLOCK)<br/>WHERE Id = 42</span></pre><p id="61c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们执行这个时，数据库引擎使用我们新创建的索引；这是非常非常快，因为它使用了类似酒店的方法。我们还可以在执行计划中看到这一点:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi on"><img src="../Images/e010307a9076ac7dd7b42b008f08e23d.png" data-original-src="https://miro.medium.com/v2/resize:fit:790/format:webp/1*CfDSGQh1eYqohkxzJsoAZA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">我们的查询的聚集索引查询计划(图片由作者提供)</p></figure><p id="8efd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看到我们正在使用一个<strong class="lb iu">聚集索引查找</strong>了吗？这表明我们正在使用聚集索引。也要注意时间:0.000秒；真快！我们还可以在该图块的执行细节中查看这一点:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/624a347e1d340cfb6ab7c26d22d7cc29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1018/format:webp/1*3yHmekonUXbcNc_Fg01ViA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">聚集索引查找的执行详细信息(作者图片)</p></figure><p id="fdfc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看到我们只读了一行吗？这与我们的表格扫描相比有很大的不同！但是如果我们想使用另一个列来过滤呢？</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="07c8" class="nz ms it bd mt oa ob oc mw od oe of mz jz og ka nc kc oh kd nf kf oi kg ni oj bi translated">非聚集索引</h1><p id="71b9" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">好的，主键在Id列上，我们可以使用聚集索引很快找到我们的记录。我们如何优化在其他列上过滤的查询？对于这些列，我们可以创建一个非聚集索引。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/46eef8661437080515dd31bfb20f5293.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3cOVP503B3twdRUE"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">蜘蛛侠使用书中的索引查找SQL术语的图片(图片由<a class="ae ky" href="https://unsplash.com/@roadtripwithraj" rel="noopener ugc nofollow" target="_blank"> Raj </a>在<a class="ae ky" href="https://unsplash.com/photos/o4c2zoVhjSw" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上提供)</p></figure><h2 id="4a98" class="mr ms it bd mt mu mv dn mw mx my dp mz li na nb nc lm nd ne nf lq ng nh ni nj bi translated">它是如何工作的</h2><p id="2ca5" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">非聚集索引的工作方式很像书中的索引。这些包含某些单词以及这些单词的使用位置。在一本经济学书中，你可能会在第42、119和246页看到“通货膨胀”一词。非聚集索引的工作方式非常类似:它将列中的所有值作为键，并注册所有相应的id(来自聚集索引)。非聚集索引需要聚集索引才能运行。这些键-值-对被排序并存储在它们自己的树状结构中，因此我们可以快速定位它们。这个操作被称为<strong class="lb iu">步进扫描</strong>。</p><p id="5ff9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们将创建索引:</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="5261" class="mr ms it nq b gy nu nv l nw nx">CREATE NONCLUSTERED INDEX ix_users_lastname <br/>    ON Med.dbo.Users(LastName)</span></pre><p id="ec99" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您在LastName = 'Cartman '上过滤的图像:</p><ol class=""><li id="a9e3" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu op mc md me bi translated">然后，非聚集索引将执行<strong class="lb iu">键查找</strong>:它将遍历树，查找名为‘Cartman’的键。它将在我们的表中找到3个具有这个姓氏的记录；他们有编号4，16和333。</li><li id="d503" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu op mc md me bi translated">在步骤2中，我们将使用聚集索引，执行索引查找，返回实际记录。让我们看看这是怎么回事！</li></ol><h2 id="eff6" class="mr ms it bd mt mu mv dn mw mx my dp mz li na nb nc lm nd ne nf lq ng nh ni nj bi translated">询问</h2><p id="877e" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">现在，我们可以通过名称列检索记录。假设我们想要检索LastName = 'LastName456456 '的记录:</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="f255" class="mr ms it nq b gy nu nv l nw nx">SELECT *<br/>FROM Med.dbo.Users WITH (NOLOCK)<br/>WHERE LastName = 'LastName456456'</span></pre><p id="4088" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个查询也非常快；正如您在下面的执行计划中看到的，所有操作都在0.000秒内完成:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/005f55838f170dd8b8b60d271acfe83f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1066/format:webp/1*AQvZJiyw2I8C8-j8rLyluw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">我们的非聚集索引查询的执行计划(图片由作者提供)</p></figure><p id="cce0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您将看到它首先执行键查找；它查找我们的列的值并返回id。然后这些id会在索引搜索中使用。这两个索引一起工作保证了用户友好的、超快的查询！</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="ba30" class="nz ms it bd mt oa ob oc mw od oe of mz jz og ka nc kc oh kd nf kf oi kg ni oj bi translated">结论</h1><p id="d470" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">在这篇文章中，我希望通过添加索引来加速你的表。本文主要关注创建索引和从表中检索数据。在以后的文章中，我们将讨论什么时候创建索引实际上会损害性能，以及如何最好地插入数据以防止频繁更新索引。请关注我，保持联系！</p><p id="a439" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同时，看看我的<a class="ae ky" href="https://mikehuls.medium.com/" rel="noopener">关于各种编程相关话题的其他文章</a>，比如:</p><ul class=""><li id="b1ab" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated"><a class="ae ky" href="https://mikehuls.medium.com/sql-delete-into-another-table-b5b946a42299" rel="noopener">删除进入另一个表</a></li><li id="e269" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated"><a class="ae ky" href="https://mikehuls.medium.com/sql-update-into-another-table-bfc3dff79a66" rel="noopener">更新到另一个标签页</a> le</li><li id="afdc" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated"><a class="ae ky" href="https://mikehuls.medium.com/sql-insert-delete-and-update-in-one-statement-sync-your-tables-with-merge-14814215d32c" rel="noopener">在一条语句中插入、删除和更新</a></li><li id="b4b6" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated"><a class="ae ky" href="https://mikehuls.medium.com/sql-update-select-in-one-query-b067a7e60136" rel="noopener">更新选择一批记录</a></li><li id="4ae5" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated"><a class="ae ky" href="https://mikehuls.medium.com/python-to-sql-upsert-safely-easily-and-fast-17a854d4ec5a" rel="noopener">保存上插</a></li><li id="c8eb" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated"><a class="ae ky" href="https://mikehuls.medium.com/sql-inserting-only-unique-values-in-a-unique-table-af2eb3b9890a" rel="noopener">插入唯一表格</a></li><li id="73fb" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated"><a class="ae ky" href="https://mikehuls.medium.com/sql-insert-values-with-joined-ids-from-another-table-83ff7f149296" rel="noopener">从另一个表中插入具有连接id的值</a></li></ul><p id="1449" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">编码快乐！</p><p id="303e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">—迈克</p><p id="2aec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">页（page的缩写）学生:比如我正在做的事情？<a class="ae ky" href="https://github.com/mike-huls" rel="noopener ugc nofollow" target="_blank">跟我来</a>！</p></div></div>    
</body>
</html>