<html>
<head>
<title>Custom dataset in Pytorch —Part 1. Images</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Pytorch中的自定义数据集—第1部分。形象</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/custom-dataset-in-pytorch-part-1-images-2df3152895?source=collection_archive---------3-----------------------#2021-08-18">https://towardsdatascience.com/custom-dataset-in-pytorch-part-1-images-2df3152895?source=collection_archive---------3-----------------------#2021-08-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/c7953364abe0225aaf91f29fffeda9db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*863QDrCbsLoVeoim"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">马克·特里亚皮奇尼科夫在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="be67" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Pytorch有一个很好的生态系统来加载定制数据集，用于训练机器学习模型。这是关于在Pytorch中加载自定义数据集的两部分系列文章的第一部分。在<a class="ae kc" rel="noopener" target="_blank" href="/custom-datasets-in-pytorch-part-2-text-machine-translation-71c41a3e994e">第2部分</a>中，我们将探索为机器翻译任务加载自定义数据集。在本演练中，我们将了解如何加载自定义影像数据集进行分类。本演练的代码也可以在<a class="ae kc" href="https://github.com/UtkarshGarg-UG/Deep-Learning-Projects/blob/main/Computer-Vision/Loading-Custom-Dataset/loading_custom_dataset_images.ipynb" rel="noopener ugc nofollow" target="_blank"> Github </a>上找到。</p><p id="ac9b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这里，我们将使用可用的地标数据集<a class="ae kc" href="https://udacity-dlnfd.s3-us-west-1.amazonaws.com/datasets/landmark_images.zip" rel="noopener ugc nofollow" target="_blank">。它是谷歌地标数据v2的子集。它有50个班级，包含来自世界各地的各种地标。</a></p><p id="4f2f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本练习中，我们将保持以下文件夹结构:</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div class="gh gi lb"><img src="../Images/81aa8dfa3c07ee418b4ba76136e7a561.png" data-original-src="https://miro.medium.com/v2/resize:fit:580/format:webp/1*suj4Cjtr4nB_EVpIcIFiOw.png"/></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">图一。我们数据的文件夹结构(来源:self)</p></figure><p id="1569" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是一个简单的文件夹结构，根文件夹是Train/Test文件夹，其中包含带有图像的类。正如我们将看到的，我们用什么结构获取数据并不重要。数据可以全部放在一个文件夹中，图像名称中有类名(如“Cat_001.jpg”)，甚至可以放在一个CSV文件中，我们可以在自定义数据集类中处理所有这些数据。</p><p id="055b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们将使用<a class="ae kc" href="https://github.com/albumentations-team/albumentations" rel="noopener ugc nofollow" target="_blank">albuminations</a>库进行图像增强。这个库包含了大量可用的图像增强选项。因此，我们将了解如何在我们的自定义数据集管道中使用它。您可以使用以下方式安装它:</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="be0d" class="ll lm iq lh b gy ln lo l lp lq">pip install -U albumentations</span></pre><figure class="lc ld le lf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lr"><img src="../Images/b72ece7051b415d7e8bf10642d7bd6a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NzzA85-x0_oXtL3m_iR4Hw.png"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">图二。白蛋白中图像增强的例子(来源:<a class="ae kc" href="https://github.com/albumentations-team/albumentations" rel="noopener ugc nofollow" target="_blank">https://github.com/albumentations-team/albumentations</a></p></figure><h1 id="d3b8" class="ls lm iq bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated"><strong class="ak">让我们编码</strong></h1><h2 id="bc4a" class="ll lm iq bd lt mp mq dn lx mr ms dp mb ko mt mu mf ks mv mw mj kw mx my mn mz bi translated">1.导入库</h2><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="na nb l"/></div></figure><h2 id="1350" class="ll lm iq bd lt mp mq dn lx mr ms dp mb ko mt mu mf ks mv mw mj kw mx my mn mz bi translated">2.定义转换</h2><p id="7805" class="pw-post-body-paragraph kd ke iq kf b kg nc ki kj kk nd km kn ko ne kq kr ks nf ku kv kw ng ky kz la ij bi translated">接下来，我们使用白蛋白定义我们的扩增。我们为训练和测试定义了不同的扩充。我们对训练数据应用与裁剪/旋转、颜色/饱和度和亮度相关的变换。我们还用图像净平均值和标准差来归一化训练和测试数据。最后，我们使用ToTensor()将数据转换为PyTorch张量。</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="na nb l"/></div></figure><h2 id="1a93" class="ll lm iq bd lt mp mq dn lx mr ms dp mb ko mt mu mf ks mv mw mj kw mx my mn mz bi translated">3.创建训练集、有效集和测试集</h2><p id="48fd" class="pw-post-body-paragraph kd ke iq kf b kg nc ki kj kk nd km kn ko ne kq kr ks nf ku kv kw ng ky kz la ij bi translated">接下来，我们创建训练集、有效集和测试集。这里，我们为训练集、有效集和测试集创建单独的图像路径列表。这些将在我们的数据集类中使用，该数据集类将为自定义数据集定义。</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="3644" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们得到以下输出:</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="e92e" class="ll lm iq lh b gy ln lo l lp lq">train_image_path example:  images/train/15.Central_Park/462f876f97d424a2.jpg</span><span id="4c1f" class="ll lm iq lh b gy nh lo l lp lq">class example:  42.Death_Valley_National_Park<br/><br/>Train size: 3996<br/>Valid size: 1000<br/>Test size: 1250</span></pre><h2 id="e4a9" class="ll lm iq bd lt mp mq dn lx mr ms dp mb ko mt mu mf ks mv mw mj kw mx my mn mz bi translated">4.创建索引到类和类到索引字典</h2><p id="a29c" class="pw-post-body-paragraph kd ke iq kf b kg nc ki kj kk nd km kn ko ne kq kr ks nf ku kv kw ng ky kz la ij bi translated">我们不能直接为模型使用类名。我们创建类到索引和索引到类的映射。</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="4ff9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们得到idx_to_class的输出如下:</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="0aee" class="ll lm iq lh b gy ln lo l lp lq">{0: '42.Death_Valley_National_Park',<br/> 1: '39.Gateway_of_India',<br/> 2: '13.Yellowstone_National_Park',<br/> 3: '44.Trevi_Fountain',<br/> 4: '32.Hanging_Temple'}</span></pre><h2 id="6160" class="ll lm iq bd lt mp mq dn lx mr ms dp mb ko mt mu mf ks mv mw mj kw mx my mn mz bi translated">5.数据集类</h2><p id="f81f" class="pw-post-body-paragraph kd ke iq kf b kg nc ki kj kk nd km kn ko ne kq kr ks nf ku kv kw ng ky kz la ij bi translated">这是我们自定义数据集的核心。数据集类的结构如下所示:</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/eb7c43735bbdaa00bb30438f5259931f.png" data-original-src="https://miro.medium.com/v2/resize:fit:608/format:webp/1*atYFDNw1OFWjtH5wztDFgg.png"/></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">图3。数据集类的结构</p></figure><p id="b67d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们通过继承Dataset类来创建我们的LandmarkDataset类:</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="1de9" class="ll lm iq lh b gy ln lo l lp lq">from torch.utils.data import Dataset</span></pre><p id="817b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，我们定义__init__函数。一旦我们创建了LandMarkDataset类的实例，默认情况下就会调用这个函数。这个函数应该包含我们想要在整个数据集(如train) <strong class="kf ir">上运行一次</strong>的所有操作。在本系列的下一部分，我们将创建一个定制的机器翻译数据集，这一点的用法将会更加清楚。现在，我们为相应的训练集、有效集和测试集定义image_paths和转换的变量。</p><p id="2bff" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们有__len__函数，它只返回数据集的长度。数据加载器随后使用它来创建批处理。</p><p id="6888" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，我们有__getitem__。这一次处理并返回一个数据点。</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="da8b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从上面可以看出，__getitem__需要一个索引。这是由数据加载器自动处理的，它为<strong class="kf ir">批处理中的每个</strong>图像运行__getitem__。在__getitem__的代码中，我们加载索引“idx”处的图像，从文件路径中提取标签，然后通过我们定义的转换运行它。该函数返回图像数组的张量及其对应的标签。</p><p id="8462" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">创建train_dataset后，我们可以访问如下示例:</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="na nb l"/></div></figure><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="efd7" class="ll lm iq lh b gy ln lo l lp lq">output:<br/>The shape of tensor for 50th image in train dataset:  <br/>torch.Size([3, 256, 256])</span><span id="beec" class="ll lm iq lh b gy nh lo l lp lq">The label for 50th image in train dataset: <br/>37</span></pre><p id="7dbe" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们通过train_dataset可视化一些增强后的图像。</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="na nb l"/></div></figure><figure class="lc ld le lf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nj"><img src="../Images/803d7aa1a2d57945a2f4d808398b80b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T-51HneVXJ1g0xqaZbHp8A.png"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">来源:self</p></figure><p id="d88c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">还有一些，</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nk"><img src="../Images/f1e0684cdcfc666866fa3bd6d24772c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LjMSgGD_ns4nj9m8bM2E_g.png"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">来源:self</p></figure><h2 id="bcd6" class="ll lm iq bd lt mp mq dn lx mr ms dp mb ko mt mu mf ks mv mw mj kw mx my mn mz bi translated">6.创建数据加载器</h2><p id="1060" class="pw-post-body-paragraph kd ke iq kf b kg nc ki kj kk nd km kn ko ne kq kr ks nf ku kv kw ng ky kz la ij bi translated">最后一步。DataLoader类用于为模型批量加载数据。这有助于我们以小批量的方式处理数据，这些数据可以放在我们的GPU RAM中。首先，我们导入数据加载器:</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="2294" class="ll lm iq lh b gy ln lo l lp lq">from torch.utils.data import DataLoader</span></pre><p id="373a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通过发送数据集的对象和批处理大小来启动数据加载器。</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="701a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦我们有了dataloader实例— train_loader，我们就可以使用迭代器来访问数据，如下所示:</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="829d" class="ll lm iq lh b gy ln lo l lp lq">#batch of image tensor<br/>next(iter(train_loader))[0].shape</span><span id="5ef7" class="ll lm iq lh b gy nh lo l lp lq">output:<br/>torch.Size([64, 3, 256, 256])</span><span id="b65b" class="ll lm iq lh b gy nh lo l lp lq">#batch of the corresponding labels<br/>next(iter(train_loader))[1].shape</span><span id="65b4" class="ll lm iq lh b gy nh lo l lp lq">output: <br/>torch.Size([64])</span></pre><p id="cfb1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是我们在训练循环中用来批量处理数据的。每次我们运行迭代器时，dataloader都会选择接下来的64个索引，并逐个运行dataset类中的__getitem__然后将其返回给训练循环。</p><h1 id="c31f" class="ls lm iq bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">结论</h1><p id="deab" class="pw-post-body-paragraph kd ke iq kf b kg nc ki kj kk nd km kn ko ne kq kr ks nf ku kv kw ng ky kz la ij bi translated">在这个由两部分组成的系列的第1部分中，我们看到了如何编写我们自己的定制数据管道。我们还学会了使用白蛋白来增强图像。此外，我们了解了数据集和数据加载器类的内部工作方式。在下一部分中，我们将通过为机器翻译任务创建一个自定义数据集类来提升级别。</p><p id="1e16" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下一集再见！</p><p id="b7f5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第二部分可以在这里找到<a class="ae kc" rel="noopener" target="_blank" href="/custom-datasets-in-pytorch-part-2-text-machine-translation-71c41a3e994e">。</a></p><h1 id="a61e" class="ls lm iq bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">更多来自作者</h1><div class="nl nm gp gr nn no"><a rel="noopener follow" target="_blank" href="/custom-datasets-in-pytorch-part-2-text-machine-translation-71c41a3e994e"><div class="np ab fo"><div class="nq ab nr cl cj ns"><h2 class="bd ir gy z fp nt fr fs nu fu fw ip bi translated">Pytorch中的自定义数据集—第2部分。文本(机器翻译)</h2><div class="nv l"><h3 class="bd b gy z fp nt fr fs nu fu fw dk translated">在本系列的第一部分中，我们学习了加载自定义图像数据集。在那篇文章中，我们也谈到了一些…</h3></div><div class="nw l"><p class="bd b dl z fp nt fr fs nu fu fw dk translated">towardsdatascience.com</p></div></div><div class="nx l"><div class="ny l nz oa ob nx oc jw no"/></div></div></a></div><div class="nl nm gp gr nn no"><a href="https://medium.com/@ug2409/a-non-technical-introduction-to-reinforcement-learning-part-1-62373183b2bc" rel="noopener follow" target="_blank"><div class="np ab fo"><div class="nq ab nr cl cj ns"><h2 class="bd ir gy z fp nt fr fs nu fu fw ip bi translated">强化学习的非技术性介绍(第1部分)</h2><div class="nv l"><h3 class="bd b gy z fp nt fr fs nu fu fw dk translated">没有数学。我保证。好吧，刚刚意识到，有一些。</h3></div><div class="nw l"><p class="bd b dl z fp nt fr fs nu fu fw dk translated">medium.com</p></div></div><div class="nx l"><div class="od l nz oa ob nx oc jw no"/></div></div></a></div><h2 id="28b9" class="ll lm iq bd lt mp mq dn lx mr ms dp mb ko mt mu mf ks mv mw mj kw mx my mn mz bi translated">参考</h2><div class="nl nm gp gr nn no"><a href="https://pytorch.org/tutorials/beginner/basics/data_tutorial.html" rel="noopener  ugc nofollow" target="_blank"><div class="np ab fo"><div class="nq ab nr cl cj ns"><h2 class="bd ir gy z fp nt fr fs nu fu fw ip bi translated">数据集和数据加载器- PyTorch教程1.9.0+cu102文档</h2><div class="nv l"><h3 class="bd b gy z fp nt fr fs nu fu fw dk translated">了解基础知识||快速入门||张量||数据集和数据加载器||转换||构建模型||自动签名||…</h3></div><div class="nw l"><p class="bd b dl z fp nt fr fs nu fu fw dk translated">pytorch.org</p></div></div></div></a></div></div></div>    
</body>
</html>