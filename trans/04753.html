<html>
<head>
<title>Poisson Regression Models for Time Series Data Sets</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">时间序列数据集的泊松回归模型</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/poisson-regression-models-for-time-series-data-sets-54114e68c46d?source=collection_archive---------21-----------------------#2021-04-25">https://towardsdatascience.com/poisson-regression-models-for-time-series-data-sets-54114e68c46d?source=collection_archive---------21-----------------------#2021-04-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/597bd286c856b302f50fe87a07ab6e0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7iECMDIJSGh8PHn62Ve5SA.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">图片由<a class="ae jd" href="https://pixabay.com/users/clker-free-vector-images-3736/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=35081" rel="noopener ugc nofollow" target="_blank"> Clker-Free-Vector-Images </a>来自<a class="ae jd" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=35081" rel="noopener ugc nofollow" target="_blank"> Pixabay </a> ( <a class="ae jd" href="https://pixabay.com/service/license/" rel="noopener ugc nofollow" target="_blank"> Pixabay许可</a>)</p></figure><div class=""/><div class=""><h2 id="6852" class="pw-subtitle-paragraph kd jf jg bd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dk translated">如何使用Python和Statsmodels为计数的时间序列数据集构建泊松回归模型</h2></div><p id="5feb" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><a class="ae jd" rel="noopener" target="_blank" href="/an-illustrated-guide-to-the-poisson-regression-model-50cccba15958">泊松</a>和<a class="ae jd" rel="noopener" target="_blank" href="/generalized-poisson-regression-for-real-world-datasets-d1ff32607d79">类泊松</a>回归模型通常用于基于计数的数据集，即包含整数计数的数据。例如，每小时走进医院急诊室的人数就是这样一组数据。</p><p id="4015" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">基于普通最小二乘回归的线性模型或非线性模型，例如基于基于神经网络的回归技术的模型，对于这样的数据集效果不好，因为它们可以预测负值。</p><p id="0ab8" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果数据集是计数的<strong class="kx jh">时间序列</strong>，由于时间序列数据通常是自相关的，因此会增加建模的复杂性。以前的计数会影响将来计数的值。如果回归模型不能充分捕捉这些相关性中包含的“信息”，则“无法解释的”信息将以自相关误差的形式泄漏到模型的剩余误差中。在这种情况下，模型的<a class="ae jd" rel="noopener" target="_blank" href="/the-complete-guide-to-r-squared-adjusted-r-squared-and-pseudo-r-squared-4136650fc06c"> <strong class="kx jh">拟合优度</strong> </a>会很差。</p><p id="62de" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">解决此问题的常见补救措施如下:</p><ol class=""><li id="2980" class="lr ls jg kx b ky kz lb lc le lt li lu lm lv lq lw lx ly lz bi translated">在拟合回归模型之前，检查时间序列是否有季节性，如果有，<a class="ae jd" rel="noopener" target="_blank" href="/what-is-time-series-decomposition-and-how-does-it-work-9b67e007ae90"> <strong class="kx jh">进行季节性调整</strong> </a>。这样做，解释了季节性自相关，如果有的话。</li><li id="25d7" class="lr ls jg kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated"><strong class="kx jh">对时间序列</strong>进行一次差分，即<em class="mf"> y_t — y_(t-1) </em>对所有的<em class="mf"> t </em>和<a class="ae jd" rel="noopener" target="_blank" href="/the-white-noise-model-1388dbd0a7d"> <strong class="kx jh">对差分后的时间序列进行白噪声测试</strong> </a>。如果差分时间序列可以表示为<a class="ae jd" rel="noopener" target="_blank" href="/the-white-noise-model-1388dbd0a7d">白噪声</a>，那么原始时间序列就是一个<a class="ae jd" rel="noopener" target="_blank" href="/the-white-noise-model-1388dbd0a7d">随机游走</a>。在这种情况下，不需要进一步建模。</li><li id="5ff4" class="lr ls jg kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">对季节性调整的时间序列拟合基于泊松(或相关)计数的回归模型，但<em class="mf">包括因变量</em> <strong class="kx jh"> <em class="mf"> y </em> </strong> <em class="mf">的滞后副本作为回归变量</em>。</li></ol><p id="d67b" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在本文中，我们将解释如何使用<strong class="kx jh">方法(3) </strong>对计数的时间序列拟合泊松或类泊松模型。</p><h1 id="b385" class="mg mh jg bd mi mj mk ml mm mn mo mp mq km mr kn ms kp mt kq mu ks mv kt mw mx bi translated">制造业罢工数据集</h1><p id="6927" class="pw-post-body-paragraph kv kw jg kx b ky my kh la lb mz kk ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">为了说明模型拟合过程，我们将使用以下在回归建模文献中广泛使用的开源数据集:</p><figure class="ne nf ng nh gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nd"><img src="../Images/99b6110b1a9f623b729774b48757d5f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:902/format:webp/1*UAq9UvItuyUVKm2llWDWTg.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">制造业罢工(数据来源:<a class="ae jd" href="https://www.bls.gov/" rel="noopener ugc nofollow" target="_blank">美国BLS </a>通过<a class="ae jd" href="https://github.com/vincentarelbundock/Rdatasets/blob/master/datasets.csv#L609" rel="noopener ugc nofollow" target="_blank"> R数据集</a></p></figure><p id="f968" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">该数据集是一个月度时间序列，显示了从1968年到1976年每月开始的美国制造业活动与美国制造业合同罢工数量之间的关系。</p><figure class="ne nf ng nh gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ni"><img src="../Images/e9849fc4461ddf78fbffe14dd2a18de4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XtJIyBpMIvNJxT9ZUTZgww.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">STRIKES数据集(来源:<a class="ae jd" href="https://github.com/vincentarelbundock/Rdatasets/blob/master/datasets.csv#L609" rel="noopener ugc nofollow" target="_blank"> R数据集</a>)(图片由<a class="ae jd" href="https://sachin-date.medium.com/" rel="noopener">作者</a>提供)</p></figure><p id="e9c6" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">该数据集在R中可用，可以使用<a class="ae jd" href="https://www.statsmodels.org/devel/datasets/index.html" rel="noopener ugc nofollow" target="_blank"> statsmodels数据集包</a>获取。</p><p id="0324" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因变量<strong class="kx jh"> <em class="mf"> y </em> </strong>为<em class="mf">击</em>。</p><p id="64b0" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们将从导入所有必需的包开始:</p><pre class="ne nf ng nh gt nj nk nl nm aw nn bi"><span id="625f" class="no mh jg nk b gy np nq l nr ns"><strong class="nk jh">import </strong>statsmodels.api <strong class="nk jh">as </strong>sm<br/><strong class="nk jh">import </strong>statsmodels.discrete.discrete_model <strong class="nk jh">as </strong>dm<br/><strong class="nk jh">import </strong>numpy <strong class="nk jh">as </strong>np<br/><strong class="nk jh">from </strong>patsy <strong class="nk jh">import </strong>dmatrices<br/><strong class="nk jh">import </strong>statsmodels.graphics.tsaplots <strong class="nk jh">as </strong>tsa<br/><strong class="nk jh">from </strong>matplotlib <strong class="nk jh">import </strong>pyplot <strong class="nk jh">as </strong>plt</span></pre><p id="a0a9" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们使用statsmodels将数据集加载到内存中:</p><pre class="ne nf ng nh gt nj nk nl nm aw nn bi"><span id="df36" class="no mh jg nk b gy np nq l nr ns">strikes_dataset = sm.datasets.<strong class="nk jh">get_rdataset</strong>(dataname=<strong class="nk jh">'StrikeNb'</strong>, package=<strong class="nk jh">'Ecdat'</strong>)</span></pre><p id="9834" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">打印出数据集:</p><pre class="ne nf ng nh gt nj nk nl nm aw nn bi"><span id="3967" class="no mh jg nk b gy np nq l nr ns"><strong class="nk jh">print</strong>(strikes_dataset.<strong class="nk jh">data</strong>)</span></pre><p id="bad4" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们看到以下输出:</p><figure class="ne nf ng nh gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nd"><img src="../Images/75e29ce0b4d6a74bcc163a48b92e1772.png" data-original-src="https://miro.medium.com/v2/resize:fit:902/format:webp/1*NkHEbEXkp2IcsOhMOZePpg.png"/></div></div></figure><p id="5d05" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们将前92个数据点视为训练集，其余16个数据点视为测试数据集</p><pre class="ne nf ng nh gt nj nk nl nm aw nn bi"><span id="9ca1" class="no mh jg nk b gy np nq l nr ns">strikes_data = strikes_dataset.<strong class="nk jh">data</strong>.<strong class="nk jh">copy</strong>()<br/>strikes_data_train = strikes_data.<strong class="nk jh">query</strong>(<strong class="nk jh">'time&lt;=92'</strong>)</span><span id="d3aa" class="no mh jg nk b gy nt nq l nr ns">strikes_data_test = strikes_data.<strong class="nk jh">query</strong>(<strong class="nk jh">'time&gt;92'</strong>).<strong class="nk jh">reset_index</strong>().<strong class="nk jh">drop</strong>(<strong class="nk jh">'index'</strong>, <strong class="nk jh">axis</strong>=1)</span></pre><p id="a489" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">打印出因变量的统计数据:</p><pre class="ne nf ng nh gt nj nk nl nm aw nn bi"><span id="6601" class="no mh jg nk b gy np nq l nr ns"><strong class="nk jh">print</strong>(<strong class="nk jh">'Mean='</strong>+str(np.<strong class="nk jh">mean</strong>(strikes_data_train[<strong class="nk jh">'strikes'</strong>])) + <strong class="nk jh">' Variance='</strong>+str(np.<strong class="nk jh">var</strong>(strikes_data_train[<strong class="nk jh">'strikes'</strong>])))</span></pre><p id="0146" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们得到以下输出:</p><pre class="ne nf ng nh gt nj nk nl nm aw nn bi"><span id="2b1d" class="no mh jg nk b gy np nq l nr ns">Mean=5.5 Variance=14.728260869565217</span></pre><p id="4296" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们看到<strong class="kx jh"> <em class="mf"> y </em> </strong>过度分散，因此违反了泊松模型的<em class="mf">均值=方差</em>假设。为了说明过度分散，我们将拟合一个具有以下NB2方差函数的<a class="ae jd" rel="noopener" target="_blank" href="/negative-binomial-regression-f99031bb25b4"> <strong class="kx jh">负二项式回归模型</strong> </a>:</p><figure class="ne nf ng nh gt is gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/9e495e5fcdb3d20a6a290f07871b5bf4.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/format:webp/0*RzMYY0om4RjEqR-i.png"/></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">NB2模型的方差函数(图片由<a class="ae jd" href="https://sachin-date.medium.com/" rel="noopener">作者</a></p></figure><p id="4875" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这是我们的回归表达式。<em class="mf">打击</em>是因变量<em class="mf">输出</em>是我们的解释变量。假设回归截距存在:</p><pre class="ne nf ng nh gt nj nk nl nm aw nn bi"><span id="756f" class="no mh jg nk b gy np nq l nr ns">expr = <strong class="nk jh">'strikes ~ output'</strong></span></pre><p id="9914" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们将使用<a class="ae jd" href="https://patsy.readthedocs.io/en/latest/quickstart.html" rel="noopener ugc nofollow" target="_blank"> Patsy </a>来雕刻出<strong class="kx jh"> <em class="mf"> X </em> </strong>和<strong class="kx jh"> <em class="mf"> y </em> </strong>矩阵。Patsy会自动为<strong class="kx jh"> <em class="mf"> X </em> </strong>添加一个回归截距列:</p><pre class="ne nf ng nh gt nj nk nl nm aw nn bi"><span id="904e" class="no mh jg nk b gy np nq l nr ns">y_train, X_train = <strong class="nk jh">dmatrices</strong>(expr, strikes_data_train, <strong class="nk jh">return_type</strong>=<strong class="nk jh">'</strong>dataframe<strong class="nk jh">'</strong>)<br/><strong class="nk jh">print</strong>(y_train)<br/><strong class="nk jh">print</strong>(X_train)<br/><br/>y_test, X_test = <strong class="nk jh">dmatrices</strong>(expr, strikes_data_test, <strong class="nk jh">return_type</strong>=<strong class="nk jh">'</strong>dataframe<strong class="nk jh">'</strong>)<br/><strong class="nk jh">print</strong>(y_test)<br/><strong class="nk jh">print</strong>(X_test)</span></pre><p id="2212" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">使用NB2方差函数构建和训练负二项式回归模型:</p><pre class="ne nf ng nh gt nj nk nl nm aw nn bi"><span id="b38e" class="no mh jg nk b gy np nq l nr ns">nb2_model = dm.<strong class="nk jh">NegativeBinomial</strong>(<strong class="nk jh">endog</strong>=y_train, <strong class="nk jh">exog</strong>=X_train, <strong class="nk jh">loglike_method</strong>=<strong class="nk jh">'</strong>nb2<strong class="nk jh">'</strong>)</span><span id="a739" class="no mh jg nk b gy nt nq l nr ns">nb2_model_results = nb2_model.<strong class="nk jh">fit</strong>(<strong class="nk jh">maxiter</strong>=100)</span><span id="c9d8" class="no mh jg nk b gy nt nq l nr ns"><strong class="nk jh">print</strong>(nb2_model_results.<strong class="nk jh">summary</strong>())</span></pre><p id="76eb" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们得到拟合模型摘要的以下输出:</p><figure class="ne nf ng nh gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nv"><img src="../Images/5f5886910ef7db78a2d0c1119bece437.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9IBB8GvwGSJ7U5AegLIlFw.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">NB2模型的模型摘要(图片由<a class="ae jd" href="https://sachin-date.medium.com/" rel="noopener">作者</a>提供)</p></figure><p id="5616" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如系数的p值(0.034和0.000)所示，输出和离差参数α在95%置信水平下具有统计显著性。</p><h2 id="9a47" class="no mh jg bd mi nw nx dn mm ny nz dp mq le oa ob ms li oc od mu lm oe of mw og bi translated">适合度</h2><p id="2839" class="pw-post-body-paragraph kv kw jg kx b ky my kh la lb mz kk ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated"><a class="ae jd" rel="noopener" target="_blank" href="/the-complete-guide-to-r-squared-adjusted-r-squared-and-pseudo-r-squared-4136650fc06c"> <strong class="kx jh">伪R平方</strong> </a>仅为0.9%，表明<strong class="kx jh">对训练数据集的拟合质量</strong>非常差。</p><p id="05e8" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">对数似然比检验的<em class="mf"> p值</em>为<em class="mf"> 0.03589 </em>，表明该模型在<em class="mf"> 95% </em>置信水平下优于仅截距模型(又称零模型)，但在<em class="mf"> 99% </em>或更高置信水平下则不然。</p><p id="b03c" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们看看拟合模型的残差的自相关图:</p><figure class="ne nf ng nh gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi oh"><img src="../Images/6a4cd9df7b72395fc3cb880b544d31a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XmIZF6Fi6hGLgm5NHktq7w.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">NB2模型残差的自相关图(图片由<a class="ae jd" href="https://sachin-date.medium.com/" rel="noopener">作者</a>提供)</p></figure><p id="e35a" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们可以看到，残差在时间滞后1、2和3处是自相关的，这表明因变量<em class="mf">与</em>之间存在自相关，NB2模型无法完全解释这一点，导致其泄漏到模型的残差中。</p><p id="88c1" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">总体来说，这个模型的拟合优度很差。</p><h1 id="cc28" class="mg mh jg bd mi mj mk ml mm mn mo mp mq km mr kn ms kp mt kq mu ks mv kt mw mx bi translated">建立自回归泊松模型</h1><p id="b1fe" class="pw-post-body-paragraph kv kw jg kx b ky my kh la lb mz kk ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">为了修正自相关残差的情况，我们将引入<strong class="kx jh"><em class="mf">【y】</em></strong>的滞后副本，特别是<em class="mf"> y_(t-1)、y_(t-2) </em>和<em class="mf"> y_(t-3) </em>作为回归变量以及<em class="mf">输出</em>变量。</p><p id="293f" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">但是我们没有直接引入<em class="mf"> y_(t-k) </em>作为回归变量，而是使用<em class="mf">ln[y _(t-k)】</em>来解决当<em class="mf"> y_(t-k) </em>的系数为正时的“模型爆炸”问题。</p><p id="644d" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">但是使用<em class="mf"> ln() </em>变换产生了如何处理对数未定义的<em class="mf"> y_t </em>的零值的问题。</p><p id="c155" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们使用Cameron和Trivedi在他们的书<em class="mf">计数数据的回归分析</em> <em class="mf">(参见第7.5节:自回归模型)</em>中概述的以下技巧来解决这个问题:</p><p id="2d04" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们将为每个感兴趣的时间延迟定义一个新的指标变量<em class="mf"> d_t </em>,如下所示:</p><p id="640a" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当<em class="mf"> y_t = 0: </em>设置<em class="mf"> d_t=1。</em></p><p id="f8e3" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当<em class="mf"> y_t &gt; 0: </em>设置<em class="mf"> d_t=0 </em>时。</p><p id="ee6d" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们对数据框进行这些更改。</p><p id="548c" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">定义一个函数，该函数将设置指示器变量<em class="mf"> d_t </em>的值，如上文所定义:</p><pre class="ne nf ng nh gt nj nk nl nm aw nn bi"><span id="e0f2" class="no mh jg nk b gy np nq l nr ns"><strong class="nk jh">def </strong>indicator_func(x):<br/>    <strong class="nk jh">if </strong>x == 0:<br/>        <strong class="nk jh">return </strong>1<br/>    <strong class="nk jh">else</strong>:<br/>        <strong class="nk jh">return </strong>0</span></pre><p id="496b" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">并使用此函数创建一个新的指标变量列:</p><pre class="ne nf ng nh gt nj nk nl nm aw nn bi"><span id="adf6" class="no mh jg nk b gy np nq l nr ns">strikes_data[<strong class="nk jh">'d'</strong>] = strikes_data[<strong class="nk jh">'strikes'</strong>].<strong class="nk jh">apply</strong>(indicator_func)</span></pre><p id="dccd" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们还创建一个新列<em class="mf"> strikes_adj </em>，如果<em class="mf"> strikes </em>为0，则该列设置为1，否则将其设置为<em class="mf"> strikes </em>的值:</p><pre class="ne nf ng nh gt nj nk nl nm aw nn bi"><span id="cb08" class="no mh jg nk b gy np nq l nr ns">strikes_data[<strong class="nk jh">'strikes_adj'</strong>] = np.<strong class="nk jh">maximum</strong>(1, strikes_data[<strong class="nk jh">'strikes'</strong>])</span></pre><p id="cbfb" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在为<em class="mf"> strikes_adj </em>和<em class="mf">d</em>T46】:创建滞后变量</p><pre class="ne nf ng nh gt nj nk nl nm aw nn bi"><span id="40f8" class="no mh jg nk b gy np nq l nr ns">strikes_data[<strong class="nk jh">'ln_strikes_adj_lag1'</strong>] = strikes_data[<strong class="nk jh">'strikes_adj'</strong>].shift(1)<br/>strikes_data[<strong class="nk jh">'ln_strikes_adj_lag2'</strong>] = strikes_data[<strong class="nk jh">'strikes_adj'</strong>].shift(2)<br/>strikes_data[<strong class="nk jh">'ln_strikes_adj_lag3'</strong>] = strikes_data[<strong class="nk jh">'strikes_adj'</strong>].shift(3)<br/><br/>strikes_data[<strong class="nk jh">'d_lag1'</strong>] = strikes_data[<strong class="nk jh">'d'</strong>].shift(1)<br/>strikes_data[<strong class="nk jh">'d_lag2'</strong>] = strikes_data[<strong class="nk jh">'d'</strong>].shift(2)<br/>strikes_data[<strong class="nk jh">'d_lag3'</strong>] = strikes_data[<strong class="nk jh">'d'</strong>].shift(3)</span></pre><p id="a209" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">删除所有包含空单元格的行:</p><pre class="ne nf ng nh gt nj nk nl nm aw nn bi"><span id="c3a5" class="no mh jg nk b gy np nq l nr ns">strikes_data = strikes_data.<strong class="nk jh">dropna</strong>()</span></pre><p id="5f2b" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">最后取<em class="mf"> ln_strikes_adj_lag1 </em>、<em class="mf"> ln_strikes_adj_lag2 </em>和<em class="mf"> ln_strikes_adj_lag3 </em>的自然对数。回想一下我们要添加<em class="mf"> ln(y_(t_1)) </em>、<em class="mf"> ln(y_(t_2)) </em>和ln( <em class="mf"> y_(t_3)) </em>作为回归变量<em class="mf"> : </em></p><pre class="ne nf ng nh gt nj nk nl nm aw nn bi"><span id="4e9f" class="no mh jg nk b gy np nq l nr ns">strikes_data[<strong class="nk jh">'</strong>ln_strikes_adj_lag1<strong class="nk jh">'</strong>] = np.<strong class="nk jh">log</strong>(strikes_data[<strong class="nk jh">'</strong>ln_strikes_adj_lag1<strong class="nk jh">'</strong>])<br/>strikes_data[<strong class="nk jh">'</strong>ln_strikes_adj_lag2<strong class="nk jh">'</strong>] = np.<strong class="nk jh">log</strong>(strikes_data[<strong class="nk jh">'</strong>ln_strikes_adj_lag2<strong class="nk jh">'</strong>])<br/>strikes_data[<strong class="nk jh">'</strong>ln_strikes_adj_lag3<strong class="nk jh">'</strong>] = np.<strong class="nk jh">log</strong>(strikes_data[<strong class="nk jh">'</strong>ln_strikes_adj_lag3<strong class="nk jh">'</strong>])</span></pre><p id="6ebe" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们看看我们的数据框现在是什么样子:</p><pre class="ne nf ng nh gt nj nk nl nm aw nn bi"><span id="9adb" class="no mh jg nk b gy np nq l nr ns"><strong class="nk jh">print</strong>(strikes_data)</span></pre><figure class="ne nf ng nh gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi oi"><img src="../Images/8393ba923573ca6952ed5ea16302924c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MufaC6MlnbN6_IBQU4LLYg.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">添加了滞后变量的strikes数据框</p></figure><p id="9d48" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们再次将数据框架分为训练数据集和测试数据集:</p><pre class="ne nf ng nh gt nj nk nl nm aw nn bi"><span id="2942" class="no mh jg nk b gy np nq l nr ns">strikes_data_train=strikes_data.<strong class="nk jh">query</strong>(<strong class="nk jh">'time&lt;=92'</strong>)</span><span id="de5e" class="no mh jg nk b gy nt nq l nr ns">strikes_data_test=strikes_data.<strong class="nk jh">query</strong>(<strong class="nk jh">'time&gt;92'</strong>).<strong class="nk jh">reset_index</strong>().<strong class="nk jh">drop</strong>(<strong class="nk jh">'index'</strong>, <strong class="nk jh">axis</strong>=1)</span></pre><p id="c442" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们的回归表达式也需要更新，以包括滞后变量:</p><pre class="ne nf ng nh gt nj nk nl nm aw nn bi"><span id="cf86" class="no mh jg nk b gy np nq l nr ns">expr = <strong class="nk jh">'strikes ~ output + ln_strikes_adj_lag1 + ln_strikes_adj_lag2 + ln_strikes_adj_lag3 + d_lag1 + d_lag2 + d_lag3'</strong></span></pre><p id="64dd" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">使用Patsy雕刻出y<strong class="kx jh"><em class="mf"/></strong><em class="mf"/>和X<strong class="kx jh"><em class="mf"/></strong><em class="mf"/>矩阵:</p><pre class="ne nf ng nh gt nj nk nl nm aw nn bi"><span id="8156" class="no mh jg nk b gy np nq l nr ns">y_train, X_train = <strong class="nk jh">dmatrices</strong>(expr, strikes_data_train, <strong class="nk jh">return_type</strong>='dataframe')</span><span id="f1be" class="no mh jg nk b gy nt nq l nr ns"><strong class="nk jh">print</strong>(y_train)</span><span id="aae4" class="no mh jg nk b gy nt nq l nr ns"><strong class="nk jh">print</strong>(X_train)</span></pre><p id="9524" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">最后，我们将在<em class="mf">(</em><strong class="kx jh"><em class="mf">y _ train</em></strong><em class="mf">，</em><strong class="kx jh"><em class="mf">X _ train</em></strong><em class="mf">)</em>上构建并拟合回归模型。这一次，我们将使用简单的泊松回归模型:</p><pre class="ne nf ng nh gt nj nk nl nm aw nn bi"><span id="f3dd" class="no mh jg nk b gy np nq l nr ns">poisson_model = dm.<strong class="nk jh">Poisson</strong>(<strong class="nk jh">endog</strong>=y_train, <strong class="nk jh">exog</strong>=X_train)</span><span id="df5d" class="no mh jg nk b gy nt nq l nr ns">poisson_model_results = poisson_model.<strong class="nk jh">fit</strong>(<strong class="nk jh">maxiter</strong>=100)</span><span id="2e13" class="no mh jg nk b gy nt nq l nr ns"><strong class="nk jh">print</strong>(poisson_model_results.<strong class="nk jh">summary</strong>())</span></pre><p id="e021" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们看到以下结果:</p><figure class="ne nf ng nh gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi oj"><img src="../Images/2b8e188d26190a77a554b079c1a0fa0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HVu939tF0M9aPAIg7NxlyQ.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">具有滞后输出变量的泊松回归模型的训练综述</p></figure><h2 id="f9b3" class="no mh jg bd mi nw nx dn mm ny nz dp mq le oa ob ms li oc od mu lm oe of mw og bi translated">适合度</h2><p id="2b87" class="pw-post-body-paragraph kv kw jg kx b ky my kh la lb mz kk ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">首先要注意的是，由<a class="ae jd" rel="noopener" target="_blank" href="/the-complete-guide-to-r-squared-adjusted-r-squared-and-pseudo-r-squared-4136650fc06c">伪R平方</a>测量的拟合优度比早期的NB2模型有所提高，从<em class="mf"> 0.9% </em>提高到<em class="mf"> 15.69% </em>。这是一个很大的进步。这一次，LLR测试的<em class="mf"> p值</em>也在<em class="mf"> 1.295e-15 </em>处小得几乎为零。这意味着我们可以以接近100%的信心说滞后变量泊松模型比仅截距模型更好。回想一下，之前我们可以说只有95%的置信水平。</p><p id="6b34" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们看看这个滞后变量泊松模型的残差的自相关图:</p><pre class="ne nf ng nh gt nj nk nl nm aw nn bi"><span id="f70e" class="no mh jg nk b gy np nq l nr ns">tsa.<strong class="nk jh">plot_acf</strong>(poisson_model_results.<strong class="nk jh">resid</strong>, <strong class="nk jh">alpha</strong>=0.05)</span><span id="d9f6" class="no mh jg nk b gy nt nq l nr ns">plt.<strong class="nk jh">show</strong>()</span></pre><p id="fb3c" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们看到下面的情节:</p><figure class="ne nf ng nh gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ok"><img src="../Images/c718209bcd798c075308383f06051ee2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GfhefG-IMCdr1Ir4qGEgIA.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">滞后变量泊松模型残差的自相关图(图片由<a class="ae jd" href="https://sachin-date.medium.com/" rel="noopener">作者</a>提供)</p></figure><p id="ae61" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">除了在滞后13处有非常轻微的显著相关性外，残差与所有其他滞后的相关性都在规定的alpha范围内。</p><p id="6a24" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们将<em class="mf">走向</em>的滞后副本添加到泊松模型的回归变量的策略似乎已经解释了<em class="mf">走向</em>变量中的大部分自相关。</p><h2 id="40d2" class="no mh jg bd mi nw nx dn mm ny nz dp mq le oa ob ms li oc od mu lm oe of mw og bi translated">可变重要性</h2><p id="53c5" class="pw-post-body-paragraph kv kw jg kx b ky my kh la lb mz kk ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">最后，让我们从滞后变量泊松模型的训练总结中注意到，虽然<em class="mf">输出</em>、<em class="mf"> ln_strikes_adj_lag1 </em>和<em class="mf"> ln_strikes_adj_lag2 </em>的系数在<em class="mf"> 95% c </em>置信水平下是显著的，但是第三个滞后<em class="mf"> ln_strikes_adj_lag3 </em>的系数仅在其表示的<em class="mf"> 75% </em>置信水平附近是显著的此外，所有三个滞后指标变量<em class="mf"> d_lag1 </em>、<em class="mf"> d_lag2 </em>和<em class="mf"> d_lag3 </em>在<em class="mf"> 95% </em>置信水平下均不具有统计显著性。</p><h1 id="177a" class="mg mh jg bd mi mj mk ml mm mn mo mp mq km mr kn ms kp mt kq mu ks mv kt mw mx bi translated">预言；预测；预告</h1><p id="0a98" class="pw-post-body-paragraph kv kw jg kx b ky my kh la lb mz kk ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">让我们使用拟合的滞后变量泊松模型来预测我们之前搁置的测试数据集的命中次数。我们不应该对预测的质量期望过高。请记住，虽然这个模型比以前的NB2模型拟合得更好，但伪R平方仍然只有16%。</p><p id="7926" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们将使用Patsy来雕刻出(<strong class="kx jh"> <em class="mf"> y_test </em> </strong>，<strong class="kx jh"> <em class="mf"> X_test </em> </strong>):</p><pre class="ne nf ng nh gt nj nk nl nm aw nn bi"><span id="7a56" class="no mh jg nk b gy np nq l nr ns">y_test, X_test = <strong class="nk jh">dmatrices</strong>(expr, strikes_data_test, <strong class="nk jh">return_type</strong>='dataframe')</span><span id="7128" class="no mh jg nk b gy nt nq l nr ns"><strong class="nk jh">print</strong>(y_test)</span><span id="809c" class="no mh jg nk b gy nt nq l nr ns"><strong class="nk jh">print</strong>(X_test)</span></pre><p id="5280" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在<strong class="kx jh"> <em class="mf"> X_test </em> </strong>上进行预测:</p><pre class="ne nf ng nh gt nj nk nl nm aw nn bi"><span id="aa52" class="no mh jg nk b gy np nq l nr ns">poisson_predictions = poisson_model_results.<strong class="nk jh">predict</strong>(X_test)</span></pre><p id="d7d4" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">绘制预测值和实际值:</p><pre class="ne nf ng nh gt nj nk nl nm aw nn bi"><span id="cc2c" class="no mh jg nk b gy np nq l nr ns">predicted_counts=poisson_predictions</span><span id="1bc6" class="no mh jg nk b gy nt nq l nr ns">actual_counts = y_test[<strong class="nk jh">'strikes'</strong>]</span><span id="47a5" class="no mh jg nk b gy nt nq l nr ns">fig = plt.<strong class="nk jh">figure</strong>()</span><span id="cf15" class="no mh jg nk b gy nt nq l nr ns">fig.<strong class="nk jh">suptitle</strong>(<strong class="nk jh">'Predicted versus actual strike counts'</strong>)</span><span id="1339" class="no mh jg nk b gy nt nq l nr ns">predicted, = plt.<strong class="nk jh">plot</strong>(X_test.<strong class="nk jh">index</strong>, predicted_counts, <strong class="nk jh">'go-'</strong>, <strong class="nk jh">label</strong>=<strong class="nk jh">'Predicted counts'</strong>)</span><span id="ec17" class="no mh jg nk b gy nt nq l nr ns">actual, = plt.<strong class="nk jh">plot</strong>(X_test.<strong class="nk jh">index</strong>, actual_counts, <strong class="nk jh">'ro-'</strong>, <strong class="nk jh">label</strong>=<strong class="nk jh">'Actual counts'</strong>)</span><span id="a4f5" class="no mh jg nk b gy nt nq l nr ns">plt.<strong class="nk jh">legend</strong>(<strong class="nk jh">handles</strong>=[predicted, actual])</span><span id="773e" class="no mh jg nk b gy nt nq l nr ns">plt.<strong class="nk jh">show</strong>()</span></pre><p id="77ea" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们得到如下的情节:</p><figure class="ne nf ng nh gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ol"><img src="../Images/5b6720b1152a632aab088060ebc97b5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oqFeQMt9Qz8MRbmwmgnZTg.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">使用滞后变量泊松模型预测的与实际的撞击数(图片由<a class="ae jd" href="https://sachin-date.medium.com/" rel="noopener">作者</a>提供)</p></figure></div><div class="ab cl om on hu oo" role="separator"><span class="op bw bk oq or os"/><span class="op bw bk oq or os"/><span class="op bw bk oq or"/></div><div class="ij ik il im in"><h1 id="6ab5" class="mg mh jg bd mi mj ot ml mm mn ou mp mq km ov kn ms kp ow kq mu ks ox kt mw mx bi translated">后续步骤</h1><p id="38ff" class="pw-post-body-paragraph kv kw jg kx b ky my kh la lb mz kk ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">我们可以尝试通过以下修改来提高滞后变量模型的拟合优度:</p><ul class=""><li id="0326" class="lr ls jg kx b ky kz lb lc le lt li lu lm lv lq oy lx ly lz bi translated">除了<em class="mf">输出</em>之外，还包括<em class="mf">输出</em>变量的前三个时滞作为回归变量。</li><li id="4c3d" class="lr ls jg kx b ky ma lb mb le mc li md lm me lq oy lx ly lz bi translated">包括<em class="mf">输出</em>变量和<em class="mf">撞击</em>变量的时滞值作为回归变量。</li><li id="f4ba" class="lr ls jg kx b ky ma lb mb le mc li md lm me lq oy lx ly lz bi translated">不要使用泊松模型，使用负二项式模型(使用NB1或NB2方差函数),并将上述种类的滞后变量作为回归变量。</li></ul><p id="83d7" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">此外，使用statsmodels提供的<a class="ae jd" href="https://www.statsmodels.org/stable/glm.html" rel="noopener ugc nofollow" target="_blank">广义线性模型</a>框架来构建和训练泊松或负二项式模型也很有趣。参见下面关于如何建立和训练GLM模型的链接。</p></div><div class="ab cl om on hu oo" role="separator"><span class="op bw bk oq or os"/><span class="op bw bk oq or os"/><span class="op bw bk oq or"/></div><div class="ij ik il im in"><h1 id="be25" class="mg mh jg bd mi mj ot ml mm mn ou mp mq km ov kn ms kp ow kq mu ks ox kt mw mx bi translated">引用和版权</h1><h2 id="3962" class="no mh jg bd mi nw nx dn mm ny nz dp mq le oa ob ms li oc od mu lm oe of mw og bi translated">书</h2><p id="2eff" class="pw-post-body-paragraph kv kw jg kx b ky my kh la lb mz kk ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">Cameron A. Colin，Trivedi Pravin K .，<a class="ae jd" href="http://cameron.econ.ucdavis.edu/racd/count.html" rel="noopener ugc nofollow" target="_blank"> <em class="mf">计数数据的回归分析</em> </a>，计量经济学会专论№30，剑桥大学出版社，1998年。国际标准书号:0521635675</p><p id="1076" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">McCullagh P .，Nelder John A .，<a class="ae jd" href="https://www.routledge.com/Generalized-Linear-Models/McCullagh-Nelder/p/book/9780412317606" rel="noopener ugc nofollow" target="_blank"> <em class="mf">广义线性模型</em> </a>，第二版。，CRC出版社，1989，ISBN 0412317605，9780412317606</p><h2 id="7214" class="no mh jg bd mi nw nx dn mm ny nz dp mq le oa ob ms li oc od mu lm oe of mw og bi translated">报纸</h2><p id="47df" class="pw-post-body-paragraph kv kw jg kx b ky my kh la lb mz kk ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">凯南j .，<a class="ae jd" href="https://www.sciencedirect.com/science/article/pii/0304407685900648" rel="noopener ugc nofollow" target="_blank"> <em class="mf">美国制造业的合同罢工持续时间，计量经济学杂志</em> </a>，第28卷，1985年第1期，第5-28页，ISSN 0304-4076，<a class="ae jd" href="https://doi.org/10.1016/0304-4076(85)90064-8." rel="noopener ugc nofollow" target="_blank">https://doi . org/10.1016/0304-4076(85)90064-8。</a> <a class="ae jd" href="https://www.ssc.wisc.edu/~jkennan/research/JEM85.pdf" rel="noopener ugc nofollow" target="_blank"> <strong class="kx jh"> PDF下载链接</strong> </a></p><p id="8ac3" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">Cameron C. A .，Trivedi P. K .，<a class="ae jd" href="https://www.sciencedirect.com/science/article/pii/030440769090014K" rel="noopener ugc nofollow" target="_blank"> <em class="mf">泊松模型</em> </a>中过度分散的回归测试，《计量经济学杂志》，第46卷，第3期，1990年，第347-364页，ISSN 0304-4076，<a class="ae jd" href="https://doi.org/10.1016/0304-4076(90)90014-K." rel="noopener ugc nofollow" target="_blank">https://doi . org/10.1016/0304-4076(90)90014-k .</a></p><h2 id="be05" class="no mh jg bd mi nw nx dn mm ny nz dp mq le oa ob ms li oc od mu lm oe of mw og bi translated">数据集</h2><p id="a1b5" class="pw-post-body-paragraph kv kw jg kx b ky my kh la lb mz kk ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">文章中使用的制造业罢工数据集是统计软件中可供公众使用和实验的几个数据集之一，最值得注意的是，这里的<a class="ae jd" href="https://rdrr.io/rforge/Ecdat/man/StrikeNb.html" rel="noopener ugc nofollow" target="_blank">是R包</a>。在GPL v3许可下，<a class="ae jd" href="https://github.com/vincentarelbundock" rel="noopener ugc nofollow" target="_blank">文森特·阿雷-本多克</a>通过<a class="ae jd" href="https://vincentarelbundock.github.io/Rdatasets" rel="noopener ugc nofollow" target="_blank">vincentarelbundock.github.io/rdatasets</a>已经可以使用Python访问数据集。</p><h2 id="775d" class="no mh jg bd mi nw nx dn mm ny nz dp mq le oa ob ms li oc od mu lm oe of mw og bi translated">形象</h2><p id="5027" class="pw-post-body-paragraph kv kw jg kx b ky my kh la lb mz kk ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">本文中的所有图片版权归<a class="ae jd" href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener ugc nofollow" target="_blank"> CC-BY-NC-SA </a>所有，除非图片下方提到了不同的来源和版权。</p></div><div class="ab cl om on hu oo" role="separator"><span class="op bw bk oq or os"/><span class="op bw bk oq or os"/><span class="op bw bk oq or"/></div><div class="ij ik il im in"><h1 id="14ac" class="mg mh jg bd mi mj ot ml mm mn ou mp mq km ov kn ms kp ow kq mu ks ox kt mw mx bi translated">相关文章</h1><div class="ip iq gp gr ir oz"><a rel="noopener follow" target="_blank" href="/the-complete-guide-to-r-squared-adjusted-r-squared-and-pseudo-r-squared-4136650fc06c"><div class="pa ab fo"><div class="pb ab pc cl cj pd"><h2 class="bd jh gy z fp pe fr fs pf fu fw jf bi translated">R平方、调整R平方和伪R平方完全指南</h2><div class="pg l"><h3 class="bd b gy z fp pe fr fs pf fu fw dk translated">了解如何使用这些方法来评估线性和某些非线性回归模型的拟合优度</h3></div><div class="ph l"><p class="bd b dl z fp pe fr fs pf fu fw dk translated">towardsdatascience.com</p></div></div><div class="pi l"><div class="pj l pk pl pm pi pn ix oz"/></div></div></a></div><div class="ip iq gp gr ir oz"><a rel="noopener follow" target="_blank" href="/an-illustrated-guide-to-the-poisson-regression-model-50cccba15958"><div class="pa ab fo"><div class="pb ab pc cl cj pd"><h2 class="bd jh gy z fp pe fr fs pf fu fw jf bi translated">泊松回归模型图解指南</h2><div class="pg l"><h3 class="bd b gy z fp pe fr fs pf fu fw dk translated">和使用Python的泊松回归教程</h3></div><div class="ph l"><p class="bd b dl z fp pe fr fs pf fu fw dk translated">towardsdatascience.com</p></div></div><div class="pi l"><div class="po l pk pl pm pi pn ix oz"/></div></div></a></div><div class="ip iq gp gr ir oz"><a rel="noopener follow" target="_blank" href="/negative-binomial-regression-f99031bb25b4"><div class="pa ab fo"><div class="pb ab pc cl cj pd"><h2 class="bd jh gy z fp pe fr fs pf fu fw jf bi translated">负二项式回归:逐步指南</h2><div class="pg l"><h3 class="bd b gy z fp pe fr fs pf fu fw dk translated">外加一个关于负二项式回归的Python教程</h3></div><div class="ph l"><p class="bd b dl z fp pe fr fs pf fu fw dk translated">towardsdatascience.com</p></div></div><div class="pi l"><div class="pp l pk pl pm pi pn ix oz"/></div></div></a></div><div class="ip iq gp gr ir oz"><a rel="noopener follow" target="_blank" href="/generalized-poisson-regression-for-real-world-datasets-d1ff32607d79"><div class="pa ab fo"><div class="pb ab pc cl cj pd"><h2 class="bd jh gy z fp pe fr fs pf fu fw jf bi translated">真实世界数据集的广义泊松回归</h2><div class="pg l"><h3 class="bd b gy z fp pe fr fs pf fu fw dk translated">以及用Python进行广义泊松回归的分步指南</h3></div><div class="ph l"><p class="bd b dl z fp pe fr fs pf fu fw dk translated">towardsdatascience.com</p></div></div><div class="pi l"><div class="pq l pk pl pm pi pn ix oz"/></div></div></a></div></div><div class="ab cl om on hu oo" role="separator"><span class="op bw bk oq or os"/><span class="op bw bk oq or os"/><span class="op bw bk oq or"/></div><div class="ij ik il im in"><p id="c621" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="mf">感谢阅读！如果您喜欢这篇文章，请</em> <a class="ae jd" href="https://timeseriesreasoning.medium.com" rel="noopener"> <strong class="kx jh"> <em class="mf">关注我</em> </strong> </a> <em class="mf">获取关于回归和时间序列分析的提示、操作方法和编程建议。</em></p></div></div>    
</body>
</html>