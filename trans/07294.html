<html>
<head>
<title>Building a VAE Playground with Streamlit</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Streamlit建造VAE游乐场</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/building-a-vae-playground-with-streamlit-aa88a3394c04?source=collection_archive---------22-----------------------#2021-07-02">https://towardsdatascience.com/building-a-vae-playground-with-streamlit-aa88a3394c04?source=collection_archive---------22-----------------------#2021-07-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6cbe" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">借助Streamlit，创建和部署web应用程序变得非常简单！</h2></div><p id="0ac2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这篇博客文章是一个迷你系列的一部分，该系列讨论了使用可变自动编码器构建PyTorch深度学习项目的不同方面。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi le"><img src="../Images/8398e12eafde8e28bb62aacb3a87577e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VG-wIk8kr17qsn_Me2mkQg.png"/></div></div><p class="lq lr gj gh gi ls lt bd b be z dk translated">MNIST数据集上的Streamlit应用</p></figure><blockquote class="lu lv lw"><p id="e525" class="ki kj lx kk b kl km ju kn ko kp jx kq ly ks kt ku lz kw kx ky ma la lb lc ld im bi translated"><a class="ae mb" rel="noopener" target="_blank" href="/beginner-guide-to-variational-autoencoders-vae-with-pytorch-lightning-13dbc559ba4b"> <em class="it">第一部分</em> </a> <em class="it">:数学基础与实现<br/> </em> <a class="ae mb" rel="noopener" target="_blank" href="/beginner-guide-to-variational-autoencoders-vae-with-pytorch-lightning-part-2-6b79ad697c79"> <em class="it">第二部分</em> </a> <em class="it">:用py torch Lightning<br/></em><a class="ae mb" rel="noopener" target="_blank" href="/beginner-guide-to-variational-autoencoders-vae-with-pytorch-lightning-part-3-9d686d0d85d9#1921-b4c73b02c87"><em class="it">增压第三部分</em> </a> <em class="it">:卷积VAE、继承与单元测试<br/> </em> <a class="ae mb" rel="noopener" target="_blank" href="/building-a-vae-playground-with-streamlit-aa88a3394c04"> <em class="it">第四部分</em> </a> <em class="it">:部署</em></p></blockquote><p id="6042" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在前面的章节中，我们学习了如何使用PyTorch Lightning训练两种不同类型的变分自动编码器。第一种是使用线性层的普通VAE，而第二种是使用卷积层进行特征提取和数据生成的卷积VAE。</p><p id="3a0b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这一节中，我们将看看如何使用Docker和Streamlit来创建这个web应用程序，在这里我们可以直接与模型进行交互。通过与模型交互并获得即时预测，我们有望更好地了解如何调整VAEs。</p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h2 id="c13e" class="mj mk it bd ml mm mn dn mo mp mq dp mr kr ms mt mu kv mv mw mx kz my mz na nb bi translated"><strong class="ak">流线型</strong></h2><div class="nc nd gp gr ne nf"><a href="https://streamlit.io/" rel="noopener  ugc nofollow" target="_blank"><div class="ng ab fo"><div class="nh ab ni cl cj nj"><h2 class="bd iu gy z fp nk fr fs nl fu fw is bi translated">Streamlit *构建和共享数据应用的最快方式</h2><div class="nm l"><h3 class="bd b gy z fp nk fr fs nl fu fw dk translated">用我们神奇简单的API，用几行代码构建一个应用程序。然后看到它随着你的迭代自动更新…</h3></div><div class="nn l"><p class="bd b dl z fp nk fr fs nl fu fw dk translated">streamlit.io</p></div></div><div class="no l"><div class="np l nq nr ns no nt lo nf"/></div></div></a></div><p id="8b19" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Streamlit是任何数据科学应用程序的绝佳工具。有了它，你可以使用纯Python创建漂亮的网络应用，而不需要任何HTML、CSS或JavaScript。Streamlit最棒的地方在于它的代码非常直观和pythonic化。Streamlit可以帮助创建令人印象深刻的演示，并且是帮助您的项目实现的一个很好的工具！</p><h2 id="4098" class="mj mk it bd ml mm mn dn mo mp mq dp mr kr ms mt mu kv mv mw mx kz my mz na nb bi translated"><strong class="ak">设计应用</strong></h2><p id="d30b" class="pw-post-body-paragraph ki kj it kk b kl nu ju kn ko nv jx kq kr nw kt ku kv nx kx ky kz ny lb lc ld im bi translated">这个应用程序将非常简单，有两个功能<strong class="kk iu">重建</strong>和<strong class="kk iu">插值</strong>。</p><p id="8cc4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于重建，我们只需通过VAE传递一个图像，然后查看输出。由此，我们可以从图像重建的质量来评估VAE。</p><p id="6fdf" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">插值更有趣一点。通过执行插值，我们可以探索VAE的潜在空间。首先，我们从数据集中提取两幅图像并进行编码。对于VAE，这意味着获取μ和log(σ)向量，并从分布中抽取样本。这个样本给了我们数据的潜在概率分布中的一个点。我们对第二幅图像做同样的处理，得到另一个点。</p><p id="5fc0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里，我们在潜在概率分布中取等间距的点，并在这些点上运行解码器。这允许我们观察潜在的概率分布，并想象这些点是如何被绘制的。理想情况下，我们希望两个数据点之间平滑过渡。</p><p id="44d3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以在VAE类中用函数的形式来写这个</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="nz oa l"/></div><p class="lq lr gj gh gi ls lt bd b be z dk translated">VAE类的插值函数</p></figure><p id="f193" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe ob oc od oe b">Conv_VAE</code>类也将继承这个函数，我们不必再重写它</p><h2 id="4784" class="mj mk it bd ml mm mn dn mo mp mq dp mr kr ms mt mu kv mv mw mx kz my mz na nb bi translated"><strong class="ak"> Streamlit可绘制画布</strong></h2><p id="bf08" class="pw-post-body-paragraph ki kj it kk b kl nu ju kn ko nv jx kq kr nw kt ku kv nx kx ky kz ny lb lc ld im bi translated">现在让用户与模型互动。让我们创建一个应用程序，用户可以直接在应用程序上绘图来创建一个全新的数据点，而不是上传图像或从MNIST数据集中选择图像！</p><p id="61ef" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">幸运的是，包<code class="fe ob oc od oe b">streamlit-drawable-canvas</code>已经为我们做了！我们可以使用它来创建一个区域，用户可以使用鼠标来创建一个绘图，我们可以使用它作为模型的输入</p><div class="nc nd gp gr ne nf"><a href="https://github.com/andfanilo/streamlit-drawable-canvas" rel="noopener  ugc nofollow" target="_blank"><div class="ng ab fo"><div class="nh ab ni cl cj nj"><h2 class="bd iu gy z fp nk fr fs nl fu fw is bi translated">和平面/流线型可画画布</h2><div class="nm l"><h3 class="bd b gy z fp nk fr fs nl fu fw dk translated">Streamlit组件提供了一个使用Fabric.js的素描画布。自由绘制，线条，圆形，方框和多边形…</h3></div><div class="nn l"><p class="bd b dl z fp nk fr fs nl fu fw dk translated">github.com</p></div></div><div class="no l"><div class="of l nq nr ns no nt lo nf"/></div></div></a></div><p id="3973" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有了这个包，我们可以在任何我们想要的地方创建一个可绘制的画布。所有我们需要做的是设置一些参数，如高度，重量，填充颜色等。我们我们完了。我们可以在应用程序中使用这个组件，然后将用户的绘图保存为numpy数组。</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="nz oa l"/></div><p class="lq lr gj gh gi ls lt bd b be z dk translated">实例化Streamlit可绘制画布</p></figure><p id="9740" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">除此之外，我们还需要一些预处理功能。需要注意的一点是，MNIST数据集图像只有28 x 28，这对我们来说太小了，无法绘制。下面是我们的预处理函数要做的事情</p><p id="8ad9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">1.移除Alpha(透明)通道<br/> 2。转换为黑白<br/> 3。缩放至[-1，1] <br/> 4。将其转换为具有正确形状的张量<br/> 5。调整张量的大小</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="nz oa l"/></div><p class="lq lr gj gh gi ls lt bd b be z dk translated">预处理功能</p></figure><p id="86c1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以将所有这些放入<code class="fe ob oc od oe b">app_utils.py</code>的一个函数中，让我们的Streamlit应用程序使用它。</p><h2 id="db10" class="mj mk it bd ml mm mn dn mo mp mq dp mr kr ms mt mu kv mv mw mx kz my mz na nb bi translated"><strong class="ak">模型加载</strong></h2><p id="3526" class="pw-post-body-paragraph ki kj it kk b kl nu ju kn ko nv jx kq kr nw kt ku kv nx kx ky kz ny lb lc ld im bi translated">现在我们有了生成数据点的方法，我们只剩下加载模型了！</p><p id="0e2c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe ob oc od oe b">vae_models</code>是一个将类似<code class="fe ob oc od oe b">”conv-vae”</code>的字符串映射到类对象<code class="fe ob oc od oe b">Conv_VAE</code>的字典。我们加载模型并将其设置为<code class="fe ob oc od oe b">eval</code>模式，然后将其返回。</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="nz oa l"/></div><p class="lq lr gj gh gi ls lt bd b be z dk translated">模型加载功能</p></figure><p id="8605" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">剩下的就是写一些代码来创建运行插值的按钮，信不信由你，我们已经完成了！剩下的就是在命令行中运行<code class="fe ob oc od oe b">streamlit run app.py</code>，然后进入<code class="fe ob oc od oe b">localhost:8501/</code>访问应用程序。</p><p id="cb4f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用Streamlit，我们可以使用我们非常熟悉的工具创建非常专业的web应用程序，并在很短的时间内完成。让我们花些时间来探索这款应用</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi og"><img src="../Images/2e8996a30497f080b86c8297cbeb4a59.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*bf-CUFfd2qoyOcw_XDeaRA.gif"/></div></div></figure><p id="5a65" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在<code class="fe ob oc od oe b">saved_models/</code>目录中有6种不同的模型，你可以用不同的α值来玩。概括地说，我们的损失函数是<code class="fe ob oc od oe b">MSELoss * alpha + kl_loss</code>，这意味着α值越高，模型优先考虑图像重建质量而不是潜在空间规律性。</p><p id="53fc" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">太好了，现在我们的应用程序工作了，让我们在网络上分享它。为此，我们将使用Docker来封装应用程序，并将其部署在Heroku dyno上。</p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="2929" class="oh mk it bd ml oi oj ok mo ol om on mr jz oo ka mu kc op kd mx kf oq kg na or bi translated"><strong class="ak">Docker是什么？</strong></h1><p id="0568" class="pw-post-body-paragraph ki kj it kk b kl nu ju kn ko nv jx kq kr nw kt ku kv nx kx ky kz ny lb lc ld im bi translated">Docker是一个集装箱工具。通过拍摄当前环境的快照并创建一个隔离的环境来运行应用程序，实现了可再现性。这使得我们可以在任何安装了docker的设备上发布和运行我们的代码。除了容器化应用程序，我们甚至可以使用Docker来创建可配置和可复制的开发人员环境。Docker的安装说明可在以下链接中找到:</p><div class="nc nd gp gr ne nf"><a href="https://www.docker.com/get-started" rel="noopener  ugc nofollow" target="_blank"><div class="ng ab fo"><div class="nh ab ni cl cj nj"><h2 class="bd iu gy z fp nk fr fs nl fu fw is bi translated">Docker | Docker入门</h2><div class="nm l"><h3 class="bd b gy z fp nk fr fs nl fu fw dk translated">了解Docker提供的完整容器解决方案。为开发人员、IT运营和…查找信息</h3></div><div class="nn l"><p class="bd b dl z fp nk fr fs nl fu fw dk translated">www.docker.com</p></div></div><div class="no l"><div class="os l nq nr ns no nt lo nf"/></div></div></a></div><p id="0266" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们需要做的是创建一个<code class="fe ob oc od oe b">Dockerfile</code>，它包含Docker创建容器所需的所有指令。这个容器将包含我们需要的所有文件，也与我们运行应用程序的环境相同。</p><p id="763c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于这样一个简单的Python应用程序，有4个主要组件。</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="08ac" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">1.<strong class="kk iu">来自python:3.8-slim-buster </strong></p><p id="d729" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Docker映像是使用层构建的，这允许Docker从现有映像快速构建映像，而不必从头开始构建。从一个python映像开始，我们得到的是一个Linux Ubuntu发行版，它包含一些重要的Python包并安装了Python 3。</p><p id="94fc" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">2.<strong class="kk iu">工作目录和副本</strong></p><p id="10d5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe ob oc od oe b">WORKDIR</code>命令为容器创建一个工作目录。这将作为<code class="fe ob oc od oe b">./</code>路径，防止容器过于混乱。<code class="fe ob oc od oe b">COPY</code>命令只是将所有必要的文件复制到映像中。类似于。gitignore我们可以创建一个. dockerignore来指定任何我们不想复制的文件，比如我们正在使用的数据集。</p><p id="b7bf" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">3.<strong class="kk iu">运行pip 3 install-r requirements . txt</strong></p><p id="a56d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe ob oc od oe b">RUN</code>允许docker运行项目所需的任何终端命令。我们可以运行pip install来安装项目所需的软件包。需要注意的一点是，我们为PyTorch安装了CPU专用版本。这避免了安装额外的CUDA驱动程序的需要，并保持容器较小。</p><p id="d073" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">4.<strong class="kk iu"> CMD </strong></p><p id="d8fd" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">开始运行应用程序的最后一个命令。这基本上是用于在本地环境中运行Streamlit的终端命令</p><p id="2d07" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先，在命令行中运行<code class="fe ob oc od oe b">docker build -t &lt;name_of_image&gt; .</code>。这告诉Docker在当前目录中查找Docker文件，并使用它构建一个映像。这一步需要相当长的时间，因为PyTorch是一个相当大的包</p><p id="5cc5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一旦建立了映像，我们可以使用命令<code class="fe ob oc od oe b">docker run</code>创建一个容器</p><p id="30cb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">默认情况下，容器与外部环境完全隔离，要访问我们的应用程序，我们必须使用<code class="fe ob oc od oe b">-p</code>标志打开一个端口。完成这项工作的完整命令是<code class="fe ob oc od oe b">docker run -p 8501:8501 &lt;name_of_image&gt;</code>，我们可以在<code class="fe ob oc od oe b">localhost:8501/</code>看到这个应用程序</p><p id="44c4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这可能看起来有点罗嗦，但是将我们的应用程序归档的好处是，我们可以毫无问题地与其他人共享它。我们可以将图像推送到Docker hub(Docker Images的Github ),任何人都可以毫无问题地运行这个应用程序。除此之外，容器化在部署应用程序时也会有所帮助。</p><h2 id="db67" class="mj mk it bd ml mm mn dn mo mp mq dp mr kr ms mt mu kv mv mw mx kz my mz na nb bi translated"><strong class="ak">部署</strong></h2><p id="3303" class="pw-post-body-paragraph ki kj it kk b kl nu ju kn ko nv jx kq kr nw kt ku kv nx kx ky kz ny lb lc ld im bi translated">很好，现在可以将最后一部分部署到网络上了。为此，我们将使用Heroku a PaaS(平台即服务),它允许我们部署web应用程序，而不必担心维护基础设施。这真的很容易使用，免费层通常是足够的个人项目。有几种方法可以部署到Heroku，但是我们将使用容器方法。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/958048a4c84b2f108d8ba93963ac9942.png" data-original-src="https://miro.medium.com/v2/resize:fit:1356/format:webp/1*aYoE0SyzT2zx4M547s41Tg.png"/></div></figure><p id="24a4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">登录Heroku账号后，我们首先需要创建一个app。我们可以通过给应用程序命名并设置区域，非常容易地从仪表板创建应用程序。记住应用程序名称，因为我们将在部署中使用它。</p><p id="e3bb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用Heroku的一个重要注意事项是，端口是随机分配给不同的应用程序的。Heroku提供给app的端口是不固定的，但它将作为环境变量<code class="fe ob oc od oe b">$PORT</code>给出。因此，我们必须对之前的docker文件做一个小小的修改。</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="nz oa l"/></div><p class="lq lr gj gh gi ls lt bd b be z dk translated">Heroku部署的Dockerfile</p></figure><p id="86db" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这样做的目的是更改最终命令，使其使用<code class="fe ob oc od oe b">$PORT</code>环境变量，而不是分配默认端口8501。</p><h1 id="1b69" class="oh mk it bd ml oi ou ok mo ol ov on mr jz ow ka mu kc ox kd mx kf oy kg na or bi translated">最终部署步骤</h1><p id="ebc2" class="pw-post-body-paragraph ki kj it kk b kl nu ju kn ko nv jx kq kr nw kt ku kv nx kx ky kz ny lb lc ld im bi translated">第一步是登录Heroku</p><p id="77e5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe ob oc od oe b">heroku login</code></p><p id="8230" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，我们指定用于Heroku构建的docker映像</p><p id="7a3a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe ob oc od oe b">heroku container:push -a &lt;app_name&gt; web</code></p><p id="5634" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个命令成功后，剩下唯一要做的就是释放应用程序。</p><p id="63aa" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe ob oc od oe b">heroku container:release -a &lt;app_name&gt; web</code></p><p id="6925" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">就是这样！该应用程序现在在Heroku提供的URL上运行。</p><p id="9290" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">希望这篇文章向您展示了如何使用Streamlit以及部署web应用程序所需的一些步骤来轻松构建web应用程序！</p><p id="fa03" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">请随意查看GitHub上的完整代码，非常感谢您的任何反馈！</p><p id="1a12" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">Github</strong>:<a class="ae mb" href="https://github.com/reoneo97/vae-playground" rel="noopener ugc nofollow" target="_blank">https://github.com/reoneo97/vae-playground</a><br/><strong class="kk iu">LinkedIn</strong>:<a class="ae mb" href="https://www.linkedin.com/in/reo-neo/" rel="noopener ugc nofollow" target="_blank">https://www.linkedin.com/in/reo-neo/</a></p></div></div>    
</body>
</html>