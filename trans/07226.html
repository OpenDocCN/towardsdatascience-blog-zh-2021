<html>
<head>
<title>Crack SQL Interview Question: Subquery vs. CTE</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">破解SQL面试问题:子查询vs. CTE</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/sql-for-data-analysis-subquery-vs-cte-699ef629d9eb?source=collection_archive---------1-----------------------#2021-07-01">https://towardsdatascience.com/sql-for-data-analysis-subquery-vs-cte-699ef629d9eb?source=collection_archive---------1-----------------------#2021-07-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="26b8" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">CTE和子查询的区别</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/46858cbfe35dc2d28ce8f7ba20dba5c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*FRwLYyo95N2K0d8g"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">迈克·本纳在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><h1 id="92e4" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">背景</h1><p id="e167" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">SQL是数据科学专业人员的必备技能。许多公司将其数据存储在关系数据库系统中，如MySQL、PostgreSQL、MS SQL Server、SQLite。SQL是我们与他们互动所需的编程语言。我们可以编写一个SQL查询来选择、过滤、转换、插入、更新和删除数据库中的底层数据。</p><p id="937d" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><strong class="lt iu">SQL不仅可以用来查询数据库，还可以用来进行数据分析。</strong>子查询和CTE(公共表表达式)都是有用的工具，我们可以使用它们编写复杂的SQL查询来实现数据分析，就像其他数据科学工具一样，比如Python中的<a class="ae ky" href="https://medium.com/geekculture/data-manipulation-sql-vs-pandas-116bb33a9abf" rel="noopener"> Pandas </a>和r中的dplyr</p><p id="e418" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在本文中，我将解释子查询和CTE之间的异同。</p><h1 id="22bd" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">子查询和CTE之间的相似性</h1><p id="d76f" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我将使用一个常见的SQL访问问题来演示子查询和CTE之间的相似性。</p><p id="5e06" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><strong class="lt iu"> SQL问题</strong>:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="50f5" class="mx la it mt b gy my mz l na nb">Distance Per Dollar</span><span id="148a" class="mx la it mt b gy nc mz l na nb">You’re given a dataset of Uber rides with the traveling distance ("distance_to_travel") and cost ("monetary_cost") for each ride. For each date, find the difference between the distance-per-dollar for that date and the average distance-per-dollar for that year-month. Distance-per-dollar is defined as the distance traveled divided by the cost of the ride.  <br/>The output should include the year-month (YYYY-MM) and the average difference in distance-per-dollar for said year-month as an absolute value rounded to the 2nd decimal. You should also count both success and failed request_status as the distance and cost values are populated for all ride requests. Also, assume that all dates are unique in the dataset. Order your results by the earliest request date first.</span><span id="87af" class="mx la it mt b gy nc mz l na nb">Source: <a class="ae ky" href="https://platform.stratascratch.com/coding-question?id=10302" rel="noopener ugc nofollow" target="_blank">stratascratch.com</a></span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nd"><img src="../Images/bcabe72d96bafa6818e115000c492fb2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P6Qn7FCmajp2sm5-P0_mXg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来源:<a class="ae ky" href="https://platform.stratascratch.com/coding-question?id=10302" rel="noopener ugc nofollow" target="_blank">stratascratch.com</a></p></figure><p id="0e55" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">以下是我们需要采取的步骤来解决这个问题:</p><ul class=""><li id="7660" class="ne nf it lt b lu mn lx mo ma ng me nh mi ni mm nj nk nl nm bi translated">步骤1:在给定的一天，计算每成本距离，并根据这一天创建年月</li><li id="301a" class="ne nf it lt b lu nn lx no ma np me nq mi nr mm nj nk nl nm bi translated">步骤2:使用一个窗口函数<a class="ae ky" href="https://medium.com/geekculture/data-manipulation-sql-vs-pandas-116bb33a9abf" rel="noopener">来计算年月级别的平均每成本距离</a></li><li id="84d9" class="ne nf it lt b lu nn lx no ma np me nq mi nr mm nj nk nl nm bi translated">步骤3:使用一个<a class="ae ky" href="https://medium.com/geekculture/data-manipulation-sql-vs-pandas-116bb33a9abf" rel="noopener">聚合函数</a>来计算年月级别上每日每成本距离和每月每成本距离之间的绝对差值的平均值</li><li id="a379" class="ne nf it lt b lu nn lx no ma np me nq mi nr mm nj nk nl nm bi translated">步骤4:按最早年月顺序输出</li></ul><h1 id="818e" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">使用子查询</h1><p id="f0a0" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">顾名思义，<strong class="lt iu">子查询</strong>是中的<strong class="lt iu">查询。要使用子查询，我们只需添加括号并将查询放入其中。子查询创建的输出将充当临时表。在我们执行完整个语句后，临时子查询将自动消失。</strong></p><p id="5c5a" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">对于这个SQL问题，如果我们使用子查询，我们将最终拥有多个<strong class="lt iu">嵌套子查询</strong>。</p><ul class=""><li id="e48e" class="ne nf it lt b lu mn lx mo ma ng me nh mi ni mm nj nk nl nm bi translated">步骤1:我们创建一个<strong class="lt iu">内部查询</strong> (a)来计算每成本的每日距离，并使用<code class="fe ns nt nu mt b">TO_CHAR</code>创建一个新列year-month。</li></ul><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="5a62" class="mx la it mt b gy my mz l na nb">SELECT *,<br/>   TO_CHAR(request_date::DATE, 'YYYY-MM') AS month<br/>   (distance_to_travel/monetary_cost) AS daily_dis_to_cost<br/>FROM uber_request_logs</span></pre><ul class=""><li id="251e" class="ne nf it lt b lu mn lx mo ma ng me nh mi ni mm nj nk nl nm bi translated">步骤2:我们创建另一个<strong class="lt iu">嵌套子查询</strong> (b)来使用窗口函数<code class="fe ns nt nu mt b">AVG(a.daily_dis_to_cost) OVER (PARTITION BY a.month)</code>计算每月平均每成本距离。使用窗口函数，输出将具有与原始数据集相同的行数。</li></ul><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="081c" class="mx la it mt b gy my mz l na nb">SELECT <br/>     a.request_date,<br/>     a.month,<br/>     a.daily_dis_to_cost,<br/>     AVG(a.daily_dis_to_cost) OVER(PARTITION BY a.month) AS monthly_dist_to_cost<br/>  FROM <br/>   (SELECT *,<br/>       TO_CHAR(request_date::DATE, 'YYYY-MM') AS month,<br/>       (distance_to_travel/monetary_cost) AS daily_dis_to_cost<br/>    FROM uber_request_logs) a<br/> ORDER BY request_date</span></pre><p id="7862" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><strong class="lt iu">中间</strong> <strong class="lt iu">输出</strong>:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nv"><img src="../Images/40b6aefb50a17f435ef7c634fcef8451.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WXviQeGApmPQ073ojmadGA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(作者创作)</p></figure><ul class=""><li id="c85d" class="ne nf it lt b lu mn lx mo ma ng me nh mi ni mm nj nk nl nm bi translated">第3步和第4步，我们运行<strong class="lt iu">外部查询</strong>来实现聚合函数<code class="fe ns nt nu mt b">AVG(ABS(b.daily_dis_to_cost-b.monthly_dis_to_cost))</code>和<code class="fe ns nt nu mt b">GROUP BY b.month</code>来计算年月级别上每日每成本距离和每月每成本距离之间的绝对差值的平均值。最后，我们按月排序输出。</li></ul><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="4d96" class="mx la it mt b gy my mz l na nb">SELECT <br/>    b.month,<br/>    ROUND(AVG(ABS(b.daily_dis_to_cost-b.monthly_dist_to_cost))::DECIMAL, 2) AS avg_diff<br/>FROM<br/>    (SELECT <br/>         a.request_date,<br/>         a.month,<br/>         a.daily_dis_to_cost,<br/>         AVG(a.daily_dis_to_cost) OVER(PARTITION BY a.month) AS monthly_dist_to_cost<br/>      FROM <br/>       (SELECT *,<br/>           TO_CHAR(request_date::DATE, 'YYYY-MM') AS month,<br/>           (distance_to_travel/monetary_cost) AS daily_dis_to_cost<br/>        FROM uber_request_logs) a<br/>     ORDER BY request_date) b<br/>GROUP BY b.month<br/>ORDER BY b.month</span></pre><h2 id="0fc5" class="mx la it bd lb nw nx dn lf ny nz dp lj ma oa ob ll me oc od ln mi oe of lp og bi translated"><strong class="ak">期望输出</strong>:</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/121373dd827770ebf237040647534c18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z5nF9CCD10xXMq3a1JE10w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(作者创作)</p></figure><h1 id="3f94" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">使用CTE</h1><p id="3801" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">一个<strong class="lt iu"> CTE </strong> ( <strong class="lt iu">又名公共表表达式</strong>)是我们在编写主查询之前使用<code class="fe ns nt nu mt b">WITH</code>子句创建的结果集。我们可以简单地将其输出用作临时表，就像子查询一样。类似于子查询，我们也可以创建多个cte。</p><p id="0fa4" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">为了使用CTE解决上述SQL问题，我们将创建多个cte(cte 1和cte2)，它们相当于上面提到的子查询(a和b)。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="f9ac" class="mx la it mt b gy my mz l na nb">WITH cte1 AS(<br/>    SELECT *,<br/>        TO_CHAR(request_date::DATE, 'YYYY-MM') AS month, <br/>        (distance_to_travel/monetary_cost) AS daily_dis_to_cost<br/>    FROM uber_request_logs<br/>),<br/>cte2 AS(<br/>    SELECT <br/>        request_date,<br/>        month,<br/>        daily_dis_to_cost,<br/>        AVG(daily_dis_to_cost) OVER(PARTITION BY month) AS monthly_dis_to_cost<br/>    FROM cte1<br/>    ORDER BY request_date<br/>)<br/>SELECT<br/>    month,<br/>    ROUND(AVG(ABS(daily_dis_to_cost-monthly_dis_to_cost))::DECIMAL, 2) AS avg_diff<br/>FROM cte2<br/>GROUP BY month<br/>ORDER BY month</span></pre><p id="e4db" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">子查询和CTE产生的结果完全相同。起初，我们可能认为这两个工具除了语法之外没有太多区别。在下一节中，我们将讨论这两种方法之间的区别。</p><h1 id="ea73" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">子查询和CTE的区别</h1><h2 id="3c46" class="mx la it bd lb nw nx dn lf ny nz dp lj ma oa ob ll me oc od ln mi oe of lp og bi translated">使用CTE的优势</h2><p id="c29d" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated"><strong class="lt iu"> CTE可以重用:</strong>使用CTE的一个优点是CTE在设计上是可重用的。不必在需要使用子查询的每个地方都声明相同的子查询，可以使用CTE定义一次临时表，然后在需要时引用它。</p><p id="a18b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">CTE更具可读性:CTE的另一个优势是CTE比子查询更具可读性。因为CTE可以重用，所以使用CTE比使用子查询可以编写更少的代码。此外，人们倾向于按照顺序而不是嵌套的方式来遵循逻辑和想法。当你写一个查询时，使用CTE将一个复杂的查询分解成更小的部分会更容易。</p><p id="49e3" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><strong class="lt iu">cte可以递归:</strong>CTE可以递归运行，而子查询不能。这使得它特别适合于树形结构，在这种结构中，给定行中的信息是基于前面行中的信息的。递归特性可以用<code class="fe ns nt nu mt b">RECURSIVE</code>和<code class="fe ns nt nu mt b">UNION ALL</code>实现。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="e713" class="mx la it mt b gy my mz l na nb">WITH RECURSIVE [cte_name] (column, ...) AS (<br/>  [non-recursive_term]<br/>UNION ALL<br/>  [recursive_term])<br/>SELECT ... FROM [cte_name];</span></pre><p id="ed71" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">让我们创建斐波纳契数列(<strong class="lt iu">数列</strong>中的每个数字都是它前面两个数字的和。)使用CTE的递归特性。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="259c" class="mx la it mt b gy my mz l na nb">WITH RECURSIVE fib(f1, f2) AS ( <br/>    SELECT 0, 1 <br/>    UNION ALL<br/>    SELECT f2, (f1+f2) FROM fib ) <br/>SELECT f1 FROM fib LIMIT 10;</span></pre><p id="68be" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><strong class="lt iu">输出:</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/ff814740f4ddfe496eb2666e4137bd22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hn0UiZKqRXgErWPsO6Saag.png"/></div></div></figure><p id="4214" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">到目前为止，我们已经讨论了CTE和子查询之间的一些差异。看起来CTE比子查询有更多的优势。但是在下一节中，我们将讨论子查询的特性，这是使用CTE无法实现的。</p><h2 id="574a" class="mx la it bd lb nw nx dn lf ny nz dp lj ma oa ob ll me oc od ln mi oe of lp og bi translated">使用子查询的优势</h2><p id="ddf0" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在WHERE子句中可以使用子查询:我们可以使用子查询返回值，然后在WHERE子句中使用它。在下面的示例中，我们希望返回工资高于平均工资的雇员。用一个计算平均工资的子查询很容易实现。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="812c" class="mx la it mt b gy my mz l na nb">SELECT<br/>   employee_name, salary <br/>FROM sample<br/>WHERE<br/>   salary &gt; (SELECT AVG(salary) FROM sample)</span></pre><p id="eb6b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><strong class="lt iu">子查询可以充当具有单个值的列:</strong>您也可以将子查询用作新列。唯一的约束是子查询必须只返回一个值。在下面的示例中，我们希望添加一个新列，其中包含平均工资。我们可以使用子查询来计算平均工资，然后将其包含在SELECT语句中。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="8d0f" class="mx la it mt b gy my mz l na nb">SELECT<br/>   employee_name,<br/>   salary,<br/>   (SELECT AVG(salary) FROM sample) AS average_salary<br/>FROM sample</span></pre><p id="5e84" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><strong class="lt iu">子查询可以与相关子查询一起使用:</strong>与CTE不同，我们可以将内部子查询用作相关子查询。这意味着对于外部查询处理的每个记录，将执行一个内部查询。</p><p id="1aa3" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在下面的例子中，我们想返回工资第二高的雇员。下面是我们将使用相关子查询来解决这个问题的方法。对于每个雇员(在外部查询(a)中)，我们计算工资高于给定雇员的雇员数量(在内部查询(b)中)。如果只有一个其他雇员的工资比这个给定的雇员高，我们就保留这个雇员。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="a673" class="mx la it mt b gy my mz l na nb">SELECT <br/>   employee_name, salary<br/>FROM sample a<br/>WHERE 1 = (SELECT COUNT(DISTINCT(salary)) FROM sample b WHERE a.salary &lt; b.salary)</span></pre><p id="08d1" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><strong class="lt iu">但是请记住，因为外部查询每次处理每一行时都会计算内部子查询，所以它可能会很慢。</strong></p><p id="02ba" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">如果你想探索更多的<strong class="lt iu"> SQL面试问题</strong>，请查看我的文章:</p><ul class=""><li id="df84" class="ne nf it lt b lu mn lx mo ma ng me nh mi ni mm nj nk nl nm bi translated"><a class="ae ky" href="https://medium.com/geekculture/comprehensive-sql-cheat-sheet-f821c5abf85a" rel="noopener"> <strong class="lt iu">综合SQL备忘单</strong> </a></li><li id="0987" class="ne nf it lt b lu nn lx no ma np me nq mi nr mm nj nk nl nm bi translated"><a class="ae ky" rel="noopener" target="_blank" href="/practical-sql-questions-for-data-science-interview-3b5c9d726baa"> <strong class="lt iu">破解SQL面试问题的有用程序</strong> </a></li><li id="be37" class="ne nf it lt b lu nn lx no ma np me nq mi nr mm nj nk nl nm bi translated"><a class="ae ky" rel="noopener" target="_blank" href="/sql-for-data-analysis-subquery-vs-cte-699ef629d9eb"> <strong class="lt iu">破解SQL面试问题:子查询vs CTE</strong></a></li><li id="5b95" class="ne nf it lt b lu nn lx no ma np me nq mi nr mm nj nk nl nm bi translated"><a class="ae ky" rel="noopener" target="_blank" href="/crack-sql-interview-question-join-vs-case-when-statement-116d40a361f0"> <strong class="lt iu">破解SQL面试题:Join vs Case-When语句</strong> </a></li><li id="dc39" class="ne nf it lt b lu nn lx no ma np me nq mi nr mm nj nk nl nm bi translated"><a class="ae ky" rel="noopener" target="_blank" href="/crack-sql-interview-question-window-functions-with-partition-by-599d792c07c3"> <strong class="lt iu">破解SQL面试题:带分区的窗口函数-By </strong> </a></li><li id="f3f8" class="ne nf it lt b lu nn lx no ma np me nq mi nr mm nj nk nl nm bi translated"><a class="ae ky" rel="noopener" target="_blank" href="/crack-sql-interview-question-date-part-function-aff0b15478d9"> <strong class="lt iu">破解SQL面试问题:Date_Part函数</strong> </a></li><li id="4d4b" class="ne nf it lt b lu nn lx no ma np me nq mi nr mm nj nk nl nm bi translated"><a class="ae ky" href="https://medium.com/geekculture/crack-sql-interview-questions-row-number-rank-and-dense-rank-ef439749f3ff" rel="noopener"> <strong class="lt iu">破解SQL面试题:ROW_NUMBER、RANK和DENSE_RANK </strong> </a></li><li id="2052" class="ne nf it lt b lu nn lx no ma np me nq mi nr mm nj nk nl nm bi translated"><a class="ae ky" href="https://python.plainenglish.io/crack-sql-interview-question-unnest-string-to-array-1b75578cbe75" rel="noopener ugc nofollow" target="_blank"> <strong class="lt iu">破解SQL面试问题:UNNEST，STRING_TO_ARRAY </strong> </a></li><li id="0675" class="ne nf it lt b lu nn lx no ma np me nq mi nr mm nj nk nl nm bi translated"><a class="ae ky" href="https://medium.com/geekculture/crack-sql-interview-question-generate-series-string-agg-split-part-fbc0e5e42d7d" rel="noopener"> <strong class="lt iu">破解SQL面试问题:GENERATE_SERIES，STRING_AGG，SPLIT_PART </strong> </a></li><li id="0676" class="ne nf it lt b lu nn lx no ma np me nq mi nr mm nj nk nl nm bi translated"><a class="ae ky" href="https://medium.com/geekculture/crack-sql-interview-question-self-join-and-non-equi-join-1cb2a181104a" rel="noopener"> <strong class="lt iu">破解SQL面试问题:自连接和非等同连接</strong> </a></li><li id="c18f" class="ne nf it lt b lu nn lx no ma np me nq mi nr mm nj nk nl nm bi translated"><a class="ae ky" href="https://medium.com/geekculture/crack-sql-interview-question-any-operator-d39e07e0e224" rel="noopener"> <strong class="lt iu">破解SQL面试问题:任意运算符</strong> </a></li><li id="112a" class="ne nf it lt b lu nn lx no ma np me nq mi nr mm nj nk nl nm bi translated"><a class="ae ky" href="https://medium.com/geekculture/crack-sql-interview-question-subquery-d9db4763eef4" rel="noopener"> <strong class="lt iu">破解SQL面试问题:子查询</strong> </a></li></ul><h1 id="65c8" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">感谢您的阅读！！！</h1><p id="1788" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">如果你喜欢这篇文章，并且想<strong class="lt iu">请我喝杯咖啡，</strong>请<a class="ae ky" href="https://ko-fi.com/aaronzhu" rel="noopener ugc nofollow" target="_blank">点击这里</a>。</p><p id="2947" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">您可以注册一个<a class="ae ky" href="https://aaron-zhu.medium.com/membership" rel="noopener"> <strong class="lt iu">会员</strong> </a>来解锁我的文章的全部访问权限，并且可以无限制访问介质上的所有内容。如果你想在我发表新文章时收到电子邮件通知，请订阅。</p></div></div>    
</body>
</html>