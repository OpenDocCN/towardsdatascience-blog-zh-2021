<html>
<head>
<title>“Find the Difference” in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的“寻找差异”</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/find-the-difference-in-python-68bbd000e513?source=collection_archive---------1-----------------------#2021-03-21">https://towardsdatascience.com/find-the-difference-in-python-68bbd000e513?source=collection_archive---------1-----------------------#2021-03-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/9e4a89d9a6fe6b2d5823274369cd0eb4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ikBuzN1xqzcpBrDYXCtLGQ.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">照片由<a class="ae jg" href="https://pixabay.com/users/geralt-9301/" rel="noopener ugc nofollow" target="_blank"> geralt </a>在<a class="ae jg" href="https://pixabay.com/illustrations/difference-mobile-phone-smartphone-2048174/" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>拍摄</p></figure><div class=""/><div class=""><h2 id="470e" class="pw-subtitle-paragraph kg ji jj bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dk translated">difflib——Python内置库中隐藏的瑰宝</h2></div><p id="42b9" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最近，我一直专注于审查和试用Python内置库。这个自我分配的任务给我带来了很多乐趣。Python中有许多有趣的特性，为不同类型的问题提供了现成的实现和解决方案。</p><p id="f136" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">其中一个例子就是我要在本文中介绍的内置库——Difflib。因为它是Python3内置的，所以我们不需要下载或安装任何东西，只需如下导入即可。</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="1b70" class="md me jj lz b gy mf mg l mh mi">import difflib as dl</span></pre><p id="d532" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在我们应该开始了:)</p><h1 id="4946" class="mj me jj bd mk ml mm mn mo mp mq mr ms kp mt kq mu ks mv kt mw kv mx kw my mz bi translated">1.查找“已更改”的元素</h1><figure class="lu lv lw lx gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/2796c6972625a462a309c9099bccf7f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R5KPGr8TiNxoHtCYRUmbVg.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">照片由<a class="ae jg" href="https://pixabay.com/users/geralt-9301/" rel="noopener ugc nofollow" target="_blank"> geralt </a>在<a class="ae jg" href="https://pixabay.com/illustrations/change-arrows-clouds-sky-direction-948024/" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>上拍摄</p></figure><p id="3f51" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我相信我的大多数观众都知道如何使用git。如果您是其中之一，您可能已经看到了如下带有冲突的原始代码文件。</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="ef6b" class="md me jj lz b gy mf mg l mh mi">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD:file.txt<br/>Hello world<br/>=======<br/>Goodbye<br/>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 77976da35a11db4580b80ae27e8d65caf5208086:file.txt</span></pre><p id="2045" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在大多数Git的GUI工具中，比如Atlassian Sourcetree，您一定见过这样的表示。</p><figure class="lu lv lw lx gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi na"><img src="../Images/672d58825e0feba9f48a88594beec7f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/0*5DGRXGvKmEPY4MFV.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">图片提供:<a class="ae jg" href="https://blog.sourcetreeapp.com/files/2013/03/hero-small.png" rel="noopener ugc nofollow" target="_blank">https://blog.sourcetreeapp.com/files/2013/03/hero-small.png</a></p></figure><p id="4024" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">减号表示该行代码在新版本中被删除，而加号表示该行代码被添加到新版本的代码中，而该代码在旧版本中并不存在。</p><p id="aa22" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在Python中，我们可以使用Difflib通过一行代码轻松实现非常类似的东西。我要展示的第一个函数是<code class="fe nb nc nd lz b">context_diff()</code>。</p><p id="bd1d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们用一些字符串元素组成两个列表。</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="1ab5" class="md me jj lz b gy mf mg l mh mi">s1 = ['Python', 'Java', 'C++', 'PHP']<br/>s2 = ['Python', 'JavaScript', 'C', 'PHP']</span></pre><p id="5fc6" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后，魔法来了。我们可以生成如下的比较“报告”。</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="3c55" class="md me jj lz b gy mf mg l mh mi">dl.context_diff(s1, s2)</span></pre><p id="1f38" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe nb nc nd lz b">context_diff()</code>函数将返回一个Python生成器。因此，我们可以循环它来一次性打印所有内容。</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="de8b" class="md me jj lz b gy mf mg l mh mi">for diff in dl.context_diff(s1, s2):<br/>    print(diff)</span></pre><figure class="lu lv lw lx gt iv gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/d1360729599fe193819e64f7f30bdd22.png" data-original-src="https://miro.medium.com/v2/resize:fit:916/format:webp/1*pRa5aSjesBxirlA5ed8TKA.png"/></div></figure><p id="ecc7" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输出使用感叹号<code class="fe nb nc nd lz b">!</code>清楚地显示第二个和第三个元素是不同的，表示“这个元素是不同的”！</p><p id="2339" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这种情况下，第一个和第四个元素是相同的，因此它将只显示差异。最有趣的是，如果我们把场景变得更复杂，它会显示出更有用的东西。让我们将这两个列表更改如下。</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="e805" class="md me jj lz b gy mf mg l mh mi">s1 = ['Python', 'Java', 'C++', 'PHP']<br/>s2 = ['Python', 'Java', 'PHP', 'Swift']</span></pre><figure class="lu lv lw lx gt iv gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/8408817761787cb815345ed6720f55d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:802/format:webp/1*KmEQHLdOrqEcyxIrSua6lw.png"/></div></figure><p id="a81b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">上面的输出表明“C++”已经从第一个列表(原始列表)中删除，“Swift”已经被添加到第二个列表(新列表)中。</p><p id="023a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我们想显示与从Sourcetree获得的截图完全相似的内容，该怎么办？是的，Python允许我们这样做。只需使用另一个名为<code class="fe nb nc nd lz b">unified_diff()</code>的函数。</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="9177" class="md me jj lz b gy mf mg l mh mi">dl.unified_diff(s1, s2)</span></pre><figure class="lu lv lw lx gt iv gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/6ab932274958f5f058ebb097314ef8ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:678/format:webp/1*jjLSkcL-KDw-SAfb2QymIQ.png"/></div></figure><p id="69a1" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe nb nc nd lz b">unified_diff()</code>函数将两个列表“统一”在一起，可以生成如上图所示的输出，在我看来这更具可读性。</p><h1 id="b50c" class="mj me jj bd mk ml mm mn mo mp mq mr ms kp mt kq mu ks mv kt mw kv mx kw my mz bi translated">2.准确指出差异</h1><figure class="lu lv lw lx gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/744d49f1b5d2f730abb83e752fa9bd62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KbGLNRZLx0j624cjCMn49g.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">照片由<a class="ae jg" href="https://pixabay.com/photos/magnifying-glass-research-find-5288875/" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>上的<a class="ae jg" href="https://pixabay.com/users/lucasgeorgewendt-15638399/" rel="noopener ugc nofollow" target="_blank"> lucasgeorgewendt </a>拍摄</p></figure><p id="29c7" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在第1节中，我们着重于确定行级的差异。能不能具体一点？例如，如果我们想要一个字符一个字符地比较，并显示有什么不同呢？</p><p id="12ee" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">答案是肯定的。我们可以使用<code class="fe nb nc nd lz b">ndiff()</code>功能。</p><p id="0786" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">假设我们正在比较两个列表中的单词，如下所示。</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="5bcc" class="md me jj lz b gy mf mg l mh mi">['tree', 'house', 'landing']<br/>['tree', 'horse', 'lending']</span></pre><p id="ce3b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这三个单词看起来非常相似，但是只有第二和第三个单词有一个字母的变化。让我们看看函数会返回给我们什么。</p><figure class="lu lv lw lx gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi gj"><img src="../Images/16caa5d99e6c3c78c7dc6cc38a163ecc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WAHwgUY5VckAPGkaQDIgdQ.png"/></div></div></figure><p id="6d03" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">它不仅显示了哪些内容已更改(带减号和加号)和未更改(“树”未更改，因此根本没有指示符)，还显示了哪个字母已更改。<code class="fe nb nc nd lz b">^</code>指示符已正确添加到已被识别为差异的信函中。</p><h1 id="7927" class="mj me jj bd mk ml mm mn mo mp mq mr ms kp mt kq mu ks mv kt mw kv mx kw my mz bi translated">3.获得相近的匹配</h1><figure class="lu lv lw lx gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/f3ac83d3c9f7fb3266f8cc1bb03f0110.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MbQVQxFMUWXTeBe0H96pDw.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">由<a class="ae jg" href="https://pixabay.com/users/pezibear-526143/" rel="noopener ugc nofollow" target="_blank"> Pezibear </a>在<a class="ae jg" href="https://pixabay.com/photos/tulips-garden-garden-flowers-flower-3339416/" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>上拍摄的照片</p></figure><p id="f31d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你有没有输入“teh”被自动更正为“the”的经历？我打赌你有，我一直都是这样:)</p><p id="e39d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，有了Difflib，您可以非常容易地在Python应用程序中实现这个特性。关键是使用<code class="fe nb nc nd lz b">get_close_matches()</code>功能。</p><p id="10cc" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">假设我们有一个候选列表和一个“输入”，这个函数可以帮助我们挑选与“输入”接近的一个(或多个)。让我们看看下面的例子。</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="710e" class="md me jj lz b gy mf mg l mh mi">dl.get_close_matches('thme', ['them', 'that', 'this'])</span></pre><figure class="lu lv lw lx gt iv gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/6467ddebf7fdb48864c4b4395f18ce04.png" data-original-src="https://miro.medium.com/v2/resize:fit:992/format:webp/1*9i_SxvuBQAuq-fmbCAfcgw.png"/></div></figure><p id="10bc" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当我们输入“thme”(一个错别字)而不是“this”或“that”时，它成功地找到了“them”，因为“them”是最接近的一个。但是，该函数不能保证返回某个值。也就是说，当没有足够接近输入的内容时，将返回一个空列表。</p><figure class="lu lv lw lx gt iv gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/2d3debeb26c70c91f8ab3e0bdaf16662.png" data-original-src="https://miro.medium.com/v2/resize:fit:964/format:webp/1*ZAdp0gGx4VgUFviW8K9o2w.png"/></div></figure><p id="6c48" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这非常有意义，因为我们不会一直犯拼写错误，对吗？:)</p><p id="3650" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">事实上，我们可以通过向参数<code class="fe nb nc nd lz b">cutoff</code>传递一个参数来控制如何度量“相似性”。它需要一个介于0和1之间的浮点数。数字越大意味着越严格，反之亦然。</p><figure class="lu lv lw lx gt iv gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/0a9239fda43875ca59ced3dcdbcff388.png" data-original-src="https://miro.medium.com/v2/resize:fit:1146/format:webp/1*wxE-tJ0rnOHN4FrrhnsXhQ.png"/></div></figure><p id="f705" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一个<code class="fe nb nc nd lz b">cutoff = 0.1</code>足够小，可以让函数匹配输入的所有候选项。如果我们想限制返回的匹配项的数量呢？我们可以使用另一个参数<code class="fe nb nc nd lz b">n</code>，它将返回给我们“前n个”最匹配的术语。</p><figure class="lu lv lw lx gt iv gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/950ee78e6e38ed1b1ae48731715ced8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1252/format:webp/1*k4xUX9ARfeTWySbbT6DPSA.png"/></div></figure><h1 id="9efc" class="mj me jj bd mk ml mm mn mo mp mq mr ms kp mt kq mu ks mv kt mw kv mx kw my mz bi translated">4.如何将一个字符串A修改为B？</h1><figure class="lu lv lw lx gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/4515aaf060818ce8f96ab1f54d581167.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l0PyulR_jaZJLL6Jgl-n4Q.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated"><a class="ae jg" href="https://pixabay.com/users/foundry-923783/" rel="noopener ugc nofollow" target="_blank">铸造厂</a>在<a class="ae jg" href="https://pixabay.com/photos/knit-sew-girl-female-make-craft-869221/" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>上拍摄的照片</p></figure><p id="c619" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你有一些信息检索的知识，你可能已经意识到上述函数利用了Levenshtein距离。它试图找出两个文本术语之间的差异，并测量它们之间的“距离”。</p><p id="4576" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">通常，该距离由修改术语A到b所需的最小替换、插入和删除次数来定义。有时，不同的修改将被赋予不同的权重。在本文中，我将跳过算法部分。如果你感兴趣的话，可以去Levenshtein Distance的Wiki页面了解详情。</p><div class="is it gp gr iu nl"><a href="https://en.wikipedia.org/wiki/Levenshtein_distance" rel="noopener  ugc nofollow" target="_blank"><div class="nm ab fo"><div class="nn ab no cl cj np"><h2 class="bd jk gy z fp nq fr fs nr fu fw ji bi translated">莱文斯坦距离</h2><div class="ns l"><h3 class="bd b gy z fp nq fr fs nr fu fw dk translated">在信息论、语言学和计算机科学中，Levenshtein距离是一个字符串度量，用于测量…</h3></div><div class="nt l"><p class="bd b dl z fp nq fr fs nr fu fw dk translated">en.wikipedia.org</p></div></div></div></a></div><p id="1915" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">其实这篇文章还没写完。使用Difflib，我们甚至可以实现如何将Levenshtein距离应用于两个字符串的步骤。这可以使用Difflib中的<code class="fe nb nc nd lz b">SequenceMatcher</code>类来完成。</p><p id="d827" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">假设我们有两个字符串<code class="fe nb nc nd lz b">abcde</code>和<code class="fe nb nc nd lz b">fabdc</code>，我们想知道如何将前者修改成后者。第一步是实例化该类。</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="c153" class="md me jj lz b gy mf mg l mh mi">s1 = 'abcde'<br/>s2 = 'fabdc'</span><span id="dccb" class="md me jj lz b gy nu mg l mh mi">seq_matcher = dl.SequenceMatcher(None, s1, s2)</span></pre><p id="91f6" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后，我们可以使用类方法<code class="fe nb nc nd lz b">get_opcodes()</code>来获得元组列表，该列表指示:</p><ul class=""><li id="e907" class="nv nw jj la b lb lc le lf lh nx ll ny lp nz lt oa ob oc od bi translated">修改操作(插入、等于或删除)的标签</li><li id="c9a5" class="nv nw jj la b lb oe le of lh og ll oh lp oi lt oa ob oc od bi translated">源字符串的开始和结束位置</li><li id="9041" class="nv nw jj la b lb oe le of lh og ll oh lp oi lt oa ob oc od bi translated">目标字符串的开始和结束位置</li></ul><p id="698c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以将上述信息“翻译”成可读性更强的东西。</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="0dfc" class="md me jj lz b gy mf mg l mh mi">for tag, i1, i2, j1, j2 in seq_matcher.get_opcodes():<br/>    print(f'{tag:7}   s1[{i1}:{i2}] --&gt; s2[{j1}:{j2}] {s1[i1:i2]!r:&gt;6} --&gt; {s2[j1:j2]!r}')</span></pre><figure class="lu lv lw lx gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oj"><img src="../Images/69775fd32140e884f2118393fedc4594.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e3Ntc3qFUDP_iemjiu5GeA.png"/></div></div></figure><p id="1f11" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">超级爽:)</p><p id="b861" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你可能也注意到了，我们传递给<code class="fe nb nc nd lz b">SequenceMatcher</code>类的第一个参数是<code class="fe nb nc nd lz b">None</code>。此参数用于指示某些字符可能被“忽略”的算法。这种忽略并不意味着从源字符串中删除它，而是在算法处理中忽略它。我知道这有点难以理解。让我给你看一个例子。</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="6718" class="md me jj lz b gy mf mg l mh mi">seq_matcher = dl.SequenceMatcher(lambda c: c in 'abc', s1, s2)</span></pre><figure class="lu lv lw lx gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ok"><img src="../Images/2502a3e490f3f551dd2d24daf4f12620.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xgUST83K-z9-90k-YbvC2w.png"/></div></div></figure><p id="04da" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">字母“abc”不会在算法中运行，但会被视为一个整体。</p><p id="d037" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后但同样重要的是，下面的例子展示了我们在实践中如何使用这个函数。</p><figure class="lu lv lw lx gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ol"><img src="../Images/615999356169fcff1bd24064f4c7547b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GigOgXQWMJ3DCUb0IlqWqg.png"/></div></div></figure><h1 id="9aa0" class="mj me jj bd mk ml mm mn mo mp mq mr ms kp mt kq mu ks mv kt mw kv mx kw my mz bi translated">摘要</h1><figure class="lu lv lw lx gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/339e0439ae2afd4c8387743710efa239.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GOkuDoEA99yz5cMSlG7CUg.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">在<a class="ae jg" href="https://pixabay.com/photos/woman-girl-freedom-happy-sun-591576/" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>上由<a class="ae jg" href="https://pixabay.com/users/jillwellington-334088/" rel="noopener ugc nofollow" target="_blank">吉尔·威林顿</a>拍摄的照片</p></figure><p id="d29d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在本文中，我介绍了另一个名为Difflib的Python内置库。它可以生成报告，指出两个列表或两个字符串之间的差异。此外，它还可以帮助我们在输入和候选字符串列表之间找到最匹配的字符串。最终，我们可以使用这个模块的一个类来实现一些更复杂和高级的功能。</p><div class="is it gp gr iu nl"><a href="https://medium.com/@qiuyujx/membership" rel="noopener follow" target="_blank"><div class="nm ab fo"><div class="nn ab no cl cj np"><h2 class="bd jk gy z fp nq fr fs nr fu fw ji bi translated">通过我的推荐链接加入Medium克里斯托弗·陶</h2><div class="ns l"><h3 class="bd b gy z fp nq fr fs nr fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="nt l"><p class="bd b dl z fp nq fr fs nr fu fw dk translated">medium.com</p></div></div><div class="om l"><div class="on l oo op oq om or ja nl"/></div></div></a></div><p id="9bba" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">如果你觉得我的文章有帮助，请考虑加入灵媒会员来支持我和成千上万的其他作家！(点击上面的链接)</strong></p></div></div>    
</body>
</html>