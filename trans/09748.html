<html>
<head>
<title>How Do You Join SQL Tables?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何连接SQL表？</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-do-you-join-sql-tables-a4b6ceb898bb?source=collection_archive---------14-----------------------#2021-09-12">https://towardsdatascience.com/how-do-you-join-sql-tables-a4b6ceb898bb?source=collection_archive---------14-----------------------#2021-09-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="554f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">WHERE或ON子句？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/98e835adac456ab74c518b877dbb07b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YECeOxlko9KoOJNw8RNm3A.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@alinnnaaaa?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Alina Grubnyak </a>在<a class="ae ky" href="https://unsplash.com/s/photos/data?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="8a65" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">马上，我不使用也永远不会使用<code class="fe lv lw lx ly b">WHERE</code>子句来连接表。</p><p id="a6e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你正在使用<code class="fe lv lw lx ly b">WHERE</code>子句，这篇文章试图说服你也这样做。相反，使用<code class="fe lv lw lx ly b">ON</code>子句来实现表连接。</p><p id="5695" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您使用<code class="fe lv lw lx ly b">WHERE</code>子句执行表连接吗？请不要让我检查或帮助你找到你的查询中令人沮丧的障碍。</p><p id="fff9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你在问我为什么吗？</p><p id="1485" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我告诉过你，我不喜欢用于连接表的<code class="fe lv lw lx ly b">WHERE</code>子句。我只用它来过滤数据。当用于实现表连接时，它以一种糟糕的方式(畏缩)让我恼火。我的思维变得超速，特别是在用于实现两个表之外的多个连接时。</p><p id="391c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">类似下面的SQL查询伤害了我的眼睛，更糟糕的是我的大脑。使用<code class="fe lv lw lx ly b">WHERE </code>子句来实现表连接，会使表连接的顺序变得不清晰，也没有任何视觉提示。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用WHERE子句连接多个表的SQL查询示例。这个SQL使用相同的WHERE子句进行过滤。</p></figure><p id="e5d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">参见上面使用<code class="fe lv lw lx ly b">WHERE</code>子句连接6个表的SQL查询。更糟糕的是，它还使用3个带有相同的<code class="fe lv lw lx ly b">WHERE</code>子句的<code class="fe lv lw lx ly b">AND</code>逻辑操作符来执行数据过滤。</p><p id="c8e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<code class="fe lv lw lx ly b">ON</code>子句实现相同结果的重写看起来像这样。奖励是非常明显的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="1fc0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们使用了<code class="fe lv lw lx ly b">WHERE</code>子句的查询尾部的混乱被很好地整理了。现在很明显<code class="fe lv lw lx ly b">WHERE</code>子句在做什么——一件事——只有行过滤。</p><p id="278a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第二，简单地说，您可以识别和理解连接表的顺序，以创建保存查询结果的概念上的巨型表。</p><p id="ac13" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">重写看起来也很有凝聚力。</p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="b2fc" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">表连接不使用WHERE But ON子句的更多理由</h1><h2 id="2408" class="na mj it bd mk nb nc dn mo nd ne dp ms li nf ng mu lm nh ni mw lq nj nk my nl bi translated">1.数据过滤</h2><p id="9142" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated"><code class="fe lv lw lx ly b">WHERE</code>子句很优秀，更适合数据过滤，而不是连接表。</p><h2 id="f10e" class="na mj it bd mk nb nc dn mo nd ne dp ms li nf ng mu lm nh ni mw lq nj nk my nl bi translated">2.认知超载</h2><p id="0f0b" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">在实现数据过滤和表连接时使用<code class="fe lv lw lx ly b">WHERE</code>子句会造成认知超载。<code class="fe lv lw lx ly b">WHERE</code>子句在同时用于实现表连接和数据过滤时会影响可读性和查询理解。</p><h2 id="5332" class="na mj it bd mk nb nc dn mo nd ne dp ms li nf ng mu lm nh ni mw lq nj nk my nl bi translated">3.有限的</h2><p id="a3f1" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated"><code class="fe lv lw lx ly b">WHERE</code>子句限制了你在不同的表上可以实现的连接。<code class="fe lv lw lx ly b">WHERE</code>子句只实现了<code class="fe lv lw lx ly b">INNER JOIN</code>，这是您可以使用<code class="fe lv lw lx ly b">ON</code>子句执行的5种连接类型之一。</p><h2 id="4f83" class="na mj it bd mk nb nc dn mo nd ne dp ms li nf ng mu lm nh ni mw lq nj nk my nl bi translated">4.缺失记录</h2><p id="fcee" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">因为使用<code class="fe lv lw lx ly b">WHERE</code>子句执行表连接在技术上与<code class="fe lv lw lx ly b">INNER JOIN</code>的行为相同，所以连接的表中的记录必须满足<code class="fe lv lw lx ly b">WHERE</code>子句中表达的条件，才能成为连接的表的结果的一部分。忽略这些基础知识可能会导致查询结果中遗漏重要的记录。在银行和汇款应用程序这样的金融应用程序中，这种疏忽可能是代价高昂的。</p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="0b35" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">使用ON子句实现比内部连接更多的功能</h1><p id="eee6" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">正如我前面指出的，使用<code class="fe lv lw lx ly b">WHERE</code>子句产生的结果与同时使用<code class="fe lv lw lx ly b">ON</code>子句和<code class="fe lv lw lx ly b">INNER JOIN</code>子句产生的结果相同。</p><p id="b19e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了使用<code class="fe lv lw lx ly b">ON</code>子句实现<code class="fe lv lw lx ly b">INNER JOIN</code>之外，您还可以实现其他形式的SQL表连接。这些其他类型的表连接的好处是有足够的参数将<code class="fe lv lw lx ly b">WHERE</code>子句严格留给数据过滤。这样做也为您的查询带来了一致性，并减少了其他开发人员的SQL审查和维护难题，因为他们不必费力区分用于表连接和数据过滤的条件。</p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><p id="de95" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文的其余部分，除了内部连接之外，我将通过示例数据展示其他三种形式的SQL连接。</p><p id="ddb7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您想亲自操作，那么首先创建表并用示例数据作为种子。</p><p id="6940" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建表格，<code class="fe lv lw lx ly b">person</code>和<code class="fe lv lw lx ly b">contact</code></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">创建表“person”的SQL查询</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">创建表“联系人”的SQL查询</p></figure><p id="8e31" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下载样本数据<a class="ae ky" href="https://gist.github.com/ofelix03/2ef0d1cdfec43a10755ec871342daa05/archive/b1751827ba2d0801cdd38204747a1e2c00dd244a.zip" rel="noopener ugc nofollow" target="_blank"> person.csv </a>和<a class="ae ky" href="https://gist.github.com/ofelix03/957dc0c1e718d8758ef5ebc003455fd3/archive/f79bd45fe9c11b9c8cbd162db281ec6d47e48412.zip" rel="noopener ugc nofollow" target="_blank"> contact.csv </a>并分别植入表<code class="fe lv lw lx ly b">person</code>和<code class="fe lv lw lx ly b">contact</code>。</p><p id="036c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用下面的查询解压缩并最终用示例数据播种这些表。记得用你下载的解压副本的路径替换<code class="fe lv lw lx ly b">/path/to/person.csv</code>和<code class="fe lv lw lx ly b">/path/to/contact.csv</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="dbc2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您做的一切都是正确的，那么表上的select语句应该产生下面的输出</p><h2 id="805a" class="na mj it bd mk nb nc dn mo nd ne dp ms li nf ng mu lm nh ni mw lq nj nk my nl bi translated">餐桌人员</h2><pre class="kj kk kl km gt nr ly ns nt aw nu bi"><span id="5d0c" class="na mj it ly b gy nv nw l nx ny">SELECT * FROM person;</span></pre><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">person.csv</p></figure><h2 id="03bb" class="na mj it bd mk nb nc dn mo nd ne dp ms li nf ng mu lm nh ni mw lq nj nk my nl bi translated">表格联系人</h2><pre class="kj kk kl km gt nr ly ns nt aw nu bi"><span id="e743" class="na mj it ly b gy nv nw l nx ny">SELECT * FROM contact;</span></pre><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">contact.csv</p></figure></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="cdfa" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">除了内部连接之外的其他连接类型</h1><p id="8f89" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">除了<code class="fe lv lw lx ly b">INNER JOIN</code>，还有4种其他类型的连接，分别是<code class="fe lv lw lx ly b">FULL OUTER JOIN</code>、<code class="fe lv lw lx ly b">LEFT OUTER JOIN</code>、<code class="fe lv lw lx ly b">RIGHT OUTER JOIN</code>和<code class="fe lv lw lx ly b">CROSS JOIN</code>。</p><p id="8915" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将讨论<code class="fe lv lw lx ly b">LEFT OUTER JOIN , RIGHT OUTER JOIN</code>和<code class="fe lv lw lx ly b">FULL OUTER JOIN</code></p><h2 id="f1d1" class="na mj it bd mk nb nc dn mo nd ne dp ms li nf ng mu lm nh ni mw lq nj nk my nl bi translated">左外部连接</h2><p id="9590" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">如果两个表都满足用<code class="fe lv lw lx ly b">ON</code>子句指定的条件，左外连接通过列出左表中的指定列并将它们连接到右表中的列来组合两个表。</p><p id="ed2c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当条件与左表中的列不匹配时，为右表中的列设置一个<code class="fe lv lw lx ly b">NULL</code>值。</p><p id="2ced" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">考虑下面的例子，一个<code class="fe lv lw lx ly b">person</code>表位于表<code class="fe lv lw lx ly b">contact</code>的左外部连接中。</p><p id="4828" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">工作台<code class="fe lv lw lx ly b">person</code>为左工作台<code class="fe lv lw lx ly b">contact</code>为右工作台。</p><p id="5824" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您会注意到左边表格<code class="fe lv lw lx ly b">person</code>中的<code class="fe lv lw lx ly b">name</code>、<code class="fe lv lw lx ly b">gender</code>、<code class="fe lv lw lx ly b">age</code>列被连接到右边表格<code class="fe lv lw lx ly b">contact</code>中的<code class="fe lv lw lx ly b">phone_number</code>列。同样明显的是，没有匹配<code class="fe lv lw lx ly b">person_id</code>的最后4行将<code class="fe lv lw lx ly b">phone_number</code>设置为空。</p><pre class="kj kk kl km gt nr ly ns nt aw nu bi"><span id="c5ba" class="na mj it ly b gy nv nw l nx ny">SELECT person.name,<br/>       person.gender,<br/>       person.age, <br/>       person.phone_number<br/>FROM person<br/>LEFT OUTER JOIN contact<br/>ON person.id = contact.person_id</span></pre><h2 id="372e" class="na mj it bd mk nb nc dn mo nd ne dp ms li nf ng mu lm nh ni mw lq nj nk my nl bi translated">输出:</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">表person和contact之间左外部连接的输出</p></figure></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h2 id="e272" class="na mj it bd mk nb nc dn mo nd ne dp ms li nf ng mu lm nh ni mw lq nj nk my nl bi translated">右外部联接</h2><p id="ad16" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">右外连接通过列出右表中的指定列并在两个表都满足用<code class="fe lv lw lx ly b">ON</code>子句指定的条件时将它们连接到左表中的列来组合两个表。</p><p id="d680" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当条件与左表中的列不匹配时，为左表中的列设置一个<code class="fe lv lw lx ly b">NULL</code>值。</p><p id="e036" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">考虑下面的例子，右外部连接中的一个<code class="fe lv lw lx ly b">person</code>表与表<code class="fe lv lw lx ly b">contact</code>。工作台<code class="fe lv lw lx ly b">person</code>是左工作台<code class="fe lv lw lx ly b">contact</code>是右工作台。</p><p id="a004" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您会注意到右表中所有行的<code class="fe lv lw lx ly b">phone_number</code>都被列出，并连接到左表中匹配记录的<code class="fe lv lw lx ly b">name</code>、<code class="fe lv lw lx ly b">gender</code>、<code class="fe lv lw lx ly b">age</code>。</p><p id="651a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为<code class="fe lv lw lx ly b">person</code>表和<code class="fe lv lw lx ly b">contact</code>表之间的关联是关系型的，确切地说是一个<code class="fe lv lw lx ly b">One2many</code>关系，所以如果没有一个根实体person来拥有它，就不会有联系人记录。因此，我们的<code class="fe lv lw lx ly b">RIGHT OUTER JOIN</code>结果仅限于有联系记录的人员。</p><p id="51d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果来自<code class="fe lv lw lx ly b">person</code>表的<code class="fe lv lw lx ly b">name</code>、<code class="fe lv lw lx ly b">gender</code>、<code class="fe lv lw lx ly b">age</code>列表都满足<code class="fe lv lw lx ly b">ON</code>条款规定的条件，则它们被连接到来自<code class="fe lv lw lx ly b">contact</code>表的<code class="fe lv lw lx ly b">phone_number</code>。</p><pre class="kj kk kl km gt nr ly ns nt aw nu bi"><span id="b409" class="na mj it ly b gy nv nw l nx ny">SELECT person.name, <br/>       contact.mobile_number, <br/>       contact.home_address<br/>FROM person<br/>RIGHT OUTER JOIN contact<br/>ON person.id = contact.person_id</span></pre><p id="fe3b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">输出:</strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">表person和contact之间右外连接的输出</p></figure><h2 id="addd" class="na mj it bd mk nb nc dn mo nd ne dp ms li nf ng mu lm nh ni mw lq nj nk my nl bi translated">完全外部连接</h2><p id="34d9" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">完全外部联接通过列出两个表中的列来组合这两个表。当条件不满足时，为左表或右表的列设置一个<code class="fe lv lw lx ly b">NULL</code>值。</p><p id="e9c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">考虑下面的例子，一个<code class="fe lv lw lx ly b">person</code>表和<code class="fe lv lw lx ly b">contact</code>通过一个更完整的外部连接组合在一起，条件是<code class="fe lv lw lx ly b">person</code>上的<code class="fe lv lw lx ly b">id</code>列与<code class="fe lv lw lx ly b">contact</code>表上的<code class="fe lv lw lx ly b">person_id</code>列匹配。每个表中不满足该条件的行仍然显示在结果中，它们的列设置为<code class="fe lv lw lx ly b">NULL</code></p><pre class="kj kk kl km gt nr ly ns nt aw nu bi"><span id="6f81" class="na mj it ly b gy nv nw l nx ny">SELECT person.name,<br/>       person.gender,<br/>       person.age, <br/>       person.phone_number<br/>FROM person<br/>FULL OUTER JOIN contact<br/>ON person.id = contact.person_id</span></pre><h2 id="380e" class="na mj it bd mk nb nc dn mo nd ne dp ms li nf ng mu lm nh ni mw lq nj nk my nl bi translated">输出:</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">表person和contact之间完全外部连接的输出</p></figure></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="68a5" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">结束语</h1><p id="8af2" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">希望我成功说服您放弃使用<code class="fe lv lw lx ly b">WHERE</code>子句来连接表。如果什么都没有，你已经注意到使用<code class="fe lv lw lx ly b">ON</code>子句给你的查询带来了多大的清晰度。还记得使用<code class="fe lv lw lx ly b">ON</code>子句时可以执行的其他类型的连接。</p><p id="c9a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">希望这篇文章对你有所帮助。</p><p id="907b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">知识是给世界的，所以我们分享。<br/>祝你一切顺利。下次见。</p></div></div>    
</body>
</html>