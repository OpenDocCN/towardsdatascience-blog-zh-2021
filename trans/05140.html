<html>
<head>
<title>DASK HACK: Efficiently Distributing Large Auxiliary Data Across Your Workers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">DASK HACK:在您的员工中高效地分发大型辅助数据</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/dask-hack-efficiently-distributing-large-auxiliary-data-across-your-workers-ac64ab919f9b?source=collection_archive---------39-----------------------#2021-05-05">https://towardsdatascience.com/dask-hack-efficiently-distributing-large-auxiliary-data-across-your-workers-ac64ab919f9b?source=collection_archive---------39-----------------------#2021-05-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="d78e" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何围绕每个工作人员只运行一次的函数创建延迟对象</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/25615be101f74318d83e7f47516bf2f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*__F0JOMImR_Azzh_5OATEA.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/@sortino?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">约书亚·索特诺</a>在<a class="ae kv" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">un plash</a>上拍摄的照片</p></figure><h1 id="95fe" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">TL；博士；医生</h1><p id="30f5" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated"><code class="fe mk ml mm mn b">once_per_worker</code>是一个围绕函数创建<a class="ae kv" href="https://docs.dask.org/en/latest/delayed.html" rel="noopener ugc nofollow" target="_blank">dask . delived</a>对象的实用程序，您希望每个<a class="ae kv" href="https://distributed.dask.org/en/latest/" rel="noopener ugc nofollow" target="_blank">分布式</a>工作器只运行一次。当您将一些大数据烘焙到docker图像中，并且需要将这些数据用作另一个dask操作的辅助输入时(例如，<code class="fe mk ml mm mn b">df.map_partitions</code>)，这很有用。<code class="fe mk ml mm mn b">once_per_worker</code>不需要在集群中的工作人员之间传输串行数据——因为数据的大小会比较慢——而是允许每个工作人员调用一次解析函数，然后在下游使用相同的解析对象。</p><p id="43d5" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mq lz ma mb mr md me mf ms mh mi mj ij bi translated">请参见下面的用例。</p><div class="mt mu gp gr mv mw"><a href="https://github.com/gjoseph92/once-per-worker" rel="noopener  ugc nofollow" target="_blank"><div class="mx ab fo"><div class="my ab mz cl cj na"><h2 class="bd ir gy z fp nb fr fs nc fu fw ip bi translated">gjoseph 92/每名员工一次</h2><div class="nd l"><h3 class="bd b gy z fp nb fr fs nc fu fw dk translated">每工作人员一次是一个实用程序，用于围绕您只希望每次运行一次的函数创建dask.delayed对象…</h3></div><div class="ne l"><p class="bd b dl z fp nb fr fs nc fu fw dk translated">github.com</p></div></div><div class="nf l"><div class="ng l nh ni nj nf nk kp mw"/></div></div></a></div><h1 id="27d9" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">用例</h1><p id="5606" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">在我的<a class="ae kv" href="https://richardpelgrim.medium.com/project-outline-detecting-arabic-misinformation-tweets-2a2839e0a4c" rel="noopener">阿拉伯语错误信息检测项目</a>中，我一直在广泛使用新的<a class="ae kv" href="https://coiled.io/" rel="noopener ugc nofollow" target="_blank">螺旋</a>平台，该平台提供了一个非常用户友好且可访问的界面，可以在云中扩展Python，以使用Dask处理大于内存的数据集。安装后，您可以用4行代码配置一个AWS集群，旋转它只需要2-3分钟，甚至不足以煮一杯咖啡！</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/d3394e6940f645d0b0cfb915b827a97e.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/1*3zxQ774VK5-yNCQI2_WaKw.gif"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">经由Giphy.com的影像</p></figure><p id="6553" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mq lz ma mb mr md me mf ms mh mi mj ij bi translated">我一直在测试这个平台的极限，对它的性能、可访问性和令人惊叹的支持团队印象深刻，每当我遇到任何问题时，他们都会迅速做出反应。(哦，还有有趣的额外福利——在测试版运行集群完全是免费的！)</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nm"><img src="../Images/d89561620e9cbd476576dfe9086781cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6CYIySCwlHEMIc20t3WcLg.png"/></div></div></figure><p id="87bb" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mq lz ma mb mr md me mf ms mh mi mj ij bi translated">我遇到的一个挑战是让我的阿拉伯语推文在云上得到满足。正如我在<a class="ae kv" rel="noopener" target="_blank" href="/arabic-nlp-unique-challenges-and-their-solutions-d99e8a87893d">我的上一篇文章</a>中所写的，为自然语言处理预处理阿拉伯文本带来了一系列挑战；其中之一是同一个字母组合(即看起来像同一个单词)可以有许多许多不同的意思。因此，为了使我们的记号变得简单，我们需要将这个<em class="nn">可能的</em>含义的范围缩减为一个；一个叫做<em class="nn">消歧</em>的过程。为此，我们使用<strong class="lq ir"> camel-tools </strong>库将每个单词与一个形态学数据库进行比较，并提取该单词最可能的版本及其词条。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="fadb" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mq lz ma mb mr md me mf ms mh mi mj ij bi translated">我遇到的问题是，这个形态学数据库非常大，当试图在云中运行这个引理满足时会出现问题。</p><p id="96f8" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mq lz ma mb mr md me mf ms mh mi mj ij bi translated">虽然形态学数据库被烘焙到Docker映像中，该映像被分发给my cluster上的所有worker，<strong class="lq ir"> Dask默认不知道每个worker已经有了它的副本</strong>。因此，当我们将我们的函数映射到Dask数据帧中的所有分区时，它将在工人之间传输序列化数据以执行它。考虑到文件的大小，这意味着执行下面的<strong class="lq ir"> map_partitions() </strong>调用非常慢。一个只有36行的dask数据帧样本花费了将近10分钟。)</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="b674" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mq lz ma mb mr md me mf ms mh mi mj ij bi translated">谢天谢地，Dask的维护者之一Gabe Joseph用这个可爱的黑客拯救了我。我将从下面的软件包回购中复制完整的描述:</p><blockquote class="nq nr ns"><p id="1c06" class="lo lp nn lq b lr mo jr lt lu mp ju lw nt mq lz ma nu mr md me nv ms mh mi mj ij bi translated"><code class="fe mk ml mm mn b">once_per_worker</code>是一个围绕函数创建<a class="ae kv" href="https://docs.dask.org/en/latest/delayed.html" rel="noopener ugc nofollow" target="_blank"> dask.delayed </a>对象的实用程序，您只希望每个<a class="ae kv" href="https://distributed.dask.org/en/latest/" rel="noopener ugc nofollow" target="_blank">分布式</a>工作进程运行一次这些函数。</p><p id="5dc3" class="lo lp nn lq b lr mo jr lt lu mp ju lw nt mq lz ma nu mr md me nv ms mh mi mj ij bi translated">假设您的docker映像中有一些大型数据(因此每个工人都有一份副本)。您需要将该数据作为另一个dask操作的辅助输入(例如，<code class="fe mk ml mm mn b">df.map_partitions</code>)。但是解析/预处理数据很慢，而且一旦加载到内存中，数据就会很大，因此每个工作线程从磁盘加载数据比在集群中的工作线程之间传输序列化数据要快。因此，您只需要为每个worker调用一次解析函数，然后在所有下游任务中为每个worker使用相同的解析对象。</p><p id="1c72" class="lo lp nn lq b lr mo jr lt lu mp ju lw nt mq lz ma nu mr md me nv ms mh mi mj ij bi translated">通过在<code class="fe mk ml mm mn b">once_per_worker</code>中包装您的预处理函数，您得到一个延迟的对象，在一个给定的worker上，它将总是解析为相同的预处理对象。您的函数在您第一次<em class="iq">访问返回值的属性</em>时被调用。</p></blockquote><p id="db0b" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mq lz ma mb mr md me mf ms mh mi mj ij bi translated">下面的代码将这个包应用于我的特定用例。概括的工作流程如下:</p><ol class=""><li id="b244" class="nw nx iq lq b lr mo lu mp lx ny mb nz mf oa mj ob oc od oe bi translated">导入<code class="fe mk ml mm mn b">once_per_worker</code>包</li><li id="41bd" class="nw nx iq lq b lr of lu og lx oh mb oi mf oj mj ob oc od oe bi translated">在一个<strong class="lq ir"> once_per_worker </strong>调用中包装你的预处理函数(它运行在你不想序列化和移动的大数据上)。</li><li id="e26e" class="nw nx iq lq b lr of lu og lx oh mb oi mf oj mj ob oc od oe bi translated">使用预处理函数作为参数来定义映射函数。</li><li id="f9ac" class="nw nx iq lq b lr of lu og lx oh mb oi mf oj mj ob oc od oe bi translated">跨分区映射映射函数。</li></ol><p id="ee24" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mq lz ma mb mr md me mf ms mh mi mj ij bi translated"><strong class="lq ir">注意:</strong>定义<strong class="lq ir"> once_per_worker </strong>对象很重要，这样映射函数就可以访问这个对象的<em class="nn">属性</em>。否则不会调用该对象！在我的具体用例中，<strong class="lq ir">loaded _ disambiguitor</strong>只在我访问它的<strong class="lq ir">时被调用。消歧()</strong>属性。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="f225" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mq lz ma mb mr md me mf ms mh mi mj ij bi translated">以这种方式处理比dask默认方式更快。在我的例子中，仅用20秒就执行了60k行！</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/1a9851014c2e4f999ce0032d139675fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/1*x7VMh6rnRyjccCWk0mfKaQ.gif"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片来自Giphy.com</p></figure><p id="1339" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mq lz ma mb mr md me mf ms mh mi mj ij bi translated">非常感谢Gabe为这个问题写了一个补丁，也非常感谢Dask/Coiled的所有人的大力支持！</p><p id="b15c" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mq lz ma mb mr md me mf ms mh mi mj ij bi translated">如果您也经常使用大于内存的数据集，那么一定要看看Coiled——我怎么推荐都不为过！</p><div class="mt mu gp gr mv mw"><a href="https://coiled.io/" rel="noopener  ugc nofollow" target="_blank"><div class="mx ab fo"><div class="my ab mz cl cj na"><h2 class="bd ir gy z fp nb fr fs nc fu fw ip bi translated">盘绕</h2><div class="nd l"><h3 class="bd b gy z fp nb fr fs nc fu fw dk translated">Coiled |使用Dask的可扩展数据科学和机器学习</h3></div><div class="ne l"><p class="bd b dl z fp nb fr fs nc fu fw dk translated">coiled.io</p></div></div></div></a></div></div></div>    
</body>
</html>