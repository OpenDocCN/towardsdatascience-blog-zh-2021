<html>
<head>
<title>Analyzing COVID Medical Papers with Azure Machine Learning and Text Analytics for Health</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 Azure 机器学习和健康文本分析分析 COVID 医学论文</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/analyzing-covid-medical-papers-with-azure-machine-learning-and-text-analytics-for-health-c87ab621a3d0?source=collection_archive---------21-----------------------#2021-10-28">https://towardsdatascience.com/analyzing-covid-medical-papers-with-azure-machine-learning-and-text-analytics-for-health-c87ab621a3d0?source=collection_archive---------21-----------------------#2021-10-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="42e6" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/thoughts-and-theory" rel="noopener" target="_blank">思想和理论</a></h2><div class=""/><div class=""><h2 id="8658" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">如何最大限度地利用人工智能，以便从海量文本语料库中提取见解</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/46ee1f3842130e2fa2a3733c3d0afeeb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mLtJK6PVkWDz3P28bjFYrQ.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">作者图片</p></figure><p id="1ef3" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">自从 COVID 疫情开始以来，已经有超过 70 万篇关于这个主题的科学论文发表了。人类研究人员不可能熟悉如此庞大的文本语料库，因此非常需要人工智能的帮助。在这篇文章中，我们将展示如何从科学论文中提取一些知识，获得洞察力，并构建一个工具来帮助研究人员以有意义的方式浏览论文集。在这个过程中，我们还会遇到一些对数据科学家有用的云工具。</p><p id="1689" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">如果您想继续下去，自己做这个实验，您可以在这里找到所有源代码和分步说明:</p><div class="ma mb gp gr mc md"><a href="http://github.com/CloudAdvocacy/AzurePaperExplorationWorkshop" rel="noopener  ugc nofollow" target="_blank"><div class="me ab fo"><div class="mf ab mg cl cj mh"><h2 class="bd ja gy z fp mi fr fs mj fu fw iz bi translated">GitHub-cloud advocate/azurepaexplorationworkshop</h2><div class="mk l"><h3 class="bd b gy z fp mi fr fs mj fu fw dk translated">在本次研讨会中，我们将探索不同的 Microsoft Azure 特性，同时研究一个重要的示例:提取…</h3></div><div class="ml l"><p class="bd b dl z fp mi fr fs mj fu fw dk translated">github.com</p></div></div><div class="mm l"><div class="mn l mo mp mq mm mr ky md"/></div></div></a></div><p id="25cb" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">如果要引用这段文字，请使用<a class="ae ms" href="https://arxiv.org/abs/2110.15453" rel="noopener ugc nofollow" target="_blank">arXiv:2110.15453</a><strong class="lg ja">【cs。CL] </strong>。</p><h1 id="8cd7" class="mt mu iq bd mv mw mx my mz na nb nc nd kf ne kg nf ki ng kj nh kl ni km nj nk bi translated">自动纸张分析</h1><p id="c266" class="pw-post-body-paragraph le lf iq lg b lh nl ka lj lk nm kd lm ln nn lp lq lr no lt lu lv np lx ly lz ij bi translated">自动科学论文分析是快速发展的研究领域，并且由于 NLP 技术的最近改进，在最近几年中已经有了很大的改进。在本帖中，我们将向您展示如何从 COVID 论文中获得具体的见解，例如医学治疗随时间的变化，或使用几种药物的联合治疗策略。</p><p id="ad74" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">我将在这篇文章中描述的主要方法是从文本中提取尽可能多的半结构化信息，然后将其存储到某个 NoSQL 数据库中以供进一步处理。将信息存储在数据库中将允许我们进行一些非常具体的查询来回答一些问题，以及为医学专家提供可视化探索工具以进行结构化搜索和洞察生成。提议系统的整体架构如下所示:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nq"><img src="../Images/e1c4fc87242366430b90beb465335195.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*rgR6wji7QEVFrtur.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">作者图片</p></figure><p id="0e28" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">我们将使用不同的 Azure 技术来深入了解纸质语料库，如<a class="ae ms" href="https://docs.microsoft.com/azure/cognitive-services/text-analytics/how-tos/text-analytics-for-health/?WT.mc_id=aiml-20447-dmitryso" rel="noopener ugc nofollow" target="_blank"> <strong class="lg ja">健康文本分析</strong> </a>、<a class="ae ms" href="https://azure.microsoft.com/services/cosmos-db/?WT.mc_id=aiml-20447-dmitryso" rel="noopener ugc nofollow" target="_blank"> <strong class="lg ja"> CosmosDB </strong> </a>和<a class="ae ms" href="https://powerbi.microsoft.com/?WT.mc_id=aiml-20447-dmitryso" rel="noopener ugc nofollow" target="_blank"> <strong class="lg ja"> PowerBI </strong> </a>。现在，让我们关注该图的各个部分，并详细讨论它们。</p><blockquote class="nr ns nt"><p id="c202" class="le lf nu lg b lh li ka lj lk ll kd lm nv lo lp lq nw ls lt lu nx lw lx ly lz ij bi translated">如果你想自己尝试文本分析，你需要一个 Azure 账户。如果你没有免费试用版<a class="ae ms" href="https://azure.microsoft.com/free/?OCID=AID3029145&amp;WT.mc_id=aiml-20447-dmitryso" rel="noopener ugc nofollow" target="_blank"><strong class="lg ja"/></a>，你可以随时获得。而且你可能还想为开发者查阅<a class="ae ms" href="https://azure.microsoft.com/overview/ai-platform/dev-resources/?OCID=AID3029145&amp;WT.mc_id=aiml-20447-dmitryso" rel="noopener ugc nofollow" target="_blank"> <strong class="lg ja">其他 AI 技术</strong> </a>。</p></blockquote><h1 id="0845" class="mt mu iq bd mv mw mx my mz na nb nc nd kf ne kg nf ki ng kj nh kl ni km nj nk bi translated">COVID 科学论文和 CORD 数据集</h1><p id="1291" class="pw-post-body-paragraph le lf iq lg b lh nl ka lj lk nm kd lm ln nn lp lq lr no lt lu lv np lx ly lz ij bi translated">将自然语言处理方法应用于科学文献的想法似乎很自然。首先，科学文本已经是结构良好的了，它们包含关键词、摘要以及定义明确的术语。因此，在 COVID 疫情的最开始，一个<a class="ae ms" href="https://www.kaggle.com/allen-institute-for-ai/CORD-19-research-challenge" rel="noopener ugc nofollow" target="_blank"> <strong class="lg ja">研究挑战已经在 Kaggle </strong> </a>上启动，以分析关于该主题的科学论文。这场比赛背后的数据集被称为<a class="ae ms" href="https://www.semanticscholar.org/cord19" rel="noopener ugc nofollow" target="_blank"><strong class="lg ja">CORD</strong></a>(<a class="ae ms" href="https://arxiv.org/pdf/2004.10706.pdf" rel="noopener ugc nofollow" target="_blank"><strong class="lg ja">publication</strong></a>)，它包含了与 COVID 相关的主题中发布的所有内容的不断更新的语料库。</p><p id="dd67" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">该数据集由以下部分组成:</p><ul class=""><li id="e58b" class="ny nz iq lg b lh li lk ll ln oa lr ob lv oc lz od oe of og bi translated"><strong class="lg ja">元数据文件</strong> <a class="ae ms" href="https://www.kaggle.com/allen-institute-for-ai/CORD-19-research-challenge?select=metadata.csv" rel="noopener ugc nofollow" target="_blank"> <strong class="lg ja"> Metadata.csv </strong> </a>在一个地方包含所有出版物的最重要信息。该表中的每篇论文都有唯一的标识符<code class="fe oh oi oj ok b">cord_uid</code>(事实上，一旦你真正开始使用数据集，它并不完全是唯一的)。这些信息包括:出版物名称、期刊、作者、摘要、出版日期、doi</li><li id="5e99" class="ny nz iq lg b lh ol lk om ln on lr oo lv op lz od oe of og bi translated"><strong class="lg ja">全文论文</strong>在<code class="fe oh oi oj ok b">document_parses</code>目录下，用 JSON 格式的结构化文本表示，这大大简化了分析。</li><li id="d753" class="ny nz iq lg b lh ol lk om ln on lr oo lv op lz od oe of og bi translated">预构建的<strong class="lg ja">文档嵌入</strong>，它将<code class="fe oh oi oj ok b">cord_uid</code>映射到反映论文整体语义的浮点向量。</li></ul><p id="e55a" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">在本帖中，我们将关注论文摘要，因为它们包含了论文中最重要的信息。然而，对于数据集的完整分析，在全文上使用相同的方法肯定是有意义的。</p><h1 id="9aa2" class="mt mu iq bd mv mw mx my mz na nb nc nd kf ne kg nf ki ng kj nh kl ni km nj nk bi translated">AI 能用文字做什么？</h1><p id="bb60" class="pw-post-body-paragraph le lf iq lg b lh nl ka lj lk nm kd lm ln nn lp lq lr no lt lu lv np lx ly lz ij bi translated">近年来，自然语言处理领域取得了巨大的进步，已经训练出了非常强大的神经网络语言模型。在 NLP 领域，通常会考虑以下任务:</p><ul class=""><li id="11bf" class="ny nz iq lg b lh li lk ll ln oa lr ob lv oc lz od oe of og bi translated"><strong class="lg ja">文本分类/意图识别— </strong>在这个任务中，我们需要将一段文本分成若干类别。这是一个典型的分类任务。</li><li id="3a5d" class="ny nz iq lg b lh ol lk om ln on lr oo lv op lz od oe of og bi translated"><strong class="lg ja">情感分析— </strong>我们需要返回一个数字，显示文本的积极或消极程度。这是一个典型的回归任务。</li><li id="7d8a" class="ny nz iq lg b lh ol lk om ln on lr oo lv op lz od oe of og bi translated"><strong class="lg ja">命名实体识别</strong>(NER)——在 NER，我们需要从文本中提取命名实体，并确定它们的类型。例如，我们可能在寻找药品名称或诊断。另一个类似于 NER 的任务是<strong class="lg ja">关键词提取</strong>。</li><li id="da45" class="ny nz iq lg b lh ol lk om ln on lr oo lv op lz od oe of og bi translated"><strong class="lg ja">文本摘要— </strong>这里我们希望能够产生原始文本的简短版本，或者选择最重要的文本片段。</li><li id="3ef2" class="ny nz iq lg b lh ol lk om ln on lr oo lv op lz od oe of og bi translated"><strong class="lg ja">问答— </strong>在这个任务中，我们被给予一段文字和一个问题，我们的目标是从文字中找到这个问题的确切答案。</li><li id="de22" class="ny nz iq lg b lh ol lk om ln on lr oo lv op lz od oe of og bi translated"><strong class="lg ja">开放领域问答</strong>(ODQA)——与之前任务的主要区别在于，我们得到了一个大的文本语料库，我们需要在整个语料库的某个地方找到我们问题的答案。</li></ul><blockquote class="nr ns nt"><p id="ccf4" class="le lf nu lg b lh li ka lj lk ll kd lm nv lo lp lq nw ls lt lu nx lw lx ly lz ij bi translated">在我之前的一篇文章 中，我描述了我们如何使用 ODQA 方法自动找到特定 COVID 问题的答案。然而，这种方法不适合严肃的研究。</p></blockquote><p id="51ef" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">要从文本中获得一些见解，NER 似乎是最突出的技巧。如果我们能够理解文本中存在的特定实体，我们就可以在文本中执行语义丰富的搜索，回答特定的问题，并获得不同实体共现的数据，找出我们感兴趣的特定场景。</p><p id="5181" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">为了训练 NER 模型以及任何其他神经语言模型，我们需要一个适当标记的相当大的数据集。找到这些数据集通常不是一件容易的事情，为新的问题领域生成数据集通常需要最初的人工努力来标记数据。</p><h1 id="9be8" class="mt mu iq bd mv mw mx my mz na nb nc nd kf ne kg nf ki ng kj nh kl ni km nj nk bi translated">预先训练的语言模型</h1><p id="cd84" class="pw-post-body-paragraph le lf iq lg b lh nl ka lj lk nm kd lm ln nn lp lq lr no lt lu lv np lx ly lz ij bi translated">幸运的是，现代的<a class="ae ms" href="https://en.wikipedia.org/wiki/Transformer_(machine_learning_model)" rel="noopener ugc nofollow" target="_blank"> <strong class="lg ja">变压器语言模型</strong> </a>可以使用迁移学习以半监督的方式进行训练。首先，基础语言模型(例如，<a class="ae ms" rel="noopener" target="_blank" href="/bert-explained-state-of-the-art-language-model-for-nlp-f8b21a9b6270"> <strong class="lg ja"> BERT </strong> </a>)首先在大型文本语料库上训练，然后可以在较小的数据集上专门用于特定的任务，例如分类或 NER。</p><p id="bb42" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">该迁移学习过程还可以包含额外的步骤——在特定领域数据集上进一步训练通用预训练模型。例如，在医学科学领域，微软研究院使用 PubMed 知识库中的文本，预先训练了一个名为<a class="ae ms" href="https://huggingface.co/microsoft/BiomedNLP-PubMedBERT-base-uncased-abstract" rel="noopener ugc nofollow" target="_blank"><strong class="lg ja">PubMed Bert</strong></a>(<a class="ae ms" href="https://arxiv.org/abs/2007.15779" rel="noopener ugc nofollow" target="_blank"><strong class="lg ja">publication</strong></a>)的模型。如果我们有一些专门的数据集可用，那么这个模型可以进一步用于不同的特定任务。</p><h1 id="6d88" class="mt mu iq bd mv mw mx my mz na nb nc nd kf ne kg nf ki ng kj nh kl ni km nj nk bi translated">文本分析认知服务</h1><p id="fad6" class="pw-post-body-paragraph le lf iq lg b lh nl ka lj lk nm kd lm ln nn lp lq lr no lt lu lv np lx ly lz ij bi translated">然而，除了数据集之外，训练模型还需要大量的技能和计算能力。微软(以及其他一些大型云供应商)也通过 REST API 提供一些预先训练好的模型。这些服务被称为<a class="ae ms" href="https://azure.microsoft.com/services/cognitive-services/?WT.mc_id=aiml-20447-dmitryso" rel="noopener ugc nofollow" target="_blank"> <strong class="lg ja">认知服务</strong> </a>，其中一个处理文本的服务被称为<a class="ae ms" href="https://azure.microsoft.com/services/cognitive-services/text-analytics/?WT.mc_id=aiml-20447-dmitryso" rel="noopener ugc nofollow" target="_blank"> <strong class="lg ja">文本分析</strong> </a>。它可以执行以下操作:</p><ul class=""><li id="26c1" class="ny nz iq lg b lh li lk ll ln oa lr ob lv oc lz od oe of og bi translated"><strong class="lg ja">关键词提取</strong>和 NER 用于一些常见的实体类型，如人、组织、日期/时间等。</li><li id="ae8f" class="ny nz iq lg b lh ol lk om ln on lr oo lv op lz od oe of og bi translated"><strong class="lg ja">情感分析</strong></li><li id="cf36" class="ny nz iq lg b lh ol lk om ln on lr oo lv op lz od oe of og bi translated"><strong class="lg ja">语言检测</strong></li><li id="cd68" class="ny nz iq lg b lh ol lk om ln on lr oo lv op lz od oe of og bi translated"><strong class="lg ja">实体链接</strong>，通过自动添加互联网链接到一些最常见的实体。这也执行了<strong class="lg ja">歧义消除</strong>，例如<em class="nu">火星</em>既可以指行星也可以指巧克力棒，正确的链接将根据上下文使用。</li></ul><p id="5a29" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">例如，让我们来看看通过文本分析分析的一篇医学论文摘要:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oq"><img src="../Images/7feb9929811de780f0b2b6a7bc11d669.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*56YyQf49HR1e5rsL.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">作者图片</p></figure><p id="5f6d" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">正如你所看到的，一些特定的实体(例如，HCQ，它是羟氯喹的缩写)根本没有被识别出来，而其他的则分类很差。幸运的是，微软提供了特别版的<a class="ae ms" href="https://docs.microsoft.com/azure/cognitive-services/text-analytics/how-tos/text-analytics-for-health/?WT.mc_id=aiml-20447-dmitryso" rel="noopener ugc nofollow" target="_blank"> <strong class="lg ja">健康文本分析</strong> </a>。</p><h1 id="99c8" class="mt mu iq bd mv mw mx my mz na nb nc nd kf ne kg nf ki ng kj nh kl ni km nj nk bi translated">健康文本分析</h1><p id="13d0" class="pw-post-body-paragraph le lf iq lg b lh nl ka lj lk nm kd lm ln nn lp lq lr no lt lu lv np lx ly lz ij bi translated">面向健康的文本分析是一种认知服务，它公开了预训练的 PubMedBERT 模型以及一些附加功能。以下是使用健康文本分析从同一段文本中提取实体的结果:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi or"><img src="../Images/7853f68dc5d08a1cdfdaf250b0b46b91.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*lCst3rBAI8RbgH0d.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">作者图片</p></figure><p id="2608" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">要执行分析，我们可以使用最新版本的<a class="ae ms" href="https://github.com/Azure/azure-sdk-for-python/blob/master/sdk/textanalytics/azure-ai-textanalytics/README.md" rel="noopener ugc nofollow" target="_blank"> <strong class="lg ja">文本分析 Python SDK </strong> </a>，我们需要先安装:</p><pre class="kp kq kr ks gt os ok ot ou aw ov bi"><span id="db1e" class="ow mu iq ok b gy ox oy l oz pa">pip install azure.ai.textanalytics</span></pre><p id="7791" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">该服务可以分析一堆<strong class="lg ja">文本文档</strong>，一次最多 10 个。您可以传递文档列表或字典。假设我们在<code class="fe oh oi oj ok b">txt</code>变量中有一个摘要文本，我们可以使用下面的代码来分析它:</p><pre class="kp kq kr ks gt os ok ot ou aw ov bi"><span id="8b47" class="ow mu iq ok b gy ox oy l oz pa">poller <strong class="ok ja">=</strong> client.begin_analyze_healthcare_entities([txt])<br/>res <strong class="ok ja">=</strong> list(poller.result())<br/><strong class="ok ja">print</strong>(res)</span></pre><blockquote class="nr ns nt"><p id="7250" class="le lf nu lg b lh li ka lj lk ll kd lm nv lo lp lq nw ls lt lu nx lw lx ly lz ij bi translated">在进行这个调用之前，您需要创建<code class="fe oh oi oj ok b">TextAnalyticsClient</code>对象，传递您的端点和访问键。你从认知服务/文本分析 Azure 资源中获得这些价值，你需要通过门户或命令行在你的 Azure 订阅<a class="ae ms" href="https://ms.portal.azure.com/#create/Microsoft.CognitiveServicesTextAnalytics" rel="noopener ugc nofollow" target="_blank">中创建这些价值。</a></p></blockquote><p id="18e1" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">除了实体列表之外，我们还会得到以下内容:</p><ul class=""><li id="00d0" class="ny nz iq lg b lh li lk ll ln oa lr ob lv oc lz od oe of og bi translated"><strong class="lg ja">实体映射</strong>实体到标准医学本体，如<a class="ae ms" href="https://www.nlm.nih.gov/research/umls/index.html" rel="noopener ugc nofollow" target="_blank"><strong class="lg ja"/></a>。</li><li id="ba12" class="ny nz iq lg b lh ol lk om ln on lr oo lv op lz od oe of og bi translated"><strong class="lg ja">文本内部实体之间的关系</strong>，如<code class="fe oh oi oj ok b">TimeOfCondition</code>等。</li><li id="dbf7" class="ny nz iq lg b lh ol lk om ln on lr oo lv op lz od oe of og bi translated"><strong class="lg ja">否定</strong>，表示实体用于否定语境，例如<em class="nu">新冠肺炎诊断没有发生</em>。</li></ul><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi pb"><img src="../Images/6da7febc9ee1f8ceca1c18006919bf1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aR4eg0LLfkry694iCupCyg.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">作者图片</p></figure><p id="9e28" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">除了使用 Python SDK，还可以直接使用 REST API 调用文本分析。如果您使用的编程语言没有相应的 SDK，或者如果您更喜欢接收 JSON 格式的文本分析结果以便进一步存储或处理，这将非常有用。在 Python 中，这可以通过使用<code class="fe oh oi oj ok b">requests</code>库轻松完成:</p><pre class="kp kq kr ks gt os ok ot ou aw ov bi"><span id="c9f9" class="ow mu iq ok b gy ox oy l oz pa">uri <strong class="ok ja">=</strong> f"{endpoint}/text/analytics/v3.1/entities/<br/>         health/jobs?model-version=v3.1"<br/>headers <strong class="ok ja">=</strong> { "Ocp-Apim-Subscription-Key" : key }<br/>resp <strong class="ok ja">=</strong> requests.post(uri,headers<strong class="ok ja">=</strong>headers,data<strong class="ok ja">=</strong>doc)<br/>res <strong class="ok ja">=</strong> resp.json()<br/><strong class="ok ja">if</strong> res['status'] <strong class="ok ja">==</strong> 'succeeded':<br/>    result <strong class="ok ja">=</strong> t['results']<br/><strong class="ok ja">else</strong>:<br/>    result <strong class="ok ja">=</strong> None</span></pre><p id="7f56" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">生成的 JSON 文件将如下所示:</p><pre class="kp kq kr ks gt os ok ot ou aw ov bi"><span id="3d7a" class="ow mu iq ok b gy ox oy l oz pa">{"id": "jk62qn0z",<br/> "entities": [<br/>    {"offset": 24, "length": 28, "text": "coronavirus disease pandemic", <br/>     "category": "Diagnosis", "confidenceScore": 0.98, <br/>     "isNegated": <strong class="ok ja">false</strong>}, <br/>    {"offset": 54, "length": 8, "text": "COVID-19", <br/>     "category": "Diagnosis", "confidenceScore": 1.0, "isNegated": <strong class="ok ja">false</strong>, <br/>     "links": [<br/>       {"dataSource": "UMLS", "id": "C5203670"}, <br/>       {"dataSource": "ICD10CM", "id": "U07.1"}, ... ]},<br/> "relations": [<br/>    {"relationType": "Abbreviation", "bidirectional": <strong class="ok ja">true</strong>, <br/>     "source": "#/results/documents/2/entities/6", <br/>     "target": "#/results/documents/2/entities/7"}, ...],<br/>}</span></pre><blockquote class="nr ns nt"><p id="3bdf" class="le lf nu lg b lh li ka lj lk ll kd lm nv lo lp lq nw ls lt lu nx lw lx ly lz ij bi translated"><strong class="lg ja">注意:</strong>在生产中，您可能希望包含一些代码，以便在服务返回错误时重试操作。有关正确实现认知服务 REST 客户端的更多指导，您可以<a class="ae ms" href="https://github.com/Azure/azure-sdk-for-python/tree/master/sdk/textanalytics/azure-ai-textanalytics/azure/ai/textanalytics" rel="noopener ugc nofollow" target="_blank"> <strong class="lg ja">查看 Azure Python SDK 的源代码</strong> </a>，或者使用<a class="ae ms" href="https://swagger.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="lg ja"> Swagger </strong> </a>生成客户端代码。</p></blockquote><h1 id="e0cf" class="mt mu iq bd mv mw mx my mz na nb nc nd kf ne kg nf ki ng kj nh kl ni km nj nk bi translated">并行处理所有文件</h1><p id="15e8" class="pw-post-body-paragraph le lf iq lg b lh nl ka lj lk nm kd lm ln nn lp lq lr no lt lu lv np lx ly lz ij bi translated">由于数据集目前包含 80 万篇论文摘要，通过文本分析按顺序处理它们将非常耗时，可能需要几天时间。要并行运行这段代码，我们可以使用<a class="ae ms" href="https://docs.microsoft.com/azure/batch/?WT.mc_id=aiml-20447-dmitryso" rel="noopener ugc nofollow" target="_blank"> <strong class="lg ja"> Azure Batch </strong> </a>或者<a class="ae ms" href="https://azure.microsoft.com/services/machine-learning/?WT.mc_id=aiml-20447-dmitryso" rel="noopener ugc nofollow" target="_blank"><strong class="lg ja">Azure Machine Learning</strong></a><strong class="lg ja">等技术。</strong>它们都允许您创建一个相同虚拟机的集群，并在所有虚拟机上并行运行相同的代码。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi pc"><img src="../Images/75433057f6124800696cdb235a9c41af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qt6SGTpDX5shHgH1w2Fqjg.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">作者图片</p></figure><p id="239c" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">Azure 机器学习是一项旨在满足数据科学家所有需求的服务。它通常用于培训和部署模型和 ML 管道；但是，我们也可以使用它在一个计算集群上运行我们的并行扫描作业。为此，我们需要提交一个<code class="fe oh oi oj ok b">sweep_job</code>实验。</p><p id="ce11" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">有几种方法可以使用 Azure ML 并提交实验:</p><ul class=""><li id="a1fe" class="ny nz iq lg b lh li lk ll ln oa lr ob lv oc lz od oe of og bi translated">通过 Azure 门户进行交互。这可能最适合初学者，但不容易复制或记录。</li><li id="6502" class="ny nz iq lg b lh ol lk om ln on lr oo lv op lz od oe of og bi translated">使用<a class="ae ms" href="https://docs.microsoft.com/python/api/overview/azure/ml/?view=azure-ml-py&amp;WT.mc_id=academic-47617-dmitryso" rel="noopener ugc nofollow" target="_blank"><strong class="lg ja">Azure ML Python SDK</strong></a><strong class="lg ja">。它允许你通过代码定义一个实验的所有属性，然而，Python 代码似乎有很多样板文件。</strong></li><li id="dffc" class="ny nz iq lg b lh ol lk om ln on lr oo lv op lz od oe of og bi translated">从<a class="ae ms" href="https://docs.microsoft.com/cli/azure/ml?view=azure-cli-latest&amp;WT.mc_id=academic-47617-dmitryso" rel="noopener ugc nofollow" target="_blank"> <strong class="lg ja">命令行</strong> </a>，使用<a class="ae ms" href="https://docs.microsoft.com/azure/machine-learning/reference-yaml-overview&amp;WT.mc_id=academic-47617-dmitryso" rel="noopener ugc nofollow" target="_blank"> <strong class="lg ja"> YAML 文件</strong> </a>来定义参数。这是目前推荐的方法。</li><li id="a691" class="ny nz iq lg b lh ol lk om ln on lr oo lv op lz od oe of og bi translated">来自<a class="ae ms" href="https://docs.microsoft.com/en-us/azure/machine-learning/how-to-setup-vs-code/?WT.mc_id=academic-47617-dmitryso" rel="noopener ugc nofollow" target="_blank"><strong class="lg ja">Visual Studio Code Azure ML Extension</strong></a><strong class="lg ja"/>—它本质上与上面的方法非常相似，但是 VS Code 通过提供自动完成选项来帮助您简化所有配置文件的创作，它还可以为您提交命令。</li></ul><p id="ca95" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">首先，我们需要创建一个 Azure 机器学习工作区，以及一个运行实验的集群。这是通过<a class="ae ms" href="https://docs.microsoft.com/cli/azure/?WT.mc_id=academic-33679-dmitryso" rel="noopener ugc nofollow" target="_blank"> Azure CLI </a>完成的:</p><pre class="kp kq kr ks gt os ok ot ou aw ov bi"><span id="3177" class="ow mu iq ok b gy ox oy l oz pa"><strong class="ok ja">$ </strong>az ml workspace create -w AzMLWorkspace -l westus -g MyGroup<br/><strong class="ok ja">$ </strong>az ml compute create –n AzMLCompute --size Standard_NC <br/>      --max-node-count 8</span></pre><p id="ee43" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">我们还需要将我们的 CORD 数据集上传到 Azure ML 中。我们首先用 YAML 文件<code class="fe oh oi oj ok b">data_metacord</code>定义数据集:</p><pre class="kp kq kr ks gt os ok ot ou aw ov bi"><span id="5d55" class="ow mu iq ok b gy ox oy l oz pa">name: metacord<br/>version: 1<br/>local_path: Metadata.csv</span></pre><p id="4bd8" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">然后我们将数据集上传到云端:</p><pre class="kp kq kr ks gt os ok ot ou aw ov bi"><span id="a658" class="ow mu iq ok b gy ox oy l oz pa"><strong class="ok ja">$ </strong>az ml data create -f data_metacord.yml</span></pre><p id="429a" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">我们还需要定义脚本运行的环境。环境本质上是一个容器，可以通过指定一个起始容器并在其上应用一些附加配置来定义。这里，我们在<code class="fe oh oi oj ok b">env.yml</code>中定义一个环境:</p><pre class="kp kq kr ks gt os ok ot ou aw ov bi"><span id="c0e5" class="ow mu iq ok b gy ox oy l oz pa">name: cognitive-env<br/>version: 1<br/>docker:<br/>    image: mcr.microsoft.com/azureml/base:intelmpi2018.3-ubuntu16.04<br/>conda_file: <br/>    file:./cognitive_conda.yml</span></pre><p id="6e4e" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">我们从一个标准的 Azure ML Ubuntu 容器开始，并在<code class="fe oh oi oj ok b">cognitive_conda.yml</code>中指定额外的 Python 依赖项:</p><pre class="kp kq kr ks gt os ok ot ou aw ov bi"><span id="dc9c" class="ow mu iq ok b gy ox oy l oz pa">channels:<br/>  - conda<br/>dependencies:<br/>  - python=3.8<br/>  - pip<br/>  - pip:<br/>    - azure-cosmos<br/>    - azure.ai.textanalytics<br/>    - requests</span></pre><p id="6969" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">我们通过跑步来创造环境</p><pre class="kp kq kr ks gt os ok ot ou aw ov bi"><span id="7d15" class="ow mu iq ok b gy ox oy l oz pa">az ml environment create -f env.yml</span></pre><p id="5cee" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">为了定义一个清扫任务，我们将使用下面的 YAML 文件<code class="fe oh oi oj ok b">sweepexp.yml</code>:</p><pre class="kp kq kr ks gt os ok ot ou aw ov bi"><span id="957d" class="ow mu iq ok b gy ox oy l oz pa">experiment_name: sweep_experiment<br/>algorithm: grid<br/>type: sweep_job<br/>search_space:<br/>  number:<br/>     type: choice<br/>     values: [0,1,2,3,4,5,6,7]<br/>trial:<br/>   command: python process.py <br/>     --number {search_space.number} <br/>     --nodes 8<br/>     --data {inputs.metacord}<br/>   inputs:<br/>      metacord:<br/>        data: azureml:metacord:1<br/>        mode: download<br/>   code:<br/>    local_path: .<br/>   environment: azureml:cognitive-env:1<br/>   compute:<br/>      target: azureml:AzMLCompute<br/>max_concurrent_trials: 8<br/>timeout_minutes: 10000</span></pre><p id="3aaf" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">这里我们用整数参数<code class="fe oh oi oj ok b">number</code>定义一个搜索空间，取值从 0 到 7。我们允许最多 8 个并发运行，每个运行将包括调用<code class="fe oh oi oj ok b">process.py</code>脚本，向其传递数据集的命令行参数，并发运行的总数和单独运行<code class="fe oh oi oj ok b">--number</code>，其范围从 0 到 7。</p><blockquote class="nr ns nt"><p id="0cca" class="le lf nu lg b lh li ka lj lk ll kd lm nv lo lp lq nw ls lt lu nx lw lx ly lz ij bi translated">注意，我们还在这里指定了环境名和计算机名。如果您使用带有 Azure ML 扩展的 Visual Studio 代码来创建这些脚本，您可以使用自动完成(按 Ctrl-Space)来填充字段的名称和必需的值(如可用的计算名称、容器名称等)。)自动。</p></blockquote><p id="7496" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">处理逻辑将编码在 Python 脚本中，大致如下:</p><pre class="kp kq kr ks gt os ok ot ou aw ov bi"><span id="ffb7" class="ow mu iq ok b gy ox oy l oz pa">## process command-line arguments using ArgParse<br/>…<br/>df = pd.read_csv(args.data) # Get metadata.csv into Pandas DF</span><span id="f84b" class="ow mu iq ok b gy pd oy l oz pa">## Connect to the database<br/>coscli <strong class="ok ja">=</strong> azure.cosmos.CosmosClient(cosmos_uri, credential<strong class="ok ja">=</strong>cosmoskey)<br/>cosdb <strong class="ok ja">=</strong> coscli.get_database_client("CORD")<br/>cospapers <strong class="ok ja">=</strong> cosdb.get_container_client("Papers")</span><span id="1b7a" class="ow mu iq ok b gy pd oy l oz pa">## Process papers<br/><strong class="ok ja">for </strong>i,(id,x) <strong class="ok ja">in </strong>enumerate(df.iterrows()):<br/>   if i%args.nodes == args.number: # process only portion of record<br/>   # Process the record using REST call (see code above)<br/>   # Store the JSON result in the database<br/>   cospapers.upsert_item(json)</span></pre><blockquote class="nr ns nt"><p id="d5be" class="le lf nu lg b lh li ka lj lk ll kd lm nv lo lp lq nw ls lt lu nx lw lx ly lz ij bi translated">为了简单起见，我们不会在这里展示完整的脚本</p></blockquote><h1 id="6144" class="mt mu iq bd mv mw mx my mz na nb nc nd kf ne kg nf ki ng kj nh kl ni km nj nk bi translated">使用 CosmosDB 存储分析结果</h1><p id="1471" class="pw-post-body-paragraph le lf iq lg b lh nl ka lj lk nm kd lm ln nn lp lq lr no lt lu lv np lx ly lz ij bi translated">使用上面的代码，我们获得了一个论文集合，每个论文都有许多实体和对应关系。这种结构本质上是分层的，存储和处理它的最佳方式是使用 NoSQL 方法进行数据存储。在 Azure 中，<a class="ae ms" href="https://azure.microsoft.com/services/cosmos-db/?WT.mc_id=aiml-20447-dmitryso" rel="noopener ugc nofollow" target="_blank"> <strong class="lg ja"> Cosmos DB </strong> </a>是一个通用数据库，可以存储和查询类似我们的 JSON 集合的半结构化数据，因此将所有 JSON 文件上传到 Cosmos DB 集合是有意义的。上面显示的代码演示了如何从并行运行的处理脚本中将 JSON 文档直接存储到 CosmosDB 数据库中。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi pe"><img src="../Images/8ccdf70162c3b512234be17de1efa708.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*jcxd8RbtPn5RrFtN.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">作者图片</p></figure><blockquote class="nr ns nt"><p id="7b09" class="le lf nu lg b lh li ka lj lk ll kd lm nv lo lp lq nw ls lt lu nx lw lx ly lz ij bi translated">我们假设您已经创建了一个名为“CORD”的 Cosmos DB 数据库，并获得了进入<code class="fe oh oi oj ok b">cosmos_uri</code>和<code class="fe oh oi oj ok b">cosmoskey</code>变量所需的凭证。</p></blockquote><p id="b976" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">运行完这段代码后，我们将以容器<code class="fe oh oi oj ok b">Papers</code>结束所有元数据。我们现在可以在 Azure Portal 中使用这个容器，方法是转到<strong class="lg ja">数据浏览器</strong>:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi pf"><img src="../Images/50614a4f8d2ac5c5383fbbdd6b241837.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*AiU9wgmjcALmHNdl.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">作者图片</p></figure><p id="89d0" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">现在我们可以使用<a class="ae ms" href="https://docs.microsoft.com/azure/cosmos-db/sql-query-getting-started/?WT.mc_id=aiml-20447-dmitryso" rel="noopener ugc nofollow" target="_blank"> <strong class="lg ja"> Cosmos DB SQL </strong> </a>来查询我们的集合。例如，下面是我们如何获得语料库中所有药物的列表:</p><pre class="kp kq kr ks gt os ok ot ou aw ov bi"><span id="d0ce" class="ow mu iq ok b gy ox oy l oz pa"><em class="nu">-- unique medication names</em><br/><strong class="ok ja">SELECT</strong> <strong class="ok ja">DISTINCT</strong> e.text <br/><strong class="ok ja">FROM</strong> papers p <br/><strong class="ok ja">JOIN</strong> e <strong class="ok ja">IN</strong> p.entities <br/><strong class="ok ja">WHERE</strong> e.category<strong class="ok ja">=</strong>'MedicationName'</span></pre><p id="dcca" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">使用 SQL，我们可以制定一些非常具体的查询。假设，一位医学专家想要找出一种特定药物的所有建议剂量(比如说<strong class="lg ja">羟氯喹</strong>)，并查看所有提到这些剂量的论文。这可以使用以下查询来完成:</p><pre class="kp kq kr ks gt os ok ot ou aw ov bi"><span id="023a" class="ow mu iq ok b gy ox oy l oz pa"><em class="nu">-- dosage of specific drug with paper titles</em><br/><strong class="ok ja">SELECT</strong> p.title, r.source.text<br/><strong class="ok ja">FROM</strong> papers p <strong class="ok ja">JOIN</strong> r <strong class="ok ja">IN</strong> p.relations <br/><strong class="ok ja">WHERE</strong> r.relationType<strong class="ok ja">=</strong>'DosageOfMedication' <br/><strong class="ok ja">AND</strong> r.target.text <strong class="ok ja">LIKE </strong>'hydro%'</span></pre><p id="6b39" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">更困难的任务是选择所有实体以及它们相应的本体 ID。这将是非常有用的，因为最终我们希望能够引用一个特定的实体(<em class="nu">羟氯喹</em>)，而不管它在论文中被提及的方式(例如，<em class="nu"> HCQ </em>也指同一种药物)。我们将使用 UMLS 作为我们的主要本体。</p><pre class="kp kq kr ks gt os ok ot ou aw ov bi"><span id="d85e" class="ow mu iq ok b gy ox oy l oz pa"><em class="nu">--- get entities with UMLS IDs</em><br/><strong class="ok ja">SELECT</strong> e.category, e.text, <br/>  ARRAY (<strong class="ok ja">SELECT</strong> VALUE l.id <br/>         <strong class="ok ja">FROM</strong> l <strong class="ok ja">IN</strong> e.links <br/>         <strong class="ok ja">WHERE</strong> l.dataSource<strong class="ok ja">=</strong>'UMLS')[0] <strong class="ok ja">AS</strong> umls_id <br/><strong class="ok ja">FROM</strong> papers p <strong class="ok ja">JOIN</strong> e <strong class="ok ja">IN</strong> p.entities</span></pre><h1 id="38c1" class="mt mu iq bd mv mw mx my mz na nb nc nd kf ne kg nf ki ng kj nh kl ni km nj nk bi translated">创建交互式仪表板</h1><p id="246e" class="pw-post-body-paragraph le lf iq lg b lh nl ka lj lk nm kd lm ln nn lp lq lr no lt lu lv np lx ly lz ij bi translated">虽然能够使用 SQL 查询来获得一些特定问题的答案，如药物剂量，似乎是一个非常有用的工具——但对于没有很高 SQL 掌握水平的非 it 专业人员来说，这并不方便。为了使医疗专业人员能够访问元数据集合，我们可以使用<a class="ae ms" href="https://powerbi.microsoft.com/?WT.mc_id=aiml-20447-dmitryso" rel="noopener ugc nofollow" target="_blank"> <strong class="lg ja"> PowerBI </strong> </a>工具来创建一个用于实体/关系探索的交互式仪表板。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi pg"><img src="../Images/cd00d21b04c2630a90156a3e0d40d3a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*_2PSum0sRBLEMyHl.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">作者图片</p></figure><p id="aa79" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">在上面的例子中，您可以看到不同实体的仪表板。用户可以在左侧选择所需的实体类型(例如，本例中的<strong class="lg ja">药物名称</strong>，并在右侧观察该类型的所有实体及其数量。您还可以在表格中看到相关的 IDs in，并且从上面的例子中可以注意到几个实体可以引用同一个本体 ID ( <em class="nu">羟氯喹</em>和<em class="nu"> HCQ </em>)。</p><p id="8ba6" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">要制作这个仪表盘，我们需要使用<a class="ae ms" href="https://powerbi.microsoft.com/desktop/?WT.mc_id=aiml-20447-dmitryso" rel="noopener ugc nofollow" target="_blank"> <strong class="lg ja"> PowerBI 桌面</strong> </a>。首先，我们需要导入 Cosmos DB 数据——这些工具支持从 Azure 直接导入数据。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ph"><img src="../Images/cfe86df991dd248bf3f65f801e301fcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*eFG6wqrlMs_lYOIc.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">作者图片</p></figure><p id="ae71" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">然后，我们提供 SQL 查询来获取具有相应 UMLS id 的所有实体——如上所示——以及另一个查询来显示所有唯一的类别。然后我们将这两个表拖到 PowerBI 画布上，得到上面显示的仪表板。该工具自动理解两个表由一个名为<strong class="lg ja">类别</strong>的字段链接，并支持基于第一个表中的选择过滤第二个表的功能。</p><p id="7bc6" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">同样，我们可以创建一个工具来查看关系:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi pi"><img src="../Images/c7cc51c3431958cb2c20d6eeb61b8a32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*IW9cVhae-nKz63Hn.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">作者图片</p></figure><p id="c9e8" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">从这个工具中，我们可以进行类似于上面在 SQL 中进行的查询，以确定特定药物的剂量。为此，我们需要在左侧表格中选择<strong class="lg ja">药物剂量</strong>关系类型，然后根据我们想要的药物过滤右侧表格。还可以创建进一步的下钻表格，以显示提及选定药物剂量的特定论文，使该工具成为医学科学家的有用研究工具。</p><h1 id="8ea6" class="mt mu iq bd mv mw mx my mz na nb nc nd kf ne kg nf ki ng kj nh kl ni km nj nk bi translated">获得自动洞察</h1><p id="09c9" class="pw-post-body-paragraph le lf iq lg b lh nl ka lj lk nm kd lm ln nn lp lq lr no lt lu lv np lx ly lz ij bi translated">然而，故事最有趣的部分是从文本中得出一些自动的见解，例如随着时间的推移医疗策略的变化。为此，我们需要用 Python 编写更多的代码来进行适当的数据分析。最方便的方法是使用嵌入 Cosmos DB 的<strong class="lg ja">笔记本:</strong></p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi pj"><img src="../Images/83d71aeab715e83819f02e6c4fc7ec11.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*GRrL9eETh1M-xlVz.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">作者图片</p></figure><p id="964c" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">那些笔记本支持嵌入式 SQL 查询；因此，我们能够执行 SQL 查询，然后将结果放入 Pandas DataFrame，这是 Python 固有的数据浏览方式:</p><pre class="kp kq kr ks gt os ok ot ou aw ov bi"><span id="2d2a" class="ow mu iq ok b gy ox oy l oz pa"><strong class="ok ja">%%sql</strong> <em class="nu">--database CORD --container Papers --output meds</em><br/><strong class="ok ja">SELECT</strong> e.text, e.isNegated, p.title, p.publish_time,<br/>       ARRAY (<strong class="ok ja">SELECT</strong> VALUE l.id <strong class="ok ja">FROM</strong> l <br/>              <strong class="ok ja">IN</strong> e.links <br/>              <strong class="ok ja">WHERE</strong> l.dataSource<strong class="ok ja">=</strong>'UMLS')[0] <strong class="ok ja">AS</strong> umls_id <br/><strong class="ok ja">FROM</strong> papers p <br/><strong class="ok ja">JOIN</strong> e <strong class="ok ja">IN</strong> p.entities<br/><strong class="ok ja">WHERE</strong> e.category <strong class="ok ja">=</strong> 'MedicationName'</span></pre><p id="d760" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">这里我们以<code class="fe oh oi oj ok b">meds</code>数据框架结束，包含药物名称，以及相应的论文标题和出版日期。我们可以根据本体 ID 进一步分组，以获得不同药物的提及频率:</p><pre class="kp kq kr ks gt os ok ot ou aw ov bi"><span id="bbee" class="ow mu iq ok b gy ox oy l oz pa">unimeds <strong class="ok ja">=</strong> meds.groupby('umls_id') \<br/>              .agg({'text' : <strong class="ok ja">lambda</strong> x : ','.join(x), <br/>                    'title' : 'count', <br/>                    'isNegated' : 'sum'})<br/>unimeds['negativity'] <strong class="ok ja">=</strong> unimeds['isNegated'] <strong class="ok ja">/</strong> unimeds['title']<br/>unimeds['name'] <strong class="ok ja">=</strong> unimeds['text'] \<br/>                  .apply(<strong class="ok ja">lambda</strong> x: x <strong class="ok ja">if</strong> ',' <strong class="ok ja">not</strong> <strong class="ok ja">in</strong> x <br/>                                     <strong class="ok ja">else</strong> x[:x.find(',')])<br/>unimeds.sort_values('title',ascending<strong class="ok ja">=</strong>False).drop('text',axis<strong class="ok ja">=</strong>1)</span></pre><p id="7983" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">这为我们提供了下表:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi pk"><img src="../Images/8488d6f1c5bf43aa416b2fb90b2fcf18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VQA2Bbb64bO6ATJbZWuenw.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">作者图片</p></figure><p id="4935" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">从该表中，我们可以选择 15 种最常提及的药物:</p><pre class="kp kq kr ks gt os ok ot ou aw ov bi"><span id="e0a7" class="ow mu iq ok b gy ox oy l oz pa">top <strong class="ok ja">=</strong> { <br/>    x[0] : x[1]['name'] <strong class="ok ja">for</strong> i,x <strong class="ok ja">in</strong> zip(range(15),<br/>      unimeds.sort_values('title',ascending<strong class="ok ja">=</strong>False).iterrows())<br/>}</span></pre><p id="6325" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">为了了解药物的提及频率如何随时间变化，我们可以计算每月提及次数的平均值:</p><pre class="kp kq kr ks gt os ok ot ou aw ov bi"><span id="a390" class="ow mu iq ok b gy ox oy l oz pa"><em class="nu"># First, get table with only top medications <br/></em>imeds <strong class="ok ja">=</strong> meds[meds['umls_id'].apply(<strong class="ok ja">lambda</strong> x: x <strong class="ok ja">in</strong> top.keys())].copy()<br/>imeds['name'] <strong class="ok ja">=</strong> imeds['umls_id'].apply(<strong class="ok ja">lambda</strong> x: top[x])</span><span id="588b" class="ow mu iq ok b gy pd oy l oz pa"><em class="nu"># Create a computable field with month<br/></em>imeds['month'] <strong class="ok ja">=</strong> imeds['publish_time'].astype('datetime64[M]')</span><span id="8c8e" class="ow mu iq ok b gy pd oy l oz pa"><em class="nu"># Group by month<br/></em>medhist <strong class="ok ja">=</strong> imeds.groupby(['month','name']) \<br/>          .agg({'text' : 'count', <br/>                'isNegated' : [positive_count,negative_count] })</span></pre><p id="2567" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">这为我们提供了一个数据框架，其中包含每个月对药物的正面和负面提及次数。从那里，我们可以使用<code class="fe oh oi oj ok b">matplotlib</code>绘制相应的图形:</p><pre class="kp kq kr ks gt os ok ot ou aw ov bi"><span id="6e91" class="ow mu iq ok b gy ox oy l oz pa">medh <strong class="ok ja">=</strong> medhist.reset_index()<br/>fig,ax <strong class="ok ja">=</strong> plt.subplots(5,3)<br/><strong class="ok ja">for</strong> i,n <strong class="ok ja">in</strong> enumerate(top.keys()):<br/>    medh[medh['name']<strong class="ok ja">==</strong>top[n]] \<br/>    .set_index('month')['isNegated'] \<br/>    .plot(title<strong class="ok ja">=</strong>top[n],ax<strong class="ok ja">=</strong>ax[i<strong class="ok ja">//</strong>3,i<strong class="ok ja">%</strong>3])<br/>fig.tight_layout()</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi pl"><img src="../Images/c82aed92f3c66c6909dc35de3afd11c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*FMkDr-tFbcQYQg2s.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">作者图片</p></figure><h1 id="5bdb" class="mt mu iq bd mv mw mx my mz na nb nc nd kf ne kg nf ki ng kj nh kl ni km nj nk bi translated">可视化术语共现</h1><p id="d208" class="pw-post-body-paragraph le lf iq lg b lh nl ka lj lk nm kd lm ln nn lp lq lr no lt lu lv np lx ly lz ij bi translated">另一个有趣的发现是观察哪些术语经常一起出现。为了可视化这种依赖关系，有两种类型的图表:</p><ul class=""><li id="b671" class="ny nz iq lg b lh li lk ll ln oa lr ob lv oc lz od oe of og bi translated"><strong class="lg ja">桑基图</strong>允许我们调查两类术语之间的关系，例如诊断和治疗</li><li id="acfc" class="ny nz iq lg b lh ol lk om ln on lr oo lv op lz od oe of og bi translated"><strong class="lg ja">弦图</strong>有助于可视化同类型术语的共现(例如，哪些药物被一起提及)</li></ul><p id="e1d2" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">为了绘制这两个图，我们需要计算<strong class="lg ja">共现矩阵</strong>，该矩阵在行<code class="fe oh oi oj ok b">i</code>和列<code class="fe oh oi oj ok b">j</code>中包含术语<code class="fe oh oi oj ok b">i</code>和<code class="fe oh oi oj ok b">j</code>在同一摘要中的共现次数(可以注意到这个矩阵是对称的)。我们计算的方法是为我们的本体手动选择相对少量的术语，如果需要，将一些术语组合在一起:</p><pre class="kp kq kr ks gt os ok ot ou aw ov bi"><span id="c2ff" class="ow mu iq ok b gy ox oy l oz pa">treatment_ontology <strong class="ok ja">=</strong> {<br/> 'C0042196': ('vaccination',1),<br/> 'C0199176': ('prevention',2),<br/> 'C0042210': ('vaccines',1), ... }</span><span id="eaf3" class="ow mu iq ok b gy pd oy l oz pa">diagnosis_ontology <strong class="ok ja">=</strong> {<br/> 'C5203670': ('COVID-19',0),<br/> 'C3714514': ('infection',1),<br/> 'C0011065': ('death',2),<br/> 'C0042769': ('viral infections',1),<br/> 'C1175175': ('SARS',3),<br/> 'C0009450': ('infectious disease',1), ...}</span></pre><p id="8a82" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">然后，我们定义一个函数来计算由这些本体字典指定的两个类别的共现矩阵:</p><pre class="kp kq kr ks gt os ok ot ou aw ov bi"><span id="5124" class="ow mu iq ok b gy ox oy l oz pa"><strong class="ok ja">def</strong> <strong class="ok ja">get_matrix</strong>(cat1, cat2):<br/>    d1 <strong class="ok ja">=</strong> {i:j[1] <strong class="ok ja">for</strong> i,j <strong class="ok ja">in</strong> cat1.items()}<br/>    d2 <strong class="ok ja">=</strong> {i:j[1] <strong class="ok ja">for</strong> i,j <strong class="ok ja">in</strong> cat2.items()}<br/>    s1 <strong class="ok ja">=</strong> set(cat1.keys())<br/>    s2 <strong class="ok ja">=</strong> set(cat2.keys())<br/>    a <strong class="ok ja">=</strong> np.zeros((len(cat1),len(cat2)))<br/>    <strong class="ok ja">for</strong> i <strong class="ok ja">in</strong> all_papers:<br/>        ent <strong class="ok ja">=</strong> get_entities(i)<br/>        <strong class="ok ja">for</strong> j <strong class="ok ja">in</strong> ent <strong class="ok ja">&amp;</strong> s1:<br/>            <strong class="ok ja">for</strong> k <strong class="ok ja">in</strong> ent <strong class="ok ja">&amp;</strong> s2 :<br/>                a[d1[j],d2[k]] <strong class="ok ja">+=</strong> 1<br/>    <strong class="ok ja">return</strong> a</span></pre><p id="4860" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">这里，<code class="fe oh oi oj ok b">get_entities</code>函数返回论文中提到的所有实体的 UMLS id 列表，而<code class="fe oh oi oj ok b">all_papers</code>是返回论文摘要元数据完整列表的生成器。</p><p id="519d" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">为了实际绘制桑基图，我们可以使用<a class="ae ms" href="https://plotly.com/python/" rel="noopener ugc nofollow" target="_blank"> <strong class="lg ja"> Plotly </strong> </a>图形库。这个过程在<a class="ae ms" href="https://plotly.com/python/sankey-diagram/" rel="noopener ugc nofollow" target="_blank"> <strong class="lg ja">这里</strong> </a>有很好的描述，不再赘述。结果如下:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi pm"><img src="../Images/bbececc7e3f9556bc9dbc6888785992c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*rOQpsM_t-SjZ0BHJ.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">作者图片</p></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi pm"><img src="../Images/d6d796a728b6fef9cedaee2c01bbdbfc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*NUDuvV4IxUTFkcw6.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">作者图片</p></figure><p id="2c22" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">用 Plotly 绘制和弦图并不容易，但可以用一个不同的库— <a class="ae ms" href="https://pypi.org/project/chord/" rel="noopener ugc nofollow" target="_blank"> <strong class="lg ja"> Chord </strong> </a>来完成。主要思想保持不变——我们使用上述相同的函数构建共现矩阵，传递相同的本体两次，然后将该矩阵传递给<code class="fe oh oi oj ok b">Chord</code>:</p><pre class="kp kq kr ks gt os ok ot ou aw ov bi"><span id="4f4f" class="ow mu iq ok b gy ox oy l oz pa"><strong class="ok ja">def</strong> <strong class="ok ja">chord</strong>(cat):<br/>    matrix <strong class="ok ja">=</strong> get_matrix(cat,cat)<br/>    np.fill_diagonal(matrix,0)<br/>    names <strong class="ok ja">=</strong> cat.keys()<br/>    Chord(matrix.tolist(), names, font_size <strong class="ok ja">=</strong> "11px").to_html()</span></pre><p id="9412" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">治疗类型和药物的弦图结果如下:</p><div class="kp kq kr ks gt ab cb"><figure class="pn kt po pp pq pr ps paragraph-image"><img src="../Images/3d40ec0215a96b9dbfc1a95d15590f31.png" data-original-src="https://miro.medium.com/v2/resize:fit:940/format:webp/0*wN66InpItm_BpGee.png"/></figure><figure class="pn kt pt pp pq pr ps paragraph-image"><img src="../Images/08f049c4b4696260345270a227a8797b.png" data-original-src="https://miro.medium.com/v2/resize:fit:928/format:webp/0*014ihINt6P8Bnm3Z.png"/><p class="la lb gj gh gi lc ld bd b be z dk pu di pv pw translated">作者图片</p></figure></div><p id="04d3" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">右图显示了哪些药物被一起提及(在同一摘要中)。我们可以看到那些众所周知的组合，如<strong class="lg ja">羟氯喹+阿奇霉素</strong>，清晰可见。</p><h1 id="2c08" class="mt mu iq bd mv mw mx my mz na nb nc nd kf ne kg nf ki ng kj nh kl ni km nj nk bi translated">结论</h1><p id="b337" class="pw-post-body-paragraph le lf iq lg b lh nl ka lj lk nm kd lm ln nn lp lq lr no lt lu lv np lx ly lz ij bi translated">在这篇文章中，我们描述了一个用于从大型医学文本语料库中提取知识的概念验证系统的架构。我们使用 Text Analytics for Health 来执行从文本中提取实体和关系的主要任务，然后一些 Azure 服务一起为医学科学家构建查询并提取一些视觉洞察。这个帖子目前还是概念性的，可以通过在 PowerBI 模块中提供更详细的下钻功能，以及对提取的实体/关系集合进行更多的数据探索来进一步改进系统。切换到处理全文也会很有意思，在这种情况下，我们需要考虑术语共现的稍微不同的标准(例如，在同一段落与同一篇论文中)。</p><p id="cb9b" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">同样的方法可以应用于其他科学领域，但我们需要准备训练一个定制的神经网络模型来执行实体提取。这个任务已经在上面简要地描述过了(当我们谈到 BERT 的使用时)，我将在我的下一篇文章中集中讨论它。同时，如果你正在做类似的研究，或者对代码和/或方法有任何具体的问题，请随时联系我。</p></div></div>    
</body>
</html>