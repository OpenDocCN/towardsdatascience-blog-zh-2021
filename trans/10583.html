<html>
<head>
<title>Three Python Built-In Function Tricks Reducing Our Workloads</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">三个Python内置函数技巧减少了我们的工作量</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/three-python-built-in-function-tricks-reducing-our-workloads-60fe54c55cf3?source=collection_archive---------2-----------------------#2021-10-10">https://towardsdatascience.com/three-python-built-in-function-tricks-reducing-our-workloads-60fe54c55cf3?source=collection_archive---------2-----------------------#2021-10-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/51c02e9eb40b01310ac23ae58fb12758.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aRnM3jrOH7bIOjV9ta2bJQ.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">图片来自<a class="ae jg" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=6599328" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>的<a class="ae jg" href="https://pixabay.com/users/jonleong64-21259161/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=6599328" rel="noopener ugc nofollow" target="_blank">梁家杰</a></p></figure><div class=""/><div class=""><h2 id="632a" class="pw-subtitle-paragraph kg ji jj bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dk translated">一颗隐藏的宝石——Python functools+decorator</h2></div><p id="ae7a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在我之前的一篇博客中，我介绍了Python functools中的一个装饰器，它可以自动缓存递归函数和web请求的中间结果。我们需要做的只是在函数定义中添加一个装饰器。</p><div class="is it gp gr iu lu"><a rel="noopener follow" target="_blank" href="/you-should-never-repeat-computing-in-python-b097d57cf661"><div class="lv ab fo"><div class="lw ab lx cl cj ly"><h2 class="bd jk gy z fp lz fr fs ma fu fw ji bi translated">你不应该在Python中重复计算</h2><div class="mb l"><h3 class="bd b gy z fp lz fr fs ma fu fw dk translated">Python中的内置函数工具帮助我们缓存</h3></div><div class="mc l"><p class="bd b dl z fp lz fr fs ma fu fw dk translated">towardsdatascience.com</p></div></div><div class="md l"><div class="me l mf mg mh md mi ja lu"/></div></div></a></div><p id="4cc4" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在本文中，我将介绍functools模块中三个更有用的特性。所有这些都可以节省我们键入大量代码的时间，更重要的是，使我们的代码整洁，可读性更好。还是那句话，这些都是Python 3.7以上内置的，我们不需要下载任何东西。</p><p id="a4b5" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请注意，本文中的所有代码示例都基于functools模块，导入如下。</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="7bb4" class="ms mt jj mo b gy mu mv l mw mx">from functools import *</span></pre><p id="a1ea" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在您的情况下，可能没有必要导入所有内容。您可能只想导入特定的对象。</p><h1 id="7284" class="my mt jj bd mz na nb nc nd ne nf ng nh kp ni kq nj ks nk kt nl kv nm kw nn no bi translated">1.总订购量</h1><figure class="mj mk ml mm gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/cdc1d303a64343faf9506dfbf98f1de2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OZeKp6bNScstENeo7lfWdw.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">图片由<a class="ae jg" href="https://pixabay.com/users/mamaclown-6746727/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=2862708" rel="noopener ugc nofollow" target="_blank"> Janine Bolon </a>提供，来自<a class="ae jg" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=2862708" rel="noopener ugc nofollow" target="_blank"> Pixabay </a></p></figure><p id="b70f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我要介绍的第一个是“总订购”。它是一个用于类定义的装饰器。</p><p id="6d1e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当我们定义一个类时，我们希望该类中的实例可以互相比较，比如大于、等于和小于。然后，我们将不得不实现相应的方法，如<code class="fe np nq nr mo b">__gt__()</code>、<code class="fe np nq nr mo b">__lt__()</code>和<code class="fe np nq nr mo b">__eq__()</code>。如果我们希望这个类能够处理所有的比较情况，我们就必须实现所有这些方法:</p><ul class=""><li id="57e0" class="ns nt jj la b lb lc le lf lh nu ll nv lp nw lt nx ny nz oa bi translated">等于:<code class="fe np nq nr mo b">__eq__()</code></li><li id="edc4" class="ns nt jj la b lb ob le oc lh od ll oe lp of lt nx ny nz oa bi translated">大于:<code class="fe np nq nr mo b">__gt__()</code></li><li id="c003" class="ns nt jj la b lb ob le oc lh od ll oe lp of lt nx ny nz oa bi translated">小于:<code class="fe np nq nr mo b">__lt__()</code></li><li id="1e08" class="ns nt jj la b lb ob le oc lh od ll oe lp of lt nx ny nz oa bi translated">大于或等于:<code class="fe np nq nr mo b">__ge__()</code></li><li id="2eea" class="ns nt jj la b lb ob le oc lh od ll oe lp of lt nx ny nz oa bi translated">小于或等于:<code class="fe np nq nr mo b">__le__()</code></li></ul><p id="994f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们看看下面的例子。假设我们正在为雇员定义一个类。我们想根据员工的年龄来比较他们。</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="9692" class="ms mt jj mo b gy mu mv l mw mx">class Employee:<br/>    def __init__(self, name, age):<br/>        self.name = name<br/>        self.age = age</span><span id="c89b" class="ms mt jj mo b gy og mv l mw mx">def __lt__(self, other):<br/>        return self.age &lt; other.age</span><span id="298d" class="ms mt jj mo b gy og mv l mw mx">def __eq__(self, other):<br/>        return self.age == other.age</span></pre><p id="e4a9" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请注意，我只定义了“小于”和“等于”的方法。</p><p id="8e13" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，让我们来看看这个雇员类的实例。</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="4e07" class="ms mt jj mo b gy mu mv l mw mx">e1 = Employee('Alice', 30)<br/>e2 = Employee('Bob', 28)</span></pre><p id="fdce" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，如果我们用小于或等于来比较它们，就不会有任何问题了。</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="ea3a" class="ms mt jj mo b gy mu mv l mw mx">print(e1 &lt; e2)<br/>print(e1 == e2)</span></pre><figure class="mj mk ml mm gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oh"><img src="../Images/5600dcab78d8dcc75d3d6648968fe611.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g-r4CWZ7UC40kJ8NOY0LdA.png"/></div></div></figure><p id="54a6" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">由于我们从未为“小于或等于”实现过<code class="fe np nq nr mo b">__le__()</code>，下面的比较将会失败。</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="bb0a" class="ms mt jj mo b gy mu mv l mw mx">print(e1 &lt;= e2)</span></pre><figure class="mj mk ml mm gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oi"><img src="../Images/70eb3e471b220a7b3e8d76309398a03e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OhQDvxiZMYFKpudGX03dVw.png"/></div></div></figure><p id="bd7a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这种情况下，功能工具“总排序”会有所帮助。我们需要做的就是向类中添加一个装饰器，如下所示。</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="1888" class="ms mt jj mo b gy mu mv l mw mx"><a class="ae jg" href="http://twitter.com/total_ordering" rel="noopener ugc nofollow" target="_blank">@total_ordering</a><br/>class Employee:<br/>    def __init__(self, name, age):<br/>        self.name = name<br/>        self.age = age</span><span id="0ef1" class="ms mt jj mo b gy og mv l mw mx">def __lt__(self, other):<br/>        return self.age &lt; other.age</span><span id="1c83" class="ms mt jj mo b gy og mv l mw mx">def __eq__(self, other):<br/>        return self.age == other.age</span></pre><p id="7a2d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，我们可以用任何方式比较Employee类的两个实例。</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="7659" class="ms mt jj mo b gy mu mv l mw mx">print(e1 &lt; e2)<br/>print(e1 &gt; e2)<br/>print(e1 == e2)<br/>print(e1 &lt;= e2)<br/>print(e1 &gt;= e2)</span></pre><figure class="mj mk ml mm gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oj"><img src="../Images/9a6b25979a6c22056c13441cafaeb44b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7rPqzg6lhJpjv0gNlNTdKg.png"/></div></div></figure><p id="b948" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于全排序，我们只需要实现相等的<code class="fe np nq nr mo b">__eq__()</code>和<code class="fe np nq nr mo b">__gt__()</code>、<code class="fe np nq nr mo b">__lt__()</code>、<code class="fe np nq nr mo b">__ge__()</code>或<code class="fe np nq nr mo b">__le__()</code>中的任意一个。总排序函数工具将帮助我们获得所有其他比较结果。</p><p id="733a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">还请注意，这个装饰器可能不会用在对性能敏感的应用程序中，因为它确实评估了多个比较函数，以便“导出”最终结果。比如我们已经定义了“小于”和“等于”。在后台，如果我们比较两个具有“小于或等于”条件的对象，总排序将对它们进行评估。</p><h1 id="4b5f" class="my mt jj bd mz na nb nc nd ne nf ng nh kp ni kq nj ks nk kt nl kv nm kw nn no bi translated">2.部分功能</h1><figure class="mj mk ml mm gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/1caf567a726934b2119fbd7e5555c1ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pf4VX5Xhpgq18ugLhxFQwg.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">图片来自<a class="ae jg" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=889904" rel="noopener ugc nofollow" target="_blank">pix abay</a>Julio césar velásquez mejía</p></figure><p id="3c17" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你有没有定义过几个签名非常相似的函数，做着非常相似的事情？有时候，我们可能需要考虑在Python中使用partial函数。</p><p id="431a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我来举个例子。假设我们想从一个句子中找出所有以“A”开头的单词。我们可以纠正这样一个函数。</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="3d79" class="ms mt jj mo b gy mu mv l mw mx">def find_A_words(txt):<br/>    return re.findall(r'A\w+', txt)</span></pre><p id="7869" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="ok">请注意，定义这样一个函数可能没有必要，但我只想有一个简单的函数，因为正则表达式不是重点。</em></p><p id="5c73" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，我们想定义另一个函数来检测以“B”开头的单词。所以，我们可以这样定义另一个。</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="9b95" class="ms mt jj mo b gy mu mv l mw mx">def find_B_words(txt):<br/>    return re.findall(r'B\w+', txt)</span></pre><p id="6108" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以测试他们，他们应该工作。</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="2c84" class="ms mt jj mo b gy mu mv l mw mx">print(find_A_words('Apple Ate Big Bad Air Bag'))<br/>print(find_B_words('Apple Ate Big Bad Air Bag'))</span></pre><figure class="mj mk ml mm gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ol"><img src="../Images/0ddb34843458d6a893be19ccce9df873.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ufr9PN8_qI_V8gUppuzDJg.png"/></div></div></figure><p id="3ce7" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">利用Python functools模块中的partial函数，我们将find_A_words()函数和find_A_words()函数定义为<code class="fe np nq nr mo b">re.findall()</code>函数的“partial”函数。</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="17d2" class="ms mt jj mo b gy mu mv l mw mx">find_A_words = partial(re.findall, r'A\w+')<br/>find_B_words = partial(re.findall, r'B\w+')</span></pre><p id="711e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如图所示，第一个参数应该是原始函数。然后，我们可以给原函数部分参数。因此，当我们使用重新定义的部分函数时，我们只需要给出其余的自变量。</p><p id="502c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">具体来说，在这个例子中，<code class="fe np nq nr mo b">re.findall()</code>函数至少有两个参数<code class="fe np nq nr mo b">pattern</code>和<code class="fe np nq nr mo b">string</code>。我们已经使用部分函数通过了<code class="fe np nq nr mo b">pattern</code>。因此，我们在使用它时只需要给出<code class="fe np nq nr mo b">string</code>参数。</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="32e2" class="ms mt jj mo b gy mu mv l mw mx">print(find_A_words('Apple Ate Big Bad Air Bag'))<br/>print(find_B_words('Apple Ate Big Bad Air Bag'))</span></pre><figure class="mj mk ml mm gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi om"><img src="../Images/928e9c59b3733c14339d68be44dd8651.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uqsMY3orsvQYlLhGBPAJaQ.png"/></div></div></figure><p id="3ffc" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">结果与前面的实现相同。</p><h1 id="cd4a" class="my mt jj bd mz na nb nc nd ne nf ng nh kp ni kq nj ks nk kt nl kv nm kw nn no bi translated">3.单一调度</h1><figure class="mj mk ml mm gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/1e4c43159615d77a50da3a066157ffcd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AeUITlV4-3jjXSRRTa_kAw.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">图片来自<a class="ae jg" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=1511683" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>的<a class="ae jg" href="https://pixabay.com/users/siala-719262/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=1511683" rel="noopener ugc nofollow" target="_blank"> siala </a></p></figure><p id="74bd" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">有时，我们需要定义一个函数，它接受一个数据类型不确定的参数。例如，它可以是字符串、整数或其他值。通常，我们将不得不编写几个if-else案例来处理这个问题。</p><p id="cc3c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Python functools模块中的单一分派提供了解决这个问题的另一种方法。我们可以在多个函数中为不同的数据类型定义这个逻辑。有时，它会提高我们代码的可读性。</p><p id="440d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">假设我们向用户发送一条问候消息。它可以像下面这样简单。</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="ac44" class="ms mt jj mo b gy mu mv l mw mx">def greeting(name):<br/>    print(f'Hi, {name}!')</span></pre><p id="7f9f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我们把名字作为参数传递，没问题。</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="b1a1" class="ms mt jj mo b gy mu mv l mw mx">greeting('Chris')</span></pre><figure class="mj mk ml mm gt iv gh gi paragraph-image"><div class="gh gi on"><img src="../Images/ab7fb5bcdea06f6aaaeb10cb9c1bc1b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1132/format:webp/1*Ci6z934YPHGcwsWJqJXjrw.png"/></div></figure><p id="a448" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，如果我们有一个用户列表，我们想问候他们所有人，该怎么办？使用单个分派函数工具，我们可以首先使用装饰器定义函数。</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="71db" class="ms mt jj mo b gy mu mv l mw mx"><a class="ae jg" href="http://twitter.com/singledispatch" rel="noopener ugc nofollow" target="_blank">@singledispatch</a><br/>def greeting(name):<br/>    print(f'Hi, {name}!')</span></pre><p id="a22a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后，我们可以通过使用单个分派的寄存器向该函数注册更多的重载版本。</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="a897" class="ms mt jj mo b gy mu mv l mw mx"><a class="ae jg" href="http://twitter.com/greeting" rel="noopener ugc nofollow" target="_blank">@greeting</a>.register<br/>def _(name: list):<br/>    name_string = ', '.join(name)<br/>    print(f'Hi, {name_string}!')</span></pre><p id="8ac1" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请注意，函数名并不重要，所以我用了下划线。</p><p id="2035" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后，单个分派函数工具将检测签名并决定应该使用哪个函数体。</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="ee50" class="ms mt jj mo b gy mu mv l mw mx">greeting(['Alice', 'Bob', 'Chris'])</span></pre><figure class="mj mk ml mm gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oo"><img src="../Images/d382e58a9eede3685273b67fb4ffb32a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2dDaZ29BxbUmmRswZZzeDw.png"/></div></div></figure><h1 id="8eb9" class="my mt jj bd mz na nb nc nd ne nf ng nh kp ni kq nj ks nk kt nl kv nm kw nn no bi translated">摘要</h1><figure class="mj mk ml mm gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/66e0a4c42af986c2d25f069b37778494.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U2kJGay0J9rcJ2KcaUW0oA.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">图片来自<a class="ae jg" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=821500" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>的<a class="ae jg" href="https://pixabay.com/users/fancycrave1-1115284/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=821500" rel="noopener ugc nofollow" target="_blank"> fancycrave1 </a></p></figure><p id="19bb" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在本文中，我介绍了Python functools模块中的三个函数工具。这些小技巧可能会减少我们的编码工作，或者提高它的可读性。必要时使用它们！</p><div class="is it gp gr iu lu"><a href="https://medium.com/@qiuyujx/membership" rel="noopener follow" target="_blank"><div class="lv ab fo"><div class="lw ab lx cl cj ly"><h2 class="bd jk gy z fp lz fr fs ma fu fw ji bi translated">通过我的推荐链接加入灵媒-陶</h2><div class="mb l"><h3 class="bd b gy z fp lz fr fs ma fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="mc l"><p class="bd b dl z fp lz fr fs ma fu fw dk translated">medium.com</p></div></div><div class="md l"><div class="op l mf mg mh md mi ja lu"/></div></div></a></div><p id="994a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你觉得我的文章有帮助，请考虑加入Medium会员来支持我和成千上万的其他作者！(点击上面的链接)</p></div></div>    
</body>
</html>