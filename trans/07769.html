<html>
<head>
<title>Understanding A* Path Algorithms and Implementation with Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解A*路径算法并使用Python实现</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/understanding-a-path-algorithms-and-implementation-with-python-4d8458d6ccc7?source=collection_archive---------7-----------------------#2021-07-16">https://towardsdatascience.com/understanding-a-path-algorithms-and-implementation-with-python-4d8458d6ccc7?source=collection_archive---------7-----------------------#2021-07-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="ddf9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl">a*算法是最有效的路径查找算法之一，用于查找两点之间的最短路径。它由彼得·哈特、尼尔斯·尼尔森和伯特伦·拉斐尔于1968年首次出版。虽然它最初可以被看作是T2·迪杰斯特拉算法的扩展，但它已经成为今天最常用的寻路算法之一。</em></p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/bb704ce466ae4e5ffcf5d7ad31891c61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*93pSrvbUYke9n5I0fSbETA.jpeg"/></div></div><p class="ky kz gj gh gi la lb bd b be z dk translated">Via <a class="ae lc" href="https://pixabay.com/photos/forest-wood-log-nature-brown-tree-1500482/" rel="noopener ugc nofollow" target="_blank"> Pixabay </a></p></figure><p id="a95c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">A*算法基本上通过计算起始节点和结束节点之间所有其他节点的位置来达到最优结果。此外，由于启发式函数[2]，它比Dijkstra的算法更快。</p><p id="8b12" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">f(n) = g(n) + h(n)</p><p id="2397" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">f(n):计算出的路径总开销</p><p id="f89c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">g(n):第一个节点和当前节点之间的路径成本</p><p id="a11b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">h(n):启发式函数</p><p id="2764" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们想使用上面的函数找到图2中的最短路径；</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi ld"><img src="../Images/d666c0172b8463634b42922897e9ffcf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8KbswpUrSZr9jdHKu4tn7A.png"/></div></div><p class="ky kz gj gh gi la lb bd b be z dk translated">图二。样本路线</p></figure><p id="8556" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">假设我们试图从点X到达点y，由于点X没有被移动到不同的节点，g(n)成本没有发生，其值为0。这个点的启发值是写在红色节点上的值5。在这样的问题中，启发值通常是当前节点和期望节点之间的空中距离。从x点到A点有两个点<br/>在去A点的情况下，g(n) = 5(路径代价)，因为它移动到了一个新的节点。试探被设置为h(n) = 1。发现A点的f(n)值为5+1 = 6。如果我们想用这种方法找到所有点的f(n)值，</p><p id="ed7c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">X— A =&gt; g(A) + f(A) = 5 + 1 = 6，</p><p id="ef57" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">A — Y=&gt; g(Y) + f(Y) = 6+ 0= 6，</p><p id="8242" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">X— B =&gt; g(B) + f(B) = 1+ 4= 5，</p><p id="9df3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">B — C =&gt; g(C) + f(C) = 3+ 2= 5，</p><p id="3065" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">C — Y=&gt; g(Y) + f(Y) = 5 + 0= 5，</p><p id="6177" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如上面简单的例子所示，最短路径是X-B-C-Y路线。这条路的成本是5个单位，而备选的X-A-Y路线的成本是6个单位。一旦我们完全理解了如何使用上述等式，就可以更详细地研究图3中的例子。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi le"><img src="../Images/3757ff560291ad92c5bf9556d5a0f951.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YBxYjiDJ0I5enuH7rxC8hw.png"/></div></div><p class="ky kz gj gh gi la lb bd b be z dk translated">图3。示例路线v2</p></figure><p id="49af" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">假设我们想从节点j到达节点A。有2个点(B和F)，可以从点A到达。计算间接费用，我们得到f(B) = 8 + 6 = 14，f(F) = 3+6 =9。因为最小成本在F点，A*算法从这里继续。f点有2条路径，f(G) = 4 +5 = 9，f(H) = 10 + 3 = 13。因为最小成本在g点，我们可以从那点开始。然后，沿着I和J节点，我们得到f(I) = 7 + 1 = 8，f(J) = 10。由于转到F节点后得到的所有值都小于f(B)节点，所以没有返回到B节点。但是在不同的场景下，我们假设在节点F和G之后f(I)大于F(B)(F(I)&gt; 14)。在这种情况下，根据A*算法，该过程在这里被中断，并且路径继续到B节点。这里，一旦f(C) &gt; f(I)，路径确定过程再次从I节点继续。</p><h2 id="ace4" class="lf lg iq bd lh li lj dn lk ll lm dp ln jy lo lp lq kc lr ls lt kg lu lv lw lx bi translated">用Python实现</h2><p id="6c66" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">以下所有代码均可从<a class="ae lc" href="https://github.com/ademakdogan/Implementation-of-A-Algorithm-Visualization-via-Pyp5js-" rel="noopener ugc nofollow" target="_blank">https://github . com/ademakdogan/Implementation-of-A-Algorithm-Visualization-via-Pyp5js-</a>获得</p><p id="de90" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，创建网格结构。这里的一些节点被标记为障碍。然后确定开始和结束节点，并使用A*算法[3]找到这两点之间的最短路径。该算法的工作逻辑基本上基于两个名为open_set和closed_set的列表。虽然存在可以在open_set中处理的节点，但是存在在closed_set中处理的节点路径，因此不应该重复(在一些方法中，障碍也被直接扔进closed_set列表中，而在一些方法中，它可以被添加为作为对象产生的每个节点的合格属性之一。).作为各种过程的结果，这些列表被填充和清空，并到达最终结果。</p><p id="1a4d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所有阶段的伪代码都可以在<a class="ae lc" href="https://en.wikipedia.org/wiki/A*_search_algorithm" rel="noopener ugc nofollow" target="_blank">维基百科</a>上查看。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi md"><img src="../Images/882be146ceae81d14620dccbb51ca240.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*PyptNl4xejdP-RWR0XedbQ.gif"/></div></div><p class="ky kz gj gh gi la lb bd b be z dk translated">图4。A*算法示例- <a class="ae lc" href="https://github.com/ademakdogan/Implementation-of-A-Algorithm-Visualization-via-Pyp5js-" rel="noopener ugc nofollow" target="_blank">链接</a></p></figure><h2 id="6cad" class="lf lg iq bd lh li lj dn lk ll lm dp ln jy lo lp lq kc lr ls lt kg lu lv lw lx bi translated">开源代码库</h2><p id="10b1" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">图4显示了A*算法的python实现。Pyp5js库被用来可视化这项工作。此外，A*算法可以根据要具体给出的障碍列表、起始和结束节点的坐标以及网格结构的大小来工作。因此，<a class="ae lc" href="https://github.com/ademakdogan/Implementation-of-A-Algorithm-Visualization-via-Pyp5js-" rel="noopener ugc nofollow" target="_blank">这个项目</a>也可以用来对抗特定的问题。</p><pre class="kn ko kp kq gt me mf mg mh aw mi bi"><span id="a531" class="lf lg iq mf b gy mj mk l ml mm">python AStar.py -c 25 -r 25 -s 1 -q 3 -e 23 -t 21 -l True</span></pre><p id="a23e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，</p><pre class="kn ko kp kq gt me mf mg mh aw mi bi"><span id="5f83" class="lf lg iq mf b gy mj mk l ml mm">The way found!!!<br/>23 20<br/>23 19<br/>23 18<br/>23 17<br/>23 16<br/>23 15<br/>23 14<br/>23 13<br/>23 12<br/>23 11<br/>23 10<br/>23 9<br/>23 8<br/>23 7<br/>23 6<br/>23 5<br/>23 4<br/>23 3<br/>22 3<br/>21 3<br/>20 3<br/>19 3<br/>18 3<br/>17 3<br/>16 3<br/>15 3<br/>14 3<br/>13 3<br/>12 3<br/>11 3<br/>10 3<br/>9 3<br/>8 3<br/>7 3<br/>6 3<br/>5 3<br/>4 3<br/>3 3<br/>2 3<br/>1 3</span></pre><h2 id="cfb1" class="lf lg iq bd lh li lj dn lk ll lm dp ln jy lo lp lq kc lr ls lt kg lu lv lw lx bi translated">Pyp5js</h2><p id="5885" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">Pyp5js是一个在浏览器上可视化python代码的框架。它支持通过Python的Transcrypt使用p5.js javascript库。完成必要的安装后，只需使用以下命令运行即可。</p><pre class="kn ko kp kq gt me mf mg mh aw mi bi"><span id="3d99" class="lf lg iq mf b gy mj mk l ml mm">$ SKETCHBOOK_DIR<strong class="mf ir">=</strong>'~/my-custom-sketchbook' pyp5js serve</span></pre><p id="af61" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">之后，通过<a class="ae lc" href="http://localhost:5000/" rel="noopener ugc nofollow" target="_blank"> http://localhost:5000/ </a>访问接口部分进行必要的配置设置。在指定的文件夹(SKETCHBOOK_DIR)中，根据与项目名称同名的python文件中的代码执行操作。如果想详细考察这个项目，可以去https://berinhard.github.io/pyp5js/的<a class="ae lc" href="https://berinhard.github.io/pyp5js/" rel="noopener ugc nofollow" target="_blank">看看。</a></p><p id="6c78" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，A*算法是最常用的路径查找算法之一。本文讨论了该算法的工作原理及其python编码。所有代码都可以在<a class="ae lc" href="https://github.com/ademakdogan/Implementation-of-A-Algorithm-Visualization-via-Pyp5js-" rel="noopener ugc nofollow" target="_blank"> github </a>找到。pyp5js库用于可视化算法。在接下来的文章中，将讨论不同路径确定算法与A*算法的比较。</p><p id="c279" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">Github:</strong><a class="ae lc" href="https://github.com/ademakdogan" rel="noopener ugc nofollow" target="_blank">https://github.com/ademakdogan</a></p><p id="636a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">领英:</strong><a class="ae lc" href="https://www.linkedin.com/in/adem-akdo%C4%9Fan-948334177/" rel="noopener ugc nofollow" target="_blank">https://www.linkedin.com/in/adem-akdo%C4%9Fan-948334177/</a></p><h1 id="141b" class="mn lg iq bd lh mo mp mq lk mr ms mt ln mu mv mw lq mx my mz lt na nb nc lw nd bi translated">参考</h1><p id="46f3" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">[1]哈特，体育；新泽西州尼尔森；拉斐尔，B. (1968)。“启发式确定最小成本路径的形式基础”。IEEE系统科学与控制论汇刊。<strong class="jp ir">4</strong>(2):100–107。</p><p id="2203" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">[2]曾，w；丘奇，R. L. (2009年)。<a class="ae lc" href="https://zenodo.org/record/979689" rel="noopener ugc nofollow" target="_blank">“在真实道路网络上寻找最短路径:A*的情况”</a>。<em class="kl">国际地理信息科学杂志</em>。23(4):531–543。</p><p id="178c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">[3]赫特兰德，马格努斯·列(2010)，<a class="ae lc" href="https://books.google.com/books?id=9_AXCmGDiz8C&amp;pg=PA214" rel="noopener ugc nofollow" target="_blank"> <em class="kl"> Python算法:掌握Python语言中的基本算法</em> </a>，Apress，第214页，<a class="ae lc" href="https://en.wikipedia.org/wiki/ISBN_(identifier)" rel="noopener ugc nofollow" target="_blank">ISBN</a><a class="ae lc" href="https://en.wikipedia.org/wiki/Special:BookSources/9781430232377" rel="noopener ugc nofollow" target="_blank">9781430232377</a>。</p></div></div>    
</body>
</html>