<html>
<head>
<title>Python’s Data Classes Are Underrated</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python的数据类被低估了</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/pythons-data-classes-are-underrated-cc6047671a30?source=collection_archive---------9-----------------------#2021-05-26">https://towardsdatascience.com/pythons-data-classes-are-underrated-cc6047671a30?source=collection_archive---------9-----------------------#2021-05-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="67b8" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">看看Python中的数据类以及它们如何节省大量时间</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/a1b220d1100ca79614fad3eb3dfee5df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EEUIKPkdqR2O2lggQ4fA6g.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(src =<a class="ae ky" href="https://pixabay.com/images/id-1076536/" rel="noopener ugc nofollow" target="_blank">https://pixabay.com/images/id-1076536/</a></p></figure><h1 id="ef58" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">介绍</h1><p id="3ded" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在计算机编程的世界里，有许多程序员为了节省时间而使用的技术。在软件工程的世界里，时间总是一个问题，而且期限很难达到。因此，节省时间的技术非常受欢迎，更重要的是，非常有用。虽然Python可能是一种编写速度很快的语言，但是有一些方法可以加快编写Python的过程，甚至变得更快。记住这一点，请允许我向您介绍Pythonic编程的概念和对象:</p><blockquote class="mn"><p id="5c2d" class="mo mp it bd mq mr ms mt mu mv mw mm dk translated">数据类。</p></blockquote><p id="6007" class="pw-post-body-paragraph lr ls it lt b lu mx ju lw lx my jx lz ma mz mc md me na mg mh mi nb mk ml mm im bi translated">Python中的数据类是使用标准库中的工具修饰的类。dataclass装饰器@dataclass可用于向用户定义的类添加特殊方法。这样做的好处是，这是自动完成的，这意味着您可以更多地关注类中的函数，而不是关注类本身。</p><blockquote class="mn"><p id="3b77" class="mo mp it bd mq mr ms mt mu mv mw mm dk translated"><a class="ae ky" href="https://github.com/emmettgb/Emmetts-DS-NoteBooks/blob/master/Python3/Python%20DataClasses.ipynb" rel="noopener ugc nofollow" target="_blank">笔记本</a></p></blockquote></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><h1 id="98c8" class="kz la it bd lb lc nj le lf lg nk li lj jz nl ka ll kc nm kd ln kf nn kg lp lq bi translated">创建数据类</h1><p id="1a18" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">虽然dataclass decorator包含在标准库中，但像Python的许多其他组件一样，它包含在自己独特的模块中。记住，创建数据类的第一步是实际导入模块。</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="0fa6" class="nt la it np b gy nu nv l nw nx">import dataclass</span></pre><p id="7e69" class="pw-post-body-paragraph lr ls it lt b lu ny ju lw lx nz jx lz ma oa mc md me ob mg mh mi oc mk ml mm im bi translated">现在我们可以创建一个保存任意数据的新类，并用@dataclass装饰器来装饰这个类。我们将使用<a class="ae ky" href="https://www.python.org/dev/peps/pep-0526" rel="noopener ugc nofollow" target="_blank"> PEP526 </a>中描述的注释来定义这个类中的数据。</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="d492" class="nt la it np b gy nu nv l nw nx">from dataclasses import dataclass</span><span id="d9c8" class="nt la it np b gy od nv l nw nx"><a class="ae ky" href="http://twitter.com/dataclass" rel="noopener ugc nofollow" target="_blank">@dataclass</a><br/>class Food:<br/>    name: str<br/>    unit_price: float<br/>    stock: int = 0<br/>        <br/>    def stock_value(self) -&gt; float:<br/>        return(self.stock * self.unit_price)</span></pre><p id="1c0b" class="pw-post-body-paragraph lr ls it lt b lu ny ju lw lx nz jx lz ma oa mc md me ob mg mh mi oc mk ml mm im bi translated">现在我们可以通过调用这个构造函数来创建一个新类，如下所示:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="1ec3" class="nt la it np b gy nu nv l nw nx">carrot = Food("Carrot", .45, 25)</span></pre><p id="3142" class="pw-post-body-paragraph lr ls it lt b lu ny ju lw lx nz jx lz ma oa mc md me ob mg mh mi oc mk ml mm im bi translated">现在让我们看看如果我们不使用dataclass装饰器编写相同的代码会发生什么:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="0652" class="nt la it np b gy nu nv l nw nx">class Food:<br/>    name: str<br/>    unit_price: float<br/>    stock: int = 0<br/>        <br/>    def stock_value(self) -&gt; float:<br/>        return(self.stock * self.unit_price)</span><span id="2f07" class="nt la it np b gy od nv l nw nx">carrot = Food("Carrot", .45, 25)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/4fa687a4cd2197872609c3835c3709fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2OtJ3hEwzaztNDQXLUlcjw.png"/></div></div></figure><p id="6cd6" class="pw-post-body-paragraph lr ls it lt b lu ny ju lw lx nz jx lz ma oa mc md me ob mg mh mi oc mk ml mm im bi translated">我们看到，当我们调用这个构造函数时，我们得到了一个类型错误。这是因为现在我们的数据仅仅被存储为成员变量。因此，我们的__init__函数采用默认形式。默认表单不包含任何参数，这是我们试图创建数据时调用的函数。为了解决这个问题，我们需要为我们的类编写一个新的_ _ init _ _函数:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="3b05" class="nt la it np b gy nu nv l nw nx">class Food:<br/>    name: str<br/>    unit_price: float<br/>    stock: int = 0<br/>        <br/>    def __init__(self, name: str, unit_price: float, stock: int):<br/>        self.name, self.unit_price, self.stock = name, stock, unit_price<br/>    <br/>    def stock_value(self) -&gt; float:<br/>        return(self.stock * self.unit_price)</span></pre><p id="0744" class="pw-post-body-paragraph lr ls it lt b lu ny ju lw lx nz jx lz ma oa mc md me ob mg mh mi oc mk ml mm im bi translated">现在我们看到，我们可以成功地创建我们的食物类型:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="d953" class="nt la it np b gy nu nv l nw nx">carrot = Food("Carrot", .45, 25)</span></pre><p id="9ffd" class="pw-post-body-paragraph lr ls it lt b lu ny ju lw lx nz jx lz ma oa mc md me ob mg mh mi oc mk ml mm im bi translated">我们刚刚添加到函数中的所有代码都是由我们的dataclass装饰器自动添加的。不用说，这是相当可怕的！</p><h1 id="41cd" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">他们为什么伟大？</h1><p id="c881" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">现在我们对这个装饰器的作用有了基本的了解，让我们考虑一下为什么您可能想要将它应用到您的代码中。首先，您将需要编写许多不太特殊的方法。这可以节省时间，提高你的工作效率。在上面的例子中，如果我没有在一行中完成所有的自我赋值，我们可以节省四行代码。此外，每当我们调用dataclass装饰器时，这不是唯一生成的特殊函数。这意味着我们的类在编写更少的代码的同时，在特殊函数方面会更有说服力。</p><p id="4e6a" class="pw-post-body-paragraph lr ls it lt b lu ny ju lw lx nz jx lz ma oa mc md me ob mg mh mi oc mk ml mm im bi translated">使用这个装饰器的一个非常有效的优点是它避免了类中的许多混乱。将Python类中的每个值赋给成员变量的例子实际上非常普遍。当这完全可以通过简单地使用装饰器来避免时，没有什么理由用大量的<code class="fe of og oh np b">self.x = x</code>来编写整个函数。这也可以使一个类更具可读性。很容易理解为什么会这样</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="fba6" class="nt la it np b gy nu nv l nw nx"><a class="ae ky" href="http://twitter.com/dataclass" rel="noopener ugc nofollow" target="_blank">@dataclass</a><br/>class Food:<br/>    name: str<br/>    unit_price: float<br/>    stock: int = 0<br/>        <br/>    def stock_value(self) -&gt; float:<br/>        return(self.stock * self.unit_price)</span></pre><p id="527d" class="pw-post-body-paragraph lr ls it lt b lu ny ju lw lx nz jx lz ma oa mc md me ob mg mh mi oc mk ml mm im bi translated">可能比这更具可读性</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="2e95" class="nt la it np b gy nu nv l nw nx">class Food:<br/>    name: str<br/>    unit_price: float<br/>    stock: int = 0<br/>        <br/>    def __init__(self, name: str, unit_price: float, stock: int):<br/>        self.name = name</span><span id="4f2d" class="nt la it np b gy od nv l nw nx">        self.stock = stock<br/>        self.unit_price = unit_price<br/>    <br/>    def stock_value(self) -&gt; float:<br/>        return(self.stock * self.unit_price)</span></pre><p id="7713" class="pw-post-body-paragraph lr ls it lt b lu ny ju lw lx nz jx lz ma oa mc md me ob mg mh mi oc mk ml mm im bi translated">此外，使用dataclass decorator还可以将焦点放在这个函数中真正重要的地方。因为在这个类的初始化中不需要做任何事情，所以把一个大的__init__函数放在中间是没有意义的。这里的重点应该是类内部的数据和处理这些数据的函数。</p><p id="00e8" class="pw-post-body-paragraph lr ls it lt b lu ny ju lw lx nz jx lz ma oa mc md me ob mg mh mi oc mk ml mm im bi translated">最后，需要注意的是，这并不是装饰者所做的全部工作。数据类可以用来快速创建一些非常复杂的惊人结构。例如，我们也可以使用dataclasses作为JSON数据的Pythonic方法。在很多方面，我们可以把它们想象成Javascript中的数据数组。不用说，这在Python编程中很方便。考虑这个例子:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="1a5a" class="nt la it np b gy nu nv l nw nx"><a class="ae ky" href="http://twitter.com/dataclass" rel="noopener ugc nofollow" target="_blank">@dataclass</a><br/>class Point:<br/>     x: int<br/>     y: int</span><span id="5a11" class="nt la it np b gy od nv l nw nx">p = Point(10, 20)<br/>assert dataclasses.asdict(p) == {'x': 10, 'y': 20}</span></pre><p id="efb0" class="pw-post-body-paragraph lr ls it lt b lu ny ju lw lx nz jx lz ma oa mc md me ob mg mh mi oc mk ml mm im bi translated">在这里，我们将一个类转换成一个包含这两个值的字典。这两个基本上已经成为等价的数据类型，它们的定义需要大约相同的时间。编写一个比字典还快的类似乎是不可能的，但是在上面的例子中我们做到了。不用说，这些肯定会派上用场。对于我们这些处理大量数据的人来说尤其如此。</p><h1 id="eedb" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">结论</h1><p id="1f9d" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">总的来说，数据类太棒了！如果你想了解更多关于数据类的内容，你可以查看<a class="ae ky" href="https://www.python.org/dev/peps/pep-0557/" rel="noopener ugc nofollow" target="_blank"> PEP557 </a>来获得关于数据类和使用它们的全面的信息来源。有很多很好的理由将这些实现到您的代码中。这不仅可以让你的代码更容易阅读，而且也让你的代码更容易编写！感谢您的阅读，我希望这个装饰器将带您踏上Python之旅！</p></div></div>    
</body>
</html>