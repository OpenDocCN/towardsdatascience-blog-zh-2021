<html>
<head>
<title>Making Numba Accessible for Faster Processing with Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使Numba可访问，以便用Python进行更快的处理</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/making-numba-accessible-for-faster-processing-with-python-77a4377576c?source=collection_archive---------28-----------------------#2021-09-24">https://towardsdatascience.com/making-numba-accessible-for-faster-processing-with-python-77a4377576c?source=collection_archive---------28-----------------------#2021-09-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="f64f" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">克服Numba的局限性，并以明智的方式使用它</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/153d52c7d074c67f2812bbbc3a8d6c32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*KFyJZo9v_spDenao"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">克里斯里德在<a class="ae kv" href="https://unsplash.com/s/photos/python?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="7e4c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Numba是一个针对Python的实时编译器，可以通过计算密集型的计算和函数(如NumPy数组上的循环)来加速代码。</p><p id="2e7e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Numba编译的算法可以使Python代码的运行时间加快一百万倍，从而可以达到c的速度。此外，随着操作数量的增加，计算时间通常比Cython快得多，cyt hon是另一种用于更快处理的编译器。这里有一篇参考文章，展示了Python、Cython和Numba处理之间的精确比较。使用Numba也非常容易，只需将Numba decorators (@njit)应用于Python函数。</p><h2 id="0719" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">Numba的局限性及其克服方法</h2><p id="f543" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">但是，Numba有一定的局限性。虽然它在NumPy数组上工作得最好，但它可能无法被pandas对象或list参数列表、一些NumPy函数(如numpy.concatenate或numpy.diff)访问，或者更重要的是，无法被一些流行的python库(如Scipy)访问。在这种情况下，使用Numba和Cython/Python函数以智能的方式重构代码可以大大提高处理速度。</p><p id="6d04" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，我将向您展示一个使用Numba和Cython/Python进行重构的示例，该示例旨在借助Scipy函数从任何1D信号中生成峰值屏蔽。在这里，我使用质谱数据作为示例数据集，它显示了肽的强度与质量/电荷的关系。如果您想对这些数据有更深入的了解，参考文章(张等，2009)可能会对您有所帮助。使用Cython/Python函数通过Scipy库进行峰值检测，然后使用Numba进行其余计算，结果证明这是一种高度优化且省时的方法。</p><p id="9918" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一些Scipy函数有一些Numba替代函数，比如scipy.integrate.quad的numbaducpack和scipy.optimize.root的NumbaMinpack。对于这些，建议在Cython和Numba之间分割总的处理，因为，</p><p id="2413" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">两者都被证明可以显著提高Python代码的速度</p><p id="6ae6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Scipy代码可以用Cython编译</p><p id="702f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">随着运算次数的增加，Numba的速度比Cython快。</p><p id="ccd7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是Jupyter notebook中编写的一段简单代码的示例，它通过使用Scipy.signal的find_peaks和peak_prominences函数来检测信号(_data_slice)的峰值。在Cythonized单元格中，手动添加每个变量的类型，最后将信号全长的强度值(int_array)的numpy版本、峰值点(作为peaks_array)、检测到的峰值的左右基点(分别作为left_bases_array和right_bases_array)传递给Numba函数</p><h2 id="2687" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">Cython函数</h2><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="aace" class="ls lt iq mr b gy mv mw l mx my">%load_ext Cython</span><span id="9d1e" class="ls lt iq mr b gy mz mw l mx my">%%cython <br/>from scipy.signal import find_peaks, peak_prominences<br/>cimport numpy as cnp<br/>cnp.import_array()<br/>import numpy as np</span><span id="a6fd" class="ls lt iq mr b gy mz mw l mx my">cpdef <strong class="mr ir">peak_finder_cy</strong>(cnp.ndarray _data_slice, _scan_no, int int_index = 0):</span><span id="eec3" class="ls lt iq mr b gy mz mw l mx my">    cdef cnp.ndarray _int<br/>    cdef cnp.ndarray _peaks<br/>    cdef cnp.ndarray _prominences<br/>    cdef cnp.ndarray peak_mask<br/>    cdef int wlen<br/>    cdef cnp.ndarray int_array<br/>    cdef cnp.ndarray left_bases_array<br/>    cdef cnp.ndarray right_bases_array<br/>    cdef cnp.ndarray peaks_list_array</span><span id="1d63" class="ls lt iq mr b gy mz mw l mx my">    _int = _ms1_data_slice[_data_slice[:, 4] == _scan_no, int_index]<br/>    _peaks, _ = find_peaks(_int)<br/>    prominences, left_bases, right_bases = peak_prominences(_int,   _peaks, wlen=20)         <br/>    <br/>    int_array = np.array(_int)<br/>    peaks_array = np.array(_peaks)    <br/>    left_bases_array = np.array(left_bases)<br/>    right_bases_array = np.array(right_bases)</span><span id="8e22" class="ls lt iq mr b gy mz mw l mx my">    return int_array, peaks_array, left_bases_array,        right_bases_array</span></pre><h2 id="cc4a" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">数字函数</h2><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="231b" class="ls lt iq mr b gy mv mw l mx my">import numba as nb</span><span id="49c2" class="ls lt iq mr b gy mz mw l mx my"><a class="ae kv" href="http://twitter.com/nb" rel="noopener ugc nofollow" target="_blank">@nb</a>.njit()<br/>def <strong class="mr ir">peak_mask_finder_cy</strong>(_int_list, _peaks_list, _left_bases_list, _right_bases_list):   <br/>    peak_id = 1<br/>    peak_mask = np.zeros(_int_list)<br/>    j = 0<br/>    for j in nb.prange(_peaks_list):                <br/>        if j &gt; 0 and _left_bases_list[j] &lt; _right_bases_list[j-1] and _int_list[_peaks_list[j]] &gt; _int_list[_peaks_list[j-1]]:<br/>            _left_bases_list[j] = _right_bases_list[j-1]             <br/>                <br/>        peak_mask[_left_bases_list[j] + 1 : _right_bases_list[j]] = peak_id<br/>        peak_id += 1<br/>    return peak_mask</span></pre><h2 id="3d48" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">调用各自的函数</h2><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="8e84" class="ls lt iq mr b gy mv mw l mx my">%%timeit<br/>int_list, peaks_list, left_bases_list, right_bases_list = <strong class="mr ir">peak_finder_cy</strong>(signal_data, scan_no)</span><span id="065a" class="ls lt iq mr b gy mz mw l mx my">peak_mask_final = <strong class="mr ir">peak_mask_finder_cy</strong>(int_list, peaks_list, left_bases_list, right_bases_list)</span></pre><p id="b39a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">使用Cython和Numba的处理时间</strong></p><p id="7b1b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">每圈39.2 s 120 ns(平均标准偏差。戴夫。7次运行，每次10000个循环)</p><p id="5c51" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">仅使用cy thon</strong></p><p id="3dda" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">每循环101 s 178 ns(平均标准偏差。戴夫。7次运行，每次10000个循环)</p><p id="f2d6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，即使对于一小块数据，与仅基于Cython的代码相比，使用带有Cython和Numba的重构代码在处理时间上的改进也是显著的。随着从更大体积的数据集中检测到的峰的数量的增加，两者之间的处理时间差异可能会更加突出和显著。</p><p id="d0c9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里要提到的是，为了开发处理流水线，Cython代码必须在. pyx文件中，并且需要一个单独的setup.py脚本，由Cython将其编译成. c文件。C文件由C编译器编译成. so文件。这里使用的命令是:python setup . py build _ ext—in place。然后，可以在任何python脚本中以通常的方式导入Cython模块。</p><p id="6d76" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有人可能会说直接使用Python代码，而不是使用第一个函数(peak_finder_cy)的Cythonized版本。对于像Scipy这样调用编译C的库来说，它已经是一个高性能的库了，这是一个合理的论点。然而，当有大量扫描/数据段需要循环查找峰值时，Cython可以被证明是非常有效的。这里的这篇文章可以帮助你了解更多的细节和例子。作为参考，使用Python和Numba对上面这段代码的处理时间是每循环40.7 s 91.6 ns(平均标准时间。戴夫。7次运行，每次10000个循环)。</p><h2 id="6009" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">结论</h2><p id="e446" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">总之，重构是最可行的选择，使<strong class="ky ir"> Numba </strong>可用于不兼容的Python库和函数的计算，同时确保代码的最佳运行时间。</p><h2 id="23f9" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">参考</h2><ol class=""><li id="540b" class="na nb iq ky b kz ml lc mm lf nc lj nd ln ne lr nf ng nh ni bi translated"><a class="ae kv" href="https://www.pickupbrain.com/python/speed-up-python-up-to-1-million-times-cython-vs-numba/" rel="noopener ugc nofollow" target="_blank">https://www . pick up brain . com/python/speed-up-python-up-to-100万次-cython-vs-numba/ </a></li><li id="b95e" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nf ng nh ni bi translated">张，j，冈萨雷斯，e，赫斯提洛，t，哈斯金斯，w，黄，y(2009)。液相色谱-质谱联用中的峰值检测算法综述。<em class="no">当代基因组学</em>，<em class="no"> 10 </em> (6)，388。</li><li id="13ae" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nf ng nh ni bi translated"><a class="ae kv" href="http://stephanhoyer.com/2015/04/09/numba-vs-cython-how-to-choose/" rel="noopener ugc nofollow" target="_blank">http://Stephan hoyer . com/2015/04/09/numba-vs-cy thon-how-to-choose/</a></li></ol><p id="35f3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从读者的角度来看，<a class="np nq ep" href="https://medium.com/u/425209fe4dbb?source=post_page-----77a4377576c--------------------------------" rel="noopener" target="_blank"> Joseph Bloom </a>感谢他对本文非常有用的反馈。</p></div></div>    
</body>
</html>