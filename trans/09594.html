<html>
<head>
<title>Converting Scientific Kaggle Notebooks to Friendly Python Package</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将科学Kaggle笔记本转换为友好的Python包</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/converting-kaggle-training-notebooks-to-sharable-code-1cc59fec2414?source=collection_archive---------29-----------------------#2021-09-06">https://towardsdatascience.com/converting-kaggle-training-notebooks-to-sharable-code-1cc59fec2414?source=collection_archive---------29-----------------------#2021-09-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/a3a11b4d1deb121799d8e433edc51190.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jzz5jN6b-P_5-SDKGTgA2w.jpeg"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">插图照片由<a class="ae jd" href="https://www.pexels.com/@olia-danilevich?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">奥利娅·丹尼利维奇</a>从<a class="ae jd" href="https://www.pexels.com/photo/two-men-looking-at-a-laptop-4974920/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">派克斯</a>拍摄</p></figure><div class=""/><div class=""><h2 id="18ac" class="pw-subtitle-paragraph kd jf jg bd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dk translated">这篇文章展示了如何轻松地将笔记本转换为标准Python包，并在培训脚本中包含一个简单的命令行界面(CLI ),以实现更快的超参数交互。</h2></div><p id="ccbc" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在<a class="ae jd" rel="noopener" target="_blank" href="/intuitive-kaggle-task-exploration-and-model-baselining-e5f641943d08">之前的文章</a>中，我们分享了如何筛选给定的数据集，并展示了如何将类似文件的数据集包装到PyTorch类数据集，这是数据处理的核心。此外，我们基于一个<a class="ae jd" href="https://pytorch.org/vision/stable/index.html" rel="noopener ugc nofollow" target="_blank"> TorchVision </a>模型在<a class="ae jd" href="https://pytorch-lightning.readthedocs.io/en/stable/" rel="noopener ugc nofollow" target="_blank"> PyTorchLightning </a>中编写了一个基本的图像多标签分类模型，并在GPU上无缝地训练它，而无需在Jupyter笔记本中编写额外的代码。</p><div class="ip iq gp gr ir lr"><a rel="noopener follow" target="_blank" href="/intuitive-kaggle-task-exploration-and-model-baselining-e5f641943d08"><div class="ls ab fo"><div class="lt ab lu cl cj lv"><h2 class="bd jh gy z fp lw fr fs lx fu fw jf bi translated">直观的Kaggle任务探索和模型基线</h2><div class="ly l"><h3 class="bd b gy z fp lw fr fs lx fu fw dk translated">用PyTorch闪电和网格点实例在Kaggle上排名的最佳实践(第2/5部分)</h3></div><div class="lz l"><p class="bd b dl z fp lw fr fs lx fu fw dk translated">towardsdatascience.com</p></div></div><div class="ma l"><div class="mb l mc md me ma mf ix lr"/></div></div></a></div></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><p id="8ab6" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">笔记本电脑非常适合快速原型开发或数据探索，但对于大规模开发来说不太实用。笔记本电脑的单元式结构使得寻找不同的参数配置来优化模型具有挑战性。笔记本结果不一定是可重复的，因为您可能会交换一些编辑单元格或不按顺序运行它们。笔记本不支持版本控制，这使得与同事或更广泛的开源社区的协作变得困难。</p><h1 id="20b0" class="mn mo jg bd mp mq mr ms mt mu mv mw mx km my kn mz kp na kq nb ks nc kt nd ne bi translated">将笔记本转换为可共享的Python包</h1><p id="9bc7" class="pw-post-body-paragraph kv kw jg kx b ky nf kh la lb ng kk ld le nh lg lh li ni lk ll lm nj lo lp lq ij bi translated">使用PyTorch Lightning，将一个笔记本转换成一个基本的python包是很简单的事情，并将其作为GitHub存储库共享。PyTorch Lightning实施了最佳实践，并通过其功能(数据处理和模型架构)暗示了自然的代码组织。</p><p id="b6bc" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">python包是一种组织函数、类等的结构。，到python模块中，可以在任何地方导入和使用它们。这种包装是紧凑的和单元的，适于与Pip或Conda一起分配。所以在我们的例子中，我们创建了两个python模块— <code class="fe nk nl nm nn b">data</code>和<code class="fe nk nl nm nn b">models</code>，并复制粘贴了之前实现的类。</p><p id="fb05" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><a class="ae jd" href="https://packaging.python.org/tutorials/packaging-projects/" rel="noopener ugc nofollow" target="_blank">使用</a> <code class="fe nk nl nm nn b"><a class="ae jd" href="https://packaging.python.org/tutorials/packaging-projects/" rel="noopener ugc nofollow" target="_blank">setup.py</a></code>我们可以安装我们的软件包，并将其导入我们环境中的任何地方。否则，我们需要将包的路径添加到我们的Python系统路径中。通过将数据和模型实现移动到我们自己的包中，我们可以通过导入在我们的笔记本中使用它，并将所有培训简化为以下几行:</p><figure class="no np nq nr gt is"><div class="bz fp l di"><div class="ns nt l"/></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">来自共享的<a class="ae jd" href="https://github.com/Borda/kaggle_plant-pathology" rel="noopener ugc nofollow" target="_blank">库</a>的代码片段。</p></figure><p id="87f2" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这使您能够在GitHub 上共享您的<a class="ae jd" href="https://github.com/Borda/kaggle_plant-pathology" rel="noopener ugc nofollow" target="_blank">库/包，使人们能够轻松地在您的工作基础上进行构建。</a></p><figure class="no np nq nr gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nu"><img src="../Images/a64f38de0cd3e3c62d6a842f4aa5f3ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*98Nc9_W0SNVj35NxRgSxHg.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">将PL实现移动到包中，然后通过导入使用它们的模式。</p></figure><h2 id="62f8" class="nv mo jg bd mp nw nx dn mt ny nz dp mx le oa ob mz li oc od nb lm oe of nd og bi translated">模板/初学者存储库</h2><p id="901f" class="pw-post-body-paragraph kv kw jg kx b ky nf kh la lb ng kk ld le nh lg lh li ni lk ll lm nj lo lp lq ij bi translated">作为你下一个项目的灵感，我创建了这个<a class="ae jd" href="https://github.com/Borda/kaggle_sandbox" rel="noopener ugc nofollow" target="_blank">stater/template repository</a>，它用一个演示包<code class="fe nk nl nm nn b">challenge_xyz</code>建立了一个基本的项目结构。它包括测试、代码格式化和Github问题/公关模板的基本工作流程。您可以从该模板创建以下存储库；参见<a class="ae jd" href="https://docs.github.com/en/github/creating-cloning-and-archiving-repositories/creating-a-repository-on-github/creating-a-repository-from-a-template" rel="noopener ugc nofollow" target="_blank">分步文档</a>。</p><div class="ip iq gp gr ir lr"><a href="https://github.com/Borda/kaggle_sandbox" rel="noopener  ugc nofollow" target="_blank"><div class="ls ab fo"><div class="lt ab lu cl cj lv"><h2 class="bd jh gy z fp lw fr fs lx fu fw jf bi translated">GitHub-Borda/ka ggle _ sandbox:ka ggle尝试的起点:]</h2><div class="ly l"><h3 class="bd b gy z fp lw fr fs lx fu fw dk translated">Kaggle尝试的一个起点:】。在GitHub上创建一个帐户，为Borda/kaggle_sandbox开发做贡献。</h3></div><div class="lz l"><p class="bd b dl z fp lw fr fs lx fu fw dk translated">github.com</p></div></div><div class="ma l"><div class="oh l mc md me ma mf ix lr"/></div></div></a></div><div class="ip iq gp gr ir lr"><a href="https://medium.com/geekculture/thought-on-why-code-formatting-is-important-even-more-for-open-source-476829b54eaf" rel="noopener follow" target="_blank"><div class="ls ab fo"><div class="lt ab lu cl cj lv"><h2 class="bd jh gy z fp lw fr fs lx fu fw jf bi translated">思考为什么代码格式化对开源更重要</h2><div class="ly l"><h3 class="bd b gy z fp lw fr fs lx fu fw dk translated">格式化程序不会打扰任何人；它们旨在帮助和促进任何合作的顺利进行…</h3></div><div class="lz l"><p class="bd b dl z fp lw fr fs lx fu fw dk translated">medium.com</p></div></div><div class="ma l"><div class="oi l mc md me ma mf ix lr"/></div></div></a></div><h1 id="1516" class="mn mo jg bd mp mq mr ms mt mu mv mw mx km my kn mz kp na kq nb ks nc kt nd ne bi translated">包装实体的小技巧</h1><p id="91ab" class="pw-post-body-paragraph kv kw jg kx b ky nf kh la lb ng kk ld le nh lg lh li ni lk ll lm nj lo lp lq ij bi translated">现在我们开源了我们的代码，我们已经准备好让他们贡献或修复问题。这听起来不错，但是如何确保新的修改不会破坏其他东西呢？</p><p id="1d83" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">标准的软件工程答案是通过测试(单元测试或集成测试)。在提交/发布每一个新的贡献之前，我们可以在存储库中运行所有的测试，并验证所有的工作都如预期的那样。就我个人而言，我在我的大部分项目中使用的都是pytest包，reed <a class="ae jd" href="https://realpython.com/pytest-python-testing/" rel="noopener ugc nofollow" target="_blank">紧随其后进入</a>。</p><p id="ccf1" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">使用标准框架又一次变得很方便，在我们的例子中是Pytoch Lightning，它已经进行了数百次测试来保证正确的行为。我们只需要编写一小组测试用例来覆盖我们的解决方案，因为lightning已经完成了剩下的工作。例如，我们可能想要实例化所有的类。</p><p id="3bb8" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如下所示，我们添加了参数化，它使用不同的网络调用相同的测试两次——第一次获取network作为实例，第二次获取networks作为字符串名称:</p><figure class="no np nq nr gt is gh gi paragraph-image"><a href="https://github.com/Borda/kaggle_plant-pathology/blob/a642861e8d4d896c15b10c5dfcf071d8436889b5/tests/test_models.py#L16-L19"><div class="gh gi oj"><img src="../Images/5dc642f54bdcc5268b3a0aac594cb777.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xlkuKL-Vt07LjpaxcsX16Q.png"/></div></a><p class="iz ja gj gh gi jb jc bd b be z dk translated">来自共享<a class="ae jd" href="https://github.com/Borda/kaggle_plant-pathology" rel="noopener ugc nofollow" target="_blank">库</a>的代码<a class="ae jd" href="https://github.com/Borda/kaggle_plant-pathology/blob/a642861e8d4d896c15b10c5dfcf071d8436889b5/tests/test_models.py#L16-L19" rel="noopener ugc nofollow" target="_blank">片段</a>。</p></figure><p id="3842" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了测试训练能力，我们可以通过设置下面的<code class="fe nk nl nm nn b">Trainer</code>的标志<code class="fe nk nl nm nn b">fast_dev_run=True</code>，在一些样本图像上测试负载并运行您的模型。</p><figure class="no np nq nr gt is gh gi paragraph-image"><a href="https://github.com/Borda/kaggle_plant-pathology/blob/a642861e8d4d896c15b10c5dfcf071d8436889b5/tests/test_models.py#L22-L51"><div class="gh gi oj"><img src="../Images/c93d32cac160208977bb5fdaa09176c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1_BCov7Iu12BrC0hNmVQPg.png"/></div></a><p class="iz ja gj gh gi jb jc bd b be z dk translated">来自共享<a class="ae jd" href="https://github.com/Borda/kaggle_plant-pathology" rel="noopener ugc nofollow" target="_blank">库</a>的代码<a class="ae jd" href="https://github.com/Borda/kaggle_plant-pathology/blob/a642861e8d4d896c15b10c5dfcf071d8436889b5/tests/test_models.py#L22-L51" rel="noopener ugc nofollow" target="_blank">片段</a>。</p></figure><p id="b2fd" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">测试的最后一个技巧是包括几个样本图像和类似注释的文件来模拟实际的数据集。这允许您更真实地测试正确的用例。</p><h1 id="e361" class="mn mo jg bd mp mq mr ms mt mu mv mw mx km my kn mz kp na kq nb ks nc kt nd ne bi translated">将笔记本转换为CLI可配置的Python脚本</h1><p id="9686" class="pw-post-body-paragraph kv kw jg kx b ky nf kh la lb ng kk ld le nh lg lh li ni lk ll lm nj lo lp lq ij bi translated">将笔记本转换成python脚本的一种方法是通过JupyterLab——选择“下载为-&gt; Python”。<a class="ae jd" href="https://github.com/Borda/kaggle_plant-pathology/blob/a642861e8d4d896c15b10c5dfcf071d8436889b5/notebooks/Plant-Pathology-with-Lightning.ipynb" rel="noopener ugc nofollow" target="_blank">简化笔记本</a>应更短，主要关注数据/模型/教练配置(如果我们跳过所有数据探索部分)。</p><p id="4f01" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">不幸的是，它会生成一个带有硬编码参数的脚本。为了解决这个限制，我们需要编写自己的<code class="fe nk nl nm nn b">argparser</code>，并将所有CLI参数映射到模型/数据模块/训练器。幸运的是，Lightning最近推出了自己的极简<code class="fe nk nl nm nn b">LightningCLI</code>界面，为你处理争论投标。</p><div class="ip iq gp gr ir lr"><a href="https://devblog.pytorchlightning.ai/auto-structuring-deep-learning-projects-with-the-lightning-cli-9f40f1ef8b36" rel="noopener  ugc nofollow" target="_blank"><div class="ls ab fo"><div class="lt ab lu cl cj lv"><h2 class="bd jh gy z fp lw fr fs lx fu fw jf bi translated">使用Lightning CLI自动构建深度学习项目</h2><div class="lz l"><p class="bd b dl z fp lw fr fs lx fu fw dk translated">devblog.pytorchlightning.ai</p></div></div><div class="ma l"><div class="ok l mc md me ma mf ix lr"/></div></div></a></div><p id="eac8" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe nk nl nm nn b">LightningCLI</code>几乎不需要额外的代码就能为Lightning脚本提供简单的参数解析！它被设计成接受这些主要的组件/角色:<code class="fe nk nl nm nn b">LightningModule</code>、<code class="fe nk nl nm nn b">LightningDataModule </code>和<code class="fe nk nl nm nn b">Trainer</code>，解析命令行参数并实例化这些角色。最终，<code class="fe nk nl nm nn b">LightningCLI </code>执行了训练。最终的脚本如下所示:</p><figure class="no np nq nr gt is gh gi paragraph-image"><a href="https://github.com/Borda/kaggle_plant-pathology/blob/a642861e8d4d896c15b10c5dfcf071d8436889b5/kaggle_plantpatho/cli_train.py#L39-L45"><div class="gh gi oj"><img src="../Images/31e345a96548b701df706a14fd4c064d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MIUXMdsQxhLws9FcffrRMg.png"/></div></a><p class="iz ja gj gh gi jb jc bd b be z dk translated">来自共享<a class="ae jd" href="https://github.com/Borda/kaggle_plant-pathology" rel="noopener ugc nofollow" target="_blank">库</a>的代码<a class="ae jd" href="https://github.com/Borda/kaggle_plant-pathology/blob/a642861e8d4d896c15b10c5dfcf071d8436889b5/kaggle_plantpatho/cli_train.py#L39-L45" rel="noopener ugc nofollow" target="_blank">片段</a>。</p></figure><p id="f4f9" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">使用CLI，您可以在任何终端中运行python脚本。</p><pre class="no np nq nr gt ol nn om on aw oo bi"><span id="103a" class="nv mo jg nn b gy op oq l or os">python kaggle_plantpatho/cli_train.py \<br/>    <!-- -->--model.model 'resnet34' \<br/>    --data.base_path /home/jirka/datasets/kaggle_plant-pathology \<br/>    --trainer.max_epochs 5</span></pre><p id="b47f" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="ot">由于我们计划试验不同的模型架构，我们可能需要调整每个模型的批量大小，以使用最大的资源(对于较小的模型，例如</em> <code class="fe nk nl nm nn b"><em class="ot">resnet18</em></code> <em class="ot">，我们可以使用比</em> <code class="fe nk nl nm nn b"><em class="ot">resnet101</em></code> <em class="ot">大得多的批量)。这可以通过在方法</em> <code class="fe nk nl nm nn b"><em class="ot">before_fit(...)</em></code> <em class="ot">中实现的闪电训练器</em> <code class="fe nk nl nm nn b"><a class="ae jd" href="https://pytorch-lightning.readthedocs.io/en/1.4.0/common/trainer.html?highlight=tune#auto-scale-batch-size" rel="noopener ugc nofollow" target="_blank"><em class="ot">tune</em></a></code> <em class="ot">来实现，因为它会找到适合GPU内存的最大</em> <code class="fe nk nl nm nn b"><em class="ot">batch_size</em></code> <em class="ot">并使用它进行训练。</em></p><figure class="no np nq nr gt is gh gi paragraph-image"><a href="https://github.com/Borda/kaggle_plant-pathology/blob/a642861e8d4d896c15b10c5dfcf071d8436889b5/kaggle_plantpatho/cli_train.py#L29-L36"><div class="gh gi oj"><img src="../Images/0bf27e528915c40abc92404091a0566a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QOsovQ5mm49N34xcNBCB5Q.png"/></div></a><p class="iz ja gj gh gi jb jc bd b be z dk translated">来自共享<a class="ae jd" href="https://github.com/Borda/kaggle_plant-pathology" rel="noopener ugc nofollow" target="_blank">库</a>的代码<a class="ae jd" href="https://github.com/Borda/kaggle_plant-pathology/blob/a642861e8d4d896c15b10c5dfcf071d8436889b5/kaggle_plantpatho/cli_train.py#L29-L36" rel="noopener ugc nofollow" target="_blank">片段</a>。</p></figure></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><p id="b7aa" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在这篇文章中，我们展示了如何将科学笔记本转换成可以共享的标准python包。我们已经讨论了添加最小测试的动机，以便在不意外破坏它的情况下促进任何未来的包增强。最后，我们展示了从<a class="ae jd" href="https://gist.github.com/Borda/5eb3dea49aff2cd60f8c88e1e3f01a3c" rel="noopener ugc nofollow" target="_blank">普通python脚本</a>到公开所有命令行参数的通用脚本的简单转换。</p><p id="115d" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在未来，我们将展示如何使用这个简单的脚本在<a class="ae jd" href="https://www.grid.ai/" rel="noopener ugc nofollow" target="_blank"> Grid.ai </a>上并行运行跨多台机器的超参数搜索，并在线观察训练表现。</p><div class="ip iq gp gr ir lr"><a rel="noopener follow" target="_blank" href="/hyperparameter-optimization-with-grid-ai-and-no-code-change-b89218d4ff49"><div class="ls ab fo"><div class="lt ab lu cl cj lv"><h2 class="bd jh gy z fp lw fr fs lx fu fw jf bi translated">使用Grid.ai进行超参数优化，无需更改代码</h2><div class="ly l"><h3 class="bd b gy z fp lw fr fs lx fu fw dk translated">用PyTorch闪电和网格点实例在Kaggle上排名的最佳实践(第4/5部分)</h3></div><div class="lz l"><p class="bd b dl z fp lw fr fs lx fu fw dk translated">towardsdatascience.com</p></div></div><div class="ma l"><div class="ou l mc md me ma mf ix lr"/></div></div></a></div><p id="82eb" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx jh">敬请关注，并跟随我了解更多！</strong></p><div class="ip iq gp gr ir lr"><a href="https://devblog.pytorchlightning.ai/best-practices-to-rank-on-kaggle-competition-with-pytorch-lightning-and-grid-ai-spot-instances-54aa5248aa8e" rel="noopener  ugc nofollow" target="_blank"><div class="ls ab fo"><div class="lt ab lu cl cj lv"><h2 class="bd jh gy z fp lw fr fs lx fu fw jf bi translated">使用PyTorch Lightning和Grid.ai Spot实例对Kaggle竞争进行排名的最佳实践</h2><div class="ly l"><h3 class="bd b gy z fp lw fr fs lx fu fw dk translated">通过交互式会话、超参数解决图像分类挑战的完整数据科学周期…</h3></div><div class="lz l"><p class="bd b dl z fp lw fr fs lx fu fw dk translated">devblog.pytorchlightning.ai</p></div></div><div class="ma l"><div class="ov l mc md me ma mf ix lr"/></div></div></a></div><h1 id="07b3" class="mn mo jg bd mp mq mr ms mt mu mv mw mx km my kn mz kp na kq nb ks nc kt nd ne bi translated">关于作者</h1><p id="48e4" class="pw-post-body-paragraph kv kw jg kx b ky nf kh la lb ng kk ld le nh lg lh li ni lk ll lm nj lo lp lq ij bi translated"><a class="ae jd" href="https://medium.com/@jborovec" rel="noopener"><strong class="kx jh">Jirka boro vec</strong></a><strong class="kx jh"/>已经在几家不同的IT公司从事机器学习和数据科学工作好几年了。特别是，他喜欢探索有趣的世界问题，并用最先进的技术解决它们。此外，他开发了几个开源python包，并积极参与其他知名项目。在<a class="ae jd" href="https://www.grid.ai/" rel="noopener ugc nofollow" target="_blank"> <em class="ot"> Grid.ai </em> </a>工作，担任研究工程师，是<a class="ae jd" href="https://pytorchlightning.ai/" rel="noopener ugc nofollow" target="_blank"><em class="ot">pytorchlightning . ai</em></a>的主要撰稿人。</p></div></div>    
</body>
</html>