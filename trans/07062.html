<html>
<head>
<title>What song did I miss in the 2010s?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">2010年代我错过了什么歌？</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/what-song-did-i-miss-in-the-2010s-306ff6a061c5?source=collection_archive---------24-----------------------#2021-06-26">https://towardsdatascience.com/what-song-did-i-miss-in-the-2010s-306ff6a061c5?source=collection_archive---------24-----------------------#2021-06-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="162f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated"><strong class="ak">使用Spotify Web API和k-means聚类找出它们</strong></h2></div><h2 id="a8b9" class="ki kj it bd kk kl km dn kn ko kp dp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">介绍</h2><p id="d77c" class="pw-post-body-paragraph le lf it lg b lh li ju lj lk ll jx lm kr ln lo lp kv lq lr ls kz lt lu lv lw im bi translated">没有人能否认Spotify革新了整个音乐行业。但很多人不知道的是，Spotify还免费提供了强大的Web API。在Spotify中创建你的开发者账号后，你就可以打开这个闸门，摆弄与音乐相关的海量信息。今天我在这里演示如何用Python玩Spotify Web API。</p><h2 id="0829" class="ki kj it bd kk kl km dn kn ko kp dp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">情况</h2><p id="016a" class="pw-post-body-paragraph le lf it lg b lh li ju lj lk ll jx lm kr ln lo lp kv lq lr ls kz lt lu lv lw im bi translated">我有自己的播放列表，只有56首歌曲。我确定我错过了很多好歌。但是我怎么才能确定我错过了什么呢？更重要的是，我如何利用我当前的播放列表找到我可能也喜欢的其他歌曲？所以需要一个基于我目前歌单的推荐系统。但是如何量化我的歌单里我爱听的歌？</p><p id="792f" class="pw-post-body-paragraph le lf it lg b lh lx ju lj lk ly jx lm kr lz lo lp kv ma lr ls kz mb lu lv lw im bi translated">我们开始吧！</p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h2 id="6d9f" class="ki kj it bd kk kl km dn kn ko kp dp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">第一步:访问Spotify Web API</h2><p id="c1ac" class="pw-post-body-paragraph le lf it lg b lh li ju lj lk ll jx lm kr ln lo lp kv lq lr ls kz lt lu lv lw im bi translated">首先，你需要在你的Spotify账户中设置好一切。客户端ID和客户端密码是必需的。如果您还没有，请点击<a class="ae mj" href="https://developer.spotify.com/documentation/web-api/quick-start/" rel="noopener ugc nofollow" target="_blank">链接</a>下的“设置您的帐户”部分。</p><p id="ac74" class="pw-post-body-paragraph le lf it lg b lh lx ju lj lk ly jx lm kr lz lo lp kv ma lr ls kz mb lu lv lw im bi translated">在仪表板页面上设置应用程序后，您将获得客户端ID和客户端密码。这两个是访问Spotify API所必需的。不要和别人分享！</p><figure class="ml mm mn mo gt mp gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi mk"><img src="../Images/6dc742760f4de718349603d0134d204f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*datoO5YjuDuZJDwE4IOpFA.png"/></div></div></figure><p id="4d16" class="pw-post-body-paragraph le lf it lg b lh lx ju lj lk ly jx lm kr lz lo lp kv ma lr ls kz mb lu lv lw im bi translated">Spotify Web API基于REST。所以我们需要的就是包装。在获得客户机ID和客户机秘密之后，我们需要的下一件事是访问令牌。你可以向Spotify提出请求，Spotify会将访问令牌返还给你。</p><pre class="ml mm mn mo gt na mz nb nc aw nd bi"><span id="295c" class="ki kj it mz b gy ne nf l ng nh">auth_response = requests.post("<a class="ae mj" href="https://accounts.spotify.com/api/token" rel="noopener ugc nofollow" target="_blank">https://accounts.spotify.com/api/token</a>", {<br/>    "grant_type": "client_credentials",<br/>    "client_id": CLIENT_ID,<br/>    "client_secret": CLIENT_SECRET,<br/>})</span><span id="b0b5" class="ki kj it mz b gy ni nf l ng nh">auth_response_json = auth_response.json()</span><span id="043a" class="ki kj it mz b gy ni nf l ng nh">access_token = auth_response_json["access_token"]</span></pre><p id="ed9e" class="pw-post-body-paragraph le lf it lg b lh lx ju lj lk ly jx lm kr lz lo lp kv ma lr ls kz mb lu lv lw im bi translated"><code class="fe mw mx my mz b">auth_response_json</code>将采用JSON格式，如下所示</p><figure class="ml mm mn mo gt mp gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/e3af3f54cd08b3d564e1304cb7e2eb5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1286/format:webp/1*vzuyWKDUSUQBV4_bzS1ngA.png"/></div></figure><p id="a5e0" class="pw-post-body-paragraph le lf it lg b lh lx ju lj lk ly jx lm kr lz lo lp kv ma lr ls kz mb lu lv lw im bi translated">当我们向Spotify发送任何请求时，我们都会添加一个包含此access_token的额外标头。</p><pre class="ml mm mn mo gt na mz nb nc aw nd bi"><span id="d426" class="ki kj it mz b gy ne nf l ng nh">headers = {"Authorization": f"Bearer {access_token}"}</span></pre><p id="dc8a" class="pw-post-body-paragraph le lf it lg b lh lx ju lj lk ly jx lm kr lz lo lp kv ma lr ls kz mb lu lv lw im bi translated">访问API的基本URL是<a class="ae mj" href="https://api.spotify.com/v1/'" rel="noopener ugc nofollow" target="_blank">https://api.spotify.com/v1/</a>。URL后面的会话是选择API的类型。比如对于一个艺人，网址会是<a class="ae mj" href="https://api.spotify.com/v1/artists" rel="noopener ugc nofollow" target="_blank">https://api.spotify.com/v1/artists</a>；对于播放列表，它将是<a class="ae mj" href="https://api.spotify.com/v1/me/playlists" rel="noopener ugc nofollow" target="_blank">https://api.spotify.com/v1/me/playlists</a>。然后对于每种类型的API，会有不同的API调用。欲了解更多信息，您可以访问<a class="ae mj" href="https://developer.spotify.com/documentation/web-api/reference/" rel="noopener ugc nofollow" target="_blank">此链接</a>。</p><figure class="ml mm mn mo gt mp gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi nk"><img src="../Images/83d0fa35d41403c69512cd1bd613b423.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t29Deo2tmzK8yOc7NhcAQA.png"/></div></div></figure></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h2 id="4e6e" class="ki kj it bd kk kl km dn kn ko kp dp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">第二步:我的Spotify播放列表中的歌曲</h2><p id="81f8" class="pw-post-body-paragraph le lf it lg b lh li ju lj lk ll jx lm kr ln lo lp kv lq lr ls kz lt lu lv lw im bi translated">现在我们都准备好享受Spotify API了。第一个问题，我的播放列表里有哪些歌曲？要识别哪个播放列表，您需要提供该播放列表的ID。如果你点击三个点-&gt;共享-&gt;复制链接到播放列表，就可以获得ID。</p><figure class="ml mm mn mo gt mp gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/8a7614d5c43e3cbe4d0991dfceae44e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:674/format:webp/1*bxtuyKxy_X3DUb60ooT_MA.png"/></div></figure><p id="b29d" class="pw-post-body-paragraph le lf it lg b lh lx ju lj lk ly jx lm kr lz lo lp kv ma lr ls kz mb lu lv lw im bi translated">你会得到一个网址。playlist/后面的字符串是播放列表的ID。</p><figure class="ml mm mn mo gt mp gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/2c1a2e5a10998a99f9e489ff848ef8c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1150/format:webp/1*nLjTPJZ-pblcFXXvm77v1w.png"/></div></figure><p id="1a85" class="pw-post-body-paragraph le lf it lg b lh lx ju lj lk ly jx lm kr lz lo lp kv ma lr ls kz mb lu lv lw im bi translated">如果我们专门获取一个播放列表中的所有歌曲，您可以按如下方式进行:</p><pre class="ml mm mn mo gt na mz nb nc aw nd bi"><span id="911f" class="ki kj it mz b gy ne nf l ng nh">requests.get("https://api.spotify.com/v1/playlists/YOUR_PLAYLIST_ID/tracks", headers=headers).json()</span></pre><p id="7064" class="pw-post-body-paragraph le lf it lg b lh lx ju lj lk ly jx lm kr lz lo lp kv ma lr ls kz mb lu lv lw im bi translated">然而，有一个问题是，每次发送请求，你最多只能从Spotify API获得100首歌曲。</p><figure class="ml mm mn mo gt mp gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi nn"><img src="../Images/94889d61992e0530d4d63d70a254f250.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9ZFuhCsn45JagAPrr9ik4Q.png"/></div></div></figure><p id="fbc8" class="pw-post-body-paragraph le lf it lg b lh lx ju lj lk ly jx lm kr lz lo lp kv ma lr ls kz mb lu lv lw im bi translated">因此，如果您的播放列表中有超过100首歌曲，那么您需要包含<code class="fe mw mx my mz b">offset</code>参数并使用for循环来获取所有歌曲的详细信息。</p><figure class="ml mm mn mo gt mp gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi no"><img src="../Images/e9b4aede24442544ed288be6e2e9fc99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mQBOT307cdEsWZCzReMl6Q.png"/></div></div></figure><p id="fd5a" class="pw-post-body-paragraph le lf it lg b lh lx ju lj lk ly jx lm kr lz lo lp kv ma lr ls kz mb lu lv lw im bi translated">但由于我的播放列表只有56首歌曲，所以我没事。</p><p id="1e36" class="pw-post-body-paragraph le lf it lg b lh lx ju lj lk ly jx lm kr lz lo lp kv ma lr ls kz mb lu lv lw im bi translated">你会收到一个长长的JSON。<code class="fe mw mx my mz b">Item</code>中的每个元素代表一首歌。它列出了歌曲的详细信息，包括歌曲名称、艺术家和专辑名称。</p><figure class="ml mm mn mo gt mp gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi np"><img src="../Images/4f12d4ea3ad8f3c833d4eaa01629c7eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eUlepfY2_MEjigQeuFIdzg.png"/></div></div><p class="nq nr gj gh gi ns nt bd b be z dk translated">艺术家详细信息</p></figure><figure class="ml mm mn mo gt mp gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi nu"><img src="../Images/73fa31178487a9dbe52df34a8e7119b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Jr0Sq2RySyNjdwHN6kVLJA.png"/></div></div><p class="nq nr gj gh gi ns nt bd b be z dk translated">歌曲细节</p></figure><p id="90f9" class="pw-post-body-paragraph le lf it lg b lh lx ju lj lk ly jx lm kr lz lo lp kv ma lr ls kz mb lu lv lw im bi translated">我们下一步需要的是歌曲的ID。但是这里我们也得到歌曲名称和艺术家，只是为了演示。</p><p id="a368" class="pw-post-body-paragraph le lf it lg b lh lx ju lj lk ly jx lm kr lz lo lp kv ma lr ls kz mb lu lv lw im bi translated">由于我们将发送请求超过三次，我简单地创建了如下函数(<a class="ae mj" href="https://twitter.com/drob/status/928447584712253440" rel="noopener ugc nofollow" target="_blank"> Link </a>):</p><pre class="ml mm mn mo gt na mz nb nc aw nd bi"><span id="663c" class="ki kj it mz b gy ne nf l ng nh">def send_request(send_type_,id_,remaining_ = ""):<br/>    return requests.get(BASE_URL + send_type_ +"/"+ id_ + "/"+remaining_, headers=headers).json()</span><span id="ce11" class="ki kj it mz b gy ni nf l ng nh">myPlaylist = send_request("playlists", <!-- -->YOUR_PLAYLIST_ID<!-- -->,"tracks")</span></pre></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h2 id="4d9d" class="ki kj it bd kk kl km dn kn ko kp dp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">第三步:歌曲的特点</h2><p id="0565" class="pw-post-body-paragraph le lf it lg b lh li ju lj lk ll jx lm kr ln lo lp kv lq lr ls kz lt lu lv lw im bi translated">是时候想办法描述一下我喜欢什么类型的歌了。从最后一步，我们可以获得每首歌曲的唯一ID。在这个阶段，我们可以使用<code class="fe mw mx my mz b">audio_features</code>发送一个请求，并将ID作为参数。例如:</p><pre class="ml mm mn mo gt na mz nb nc aw nd bi"><span id="ce08" class="ki kj it mz b gy ne nf l ng nh">requests.get("<a class="ae mj" href="https://api.spotify.com/v1/audio-features/4ltxkXhSE3oH4Xnx0Ek598/" rel="noopener ugc nofollow" target="_blank">https://api.spotify.com/v1/audio-features/4ltxkXhSE3oH4Xnx0Ek598/</a>", headers=headers).json()</span></pre><p id="b8f9" class="pw-post-body-paragraph le lf it lg b lh lx ju lj lk ly jx lm kr lz lo lp kv ma lr ls kz mb lu lv lw im bi translated">这就是你将得到的，一个列出了歌曲特征的JSON。</p><figure class="ml mm mn mo gt mp gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/2749607a50e32a5d53fb79b6a380af39.png" data-original-src="https://miro.medium.com/v2/resize:fit:1198/format:webp/1*sKViDgqnWD-TMsrSavJoDw.png"/></div></figure><p id="64b3" class="pw-post-body-paragraph le lf it lg b lh lx ju lj lk ly jx lm kr lz lo lp kv ma lr ls kz mb lu lv lw im bi translated">这里就不解释每个字符的意思了。有兴趣的话，去<a class="ae mj" href="https://developer.spotify.com/documentation/web-api/reference/#object-audiofeaturesobject" rel="noopener ugc nofollow" target="_blank">这个链接</a>了解更多。</p><figure class="ml mm mn mo gt mp gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/03fa9a11ce691f1b2edba7f0b5c11652.png" data-original-src="https://miro.medium.com/v2/resize:fit:764/format:webp/1*NFE894c0UKntKm9e4xHAag.png"/></div></figure><p id="fc5d" class="pw-post-body-paragraph le lf it lg b lh lx ju lj lk ly jx lm kr lz lo lp kv ma lr ls kz mb lu lv lw im bi translated">现在，我们几乎完成了收集我的播放列表中歌曲的所有必要信息。最后一步是将所有信息存储在数据帧中。</p><pre class="ml mm mn mo gt na mz nb nc aw nd bi"><span id="92ca" class="ki kj it mz b gy ne nf l ng nh"># This is to get the song ID of a song<br/>def get_id(dict_):<br/>    return dict_["track"]["id"]</span><span id="746b" class="ki kj it mz b gy ni nf l ng nh"># This is to get all details of a song <br/>def getSongDetail(trackID_):<br/>    # Get the audio feature of a song <br/>    audioFeatures = send_request("audio-features" , trackID_)<br/>    # Get the information of a song <br/>    songDetails = send_request("tracks", trackID_)<br/>    songName = songDetails["name"]<br/>    artists = songDetails["artists"]<br/>    artistsName = [x["name"] for x in artists]<br/>    # Combine all into a dict<br/>    return {**{"Song_Name": songName, "Artists": artistsName},**audioFeatures}</span><span id="376e" class="ki kj it mz b gy ni nf l ng nh">mySongs = []<br/>for song in myPlaylist["items"]:<br/>    mySongs.append(getSongDetail(get_id(song)))<br/>mySongsDF = pd.DataFrame(mySongs)</span></pre></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h2 id="e2c3" class="ki kj it bd kk kl km dn kn ko kp dp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">第四步:k-means聚类</h2><p id="1578" class="pw-post-body-paragraph le lf it lg b lh li ju lj lk ll jx lm kr ln lo lp kv lq lr ls kz lt lu lv lw im bi translated">(这里我假设你已经知道什么是k均值聚类。如果没有，有大量的材料介绍。例如<a class="ae mj" href="https://scikit-learn.org/stable/modules/clustering.html#k-means" rel="noopener ugc nofollow" target="_blank"> scikit-learn doc </a>。)</p><p id="8e38" class="pw-post-body-paragraph le lf it lg b lh lx ju lj lk ly jx lm kr lz lo lp kv ma lr ls kz mb lu lv lw im bi translated">因此，我们将只需要数字变量进行k均值聚类。在执行聚类之前，还要执行标准化，以调整所有数值变量的标度。</p><pre class="ml mm mn mo gt na mz nb nc aw nd bi"><span id="d282" class="ki kj it mz b gy ne nf l ng nh">numeric_Variable = ["danceability", "energy",  "loudness", "speechiness",<br/>       "acousticness", "instrumentalness", "liveness", "valence", "tempo","duration_ms"]<br/>mySongsNumericDF = mySongsDF[numeric_Variable]</span><span id="61a8" class="ki kj it mz b gy ni nf l ng nh"># This is to standardize all numeric variables <br/>mysongsScaler = StandardScaler().fit(mySongsNumericDF)<br/>mysongsNormalizedDF = mysongsScaler.transform(mySongsNumericDF)</span></pre><p id="e99e" class="pw-post-body-paragraph le lf it lg b lh lx ju lj lk ly jx lm kr lz lo lp kv ma lr ls kz mb lu lv lw im bi translated">用肘法求最优k。</p><pre class="ml mm mn mo gt na mz nb nc aw nd bi"><span id="4395" class="ki kj it mz b gy ne nf l ng nh"># This is to return the sum of squared distances of samples to their closest cluster center.<br/>def get_inertia(n_cluster_,df_):<br/>    return  KMeans(n_clusters = n_cluster_, random_state= 42).fit(df_).inertia_</span><span id="f5f9" class="ki kj it mz b gy ni nf l ng nh">mySongSqDistance = []<br/>for i in range(1,10):<br/>    mySongSqDistance.append(get_inertia(i,mysongsNormalizedDF))</span><span id="8f8a" class="ki kj it mz b gy ni nf l ng nh">plt.plot(range(1,10), mySongSqDistance, "rx-")<br/>plt.show()</span></pre><figure class="ml mm mn mo gt mp gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/56a4ee4442b71dac3d294692b2546da8.png" data-original-src="https://miro.medium.com/v2/resize:fit:746/format:webp/1*WWa7e_AuqxAEli-RkfCGGg.png"/></div></figure><p id="c562" class="pw-post-body-paragraph le lf it lg b lh lx ju lj lk ly jx lm kr lz lo lp kv ma lr ls kz mb lu lv lw im bi translated">肘部不清楚，但至少从1到2的下降比从2开始大。所以下一步我取k =2。</p><pre class="ml mm mn mo gt na mz nb nc aw nd bi"><span id="fbf5" class="ki kj it mz b gy ne nf l ng nh">kMeansResult = KMeans(n_clusters = 2, random_state= 42).fit(mysongsNormalizedDF)</span></pre><p id="86ba" class="pw-post-body-paragraph le lf it lg b lh lx ju lj lk ly jx lm kr lz lo lp kv ma lr ls kz mb lu lv lw im bi translated">第一个问题:每个集群有多少首歌？</p><pre class="ml mm mn mo gt na mz nb nc aw nd bi"><span id="3898" class="ki kj it mz b gy ne nf l ng nh">collections.Counter(kMeansResult.labels_)<br/># Counter({1: 18, 0: 38})</span></pre><p id="2f7c" class="pw-post-body-paragraph le lf it lg b lh lx ju lj lk ly jx lm kr lz lo lp kv ma lr ls kz mb lu lv lw im bi translated">第二个问题:每个集群都分组了哪些歌曲？</p><pre class="ml mm mn mo gt na mz nb nc aw nd bi"><span id="3ec3" class="ki kj it mz b gy ne nf l ng nh">mySongsDF["kCluster"] = kMeansResult.labels_.tolist()<br/>list(mySongsDF[mySongsDF["kCluster"]==1]["Song_Name"])</span></pre><figure class="ml mm mn mo gt mp gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/55527ae8687f0a135125e03540027666.png" data-original-src="https://miro.medium.com/v2/resize:fit:470/format:webp/1*a6k7YpmHnN8U0Hfli8qbSw.png"/></div></figure><p id="d7f9" class="pw-post-body-paragraph le lf it lg b lh lx ju lj lk ly jx lm kr lz lo lp kv ma lr ls kz mb lu lv lw im bi translated">有意思的一点是，我所有的粤语歌都在这个集群里。</p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h2 id="4a4a" class="ki kj it bd kk kl km dn kn ko kp dp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">第五步:我错过了什么歌？</h2><p id="a55d" class="pw-post-body-paragraph le lf it lg b lh li ju lj lk ll jx lm kr ln lo lp kv lq lr ls kz lt lu lv lw im bi translated">现在是时候找出我错过了哪首歌了。</p><p id="a071" class="pw-post-body-paragraph le lf it lg b lh lx ju lj lk ly jx lm kr lz lo lp kv ma lr ls kz mb lu lv lw im bi translated">我将使用现有的歌曲列表，并将所有歌曲放入经过训练的k-means聚类中。聚类之后，我将进一步计算每首歌曲与相应聚类的质心之间的距离。</p><figure class="ml mm mn mo gt mp gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi nz"><img src="../Images/b3d1fb31accda1ad77638927e20e87f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zj84gvvPDi-eJAM_ZI3x5Q.png"/></div></div><p class="nq nr gj gh gi ns nt bd b be z dk translated">这将是歌单。</p></figure><p id="6a5d" class="pw-post-body-paragraph le lf it lg b lh lx ju lj lk ly jx lm kr lz lo lp kv ma lr ls kz mb lu lv lw im bi translated">得到歌曲特征的过程和前面一样。所以下面更侧重于k-means聚类部分。首先是标准化，然后预测结果。</p><pre class="ml mm mn mo gt na mz nb nc aw nd bi"><span id="3c25" class="ki kj it mz b gy ne nf l ng nh"># playlist_songsNumericDF is a dataframe for storing all numeric characteristics of all songs in the playlist</span><span id="0b7f" class="ki kj it mz b gy ni nf l ng nh"># Below processes are to standardize all numeric variables and then predict the result. </span><span id="c146" class="ki kj it mz b gy ni nf l ng nh">playlist_songsNormalizedDF = mysongsScaler.transform(playlist_songsNumericDF)</span><span id="4763" class="ki kj it mz b gy ni nf l ng nh">playlist_songsPredict = kMeansResult.predict(playlist_songsNormalizedDF)</span></pre><p id="01c1" class="pw-post-body-paragraph le lf it lg b lh lx ju lj lk ly jx lm kr lz lo lp kv ma lr ls kz mb lu lv lw im bi translated">下面是所有被预测在聚类1中的歌曲。</p><figure class="ml mm mn mo gt mp gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/743ec69e82e324f2c5764dda0f20345c.png" data-original-src="https://miro.medium.com/v2/resize:fit:718/format:webp/1*lSd3IA7iCm3PkDp4xgasAQ.png"/></div></figure><p id="6e16" class="pw-post-body-paragraph le lf it lg b lh lx ju lj lk ly jx lm kr lz lo lp kv ma lr ls kz mb lu lv lw im bi translated">然后，我们计算每首歌曲与其各自的聚类质心之间的距离。这里我们使用距离numpy的欧几里德距离。</p><pre class="ml mm mn mo gt na mz nb nc aw nd bi"><span id="986c" class="ki kj it mz b gy ne nf l ng nh">playlist_songsDF["Distance_to_Centroid"]=[np.linalg.norm(<br/>    result[0]-kMeansResult.cluster_centers_[result[1]]) <br/>    for result in list(zip(playlist_songsNormalizedDF,<br/>                           playlist_songsPredict))<br/>]</span></pre><p id="c922" class="pw-post-body-paragraph le lf it lg b lh lx ju lj lk ly jx lm kr lz lo lp kv ma lr ls kz mb lu lv lw im bi translated">与质心距离最短的前五首歌曲是:</p><pre class="ml mm mn mo gt na mz nb nc aw nd bi"><span id="e99f" class="ki kj it mz b gy ne nf l ng nh">list(playlist_songsDF[playlist_songsDF["kCluster"]==1].nsmallest(5,"Distance_to_Centroid")['Song_Name'])</span></pre><figure class="ml mm mn mo gt mp gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/494034f38f7e36baf4a873005f06e8a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1068/format:webp/1*rKrw9Tt3JGX7uREbN89EKg.png"/></div></figure></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h2 id="d65f" class="ki kj it bd kk kl km dn kn ko kp dp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">最后的</h2><p id="af80" class="pw-post-body-paragraph le lf it lg b lh li ju lj lk ll jx lm kr ln lo lp kv lq lr ls kz lt lu lv lw im bi translated">这里我只演示一个简单的例子来使用Spotify Web API。如果你对此感兴趣，我建议你访问https://developer.spotify.com/，发现Spotify免费提供的其他酷功能。</p><p id="2e13" class="pw-post-body-paragraph le lf it lg b lh lx ju lj lk ly jx lm kr lz lo lp kv ma lr ls kz mb lu lv lw im bi translated">本文到此结束，整个Jupyter笔记本已经发布在我的GitHub上(<a class="ae mj" href="https://github.com/wyfok/Spotify_API_KMeans" rel="noopener ugc nofollow" target="_blank">链接</a>)。</p><p id="9c89" class="pw-post-body-paragraph le lf it lg b lh lx ju lj lk ly jx lm kr lz lo lp kv ma lr ls kz mb lu lv lw im bi translated">下次见。</p></div></div>    
</body>
</html>