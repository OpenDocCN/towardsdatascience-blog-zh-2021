<html>
<head>
<title>Modeling and Generating Time-Series Data using TimeGAN</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用TimeGAN建模和生成时间序列数据</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/modeling-and-generating-time-series-data-using-timegan-29c00804f54d?source=collection_archive---------5-----------------------#2021-09-08">https://towardsdatascience.com/modeling-and-generating-time-series-data-using-timegan-29c00804f54d?source=collection_archive---------5-----------------------#2021-09-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="8f0b" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用具有TimeGAN高级实现的库生成时间序列数据</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/b6a7162f45e31d1afdd67ad7c068f1d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*6ijCnhkjnxbHLg3t"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">由<a class="ae kv" href="https://unsplash.com/@agebarros?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">阿格巴洛斯</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h1 id="feeb" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">1.背景</h1><p id="df9a" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">在<a class="ae kv" rel="noopener" target="_blank" href="/generating-expanding-your-datasets-with-synthetic-data-4e27716be218">之前的一篇文章</a>中，我们探索了生成人工或合成数据的想法，给出了有限数量的数据集作为起点。当时取的数据是表格形式的，就像我们平时遇到的常规数据集。然而，在本文中，我们将着眼于时间序列数据，并探索一种生成合成时间序列数据的方法。</p><h1 id="c0d1" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">2.时间序列数据—简要概述</h1><p id="9766" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">那么，时间序列数据与常规的表格数据有什么不同呢？时序数据集有一个额外的维度—时间。把它想象成一个3D数据集。比方说，我们有一个包含5个要素和5个输入实例的数据集。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mk"><img src="../Images/0a2caa9c02a7717777f360de0eb9d8fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aeHnXOUm-BZiv4hDF6s2Kg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="6b4c" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">那么时间序列数据基本上是该表在第三维中的扩展，其中每个新表只是新时间步的另一个数据集。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mq"><img src="../Images/59b9c27cfc90763ee8c5ab8696dc49ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GNNUt0bZ4tGBwwWJ3iijuQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="89c8" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">主要区别在于，与表格数据相比，时间序列数据有更多的数据点实例。</p><h1 id="a77f" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">3.案例研究:能源数据集</h1><p id="14a8" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">如果我们查看能源数据集(此处可用<a class="ae kv" href="https://github.com/jsyoon0823/TimeGAN/blob/master/data/energy_data.csv" rel="noopener ugc nofollow" target="_blank">此处</a>，最初取自此处<a class="ae kv" href="http://archive.ics.uci.edu/ml/datasets/Appliances+energy+prediction" rel="noopener ugc nofollow" target="_blank">的数据)，它实际上看起来只是一个常规的表格数据集，每一行都意味着一个新的时间步长，并以特征的形式拥有其相应的数据点。根据数据栏，每个条目在10分钟后被记录。</a></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="4f62" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">但是我们在前面的章节中已经看到它看起来像是一个3D表格数据集，对吗？这是我们可以利用一种聪明的采样数据点的方式来创建第三维空间的地方。</p><p id="1b9d" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">我们取一个大小为24的窗口，并沿着数据集的行运行它，一次移动一个位置，从而获得一定数量的2D矩阵，每个矩阵的长度为24，并具有我们所有的列特征。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mt"><img src="../Images/25754d2d83a0f478ce5e69e33b45bbbe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kKGEMg92f9MOeaNuTHN66w.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="2c60" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">在能源数据集中，有19736行。通过每24行移位采样，我们得到19712个条目，每个条目有24行和28个特征。然后，我们当然可以随机混合它们，以使它们独立且同分布(IID)。因此，本质上我们得到了一个维度数据集(19712，(24，28))，其中19712个实例中的每一个都有24行(即时间步长)和28个特征。这个实现可以在<a class="ae kv" href="https://github.com/ydataai/ydata-synthetic/blob/master/src/ydata_synthetic/preprocessing/timeseries/utils.py" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><h1 id="31e1" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">4.使用TimeGAN生成时间序列数据</h1><p id="bddf" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">TimeGAN(时序生成对抗网络)是针对合成时序数据的一种实现。它基于同一作者的一篇<a class="ae kv" href="https://papers.nips.cc/paper/2019/hash/c9efe5f26cd17ba6216bbe2a7d26d490-Abstract.html" rel="noopener ugc nofollow" target="_blank">论文</a>。YData的ydata-synthetic TimeGAN实现本质上使其在一个易于使用的库中可用，该库可以作为Python包索引(PyPi)安装。在本文中，我们将使用撰写本文时的最新版本0.3.0。</p><pre class="kg kh ki kj gt mu mv mw mx aw my bi"><span id="b85a" class="mz kx iq mv b gy na nb l nc nd">pip install ydata-synthetic==0.3.0</span></pre><p id="2d0d" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">关于这个的更多细节在<a class="ae kv" href="https://github.com/ydataai/ydata-synthetic" rel="noopener ugc nofollow" target="_blank">ydata-synthetic repository</a>上。在本节中，我们将研究如何使用能源数据集作为输入源来生成时间序列数据集。</p><p id="a5ac" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">我们首先读取能量数据集，然后以数据转换的形式应用一些预处理。这种预处理实质上是在范围[0，1]内缩放数据，并应用我们在上一节中看到的数据转换。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="07c1" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">现在，从这个时间序列数据(<em class="ne"> energy_data </em>)生成实际的合成数据是最简单的部分。我们基本上是在我们的<em class="ne"> energy_data </em>上训练TimeGAN模型，然后使用训练好的模型来生成更多。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="47a0" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">其中必须根据我们的要求适当地定义要提供给TimeGAN构造函数的参数。我们将<em class="ne"> n_seq </em>定义为28(特性)，将<em class="ne"> seq_len </em>定义为24(时间步长)。其余参数定义如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="b15e" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">现在我们已经有了生成的<em class="ne"> synth_data </em>，让我们看看它与我们的原始数据相比，在视觉上有什么不同。我们可以为28个特征中的每一个绘制一个图，并观察它们随时间步长的变化。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nf"><img src="../Images/85d752466d672937cd4e4a2b58090e00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WDozH7_2zkGUtJGo1JybYQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="4c86" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">这些图只是稍微有点意思，可能对比较没有用处。显而易见，合成数据肯定会不同于原始(真实)数据，否则这样做没有任何意义。鉴于数据集有如此多的要素，也很难以直观的方式将它们一起可视化和解释。更有趣和更有帮助的是在一个对我们来说更容易理解和更直观的维度上可视化(和比较)这些生成的数据。</p><h1 id="9cd0" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">5.评估和可视化</h1><p id="13f6" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">我们可以利用以下两种众所周知的可视化技术:</p><ol class=""><li id="6458" class="ng nh iq lq b lr ml lu mm lx ni mb nj mf nk mj nl nm nn no bi translated">PCA —主成分分析</li><li id="c0e3" class="ng nh iq lq b lr np lu nq lx nr mb ns mf nt mj nl nm nn no bi translated">t-SNE——t-分布随机邻居嵌入</li></ol><p id="f8b2" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">这些技术背后的基本思想是应用降维，以便可视化那些具有大量维度(即大量特征)的数据集。主成分分析和t-SNE都能够实现这些，它们之间的主要区别在于，主成分分析试图保留数据的全局结构(因为它着眼于在整个数据集内全局保留数据集方差的方式)，而t-SNE试图保留局部结构(通过确保原始数据中靠近的点的邻居在降维空间中也靠近)。可以在<a class="ae kv" href="https://datascience.stackexchange.com/a/36890/118385" rel="noopener ugc nofollow" target="_blank">这里</a>找到详细说明差异的精彩答案。</p><p id="1134" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">对于我们的用例，我们将使用sklearn中的PCA和TSNE对象。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="dcbb" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">既然我们要绘制的数据已经准备好了，我们可以使用matplotlib来绘制原始的和合成的转换。<em class="ne"> pca_real </em>和<em class="ne"> pca_synth </em>一起给我们pca结果，并且<em class="ne"> tsne_results </em>包含原始的和合成的(由于连接)t-SNE变换。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nu"><img src="../Images/c83450e5cd5895fe97bea3a51a63683e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nFwzK5RxGQy-nOpaZHIdjQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="ebd3" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">这些图表告诉我们什么？它们向我们展示了如果将整个数据集转换为具有较少要素的数据集(两个轴对应于两个要素)，它可能会是什么样子。主成分分析图可能不足以得出正确的结论，但t-SNE图似乎告诉我们，原始数据(黑色)和合成数据(红色)似乎遵循相似的分布。此外，特定于数据集的观察结果是，在整个数据集中有7个组(聚类)，它们的数据点彼此(明显地)相似(因此聚类在一起)。</p><h1 id="5101" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">6.结论</h1><p id="8787" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">我们简要地看了时间序列数据以及它与表格数据的区别。通过ydata-synthetic库使用TimeGAN架构是为了生成更多的时序数据。笔记本中的完整实现可以在<a class="ae kv" href="https://github.com/archity/synthetic-data-gan/blob/main/timeseries-data/energy-data-synthesize.ipynb" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p></div></div>    
</body>
</html>