<html>
<head>
<title>You Should Never Repeat Computing In Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你不应该在Python中重复计算</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/you-should-never-repeat-computing-in-python-b097d57cf661?source=collection_archive---------11-----------------------#2021-08-15">https://towardsdatascience.com/you-should-never-repeat-computing-in-python-b097d57cf661?source=collection_archive---------11-----------------------#2021-08-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/d89226ebe7c752d159490f9c422a1ee6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aYtStsKhLOBmPqrfRG8T0A.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">图片来自<a class="ae jg" href="https://pixabay.com/users/nastasyaday-11197808/" rel="noopener ugc nofollow" target="_blank"> NastasyaDay </a>来自<a class="ae jg" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=6514669" rel="noopener ugc nofollow" target="_blank"> Pixabay </a></p></figure><div class=""/><div class=""><h2 id="59f2" class="pw-subtitle-paragraph kg ji jj bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dk translated">Python中的内置函数工具帮助我们缓存</h2></div><p id="4d41" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你做编程的很多，你一定知道一个编程原则就是“不重复自己”。那是在编码层面。能概括的就不要重复了。</p><p id="dcc2" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是，我要讨论的话题是“不要重复计算”。也就是说，如果我们已经计算了某个东西，我们就不应该在另一个时间计算它。您可能会想到一个可以缓存结果的解决方案。是的，我们可以用任何编程语言实现缓存机制。然而，在Python中，这是现成的！</p><p id="5134" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在本文中，我将介绍一个名为<code class="fe lu lv lw lx b">lru_cache</code>的Python内置装饰器，它可以启用开箱即用的缓存机制。在动态编程、Web开发等很多场景下都会超级有效。</p><h1 id="cfb0" class="ly lz jj bd ma mb mc md me mf mg mh mi kp mj kq mk ks ml kt mm kv mn kw mo mp bi translated">什么是LRU缓存？</h1><figure class="mq mr ms mt gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/884b1b31467a72c94d25f1a10e07625b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*64Io23eVHdWD_WB_s7PTvQ.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">图片来自<a class="ae jg" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=4203677" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>的<a class="ae jg" href="https://pixabay.com/users/valdasmiskinis-12049839/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=4203677" rel="noopener ugc nofollow" target="_blank"> Valdas Miskinis </a></p></figure><h2 id="24a6" class="mu lz jj bd ma mv mw dn me mx my dp mi lh mz na mk ll nb nc mm lp nd ne mo nf bi translated"><strong class="ak"><em class="ng">TL；</em>博士</strong></h2><p id="f1a4" class="pw-post-body-paragraph ky kz jj la b lb nh kk ld le ni kn lg lh nj lj lk ll nk ln lo lp nl lr ls lt im bi translated"><em class="nm">如果您没有完全理解本节中的概念，请不要害怕。从下一节中的例子开始并不是一个坏主意。然后，回到这里你就没事了:)</em></p><p id="a873" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在我们开始之前，需要澄清一些概念。我们今天要讨论的<code class="fe lu lv lw lx b">lru_cache</code>是一个Python装饰器。如果你仍然不知道什么是室内设计师，请看看这篇文章。</p><div class="is it gp gr iu nn"><a rel="noopener follow" target="_blank" href="/the-simplest-tutorial-for-python-decorator-dadbf8f20b0f"><div class="no ab fo"><div class="np ab nq cl cj nr"><h2 class="bd jk gy z fp ns fr fs nt fu fw ji bi translated">Python装饰者的最简单教程</h2><div class="nu l"><h3 class="bd b gy z fp ns fr fs nt fu fw dk translated">添加任何函数/类的“Pythonic式”包装，而不修改它们</h3></div><div class="nv l"><p class="bd b dl z fp ns fr fs nt fu fw dk translated">towardsdatascience.com</p></div></div><div class="nw l"><div class="nx l ny nz oa nw ob ja nn"/></div></div></a></div><p id="6e09" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后，它涉及到LRU的概念。它代表“最近最少使用的”。当最近的调用是即将到来的调用的最佳预测时，LRU缓存工作得最好。例如，虽然我已经写了近100篇关于数据科学的文章，但前10篇文章贡献了近80%的总阅读量。如果我要写一个网站来托管这些文章，缓存这10篇文章是个好主意，这样大多数读者就可以以最佳性能加载它们。</p><h2 id="38a1" class="mu lz jj bd ma mv mw dn me mx my dp mi lh mz na mk ll nb nc mm lp nd ne mo nf bi translated">缓存大小限制</h2><p id="9450" class="pw-post-body-paragraph ky kz jj la b lb nh kk ld le ni kn lg lh nj lj lk ll nk ln lo lp nl lr ls lt im bi translated">如果我们不知道哪些文章是最受欢迎的呢？这意味着我们不能指定缓存哪一个。我们应该缓存所有内容吗？当然不是，因为缓存一切就意味着什么都不缓存。</p><p id="aed4" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在Python中，我们可以为LRU缓存指定一个缓存大小限制，这样它就不会无限制地增长。这对于长时间运行的进程(如Web服务器)非常重要。</p><p id="d20f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe lu lv lw lx b">lru_cache()</code>采用一个名为<code class="fe lu lv lw lx b">maxsize</code>的参数。我们可以使用这个参数来限制缓存大小。如果<code class="fe lu lv lw lx b">maxsize</code>设置为无，缓存可以无限制增长。当<code class="fe lu lv lw lx b">maxsize</code>是2的幂时，LRU特性表现最佳。</p><h2 id="ffe3" class="mu lz jj bd ma mv mw dn me mx my dp mi lh mz na mk ll nb nc mm lp nd ne mo nf bi translated">什么时候我们不应该使用LRU缓存？</h2><p id="8e91" class="pw-post-body-paragraph ky kz jj la b lb nh kk ld le ni kn lg lh nj lj lk ll nk ln lo lp nl lr ls lt im bi translated">基本上，除非我们懒得加或者计算过程预计不会重复，否则我们总是可以用的。</p><p id="632d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是，在这种情况下，我们不应该使用LRU缓存。缓存有副作用的函数、需要在每次调用时创建不同的可变对象的函数或者不纯的函数(如time()或random())是没有意义的。</p><h1 id="c711" class="ly lz jj bd ma mb mc md me mf mg mh mi kp mj kq mk ks ml kt mm kv mn kw mo mp bi translated">一个基本例子</h1><figure class="mq mr ms mt gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/e0d0b8f7656ea84f38ff016c609d8540.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mt3EG_NUNrEuq7G3neOGSg.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">图片来自<a class="ae jg" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=2714998" rel="noopener ugc nofollow" target="_blank"> Pixabay </a></p></figure><p id="f0e9" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">太多干的东西。让我们用一个例子来演示在Python中使用LRU缓存是多么容易。</p><p id="8861" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">LRU缓存内置于Python中。所以，我们不需要下载任何包，但是我们需要在使用之前导入函数。</p><pre class="mq mr ms mt gt oc lx od oe aw of bi"><span id="779c" class="mu lz jj lx b gy og oh l oi oj">from functools import lru_cache</span></pre><p id="9494" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后，让我们用<code class="fe lu lv lw lx b">lru_cache</code>作为装饰器来定义一个函数。</p><pre class="mq mr ms mt gt oc lx od oe aw of bi"><span id="a915" class="mu lz jj lx b gy og oh l oi oj"><a class="ae jg" href="http://twitter.com/lru_cache" rel="noopener ugc nofollow" target="_blank">@lru_cache</a>(maxsize=1)<br/>def compute_something():<br/>    return pow(123, 456)</span></pre><p id="b236" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们定义的函数只是为了演示的目的而“计算一些东西”。这里我们计算123的456次方。这将是一个很大的数字，但无论如何，这并不重要。</p><p id="9fce" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">重要的是我们增加了<code class="fe lu lv lw lx b">lru_cache</code>作为函数的装饰器。同样，我们已经定义了<code class="fe lu lv lw lx b">maxsize=1</code>。因此，缓存将只保留1个计算结果。这是有意义的，因为这个函数只有一个计算结果。</p><p id="11b9" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，让我们用计时统计运行这个函数。</p><pre class="mq mr ms mt gt oc lx od oe aw of bi"><span id="151f" class="mu lz jj lx b gy og oh l oi oj">%%timeit<br/>compute_something()</span></pre><figure class="mq mr ms mt gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ok"><img src="../Images/cf166ec6b37d5a629b1ad98c66a46c86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SHEGzLQ6T4CLwV63zYqnoQ.png"/></div></div></figure><p id="96bb" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">结果显示，最慢的运行(第一次运行)比最快的运行慢144倍。此外，检测到某些内容可能被缓存。是的，没错。我们知道结果被LRU缓存器缓存了。因此，除了第一次运行之外，其余所有运行都将只是从缓存中获得结果，而不是再次计算它。</p><h2 id="601e" class="mu lz jj bd ma mv mw dn me mx my dp mi lh mz na mk ll nb nc mm lp nd ne mo nf bi translated">缓存信息</h2><p id="2680" class="pw-post-body-paragraph ky kz jj la b lb nh kk ld le ni kn lg lh nj lj lk ll nk ln lo lp nl lr ls lt im bi translated">我们如何证实这一点？是的，我们可以。使用<code class="fe lu lv lw lx b">cache_info()</code>可以检查所有LRU缓存启用的功能。</p><pre class="mq mr ms mt gt oc lx od oe aw of bi"><span id="1745" class="mu lz jj lx b gy og oh l oi oj">compute_something.cache_info()</span></pre><figure class="mq mr ms mt gt iv gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/c08d279c5d78b4622ad42b7ef0429bc7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1070/format:webp/1*xlbNdV_3UhbpMFcvEws4rA.png"/></div></figure><p id="3153" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">缓存信息包含四个统计信息:</p><ul class=""><li id="f9c9" class="om on jj la b lb lc le lf lh oo ll op lp oq lt or os ot ou bi translated"><code class="fe lu lv lw lx b">hits</code>缓存被使用的次数。</li></ul><p id="d435" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，我们可以使用这个值来衡量缓存机制节省了多少次重新计算相同内容的时间。</p><ul class=""><li id="27df" class="om on jj la b lb lc le lf lh oo ll op lp oq lt or os ot ou bi translated"><code class="fe lu lv lw lx b">misses</code>缓存未被使用的次数。</li></ul><p id="e8d2" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这种情况下，我们只有一次运行没有使用来自LRU缓存的结果。那是第一轮。</p><ul class=""><li id="cf08" class="om on jj la b lb lc le lf lh oo ll op lp oq lt or os ot ou bi translated"><code class="fe lu lv lw lx b">maxsize</code>我们定义的缓存限制的大小。</li><li id="b434" class="om on jj la b lb ov le ow lh ox ll oy lp oz lt or os ot ou bi translated"><code class="fe lu lv lw lx b">currsize</code>当前缓存的结果数。</li></ul><h2 id="66e7" class="mu lz jj bd ma mv mw dn me mx my dp mi lh mz na mk ll nb nc mm lp nd ne mo nf bi translated">清除缓存</h2><p id="78bd" class="pw-post-body-paragraph ky kz jj la b lb nh kk ld le ni kn lg lh nj lj lk ll nk ln lo lp nl lr ls lt im bi translated">如果有必要，我们还可以清除LRU的缓存。</p><pre class="mq mr ms mt gt oc lx od oe aw of bi"><span id="8566" class="mu lz jj lx b gy og oh l oi oj">compute_something.cache_clear()</span></pre><p id="7fee" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">清除后，所有缓存的结果都将被删除，缓存信息也将被重置。</p><figure class="mq mr ms mt gt iv gh gi paragraph-image"><div class="gh gi pa"><img src="../Images/8eeb87006d77e39dc7fee98f632d3487.png" data-original-src="https://miro.medium.com/v2/resize:fit:950/format:webp/1*ArJ0Pa83P3bdNNio4UzUGw.png"/></div></figure><h1 id="49cd" class="ly lz jj bd ma mb mc md me mf mg mh mi kp mj kq mk ks ml kt mm kv mn kw mo mp bi translated">递归和动态编程</h1><figure class="mq mr ms mt gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/86d9d58d1e7c90bb4d998bffedaa048a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uGm88tRXPVTZay4jZtS0IQ.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">图片来自<a class="ae jg" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=1959267" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>的<a class="ae jg" href="https://pixabay.com/users/hans-2/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=1959267" rel="noopener ugc nofollow" target="_blank"> Hans Braxmeier </a></p></figure><p id="d732" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，让我们编造一些实际的例子。受益于LRU缓存的一个典型场景是递归函数。动态编程被认为比简单的递归函数更高级，但是我们必须手动实现缓存机制。有了LRU缓存，所有这些都不是问题。</p><p id="c593" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们用一个基本且流行的递归问题——斐波那契递归。这是它的递归树。</p><figure class="mq mr ms mt gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pb"><img src="../Images/9ac1b4b8e07d9c892442ecfb5ec30043.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*UK-1I9kmutuuRWdY.jpg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">图片提供:<a class="ae jg" href="http://theoryofprogramming.com/2015/03/02/dynamic-programming-introduction-and-fibonacci-numbers/" rel="noopener ugc nofollow" target="_blank">http://theory of programming . com/2015/03/02/dynamic-programming-introduction-and-Fibonacci-numbers/</a></p></figure><p id="17bf" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你看到<code class="fe lu lv lw lx b">fib(6)</code>功能的问题了吗？许多子功能被计算了不止一次。比如<code class="fe lu lv lw lx b">fib(2)</code>被计算了5次。如果我们正在计算一个更大的斐波那契数，重复的时间将会成倍增加。</p><p id="822e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">嗯，这是在一个单独的斐波那契数计算的范围内。如果我们正在计算更多呢？比如我们要计算从1到10的斐波那契数，重复计算的次数会更大。将会有大量的CPU和执行时间的浪费。</p><p id="4b42" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们做一个简单的实验。</p><pre class="mq mr ms mt gt oc lx od oe aw of bi"><span id="3f32" class="mu lz jj lx b gy og oh l oi oj">computing_times = 0</span><span id="6d8e" class="mu lz jj lx b gy pc oh l oi oj">def fib(n):<br/>    global computing_times<br/>    computing_times += 1<br/>    if n &lt; 2:<br/>        return n<br/>    return fib(n-1) + fib(n-2)</span></pre><p id="396c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在上面的代码中，我们定义了斐波那契递归函数。除此之外，我们还定义了一个全局变量<code class="fe lu lv lw lx b">computing_times</code>来计算函数被调用的次数。</p><p id="5e5a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，让我们写一个for循环来计算从1到10的所有斐波那契数列。</p><pre class="mq mr ms mt gt oc lx od oe aw of bi"><span id="73ce" class="mu lz jj lx b gy og oh l oi oj">for n in range(10):<br/>    fib(n)</span></pre><figure class="mq mr ms mt gt iv gh gi paragraph-image"><div class="gh gi pd"><img src="../Images/1d5ee5ea05e84572eb521203708f9ee0.png" data-original-src="https://miro.medium.com/v2/resize:fit:652/format:webp/1*KWed_u-xKApNMVKH3skjrQ.png"/></div></figure><p id="041a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">显示该函数被调用了276次！</p><p id="8a16" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，让我们将LRU缓存添加到函数中。我懒得计算我们需要多大的尺寸，所以我只想设置<code class="fe lu lv lw lx b">maxsize=None</code>。这没问题，因为我们知道在这个演示中缓存大小不会疯狂增长:)</p><pre class="mq mr ms mt gt oc lx od oe aw of bi"><span id="98f0" class="mu lz jj lx b gy og oh l oi oj">computing_times = 0</span><span id="9ba0" class="mu lz jj lx b gy pc oh l oi oj"><a class="ae jg" href="http://twitter.com/lru_cache" rel="noopener ugc nofollow" target="_blank">@lru_cache</a>(maxsize=None)<br/>def fib(n):<br/>    global computing_times<br/>    computing_times += 1<br/>    if n &lt; 2:<br/>        return n<br/>    return fib(n-1) + fib(n-2)</span><span id="0fed" class="mu lz jj lx b gy pc oh l oi oj">for n in range(10):<br/>    _ = fib(n)</span></pre><figure class="mq mr ms mt gt iv gh gi paragraph-image"><div class="gh gi pe"><img src="../Images/b73ee4b5beef3d4ddf17e53ca666e0bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:636/format:webp/1*ErqzbVympfhAXC24Sa50TA.png"/></div></figure><p id="8ba1" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">哇，就10次！这很有意义，我们实际上只需要计算从1到10的斐波纳契数。所以，这是10倍。所有剩余的计算都可以跳过，因为它们被缓存了。</p><p id="4ae5" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们所做的就是向函数添加装饰器。就是这样！</p><pre class="mq mr ms mt gt oc lx od oe aw of bi"><span id="f7d4" class="mu lz jj lx b gy og oh l oi oj"><a class="ae jg" href="http://twitter.com/lru_cache" rel="noopener ugc nofollow" target="_blank">@lru_cache</a>(maxsize=None)</span></pre><p id="d4d8" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当然，我们可以检查缓存信息。它还记录了统计数据。</p><figure class="mq mr ms mt gt iv gh gi paragraph-image"><div class="gh gi pf"><img src="../Images/f90b6ce9ec82c618c9614e509a99eaf2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1038/format:webp/1*w4zhTe4Jy2OvxNp4VW2ahQ.png"/></div></figure><h1 id="f983" class="ly lz jj bd ma mb mc md me mf mg mh mi kp mj kq mk ks ml kt mm kv mn kw mo mp bi translated">Web请求处理</h1><figure class="mq mr ms mt gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/36c83abfb15bf00f4db00af43b4eeef3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xea1uTl3nHIKMRRXWOAnFQ.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">图片来自<a class="ae jg" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=1572617" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>的<a class="ae jg" href="https://pixabay.com/users/martinelle-495565/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=1572617" rel="noopener ugc nofollow" target="_blank"> Martinelle </a></p></figure><p id="a2e0" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">另一个更实际的例子是Web开发。假设我们正在为一个Web服务开发一个后端服务器。因此，我们需要接收所有用户的请求，并根据请求做出响应。如果我们的大多数用户请求少量的资源，这将是一个完美的缓存场景。</p><p id="1c5f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们在这个演示中使用Python PEP (Python增强提案)。假设我们正在开发一个基于数字检索PEP文档的函数。</p><p id="9e73" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">启用LRU缓存后，完整实现的功能如下。</p><pre class="mq mr ms mt gt oc lx od oe aw of bi"><span id="cacb" class="mu lz jj lx b gy og oh l oi oj">import urllib.request<br/>import urllib.error</span><span id="e690" class="mu lz jj lx b gy pc oh l oi oj"><a class="ae jg" href="http://twitter.com/lru_cache" rel="noopener ugc nofollow" target="_blank">@lru_cache</a>(maxsize=32)<br/>def get_pep(num):<br/>    'Retrieve text of a Python Enhancement Proposal'<br/>    resource = f'<a class="ae jg" href="http://www.python.org/dev/peps/pep-{num:04d}/'" rel="noopener ugc nofollow" target="_blank">http://www.python.org/dev/peps/pep-{num:04d}/'</a><br/>    try:<br/>        with urllib.request.urlopen(resource) as s:<br/>            return s.read()<br/>    except urllib.error.HTTPError:<br/>        return 'Not Found'</span></pre><p id="618e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">该函数以PEP编号为参数，从PEP官网检索。LRU缓存启用了<code class="fe lu lv lw lx b">maxsize=32</code>,因为这一次我们不希望缓存变得太大。我们假设大多数用户对一些重要的PEP文档感兴趣。</p><p id="5053" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，让我们用for循环来模拟请求。</p><pre class="mq mr ms mt gt oc lx od oe aw of bi"><span id="eb85" class="mu lz jj lx b gy og oh l oi oj">for n in 8, 290, 308, 320, 8, 218, 320, 279, 289, 320, 9991:<br/>    pep = get_pep(n)<br/>    print(f'PEP-{n}, Length: {len(pep)}')</span></pre><p id="df0b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因为我们只是在测试LRU缓存，所以我只想计算HTML页面上的字符数。</p><figure class="mq mr ms mt gt iv gh gi paragraph-image"><div class="gh gi pg"><img src="../Images/22242f1af0d61ee87c9881210b323b67.png" data-original-src="https://miro.medium.com/v2/resize:fit:1172/format:webp/1*ACl63ryP6Wr7RNFmSYn4ig.png"/></div></figure><p id="9864" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如截图所示。红色的是第一次计算的，而绿色的则利用了缓存的结果。</p><p id="c5d6" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，在这11个请求中，有3个来自缓存。这意味着我们不需要向URL发送GET请求，获取HTML内容并计算字符数。结果只是从缓存中获得。</p><figure class="mq mr ms mt gt iv gh gi paragraph-image"><div class="gh gi ph"><img src="../Images/0727011cd1eb5feea871352ea6ed82e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:988/format:webp/1*ufuH15ZpSCu_1jJJsb-JDg.png"/></div></figure><p id="932e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这种情况下，LRU缓存不仅节省了计算时间，还节省了网络流量的时间。这可以为我们节省大量资源，并以更快的方式为用户服务。</p><h1 id="4f72" class="ly lz jj bd ma mb mc md me mf mg mh mi kp mj kq mk ks ml kt mm kv mn kw mo mp bi translated">摘要</h1><figure class="mq mr ms mt gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/ad194ddd277e914f95bd41af344fbd5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1VZ5omGaNaNh5WheWzjgtg.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">图片由<a class="ae jg" href="https://pixabay.com/users/anestiev-2736923/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=6096180" rel="noopener ugc nofollow" target="_blank">克里斯托·阿涅斯特夫</a>从<a class="ae jg" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=6096180" rel="noopener ugc nofollow" target="_blank">皮克斯拜</a>拍摄</p></figure><p id="b213" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在本文中，我介绍了LRU缓存，它是Python内置的<code class="fe lu lv lw lx b">functools</code>模块中的一个工具。它可以缓存函数的结果以防止重复计算。</p><p id="c102" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这两个实例表明，LRU缓存在递归函数、动态编程以及Web服务等需要重复的场景中有很大的价值。正确使用LRU缓存将节省我们大量的硬件资源和执行时间。</p><div class="is it gp gr iu nn"><a href="https://medium.com/@qiuyujx/membership" rel="noopener follow" target="_blank"><div class="no ab fo"><div class="np ab nq cl cj nr"><h2 class="bd jk gy z fp ns fr fs nt fu fw ji bi translated">通过我的推荐链接加入Medium克里斯托弗·陶</h2><div class="nu l"><h3 class="bd b gy z fp ns fr fs nt fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="nv l"><p class="bd b dl z fp ns fr fs nt fu fw dk translated">medium.com</p></div></div><div class="nw l"><div class="pi l ny nz oa nw ob ja nn"/></div></div></a></div><p id="33d6" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你觉得我的文章有帮助，请考虑加入Medium会员来支持我和其他成千上万的作者！(点击上面的链接)</p></div></div>    
</body>
</html>