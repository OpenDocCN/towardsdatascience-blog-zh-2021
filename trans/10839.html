<html>
<head>
<title>Top 3 Visualization Python Packages to Help Your Data Science Activities</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">帮助您开展数据科学活动的三大可视化Python包</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/top-3-visualization-python-packages-to-help-your-data-science-activities-168e22178e53?source=collection_archive---------10-----------------------#2021-10-20">https://towardsdatascience.com/top-3-visualization-python-packages-to-help-your-data-science-activities-168e22178e53?source=collection_archive---------10-----------------------#2021-10-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="fa6a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用这些包来帮助您的数据科学工作</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/828412c8a38412142336663461a4a00b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*31iBxmqQ1yRnvT-I"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@firmbee?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Firmbee.com</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</p></figure><p id="1824" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">数据可视化是将数据汇总成图形表示以帮助人们理解数据的过程。想象一下没有数据可视化的数据探索或验证？很难，对吧？。此外，数据可视化可能揭示我们在统计摘要中找不到的额外信息。</p><p id="621a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">数据可视化也有助于数据科学家的工作，例如，理解我们的数据、特征选择和验证我们的机器学习模型。为了进一步帮助您的工作，我想概述我的三个顶级可视化python包，以帮助您的数据科学活动。让我们开始吧。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="1669" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">1.AutoViz</h1><p id="f339" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><a class="ae ky" href="https://github.com/AutoViML/AutoViz" rel="noopener ugc nofollow" target="_blank"> AutoViz </a>是<a class="ae ky" href="https://github.com/AutoViML" rel="noopener ugc nofollow" target="_blank"> AutoViML </a>包库下的一个开源可视化包，旨在自动化许多数据科学家的工作。许多项目快速而直接，但无疑是有帮助的，包括AutoViz。</p><p id="b631" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> AutoViz是一个单行代码可视化包，可以自动生成数据可视化</strong>。让我们尝试这个包来展示为什么AutoViz可以帮助您的工作。首先，我们需要安装AutoViz。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="0221" class="ne md it na b gy nf ng l nh ni">pip install autoviz</span></pre><p id="5052" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">安装完软件包后，让我们使用一个样本数据集。在本文中，我将使用来自<a class="ae ky" href="https://www.kaggle.com/new-york-city/nyc-property-sales" rel="noopener ugc nofollow" target="_blank"> Kaggle </a>的纽约房地产销售数据集。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="ff2e" class="ne md it na b gy nf ng l nh ni">df = pd.read_csv('nyc-rolling-sales.csv')</span></pre><p id="b9d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用AutoViz，我们只需要从包中导入一个类函数，并执行一行代码来自动生成可视化。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="ba07" class="ne md it na b gy nf ng l nh ni">#Importing the class function<br/>from autoviz.AutoViz_Class import AutoViz_Class<br/>AV = AutoViz_Class()</span><span id="f90b" class="ne md it na b gy nj ng l nh ni">#Automatically produce dataset<br/>AV.AutoViz("",dfte = df )</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/f24f53b47ec9a9da10f5f415b8d5ccdb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/1*CRkidft4usbra_03P1wizA.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者GIF</p></figure><p id="607c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从上面的GIF中我们可以看到，AutoViz包基于我们的数据集自动生成了许多可视化效果。可视化简单；然而，执行时间很快，并且该图有助于特征选择的初始分析。让我们详细看看AutoViz生产了什么。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nl"><img src="../Images/1d29c3811d8e097aa299a18998a5f448.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Js0ydFqo8XQ2ENWF5yJt7w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="4d07" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">AutoViz的第一步是将要素分类为特定的数据类型，并使用这些信息来决定使用哪种可视化来表示数据。从这里，让我们来看看一些生产的情节快照。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nm"><img src="../Images/019a71a796f475c84f43ba81ecfb374c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vqbZS8-aWnuPqfgFQmSKbQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来自AutoViz的成对散点图(图片由作者提供)</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nn"><img src="../Images/c81c913598deddce0c699e075c980562.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zom448mh6NUv22ebXvCMFA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">分布图来自AutoViz(图片由作者提供)</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/83b07b82337083ad69b97941fb72faf4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QKZx8e1zvoWHsARF0o6iMQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">违反AutoViz的情节(图片由作者提供)</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi np"><img src="../Images/fdae9b5048a5cfe2d3cf9495a59dab86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C7iphUve4dfDrUyWLP7tiw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来自AutoViz的方框图(图片由作者提供)</p></figure><p id="0b85" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些是AutoViz制作的示例图。许多其他软件包自动可视化数据，但AutoViz有一些我觉得其他人没有的优势。<strong class="lb iu">可视化产生的速度有多快，结果的重量有多轻</strong>。这就是为什么我建议AutoViz自动可视化您的数据，特别是如果您需要对您的数据进行初步评估。</p><p id="01f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想看看其他的自动可视化软件包，可以看看我下面的其他文章。</p><div class="nq nr gp gr ns nt"><a rel="noopener follow" target="_blank" href="/data-frame-eda-packages-comparison-pandas-profiling-sweetviz-and-pandasgui-bbab4841943b"><div class="nu ab fo"><div class="nv ab nw cl cj nx"><h2 class="bd iu gy z fp ny fr fs nz fu fw is bi translated">数据框EDA软件包比较:Pandas Profiling、Sweetviz和PandasGUI</h2><div class="oa l"><h3 class="bd b gy z fp ny fr fs nz fu fw dk translated">哪些熊猫数据框EDA包适合你？</h3></div><div class="ob l"><p class="bd b dl z fp ny fr fs nz fu fw dk translated">towardsdatascience.com</p></div></div><div class="oc l"><div class="od l oe of og oc oh ks nt"/></div></div></a></div><div class="nq nr gp gr ns nt"><a rel="noopener follow" target="_blank" href="/quick-recommendation-based-data-exploration-with-lux-f4d0ccb68133"><div class="nu ab fo"><div class="nv ab nw cl cj nx"><h2 class="bd iu gy z fp ny fr fs nz fu fw is bi translated">使用Lux进行基于快速推荐的数据探索</h2><div class="oa l"><h3 class="bd b gy z fp ny fr fs nz fu fw dk translated">通过基于一行建议的数据探索，轻松探索您的数据</h3></div><div class="ob l"><p class="bd b dl z fp ny fr fs nz fu fw dk translated">towardsdatascience.com</p></div></div><div class="oc l"><div class="oi l oe of og oc oh ks nt"/></div></div></a></div></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="b9f4" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">2.缺少编号</h1><p id="590b" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><strong class="lb iu">数据探索不仅限于数据集中存在的数据，还包括数据集中缺失的数据</strong>。有这样的情况，丢失的数据是由于一个意外或纯粹的机会发生的，但这通常是不正确的。缺失的数据可能会揭示出我们以前从来不知道的洞察力。如果想了解缺失数据的分类，可以看下面的文章。</p><div class="nq nr gp gr ns nt"><a href="https://medium.datadriveninvestor.com/3-missing-data-types-and-the-suggestion-to-handle-it-75eb10bfdf3b" rel="noopener  ugc nofollow" target="_blank"><div class="nu ab fo"><div class="nv ab nw cl cj nx"><h2 class="bd iu gy z fp ny fr fs nz fu fw is bi translated">3种缺失的数据类型及处理建议</h2><div class="oa l"><h3 class="bd b gy z fp ny fr fs nz fu fw dk translated">知道关于丢失的数据应该知道什么</h3></div><div class="ob l"><p class="bd b dl z fp ny fr fs nz fu fw dk translated">medium.datadriveninvestor.com</p></div></div><div class="oc l"><div class="oj l oe of og oc oh ks nt"/></div></div></a></div><p id="6975" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">推出</strong><a class="ae ky" href="https://github.com/ResidentMario/missingno" rel="noopener ugc nofollow" target="_blank"><strong class="lb iu">missing no</strong></a><strong class="lb iu">，一款专门为可视化您的丢失数据而开发的软件包</strong>。这个包提供了一个易于使用的有见地的一行代码来解释缺失数据，并显示了缺失数据之间的关系。让我们尝试一下这个包，以便更好地理解。</p><p id="6f12" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们需要安装missingno包。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="7c4e" class="ne md it na b gy nf ng l nh ni">pip install missingno</span></pre><p id="34e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于这个例子，我将使用Kaggle的M<a class="ae ky" href="https://www.kaggle.com/snocco/missing-migrants-project" rel="noopener ugc nofollow" target="_blank">is sing migrators项目</a>数据集。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="cfd4" class="ne md it na b gy nf ng l nh ni">df = pd.read_csv('MissingMigrants-Global-2019-12-31_correct.csv')<br/>df.info()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/e0c83d99aece6ae3667355285070bfcd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1132/format:webp/1*2kQUVwqawo58Ft-nzhQc0A.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来自作者</p></figure><p id="bf4b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">数据集包含大量缺失数据，每列的缺失量不同。为什么会发生这种情况？这里是否有缺失的数据模式？让我们用missingno来找出答案。首先，让我们将缺失的数据可视化。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="66ef" class="ne md it na b gy nf ng l nh ni">missingno.bar(df, figsize=(10,5), fontsize=12, sort="ascending")</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ol"><img src="../Images/ce2f9abef2faf68f2cd881ea2722115e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WAyD8JcoQzar4rQrP55d4Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">缺失数据条形图(图片由作者提供)</p></figure><p id="3b82" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的函数生成一个条形图来显示每一列中的数据数量。正如我们所看到的，“最小估计失踪人数”的数据最多，其次是“儿童人数”、“幸存者人数”，等等。如果要计算日志中缺失数据的数量，我们可以使用下面的代码。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="02d7" class="ne md it na b gy nf ng l nh ni">missingno.bar(df, log=True,figsize=(10,5), color="tab:green", fontsize=12,sort="ascending")</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi om"><img src="../Images/07c39eb4f3e220a47d5d3272891c9a8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QSQfQIswgPL_OGzqKpZvig.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">日志缺失数据编号(图片由作者提供)</p></figure><p id="e09d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对数可以帮助您了解每一列中缺失数据的百分比。我们可以看到,‘最小估计缺失数’一栏只占目前全部数据的不到10%,其余都是缺失的。</p><p id="b9be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">缺失的数据可能有一种模式，无论是因为另一列的存在、及时的方式，还是纯粹的偶然。为了可视化这个缺失数据模式，让我们尝试使用矩阵图来可视化数据集中缺失数据的位置。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="01c1" class="ne md it na b gy nf ng l nh ni">missingno.matrix(df,figsize=(10,5), fontsize=12)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi on"><img src="../Images/685dee57583ca1cadafb32b6fe061557.png" data-original-src="https://miro.medium.com/v2/resize:fit:1318/format:webp/1*t3A_HyslZ6n1iWyjMJ3jaw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">缺失数据矩阵(图片由作者提供)</p></figure><p id="ce2a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了给出一个背景，我们的移民失踪项目数据集按时间(从2014年到2019年)从最近到最早排序。最上面的数据位置是最近的(2019)，最下面的数据位置是最早的(2014)。</p><p id="6b88" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们看上面的图表,“URL”缺失数据似乎更多地出现在更早的时间，类似于“男性数量”。它不同于最近越来越多地丢失数据的“迁移路线”列。上面的图表可以让我们更好地了解我们的数据集中发生了什么。</p><p id="629c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用missingno，我们可以可视化<strong class="lb iu">零相关性</strong>(范围-1到1)来测量要素之间的缺失数据关系。让我们试一试。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="b20b" class="ne md it na b gy nf ng l nh ni">missingno.heatmap(df, figsize=(10,5), fontsize=12)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oo"><img src="../Images/bdbb70c0bcf1daadbb581fb96fce41c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cGBc1gM0HXbfdVxS8Dd1Sw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">无效相关热图(图片由作者提供)</p></figure><p id="09ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">零相关性为我们提供了丢失数据的列之间的关系。分数越接近-1，意味着一列的数据存在，另一列的数据将会丢失。相反，当它接近1时，当其他列数据存在时，该数据也存在。0表示特征之间没有相关性。</p><p id="90ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了更深入地理解特征之间的缺失数据关系，我们可以使用missingno来构建基于<a class="ae ky" href="http://docs.scipy.org/doc/scipy/reference/cluster.hierarchy.html" rel="noopener ugc nofollow" target="_blank">分层聚类算法</a>和零相关性的树状图。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="e3a7" class="ne md it na b gy nf ng l nh ni">missingno.dendrogram(df, figsize=(10,5), fontsize=12)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi op"><img src="../Images/607cd27bf9c3691a3f022b315b6bed2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1382/format:webp/1*92T87HHhSsjNzKaBKIlQpw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">缺失数据树状图(图片由作者提供)</p></figure><p id="9601" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了解释上面的树状图，我们将从自上而下的角度来看。显示以最近距离链接在一起的要素或聚类，以预测彼此缺失的数据或更好地呈现数据。例如，要素“幸存者人数”和“最小估计失踪人数”比其他要素更早聚类在一起，这意味着它们比其他要素更好地预测彼此。</p><p id="b09c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以零距离链接在一起的聚类要素意味着它们可以完全预测彼此(一个缺失，另一个存在，或者两者都总是缺失/存在)。不在零处分裂的叶聚类意味着它们可以预测彼此，但是可能是不完美的(越接近零，它们越能预测彼此缺失的数据/存在的数据)。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="b06f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">3.黄砖</h1><p id="7e6b" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">当你探索了数据，发现了有见地的模式，就该开发机器学习模型了。为了帮助您的机器学习开发和评估，我们有一个名为<a class="ae ky" href="https://www.scikit-yb.org/en/latest/index.html" rel="noopener ugc nofollow" target="_blank"> Yellowbrick </a>的python包来可视化机器学习模型过程。</p><p id="7a14" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Yellowbrick是一个开源包，可以可视化并作为构建在Scikit-Learn之上的诊断工具。Yellowbrick的开发是为了使用从Scikit-Learn API扩展而来的各种可视化API来帮助模型选择过程。</p><p id="41c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在开发我们的机器学习模型时，让我们尝试一些Yellowbricks的可视化API。在这个例子中，我将使用来自Kaggle的<a class="ae ky" href="https://www.kaggle.com/imakash3011/customer-personality-analysis" rel="noopener ugc nofollow" target="_blank">客户分析数据集</a>。首先，让我们尝试创建一个分类器模型，并使用Yellowbricks来可视化分类报告。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="9989" class="ne md it na b gy nf ng l nh ni">from yellowbrick.classifier import ClassificationReport<br/>from sklearn.linear_model import LogisticRegression<br/>from sklearn.model_selection import train_test_split</span><span id="b363" class="ne md it na b gy nj ng l nh ni">#Reading the data and dropping some data<br/>df = pd.read_csv('marketing_campaign.csv', sep = '\t')<br/>df = df.drop(['ID', 'Dt_Customer', 'Education', 'Marital_Status'], axis = 1).dropna().reset_index(drop = True)</span><span id="2c14" class="ne md it na b gy nj ng l nh ni">X_train, X_test, y_train, y_test = train_test_split(df.drop('Response', axis = 1), df['Response'])</span><span id="cca7" class="ne md it na b gy nj ng l nh ni">model = LogisticRegression()<br/>visualizer = ClassificationReport(model)</span><span id="9398" class="ne md it na b gy nj ng l nh ni">visualizer.fit(X_train, y_train)<br/>visualizer.score(X_test, y_test)<br/>visualizer.show()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/5ebc4a3cbdf7f7111ba1c0013fb981db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1040/format:webp/1*wEF2Q0Ap3TrQmzGFAj5TTA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">逻辑回归分类报告自</p></figure><p id="ae0b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们从Scikit-Learn开发了逻辑回归模型，并从上面的函数可视化了分类报告指标。我们可以看到，与类0相比，我们的模型在类1中的得分较低。</p><p id="50ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了评估我们的预测模型，让我们看看ROC-AUC指标的可视化。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="3f38" class="ne md it na b gy nf ng l nh ni">from yellowbrick.classifier import ROCAUC</span><span id="069b" class="ne md it na b gy nj ng l nh ni">visualizer = ROCAUC(model)<br/>visualizer.fit(X_train, y_train)<br/>visualizer.score(X_test, y_test)<br/>visualizer.show()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi or"><img src="../Images/e2bd5cdb24b08028c48e7178397bfb5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1004/format:webp/1*dnX9Jo-3eu0OI5ohQwSIiA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Yellowbrick的ROC-AUC曲线(图片由作者提供)</p></figure><p id="8255" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">ROC-AUC似乎还不错。然而，我们已经有了以前的度量结果，它表明预测偏向于一个类。如果我们稍微研究一下数据，也许会更好。我们来查一下阶级不平衡；上述情况经常发生是因为不平衡的问题。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="984e" class="ne md it na b gy nf ng l nh ni">from yellowbrick.target import class_balance</span><span id="97ad" class="ne md it na b gy nj ng l nh ni">class_balance(df['Response'])</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi os"><img src="../Images/b4c539174da3eb0b5801a95f029e8849.png" data-original-src="https://miro.medium.com/v2/resize:fit:1008/format:webp/1*FZuz29n7srHM51Zh4kkUZg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来自Yellowbricks的班级平衡(图片由作者提供)</p></figure><p id="6797" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有一个不平衡的问题，即0类人数超过1类。让我们也来看看特征相关性；这可能有助于预测。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="a6fa" class="ne md it na b gy nf ng l nh ni">from yellowbrick.features import Rank2D</span><span id="905b" class="ne md it na b gy nj ng l nh ni">visualizer = Rank2D(algorithm="pearson")<br/>visualizer.fit_transform(df)<br/>visualizer.show()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/1e3690d8f45af8def93d487df6eac27f.png" data-original-src="https://miro.medium.com/v2/resize:fit:986/format:webp/1*XGIuq-5TWZpkfpcjwT0xwA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来自Yellowbricks的皮尔逊相关性(图片由作者提供)</p></figure><p id="ee92" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从上图中我们可以看出，目标(“响应”)与独立特征之间没有很强的皮尔逊相关性。也许我们可以尝试根据机器学习模型删除一些不重要的功能？让我们使用递归特征消除(RFE)进行特征选择。值得注意的是，RFE是一种使用机器学习模型系数或分数的特征选择方法，通过移除最弱的特征，直到达到指定数量的特征。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="bcea" class="ne md it na b gy nf ng l nh ni">from yellowbrick.model_selection import RFECV</span><span id="ffcf" class="ne md it na b gy nj ng l nh ni">visualizer = RFECV(model)</span><span id="3c2f" class="ne md it na b gy nj ng l nh ni">visualizer.fit(df.drop('Response', axis = 1), df['Response'])      <br/>visualizer.show()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi os"><img src="../Images/97c51ef8001c07ceae2749d7d8747151.png" data-original-src="https://miro.medium.com/v2/resize:fit:1008/format:webp/1*O3gBgN0vOaWrhcKWpNzElA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">《黄砖》中的RFE(图片由作者提供)</p></figure><p id="36cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看起来我们应该使用的最佳特征数是14个。让我们看看从RFE方法中选择了哪些特征。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="3543" class="ne md it na b gy nf ng l nh ni">df.drop('Response', axis = 1).columns[visualizer.support_]</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/9ffca4ed15bd10b0d38944f425448060.png" data-original-src="https://miro.medium.com/v2/resize:fit:1312/format:webp/1*9mzgeX7itSUaTT6mLAyUhw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="8377" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看起来这些功能主要与购买、收入和客户的家属有关。我们可以尝试的最后一项技术是基于分类模型可视化交叉验证分数。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="8035" class="ne md it na b gy nf ng l nh ni">from sklearn.model_selection import StratifiedKFold<br/>from yellowbrick.model_selection import CVScores<br/>cv = StratifiedKFold(n_splits=9)</span><span id="de89" class="ne md it na b gy nj ng l nh ni">visualizer = CVScores(model, cv=cv, scoring='f1_weighted')<br/>visualizer.fit(df.drop('Response', axis = 1), df['Response'])       <br/>visualizer.show()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ov"><img src="../Images/e367c03d7b7a9306fd6573b9823ce169.png" data-original-src="https://miro.medium.com/v2/resize:fit:990/format:webp/1*BD3EAXXTH6rdiJgniWdqbw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">从Yellowbricks评分的交叉验证(图片由作者提供)</p></figure><p id="d8d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">平均而言，我们的F1模型在9次迭代后的得分为0.817。然而，你知道它受到不平衡等级的影响。</p><p id="94b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">总的来说，Yellowbrick中仍然有许多API，您可以尝试帮助选择您的机器学习模型。如果你对这些功能感兴趣，请参考他们的文档<a class="ae ky" href="https://www.scikit-yb.org/en/latest/api/index.html" rel="noopener ugc nofollow" target="_blank">这里</a>。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="7897" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="eb22" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">可视化是一个有助于数据科学工作的过程。如果没有数据可视化，我们的工作会变得更加困难。在本文中，我概述了三个可视化Python包，它们将有助于您的数据科学工作；它们是:</p><ol class=""><li id="c963" class="ow ox it lb b lc ld lf lg li oy lm oz lq pa lu pb pc pd pe bi translated">AutoViz</li><li id="88d5" class="ow ox it lb b lc pf lf pg li ph lm pi lq pj lu pb pc pd pe bi translated">缺少编号</li><li id="8a98" class="ow ox it lb b lc pf lf pg li ph lm pi lq pj lu pb pc pd pe bi translated">黄砖</li></ol><p id="b8c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">希望有帮助！</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><blockquote class="pk pl pm"><p id="c60c" class="kz la pn lb b lc ld ju le lf lg jx lh po lj lk ll pp ln lo lp pq lr ls lt lu im bi translated"><em class="it">如果您喜欢我的内容，并希望获得更多关于数据或数据科学家日常生活的深入知识，请考虑在此订阅我的</em> <a class="ae ky" href="https://cornellius.substack.com/welcome" rel="noopener ugc nofollow" target="_blank"> <em class="it">简讯。</em> </a></p></blockquote><blockquote class="pr"><p id="f278" class="ps pt it bd pu pv pw px py pz qa lu dk translated"><em class="qb">如果您没有订阅为中等会员，请考虑通过</em> <a class="ae ky" href="https://cornelliusyudhawijaya.medium.com/membership" rel="noopener"> <em class="qb">我的推荐</em> </a> <em class="qb">订阅。</em></p></blockquote><p id="4b9d" class="pw-post-body-paragraph kz la it lb b lc qc ju le lf qd jx lh li qe lk ll lm qf lo lp lq qg ls lt lu im bi translated">访问我的<a class="ae ky" href="https://www.linkedin.com/in/cornellius-yudha-wijaya/" rel="noopener ugc nofollow" target="_blank"><strong class="lb iu">LinkedIn</strong></a><strong class="lb iu"/>或<a class="ae ky" href="https://twitter.com/CornelliusYW" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu"> Twitter </strong> </a>。</p></div></div>    
</body>
</html>