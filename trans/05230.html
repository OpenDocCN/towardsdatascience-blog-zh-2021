<html>
<head>
<title>6 Key differences between np.ndarray and np.matrix objects</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">np.ndarray和np.matrix对象之间的6个主要区别</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/6-key-differences-between-np-ndarray-and-np-matrix-objects-e3f5234ae327?source=collection_archive---------12-----------------------#2021-05-08">https://towardsdatascience.com/6-key-differences-between-np-ndarray-and-np-matrix-objects-e3f5234ae327?source=collection_archive---------12-----------------------#2021-05-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="98a8" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">这两者在技术上是不同的，即使它们在外观上看起来是一样的</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/136f227e1d2e4cf0f6a82dad5d391a99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ibHlmTU7buYUGVtLFZ4TVA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@laimannung?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> 𝓴𝓘𝓡𝓚 𝕝𝔸𝕀 </a>在<a class="ae ky" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</p></figure><p id="53d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> Numpy </strong>是基础Python库，广泛用于数值计算和线性代数。<strong class="lb iu"> <em class="lv"> ndarray </em> </strong>和<strong class="lb iu"> <em class="lv"> matrix </em> </strong>对象是常用的numpy对象。<strong class="lb iu"> <em class="lv"> ndarray </em> </strong>对象是从numpy <em class="lv"> ndarray </em>类创建的。<strong class="lb iu"> <em class="lv">矩阵</em> </strong>对象是从numpy <em class="lv">矩阵</em>类中创建的。如果你是numpy的新手，你可能会对numpy<em class="lv">n array</em>和numpy <em class="lv"> matrix </em>对象感到困惑。如果外表看起来一样，那就是两回事。今天，我们将讨论他们之间的6个不同点。</p><h2 id="977f" class="lw lx it bd ly lz ma dn mb mc md dp me li mf mg mh lm mi mj mk lq ml mm mn mo bi translated">先决条件</h2><p id="cbe4" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">推荐你看下面我写的内容。</p><ul class=""><li id="475e" class="mu mv it lb b lc ld lf lg li mw lm mx lq my lu mz na nb nc bi translated"><a class="ae ky" rel="noopener" target="_blank" href="/numpy-for-data-science-part-1-21e2c5ddbbd3">面向数据科学的NumPy:第1部分— NumPy基础知识和数组创建</a></li></ul><h2 id="2b95" class="lw lx it bd ly lz ma dn mb mc md dp me li mf mg mh lm mi mj mk lq ml mm mn mo bi translated">创建ndarray对象</h2><p id="9ed5" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">我们可以使用<strong class="lb iu"> np.array() </strong>函数创建一个ndarray对象。</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="2d83" class="lw lx it ne b gy ni nj l nk nl">import numpy as np</span><span id="5d18" class="lw lx it ne b gy nm nj l nk nl">A = np.array([[1, 2], <br/>             [3, 4]])<br/>print(A)<br/>print()<br/>print(type(A))</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/3339cde4fd538879f0e8d3fab892109e.png" data-original-src="https://miro.medium.com/v2/resize:fit:406/format:webp/1*rictMzjji_9pNC1IOavx_w.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><h2 id="5e86" class="lw lx it bd ly lz ma dn mb mc md dp me li mf mg mh lm mi mj mk lq ml mm mn mo bi translated">创建矩阵对象</h2><p id="3a23" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">我们可以使用<strong class="lb iu"> np.matrix() </strong>函数创建一个矩阵对象。</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="b699" class="lw lx it ne b gy ni nj l nk nl">import numpy as np</span><span id="882c" class="lw lx it ne b gy nm nj l nk nl">B = np.matrix([[1, 2], <br/>              [3, 4]])<br/>print(B)<br/>print()<br/>print(type(B))</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi no"><img src="../Images/9c29bb93289fb0b8a4580c4bb9384dd9.png" data-original-src="https://miro.medium.com/v2/resize:fit:394/format:webp/1*pT24pEcUFURf2pffVmJw5w.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="9615" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">即使<em class="lv"> ndarray </em>和<em class="lv"> matrix </em>对象外观相同，但它们属于两个不同的类，具有不同的功能。现在我们来讨论一下。</p><h2 id="c8d2" class="lw lx it bd ly lz ma dn mb mc md dp me li mf mg mh lm mi mj mk lq ml mm mn mo bi translated">区别1:矩阵对象是严格二维的，而n数组对象可以是多维的</h2><p id="f2c5" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">我们可以创建1d，2d，3d，甚至4d，5d(但他们很难想象)ndarray对象，但我们只能创建2d矩阵对象。</p><p id="ca93" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">一维数组</strong></p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="2307" class="lw lx it ne b gy ni nj l nk nl">import numpy as np</span><span id="4582" class="lw lx it ne b gy nm nj l nk nl">A = np.array([1, 2, 3])<br/>print(A)<br/>print('\nDimensions:', A.shape)<br/>print('No. of Dimensions:', A.ndim)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi np"><img src="../Images/5f0fd3c153d56d7e37d6244bf89324e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:370/format:webp/1*_FZ-vzlb0Iip1QTtd08Baw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="0e2c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">二维数组</strong></p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="4e08" class="lw lx it ne b gy ni nj l nk nl">import numpy as np</span><span id="d9f4" class="lw lx it ne b gy nm nj l nk nl">B = np.array([[1, 2], <br/>             [3, 4]])<br/>print(B)<br/>print('\nDimensions:', B.shape)<br/>print('No. of Dimensions:', B.ndim)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/725a3dee8dc24a1c3da33d54cff8de6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:402/format:webp/1*YWUWtqZ4xLnD_XY1SsFH2w.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="85ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">三维数组</strong></p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="f6ad" class="lw lx it ne b gy ni nj l nk nl">import numpy as np</span><span id="3ce2" class="lw lx it ne b gy nm nj l nk nl">C = np.array([[[1, 2], [3, 4]],<br/>             [[5, 6], [7, 8]],<br/>             [[9, 10], [11, 12]]])<br/>print(C)<br/>print('\nDimensions:', C.shape)<br/>print('No. of Dimensions:', C.ndim)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/3983fa1ba4bfa91e6125cdc890192723.png" data-original-src="https://miro.medium.com/v2/resize:fit:464/format:webp/1*bCuNZqF4zZ_nQlO9f-KHVg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="a5d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">矩阵对象是严格二维的。如果我们试图创建一个一维矩阵，它会自动创建一个二维矩阵。</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="3e02" class="lw lx it ne b gy ni nj l nk nl">import numpy as np</span><span id="1da7" class="lw lx it ne b gy nm nj l nk nl">A = np.matrix([1, 2, 3])<br/>print(A)<br/>print()<br/>print(type(A))<br/>print('Dimensions:', A.shape)<br/>print('No. of Dimensions:', A.ndim)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/9dd2c3a779e416435eff5ccae5520dd3.png" data-original-src="https://miro.medium.com/v2/resize:fit:402/format:webp/1*3q1webTmrBqZjICZusrsQQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="c244" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们试图创建一个3d矩阵，它会给出一个错误。</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="5540" class="lw lx it ne b gy ni nj l nk nl">np.matrix([[[1, 2], [3, 4]], <br/>          [[5, 6], [7, 8]], <br/>          [[9, 10], [11, 12]]])</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/53108ccef0bd9ca4aba612699e40fb0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1084/format:webp/1*N5xNB9bFMDH0zv4tHdHuBQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><h2 id="f110" class="lw lx it bd ly lz ma dn mb mc md dp me li mf mg mh lm mi mj mk lq ml mm mn mo bi translated">区别2:n array和matrix对象在使用*(单星号)运算符时表现不同</h2><p id="54b9" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">当我们使用<strong class="lb iu"> * </strong>操作符将两个ndarray对象相乘时，结果是<em class="lv">元素到元素的乘法</em>。</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="3fdb" class="lw lx it ne b gy ni nj l nk nl">a = np.array([[1, 2], <br/>             [3, 4]])<br/>b = np.array([[5, 6], <br/>             [8, 9]])<br/>print("a", type(a))<br/>print(a)<br/>print("\nb", type(b))<br/>print(b)<br/>print("\n* operation on two ndarray objects (Elementwise)")<br/>print(a * b)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/64e01bbe0cb8370c0faf374c8bc7d2fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:798/format:webp/1*XC-nIUfXlaUveqhiyzHzXg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="e26e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们使用<strong class="lb iu"> * </strong>运算符将两个矩阵对象相乘时，结果是<em class="lv">点(矩阵)积</em>。</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="20f4" class="lw lx it ne b gy ni nj l nk nl">c = np.matrix([[1, 2], <br/>              [3, 4]])<br/>d = np.matrix([[5, 6], <br/>              [8, 9]])<br/>print("c", type(c))<br/>print(c)<br/>print("\nd", type(d))<br/>print(d)<br/>print("\n* operation on two matrix objects")<br/>print(c * d)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nu"><img src="../Images/7cb78ab1f9923dfe67f8d50f8ee87cd6.png" data-original-src="https://miro.medium.com/v2/resize:fit:606/format:webp/1*NIZEisWxUSQgntGew1eA-Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><h2 id="9e4e" class="lw lx it bd ly lz ma dn mb mc md dp me li mf mg mh lm mi mj mk lq ml mm mn mo bi translated">区别3:n array和matrix对象在使用**(双星)操作符时表现不同</h2><p id="1b6b" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">当我们在两个ndarray对象上使用**操作符时，结果是每个元素的元素值的平方。</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="08d6" class="lw lx it ne b gy ni nj l nk nl">a = np.array([[1, 2], <br/>             [3, 4]])<br/>print("a", type(a))<br/>print(a)<br/>print("\n** operation on two ndarray objects (Elementwise)")<br/>print(a ** 2)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/0d0951dabe27e38e01e80ec20c7d3b66.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*8ISVH_A9xoxVNplbevIKqA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="e17a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们在两个矩阵对象上使用**运算符时，结果是一个矩阵乘法！</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="f8b9" class="lw lx it ne b gy ni nj l nk nl">b = np.matrix([[1, 2], <br/>              [3, 4]])<br/>print(b)<br/>print("\n** operation on two matrix objects")<br/>print(b ** 2)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/e28e3b51d63f62e812fcca017b46c9d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:574/format:webp/1*TK2Lk2SZOgbBWdEwx_mJfg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><h2 id="25c9" class="lw lx it bd ly lz ma dn mb mc md dp me li mf mg mh lm mi mj mk lq ml mm mn mo bi translated">区别4: matrix类是ndarray类的子类</h2><p id="570a" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">Matrix对象继承了ndarray对象的所有属性和方法。</p><h2 id="c727" class="lw lx it bd ly lz ma dn mb mc md dp me li mf mg mh lm mi mj mk lq ml mm mn mo bi translated">区别5:矩阵对象有。I代表逆，但ndarray对象不代表逆</h2><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="40e6" class="lw lx it ne b gy ni nj l nk nl">a = np.matrix([[1, 2], <br/>              [3, 4]])<br/>print(a)<br/>print('\nInverse')<br/>print(a.I)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/52279b79de4f4b66f69781819eefe5cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:282/format:webp/1*RIeG978ThU_0y9ZWt0YHLg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="aa31" class="lw lx it ne b gy ni nj l nk nl">b = np.array([[1, 2], <br/>             [3, 4]])<br/>print(b)<br/>print('\nInverse')<br/>print(b.I)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/5ce7257ea8cc25adc0604205421ba41c.png" data-original-src="https://miro.medium.com/v2/resize:fit:950/format:webp/1*OLx_aidFiIb1ss8ee8milw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="7856" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要得到ndarray对象的逆，使用<strong class="lb iu"> np.linalg.inv() </strong>函数。</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="b572" class="lw lx it ne b gy ni nj l nk nl">np.linalg.inv(b)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/2d61a8cf1d97f569ff40da0a4b992af9.png" data-original-src="https://miro.medium.com/v2/resize:fit:366/format:webp/1*81-gXAFsRa910rcMk-7dSQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><h2 id="cb8a" class="lw lx it bd ly lz ma dn mb mc md dp me li mf mg mh lm mi mj mk lq ml mm mn mo bi translated">区别6:用法—通常使用ndarray类而不是matrix类</h2><p id="de44" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">下面是numpy文档对这两个类的用法的描述。</p><blockquote class="oa ob oc"><p id="2467" class="kz la lv lb b lc ld ju le lf lg jx lh od lj lk ll oe ln lo lp of lr ls lt lu im bi translated">不再推荐使用matrix类，即使是线性代数。相反，使用常规的numpy数组。matrix类将来可能会被删除。</p></blockquote><h1 id="a005" class="og lx it bd ly oh oi oj mb ok ol om me jz on ka mh kc oo kd mk kf op kg mn oq bi translated">摘要</h1><p id="756d" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated"><strong class="lb iu"> <em class="lv"> ndarray </em> </strong>和<strong class="lb iu"> <em class="lv"> matrix </em> </strong>类表现不同。使用<em class="lv"> matrix </em>类可能要容易得多，因为这就像在线性代数中使用矩阵一样。如果你需要处理多维数组，你应该使用<em class="lv"> ndarray </em>对象，因为它们是多维的。Numpy文档推荐你使用<em class="lv">n数组</em>对象，而不是<em class="lv">矩阵</em>对象。通过使用适当的函数，您总是可以将一种类类型转换成另一种。因此，使用<strong class="lb iu"> np.asmatrix() </strong>函数将一个<em class="lv"> ndarray </em>对象转换成一个<em class="lv"> matrix </em>对象。</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="2f06" class="lw lx it ne b gy ni nj l nk nl">a = np.array([[1, 2], <br/>             [3, 4]])<br/>print(a)<br/>print(type(a))<br/>print()</span><span id="b6cf" class="lw lx it ne b gy nm nj l nk nl">b = np.asmatrix(a)<br/>print(b)<br/>print(type(b))</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/d25378198347b4936261eab47000823f.png" data-original-src="https://miro.medium.com/v2/resize:fit:406/format:webp/1*bBVL5KEfqo4pYciBRicFsQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="e530" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，您可以使用<strong class="lb iu"> np.asarray() </strong>函数将<em class="lv">矩阵</em>对象转换为<em class="lv">n array</em>对象。</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="1832" class="lw lx it ne b gy ni nj l nk nl">a = np.matrix([[1, 2], [3, 4]])<br/>print(a)<br/>print(type(a))<br/>print()</span><span id="1fab" class="lw lx it ne b gy nm nj l nk nl">b = np.asarray(a)<br/>print(b)<br/>print(type(b))</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi or"><img src="../Images/78324e09ced5e46367a56042e958a497.png" data-original-src="https://miro.medium.com/v2/resize:fit:410/format:webp/1*7CjKAoUBlKRBvo3-qFnymg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="b59f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读！</p><p id="223b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本教程由<a class="ae ky" href="https://www.linkedin.com/in/rukshan-manorathna-700a3916b/" rel="noopener ugc nofollow" target="_blank"><em class="lv">Rukshan Pramoditha</em></a><em class="lv">，</em>数据科学365博客作者设计创作。</p><p id="3ce5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在https://rukshanpramoditha.medium.com<a class="ae ky" href="https://rukshanpramoditha.medium.com/" rel="noopener">阅读我的其他文章</a></p><p id="df55" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi">2021–05–08</p></div></div>    
</body>
</html>