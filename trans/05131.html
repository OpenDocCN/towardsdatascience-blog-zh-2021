<html>
<head>
<title>Virtual Graphs in a Relational Database</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关系数据库中的虚拟图</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/virtual-graphs-in-a-relational-database-5813622a688?source=collection_archive---------30-----------------------#2021-05-05">https://towardsdatascience.com/virtual-graphs-in-a-relational-database-5813622a688?source=collection_archive---------30-----------------------#2021-05-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4bab" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">超图/关系数据库绝对有优势</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/a297f078baf2f3edb85162ec0970ffe2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XWXZnYbucgWD-3oAAUoJaw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">同一型号的三视图。实体关系、图和对象-角色建模。图片作者。</p></figure><p id="fbe0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我正在研究<a class="ae lu" rel="noopener" target="_blank" href="/what-is-a-graph-database-249cd7fdf24d">专用图形数据库</a>如何处理关系/边上的唯一性约束，我的发现让我很惊讶…</p><p id="d295" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">假设我们有一个专用的图形数据库，其中有<em class="lv">人</em>节点和<em class="lv">车</em>节点，并且有一个模式，其中<strong class="la iu"> <em class="lv">人驾驶车</em> </strong>是一种关系类型。<br/>在模式的图形数据库中，如何将人员节点限制为“驾驶”一辆汽车节点？</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lw"><img src="../Images/49389bb94bcba9f92b456edb1627fe75.png" data-original-src="https://miro.medium.com/v2/resize:fit:826/format:webp/1*3YdahAfTugIR6hVUqUXPsA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图表模式。图片作者。</p></figure><p id="9a66" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我的研究表明，在一些专用的图形数据库中，当数据库执行约束时，你纯粹是运气不好。在创建新的关系之前，您必须以编程方式检查您选择的Person节点和Car节点之间是否存在关系……数据库不会自动检查关系类型的基数。</p><p id="1121" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后我发现了一个例子，有人试图用一个专用的图形数据库做一些事情，我认为这是非常了不起的。对我来说，这是一个试图把一个方钉装进一个圆孔的例子，超图/关系数据库肯定比一个专用的图形数据库有优势。让我们看看…</p><p id="fe1f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">想象以下图表模式:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lx"><img src="../Images/65b73d75e2ffb80271dc8f51536e5f38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1018/format:webp/1*ctICGEkzrTm8mAQ5Z0on4g.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">属性图架构。图片作者。</p></figure><p id="a25b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">该模式用于有健康问题的人在医生诊所的预约。</p><p id="d725" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">发布问题的论坛上的人试图确定他们是否应该有用于查询目的的日期和时间的节点，并最终被推荐了一个复杂的模式映射关系(Person)-[ON _ Date]-&gt;(Date)-&gt;[AT _ Time]-&gt;(Time)-&gt;[TREATMENT _ FOR]-&gt;(Condition)，并想知道他们将如何管理这样一个模式中各个节点之间的关系基数。尽管专用图形数据库中的(时间)-&gt;[治疗条件]-&gt;(条件)关系的益处值得怀疑。</p><p id="6932" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">再一次，当涉及到管理关系的唯一性时，共识是…这取决于数据库<strong class="la iu"> <em class="lv">用户</em> </strong>而不是专用的图形数据库。基本上这是一个令人费解的组合混乱，有更好的方法来处理管理关系基数的场景。</p><h2 id="d41e" class="ly lz it bd ma mb mc dn md me mf dp mg lh mh mi mj ll mk ml mm lp mn mo mp mq bi translated">当您使用超图/关系数据库和对象-角色建模时，所有可能的图在一个模式下都是可能的</h2><p id="64b2" class="pw-post-body-paragraph ky kz it la b lb mr ju ld le ms jx lg lh mt lj lk ll mu ln lo lp mv lr ls lt im bi translated">让我们用<a class="ae lu" rel="noopener" target="_blank" href="/why-learn-object-role-modelling-4eebd93dcda2">对象角色建模</a>来重新审视这个问题:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mw"><img src="../Images/f0c1efa8103359d5c27fc7b948783a3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ouY8CamfkKIYpTLku39V2g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">对象-角色模型。图片作者。</p></figure><p id="c2b8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">人、日期、时间和条件之间的关系在约会中是唯一的，约会关系是多对多对多的关系。例如，一个人可能在许多日期和时间有关于条件的约会，但是每个约会都是唯一的。我们已经通过在多个/组合关系上具有唯一性约束解决了关系基数的管理。为了使生活变得更容易…让我们看一下与关系数据库的实体关系图相同的模式:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mx"><img src="../Images/e6a5650e6ab99b6bab917dbee82eda8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BmFITIJIy15iTZEK9QKOPw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">实体关系图。图片作者。</p></figure><p id="fea0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">与我们的对象-角色模型类似，关系模型通过设计来管理关系的基数，其中<em class="lv">约会</em>的主键(标记为#)覆盖了Person_Id、Date、Time和Condition_Name之间关系的唯一性。</p><p id="ba69" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在我们的对象-角色模型中，<em class="lv">对象类型</em>，人、日期、时间和条件在<em class="lv">约会</em>事实类型下连接在一起，如<strong class="la iu"> <em class="lv">人在日期时间对条件</em> </strong>进行了咨询。</p><p id="3718" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这种关系的表述被称为对象-角色建模(ORM)中的<em class="lv">事实类型读取</em>，ORM的美妙之处在于可以创建与事实类型关联的<em class="lv">对象类型</em>集合的任何组合表现:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi my"><img src="../Images/ae955b203f590ebeb24f33cda5a7ba1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:844/format:webp/1*EGEz1p7wxJuFiHCj2cRYlw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">同一事实类型的各种事实类型读数。图片作者。</p></figure><p id="7a7e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">基本上，这导致，如果你有一个图形查询语言在你的超图/关系数据库上使用对象-角色建模主干，那么你可以把任何或所有的人、日期、时间和条件当作图形数据库中的节点。例如，您可以将图形查询表述为*:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mz"><img src="../Images/e4d1e4fa0b1333827709dfd5a0bb9081.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*61pWSQCpKpn7jWKToUjMcQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">FactEngine中的图形查询。图片作者。</p></figure><p id="104e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">* FactEngine查询语言。有许多图形查询语言。</p><p id="b004" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">或者</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi na"><img src="../Images/51999b8f68cb4fd86e2e9a447f04e4bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NZOOKoAQSN-dZ3mxLvd53g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">FactEngine中的图形查询。图片作者。</p></figure><p id="8335" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">也就是说，<strong class="la iu"> <em class="lv">图查询</em> </strong>中的节点决定可能与<strong class="la iu"> <em class="lv">属性图模式</em> </strong>不同，当查询您的数据库时，这些有效节点有时由超图(其中对象角色建模<a class="ae lu" rel="noopener" target="_blank" href="/knowledge-hypergraphs-object-role-modeling-ef0f58f38066">被视为超图概念建模语言</a>)处理更好，如果您有超图模式…默认情况下您有其相应的图模式。为什么？因为超图比属性图更具表达性，并且封装了所有信息来派生您的图模式。</p><p id="2d59" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">同样，专用的图形数据库可能并不总是能够以您想要的方式被查询，在使用正确的工具时，数据库的超图处理为您提供了各种各样的查询选项。</p><p id="163f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">考虑以下查询:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nb"><img src="../Images/6c99f4cad1db2fff71c8f62cd6aa6edc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E97TDYQnbxvVAk43G8XQ1g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">FactEngine中的图形查询。图片作者。</p></figure><p id="abf2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">该查询使用部分现存事实类型Reading(<strong class="la iu"><em class="lv">Person Date at Time……</em></strong>)然后使用<strong class="la iu"><em class="lv">Person has Appointment</em></strong>and<strong class="la iu"><em class="lv">Appointment for Condition</em></strong><a class="ae lu" rel="noopener" target="_blank" href="/link-fact-types-in-object-role-modeling-3c68c15eec92">Link事实类型</a>进行非常自然的读取图形查询。Person(_Id)，Date和Time在我们的关系视图中是属性，但在查询时成为一个超图中的节点，解决了既有图查询又同时有关系基数约束的问题。</p><p id="f0e2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">也就是说，关系数据库具有优势，因为它们用唯一索引管理关系基数，而用户不必编写额外的代码来检查关系基数约束是否被破坏。使用正确的工具，您可以在关系数据库上编写图形查询。</p><p id="c947" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在本文中，我们介绍了:</p><ol class=""><li id="25b2" class="nc nd it la b lb lc le lf lh ne ll nf lp ng lt nh ni nj nk bi translated">您不一定需要专用图形数据库中的节点来使用这些概念节点对数据库进行图形查询。</li><li id="d1b3" class="nc nd it la b lb nl le nm lh nn ll no lp np lt nh ni nj nk bi translated">对象角色建模中的对象类型可以被认为是超图数据库中的节点，而不管它们是相应属性图模式中的节点还是属性；和</li><li id="335e" class="nc nd it la b lb nl le nm lh nn ll no lp np lt nh ni nj nk bi translated">关系数据库中的单个实体可能实际上是节点及其在相应超图模式中的关系的集合，用于查询目的，管理复杂的关系基数约束，以及关系数据库最擅长的……索引关系。</li></ol><p id="450c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Hypergraph数据库查询引擎正在开始改变数据库的面貌，而FactEngine只是一种新型的查询引擎。事实上，FactEngine体系结构及其查询语言是数据库不可知的，因此没有提升任何特定的数据库，但第一个版本是基于关系数据库的，并将图形查询转换为结构化查询语言(SQL)。目的是通过比较编写SQL或使用标准图形查询语言，使查询数据库<a class="ae lu" rel="noopener" target="_blank" href="/natural-language-queries-for-real-this-time-5383bf42ad2a">变得非常容易。你可以在这里阅读更多关于FactEngine架构的信息。</a></p><p id="4f43" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">感谢您的阅读。我希望这有助于决定为您的下一个项目选择哪种类型的数据库，以及哪种查询语言会使工作更容易。如果时间允许，我会写更多关于图形/超图数据库、关系数据库和对象角色建模的文章。</p><p id="86de" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">— — — — —结束— — — —</p></div></div>    
</body>
</html>