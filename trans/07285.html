<html>
<head>
<title>AMLSim Fraud Detection with TigerGraph and Google Vertex Part I: Preparing the Data</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用TigerGraph和Google Vertex检测AMLSim欺诈第一部分:准备数据</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/amlsim-fraud-detection-with-tigergraph-and-google-vertex-part-i-preparing-the-data-2f3e6487f398?source=collection_archive---------13-----------------------#2021-07-02">https://towardsdatascience.com/amlsim-fraud-detection-with-tigergraph-and-google-vertex-part-i-preparing-the-data-2f3e6487f398?source=collection_archive---------13-----------------------#2021-07-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="c3eb" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用TigerGraph运行图形查询以准备AMLSim欺诈检测数据集</h2></div><blockquote class="kf kg kh"><p id="6ebe" class="ki kj kk kl b km kn jr ko kp kq ju kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">这个项目是和<a class="lf lg ep" href="https://medium.com/u/9ee92495f34e?source=post_page-----2f3e6487f398--------------------------------" rel="noopener" target="_blank">德州陈</a> ( <a class="ae lh" href="https://www.linkedin.com/in/dezhou-chen-625904206" rel="noopener ugc nofollow" target="_blank">领英</a>)在<a class="lf lg ep" href="https://medium.com/u/571f80cc8b69?source=post_page-----2f3e6487f398--------------------------------" rel="noopener" target="_blank">乔恩·赫克</a> ( <a class="ae lh" href="https://www.linkedin.com/in/jonherke" rel="noopener ugc nofollow" target="_blank">领英</a>)的帮助下共同创作的。它基于Jon Herke创建的AMLSim Python Lab。</p></blockquote><h1 id="a060" class="li lj iq bd lk ll lm ln lo lp lq lr ls jw lt jx lu jz lv ka lw kc lx kd ly lz bi translated">概述和目标</h1><p id="2f41" class="pw-post-body-paragraph ki kj iq kl b km ma jr ko kp mb ju kr mc md ku kv me mf ky kz mg mh lc ld le ij bi translated">图形数据库最流行的用例之一是欺诈检测。在这篇博客中，我们将加载基于<a class="ae lh" href="https://github.com/IBM/AMLSim" rel="noopener ugc nofollow" target="_blank"> IBM的AMLSim项目</a>的数据(我们将在这里使用来自实验室<a class="ae lh" href="https://github.com/TigerGraph-DevLabs/AMLSim_Python_Lab" rel="noopener ugc nofollow" target="_blank">的数据)，一个来自银行交易模拟的数据集。</a></p><p id="0486" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr mc kt ku kv me kx ky kz mg lb lc ld le ij bi translated">在这个实验中，我们将利用TigerGraph的图形数据库和Google Vertex的机器学习来将交易分类为欺诈性或非欺诈性交易。</p><p id="00f7" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr mc kt ku kv me kx ky kz mg lb lc ld le ij bi translated">本博客将向您介绍如何使用TigerGraph创建AML Sim图，运行pagerank和label prop等图形算法，最后编写查询从TigerGraph中提取所需信息。我们开始吧！</p><h1 id="ca5d" class="li lj iq bd lk ll lm ln lo lp lq lr ls jw lt jx lu jz lv ka lw kc lx kd ly lz bi translated">第一部分:在https://tgcloud.io/创建一个免费的TigerGraph解决方案</h1><p id="05bb" class="pw-post-body-paragraph ki kj iq kl b km ma jr ko kp mb ju kr mc md ku kv me mf ky kz mg mh lc ld le ij bi translated">首先，你需要在<a class="ae lh" href="https://tgcloud.io/" rel="noopener ugc nofollow" target="_blank">https://tgcloud.io/</a>创建一个免费的解决方案。这是我们存放图表数据库的地方。如果您还没有，请前往<a class="ae lh" href="https://tgcloud.io/" rel="noopener ugc nofollow" target="_blank">https://tgcloud.io/</a>创建一个帐户。你可以在谷歌、LinkedIn或电子邮件上注册。</p><figure class="mj mk ml mm gt mn gh gi paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="gh gi mi"><img src="../Images/b07010e81ae58ef2d0a46f86be3948f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Xk21sdPeOFFthTarQ1JpaQ.png"/></div></div></figure><p id="4b61" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr mc kt ku kv me kx ky kz mg lb lc ld le ij bi translated">注册或登录后，导航至左侧边栏中的“我的解决方案”选项卡，然后点击右上角的蓝色“创建解决方案”按钮。</p><div class="mj mk ml mm gt ab cb"><figure class="mu mn mv mw mx my mz paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><img src="../Images/e6fb2cf1e060431809ddeee9ce218237.png" data-original-src="https://miro.medium.com/v2/resize:fit:402/format:webp/1*gdPbTndc_PL8pIxRhoIL7A.png"/></div></figure><figure class="mu mn na mw mx my mz paragraph-image"><img src="../Images/e8af302e0cbdbd6032d9be6d2578f959.png" data-original-src="https://miro.medium.com/v2/resize:fit:1324/format:webp/1*ljharnf4Xf_uEj2barkQGw.png"/><p class="nb nc gj gh gi nd ne bd b be z dk nf di ng nh translated">转到“我的解决方案”选项卡，然后单击“创建解决方案”</p></figure></div><p id="2fb4" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr mc kt ku kv me kx ky kz mg lb lc ld le ij bi translated">在第一个选项卡上，从“选择初学者工具包”中选择“空白”选项。不要更改任何其他内容，然后按下一步。</p><figure class="mj mk ml mm gt mn gh gi paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="gh gi mi"><img src="../Images/c654c2f8e9c6bc1276d7eb812d58815c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qz6loEebsaseZWlhaETHxQ.png"/></div></div><p class="nb nc gj gh gi nd ne bd b be z dk translated">单击空白，然后单击下一步。</p></figure><p id="212b" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr mc kt ku kv me kx ky kz mg lb lc ld le ij bi translated">第二步，不要修改任何东西(本质上这只是创建一个免费的解决方案),然后点击next。</p><figure class="mj mk ml mm gt mn gh gi paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="gh gi mi"><img src="../Images/1e157aa07e6ab5f25395db129ef7be24.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nKtjhGa8GrGDs8eGBV7GQA.png"/></div></div><p class="nb nc gj gh gi nd ne bd b be z dk translated">不要在这里修改任何东西，然后按下一步。</p></figure><p id="0973" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr mc kt ku kv me kx ky kz mg lb lc ld le ij bi translated">第三步，添加您的解决方案名称、标签、密码、子域和描述。请记住您的初始密码和子域！</p><blockquote class="kf kg kh"><p id="6f17" class="ki kj kk kl b km kn jr ko kp kq ju kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">注意:每个子域必须是唯一的，所以你可能无法使用我使用的相同的子域。</p></blockquote><figure class="mj mk ml mm gt mn gh gi paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="gh gi mi"><img src="../Images/82442defe8c3081061f22a91b8e3dd88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u2ufdLu-Ikbjbp5wzjwQlg.png"/></div></div><p class="nb nc gj gh gi nd ne bd b be z dk translated">将此更新为您自己的</p></figure><p id="ead9" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr mc kt ku kv me kx ky kz mg lb lc ld le ij bi translated">仔细检查第四步中的所有信息，然后按“提交”创建您的解决方案。创建您的解决方案可能需要几分钟时间。</p><figure class="mj mk ml mm gt mn gh gi paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="gh gi mi"><img src="../Images/240f21d92f52289d99ebd79dd0d9110f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7pi-A7G-i3LXmYqZLiDLCg.png"/></div></div><p class="nb nc gj gh gi nd ne bd b be z dk translated">仔细检查您的解决方案摘要是否正确，然后按提交！</p></figure><p id="cff9" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr mc kt ku kv me kx ky kz mg lb lc ld le ij bi translated">恭喜你。您已经用TigerGraph创建了一个解决方案！现在，让我们转到笔记本来创建图表、加载数据、创建和运行查询！</p><h1 id="0e59" class="li lj iq bd lk ll lm ln lo lp lq lr ls jw lt jx lu jz lv ka lw kc lx kd ly lz bi translated">第二部分:用TigerGraph创建一个AMLSim图</h1><h2 id="d28e" class="ni lj iq bd lk nj nk dn lo nl nm dp ls mc nn no lu me np nq lw mg nr ns ly nt bi translated">步骤1:连接到您的解决方案</h2><p id="03f9" class="pw-post-body-paragraph ki kj iq kl b km ma jr ko kp mb ju kr mc md ku kv me mf ky kz mg mh lc ld le ij bi translated">首先，我们将使用pyTigerGraph连接到我们刚刚创建的解决方案。pyTigerGraph是一个用于TigerGraph的Python包，我们将使用它与我们的解决方案进行交互。</p><p id="bc45" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr mc kt ku kv me kx ky kz mg lb lc ld le ij bi translated">在Colab中，我们需要首先pip安装pyTigerGraph，然后导入库。</p><pre class="mj mk ml mm gt nu nv nw nx aw ny bi"><span id="78cd" class="ni lj iq nv b gy nz oa l ob oc">!pip install pyTigerGraph</span><span id="f305" class="ni lj iq nv b gy od oa l ob oc">import pyTigerGraph as tg</span></pre><p id="b7a7" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr mc kt ku kv me kx ky kz mg lb lc ld le ij bi translated">太好了！现在，让我们连接到刚刚创建的解决方案。为此，我们可以使用tg.TigerGraphConnection。</p><pre class="mj mk ml mm gt nu nv nw nx aw ny bi"><span id="dfe9" class="ni lj iq nv b gy nz oa l ob oc">conn = tg.TigerGraphConnection(host="https://SUBDOMAIN.i.tgcloud.io", password="PASSWORD")</span></pre><p id="20e2" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr mc kt ku kv me kx ky kz mg lb lc ld le ij bi translated">运行之后，您就可以连接并准备创建一个模式了！</p><h2 id="3c62" class="ni lj iq bd lk nj nk dn lo nl nm dp ls mc nn no lu me np nq lw mg nr ns ly nt bi translated">步骤二:创建一个模式</h2><p id="b343" class="pw-post-body-paragraph ki kj iq kl b km ma jr ko kp mb ju kr mc md ku kv me mf ky kz mg mh lc ld le ij bi translated">现在我们要创建一个模式。这将由包括账户和交易在内的几个顶点组成，这些顶点将由无向和有向边连接。例如，帐户和交易顶点将用两条有向边连接:Send_Transaction和Recieve _ Transaction。</p><p id="599f" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr mc kt ku kv me kx ky kz mg lb lc ld le ij bi translated">下面的代码将创建所有的顶点和边。</p><pre class="mj mk ml mm gt nu nv nw nx aw ny bi"><span id="5104" class="ni lj iq nv b gy nz oa l ob oc">print(conn.gsql('''</span><span id="3a85" class="ni lj iq nv b gy od oa l ob oc">CREATE VERTEX Country (PRIMARY_ID id STRING) WITH primary_id_as_attribute="true"<br/>CREATE VERTEX Customer (PRIMARY_ID id STRING) WITH primary_id_as_attribute="true"<br/>CREATE VERTEX Account (PRIMARY_ID id STRING, init_balance DOUBLE, account_type STRING, tx_behavior INT, pagerank FLOAT, label INT, current_balance DOUBLE, min_send_tx DOUBLE, min_recieve_tx DOUBLE, max_send_tx DOUBLE, max_recieve_tx DOUBLE, avg_send_tx DOUBLE, avg_recieve_tx DOUBLE, cnt_recieve_tx INT, cnt_send_tx INT) WITH primary_id_as_attribute="true"<br/>CREATE VERTEX Transaction (PRIMARY_ID id STRING, tx_behavior_id INT, amount DOUBLE, is_fraud BOOL) WITH primary_id_as_attribute="true"<br/>CREATE VERTEX Alert (PRIMARY_ID id STRING, alert_type STRING, ts INT) WITH primary_id_as_attribute="true"</span><span id="0b64" class="ni lj iq nv b gy od oa l ob oc">CREATE UNDIRECTED EDGE Based_In (From Customer, To Country)<br/>CREATE UNDIRECTED EDGE Customer_Account (From Customer, To Account)<br/>CREATE UNDIRECTED EDGE Transaction_Flagged (From Transaction, To Alert)<br/>CREATE DIRECTED EDGE Send_To (From Account, To Account) WITH REVERSE_EDGE="reverse_Send_To"<br/>CREATE DIRECTED EDGE Send_Transaction (From Account, To Transaction, ts INT, tx_type STRING) WITH REVERSE_EDGE="reverse_Send_Transaction"<br/>CREATE DIRECTED EDGE Recieve_Transaction (From Transaction, To Account, ts INT, tx_type STRING) WITH REVERSE_EDGE="reverse_Recieve_Transaction"</span><span id="a9bc" class="ni lj iq nv b gy od oa l ob oc">''', options=[]))</span></pre><p id="3eb7" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr mc kt ku kv me kx ky kz mg lb lc ld le ij bi translated">接下来，我们将使用上面创建的所有顶点和边创建一个名为AMLSim的图(我们将把它作为参数传递给CREATE GRAPH函数)。</p><pre class="mj mk ml mm gt nu nv nw nx aw ny bi"><span id="3523" class="ni lj iq nv b gy nz oa l ob oc">print(conn.gsql('''CREATE GRAPH AMLSim(Country, Customer, Account, Transaction, Alert, Based_In, Customer_Account, Transaction_Flagged, Send_To, Send_Transaction, reverse_Send_Transaction, Recieve_Transaction, reverse_Recieve_Transaction)''', options=[]))</span></pre><p id="c1f3" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr mc kt ku kv me kx ky kz mg lb lc ld le ij bi translated">现在，如果您返回到https://tgcloud.io/的<a class="ae lh" href="https://tgcloud.io/" rel="noopener ugc nofollow" target="_blank"/>，点击“我的解决方案”选项卡，点击“操作”下的四个框(悬停值为“应用”)，然后点击GraphStudio，您将能够看到您创建的图表。</p><figure class="mj mk ml mm gt mn gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/d9f47949cb9df3bfba4d9441c9586980.png" data-original-src="https://miro.medium.com/v2/resize:fit:740/format:webp/1*pMQoTxeqRcFqpkRq9Tifbg.png"/></div><p class="nb nc gj gh gi nd ne bd b be z dk translated">转到GraphStudio。</p></figure><p id="1214" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr mc kt ku kv me kx ky kz mg lb lc ld le ij bi translated">单击“设计模式”查看全局模式。</p><figure class="mj mk ml mm gt mn gh gi paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="gh gi mi"><img src="../Images/a737adcdb07481990004c4f04e73e5b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cigZR14EIifECV7IevnspQ.png"/></div></div><p class="nb nc gj gh gi nd ne bd b be z dk translated">模式的全局视图。</p></figure><p id="eb1c" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr mc kt ku kv me kx ky kz mg lb lc ld le ij bi translated">如果您单击“全局视图”，将会出现该解决方案中所有图表的下拉列表。您会注意到我们刚刚创建的图表AMLSim就在那里！点击那个。</p><figure class="mj mk ml mm gt mn gh gi paragraph-image"><div class="gh gi of"><img src="../Images/0e03063fe31fd74c9451b417810d739d.png" data-original-src="https://miro.medium.com/v2/resize:fit:956/format:webp/1*68rg3DYi7jnk8Lspfx6DKQ.png"/></div><p class="nb nc gj gh gi nd ne bd b be z dk translated">您会注意到AMLSim是下拉选项之一。点击AMLSim。</p></figure><p id="518a" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr mc kt ku kv me kx ky kz mg lb lc ld le ij bi translated">在“设计模式”中，您将再次看到您的模式！</p><figure class="mj mk ml mm gt mn gh gi paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="gh gi mi"><img src="../Images/dc9226728a4bc47db6e28bb160c6c678.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kd-ZXugNG1l9Ofv6ZpHsuQ.png"/></div></div><p class="nb nc gj gh gi nd ne bd b be z dk translated">AMLSim图的架构。</p></figure><p id="d9bc" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr mc kt ku kv me kx ky kz mg lb lc ld le ij bi translated">如果您点击左侧边栏中的“加载数据”，您将能够看到加载到图表中的任何数据。</p><figure class="mj mk ml mm gt mn gh gi paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="gh gi mi"><img src="../Images/9a53c8bfca7d9bee25db4200177b29dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RYGADxqSVHuqJwiMlyb1WQ.png"/></div></div><p class="nb nc gj gh gi nd ne bd b be z dk translated">加载数据页面。</p></figure><p id="cddb" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr mc kt ku kv me kx ky kz mg lb lc ld le ij bi translated">现在，没有数据加载，所以让我们改变这一点！</p><h2 id="fc20" class="ni lj iq bd lk nj nk dn lo nl nm dp ls mc nn no lu me np nq lw mg nr ns ly nt bi translated">第三步:加载数据</h2><p id="4793" class="pw-post-body-paragraph ki kj iq kl b km ma jr ko kp mb ju kr mc md ku kv me mf ky kz mg mh lc ld le ij bi translated">让我们将数据加载到图表中。为此，我们首先需要从GitHub存储库中获取从CSV加载的数据。我们将首先导入pandas来读取CSV，然后git克隆存储库。我们将使用pandas的read_csv函数来创建csv数据的数据帧，并将其分配给变量accounts、alerts和transactions。</p><pre class="mj mk ml mm gt nu nv nw nx aw ny bi"><span id="44b3" class="ni lj iq nv b gy nz oa l ob oc">import pandas as pd</span><span id="ca6b" class="ni lj iq nv b gy od oa l ob oc">!git clone https://github.com/TigerGraph-OSS/AMLSim_Python_Lab</span><span id="6a4d" class="ni lj iq nv b gy od oa l ob oc">accounts = pd.read_csv("AMLSim_Python_Lab/data/accounts.csv", sep=",")<br/>alerts = pd.read_csv("AMLSim_Python_Lab/data/alerts.csv", sep=",")<br/>transactions = pd.read_csv("AMLSim_Python_Lab/data/transactions.csv", sep=",")</span></pre><p id="d49a" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr mc kt ku kv me kx ky kz mg lb lc ld le ij bi translated">接下来，我们将把数据帧中的所有id列更新为字符串，而不是整数。</p><pre class="mj mk ml mm gt nu nv nw nx aw ny bi"><span id="13bf" class="ni lj iq nv b gy nz oa l ob oc">accounts['ACCOUNT_ID'] = accounts['ACCOUNT_ID'].astype(str)</span><span id="155a" class="ni lj iq nv b gy od oa l ob oc">alerts['ALERT_ID'] = alerts['ALERT_ID'].astype(str)<br/>alerts['SENDER_ACCOUNT_ID'] = alerts['SENDER_ACCOUNT_ID'].astype(str)<br/>alerts['RECEIVER_ACCOUNT_ID'] = alerts['RECEIVER_ACCOUNT_ID'].astype(str)</span><span id="3b51" class="ni lj iq nv b gy od oa l ob oc">transactions['TX_ID'] = transactions['TX_ID'].astype(str)<br/>transactions['SENDER_ACCOUNT_ID'] = transactions['SENDER_ACCOUNT_ID'].astype(str)<br/>transactions['RECEIVER_ACCOUNT_ID'] = transactions['RECEIVER_ACCOUNT_ID'].astype(str)</span></pre><p id="ec4c" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr mc kt ku kv me kx ky kz mg lb lc ld le ij bi translated">现在，在我们将数据加载到图表中之前，让我们更新图表参数。我们将创建一个API令牌，并将graphname设置为AMLSim。</p><pre class="mj mk ml mm gt nu nv nw nx aw ny bi"><span id="5845" class="ni lj iq nv b gy nz oa l ob oc">conn.graphname = "AMLSim"</span><span id="f8a6" class="ni lj iq nv b gy od oa l ob oc">conn.apiToken = conn.getToken(conn.createSecret())</span></pre><p id="cda6" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr mc kt ku kv me kx ky kz mg lb lc ld le ij bi translated">最后，我们将使用pyTigerGraph中的upsertVertexDataFrame和upsertEdgeDataFrame函数将数据帧作为顶点和边向上插入到我们的图形中。</p><pre class="mj mk ml mm gt nu nv nw nx aw ny bi"><span id="926e" class="ni lj iq nv b gy nz oa l ob oc"># UPSERT VERTEX "Customer"<br/>v_customer = conn.upsertVertexDataFrame(accounts, "Customer", "CUSTOMER_ID", attributes={"id": "CUSTOMER_ID"})<br/>print(str(v_customer) + " Customer VERTICES Upserted")</span><span id="2267" class="ni lj iq nv b gy od oa l ob oc"># UPSERT VERTEX "Account"<br/>v_account = conn.upsertVertexDataFrame(accounts, "Account", "ACCOUNT_ID", attributes={"id": "ACCOUNT_ID", "init_balance": "INIT_BALANCE", "account_type": "ACCOUNT_TYPE", "tx_behavior": "TX_BEHAVIOR_ID"})<br/>print(str(v_account) + " Account VERTICES Upserted")</span><span id="54d5" class="ni lj iq nv b gy od oa l ob oc"># UPSERT VERTEX "Transaction"<br/>v_transaction = conn.upsertVertexDataFrame(transactions, "Transaction", "TX_ID", attributes={"id": "TX_ID", "amount": "TX_AMOUNT", "is_fraud": "IS_FRAUD"})<br/>print(str(v_transaction) + " Transaction VERTICES Upserted")</span><span id="3d02" class="ni lj iq nv b gy od oa l ob oc"># UPSERT VERTEX "Alert"<br/>v_alert = conn.upsertVertexDataFrame(alerts, "Alert", "ALERT_ID", attributes={"id": "ALERT_ID", "alert_type": "ALERT_TYPE", "ts": "TIMESTAMP"})<br/>print(str(v_alert) + " Alert VERTICES Upserted")</span><span id="9faf" class="ni lj iq nv b gy od oa l ob oc"># UPSERT EDGE "Send_Transaction"<br/>e_send_transaction = conn.upsertEdgeDataFrame(transactions, "Account", "Send_Transaction", "Transaction", from_id="SENDER_ACCOUNT_ID", to_id="TX_ID", attributes={"ts": "TIMESTAMP", "tx_type": "TX_TYPE"})<br/>print(str(e_send_transaction) + " Send_Transaction EDGES Upserted")</span><span id="bf7e" class="ni lj iq nv b gy od oa l ob oc"># UPSERT EDGE "Send_Transaction"<br/>e_recieve_transaction = conn.upsertEdgeDataFrame(transactions, "Transaction", "Recieve_Transaction", "Account", from_id="TX_ID", to_id="RECEIVER_ACCOUNT_ID", attributes={"ts": "TIMESTAMP", "tx_type": "TX_TYPE"})<br/>print(str(e_recieve_transaction) + " Recieve_Transaction EDGES Upserted")</span><span id="90bb" class="ni lj iq nv b gy od oa l ob oc"># UPSERT EDGE "Send_To"<br/>e_send_to = conn.upsertEdgeDataFrame(transactions, "Account", "Send_To", "Account", from_id="SENDER_ACCOUNT_ID", to_id="RECEIVER_ACCOUNT_ID", attributes={})<br/>print(str(e_send_to) + " Send_To EDGES Upserted")</span><span id="f8b4" class="ni lj iq nv b gy od oa l ob oc"># UPSERT EDGE "Transaction_Flagged"<br/>e_transaction_flagged = conn.upsertEdgeDataFrame(alerts, "Transaction", "Transaction_Flagged", "Alert", from_id="TX_ID", to_id="ALERT_ID", attributes={})<br/>print(str(e_transaction_flagged) + " Transaction_Flagged EDGES Upserted")</span><span id="10c3" class="ni lj iq nv b gy od oa l ob oc"># UPSERT EDGE "Customer_Account"<br/>e_customer_account = conn.upsertEdgeDataFrame(accounts, "Customer", "Customer_Account", "Account", from_id="CUSTOMER_ID", to_id="ACCOUNT_ID", attributes={})<br/>print(str(e_customer_account) + " Customer_Account EDGES Upserted")</span><span id="4819" class="ni lj iq nv b gy od oa l ob oc"># UPSERT EDGE "Based_In"<br/>e_based_in = conn.upsertEdgeDataFrame(accounts, "Customer", "Based_In", "Country", from_id="CUSTOMER_ID", to_id="COUNTRY", attributes={})<br/>print(str(e_based_in) + " Based_In EDGES Upserted")</span><span id="3735" class="ni lj iq nv b gy od oa l ob oc"># PRINT OUT STATS<br/>print("=====TOTAL_UPSERTS=====")<br/>print(str(v_customer+v_account+v_transaction+v_alert) + " TOTAL VERTICES")<br/>print(str(e_send_transaction+e_recieve_transaction+e_send_to+e_transaction_flagged+e_customer_account+e_based_in) + " TOTAL EDGES")</span></pre><p id="12fc" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr mc kt ku kv me kx ky kz mg lb lc ld le ij bi translated">最后，您可以转到GraphStudio中的loading选项卡，您会发现所有数据都被向上插入。</p><figure class="mj mk ml mm gt mn gh gi paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="gh gi mi"><img src="../Images/be65bf9cf7b96cf84c1b7203579d6dd3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2pJqBQqqlM9m2LGhfuprAA.png"/></div></div><p class="nb nc gj gh gi nd ne bd b be z dk translated">我们的图表中现在有数据了！</p></figure><p id="14e4" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr mc kt ku kv me kx ky kz mg lb lc ld le ij bi translated">恭喜你。您已经用TigerGraph正式创建了一个图形数据库，创建了一个模式并加载了数据！现在，让我们编写一些查询和图算法来更新我们的图，并为机器学习做准备。</p><h1 id="8f60" class="li lj iq bd lk ll lm ln lo lp lq lr ls jw lt jx lu jz lv ka lw kc lx kd ly lz bi translated">第三部分:创建和安装查询</h1><h2 id="c0e8" class="ni lj iq bd lk nj nk dn lo nl nm dp ls mc nn no lu me np nq lw mg nr ns ly nt bi translated">查询I:帐户活动</h2><p id="3fc4" class="pw-post-body-paragraph ki kj iq kl b km ma jr ko kp mb ju kr mc md ku kv me mf ky kz mg mh lc ld le ij bi translated">我们的第一个查询accountActivity将用于使用有关帐户活动的特性来更新图中顶点和边的属性。例如，它将更新帐户的当前余额、帐户的最大、最小和平均交易金额，以及帐户的交易数量。</p><pre class="mj mk ml mm gt nu nv nw nx aw ny bi"><span id="0bf0" class="ni lj iq nv b gy nz oa l ob oc">print(conn.gsql('''</span><span id="a635" class="ni lj iq nv b gy od oa l ob oc">CREATE QUERY accountActivity() FOR GRAPH AMLSim {</span><span id="1df0" class="ni lj iq nv b gy od oa l ob oc">SumAccum&lt;DOUBLE&gt; @s_sumAmt, @r_sumAmt;<br/>SumAccum&lt;DOUBLE&gt; @s_txCnt, @r_txCnt;<br/>MinAccum&lt;DOUBLE&gt; @s_minAmt, @r_minAmt;<br/>MaxAccum&lt;DOUBLE&gt; @s_maxAmt, @r_maxAmt;<br/>AvgAccum @s_avgAmt, @r_avgAmt;</span><span id="43a2" class="ni lj iq nv b gy od oa l ob oc">Seed = {Account.*};</span><span id="01ed" class="ni lj iq nv b gy od oa l ob oc">acctSend = SELECT tgt FROM Seed:s -(Send_Transaction:e)-&gt; Transaction:tgt<br/>ACCUM s.@s_sumAmt += tgt.amount, s.@s_txCnt += 1, s.@s_minAmt += tgt.amount, s.@s_maxAmt += tgt.amount, s.@s_avgAmt += tgt.amount<br/>POST-ACCUM s.current_balance = s.@s_sumAmt - s.init_balance, s.min_send_tx = s.@s_minAmt, s.max_send_tx = s.@s_maxAmt, s.avg_send_tx = s.@s_avgAmt, s.cnt_send_tx = s.@s_txCnt;</span><span id="55bf" class="ni lj iq nv b gy od oa l ob oc">acctRecieve = SELECT tgt FROM Seed:s -(reverse_Recieve_Transaction:e)-&gt; Transaction:tgt<br/>ACCUM s.@r_sumAmt += tgt.amount, s.@r_txCnt += 1, s.@r_minAmt += tgt.amount, s.@r_maxAmt += tgt.amount, s.@r_avgAmt += tgt.amount<br/>POST-ACCUM s.current_balance = s.@r_sumAmt + s.init_balance, s.min_recieve_tx = s.@r_minAmt, s.max_recieve_tx = s.@r_maxAmt, s.avg_recieve_tx = s.@r_avgAmt, s.cnt_recieve_tx = s.@r_txCnt;</span><span id="0e6d" class="ni lj iq nv b gy od oa l ob oc">PRINT "Features Have Been Calculated";</span><span id="497f" class="ni lj iq nv b gy od oa l ob oc">}</span><span id="ff90" class="ni lj iq nv b gy od oa l ob oc">INSTALL QUERY accountActivity</span><span id="a227" class="ni lj iq nv b gy od oa l ob oc">''', options=[]))</span></pre><h2 id="47c2" class="ni lj iq bd lk nj nk dn lo nl nm dp ls mc nn no lu me np nq lw mg nr ns ly nt bi translated">查询二:label_prop</h2><p id="71d7" class="pw-post-body-paragraph ki kj iq kl b km ma jr ko kp mb ju kr mc md ku kv me mf ky kz mg mh lc ld le ij bi translated">标签属性是一种图形算法。要了解更多信息，请访问德州陈的博客！你也可以在<a class="ae lh" href="https://docs.tigergraph.com/tigergraph-platform-overview/graph-algorithm-library#label-propagation" rel="noopener ugc nofollow" target="_blank"> TigerGraph的算法页面</a>了解。简而言之，这种算法试图找到社区，并根据其社区标记一个顶点。</p><pre class="mj mk ml mm gt nu nv nw nx aw ny bi"><span id="0df8" class="ni lj iq nv b gy nz oa l ob oc">print(conn.gsql('''</span><span id="f72e" class="ni lj iq nv b gy od oa l ob oc">CREATE QUERY label_prop (SET&lt;STRING&gt; v_type, SET&lt;STRING&gt; e_type, INT max_iter, INT output_limit, BOOL print_accum = TRUE, STRING file_path = "", STRING attr = "") FOR GRAPH AMLSim{</span><span id="235e" class="ni lj iq nv b gy od oa l ob oc">OrAccum @@changed = true;<br/>MapAccum&lt;INT, INT&gt; @map;<br/>MapAccum&lt;INT, INT&gt; @@commSizes;<br/>SumAccum&lt;INT&gt; @label, @num;</span><span id="08ca" class="ni lj iq nv b gy od oa l ob oc">FILE f (file_path);</span><span id="5090" class="ni lj iq nv b gy od oa l ob oc">Start = {v_type};<br/>Start = SELECT s FROM Start:s ACCUM s.@label = getvid(s);</span><span id="9c93" class="ni lj iq nv b gy od oa l ob oc">WHILE @@changed == true LIMIT max_iter DO<br/>@@changed = false;</span><span id="3c01" class="ni lj iq nv b gy od oa l ob oc">Start = SELECT s<br/>FROM Start:s -(e_type:e)-&gt; :t<br/>ACCUM t.@map += (s.@label -&gt; 1)<br/>POST-ACCUM INT maxV = 0, INT label = 0,<br/>FOREACH (k,v) IN t.@map DO<br/>CASE WHEN v &gt; maxV THEN maxV = v, label = k<br/>END<br/>END,</span><span id="7edc" class="ni lj iq nv b gy od oa l ob oc">CASE WHEN label != 0 AND t.@label != label AND maxV &gt; t.@num THEN<br/>@@changed += true,<br/>t.@label = label,<br/>t.@num = maxV<br/>END,<br/>t.@map.clear();</span><span id="c19a" class="ni lj iq nv b gy od oa l ob oc">END;</span><span id="52fa" class="ni lj iq nv b gy od oa l ob oc">Start = {v_type};</span><span id="2d80" class="ni lj iq nv b gy od oa l ob oc">Start =  SELECT s FROM Start:s<br/>POST-ACCUM<br/>IF attr != "" THEN s.setAttr(attr, s.@label) END,<br/>IF file_path != "" THEN f.println(s, s.@label) END,<br/>IF print_accum THEN @@commSizes += (s.@label -&gt; 1) END<br/>LIMIT output_limit;</span><span id="c6e8" class="ni lj iq nv b gy od oa l ob oc">IF print_accum THEN<br/>PRINT @@commSizes;<br/>PRINT Start[Start.@label];</span><span id="1e8e" class="ni lj iq nv b gy od oa l ob oc">END;</span><span id="7de9" class="ni lj iq nv b gy od oa l ob oc">}</span><span id="5e4b" class="ni lj iq nv b gy od oa l ob oc">INSTALL QUERY label_prop</span><span id="6fa0" class="ni lj iq nv b gy od oa l ob oc">''', options=[]))</span></pre><h2 id="4fd1" class="ni lj iq bd lk nj nk dn lo nl nm dp ls mc nn no lu me np nq lw mg nr ns ly nt bi translated">查询三:page_rank</h2><p id="debb" class="pw-post-body-paragraph ki kj iq kl b km ma jr ko kp mb ju kr mc md ku kv me mf ky kz mg mh lc ld le ij bi translated">页面排序是另一种图形算法。要了解更多，请查看即将在<a class="lf lg ep" href="https://medium.com/u/9ee92495f34e?source=post_page-----2f3e6487f398--------------------------------" rel="noopener" target="_blank">德州陈</a>的网页上发布的博客！你也可以在<a class="ae lh" href="https://docs.tigergraph.com/tigergraph-platform-overview/graph-algorithm-library#pagerank" rel="noopener ugc nofollow" target="_blank"> TigerGraph的算法页面</a>了解。简而言之，这个算法将查看图中每个顶点对每个其他顶点的影响，并给它一个影响分数。</p><pre class="mj mk ml mm gt nu nv nw nx aw ny bi"><span id="1f46" class="ni lj iq nv b gy nz oa l ob oc">print(conn.gsql('''</span><span id="6ef7" class="ni lj iq nv b gy od oa l ob oc">CREATE QUERY pageRank (STRING v_type, STRING e_type, FLOAT max_change=0.001, INT max_iter=25, FLOAT damping=0.85, INT top_k = 100, BOOL print_accum = TRUE, STRING result_attr =  "", STRING file_path = "", BOOL display_edges = FALSE) FOR GRAPH AMLSim {</span><span id="7624" class="ni lj iq nv b gy od oa l ob oc">TYPEDEF TUPLE&lt;VERTEX Vertex_ID, FLOAT score&gt; Vertex_Score;<br/>HeapAccum&lt;Vertex_Score&gt;(top_k, score DESC) @@topScores;<br/>MaxAccum&lt;FLOAT&gt; @@max_diff = 9999;<br/>SumAccum&lt;FLOAT&gt; @recvd_score = 0;<br/>SumAccum&lt;FLOAT&gt; @score = 1;<br/>SetAccum&lt;EDGE&gt; @@edgeSet;</span><span id="f4ce" class="ni lj iq nv b gy od oa l ob oc">FILE f (file_path);</span><span id="8f44" class="ni lj iq nv b gy od oa l ob oc">Start = {v_type};</span><span id="0791" class="ni lj iq nv b gy od oa l ob oc">WHILE @@max_diff &gt; max_change LIMIT max_iter DO<br/>@@max_diff = 0;</span><span id="8c8a" class="ni lj iq nv b gy od oa l ob oc">V = SELECT s FROM Start:s -(e_type:e)-&gt; v_type:t<br/>ACCUM t.@recvd_score += s.@score/(s.outdegree(e_type))<br/>POST-ACCUM s.@score = (1.0-damping) + damping * s.@recvd_score, s.@recvd_score = 0, @@max_diff += abs(s.@score - s.@score');</span><span id="4ac3" class="ni lj iq nv b gy od oa l ob oc">END; </span><span id="5bac" class="ni lj iq nv b gy od oa l ob oc">IF file_path != "" THEN<br/>f.println("Vertex_ID", "PageRank");<br/>END;</span><span id="8234" class="ni lj iq nv b gy od oa l ob oc">V = SELECT s FROM Start:s<br/>POST-ACCUM<br/>IF result_attr != "" THEN s.setAttr(result_attr, s.@score) END,<br/>IF file_path != "" THEN f.println(s, s.@score) END,<br/>IF print_accum THEN @@topScores += Vertex_Score(s, s.@score) END;<br/>IF print_accum THEN PRINT @@topScores;<br/>IF display_edges THEN PRINT Start[Start.@score];</span><span id="acae" class="ni lj iq nv b gy od oa l ob oc">Start = SELECT s FROM Start:s -(e_type:e)-&gt; v_type:t<br/>ACCUM @@edgeSet += e;<br/>PRINT @@edgeSet;</span><span id="3757" class="ni lj iq nv b gy od oa l ob oc">END; END;</span><span id="a07b" class="ni lj iq nv b gy od oa l ob oc">}</span><span id="12a8" class="ni lj iq nv b gy od oa l ob oc">INSTALL QUERY pageRank</span><span id="2b9a" class="ni lj iq nv b gy od oa l ob oc">''', options=[]))</span></pre><h2 id="27de" class="ni lj iq bd lk nj nk dn lo nl nm dp ls mc nn no lu me np nq lw mg nr ns ly nt bi translated">查询四:多重限制</h2><p id="f049" class="pw-post-body-paragraph ki kj iq kl b km ma jr ko kp mb ju kr mc md ku kv me mf ky kz mg mh lc ld le ij bi translated">这是我们将使用的最后一个查询。这个查询将能够获取我们想要的所有期望的属性。它将抓取前1000笔交易，订单基于是否欺诈。</p><pre class="mj mk ml mm gt nu nv nw nx aw ny bi"><span id="57b2" class="ni lj iq nv b gy nz oa l ob oc">print(conn.gsql('''</span><span id="bd30" class="ni lj iq nv b gy od oa l ob oc">CREATE QUERY txMultiHopLimit() FOR GRAPH AMLSim SYNTAX v2 {  </span><span id="01f1" class="ni lj iq nv b gy od oa l ob oc">/* This grabs the first 1,000 transactions. The beginning has all of the fraudulent transactions and the latter part has some non-fraudulent transactions. */</span><span id="c6c2" class="ni lj iq nv b gy od oa l ob oc">TYPEDEF TUPLE &lt;BOOL tx_fraud, DOUBLE tx_amount, FLOAT s_pagerank, INT s_label, DOUBLE s_min_send_tx, DOUBLE s_min_receieve_tx, DOUBLE s_max_send_tx, DOUBLE s_max_recieve_tx, DOUBLE s_avg_send_tx, DOUBLE s_avg_recieve_tx, INT s_cnt_recieve_tx, INT s_cnt_send_tx, INT s_timestamp, FLOAT r_pagerank, INT r_label, DOUBLE r_min_send_tx, DOUBLE r_min_receieve_tx, DOUBLE r_max_send_tx, DOUBLE r_max_recieve_tx, DOUBLE r_avg_send_tx, DOUBLE r_avg_recieve_tx, INT r_cnt_recieve_tx, INT r_cnt_send_tx, INT r_timestamp&gt; ORDER_TX;</span><span id="105b" class="ni lj iq nv b gy od oa l ob oc">HeapAccum&lt;ORDER_TX&gt;(1000, tx_fraud DESC) @@txRecords;</span><span id="1e87" class="ni lj iq nv b gy od oa l ob oc">Seed = {Account.*};</span><span id="20e1" class="ni lj iq nv b gy od oa l ob oc">acctSend = SELECT tgt FROM Seed:s - ((Send_Transaction&gt;):e1) - Transaction:v1 - ((Recieve_Transaction&gt;):e2) - Account:tgt </span><span id="8d58" class="ni lj iq nv b gy od oa l ob oc">ACCUM @@txRecords += ORDER_TX(v1.is_fraud, v1.amount, s.pagerank, s.label, s.min_send_tx, s.min_recieve_tx, s.max_send_tx, s.max_recieve_tx, s.avg_send_tx, s.avg_recieve_tx, s.cnt_recieve_tx, s.cnt_send_tx, e1.ts, tgt.pagerank, tgt.label, tgt.min_send_tx, tgt.min_recieve_tx, tgt.max_send_tx, tgt.max_recieve_tx, tgt.avg_send_tx, tgt.avg_recieve_tx, tgt.cnt_recieve_tx, tgt.cnt_send_tx, e2.ts);  </span><span id="e39f" class="ni lj iq nv b gy od oa l ob oc">PRINT @@txRecords; </span><span id="72ee" class="ni lj iq nv b gy od oa l ob oc">}</span><span id="ec0b" class="ni lj iq nv b gy od oa l ob oc">INSTALL QUERY txMultiHopLimit</span><span id="55e8" class="ni lj iq nv b gy od oa l ob oc">''', options=[]))</span></pre><p id="69a0" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr mc kt ku kv me kx ky kz mg lb lc ld le ij bi translated">干得好！您现在已经创建并安装了您需要的所有查询！现在让我们开始执行查询来更新我们的图表并获取我们的数据(我们将使用这些数据进行机器学习)。</p><h1 id="4786" class="li lj iq bd lk ll lm ln lo lp lq lr ls jw lt jx lu jz lv ka lw kc lx kd ly lz bi translated">第四部分:执行查询来构建图表</h1><p id="b783" class="pw-post-body-paragraph ki kj iq kl b km ma jr ko kp mb ju kr mc md ku kv me mf ky kz mg mh lc ld le ij bi translated">现在，让我们把所有的东西放在一起更新我们的图表。首先，我们需要在图表中生成属性/特征，所以让我们运行accountActivity查询。</p><pre class="mj mk ml mm gt nu nv nw nx aw ny bi"><span id="17fc" class="ni lj iq nv b gy nz oa l ob oc">accAct = conn.runInstalledQuery("accountActivity", {})</span></pre><p id="8124" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr mc kt ku kv me kx ky kz mg lb lc ld le ij bi translated">接下来，我们需要更新图中的label_prop和pagerank值，所以接下来让我们运行它们。</p><pre class="mj mk ml mm gt nu nv nw nx aw ny bi"><span id="b8ed" class="ni lj iq nv b gy nz oa l ob oc">pagerank = conn.runInstalledQuery("pageRank", {"v_type":"Account", "e_type":"Send_To", "max_change":"0.001", "max_iter":"25", "damping":"0.85", "top_k":"10", "print_accum":"TRUE", "result_attr":"pagerank", "file_path":"", "display_edges":"FALSE"})</span><span id="0789" class="ni lj iq nv b gy od oa l ob oc">label_prop = conn.runInstalledQuery("label_prop", {"v_type":"Account", "e_type":"Send_To", "max_iter":"10", "output_limit":"10", "print_accum":"TRUE", "file_path":"", "attr":"label"})</span></pre><p id="bd9e" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr mc kt ku kv me kx ky kz mg lb lc ld le ij bi translated">太好了！我们的图表正式全面更新！现在让我们用txMultiHopLimit获取我们想要的所有值。</p><pre class="mj mk ml mm gt nu nv nw nx aw ny bi"><span id="3ce6" class="ni lj iq nv b gy nz oa l ob oc">tx_hop = conn.runInstalledQuery("txMultiHopLimit", {}, timeout="99999999999", sizeLimit="1500000000")</span></pre><p id="85de" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr mc kt ku kv me kx ky kz mg lb lc ld le ij bi translated">最后，我们将导入flat_tables来规范化图形(注意任何有问题的值，比如NaN)。我们将删除索引列并保存CSV。</p><pre class="mj mk ml mm gt nu nv nw nx aw ny bi"><span id="f753" class="ni lj iq nv b gy nz oa l ob oc">!pip install flat-table<br/>import flat_table</span><span id="1237" class="ni lj iq nv b gy od oa l ob oc">df_tx_hop = pd.DataFrame(tx_hop[0]["@@txRecords"])<br/>df_tx_hop = flat_table.normalize(df_tx_hop)</span><span id="68fe" class="ni lj iq nv b gy od oa l ob oc">df_tx_hop = df_tx_hop.drop(columns=["index"])</span><span id="1a2b" class="ni lj iq nv b gy od oa l ob oc">df_tx_hop.to_csv("tg_fraud_data.csv", index=False)</span></pre><p id="6f6c" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr mc kt ku kv me kx ky kz mg lb lc ld le ij bi translated">太棒了。现在您的Colab中有一个CSV文件可以下载了！我们将在控制台中对Vertex AI使用该查询，并且我们将对自定义训练使用txMultiHopLimit查询。</p><h1 id="33a5" class="li lj iq bd lk ll lm ln lo lp lq lr ls jw lt jx lu jz lv ka lw kc lx kd ly lz bi translated">第五部分:祝贺+下一步</h1><p id="1b85" class="pw-post-body-paragraph ki kj iq kl b km ma jr ko kp mb ju kr mc md ku kv me mf ky kz mg mh lc ld le ij bi translated">恭喜你。您已经使用TigerGraph创建了一个图表，创建并运行了用于特征提取和图表算法的查询，并保存了数据的CSV文件！接下来，我们将探索如何使用Google的AutoML来处理我们刚刚导出的CSV数据。明天在博客上看看吧！</p><p id="0baa" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr mc kt ku kv me kx ky kz mg lb lc ld le ij bi translated">与此同时，如果您有任何问题或者您想了解更多关于TigerGraph的信息，请加入TigerGraph Discord！</p><div class="og oh gp gr oi oj"><a href="https://discord.gg/gRHWBZNpxW" rel="noopener  ugc nofollow" target="_blank"><div class="ok ab fo"><div class="ol ab om cl cj on"><h2 class="bd ir gy z fp oo fr fs op fu fw ip bi translated">加入TigerGraph Discord服务器！</h2><div class="oq l"><h3 class="bd b gy z fp oo fr fs op fu fw dk translated">查看Discord上的TigerGraph社区-与572名其他成员一起玩，享受免费的语音和文本聊天。</h3></div><div class="or l"><p class="bd b dl z fp oo fr fs op fu fw dk translated">不和谐. gg</p></div></div><div class="os l"><div class="ot l ou ov ow os ox ms oj"/></div></div></a></div></div></div>    
</body>
</html>