<html>
<head>
<title>Coding a production ready API - part 1: implementing an ORM</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">编写生产就绪API -第1部分:实现ORM</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/build-a-real-life-professional-api-with-an-orm-part-1-8fce4d480d59?source=collection_archive---------22-----------------------#2021-05-23">https://towardsdatascience.com/build-a-real-life-professional-api-with-an-orm-part-1-8fce4d480d59?source=collection_archive---------22-----------------------#2021-05-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6818" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">为我们的网站创建一个高效、安全和快速的API，而不需要编写一行SQL</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/7e0f5a1b7bc438a65895a137bd415ba9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PA_am84aeXnXUX0Eb0OWNA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">我们的API会比这些可爱的生物更快(图片由<a class="ae ky" href="https://www.pexels.com/@chevanon" rel="noopener ugc nofollow" target="_blank">切瓦农摄影</a>在<a class="ae ky" href="https://www.pexels.com/photo/two-yellow-labrador-retriever-puppies-1108099/" rel="noopener ugc nofollow" target="_blank">像素</a>上拍摄)</p></figure><p id="039c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">想象一下去一家餐馆。你坐下来，看菜单，选择一些菜。然后你走向厨房，告诉厨师你想吃什么，等他吃完后再把你的饭菜端上桌。这家奇怪的餐馆里发生了什么事？</p><p id="20c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">没有API的应用程序就像没有服务员的餐馆。在餐馆里，你不需要和厨房沟通，也不需要等着点菜来享用美食。同样的，一个网站不需要知道如何与你的数据库通信。像一个服务员一样，我们的API从我们的网站收到一个命令:“我想要一些带有元数据的用户统计数据”。API随后检查订单(是否允许您拥有该数据？)，说服我们的数据库(厨师)为他烹制一些美味的信息，等待数据库完成，最后将数据返回到网站。</p><h2 id="c3b4" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">这篇文章是关于什么的？</h2><p id="a5a5" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">我们将使用ORM为我们正在构建的名为<a class="ae ky" href="https://mikehuls.medium.com/version-control-your-database-part-2-migrations-and-seeds-for-table-relations-d4fb185d95d8" rel="noopener"> <strong class="lb iu"> BeerSnob </strong> </a>的现实世界应用程序创建一个全功能、快速和安全的API一个专门为喝优质啤酒的人建立的网站。它允许用户分享关于他们在特定场所喝的啤酒的评论；在提供价格和口味信息的同时，对场地和啤酒进行评级。在本文结束时，您将拥有一个带有ORM的工作API，并有一个迁移模型来完成它！首先我们进入<em class="mt">为什么</em>我们会创建一个API或者ORM，然后我们开始编码。</p></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h1 id="3e03" class="nb lw it bd lx nc nd ne ma nf ng nh md jz ni ka mg kc nj kd mj kf nk kg mm nl bi translated">0.目标和准备</h1><p id="6036" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">我们的目标是为BeerSnob创建一个API，它将从网站接收用户创建的数据包。基于所需的动作，它然后从数据库中检索数据或将数据包插入到数据库中。数据包可能包含多个表的信息，API的工作是确保正确的信息出现在正确的表中。</p><h1 id="a6d8" class="nb lw it bd lx nc nm ne ma nf nn nh md jz no ka mg kc np kd mj kf nq kg mm nl bi translated">为什么要构建API？</h1><p id="6691" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">如果你点击脸书网站或应用程序中的“我的朋友”，你会向API发送信息请求。这个软件翻译你的请求，检查你是否被允许提出请求，收集所有的数据并用你的数据包回应。这很好，有几个原因:</p><ul class=""><li id="275d" class="nr ns it lb b lc ld lf lg li nt lm nu lq nv lu nw nx ny nz bi translated">保持我们的代码整洁</li><li id="b595" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated">保护对我们数据库的访问(网站与我们的数据库分离，例如:我们的网站不需要有数据库凭证)</li><li id="73b1" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated">检查用户对数据的访问(我只能更改<em class="mt">我的</em>个人资料，不能更改其他人的)</li></ul><h2 id="3e20" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">为什么要使用ORM？</h2><p id="c980" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">ORM代表对象关系映射，它是一种允许你使用对象从数据库中查询和操作数据的技术。您不必再编写查询，您可以使用对象来检索数据。伪代码示例:<code class="fe of og oh oi b">song_list = SongTable.query(artist="Snoop dogg")</code>。优点:</p><ul class=""><li id="51f7" class="nr ns it lb b lc ld lf lg li nt lm nu lq nv lu nw nx ny nz bi translated">没必要写SQL</li><li id="f57b" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated">很多事情都是自动完成的</li><li id="b1c5" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated">阻止<a class="ae ky" href="https://en.wikipedia.org/wiki/SQL_injection" rel="noopener ugc nofollow" target="_blank"> SQL注入</a></li></ul><p id="c4c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们来编码吧！</p></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h1 id="4afe" class="nb lw it bd lx nc nd ne ma nf ng nh md jz ni ka mg kc nj kd mj kf nk kg mm nl bi translated">1.设置</h1><p id="0791" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">在API能够处理数据库数据之前，我们需要一个实际使用的数据库。在<a class="ae ky" href="https://mikehuls.medium.com/version-control-your-database-part-2-migrations-and-seeds-for-table-relations-d4fb185d95d8" rel="noopener"> <strong class="lb iu">这篇文章</strong> </a> <strong class="lb iu"> </strong>中，我们使用迁移来创建所有的表、关联、关联和索引。无论您是否使用迁移，本文还包含一个非常漂亮的BeerSnob数据库结构图。</p><p id="44ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将在<a class="ae ky" href="https://mikehuls.medium.com/version-control-your-database-part-2-migrations-and-seeds-for-table-relations-d4fb185d95d8" rel="noopener"> <strong class="lb iu">本文</strong> </a>中构建的迁移模型上构建API。如果你想编码，那么git从这里的<a class="ae ky" href="https://github.com/mike-huls/beersnobv2" rel="noopener ugc nofollow" target="_blank"><strong class="lb iu"/></a><strong class="lb iu">克隆代码。</strong>首先让我们构建一个ORM，然后实现我们的API。</p><h1 id="eb2b" class="nb lw it bd lx nc nm ne ma nf nn nh md jz no ka mg kc np kd mj kf nq kg mm nl bi translated">2.为我们的ORM创建模型</h1><p id="612c" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">ORM是我们可以在API中使用的对象和数据库中的数据之间的转换。为了将数据库数据转换成对象，它使用“模型”。在我们的BeerSnob示例中，我们希望按照<code class="fe of og oh oi b">foundbeers = BeerTable.Get(ID=2)</code>的思路做一些事情。在这个例子中，BeerTable是一个模型，它能够连接到数据库中的Beers表，并对其执行操作，如检索数据和插入新记录。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/f949ed280408c6ddf27982835a643cd1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p1kOrihQM70O-eZr9pWWcA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">像这个好孩子一样，我们的ORM将在我们的努力中帮助我们</p></figure><p id="fdc7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们创建我们的第一个模型；国家。这个模型处理我们国家表中的数据。在“models”目录下创建一个名为countries.js的新文件，内容如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="ecbf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个简单的文件允许我们创建一个模型。创建一个模型并理解它是如何工作的并不难。重要的事情定义如下。</p><ul class=""><li id="9a94" class="nr ns it lb b lc ld lf lg li nt lm nu lq nv lu nw nx ny nz bi translated">在tableModel(第5行)中，我们添加了modelName。我决定保持表名的复数形式(countries表包含许多国家的记录)和模型名的单数形式(一个模型只描述一个国家)。</li><li id="97c1" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated">模型与另一个模型相关联(第11行)。我们告诉我们的ORM，如果我们删除一个国家，一个城市应该被删除。我们还在国家表(CountryId)上定义了外键。</li><li id="d325" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated">在Init中，我们定义了一些关于列的信息。ORM需要知道数据库中列的数据类型和名称。</li><li id="8217" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated">时间戳:false(第24行)。如果设置为true，ORM会添加额外的列来跟踪创建和修改的时间戳(我们手动处理这些，但是ORM也可以为您完成)。</li></ul><p id="d2a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当定义模型之间的关联时，有几个选项。到目前为止，我已经在这个项目中使用了一些，但是我们将在下一部分中更深入地研究它们。我还为其他表格创建了模型。查看存储库以获取更多信息。</p><h1 id="4390" class="nb lw it bd lx nc nm ne ma nf nn nh md jz no ka mg kc np kd mj kf nq kg mm nl bi translated">3.原料药制备</h1><p id="d7ed" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">在我们开始创建API之前，我们需要安装一些依赖项并准备一些东西。</p><h2 id="41b2" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">3.1安装包。</h2><p id="7c61" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">转到您的根文件夹并:</p><pre class="kj kk kl km gt om oi on oo aw op bi"><span id="821d" class="lv lw it oi b gy oq or l os ot">npm install --save express body-parser<br/>npm install --save-dev nodemon</span></pre><p id="f24e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将安装我们的API需要的包。Express是一个web服务器，body-parser允许我们解析通过该web服务器发送的请求体。然后我们安装一个开发依赖；这些仅用于构建我们的应用程序，并且通常仅用于开发。每次我们更改代码时，Nodemon都会重新加载我们的web服务器。我的f5键对此非常感谢。</p><h2 id="edd1" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">3.2配置您的应用程序以使用Nodemon</h2><p id="067d" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">打开根文件夹中的package.json文件。调整“脚本”部分以反映以下内容:</p><pre class="kj kk kl km gt om oi on oo aw op bi"><span id="a41a" class="lv lw it oi b gy oq or l os ot">"scripts": {<br/>    "start": "node server.js",<br/>    "dev": "nodemon server.js"<br/>  },</span></pre><p id="4a11" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将允许我们在生产环境中调用<code class="fe of og oh oi b">npm run start</code>或<code class="fe of og oh oi b">npm run dev</code>用nodemon运行我们的应用程序，允许重启。</p><h2 id="46df" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">3.3创建文件夹</h2><p id="66b1" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">在根目录下创建两个文件夹:“routes”和“service”。</p><h1 id="2ca2" class="nb lw it bd lx nc nm ne ma nf nn nh md jz no ka mg kc np kd mj kf nq kg mm nl bi translated">4.构建API</h1><p id="aee8" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">是时候让这些模型发挥作用了！有了API，我们将能够接收请求并使用模型从数据库中检索数据。我们首先设计我们的服务器，它将捕获所有的请求，并将它们传递给一个路由。然后，路由将检查请求并与数据库通信。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ou"><img src="../Images/0733f3e5f8a1acbe315462f9576c2c36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OygBbgZp6d89UsrIuEh4rw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">该去拿东西了！(图片由<a class="ae ky" href="https://www.pexels.com/photo/two-adult-black-and-tan-german-shepherds-running-on-ground-1633522/" rel="noopener ugc nofollow" target="_blank"> Pexels </a>上的<a class="ae ky" href="https://www.pexels.com/@jozef-feher-356581" rel="noopener ugc nofollow" target="_blank">约瑟夫·费尔</a>拍摄)</p></figure><h2 id="ff54" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">4.1为我们的应用程序创建服务器</h2><p id="2faf" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">使用下面的脚本，我们将有一个服务器启动并运行。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="5cd4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事情是这样的:</p><ul class=""><li id="4c81" class="nr ns it lb b lc ld lf lg li nt lm nu lq nv lu nw nx ny nz bi translated">我们导入了一些包和日志服务。这个服务帮助我们调试，我们在第13行这样做。</li><li id="e8fe" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated">在第9行，我们创建了一个可以传递请求的应用程序。</li><li id="fe64" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated">第24行；我们告诉app我们要用bodyParser通过这种方式，我们可以接收例如json数据。</li><li id="3aea" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated">第29行:我们设置API的规则。</li><li id="8047" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated">第41行到第46行:我们捕获一些URL路径，并将它们传递给我们的routes。</li><li id="f0aa" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated">第59行:为我们的应用程序创建一个服务器，并告诉它监听本地主机上的端口5000</li></ul><h2 id="50a1" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">4.2创建路线和处理请求</h2><p id="819d" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">现在我们的服务器已经启动并运行了，是时候将请求传递给我们在第41行到第46行定义的路由了。下面我将展示一个处理路由的例子。我已经以完全相同的方式实现了其他路线；你可以在<a class="ae ky" href="https://github.com/mike-huls/BeerSnobV3" rel="noopener ugc nofollow" target="_blank">找到我们的知识库</a>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="f934" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码中，您可以看到ORM在处理路由时是如何工作的。让我们走完第一条路线(11号线至39号线)。</p><ul class=""><li id="a0b9" class="nr ns it lb b lc ld lf lg li nt lm nu lq nv lu nw nx ny nz bi translated">第11行:我们定义路线。<code class="fe of og oh oi b">/search</code>在我们的例子中是指<code class="fe of og oh oi b">localhost:5000/api/beers/search</code></li><li id="06b4" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated">第14行:我们从url获取数据。req.query检索url参数(T2中的粗体部分)。我们将参数q的值存储在一个变量中，这个变量也称为q(用于查询)。在url <code class="fe of og oh oi b">localhost:5000/api/beers/search?q=ale</code>中，键q的值是‘ale’。</li><li id="6c64" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated">第20行:如果q太短，什么也不做</li><li id="f59e" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated">第23行到第30行:返回所有包含q的啤酒(不区分大小写)</li><li id="01d7" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated">第33行res.retun是我们的API返回的内容。它将返回一个只有一个键的对象:“beers”和我们在数据库中找到的所有啤酒的数组。我们返回状态代码200(成功)。</li><li id="4029" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated">第36行:如果try-block中有任何错误，我们通过返回一个错误让客户端知道(我们使用<a class="ae ky" href="https://github.com/Muls/BeerSnobV3/blob/main/services/errorService.js" rel="noopener ugc nofollow" target="_blank"> errorService </a>来完成这个任务)。</li></ul><p id="7503" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，我们不必自己编写一行SQL我们可以调用模型来翻译我们的请求并与我们的数据库通信。这不仅很方便，还能防止SQL注入。</p><h1 id="4cb0" class="nb lw it bd lx nc nm ne ma nf nn nh md jz no ka mg kc np kd mj kf nq kg mm nl bi translated">5.测试我们的路线</h1><p id="ed76" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">让我们测试我们的啤酒路线！在啤酒行业，有三条不同的道路:</p><ol class=""><li id="ea4d" class="nr ns it lb b lc ld lf lg li nt lm nu lq nv lu ov nx ny nz bi translated">这条路线使用我们的ORM来查询Beers表。你可以通过一个搜索词(q)像<code class="fe of og oh oi b">localhost:5000/api/beers/search?q=heine</code>。然后它会寻找类似q的啤酒。</li><li id="79eb" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu ov nx ny nz bi translated">一个GET for / <br/>这个路由使用可选的查询参数Id，如果提供了Id，就尝试查找记录。否则它返回所有啤酒。尝试<code class="fe of og oh oi b">localhost:5000/api/beers</code>或<code class="fe of og oh oi b">localhost:5000/api/beers?id=1</code></li><li id="5853" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu ov nx ny nz bi translated">一个用于/ <br/>的POST此路由接受一个它将在第72行(req.body)上捕获的主体。试着将下面的json发布到<code class="fe of og oh oi b">localhost:5000/api/beers</code>，你会看到数据库中出现一条新记录。</li></ol><pre class="kj kk kl km gt om oi on oo aw op bi"><span id="24fe" class="lv lw it oi b gy oq or l os ot">{<br/>    "Name": "Bud Light",<br/>    "Type": "Beer flavored water"<br/>}</span></pre></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ow"><img src="../Images/4202b037b38e4286090159bffe7df022.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UhCZTY1TKWVAZcpY2XUSPg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">这是一篇相当长的文章:这只可爱的小狗是我们应得的(图片由<a class="ae ky" href="https://unsplash.com/@oddityandgrace" rel="noopener ugc nofollow" target="_blank"> Hannah Grace </a>在<a class="ae ky" href="https://unsplash.com/photos/fk4tiMlDFF0" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上提供)</p></figure><h1 id="1ccb" class="nb lw it bd lx nc nm ne ma nf nn nh md jz no ka mg kc np kd mj kf nq kg mm nl bi translated">结论</h1><p id="7b70" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">这个API为我们的应用程序提供了一些不错的基本功能！使用我们的ORM，我们现在能够使用我们的API来搜索、获取和创建国家、城市、地点、啤酒、用户和报告。在下一部分中，我们将进一步充实我们的API:</p><ul class=""><li id="89f7" class="nr ns it lb b lc ld lf lg li nt lm nu lq nv lu nw nx ny nz bi translated">我们将添加更深入的关联(<em class="mt">返回用户X提交的所有啤酒</em>或<em class="mt">返回访问过场所X并报告了啤酒Y的所有用户</em>)。</li><li id="6829" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated">实现更多的功能，例如:用户想要更新他们的密码</li><li id="fa4f" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated">我们会增加安全措施。我只能编辑自己的密码，不能编辑别人的。</li></ul><p id="0814" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一篇很长的文章；我希望你到这里为止，我的解释够清楚了。如果不是，请让我知道我可以在哪里提高自己。<a class="ae ky" href="https://mikehuls.medium.com/" rel="noopener">关注我</a>敬请关注！</p><p id="5c62" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">—迈克</p></div></div>    
</body>
</html>