<html>
<head>
<title>R is Slow — and It’s Your Fault!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">r慢——都是你的错！</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/r-is-slow-and-its-your-fault-2fcedacc7abb?source=collection_archive---------13-----------------------#2021-06-28">https://towardsdatascience.com/r-is-slow-and-its-your-fault-2fcedacc7abb?source=collection_archive---------13-----------------------#2021-06-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="ab90" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">教程| R |优化代码</h2><div class=""/><div class=""><h2 id="f9a7" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">了解您的工具对您的成功至关重要</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/43c6196448b0fc63c45b996cef395ab1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Y96LuuL2X7hQBFDj"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">由<a class="ae lh" href="https://unsplash.com/@lucambro?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">卢卡·安布罗西</a>在<a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</p></figure><p id="5360" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">任何在数据科学领域工作的人都熟悉R。您肯定遇到过有人认为R是一种缓慢的语言，无法处理更大的数据。事实并非总是如此。我在野外看到的许多R代码表明，对这种语言的工作原理缺乏基本的理解。让我们看一个例子，如何优化你的代码来与你合作，而不是与你作对。</p><div class="me mf gp gr mg mh"><a href="https://realdrewdata.medium.com/membership" rel="noopener follow" target="_blank"><div class="mi ab fo"><div class="mj ab mk cl cj ml"><h2 class="bd jd gy z fp mm fr fs mn fu fw jc bi translated">通过我的推荐链接加入Medium-Drew Seewald</h2><div class="mo l"><h3 class="bd b gy z fp mm fr fs mn fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="mp l"><p class="bd b dl z fp mm fr fs mn fu fw dk translated">realdrewdata.medium.com</p></div></div><div class="mq l"><div class="mr l ms mt mu mq mv lb mh"/></div></div></a></div></div><div class="ab cl mw mx hx my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="im in io ip iq"><h1 id="61a3" class="nd ne it bd nf ng nh ni nj nk nl nm nn ki no kj np kl nq km nr ko ns kp nt nu bi translated">为什么循环很慢？</h1><p id="7e25" class="pw-post-body-paragraph li lj it lk b ll nv kd ln lo nw kg lq lr nx lt lu lv ny lx ly lz nz mb mc md im bi translated">让我们从R编程语言是如何工作的开始。这就是所谓的<a class="ae lh" href="https://www.geeksforgeeks.org/difference-between-compiled-and-interpreted-language/" rel="noopener ugc nofollow" target="_blank">解释语言</a>。这意味着在运行代码之前你不需要编译任何东西，计算机只是解释并运行它，给你结果。这有助于加快您编写和测试代码的速度，但缺点是通常执行起来较慢。在处理过程中有很多开销，因为R几乎每次查看变量时都需要检查变量的类型。这使得改变类型和重用变量名变得容易，但是对于非常重复的任务，例如在循环中执行一个动作，会降低计算速度。</p><p id="aa35" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">让我们以一个简单的编程问题为例:找出给定数字的所有<a class="ae lh" href="https://www.cuemath.com/numbers/factors/" rel="noopener ugc nofollow" target="_blank">因子</a>。为此，我们可以查看从1开始一直到给定数字的每个数字，包括给定数字。如果我们的数字是2048，这将是从1到2048的所有数字。我们将2048年除以这些可能的因素。如果余数是0，则该数是一个因子。</p><p id="fa12" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">对于初学编程的人来说，用For循环可以很容易地解决这个问题。我们将2048赋给一个变量<code class="fe oa ob oc od b">x</code>。然后我们可以创建一个空白向量来存储找到的因子。</p><pre class="ks kt ku kv gt oe od of og aw oh bi"><span id="485d" class="oi ne it od b gy oj ok l ol om">x &lt;- 2048</span><span id="9f17" class="oi ne it od b gy on ok l ol om">factors &lt;- c()</span></pre><p id="4821" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在是for循环。我们从1到<code class="fe oa ob oc od b">x</code>。在for循环中，我们将创建一个if语句。if语句的条件将是<code class="fe oa ob oc od b">x</code>模(<code class="fe oa ob oc od b">%%</code> ) <code class="fe oa ob oc od b">i</code>等于0。模运算将给出每个数除以<code class="fe oa ob oc od b">x</code>的余数。当这个值为0时，我们将执行下一行，将<code class="fe oa ob oc od b">i</code>的值添加到我们的因子向量中。</p><pre class="ks kt ku kv gt oe od of og aw oh bi"><span id="4c12" class="oi ne it od b gy oj ok l ol om">for (i in 1:x) {<br/>    if (x %% i == 0) {<br/>        factors &lt;- c(factors, i)<br/>    }<br/>}</span></pre><p id="9029" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这种方法没有任何问题。在一台相当标准的计算机上运行它根本不需要任何时间。您也将在因子向量中获得正确的值。那么这种方法有什么问题呢？</p><p id="11c3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">当R使用循环时，它必须在每次循环运行时检查<code class="fe oa ob oc od b">x</code>和<code class="fe oa ob oc od b">i</code>的值。在我们看来，很明显这些总是数字，但是R仍然需要每次都检查。当你想找出一个更大的数字的因数时，比如2，048，000，这就成了一个问题。在我的电脑上，同样的循环用了大约26(！)秒求2，048，000的所有因子。</p><p id="0176" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果你想在你的机器上运行它，使用<code class="fe oa ob oc od b">rbenchmark</code>包。使用<code class="fe oa ob oc od b">benchmark</code>函数，给你的代码起一个名字，比如Loop。将该名称设置为我们的循环，您将在输出的elapsed部分获得您的执行时间。请注意，代码运行了多次，运行时间是所有运行的累计时间。</p><pre class="ks kt ku kv gt oe od of og aw oh bi"><span id="4485" class="oi ne it od b gy oj ok l ol om">library(rbenchmark)</span><span id="461b" class="oi ne it od b gy on ok l ol om">benchmark(<br/>    "Loop" = {<br/>        loop_factors &lt;- c(1)<br/>        for (i in 2:x) {<br/>            if (x %% i == 0) {<br/>                loop_factors &lt;- c(loop_factors, i)<br/>            }<br/>        }<br/>    }<br/>)</span><span id="857d" class="oi ne it od b gy on ok l ol om"># Output<br/># test replications elapsed relative user.self sys.self user.child<br/># Loop          100    27.5        1     27.44        0         NA<br/># Sys.child<br/>#        NA</span></pre></div><div class="ab cl mw mx hx my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="im in io ip iq"><h1 id="1489" class="nd ne it bd nf ng nh ni nj nk nl nm nn ki no kj np kl nq km nr ko ns kp nt nu bi translated">还有另一种方法</h1><p id="24fc" class="pw-post-body-paragraph li lj it lk b ll nv kd ln lo nw kg lq lr nx lt lu lv ny lx ly lz nz mb mc md im bi translated">现在我知道你在说什么了，用python(或者另一种更快的语言)！但是如果你知道它是如何工作的，没有理由R不能更快地处理这个任务。我们需要做的就是消除每次循环时检查每个变量类型的开销。大概是这样的:</p><pre class="ks kt ku kv gt oe od of og aw oh bi"><span id="11c0" class="oi ne it od b gy oj ok l ol om">factors &lt;- (1:x)[(x %% 1:x) == 0]</span></pre><p id="1967" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">好了，问题解决了！运行速度快了7到8倍，并且给出了相同的正确答案。但这都是为了理解为什么我喜欢代码是可读的，所以当我们重写这个优化的语句时，让我们更深入一点。</p><p id="8245" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">首先，我们已经确定了R花很长时间运行循环的部分原因是因为它在每次循环时都要检查变量的类型。幸运的是，R被设计成利用向量来避免这种情况。要求向量的每个元素都具有相同的类型，所以R在计算时不需要检查每个元素。因此，为了优化，我们将使用矢量化运算。</p><div class="me mf gp gr mg mh"><a rel="noopener follow" target="_blank" href="/storing-data-r-data-structures-717245c6bab8"><div class="mi ab fo"><div class="mj ab mk cl cj ml"><h2 class="bd jd gy z fp mm fr fs mn fu fw jc bi translated">存储数据:R数据结构</h2><div class="mo l"><h3 class="bd b gy z fp mm fr fs mn fu fw dk translated">存放数据科学剩余产品的容器</h3></div><div class="mp l"><p class="bd b dl z fp mm fr fs mn fu fw dk translated">towardsdatascience.com</p></div></div><div class="mq l"><div class="oo l ms mt mu mq mv lb mh"/></div></div></a></div><p id="b01c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">首先，我们将得到我们的数<code class="fe oa ob oc od b">x</code>，并使用模运算符(<code class="fe oa ob oc od b">%%</code>)来得到除以从1到<code class="fe oa ob oc od b">x</code>的每个数时的每个余数。我们可以使用<code class="fe oa ob oc od b">1:x</code>来创建从1到<code class="fe oa ob oc od b">x</code>的所有数字的向量。当我们用一个数字向量对单个元素<code class="fe oa ob oc od b">x</code>取模时，R用向量的每个元素除<code class="fe oa ob oc od b">x</code>，返回余数的向量。</p><pre class="ks kt ku kv gt oe od of og aw oh bi"><span id="af17" class="oi ne it od b gy oj ok l ol om">remainders &lt;- x %% 1:x</span></pre><p id="e0eb" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">接下来，我们要测试哪些余数是0。类似于余数运算的工作方式，我们可以将整个<code class="fe oa ob oc od b">remainders</code>向量与0进行比较。这将返回一个向量<code class="fe oa ob oc od b">TRUE</code> / <code class="fe oa ob oc od b">FALSE</code>，其中<code class="fe oa ob oc od b">TRUE</code>表示余数为0。</p><pre class="ks kt ku kv gt oe od of og aw oh bi"><span id="fe11" class="oi ne it od b gy oj ok l ol om">true_false &lt;- remainders == 0</span></pre><p id="063f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在，我们可以使用<code class="fe oa ob oc od b">true_false</code>向量来过滤我们可能的数字，1到<code class="fe oa ob oc od b">x</code>，给出我们最终的答案。</p><pre class="ks kt ku kv gt oe od of og aw oh bi"><span id="a4d3" class="oi ne it od b gy oj ok l ol om">(1:x)[true_false]</span></pre></div><div class="ab cl mw mx hx my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="im in io ip iq"><h1 id="5baa" class="nd ne it bd nf ng nh ni nj nk nl nm nn ki no kj np kl nq km nr ko ns kp nt nu bi translated">让我们飙车吧</h1><p id="bef2" class="pw-post-body-paragraph li lj it lk b ll nv kd ln lo nw kg lq lr nx lt lu lv ny lx ly lz nz mb mc md im bi translated">让我们再次检查我们的计算速度，比较所有三个版本:for循环版本、单行向量优化版本和可读向量优化版本。我将再次使用<code class="fe oa ob oc od b">benchmark</code>函数，这次添加一个向量和向量可读。<code class="fe oa ob oc od b">x</code>再次设置为2，048，000。</p><pre class="ks kt ku kv gt oe od of og aw oh bi"><span id="5c97" class="oi ne it od b gy oj ok l ol om">benchmark(<br/>    "Loop" = {<br/>        loop_factors &lt;- c(1)<br/>        for (i in 2:x) {<br/>            if (x %% i == 0) {<br/>                loop_factors &lt;- c(loop_factors, i)<br/>            }<br/>        }<br/>    },<br/>    "Vector" = {<br/>        loop_factors &lt;- (1:x)[(x %% 1:x) == 0]<br/>    },<br/>    "Vector Readable" = {<br/>        remainders &lt;- x %% 1:x<br/>        true_false &lt;- remainders == 0<br/>        loop_factors &lt;- (1:x)[true_false]<br/>    }<br/>)</span><span id="572d" class="oi ne it od b gy on ok l ol om"># Output<br/>#              test replications elapsed relative user.self sys.self<br/># 1            Loop          100   27.52    7.519     27.38     0.00<br/># 2          Vector          100    3.66    1.000      2.99    0.66<br/># 3 Vector Readable          100    3.77    1.030      3.24    0.50<br/>#<br/>#   user.child sys.child<br/># 1         NA        NA<br/># 2         NA        NA<br/># 3         NA        NA</span></pre><p id="5fca" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在输出中，运行最快的代码的相对值为1。每隔一个片段将显示相对于最快的片段所用的时间的多少倍。在我的例子中，单行版本比可读版本稍快。这很可能是因为我们存储了步骤之间的输出，使其更具可读性。您还可以看到，for循环比vector版本慢7.5倍。向量确实有助于优化你的代码！</p><p id="2164" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">太棒了。r用向量做任何事都快得多，对吗？嗯，R还是有一些限制的。虽然使用向量可以大大加快计算速度，但R仍然在内存中完成大部分计算。所以一旦我们达到足够大的数字，R将无法分配计算所需大小的向量，比如2，048，000，000。事情是这样的:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi op"><img src="../Images/6f961542994f48801ed51c11351bc023.png" data-original-src="https://miro.medium.com/v2/resize:fit:1202/format:webp/1*G3Ix9fROkpGazMr9_gH5YQ.png"/></div></figure></div><div class="ab cl mw mx hx my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="im in io ip iq"><h1 id="aabb" class="nd ne it bd nf ng nh ni nj nk nl nm nn ki no kj np kl nq km nr ko ns kp nt nu bi translated">结论</h1><p id="ab65" class="pw-post-body-paragraph li lj it lk b ll nv kd ln lo nw kg lq lr nx lt lu lv ny lx ly lz nz mb mc md im bi translated">所以最后，了解你的工具是很重要的。r是一种非常容易掌握的语言。学习一些技巧，比如利用向量，可以加快计算速度，并有助于保持R在工具箱中的相关性。你还需要知道你的工具的局限性。学习用向量优化你的代码是有用的，但是一旦你遇到一定规模的数据和计算，你可能要开始寻找一种新的语言。</p></div></div>    
</body>
</html>