<html>
<head>
<title>SVM Talking maths: Formulating Support Vector Machine as a Quadratic Programming problem</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SVM谈数学:将支持向量机公式化为二次规划问题</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/svm-talking-maths-formulating-support-vector-machine-as-a-quadratic-programming-problem-ab5d30a8d73e?source=collection_archive---------28-----------------------#2021-10-07">https://towardsdatascience.com/svm-talking-maths-formulating-support-vector-machine-as-a-quadratic-programming-problem-ab5d30a8d73e?source=collection_archive---------28-----------------------#2021-10-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="9763" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated"><strong class="ak">从分离超平面的想法到最终的二次规划分4步</strong></h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/bcf4831bdaef580f7fee9a3f28a9bd1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*zU5XcxCMLm81mwkN660V9A.gif"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者GIF</p></figure><p id="b170" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">上周，我们<a class="ae lr" href="https://medium.com/@marialavrovskaya/svm-talking-maths-quadratic-programming-and-cholesky-factorisation-968a493db10b" rel="noopener">介绍了</a>约束优化，但没有给你任何提示，说明这如何有助于在数值上解决支持向量机问题。这一次我们将通过把支持向量机公式化为QP问题来把一切放入上下文中！</p><p id="d18d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在这篇文章中，我们引入了卡鲁克-库恩-塔克特(KKT)条件，将支持向量机问题公式化为一个凸优化问题，并引入了几个变换，使其更便于数值求解！</p><p id="2540" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="ls">让我们直入主题吧。</em></p><h1 id="aa4c" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">这些KKT条件是什么，我们为什么要关心？</h1><p id="b3e2" class="pw-post-body-paragraph kv kw iq kx b ky ml jr la lb mm ju ld le mn lg lh li mo lk ll lm mp lo lp lq ij bi translated">简单地说，KKT条件是一阶导数<strong class="kx ir">测试</strong>，它允许我们检查是否<strong class="kx ir">确实</strong>达到了最优解<strong class="kx ir">。</strong>我们记得，假设目标函数、不等式和等式约束是可微的，我们的拉格朗日函数具有以下形式</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/91187a60d5c62be3f7d4063fc6389bf2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1114/0*Re5ARW1HkGbYbQqB"/></div></figure><p id="f6e8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">其中x*是最优解。因此，我们有以下KKT条件</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/5be34e159c7fc201b1516639f3064b71.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/0*E-fN2An__I4rWxIH"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">KKT条件</p></figure><p id="fca3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">所有这些符号对你来说都有意义吗？如果没有，让我知道我会提供更多的解释！</p><p id="4ebc" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">这里有好消息！😃</strong>如果我们假设目标是凸的，这些条件就变得必要和充分。换句话说，我们保证<em class="ls"> x*，lambda* </em>和<em class="ls"> nu* </em>是原始的和对偶最优的<strong class="kx ir">，对偶间隙</strong>为零。还记得<a class="ae lr" href="https://medium.com/@marialavrovskaya/svm-talking-maths-quadratic-programming-and-cholesky-factorisation-968a493db10b" rel="noopener">是什么意思</a>吗？</p></div><div class="ab cl ms mt hu mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="ij ik il im in"><p id="0973" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">所以现在，我们完全准备好了！我们有我们的拉格朗日和KKT条件，我们应该如何制定SVM作为一个约束优化问题？</p><h1 id="8786" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">作为二次规划问题的支持向量机</h1><p id="6029" class="pw-post-body-paragraph kv kw iq kx b ky ml jr la lb mm ju ld le mn lg lh li mo lk ll lm mp lo lp lq ij bi translated">我们记得，支持向量机本质上是寻找一个最优超平面，其中“支持向量”是超平面的位置和边缘的宽度。</p><h2 id="adf2" class="mz lu iq bd lv na nb dn lz nc nd dp md le ne nf mf li ng nh mh lm ni nj mj nk bi translated">分离超平面的思想</h2><p id="d282" class="pw-post-body-paragraph kv kw iq kx b ky ml jr la lb mm ju ld le mn lg lh li mo lk ll lm mp lo lp lq ij bi translated">如果我们在一个<em class="ls"> p- </em>维空间中有向量<em class="ls"> x </em>，超平面或仿射集<em class="ls"> L </em>由以下等式定义</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/2c98f8e16a8eaa47a8bb2d6fb428402f.png" data-original-src="https://miro.medium.com/v2/resize:fit:852/0*pV31Uk8wAEVjJyJ5"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">分离超平面</p></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nm"><img src="../Images/9f629e4fa3c86dd14fb475d16e8ebb9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-Amy_BnbY4AQ7sYIDBpVKQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片作者。灵感来源于[1]</p></figure><p id="0513" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">那才是你心目中应该有的画面(<em class="ls">抱歉画的乱七八糟</em>)。<strong class="kx ir">大主意！</strong>🙂这些<em class="ls">贝塔</em>是控制线方向的——因此，我们希望通过最小化<em class="ls">贝塔</em>找到最佳分离！</p><p id="b6b2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们现在列出一些重要的属性:</p><ol class=""><li id="24cb" class="nn no iq kx b ky kz lb lc le np li nq lm nr lq ns nt nu nv bi translated">对于位于<em class="ls"> L，</em>中的任意两点x1和x2，我们有</li></ol><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/42d48ca40d2df4b8959062930e03167a.png" data-original-src="https://miro.medium.com/v2/resize:fit:354/0*6-0F5JeVXhV6y1vQ"/></div></figure><p id="0904" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因此，我们可以构造曲面l的法向量<em class="ls"> B* </em>。因为我们在2D，我们有一条线而不是曲面。<em class="ls">我们记得矢量法线是在给定点垂直于表面的矢量。</em></p><p id="cd07" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">2.对于<em class="ls"> L，</em>中的任意给定点<em class="ls"> x_0 </em>，我们有</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/f3100e4c0329e2c6e524cb1355605665.png" data-original-src="https://miro.medium.com/v2/resize:fit:268/0*Xzy0hAJg71J7_r1J"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">直接从上面分离超平面的定义</p></figure><p id="67d6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">3.从<em class="ls"> x </em>的任意点到<em class="ls"> L </em>的<strong class="kx ir">符号</strong>距离由下式给出。<em class="ls">我注意到，我们在最终表达式的分母中有一个导数，因为对目标求一阶导数，我们将只剩下β。</em></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/e5839cd2a84e8dd805f6af7068a1fa49.png" data-original-src="https://miro.medium.com/v2/resize:fit:982/0*53yP-zwKflMUbY2j"/></div></figure><h2 id="8e9c" class="mz lu iq bd lv na nb dn lz nc nd dp md le ne nf mf li ng nh mh lm ni nj mj nk bi translated">步骤1——制定一个优化问题。</h2><p id="be11" class="pw-post-body-paragraph kv kw iq kx b ky ml jr la lb mm ju ld le mn lg lh li mo lk ll lm mp lo lp lq ij bi translated">目标是通过<strong class="kx ir">最大化到任一类中最近点的距离，找到分隔数据点的超平面。</strong>如果M是一个带符号的距离，<strong class="kx ir"> </strong>那么我们有如下优化问题</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/6fabe870e19ab0c56f3e922b7382edcc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1004/0*44f5AuXU0F1q_uYy"/></div></figure><p id="0ffa" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">以下不等式条件确保所有点距离由<em class="ls">βas</em>定义的决策边界至少有符号距离<em class="ls"> M </em>。</p><h2 id="d6fb" class="mz lu iq bd lv na nb dn lz nc nd dp md le ne nf mf li ng nh mh lm ni nj mj nk bi translated">第二步——再想想！为方便起见重新表述。</h2><p id="8931" class="pw-post-body-paragraph kv kw iq kx b ky ml jr la lb mm ju ld le mn lg lh li mo lk ll lm mp lo lp lq ij bi translated">现在仔细观察，我们应该对上述优化公式<strong class="kx ir">进行三个重要的调整，以解决分类错误</strong>和<strong class="kx ir">的问题，从而使数值求解</strong>稍微容易一些。我们引入了以下变化:</p><ol class=""><li id="f028" class="nn no iq kx b ky kz lb lc le np li nq lm nr lq ns nt nu nv bi translated">任意设置</li></ol><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/d4bb80c58fb3b52ef31a1f158fe68142.png" data-original-src="https://miro.medium.com/v2/resize:fit:206/0*8akisre68ec8-UJ_"/></div></figure><p id="cf7f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这允许我们以这样一种方式重写最初的问题，在将来我们将最小化平方范数，这样做纯粹是为了方便。</p><p id="b6a9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">2.现实世界的问题通常是<strong class="kx ir">不可分的</strong>，因为它总是包括一些在未来空间重叠的观察。这叫做<strong class="kx ir">软余量</strong>。因此，我们需要允许一些点位于边缘的错误一侧。数学上，我们引入<strong class="kx ir">松弛变量</strong> <em class="ls"> ( </em>字母<em class="ls"> xi) </em> <strong class="kx ir">，</strong>其总和不应超过指定的值<em class="ls"> C </em></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/68ce43efd21973e754584c3ab621a5eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/0*MemkV-UXw8yiazng"/></div></figure><p id="2fb5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">该约束以这样的方式公式化，以表达预测<em class="ls">f(x _ I)</em>在其余量的错误侧的比例量。</p><p id="52a4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们现在有以下优化问题。<em class="ls">我们注意到，在平方范数完成之前引入1/2纯粹是为了方便——回想一下，一旦我们求一阶导数，2的幂将下降，因此1/2将抵消它。此外，我们将边界约束重写为“正则化”项，这本质上与我们惩罚错误分类是一回事！</em></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/78671115ad0c6e6c7d5c6a1277ca6de2.png" data-original-src="https://miro.medium.com/v2/resize:fit:956/0*lMKmyCbx0cuNWNqe"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">重写优化问题</p></figure><h2 id="ef96" class="mz lu iq bd lv na nb dn lz nc nd dp md le ne nf mf li ng nh mh lm ni nj mj nk bi translated">第三步——写拉格朗日(我们快到了)。</h2><p id="d79f" class="pw-post-body-paragraph kv kw iq kx b ky ml jr la lb mm ju ld le mn lg lh li mo lk ll lm mp lo lp lq ij bi translated">前面提到的给了我们约束优化问题，现在我们把所有东西放在一起得到拉格朗日！</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi od"><img src="../Images/0683143c5d9b2941a59b4940e0b9d6c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*HAFtRII07aDUYm6t"/></div></div></figure><p id="6989" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">所以我们的新目标是最小化贝塔的矢量、<em class="ls">贝塔_0 </em>、<em class="ls">阿尔法的矢量</em>和<em class="ls">Xi的矢量</em>。你能看出这些术语是从哪里来的吗？如果没有，让我知道，我会分解它。</p><p id="e32e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们还遗漏了什么？对！我们仍然需要应用我们的一阶导数测试(KKT条件)来看看我们试图找到的最优解是否是真正最优的。让我们现在把这些写下来。</p><p id="7c3f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们先介绍<strong class="kx ir">平稳性条件</strong>。这就好像我们试图确定一个函数导数为零的驻点。由于我们是针对β的<em class="ls">向量</em>、<em class="ls">β_ 0</em>、<em class="ls">α、</em>和<em class="ls">Xi的向量进行优化。</em>我们需要确保这三个都通过这些静态测试！因此，我们写道</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oe"><img src="../Images/ecdb371d2def54b743bcf76134da046d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_34pxf-hLfRDH_i5"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">平稳条件</p></figure><p id="c1e0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">从问题的原始形式，我们有所谓的原始可行性条件。<em class="ls">可行性简单来说就是我们的最优点位于满足约束的可能区域！</em></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi of"><img src="../Images/75cc52f3c9e0cd2be39acf48786c67af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1070/0*TGiwH9DE77uOOP8T"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">最初的可行性约束</p></figure><p id="b379" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">更进一步，我们有乘数条件！因为这两个是直接来自KKT的条件。我们有一个等式约束的乘数和一个不等式约束的乘数。因此，我们写道</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi og"><img src="../Images/c105bd105bbbcd964af166997df57b86.png" data-original-src="https://miro.medium.com/v2/resize:fit:692/0*PzHU0dQHaJeN3ybH"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">拉格朗日乘数条件</p></figure><p id="e599" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">最后但同样重要的是，我们有互补的松弛条件。引入这些约束是因为我们有<strong class="kx ir">零对偶间隙</strong>，因此它们保证了原始和对偶的值是相同的！你可以在这里阅读更多关于这些条件是如何获得的<a class="ae lr" href="http://www.gatsby.ucl.ac.uk/~gretton/coursefiles/Slides5A.pdf" rel="noopener ugc nofollow" target="_blank">。</a></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/d6aba335d2e1919158022c9eb3f40198.png" data-original-src="https://miro.medium.com/v2/resize:fit:1330/0*qjwUuI529gF3SihF"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">互补松弛条件</p></figure><h2 id="010c" class="mz lu iq bd lv na nb dn lz nc nd dp md le ne nf mf li ng nh mh lm ni nj mj nk bi translated">第四步——拉格朗日看起来有点吓人。我们来写对偶形式吧！</h2><p id="6b28" class="pw-post-body-paragraph kv kw iq kx b ky ml jr la lb mm ju ld le mn lg lh li mo lk ll lm mp lo lp lq ij bi translated">我们的拉格朗日看起来很吓人我们也有9(！)要考虑的约束。我们已经知道我们有一个凸问题，因此我们可以找到全局最优解，即使我们通过写对偶形式来处理这个问题。</p><p id="2aa5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们试着把我们的原始问题转换成对偶形式。我们使用前三个平稳性条件，并将它们代入拉格朗日方程。我们写作</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oi"><img src="../Images/f3e2d01b51c6adf1520a7dac558eb1d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*AJxTHfmlNhCKZ20H"/></div></div></figure><p id="9dd2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">总而言之，我们有以下问题</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/deb14293a13dcf9950019eea8df921ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1118/0*teAMhopLohZzb1zq"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">最终二次规划问题！</p></figure><p id="ab81" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这比我们之前见过的拉格朗日简单多了。它也更加灵活，因为我们引入了允许错误分类的松弛变量！</p><p id="55d0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">仔细看这个表情。它让你想起了什么？完全正确，它具有二次规划的形式！</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/ed9b9f5d4c923726241fd81e54c0c6e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1044/0*wXO9CFghnp6wqbD4"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">二次问题的标准形式</p></figure><p id="02f6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这意味着现在我们可以应用QP方法来数值解决这个问题🚀</p><h2 id="3fad" class="mz lu iq bd lv na nb dn lz nc nd dp md le ne nf mf li ng nh mh lm ni nj mj nk bi translated">最好的事情——来了一个内核函数！</h2><p id="bedd" class="pw-post-body-paragraph kv kw iq kx b ky ml jr la lb mm ju ld le mn lg lh li mo lk ll lm mp lo lp lq ij bi translated">关于对偶形式最好的事情之一是数据(我们的<em class="ls"> x </em>)以点积的形式出现。这意味着我们可以事先对我们的数据应用任何类型的转换！这非常方便，因为几乎没有真正的数据集可以线性分离！</p><p id="42d3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">参考文献:</strong></p><p id="6148" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">[1] T. et。全部。哈斯蒂，“统计中的斯普林格系列统计学习的要素”，<em class="ls">数学。智能。</em>，2009年第27卷第2期，第83–85页【在线】。可用:<a class="ae lr" href="http://www.springerlink.com/index/D7X7KX6772HQ2135.pdf." rel="noopener ugc nofollow" target="_blank">http://www.springerlink.com/index/D7X7KX6772HQ2135.pdf.</a></p></div></div>    
</body>
</html>