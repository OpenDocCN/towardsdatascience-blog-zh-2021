<html>
<head>
<title>A Simple And Intuitive Guide to Regular Expressions in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python正则表达式的简单直观指南</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/a-simple-and-intuitive-guide-to-regular-expressions-404b057b1081?source=collection_archive---------14-----------------------#2021-04-14">https://towardsdatascience.com/a-simple-and-intuitive-guide-to-regular-expressions-404b057b1081?source=collection_archive---------14-----------------------#2021-04-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="dfca" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用Python轻松地从任何文本中提取信息。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/394b74fef0567d772b9e8ca19567b2f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*fKBsceH94Fh44O8q"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Max Kleinen 在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的<a class="ae ky" href="https://unsplash.com/@hirmin?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">照片</a></p></figure><p id="92f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您曾经在Python中处理过文本数据，您会知道大多数时候您必须处理脏数据。这意味着您正在寻找的特定文本(姓名、日期、电子邮件等)需要提取出来才能使用。</p><p id="4ee2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这时正则表达式(regex)就派上用场了。由于它的语法，你将能够找到你想要提取的模式，并节省大量时间。</p><p id="e650" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管正则表达式看起来令人生畏，但乍一看，我为本文中将要看到的所有正则表达式创建了一些动画图像，因此您可以很容易地理解它们背后的概念。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="4da3" class="ma mb it lw b gy mc md l me mf"><strong class="lw iu">Table of Contents<br/></strong>1. <a class="ae ky" href="#9216" rel="noopener ugc nofollow">The re module (re.match, re.findall)</a><br/>2. <a class="ae ky" href="#39c1" rel="noopener ugc nofollow">^ and $ symbols</a><br/>3. <a class="ae ky" href="#8860" rel="noopener ugc nofollow">Metacharacters (., \w, \d, \s)</a><br/>4. <a class="ae ky" href="#35eb" rel="noopener ugc nofollow">Quantifiers (*, +, ?, {, })</a><br/>5. <a class="ae ky" href="#5791" rel="noopener ugc nofollow">Group and capture with ( )</a><br/>6. <a class="ae ky" href="#bf4d" rel="noopener ugc nofollow">Match an expression with [ ]</a><br/>7. <a class="ae ky" href="#1426" rel="noopener ugc nofollow">Or</a><br/>8. <a class="ae ky" href="#a5b1" rel="noopener ugc nofollow">Boundaries (\b)</a><br/>9. <a class="ae ky" href="#5fc6" rel="noopener ugc nofollow">Back-references (e.g. \1</a>)<br/>10. <a class="ae ky" href="#7c1c" rel="noopener ugc nofollow">Flags</a><br/>11. <a class="ae ky" href="#d2a9" rel="noopener ugc nofollow">Greedy and Lazy match</a><br/>12. <a class="ae ky" href="#7d2a" rel="noopener ugc nofollow">Common Use Cases</a><br/> - <a class="ae ky" href="#19ea" rel="noopener ugc nofollow">Match punctuation</a><br/> - <a class="ae ky" href="#f247" rel="noopener ugc nofollow">Valid date format</a><br/> - <a class="ae ky" href="#8c18" rel="noopener ugc nofollow">Valid email</a><br/> - <a class="ae ky" href="#9e48" rel="noopener ugc nofollow">Valid username</a></span></pre><h1 id="9216" class="mg mb it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">re模块(重新搜索，重新查找)</h1><p id="8d57" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">在本文中，我们将使用下面的文本来展示正则表达式是如何工作的。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="e9ce" class="ma mb it lw b gy mc md l me mf">text = '''<br/>Hello World<br/>I love Python!!!!!<br/>My first lucky number is 987-654-321<br/>My second lucky number is 876-543-210<br/>My third lucky number is 765-432-100<br/>'''</span></pre><p id="1032" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将使用Python来解释一些额外的细节，然而，正则表达式语法对于大多数编程语言来说几乎是相同的。在Python中，我们需要导入以下内容来处理正则表达式。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="faa6" class="ma mb it lw b gy mc md l me mf">import<strong class="lw iu"> </strong>re</span></pre><p id="98ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了找到与正则表达式模式匹配的第一个匹配项和所有匹配项，我们使用下面的。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="8003" class="ma mb it lw b gy mc md l me mf">#return the first match<br/>re.search(pattern, text)</span><span id="a653" class="ma mb it lw b gy nc md l me mf"># return all the matches<br/>re.findall(pattern, text)</span></pre><p id="b7e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，为了主要关注学习正则表达式，<strong class="lb iu">我们将只检查正则表达式</strong> <code class="fe nd ne nf lw b"><strong class="lb iu">pattern</strong></code>以避免重复输入<code class="fe nd ne nf lw b">re.search, re.findall and text</code><code class="fe nd ne nf lw b">.</code></p><h1 id="39c1" class="mg mb it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">^和$符号</h1><p id="7dd7" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">这两个符号将分别匹配以指定字符开头或结尾的字符串。让我们看一个上面定义的<code class="fe nd ne nf lw b">text</code>变量的例子。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="885f" class="ma mb it lw b gy mc md l me mf"><strong class="lw iu">^Hello</strong>  matches any string that starts with Hello<strong class="lw iu"><br/>World$  </strong>matches a string that ends with World<strong class="lw iu"><br/>^Hello World$ </strong>matches a string that<strong class="lw iu"> </strong>starts and ends with Hello World (exact match)</span></pre><p id="30d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看上面列出的正则表达式。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/a6710fa5ac209eca0a238b79ad14fcf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:856/1*DcVGwazu3Ucf5QegTLJqQQ.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="67da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">中以蓝色突出显示的文本。上面的gif将是匹配的图案。</strong></p><p id="55f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在很清楚每个符号的作用了。请记住，如果文本是<code class="fe nd ne nf lw b">World Hello!</code>，那么前面的模式都不起作用。此外，在这个例子中，默认的regex标志被设置为multiline(我在下面的标志部分解释了regex中的标志)</p><h1 id="8860" class="mg mb it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">元字符(。，\w，\d，\s)</h1><p id="9e30" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">在正则表达式中，元字符被理解为具有特殊含义的字符，如下所示。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="734e" class="ma mb it lw b gy mc md l me mf"><strong class="lw iu">.</strong> matches any character except a new line<br/><strong class="lw iu">\d</strong> matches a digit<br/><strong class="lw iu">\w</strong> matches a word character (a-z, A-Z, 0-9, _)<br/><strong class="lw iu">\s</strong> matches a whitespace (space, tab, newline)</span></pre><p id="2f9d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们来验证一下它们各自的工作原理。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/ba863eb387592d067c04b39d6cd974ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:856/1*J7DSrnQq_38qMxOTs5Du_g.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="41fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">记住，上面提到的元字符也有它们的否定形式<code class="fe nd ne nf lw b">\D</code>、<code class="fe nd ne nf lw b">\W</code>和<code class="fe nd ne nf lw b">\S</code>。同样，为了转义这个和其他特殊字符<code class="fe nd ne nf lw b">^.[$()|*+?</code>，我们使用反斜杠<code class="fe nd ne nf lw b">\</code>。我在<code class="fe nd ne nf lw b">Hello World</code>的末尾加了点，看看这是如何工作的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/d57b0f43af836df91952ac4079676827.png" data-original-src="https://miro.medium.com/v2/resize:fit:856/1*bJnhWLJ-hjO1XqkDQZLjoQ.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="c690" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，当您包含反斜杠<code class="fe nd ne nf lw b">\.</code>时，<code class="fe nd ne nf lw b">. </code>并不匹配所有字符</p><h1 id="35eb" class="mg mb it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">量词(*、+、？, {, })</h1><p id="a0ce" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">量词将帮助我们找到一个重复“n”次的字符。我们来看看最基本的量词<code class="fe nd ne nf lw b">*+?</code></p><p id="554e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们想要匹配单词<code class="fe nd ne nf lw b">Python</code>后的感叹号<code class="fe nd ne nf lw b"><strong class="lb iu">!</strong></code> <strong class="lb iu"> </strong>的数量</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="f8f0" class="ma mb it lw b gy mc md l me mf">Python!<strong class="lw iu">*</strong>    matches a string that has Python followed by 0 or more <strong class="lw iu">!<br/></strong>Python!<strong class="lw iu">+</strong>    matches a string that has Python followed by 1 or more <strong class="lw iu">!<br/></strong>Python!<strong class="lw iu">?</strong>    matches a string that has Python followed by 0 or 1 <strong class="lw iu">!</strong></span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/b1caeffe21ffe06c76f95827ec953384.png" data-original-src="https://miro.medium.com/v2/resize:fit:856/1*EegznDWMWPP1RlIWV_JZDQ.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="a917" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下量词将让您指定重复的字符数。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="785e" class="ma mb it lw b gy mc md l me mf">Python!<strong class="lw iu">{2}</strong>  matches a string that has Python<strong class="lw iu"> </strong>followed<strong class="lw iu"> </strong>by 2<strong class="lw iu"> !<br/></strong>Python!<strong class="lw iu">{2,}</strong> matches a string that has Python<strong class="lw iu"> </strong>followed by 2 or more <strong class="lw iu">!<br/></strong>Python!<strong class="lw iu">{2,4}</strong>matches a string that has Python<strong class="lw iu"> </strong>followed by 2 up to 4<strong class="lw iu">!<br/></strong>Python<strong class="lw iu">(!!){2,4} </strong>matches a string that has Python<strong class="lw iu"> </strong>followed by 2 up to 4 copies of the sequence<strong class="lw iu"> !!</strong></span></pre><p id="bc0d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这可能看起来很可怕，但它比你想象的要简单。让我们来看看。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/7c76decd0f3355ea02f3d4ed1aeacfa7.png" data-original-src="https://miro.medium.com/v2/resize:fit:856/1*PLeJrkj3uvLgWcXqJqAxww.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="6e47" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后一个图案<code class="fe nd ne nf lw b">Python<strong class="lb iu">(!!){2,4}</strong></code> <strong class="lb iu"> </strong>也捕捉到了感叹号<code class="fe nd ne nf lw b">!!</code>，因为有括号。我们将在下一节中对此进行更多的检查。</p><h1 id="5791" class="mg mb it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">使用( )进行分组和采集</h1><p id="449b" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">要捕获模式中的特定字符组，只需添加括号<code class="fe nd ne nf lw b">()</code>。例如，正如我们到目前为止所看到的，模式<code class="fe nd ne nf lw b">\d+-\d+-\d+</code>将匹配由连字符分隔的数字，但是如果我们只想获得第一个连字符之前的数字组呢？</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="92c2" class="ma mb it lw b gy mc md l me mf">(\d+)-\d+-\d+  parentheses create a capturing group of the first group of digits before the hyphen -</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/a9b6a9a04ce6273f4aeb44efd5aa331d.png" data-original-src="https://miro.medium.com/v2/resize:fit:856/1*Yghe6IrsmdtTkrL4QvOahQ.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="812e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，当添加括号时，颜色变为绿色，这表示捕获的组。</p><p id="b7a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Python中，您可以使用<code class="fe nd ne nf lw b">re.findall()</code>来查找所有的事件并显示捕获的组。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="4c19" class="ma mb it lw b gy mc md l me mf">IN [0]: re.findall(r'(\d+)-\d+-\d+', text)<br/>OUT [0]: ['987', '876', '765']</span></pre><h1 id="bf4d" class="mg mb it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">用[ ]匹配表达式</h1><p id="b741" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">与圆括号不同，方括号<code class="fe nd ne nf lw b">[] </code>不捕捉表达式，只匹配表达式中的任何内容。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="37fe" class="ma mb it lw b gy mc md l me mf"><strong class="lw iu">[789]  </strong>matches a string that has 7, 8 or 9. It's like 7|8|9<strong class="lw iu"><br/>[7-9]  </strong>same as previous<br/><strong class="lw iu">[a-zA-Z]   </strong>a string that has a letter from a to z or from A to Z<strong class="lw iu"><br/>[^a-zA-Z]</strong>  a string that has not a letter from a to z or from A to Z. (the <strong class="lw iu">^ is used as negation</strong> of the expression when it's at the beginning inside brackets)</span></pre><p id="6a52" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">许多人被写在方括号内的模式吓到了，但是当你通过一个例子看到它是如何工作的时候，就不会那么困难了。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/cd80c158bbe41fbea0378afdbbb37a99.png" data-original-src="https://miro.medium.com/v2/resize:fit:856/1*gms77G4pKlZX8nRz3QsVfw.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="a017" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不管模式有多长，如果它在方括号内，你可以把它们分成“或”条件组。</p><p id="1cf7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">说到“或”条件，让我们回顾一下目前为止我们已经看到的。</p><h1 id="1426" class="mg mb it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">或者</h1><p id="7886" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">我们已经看到了在正则表达式中获得“或”条件的两种方法。第一种是使用括号，第二种是使用方括号。假设我们想要匹配数字8或9后面的2位数。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="c089" class="ma mb it lw b gy mc md l me mf">(9|8)\d{2}   matches a string that has 9 or 8 followed by 2 digits <em class="nh">(captures </em>9 or 8<em class="nh">)</em><strong class="lw iu"><br/></strong>[98]\d{2}<strong class="lw iu"> </strong>matches a string that has 9 or 8 followed by 2 digits without capturing 9 or 8</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/7a37cc80c0f7d89828c10e17f1692a74.png" data-original-src="https://miro.medium.com/v2/resize:fit:856/1*5QvLP7dz5vc4Bdz4ZfltLQ.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="3834" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可能还记得，这两者的主要区别是圆括号捕捉组，而方括号不捕捉组。此外，应该在括号中指定“or”<code class="fe nd ne nf lw b">|</code>,但是没有必要将它包含在方括号中。</p><h1 id="a5b1" class="mg mb it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">边界(\b)</h1><p id="9e05" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated"><code class="fe nd ne nf lw b">\b </code>符号是另一个元字符，它匹配单词字符(\w)和非单词字符(\W)之间的位置。这叫字界。让我们看看这个怎么样。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/789fb5329f9502f65a06e25032c62ae7.png" data-original-src="https://miro.medium.com/v2/resize:fit:856/1*5BBltI9n-oRx1o6uwKo4kA.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="4d8d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在图中，我们可以看到3个不同的位置符合“单词边界”的条件:</p><ol class=""><li id="1804" class="ni nj it lb b lc ld lf lg li nk lm nl lq nm lu nn no np nq bi translated">如果第一个字符是单词字符，则在字符串的第一个字符之前。</li><li id="b37a" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">在字符串的最后一个字符之后，如果最后一个字符是单词字符。</li><li id="7e80" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">字符串中的两个字符之间，其中一个是单词字符，另一个不是单词字符。</li></ol><p id="fa8f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们看看第2点只匹配右边的单词边界实际上意味着什么。为此，我们编写了表达式<code class="fe nd ne nf lw b">.\b</code></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/2faf772b55bea057a95576b4120637e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:856/1*VYvZF11bjZsIzoJTH0JRgw.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="d1eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nd ne nf lw b">\b </code>符号还有一个与<code class="fe nd ne nf lw b">\b</code>相反的否定<code class="fe nd ne nf lw b">\B </code></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/d8a10bb4e31fce4d00ce0799aa62ad48.png" data-original-src="https://miro.medium.com/v2/resize:fit:856/1*8Opt178SHleEtmnc6EBreQ.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><h1 id="5fc6" class="mg mb it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">反向引用(\1)</h1><p id="1d60" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">反向引用帮助我们重用已经识别的捕获组。为了更好地解释这一点，我将把下面的句子添加到我们之前定义的文本中。</p><p id="75f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nd ne nf lw b">“My fourth lucky number is 123–456–123–123–456”</code></p><p id="d45d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以我们的目标是找到重复性的<code class="fe nd ne nf lw b">123- </code>放一个又一个。我们可以通过反向引用来解决这个问题。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="333b" class="ma mb it lw b gy mc md l me mf">(123-)\1     the <strong class="lw iu">\1</strong> matches the same text that was matched by the first capturing group (123-)</span></pre><p id="68ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来看看。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/c5d07ecb8964062e6e33deb0f84885fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:856/1*AAT86h37JoToxd7E1iCzcQ.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="b23e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以看到，如果只写<code class="fe nd ne nf lw b">(123-)</code>，得到的不是<code class="fe nd ne nf lw b">123-</code>的序列，而是单个元素。相反，如果我们写正则表达式<code class="fe nd ne nf lw b">(123-)\1 </code>，期望的序列是匹配的。该引用相当于编写<code class="fe nd ne nf lw b">(123-)(123-)</code></p><p id="28d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您有一个以上的捕获组，您也可以指定您想要重用的组，方法是写下它的顺序<code class="fe nd ne nf lw b">\1</code>为第一个，<code class="fe nd ne nf lw b">\2</code>为第二个，依此类推。</p><h1 id="7c1c" class="mg mb it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">旗帜</h1><p id="df3f" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">简而言之，标志是可选参数，用于修改正则表达式的搜索行为。每个标志由一个字母字符表示，并以不同的方式修改搜索行为。</p><p id="bc4f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，让我们看看标志<code class="fe nd ne nf lw b">i</code>，它使表达式不区分大小写。在Python中，我们会这样做来添加这个新参数。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="9294" class="ma mb it lw b gy mc md l me mf"># without flag<br/>IN [0]: re.search(r'[a-z]+', 'Hello')<br/>OUT [0]: &lt;re.Match object; span=(1, 5), <strong class="lw iu">match='ello'</strong>&gt;</span><span id="3e22" class="ma mb it lw b gy nc md l me mf"># with I flag<br/>IN [1]: re.search(r'[a-z]+', 'Hello', flags=<strong class="lw iu">re.I</strong>)<br/>OUT [1]: &lt;re.Match object; span=(0, 5), <strong class="lw iu">match='Hello'</strong>&gt;</span></pre><p id="1a42" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们所看到的，由于正则表达式中增加了参数<code class="fe nd ne nf lw b">re.I</code>，我们可以得到整个<code class="fe nd ne nf lw b">‘Hello’</code>而不仅仅是<code class="fe nd ne nf lw b">‘ello’</code></p><p id="a46e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用的其他标志如下</p><ul class=""><li id="20c6" class="ni nj it lb b lc ld lf lg li nk lm nl lq nm lu nw no np nq bi translated"><code class="fe nd ne nf lw b">g</code>(全局)让表达式搜索所有匹配项</li><li id="1954" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nw no np nq bi translated"><code class="fe nd ne nf lw b">m</code>(多行)使边界字符<code class="fe nd ne nf lw b">^</code>和<code class="fe nd ne nf lw b">$</code>匹配每一行的开始和结束，而不是整个字符串的开始和结束</li><li id="76c5" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nw no np nq bi translated"><code class="fe nd ne nf lw b">s</code>(点全)使点符号也匹配换行符。</li></ul><h1 id="d2a9" class="mg mb it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">贪婪和懒惰的搭配</h1><p id="6f8d" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">这是一些操作符默认的行为方式。像<code class="fe nd ne nf lw b">*+{}</code>这样的一些字符是<strong class="lb iu">贪婪的</strong>，这意味着它们将匹配<strong class="lb iu">最长的可能字符串</strong>。例如，假设我们想要获取连字符<code class="fe nd ne nf lw b">-</code>中的所有字符</p><p id="9d4b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以很容易地得到这个正则表达式<code class="fe nd ne nf lw b">-.+- </code>，但是加号<code class="fe nd ne nf lw b">+ </code>是贪婪的，所以它将尽可能多地使用字符(如果我们的目标是匹配尽可能短的字符串，甚至是其他连字符<code class="fe nd ne nf lw b">-) </code>)。，我们应该像<code class="fe nd ne nf lw b">?</code>一样加一个<strong class="lb iu">懒算子</strong>。我们来对比一下。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/511d71a48e0863e87108c5f77cb23a75.png" data-original-src="https://miro.medium.com/v2/resize:fit:856/1*6WK0d1ghRBxeQXDTr5Qkig.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="c3de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">开始时，<code class="fe nd ne nf lw b">+ </code>匹配整个字符串<code class="fe nd ne nf lw b">–456–123–123– </code>,但是<code class="fe nd ne nf lw b">? </code>确保用最少的字符数进行匹配，所以它首先匹配<code class="fe nd ne nf lw b">-456-</code>,然后匹配<code class="fe nd ne nf lw b">-123-</code></p><p id="72e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请记住，您可以通过编写严格的表达式来避免这些贪婪/懒惰的匹配，比如<code class="fe nd ne nf lw b">-[^-]+- </code> This匹配连字符之间的任何内容，同时也不包含任何连字符。</p><h1 id="7d2a" class="mg mb it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">常见使用案例</h1><h2 id="19ea" class="ma mb it bd mh nx ny dn ml nz oa dp mp li ob oc mr lm od oe mt lq of og mv oh bi translated">匹配标点符号</h2><p id="c6bc" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">在处理文本时，通常需要在分析前删除标点符号。为此，我们编写以下表达式</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="fa5f" class="ma mb it lw b gy mc md l me mf">[^\w\s]</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/408d16aa088f875d8aeeb2b40132b85e.png" data-original-src="https://miro.medium.com/v2/resize:fit:856/1*4ao39CbqrYixsiDpta-qUA.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><h2 id="f247" class="ma mb it bd mh nx ny dn ml nz oa dp mp li ob oc mr lm od oe mt lq of og mv oh bi translated">有效的日期格式</h2><p id="7e93" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">这将取决于您希望匹配的格式。让我们假设你想用美国格式匹配一个日期<code class="fe nd ne nf lw b">mm-dd-yyyy</code></p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="9f7a" class="ma mb it lw b gy mc md l me mf">\d{2}-\d{2}-\d{4}</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/c8f96b8889f31bb2fc5b9d02672cd696.png" data-original-src="https://miro.medium.com/v2/resize:fit:856/1*zYb_mBXTgHvtOJXA4xtSIw.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><h2 id="8c18" class="ma mb it bd mh nx ny dn ml nz oa dp mp li ob oc mr lm od oe mt lq of og mv oh bi translated">有效电子邮件</h2><p id="e2c0" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">您可以通过以下表达式轻松识别有效的电子邮件</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="bbd9" class="ma mb it lw b gy mc md l me mf">^[^@ ]+@[^@ ]+\.[^@ \.]{2,}$</span></pre><p id="fd16" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">表达式的键直到需要时才匹配@和空格，所以我们写<code class="fe nd ne nf lw b">[^@ ] </code>来忽略它们。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/79f8bcd920389f2e39123236de45e4ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:856/1*n2sVw809va8XwFSFWmNtaw.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><h2 id="9e48" class="ma mb it bd mh nx ny dn ml nz oa dp mp li ob oc mr lm od oe mt lq of og mv oh bi translated">有效用户名</h2><p id="2851" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">假设用户名只允许小写字母或数字。此外，用户名的最小长度必须是4个字符，最大长度必须是16个字符。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="386b" class="ma mb it lw b gy mc md l me mf">^[a-z0-9]{4,16}$</span></pre><p id="c1cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以在这个<a class="ae ky" href="https://regex101.com/" rel="noopener ugc nofollow" target="_blank">网站</a>上测试这个以及我们在本文中使用的其他正则表达式。</p></div><div class="ab cl oi oj hx ok" role="separator"><span class="ol bw bk om on oo"/><span class="ol bw bk om on oo"/><span class="ol bw bk om on"/></div><div class="im in io ip iq"><p id="f848" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nh">就是这样！现在是你创建正则表达式来解决日常任务的时候了！我在我的</em> <a class="ae ky" href="https://github.com/ifrankandrade/data_preprocessing.git" rel="noopener ugc nofollow" target="_blank"> <em class="nh"> Github </em> </a> <em class="nh">上列出了本文中使用的正则表达式字符及其含义。</em></p><p id="6ba5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://frankandrade.ck.page/bd063ff2d3" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">与3k以上的人一起加入我的电子邮件列表，获取我在所有教程中使用的Python for Data Science备忘单(免费PDF) </strong> </a></p></div></div>    
</body>
</html>