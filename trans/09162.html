<html>
<head>
<title>How to Train Your Own TensorFlow Models, and Run Them on Any Platform</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何训练自己的张量流模型，并在任何平台上运行它们</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-train-your-own-tensorflow-models-and-run-them-on-any-platform-6a1303d4c2d6?source=collection_archive---------20-----------------------#2021-08-24">https://towardsdatascience.com/how-to-train-your-own-tensorflow-models-and-run-them-on-any-platform-6a1303d4c2d6?source=collection_archive---------20-----------------------#2021-08-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="6a2a" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">探索全球芯片短缺危机的解决方案。</h2></div><p id="e316" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi lb translated">训练自己的TensorFlow Lite模型为您提供了一个创建自己的定制AI应用程序的机会。此外，使用像<a class="ae lk" href="https://wasmedge.org/" rel="noopener ugc nofollow" target="_blank"> WasmEdge </a>这样的运行时，您就有机会在许多不同的平台上运行您的定制TensorFlow应用程序。包括共享硬件。稍后将详细介绍共享硬件…</p><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="gh gi ll"><img src="../Images/7598498446b5fd2f326b499688ee96d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*1SoQ92LYt7fsPVGR"/></div></div><p class="lx ly gj gh gi lz ma bd b be z dk translated">照片由<a class="ae lk" href="https://unsplash.com/@jeremy0?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">杰瑞米·零</a>在<a class="ae lk" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><h2 id="3831" class="mb mc iq bd md me mf dn mg mh mi dp mj ko mk ml mm ks mn mo mp kw mq mr ms mt bi translated">什么是WasmEdge？</h2><p id="a29b" class="pw-post-body-paragraph kf kg iq kh b ki mu jr kk kl mv ju kn ko mw kq kr ks mx ku kv kw my ky kz la ij bi translated">WasmEdge是一个轻量级和高性能的WebAssembly (WASM)虚拟机(VM ),针对边缘计算进行了优化。它广泛用于云无服务器功能(FaaS)、软件即服务(SaaS)、区块链智能合约和物联网以及实时汽车应用等场景。</p><p id="4629" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">由<a class="ae lk" href="https://www.cncf.io/" rel="noopener ugc nofollow" target="_blank"> CNCF </a>主办，WasmEdge旨在成为Wasm及其Edge相关扩展的开源“参考实现”。</p><p id="fae6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">本文主要关注WasmEdge的TensorFlow扩展。可以通过<a class="ae lk" href="https://github.com/WasmEdge/WasmEdge" rel="noopener ugc nofollow" target="_blank"> GitHub </a>了解更多WasmEdge如果您想为WasmEdge投稿，请参见<a class="ae lk" href="https://github.com/WasmEdge/WasmEdge/blob/master/docs/CONTRIBUTING.md" rel="noopener ugc nofollow" target="_blank">该投稿人文档</a>。</p><h2 id="a1a9" class="mb mc iq bd md me mf dn mg mh mi dp mj ko mk ml mm ks mn mo mp kw mq mr ms mt bi translated"><strong class="ak">我们为什么要使用Wasm？</strong></h2><p id="a2ae" class="pw-post-body-paragraph kf kg iq kh b ki mu jr kk kl mv ju kn ko mw kq kr ks mx ku kv kw my ky kz la ij bi translated">Wasm生态系统仍处于早期阶段。然而，Wasm相对于传统的执行环境有一些非常重要和独特的优势。</p><p id="6565" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">除了它的性能…</p><blockquote class="mz"><p id="38ac" class="na nb iq bd nc nd ne nf ng nh ni la dk translated">"在其超前(AOT)编译模式下，WasmEdge是目前市场上速度最快的Wasm虚拟机."[1]</p></blockquote><p id="c95f" class="pw-post-body-paragraph kf kg iq kh b ki nj jr kk kl nk ju kn ko nl kq kr ks nm ku kv kw nn ky kz la ij bi translated">…一个独特的主张是Wasm可执行文件在独立的、基于堆栈的Wasm虚拟机中运行。这意味着任何不受信任的Wasm程序都可以在共享硬件上与其他Wasm程序一起运行；没有副作用。</p><h2 id="6971" class="mb mc iq bd md me mf dn mg mh mi dp mj ko mk ml mm ks mn mo mp kw mq mr ms mt bi translated"><strong class="ak">您为什么想要共享硬件？</strong></h2><p id="ed0d" class="pw-post-body-paragraph kf kg iq kh b ki mu jr kk kl mv ju kn ko mw kq kr ks mx ku kv kw my ky kz la ij bi translated">就制造业的未来而言，这是一件大事。例如，丰田最近宣布，他们将“因全球芯片短缺而削减40%的汽车产量”[2]。</p><p id="007b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所有领域的消费电子产品，不管是什么类型，都有不断满足消费者需求的动力。这些需求包括不同种类的娱乐、信息娱乐、安全、反垃圾邮件、语音识别、物体检测等等。</p><p id="ac6d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">能够在共享硬件上训练和运行复杂的人工智能应用程序(可以帮助满足这些消费者需求)对生产来说至关重要。以下是全球制造商的一些报价，它们证明了这一点。</p><p id="44af" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">大众</strong></p><blockquote class="no np nq"><p id="2afa" class="kf kg nr kh b ki kj jr kk kl km ju kn ns kp kq kr nt kt ku kv nu kx ky kz la ij bi translated">“德国大众汽车表示，它可能还需要进一步减产，并预计第三季度的芯片供应将‘非常不稳定和紧张’。”</p></blockquote><p id="8018" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">福特</strong></p><blockquote class="no np nq"><p id="72df" class="kf kg nr kh b ki kj jr kk kl km ju kn ns kp kq kr nt kt ku kv nu kx ky kz la ij bi translated">“福特汽车表示，由于半导体相关零件短缺，将暂时关闭其制造最畅销的F-150皮卡的堪萨斯城组装厂”</p></blockquote></div><div class="ab cl nv nw hu nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="ij ik il im in"><h1 id="8319" class="oc mc iq bd md od oe of mg og oh oi mj jw oj jx mm jz ok ka mp kc ol kd ms om bi translated">学习人工智能模型和数据</h1><p id="7b15" class="pw-post-body-paragraph kf kg iq kh b ki mu jr kk kl mv ju kn ko mw kq kr ks mx ku kv kw my ky kz la ij bi translated">开始学习如何训练TensorFlow的最好方法是查看一些现成的TensorFlow训练数据。</p><p id="0b41" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们的<strong class="kh ir">第一个例子</strong>是专门针对自然语言情感分析的。我们要检查一些训练数据。一旦您理解了这个特定的数据集，您就可以继续创建自己的训练数据，然后为特定的用例(无论是什么)训练和运行自然语言模型。</p><p id="7b45" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们的<strong class="kh ir">第二个例子</strong>中，我们也将从查看一些现成的数据开始；深入到关于边界框坐标等等的细节。</p><p id="9e0b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦我们了解了单发探测器(SSD)边界框的工作原理，我们就可以创建自己的训练数据，然后针对特定用例训练和运行SSD模型。</p><p id="953e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们从一些动手演示开始；请继续阅读，即使你不是编码。有许多图表和解释将使这容易理解。</p></div><div class="ab cl nv nw hu nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="ij ik il im in"><h1 id="9b83" class="oc mc iq bd md od oe of mg og oh oi mj jw oj jx mm jz ok ka mp kc ol kd ms om bi translated">第一个例子—自然语言、情感分析</h1><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="gh gi on"><img src="../Images/23c4f446baf47c0d4114f92c51b114ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*e7zRuK_3V5wUxd6R"/></div></div><p class="lx ly gj gh gi lz ma bd b be z dk translated">亚历山大·辛恩在<a class="ae lk" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="a808" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在开始之前，让我们运行几个命令来准备好我们的系统。我们安装了TensorFlow、TensorFlow模型制作工具、Numpy和熊猫。</p><pre class="lm ln lo lp gt oo op oq or aw os bi"><span id="a42b" class="mb mc iq op b gy ot ou l ov ow">pip3 install tensorflow<br/>pip3 install tflite-model-maker<br/>pip3 install numpy~=1.19.2<br/>pip3 install pandas</span></pre><p id="d734" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们打开一个<code class="fe ox oy oz op b">python3</code>解释器，运行下面的代码。</p><pre class="lm ln lo lp gt oo op oq or aw os bi"><span id="5574" class="mb mc iq op b gy ot ou l ov ow">import os<br/>import numpy as np<br/>import pandas as pd<br/>import tensorflow as tf<br/>from tflite_model_maker import model_spec<br/>from tflite_model_maker import text_classifier<br/>from tflite_model_maker.config import ExportFormat<br/>from tflite_model_maker.text_classifier import AverageWordVecSpec<br/>from tflite_model_maker.text_classifier import DataLoader<br/># Get the data<br/>data_dir = tf.keras.utils.get_file(<br/>      fname='SST-2.zip',<br/>      origin='<a class="ae lk" href="https://dl.fbaipublicfiles.com/glue/data/SST-2.zip'" rel="noopener ugc nofollow" target="_blank">https://dl.fbaipublicfiles.com/glue/data/SST-2.zip'</a>,<br/>      extract=True)<br/>data_dir = os.path.join(os.path.dirname(data_dir), 'SST-2')</span></pre><p id="2c11" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可以在这里看到，作为该设置的一部分，我们正在从<em class="nr">fbaipublicfiles.com</em>下载一个公共数据集。我们需要去看看那些公共数据，因为它是我们理解如何创建我们自己的数据的关键。</p><p id="54c2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们打印<code class="fe ox oy oz op b">data_dir</code>，我们可以看到数据已经保存到我们的主目录中(在一个隐藏的<code class="fe ox oy oz op b">.keras</code>文件夹中)。</p><pre class="lm ln lo lp gt oo op oq or aw os bi"><span id="d48f" class="mb mc iq op b gy ot ou l ov ow">print(data_dir)<br/>/Users/tpmccallum/.keras/datasets/SST-2</span></pre><p id="703d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们查看这些数据，我们可以看到数据集的格式不适合TensorFlow Lite …还不适合！</p><p id="6e31" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以解决这个问题:)</p><p id="8e6c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了使该数据与TensorFlow Lite兼容，我们执行以下任务。</p><p id="9418" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，我们将制表符分隔的数据文件<code class="fe ox oy oz op b">dev.tsv</code>转换为逗号分隔的文件，并替换标签(将<code class="fe ox oy oz op b">0</code>转换为单词<code class="fe ox oy oz op b">negative</code>，将<code class="fe ox oy oz op b">1</code>转换为单词<code class="fe ox oy oz op b">positive</code>，如下图所示)。</p><pre class="lm ln lo lp gt oo op oq or aw os bi"><span id="87ac" class="mb mc iq op b gy ot ou l ov ow">df = pd.read_csv('/Users/tpmccallum/.keras/datasets/SST-2/dev.tsv', sep='\t')<br/>label_map = {0: 'negative', 1: 'positive'}<br/>df.replace({'label': label_map}, inplace=True)<br/>df.to_csv('/Users/tpmccallum/.keras/datasets/SST-2/dev.csv')<br/>replace_label(os.path.join(os.path.join(data_dir, 'dev.tsv')), 'dev.csv')</span></pre><p id="8652" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们也对<code class="fe ox oy oz op b">train.tsv</code>文件这样做</p><pre class="lm ln lo lp gt oo op oq or aw os bi"><span id="0287" class="mb mc iq op b gy ot ou l ov ow">df = pd.read_csv('/Users/tpmccallum/.keras/datasets/SST-2/train.tsv', sep='\t')<br/>label_map = {0: 'negative', 1: 'positive'}<br/>df.replace({'label': label_map}, inplace=True)<br/>df.to_csv('/Users/tpmccallum/.keras/datasets/SST-2/train.csv')<br/>replace_label(os.path.join(os.path.join(data_dir, 'train.tsv')), 'train.csv')</span></pre><p id="44da" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，我们再次对<code class="fe ox oy oz op b">test.tsv</code>文件执行此操作。</p><pre class="lm ln lo lp gt oo op oq or aw os bi"><span id="3fcd" class="mb mc iq op b gy ot ou l ov ow">df = pd.read_csv('/Users/tpmccallum/.keras/datasets/SST-2/test.tsv', sep='\t')<br/>label_map = {0: 'negative', 1: 'positive'}<br/>df.replace({'label': label_map}, inplace=True)<br/>df.to_csv('/Users/tpmccallum/.keras/datasets/SST-2/test.csv')<br/>replace_label(os.path.join(os.path.join(data_dir, 'test.tsv')), 'test.csv')</span></pre><p id="1323" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">好的，太好了！现在我们有了一些有意义的TensorFlow Lite兼容数据，可以使用和复制(使用我们自己的句子和标签)。</p><p id="9a8a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">3个电子表格(<code class="fe ox oy oz op b">dev.csv</code>、<code class="fe ox oy oz op b">train.csv</code>和<code class="fe ox oy oz op b">test.csv</code>)各有两列(句子和标签)。</p><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="gh gi pa"><img src="../Images/a816a2e84f74aaa700520839fe53ec87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LD-vksfOLtMLOW1JhSjh5w.png"/></div></div></figure><p id="baeb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个句子不是肯定的就是否定的。例如，句子“坚定地黯淡和绝望”被正确地标注为否定的。</p><p id="9011" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">理解了这个大纲，你就可以开始创建你自己的训练和测试数据。你只需简单地添加句子，然后正确/准确地标记它们(然后存储<strong class="kh ir">你的</strong>定制文件来代替这些原始文件)。</p><h2 id="53ac" class="mb mc iq bd md me mf dn mg mh mi dp mj ko mk ml mm ks mn mo mp kw mq mr ms mt bi translated">培养</h2><p id="d673" class="pw-post-body-paragraph kf kg iq kh b ki mu jr kk kl mv ju kn ko mw kq kr ks mx ku kv kw my ky kz la ij bi translated">我们现在可以加载这些<code class="fe ox oy oz op b">csv</code>文件，然后执行训练。</p><pre class="lm ln lo lp gt oo op oq or aw os bi"><span id="059e" class="mb mc iq op b gy ot ou l ov ow">spec = model_spec.get('average_word_vec')<br/>train_data = DataLoader.from_csv(filename='train.csv', text_column='sentence', label_column='label', model_spec=spec, is_training=True)<br/>test_data = DataLoader.from_csv(filename='dev.csv', text_column='sentence', label_column='label', model_spec=spec, is_training=False)<br/># Train<br/>model = text_classifier.create(train_data, model_spec=spec, epochs=10)</span></pre><p id="8e44" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">培训过程将生成如下所示的输出。</p><pre class="lm ln lo lp gt oo op oq or aw os bi"><span id="35d9" class="mb mc iq op b gy ot ou l ov ow">Epoch 1/10</span><span id="3898" class="mb mc iq op b gy pb ou l ov ow">1/2104 [..............................]<br/>2104/2104 [==============================] - 3s 1ms/step - loss: 0.6841 - accuracy: 0.5570</span><span id="03e4" class="mb mc iq op b gy pb ou l ov ow">// snip //</span><span id="ceec" class="mb mc iq op b gy pb ou l ov ow">Epoch 10/10<br/>2104/2104 [==============================] - 2s 1ms/step - loss: 0.3340 - accuracy: 0.8647</span></pre><p id="8055" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们现在可以对训练好的模型进行测试</p><pre class="lm ln lo lp gt oo op oq or aw os bi"><span id="e1e7" class="mb mc iq op b gy ot ou l ov ow"># Test<br/>loss, acc = model.evaluate(test_data)</span></pre><p id="490b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">培训的结果如下</p><pre class="lm ln lo lp gt oo op oq or aw os bi"><span id="02d8" class="mb mc iq op b gy ot ou l ov ow">28/28 [==============================] - 0s 1ms/step - loss: 0.5160 - accuracy: 0.8303</span></pre><p id="c61a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们对这些结果满意，那么我们可以将训练好的模型导出为一个<code class="fe ox oy oz op b">.tflite</code>文件；然后我们可以在我们的应用程序中使用它(稍后将详细介绍如何创建应用程序)。</p><pre class="lm ln lo lp gt oo op oq or aw os bi"><span id="51ca" class="mb mc iq op b gy ot ou l ov ow">model.export(export_dir='average_word_vec')</span></pre><p id="ab6d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们在<a class="ae lk" href="https://netron.app/" rel="noopener ugc nofollow" target="_blank"> netron app </a>中打开新创建的TensorFlow Lite兼容文件(<code class="fe ox oy oz op b">model.tflite</code>，可以看到<strong class="kh ir">输入</strong>和<strong class="kh ir">输出</strong>规范。这些规范将帮助我们编写应用程序。</p><h2 id="2b2c" class="mb mc iq bd md me mf dn mg mh mi dp mj ko mk ml mm ks mn mo mp kw mq mr ms mt bi translated">模型设定</h2><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div class="gh gi pc"><img src="../Images/f70bbe4efe112d0636b1a5d2a0e33b50.png" data-original-src="https://miro.medium.com/v2/resize:fit:958/format:webp/1*NI7AOjkvpvQOXQCju8HWEQ.png"/></div></figure><p id="30f6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如我们所见，输入称为<code class="fe ox oy oz op b">input_1</code>，输出称为<code class="fe ox oy oz op b">Identity</code>。</p><h2 id="bdd7" class="mb mc iq bd md me mf dn mg mh mi dp mj ko mk ml mm ks mn mo mp kw mq mr ms mt bi translated">输入(称为input_1)</h2><p id="6ddc" class="pw-post-body-paragraph kf kg iq kh b ki mu jr kk kl mv ju kn ko mw kq kr ks mx ku kv kw my ky kz la ij bi translated">模型属性中的描述描述了输入的数据格式。具体来说…</p><blockquote class="no np nq"><p id="7bc7" class="kf kg nr kh b ki kj jr kk kl km ju kn ns kp kq kr nt kt ku kv nu kx ky kz la ij bi translated">嵌入表示要分类的输入文本的向量。输入需要从原始文本转换为嵌入向量使用附加的字典文件。</p></blockquote><p id="94ab" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">本质上，这个输入希望文本(用户提供的)被转换成一个单独的i32整数数组，即<code class="fe ox oy oz op b">[5043, 201023, ... , 29361, 3499]</code>。因此，我们需要了解模型的创建者希望我们如何将单词映射到数字。</p><p id="1403" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通过调查数据，我们了解到该模型的创建者使用了一个字典文件，该文件将单词/短语映射到数字。字典文件每行有一个唯一的整数(对应于文本)。</p><p id="a1f3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，在第85，155行，我们有单词“awesome”和整数29361(如下所示)。</p><pre class="lm ln lo lp gt oo op oq or aw os bi"><span id="6590" class="mb mc iq op b gy ot ou l ov ow">awesome|29361</span></pre><p id="25ee" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，在我们的应用程序中，如果用户键入单词“awesome ”,我们需要将整数<code class="fe ox oy oz op b">29361</code>发送给模型(作为模型期望的<code class="fe ox oy oz op b">i32</code>数组中的许多元素之一)。</p><p id="1c60" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这取决于您是在客户端还是在服务器端这样做。编程语言是你自己的个人喜好；我在下面创建了一些Rust代码，展示了如何从本地文件系统中读取字典，然后从数据中创建一个HashMap。<strong class="kh ir">然而，我们也可以通过网络阅读这个文件，而不是</strong>；请允许我在下一节解释。</p><h2 id="2b68" class="mb mc iq bd md me mf dn mg mh mi dp mj ko mk ml mm ks mn mo mp kw mq mr ms mt bi translated">从本地磁盘读取并解析字典文件</h2><pre class="lm ln lo lp gt oo op oq or aw os bi"><span id="7ef0" class="mb mc iq op b gy ot ou l ov ow"><br/>    // Create HashMap which stores String and Integer pairs<br/>    let mut map_name: HashMap&lt;String, i32&gt; = HashMap::new();<br/>    // Read the dictionary file <br/>    let filename = "src/dictionary.txt";<br/>    let file = File::open(filename).unwrap();<br/>    let reader = BufReader::new(file);<br/>    // Process each line<br/>    for (index, line) in reader.lines().enumerate() {<br/>        let line = line.unwrap();<br/>        // Create vector to store each line as split data<br/>        let v: Vec&lt;&amp;str&gt; = line.split(|c| c == '|').collect();<br/>        // Place the split data into the HashMap<br/>        map_name.insert(v[0].to_string(), v[1].parse::&lt;i32&gt;().unwrap());<br/>    }<br/>    // Create another vector to hold the input data<br/>    let size = 256;<br/>    let mut vecForModel: Vec&lt;i32&gt; = Vec::with_capacity(size);<br/>    // Split this functions input by space<br/>    let vInputString: Vec&lt;&amp;str&gt; = input_string.split(|c| c == ' ').collect();<br/>    // See if any words are in the HashMap<br/>    for word in vInputString {<br/>        if map_name.contains_key(word){<br/>            // If so, add the appropriate integer<br/>            vecForModel.push(*map_name.get(word).unwrap());<br/>        }</span></pre><h2 id="de0c" class="mb mc iq bd md me mf dn mg mh mi dp mj ko mk ml mm ks mn mo mp kw mq mr ms mt bi translated">通过网络读取和解析字典文件</h2><p id="604a" class="pw-post-body-paragraph kf kg iq kh b ki mu jr kk kl mv ju kn ko mw kq kr ks mx ku kv kw my ky kz la ij bi translated">为了向您展示如何为web 创建AI应用<strong class="kh ir">，让我们远程解析这个字典文件。</strong></p><p id="921c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">WasmEdge的RESTful API其实可以远程为我们取这个字典文件；类似于使用内容交付网络(CDN ),而不是在本地存储文件。这有几个好处。</p><p id="170e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，应用程序开发人员可以更新字典文件(在其远程位置),而用户无需做任何事情。</p><p id="5f3a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">其次，文件的获取和读取现在100%在服务器端完成(客户机不需要做任何这种高带宽的工作)。我们的AI应用程序的用户(在客户端)只上传他们的句子和指向字典文件的URL指针。我们必须记住，这个字典文件超过20万行(239，232)，并且可能随着新单词/语言的添加而增长。</p><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="gh gi pd"><img src="../Images/d05cd139b6176b86d34cb9e4485110b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nRW_PEd_RnYZQAqd0wYnsg.png"/></div></div></figure><p id="14ae" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面屏幕截图显示这只是一个文本文件。</p><p id="90ef" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">远程获取这种大型文本文件要快得多，繁重的工作更适合服务器端。下图说明了远程获取是如何工作的。</p><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div class="gh gi pe"><img src="../Images/d7c02f5456b563acc8979f2d91d015e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1210/format:webp/1*ZLnVchXmxCM2vvy1FXhWKQ.png"/></div></figure><h2 id="4efb" class="mb mc iq bd md me mf dn mg mh mi dp mj ko mk ml mm ks mn mo mp kw mq mr ms mt bi translated">Web表单</h2><p id="d47c" class="pw-post-body-paragraph kf kg iq kh b ki mu jr kk kl mv ju kn ko mw kq kr ks mx ku kv kw my ky kz la ij bi translated">让这个AI应用程序可用的最好方法是使用表单数据(即web表单)。让我们看看web表单会是什么样子。</p><p id="d343" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">除了几个输入框(在HTML中)，我们将有一个Javascript函数，它接受输入，然后调用WasmEdge的RESTful API。</p><p id="b41f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是Javascript。本质上只是一个AJAX请求。</p><pre class="lm ln lo lp gt oo op oq or aw os bi"><span id="76e2" class="mb mc iq op b gy ot ou l ov ow">function callService() {<br/>          setTimeout(function() {<br/>            $('#process').prop('disabled', true);<br/>          }, 0);</span><span id="3a82" class="mb mc iq op b gy pb ou l ov ow">          var formData = new FormData();<br/>          formData.append('input_1', $('#input_1').val());<br/>          formData.append('fetch_input_2', $('#input_2').val());<br/>          console.log("Running ...");<br/>          $.ajax({<br/>            url: "<a class="ae lk" href="https://rpc.ssvm.secondstate.io:8081/api/multipart/run/392/classify" rel="noopener ugc nofollow" target="_blank">https://rpc.ssvm.secondstate.io:8081/api/multipart/run/392/classify</a>",<br/>            type: "post",<br/>            cache: false,<br/>            data: formData,<br/>            contentType: false,<br/>            processData: false,<br/>            xhrFields: {<br/>              responseType: "" // defaults to text<br/>            },<br/>            success: function(r_data) {<br/>              console.log("Successfully ran the ajax");<br/>              document.getElementById("result_box").innerHTML = r_data;<br/>              $('#process').prop('disabled', false);<br/>            },<br/>            error: function(r_error) {<br/>              console.log("Error running the ajax: " + r_error);<br/>              alert("Rate limit exceeded");<br/>              $('#process').prop('disabled', false);<br/>            }<br/>          });<br/>          console.log("END");<br/>          return false;<br/>        }</span></pre><p id="38de" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">只是提醒一下，WasmEdge几乎可以在任何设备上运行。为了这篇文章，我们将使用网络，以便您可以看到它的行动。</p><p id="c6a9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从上面的Javascript代码可以看出，WasmEdge有一个API端点，任何能够发出安全HTTP请求的设备都可以调用它。显然，对于汽车应用来说，这些程序将在本地硬件上运行，而不是通过网络。</p><p id="2842" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，仅仅为了演示WasmEdge的多功能性，让我们仔细看看WasmEdge的API端点结构。</p><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div class="gh gi pf"><img src="../Images/a1ae41dc9916ee3ada143d0cef3a55f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1022/format:webp/1*wFPGaWt-ngIRtgBuIlDMFQ.png"/></div></figure><p id="5fab" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您会注意到这个URL以一个函数名结尾，在本例中是<code class="fe ox oy oz op b">classify</code>。这实际上是执行所有逻辑(执行张量流模型)的Rust函数的名称。出于演示的目的，Rust函数已经被编写、编译成Wasm并部署在wasm_id <code class="fe ox oy oz op b">392</code>(如上面的URL所示)。不要担心，我们很快就会深入研究Rust/Wasm。现在，让我们只关注应用程序的前端(客户端)。</p><p id="260d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">以下简单的curl命令可用于执行我们预先编写的Wasm二进制文件。注意我们如何添加两个<code class="fe ox oy oz op b">--form</code>参数(让curl模拟一个填充的表单)。注意，第二个输入实际上是我们前面提到的大字典文件的远程获取。</p><p id="a470" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">提示</strong>:执行远程获取时，使用不经过重定向的URL，即如果在GitHub中存储数据，则使用如下所示的<code class="fe ox oy oz op b">raw.githubusercontent</code>风格的URL。</p><pre class="lm ln lo lp gt oo op oq or aw os bi"><span id="4db2" class="mb mc iq op b gy ot ou l ov ow">curl --location --request POST 'https://rpc.ssvm.secondstate.io:8081/api/multipart/run/392/classify' --form 'input_1="Awesome movie"' --form 'fetch_input_2="<a class="ae lk" href="https://raw.githubusercontent.com/tpmccallum/Tim2/main/dictionary_testing.txt" rel="noopener ugc nofollow" target="_blank">https://<strong class="op ir">raw.githubusercontent</strong>.com/tpmccallum/Tim2/main/dictionary_testing.txt</a>"'</span></pre><p id="c5f5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦curl工作了，我们就可以为我们的应用程序创建一个HTML表单了。我们之前准备的那个看起来像下图，你可以在这里访问HTML源代码<a class="ae lk" href="https://github.com/second-state/wasm-learning/blob/master/faas/tf_lite_natural_language/html/index.html" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="2f77" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">同样的页面也可以通过GitHub pages进行现场演示。</p><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="gh gi pg"><img src="../Images/2e8484ff5de429e6e9764f92ad854ba2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eJT1f1cGZpiRGmb54DIZkA.png"/></div></div></figure><p id="9023" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们已经介绍了HTML和Javascript，让我们看看我们实际上通过WasmEdge API调用的可执行代码。</p><p id="7a76" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这整个应用程序是由Rust函数驱动的，<a class="ae lk" href="https://github.com/second-state/wasm-learning/blob/master/faas/tf_lite_natural_language/src/lib.rs" rel="noopener ugc nofollow" target="_blank">这里是我们之前准备的Rust源代码</a>的链接。注意，这个函数叫做<code class="fe ox oy oz op b">classify</code>，它与上面的API URL相匹配。</p><figure class="lm ln lo lp gt lq"><div class="bz fp l di"><div class="ph pi l"/></div></figure><p id="643d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们使用一个命令将Rust源代码编译成WebAssembly (Wasm)。</p><pre class="lm ln lo lp gt oo op oq or aw os bi"><span id="5089" class="mb mc iq op b gy ot ou l ov ow">rustwasmc build</span></pre><p id="9aba" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如上所述，WasmEdge能够在多种模式下运行，即通过NodeJS、在嵌入式设备上等等。然而，我们将继续使用WasmEdge的API进行演示，以便您可以试用。</p><p id="b131" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们看看如何解释输出。</p><h2 id="c1f2" class="mb mc iq bd md me mf dn mg mh mi dp mj ko mk ml mm ks mn mo mp kw mq mr ms mt bi translated">输出——“身份”</h2><p id="5c42" class="pw-post-body-paragraph kf kg iq kh b ki mu jr kk kl mv ju kn ko mw kq kr ks mx ku kv kw my ky kz la ij bi translated">正如我们在模型的属性中看到的，输出<strong class="kh ir">被称为“身份”。Identity是一个包含两个元素的数组(数据类型都是float 32)。第一个是与负面情绪相关的指数<code class="fe ox oy oz op b">0-1</code>。例如，0.25意味着它有1/4的负面含义，1意味着它是一个完全负面的评论。</strong></p><p id="99eb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第二个因素代表积极的情绪。</p><p id="5b88" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">数组中的2个元素的总和总是1。例如，中性将是0.5负和0.5正。</p><p id="d2d7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们尝试一些句子，看看我们得到了什么。</p><p id="ece8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">…的句子</p><p id="551a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir"> <em class="nr">“绝顶的平淡，痛苦的缓慢。”</em>T12】</strong></p><p id="829c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">导致了:</p><ul class=""><li id="d63e" class="pj pk iq kh b ki kj kl km ko pl ks pm kw pn la po pp pq pr bi translated">高负指数<code class="fe ox oy oz op b">1</code></li><li id="d295" class="pj pk iq kh b ki ps kl pt ko pu ks pv kw pw la po pp pq pr bi translated"><code class="fe ox oy oz op b">0</code>的低正指数</li></ul><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="gh gi px"><img src="../Images/0e2bc38f09ad7818a49a8439176f78b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HDJY7P_KaOABGFNOJIYADg.png"/></div></div></figure><p id="1d77" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">相比之下……的句子</p><p id="48ed" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这部电影棒极了。伟大的演员，好的情节和娱乐性。 </p><p id="e77b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">导致了:</p><ul class=""><li id="ad31" class="pj pk iq kh b ki kj kl km ko pl ks pm kw pn la po pp pq pr bi translated"><code class="fe ox oy oz op b">0.09839419</code>的低负指数</li><li id="8261" class="pj pk iq kh b ki ps kl pt ko pu ks pv kw pw la po pp pq pr bi translated"><code class="fe ox oy oz op b">0.9016058</code>的积极指数较高</li></ul><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="gh gi py"><img src="../Images/7c79a1abedc5ca7706718d13e70638f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VBu_2lNLmT1xzMutBXejVw.png"/></div></div></figure><p id="c0d8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了更深入一点，在我们结束自然语言示例之前，我冒昧地粘贴了WasmEdge服务器端日志的输出。下面的输出显示了Rust源代码中所有的<code class="fe ox oy oz op b">println!</code>语句；本质上展示了我们如何远程获取字典，获取用户的输入，然后为模型创建一个256元素的数组，该数组包含任何单词/整数匹配的数字表示(在输入与字典文件的交叉引用期间)。</p><pre class="lm ln lo lp gt oo op oq or aw os bi"><span id="8f17" class="mb mc iq op b gy ot ou l ov ow">Input string: "This film was excellent. Great actors, good plot and entertaining"</span><span id="273f" class="mb mc iq op b gy pb ou l ov ow">Processing word: "this"</span><span id="fce7" class="mb mc iq op b gy pb ou l ov ow">Processing word: "film"</span><span id="e15f" class="mb mc iq op b gy pb ou l ov ow">Processing word: "was"</span><span id="b093" class="mb mc iq op b gy pb ou l ov ow">Processing word: "excellent."</span><span id="3a1f" class="mb mc iq op b gy pb ou l ov ow">Processing word: "great"</span><span id="a957" class="mb mc iq op b gy pb ou l ov ow">Processing word: "actors,"</span><span id="e855" class="mb mc iq op b gy pb ou l ov ow">Processing word: "good"</span><span id="1534" class="mb mc iq op b gy pb ou l ov ow">Processing word: "plot"</span><span id="3771" class="mb mc iq op b gy pb ou l ov ow">Processing word: "and"</span><span id="ad88" class="mb mc iq op b gy pb ou l ov ow">Processing word: "entertaining"</span><span id="7127" class="mb mc iq op b gy pb ou l ov ow">Processing loading the model</span><span id="2aa5" class="mb mc iq op b gy pb ou l ov ow">Final Vec For Model: [2838, 976, 3070, 6874, 1092, 9754, 408, 6224, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]</span><span id="3190" class="mb mc iq op b gy pb ou l ov ow">Adding output</span><span id="a01c" class="mb mc iq op b gy pb ou l ov ow">Running session</span><span id="0823" class="mb mc iq op b gy pb ou l ov ow">The words you provided have a negative connotation index of 0.09839419, and a positive connotation index of 0.9016058.</span></pre><p id="4fbc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第一个例子到此结束，现在我们来看另一个例子。物体检测。你可能在无人驾驶汽车演示中见过这种人工智能。物体检测有着广泛的用途，尤其是在工程和制造业。</p></div><div class="ab cl nv nw hu nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="ij ik il im in"><h1 id="5dd6" class="oc mc iq bd md od oe of mg og oh oi mj jw oj jx mm jz ok ka mp kc ol kd ms om bi translated">目标检测</h1><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="gh gi pz"><img src="../Images/6f7b4be9c14bab9f7df706f1bc35d42f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*HhoSpzzLoNZ9FdjB"/></div></div><p class="lx ly gj gh gi lz ma bd b be z dk translated"><a class="ae lk" href="https://unsplash.com/@scienceinhd?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">科学高清照片</a>上<a class="ae lk" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></p></figure><h2 id="bb14" class="mb mc iq bd md me mf dn mg mh mi dp mj ko mk ml mm ks mn mo mp kw mq mr ms mt bi translated">单发探测器(SSD)示例</h2><p id="4785" class="pw-post-body-paragraph kf kg iq kh b ki mu jr kk kl mv ju kn ko mw kq kr ks mx ku kv kw my ky kz la ij bi translated">和上面的自然语言例子一样，我们将首先安装一些依赖项</p><pre class="lm ln lo lp gt oo op oq or aw os bi"><span id="2c32" class="mb mc iq op b gy ot ou l ov ow">pip3 install testresources<br/>pip3 install pycocotools<br/>pip install grpcio==1.32<br/>pip3 install tflite-model-maker</span></pre><p id="1992" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后输入<code class="fe ox oy oz op b">python3</code>进入Python解释器。</p><pre class="lm ln lo lp gt oo op oq or aw os bi"><span id="afed" class="mb mc iq op b gy ot ou l ov ow">import numpy as np<br/>import os<br/><br/>from tflite_model_maker.config import ExportFormat<br/>from tflite_model_maker import model_spec<br/>from tflite_model_maker import object_detector<br/><br/>import tensorflow as tf<br/>assert tf.__version__.startswith('2')<br/><br/>tf.get_logger().setLevel('ERROR')<br/>from absl import logging<br/>logging.set_verbosity(logging.ERROR)</span></pre><p id="651e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于这个特定的对象检测，我们将使用GS://cloud-ml-data/img/open image/CSV/Salads _ ml _ use . CSV中的<em class="nr">沙拉</em>数据集</p><p id="889f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">前述的<code class="fe ox oy oz op b">salads_ml_use.csv</code>遵循<a class="ae lk" href="https://cloud.google.com/vision/automl/object-detection/docs/csv-format" rel="noopener ugc nofollow" target="_blank">特定的约定</a>。以下是为培训目的创建自己的<code class="fe ox oy oz op b">csv</code>文件的条件。</p><p id="40b0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">目标是理解这个模型，这样你就可以在你喜欢的任何图像/物体上训练它；不仅仅是沙拉😊</p><h2 id="4362" class="mb mc iq bd md me mf dn mg mh mi dp mj ko mk ml mm ks mn mo mp kw mq mr ms mt bi translated">数据格式</h2><p id="ea9d" class="pw-post-body-paragraph kf kg iq kh b ki mu jr kk kl mv ju kn ko mw kq kr ks mx ku kv kw my ky kz la ij bi translated"><code class="fe ox oy oz op b">csv</code>文件:</p><ul class=""><li id="1687" class="pj pk iq kh b ki kj kl km ko pl ks pm kw pn la po pp pq pr bi translated">必须是UTF 8编码的</li><li id="ee2e" class="pj pk iq kh b ki ps kl pt ko pu ks pv kw pw la po pp pq pr bi translated">必须以<code class="fe ox oy oz op b">.csv</code>扩展名结尾</li><li id="6a05" class="pj pk iq kh b ki ps kl pt ko pu ks pv kw pw la po pp pq pr bi translated">集合中的每个边界框都有一行<strong class="kh ir"/></li><li id="68ea" class="pj pk iq kh b ki ps kl pt ko pu ks pv kw pw la po pp pq pr bi translated">每行包含<strong class="kh ir">一幅图像</strong>；具有多个边界框的图像将在与边界框一样多的行上重复</li></ul><h2 id="6206" class="mb mc iq bd md me mf dn mg mh mi dp mj ko mk ml mm ks mn mo mp kw mq mr ms mt bi translated"><strong class="ak">标签</strong></h2><p id="18c0" class="pw-post-body-paragraph kf kg iq kh b ki mu jr kk kl mv ju kn ko mw kq kr ks mx ku kv kw my ky kz la ij bi translated">每个标签必须以字母开头，并且只能包含字母、数字和下划线。</p><h2 id="38aa" class="mb mc iq bd md me mf dn mg mh mi dp mj ko mk ml mm ks mn mo mp kw mq mr ms mt bi translated">边界框</h2><p id="1024" class="pw-post-body-paragraph kf kg iq kh b ki mu jr kk kl mv ju kn ko mw kq kr ks mx ku kv kw my ky kz la ij bi translated">图像中特定对象的每个边界框(在<code class="fe ox oy oz op b">csv</code>文件的那一行)可以用两种方式之一来表示。</p><ol class=""><li id="2415" class="pj pk iq kh b ki kj kl km ko pl ks pm kw pn la qa pp pq pr bi translated">只有两个顶点(由一组x，y坐标组成),如果它们是矩形的对角点。</li></ol><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div class="gh gi qb"><img src="../Images/59ee6700b10a63ae64c1bec07a104204.png" data-original-src="https://miro.medium.com/v2/resize:fit:1120/format:webp/1*uxM3hpU8P7QaAWEJIu2_Ig.png"/></div></figure><p id="52b7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如:</p><pre class="lm ln lo lp gt oo op oq or aw os bi"><span id="e747" class="mb mc iq op b gy ot ou l ov ow">(<!-- -->x_relative_min<!-- -->,<br/>    <!-- -->y_relative_min<!-- -->,<br/>    ,<br/>    ,<br/>    <!-- -->x_relative_max<!-- -->,<br/>    <!-- -->y_relative_max<!-- -->,<br/>    ,<br/>)</span></pre><p id="8815" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">2.所有4个顶点</p><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div class="gh gi qc"><img src="../Images/db0da0a66ba5c1f980ea20741ac117a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1194/format:webp/1*jCo3VEjIzSODvEWh42I3Wg.png"/></div></figure><p id="8fe6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如</p><pre class="lm ln lo lp gt oo op oq or aw os bi"><span id="df3d" class="mb mc iq op b gy ot ou l ov ow">(<!-- -->x_relative_min<!-- -->,<br/>    <!-- -->y_relative_min<!-- -->,<br/>    <!-- -->x_relative_max<!-- -->,<br/>    <!-- -->y_relative_min<!-- -->,<br/>    <!-- -->x_relative_max<!-- -->,<br/>    <!-- -->y_relative_max<!-- -->,<br/>    <!-- -->x_relative_min<!-- -->,<br/>y_relative_max<!-- -->)</span></pre><p id="e281" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从示例中可以看出，这些坐标必须是0到1范围内的浮点数，其中0表示最小的x或y值，1表示最大的x或y值。</p><p id="31cd" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如我们在本文开头提到的，理解数据非常重要，这样我们才能创建自己的训练数据。这些坐标可能会有点混乱，所以让我们来看一张图，这将使这一点更清楚。首先，正如你所看到的，最小值和最大值是从左上到右下排序的。因此，不要感到困惑，或者尝试将这与传统的数据绘图练习联系起来(这是不同的)。</p><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div class="gh gi qd"><img src="../Images/c10b891adc535b5b721bf71f6c1ff3c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1116/format:webp/1*jR33fnM2PUkpZiCjiZ7ofA.png"/></div></figure><p id="8a09" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下图增加了一些细节；演示边界框的坐标位置。</p><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div class="gh gi qe"><img src="../Images/58150a8bacd574e14b5111cb87172c68.png" data-original-src="https://miro.medium.com/v2/resize:fit:1218/format:webp/1*TkPUEjXKbpq_IXuoBc4yqQ.png"/></div></figure><p id="10b9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，x_min = 0，x_max = 1，y_min = 0，y_max = 1</p><h2 id="741a" class="mb mc iq bd md me mf dn mg mh mi dp mj ko mk ml mm ks mn mo mp kw mq mr ms mt bi translated">创建您自己的数据集</h2><p id="e98e" class="pw-post-body-paragraph kf kg iq kh b ki mu jr kk kl mv ju kn ko mw kq kr ks mx ku kv kw my ky kz la ij bi translated">我们马上就要使用一个现成的数据集，但是现在我们已经了解了这个数据是如何工作的，让我们来看看如何从头开始创建我们自己的数据集。</p><p id="91c4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有许多应用程序允许你在自己的图像上手动创建带标签的边界框。其中一个应用叫做<a class="ae lk" href="https://github.com/tzutalin/labelImg" rel="noopener ugc nofollow" target="_blank"> labelImg </a>。</p><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="gh gi qf"><img src="../Images/91f3b675e8e1e693e8ba31bef06c672e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X02L5Sx4F5Nnnq45pMn3FQ.png"/></div></div></figure><p id="29cb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们在本文中使用的另一个应用程序叫做<a class="ae lk" href="https://makeml.app/" rel="noopener ugc nofollow" target="_blank"> MakeML </a>。</p><p id="a943" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下图显示了我们如何拍摄桌子的照片，然后识别笔记本电脑(通过绘制黄色边框并创建名为“laptop”的标签)。</p><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="gh gi qg"><img src="../Images/f8cd27b9cbc9051c742aaab82458d81d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4ovemUoRxE8YKBg-MCZiwQ.png"/></div></div></figure><p id="2a73" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们识别笔记本电脑的键盘(通过画一个紫色的方框并创建一个名为“keyboard”的标签)。</p><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="gh gi qh"><img src="../Images/728f8cceb2b52dbf4d57cb8156b0f3b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Imv2wFpZ3aR03T1nfBCuJQ.png"/></div></div></figure><p id="accf" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在每张图片上画出一个边界框(越多越好)，然后点击左下角的“导出数据集”链接。</p><p id="8a61" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有几种不同的数据格式可供选择。我们来对比一下。</p><h2 id="7e34" class="mb mc iq bd md me mf dn mg mh mi dp mj ko mk ml mm ks mn mo mp kw mq mr ms mt bi translated">Turicreate</h2><p id="8eba" class="pw-post-body-paragraph kf kg iq kh b ki mu jr kk kl mv ju kn ko mw kq kr ks mx ku kv kw my ky kz la ij bi translated">Turicreate兼容数据如下。</p><pre class="lm ln lo lp gt oo op oq or aw os bi"><span id="fc16" class="mb mc iq op b gy ot ou l ov ow">[{'label':'keyboard','type':'rectangle','coordinates':{'x':298,'y':301,'width':397,'height':69}},{'label':'laptop','type':'rectangle','coordinates':{'x':294,'y':225,'width':508,'height':407}}]</span></pre><h2 id="d62a" class="mb mc iq bd md me mf dn mg mh mi dp mj ko mk ml mm ks mn mo mp kw mq mr ms mt bi translated">椰子树</h2><p id="3417" class="pw-post-body-paragraph kf kg iq kh b ki mu jr kk kl mv ju kn ko mw kq kr ks mx ku kv kw my ky kz la ij bi translated">这个通用对象上下文(COCO)兼容数据集是一个JSON文件(如下所示)。</p><pre class="lm ln lo lp gt oo op oq or aw os bi"><span id="30c4" class="mb mc iq op b gy ot ou l ov ow">{<br/>  "categories" : [<br/>    {<br/>      "id" : 1629415338,<br/>      "name" : "laptop"<br/>    },<br/>    {<br/>      "name" : "keyboard",<br/>      "id" : 1629415413<br/>    }<br/>  ],<br/>  "images" : [<br/>    {<br/>      "file_name" : "ssd10.png",<br/>      "height" : 450,<br/>      "id" : 0,<br/>      "width" : 600<br/>    }<br/>  ],<br/>  "annotations" : [<br/>    {<br/>      "id" : 0,<br/>      "category_id" : 1629415413,<br/>      "iscrowd" : 0,<br/>      "bbox" : [<br/>        101,<br/>        268,<br/>        498,<br/>        114<br/>      ],<br/>      "segmentation" : [</span><span id="29ae" class="mb mc iq op b gy pb ou l ov ow">],<br/>      "image_id" : 0,<br/>      "area" : 27456<br/>    },<br/>    {<br/>      "iscrowd" : 0,<br/>      "id" : 1,<br/>      "bbox" : [<br/>        40,<br/>        22,<br/>        549,<br/>        21<br/>      ],<br/>      "segmentation" : [</span><span id="5935" class="mb mc iq op b gy pb ou l ov ow">],<br/>      "area" : 207401,<br/>      "image_id" : 0,<br/>      "category_id" : 1629415338<br/>    }<br/>  ]<br/>}</span></pre><h2 id="e200" class="mb mc iq bd md me mf dn mg mh mi dp mj ko mk ml mm ks mn mo mp kw mq mr ms mt bi translated">帕斯卡VOC</h2><p id="3fbd" class="pw-post-body-paragraph kf kg iq kh b ki mu jr kk kl mv ju kn ko mw kq kr ks mx ku kv kw my ky kz la ij bi translated">Pascal VOC数据集格式是一个XML文件(如下所示)</p><pre class="lm ln lo lp gt oo op oq or aw os bi"><span id="c98e" class="mb mc iq op b gy ot ou l ov ow">&lt;annotation&gt;<br/>    &lt;folder&gt;images&lt;/folder&gt;<br/>    &lt;filename&gt;ssd10.png&lt;/filename&gt;<br/>    &lt;size&gt;<br/>        &lt;width&gt;600&lt;/width&gt;<br/>        &lt;height&gt;450&lt;/height&gt;<br/>        &lt;depth&gt;3&lt;/depth&gt;<br/>    &lt;/size&gt;<br/>    &lt;segmented&gt;0&lt;/segmented&gt;<br/>    &lt;object&gt;<br/>        &lt;name&gt;keyboard&lt;/name&gt;<br/>        &lt;pose&gt;Unspecified&lt;/pose&gt;<br/>        &lt;truncated&gt;0&lt;/truncated&gt;<br/>        &lt;occluded&gt;0&lt;/occluded&gt;<br/>        &lt;difficult&gt;0&lt;/difficult&gt;<br/>        &lt;bndbox&gt;<br/>            &lt;xmin&gt;101&lt;/xmin&gt;<br/>            &lt;ymin&gt;268&lt;/ymin&gt;<br/>            &lt;xmax&gt;498&lt;/xmax&gt;<br/>            &lt;ymax&gt;337&lt;/ymax&gt;<br/>        &lt;/bndbox&gt;<br/>    &lt;/object&gt;<br/>    &lt;object&gt;<br/>        &lt;name&gt;laptop&lt;/name&gt;<br/>        &lt;pose&gt;Unspecified&lt;/pose&gt;<br/>        &lt;truncated&gt;0&lt;/truncated&gt;<br/>        &lt;occluded&gt;0&lt;/occluded&gt;<br/>        &lt;difficult&gt;0&lt;/difficult&gt;<br/>        &lt;bndbox&gt;<br/>            &lt;xmin&gt;40&lt;/xmin&gt;<br/>            &lt;ymin&gt;22&lt;/ymin&gt;<br/>            &lt;xmax&gt;549&lt;/xmax&gt;<br/>            &lt;ymax&gt;430&lt;/ymax&gt;<br/>        &lt;/bndbox&gt;<br/>    &lt;/object&gt;<br/>&lt;/annotation&gt;</span></pre><p id="28d0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可能还记得上面的内容，我们需要以特定的方式格式化数据，即电子表格的每一行都需要如下所示:</p><p id="252a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">链接到图像、标签、边界框坐标，即</p><p id="0f37" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">gs://folder/ssd10.png，<strong class="kh ir">笔记本电脑</strong>，x_min，y_min，x_max，y_min，x_max，y_max，x_min，y_max</p><p id="5bf0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">gs://folder/ssd10.png，<strong class="kh ir">键盘</strong>，x_min，y_min，x_max，y_min，x_max，y_max，x_min，y_max</p><p id="ac20" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了符合上面讨论的格式，我们需要将图像形状和框坐标转换为0–1值(作为600 px x450 px格式中的并列像素坐标)。</p><p id="eec9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果宽度(x轴)是600像素，高度(y轴)是450像素，那么我们将对笔记本电脑的边界框坐标执行以下转换。</p><p id="6bb4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">40px(最小)/ 600px(宽度)= 0.06</p><p id="96ab" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">549像素(最大值)/600像素(宽度)= 0.91</p><p id="8e65" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">22px(最小)/ 450px(高度)= 0.04</p><p id="5c79" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">430(最大)/450像素(高度)= 0.95</p><p id="01cb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，膝上型电脑边界框的单行条目如下</p><p id="1bfb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">gs://folder/ssd10.png，笔记本电脑，0.06，0.04，0.91，0.04，0.91，0.95，0.06，0.95</p><h2 id="ae3d" class="mb mc iq bd md me mf dn mg mh mi dp mj ko mk ml mm ks mn mo mp kw mq mr ms mt bi translated">用数据训练</h2><p id="09da" class="pw-post-body-paragraph kf kg iq kh b ki mu jr kk kl mv ju kn ko mw kq kr ks mx ku kv kw my ky kz la ij bi translated">准备好电子表格行和图像后，您可以继续运行以下命令。</p><pre class="lm ln lo lp gt oo op oq or aw os bi"><span id="d6cf" class="mb mc iq op b gy ot ou l ov ow">spec = model_spec.get('efficientdet_lite0')</span><span id="a45f" class="mb mc iq op b gy pb ou l ov ow">train_data, validation_data, test_data = object_detector.DataLoader.from_csv('gs://cloud-ml-data/img/openimage/csv/salads_ml_use.csv')</span><span id="1fba" class="mb mc iq op b gy pb ou l ov ow">model = object_detector.create(train_data, model_spec=spec, batch_size=8, train_whole_model=<strong class="op ir">True</strong>, validation_data=validation_data)</span><span id="3fae" class="mb mc iq op b gy pb ou l ov ow">model.evaluate(test_data)</span><span id="f9ce" class="mb mc iq op b gy pb ou l ov ow">model.export(export_dir='.')</span></pre><h2 id="76bf" class="mb mc iq bd md me mf dn mg mh mi dp mj ko mk ml mm ks mn mo mp kw mq mr ms mt bi translated">编写应用程序来执行对象检测</h2><p id="bac1" class="pw-post-body-paragraph kf kg iq kh b ki mu jr kk kl mv ju kn ko mw kq kr ks mx ku kv kw my ky kz la ij bi translated">使用经过训练的模型来执行对象检测的应用程序需要提供正确的输入(数据类型)，并且还知道如何解释模型的输出。</p><p id="9a9d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们检查<code class="fe ox oy oz op b">model.tflite</code>文件(使用netron这样的应用程序。app)，我们看到以下内容</p><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="gh gi qi"><img src="../Images/b053630e95673655ce8c57ea0c0daee5.png" data-original-src="https://miro.medium.com/v2/resize:fit:680/format:webp/1*-QAU4tzbLu11QApgUgAxWw.png"/></div></div></figure><h2 id="a731" class="mb mc iq bd md me mf dn mg mh mi dp mj ko mk ml mm ks mn mo mp kw mq mr ms mt bi translated">投入</h2><p id="c7c9" class="pw-post-body-paragraph kf kg iq kh b ki mu jr kk kl mv ju kn ko mw kq kr ks mx ku kv kw my ky kz la ij bi translated">这个模型很好地描述了输入和输出(我们可以看到输入在RGB中是320 x 320像素)</p><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div class="gh gi qj"><img src="../Images/4b3d2109d120694440f9aad5aba7c6a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:974/format:webp/1*0AY4TkJpC7IeI7LtyO1Ppg.png"/></div></figure><p id="2801" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们确保Rust源代码以320x320数组格式提供图像；平面阵列。</p><pre class="lm ln lo lp gt oo op oq or aw os bi"><span id="8d0c" class="mb mc iq op b gy ot ou l ov ow">let mut resized = image::imageops::thumbnail(&amp;img, 320, 320);<br/>let mut flat_img: Vec&lt;u8&gt; = Vec::new();<br/>for rgb in resized.pixels() {<br/>    flat_img.push(rgb[0]);<br/>    flat_img.push(rgb[1]);<br/>    flat_img.push(rgb[2]);<br/>}</span></pre><h2 id="9dee" class="mb mc iq bd md me mf dn mg mh mi dp mj ko mk ml mm ks mn mo mp kw mq mr ms mt bi translated">输出</h2><p id="b4fb" class="pw-post-body-paragraph kf kg iq kh b ki mu jr kk kl mv ju kn ko mw kq kr ks mx ku kv kw my ky kz la ij bi translated">输出在模型规格中有详细说明，如下图所示。</p><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div class="gh gi qk"><img src="../Images/49eb0405b4a6f8aa3b7e643246e56415.png" data-original-src="https://miro.medium.com/v2/resize:fit:988/format:webp/1*PeNRYZ_za7aOCmcwYx5c4A.png"/></div></figure><p id="13e0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们看一个使用前面提到的沙拉数据集的例子。</p><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div class="gh gi ql"><img src="../Images/ed5ac1fd8bb65c4aecdb5c6b999354d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*pVwDYTw40FTAW0dybBgikw.jpeg"/></div><p class="lx ly gj gh gi lz ma bd b be z dk translated">弗兰霍根，CC BY-SA 4.0&lt;<a class="ae lk" href="https://creativecommons.org/licenses/by-sa/4.0" rel="noopener ugc nofollow" target="_blank">https://creativecommons.org/licenses/by-sa/4.0</a>&gt;，通过维基共享</p></figure><p id="250e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该模型本质上是采用它以前从未见过的新图像，然后以与我们在生成训练数据时手动创建边界框坐标几乎相同的方式返回边界框坐标。</p><p id="1a2d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有趣的是，这个模型以相同的<code class="fe ox oy oz op b">0–1</code>格式返回给我们边界框，并且与缩小的320x320图像尺寸相关。</p><p id="2229" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们将原始图像返回给用户时，我们需要确保根据原始图像的大小来转换对象边界框。</p><p id="edff" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里有一个包围盒坐标的例子，我们称这个数据为<code class="fe ox oy oz op b">res0</code>。</p><pre class="lm ln lo lp gt oo op oq or aw os bi"><span id="cd53" class="mb mc iq op b gy ot ou l ov ow">[0.8125, 0.72265625, 0.5859375, 0.45703125, <br/>...<br/>0.4296875, 0.36328125, 0.36328125, 0.3203125]</span></pre><p id="8860" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">处理盒子的逻辑如下(基于我们在每个盒子4个坐标的集合中工作的事实)</p><pre class="lm ln lo lp gt oo op oq or aw os bi"><span id="eed8" class="mb mc iq op b gy ot ou l ov ow">let mut iter = 0;<br/>while (iter * 4) &lt; res0.len() {<br/>    // bounding box logic<br/>    iter += 1;<br/>}</span></pre><p id="287f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">边界框逻辑的具体实现(假定原始图像是512像素乘512像素)如下。</p><pre class="lm ln lo lp gt oo op oq or aw os bi"><span id="1f6b" class="mb mc iq op b gy ot ou l ov ow">let image_height: f32 = img.height() as f32; //512<br/>let image_width: f32 = img.width() as f32; //512<br/>let x1 = res0[4 * iter + 1] * image_width;<br/>let y1 = res0[4 * iter] * image_height;<br/>let x2 = res0[4 * iter + 3] * image_width;<br/>let y2 = res0[4 * iter + 2]  * image_height;</span></pre><h2 id="3f23" class="mb mc iq bd md me mf dn mg mh mi dp mj ko mk ml mm ks mn mo mp kw mq mr ms mt bi translated">为训练和测试创建自己的数据集</h2><p id="554c" class="pw-post-body-paragraph kf kg iq kh b ki mu jr kk kl mv ju kn ko mw kq kr ks mx ku kv kw my ky kz la ij bi translated">我想用一个额外的工具来结束这篇文章，它可能有助于使这个数据训练过程更快和更健壮。</p><p id="3701" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们在上面提到了<a class="ae lk" href="https://github.com/tzutalin/labelImg" rel="noopener ugc nofollow" target="_blank">标签</a>图像标签应用程序。这是一个开源产品，以PASCAL VOC格式的XML文件构建训练集。这是ImageNet使用的格式。</p><p id="8bb2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">ImageNet是一项正在进行的研究工作，旨在为世界各地的研究人员提供用于训练大规模对象识别模型的图像数据。</p><p id="8234" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">令人欣慰的是，labelImg似乎有一个免费的转换工具，可以在<a class="ae lk" href="https://github.com/tzutalin/labelImg/tree/master/tools" rel="noopener ugc nofollow" target="_blank">GitHub仓库</a>获得，它可以将你的XML文件从PASCAL VOC格式转换成TensorFlow兼容格式，我们在本文中已经解包了这种格式；正式描述在<a class="ae lk" href="https://cloud.google.com/vision/automl/object-detection/docs/csv-format" rel="noopener ugc nofollow" target="_blank">谷歌的官方文档</a>中。labelImg还支持YOLO和CreateML格式。</p><p id="5fd2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用labelImg将允许您创建自己的自定义图像和自定义标签。额外的转换工具将使您不必编写自己的转换工具。</p><p id="1916" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦你的数据集被训练并导出为<code class="fe ox oy oz op b">tflite</code>文件，你就可以使用WasmEdge创建你自己的AI应用程序。</p><p id="0e89" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你会创造什么？</p><p id="b387" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你有任何问题，请在下面留下评论。</p><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="gh gi qm"><img src="../Images/37a2d0526b68036c0f3f3ede5a3473b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Tpg9NHyTjB9TSB9b7_o_VQ.png"/></div></div></figure><p id="d3c3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，如果您想为WasmEdge做贡献，请访问<a class="ae lk" href="https://github.com/WasmEdge/WasmEdge" rel="noopener ugc nofollow" target="_blank">官方WasmEdge GitHub </a>页面。</p><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div class="gh gi qn"><img src="../Images/b28c034ec13360fbff6a9ce15813e5f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:420/format:webp/1*DWuefD5ts7WCK_IL-PhxYg.png"/></div><p class="lx ly gj gh gi lz ma bd b be z dk translated"><a class="ae lk" href="https://www.secondstate.io/" rel="noopener ugc nofollow" target="_blank">https://www.secondstate.io/</a></p></figure><p id="52f3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">SecondState团队是WasmEdge的最初创建者和当前维护者，所以请随时查看SecondState的网站、<a class="ae lk" href="https://blog.secondstate.io/categories/en/" rel="noopener ugc nofollow" target="_blank">博客</a>和<a class="ae lk" href="https://github.com/second-state/" rel="noopener ugc nofollow" target="_blank"> GitHub </a>库。</p><p id="3dd5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">感谢阅读！</p><h1 id="9063" class="oc mc iq bd md od qo of mg og qp oi mj jw qq jx mm jz qr ka mp kc qs kd ms om bi translated">参考</h1><p id="9ebe" class="pw-post-body-paragraph kf kg iq kh b ki mu jr kk kl mv ju kn ko mw kq kr ks mx ku kv kw my ky kz la ij bi translated">[1]<a class="ae lk" href="https://github.com/WasmEdge/WasmEdge#introduction" rel="noopener ugc nofollow" target="_blank">https://github.com/WasmEdge/WasmEdge#introduction</a></p><p id="3979" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">[2]<a class="ae lk" href="https://www.abc.net.au/news/2021-08-20/toyota-slash-car-production-over-chip-shortage/100392630" rel="noopener ugc nofollow" target="_blank">https://www . ABC . net . au/news/2021-08-20/Toyota-slash-car-production-over-chip-short/100392630</a></p></div></div>    
</body>
</html>