<html>
<head>
<title>How to Select a Data Splitting Method</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何选择数据拆分方法</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-select-a-data-splitting-method-4cf6bc6991da?source=collection_archive---------12-----------------------#2021-07-17">https://towardsdatascience.com/how-to-select-a-data-splitting-method-4cf6bc6991da?source=collection_archive---------12-----------------------#2021-07-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2e14" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">不同数据拆分方法的优缺点及其背后的原因。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/763447e34557ab09b3a7ada709cc83a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*1xWQC7PoFx2q1zu3"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">班农·莫里西在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><p id="cb3a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi lv translated"><span class="l lw lx ly bm lz ma mb mc md di"> S </span>分离你现有的数据是有效训练和评估你的模型的一项重要任务。在这里，我将讨论scikit-learn中不同的数据分离技术，选择特定的方法，以及一些常见的陷阱。</p><p id="1304" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本文包含供您使用的易用代码块和供参考的快速摘要。<strong class="lb iu"> ** <em class="me">请随意将这篇文章加入书签以备后用。** </em> </strong></p><p id="9ce1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当你第一次学习数据科学时，拆分你的数据是一项次要的任务。</p><p id="9de4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为什么您应该只使用部分数据？让我的模型学习更多的数据不是会产生更好的结果吗？</p><p id="78ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然人们普遍认为，在构建预测模型时，更多的数据会带来更好的模型，但考虑如何使用您的模型也很重要。</p><p id="ac5f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在将模型投入使用之前，测试模型在开发过程中是必不可少的。不过，你必须只处理可用的数据，这意味着留出一些数据作为你的“真实”数据。</p><p id="d71d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是调查你真实的“现实生活”数据是至关重要的。这个问题的答案决定了您应该如何分离您的数据。</p><h1 id="7594" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated"><strong class="ak">列车试分裂</strong></h1><p id="e832" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">在最简单的数据分离形式中，您随机抽取一部分数据，将其放在一边供以后测试。</p><h2 id="6975" class="nc mg it bd mh nd ne dn ml nf ng dp mp li nh ni mr lm nj nk mt lq nl nm mv nn bi translated">很简单，但是停下来想想这些假设。</h2><ol class=""><li id="6422" class="no np it lb b lc mx lf my li nq lm nr lq ns lu nt nu nv nw bi translated"><strong class="lb iu">该方法假设数据来自同一分布</strong>。例如，假设您有逐年变化的数据。假设您主要从最近一年的数据中取样(甚至可能是由于随机选择而偶然取样)。在这种情况下，您的模型可能无法有效处理今年的预测。</li><li id="17d3" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated"><strong class="lb iu">你有足够的数据使你的数据集具有代表性。</strong>如果您有来自相同分布的数据，但只有100个实例，选择10%的数据作为测试集可能会提供不准确的结果。如果这10个数据点来自数据中最异常的区域，那么模型的性能会更差。当您有更多的数据实例时，这种情况不太可能发生。</li><li id="5145" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated"><strong class="lb iu">对于分类问题，是否需要考虑每个类的份额？</strong>假设您有一个高度倾斜的分类问题(根据我的经验，通常都是这样)。在这种情况下，您可能需要考虑对数据集进行分层。这一点几乎落入前一点，测试集可能太小，但在这种情况下，它对于您试图预测的一个类来说太小了。</li></ol><p id="da87" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您想要执行内部交叉验证，这种拆分方法是完美的。将数据分为训练和测试，并在训练模型时应用交叉验证方法。对于来自同一分布的足够数据，这种方法是可行的</p><p id="b035" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="me">对中大型数据集使用train_test_split，数据来自同一个分布</em> </strong></p><pre class="kj kk kl km gt oc od oe of aw og bi"><span id="c77a" class="nc mg it od b gy oh oi l oj ok">import numpy as np<br/>from sklearn.model_selection import train_test_split</span><span id="2ef5" class="nc mg it od b gy ol oi l oj ok"># Update with your data<br/>X = np.array([[1, 2], [3, 4], [5, 6], [7, 8], [9, 10]])<br/>y = np.array([1, 2, 3, 4, 5])</span><span id="e973" class="nc mg it od b gy ol oi l oj ok">X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.33, random_state=10)</span><span id="0a30" class="nc mg it od b gy ol oi l oj ok">###########################################<br/>#### Add the code for your model here #####<br/>###########################################</span></pre><p id="5189" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">训练测试分割的一个缺点是，当您进行分割时，有一个决定，即您的测试集中的数据将始终是您的测试数据。</p><h2 id="0122" class="nc mg it bd mh nd ne dn ml nf ng dp mp li nh ni mr lm nj nk mt lq nl nm mv nn bi translated">这有几个缺点。</h2><ol class=""><li id="8b6b" class="no np it lb b lc mx lf my li nq lm nr lq ns lu nt nu nv nw bi translated"><strong class="lb iu">在训练</strong>时，你从不在你的模型中包含测试数据。在您的测试数据中可能有一些实例会使您的模型更加健壮。</li><li id="d878" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated"><strong class="lb iu">测试数据是固定的。</strong>最后，还有一个微妙的问题，就是过度适应这个测试集。虽然这不像过度训练神经网络来完美地学习数据那样明确，但这种过度拟合仍然是一个问题。一旦这些数据固定下来，您所执行的实验将根据这个测试集进行重复测试。你要寻找在这个场景中表现最好的模型。但是考虑一下预测建模的原始问题。你不知道未来的数据会怎样。通过对固定的测试集进行重复测试，您正在做一些在真实场景中不可能完成的事情。</li></ol></div><div class="ab cl om on hx oo" role="separator"><span class="op bw bk oq or os"/><span class="op bw bk oq or os"/><span class="op bw bk oq or"/></div><div class="im in io ip iq"><h1 id="f560" class="mf mg it bd mh mi ot mk ml mm ou mo mp jz ov ka mr kc ow kd mt kf ox kg mv mw bi translated"><strong class="ak"> KFold </strong></h1><p id="8f06" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">作为训练-测试分割的替代方法，K-fold提供了一种机制，可以将数据集中的所有数据点同时用作训练数据和测试数据。</p><p id="8252" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Kfolds将数据集分成多组零重叠的索引，从数据集中随机抽取数据集。</p><p id="f7f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种方法优于以前的训练测试分割，因为每个数据点都可以是模型的一部分和测试集中的一部分。</p><h2 id="ae15" class="nc mg it bd mh nd ne dn ml nf ng dp mp li nh ni mr lm nj nk mt lq nl nm mv nn bi translated">然而，这意味着一些事情。</h2><ol class=""><li id="5af8" class="no np it lb b lc mx lf my li nq lm nr lq ns lu nt nu nv nw bi translated"><strong class="lb iu">您将在每个训练数据集上构建多个模型，并在每个测试数据集上进行测试</strong>。虽然这对于小数据集来说没问题，但是当模型很大，数据集很大时，事情很快变得昂贵。</li><li id="1929" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated"><strong class="lb iu">测试之间的性能有所不同</strong>。这种性能上的变化是一件好事。您可以计算关于您的表现的统计数据(即，您可以从多次评估中获得标准偏差和平均值)。您还可以更好地了解您的模型在不同场景下的行为。</li><li id="97b6" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated">通常，当使用这种类型的数据分段时，每个测试的平均值给出了一个模型在真实环境中如何表现的更加可靠的解释。外部交叉验证以这种方式创建多个模型，报告所有折叠的平均性能，然后基于所有数据制作最后一个模型。这个最终模型得益于所有数据的使用。但是，在有额外数据之前，无法对其进行测试。因此，在这种情况下，模型性能的平均值被用作该模型的性能。</li></ol><p id="b66d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="me">当您的数据来自同一个分布</em> </strong>时，将KFold用于中小型数据集</p><pre class="kj kk kl km gt oc od oe of aw og bi"><span id="0669" class="nc mg it od b gy oh oi l oj ok">import numpy as np<br/>from sklearn.model_selection import KFold</span><span id="36cb" class="nc mg it od b gy ol oi l oj ok"># Update with your data<br/>X = np.array([[1, 2], [3, 4], [5, 6], [7, 8], [9, 10]])<br/>y = np.array([1, 2, 3, 4, 5])</span><span id="ced1" class="nc mg it od b gy ol oi l oj ok">KF = KFold(n_splits=5)<br/>for train_index, test_index in KF.split(X):<br/>    X_train, X_test = X[train_index], X[test_index]<br/>    y_train, y_test = y[train_index], y[test_index]</span><span id="02d0" class="nc mg it od b gy ol oi l oj ok">    ###########################################<br/>    #### Add the code for your model here #####<br/>    ###########################################</span></pre></div><div class="ab cl om on hx oo" role="separator"><span class="op bw bk oq or os"/><span class="op bw bk oq or os"/><span class="op bw bk oq or"/></div><div class="im in io ip iq"><h1 id="32f9" class="mf mg it bd mh mi ot mk ml mm ou mo mp jz ov ka mr kc ow kd mt kf ox kg mv mw bi translated"><strong class="ak">时间序列分割</strong></h1><p id="7502" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">前面的两种方法都认为你所拥有的数据是可以随机抽样的。<strong class="lb iu">然而，在时间序列数据中，你不能随机抽样数据。</strong>最重要的原因是，没有现实生活中的场景可以用未来的数据训练一个模型来预测过去。</p><p id="d272" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">相反，你可以通过时间来分离数据。例如，获取一个数据点之前的所有数据，然后在下一个数据点上测试它，可以确保没有数据泄漏。从这个意义上说，漏损就是用未来的数据来预测以前的数据。</p><p id="0827" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种分割方法是三种<strong class="lb iu">方法中唯一一种考虑分布随时间变化的方法</strong>。因此，当您有随时间变化的数据时，可以使用它。</p><p id="1e0c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="me">对于时间序列数据或数据分布随时间变化时，使用TimeSeriesSplit。</em>T15】</strong></p><pre class="kj kk kl km gt oc od oe of aw og bi"><span id="3d14" class="nc mg it od b gy oh oi l oj ok">import numpy as np<br/>from sklearn.model_selection import TimeSeriesSplit</span><span id="a214" class="nc mg it od b gy ol oi l oj ok"># Update with your data<br/>X = np.array([[1, 2], [3, 4], [5, 6], [7, 8], [9, 10]])<br/>y = np.array([1, 2, 3, 4, 5])</span><span id="0147" class="nc mg it od b gy ol oi l oj ok">time_series_cv = TimeSeriesSplit(gap=0, max_train_size=None, n_splits=5, test_size=None)</span><span id="04e1" class="nc mg it od b gy ol oi l oj ok">for train_index, test_index in time_series_cv.split(X):<br/>    X_train, X_test = X[train_index], X[test_index]<br/>    y_train, y_test = y[train_index], y[test_index]</span><span id="4d97" class="nc mg it od b gy ol oi l oj ok">###########################################<br/>#### Add the code for your model here #####<br/>###########################################</span></pre></div><div class="ab cl om on hx oo" role="separator"><span class="op bw bk oq or os"/><span class="op bw bk oq or os"/><span class="op bw bk oq or"/></div><div class="im in io ip iq"><h1 id="cf61" class="mf mg it bd mh mi ot mk ml mm ou mo mp jz ov ka mr kc ow kd mt kf ox kg mv mw bi translated"><strong class="ak">总结</strong></h1><p id="6023" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">建立模型很有趣。但是，试图提高模型的性能可能是一项无止境的任务。虽然您可能在一组数据上有出色的表现，但考虑如何在现实世界中使用您的模型是否至关重要。不同的拆分方式服务于不同的目的，所以要相应选择。</p><p id="2289" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">记住关注目标问题，而不仅仅是某个测试集的最高性能。</strong></p></div><div class="ab cl om on hx oo" role="separator"><span class="op bw bk oq or os"/><span class="op bw bk oq or os"/><span class="op bw bk oq or"/></div><div class="im in io ip iq"><p id="42aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你有兴趣阅读关于新颖的数据科学工具和理解机器学习算法的文章，可以考虑在Medium上关注我。</p><p id="4f22" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你对我的写作感兴趣，想直接支持我，请通过以下链接订阅。这个链接确保我会收到你的会员费的一部分。</p><div class="oy oz gp gr pa pb"><a href="https://zjwarnes.medium.com/membership" rel="noopener follow" target="_blank"><div class="pc ab fo"><div class="pd ab pe cl cj pf"><h2 class="bd iu gy z fp pg fr fs ph fu fw is bi translated">通过我的推荐链接加入Medium-Zachary Warnes</h2><div class="pi l"><h3 class="bd b gy z fp pg fr fs ph fu fw dk translated">阅读扎卡里·沃恩斯(以及媒体上成千上万的其他作家)的每一个故事。您的会员费直接支持…</h3></div><div class="pj l"><p class="bd b dl z fp pg fr fs ph fu fw dk translated">zjwarnes.medium.com</p></div></div><div class="pk l"><div class="pl l pm pn po pk pp ks pb"/></div></div></a></div></div></div>    
</body>
</html>