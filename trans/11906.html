<html>
<head>
<title>Applied Concurrency Techniques in ETL Pipelines</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">ETL 管道中的应用并发技术</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/applied-concurrency-techniques-for-etl-pipelines-32387eb82fbc?source=collection_archive---------17-----------------------#2021-11-29">https://towardsdatascience.com/applied-concurrency-techniques-for-etl-pipelines-32387eb82fbc?source=collection_archive---------17-----------------------#2021-11-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="d7d2" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">Python 并发方法与案例场景</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/a1acf2a10c1d8d6ceeca46cb4186b0b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1GIMIqL9uLz_kJ7GEbkcAg.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://burst.shopify.com/photos/fast-bike-racing?" rel="noopener ugc nofollow" target="_blank">突发</a></p></figure><p id="8a02" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">并发性意味着在重叠的时间间隔内运行程序的组成部分&amp;并行性意味着并行运行所有部分的能力(这也取决于系统的能力，如多核和语言支持)。如果我们想让程序多任务化(并行)或表现得像多任务化(并发)，我们必须理解这些概念是什么，何时以及如何应用的。今天，在这篇文章中，我将尝试解释这些技术以及它们通过一个简单的 ETL 管道的实现。</p><p id="fb95" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">词汇</strong>:</p><ol class=""><li id="697a" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">python 技术简介。</li><li id="bf96" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">通过示例 ETL 过程实现</li><li id="26e7" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">所有技术的执行时间表</li></ol><p id="05c7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">简介</strong>:在 python 中，我们有一个强大的模块，可以在任何程序中实现并发/并行。这里，下面是三个需要实现的模块—</p><ul class=""><li id="5407" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr mg ly lz ma bi translated"><em class="mh">concurrent . futurers . threadpool executor</em></li><li id="4170" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr mg ly lz ma bi translated"><em class="mh">concurrent . futures . processpoolexecutor</em></li><li id="c1dc" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr mg ly lz ma bi translated"><em class="mh">阿辛西奥</em></li></ul><p id="cfcb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将在每个单独的管道中使用上述模块，并读取性能，但在此之前，让我们尝试了解这些模块是关于什么的？</p><ul class=""><li id="c6f8" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr mg ly lz ma bi translated"><em class="mh">并发。期货</em>包提供了<em class="mh">执行器</em>接口，可以向<em class="mh">线程</em>或<em class="mh">进程提交作业。一个</em>作业可以提交给线程实现多线程(<strong class="ky ir"> ThreadPoolExecutor 将被使用</strong>)，一个作业提交给进程实现多处理，然后<strong class="ky ir"> ProcessPoolExecutor </strong>将被使用。</li><li id="e933" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr mg ly lz ma bi translated">另一方面，asyncio(异步 i/o)类似于线程，但它通过单线程或事件循环来归档并发性。</li></ul><p id="720a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我们将在实施部分讨论何时以及哪个模块适合任何特定的场景——</p><p id="b040" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">实现</strong> —我们将获取一个 CSV 文件，其中包含通过示例 ETL 流程中的提取功能处理的机场频率记录。转换函数将这两个值['airport_ident，' ' ***']连接到输出文件中的新列。这是一个非常简单的场景，显示了实现我们的技术(并发/并行)的 ETL 执行流程。</p><p id="40f2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">线程支持 i/o 绑定操作、网络 i/o、磁盘操作，多进程支持 CPU 绑定操作。平台上有很多很好的文章来了解什么是线程&amp;进程，为什么是操作特定的！为了继续我们的讨论，我们需要了解哪个组件/模块支持哪种操作。</p><p id="d03f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是如何使用每种技术运行它。</p><ol class=""><li id="1ecf" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">多线程——正如我们已经讨论过的，每个线程的操作在重叠的时间间隔内并发运行。并且这种重叠与以并行方式执行一样快。</li></ol><p id="6b58" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，在实现多线程时，我们需要记住一些事情，比如线程间的竞争条件使程序的关键部分容易出错；在 ETL 或任何程序中，这可能会导致数据加载/处理损坏。为了避免这种竞争情况或控制任务执行的流程，我们可以使用锁或信号量。如我们的 ETL 示例所示。此外，下面的示例截图显示了线程是如何执行的，当前进入和退出执行的是哪个线程！</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mi"><img src="../Images/19b23b64f99846faf0ef447fea9f6829.png" data-original-src="https://miro.medium.com/v2/resize:fit:1248/format:webp/1*rrFY-cMRh9FxUvgFO9o-vw.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">线程执行-作者图片</p></figure><p id="8854" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">注意</strong>——在 python 的线程化中，我们还要记住一件重要的事情，那就是 GIL(global interpreter lock)，它通过对一个解释器应用全局锁，使得任何程序一次只能运行一个线程。</p><pre class="kg kh ki kj gt mj mk ml mm aw mn bi"><span id="1707" class="mo mp iq mk b gy mq mr l ms mt">from concurrent.futures import ThreadPoolExecutor<br/>import pandas as pd<br/>import time</span><span id="80d1" class="mo mp iq mk b gy mu mr l ms mt">##Threading:<br/>##- A new thread is spawned within the existing process<br/>##- starting a thread is faster than starting a process<br/>##- memory is shared between all threads<br/>##- mutexes often necessary to control access to shared data<br/>##- on GIL (Global Interpreter Lock) for all threads</span><span id="07f3" class="mo mp iq mk b gy mu mr l ms mt">##semaphore locks with lock access count<br/>semTrn = Semaphore(4)<br/>semLd = Semaphore(4)<br/><br/>def extract(file):<br/>    dtype_dict = {'id': 'category',<br/>                  'airport_ref': 'category',<br/>                  'airport_ident': 'category',<br/>                  'type': 'category',<br/>                  'description': 'category',<br/>                  'frequency_mhz': 'float16'<br/>                  }<br/><br/>    df = pd.read_csv(file, dtype=dtype_dict, low_memory=False)<br/>    return df<br/><br/><br/>def transform(df):<br/>    ##semaphore lock<br/>    semTrn.acquire()<br/>    print("thread {} acquired tranform lock ".format(threading.currentThread().ident))<br/>    ##basic transformation operation<br/><br/>    df['ref_code'] = df['airport_ident'].astype(str)+str('***')<br/>    semTrn.release()<br/>    print("thread {} released tranform lock ".format(threading.currentThread().ident))<br/>    print("thread {} acquired load lock ".format(threading.currentThread().ident))<br/>    semLd.acquire()<br/>    load(df)<br/><br/><br/>def load(tdf):<br/><br/>    tdf.to_csv('airport_freq_output.csv', mode='a', header=False, index=False)<br/>    semLd.release()<br/>    print("thread {} released load lock  ".format(threading.currentThread().ident))<br/>    print("thread {} load completion ".format(threading.currentThread().ident))<br/><br/>def main():<br/>    pd.set_option('mode.chained_assignment', None)<br/>    file = 'airport_freq.csv'<br/>    df = extract(file)<br/>    chunk_size = int(df.shape[0] / 4)<br/>    ##t = [0] * 4<br/>    executor = ThreadPoolExecutor(max_workers=4)<br/>    lst = list()<br/>    for start in range(0, df.shape[0], chunk_size):<br/>        df_subset = df.iloc[start:start + chunk_size]<br/>        ##df_subset.is_copy=None<br/>        lst.append(executor.submit(transform, df_subset))<br/>    for future in lst:<br/>        future.result()<br/>    executor.shutdown()<br/><br/>if __name__ == "__main__":<br/>    start = time.time()<br/>    main()<br/>    end = time.time() - start<br/>    print("Execution time {} sec".format(end))</span></pre><p id="1560" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">2.多处理——在这种情况下，python 提供了在每个进程中运行程序任务的能力，并且全局解释器锁的限制也得到扩展(这意味着我们可以通过多处理接口正式并行运行每个任务),但这也带来了其他特定的约定，例如每个进程比线程花费更多的创建时间。另外，每个进程都需要自己的内存执行空间；这使得成本很高，所以在用户被要求运行任何特定于 CPU 的活动之前，多处理对于 i/o 相关的任务来说是很昂贵的。下面显示了示例 ETL 实现的执行流程。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mi"><img src="../Images/ba75bb371d257e79527f9b1b00e5563c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1248/format:webp/1*uLZ9hjnEM0WTTkg_VYugGw.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">多进程执行流程—作者图片</p></figure><pre class="kg kh ki kj gt mj mk ml mm aw mn bi"><span id="9265" class="mo mp iq mk b gy mq mr l ms mt">from concurrent.futures import ProcessPoolExecutor<br/>import pandas as pd<br/>import time</span><span id="20c4" class="mo mp iq mk b gy mu mr l ms mt">##MultiProcessing<br/>##- A new process is started independent from the first process<br/>##- Starting a process is slower than starting a thread<br/>##- Memory is not shared between processes<br/>##- Mutexes not necessary (unless threading in the new process)<br/>##- One GIL(Global Interpreter Lock) for each process</span><span id="1c88" class="mo mp iq mk b gy mu mr l ms mt">semTrn = Semaphore(5)<br/>semLd = Semaphore(5)<br/>def extract(file):<br/>    dtype_dict = {'id': 'category',<br/>                  'airport_ref': 'category',<br/>                  'airport_ident': 'category',<br/>                  'type': 'category',<br/>                  'description': 'category',<br/>                  'frequency_mhz': 'float16'<br/>                  }<br/><br/>    df = pd.read_csv(file, dtype=dtype_dict, low_memory=False)<br/>    return df<br/><br/>def transform(df):<br/>    print("process {} transform started ".format(multiprocessing.current_process().pid))<br/>    ##basic transformation operation<br/>    semTrn.acquire()<br/>    df['ref_code'] = df['airport_ident'].astype(str)+str('***')<br/>    semTrn.release()<br/>    print("process {} transform completion ".format(multiprocessing.current_process().pid))<br/>    semLd.acquire()<br/>    load(df)<br/><br/>def load(tdf):<br/>    print("process {} load started".format(multiprocessing.current_process().pid))<br/>    tdf.to_csv('airport_freq_output.csv', mode='a', header=False, index=False)<br/>    semLd.release()<br/>    print("process {} load completion ".format(multiprocessing.current_process().pid))<br/><br/><br/>def main():<br/>    file = 'airport_freq.csv'<br/>    df = extract(file)<br/>    chunk_size = int(df.shape[0] / 4)<br/>    executor = ProcessPoolExecutor(max_workers=5)<br/>    lst = list()<br/>    for start in range(0, df.shape[0], chunk_size):<br/>        df_subset = df.iloc[start:start + chunk_size]<br/>        lst.append(executor.submit(transform, df_subset))<br/>    for future in lst:<br/>        future.result()<br/>    executor.shutdown()<br/><br/><br/>if __name__ == "__main__":<br/>    start = time.time()<br/>    main()<br/>    end = time.time() - start<br/>    print("Execution time {} sec".format(end))</span></pre><p id="ce8e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">3.Asyncio —该模块为任何网络、磁盘或基于 web 的操作提供高性能。我们可以使用 asyncio 模块编写并发代码。这可以在函数中使用异步/等待条件来实现；以下 ETL 示例的执行展示了 asyncio 技术的实现。</p><pre class="kg kh ki kj gt mj mk ml mm aw mn bi"><span id="a435" class="mo mp iq mk b gy mq mr l ms mt">import asyncio<br/>import time<br/>import pandas as pd</span><span id="d3cf" class="mo mp iq mk b gy mu mr l ms mt">##coroutine - wrapped version of the function to run async<br/>##async function in python is typically called coroutine<br/>##coroutines declared with async/await syntax<br/>##coroutines are special functions that return coroutine objects when called<br/><br/><br/>##event loop -<br/>##the event loop is a very efficient task manager<br/>##coordinate tasks<br/>##run asynchronous tasks and callbacks<br/><br/>def extract(file):<br/>    dtype_dict = {'id': 'category',<br/>                  'airport_ref': 'category',<br/>                  'airport_ident': 'category',<br/>                  'type': 'category',<br/>                  'description': 'category',<br/>                  'frequency_mhz': 'float16'<br/>                  }<br/>    df = pd.read_csv(file, dtype=dtype_dict,low_memory=False)<br/>    return df<br/><br/>async def transform(df):<br/><br/>    df['ref_code'] = df['airport_ident'].astype(str)+str('***')<br/>    await load(df)<br/><br/>async def load(tdf):<br/><br/>    tdf.to_csv('airport_freq_out.csv', mode='a', header=False, index=False)<br/>    await asyncio.sleep(0)<br/><br/>async def main():<br/>    pd.set_option('mode.chained_assignment', None)<br/>    file = 'airport_freq.csv'<br/>    df = extract(file)<br/>    chunk_size = int(df.shape[0] / 4)<br/>    for start in range(0, df.shape[0], chunk_size):<br/>        df_subset = df.iloc[start:start + chunk_size]<br/>        x = asyncio.create_task(transform(df_subset))<br/>        await x<br/><br/>start = time.time()<br/>asyncio.run(main())<br/>end=time.time()-start<br/>print("execution time {} sec".format(end))</span></pre><p id="4b0e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">执行时间:</strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/b5540a26d54aa13f9f716732d41e388a.png" data-original-src="https://miro.medium.com/v2/resize:fit:962/format:webp/1*0O68r1pWnbZl9AuYtYp-Gw.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/bae4a42c6e5f82bb5e6a88eddda6a4f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:690/format:webp/1*1W7nWbt5PUZRcRAq6Rphtw.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">几秒钟！！—作者图片</p></figure><p id="67c5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">结论</strong>:从我们的样本运行来看，我们可以假设 asyncio 线程方法适合我们的场景，因为它涉及到文件的 i/o 处理。多重处理对我们的系统来说是昂贵的，尽管它涉及并行处理。</p><p id="d73e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">今天的帖子通过一个示例 ETL 强调了应用并发性/并行性的技术。我希望这个细节对理解这些技术并在您的实现中使用有所帮助。在以后的文章中，我将尝试在任何数据集的 groupby 和 aggregation 等操作上实现这些技术。</p><p id="e03a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> GitHub 地点</strong>—<a class="ae kv" href="https://github.com/Shivakoreddi/ConcurrencyPipelines" rel="noopener ugc nofollow" target="_blank">https://github.com/Shivakoreddi/ConcurrencyPipelines</a></p><p id="07b4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">参考:</p><ol class=""><li id="d10b" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">Python 文档，<a class="ae kv" href="https://docs.python.org/3/library/asyncio.html" rel="noopener ugc nofollow" target="_blank">https://docs.python.org/3/library/asyncio.html</a></li><li id="d078" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">塞尔达尔，<a class="ae kv" href="https://www.infoworld.com/article/3632284/python-concurrency-and-parallelism-explained.html" rel="noopener ugc nofollow" target="_blank">https://www . infoworld . com/article/3632284/python-concurrency-and-parallelism-explained . html</a>，2021 年</li><li id="7f87" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">http://pymotw.com/2/threading/<a class="ae kv" href="http://pymotw.com/2/threading/" rel="noopener ugc nofollow" target="_blank">PyMOTW</a></li></ol></div></div>    
</body>
</html>