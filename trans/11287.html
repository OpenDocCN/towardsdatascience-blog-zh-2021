<html>
<head>
<title>Python and the Module Search Path</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python和模块搜索路径</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/python-and-the-module-search-path-e71ae7a7e65f?source=collection_archive---------9-----------------------#2021-11-05">https://towardsdatascience.com/python-and-the-module-search-path-e71ae7a7e65f?source=collection_archive---------9-----------------------#2021-11-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/5c63acf00277c662fb96b2ff7fafea0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1X0-98EiQNkwBJj2vnTTqQ.jpeg"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">克里斯·里德在<a class="ae jd" href="https://unsplash.com/s/photos/code-system-path?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><div class=""/><div class=""><h2 id="3f03" class="pw-subtitle-paragraph kd jf jg bd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dk translated">python如何知道要导入哪些包，在哪里可以找到它们，以及现代工具(conda、pyenv、them)如何让这一切变得简单</h2></div><p id="270c" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">之前我们已经研究过各种工具(conda，pyenv)如何操作<code class="fe lr ls lt lu b">$PATH</code>变量，这样当你输入<code class="fe lr ls lt lu b">python</code>时，你想要的python版本(在给定的环境中)就是你得到的python版本。对于导入python标准默认函数库来说，这一切都很好，但是:</p><ul class=""><li id="f30a" class="lv lw jg kx b ky kz lb lc le lx li ly lm lz lq ma mb mc md bi translated">当我们想从PyPI安装第三方软件包时(比如numpy，pandas，scipy)</li><li id="69b5" class="lv lw jg kx b ky me lb mf le mg li mh lm mi lq ma mb mc md bi translated">当我们想在本地安装我们自己的包/模块时——无论是开发还是在为PyPI构建我们自己的包之前进行测试</li></ul><p id="63af" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">python如何知道:</p><ul class=""><li id="584d" class="lv lw jg kx b ky kz lb lc le lx li ly lm lz lq ma mb mc md bi translated">在哪里寻找这些包</li><li id="3884" class="lv lw jg kx b ky me lb mf le mg li mh lm mi lq ma mb mc md bi translated">如果我们有两个同名的，如何区分它们的优先级</li></ul><p id="e775" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为此，你一输入<code class="fe lr ls lt lu b">python</code>，它就会构建‘模块搜索路径’。</p><h2 id="fa1e" class="mj mk jg bd ml mm mn dn mo mp mq dp mr le ms mt mu li mv mw mx lm my mz na nb bi translated">输入<code class="fe lr ls lt lu b">python</code>会发生什么？</h2><p id="8e2d" class="pw-post-body-paragraph kv kw jg kx b ky nc kh la lb nd kk ld le ne lg lh li nf lk ll lm ng lo lp lq ij bi translated">所以我们已经知道，当你输入<code class="fe lr ls lt lu b">python</code>时，你的操作系统会从上到下查找第一个名为‘python’的可执行文件的路径(不管它实际上是不是pyenv shims指出的python可执行文件)。然后，一旦找到它，它就执行它。但是这有什么用呢？接下来是什么？在知道如何定位我们的包的背景下，我们关心它如何构造<code class="fe lr ls lt lu b">sys.path</code>变量。</p><p id="f0ac" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">类似于<code class="fe lr ls lt lu b">$PATH</code> , <code class="fe lr ls lt lu b"><a class="ae jd" href="https://docs.python.org/3/library/sys.html#sys.path" rel="noopener ugc nofollow" target="_blank">sys.path</a></code>是一个内部python版本，类似于操作系统如何自顶向下遍历<code class="fe lr ls lt lu b">$PATH</code>来匹配可执行文件，python遍历<code class="fe lr ls lt lu b">sys.path</code>来匹配包和模块。</p><div class="ip iq gp gr ir nh"><a rel="noopener follow" target="_blank" href="/python-the-system-path-and-how-conda-and-pyenv-manipulate-it-234f8e8bbc3e"><div class="ni ab fo"><div class="nj ab nk cl cj nl"><h2 class="bd jh gy z fp nm fr fs nn fu fw jf bi translated">Python，系统路径以及conda和pyenv如何操纵它</h2><div class="no l"><h3 class="bd b gy z fp nm fr fs nn fu fw dk translated">深入探究当您在shell中键入“python”时会发生什么，以及流行的环境管理工具如何操纵…</h3></div><div class="np l"><p class="bd b dl z fp nm fr fs nn fu fw dk translated">towardsdatascience.com</p></div></div><div class="nq l"><div class="nr l ns nt nu nq nv ix nh"/></div></div></a></div><h2 id="3dc4" class="mj mk jg bd ml mm mn dn mo mp mq dp mr le ms mt mu li mv mw mx lm my mz na nb bi translated"><code class="fe lr ls lt lu b">sys.path</code>是如何确定和设定的？</h2><p id="914d" class="pw-post-body-paragraph kv kw jg kx b ky nc kh la lb nd kk ld le ne lg lh li nf lk ll lm ng lo lp lq ij bi translated">这里有一篇很棒的文章<a class="ae jd" href="https://newbedev.com/where-is-python-s-sys-path-initialized-from" rel="noopener ugc nofollow" target="_blank"/>介绍了这一点的复杂性，尽管这看起来是一个简单的任务，但有许多困难需要克服。在“现代python设置”中，我们有幸使用以下一项或多项:</p><ul class=""><li id="d1b4" class="lv lw jg kx b ky kz lb lc le lx li ly lm lz lq ma mb mc md bi translated">pyenv</li><li id="8d2f" class="lv lw jg kx b ky me lb mf le mg li mh lm mi lq ma mb mc md bi translated">康达</li><li id="5984" class="lv lw jg kx b ky me lb mf le mg li mh lm mi lq ma mb mc md bi translated">诗意</li></ul><p id="c680" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这个过程在很大程度上被简化了，因为我们并不真正关心像T0和T1这样的东西，因为它们往往是空白的。</p><p id="2090" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们来看一个例子。我使用的是<code class="fe lr ls lt lu b">pyenv</code>，就像之前一样，我们可以验证我们运行的是哪个版本的python:</p><pre class="nx ny nz oa gt ob lu oc od aw oe bi"><span id="8831" class="mj mk jg lu b gy of og l oh oi">&gt; pyenv version<br/>3.9.7 (set by /Users/jamisonm/.pyenv/version)</span></pre><p id="f9e8" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">鉴于我们已经在上一篇文章中讨论了<a class="ae jd" href="https://markjamison03.medium.com/python-the-system-path-and-how-conda-and-pyenv-manipulate-it-234f8e8bbc3e" rel="noopener">和</a>pyenv实际上是如何查找和设置可执行文件的，我们知道我们在这个实例中使用了<code class="fe lr ls lt lu b">/Users/jamisonm/.pyenv/versions/3.9.7/bin/python</code>作为python可执行文件。那么现在会发生什么呢？</p><p id="91ce" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx jh">找到这个版本的python被执行的位置</strong></p><p id="9788" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因此，操作系统执行python可执行程序，然后被执行的程序向操作系统询问其位置。假设没有打嗝，这将被设置在变量<code class="fe lr ls lt lu b">sys.executable</code> = <code class="fe lr ls lt lu b">/Users/jamisonm/.pyenv/versions/3.9.7/bin/python</code>中。</p><p id="3fc9" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx jh">设置sys.prefix和sys.exec_prefix </strong></p><p id="3516" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">接下来，python设置前缀和exec_prefix，它们看起来通常是相同的。如果我们的<code class="fe lr ls lt lu b">sys.executable</code>变量设置为<code class="fe lr ls lt lu b">/Users/jamisonm/.pyenv/versions/3.9.7/bin/python</code>，那么<code class="fe lr ls lt lu b">sys.prefix</code> = <code class="fe lr ls lt lu b">sys.exec_prefix</code> = <code class="fe lr ls lt lu b">/Users/jamisonm/.pyenv/versions/3.9.7/</code>。然而，如果一个<code class="fe lr ls lt lu b">pyvenv.cfg</code>文件存在于<code class="fe lr ls lt lu b">sys.executable</code>之上的目录中，那么它被读取，并且<code class="fe lr ls lt lu b">sys.prefix</code>和<code class="fe lr ls lt lu b">sys.exec_prefix</code>都被设置到那个目录——这是由<a class="ae jd" href="https://github.com/python/cpython/blob/32f55d1a5de66f9a86964fc0655d7a006a9d90b9/Lib/site.py#L495" rel="noopener ugc nofollow" target="_blank">这个函数控制的，这里是</a>。</p><p id="0b80" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx jh">使用sys.prefix和sys.exec_prefix设置sys . path</strong></p><p id="3708" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">Python现在导入模块<a class="ae jd" href="https://docs.python.org/3/library/site.html#module-site" rel="noopener ugc nofollow" target="_blank">站点</a>并运行其<a class="ae jd" href="https://github.com/python/cpython/blob/32f55d1a5de66f9a86964fc0655d7a006a9d90b9/Lib/site.py#L587" rel="noopener ugc nofollow" target="_blank">主函数</a>。根据文件<a class="ae jd" href="https://docs.python.org/3/library/site.html#module-site" rel="noopener ugc nofollow" target="_blank">这里的</a>，这样做如下:</p><p id="5cf8" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="nw">“它从头部和尾部开始构建多达四个目录。对于head部分，它使用sys.prefix和sys.exec _ prefix跳过空磁头。对于尾部，它使用空字符串，然后是lib/site-packages(在Windows上)或lib/pythonX。Y/site-packages(在Unix和macOS上)。对于每个不同的头尾组合，它会查看它是否引用现有目录，如果是，则将其添加到sys.path中，并检查配置文件的新添加路径。</em></p><p id="dc40" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">实际上，这会将以下内容添加到sys path中:</p><pre class="nx ny nz oa gt ob lu oc od aw oe bi"><span id="07e0" class="mj mk jg lu b gy of og l oh oi">/Users/jamisonm/.pyenv/versions/3.9.7/lib/python39.zip<br/>/Users/jamisonm/.pyenv/versions/3.9.7/lib/python3.9<br/>/Users/jamisonm/.pyenv/versions/3.9.7/lib/python3.9/lib-dynload<br/>/Users/jamisonm/.pyenv/versions/3.9.7/lib/python3.9/site-packages</span></pre><p id="49f0" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">仅此而已。现在我们有了我们的<code class="fe lr ls lt lu b">sys.path</code>变量。就像使用<code class="fe lr ls lt lu b">$PATH</code>和操作系统一样，python从上到下遍历<code class="fe lr ls lt lu b">sys.path</code>变量，寻找匹配的模块和包名，当找到一个匹配的模块和包名时，它就执行那段python代码。与<code class="fe lr ls lt lu b">$PATH</code>的唯一区别是python在遍历<code class="fe lr ls lt lu b">sys.path</code>之前首先检查本地调用目录以寻找匹配的模块(下面将详细介绍)。</p><figure class="nx ny nz oa gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi oj"><img src="../Images/080d5e41e758d96d81328eaa23e0d3b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Tt0oeVC1bCnU9fY6.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">图片来自<a class="ae jd" href="https://xkcd.com/1987/" rel="noopener ugc nofollow" target="_blank">https://xkcd.com/1987/</a></p></figure><h2 id="4263" class="mj mk jg bd ml mm mn dn mo mp mq dp mr le ms mt mu li mv mw mx lm my mz na nb bi translated">什么是“站点包”？</h2><p id="195e" class="pw-post-body-paragraph kv kw jg kx b ky nc kh la lb nd kk ld le ne lg lh li nf lk ll lm ng lo lp lq ij bi translated">这是你从PyPI下载的所有第三方软件包的去处(通过pip，conda，poetics等)。一旦我们以这种方式看待事情，管理一个环境并确保所有依赖关系都在正确的位置的想法就变得非常琐碎。一旦我们有了python可执行文件的正确位置，我们只需确保遵守规则，并将其放入相应的<code class="fe lr ls lt lu b">site-packages</code>文件夹中。当我们在那个环境中键入<code class="fe lr ls lt lu b">python</code>时:</p><ul class=""><li id="c1c9" class="lv lw jg kx b ky kz lb lc le lx li ly lm lz lq ma mb mc md bi translated">操作系统遍历<code class="fe lr ls lt lu b">$PATH</code>变量，找到并执行python的正确版本</li><li id="0a95" class="lv lw jg kx b ky me lb mf le mg li mh lm mi lq ma mb mc md bi translated">然后，操作系统将这个位置交给python可执行文件，并初始化类似于<code class="fe lr ls lt lu b">sys.executable</code>的东西</li><li id="9877" class="lv lw jg kx b ky me lb mf le mg li mh lm mi lq ma mb mc md bi translated">python还基于上面的公式创建了<code class="fe lr ls lt lu b">sys.path</code>变量，指定在相应的<code class="fe lr ls lt lu b">site-packages</code>文件夹中查找包</li></ul><h2 id="26db" class="mj mk jg bd ml mm mn dn mo mp mq dp mr le ms mt mu li mv mw mx lm my mz na nb bi translated">在本地安装一个包怎么样？</h2><p id="0f57" class="pw-post-body-paragraph kv kw jg kx b ky nc kh la lb nd kk ld le ne lg lh li nf lk ll lm ng lo lp lq ij bi translated">如果我们想用特定版本的python和相关的依赖项(我们可以从PyPI中获取)来建立一个环境，上面的方法非常有用。但是那些不在PyPI上的东西呢？或者，如果我们从PyPI中取出一个包并修改它(可能是为了改进它)然后想要使用它呢？</p><p id="d0e6" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">对此，python有另一种解决方案— <strong class="kx jh">。pth文件</strong>。从python文档<a class="ae jd" href="https://docs.python.org/3/library/site.html#module-site" rel="noopener ugc nofollow" target="_blank">这里</a>:</p><p id="1e36" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="nw">“路径配置文件是一个文件，其名称的格式为name.pth，并且存在于上述四个目录之一中；它的内容是要添加到sys.path中的附加项(每行一项)。不存在的项永远不会添加到sys.path中，并且不会检查该项是否引用了目录而不是文件。任何项都不会被多次添加到sys.path中。空行和以#开头的行将被跳过。执行以import(后跟空格或制表符)开头的行。</em></p><p id="7fc4" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因此，为了在本地编写一些代码，并确保当我们在某个地方启动python时，我们可以导入我们需要的代码:</p><ul class=""><li id="3e47" class="lv lw jg kx b ky kz lb lc le lx li ly lm lz lq ma mb mc md bi translated">将代码写在名为<code class="fe lr ls lt lu b">module_name.py</code>的文件中</li><li id="429e" class="lv lw jg kx b ky me lb mf le mg li mh lm mi lq ma mb mc md bi translated">在<code class="fe lr ls lt lu b">sys.path</code>(通常是<code class="fe lr ls lt lu b">site-packages</code>)的某个目录中添加一个名为<code class="fe lr ls lt lu b">module_name.pth</code>的文件，该文件包含我们的模块所在的目录</li></ul><p id="56d9" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx jh">这正是当您运行类似</strong> <code class="fe lr ls lt lu b"><strong class="kx jh">poetry install</strong></code> <strong class="kx jh">或</strong> <code class="fe lr ls lt lu b"><strong class="kx jh">pip install . -e</strong></code>的程序时所发生的事情——一个. pth文件被添加到<code class="fe lr ls lt lu b">site-packages</code>文件夹中，该文件夹将该位置添加到<code class="fe lr ls lt lu b">sys.path</code>变量中。</p><p id="a035" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们用一个测试模块来测试一下。在一个新目录中创建一个名为test的文件夹。在我的主目录中，我们有<code class="fe lr ls lt lu b">mkdir ~/test</code>。然后，我们可以将以下文件添加到名为<code class="fe lr ls lt lu b">datetime.py</code>的目录中(故意命名为与python标准库中的<code class="fe lr ls lt lu b">datetime.py</code>文件冲突)。总而言之，我们有以下几点:</p><pre class="nx ny nz oa gt ob lu oc od aw oe bi"><span id="8a03" class="mj mk jg lu b gy of og l oh oi">&gt; mkdir ~/test<br/>&gt; cd test<br/>&gt; touch datetime.py</span></pre><p id="7390" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然后将以下内容添加到<code class="fe lr ls lt lu b">datetime.py</code>:</p><pre class="nx ny nz oa gt ob lu oc od aw oe bi"><span id="9758" class="mj mk jg lu b gy of og l oh oi">def hello_world():<br/>    print('hello world')<br/>    return</span></pre><p id="0e08" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">最后，我们需要将我们的<code class="fe lr ls lt lu b">test.pth</code>文件添加到我们当前环境的<code class="fe lr ls lt lu b">site-packages</code>目录中。如上所述，使用pyenv(在我使用python版本3.9.7的全局设置中)，我的目录位于<code class="fe lr ls lt lu b">/Users/jamisonm/.pyenv/versions/3.9.7/lib/python3.9/site-packages</code>。然后，我们可以添加以下内容:</p><pre class="nx ny nz oa gt ob lu oc od aw oe bi"><span id="8b0c" class="mj mk jg lu b gy of og l oh oi">&gt; cd /Users/jamisonm/.pyenv/versions/3.9.7/lib/python3.9/site-packages<br/>&gt; echo "/Users/jamisonm/test" &gt; test.pth</span></pre><p id="1a61" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">其中最后一个命令是一个命令行程序，创建一个包含我们想要的目录的文本文件。现在，如果我们启动python并运行sys.path，我们会看到以下内容:</p><pre class="nx ny nz oa gt ob lu oc od aw oe bi"><span id="e0b5" class="mj mk jg lu b gy of og l oh oi">&gt;&gt;&gt; import sys<br/>&gt;&gt;&gt; print('\n'.join(sys.path))<br/>/Users/jamisonm/.pyenv/versions/3.9.7/lib/python39.zip<br/>/Users/jamisonm/.pyenv/versions/3.9.7/lib/python3.9<br/>/Users/jamisonm/.pyenv/versions/3.9.7/lib/python3.9/lib-dynload<br/>/Users/jamisonm/.pyenv/versions/3.9.7/lib/python3.9/site-packages<br/>/Users/jamisonm/test</span></pre><p id="3bd6" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">增加了底部条目。这是因为当python扫描<code class="fe lr ls lt lu b">sys.path</code>中的前4个位置时，它发现了一个<code class="fe lr ls lt lu b">.pth</code>文件(我们创建的<code class="fe lr ls lt lu b">test.pth</code>文件),并相应地将其添加到最后的<code class="fe lr ls lt lu b">sys.path</code>。重要的是，这意味着:</p><ul class=""><li id="9b90" class="lv lw jg kx b ky kz lb lc le lx li ly lm lz lq ma mb mc md bi translated">python将在<code class="fe lr ls lt lu b">/Users/jamisonm/test</code>中查找之前，首先在其他位置搜索匹配的包或模块名</li><li id="f5ec" class="lv lw jg kx b ky me lb mf le mg li mh lm mi lq ma mb mc md bi translated">在此之前，python实际上在当前目录中搜索匹配项</li></ul><p id="ce20" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这意味着，如果我们从<code class="fe lr ls lt lu b">/Users/jamisonm/test</code>开始运行以下命令，我们会看到:</p><pre class="nx ny nz oa gt ob lu oc od aw oe bi"><span id="cc80" class="mj mk jg lu b gy of og l oh oi">import datetime<br/>datetime.date.today()<br/>Traceback (most recent call last):<br/>  File "&lt;stdin&gt;", line 1, in &lt;module&gt;<br/>AttributeError: module 'datetime' has no attribute 'date'</span></pre><p id="0d55" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因为我们在<code class="fe lr ls lt lu b">/Users/jamisonm/test</code>中定义的<code class="fe lr ls lt lu b">datetime.py</code>模块优先于其余的<code class="fe lr ls lt lu b">sys.path</code>——包括在<code class="fe lr ls lt lu b">/Users/jamisonm/.pyenv/versions/3.9.7/lib/python3.9</code>中定义的python标准库模块<code class="fe lr ls lt lu b">datetime.py</code>。但是，如果我们移出<code class="fe lr ls lt lu b">test</code>目录并重复，我们会看到:</p><pre class="nx ny nz oa gt ob lu oc od aw oe bi"><span id="095d" class="mj mk jg lu b gy of og l oh oi">import datetime<br/>datetime.date.today()<br/>datetime.date(2021, 11, 5)<br/>import sys<br/>print('\n'.join(sys.path))<br/>/Users/jamisonm/.pyenv/versions/3.9.7/lib/python39.zip<br/>/Users/jamisonm/.pyenv/versions/3.9.7/lib/python3.9<br/>/Users/jamisonm/.pyenv/versions/3.9.7/lib/python3.9/lib-dynload<br/>/Users/jamisonm/.pyenv/versions/3.9.7/lib/python3.9/site-packages<br/>/Users/jamisonm/test</span></pre><p id="fdb2" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">即python首先找到标准库<code class="fe lr ls lt lu b">datetime.py</code>模块(它包含<code class="fe lr ls lt lu b">datetime.date.today()</code>函数)，即使<code class="fe lr ls lt lu b">/Users/jamisonm/test</code>仍然在我们的<code class="fe lr ls lt lu b">sys.path</code>中。</p><h2 id="84cf" class="mj mk jg bd ml mm mn dn mo mp mq dp mr le ms mt mu li mv mw mx lm my mz na nb bi translated">结论</h2><p id="289d" class="pw-post-body-paragraph kv kw jg kx b ky nc kh la lb nd kk ld le ne lg lh li nf lk ll lm ng lo lp lq ij bi translated">类似于当您通过从上到下遍历您的<code class="fe lr ls lt lu b">$PATH</code>变量来键入<code class="fe lr ls lt lu b">python</code>时，您的操作系统如何确定运行哪个python版本，python创建并搜索模块搜索路径(主要通过创建<code class="fe lr ls lt lu b">sys.path</code>变量)来定位已安装的包，并且如果我们有名称冲突，哪个应该优先。</p><p id="3d65" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">一旦我们以这种方式理解了事情，环境和依赖性管理的主题就变得容易了。通过消除设置这些变量的人工工作，让我们的生活变得更轻松的工具非常有用，但基本过程不一定非常复杂:</p><ul class=""><li id="b71a" class="lv lw jg kx b ky kz lb lc le lx li ly lm lz lq ma mb mc md bi translated">操作系统找到要使用的正确python版本</li><li id="e157" class="lv lw jg kx b ky me lb mf le mg li mh lm mi lq ma mb mc md bi translated">使用这些信息，python定义了<code class="fe lr ls lt lu b">sys.path</code>来创建模块搜索路径</li><li id="2344" class="lv lw jg kx b ky me lb mf le mg li mh lm mi lq ma mb mc md bi translated">。pth文件可以添加到这些位置之一，以将本地模块的位置添加到<a class="ae jd" href="https://docs.python.org/3/tutorial/modules.html#the-module-search-path" rel="noopener ugc nofollow" target="_blank">模块搜索路径</a>的末尾</li></ul><p id="7f5d" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">像conda和pyenv+poem这样的工具就是这样做的——它们通过创建、更改和管理这些python可执行文件、相应的站点包目录和任何其他文件，使我们能够轻松地掌握这些步骤。pth文件添加到它们中以简化本地开发。</p></div></div>    
</body>
</html>