<html>
<head>
<title>Going beyond Binary</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">超越二进制</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/going-beyond-binary-cdb70c18a4a4?source=collection_archive---------29-----------------------#2021-06-12">https://towardsdatascience.com/going-beyond-binary-cdb70c18a4a4?source=collection_archive---------29-----------------------#2021-06-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="7281" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">了解量子计算的世界⚛</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/216983992265486cd8b4a48b091d98bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R9gQ4GmC60iNmuzWzn0jzA.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片由<a class="ae kv" href="https://pixabay.com/users/geralt-9301/?utm_source=link-attribution&amp;amp;utm_medium=referral&amp;amp;utm_campaign=image&amp;amp;utm_content=3871216" rel="noopener ugc nofollow" target="_blank">格特·奥特曼</a>提供，来自<a class="ae kv" href="https://pixabay.com/?utm_source=link-attribution&amp;amp;utm_medium=referral&amp;amp;utm_campaign=image&amp;amp;utm_content=3871216" rel="noopener ugc nofollow" target="_blank"> Pixabay </a></p></figure><h1 id="f84f" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">什么是量子计算？</h1><p id="cb4e" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">让我们考虑一台经典的计算机，它的每一位都处于两种状态之一，T0或T1，通常被认为是T2或T3。一个<em class="mk">量子</em>比特，更好的说法是一个<strong class="lq ir"> <em class="mk">量子比特</em> </strong>，相当于量子计算机。量子位具有一些非常独特和有趣的性质，这使得量子计算成为计算机中最有趣的领域之一。</p><h2 id="c8a3" class="mp kx iq bd ky mq mr dn lc ms mt dp lg lx mu mv li mb mw mx lk mf my mz lm na bi translated">叠加</h2><p id="b0fb" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">与比特不同，量子比特可以处于<code class="fe ml mm mn mo b">1</code>或<code class="fe ml mm mn mo b">0</code>或<em class="mk">的状态，在</em>之间的任何地方🤯！很疯狂，不是吗？这是由于被称为<strong class="lq ir"> <em class="mk">叠加</em> </strong>的量子粒子的能力，其中这些粒子不是具有单个<em class="mk">定义的</em>状态，比如1或0，而是具有成为<code class="fe ml mm mn mo b">1</code>或<code class="fe ml mm mn mo b">0</code>的<strong class="lq ir"><em class="mk"/></strong>。</p><p id="b89b" class="pw-post-body-paragraph lo lp iq lq b lr nb jr lt lu nc ju lw lx nd lz ma mb ne md me mf nf mh mi mj ij bi translated">当一个量子位处于叠加态时，测量它的值，然后<strong class="lq ir"> <em class="mk">将量子位从它的无限可能状态</em> </strong>坍缩到众所周知的状态<code class="fe ml mm mn mo b">0</code>和<code class="fe ml mm mn mo b">1</code>。然后，它保持在该状态，直到复位。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/2af58e16eecab487e86cc1d080bb579f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1210/format:webp/0*NsXymaMHPUWwAzhR.jpg"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://www.blogger.com/profile/03712859045968965104" rel="noopener ugc nofollow" target="_blank"> MuonRay </a>来自<a class="ae kv" href="http://muonray.blogspot.com/2014/09/overview-of-quantum-entanglement.html" rel="noopener ugc nofollow" target="_blank">博客</a></p></figure><h2 id="0785" class="mp kx iq bd ky mq mr dn lc ms mt dp lg lx mu mv li mb mw mx lk mf my mz lm na bi translated">纠缠</h2><p id="cac8" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">可以说，量子计算最有趣的现象是两个或更多的量子比特能够成为相互纠缠的<strong class="lq ir"><em class="mk"/></strong>。</p><p id="451d" class="pw-post-body-paragraph lo lp iq lq b lr nb jr lt lu nc ju lw lx nd lz ma mb ne md me mf nf mh mi mj ij bi translated">在这样的系统中，任何一个纠缠粒子的状态都不能独立于其他粒子的量子状态来描述。这意味着无论您对一个粒子应用什么操作或过程，都会与其他粒子相关联。例如，如果你测量一个粒子并坍缩，那么其他粒子也会坍缩。</p><blockquote class="nh ni nj"><p id="8488" class="lo lp mk lq b lr nb jr lt lu nc ju lw nk nd lz ma nl ne md me nm nf mh mi mj ij bi translated">好吧，所以它们是基于概率的。但是我们能改变这些概率吗？</p></blockquote><p id="8bd1" class="pw-post-body-paragraph lo lp iq lq b lr nb jr lt lu nc ju lw lx nd lz ma mb ne md me mf nf mh mi mj ij bi translated">是啊！它遵循一个叫做<strong class="lq ir"> <em class="mk">的量子干涉过程。</em> </strong></p><h2 id="b803" class="mp kx iq bd ky mq mr dn lc ms mt dp lg lx mu mv li mb mw mx lk mf my mz lm na bi translated">量子干涉</h2><p id="9e63" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">量子位元以这种或那种方式坍缩(即坍缩为0或1)的可能性是由量子干涉决定的。干涉会影响一个量子位的状态，从而影响测量过程中某个结果的概率，而这个概率状态正是量子计算的强大之处。</p><blockquote class="nh ni nj"><p id="102c" class="lo lp mk lq b lr nb jr lt lu nc ju lw nk nd lz ma nl ne md me nm nf mh mi mj ij bi translated">所以我有点掌握它的窍门了…但是我实际上是如何编码的呢？我需要量子计算机吗？</p></blockquote><p id="1cea" class="pw-post-body-paragraph lo lp iq lq b lr nb jr lt lu nc ju lw lx nd lz ma mb ne md me mf nf mh mi mj ij bi translated">一点也不！微软发布了一个<a class="ae kv" href="https://docs.microsoft.com/en-us/azure/quantum/overview-what-is-qsharp-and-qdk" rel="noopener ugc nofollow" target="_blank"> <strong class="lq ir"> <em class="mk">量子开发套件</em> </strong> <em class="mk"> (QDK) </em> </a>，这是一套工具，允许我们<em class="mk">在我们的桌面上模拟量子环境</em>！</p><h1 id="1702" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">量子环境中的编码</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nn"><img src="../Images/d7daa5363ab4f86e29c9d23fae32e7fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TDyt73iwAwodOEP13cqftQ.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://www.pexels.com/@luis-gomes-166706?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">路易斯·戈麦斯</a>从<a class="ae kv" href="https://www.pexels.com/photo/black-and-gray-laptop-computer-546819/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"> Pexels </a>拍摄</p></figure><p id="ef89" class="pw-post-body-paragraph lo lp iq lq b lr nb jr lt lu nc ju lw lx nd lz ma mb ne md me mf nf mh mi mj ij bi translated">虽然我们通常需要下载QDK进行开发，但在Jupyter环境中测试是最容易的，微软为此专门发布了一个IPython内核。</p><p id="f18a" class="pw-post-body-paragraph lo lp iq lq b lr nb jr lt lu nc ju lw lx nd lz ma mb ne md me mf nf mh mi mj ij bi translated">虽然这里也解释了所有的Jupyter代码，但我鼓励你去<a class="ae kv" href="https://deepnote.com/project/Quantum-Computing-Q-YrKZTUadQuCIe1GiyZG24A/%2FQuantumComputing%2FQuantumComputing.ipynb" rel="noopener ugc nofollow" target="_blank"> <strong class="lq ir"> <em class="mk">这个DeepNote项目</em> </strong> </a>，复制它并运行它，因为它包含额外的注释和代码练习。解决了这个问题，让我们开始吧。</p><h2 id="847b" class="mp kx iq bd ky mq mr dn lc ms mt dp lg lx mu mv li mb mw mx lk mf my mz lm na bi translated">QSharp基础知识</h2><p id="b5db" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">在一篇文章中解释完整的Q#语言超出了我的能力范围，但是，让我们看看一般的语法来了解这种语言。</p><p id="31be" class="pw-post-body-paragraph lo lp iq lq b lr nb jr lt lu nc ju lw lx nd lz ma mb ne md me mf nf mh mi mj ij bi translated">在下面的代码块中，使用<code class="fe ml mm mn mo b">open</code>命令，一些依赖项被导入到文件中。遵循的命名约定非常类似于C#。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">这些用于整个Jupyter笔记本</p></figure><p id="1696" class="pw-post-body-paragraph lo lp iq lq b lr nb jr lt lu nc ju lw lx nd lz ma mb ne md me mf nf mh mi mj ij bi translated">现在我们可以看看在Q#中创建函数和变量的语法。在Q#中，变量是不可变的，这意味着在初始化之后，它们不能被重新赋值，除非被指定为可变的。创建它们的语法类似于您在javaScript中看到的，使用了<code class="fe ml mm mn mo b">let</code>关键字。</p><pre class="kg kh ki kj gt nq mo nr ns aw nt bi"><span id="c76b" class="mp kx iq mo b gy nu nv l nw nx">let varName = varValue;</span></pre><p id="97df" class="pw-post-body-paragraph lo lp iq lq b lr nb jr lt lu nc ju lw lx nd lz ma mb ne md me mf nf mh mi mj ij bi translated">注意，变量的数据类型不是在初始化时指定的，而是从给定的<code class="fe ml mm mn mo b">varValue</code>中自动推断出来的。</p><p id="bc30" class="pw-post-body-paragraph lo lp iq lq b lr nb jr lt lu nc ju lw lx nd lz ma mb ne md me mf nf mh mi mj ij bi translated">可变变量(值<em class="mk">可以</em>改变的变量)可以使用<code class="fe ml mm mn mo b">mutable</code>关键字初始化，并使用<code class="fe ml mm mn mo b">set</code>关键字重新赋值。</p><pre class="kg kh ki kj gt nq mo nr ns aw nt bi"><span id="59bb" class="mp kx iq mo b gy nu nv l nw nx">mutable varName = varValue;<br/>set varName = anotherValue;</span></pre><p id="49ac" class="pw-post-body-paragraph lo lp iq lq b lr nb jr lt lu nc ju lw lx nd lz ma mb ne md me mf nf mh mi mj ij bi translated">另一个重要的Q#特性是操作，它相当于其他语言中的函数。操作将特定的数据类型作为输入来返回输出。操作的语法是~</p><pre class="kg kh ki kj gt nq mo nr ns aw nt bi"><span id="00a3" class="mp kx iq mo b gy nu nv l nw nx">operation OpName(input1: DType, input2: DType): ReturnDType {<br/>    // body of the operation<br/>    return retVal;<br/>}</span></pre><blockquote class="nh ni nj"><p id="9034" class="lo lp mk lq b lr nb jr lt lu nc ju lw nk nd lz ma nl ne md me nm nf mh mi mj ij bi translated">注意，没有返回值的函数的<code class="fe ml mm mn mo b">ReturnDType</code>是<code class="fe ml mm mn mo b">Unit</code>，相当于C#或C/C++中的<code class="fe ml mm mn mo b">void</code>。要了解更多关于Q#数据类型的信息，请查阅微软官方文档。</p></blockquote><p id="40d1" class="pw-post-body-paragraph lo lp iq lq b lr nb jr lt lu nc ju lw lx nd lz ma mb ne md me mf nf mh mi mj ij bi translated">下面是一个基本Hello World操作的代码，使用Q#中的<code class="fe ml mm mn mo b"><a class="ae kv" href="https://docs.microsoft.com/en-us/qsharp/api/qsharp/microsoft.quantum.intrinsic.message" rel="noopener ugc nofollow" target="_blank">Message</a></code>函数，它大致相当于Python中的<code class="fe ml mm mn mo b">print</code>、C#中的<code class="fe ml mm mn mo b">Console.Write</code>和C++中的<code class="fe ml mm mn mo b">std::cout</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny np l"/></div></figure><p id="8086" class="pw-post-body-paragraph lo lp iq lq b lr nb jr lt lu nc ju lw lx nd lz ma mb ne md me mf nf mh mi mj ij bi translated">由于Q#是一种运行在量子计算机上的语言，执行操作的方式有点不同。我们不是直接执行，而是运行一个IPYNB magic命令— <code class="fe ml mm mn mo b"><a class="ae kv" href="https://docs.microsoft.com/en-us/qsharp/api/iqsharp-magic/simulate" rel="noopener ugc nofollow" target="_blank">%simulate</a></code>，后跟模拟操作的名称。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz np l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">该消息打印在标准输出中</p></figure><p id="2751" class="pw-post-body-paragraph lo lp iq lq b lr nb jr lt lu nc ju lw lx nd lz ma mb ne md me mf nf mh mi mj ij bi translated">Q#支持基本的数据类型<code class="fe ml mm mn mo b">Int</code>、<code class="fe ml mm mn mo b">Float</code>等等，以及它们上面的操作符。下面是Q#中的一个基本加法函数。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oa np l"/></div></figure><p id="7e34" class="pw-post-body-paragraph lo lp iq lq b lr nb jr lt lu nc ju lw lx nd lz ma mb ne md me mf nf mh mi mj ij bi translated">为了模拟我们的操作，我们需要在操作名称后输入<code class="fe ml mm mn mo b">key=value</code>格式的参数，如下所示。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ob np l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">3 + 5 = 8，对吗？</p></figure><h2 id="8fb7" class="mp kx iq bd ky mq mr dn lc ms mt dp lg lx mu mv li mb mw mx lk mf my mz lm na bi translated">Q#中的量子测量</h2><p id="1cdd" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">如上所述，量子位(更好的说法是量子位)是量子计算机的基本存储单位。这里有一个程序分配一个量子位并返回它的测量值。<br/>返回Q#中一个量子位的测量值的函数是<a class="ae kv" href="https://docs.microsoft.com/en-us/qsharp/api/qsharp/microsoft.quantum.intrinsic.m" rel="noopener ugc nofollow" target="_blank"> M操作</a> <code class="fe ml mm mn mo b"><a class="ae kv" href="https://docs.microsoft.com/en-us/qsharp/api/qsharp/microsoft.quantum.intrinsic.m" rel="noopener ugc nofollow" target="_blank">M(Qubit) =&gt; Result</a></code>，其中<code class="fe ml mm mn mo b">Result</code>是一个内置的数据类型，它给出了<code class="fe ml mm mn mo b">One</code>或<code class="fe ml mm mn mo b">Zero</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oc np l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">用于创建和测量量子位的代码</p></figure><p id="c824" class="pw-post-body-paragraph lo lp iq lq b lr nb jr lt lu nc ju lw lx nd lz ma mb ne md me mf nf mh mi mj ij bi translated">运行这个程序给了我们<code class="fe ml mm mn mo b">0</code>的输出，因为量子位在分配后<em class="mk">总是</em>处于零的初始化状态。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ob np l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">初始化的量子位总是具有0的测量值</p></figure><h2 id="7fde" class="mp kx iq bd ky mq mr dn lc ms mt dp lg lx mu mv li mb mw mx lk mf my mz lm na bi translated">Q#中的叠加</h2><p id="d927" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">叠加态是量子粒子的唯一状态，其值是无限概率的组合。<br/>回想一下，在叠加态下测量一个量子位会将它折叠成两个二进制值中的一个。<br/>一个特殊的<em class="mk">量子比特门</em>将一个量子粒子置于叠加态，在Q#中，就是<a class="ae kv" href="https://docs.microsoft.com/en-us/qsharp/api/qsharp/microsoft.quantum.intrinsic.h" rel="noopener ugc nofollow" target="_blank"> H(哈达玛的简称)</a> <code class="fe ml mm mn mo b"><a class="ae kv" href="https://docs.microsoft.com/en-us/qsharp/api/qsharp/microsoft.quantum.intrinsic.h" rel="noopener ugc nofollow" target="_blank">H(Qubit) =&gt; Unit</a></code>。</p><blockquote class="nh ni nj"><p id="052a" class="lo lp mk lq b lr nb jr lt lu nc ju lw nk nd lz ma nl ne md me nm nf mh mi mj ij bi translated">注意，H变换返回<code class="fe ml mm mn mo b">Unit</code>，因为它只是就地改变量子位的状态。</p></blockquote><h2 id="23b8" class="mp kx iq bd ky mq mr dn lc ms mt dp lg lx mu mv li mb mw mx lk mf my mz lm na bi translated">随机数发生器</h2><p id="78ff" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">这意味着我们可以用量子位制造一个<a class="ae kv" href="https://en.wikipedia.org/wiki/Random_number_generation" rel="noopener ugc nofollow" target="_blank">真随机数发生器(RNG) </a>！这里面的步骤会是~</p><ul class=""><li id="1709" class="od oe iq lq b lr nb lu nc lx of mb og mf oh mj oi oj ok ol bi translated">分配量子位</li><li id="03b3" class="od oe iq lq b lr om lu on lx oo mb op mf oq mj oi oj ok ol bi translated">将量子位叠加</li><li id="d25c" class="od oe iq lq b lr om lu on lx oo mb op mf oq mj oi oj ok ol bi translated">测量量子位并返回其值。</li></ul><blockquote class="nh ni nj"><p id="0593" class="lo lp mk lq b lr nb jr lt lu nc ju lw nk nd lz ma nl ne md me nm nf mh mi mj ij bi translated">请注意，为了能够重复使用，量子位需要在每次测量后重置。为此，我们使用测量和复位的组合操作，即<code class="fe ml mm mn mo b"><a class="ae kv" href="https://docs.microsoft.com/en-us/qsharp/api/qsharp/microsoft.quantum.measurement.mresetz" rel="noopener ugc nofollow" target="_blank">MResetZ</a></code>。</p><p id="ce61" class="lo lp mk lq b lr nb jr lt lu nc ju lw nk nd lz ma nl ne md me nm nf mh mi mj ij bi translated">此外，我还创建了一个助手函数<code class="fe ml mm mn mo b">RunNTimes</code>，它将任意一个函数<code class="fe ml mm mn mo b">Unit =&gt; Result</code>和一个数字<code class="fe ml mm mn mo b">n</code>作为输入，并运行该函数n次。</p></blockquote><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="or np l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">用于创建一位数随机数生成器的代码</p></figure><p id="6145" class="pw-post-body-paragraph lo lp iq lq b lr nb jr lt lu nc ju lw lx nd lz ma mb ne md me mf nf mh mi mj ij bi translated">用<code class="fe ml mm mn mo b">n = 100</code>运行<code class="fe ml mm mn mo b">nQRNG</code>,得到如下结果~</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="os np l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">我们得到几乎等量的1和0，证实了随机性</p></figure><h1 id="3ab2" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">结论</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nn"><img src="../Images/7c34f99b903f15e4cc1147220b9f8036.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9PYoh5U6Z_C2DIwZH9bPvg.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://www.pexels.com/@ana-arantes-1457565?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">安娜·阿兰特斯</a>从<a class="ae kv" href="https://www.pexels.com/photo/photo-of-end-signage-3006228/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">派克斯</a>拍摄</p></figure><p id="5b71" class="pw-post-body-paragraph lo lp iq lq b lr nb jr lt lu nc ju lw lx nd lz ma mb ne md me mf nf mh mi mj ij bi translated">我们完了！本教程的目的是以一种不需要任何数学资格的方式唤起人们对量子计算的兴趣，此外还为读者提供了使用Q#和QDK迈出量子计算第一步的工具。如果你还没有<strong class="lq ir"> <em class="mk">我真的鼓励你</em> </strong> <a class="ae kv" href="https://deepnote.com/project/Quantum-Computing-Q-YrKZTUadQuCIe1GiyZG24A/%2FQuantumComputing%2FQuantumComputing.ipynb" rel="noopener ugc nofollow" target="_blank"> <strong class="lq ir"> <em class="mk">看看这里的Jupyter笔记本</em> </strong> </a>因为那会给你一些Q#的实践经验。</p><p id="5a82" class="pw-post-body-paragraph lo lp iq lq b lr nb jr lt lu nc ju lw lx nd lz ma mb ne md me mf nf mh mi mj ij bi translated">为了继续你的量子计算专业知识之旅，我鼓励你查阅微软文档中的以下资源。</p><p id="278f" class="pw-post-body-paragraph lo lp iq lq b lr nb jr lt lu nc ju lw lx nd lz ma mb ne md me mf nf mh mi mj ij bi translated">学习数学的工具</p><ul class=""><li id="0e2c" class="od oe iq lq b lr nb lu nc lx of mb og mf oh mj oi oj ok ol bi translated"><a class="ae kv" href="https://docs.microsoft.com/en-us/azure/quantum/overview-algebra-for-quantum-computing" rel="noopener ugc nofollow" target="_blank">用于量子计算的线性代数</a></li><li id="5977" class="od oe iq lq b lr om lu on lx oo mb op mf oq mj oi oj ok ol bi translated"><a class="ae kv" href="https://docs.microsoft.com/en-us/azure/quantum/concepts-vectors-and-matrices" rel="noopener ugc nofollow" target="_blank">向量和矩阵</a></li><li id="e5fa" class="od oe iq lq b lr om lu on lx oo mb op mf oq mj oi oj ok ol bi translated"><a class="ae kv" href="https://docs.microsoft.com/en-us/azure/quantum/concepts-the-qubit" rel="noopener ugc nofollow" target="_blank">量子位</a></li></ul><p id="c0cd" class="pw-post-body-paragraph lo lp iq lq b lr nb jr lt lu nc ju lw lx nd lz ma mb ne md me mf nf mh mi mj ij bi translated">此外,<a class="ae kv" href="https://github.com/microsoft/QuantumKatas" rel="noopener ugc nofollow" target="_blank">量子卡式</a>是开始Q#和量子计算之旅的绝佳方式。</p><p id="116a" class="pw-post-body-paragraph lo lp iq lq b lr nb jr lt lu nc ju lw lx nd lz ma mb ne md me mf nf mh mi mj ij bi translated">你可以通过<a class="ae kv" href="https://www.linkedin.com/in/dweep-joshipura/" rel="noopener ugc nofollow" target="_blank"> Linkedin </a>、<a class="ae kv" href="mailto:dweepjoshipuracar@gmail.com" rel="noopener ugc nofollow" target="_blank"> Email </a>或<a class="ae kv" href="https://github.com/djthegr8" rel="noopener ugc nofollow" target="_blank"> Github </a>联系我！</p><p id="f48d" class="pw-post-body-paragraph lo lp iq lq b lr nb jr lt lu nc ju lw lx nd lz ma mb ne md me mf nf mh mi mj ij bi translated">我希望你喜欢这个教程，并拥有美好的一天！ </p></div></div>    
</body>
</html>