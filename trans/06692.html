<html>
<head>
<title>Data Engineers Shouldn’t Write Airflow Dags — Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数据工程师不应该写气流图——第二部分</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/data-engineers-shouldnt-write-airflow-dags-part-2-8dee642493fb?source=collection_archive---------8-----------------------#2021-06-16">https://towardsdatascience.com/data-engineers-shouldnt-write-airflow-dags-part-2-8dee642493fb?source=collection_archive---------8-----------------------#2021-06-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="24de" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">阿帕奇气流的框架建议</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/20f111f69393d0830b1a6579d4474831.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*twFJpk1_-yqGwIsa"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">理查德·霍瓦特在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="7d59" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是关于为什么<strong class="lb iu">数据工程师不应该写气流Dag</strong>的第二篇文章。在这篇新文章中，我们将介绍一个针对Apache气流的框架  <strong class="lb iu">提案</strong><strong class="lb iu">。</strong></p><p id="1381" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本文旨在阐明构建框架如何帮助您解决一些与DAG编写相关的问题。</p><p id="1348" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇新文章中，我将对第一部分做一个简短的回顾。所以，没必要看。尽管如此，如果你想对我在这一篇中要阐述的东西有更详细的解释，你应该考虑读一读。</p><div class="lv lw gp gr lx ly"><a rel="noopener follow" target="_blank" href="/data-engineers-shouldnt-write-airflow-dags-b885d57737ce"><div class="lz ab fo"><div class="ma ab mb cl cj mc"><h2 class="bd iu gy z fp md fr fs me fu fw is bi translated">数据工程师不应该写气流图——第1部分</h2><div class="mf l"><p class="bd b dl z fp md fr fs me fu fw dk translated">towardsdatascience.com</p></div></div><div class="mg l"><div class="mh l mi mj mk mg ml ks ly"/></div></div></a></div></div><div class="ab cl mm mn hx mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="im in io ip iq"><h1 id="83fe" class="mt mu it bd mv mw mx my mz na nb nc nd jz ne ka nf kc ng kd nh kf ni kg nj nk bi translated">为什么数据工程师不应该写Dag</h1><p id="8046" class="pw-post-body-paragraph kz la it lb b lc nl ju le lf nm jx lh li nn lk ll lm no lo lp lq np ls lt lu im bi translated">正如我在第一篇文章中提到的，数据工程师的工作不是编写ETL。数据工程师的工作是<strong class="lb iu">编写可靠的、可伸缩的、可维护的代码</strong>。</p><p id="e31f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">数据工程师不应该为了写Dag而写Dag。如果数据工程师专注于概括和抽象事物，而不是编写简单的Dag，他们的技能可以得到更好的利用。</p><p id="c42c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">DAG写入有两个主要问题:</p><ul class=""><li id="f1da" class="nq nr it lb b lc ld lf lg li ns lm nt lq nu lu nv nw nx ny bi translated">这是一个重复的过程。违反了<a class="ae ky" href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself" rel="noopener ugc nofollow" target="_blank">干</a> ( <em class="nz">不重复自己</em>)的原则。如果处理不当，最终会产生大量重复且不可维护的代码。</li><li id="0c13" class="nq nr it lb b lc oa lf ob li oc lm od lq oe lu nv nw nx ny bi translated">对于那些没有专业知识的人来说，这可能很难做到。当这种情况发生时，数据工程师就成了为其他人写Dag的人。这不一定是坏事，但我们可以做得更好。</li></ul><p id="6465" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我相信你可以遵循几个原则来缓解这两个主要问题:</p><ul class=""><li id="7d11" class="nq nr it lb b lc ld lf lg li ns lm nt lq nu lu nv nw nx ny bi translated">尽可能使用<a class="ae ky" href="https://www.astronomer.io/guides/dynamically-generating-dags" rel="noopener ugc nofollow" target="_blank">动态Dag</a>来生成你的Dag。坚持干原则是个好办法。</li><li id="874c" class="nq nr it lb b lc oa lf ob li oc lm od lq oe lu nv nw nx ny bi translated">通过使用面向对象编程(OOP)和设计模式来改进您生成动态Dag的方式。如果处理得当，它可以提高代码的可维护性。</li><li id="5061" class="nq nr it lb b lc oa lf ob li oc lm od lq oe lu nv nw nx ny bi translated">构建允许人们与他们的Dag交互的界面。作为一名数据工程师，你的工作不是为别人写Dag。你的工作是授权给人们，让他们可以写自己的Dag并与他们互动。</li></ul><p id="627b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些原则帮助我们解决了上述问题。我们用它们建立了一个处于早期阶段的框架。但是，它被证明是有用的。</p><p id="3573" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下一节中，我们将介绍我们的框架提案，称为<strong class="lb iu"> <em class="nz"> Castor </em> </strong> <em class="nz"> — </em>，在西班牙语中代表<em class="nz"> beaver </em>。我们希望这个框架能够为我们如何更好地使用Apache Airflow提供一些启示。</p><p id="1be7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该框架允许使用<strong class="lb iu">一种更为</strong> <a class="ae ky" href="https://www.thoughtworks.com/radar/techniques/declarative-data-pipeline-definition" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">的声明性</strong> </a> <strong class="lb iu">方法</strong>来定义数据管道。而不是由DAG编写强制执行的命令式方法。我们相信<strong class="lb iu">声明式数据管道是数据管道的未来。</strong></p></div><div class="ab cl mm mn hx mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="im in io ip iq"><h1 id="482e" class="mt mu it bd mv mw mx my mz na nb nc nd jz ne ka nf kc ng kd nh kf ni kg nj nk bi translated">castor:Apache气流的框架提案</h1><p id="b2e4" class="pw-post-body-paragraph kz la it lb b lc nl ju le lf nm jx lh li nn lk ll lm no lo lp lq np ls lt lu im bi translated">想象一下，编写DAG就像编写一个简单的配置文件一样简单。该配置文件将为您做一切。你只需要指定你想做的事情，剩下的事情会由其他的事情来处理。</p><p id="056a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是我们在编写框架时试图实现的目标，<em class="nz"> Castor </em>。我们希望简化DAG的编写，这样就像编写配置文件一样简单。但是，我们也想解决这两篇文章中已经提到的问题。</p><p id="6620" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为此，我们结合了动态Dag、OOP和软件设计模式，并构建了<em class="nz"> Castor </em>。我们通过构建和使用该框架获得的一些好处是:</p><ul class=""><li id="7f24" class="nq nr it lb b lc ld lf lg li ns lm nt lq nu lu nv nw nx ny bi translated">它帮助我们标准化了使用Dag的方式。因此，团队中的每个人都在同一页上。因为每个人都知道框架，所以移交很容易完成。当你不得不把一个进程交给别人的时候，你传递配置文件，就是这样。配置文件比DAG代码更容易阅读和理解。</li><li id="1d7f" class="nq nr it lb b lc oa lf ob li oc lm od lq oe lu nv nw nx ny bi translated">几乎所有的Dag都是由相同的代码行生成的。因此，如果我们想引入一个变化，我们在一个文件中做，这适用于项目的其余部分。我们不必在10或20个文件中做同样的更改。</li><li id="0071" class="nq nr it lb b lc oa lf ob li oc lm od lq oe lu nv nw nx ny bi translated">我们使用设计模式来获得某种程度的代码解耦，这让我们感到安全。引入新功能现在更容易了。就像贬低他们一样。</li><li id="7519" class="nq nr it lb b lc oa lf ob li oc lm od lq oe lu nv nw nx ny bi translated">因为编写DAG就像编写配置文件一样简单，所以几乎任何人都可以做到。通过这种方式，我们使数据分析师和数据科学家能够编写他们自己的Dag，而不必沾染Airflow编程风格。</li></ul><p id="05d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的框架包括5个组件:<em class="nz">配置文件、DAG工厂、任务创建器、任务策略和操作符工厂</em>。</p><h2 id="a220" class="of mu it bd mv og oh dn mz oi oj dp nd li ok ol nf lm om on nh lq oo op nj oq bi translated">配置文件</h2><p id="e01c" class="pw-post-body-paragraph kz la it lb b lc nl ju le lf nm jx lh li nn lk ll lm no lo lp lq np ls lt lu im bi translated">配置文件是生成Dag的方式。你基本上指定你想在你的DAG中是什么，就是这样。</p><p id="25ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以一个有5个任务的简单DAG为例。这两个任务中的两个是<a class="ae ky" href="https://airflow.apache.org/docs/apache-airflow/stable/_api/airflow/operators/dummy/index.html" rel="noopener ugc nofollow" target="_blank">虚拟操作员</a>用<em class="nz">开始</em>任务和<em class="nz">结束</em>任务使DAG看起来漂亮。其他3个任务就是<a class="ae ky" href="https://airflow.apache.org/docs/apache-airflow/stable/_modules/airflow/operators/python.html#PythonOperator" rel="noopener ugc nofollow" target="_blank"> PythonOperators </a>做你想做的任何事情——数据提取、数据转换等等。这是它在Airflow UI上的样子。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi or"><img src="../Images/7e5422f4961a27e0421510e6195059f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:756/format:webp/1*IK2NIuCiFDdQj7MgkVBS2Q.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来自Airflow UI的DAG示例—作者制作的插图。</p></figure><p id="354f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您想采用传统的方法，您可以为DAG编写代码，仅此而已。但是，如果您使用更具声明性的方法，这就是使用YAML配置文件的样子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="os ot l"/></div></figure><p id="7e6f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接口获取配置文件，并将其传递给框架的其他<em class="nz">组件</em>。此类组件根据您的请求获取文件并构建DAG。</p><h2 id="994a" class="of mu it bd mv og oh dn mz oi oj dp nd li ok ol nf lm om on nh lq oo op nj oq bi translated">达格工厂</h2><p id="b891" class="pw-post-body-paragraph kz la it lb b lc nl ju le lf nm jx lh li nn lk ll lm no lo lp lq np ls lt lu im bi translated">DAG工厂只是<a class="ae ky" href="https://en.wikipedia.org/wiki/Factory_method_pattern" rel="noopener ugc nofollow" target="_blank">工厂方法模式</a>的一个实现。</p><p id="4529" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">DAG工厂的责任不仅仅是创建DAG。但是，要确保Dag的<em class="nz">任务</em>是根据配置文件中声明的依赖关系正确创建的。为此，它使用了<strong class="lb iu"> <em class="nz">任务创建器</em> </strong>。</p><p id="edbf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">代码看起来是这样的</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="os ot l"/></div></figure><h2 id="cea0" class="of mu it bd mv og oh dn mz oi oj dp nd li ok ol nf lm om on nh lq oo op nj oq bi translated">任务创建者和任务策略</h2><p id="6f9c" class="pw-post-body-paragraph kz la it lb b lc nl ju le lf nm jx lh li nn lk ll lm no lo lp lq np ls lt lu im bi translated">这是魔法开始的地方。任务创建者和任务策略是<a class="ae ky" href="https://en.wikipedia.org/wiki/Strategy_pattern" rel="noopener ugc nofollow" target="_blank">策略模式</a>的实现。</p><p id="d927" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你对<em class="nz">策略模式</em>一无所知，这里有它的UML图。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ou"><img src="../Images/168c544678c7ce8127f841d899869b5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IplKzrBH7VV4EZLgoXj44Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">战略模式UML图—作者基于[ <a class="ae ky" href="https://refactoring.guru/design-patterns/strategy" rel="noopener ugc nofollow" target="_blank"> 1 </a> ]所做的图解</p></figure><p id="809a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">基本上，你有一个接口(<em class="nz">策略</em>)来声明子类应该实现什么。然后，一个<em class="nz">上下文</em>类通过接口与这些子类进行交互。</p><p id="74c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个有趣的模式，因为您用组合代替了继承。此外，它遵循<a class="ae ky" href="https://en.wikipedia.org/wiki/Open%E2%80%93closed_principle" rel="noopener ugc nofollow" target="_blank">开闭原理</a>。因此，你可以添加新的策略，而不必改变<em class="nz">的背景。</em>如果你想了解更多关于这个图案的信息，请查看<a class="ae ky" href="https://refactoring.guru/design-patterns/strategy" rel="noopener ugc nofollow" target="_blank">这个</a>以获取更多信息。</p><p id="bc12" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<em class="nz"> Castor </em>的上下文中，我们使用策略模式来创建任务。创建气流任务的方法之一是使用气流操作符。所以，按照这种模式，你基本上有尽可能多的策略<em class="nz">和你想使用的操作符</em>。</p><p id="69d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们只实现了两个策略:python operator strategy<strong class="lb iu"><em class="nz"/></strong>和dummy operator strategy<em class="nz"/>。这就是UML图的样子。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ou"><img src="../Images/0939f0d65bda0c95d0ce6f24911b40d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*30M_oY7fwj-18jvGuRdmog.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">策略模式的Castor实现——作者举例说明</p></figure><p id="fcc5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里的要点是<strong class="lb iu">你应该</strong> <strong class="lb iu">编码你想使用的策略，然后忘记它们。</strong>你不必在生活中手动创建另一个气流任务。</p><h2 id="43ab" class="of mu it bd mv og oh dn mz oi oj dp nd li ok ol nf lm om on nh lq oo op nj oq bi translated">操作员工厂</h2><p id="ba89" class="pw-post-body-paragraph kz la it lb b lc nl ju le lf nm jx lh li nn lk ll lm no lo lp lq np ls lt lu im bi translated">最后，我们有操作符工厂。这是工厂方法模式的另一个实现。我个人喜欢Operator Factory，因为在从Airflow 1.10迁移到2.0的过程中，我没有一个这样的工厂。</p><p id="a9d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">很简单。如果你在你的项目中到处使用气流操作符，如果操作符改变了，你注定要对项目做很多改变。</p><p id="1d47" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我告诉你它看起来怎么样，因为我们已经做到了。我们的项目中有很多使用KubertenesPodOperators的文件。假设有10到20个文件。</p><p id="29ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们迁移到2.0之后，我们意识到KubernetesPodOperator发生了变化。以下是一些改变了的东西:</p><ul class=""><li id="f87a" class="nq nr it lb b lc ld lf lg li ns lm nt lq nu lu nv nw nx ny bi translated"><strong class="lb iu">端口已经从列表[Port]迁移到列表[V1ContainerPort] </strong></li><li id="b481" class="nq nr it lb b lc oa lf ob li oc lm od lq oe lu nv nw nx ny bi translated"><strong class="lb iu"> env_vars已从字典迁移到列表[V1EnvVar] </strong></li><li id="ed04" class="nq nr it lb b lc oa lf ob li oc lm od lq oe lu nv nw nx ny bi translated"><strong class="lb iu">资源已经从Dict迁移到V1ResourceRequirements </strong></li><li id="ab24" class="nq nr it lb b lc oa lf ob li oc lm od lq oe lu nv nw nx ny bi translated"><strong class="lb iu">资源已经从Dict迁移到V1ResourceRequirements </strong></li><li id="c1b1" class="nq nr it lb b lc oa lf ob li oc lm od lq oe lu nv nw nx ny bi translated">…点击此处查看变更的完整列表<a class="ae ky" href="https://airflow.apache.org/docs/apache-airflow/2.0.0/upgrading-to-2.html#changed-parameters-for-the-kubernetespodoperator" rel="noopener ugc nofollow" target="_blank"/></li></ul><p id="ef2e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">迁移之后，一切都失败了。几个小时后，我们意识到这个问题与引入到KubernetesPodOperator中的变化有关。所以，我们修好了。但是，我们必须对使用KubernetesPodOperator的20个文件进行同样的修改。</p><p id="73cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这时我们意识到我们应该实现一个操作符工厂。我们将所有与气流操作员的互动都集中在那里。因此，如果想要与气流操作符交互，我们可以通过操作符工厂来实现。此外，如果我们必须引入变化，我们只在工厂里做，仅此而已。</p><p id="f2ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">实现非常简单。这是代码。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="os ot l"/></div></figure></div><div class="ab cl mm mn hx mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="im in io ip iq"><h1 id="896c" class="mt mu it bd mv mw mx my mz na nb nc nd jz ne ka nf kc ng kd nh kf ni kg nj nk bi translated">最后的想法</h1><p id="f795" class="pw-post-body-paragraph kz la it lb b lc nl ju le lf nm jx lh li nn lk ll lm no lo lp lq np ls lt lu im bi translated">在本文中，我们介绍了一个框架<strong class="lb iu">提案</strong>被称为<strong class="lb iu">T5】Castor。 </strong>之所以这是一个提议，是因为<strong class="lb iu">这个框架还没有做好生产准备</strong>。它没有测试，是一种实验性的代码。</p><p id="8e41" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想看的话，这里有Github回购。</p><div class="lv lw gp gr lx ly"><a href="https://github.com/castor-team/airflow-castor" rel="noopener  ugc nofollow" target="_blank"><div class="lz ab fo"><div class="ma ab mb cl cj mc"><h2 class="bd iu gy z fp md fr fs me fu fw is bi translated">castor-team/气流-castor</h2><div class="ov l"><h3 class="bd b gy z fp md fr fs me fu fw dk translated">通过YAML文件构建气流Dag的框架。Castor由四个模块组成:配置文件DAG工厂任务…</h3></div><div class="mf l"><p class="bd b dl z fp md fr fs me fu fw dk translated">github.com</p></div></div><div class="mg l"><div class="ow l mi mj mk mg ml ks ly"/></div></div></a></div><p id="3e70" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">本文的目的不是宣传我们的框架</strong>。我们的目标是揭示如何更好地使用Apache Airflow。在这种情况下，我们提倡使用更多的声明性数据管道，因为我们相信<strong class="lb iu">它们是数据管道的未来。</strong></p><p id="61b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">再一次，我想知道更多关于你的想法。</p><p id="3cce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读！</p><p id="74f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">特别感谢<a class="ae ky" href="https://medium.jfgomez.me/" rel="noopener ugc nofollow" target="_blank">胡安·费利佩·戈麦斯</a>让这一切成为可能。</p></div><div class="ab cl mm mn hx mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="im in io ip iq"><p id="37d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nz">如果你想随时更新我的作品，</em> <strong class="lb iu"> <em class="nz">请加入我的</em> </strong> <a class="ae ky" href="https://metadatacommunity.substack.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu"> <em class="nz">通迅</em> </strong> </a> <strong class="lb iu"> <em class="nz">！偶尔，我会和我的读者分享一些东西。如果你加入我会很感激的:)</em></strong></p></div></div>    
</body>
</html>