<html>
<head>
<title>Jinja + SQL = ❤️</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">金贾+ SQL = ❤️</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/jinja-sql-%EF%B8%8F-7e4dff8d8778?source=collection_archive---------3-----------------------#2021-08-15">https://towardsdatascience.com/jinja-sql-%EF%B8%8F-7e4dff8d8778?source=collection_archive---------3-----------------------#2021-08-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/613fed5e1a9323c46bbd633868de44f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tuN2mgBxRvevoIf9QyHiLQ.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">来源:<a class="ae jg" href="https://pixabay.com/users/bytrangle-6596164/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=2895154" rel="noopener ugc nofollow" target="_blank">特朗普</a>来自<a class="ae jg" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=2895154" rel="noopener ugc nofollow" target="_blank"> Pixabay </a></p></figure><div class=""/><div class=""><h2 id="d1f0" class="pw-subtitle-paragraph kg ji jj bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dk translated">用于可维护、可测试数据分析的宏</h2></div><p id="1f2a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">SQL是分析师的面包和黄油。它强大、富有表现力、灵活——但是一门语言给你的力量越大，你就有越多的方式搬起石头砸自己的脚。</p><p id="3425" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">更好的抽象可以帮助我们做到这一点。如果我们能够抽象出我们一直使用的代码，那么我们只需要编写并检查代码<em class="lu">一次</em>。有了正确的抽象，您还可以开始考虑单元测试SQL，这在专业分析中做得不够，但应该是标准实践。</p><p id="42fb" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><a class="ae jg" href="https://jinja.palletsprojects.com/en/3.0.x/templates/" rel="noopener ugc nofollow" target="_blank"> <strong class="la jk"> Jinja宏</strong> </a>特别适合对SQL进行抽象——如果您决定为您的数据组织使用类似Fishtown Analytics的<a class="ae jg" href="https://blog.getdbt.com/what-exactly-is-dbt/" rel="noopener ugc nofollow" target="_blank"> <strong class="la jk">数据构建工具</strong></a>——那么我们将专门探讨如何使用Jinja。但是这里的经验应该是通用的，超越任何一个特定的工具。</p><p id="f641" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你可以跟随我在<a class="ae jg" href="https://github.com/NaimKabir/jinja-sql-demo/tree/main" rel="noopener ugc nofollow" target="_blank"> <strong class="la jk">这个Git repo </strong> </a>中包含的一些玩具用例。本文中与回购中的文件相对应的代码片段将以类似如下的内容开头:</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="5b4b" class="me mf jj ma b gy mg mh l mi mj">-- path: macros/volume_by_demographic.sql</span></pre><h1 id="4b73" class="mk mf jj bd ml mm mn mo mp mq mr ms mt kp mu kq mv ks mw kt mx kv my kw mz na bi translated">用例#1:参数化查询</h1><p id="b374" class="pw-post-body-paragraph ky kz jj la b lb nb kk ld le nc kn lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">这里有一个场景:假设您有一个星型模型，有一个<code class="fe ng nh ni ma b">users</code>表链接到各种其他表，如<code class="fe ng nh ni ma b">purchases</code>、<code class="fe ng nh ni ma b">sessions</code>、<code class="fe ng nh ni ma b">marketing_pushes</code>等。</p><figure class="lv lw lx ly gt iv gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/d43faf76ba789d2736783aa602236664.png" data-original-src="https://miro.medium.com/v2/resize:fit:1258/format:webp/1*dGvVD0MEgTQPDTp086EYVA.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">来源:作者</p></figure><p id="3a62" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你可能想知道<code class="fe ng nh ni ma b">purchases</code>的销量是如何随着人口统计而变化的。该查询可能如下所示:</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="94ad" class="me mf jj ma b gy mg mh l mi mj">-- Get purchase volume by demographic<br/>select<br/>    users.age_group,<br/>    users.region,<br/>    count(*) as purchase_volume<br/>from purchases<br/>    join users on purchases.user_id=users.user_id<br/>group by 1,2</span></pre><p id="8981" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">到目前为止很简单。但是，如果我们希望用户会话的数量减少相同的维度呢？</p><p id="82fc" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们会做:</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="e95b" class="me mf jj ma b gy mg mh l mi mj">-- Get session volume by demographic<br/>select<br/>    users.age_group,<br/>    users.region,<br/>    count(*) as session_volume<br/>from sessions<br/>    join users on sessions.user_id=users.user_id<br/>group by 1,2</span></pre><p id="fa6d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是很多重复的代码！当我们可以用一个抽象来编码关于数据模型的基本假设时，为什么要写同样的东西两次呢？</p><p id="5687" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们写一个宏。这些宏片段具有用<strong class="la jk">粗体</strong>表示的宏逻辑，当调用宏时，变量名在查询的最终“呈现”中被替换为字符串值。为了更好地理解语法，查看一下<a class="ae jg" href="https://jinja.palletsprojects.com/en/3.0.x/templates/" rel="noopener ugc nofollow" target="_blank"> <strong class="la jk"> Jinja模板设计器文档</strong> </a>。</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="6cf2" class="me mf jj ma b gy mg mh l mi mj">-- path: macros/volume_by_demographic.sql</span><span id="4771" class="me mf jj ma b gy nk mh l mi mj"><strong class="ma jk">{% macro volume_by_demographic(entity_table, count_col_name) %}</strong></span><span id="c9cb" class="me mf jj ma b gy nk mh l mi mj">select<br/>    users.age_group,<br/>    users.region,<br/>    count(*) as <strong class="ma jk">{{ count_col_name }}</strong><br/>from {{ entity_table }}<br/>    join users on <strong class="ma jk">{{ entity_table }}</strong>.user_id=users.user_id<br/>group by 1,2</span><span id="48cc" class="me mf jj ma b gy nk mh l mi mj"><strong class="ma jk">{% endmacro %}</strong></span></pre><p id="54e1" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用这个宏，我们对购买量和会话量进行的最后两个查询可以通过简单的调用完全呈现出来:</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="18f5" class="me mf jj ma b gy mg mh l mi mj">-- path: models/purchase_volumes.sql</span><span id="c1ed" class="me mf jj ma b gy nk mh l mi mj"><strong class="ma jk">{% from 'volume_by_demographic.sql' import volume_by_demographic %}</strong></span><span id="748d" class="me mf jj ma b gy nk mh l mi mj">-- Get purchase volume by demographic<br/><strong class="ma jk">{{ volume_by_demographic('purchases', 'purchase_volume') }}</strong></span></pre><p id="a755" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">或者:</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="007e" class="me mf jj ma b gy mg mh l mi mj">-- path: models/session_volumes.sql</span><span id="079f" class="me mf jj ma b gy nk mh l mi mj"><strong class="ma jk">{% from 'volume_by_demographic.sql' import volume_by_demographic %}</strong></span><span id="b605" class="me mf jj ma b gy nk mh l mi mj">-- Get session volume by demographic<br/><strong class="ma jk">{{ volume_by_demographic('sessions', 'session_volume') }}</strong></span></pre><p id="a837" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在<a class="ae jg" href="https://github.com/NaimKabir/jinja-sql-demo/tree/main" rel="noopener ugc nofollow" target="_blank"> <strong class="la jk"> repo </strong> </a>中尝试一下，看看值是如何交换进来以呈现最终查询的！</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="4e58" class="me mf jj ma b gy mg mh l mi mj">&gt;&gt; ./render.py models/session_volumes.sql</span></pre><p id="487a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，如果有一个业务范围的决定，即“人口统计”的概念不应该只是年龄组和地区，因为“地区”太粗略，无法做出任何可操作的决定，会怎么样？</p><p id="965e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你可以直接回到宏代码中，把“区域”改成“州”或者什么的，并保持宏的最终调用点不变。你只需要在一个地方做出改变。</p><p id="1940" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你所做的抽象是为业务分析实现一个<em class="lu">接口</em>，在这里你可以交换后端实现，让你的分析逻辑的消费者不受影响——留给你一个SQL代码库，它很容易随着动态需求而改变。</p><p id="979c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">正如我们将会看到的(我们已经犯了一些错误)，构建接口是棘手的，但是从某个地方开始总比没有接口好。</p><h1 id="edfd" class="mk mf jj bd ml mm mn mo mp mq mr ms mt kp mu kq mv ks mw kt mx kv my kw mz na bi translated">用例2:可组合查询</h1><p id="1ef3" class="pw-post-body-paragraph ky kz jj la b lb nb kk ld le nc kn lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">SQL允许您在子查询或公共表表达式中嵌套逻辑(甚至是递归的)，让您可以无限地将一组记录与另一组记录链接起来。</p><p id="c690" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">像这样的查询可能会令人毛骨悚然，即使是我们正在探索的完美的玩具示例。例如，假设我们希望将每个人口统计组的会话量与购买量相关联，以了解每次会话的预期购买量。</p><p id="b073" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在原始SQL中，这可能看起来像:</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="fc1e" class="me mf jj ma b gy mg mh l mi mj">with purchase_volumes as (</span><span id="f5fb" class="me mf jj ma b gy nk mh l mi mj">select<br/>    users.age_group,<br/>    users.state,<br/>    count(*) as purchase_volume<br/>from purchases<br/>    join users on purchases.user_id=users.user_id<br/>group by 1,2</span><span id="5c52" class="me mf jj ma b gy nk mh l mi mj">),</span><span id="525a" class="me mf jj ma b gy nk mh l mi mj">session_volumes as (</span><span id="fdd7" class="me mf jj ma b gy nk mh l mi mj">select<br/>    users.age_group,<br/>    users.state,<br/>    count(*) as session_volume<br/>from sessions<br/>    join users on sessions.user_id=users.user_id<br/>group by 1,2</span><span id="68eb" class="me mf jj ma b gy nk mh l mi mj">)</span><span id="89f3" class="me mf jj ma b gy nk mh l mi mj">-- Get purchase/session ratios for each age_group*state combination</span><span id="9b72" class="me mf jj ma b gy nk mh l mi mj">select <br/>    age_group,<br/>    state,<br/>    purchase_volume / session_volume as ratio<br/>from purchase_volumes <br/>    join session_volumes<br/>    on purchase_volumes.age_group=session_volumes.age_group<br/>    and purchase_volumes.state=session_volumes.state</span></pre><p id="a799" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是一大堆代码，我们声明的每一项都是潜在的出错点。<a class="ae jg" href="https://www.quantamagazine.org/mathematician-solves-computer-science-conjecture-in-two-pages-20190725/" rel="noopener ugc nofollow" target="_blank"> <strong class="la jk">可证明的事实是</strong> </a>复杂性使得像基于SQL查询的决策过程这样的系统对小错误更加敏感，这一点在专业分析领域经常得到证实<em class="lu"/>。</p><p id="67f4" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">抽象化缩小了bug的表面区域。上面的查询可以归结为:</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="315e" class="me mf jj ma b gy mg mh l mi mj">-- path: models/purchase_sessions_ratio.sql</span><span id="7a58" class="me mf jj ma b gy nk mh l mi mj">-- Get purchase/session ratios for each age_group*state combination</span><span id="2445" class="me mf jj ma b gy nk mh l mi mj">select <br/>    age_group,<br/>    state,<br/>    purchase_volume / session_volume as ratio<br/>from (<br/>        <strong class="ma jk">{{ volume_by_demographic('purchases', 'purchase_volume') }}<br/>     </strong>) p   <br/>    join (<br/>        <strong class="ma jk">{{ volume_by_demographic('sessions', 'session_volume') }}<br/>    </strong>) s<br/>    on p.age_group=s.age_group<br/>    and p.state=s.state</span></pre><p id="925d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">更不用想了！</p><p id="9cbf" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，我们可以只关注转换率逻辑，同时相信基本的体积计数逻辑是正确的。更少的移动部件=更少的破碎系统。</p><p id="0934" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">试试在<a class="ae jg" href="https://github.com/NaimKabir/jinja-sql-demo/tree/main" rel="noopener ugc nofollow" target="_blank"> <strong class="la jk">回购</strong> </a>:</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="067c" class="me mf jj ma b gy mg mh l mi mj">&gt;&gt; ./render.py models/purchase_sessions_ratio.sql</span></pre><h1 id="e143" class="mk mf jj bd ml mm mn mo mp mq mr ms mt kp mu kq mv ks mw kt mx kv my kw mz na bi translated">用例3:可扩展的组合</h1><p id="cea8" class="pw-post-body-paragraph ky kz jj la b lb nb kk ld le nc kn lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">抽象让你比我们已经建立的更加灵活。如果我们不看会话与购买的比率，而是看营销推送与会话的比率，以及<em class="lu">和</em>营销推送与购买的比率，会怎么样？</p><p id="c7c1" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以对我们处理的最后一个SQL块进行宏化，这样它就可以将不同的表引用作为参数！我们将有一个<code class="fe ng nh ni ma b">numerator_vol_ref</code>来指定哪个表的计数应该是输出比率的分子，还有一个<code class="fe ng nh ni ma b">denominator_vol_ref</code>来指定相同的分母。</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="a702" class="me mf jj ma b gy mg mh l mi mj">-- path: macros/volume_ratio.sql</span><span id="6f13" class="me mf jj ma b gy nk mh l mi mj"><strong class="ma jk">{% macro volume_ratio(<br/>    numerator_vol_ref, <br/>    denominator_vol_ref<br/>) %}</strong></span><span id="3f3a" class="me mf jj ma b gy nk mh l mi mj">select <br/>    age_group,<br/>    state,<br/>    N / D as <strong class="ma jk">{{ numerator_vol_ref }}_over_{{ denominator_vol_ref }}</strong><br/>from (<br/>        <strong class="ma jk">{{ volume_by_demographic(numerator_vol_ref, 'N') }}<br/>     </strong>) p   <br/>    join (<br/>        <strong class="ma jk">{{ volume_by_demographic(denominator_vol_ref, 'D') }}<br/>    </strong>) s<br/>    on p.age_group=s.age_group<br/>    and p.state=s.state</span><span id="6103" class="me mf jj ma b gy nk mh l mi mj"><strong class="ma jk">{% endmacro %}</strong></span></pre><p id="e72e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，如果我们想再次计算购买-会话比率，我们可以问:</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="daf9" class="me mf jj ma b gy mg mh l mi mj">-- path: models/purchase_sessions_ratio_2.sql</span><span id="30c7" class="me mf jj ma b gy nk mh l mi mj"><strong class="ma jk">{%- from 'volume_ratio.sql' import volume_ratio -%}</strong></span><span id="dd6d" class="me mf jj ma b gy nk mh l mi mj">-- Get ratio of purchases to sessions for a demographic group<br/><strong class="ma jk">{{ volume_ratio('purchases', 'sessions')}}</strong></span></pre><p id="30fd" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是，如果我们想查看漏斗中的一系列步骤，并且这些步骤是动态的，那该怎么办呢？</p><p id="a013" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输入:Jinja控制流。我们可以在SQL模板中执行循环和if-conditionals，这是一个<em class="lu">超能力。</em></p><p id="e911" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们创建一个引用最后一个逻辑块的宏，但是让我们将一个<code class="fe ng nh ni ma b">denominator_vol_ref</code>和一个<code class="fe ng nh ni ma b">numerator_vol_ref</code>的整个<em class="lu">数组</em>作为参数。</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="751d" class="me mf jj ma b gy mg mh l mi mj">-- macros/volume_ratios.sql</span><span id="e47d" class="me mf jj ma b gy nk mh l mi mj"><strong class="ma jk">{% macro volume_ratios(numerator_vol_refs, denominator_vol_ref) %}</strong></span><span id="e455" class="me mf jj ma b gy nk mh l mi mj">select<br/>    age_group,<br/>    state,<br/><strong class="ma jk">    {%- for ref in numerator_vol_refs -%}<br/></strong>    <strong class="ma jk">{{ ref }}</strong>_over_<strong class="ma jk">{{ denominator_vol_ref }}</strong><br/>    <strong class="ma jk">{%- if not loop.last -%}</strong>,<strong class="ma jk">{%- endif -%}</strong><br/>    <strong class="ma jk">{% endfor %}</strong><br/>from<br/>    (<strong class="ma jk">{{ volume_ratio(numerator_vol_refs.0, denominator_vol_ref) }}</strong>)<br/>    as base<br/>    <strong class="ma jk">{% for ref in numerator_vol_refs %}</strong><br/><strong class="ma jk">    {% if not loop.first %}</strong><br/>    join<br/>    (<strong class="ma jk">{{ volume_ratio(ref, denominator_vol_ref) }}</strong>) as <strong class="ma jk">{{ref}}</strong>_r<br/>            on <strong class="ma jk">{{ref}}</strong>_r.age_group=base.age_group<br/>            and <strong class="ma jk">{{ref}}</strong>_r.state=base.state<br/><strong class="ma jk">    {%- endif -%}</strong><br/><strong class="ma jk">    {%- endfor -%}</strong></span><span id="3e33" class="me mf jj ma b gy nk mh l mi mj"><strong class="ma jk">{% endmacro %}</strong></span></pre><p id="68de" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">那里发生了很多事。让我们来分解一下我们正在做的一些事情。</p><p id="23da" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这个街区:</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="33c0" class="me mf jj ma b gy mg mh l mi mj">select<br/>    age_group,<br/>    state,<br/><strong class="ma jk">    {%- for ref in numerator_vol_refs -%}<br/></strong>    <strong class="ma jk">{{ ref }}</strong>_over_<strong class="ma jk">{{ denominator_vol_ref }}</strong><br/>    <strong class="ma jk">{%- if not loop.last -%}</strong>,<strong class="ma jk">{%- endif -%}</strong><br/>    <strong class="ma jk">{% endfor %}</strong></span></pre><p id="eaf6" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们将遍历表引用的列表，我们将使用这些表引用的人口统计量作为比率分子。<code class="fe ng nh ni ma b">if not loop.last</code>条件语句确保我们在除最后一列之外的每个列名后面都加上一个逗号，以得到格式良好的SQL。</p><p id="3d78" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这为我们提供了一组对子查询中公开的列名的引用。</p><p id="ee90" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这个街区:</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="537c" class="me mf jj ma b gy mg mh l mi mj">from<br/>    (<strong class="ma jk">{{ volume_ratio(numerator_vol_refs.0, denominator_vol_ref) }}</strong>)<br/>    as base</span></pre><p id="252a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们使用数组中的索引<code class="fe ng nh ni ma b">.0</code>从第一个分子表引用创建一个体积比率子查询，并将该子查询别名为<code class="fe ng nh ni ma b">base</code>。</p><p id="148d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在最后一块:</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="7e94" class="me mf jj ma b gy mg mh l mi mj"><strong class="ma jk">{% for ref in numerator_vol_refs %}</strong><br/><strong class="ma jk">    {% if not loop.first %}</strong><br/>    join<br/>    (<strong class="ma jk">{{ volume_ratio(ref, denominator_vol_ref) }}</strong>) as <strong class="ma jk">{{ref}}</strong>_r<br/>            on <strong class="ma jk">{{ref}}</strong>_r.age_group=base.age_group<br/>            and <strong class="ma jk">{{ref}}</strong>_r.state=base.state<br/><strong class="ma jk">    {%- endif -%}</strong><br/><strong class="ma jk">{%- endfor -%}</strong></span></pre><p id="ee84" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们再次遍历分子表引用列表。因为我们已经使用了第一个表引用来创建<code class="fe ng nh ni ma b">base</code>子查询，所以我们忽略第一个带有<code class="fe ng nh ni ma b">if not loop.first</code>条件的子查询。</p><p id="a72c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后，我们针对每个分子表引用的新的<code class="fe ng nh ni ma b">volume_ratio</code>子查询以编程方式连接<code class="fe ng nh ni ma b">base</code>，最终暴露出我们想要的所有列。</p><p id="814c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以在文件中调用宏:</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="8a8a" class="me mf jj ma b gy mg mh l mi mj">-- path: models/example_funnel.sql</span><span id="414e" class="me mf jj ma b gy nk mh l mi mj"><strong class="ma jk">{%- from 'volume_ratios.sql' import volume_ratios -%}</strong></span><span id="a0fb" class="me mf jj ma b gy nk mh l mi mj"><strong class="ma jk">{{ volume_ratios([<br/>        'purchases', <br/>        'sessions', <br/>        'supportTickets'<br/>        ], <br/>   'marketing_pushes') <br/>}}</strong></span></pre><p id="7b6a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">试试在<a class="ae jg" href="https://github.com/NaimKabir/jinja-sql-demo/tree/main" rel="noopener ugc nofollow" target="_blank">中的<strong class="la jk">回购</strong>中的</a>:</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="bf55" class="me mf jj ma b gy mg mh l mi mj">&gt;&gt; ./render models/example_funnel.sql</span></pre><p id="b604" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个东西将呈现一个庞大的查询，很难理解，手工组装起来会很痛苦。但是用宏呢？不是<em class="lu">可怕</em>可怕。</p><h1 id="d85b" class="mk mf jj bd ml mm mn mo mp mq mr ms mt kp mu kq mv ks mw kt mx kv my kw mz na bi translated">用例#4:单元测试</h1><p id="e2ef" class="pw-post-body-paragraph ky kz jj la b lb nb kk ld le nc kn lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">这是整件作品的真正主题。</p><p id="434a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们已经看到抽象是如何让我们通过构建小的乐高积木来构建复杂的查询的。如果你在工作流程中使用它们，你可以从相对简单的部分构建出最终复杂的东西。</p><p id="c1a7" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们还看到这些部分是可参数化的，我们可以提供给宏的一个关键参数是对一个表的引用！这种引用可以是对“真实的”物化数据库表、公共表表达式或视图的引用。重要的是，我们可以对生产数据<em class="lu">或</em>使用参数化查询，这是我们有意设计并存储在某处的一组合成数据。</p><p id="04e0" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这使我们能够编写一堆行，覆盖我们希望查询处理的所有测试用例，并检查结果是否如预期的那样。然后，一旦我们确定它有效，我们就可以对实际的业务相关数量使用完全相同的查询逻辑。</p><p id="4b6c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我们用已经探索过的代码进行一些单元测试，我们可能已经发现了一些错误。例如，在<code class="fe ng nh ni ma b">volume_ratio.sql</code>中，我们正在做整数除法，不会在我们的查询结果中得到<code class="fe ng nh ni ma b">real</code>个数字。我们也不检查0值分母，这在最坏的情况下是个坏消息。</p><p id="10c0" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">还有几个例子，我们对公开的列如何命名做了隐含的假设——对命名方案的任何微小改变都会破坏下游的宏，而调用者不知道发生了什么。</p><p id="4b39" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">进行单元测试强调了您的组织正在构建的整个分析卡片屋，并允许您迭代，直到您获得一个既正确又易于更改的“数据API”。</p><p id="8de6" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">它还允许您自信地进行更改，并简单地检查之后的回归，而不是将您的时间花费在生产记录中试图进行健全性检查。</p><h1 id="32d5" class="mk mf jj bd ml mm mn mo mp mq mr ms mt kp mu kq mv ks mw kt mx kv my kw mz na bi translated">分析工程</h1><p id="3861" class="pw-post-body-paragraph ky kz jj la b lb nb kk ld le nc kn lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">只有当你以一种特殊的方式塑造你的分析团队时，这篇文章的教训才会有用。在开始使用Jinja2和宏的抽象魔法之前，一些隐含的假设必须成立:</p><ul class=""><li id="44cc" class="nl nm jj la b lb lc le lf lh nn ll no lp np lt nq nr ns nt bi translated">您需要在一个统一的代码库中对分析工作进行编码，而不是在几个团队的商业智能工具页面中进行编码。</li><li id="ea49" class="nl nm jj la b lb nu le nv lh nw ll nx lp ny lt nq nr ns nt bi translated">应该有一个连续的“部署”管道，从代码库获取最新的SQL，并实际上将其分流到仪表板/报告等。这个管道可以处理Jinja渲染、查询导出等。</li><li id="4100" class="nl nm jj la b lb nu le nv lh nw ll nx lp ny lt nq nr ns nt bi translated">必须有一个框架来启动测试，如果有一个假设或逻辑错误可能产生不正确的查询结果，则<a class="ae jg" href="https://en.wikipedia.org/wiki/Andon_(manufacturing)" rel="noopener ugc nofollow" target="_blank"> <strong class="la jk">停止该行</strong> </a> <strong class="la jk"> </strong>。</li></ul><p id="4a29" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">开始这一切的一个很好的方法是浏览Fishtown Analytics' <a class="ae jg" href="https://www.getdbt.com/product/what-is-dbt/" rel="noopener ugc nofollow" target="_blank"> <strong class="la jk">数据构建工具</strong> </a>的文档，该工具旨在处理像这样的组织的许多细节。</p><p id="82fe" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">沿着这条路走下去，你的分析组织将超越侦探、特别查询处理程序和部落机构知识仓库。</p><p id="99af" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这将把他们变成一个由<em class="lu">分析工程师</em>组成的团队，他们的工作是可重复和可靠的。</p><h2 id="3513" class="me mf jj bd ml nz oa dn mp ob oc dp mt lh od oe mv ll of og mx lp oh oi mz oj bi translated">资源</h2><ul class=""><li id="1338" class="nl nm jj la b lb nb le nc lh ok ll ol lp om lt nq nr ns nt bi translated"><a class="ae jg" href="https://jinja.palletsprojects.com/en/3.0.x/templates/" rel="noopener ugc nofollow" target="_blank"> <strong class="la jk"> Jinja2模板文档</strong> </a></li><li id="21e0" class="nl nm jj la b lb nu le nv lh nw ll nx lp ny lt nq nr ns nt bi translated"><a class="ae jg" href="https://docs.getdbt.com/tutorial/setting-up" rel="noopener ugc nofollow" target="_blank"> <strong class="la jk">数据构建工具教程</strong> </a></li></ul></div></div>    
</body>
</html>