<html>
<head>
<title>Bioinformatics on the cloud part II</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">云上的生物信息学第二部分</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/bioinformatics-on-the-cloud-part-ii-a99ccfea913a?source=collection_archive---------29-----------------------#2021-08-04">https://towardsdatascience.com/bioinformatics-on-the-cloud-part-ii-a99ccfea913a?source=collection_archive---------29-----------------------#2021-08-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="751e" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/making-sense-of-big-data" rel="noopener" target="_blank">理解大数据</a></h2><div class=""/><div class=""><h2 id="ddf4" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">在Google云平台上使用HTSeq计算RNAseq表达式</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/37d671bedc3b3022413934d3e418e101.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GRB5dy2QDenVTZ1yxNYbPg.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">使用STAR和HTSeq-count的云上的RNAseq分析管道。图片作者。</p></figure><h1 id="e708" class="le lf iq bd lg lh li lj lk ll lm ln lo kf lp kg lq ki lr kj ls kl lt km lu lv bi translated">关联</h1><p id="1648" class="pw-post-body-paragraph lw lx iq ly b lz ma ka mb mc md kd me mf mg mh mi mj mk ml mm mn mo mp mq mr ij bi translated">仅在医疗保健领域，估计到2025年将有6000万患者的基因组编码被测序[1]。测序成本的下降和医学的进步推动了这一增长。重要的是，细胞水平上的信息可以用来帮助指导患者治疗。但是如何分析这些海量数据呢？我们需要的是能够根据问题的规模进行扩展的工具和基础设施。</p><p id="5473" class="pw-post-body-paragraph lw lx iq ly b lz ms ka mb mc mt kd me mf mu mh mi mj mv ml mm mn mw mp mq mr ij bi translated">进入云技术！</p><h1 id="210e" class="le lf iq bd lg lh li lj lk ll lm ln lo kf lp kg lq ki lr kj ls kl lt km lu lv bi translated">范围</h1><p id="ba08" class="pw-post-body-paragraph lw lx iq ly b lz ma ka mb mc md kd me mf mg mh mi mj mk ml mm mn mo mp mq mr ij bi translated">本教程将带你通过谷歌云平台上的RNAseq计算<em class="mx">基因表达</em>(即每个基因的RNA物质数量)的步骤。</p><h2 id="c87b" class="my lf iq bd lg mz na dn lk nb nc dp lo mf nd ne lq mj nf ng ls mn nh ni lu iw bi translated">目标</h2><ul class=""><li id="6304" class="nj nk iq ly b lz ma mc md mf nl mj nm mn nn mr no np nq nr bi translated">了解什么是基因表达。</li><li id="783e" class="nj nk iq ly b lz ns mc nt mf nu mj nv mn nw mr no np nq nr bi translated">使用<code class="fe nx ny nz oa b">samtools</code>为下游分析预处理SAM文件。</li><li id="78bf" class="nj nk iq ly b lz ns mc nt mf nu mj nv mn nw mr no np nq nr bi translated">用<code class="fe nx ny nz oa b">htseq-count</code>计算基因表达。</li></ul><h1 id="d531" class="le lf iq bd lg lh li lj lk ll lm ln lo kf lp kg lq ki lr kj ls kl lt km lu lv bi translated">背景</h1><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ob"><img src="../Images/05508d306f16bc7e6795a24fc35d30ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zLYhYCmrK0k0pPKdgUCf6g.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">图1:电池装配线的示意图。DNA指令通过RNA转化成蛋白质。图片作者。</p></figure><p id="d4d4" class="pw-post-body-paragraph lw lx iq ly b lz ms ka mb mc mt kd me mf mu mh mi mj mv ml mm mn mw mp mq mr ij bi translated">细胞的大部分艰苦工作都是由蛋白质完成的。为了构建它们，细胞表达指令，这些指令被编码在被称为<em class="mx">基因的DNA中的特定区域。</em>细胞在级联过程中合成蛋白质，其中基因的DNA首先作为<em class="mx">前体信使-RNA被读出(<em class="mx">转录</em>)。</em>这种前体随后被转化为<em class="mx">信使RNA — </em>或简称为<em class="mx">mRNA。</em>最后，细胞<em class="mx">在<em class="mx">转移RNA </em>的帮助下将</em>mRNA翻译成蛋白质。通过分析RNAseq数据，我们可以推断出样本中表达了哪种类型的RNA物质，以及有多少。因此，RNAseq数据向我们展示了细胞装配线中途的快照。虽然这些快照不能给出细胞状态的完整图像，但它们无疑是细胞下游发生的实际过程的有用替代物。通过这种方式，RNAseq可以帮助了解细胞机制的基础，例如，特定的疾病。</p><p id="ce3a" class="pw-post-body-paragraph lw lx iq ly b lz ms ka mb mc mt kd me mf mu mh mi mj mv ml mm mn mw mp mq mr ij bi translated">就我们的目的而言，重要的是要认识到DNA中的指令并没有一对一地映射到最终产品(蛋白质)上。在转录阶段，只有DNA的编码区(基因的<em class="mx">外显子</em>)被保留下来，在一个称为<em class="mx">剪接</em>的过程中形成<em class="mx">转录本</em>。去除非编码区(内含子<em class="mx"/>)后，剩余的外显子可以以各种方式组合。如图1所示，单个DNA片段因此可以产生组合数量的相关转录物，称为<em class="mx">同种型</em>。反过来，由于控制蛋白质折叠过程的竞争性偶极相互作用，每个同种型翻译成独特的三维结构。</p><h2 id="e03e" class="my lf iq bd lg mz na dn lk nb nc dp lo mf nd ne lq mj nf ng ls mn nh ni lu iw bi translated">概括</h2><p id="34fc" class="pw-post-body-paragraph lw lx iq ly b lz ma ka mb mc md kd me mf mg mh mi mj mk ml mm mn mo mp mq mr ij bi translated"><a class="ae oc" rel="noopener" target="_blank" href="/bioinformatics-on-the-cloud-144c4e7b60d1">在之前的</a>中，我们讨论了如何理解在<em class="mx">测序仪</em>上生成的大量小碱基阵列(<code class="fe nx ny nz oa b">A</code>、<code class="fe nx ny nz oa b">C</code>、<code class="fe nx ny nz oa b">T</code>、&amp;、<code class="fe nx ny nz oa b">G</code>)，称为<em class="mx">读数</em>。我们讨论了如何在一个称为参照基因组比对的过程中把拼图(参照基因组)的碎片(阅读)放在一起。使用<a class="ae oc" href="https://github.com/alexdobin/STAR" rel="noopener ugc nofollow" target="_blank"> STAR </a>，我们能够将测序机的原始数据以<a class="ae oc" href="https://en.wikipedia.org/wiki/FASTQ_format#:~:text=FASTQ%20format%20is%20a%20text,single%20ASCII%20character%20for%20brevity." rel="noopener ugc nofollow" target="_blank"> FASTQ </a>格式转换成一组<a class="ae oc" href="https://en.wikipedia.org/wiki/SAM_(file_format)" rel="noopener ugc nofollow" target="_blank"> SAM </a>文件。本教程将会更进一步。我们将使用SAM文件，使用<a class="ae oc" href="https://htseq.readthedocs.io/en/release_0.11.1/count.html" rel="noopener ugc nofollow" target="_blank"> HTSeq-count </a> [2]计算每个基因产生了多少RNA，这是一种使用谷歌云平台的可扩展方式。</p><h2 id="69d3" class="my lf iq bd lg mz na dn lk nb nc dp lo mf nd ne lq mj nf ng ls mn nh ni lu iw bi translated">基因表达</h2><p id="daa8" class="pw-post-body-paragraph lw lx iq ly b lz ma ka mb mc md kd me mf mg mh mi mj mk ml mm mn mo mp mq mr ij bi translated">量化RNAseq从计数开始:我们跟踪所有可能的转录物，并计算出现的次数。在其最基本的形式中，这正是<em class="mx">基因表达</em>的含义:每个基因的RNA计数表。这听起来很简单，但请记住，我们的转录本在测序前就被粉碎成小片段。因此，为了将一段RNA分配给一个转录本，我们需要一个转录本目录——一个<em class="mx">转录组— </em>来选择。与排列好的RNA碎片(SAM格式)一起，<code class="fe nx ny nz oa b">htseq-count</code>将汇总数据，建立一个计数表。</p></div><div class="ab cl od oe hu of" role="separator"><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi"/></div><div class="ij ik il im in"><h1 id="91a5" class="le lf iq bd lg lh ok lj lk ll ol ln lo kf om kg lq ki on kj ls kl oo km lu lv bi translated">初步步骤</h1><p id="e78f" class="pw-post-body-paragraph lw lx iq ly b lz ma ka mb mc md kd me mf mg mh mi mj mk ml mm mn mo mp mq mr ij bi translated">说够了，该编码了！打开<a class="ae oc" href="https://console.cloud.google.com/" rel="noopener ugc nofollow" target="_blank">谷歌云平台仪表盘</a>，点击右上角的云壳图标(图2)启动终端。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi op"><img src="../Images/f0139ec2ec34a0f922f3b19009402936.png" data-original-src="https://miro.medium.com/v2/resize:fit:828/format:webp/1*k5uESgEzFGkGf5_8Ga_M0Q.png"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">图2:谷歌云平台中的云壳图标。图片作者。</p></figure><p id="819d" class="pw-post-body-paragraph lw lx iq ly b lz ms ka mb mc mt kd me mf mu mh mi mj mv ml mm mn mw mp mq mr ij bi translated">我们将利用<a class="ae oc" href="https://github.com/DataBiosphere/dsub" rel="noopener ugc nofollow" target="_blank"> dsub </a>在Google云平台上分配我们的生物信息学工作量。要安装<code class="fe nx ny nz oa b">dsub</code>，请执行:</p><pre class="kp kq kr ks gt oq oa or os aw ot bi"><span id="979b" class="my lf iq oa b gy ou ov l ow ox"><strong class="oa ja">sudo pip3</strong> install dsub</span></pre><p id="83ee" class="pw-post-body-paragraph lw lx iq ly b lz ms ka mb mc mt kd me mf mu mh mi mj mv ml mm mn mw mp mq mr ij bi translated">在你的云壳里。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oy"><img src="../Images/4cd9210bd2cf1b0b75db064bb1343926.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cbf5J83XAKYRWFeQqlKA5g.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">图3:在Google云平台上的云壳中创建一个存储桶。图片作者。</p></figure><p id="6611" class="pw-post-body-paragraph lw lx iq ly b lz ms ka mb mc mt kd me mf mu mh mi mj mv ml mm mn mw mp mq mr ij bi translated">接下来，我们将需要一个位置，一个<em class="mx">桶</em>，来在云上存储我们的文件。选择一个唯一的名称，例如<code class="fe nx ny nz oa b">gs://rna-seq-tutorial</code>，并创建存储桶(<code class="fe nx ny nz oa b">mb</code>):</p><pre class="kp kq kr ks gt oq oa or os aw ot bi"><span id="4666" class="my lf iq oa b gy ou ov l ow ox"><strong class="oa ja">export</strong> BUCKET=gs://rna-seq-tutorial<br/><strong class="oa ja">export</strong> REFDATA=${BUCKET}/refdata<br/><strong class="oa ja">export</strong> INPUT=${BUCKET}/input<br/><strong class="oa ja">gsutil mb</strong> -l europe-west4 ${BUCKET}</span></pre><p id="11a7" class="pw-post-body-paragraph lw lx iq ly b lz ms ka mb mc mt kd me mf mu mh mi mj mv ml mm mn mw mp mq mr ij bi translated">如果你已经成功地完成了之前的教程，在那里我们使用STAR 对齐了FASTQ文件，你应该已经生成了两个文件:<code class="fe nx ny nz oa b">sample1.sam</code>和<code class="fe nx ny nz oa b">sample2.sam</code>。如果没有，下载并复制样本文件到<em class="mx">输入</em>目录:</p><pre class="kp kq kr ks gt oq oa or os aw ot bi"><span id="af39" class="my lf iq oa b gy ou ov l ow ox"><strong class="oa ja">wget</strong> -O - <a class="ae oc" href="https://tinyurl.com/jnetj2u3" rel="noopener ugc nofollow" target="_blank">https://tinyurl.com/jnetj2u3</a> <!-- -->\<br/>    | <strong class="oa ja">gsutil cp</strong> - <em class="mx">"${INPUT}/sample1.sam"</em><br/><strong class="oa ja">wget</strong> -O - <a class="ae oc" href="https://tinyurl.com/7exr8jsn" rel="noopener ugc nofollow" target="_blank">https://tinyurl.com/7exr8jsn</a> <!-- -->\<br/>    | <strong class="oa ja">gsutil cp</strong> - <em class="mx">"${INPUT}/sample2.sam"</em></span></pre><p id="a60f" class="pw-post-body-paragraph lw lx iq ly b lz ms ka mb mc mt kd me mf mu mh mi mj mv ml mm mn mw mp mq mr ij bi translated">我们还需要人类基因组的基因转录本目录(<em class="mx">转录组)</em>，通常是<code class="fe nx ny nz oa b">gff3</code>或<code class="fe nx ny nz oa b">gtf</code>格式。如果你愿意，你可以直接从头构建一个转录组——这被称为<em class="mx">转录组组装——</em>但为了简单起见，我们将依赖于Gencode之前策划的<a class="ae oc" href="https://www.gencodegenes.org/human/" rel="noopener ugc nofollow" target="_blank">人类基因组注释</a>。</p><p id="7fbd" class="pw-post-body-paragraph lw lx iq ly b lz ms ka mb mc mt kd me mf mu mh mi mj mv ml mm mn mw mp mq mr ij bi translated">将转录组文件下载到新创建的bucket的<em class="mx"> refdata </em>目录中，如下所示:</p><pre class="kp kq kr ks gt oq oa or os aw ot bi"><span id="c43f" class="my lf iq oa b gy ou ov l ow ox"><strong class="oa ja">wget</strong> -O - <a class="ae oc" href="https://tinyurl.com/vteb57e2" rel="noopener ugc nofollow" target="_blank">https://tinyurl.com/vteb57e2</a> <!-- -->\<br/>    | <strong class="oa ja">zcat</strong> \<br/>    | <strong class="oa ja">gsutil cp</strong> - <em class="mx">"${REFDATA}/gencode.v36.chr_patch_hapl_scaff.annotation.gff3"</em></span></pre><p id="aa94" class="pw-post-body-paragraph lw lx iq ly b lz ms ka mb mc mt kd me mf mu mh mi mj mv ml mm mn mw mp mq mr ij bi translated">最后，启用<a class="ae oc" href="https://console.cloud.google.com/apis/library/lifesciences.googleapis.com?q=cloudlife%20science" rel="noopener ugc nofollow" target="_blank">云生命科学API </a>开始使用<code class="fe nx ny nz oa b">dsub</code>。</p><h1 id="16d0" class="le lf iq bd lg lh li lj lk ll lm ln lo kf lp kg lq ki lr kj ls kl lt km lu lv bi translated">预处理校准文件</h1><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oz"><img src="../Images/1482b05a8facf678b78fb04918b8ecb2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WQAqZCHspLx2DcWxrBBZjg.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">图4:使用<code class="fe nx ny nz oa b">samtools</code>的预处理步骤概述。图片作者。</p></figure><p id="d785" class="pw-post-body-paragraph lw lx iq ly b lz ms ka mb mc mt kd me mf mu mh mi mj mv ml mm mn mw mp mq mr ij bi translated">在我们可以通过计算RNA转录物来量化基因表达之前，我们需要预处理我们的SAM文件。HTSeq-count要求SAM文件按照染色体位置分类，并附带索引文件，以便快速访问特定位置的读数。这两者都可以通过一个叫做<a class="ae oc" href="https://github.com/samtools/samtools" rel="noopener ugc nofollow" target="_blank"> samtools </a>的小工具来完成。用以下内容创建一个名为<code class="fe nx ny nz oa b">step1.sh</code>的文件(见图4):</p><pre class="kp kq kr ks gt oq oa or os aw ot bi"><span id="aa0b" class="my lf iq oa b gy ou ov l ow ox">#!/bin/bash<br/><em class="mx"># a) Sort SAM file on genomic position.</em><br/><strong class="oa ja">samtools</strong> <strong class="oa ja">sort</strong> \<br/>    --threads 2 \<br/>    --output-fmt BAM \<br/>    -o ${BAM} \<br/>    ${SAM}</span><span id="bd6a" class="my lf iq oa b gy pa ov l ow ox"><em class="mx"># b) Create index of sorted BAM file.</em><br/><strong class="oa ja">samtools</strong> <strong class="oa ja">index</strong> \<br/>    -@ 2 \<br/>    ${BAM} \<br/>    ${BAI}</span></pre><p id="b230" class="pw-post-body-paragraph lw lx iq ly b lz ms ka mb mc mt kd me mf mu mh mi mj mv ml mm mn mw mp mq mr ij bi translated">顾名思义，第一个命令对SAM文件进行排序，并将其压缩成(更小的)二进制<a class="ae oc" href="https://en.wikipedia.org/wiki/SAM_(file_format)" rel="noopener ugc nofollow" target="_blank"> BAM </a>格式(<code class="fe nx ny nz oa b">--output-fmt BAM</code>)。然后在两个线程上使用<code class="fe nx ny nz oa b">samtools index</code>对生成的BAM文件进行索引(<code class="fe nx ny nz oa b">-@ 2</code>)。注意，在这一点上，Bash变量<code class="fe nx ny nz oa b">${SAM}</code>、<code class="fe nx ny nz oa b">${BAM}</code>和<code class="fe nx ny nz oa b">${BAI}</code>还没有定义。当我们将工作负载(<code class="fe nx ny nz oa b">step1.sh</code>)提交给云时，这些将由<code class="fe nx ny nz oa b">dsub</code>提供。为此，首先创建一个<a class="ae oc" href="https://en.wikipedia.org/wiki/Tab-separated_values" rel="noopener ugc nofollow" target="_blank">制表符分隔的值文件</a> <code class="fe nx ny nz oa b">step1.tsv</code>，包含以下字段</p><pre class="kp kq kr ks gt oq oa or os aw ot bi"><span id="6c6b" class="my lf iq oa b gy ou ov l ow ox">--input SAM	--output BAM	--output BAI<br/>&lt;my-bucket&gt;/input/sample1.sam	&lt;my-bucket&gt;/output/step1/sample1_sorted.bam	&lt;my-bucket&gt;/output/step1/sample1_sorted.bam.bai<br/>&lt;my-bucket&gt;/input/sample2.sam	&lt;my-bucket&gt;/output/step1/sample2_sorted.bam	&lt;my-bucket&gt;/output/step1/sample2_sorted.bam.bai</span></pre><p id="b350" class="pw-post-body-paragraph lw lx iq ly b lz ms ka mb mc mt kd me mf mu mh mi mj mv ml mm mn mw mp mq mr ij bi translated">用您的bucket位置替换<code class="fe nx ny nz oa b">&lt;my-bucket&gt;</code>(在我们的例子中是<code class="fe nx ny nz oa b">gs://rna-seq-tutorial</code>)，并仔细检查这些值是否由制表符(而不是空格)分隔。正如您可以从标题中推断的那样，这些列指的是脚本中的变量<code class="fe nx ny nz oa b">${SAM}</code>、<code class="fe nx ny nz oa b">${BAM}</code>和<code class="fe nx ny nz oa b">${BAI}</code>。创建这个<code class="fe nx ny nz oa b">tsv</code>文件允许我们快速地将我们的计算扩展到任意大小，因为<code class="fe nx ny nz oa b">dsub</code>将为<code class="fe nx ny nz oa b">step1.tsv</code>文件中的每一行启动单独的工作线程。要启动实际的工作负载，请执行</p><pre class="kp kq kr ks gt oq oa or os aw ot bi"><span id="74a8" class="my lf iq oa b gy ou ov l ow ox"><strong class="oa ja">dsub</strong> \<br/>    --provider google-cls-v2 \<br/>    --project &lt;my-project&gt; \<br/>    --location europe-west4 \<br/>    --zones europe-west4-a \<br/>    --preemptible \<br/>    --min-ram 8 \<br/>    --min-cores 2 \<br/>    --logging "${BUCKET}/logging/step1/" \<br/>    --image registry.gitlab.com/hylkedonker/rna-seq \<br/>    --tasks step1.tsv \<br/>    --script step1.sh</span></pre><p id="2dde" class="pw-post-body-paragraph lw lx iq ly b lz ms ka mb mc mt kd me mf mu mh mi mj mv ml mm mn mw mp mq mr ij bi translated">决定你是否要冒着工作终止的风险去寻找更便宜的先占计算(<code class="fe nx ny nz oa b">--preemptible</code>)，并用你的谷歌云平台项目ID替换<code class="fe nx ny nz oa b">&lt;my-project&gt;</code>。这将启动两个工作线程(<code class="fe nx ny nz oa b">step1.tsv</code>中的每条线一个)，具有8gb的RAM ( <code class="fe nx ny nz oa b">--min-ram 8</code>)和两个虚拟内核(<code class="fe nx ny nz oa b">--min-cores 2</code>)。每个工人运行一个Docker映像(<code class="fe nx ny nz oa b">--image</code>)，其中包含运行<code class="fe nx ny nz oa b">step1.sh</code>所需的生物信息学工具。Dsub自动负责将文件从<code class="fe nx ny nz oa b">step1.tsv</code>中的<code class="fe nx ny nz oa b">--input SAM</code>列复制到<code class="fe nx ny nz oa b">step1.tsv</code>中的<code class="fe nx ny nz oa b">--output BAM</code>和<code class="fe nx ny nz oa b">--output BAI</code>列。</p><p id="0434" class="pw-post-body-paragraph lw lx iq ly b lz ms ka mb mc mt kd me mf mu mh mi mj mv ml mm mn mw mp mq mr ij bi translated">当我们的工作负载在云上运行时，让我们为下一步做准备。</p><h1 id="c881" class="le lf iq bd lg lh li lj lk ll lm ln lo kf lp kg lq ki lr kj ls kl lt km lu lv bi translated">计算基因表达</h1><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi pb"><img src="../Images/350ea52480d2a85cf2f9d9f220738fbd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yd4HVqH2BkSYfvvv_lkCtA.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">图5:使用htseq-count估计RNA丰度的概述。图片作者。</p></figure><p id="c282" class="pw-post-body-paragraph lw lx iq ly b lz ms ka mb mc mt kd me mf mu mh mi mj mv ml mm mn mw mp mq mr ij bi translated">计算RNAseq听起来似乎很简单。但是要知道，大多数现代测序机器并不能完全测量RNAseq片段。相反，他们产生仅测量片段两端的成对末端测序数据。更糟糕的是，如何统计一个跨越多个基因的片段？幸运的是，<code class="fe nx ny nz oa b">htseq-count</code>用非常合理的缺省值解决了这些问题。</p><p id="9f6a" class="pw-post-body-paragraph lw lx iq ly b lz ms ka mb mc mt kd me mf mu mh mi mj mv ml mm mn mw mp mq mr ij bi translated">为此(如图5所示)，创建一个名为<code class="fe nx ny nz oa b">step2.sh</code>的文件，其内容如下:</p><pre class="kp kq kr ks gt oq oa or os aw ot bi"><span id="dc11" class="my lf iq oa b gy ou ov l ow ox">#!/bin/bash<br/># Compute expression<br/><strong class="oa ja">htseq-count</strong> \<br/>    --stranded=reverse \<br/>    --order pos \<br/>    --format bam \<br/>    --additional-attr=gene_name \<br/>    --type gene \<br/>    -n 2 \<br/>    ${BAM} \<br/>    ${GTF} \<br/>    -c ${COUNTS}</span></pre><p id="6402" class="pw-post-body-paragraph lw lx iq ly b lz ms ka mb mc mt kd me mf mu mh mi mj mv ml mm mn mw mp mq mr ij bi translated">这里，我们使用位置排序(<code class="fe nx ny nz oa b">--order pos</code> ) BAM文件(<code class="fe nx ny nz oa b">--format bam</code>)和两个内核(<code class="fe nx ny nz oa b">-n 2</code>)上的Gencode基因注释，运行<code class="fe nx ny nz oa b">htseq-count</code>来合计每个基因的计数(<code class="fe nx ny nz oa b">--type gene</code>)。需要注意的一个重要方面是，在样品制备过程中是否使用了链识别文库，该文库可以在处理过程中保留RNA的链。(如果您不确定，<a class="ae oc" href="http://rseqc.sourceforge.net/" rel="noopener ugc nofollow" target="_blank"> RSeQC </a>的<code class="fe nx ny nz oa b">infer_experiment.py</code>工具可以帮助您识别样品的滞留情况。)在我们的例子中，<a class="ae oc" href="https://github.com/griffithlab/rnaseq_tutorial/wiki/RNAseq-Data" rel="noopener ugc nofollow" target="_blank">我们的数据</a>是使用TruSeq，一个链特定的库[3]生成的，因此我们使用<code class="fe nx ny nz oa b">--stranded=reverse</code>标志。类似于我们的预处理计算作业，我们创建一个制表符分隔的文件<code class="fe nx ny nz oa b">step2.tsv</code>，它列出了输入BAM +索引文件和相应的计数文件(以<code class="fe nx ny nz oa b">tsv</code>格式)，每个样本一行:</p><pre class="kp kq kr ks gt oq oa or os aw ot bi"><span id="566b" class="my lf iq oa b gy ou ov l ow ox">--input BAM<!-- -->	<!-- -->--input BAI<!-- -->	<!-- -->--output COUNTS<br/>gs://&lt;my-bucket&gt;/output/step1/sample1_sorted.bam<!-- -->	<!-- -->gs://&lt;my-bucket&gt;/output/step1/sample1_sorted.bam.bai<!-- -->	<!-- -->gs://&lt;my-bucket&gt;/output/step2/sample1.tsv<br/>gs://&lt;my-bucket&gt;/output/step1/sample2_sorted.bam<!-- -->	<!-- -->gs://&lt;my-bucket&gt;/output/step1/sample2_sorted.bam.bai<!-- -->	<!-- -->gs://&lt;my-bucket&gt;/output/step2/sample2.tsv</span></pre><p id="40fa" class="pw-post-body-paragraph lw lx iq ly b lz ms ka mb mc mt kd me mf mu mh mi mj mv ml mm mn mw mp mq mr ij bi translated">不要忘记用您的存储位置替换<code class="fe nx ny nz oa b">&lt;my-bucket&gt;</code>,并仔细检查您是否正确地复制了制表符(而不是空格)。在提交下一个工作负载之前，让我们通过查询它的状态来检查上一个作业是否成功完成</p><pre class="kp kq kr ks gt oq oa or os aw ot bi"><span id="9c88" class="my lf iq oa b gy ou ov l ow ox"><strong class="oa ja">dstat</strong> \<br/>    --provider google-cls-v2 \<br/>    --project &lt;my-project&gt; \<br/>    --location europe-west4 \<br/>    --status '*'</span></pre><p id="ecef" class="pw-post-body-paragraph lw lx iq ly b lz ms ka mb mc mt kd me mf mu mh mi mj mv ml mm mn mw mp mq mr ij bi translated">如果一切正常，我们准备提交下一个工作负载。</p><pre class="kp kq kr ks gt oq oa or os aw ot bi"><span id="6c86" class="my lf iq oa b gy ou ov l ow ox"><strong class="oa ja">dsub</strong> \<br/>    --provider google-cls-v2 \<br/>    --project &lt;my-project&gt; \<br/>    --location europe-west4 \<br/>    --zones europe-west4-a \<br/>    --preemptible \<br/>    --min-ram 8 \<br/>    --min-cores 2 \<br/>    --logging "${BUCKET}/logging/step2/" \<br/>    --input GTF=${REFDATA}/gencode.v36.chr_patch_hapl_scaff.annotation.gff3 \<br/>    --image registry.gitlab.com/hylkedonker/rna-seq \<br/>    --tasks step2.tsv \<br/>    --script step2.sh</span></pre><p id="1f0c" class="pw-post-body-paragraph lw lx iq ly b lz ms ka mb mc mt kd me mf mu mh mi mj mv ml mm mn mw mp mq mr ij bi translated">与前面的提交命令唯一的细微差别是我们直接向<code class="fe nx ny nz oa b">dsub</code>而不是<code class="fe nx ny nz oa b">tsv</code>文件提供了<code class="fe nx ny nz oa b">--input GTF</code>标志，因为它对于每个工作负载都是相同的。</p><p id="fa3e" class="pw-post-body-paragraph lw lx iq ly b lz ms ka mb mc mt kd me mf mu mh mi mj mv ml mm mn mw mp mq mr ij bi translated">成功完成工作量后(使用<code class="fe nx ny nz oa b">dstat</code>查询状态)，您应该有一个每个样本的计数表(<code class="fe nx ny nz oa b">sample&lt;i&gt;.tsv</code>)。您可以通过执行以下命令轻松验证这一点</p><pre class="kp kq kr ks gt oq oa or os aw ot bi"><span id="8c93" class="my lf iq oa b gy ou ov l ow ox"><strong class="oa ja">gsutil ls</strong> "${BUCKET}/output/step2/"</span></pre><p id="a202" class="pw-post-body-paragraph lw lx iq ly b lz ms ka mb mc mt kd me mf mu mh mi mj mv ml mm mn mw mp mq mr ij bi translated">显示每个相应样本的<code class="fe nx ny nz oa b">tsv</code>文件。(如果没有，您可能想看看日志<code class="fe nx ny nz oa b">gsutil ls "${BUCKET}/logging/step2/</code>看看哪里出错了。).</p><p id="974d" class="pw-post-body-paragraph lw lx iq ly b lz ms ka mb mc mt kd me mf mu mh mi mj mv ml mm mn mw mp mq mr ij bi translated">瞧，您刚刚量化了样品的基因表达！</p></div><div class="ab cl od oe hu of" role="separator"><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi"/></div><div class="ij ik il im in"><h1 id="97fe" class="le lf iq bd lg lh ok lj lk ll ol ln lo kf om kg lq ki on kj ls kl oo km lu lv bi translated">讨论</h1><h2 id="7abd" class="my lf iq bd lg mz na dn lk nb nc dp lo mf nd ne lq mj nf ng ls mn nh ni lu iw bi translated">基因表达计数</h2><p id="67d1" class="pw-post-body-paragraph lw lx iq ly b lz ma ka mb mc md kd me mf mg mh mi mj mk ml mm mn mo mp mq mr ij bi translated">在总结之前，我们应该提到，如果您想要比较单个样本，您的计数需要一个额外的标准化步骤。在每次实验运行中，测序仪将给出不同总数的<em class="mx">读数</em>。此外，因为RNA转录物在测序前被粉碎成片段，较长的转录物将产生更多的片段。因此，适当选择的变换有助于协调样本的表达估计。幸运的是，大多数下游分析包，如<a class="ae oc" href="http://bioconductor.org/packages/release/bioc/html/edgeR.html" rel="noopener ugc nofollow" target="_blank">修边机</a>、<a class="ae oc" href="https://bioconductor.org/packages/release/bioc/html/limma.html" rel="noopener ugc nofollow" target="_blank"> limma </a>和<a class="ae oc" href="https://bioconductor.org/packages/release/bioc/html/DESeq2.html" rel="noopener ugc nofollow" target="_blank"> DeSeq2 </a>会为您完成这项工作，事实上，<strong class="ly ja">需要</strong>计数数据作为输入。</p><h2 id="6713" class="my lf iq bd lg mz na dn lk nb nc dp lo mf nd ne lq mj nf ng ls mn nh ni lu iw bi translated"><code class="fe nx ny nz oa b">Dsub</code>和朋友</h2><p id="b2d3" class="pw-post-body-paragraph lw lx iq ly b lz ma ka mb mc md kd me mf mg mh mi mj mk ml mm mn mo mp mq mr ij bi translated">在本教程中，我们转向<code class="fe nx ny nz oa b">dsub</code>将我们的计算分派给虚拟<em class="mx">工作者</em>。Dsub非常适合在云上开始，尤其是当您想要做一次或几次特定的分析时。但它绝不是唯一的工具，尤其是如果你想以可重复、容错的方式一遍又一遍地运行相同的工具序列——所谓的<em class="mx">工作流</em>。<a class="ae oc" href="https://snakemake.readthedocs.io/en/stable/" rel="noopener ugc nofollow" target="_blank"> Snakemake </a>和<a class="ae oc" href="https://www.nextflow.io/" rel="noopener ugc nofollow" target="_blank"> Nextflow </a>是帮助您在云上运行生产工作流的工具的很好例子。然而，如果你喜欢工具不可知的方法，你可以考虑<a class="ae oc" href="https://www.commonwl.org/" rel="noopener ugc nofollow" target="_blank">通用工作流语言</a> (CWL)，它是一个以YAML格式表达工作流的开放标准。</p><h1 id="06ec" class="le lf iq bd lg lh li lj lk ll lm ln lo kf lp kg lq ki lr kj ls kl lt km lu lv bi translated">结束语</h1><p id="39c1" class="pw-post-body-paragraph lw lx iq ly b lz ma ka mb mc md kd me mf mg mh mi mj mk ml mm mn mo mp mq mr ij bi translated">就这样，您已经成功地使用HTSeq计算了云上的基因表达！注意扩展我们的分析是多么容易:预处理和计数1000个样本的RNAseq而不是2个样本，只需扩展制表符分隔的文件。</p><p id="75ab" class="pw-post-body-paragraph lw lx iq ly b lz ms ka mb mc mt kd me mf mu mh mi mj mv ml mm mn mw mp mq mr ij bi translated">如果你有有用的<code class="fe nx ny nz oa b">htseq-count</code>技巧或有趣的云技巧要分享，或者对代码有任何改进，请发表评论。</p><h1 id="0017" class="le lf iq bd lg lh li lj lk ll lm ln lo kf lp kg lq ki lr kj ls kl lt km lu lv bi translated">参考文献:</h1><p id="da92" class="pw-post-body-paragraph lw lx iq ly b lz ma ka mb mc md kd me mf mg mh mi mj mk ml mm mn mo mp mq mr ij bi translated">[1]: E. Birney、J. Vamathevan和P. Goodhand。医疗保健中的基因组学:GA4GH展望2022年。“bior XIV(2017):203554。</p><p id="5fcb" class="pw-post-body-paragraph lw lx iq ly b lz ms ka mb mc mt kd me mf mu mh mi mj mv ml mm mn mw mp mq mr ij bi translated">[2]: Anders <em class="mx">等</em><a class="ae oc" href="https://academic.oup.com/bioinformatics/article/31/2/166/2366196?login=true" rel="noopener ugc nofollow" target="_blank">ht seq——一个处理高通量测序数据的Python框架。</a>《生物信息学》31.2(2015):166–169。</p><p id="9a49" class="pw-post-body-paragraph lw lx iq ly b lz ms ka mb mc mt kd me mf mu mh mi mj mv ml mm mn mw mp mq mr ij bi translated">[3]: M .格里菲斯<em class="mx">等</em>"<a class="ae oc" href="https://journals.plos.org/ploscompbiol/article?id=10.1371/journal.pcbi.1004393" rel="noopener ugc nofollow" target="_blank">RNA测序信息学:云上分析的网络资源。</a>《PLoS Comput Biol 11.8(2015):e 1004393。</p></div><div class="ab cl od oe hu of" role="separator"><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi"/></div><div class="ij ik il im in"><p id="67ea" class="pw-post-body-paragraph lw lx iq ly b lz ms ka mb mc mt kd me mf mu mh mi mj mv ml mm mn mw mp mq mr ij bi translated"><em class="mx">本教程是主要与Bram van Es合作的副产品，我们试图揭示免疫疗法(一种用于抗癌的药物)背后的生物模式。</em></p></div></div>    
</body>
</html>