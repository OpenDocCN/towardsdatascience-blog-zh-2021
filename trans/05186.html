<html>
<head>
<title>4 different approaches for Time Series Analysis</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">4种不同的时间序列分析方法</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/4-different-approaches-for-time-series-analysis-7e2364fadcb9?source=collection_archive---------6-----------------------#2021-05-07">https://towardsdatascience.com/4-different-approaches-for-time-series-analysis-7e2364fadcb9?source=collection_archive---------6-----------------------#2021-05-07</a></blockquote><div><div class="fc ik il im in io"/><div class="ip iq ir is it"><h2 id="83c7" class="iu iv iw bd b dl ix iy iz ja jb jc dk jd translated" aria-label="kicker paragraph">数据分析</h2><div class=""/><div class=""><h2 id="44e1" class="pw-subtitle-paragraph kc jf iw bd b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt dk translated">一个现成的Python代码，包括用于时间序列分析的不同策略和库</h2></div><figure class="kv kw kx ky gu kz gi gj paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="gi gj ku"><img src="../Images/43388c14fb7da45d597ac21230d841be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A8sot4oBR8NGFdG-piWkVw.jpeg"/></div></div><p class="lg lh gk gi gj li lj bd b be z dk translated">图片由<a class="ae lk" href="https://pixabay.com/users/geralt-9301/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=3303560" rel="noopener ugc nofollow" target="_blank"> Gerd Altmann </a>从<a class="ae lk" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=3303560" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>拍摄</p></figure><p id="417f" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated">在本教程中，我将使用以下4种不同的方法来说明如何分析时间序列:</p><ul class=""><li id="006e" class="mh mi iw ln b lo lp lr ls lu mj ly mk mc ml mg mm mn mo mp bi translated">手动设置模型参数和多步预测</li><li id="5ce5" class="mh mi iw ln b lo mq lr mr lu ms ly mt mc mu mg mm mn mo mp bi translated">手动设置模型参数和单步预测</li><li id="8148" class="mh mi iw ln b lo mq lr mr lu ms ly mt mc mu mg mm mn mo mp bi translated">模型参数的自动设置和多步预测</li><li id="aaf6" class="mh mi iw ln b lo mq lr mr lu ms ly mt mc mu mg mm mn mo mp bi translated">分解。</li></ul><p id="f5a8" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated">前三种方法利用差分使时间序列平稳。</p><p id="1130" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated">你可以从我的<a class="ae lk" href="https://github.com/alod83/data-science/blob/master/DataAnalysis/Time%20Series%20Analysis.ipynb" rel="noopener ugc nofollow" target="_blank"> Github库</a>下载本教程的代码。</p><h1 id="da8d" class="mv mw iw bd mx my mz na nb nc nd ne nf kl ng km nh ko ni kp nj kr nk ks nl nm bi translated">数据集导入</h1><p id="108c" class="pw-post-body-paragraph ll lm iw ln b lo nn kg lq lr no kj lt lu np lw lx ly nq ma mb mc nr me mf mg ip bi translated">首先，我导入了1990年至2019年意大利入境游客的相关数据集，并将其转换为时间序列。数据摘自<a class="ae lk" href="https://ec.europa.eu/eurostat/web/tourism/data/database" rel="noopener ugc nofollow" target="_blank">欧洲统计:旅游业年度数据</a>。我将数据集作为一个<code class="fe ns nt nu nv b">pandas</code>数据帧加载。</p><pre class="kv kw kx ky gu nw nv nx ny aw nz bi"><span id="4cfb" class="oa mw iw nv b gz ob oc l od oe">import pandas as pd</span><span id="75ce" class="oa mw iw nv b gz of oc l od oe">df = pd.read_csv('source/tourist_arrivals.csv')<br/>df.head()</span></pre><figure class="kv kw kx ky gu kz gi gj paragraph-image"><div class="gi gj og"><img src="../Images/ff9a6f46b46b4b9dfe22e3c2b14e17be.png" data-original-src="https://miro.medium.com/v2/resize:fit:932/format:webp/1*ydZOb8V9ERuw4SHBx1HiOQ.png"/></div><p class="lg lh gk gi gj li lj bd b be z dk translated">作者图片</p></figure><h1 id="0af9" class="mv mw iw bd mx my mz na nb nc nd ne nf kl ng km nh ko ni kp nj kr nk ks nl nm bi translated">构建时间序列</h1><p id="2009" class="pw-post-body-paragraph ll lm iw ln b lo nn kg lq lr no kj lt lu np lw lx ly nq ma mb mc nr me mf mg ip bi translated">现在，我通过以下两个步骤将数据集转换为时间序列:</p><ul class=""><li id="b4f4" class="mh mi iw ln b lo lp lr ls lu mj ly mk mc ml mg mm mn mo mp bi translated">包含日期的列必须转换为datetime。这可以通过函数<code class="fe ns nt nu nv b">to_datetime()</code>来完成，该函数将字符串转换成日期时间。</li><li id="c2fe" class="mh mi iw ln b lo mq lr mr lu ms ly mt mc mu mg mm mn mo mp bi translated">将dataframe的索引设置为包含日期的列。这可以通过应用于数据框的功能<code class="fe ns nt nu nv b">set_index()</code>来完成。</li></ul><pre class="kv kw kx ky gu nw nv nx ny aw nz bi"><span id="65c6" class="oa mw iw nv b gz ob oc l od oe">df['date'] = pd.to_datetime(df['date'])<br/>df.set_index('date', inplace=True)<br/>ts = df['value']</span></pre><p id="731e" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated">在开始分析之前，我先画出时间序列。我用的是<code class="fe ns nt nu nv b">matplotlib</code>库。</p><pre class="kv kw kx ky gu nw nv nx ny aw nz bi"><span id="f817" class="oa mw iw nv b gz ob oc l od oe">import matplotlib.pyplot as plt</span><span id="0f00" class="oa mw iw nv b gz of oc l od oe">plt.plot(ts)<br/>plt.title('Number of tourists arrivals to Italy')<br/>plt.ylabel('Number of tourists arrivals')<br/>plt.grid()<br/>plt.show()</span></pre><figure class="kv kw kx ky gu kz gi gj paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="gi gj oh"><img src="../Images/b124d378c0dfa1274bd55415f41a12fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6YW-dlZ3J-3cTjSK4Knbog.png"/></div></div><p class="lg lh gk gi gj li lj bd b be z dk translated">作者图片</p></figure><h1 id="4997" class="mv mw iw bd mx my mz na nb nc nd ne nf kl ng km nh ko ni kp nj kr nk ks nl nm bi translated">时间序列分裂</h1><p id="5e9d" class="pw-post-body-paragraph ll lm iw ln b lo nn kg lq lr no kj lt lu np lw lx ly nq ma mb mc nr me mf mg ip bi translated">通常，在执行时间序列分析时，不会将时间序列拆分为训练集和测试集，因为要获得良好的预测，需要所有的时间序列。</p><p id="01f5" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated">但是，在本教程中，我将时间序列分为两部分——训练和测试——以便测试测试模型的性能。我把时间序列的第一部分作为训练集，第二部分作为测试集。</p><p id="f0c0" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated">每个模型将在训练集上训练，并在测试集上测试。</p><pre class="kv kw kx ky gu nw nv nx ny aw nz bi"><span id="acd4" class="oa mw iw nv b gz ob oc l od oe">ts_train = ts[:'2019-03-01']<br/>ts_test = ts['2019-04-01':]</span></pre><h1 id="6eb7" class="mv mw iw bd mx my mz na nb nc nd ne nf kl ng km nh ko ni kp nj kr nk ks nl nm bi translated">检查平稳性</h1><p id="c0aa" class="pw-post-body-paragraph ll lm iw ln b lo nn kg lq lr no kj lt lu np lw lx ly nq ma mb mc nr me mf mg ip bi translated">平稳时间序列是指具有稳定/恒定统计特性的时间序列，例如一段时间内的均值和方差。</p><p id="8db3" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated">对平稳的时间序列进行长期预测是可能的。因此，我必须测试训练时间序列是否是平稳的。这可以通过增强的Dickey-Fuller测试来完成，由<code class="fe ns nt nu nv b">statsmodels</code>包的<code class="fe ns nt nu nv b">adfuller()</code>函数实现。<code class="fe ns nt nu nv b">adfuller()</code>测试返回测试统计数据<code class="fe ns nt nu nv b">adf</code>、<code class="fe ns nt nu nv b">pvalue</code>和<code class="fe ns nt nu nv b">critical_values</code>。pvalue指定测试结果是否有意义。如果<code class="fe ns nt nu nv b">pvalue &lt; alpha</code>，则测试有意义，其中<code class="fe ns nt nu nv b">alpha</code>是一个小值，例如<code class="fe ns nt nu nv b">0.05</code>。</p><p id="1112" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated">在扩展的Dickey-Fuller检验中，零假设是时间序列不是平稳的。如果测试统计数据<code class="fe ns nt nu nv b">adf</code>大于临界值，则零假设为真。因此，我定义了一个函数，叫做<code class="fe ns nt nu nv b">check_stationarity()</code>，它检查一个时间序列是否是平稳的。</p><pre class="kv kw kx ky gu nw nv nx ny aw nz bi"><span id="56f3" class="oa mw iw nv b gz ob oc l od oe">from statsmodels.tsa.stattools import adfuller<br/>import numpy as np</span><span id="ec44" class="oa mw iw nv b gz of oc l od oe">def check_stationarity(ts):<br/>    dftest = adfuller(ts)<br/>    adf = dftest[0]<br/>    pvalue = dftest[1]<br/>    critical_value = dftest[4]['5%']<br/>    if (pvalue &lt; 0.05) and (adf &lt; critical_value):<br/>        print('The series is stationary')<br/>    else:<br/>        print('The series is NOT stationary')</span></pre><p id="f10f" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated">我用我的时间序列作为参数调用函数:</p><pre class="kv kw kx ky gu nw nv nx ny aw nz bi"><span id="0163" class="oa mw iw nv b gz ob oc l od oe">check_stationarity(ts_train)</span></pre><p id="84d8" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated">它给出了以下输出:</p><pre class="kv kw kx ky gu nw nv nx ny aw nz bi"><span id="bdec" class="oa mw iw nv b gz ob oc l od oe">The series is NOT stationary</span></pre><p id="6b0d" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated">由于时间序列不是平稳的，我转换它，通过差分一次，我再次检查平稳性。</p><pre class="kv kw kx ky gu nw nv nx ny aw nz bi"><span id="b7de" class="oa mw iw nv b gz ob oc l od oe">ts_diff = ts_train.diff()<br/>ts_diff.dropna(inplace=True)<br/>check_stationarity(ts_diff)</span></pre><p id="642f" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated">它给出了以下输出:</p><pre class="kv kw kx ky gu nw nv nx ny aw nz bi"><span id="60da" class="oa mw iw nv b gz ob oc l od oe">The series is stationary</span></pre><p id="3ab3" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated">现在，时间序列是稳定的，因此我可以将训练模型的差序设置为1。</p><pre class="kv kw kx ky gu nw nv nx ny aw nz bi"><span id="65c5" class="oa mw iw nv b gz ob oc l od oe">d = 1</span></pre><p id="d5a4" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated">我画出了不同的时间序列:</p><pre class="kv kw kx ky gu nw nv nx ny aw nz bi"><span id="5189" class="oa mw iw nv b gz ob oc l od oe">plt.plot(ts_diff)<br/>plt.title('Differenced Time Series')<br/>plt.grid()<br/>plt.show()</span></pre><figure class="kv kw kx ky gu kz gi gj paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="gi gj oi"><img src="../Images/02ebe55c7ac21fcbe7e1395d1f5a563e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ppA_HOm4gLta9mWubbuCWg.png"/></div></div><p class="lg lh gk gi gj li lj bd b be z dk translated">作者图片</p></figure><h1 id="911a" class="mv mw iw bd mx my mz na nb nc nd ne nf kl ng km nh ko ni kp nj kr nk ks nl nm bi translated">1 —手动设置模型参数和多步预测</h1><p id="d576" class="pw-post-body-paragraph ll lm iw ln b lo nn kg lq lr no kj lt lu np lw lx ly nq ma mb mc nr me mf mg ip bi translated">第一种方法是使用季节自回归综合移动平均(SARIMA)模型来预测到达意大利的游客数量。</p><p id="90de" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated">SARIMA模型需要三个参数:p、d和q。d的值已经设定，因为它指定了使时间序列平稳所需的积分顺序。</p><p id="7f56" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated">在这种方法中，我尝试通过手动查看部分自相关和相关图来设置模型p和q参数。</p><p id="b7c5" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated">部分自相关(PACF)用于计算p参数。我通过<code class="fe ns nt nu nv b">statsmodels</code>函数<code class="fe ns nt nu nv b">plot_pacf()</code>绘制PACF图。</p><pre class="kv kw kx ky gu nw nv nx ny aw nz bi"><span id="6159" class="oa mw iw nv b gz ob oc l od oe">from statsmodels.graphics.tsaplots import plot_acf, plot_pacf<br/>plot_pacf(ts_diff, lags =12)<br/>plt.show()</span></pre><figure class="kv kw kx ky gu kz gi gj paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="gi gj oj"><img src="../Images/e4360544c6f1244793886741f9164a57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GFRZJW1R5als5fbXPmitiA.png"/></div></div><p class="lg lh gk gi gj li lj bd b be z dk translated">作者图片</p></figure><p id="faf3" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated">我注意到PACF在置信区间外的最大值(浅蓝色)是10。因此，我尝试<code class="fe ns nt nu nv b">p = 10</code>。</p><pre class="kv kw kx ky gu nw nv nx ny aw nz bi"><span id="41e2" class="oa mw iw nv b gz ob oc l od oe">p = 10</span></pre><p id="bc34" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated">现在我绘制自相关(ACF)图来计算q值。</p><pre class="kv kw kx ky gu nw nv nx ny aw nz bi"><span id="d4a8" class="oa mw iw nv b gz ob oc l od oe">plot_acf(ts_diff, lags =12)<br/>plt.show()</span></pre><figure class="kv kw kx ky gu kz gi gj paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="gi gj ok"><img src="../Images/958b0c6e50fd916fd90aa81523481dd3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u5COfqwLAsFg4hjC4p0xDw.png"/></div></div><p class="lg lh gk gi gj li lj bd b be z dk translated">作者图片</p></figure><p id="84b0" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated">ACF超出置信区间的最大值是11。然而，我试着更保守一些，我试着q = 7。</p><pre class="kv kw kx ky gu nw nv nx ny aw nz bi"><span id="e8f2" class="oa mw iw nv b gz ob oc l od oe">q = 7</span></pre><p id="45c8" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated">一旦设置了p、q和d参数，我就可以运行模型了。我利用了<code class="fe ns nt nu nv b">statsmodels</code>的<code class="fe ns nt nu nv b">SARIMAX</code>模型。我创建了模型，并适应了训练时间序列。</p><pre class="kv kw kx ky gu nw nv nx ny aw nz bi"><span id="8235" class="oa mw iw nv b gz ob oc l od oe">from statsmodels.tsa.statespace.sarimax import SARIMAX</span><span id="7f61" class="oa mw iw nv b gz of oc l od oe">model = SARIMAX(ts_train, order=(p,d,q))<br/>model_fit = model.fit()</span></pre><p id="a5aa" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated">我可以使用训练好的模型进行预测。我将利用模型来预测相当于测试时间序列长度的步骤数量。</p><pre class="kv kw kx ky gu nw nv nx ny aw nz bi"><span id="4fdf" class="oa mw iw nv b gz ob oc l od oe">n_test = ts_test.shape[0]<br/>ts_pred = model_fit.forecast(steps=n_test)</span></pre><p id="944d" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated">现在我可以画出测试时间序列和预测值之间的比较。</p><pre class="kv kw kx ky gu nw nv nx ny aw nz bi"><span id="d69b" class="oa mw iw nv b gz ob oc l od oe">plt.plot(ts_pred, label='prediction')<br/>plt.plot(ts_test, label='actual')<br/>plt.title('Multi-step Forecasting (manual parameters)')<br/>plt.legend()<br/>plt.grid()<br/>plt.xticks(rotation=90)<br/>plt.show()</span></pre><figure class="kv kw kx ky gu kz gi gj paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="gi gj ol"><img src="../Images/9420c971edacd71fe6193f11c3877130.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7Zkx8lnA1Js6LIB2jCw0yw.png"/></div></div><p class="lg lh gk gi gj li lj bd b be z dk translated">作者图片</p></figure><p id="2610" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated">为了评估该模型，我计算了归一化均方根误差(NRMSE)指标。</p><pre class="kv kw kx ky gu nw nv nx ny aw nz bi"><span id="58d8" class="oa mw iw nv b gz ob oc l od oe">from statsmodels.tools.eval_measures import rmse<br/>nrmse = rmse(ts_pred, ts_test)/(np.max(ts_test)-np.min(ts_test))<br/>nrmse</span></pre><p id="cba8" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated">它给出了以下输出:</p><pre class="kv kw kx ky gu nw nv nx ny aw nz bi"><span id="594a" class="oa mw iw nv b gz ob oc l od oe">0.06079334505980257</span></pre><h1 id="2039" class="mv mw iw bd mx my mz na nb nc nd ne nf kl ng km nh ko ni kp nj kr nk ks nl nm bi translated">2 —手动设置模型参数和单步预测</h1><p id="f1b2" class="pw-post-body-paragraph ll lm iw ln b lo nn kg lq lr no kj lt lu np lw lx ly nq ma mb mc nr me mf mg ip bi translated">在这种情况下，我利用前面的模型进行单一预测(单一步骤)。然后，我将使用预测结果重新训练该模型，并执行另一次预测。依此类推，直到达到所需的预测数量。</p><pre class="kv kw kx ky gu nw nv nx ny aw nz bi"><span id="fd54" class="oa mw iw nv b gz ob oc l od oe">ts_train_step = ts_train<br/>ts_pred_step = pd.Series()<br/>for i in range(0, n_test):<br/>    model_step = SARIMAX(ts_train_step, order=(p,d,q))<br/>    model_step_fit = model_step.fit()<br/>    current_pred = model_step_fit.forecast(steps=1)<br/>    ts_train_step = ts_train_step.append(current_pred)<br/>    ts_pred_step = ts_pred_step.append(current_pred)</span></pre><p id="4785" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated">我计算了NRMSE误差。</p><pre class="kv kw kx ky gu nw nv nx ny aw nz bi"><span id="cfa9" class="oa mw iw nv b gz ob oc l od oe">nrmse = rmse(ts_pred_step, ts_test)/(np.max(ts_test)-np.min(ts_test))<br/>nrmse</span></pre><p id="7879" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated">它给出了以下输出:</p><pre class="kv kw kx ky gu nw nv nx ny aw nz bi"><span id="e3f8" class="oa mw iw nv b gz ob oc l od oe">0.06226085324175411</span></pre><p id="9da9" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated">我注意到单步模型比多步模型表现稍差。或许，单步模型更适合长期预测。</p><pre class="kv kw kx ky gu nw nv nx ny aw nz bi"><span id="2e70" class="oa mw iw nv b gz ob oc l od oe">plt.plot(ts_test, label='actual')<br/>plt.plot(ts_pred_step, label='prediction step')<br/>plt.title('Single-step Forecasting (manual parameters)')<br/>plt.legend()<br/>plt.grid()<br/>plt.xticks(rotation=90)<br/>plt.show()</span></pre><figure class="kv kw kx ky gu kz gi gj paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="gi gj om"><img src="../Images/882980db09bda76731c83a5a19e542f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vxdebe5lVJzNbRclY2GmNg.png"/></div></div><p class="lg lh gk gi gj li lj bd b be z dk translated">作者图片</p></figure><h1 id="4ecc" class="mv mw iw bd mx my mz na nb nc nd ne nf kl ng km nh ko ni kp nj kr nk ks nl nm bi translated">3 —模型参数的自动设置和多步预测</h1><p id="4554" class="pw-post-body-paragraph ll lm iw ln b lo nn kg lq lr no kj lt lu np lw lx ly nq ma mb mc nr me mf mg ip bi translated">在这种情况下，我利用<code class="fe ns nt nu nv b">pmdarima</code> Python库来自动调整SARIMA p和q参数。具体来说，我利用了<code class="fe ns nt nu nv b">auto_arima()</code>函数，它接收p和q参数的测试范围以及其他有用的信息作为输入。我设置<code class="fe ns nt nu nv b">stepwise=False</code>是为了测试p和q的所有可能组合。此外，我将设置<code class="fe ns nt nu nv b">seasonal=True</code>使用一个萨里玛模型。</p><pre class="kv kw kx ky gu nw nv nx ny aw nz bi"><span id="0ed0" class="oa mw iw nv b gz ob oc l od oe">import pmdarima as pm<br/>stepwise_model = pm.auto_arima(ts_train,start_p=1, d=1, start_q=1,<br/>                            max_p=12, max_q=12,<br/>                            m=12,<br/>                            seasonal=True, stationary=False,<br/>                            information_criterion='aic',<br/>                            stepwise=False,<br/>                            suppress_warnings=True)<br/>stepwise_model.fit(ts_train)</span></pre><p id="e189" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated">所获得的模型具有以下参数:</p><pre class="kv kw kx ky gu nw nv nx ny aw nz bi"><span id="a040" class="oa mw iw nv b gz ob oc l od oe">ARIMA(order=(1, 1, 3), seasonal_order=(0, 1, 0, 12), suppress_warnings=True)</span></pre><p id="6eef" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated">现在我用最好的模型进行预测。</p><pre class="kv kw kx ky gu nw nv nx ny aw nz bi"><span id="5220" class="oa mw iw nv b gz ob oc l od oe">ts_pred_auto = stepwise_model.predict(n_periods=n_test)</span></pre><p id="81be" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated">我绘制结果。</p><pre class="kv kw kx ky gu nw nv nx ny aw nz bi"><span id="a8d5" class="oa mw iw nv b gz ob oc l od oe">plt.plot(ts_test.index,ts_pred_auto, label='auto sarima')<br/>plt.plot(ts_test, label='actual')<br/>plt.title('Single-step Forecasting (automatic parameters)')<br/>plt.grid()<br/>plt.xticks(rotation=90)<br/>plt.legend()<br/>plt.show()</span></pre><figure class="kv kw kx ky gu kz gi gj paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="gi gj on"><img src="../Images/8ee2ad10c6cb15dba53ce58c3588c3e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J5F8bqWYDp1lhjPtDtNZgw.png"/></div></div><p class="lg lh gk gi gj li lj bd b be z dk translated">作者图片</p></figure><p id="bd02" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated">我计算了NRMSE误差。</p><pre class="kv kw kx ky gu nw nv nx ny aw nz bi"><span id="f995" class="oa mw iw nv b gz ob oc l od oe">nrmse = rmse(ts_pred_auto, ts_test)/(np.max(ts_test)-np.min(ts_test))<br/>nrmse</span></pre><p id="28b2" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated">它给出了以下输出:</p><pre class="kv kw kx ky gu nw nv nx ny aw nz bi"><span id="8922" class="oa mw iw nv b gz ob oc l od oe">0.07650715589047709</span></pre><h1 id="f4e2" class="mv mw iw bd mx my mz na nb nc nd ne nf kl ng km nh ko ni kp nj kr nk ks nl nm bi translated">4 —分解</h1><p id="f56d" class="pw-post-body-paragraph ll lm iw ln b lo nn kg lq lr no kj lt lu np lw lx ly nq ma mb mc nr me mf mg ip bi translated">相对于以前的方法，这种方法将时间序列分解成其主要成分，然后分别分析每个成分。</p><p id="e830" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated">首先，我通过<code class="fe ns nt nu nv b">statsmodels</code>库的<code class="fe ns nt nu nv b">seasonal_decompose()</code>函数分解训练时间序列。我利用乘法分解。我获得了原始时间序列的趋势、季节性和残差。我还绘制了分解的时间序列。</p><pre class="kv kw kx ky gu nw nv nx ny aw nz bi"><span id="6924" class="oa mw iw nv b gz ob oc l od oe">from statsmodels.tsa.seasonal import seasonal_decompose</span><span id="9797" class="oa mw iw nv b gz of oc l od oe">ts_decomposed = seasonal_decompose(ts_train,model='multiplicative',extrapolate_trend=True)</span><span id="9629" class="oa mw iw nv b gz of oc l od oe">ts_trend = ts_decomposed.trend<br/>ts_seasonal = ts_decomposed.seasonal<br/>ts_residual = ts_decomposed.resid<br/>ts_decomposed.plot()<br/>plt.show()</span></pre><figure class="kv kw kx ky gu kz gi gj paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="gi gj oo"><img src="../Images/1298fd61ff07134d598b004eb85205bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mxul05ThFt1cF0Wp-xsFoA.png"/></div></div><p class="lg lh gk gi gj li lj bd b be z dk translated">作者图片</p></figure><p id="a5e9" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated">现在我分别分析每一个组成部分。</p><h1 id="555c" class="mv mw iw bd mx my mz na nb nc nd ne nf kl ng km nh ko ni kp nj kr nk ks nl nm bi translated">趋势预测</h1><p id="7810" class="pw-post-body-paragraph ll lm iw ln b lo nn kg lq lr no kj lt lu np lw lx ly nq ma mb mc nr me mf mg ip bi translated">我将建立一个基于多步预测的模型。我检查趋势时间序列是否是平稳的。</p><pre class="kv kw kx ky gu nw nv nx ny aw nz bi"><span id="4c65" class="oa mw iw nv b gz ob oc l od oe">check_stationarity(ts_trend)</span></pre><p id="5656" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated">它给出了以下输出:</p><pre class="kv kw kx ky gu nw nv nx ny aw nz bi"><span id="a302" class="oa mw iw nv b gz ob oc l od oe">The series is NOT stationary</span></pre><p id="f21e" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated">由于趋势时间序列不是平稳的，我尝试对其进行差分。</p><pre class="kv kw kx ky gu nw nv nx ny aw nz bi"><span id="8794" class="oa mw iw nv b gz ob oc l od oe">ts_trend_diff = ts_trend.diff()<br/>ts_trend_diff.dropna(inplace=True)<br/>check_stationarity(ts_trend_diff)</span></pre><p id="27f6" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated">它给出了以下输出:</p><pre class="kv kw kx ky gu nw nv nx ny aw nz bi"><span id="2262" class="oa mw iw nv b gz ob oc l od oe">The series is stationary</span></pre><p id="457d" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated">现在趋势时间序列是稳定的，因此我可以设置d = 1。</p><pre class="kv kw kx ky gu nw nv nx ny aw nz bi"><span id="6b11" class="oa mw iw nv b gz ob oc l od oe">d = 1</span></pre><p id="cdb9" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated">类似地，对于自动设置参数的多步预测，我利用了<code class="fe ns nt nu nv b">auto_arima()</code>函数，指定季节性为假。在这种情况下，我将使用ARIMA模型。</p><pre class="kv kw kx ky gu nw nv nx ny aw nz bi"><span id="ae72" class="oa mw iw nv b gz ob oc l od oe">stepwise_model = pm.auto_arima(ts_trend,start_p=1, d=1, start_q=1,<br/>                            max_p=12, max_q=12,<br/>                            m=12,<br/>                            seasonal=False, stationary=False,<br/>                            information_criterion='aic',<br/>                            stepwise=False,<br/>                            suppress_warnings=True)<br/>stepwise_model.fit(ts_trend)</span></pre><p id="57d3" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated">它返回以下模型:</p><pre class="kv kw kx ky gu nw nv nx ny aw nz bi"><span id="7488" class="oa mw iw nv b gz ob oc l od oe">ARIMA(order=(4, 1, 1), suppress_warnings=True)</span></pre><p id="4a3a" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated">我使用最佳模型进行预测。</p><pre class="kv kw kx ky gu nw nv nx ny aw nz bi"><span id="8324" class="oa mw iw nv b gz ob oc l od oe">trend_pred_auto = stepwise_model.predict(n_periods=n_test)</span></pre><h1 id="f9cd" class="mv mw iw bd mx my mz na nb nc nd ne nf kl ng km nh ko ni kp nj kr nk ks nl nm bi translated">季节性预测</h1><p id="374e" class="pw-post-body-paragraph ll lm iw ln b lo nn kg lq lr no kj lt lu np lw lx ly nq ma mb mc nr me mf mg ip bi translated">我对季节性重复同样的程序。我检查平稳性。</p><pre class="kv kw kx ky gu nw nv nx ny aw nz bi"><span id="b405" class="oa mw iw nv b gz ob oc l od oe">check_stationarity(ts_seasonal)</span></pre><p id="014f" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated">它给出了以下输出:</p><pre class="kv kw kx ky gu nw nv nx ny aw nz bi"><span id="4e4e" class="oa mw iw nv b gz ob oc l od oe">The series is stationary</span></pre><p id="41c0" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated">这个数列是稳定的，所以我设d = 0。</p><pre class="kv kw kx ky gu nw nv nx ny aw nz bi"><span id="2cfa" class="oa mw iw nv b gz ob oc l od oe">d = 0</span></pre><p id="24d7" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated">我将<code class="fe ns nt nu nv b">auto_arima()</code>模型与<code class="fe ns nt nu nv b">seasonal=True</code>一起用于SARIMA模型。</p><pre class="kv kw kx ky gu nw nv nx ny aw nz bi"><span id="76f0" class="oa mw iw nv b gz ob oc l od oe">stepwise_model = pm.auto_arima(ts_seasonal,start_p=1, d=0, start_q=1,<br/>                            max_p=12, max_q=12,<br/>                            m=12,<br/>                            seasonal=True, stationary=True,<br/>                            information_criterion='aic',<br/>                            stepwise=False,<br/>                            suppress_warnings=True)<br/>stepwise_model.fit(ts_seasonal)<br/>seasonal_pred_auto = stepwise_model.predict(n_periods=n_test)</span></pre><p id="4cbb" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated">现在，我可以通过计算季节和趋势分量之间的乘积来合成原始时间序列。</p><pre class="kv kw kx ky gu nw nv nx ny aw nz bi"><span id="3e1b" class="oa mw iw nv b gz ob oc l od oe">ts_pred_decompose = trend_pred_auto * seasonal_pred_auto</span></pre><p id="4b12" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated">我绘制结果。</p><pre class="kv kw kx ky gu nw nv nx ny aw nz bi"><span id="01bb" class="oa mw iw nv b gz ob oc l od oe">plt.plot(ts_test.index, ts_pred_decompose, label='decompose')<br/>plt.plot(ts_test, label='actual')<br/>plt.title('Decomposition')<br/>plt.grid()<br/>plt.xticks(rotation=90)<br/>plt.legend()<br/>plt.show()</span></pre><figure class="kv kw kx ky gu kz gi gj paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="gi gj op"><img src="../Images/2e60f4beaf6dc22e0179d780df15043b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cBwFGauU3-9hcbi00SXJVQ.png"/></div></div><p class="lg lh gk gi gj li lj bd b be z dk translated">作者图片</p></figure><p id="060f" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated">最后，我计算了RMSE误差。</p><pre class="kv kw kx ky gu nw nv nx ny aw nz bi"><span id="0e43" class="oa mw iw nv b gz ob oc l od oe">nrmse = rmse(ts_pred_decompose, ts_test)/(np.max(ts_test)-np.min(ts_test))<br/>nrmse</span></pre><p id="9243" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated">它给出了以下输出:</p><pre class="kv kw kx ky gu nw nv nx ny aw nz bi"><span id="0031" class="oa mw iw nv b gz ob oc l od oe">0.08746142483666638</span></pre><h1 id="0baf" class="mv mw iw bd mx my mz na nb nc nd ne nf kl ng km nh ko ni kp nj kr nk ks nl nm bi translated">摘要</h1><p id="f3fc" class="pw-post-body-paragraph ll lm iw ln b lo nn kg lq lr no kj lt lu np lw lx ly nq ma mb mc nr me mf mg ip bi translated">在本教程中，我举例说明了4种不同的时间序列预测方法:手动和自动设置参数的多步预测，手动设置参数的单步预测，以及分解。</p><p id="bdac" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated">就NRMSE而言，所有方法都有非常相似的行为。但是，在这种特定情况下，最好的模型是<em class="oq">手动设置模型参数和多步预测</em>。</p><p id="af40" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated">如果你想了解我的研究和其他活动的最新情况，你可以在<a class="ae lk" href="https://twitter.com/alod83" rel="noopener ugc nofollow" target="_blank"> Twitter </a>、<a class="ae lk" href="https://www.youtube.com/channel/UC4O8-FtQqGIsgDW_ytXIWOg?view_as=subscriber" rel="noopener ugc nofollow" target="_blank"> Youtube </a>和<a class="ae lk" href="https://github.com/alod83" rel="noopener ugc nofollow" target="_blank"> Github </a>上关注我。</p><h1 id="31cd" class="mv mw iw bd mx my mz na nb nc nd ne nf kl ng km nh ko ni kp nj kr nk ks nl nm bi translated">参考</h1><p id="178e" class="pw-post-body-paragraph ll lm iw ln b lo nn kg lq lr no kj lt lu np lw lx ly nq ma mb mc nr me mf mg ip bi translated"><a class="ae lk" href="https://medium.com/@stallonejacob/time-series-forecast-a-basic-introduction-using-python-414fcb963000" rel="noopener">时间序列预测:使用Python的基本介绍</a></p><p id="464f" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated"><a class="ae lk" rel="noopener" target="_blank" href="/machine-learning-part-19-time-series-and-autoregressive-integrated-moving-average-model-arima-c1005347b0d7"> ARIMA模型Python示例—时间序列预测</a></p><p id="509a" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated"><a class="ae lk" href="https://machinelearningmastery.com/time-series-data-stationary-python/" rel="noopener ugc nofollow" target="_blank">如何用Python检查时间序列数据是否平稳</a></p><h1 id="abf9" class="mv mw iw bd mx my mz na nb nc nd ne nf kl ng km nh ko ni kp nj kr nk ks nl nm bi translated">相关文章</h1><div class="or os gq gs ot ou"><a rel="noopener follow" target="_blank" href="/how-to-model-a-time-series-through-a-sarima-model-e7587f85929c"><div class="ov ab fp"><div class="ow ab ox cl cj oy"><h2 class="bd jg gz z fq oz fs ft pa fv fx jf bi translated">如何通过SARIMA模型对时间序列建模</h2><div class="pb l"><h3 class="bd b gz z fq oz fs ft pa fv fx dk translated">季节性时间序列建模教程。</h3></div><div class="pc l"><p class="bd b dl z fq oz fs ft pa fv fx dk translated">towardsdatascience.com</p></div></div><div class="pd l"><div class="pe l pf pg ph pd pi le ou"/></div></div></a></div><div class="or os gq gs ot ou"><a rel="noopener follow" target="_blank" href="/make-your-machine-learning-model-work-better-with-datetime-features-eb21de397fe8"><div class="ov ab fp"><div class="ow ab ox cl cj oy"><h2 class="bd jg gz z fq oz fs ft pa fv fx jf bi translated">使用日期时间功能使您的机器学习模型更好地工作</h2><div class="pb l"><h3 class="bd b gz z fq oz fs ft pa fv fx dk translated">解释如何从日期和时间中提取新要素的现成教程</h3></div><div class="pc l"><p class="bd b dl z fq oz fs ft pa fv fx dk translated">towardsdatascience.com</p></div></div><div class="pd l"><div class="pj l pf pg ph pd pi le ou"/></div></div></a></div><div class="or os gq gs ot ou"><a rel="noopener follow" target="_blank" href="/how-to-spend-your-time-when-you-are-waiting-for-a-data-analysis-output-e71b383f43cb"><div class="ov ab fp"><div class="ow ab ox cl cj oy"><h2 class="bd jg gz z fq oz fs ft pa fv fx jf bi translated">当你在等待数据分析结果时，你该如何打发时间</h2><div class="pb l"><h3 class="bd b gz z fq oz fs ft pa fv fx dk translated">当你的计算机正在运行你喜欢的算法，而你正在等待的时候，一些建议不要浪费你的时间…</h3></div><div class="pc l"><p class="bd b dl z fq oz fs ft pa fv fx dk translated">towardsdatascience.com</p></div></div><div class="pd l"><div class="pk l pf pg ph pd pi le ou"/></div></div></a></div></div></div>    
</body>
</html>