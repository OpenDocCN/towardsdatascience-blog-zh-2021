<html>
<head>
<title>River: the Best Python Library for Online Machine Learning</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">River:在线机器学习的最佳Python库</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/river-the-best-python-library-for-online-machine-learning-56bf6f71a403?source=collection_archive---------11-----------------------#2021-07-26">https://towardsdatascience.com/river-the-best-python-library-for-online-machine-learning-56bf6f71a403?source=collection_archive---------11-----------------------#2021-07-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="46f6" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">意见</h2><div class=""/><div class=""><h2 id="95a3" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">流数据机器学习的“sklearn”</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/dbcb3edcc8294e8e5fa3d3c7999e3269.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*BRhqUzJ5pcAE3WRN.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">图片由<a class="ae lh" href="https://pixabay.com/users/unboxscience-1306029/" rel="noopener ugc nofollow" target="_blank"> UnboxScience </a>在<a class="ae lh" href="https://pixabay.com/vectors/water-stream-river-creek-flow-wet-908813/" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>拍摄</p></figure><p id="a0c1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">传统的机器学习算法，如线性回归和xgboost，以“批处理”模式运行。也就是说，它们一次性使用完整的数据集来拟合模型。用新数据更新该模型需要使用新数据和旧数据从头开始拟合一个全新的模型。</p><p id="54d3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在许多应用中，这可能是困难的或不可能的！它要求所有的数据都适合内存，这并不总是可能的。模型本身的重新训练可能会很慢。为模型检索旧数据可能是一个很大的挑战，尤其是在数据不断生成的应用程序中。存储历史数据要求数据存储基础设施能够快速返回完整的数据历史。</p><p id="ecec" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">或者，模型可以“在线”或以“流”模式训练。在这种情况下，数据被视为一个流或一系列项目，一个接一个地传递给模型。</p><blockquote class="me mf mg"><p id="8aef" class="li lj mh lk b ll lm kd ln lo lp kg lq mi ls lt lu mj lw lx ly mk ma mb mc md im bi translated"><strong class="lk jd"> <em class="it">增量学习、持续学习</em> </strong>和<strong class="lk jd"> <em class="it">连续学习</em> </strong> <em class="it"> </em>是“在线学习”的首选术语，因为对“在线学习”的搜索主要指向教育网站。</p></blockquote><p id="7233" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">增量学习是许多用例的理想选择，例如在大型数据集上拟合模型、垃圾邮件过滤、推荐系统和物联网应用。</p><h1 id="e176" class="ml mm it bd mn mo mp mq mr ms mt mu mv ki mw kj mx kl my km mz ko na kp nb nc bi translated">介绍河流</h1><p id="8323" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated"><code class="fe ni nj nk nl b"><a class="ae lh" href="https://riverml.xyz/latest/getting-started/getting-started/" rel="noopener ugc nofollow" target="_blank">River</a></code>是一个新的python库，用于在流设置中增量训练机器学习模型。它为不同的在线学习任务提供了最先进的学习算法、数据转换方法和性能指标。它是合并了<code class="fe ni nj nk nl b">creme</code>和<code class="fe ni nj nk nl b">scikit-multiflow</code>库的最好部分的产物，这两个库都是为了相同的目标而构建的:</p><blockquote class="me mf mg"><p id="019f" class="li lj mh lk b ll lm kd ln lo lp kg lq mi ls lt lu mj lw lx ly mk ma mb mc md im bi translated">“为社区提供工具来提升流式机器学习的状态，并促进其在现实世界应用中的使用。”</p></blockquote><p id="50bd" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">River是一个由从业者和研究人员组成的大型社区维护的开源包。源代码可在<a class="ae lh" href="https://github.com/online-ml/river." rel="noopener ugc nofollow" target="_blank"> Github </a>上获得。</p><h2 id="b8ff" class="nm mm it bd mn nn no dn mr np nq dp mv lr nr ns mx lv nt nu mz lz nv nw nb iz bi translated">River中的算法类型</h2><p id="be85" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated"><code class="fe ni nj nk nl b">river</code>为回归、分类和聚类任务提供了一系列增量学习算法。可用的模型类型包括朴素贝叶斯、树集成模型、因式分解机、线性模型等等。有关已实现算法的完整列表，请参见<a class="ae lh" href="https://riverml.xyz/latest/api/overview/" rel="noopener ugc nofollow" target="_blank"> API参考</a>。</p><p id="9f70" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">River还提供漂移检测算法。<a class="ae lh" href="https://riverml.xyz/latest/examples/concept-drift-detection/" rel="noopener ugc nofollow" target="_blank">概念漂移</a>发生在输入数据和目标变量之间的关系改变时。</p><p id="4bf8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">River提供了<a class="ae lh" href="https://riverml.xyz/latest/examples/imbalanced-learning/" rel="noopener ugc nofollow" target="_blank">处理不平衡数据集</a>和异常检测的方法。</p><p id="6939" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">最后，<code class="fe ni nj nk nl b">river</code>提供了模型度量和数据预处理方法，它们已经被重构以处理增量更新。</p><h2 id="5906" class="nm mm it bd mn nn no dn mr np nq dp mv lr nr ns mx lv nt nu mz lz nv nw nb iz bi translated">增量学习算法有什么不同？</h2><p id="1e2e" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">为了增量地转换数据和训练模型，必须重构大多数学习算法和数据转换方法来处理更新。</p><p id="2c66" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">首先，考虑<strong class="lk jd">如何缩放特征以获得零均值和单位方差。</strong>在批量设置中，这很简单:计算平均值和标准差，从每个值中减去平均值，结果除以标准差。这种方法需要完整的数据集，并且不能随着新数据的到来而更新。在流设置中，使用<em class="mh">运行统计</em>完成特征缩放，这是一种数据结构，允许平均值和标准偏差增量更新。</p><p id="2531" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">对于增量式训练模型，常见的学习算法是</strong> <a class="ae lh" rel="noopener" target="_blank" href="/stochastic-gradient-descent-clearly-explained-53d239905d31"> <strong class="lk jd"> <em class="mh">随机梯度下降</em> </strong> </a> <strong class="lk jd"> (SGD)。</strong> SGD是一种用于训练神经网络的流行算法，有多种变体。它还可以用于训练其他模型，如线性回归。SGD的核心思想是在每个训练步骤中，模型参数权重在梯度的相反方向上进行调整，该梯度是使用该步骤中的模型预测误差来计算的。</p><h1 id="06b9" class="ml mm it bd mn mo mp mq mr ms mt mu mv ki mw kj mx kl my km mz ko na kp nb nc bi translated">API河</h1><p id="6a83" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">所有模型都能够从数据中学习并做出预测。<code class="fe ni nj nk nl b">river</code>的模型具有从单一实例中学习的灵活性。每当新数据到达时，模型可以快速更新。</p><ul class=""><li id="dc68" class="nx ny it lk b ll lm lo lp lr nz lv oa lz ob md oc od oe of bi translated"><code class="fe ni nj nk nl b">learn_one(x, y)</code>更新模型的内部状态，给出一个包含输入特征<code class="fe ni nj nk nl b">x</code>和目标值<code class="fe ni nj nk nl b">y</code>的新观察值。</li><li id="bf92" class="nx ny it lk b ll og lo oh lr oi lv oj lz ok md oc od oe of bi translated"><code class="fe ni nj nk nl b">predict_one</code>(分类、回归、聚类)返回单个观察值的模型预测值</li><li id="1b73" class="nx ny it lk b ll og lo oh lr oi lv oj lz ok md oc od oe of bi translated"><code class="fe ni nj nk nl b">predict_proba_one</code>(分类)返回单次观察的模型预测概率</li><li id="2a80" class="nx ny it lk b ll og lo oh lr oi lv oj lz ok md oc od oe of bi translated"><code class="fe ni nj nk nl b">score_one</code>(异常检测)返回单个观察值的异常值</li><li id="4aea" class="nx ny it lk b ll og lo oh lr oi lv oj lz ok md oc od oe of bi translated"><code class="fe ni nj nk nl b">transform_one</code>转换一个输入观察值</li></ul><p id="e7eb" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">要演示API的用法，请参见下面的示例。在该示例中，实例化了线性<code class="fe ni nj nk nl b">LogisticRegression</code>模型和<code class="fe ni nj nk nl b">ROCAUC</code>模型评分对象。然后，对于数据集中的每个观察值，模型使用<code class="fe ni nj nk nl b">predict_proba_one</code>进行预测，并通过将观察值<code class="fe ni nj nk nl b">x</code>和标签<code class="fe ni nj nk nl b">y</code>传递给<code class="fe ni nj nk nl b">learn_one</code>方法来更新其权重。最后，用真实值<code class="fe ni nj nk nl b">y</code>和预测值<code class="fe ni nj nk nl b">y_pred</code>更新模型评分对象<code class="fe ni nj nk nl b">metric.update</code>。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ol om l"/></div></figure><h1 id="594c" class="ml mm it bd mn mo mp mq mr ms mt mu mv ki mw kj mx kl my km mz ko na kp nb nc bi translated">字典数据结构</h1><p id="d12e" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">River希望数据观察能够以python字典的形式呈现。代表功能名称的字典关键字。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="e96e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">字典数据结构有几个优点:</p><ul class=""><li id="88ef" class="nx ny it lk b ll lm lo lp lr nz lv oa lz ob md oc od oe of bi translated">词典是灵活的，不是打字的。因此，它们可以处理稀疏数据和可能出现在数据流中的新功能。</li><li id="0e81" class="nx ny it lk b ll og lo oh lr oi lv oj lz ok md oc od oe of bi translated">字典数据是轻量级的，不需要复杂数据结构(如<code class="fe ni nj nk nl b">numpy.ndarray</code>或<code class="fe ni nj nk nl b">pandas.DataFrame</code>)所需的开销。这使得在流式环境中快速处理单个观察更容易。</li></ul><p id="208b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">River扩展了原生python字典结构，以支持更高效的数据操作。</p><p id="736e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe ni nj nk nl b">river</code>中的<code class="fe ni nj nk nl b">stream</code>模块提供了几个用于处理流数据的实用程序，包括将数据加载到预期的字典格式中。</p><p id="9805" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">例如，<code class="fe ni nj nk nl b">stream.iter_csv</code>方法允许您将CSV文件加载到流数据结构中。在下面的例子中，“loaded”<code class="fe ni nj nk nl b">data_stream</code>实际上是一个python生成器，它遍历CSV文件并解析每个值。整个数据集不是一次从磁盘中读取，而是一次读取一个样本。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ol om l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated"><em class="on">典例出自</em> <a class="ae lh" href="https://riverml.xyz/latest/user-guide/reading-data/" rel="noopener ugc nofollow" target="_blank"> <em class="on">河文献</em> </a> <em class="on">。</em></p></figure><p id="cce8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">以上<code class="fe ni nj nk nl b">stream.iter_csv</code>示例中使用的一些附加参数:</p><ul class=""><li id="a70b" class="nx ny it lk b ll lm lo lp lr nz lv oa lz ob md oc od oe of bi translated"><code class="fe ni nj nk nl b">converters</code>参数指定非字符串列的数据类型。如果在加载时没有指定数据类型，<code class="fe ni nj nk nl b">stream.iter_csv</code>假设所有数据都是字符串。</li><li id="0223" class="nx ny it lk b ll og lo oh lr oi lv oj lz ok md oc od oe of bi translated"><code class="fe ni nj nk nl b">parse_dates</code>表示解析日期的预期格式。</li><li id="e56a" class="nx ny it lk b ll og lo oh lr oi lv oj lz ok md oc od oe of bi translated"><code class="fe ni nj nk nl b">target</code>指定哪个变量是目标，或<code class="fe ni nj nk nl b">y</code>列。如果排除，<code class="fe ni nj nk nl b">y</code>返回为<code class="fe ni nj nk nl b">None</code>。</li></ul><p id="6906" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在像web应用程序这样的应用程序中，字典数据结构非常直观。您可以简单地将一个JSON结构的有效负载传递给一个模型，以进行预测或更新模型。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ol om l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated"><em class="on">代码示例来自</em> <a class="ae lh" href="https://riverml.xyz/latest/user-guide/reading-data/" rel="noopener ugc nofollow" target="_blank"> <em class="on">河流文档</em> </a> <em class="on">。</em></p></figure><h1 id="41fa" class="ml mm it bd mn mo mp mq mr ms mt mu mv ki mw kj mx kl my km mz ko na kp nb nc bi translated">河流管道</h1><p id="bde6" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">管道是<code class="fe ni nj nk nl b">river</code>的核心组成部分。与<code class="fe ni nj nk nl b">scikit-learn</code>类似，管道将模型的各个步骤，包括数据转换和预处理，链接到一个序列中。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ol om l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">河流用户指南中的代码示例(<a class="ae lh" href="https://riverml.xyz/latest/user-guide/pipelines/" rel="noopener ugc nofollow" target="_blank">管道—河流(riverml.xyz) </a>)</p></figure><p id="11e3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如<a class="ae lh" href="https://riverml.xyz/latest/examples/the-art-of-using-pipelines/" rel="noopener ugc nofollow" target="_blank">使用管道的艺术</a>教程所示，当特征预处理步骤变得复杂时，管道简化了模型拟合代码。它使代码可读性更强，更不容易出错。</p><p id="627d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">需要注意的重要行为:<strong class="lk jd">当在管道上调用</strong> <code class="fe ni nj nk nl b"><strong class="lk jd">predict_one</strong></code> <strong class="lk jd">或</strong> <code class="fe ni nj nk nl b"><strong class="lk jd">predict_proba_one</strong></code> <strong class="lk jd">方法时，模型的非监督部分被更新</strong>！无监督部分包括特征缩放和其他变换。这和批量机器学习有很大不同。像要素缩放这样的变换不依赖于地面实况标签，因此可以在没有地面实况标签的情况下进行更新。当然，除了转换方法之外，管道的<code class="fe ni nj nk nl b">learn_one</code>方法还会更新受监控的组件。</p><h1 id="8c08" class="ml mm it bd mn mo mp mq mr ms mt mu mv ki mw kj mx kl my km mz ko na kp nb nc bi translated">简单的例子</h1><p id="6892" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">以下示例演示了如何在乳腺癌数据集上拟合逻辑回归模型。</p><p id="482f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">首先，实例化标准数据缩放器和逻辑回归模型。给逻辑回归模型一个学习率为0.01的随机梯度下降优化器进行训练。然后，初始化真实值和预测值的列表。</p><p id="c957" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然后，代码遍历数据集；每个<code class="fe ni nj nk nl b">xi</code>都是一个字典对象。在for循环的每一步中，代码需要4个步骤:</p><ol class=""><li id="733d" class="nx ny it lk b ll lm lo lp lr nz lv oa lz ob md oo od oe of bi translated">用新的观测值更新定标器，并对观测值进行定标。</li><li id="bded" class="nx ny it lk b ll og lo oh lr oi lv oj lz ok md oo od oe of bi translated">该模型使用缩放后的观察值进行预测。</li><li id="70ce" class="nx ny it lk b ll og lo oh lr oi lv oj lz ok md oo od oe of bi translated">模型将使用新的观察和标签进行更新。</li><li id="a9da" class="nx ny it lk b ll og lo oh lr oi lv oj lz ok md oo od oe of bi translated">真实标签和预测标签存储在一个列表中。</li></ol><p id="4819" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">当for循环结束时，计算总ROC AUC。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ol om l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">改编自<a class="ae lh" href="https://riverml.xyz/latest/examples/batch-to-online/" rel="noopener ugc nofollow" target="_blank">河(riverml.xyz) </a>文档的代码示例</p></figure><p id="4d2d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这段代码可以改进和简化。在下面的示例中，为相同的任务训练了逻辑回归模型，但是使用管道和运行度量来减少步骤数量并增强可读性。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ol om l"/></div></figure><h1 id="57af" class="ml mm it bd mn mo mp mq mr ms mt mu mv ki mw kj mx kl my km mz ko na kp nb nc bi translated">结论</h1><p id="d4a0" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated"><code class="fe ni nj nk nl b">river</code>是增量学习和持续学习的首选库。它提供了一系列数据转换方法、学习算法和优化算法。其独特的数据结构非常适合流数据和web应用程序的设置。</p><h1 id="d06f" class="ml mm it bd mn mo mp mq mr ms mt mu mv ki mw kj mx kl my km mz ko na kp nb nc bi translated">参考资料和进一步阅读</h1><p id="bc79" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">如何使用River的例子:【https://riverml.xyz/latest/examples/batch-to-online/】T4</p><p id="a37f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">用户指南:<a class="ae lh" href="https://riverml.xyz/latest/user-guide/reading-data/" rel="noopener ugc nofollow" target="_blank">https://riverml.xyz/latest/user-guide/reading-data/</a></p><p id="f71d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">河纸:<a class="ae lh" href="https://arxiv.org/abs/2012.04740" rel="noopener ugc nofollow" target="_blank">https://arxiv.org/abs/2012.04740</a></p><div class="op oq gp gr or os"><a href="https://alexandra-amidon.medium.com/membership" rel="noopener follow" target="_blank"><div class="ot ab fo"><div class="ou ab ov cl cj ow"><h2 class="bd jd gy z fp ox fr fs oy fu fw jc bi translated">阅读亚历山德拉·阿米登(以及媒体上成千上万的其他作家)的每一个故事</h2><div class="oz l"><h3 class="bd b gy z fp ox fr fs oy fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="pa l"><p class="bd b dl z fp ox fr fs oy fu fw dk translated">alexandra-amidon.medium.com</p></div></div></div></a></div></div></div>    
</body>
</html>