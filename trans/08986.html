<html>
<head>
<title>3D Volumes Augmentation for Tumor Segmentation using Monai</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于Monai的肿瘤分割三维体积增强</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/3d-volumes-augmentation-for-tumor-segmentation-using-monai-1b6d92b34813?source=collection_archive---------8-----------------------#2021-08-19">https://towardsdatascience.com/3d-volumes-augmentation-for-tumor-segmentation-using-monai-1b6d92b34813?source=collection_archive---------8-----------------------#2021-08-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="7033" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用Python和Monai来扩充用于肿瘤或器官分割的数据集。</h2></div><blockquote class="kf kg kh"><p id="c00f" class="ki kj kk kl b km kn jr ko kp kq ju kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">原创文章在我的网站，<a class="ae lf" href="https://pycad.co/3d-volumes-augmentation-for-tumor-segmentation/" rel="noopener ugc nofollow" target="_blank"> <strong class="kl ir"> <em class="iq">这里</em> </strong> </a>。还有这个故事的视频版<a class="ae lf" href="https://www.youtube.com/watch?v=bh9uyUbsj7U&amp;t=156s" rel="noopener ugc nofollow" target="_blank"> <strong class="kl ir">这里</strong> </a>。</p></blockquote><h1 id="ab9f" class="lg lh iq bd li lj lk ll lm ln lo lp lq jw lr jx ls jz lt ka lu kc lv kd lw lx bi translated">介绍</h1><p id="2e55" class="pw-post-body-paragraph ki kj iq kl b km ly jr ko kp lz ju kr ma mb ku kv mc md ky kz me mf lc ld le ij bi translated">我们在<a class="ae lf" rel="noopener" target="_blank" href="/preprocessing-3d-volumes-for-tumor-segmentation-using-monai-and-pytorch-eaeb3d718570"> <strong class="kl ir"> <em class="kk">上一篇文章</em> </strong> </a>中讨论了如何为肿瘤分割预处理3D体积，因此在本文中，我们将讨论处理深度学习项目时的另一个重要步骤。这是数据扩充步骤。</p><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi mg"><img src="../Images/8823a9e044de4cf7e19a848692e155dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sRnHma4S16hb7FO_I4dRdQ.jpeg"/></div></div><p class="ms mt gj gh gi mu mv bd b be z dk translated">图片来自MART PRODUCTION的<a class="ae lf" href="https://www.pexels.com/photo/people-woman-men-women-7089006/" rel="noopener ugc nofollow" target="_blank">像素</a></p></figure><h1 id="f514" class="lg lh iq bd li lj lk ll lm ln lo lp lq jw lr jx ls jz lt ka lu kc lv kd lw lx bi translated">什么是数据增强？</h1><p id="69d3" class="pw-post-body-paragraph ki kj iq kl b km ly jr ko kp lz ju kr ma mb ku kv mc md ky kz me mf lc ld le ij bi translated">我们都知道，为了训练一个神经网络，需要大量的数据，以便获得一个准确的模型以及一个可以在特定任务中处理大多数情况的稳健模型。然而，在任何任务中，尤其是在医疗保健项目中，并不总是能够获得大量的自然数据。因为医学成像中的一个输入是具有多个切片的单个患者，我们都知道汇集这种类型的数据(大量患者)的数据集有多困难。</p><p id="46e1" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr ma kt ku kv mc kx ky kz me lb lc ld le ij bi translated">为此，我们必须通过创建合成数据来帮助自己，以便稍微改善我们的结果。</p><p id="9b2e" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr ma kt ku kv mc kx ky kz me lb lc ld le ij bi translated"><a class="ae lf" href="https://www.youtube.com/watch?v=bh9uyUbsj7U&amp;t=156s" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=bh9uyUbsj7U&amp;t = 156s</a></p><p id="875f" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr ma kt ku kv mc kx ky kz me lb lc ld le ij bi translated">这些合成数据的生成被称为数据扩充，这意味着我们从数据集开始，然后执行一些转换以生成新数据。</p><h1 id="9f53" class="lg lh iq bd li lj lk ll lm ln lo lp lq jw lr jx ls jz lt ka lu kc lv kd lw lx bi translated">工具和操作</h1><p id="4d75" class="pw-post-body-paragraph ki kj iq kl b km ly jr ko kp lz ju kr ma mb ku kv mc md ky kz me mf lc ld le ij bi translated">如果你以前在2D图像中为一个正常任务的项目做过数据增强，你会明白我想说什么；否则不用担心，我们会走一步看一步，直到有结果。</p><p id="21ec" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr ma kt ku kv mc kx ky kz me lb lc ld le ij bi translated">为了生成这些合成数据，我们必须首先对原始数据应用一些仿射变换。这些变换可以包括旋转、缩放、平移(移位)、噪声、翻转等等。</p><p id="e1ee" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr ma kt ku kv mc kx ky kz me lb lc ld le ij bi translated">但是要小心，因为在处理普通图像时，我们可以使用这些变换中的任何一种；然而，当处理医学图像时，我们不能使用所有的变换，因为它可能创建与人体无关的形状，这不是重点。</p><p id="4092" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr ma kt ku kv mc kx ky kz me lb lc ld le ij bi translated">由于我们将使用3D体积，如果我们不小心的话，转换会更糟。</p><p id="8a96" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr ma kt ku kv mc kx ky kz me lb lc ld le ij bi translated">我们将始终使用用于处理该操作的同一个monai。对于那些不熟悉monai的人来说，它是一个基于Pytorch的开源框架，可用于对医学图像进行分割或分类。</p><h1 id="47b2" class="lg lh iq bd li lj lk ll lm ln lo lp lq jw lr jx ls jz lt ka lu kc lv kd lw lx bi translated">可以使用的变换有哪些？</h1><p id="e890" class="pw-post-body-paragraph ki kj iq kl b km ly jr ko kp lz ju kr ma mb ku kv mc md ky kz me mf lc ld le ij bi translated">以我的经验来看，能随机混合在一起产生合成病人的转化只有几个。以下是我发现的最有效的转换:</p><ul class=""><li id="81a3" class="mw mx iq kl b km kn kp kq ma my mc mz me na le nb nc nd ne bi translated"><em class="kk">翻转</em></li><li id="c687" class="mw mx iq kl b km nf kp ng ma nh mc ni me nj le nb nc nd ne bi translated"><em class="kk">旋转</em></li><li id="2510" class="mw mx iq kl b km nf kp ng ma nh mc ni me nj le nb nc nd ne bi translated"><em class="kk">移(译)</em></li><li id="f547" class="mw mx iq kl b km nf kp ng ma nh mc ni me nj le nb nc nd ne bi translated"><em class="kk">高斯噪声</em></li></ul><p id="589a" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr ma kt ku kv mc kx ky kz me lb lc ld le ij bi translated">因此，我将向您展示如何使用monai轻松应用这些转换。</p><p id="e875" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr ma kt ku kv mc kx ky kz me lb lc ld le ij bi translated">关于如何应用这些变换，你应该知道一些事情。如前所述，monai基于Python，因此没有像tensorflow这样的特定函数可以根据您在参数中提供的数字生成特定数量的数据。相反，有三种方法可以用monai扩充数据。</p><p id="7ff1" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr ma kt ku kv mc kx ky kz me lb lc ld le ij bi translated"><strong class="kl ir"> <em class="kk"> 1- </em> </strong>首先是在训练时使用变换。这意味着在训练的每个时期，你应用不同于前一个时期的变换，所以如果你做100个时期，你将得到100个不同的数据表示。</p><blockquote class="kf kg kh"><p id="3342" class="ki kj kk kl b km kn jr ko kp kq ju kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated"><strong class="kl ir"> PS: </strong>数据量将与之前相同，但是变换将随着每个时期而改变。</p></blockquote><p id="a7a0" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr ma kt ku kv mc kx ky kz me lb lc ld le ij bi translated"><strong class="kl ir"> <em class="kk"> 2- </em> </strong>第二种方法是在训练前应用变换，并在使用增加的数据量(您的数据加上生成的患者)启动训练前保存新的合成数据。</p><p id="feb7" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr ma kt ku kv mc kx ky kz me lb lc ld le ij bi translated"><strong class="kl ir"> <em class="kk"> 3- </em> </strong>第三个与第二个几乎相同，除了您将应用变换并将生成的数据保存在张量中，这意味着仅在RAM中，训练将自动开始(当您使用tensorflow时，情况相同，但在这种情况下，您需要自己创建保存在RAM中的函数)。</p></div><div class="ab cl nk nl hu nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="ij ik il im in"><p id="5b66" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr ma kt ku kv mc kx ky kz me lb lc ld le ij bi translated">对我来说，我尝试了第一种和第二种方法；第二种方法对我最有效，我会解释为什么。正如我之前所说，当我们使用这种仿射变换时，我们可以获得一些现实中不存在的形状，这会影响训练，因此您应该单独创建合成数据，验证它，然后使用它进行训练。</p><p id="0ca2" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr ma kt ku kv mc kx ky kz me lb lc ld le ij bi translated">然而，我将演示如何做到这两者，第一和第二。</p><h1 id="45ee" class="lg lh iq bd li lj lk ll lm ln lo lp lq jw lr jx ls jz lt ka lu kc lv kd lw lx bi translated">编码部分</h1><p id="87f7" class="pw-post-body-paragraph ki kj iq kl b km ly jr ko kp lz ju kr ma mb ku kv mc md ky kz me mf lc ld le ij bi translated">在我们复习了理论之后，让我们开始编码这些变换。我们需要做的第一件事是创建一个字典来帮助我们处理数据和标签；这里就不赘述了，因为你可以在之前的这篇文章中找到解释。<a class="ae lf" href="https://pycad.co/preprocessing-3d-volumes-for-tumor-segmentation-using-monai-and-pytorch/" rel="noopener ugc nofollow" target="_blank"> <strong class="kl ir"> <em class="kk">这里是编字典的代码</em> </strong> </a>。</p><figure class="mh mi mj mk gt ml"><div class="bz fp l di"><div class="nr ns l"/></div><p class="ms mt gj gh gi mu mv bd b be z dk translated"><em class="nt">作者编写的代码</em></p></figure><p id="7d8f" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr ma kt ku kv mc kx ky kz me lb lc ld le ij bi translated">如前所述，我将演示如何使用第一种和第二种方法进行数据扩充。</p><h1 id="51bf" class="lg lh iq bd li lj lk ll lm ln lo lp lq jw lr jx ls jz lt ka lu kc lv kd lw lx bi translated">训练期间的数据扩充</h1><p id="8cd0" class="pw-post-body-paragraph ki kj iq kl b km ly jr ko kp lz ju kr ma mb ku kv mc md ky kz me mf lc ld le ij bi translated">如果您在训练期间使用增强，您将把变换与预处理部分结合起来，以便每个患者同时进行预处理和变换。</p><p id="cf5c" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr ma kt ku kv mc kx ky kz me lb lc ld le ij bi translated">以下是我们将采用的转换:</p><ul class=""><li id="07e2" class="mw mx iq kl b km kn kp kq ma my mc mz me na le nb nc nd ne bi translated"><strong class="kl ir"> <em class="kk">翻页</em> </strong> →使用字典时翻页</li><li id="88a3" class="mw mx iq kl b km nf kp ng ma nh mc ni me nj le nb nc nd ne bi translated"><strong class="kl ir"> <em class="kk">旋转</em> </strong> →将旋转应用于字典</li><li id="23c6" class="mw mx iq kl b km nf kp ng ma nh mc ni me nj le nb nc nd ne bi translated"><strong class="kl ir"> <em class="kk">缩放</em> </strong> →应用缩放</li><li id="4f19" class="mw mx iq kl b km nf kp ng ma nh mc ni me nj le nb nc nd ne bi translated"><strong class="kl ir"> <em class="kk">高斯噪声化</em> </strong> →对字典应用高斯噪声</li><li id="3bf5" class="mw mx iq kl b km nf kp ng ma nh mc ni me nj le nb nc nd ne bi translated">最后还有<strong class="kl ir"><em class="kk">rand affinited</em></strong>→其实这个函数可以同时进行多次变换；我们将使用它来执行<em class="kk">平移</em>，但是如果您不想使用<strong class="kl ir"> <em class="kk">旋转</em> </strong>功能，您也可以使用它来执行<em class="kk">旋转</em>。</li></ul><p id="398c" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr ma kt ku kv mc kx ky kz me lb lc ld le ij bi translated">以下是使用预处理和转换函数生成合成数据的代码:</p><figure class="mh mi mj mk gt ml"><div class="bz fp l di"><div class="nr ns l"/></div><p class="ms mt gj gh gi mu mv bd b be z dk translated">作者编写的代码</p></figure></div><div class="ab cl nk nl hu nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="ij ik il im in"><h1 id="305e" class="lg lh iq bd li lj nu ll lm ln nv lp lq jw nw jx ls jz nx ka lu kc ny kd lw lx bi translated">训练前的数据扩充</h1><p id="16d8" class="pw-post-body-paragraph ki kj iq kl b km ly jr ko kp lz ju kr ma mb ku kv mc md ky kz me mf lc ld le ij bi translated">这一节与上一节类似，但是在应用了变换之后，我们需要添加一个函数，将torch张量保存到nifti文件中。我们将使用本文中讨论的方法来实现这一点。</p><p id="6118" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr ma kt ku kv mc kx ky kz me lb lc ld le ij bi translated">现在由您决定是只生成数据并保存它，还是进行预处理和扩充，然后保存所有数据，这样您就不需要在训练阶段进行任何转换。但是我会把两个都给你看，你可以挑一个你喜欢的。</p><h2 id="898f" class="nz lh iq bd li oa ob dn lm oc od dp lq ma oe of ls mc og oh lu me oi oj lw ok bi translated">使用预处理</h2><p id="2862" class="pw-post-body-paragraph ki kj iq kl b km ly jr ko kp lz ju kr ma mb ku kv mc md ky kz me mf lc ld le ij bi translated">如果您想同时进行预处理和数据扩充，您可以使用前面方法中的代码，但是我们将添加另一个代码来保存卷。</p><p id="de32" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr ma kt ku kv mc kx ky kz me lb lc ld le ij bi translated"><em class="kk">预处理+增强的代码</em>:</p><figure class="mh mi mj mk gt ml"><div class="bz fp l di"><div class="nr ns l"/></div><p class="ms mt gj gh gi mu mv bd b be z dk translated">作者编写的代码</p></figure><h2 id="1362" class="nz lh iq bd li oa ob dn lm oc od dp lq ma oe of ls mc og oh lu me oi oj lw ok bi translated">无需预处理</h2><p id="5b6e" class="pw-post-body-paragraph ki kj iq kl b km ly jr ko kp lz ju kr ma mb ku kv mc md ky kz me mf lc ld le ij bi translated"><em class="kk">不经预处理进行代码增强</em>:</p><figure class="mh mi mj mk gt ml"><div class="bz fp l di"><div class="nr ns l"/></div><p class="ms mt gj gh gi mu mv bd b be z dk translated">作者编写的代码</p></figure></div><div class="ab cl nk nl hu nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="ij ik il im in"><p id="b0a3" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr ma kt ku kv mc kx ky kz me lb lc ld le ij bi translated">这是同一个切片，但有不同的变换，就像我们刚才说的那样:</p><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi ol"><img src="../Images/76b8dd05b206e9b02cc5018334b04880.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hth-6QJ3MaW2FgqjqnFhbw.png"/></div></div><p class="ms mt gj gh gi mu mv bd b be z dk translated">作家创造的形象</p></figure></div><div class="ab cl nk nl hu nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="ij ik il im in"><p id="1976" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr ma kt ku kv mc kx ky kz me lb lc ld le ij bi translated">然后我们用这个函数把torch张量转换成一个numpy数组，然后再转换成nifti，你可以在<a class="ae lf" href="https://pycad.co/how-to-convert-array-into-nifti-python/" rel="noopener ugc nofollow" target="_blank"> <strong class="kl ir"> <em class="kk">这篇文章</em> </strong> </a>中找到解释。</p><figure class="mh mi mj mk gt ml"><div class="bz fp l di"><div class="nr ns l"/></div><p class="ms mt gj gh gi mu mv bd b be z dk translated">作者编写的代码</p></figure><p id="e76e" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr ma kt ku kv mc kx ky kz me lb lc ld le ij bi translated">现在，我们必须创建一个循环，它将应用我们指定的运行次数的各种转换；这个运行次数将乘以数据量。这是我使用的循环:</p><figure class="mh mi mj mk gt ml"><div class="bz fp l di"><div class="nr ns l"/></div><p class="ms mt gj gh gi mu mv bd b be z dk translated">作者编写的代码</p></figure><h1 id="61a0" class="lg lh iq bd li lj lk ll lm ln lo lp lq jw lr jx ls jz lt ka lu kc lv kd lw lx bi translated">显示合成患者</h1><p id="b757" class="pw-post-body-paragraph ki kj iq kl b km ly jr ko kp lz ju kr ma mb ku kv mc md ky kz me mf lc ld le ij bi translated">我们来看一个转化前后的患者。这是将用于创建数据加载器的代码:</p><figure class="mh mi mj mk gt ml"><div class="bz fp l di"><div class="nr ns l"/></div><p class="ms mt gj gh gi mu mv bd b be z dk translated">作者编写的代码</p></figure><p id="7efd" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr ma kt ku kv mc kx ky kz me lb lc ld le ij bi translated"><em class="kk">这是显示图像的代码:</em></p><figure class="mh mi mj mk gt ml"><div class="bz fp l di"><div class="nr ns l"/></div><p class="ms mt gj gh gi mu mv bd b be z dk translated">作者编写的代码</p></figure><p id="35d1" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr ma kt ku kv mc kx ky kz me lb lc ld le ij bi translated">结果如下:</p><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi om"><img src="../Images/37ed80dddc17cbfbeb007a4cce3add67.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*weSw9fAk0SrC4sgg"/></div></div><p class="ms mt gj gh gi mu mv bd b be z dk translated">作家创造的形象</p></figure><p id="6960" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr ma kt ku kv mc kx ky kz me lb lc ld le ij bi translated">你可以看到我们有同一个病人的同一片身体的两个不同部分，这只是一个简单的转换，所以你可以添加更多来得到更复杂的东西。</p></div><div class="ab cl nk nl hu nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="ij ik il im in"><blockquote class="on"><p id="7a48" class="oo op iq bd oq or os ot ou ov ow le dk translated">注意:如果您使用第二种方法并保存生成的数据，请返回并检查它，因为您会发现一些患者具有与正常身体不匹配的随机形状，必须将其从您的数据集中删除。</p></blockquote></div><div class="ab cl nk nl hu nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="ij ik il im in"><blockquote class="kf kg kh"><p id="7697" class="ki kj kk kl b km kn jr ko kp kq ju kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">你可以在这里得到完整的代码。</p></blockquote><div class="ox oy gp gr oz pa"><a href="https://github.com/amine0110/data-augmentation-for-3D-volumes" rel="noopener  ugc nofollow" target="_blank"><div class="pb ab fo"><div class="pc ab pd cl cj pe"><h2 class="bd ir gy z fp pf fr fs pg fu fw ip bi translated">GitHub-amine 0110/3D体积的数据增强</h2><div class="ph l"><h3 class="bd b gy z fp pf fr fs pg fu fw dk translated">在GitHub上创建一个帐户，为amine 0110/data-augmentation-for-3D-volumes开发做出贡献。</h3></div><div class="pi l"><p class="bd b dl z fp pf fr fs pg fu fw dk translated">github.com</p></div></div><div class="pj l"><div class="pk l pl pm pn pj po mq pa"/></div></div></a></div></div><div class="ab cl nk nl hu nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="ij ik il im in"><h1 id="fed1" class="lg lh iq bd li lj nu ll lm ln nv lp lq jw nw jx ls jz nx ka lu kc ny kd lw lx bi translated">你想学医学影像的深度学习！</h1><p id="5b1e" class="pw-post-body-paragraph ki kj iq kl b km ly jr ko kp lz ju kr ma mb ku kv mc md ky kz me mf lc ld le ij bi translated">即将推出全面的医学成像课程，涵盖使用Monai和PyTorch的2D和3D分割，并提供额外支持。加入等候名单以接收任何课程更新的通知。</p><div class="ox oy gp gr oz pa"><a href="https://pycad.co/monai-and-pytoch-for-medical-imaging/" rel="noopener  ugc nofollow" target="_blank"><div class="pb ab fo"><div class="pc ab pd cl cj pe"><h2 class="bd ir gy z fp pf fr fs pg fu fw ip bi translated">医学成像深度学习登录页面- PYCAD</h2><div class="ph l"><h3 class="bd b gy z fp pf fr fs pg fu fw dk translated">使用Monai和PyTorch的医学成像中的2D和3D分割。</h3></div><div class="pi l"><p class="bd b dl z fp pf fr fs pg fu fw dk translated">pycad.co</p></div></div><div class="pj l"><div class="pp l pl pm pn pj po mq pa"/></div></div></a></div></div><div class="ab cl nk nl hu nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="ij ik il im in"><blockquote class="on"><p id="7394" class="oo op iq bd oq or os ot ou ov ow le dk translated">订阅<a class="ae lf" href="https://astounding-teacher-3608.ck.page/136bdb1fbe" rel="noopener ugc nofollow" target="_blank">我的简讯</a>获取我工作的所有更新:)。</p></blockquote></div></div>    
</body>
</html>