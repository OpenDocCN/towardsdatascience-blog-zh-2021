<html>
<head>
<title>Python, The System Path and how conda and pyenv manipulate it</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python，系统路径以及 conda 和 pyenv 如何操纵它</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/python-the-system-path-and-how-conda-and-pyenv-manipulate-it-234f8e8bbc3e?source=collection_archive---------5-----------------------#2021-11-05">https://towardsdatascience.com/python-the-system-path-and-how-conda-and-pyenv-manipulate-it-234f8e8bbc3e?source=collection_archive---------5-----------------------#2021-11-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="6883" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">深入探究当您键入“python”时会发生什么，以及流行的工具是如何操作的</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/6cfdd24dcba8702490bacd369858f8bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*mLaAtknLt9Z_lll9"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/@baciutudor?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">都铎·巴休</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="dcbd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">系统路径(在 Mac/Linux 上的<code class="fe ls lt lu lv b">echo $PATH</code>或<code class="fe ls lt lu lv b">echo -e ${PATH//:/\\n}</code>版本稍微漂亮一点)不仅仅是 python 的事情，它对 python 的功能也非常重要。如果你打开一个命令行，输入一个“命令”，计算机(或“操作系统”)需要知道在哪里寻找这个命令，找到它的底层代码，然后“执行”它。这些“命令文件”通常被称为可执行文件，当你键入与它们的文件名匹配的单词时，它们就会运行。</p><p id="fc0a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们以<code class="fe ls lt lu lv b">echo</code>为例。当我们键入<code class="fe ls lt lu lv b">echo $PATH</code>时，我们的计算机需要知道在哪里找到命令<code class="fe ls lt lu lv b">echo</code>的代码，并通过传入一个参数<code class="fe ls lt lu lv b">$PATH</code>来执行它。我们可以通过下面的代码看到代码在哪里:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="8c30" class="ma mb iq lv b gy mc md l me mf">&gt; whereis echo<br/>/bin/echo</span></pre><p id="3274" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">其中<code class="fe ls lt lu lv b">whereis</code>是我们的计算机知道如何定位的另一个可执行文件:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="18c4" class="ma mb iq lv b gy mc md l me mf">&gt; whereis whereis<br/>/usr/bin/whereis</span></pre><p id="b3d2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有意思。他们坐在两个不同的位置。如果我们在这两个地方有相同的可执行文件名称会怎么样？我们会执行哪一个？</p><h2 id="2eee" class="ma mb iq bd mg mh mi dn mj mk ml dp mm lf mn mo mp lj mq mr ms ln mt mu mv mw bi translated">系统路径排序</h2><p id="6123" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated"><code class="fe ls lt lu lv b">$PATH</code>变量决定了这一点，幸运的是，操作系统做了简单的事情，从左到右/从上到下地完成了它。作为一个例子，让我们看看我的系统变量<code class="fe ls lt lu lv b">$PATH</code>的如下输出:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="c732" class="ma mb iq lv b gy mc md l me mf">&gt; echo -e ${PATH//:/\\n}<br/>/usr/local/bin<br/>/usr/bin<br/>/bin<br/>/usr/sbin<br/>/sbin</span></pre><p id="0f78" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">假设我们去寻找一个名为<code class="fe ls lt lu lv b">myspecialexec</code>的可执行文件。我们的系统将从顶层开始。在这种情况下，它将在目录<code class="fe ls lt lu lv b">/usr/local/bin</code>中查找名为<code class="fe ls lt lu lv b">myspecialexec</code>的可执行文件。如果找到了，就执行它。如果没有找到，它就移动到路径中指定的下一个目录——在这种情况下是<code class="fe ls lt lu lv b">/usr/bin</code>,如果没有找到，就移动到<code class="fe ls lt lu lv b">/bin</code>,依此类推。</p><h2 id="c964" class="ma mb iq bd mg mh mi dn mj mk ml dp mm lf mn mo mp lj mq mr ms ln mt mu mv mw bi translated">这和 Python 有什么关系？</h2><p id="8c25" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">Python 是可执行的。当你运行<code class="fe ls lt lu lv b">brew install python</code>或前往<a class="ae kv" href="https://www.python.org/downloads/" rel="noopener ugc nofollow" target="_blank">这里</a>并运行 python 安装程序时，这就是你正在下载的东西(连同标准库和一些其他东西)。您正在执行以下操作之一:</p><ul class=""><li id="ce30" class="nc nd iq ky b kz la lc ld lf ne lj nf ln ng lr nh ni nj nk bi translated">获取 python 可执行文件，并将其粘贴到<code class="fe ls lt lu lv b">$PATH</code>中的上述目录之一</li><li id="6817" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated">获取 python 可执行文件并粘贴到其他地方，然后确保<em class="nq">目录名现在在<code class="fe ls lt lu lv b">$PATH</code>中</em></li></ul><p id="83c0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，当您运行命令<code class="fe ls lt lu lv b">python</code>时，您的操作系统开始向下滑动<code class="fe ls lt lu lv b">$PATH</code>列表，寻找它能找到的第一个匹配的名字。如果您有多个版本，那么它将使用最先找到的版本。<strong class="ky ir">如果你有一个你<em class="nq">想让</em>它找到的版本，那么你应该把那个 python 版本的位置放在路径的顶部。</strong>最后一点是理解(和简化)所有这些工具“管理环境”和“管理 python 版本”的关键。一旦我们理解了我们的计算机如何决定使用哪个版本的 python，像包管理这样的其他事情就非常简单了。</p><h2 id="6366" class="ma mb iq bd mg mh mi dn mj mk ml dp mm lf mn mo mp lj mq mr ms ln mt mu mv mw bi translated">例 1:conda 是如何做到这一点的，所以我们使用基于 conda 环境的正确版本的 python？</h2><p id="1a3f" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated"><a class="ae kv" href="https://docs.conda.io/en/latest/" rel="noopener ugc nofollow" target="_blank"> Conda </a>正如它自己描述的那样<em class="nq">“一个运行在 Windows、macOS 和 Linux 上的开源包管理系统和环境管理系统”</em>。这是我学习的第一个试图创建和管理稳定的 python 环境的系统，它因其与 python 中机器学习和统计编程的兴起(matplotlib、numpy、scipy、pandas、sklearn 等)的原始联系而广受欢迎。</p><p id="113b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它的“较轻”版本，<a class="ae kv" href="https://docs.conda.io/en/latest/miniconda.html" rel="noopener ugc nofollow" target="_blank"> miniconda </a>，是大多数人在谈论“康达”时谈论的内容。如果您要前往<a class="ae kv" href="https://docs.conda.io/en/latest/miniconda.html#installing" rel="noopener ugc nofollow" target="_blank">这里</a>并安装它，您现在就会这样做，就像使用 python 一样:</p><ul class=""><li id="0465" class="nc nd iq ky b kz la lc ld lf ne lj nf ln ng lr nh ni nj nk bi translated">在你电脑的某个地方有一个<code class="fe ls lt lu lv b">conda</code>可执行文件</li><li id="d7ec" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated">通过位于<code class="fe ls lt lu lv b">$PATH</code>变量中的某个位置，该可执行文件将对您的 shell/终端可见</li></ul><p id="87e4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这意味着当你在终端中输入<code class="fe ls lt lu lv b">conda</code>时，它会知道如何执行 conda 附带的功能。</p><h2 id="b805" class="ma mb iq bd mg mh mi dn mj mk ml dp mm lf mn mo mp lj mq mr ms ln mt mu mv mw bi translated">那么 conda 如何确保你使用的是想要的 python 版本呢？</h2><p id="106d" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated"><strong class="ky ir">通过操作$PATH 变量，特别是利用它自顶向下的特性</strong>。为了建立一个例子，让我们做以下事情。假设安装了 conda，并且您打开了一个新的终端/外壳，您将看到:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="f73d" class="ma mb iq lv b gy mc md l me mf">(base) &gt;</span></pre><p id="be90" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">即，您将被定向到为您自动创建的默认基础 conda 环境。这里的目的不是谈论环境创建，而是说 conda 已经在某个地方创建了一个“基础”目录。在该目录中，它放置了:</p><ul class=""><li id="ed9a" class="nc nd iq ky b kz la lc ld lf ne lj nf ln ng lr nh ni nj nk bi translated">该环境附加到的 python 版本(因此，每次在基本环境中键入<code class="fe ls lt lu lv b">python</code>时，它都会运行相同版本的 python)</li><li id="6fb2" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated">您可以为该环境下载的所有其他软件包依赖项</li></ul><p id="f32a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个目录到底在哪里？我们可以通过使用命令<code class="fe ls lt lu lv b">which python</code>看到:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="74a6" class="ma mb iq lv b gy mc md l me mf">(base) &gt; which python<br/>/Users/jamisonm/opt/miniconda3/bin/python</span></pre><p id="0616" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">好极了。所以 conda 在某个地方创建了一个目录，并在其中放了一个我们可以调用的 python 版本。但是当我们在<em class="nq">这个</em>环境中的时候，我们的计算机怎么知道调用<em class="nq">这个</em>版本的 python 呢？因为它将该目录放在了$PATH 的顶部。我们可以证实这一点:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="f153" class="ma mb iq lv b gy mc md l me mf">(base) &gt; echo -e ${PATH//:/\\n}<br/>/Users/jamisonm/opt/miniconda3/bin<br/>/usr/local/bin<br/>/usr/bin<br/>/bin<br/>/usr/sbin<br/>/sbin</span></pre><p id="7225" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，当我停用环境，即我不想再使用这个环境和相应的 python 版本时，会发生什么？</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="192c" class="ma mb iq lv b gy mc md l me mf">(base) &gt; conda deactivate<br/><br/>&gt; echo -e ${PATH//:/\\n} # environment disabled so lose the (base)<br/>/usr/local/bin<br/>/usr/bin<br/>/bin<br/>/usr/sbin<br/>/sbin<br/><br/>&gt; which python<br/>/usr/bin/python</span></pre><p id="3cc4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以<code class="fe ls lt lu lv b">conda deactivate</code>已经从系统路径的顶部移除了<code class="fe ls lt lu lv b">/Users/jamisonm/opt/miniconda3/bin</code>，所以我们默认使用之前的自顶向下搜索，并最终在<code class="fe ls lt lu lv b">/usr/bin/python</code>中找到预装的 python。</p><p id="1007" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">创造一个新的环境怎么样？让我们创建一个名为<code class="fe ls lt lu lv b">conda-demo</code>的新环境。</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="5e75" class="ma mb iq lv b gy mc md l me mf">&gt; conda create --name conda-demo<br/>&gt; conda activate conda-demo<br/>(conda-demo) &gt; echo -e ${PATH//:/\\n}<br/>/Users/jamisonm/opt/miniconda3/envs/conda-demo/bin<br/>/usr/local/bin<br/>/usr/bin<br/>/bin<br/>/usr/sbin<br/>/sbin</span></pre><p id="8dbf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，康达又一次做到了以下几点:</p><ul class=""><li id="5f1a" class="nc nd iq ky b kz la lc ld lf ne lj nf ln ng lr nh ni nj nk bi translated">在某个地方创建了一个文件夹(<code class="fe ls lt lu lv b">/Users/jamisonm/opt/miniconda3/envs/conda-demo/bin</code>)来存放附加到这个环境中的 python 版本(以及其他潜在的下载包)</li><li id="a330" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated">将该目录放在$PATH 的顶部，这样当我们键入<code class="fe ls lt lu lv b">python</code>时，它会执行存在于该目录中的 python，而不是位于<code class="fe ls lt lu lv b">$PATH</code>变量下方的目录</li></ul><h2 id="5672" class="ma mb iq bd mg mh mi dn mj mk ml dp mm lf mn mo mp lj mq mr ms ln mt mu mv mw bi translated">示例 pyenv 是如何做到这一点的，以便我们根据特定的环境使用正确的 python 版本？</h2><p id="5a9f" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">与 conda 不同，<a class="ae kv" href="https://github.com/pyenv/pyenv" rel="noopener ugc nofollow" target="_blank"> pyenv </a>(最初)并不是一个完全成熟的环境管理器，但更倾向于解决以下问题:</p><p id="5d0d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="nq">“我如何在同一台计算机上处理使用不同版本 python 的多个项目，并确保当我键入</em> <code class="fe ls lt lu lv b"><em class="nq">python</em></code> <em class="nq">时，我使用的是我想要使用的 python 版本？”</em></p><p id="ddf3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是一个“python 版本管理”工具，关键是不涉及任何 Python。为了安装和管理不同的 python 版本，重要的是它本身不依赖于 python，而是主要是 bash 脚本的负载。</p><p id="6072" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如您可能已经猜到的，它通过操纵<code class="fe ls lt lu lv b">$PATH</code>变量来完成 python 版本管理。事情比康达复杂一点，我们来看一个例子。假设您已经通过类似<code class="fe ls lt lu lv b">brew install pyenv</code>的东西安装了<a class="ae kv" href="https://github.com/pyenv/pyenv#installation" rel="noopener ugc nofollow" target="_blank"/>，当您启动一个新的终端/shell 时，您应该准备好了(因为语句(或类似的东西)<code class="fe ls lt lu lv b">eval "$(pyenv init --path)"</code>将被添加到您的<code class="fe ls lt lu lv b">.zshrc</code> / <code class="fe ls lt lu lv b">.zprofile</code> / <code class="fe ls lt lu lv b">.bash_profile</code> / <code class="fe ls lt lu lv b">.bashrc</code>的末尾，pyenv 命令将被加载到您的 shell 中。</p><h2 id="4455" class="ma mb iq bd mg mh mi dn mj mk ml dp mm lf mn mo mp lj mq mr ms ln mt mu mv mw bi translated">树立榜样</h2><p id="52ac" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">在开始之前，让我们使用 pyenv 来建立一个示例，这样我们就可以准确地演示它是如何工作的。安装 pyenv 后，让:</p><p id="6b4a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">安装 2 个不同版本的 python，并将 3.9.7 设为全局版本</strong></p><p id="993a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在新的终端中，键入以下内容以安装 python 3.8.12 和 python 3.9.7，并将 python 3.9.7 设置为要使用的首选“全局”python 版本:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="d635" class="ma mb iq lv b gy mc md l me mf">&gt; pyenv install 3.8.12<br/>&gt; pyenv install 3.9.7<br/>&gt; pyenv global 3.9.7</span></pre><p id="ada9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，我们可以通过检查以下内容来检查这是否成功:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="170e" class="ma mb iq lv b gy mc md l me mf">&gt; pyenv versions<br/>   system<br/>   3.8.12<br/> * 3.9.7 (set by /Users/jamisonm/.pyenv/version)</span></pre><p id="dd3d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">新建一个项目，将 python 的本地版本设置为 3.8.12 </strong></p><p id="f502" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了理解 pyenv 如何同时管理多个 python 版本，我们需要创建一个“新项目”,并告诉它我们不想使用我们已经设置的“全局”python 版本——3 . 9 . 7。为此，您可以创建任何新目录并运行以下命令:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="d1da" class="ma mb iq lv b gy mc md l me mf">&gt; mkdir ~/pyenv-demo    # make a new directory called pyenv-demo in my home directory<br/>&gt; cd ~/pyenv-demo       # cd into it<br/>&gt; pyenv local 3.8.12    # set 3.8.12 as the python version to be used in this directory</span></pre><p id="79b7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这做了什么？这就创建了一个只包含以下文本的<code class="fe ls lt lu lv b">.python-version</code>文件:<code class="fe ls lt lu lv b">3.8.12</code>。如果一切按计划进行，那么:</p><ul class=""><li id="2eef" class="nc nd iq ky b kz la lc ld lf ne lj nf ln ng lr nh ni nj nk bi translated">当我们在这个目录(现在是一个简单类型的“环境”)中时，我们将使用 python 3.8.12</li><li id="6e74" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated">当我们在它之外时，我们将使用默认的 3.9.7</li></ul><p id="3c27" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们已经准备好了，我们可以检查 pyenv 如何确保我们使用期望的 python 版本。</p><h2 id="3fb5" class="ma mb iq bd mg mh mi dn mj mk ml dp mm lf mn mo mp lj mq mr ms ln mt mu mv mw bi translated">当我键入<code class="fe ls lt lu lv b">python</code>时，pyenv 如何知道运行 python 的“本地”版本？</h2><p id="02f5" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">首先，让我们通过使用<code class="fe ls lt lu lv b">cd ~/pyenv-demo</code>将自己转移到新目录。让我们看看当我们键入<code class="fe ls lt lu lv b">python</code>时我们指向哪里，并且根据我们的路径，这是否有意义:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="a021" class="ma mb iq lv b gy mc md l me mf">&gt; which python<br/>/Users/jamisonm/.pyenv/shims/python<br/>&gt; echo -e ${PATH//:/\\n}<br/>/Users/jamisonm/.pyenv/shims<br/>/usr/local/bin<br/>/usr/bin<br/>/bin<br/>/usr/sbin<br/>/sbin</span></pre><p id="89ee" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，我们似乎在<code class="fe ls lt lu lv b">/Users/jamisonm/.pyenv/shims</code>中使用了 python 可执行文件，正如 conda 的情况一样，这是因为 pyenv 在我们的路径顶部放置了一个名为<code class="fe ls lt lu lv b">/Users/jamisonm/.pyenv/shims</code>的目录(因此首先搜索这个目录)。如果我们检查指定的 python 可执行文件，我们会发现它实际上不是真正的 python 可执行文件，而是一个名为“python”的 bash 脚本。这就是“填补程序”的含义——我们欺骗我们的操作系统运行<em class="nq">这个</em>可执行文件(它<em class="nq">被称为</em> python，但实际上并不是<em class="nq">python)，而不是进一步搜索<code class="fe ls lt lu lv b">$PATH</code>并找到一个真正的 python 可执行文件。</em></p><h2 id="5344" class="ma mb iq bd mg mh mi dn mj mk ml dp mm lf mn mo mp lj mq mr ms ln mt mu mv mw bi translated">那么这个“填充”python 脚本是做什么的呢？</h2><p id="4e92" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">让我们来看看:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="ebdd" class="ma mb iq lv b gy mc md l me mf">&gt; less /Users/jamisonm/.pyenv/shims/python<br/><br/>#!/usr/bin/env bash<br/>set -e<br/>[ -n "$PYENV_DEBUG" ] &amp;&amp; set -x<br/><br/>program="${0##*/}"<br/><br/>export PYENV_ROOT="/Users/jamisonm/.pyenv"<br/>exec "/usr/local/opt/pyenv/bin/pyenv" exec "$program" "$@"</span></pre><p id="9fb1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">简单地说，它检查一些调试标准，设置一个变量<code class="fe ls lt lu lv b">PYENV_ROOT</code>，然后调用<em class="nq">另一个</em>可执行文件:<code class="fe ls lt lu lv b">/usr/local/opt/pyenv/bin/pyenv</code>。因此，到目前为止，它所做的不是调用 python，而是拦截对 python 的调用(通过操纵<code class="fe ls lt lu lv b">$PATH</code>)，然后调用自己。</p><p id="0d32" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们<em class="nq">可以</em>检查这个可执行文件(<code class="fe ls lt lu lv b">/usr/local/opt/pyenv/bin/pyenv</code>)，但是它只有大约 150 行 bash 脚本。相反，假设一切顺利，我们可以把注意力集中在底部，它有:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="42b9" class="ma mb iq lv b gy mc md l me mf">command="$1"<br/>case "$command" in<br/>"" )<br/>  { pyenv---version<br/>    pyenv-help<br/>  } | abort<br/>  ;;<br/>-v | --version )<br/>  exec pyenv---version<br/>  ;;<br/>-h | --help )<br/>  exec pyenv-help<br/>  ;;<br/>* )<br/>  <strong class="lv ir">command_path="$(command -v "pyenv-$command" || true)"</strong><br/>  if [ -z "$command_path" ]; then<br/>    if [ "$command" == "shell" ]; then<br/>      abort "shell integration not enabled. Run \`pyenv init' for instructions."<br/>    else<br/>      abort "no such command \`$command'"<br/>    fi<br/>  fi<br/><br/>  shift 1<br/>  if [ "$1" = --help ]; then<br/>    if [[ "$command" == "sh-"* ]]; then<br/>      echo "pyenv help \"$command\""<br/>    else<br/>      exec pyenv-help "$command"<br/>    fi<br/>  else<br/>    <strong class="lv ir">exec "$command_path" "$@"</strong><br/>  fi<br/>  ;;<br/>esac</span></pre><p id="0636" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以自己检查脚本，或者相信我的话，它会为您指出:</p><ul class=""><li id="9479" class="nc nd iq ky b kz la lc ld lf ne lj nf ln ng lr nh ni nj nk bi translated"><code class="fe ls lt lu lv b">command_path</code> = <code class="fe ls lt lu lv b">/usr/local/Cellar/pyenv/2.2.0/libexec/pyenv-exec</code>(这是因为我用 brew 安装了 pyenv，brew 把这个可执行文件放在了‘Cellar’目录中)</li><li id="cc37" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated"><code class="fe ls lt lu lv b">"$@"</code> = <code class="fe ls lt lu lv b">python</code></li></ul><p id="b587" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这意味着现在我们已经被引导到另一个可执行文件<em class="nq">上，即带有参数<code class="fe ls lt lu lv b">python</code>的<code class="fe ls lt lu lv b">/usr/local/Cellar/pyenv/2.2.0/libexec/pyenv-exec</code>。</em></p><h2 id="a09e" class="ma mb iq bd mg mh mi dn mj mk ml dp mm lf mn mo mp lj mq mr ms ln mt mu mv mw bi translated">那么接下来会发生什么？</h2><p id="b41a" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">现在这个脚本有点短了，所以我们可以把它全部打印出来，然后用文字浏览一遍:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="fd2b" class="ma mb iq lv b gy mc md l me mf">set -e<br/>[ -n "$PYENV_DEBUG" ] &amp;&amp; set -x<br/><br/># Provide pyenv completions<br/>if [ "$1" = "--complete" ]; then<br/>  exec pyenv-shims --short<br/>fi<br/><br/><strong class="lv ir">PYENV_VERSION="$(pyenv-version-name)"</strong><br/>PYENV_COMMAND="$1"<br/><br/>if [ -z "$PYENV_COMMAND" ]; then<br/>  pyenv-help --usage exec &gt;&amp;2<br/>  exit 1<br/>fi<br/><br/>export PYENV_VERSION<br/>PYENV_COMMAND_PATH="$(pyenv-which "$PYENV_COMMAND")"<br/>PYENV_BIN_PATH="${PYENV_COMMAND_PATH%/*}"<br/><br/>OLDIFS="$IFS"<br/>IFS=$'\n' scripts=(`pyenv-hooks exec`)<br/>IFS="$OLDIFS"<br/>for script in "${scripts[@]}"; do<br/>  source "$script"<br/>done<br/><br/>shift 1<br/>if [ "${PYENV_BIN_PATH#${PYENV_ROOT}}" != "${PYENV_BIN_PATH}" ]; then<br/>  # Only add to $PATH for non-system version.<br/>  export PATH="${PYENV_BIN_PATH}:${PATH}"<br/>fi<br/>exec "$PYENV_COMMAND_PATH" "$@"</span></pre><p id="e235" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">重要的一点是我强调的那一点。这个位在当前目录中检查一个<code class="fe ls lt lu lv b">.python-version</code>文件，如果它存在，它就使用它。否则，它会遍历到该目录的所有路径，寻找其他的<code class="fe ls lt lu lv b">.python-version</code>文件，直到找到一个。否则，它将默认使用我们设置的全局 python 版本。在这种情况下，它:</p><ul class=""><li id="dffb" class="nc nd iq ky b kz la lc ld lf ne lj nf ln ng lr nh ni nj nk bi translated">在我们的 pyenv-demo 目录中找到<code class="fe ls lt lu lv b">.python-version</code>文件</li><li id="c92d" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated">为<code class="fe ls lt lu lv b">3.8.12</code>读取</li><li id="d47b" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated">转到<code class="fe ls lt lu lv b">/Users/jamisonm/.pyenv/versions</code>，pyenv python 可执行文件<em class="nq">实际上</em>存储在那里</li><li id="27d8" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated">找到我们想要的，并将我们的可执行文件设置为<code class="fe ls lt lu lv b">/Users/jamisonm/.pyenv/versions/3.8.12/bin/python</code></li></ul><p id="a872" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上述过程在<a class="ae kv" href="https://github.com/pyenv/pyenv#choosing-the-python-version" rel="noopener ugc nofollow" target="_blank">他们的 git </a>上有描述。</p><h2 id="0db1" class="ma mb iq bd mg mh mi dn mj mk ml dp mm lf mn mo mp lj mq mr ms ln mt mu mv mw bi translated">对于它正在实现的目标来说，这似乎相当复杂</h2><p id="cb12" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">这相当复杂——尤其是来自编程 python 和尝试通读一堆 bash 脚本。然而，最终所有这些都隐藏在对<code class="fe ls lt lu lv b">pyenv</code>的简单调用之下。有时候，确切地了解正在发生的事情是很好的，但是日常生活中没有必要知道这些。然而，要点仍然存在——理解不同的环境管理程序和 python 版本化有时看起来很复杂，但归根结底只有一件事:以一致的方式操作<code class="fe ls lt lu lv b">$PATH</code>变量，以便您想要的 python 版本就是您得到的 python 版本。</p><h2 id="daf3" class="ma mb iq bd mg mh mi dn mj mk ml dp mm lf mn mo mp lj mq mr ms ln mt mu mv mw bi translated">结论</h2><p id="d940" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">希望通过这次经历，事情开始变得简单。“环境管理”和“python 版本控制”实际上可以归结为以下几点:</p><ul class=""><li id="65d4" class="nc nd iq ky b kz la lc ld lf ne lj nf ln ng lr nh ni nj nk bi translated">环境管理:在某个地方创建一个目录，并将我们希望用于该环境的 python 版本放在那里</li><li id="62c4" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated">Python 版本控制:确保当我们在特定的目录/环境中时，在浏览<code class="fe ls lt lu lv b">$PATH</code>时，首先找到附加的 python 可执行文件的路径</li><li id="abe8" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated">包管理:将所需的包下载到我们想要的 python 可执行文件所在的“相同位置”,这样就可以用它们来代替其他环境中的包</li></ul><p id="6821" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后一点我们还没有真正经历过，但是一旦我们理解了当我们键入<code class="fe ls lt lu lv b">python</code>时，我们的计算机如何知道使用哪个版本的 python，它真的一点也不复杂。然而，要理解它，我们需要理解<strong class="ky ir">模块搜索路径和</strong>，正如我们将在下一篇文章中看到的，这实际上只不过是在 python 启动时对<code class="fe ls lt lu lv b">$PATH</code>进行一些小的标准操作。</p><div class="nr ns gp gr nt nu"><a href="https://markjamison03.medium.com/python-and-the-module-search-path-e71ae7a7e65f" rel="noopener follow" target="_blank"><div class="nv ab fo"><div class="nw ab nx cl cj ny"><h2 class="bd ir gy z fp nz fr fs oa fu fw ip bi translated">Python 和模块搜索路径</h2><div class="ob l"><p class="bd b dl z fp nz fr fs oa fu fw dk translated">markjamison03.medium.com</p></div></div><div class="oc l"><div class="od l oe of og oc oh kp nu"/></div></div></a></div></div></div>    
</body>
</html>