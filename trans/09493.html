<html>
<head>
<title>Kubeflow: An MLOps Perspective</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">库伯弗洛:一个MLOps的观点</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/kubeflow-an-mlops-perspective-17d33ac57c08?source=collection_archive---------8-----------------------#2021-09-03">https://towardsdatascience.com/kubeflow-an-mlops-perspective-17d33ac57c08?source=collection_archive---------8-----------------------#2021-09-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="084e" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/notes-from-industry" rel="noopener" target="_blank">行业笔记</a></h2><div class=""/><div class=""><h2 id="6b86" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">ML管道和ML组件</h2></div><h2 id="2b80" class="ko kp iq bd kq kr ks dn kt ku kv dp kw kx ky kz la lb lc ld le lf lg lh li iw bi translated">MLOps和DevOps —连接</h2><p id="aafd" class="pw-post-body-paragraph lj lk iq ll b lm ln ka lo lp lq kd lr kx ls lt lu lb lv lw lx lf ly lz ma mb ij bi translated">在设计新技术时，几乎总是会做出牺牲一些特性来换取另一些特性的选择。理解这些选择以及它们如何影响或不影响您的用例是很重要的。通常，当选择技术或框架而不是其他技术或框架时，这样的研究永远不会完成；或者有时候没有选择。</p><p id="e94e" class="pw-post-body-paragraph lj lk iq ll b lm mc ka lo lp md kd lr kx me lt lu lb mf lw lx lf mg lz ma mb ij bi translated">例如，我们有像Kubernetes这样设计良好的平台，无论是最具技术性的，都不会出错；或者至少。当然，虽然它仍在发展中，对于硬多租户之类的事情可能有更好的解决方案，但现在一般用户并不太关心这些。它已经成为任何云原生应用的事实上的执行引擎。</p><p id="00a0" class="pw-post-body-paragraph lj lk iq ll b lm mc ka lo lp md kd lr kx me lt lu lb mf lw lx lf mg lz ma mb ij bi translated">这导致了传统软件开发的许多变化。而不是编译一个或多个操作系统的源代码并为其创建安装程序或打包程序；开发人员需要将他们的代码容器化，并创建相关的人工制品——如服务、配置图、秘密；入口和Kubernetes特定标记语言(YAML)中的类似内容。现在这已经成为惯例和常规。</p><p id="2f4c" class="pw-post-body-paragraph lj lk iq ll b lm mc ka lo lp md kd lr kx me lt lu lb mf lw lx lf mg lz ma mb ij bi translated">对于一个开发者来说；将您的微服务包装在容器中，并部署在pod中；保证它将执行相同的操作；在任何有足够资源的Kubernetes集群上。人们不必担心pod联网或调度的内部复杂性，也不必担心与控制组或名称空间等相关的Linux内部问题。当然，这是一种简化；就好像你正在安装一个主机卷，并对底层的Linux操作系统做了一个假设，那么这样的假设可能会被打破；但是这些都是离群值，而不是技术必须使用的方式。</p><p id="8364" class="pw-post-body-paragraph lj lk iq ll b lm mc ka lo lp md kd lr kx me lt lu lb mf lw lx lf mg lz ma mb ij bi translated">这是件好事。您希望其他技术也有类似的抽象；比如数据库；如果不了解数据存储的内部原理；人们可以有效地存储和检索数据。例如，为快速访问而存储的DB可能不擅长快速更新；令人惊讶的是，许多开发人员并不知道；直到特性需求中途暴露出系统的隐藏特征。基本上，当系统被用于其设计的用例时，系统开始以一种意想不到的方式运行。</p><p id="c6ed" class="pw-post-body-paragraph lj lk iq ll b lm mc ka lo lp md kd lr kx me lt lu lb mf lw lx lf mg lz ma mb ij bi translated">所有这些因素与我们要讨论的内容有什么关系？</p><p id="8a55" class="pw-post-body-paragraph lj lk iq ll b lm mc ka lo lp md kd lr kx me lt lu lb mf lw lx lf mg lz ma mb ij bi translated">我们在Kubeflow中寻找的是抽象的无泄漏性——借用<a class="ae mh" href="https://www.joelonsoftware.com/2002/11/11/the-law-of-leaky-abstractions/" rel="noopener ugc nofollow" target="_blank"> <em class="mi">乔尔·斯波尔斯基</em> </a> <em class="mi">的一个术语。</em></p><p id="e102" class="pw-post-body-paragraph lj lk iq ll b lm mc ka lo lp md kd lr kx me lt lu lb mf lw lx lf mg lz ma mb ij bi translated">借用一个被广泛使用或误用的陈词滥调，我们在Kubeflow中寻找的是“云原生”的程度。基本上，执行被安排在Kubernetes集群边缘集群或数据中心。此框被勾选，因为Kubeflow是为Kubernetes设计的。不像说ml flow—<a class="ae mh" href="https://mlflow.org/" rel="noopener ugc nofollow" target="_blank">https://mlflow.org/</a>。其他竞争者TFX，ZenML截至目前</p><p id="05f8" class="pw-post-body-paragraph lj lk iq ll b lm mc ka lo lp md kd lr kx me lt lu lb mf lw lx lf mg lz ma mb ij bi translated">在我们进入Kubeflow之前，让我们检查一下它适合的环境。</p></div><div class="ab cl mj mk hu ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="ij ik il im in"><p id="10a2" class="pw-post-body-paragraph lj lk iq ll b lm mc ka lo lp md kd lr kx me lt lu lb mf lw lx lf mg lz ma mb ij bi translated">MLOps流程应该有助于确保ML项目的生产质量。</p><p id="672a" class="pw-post-body-paragraph lj lk iq ll b lm mc ka lo lp md kd lr kx me lt lu lb mf lw lx lf mg lz ma mb ij bi translated">用您的ML项目制作一个容器并部署到Kubernetes上就足够了吗？还是有其他事情需要处理？CI是怎么做的？测试是如何执行的？和测试评估？</p><p id="57cd" class="pw-post-body-paragraph lj lk iq ll b lm mc ka lo lp md kd lr kx me lt lu lb mf lw lx lf mg lz ma mb ij bi translated">来自一篇被大量引用的论文；似乎ML代码在生产中部署时意义最小。</p><p id="75ca" class="pw-post-body-paragraph lj lk iq ll b lm mc ka lo lp md kd lr kx me lt lu lb mf lw lx lf mg lz ma mb ij bi translated">来自这篇优秀博客的例子→<a class="ae mh" href="https://cloud.google.com/architecture/mlops-continuous-delivery-and-automation-pipelines-in-machine-learning" rel="noopener ugc nofollow" target="_blank">https://cloud . Google . com/architecture/mlops-continuous-delivery-and-automation-pipeline-in-machine-learning</a></p><figure class="mr ms mt mu gt mv gh gi paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><div class="gh gi mq"><img src="../Images/ff216ee8fffbe360e1a850694f922f3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*rnVUxmjQfmAe8_Ma.png"/></div></div><p class="nc nd gj gh gi ne nf bd b be z dk translated"><em class="ng">管理信息系统的要素。改编自</em> <a class="ae mh" href="https://papers.nips.cc/paper/5656-hidden-technical-debt-in-machine-learning-systems.pdf" rel="noopener ugc nofollow" target="_blank"> <em class="ng">隐藏在机器学习系统中的技术债务</em> </a> <em class="ng">。</em></p></figure><p id="4028" class="pw-post-body-paragraph lj lk iq ll b lm mc ka lo lp md kd lr kx me lt lu lb mf lw lx lf mg lz ma mb ij bi translated">作者可能夸大了让我们注意到系统的其他部分，我们往往会错过；也可能不是。</p><p id="44d4" class="pw-post-body-paragraph lj lk iq ll b lm mc ka lo lp md kd lr kx me lt lu lb mf lw lx lf mg lz ma mb ij bi translated">作者可能会更多地考虑结构化数据和依赖于特性的经典ML方法；非结构化数据，比如音频、视频或图像分析和深度神经网络</p></div><div class="ab cl mj mk hu ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="ij ik il im in"><p id="9fd3" class="pw-post-body-paragraph lj lk iq ll b lm mc ka lo lp md kd lr kx me lt lu lb mf lw lx lf mg lz ma mb ij bi translated">MLOps和DevOps一样，似乎又是一个术语，对许多不同的人以许多不同的方式表示许多不同的事情。我们需要定义我们所说的MLOps是什么意思。</p><p id="b8ad" class="pw-post-body-paragraph lj lk iq ll b lm mc ka lo lp md kd lr kx me lt lu lb mf lw lx lf mg lz ma mb ij bi translated">DevOps一般已确定更多地代表CI/CD部分-<a class="ae mh" href="https://aws.amazon.com/devops/what-is-devops/" rel="noopener ugc nofollow" target="_blank">https://aws.amazon.com/devops/what-is-devops/</a>；与开发人员对其组件进行端到端开发、部署和操作的原始概念相比，这是开发人员和他们的部署之间更多反馈的原则。这可能就像主动检查来自客户部署的错误日志，以发现可能的问题，甚至在错误出现之前。这肯定不仅仅是CI/CD；尽管它与开发和管理文化的联系比技术过程更紧密。</p><p id="d675" class="pw-post-body-paragraph lj lk iq ll b lm mc ka lo lp md kd lr kx me lt lu lb mf lw lx lf mg lz ma mb ij bi translated">毫不奇怪，现在许多公司都有一个“DevOps”团队来担当这一角色，为CI/CD提供工具和服务，并为更好地从部署中获得反馈提供工具和基础架构，如监控、日志记录等。</p><h2 id="9803" class="ko kp iq bd kq kr ks dn kt ku kv dp kw kx ky kz la lb lc ld le lf lg lh li iw bi translated">MLOps —需要关注的几个主要特征</h2><p id="df4c" class="pw-post-body-paragraph lj lk iq ll b lm ln ka lo lp lq kd lr kx ls lt lu lb lv lw lx lf ly lz ma mb ij bi translated">MLOps —类似于微服务的DevOps。但是这有更多与ML相关的方面，不仅仅是算法，像数据和模型管理，模型版本控制，模型漂移等等。至少这是承诺，我们在这个领域有如此多的工具和服务，商业的和开源的，除非我们有一些选择标准，否则真的很容易混淆和陷入困境。</p><p id="02ff" class="pw-post-body-paragraph lj lk iq ll b lm mc ka lo lp md kd lr kx me lt lu lb mf lw lx lf mg lz ma mb ij bi translated">浏览<a class="ae mh" href="https://github.com/EthicalML/awesome-production-machine-learning" rel="noopener ugc nofollow" target="_blank">这里</a>或者<a class="ae mh" href="https://landscape.lfai.foundation/?category=platform&amp;grouping=category" rel="noopener ugc nofollow" target="_blank">这里</a>你会得到一些想法；一些作者将这种扩散称为MLOps项目的<a class="ae mh" href="https://en.wikipedia.org/wiki/Cambrian_explosion" rel="noopener ugc nofollow" target="_blank">寒武纪大爆发</a>。然而，我们可以把它简化为几个主要阶段和许多相似的角色。像Hadoop生态系统这样的一些参与者已经相当老了，准备退出舞台，我们可以放心地忽略它。此外，类似的简单技术，如S3胜过更复杂的技术，如Ceph。</p><p id="9162" class="pw-post-body-paragraph lj lk iq ll b lm mc ka lo lp md kd lr kx me lt lu lb mf lw lx lf mg lz ma mb ij bi translated">我们在MLOps特定工具中寻找什么特征？</p><p id="10db" class="pw-post-body-paragraph lj lk iq ll b lm mc ka lo lp md kd lr kx me lt lu lb mf lw lx lf mg lz ma mb ij bi translated"><strong class="ll ja">云原生</strong> —系统应该设计用于基于容器和pod的执行；而不是改装成和Kubernetes一起工作。气流的例子XCom可能不是最好的管道组件(容器)传递数据-<a class="ae mh" href="https://medium.com/the-prefect-blog/why-not-airflow-4cfa423299c4" rel="noopener">https://medium . com/the-prefect-blog/why-not-air flow-4c fa 423299 C4</a>。类似的MLFlow可以被容器化，但可能不是最适合基于Kubernetes的系统。</p><p id="2536" class="pw-post-body-paragraph lj lk iq ll b lm mc ka lo lp md kd lr kx me lt lu lb mf lw lx lf mg lz ma mb ij bi translated"><strong class="ll ja">开源</strong> —如果可以的话，我们不想被某个特定的供应商所束缚。这需要很多工具——像Pachyderm这样的数据管理工具</p><p id="cf98" class="pw-post-body-paragraph lj lk iq ll b lm mc ka lo lp md kd lr kx me lt lu lb mf lw lx lf mg lz ma mb ij bi translated"><strong class="ll ja">ML工程师易于整合— </strong>为ML问题创建Jupyter笔记本原型后，需要做大量工作才能投入生产。尽管如此，除了他们的业务领域——数据工程、模型开发和调优，我们不希望我们的ML工程师知道更多关于Kubernetes、Docker文件之类的东西。</p><p id="9155" class="pw-post-body-paragraph lj lk iq ll b lm mc ka lo lp md kd lr kx me lt lu lb mf lw lx lf mg lz ma mb ij bi translated"><strong class="ll ja">可扩展— </strong>这是云原生和基于Kubernetes的设计的一个特征。像分布式训练和全状态负载平衡这样的事情非常复杂，我们暂时不考虑这些事情。</p></div><div class="ab cl mj mk hu ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="ij ik il im in"><h2 id="36cf" class="ko kp iq bd kq kr ks dn kt ku kv dp kw kx ky kz la lb lc ld le lf lg lh li iw bi translated">ML工程和ML运营——不同的阶段</h2><p id="c36a" class="pw-post-body-paragraph lj lk iq ll b lm ln ka lo lp lq kd lr kx ls lt lu lb lv lw lx lf ly lz ma mb ij bi translated">在我们继续之前，最好先看一下MLOps的主要阶段。工具会随着时间而变化，这更加主观<a class="ae mh" href="https://valohai.com/blog/the-mlops-stack/" rel="noopener ugc nofollow" target="_blank">https://valohai.com/blog/the-mlops-stack/</a>。</p><p id="9b36" class="pw-post-body-paragraph lj lk iq ll b lm mc ka lo lp md kd lr kx me lt lu lb mf lw lx lf mg lz ma mb ij bi translated">需要有一个好的<strong class="ll ja">数据分析工具</strong>或者<a class="ae mh" href="https://www.holistics.io/blog/the-rise-and-fall-of-the-olap-cube/" rel="noopener ugc nofollow" target="_blank"> OLAP数据库</a>。类似于Apache Presto可以从多个数据存储或传统数据库中获取数据。类似于Google BigQuery，但是在开源空间。数据科学家或ML工程师可以使用简单的SQL类型查询来分析大量数据；这对算法选择和进一步的ML工作将是重要的。</p><p id="2771" class="pw-post-body-paragraph lj lk iq ll b lm mc ka lo lp md kd lr kx me lt lu lb mf lw lx lf mg lz ma mb ij bi translated">这本身就是一个完整的基础架构，但实际上可以被排除在MLOps之外，因为它更多地出现在(大)数据基础架构的预览中。我们可以把这个放在<strong class="ll ja">数据工程</strong>的一边，在以后的帖子里再讨论这个问题。有时ML项目可以从较少的数据开始；但是当收集和分析数据并用于更好地训练模型时，应该选择可扩展的数据分析系统。这里是生态系统的快照<a class="ae mh" href="https://medium.com/data-science-engineering/data-engineering-for-machine-learning-5c6b53b31e12" rel="noopener">https://raw . githubusercontent . com/Alex CPN/learn ove/master/ml flow . png</a></p><p id="25d2" class="pw-post-body-paragraph lj lk iq ll b lm mc ka lo lp md kd lr kx me lt lu lb mf lw lx lf mg lz ma mb ij bi translated">然后是<strong class="ll ja">模型开发环境</strong>以及相关的——语言和框架。例如，像Pandas、Scikit Learn这样的python库，以及编程语言——Python、R. ML框架(如TensorFlow或PyTorch)和数据格式(如简单的CSV或更高效的格式，如Apache Parquet)。这部分将自己与开发环境联系起来，开发环境通常是Jupyter Notebook。尽管大多数数据分析都基于Python及其库，但对于视频分析之类的东西，它可能是C++、Go和相关库——GStreamer、OpenCV等。</p><p id="b184" class="pw-post-body-paragraph lj lk iq ll b lm mc ka lo lp md kd lr kx me lt lu lb mf lw lx lf mg lz ma mb ij bi translated">每个从业者都清楚这一点。现在开始了一个在开始时看起来并不明显的部分。<strong class="ll ja">模块化组件</strong>通过数据流图或<strong class="ll ja">管道连接。这正是像Kubeflow这样的项目适合的地方。为什么需要这样做？来自Kubeflow网站</strong></p><p id="ade0" class="pw-post-body-paragraph lj lk iq ll b lm mc ka lo lp md kd lr kx me lt lu lb mf lw lx lf mg lz ma mb ij bi translated"><a class="ae mh" href="https://www.kubeflow.org/docs/about/kubeflow/#the-kubeflow-mission" rel="noopener ugc nofollow" target="_blank">https://www . kube flow . org/docs/about/kube flow/# the-kube flow-mission</a></p><blockquote class="nh ni nj"><p id="ae1a" class="lj lk mi ll b lm mc ka lo lp md kd lr nk me lt lu nl mf lw lx nm mg lz ma mb ij bi translated">我们的目标是通过让Kubernetes做它擅长的事情，尽可能简单地扩展机器学习(ML)模型并将其部署到生产中:</p><p id="eba0" class="lj lk mi ll b lm mc ka lo lp md kd lr nk me lt lu nl mf lw lx nm mg lz ma mb ij bi translated">在多样化的基础设施上进行简单、可重复、可移植的部署(例如，在笔记本电脑上进行试验，然后迁移到本地集群或云)</p><p id="3979" class="lj lk mi ll b lm mc ka lo lp md kd lr nk me lt lu nl mf lw lx nm mg lz ma mb ij bi translated">部署和管理松散耦合的微服务</p><p id="a2c7" class="lj lk mi ll b lm mc ka lo lp md kd lr nk me lt lu nl mf lw lx nm mg lz ma mb ij bi translated">基于需求的扩展</p></blockquote><p id="222d" class="pw-post-body-paragraph lj lk iq ll b lm mc ka lo lp md kd lr kx me lt lu lb mf lw lx lf mg lz ma mb ij bi translated">第一句话就说明了一切——<strong class="ll ja">便捷</strong>、<strong class="ll ja">可重复</strong>和<strong class="ll ja">便携。</strong>因此，我们不是创建一个整体的python代码或笔记本，而是将它分割成独立的组件；每个任务做一部分，这些步骤是可移植的——可以在其他项目中重用。我们正在创建<strong class="ll ja"> <em class="mi"> ML微服务</em> </strong>，并使用工作流调度器来协调这些微服务。</p><p id="0ecc" class="pw-post-body-paragraph lj lk iq ll b lm mc ka lo lp md kd lr kx me lt lu lb mf lw lx lf mg lz ma mb ij bi translated">这是MLOps画面的一个重要部分。通过管道，你可以确保不会形成一个整体。这里有一个类似堆栈的维护者的类似观点<a class="ae mh" rel="noopener" target="_blank" href="/why-ml-should-be-written-as-pipelines-from-the-get-go-b2d95003f998">https://towardsdatascience . com/why-ml-should-be-write-as-pipelines-from-the-get-go-b2d 95003 f998</a></p><p id="16dc" class="pw-post-body-paragraph lj lk iq ll b lm mc ka lo lp md kd lr kx me lt lu lb mf lw lx lf mg lz ma mb ij bi translated">Kubeflow是否使创建这样的模块化ML组件变得容易和高效，我们将在后面看到。但是是的，它使事情变得简单；尽管效率不高，因为组件之间的所有数据都通过Python pickle机制序列化和反序列化到磁盘。因此，如果您编写的是普通CSV格式，而不是Apache Parquet格式；或者在代码中不使用TFData或类似的高效数据表示形式；你可以试试。通过像GRPC或REST这样的接口机制传递这一点不会太难，但是Kubelow必须将组件之间的输入/输出数据作为人工制品持久化。所以它也需要存储数据。</p><p id="ad28" class="pw-post-body-paragraph lj lk iq ll b lm mc ka lo lp md kd lr kx me lt lu lb mf lw lx lf mg lz ma mb ij bi translated">我们还需要什么对MLOps至关重要的东西。</p><p id="34ba" class="pw-post-body-paragraph lj lk iq ll b lm mc ka lo lp md kd lr kx me lt lu lb mf lw lx lf mg lz ma mb ij bi translated"><strong class="ll ja">模型训练</strong>——跟踪训练参数。真正的训练是通过Tensorflow、Pytorch等模型框架完成的；这里还有更复杂的框架，如Horvod，它使用MPI等并行编程框架进行分布式培训<a class="ae mh" href="https://github.com/horovod/horovod" rel="noopener ugc nofollow" target="_blank">https://github.com/horovod/horovod</a>，或使用<a class="ae mh" href="https://developer.nvidia.com/nccl" rel="noopener ugc nofollow" target="_blank">https://developer.nvidia.com/nccl</a>进行基于Tensorflow的分布式培训。注意，对于像用于图像或视频分析的非常深的神经网络；培训将需要一个带有CUDA内核的NVIDIA GPU ，而对于数据分析来说，CPU可能就足够了。</p><p id="aaa3" class="pw-post-body-paragraph lj lk iq ll b lm mc ka lo lp md kd lr kx me lt lu lb mf lw lx lf mg lz ma mb ij bi translated"><strong class="ll ja">实验跟踪</strong> —这可能有助于从历史上检查数据和模型的准确性、精确度、混淆矩阵或类似指标，并连接到测试集的模型验证阶段。也许在ML的CI-CD管道中比在开发中更有用。</p><p id="3b4f" class="pw-post-body-paragraph lj lk iq ll b lm mc ka lo lp md kd lr kx me lt lu lb mf lw lx lf mg lz ma mb ij bi translated"><strong class="ll ja">模型上菜—</strong>TF上菜，Seldon，KF上菜之类的。最重要的是确保模型与应用程序分离，并且可以通过CI/CD进行版本控制和独立更新。另一件要注意的事情是，在媒体分析等用例中，通常需要将大量数据传递给模型。因此，模型和业务微服务应该位于同一个Kubernetes节点中，并通过负载平衡层进行扩展。</p><p id="10c0" class="pw-post-body-paragraph lj lk iq ll b lm mc ka lo lp md kd lr kx me lt lu lb mf lw lx lf mg lz ma mb ij bi translated"><strong class="ll ja">模型监控— </strong>在传统的开发运维中，对运维或开发人员的反馈是通过矩阵进行的，这些矩阵是通过<a class="ae mh" href="https://prometheus.io/" rel="noopener ugc nofollow" target="_blank"> Prometheus </a>或类似工具从部署中收集的，并显示在<a class="ae mh" href="https://grafana.com/grafana/dashboards" rel="noopener ugc nofollow" target="_blank"> Grafana </a>仪表盘中。类似的方法也可用于模型监控。但是，为了检查模型的预测是否准确，应该在预测-分析循环中加入一些手动检查或操作员参与或客户反馈。或者更高级的<strong class="ll ja"> A/B测试</strong>与其他模型，并使用复杂算法比较结果，如<a class="ae mh" href="https://www.ijntr.org/download_data/IJNTR06090006.pdf" rel="noopener ugc nofollow" target="_blank">多臂土匪</a>。还需要用可用的较新数据来验证模型，以检测模型漂移。模型监控无疑是更高水平的MLOps熟练度，这将需要非常强大的基础设施来实现。</p><p id="6941" class="pw-post-body-paragraph lj lk iq ll b lm mc ka lo lp md kd lr kx me lt lu lb mf lw lx lf mg lz ma mb ij bi translated"><strong class="ll ja">模型、数据和实验共享</strong>——你需要在不同的团队之间有一个集中的、访问受控的共享；为此，需要一些模型或数据注册。</p><p id="f8ab" class="pw-post-body-paragraph lj lk iq ll b lm mc ka lo lp md kd lr kx me lt lu lb mf lw lx lf mg lz ma mb ij bi translated">我还漏掉了其他部分。<strong class="ll ja">模型调整</strong>可能是其中之一，我们有流行的软件，如Optuna或Katib。可能还有其他重要的原因，我现在还不知道。请在评论中注明。</p></div><div class="ab cl mj mk hu ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="ij ik il im in"><h2 id="beae" class="ko kp iq bd kq kr ks dn kt ku kv dp kw kx ky kz la lb lc ld le lf lg lh li iw bi translated">kube flow m lops管道组件</h2><p id="8712" class="pw-post-body-paragraph lj lk iq ll b lm ln ka lo lp lq kd lr kx ls lt lu lb lv lw lx lf ly lz ma mb ij bi translated">Kubeflow是一个伞状项目；有多个项目与它集成，一些用于可视化，如张量板，另一些用于优化，如Katib，然后是用于训练和服务的ML操作符等。但主要指的是库伯流管道。这是Kubeflow项目的核心，管道任务集成到各种其他项目中。注意，Kubeflow中的所有东西都运行在Kubernetes集群上。Kubernetes是资源供应商和执行引擎。</p><p id="14a2" class="pw-post-body-paragraph lj lk iq ll b lm mc ka lo lp md kd lr kx me lt lu lb mf lw lx lf mg lz ma mb ij bi translated">Kubeflow基于Kubernetes。这是它的长处。然而，这意味着内部的一切都必须作为容器运行。</p><p id="dee0" class="pw-post-body-paragraph lj lk iq ll b lm mc ka lo lp md kd lr kx me lt lu lb mf lw lx lf mg lz ma mb ij bi translated">然而，让ML科学家或ML工程师接触通过Docker文件和K8s部署文件创建容器映像的复杂性并不是最佳选择。公司会有工程师团队来做这件事。但是，有没有一种方法可以促使ML科学家或ML工程师开发他们的ML程序作为谨慎的组件，而不需要他们了解太多的Kubernetes或容器技术？正如我们之前所描述的，这是库巴流的一个主要存在理由。</p><p id="90bf" class="pw-post-body-paragraph lj lk iq ll b lm mc ka lo lp md kd lr kx me lt lu lb mf lw lx lf mg lz ma mb ij bi translated">因此，我们要做的是采用常规的基于Jupyter笔记本的ML开发，并尝试将其转换为Kubeflow系统，但采用模块化的方式。</p><p id="b2fc" class="pw-post-body-paragraph lj lk iq ll b lm mc ka lo lp md kd lr kx me lt lu lb mf lw lx lf mg lz ma mb ij bi translated">下面是我们借鉴的Colab项目<a class="ae mh" href="https://colab.research.google.com/gist/alexcpn/fa8b3207fbc72f471bdb72433102344c/heartattack-prediction-tfdata.ipynb" rel="noopener ugc nofollow" target="_blank">[1]https://Colab . research . Google . com/gist/Alex CPN/fa8b 3207 FBC 72 f 471 BDB 72433102344 c/heart attack-prediction-TF data . ipynb</a></p><p id="8d91" class="pw-post-body-paragraph lj lk iq ll b lm mc ka lo lp md kd lr kx me lt lu lb mf lw lx lf mg lz ma mb ij bi translated">我们将使这款Jupyter笔记本符合Kubeflow标准。</p><p id="781e" class="pw-post-body-paragraph lj lk iq ll b lm mc ka lo lp md kd lr kx me lt lu lb mf lw lx lf mg lz ma mb ij bi translated"><strong class="ll ja">安装Kubeflow </strong></p><p id="91bf" class="pw-post-body-paragraph lj lk iq ll b lm mc ka lo lp md kd lr kx me lt lu lb mf lw lx lf mg lz ma mb ij bi translated">Kubeflow使用服务网格Istio。这意味着设置这是一个挑战。这肯定会由“MLOps团队”来完成。如果你有一台基于Linux的现代笔记本电脑；你可以使用<a class="ae mh" href="https://kind.sigs.k8s.io/" rel="noopener ugc nofollow" target="_blank">类</a>集群来设置。</p><p id="d2bd" class="pw-post-body-paragraph lj lk iq ll b lm mc ka lo lp md kd lr kx me lt lu lb mf lw lx lf mg lz ma mb ij bi translated">请遵循这个；如果您还没有准备好Kubeflow集群，或者您想要使用Kind cluster<a class="ae mh" href="https://gist.github.com/alexcpn/f7068ba5b7205e75b955404f2fc24427" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/Alex CPN/f 7068 ba 5b 7205 e 75 b 955404 F2 fc 24427</a>在Linux PC或笔记本电脑上创建一个快速集群。</p><p id="6ad7" class="pw-post-body-paragraph lj lk iq ll b lm mc ka lo lp md kd lr kx me lt lu lb mf lw lx lf mg lz ma mb ij bi translated">请注意，如果您使用的是GKE集群，请确保您的节点有足够的CPU和内存，因为部署中设置了资源请求。此外，如果你打算使用GKE自动驾驶模式，至少现在它不工作，因为Istio不被支持。</p><p id="841b" class="pw-post-body-paragraph lj lk iq ll b lm mc ka lo lp md kd lr kx me lt lu lb mf lw lx lf mg lz ma mb ij bi translated">请注意，我们使用清单方法从Kubeflow清单报告安装kube flow-<code class="fe nn no np nq b">https://github.com/kubeflow/manifests</code></p><p id="335b" class="pw-post-body-paragraph lj lk iq ll b lm mc ka lo lp md kd lr kx me lt lu lb mf lw lx lf mg lz ma mb ij bi translated"><strong class="ll ja">创建一个Jupyter笔记本</strong></p><p id="de59" class="pw-post-body-paragraph lj lk iq ll b lm mc ka lo lp md kd lr kx me lt lu lb mf lw lx lf mg lz ma mb ij bi translated">如果您成功安装了Kubeflow，您将在Kubeflow仪表板中获得一个Jupyter笔记本，在这里可以查看大多数默认的“组件”</p><figure class="mr ms mt mu gt mv gh gi paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><div class="gh gi nr"><img src="../Images/766f7aa8376c803bad5af6de37eb2267.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1cCoyWZVUusxcYGMnJEfJA.png"/></div></div></figure><h2 id="8790" class="ko kp iq bd kq kr ks dn kt ku kv dp kw kx ky kz la lb lc ld le lf lg lh li iw bi translated">任务一—连接到Kubeflow管道服务器</h2><p id="70c6" class="pw-post-body-paragraph lj lk iq ll b lm ln ka lo lp lq kd lr kx ls lt lu lb lv lw lx lf ly lz ma mb ij bi translated">让我们创建一个Jupyter笔记本实例；以下代码用于连接Kubeflow管道服务器。</p><figure class="mr ms mt mu gt mv"><div class="bz fp l di"><div class="ns nt l"/></div></figure><h2 id="c254" class="ko kp iq bd kq kr ks dn kt ku kv dp kw kx ky kz la lb lc ld le lf lg lh li iw bi translated">任务二——用Python代码创建一个Kubeflow组件</h2><p id="7faf" class="pw-post-body-paragraph lj lk iq ll b lm ln ka lo lp lq kd lr kx ls lt lu lb lv lw lx lf ly lz ma mb ij bi translated">我们将使用`<strong class="ll ja">create _ component _ from _ func _ v2</strong>` SDK helper方法来创建Python组件的部署</p><p id="0dd3" class="pw-post-body-paragraph lj lk iq ll b lm mc ka lo lp md kd lr kx me lt lu lb mf lw lx lf mg lz ma mb ij bi translated">在这里列出python组件；</p><figure class="mr ms mt mu gt mv"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="c768" class="pw-post-body-paragraph lj lk iq ll b lm mc ka lo lp md kd lr kx me lt lu lb mf lw lx lf mg lz ma mb ij bi translated">让我们更详细地看看这个组件。</p><p id="50ff" class="pw-post-body-paragraph lj lk iq ll b lm mc ka lo lp md kd lr kx me lt lu lb mf lw lx lf mg lz ma mb ij bi translated"><strong class="ll ja">从Python函数创建组件并发布它</strong></p><p id="c090" class="pw-post-body-paragraph lj lk iq ll b lm mc ka lo lp md kd lr kx me lt lu lb mf lw lx lf mg lz ma mb ij bi translated">我们在上面做的事情非常简单；接受一个URL并使用Pandas库读取一些数据。如果你看到原来的Colab Jupyter笔记本<a class="ae mh" href="https://colab.research.google.com/gist/alexcpn/fa8b3207fbc72f471bdb72433102344c/heartattack-prediction-tfdata.ipynb" rel="noopener ugc nofollow" target="_blank">【1】</a>你可以看到我们正在<strong class="ll ja">将阅读部分拆分成不同的功能。</strong></p><p id="56d1" class="pw-post-body-paragraph lj lk iq ll b lm mc ka lo lp md kd lr kx me lt lu lb mf lw lx lf mg lz ma mb ij bi translated">这个函数有一个字符串类型的URL输入。因为这是Python中的内置数据结构，所以可以按原样提供。我们将输出一个熊猫数据帧作为输出。</p><p id="35c3" class="pw-post-body-paragraph lj lk iq ll b lm mc ka lo lp md kd lr kx me lt lu lb mf lw lx lf mg lz ma mb ij bi translated">一旦我们使它成为一个组件，它就成为一个容器映像，并在Docker中作为一个容器运行。所以所有功能的输入输出都需要通过某种接口。Kubeflow使用文件接口-K8s持久卷。Kubeflow (v1)有这个<em class="mi">输入路径和输出路径</em>组件助手函数，它接收数据并使用Python <a class="ae mh" href="https://docs.python.org/3/library/pickle.html" rel="noopener ugc nofollow" target="_blank"> pickle </a>函数序列化到磁盘。</p><p id="c544" class="pw-post-body-paragraph lj lk iq ll b lm mc ka lo lp md kd lr kx me lt lu lb mf lw lx lf mg lz ma mb ij bi translated">请注意，您可以将PVC附加到组件上并向其写入。但这违背了库伯流使用原则；因为添加PVC的那一刻，组件不再变成<strong class="ll ja">不可重复使用</strong>。您可能需要将此用于外部可视化，如张量板可视化。</p><p id="cc1f" class="pw-post-body-paragraph lj lk iq ll b lm mc ka lo lp md kd lr kx me lt lu lb mf lw lx lf mg lz ma mb ij bi translated">完整代码在这里</p><p id="5fff" class="pw-post-body-paragraph lj lk iq ll b lm mc ka lo lp md kd lr kx me lt lu lb mf lw lx lf mg lz ma mb ij bi translated"><a class="ae mh" href="https://colab.research.google.com/drive/1f_p4EVKReT57J4Maz4vRfhccJ_qVv03W?usp=sharing" rel="noopener ugc nofollow" target="_blank">https://colab . research . Google . com/drive/1f _ p 4 evkret 57j 4 maz 4 vrfhccj _ qvv 03 w？usp =共享</a></p><p id="2029" class="pw-post-body-paragraph lj lk iq ll b lm mc ka lo lp md kd lr kx me lt lu lb mf lw lx lf mg lz ma mb ij bi translated">以下片段:</p><figure class="mr ms mt mu gt mv"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="1a13" class="pw-post-body-paragraph lj lk iq ll b lm mc ka lo lp md kd lr kx me lt lu lb mf lw lx lf mg lz ma mb ij bi translated">让我们看看这个组件是如何创建的。如您所见，基础映像和要安装的包在<em class="mi">create _ component _ from _ func</em>方法中给出，Rest是Kubeflow magic，用于创建Pod部署。</p><figure class="mr ms mt mu gt mv"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="c929" class="pw-post-body-paragraph lj lk iq ll b lm mc ka lo lp md kd lr kx me lt lu lb mf lw lx lf mg lz ma mb ij bi translated">您可以在这个Kubeflow仪表板快照中看到输入和输出是如何表示的</p><figure class="mr ms mt mu gt mv"><div class="bz fp l di"><div class="nu nt l"/></div></figure><p id="0242" class="pw-post-body-paragraph lj lk iq ll b lm mc ka lo lp md kd lr kx me lt lu lb mf lw lx lf mg lz ma mb ij bi translated">注意，我也可以把它写到一个组件中，并说把它放在一个组件存储中，然后从存储中加载组件</p><p id="1bf3" class="pw-post-body-paragraph lj lk iq ll b lm mc ka lo lp md kd lr kx me lt lu lb mf lw lx lf mg lz ma mb ij bi translated">我刚刚把这个上传到gist，你可以看到我从URL中读取的第二个片段。任何有权访问的人都可以通过将输入数据更改为他们自己的数据，为他们的流重用相同的组件。</p><figure class="mr ms mt mu gt mv"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="b9cd" class="pw-post-body-paragraph lj lk iq ll b lm mc ka lo lp md kd lr kx me lt lu lb mf lw lx lf mg lz ma mb ij bi translated">其他<a class="ae mh" href="https://gist.github.com/alexcpn/e9a0c4bd79ae59ac8e822c121fbcce80" rel="noopener ugc nofollow" target="_blank">组件</a>遵循类似流程。</p><figure class="mr ms mt mu gt mv"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="990e" class="pw-post-body-paragraph lj lk iq ll b lm mc ka lo lp md kd lr kx me lt lu lb mf lw lx lf mg lz ma mb ij bi translated"><strong class="ll ja">将元件接线在一起</strong></p><p id="dc81" class="pw-post-body-paragraph lj lk iq ll b lm mc ka lo lp md kd lr kx me lt lu lb mf lw lx lf mg lz ma mb ij bi translated">现在让我们看看这些组件是如何连接在一起的。</p><figure class="mr ms mt mu gt mv"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="f97c" class="pw-post-body-paragraph lj lk iq ll b lm mc ka lo lp md kd lr kx me lt lu lb mf lw lx lf mg lz ma mb ij bi translated">在第二个代码片段中，您可以看到<em class="mi"> read_data </em>输出通过管道传输到<em class="mi"> process_data </em>的输入</p><p id="6aff" class="pw-post-body-paragraph lj lk iq ll b lm mc ka lo lp md kd lr kx me lt lu lb mf lw lx lf mg lz ma mb ij bi translated">让我们看看在<em class="mi"> process_data </em>函数中发生的奇迹</p><pre class="mr ms mt mu gt nv nq nw nx aw ny bi"><span id="c4bd" class="ko kp iq nq b gy nz oa l ob oc">#Lets use output or target as preiction label<br/>def process_data( pandas_parquet: InputPath("PandasDataFrame"),<br/>                 out_train_path: OutputPath("TF_DataSet"),<br/>                 out_test_path: OutputPath("TF_DataSet"),<br/>                out_validate_path:OutputPath("TF_DataSet")<br/>                ):<br/>    import pandas as pd<br/>    import sklearn as sk<br/>    import numpy as np<br/>    import tensorflow as tf<br/>    <br/>    from tensorflow import keras<br/>    from tensorflow.keras import layers<br/>    from tensorflow.keras.layers.experimental import preprocessing<br/>    from sklearn.model_selection import train_test_split<br/>    <br/>   <strong class="nq ja"> df = pd.read_parquet(pandas_parquet)</strong></span></pre><p id="26d1" class="pw-post-body-paragraph lj lk iq ll b lm mc ka lo lp md kd lr kx me lt lu lb mf lw lx lf mg lz ma mb ij bi translated">我们读入拼花文件作为输入，并转换成熊猫数据帧。所以是的——没有魔法；类似地，您可以看到我们在一个组件中取出h5 Keras模型，并在另一个组件中读取该模型。</p><p id="921d" class="pw-post-body-paragraph lj lk iq ll b lm mc ka lo lp md kd lr kx me lt lu lb mf lw lx lf mg lz ma mb ij bi translated">这是您在必须分成不同组件时所做的权衡。也许Kubeflow的未来版本会为其中一些提供GRPC接口，这可能会加快速度。但是这个例子也是一个玩具例子，你不需要把所有东西都分成组件。</p><p id="8f13" class="pw-post-body-paragraph lj lk iq ll b lm mc ka lo lp md kd lr kx me lt lu lb mf lw lx lf mg lz ma mb ij bi translated"><strong class="ll ja">数据流的可视化</strong></p><p id="2f2e" class="pw-post-body-paragraph lj lk iq ll b lm mc ka lo lp md kd lr kx me lt lu lb mf lw lx lf mg lz ma mb ij bi translated">Kubeflow提供了数据流的交互式下钻可视化。如果豆荚还在Kubernetes，你可以看到豆荚日志。T</p><figure class="mr ms mt mu gt mv gh gi paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><div class="gh gi od"><img src="../Images/7300808ba134ee87e31d87e99da009be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xX_DTGt_pSAqhXzjklBn9A.png"/></div></div></figure><p id="5b3e" class="pw-post-body-paragraph lj lk iq ll b lm mc ka lo lp md kd lr kx me lt lu lb mf lw lx lf mg lz ma mb ij bi translated">投入/产出假象在S3持续存在。Kubeflow默认运行基于Minio的S3存储桶。</p><figure class="mr ms mt mu gt mv gh gi paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><div class="gh gi oe"><img src="../Images/8c7b28e3f4a1f039f0cfe9e6a6e44c18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*orNA1n20j8K3N8xll4AKhg.png"/></div></div></figure><p id="83ff" class="pw-post-body-paragraph lj lk iq ll b lm mc ka lo lp md kd lr kx me lt lu lb mf lw lx lf mg lz ma mb ij bi translated">您可以通过端口转发直接访问Minio</p><pre class="mr ms mt mu gt nv nq nw nx aw ny bi"><span id="c582" class="ko kp iq nq b gy nz oa l ob oc">kubectl port-forward svc/minio-service -n kubeflow  9000:9000</span></pre><p id="f372" class="pw-post-body-paragraph lj lk iq ll b lm mc ka lo lp md kd lr kx me lt lu lb mf lw lx lf mg lz ma mb ij bi translated">默认-minio/minio 123</p><figure class="mr ms mt mu gt mv gh gi paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><div class="gh gi of"><img src="../Images/f8ea2f83bc16dfb7f918510e220af4aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KE9x_HdoLMIDsB5RIyBGog.png"/></div></div></figure><p id="8efe" class="pw-post-body-paragraph lj lk iq ll b lm mc ka lo lp md kd lr kx me lt lu lb mf lw lx lf mg lz ma mb ij bi translated">有点像穷人的藏物店。注意，你也可以用它来输出张量板矩阵；尽管我还不能连接运行在名称空间中的Tensorboard Pod，以便从仪表板UI正确地到达S3 URL。</p><p id="8b98" class="pw-post-body-paragraph lj lk iq ll b lm mc ka lo lp md kd lr kx me lt lu lb mf lw lx lf mg lz ma mb ij bi translated"><strong class="ll ja">实验可视化</strong></p><p id="a96f" class="pw-post-body-paragraph lj lk iq ll b lm mc ka lo lp md kd lr kx me lt lu lb mf lw lx lf mg lz ma mb ij bi translated">Kubeflow V1管道中组件的输出可以从仪表板中可视化。然而，到目前为止，它还不是一个非常强大的GUI。在V2版本中，似乎对此有更好的支持；然而，我测试过的版本似乎有问题(库伯弗洛V2正在测试中)</p><figure class="mr ms mt mu gt mv"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="7e85" class="pw-post-body-paragraph lj lk iq ll b lm mc ka lo lp md kd lr kx me lt lu lb mf lw lx lf mg lz ma mb ij bi translated">和输出</p><figure class="mr ms mt mu gt mv gh gi paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><div class="gh gi og"><img src="../Images/293ad65f305a195f1780b2e50741a450.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BsggDPSnTk6ngjmuNGRLew.png"/></div></div></figure><p id="f5f2" class="pw-post-body-paragraph lj lk iq ll b lm mc ka lo lp md kd lr kx me lt lu lb mf lw lx lf mg lz ma mb ij bi translated">您也可以在运行之间进行比较；在你暴露的矩阵上</p><p id="77b1" class="pw-post-body-paragraph lj lk iq ll b lm mc ka lo lp md kd lr kx me lt lu lb mf lw lx lf mg lz ma mb ij bi translated"><strong class="ll ja">优化</strong></p><p id="ccf0" class="pw-post-body-paragraph lj lk iq ll b lm mc ka lo lp md kd lr kx me lt lu lb mf lw lx lf mg lz ma mb ij bi translated">Kubeflow内部整合了Katib但是需要用docker容器等指定完整的YAML文件-<a class="ae mh" href="https://www.kubeflow.org/docs/components/katib/experiment/" rel="noopener ugc nofollow" target="_blank">https://www.kubeflow.org/docs/components/katib/experiment/</a>。与Optuna不同，我猜Katib首先是Kubernetes，因此很复杂。</p><p id="589c" class="pw-post-body-paragraph lj lk iq ll b lm mc ka lo lp md kd lr kx me lt lu lb mf lw lx lf mg lz ma mb ij bi translated"><strong class="ll ja">参考</strong></p><p id="992e" class="pw-post-body-paragraph lj lk iq ll b lm mc ka lo lp md kd lr kx me lt lu lb mf lw lx lf mg lz ma mb ij bi translated"><a class="ae mh" href="https://cloud.google.com/architecture/mlops-continuous-delivery-and-automation-pipelines-in-machine-learning" rel="noopener ugc nofollow" target="_blank">https://cloud . Google . com/architecture/mlops-连续交付和自动化-机器学习管道</a></p></div></div>    
</body>
</html>