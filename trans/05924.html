<html>
<head>
<title>Exploratory Data Analysis (EDA)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">探索性数据分析</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/exploratory-data-analysis-eda-72ba03480417?source=collection_archive---------14-----------------------#2021-05-27">https://towardsdatascience.com/exploratory-data-analysis-eda-72ba03480417?source=collection_archive---------14-----------------------#2021-05-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="79e1" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">我如何在建模前调查数据</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c961ed2034a004e42c47a54cc64f101b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xTJtSQEGM4gkapqbeMRhAA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在<a class="ae ky" href="https://unsplash.com/s/photos/investigation?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae ky" href="https://unsplash.com/@adeolueletu?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Adeolu Eletu </a>拍摄的照片</p></figure><p id="b310" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">人们总说“做建模之前要先了解数据”。“<strong class="lb iu">了解数据</strong>到底是什么意思，有什么具体的步骤可以遵循吗？</p><blockquote class="lv"><p id="43a7" class="lw lx it bd ly lz ma mb mc md me lu dk translated">理解数据的过程称为探索性数据分析(EDA)。它是指在应用机器学习模型之前，对数据集进行初步调查和分析，以了解分布、异常、相关性和其他数据特征的过程。</p></blockquote><p id="d3bc" class="pw-post-body-paragraph kz la it lb b lc mf ju le lf mg jx lh li mh lk ll lm mi lo lp lq mj ls lt lu im bi translated">假设您已经有了包含所有必需数据变量的数据集，并定义了要优化的因变量。本文将介绍如何使用数据集来更好地理解它。</p><p id="7db1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于如何进行EDA，没有固定的过程。我觉得以下步骤可能有助于您更好地理解数据，但您可以根据您的数据集对其进行自定义。</p><h1 id="c83e" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">资料组</h1><p id="c4c6" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">我们使用Kaggle 的<a class="ae ky" href="https://www.kaggle.com/c/house-prices-advanced-regression-techniques/data" rel="noopener ugc nofollow" target="_blank">房价数据集。数据的想法很简单——根据房屋特征预测房价。但是，我们从这个数据例子中了解EDA过程是非常理想的，因为它有<strong class="lb iu"> 80个自变量</strong>！</a></p><blockquote class="nh ni nj"><p id="3b3c" class="kz la nk lb b lc ld ju le lf lg jx lh nl lj lk ll nm ln lo lp nn lr ls lt lu im bi translated">H <!-- -->我们如何更好地理解数据以<strong class="lb iu">选择有用的预测指标</strong>来预测房价将是这项工作的关键。</p></blockquote><h1 id="c7f8" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">EDA的步骤</h1><h2 id="1dbf" class="no ml it bd mm np nq dn mq nr ns dp mu li nt nu mw lm nv nw my lq nx ny na nz bi translated">第一步。查看整个数据概览</h2><pre class="kj kk kl km gt oa ob oc od aw oe bi"><span id="c5bd" class="no ml it ob b gy of og l oh oi">train.head()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/d8b8530a9c44a4c174149d5781db109f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vJ-A7S8yVGnqRukHGsXJRw.png"/></div></div></figure><p id="be6d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">查看前5行数据，了解每一行的情况。您可以使用tail函数查看最后5行数据</p><pre class="kj kk kl km gt oa ob oc od aw oe bi"><span id="fa8b" class="no ml it ob b gy of og l oh oi">train.shape<br/>#(1460,81)</span></pre><p id="96f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">查看数据集的行数和列数</p><pre class="kj kk kl km gt oa ob oc od aw oe bi"><span id="2361" class="no ml it ob b gy of og l oh oi">train.info()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/35bbaa85ea1d7d0571233fe274bf051d.png" data-original-src="https://miro.medium.com/v2/resize:fit:790/format:webp/1*ryw8fM170el7tsRbO-BddA.png"/></div></figure><p id="b92e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">查看每列信息(数据类型，空行)</p><p id="0434" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以看出目标变量(Saleprice)是连续的整数数据类型。</p><p id="82f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">结果的最后一部分(在下面的屏幕截图中用红色突出显示)显示了所有列的数据类型分布。例如，在这种情况下，我们知道我们有38列(包括因变量)数字类型(float或int)，43列字符串类型。</p><h2 id="487f" class="no ml it bd mm np nq dn mq nr ns dp mu li nt nu mw lm nv nw my lq nx ny na nz bi translated">第二步。查看缺失的数据</h2><p id="a7eb" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">在前面的屏幕截图中，我们可以看到某些列有很多空值，这在预测中是不可取的。在这里，我们首先希望<strong class="lb iu">看到数据集中顶部缺失的列</strong>。</p><pre class="kj kk kl km gt oa ob oc od aw oe bi"><span id="5853" class="no ml it ob b gy of og l oh oi">#count rows of missing data for each column<br/>missing_number=train.isnull().sum().sort_values(ascending=False)</span><span id="8aa2" class="no ml it ob b gy ol og l oh oi">#Calculate percentage of null value<br/>missing_percentage=missing_number/len(train)<br/>missing_info=pd.concat([missing_number,missing_percentage],axis=1,keys=['missing number','missing percentage'])<br/>missing_info.head(20)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi om"><img src="../Images/c8a68d98de4b299b4b0c23508e5541b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:680/format:webp/1*yUu-KebHcGlv2jitENfWSA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">缺失值计数</p></figure><p id="6cbc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以看到19列缺少记录，6列缺少超过15%的数据。</p><blockquote class="nh ni nj"><p id="dbdd" class="kz la nk lb b lc ld ju le lf lg jx lh nl lj lk ll nm ln lo lp nn lr ls lt lu im bi translated">就个人而言，我会删除掉<strong class="lb iu">超过15%缺失记录</strong>的列。然而，这也取决于<strong class="lb iu">有多少数据字段可用</strong>和<strong class="lb iu">字段在预测最终</strong>中有多重要。</p></blockquote><pre class="kj kk kl km gt oa ob oc od aw oe bi"><span id="2f85" class="no ml it ob b gy of og l oh oi">drop_columns=missing_info.head(6).index<br/>train=train.drop(columns=drop_columns)</span></pre><p id="2fce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">删除前6个缺失的列(缺失超过15%的6列)</p><h2 id="0b4e" class="no ml it bd mm np nq dn mq nr ns dp mu li nt nu mw lm nv nw my lq nx ny na nz bi translated">第三步。将数据集分为数字和分类(字符串)</h2><pre class="kj kk kl km gt oa ob oc od aw oe bi"><span id="3b17" class="no ml it ob b gy of og l oh oi">numerics = ['int64', 'float64']<br/>df_num = train.select_dtypes(include=numerics)</span></pre><p id="1a89" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从数据集中提取数字数据。这里你应该参考data.info()结果来看看你的数据类型是什么。</p><pre class="kj kk kl km gt oa ob oc od aw oe bi"><span id="b4cf" class="no ml it ob b gy of og l oh oi">df_num[['YearBuilt','GarageYrBlt','YrSold','YearRemodAdd']]=2010-df_num[['YearBuilt','GarageYrBlt','YrSold','YearRemodAdd']]</span></pre><p id="289b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">对“错误数字”列的特殊处理:</strong>这里我指的是以数字形式存在但实际上是分类的数据字段。例如，年份或城市等级以数字形式存在，但它们实际上是分类数据。您可以将它们视为数值型(如果value有意义)，将它们放入分类桶中，或者将数据转换为数值型。</p><p id="6c9b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我的例子中，我使用的是最后一种方法。例如，在“建造房屋的年份”列中，我使用当前年份减去“建造房屋的年份”来获得房屋建造的年份。这样，它就是一个有效的数值变量。</p><pre class="kj kk kl km gt oa ob oc od aw oe bi"><span id="2162" class="no ml it ob b gy of og l oh oi">for num_var in df_num.columns:<br/>    df_num[num_var].fillna(df_num[num_var].mean(),inplace=True)</span></pre><p id="56fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">替换数字数据中的空值</p><p id="7f70" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我使用列的<strong class="lb iu">平均值来填充空值。您可以选择对其他一些变量使用中值甚至简单的回归函数(如果在最终模型中也包含这些变量，可能会导致多重共线性)</strong></p><pre class="kj kk kl km gt oa ob oc od aw oe bi"><span id="0c02" class="no ml it ob b gy of og l oh oi">df_cat= train.select_dtypes(include='object')</span></pre><p id="86a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从数据集中提取字符串值列</p><pre class="kj kk kl km gt oa ob oc od aw oe bi"><span id="29d0" class="no ml it ob b gy of og l oh oi">for cat_var in df_cat.columns:<br/>    df_cat[cat_var].fillna(df_cat[cat_var].mode()[0],inplace=True)</span></pre><p id="e51a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，我用列中最常出现的值或模式值来填充分类空值。</p><h2 id="ac45" class="no ml it bd mm np nq dn mq nr ns dp mu li nt nu mw lm nv nw my lq nx ny na nz bi translated">第四步。查看数字列的数据分布</h2><pre class="kj kk kl km gt oa ob oc od aw oe bi"><span id="beeb" class="no ml it ob b gy of og l oh oi">df_num.describe()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi on"><img src="../Images/e6697a8bb3c32e48d71bd6899249bf87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dyO8i4kxcVTxmRUjI7Lkaw.png"/></div></div></figure><p id="b432" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Describe命令为您提供了一个关于所有数字列的汇总统计信息的概览表</p><pre class="kj kk kl km gt oa ob oc od aw oe bi"><span id="2dd2" class="no ml it ob b gy of og l oh oi">for i, col in enumerate(df_num.columns):<br/>    plt.figure(i)<br/>    ax = sns.distplot(train[col])</span></pre><div class="kj kk kl km gt ab cb"><figure class="oo kn op oq or os ot paragraph-image"><img src="../Images/3a7e2848377f129e81e24f54bedf7f7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:766/format:webp/1*9GJfurQsZLn9mQLbD2E-RA.png"/></figure><figure class="oo kn ou oq or os ot paragraph-image"><img src="../Images/27246a8fbaee64e1dd3950146ea99fa5.png" data-original-src="https://miro.medium.com/v2/resize:fit:810/format:webp/1*zNc7HjfrwKA4twbotwIwLQ.png"/></figure></div><p id="6b7a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者你可以画出所有数字变量(这里包括目标变量)的分布图，看看它们是右偏还是左偏。如果分布过于倾斜，您可能需要进行变换。上面的两个示例图显示，目标变量和地面居住面积都是右偏的，有一个长的右尾。</p><pre class="kj kk kl km gt oa ob oc od aw oe bi"><span id="f092" class="no ml it ob b gy of og l oh oi">df_num.corr()</span></pre><p id="d1bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Corr()将以表格的形式给出所有数值变量的相关矩阵。这对于查看自变量之间或自变量与因变量之间的相关性非常有用。然而，普通表格看起来并不那么用户友好，尤其是有大量预测值的时候。</p><pre class="kj kk kl km gt oa ob oc od aw oe bi"><span id="6d9c" class="no ml it ob b gy of og l oh oi">import seaborn as sns<br/>import matplotlib.pyplot as plt</span><span id="1eaf" class="no ml it ob b gy ol og l oh oi">#find correlation matrix<br/>corr_mat=df_num.corr()</span><span id="629c" class="no ml it ob b gy ol og l oh oi">#Select variables have more than 0.4 or less than -0.4 correlation with the dependent variable(SalePrice)<br/>chosen_variable=corr_mat[abs(corr_mat["SalePrice"])&gt;0.4].index</span><span id="e167" class="no ml it ob b gy ol og l oh oi">#plot the heatmap<br/>plt.figure(figsize=(12,12))<br/>ax = sns.heatmap(df_num[chosen_variable].corr(),annot=True,cmap='RdBu')</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ov"><img src="../Images/425812b0df7089b98166f2b128c0408d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oCorDVTAe0KhyS5lt4gHqA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">热图</p></figure><p id="d833" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">热图是关联矩阵更直观的表示。在这里，我只选择和想象与销售价格相关度大于0.4或小于-0.4的预测值。这是因为与因变量相关性的绝对值越高，预测值就越重要。</p><p id="82c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这也有助于你了解预测因子之间的相互关系。例如，地下室总表面和一楼表面具有0.81的强相关性。即使它们在预测销售价格方面都非常重要，您也应该只选择一个包含在模型中。</p><p id="575f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是选择重要数值特征的好方法，您可以根据预测值的数量来选择边界。如果您不喜欢当前的颜色组合，您也可以通过更改热图功能中的“cmap”参数，在此处参考<a class="ae ky" href="https://matplotlib.org/stable/tutorials/colors/colormaps.html" rel="noopener ugc nofollow" target="_blank">选择其他颜色。</a></p><h2 id="5395" class="no ml it bd mm np nq dn mq nr ns dp mu li nt nu mw lm nv nw my lq nx ny na nz bi translated">步骤5:查看文本变量的数据特征</h2><pre class="kj kk kl km gt oa ob oc od aw oe bi"><span id="3a0e" class="no ml it ob b gy of og l oh oi">for cat_var in df_cat.columns:<br/>    print(df_cat[cat_var].value_counts())</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ow"><img src="../Images/2a68bf8806dd081cacdd83c44d299da5.png" data-original-src="https://miro.medium.com/v2/resize:fit:608/format:webp/1*HlToWVqSYB59zWVUY5v5eg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">结果的前4个变量</p></figure><p id="fe2e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将打印出所有字符串变量的分布。如果一个文本变量非常集中在某个值上，如住房数据集中的“街道”,该数据集中有1454个Pave，而Grvl上只有6个，那么它对预测不会有很大的贡献。</p><pre class="kj kk kl km gt oa ob oc od aw oe bi"><span id="1427" class="no ml it ob b gy of og l oh oi">for i, col in enumerate(df_cat.columns):<br/>    plt.figure(i)<br/>    ax = sns.barplot(x=col, y="SalePrice", data=train)</span></pre><div class="kj kk kl km gt ab cb"><figure class="oo kn ox oq or os ot paragraph-image"><img src="../Images/57ead90b9fc94e22667fc9b0375fac5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:860/format:webp/1*_3hazq2d8qQ84ELmfdcnpA.png"/></figure><figure class="oo kn oy oq or os ot paragraph-image"><img src="../Images/361c4b69d8d3aef321037ccad6eb8ccd.png" data-original-src="https://miro.medium.com/v2/resize:fit:854/format:webp/1*lSJUkFr7DBDBuSrIJxldzQ.png"/><p class="ku kv gj gh gi kw kx bd b be z dk oz di pa pb translated">分类变量和因变量之间的条形图(销售价格)</p></figure></div><p id="bb72" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这部分绘制了每个分类变量类别之间销售价格分布的柱状图。理想情况下，您希望看到不同类别之间销售价格的巨大差异，因为这样分类变量将是预测最终价格的一个很好的预测器。</p><p id="f55e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您还应该查看前面的value_count表的结果，以确保每个类别都有足够的数据大小来支持它。例如，即使铺路街道类型的房屋比Grvl街道类型的房屋具有明显更高的平均销售价格，也只有6所房屋具有Grvl街道类型，因此数据大小不具有支持结论的统计意义。</p><h1 id="abb0" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">最后</h1><p id="b837" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated"><strong class="lb iu">还有几点需要注意:</strong></p><ol class=""><li id="3987" class="pc pd it lb b lc ld lf lg li pe lm pf lq pg lu ph pi pj pk bi translated">这里我假设我们只有一个训练数据集。如果您既有训练数据集又有测试数据集，您应该将它们结合起来用于EDA，因为它可能涉及一些数据转换</li><li id="ab7e" class="pc pd it lb b lc pl lf pm li pn lm po lq pp lu ph pi pj pk bi translated">房价的例子就是回归的例子。这里的因变量是连续的和数值的。如果你有一个分类问题，你应该选择绘制条形图分布，而不是相关矩阵来选择数值预测。</li><li id="020b" class="pc pd it lb b lc pl lf pm li pn lm po lq pp lu ph pi pj pk bi translated">如果你有时间序列变量，你也可以用因变量绘制时间趋势图来观察特征的显著性</li></ol><p id="1206" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">绘制了变量的相关性和分布之后，如何知道应该处理多重共线性还是正态性问题？你可以从下面我以前的文章中找到更多信息:</p><div class="pq pr gp gr ps pt"><a rel="noopener follow" target="_blank" href="/multi-collinearity-in-regression-fe7a2c1467ea"><div class="pu ab fo"><div class="pv ab pw cl cj px"><h2 class="bd iu gy z fp py fr fs pz fu fw is bi translated">回归中的多重共线性</h2><div class="qa l"><h3 class="bd b gy z fp py fr fs pz fu fw dk translated">为什么这是个问题？如何跟踪和修复它</h3></div><div class="qb l"><p class="bd b dl z fp py fr fs pz fu fw dk translated">towardsdatascience.com</p></div></div><div class="qc l"><div class="qd l qe qf qg qc qh ks pt"/></div></div></a></div><div class="pq pr gp gr ps pt"><a rel="noopener follow" target="_blank" href="/is-normal-distribution-necessary-in-regression-how-to-track-and-fix-it-494105bc50dd"><div class="pu ab fo"><div class="pv ab pw cl cj px"><h2 class="bd iu gy z fp py fr fs pz fu fw is bi translated">回归中正态分布有必要吗？如何跟踪修复？</h2><div class="qa l"><h3 class="bd b gy z fp py fr fs pz fu fw dk translated">博克斯-考克斯变换，夏皮罗-维尔克检验，QQ图</h3></div><div class="qb l"><p class="bd b dl z fp py fr fs pz fu fw dk translated">towardsdatascience.com</p></div></div><div class="qc l"><div class="qi l qe qf qg qc qh ks pt"/></div></div></a></div></div></div>    
</body>
</html>