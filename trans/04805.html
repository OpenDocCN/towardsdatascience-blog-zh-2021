<html>
<head>
<title>What’s lost in JPEG?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JPEG丢失了什么？</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/whats-lost-in-jpeg-e5e6e80b1f94?source=collection_archive---------30-----------------------#2021-04-26">https://towardsdatascience.com/whats-lost-in-jpeg-e5e6e80b1f94?source=collection_archive---------30-----------------------#2021-04-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="4871" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/hands-on-tutorials" rel="noopener" target="_blank">实践教程</a></h2><div class=""/><div class=""><h2 id="fa05" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">从头开始有损图像压缩</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/37dfc7d2c1ef130a11a710515f56fd26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JsFiJXHtw5f8K8bCZt1H3w.jpeg"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">作者图片</p></figure><p id="c3c2" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">当我第一次拿到相机时，我拍摄的所有照片都是JPEG格式的。然而，一旦我开始在网上查看摄影教程和博客帖子，所有严肃的摄影师都以raw图像格式拍摄，JPEG被认为是次等的。我的JPEG图像文件也只有raw的一半或四分之一或更小，这让我相信raw格式捕捉到了更多的信息。但我也在想:JPEG到底缺了什么？</p><p id="eaf5" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">在这篇文章中，我将用Python复制JPEG压缩过程中的有损部分，使用公共库(实际压缩中通常只有Numpy和Scipy)，包括色度子采样、离散余弦变换和量化。JPEG还进行一种称为熵编码的特殊编码，以使文件更小，但它不会影响最终图像的质量，因为压缩是无损的。我不会在这里介绍熵编码，因为在这个阶段没有信息丢失。</p><h1 id="555e" class="ma mb iq bd mc md me mf mg mh mi mj mk kf ml kg mm ki mn kj mo kl mp km mq mr bi translated">原始文件预处理</h1><p id="49cc" class="pw-post-body-paragraph le lf iq lg b lh ms ka lj lk mt kd lm ln mu lp lq lr mv lt lu lv mw lx ly lz ij bi translated">原始图像文件包含来自数码相机传感器的最低限度处理的数据，通常它与相机传感器的“视觉”最为接近。为了处理和操作原始图像数据，我们将把图像转换成一个Numpy数组。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mx my l"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">注意文件扩展名<em class="mz">。ARW </em>是索尼相机特有的，还有许多其他的扩展。还要注意，文件大小超过25MB，我的相机有2400万像素。</p></figure><p id="ac55" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">在这里，<a class="ae na" href="https://github.com/letmaik/rawpy" rel="noopener ugc nofollow" target="_blank"> rawpy </a>库完成了读取图像和元数据的繁重工作，并将其后处理成一个具有三个颜色通道(RGB)的图像数组。然后我使用<a class="ae na" href="https://docs.opencv.org/3.4/de/d25/imgproc_color_conversions.html" rel="noopener ugc nofollow" target="_blank"> OpenCV </a>将图像转换到<a class="ae na" href="https://en.wikipedia.org/wiki/YCbCr" rel="noopener ugc nofollow" target="_blank"> YCrCb </a>颜色空间。这个特定的色彩空间具有一个亮度分量(Y)和两个色度分量(Cr和Cb ),亮度分量是像素的亮度，色度分量表示颜色。使用YCrCb优于RGB的优势在于，我们可以对亮度和色度分量使用不同的压缩级别，因为我们的眼睛对亮度比对色彩饱和度更敏感。像素值也以0为中心，为以后的计算做准备。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nb"><img src="../Images/46d5caa05f14b432dfcde037f79a793d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bN9dewQj04uQXfg15fEEew.jpeg"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">YCrCb颜色空间的不同通道。Cr和Cb是红色和蓝色的差异成分，其中较亮的像素表示更强烈的颜色。照片中的蓟花有明亮的紫色，这是红色和蓝色的组合，因此是Cr和Cb通道中的亮点。</p></figure><h1 id="f973" class="ma mb iq bd mc md me mf mg mh mi mj mk kf ml kg mm ki mn kj mo kl mp km mq mr bi translated">向下采样</h1><p id="e4ce" class="pw-post-body-paragraph le lf iq lg b lh ms ka lj lk mt kd lm ln mu lp lq lr mv lt lu lv mw lx ly lz ij bi translated">知道我们在亮度通道中看到更多细节，我们将在水平和垂直方向上以因子2对两个色度分量进行下采样(也称为色度子采样)。为此，我们将计算四个相邻像素的平均值，并用平均值覆盖它们。如果您熟悉神经网络中的池化，这本质上是一个具有2x2内核的平均池化操作，但没有减少图像维度。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="0314" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">上面的代码很慢，尤其是在下采样比为4:2:0的情况下使用双循环时。我们可以使用Scipy来加速它，因为它相当于步长为2的2D卷积(在每个元素乘法后跳过2个像素)，并且相等的内核权重总和为1。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mx my l"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">将函数包装在一个类中，这样如果ratio参数不变，我们就可以重用一个实例。convolve2d函数没有stride参数，所以我将跳过结果矩阵中的每隔一个条目。同样重复这些元素，以便输出与输入具有相同的维数。</p></figure><p id="b1db" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">如上所述，我们将仅对色度分量进行下采样:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mx my l"/></div></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nb"><img src="../Images/16a6eda2af3d551be704494d72d01826.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G_ccYogAxE36Q794xMP3cw.jpeg"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">色度二次采样示例，请注意，我们通过取平均值丢失了一些颜色变化。</p></figure><h1 id="6f26" class="ma mb iq bd mc md me mf mg mh mi mj mk kf ml kg mm ki mn kj mo kl mp km mq mr bi translated">块分裂</h1><p id="fe1b" class="pw-post-body-paragraph le lf iq lg b lh ms ka lj lk mt kd lm ln mu lp lq lr mv lt lu lv mw lx ly lz ij bi translated">在进行下一步之前，我们需要将所有通道的图像分割成8×8的块，如果维数不能被8整除，则应用必要的填充。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="9885" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">正向操作分割输入图像，并返回块以及一组索引，用于以后的重建。向后操作将块连接回以形成图像，并从向前传递中移除填充。</p><h1 id="2fbc" class="ma mb iq bd mc md me mf mg mh mi mj mk kf ml kg mm ki mn kj mo kl mp km mq mr bi translated">离散余弦变换和量化</h1><p id="33d9" class="pw-post-body-paragraph le lf iq lg b lh ms ka lj lk mt kd lm ln mu lp lq lr mv lt lu lv mw lx ly lz ij bi translated">你能在多大程度上区分绿色的深浅？在一张树的照片中，我们只用了5种不同的色调，而不是20种不同的绿色，你还能分辨出这是一张树的照片吗？亮度的变化也是如此，如果我们使用更少的级别，我们可能无法分辨出差异。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/16f932a9fb17d741801c7af15455f447.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/format:webp/1*ZFFDtpRRch3UpBeuPZDcJw.png"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">来自<a class="ae na" href="https://i0.wp.com/imgs.xkcd.com/blag/doghouse_analysis.png" rel="noopener ugc nofollow" target="_blank"> XKCD色彩调查</a>，我们如何命名色彩。</p></figure><p id="f26e" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">这是量化的主要动机，我们将相同颜色或相似亮度级别的阴影放在一起，只使用一个值来表示整个桶。我们将在频域而不是空间域中这样做，因为在一个域中难以解决的问题在另一个域中可能更容易解决。在我们的例子中，并不总是很容易说出哪种红色应该被组合在一起，或者我们应该在橙色和黄色之间划一条线。</p><h2 id="af78" class="nd mb iq bd mc ne nf dn mg ng nh dp mk ln ni nj mm lr nk nl mo lv nm nn mq iw bi translated">离散余弦变换</h2><p id="b2ea" class="pw-post-body-paragraph le lf iq lg b lh ms ka lj lk mt kd lm ln mu lp lq lr mv lt lu lv mw lx ly lz ij bi translated">我们将使用二维DCT将我们的8×8块转换成频率。这意味着我们将试图把亮度或色块表示为各种余弦函数的和。形式上，</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi no"><img src="../Images/3dc75512bff8bca004540fdb0a17b62f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1258/format:webp/1*sTmv3FhLaopU7QwXpfDAzA.png"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">2D DCT来自<a class="ae na" href="https://en.wikipedia.org/wiki/JPEG#Discrete_cosine_transform" rel="noopener ugc nofollow" target="_blank">维基百科</a></p></figure><p id="3bbe" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">这里，输入是来自图像通道(Y、Cr或Cb)的8×8块，输出是相同大小的DCT系数矩阵。我们可以使用循环手工编码:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="7578" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">当然，Scipy 中有一个<a class="ae na" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.fft.dct.html" rel="noopener ugc nofollow" target="_blank"> DCT函数，它可以更有效地进行计算。二维版本相当于沿一个方向应用DCT，然后再沿另一个方向应用。</a></p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mx my l"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">这里使用“正交”或标准正交范数，使其与公式中的归一化标量保持一致。</p></figure><p id="1b9f" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">一个示例块可能如下所示:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi np"><img src="../Images/92bc513a58bc9af1c213b6c6c4f0e380.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IwLeCXAP8vkOnowKo4jhhw.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">左边是8×8像素的输入，右边是四舍五入到两位小数的DCT系数。</p></figure><p id="85ad" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">注意，DCT矩阵的第一个条目(左上角)比其余的条目大很多。这被称为DC系数，它反映了输入块的最显著特征。其他系数称为交流系数。</p><h2 id="d4d3" class="nd mb iq bd mc ne nf dn mg ng nh dp mk ln ni nj mm lr nk nl mo lv nm nn mq iw bi translated">量化</h2><p id="2940" class="pw-post-body-paragraph le lf iq lg b lh ms ka lj lk mt kd lm ln mu lp lq lr mv lt lu lv mw lx ly lz ij bi translated">现在我们有了一个块的频率表示，我们可以将频率组合在一起，减少可能信号的数量。为此，我们将一个块按元素划分为一个相同维数的矩阵，称为量化矩阵，然后将结果四舍五入为最接近的整数。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/618d3955cd03ab0c44203aaeb1bb339f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1228/format:webp/1*QXswEGmNg6T6HhbPj85JTw.png"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">摘自<a class="ae na" href="https://www.impulseadventure.com/photo/jpeg-quantization.html" rel="noopener ugc nofollow" target="_blank"> ImpulseAdventure </a>的量化矩阵示例。左边是亮度分量的量化矩阵，而右边是色度分量的矩阵。</p></figure><p id="0ebe" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">因为我们对亮度通道的细节比对颜色通道的细节更敏感，所以我们可以使用单独的量化矩阵。随着研究的深入，量化矩阵的值也逐渐变大。回想一下，DC系数位于左上角，将其除以一个较小的数会使其四舍五入为最接近的整数时不太可能为0。另一方面，除以较大的值会将较高的频率归零。量化矩阵中的值也控制压缩比；如果我们想要更大的压缩，我们可以使值更大，这样当舍入时，大部分块将是0。</p><p id="e015" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">使用上面的示例块(来自Cr通道),除以色度量化矩阵并舍入到最接近的整数，得到:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nr"><img src="../Images/aa6ad4f9681f77ba857d210e790055d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1mKtYdxyrwDsfOh_pj_VzA.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">左图是量化矩阵的除法结果，右图是四舍五入到最接近整数的矩阵。</p></figure><p id="0cb1" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">在这种特殊情况下，我们实际上只保留整个块的DC系数。</p><h1 id="e8b7" class="ma mb iq bd mc md me mf mg mh mi mj mk kf ml kg mm ki mn kj mo kl mp km mq mr bi translated">解码</h1><p id="74f1" class="pw-post-body-paragraph le lf iq lg b lh ms ka lj lk mt kd lm ln mu lp lq lr mv lt lu lv mw lx ly lz ij bi translated">我们已经完成了压缩，需要将频域中的这些块转换回图像。要做到这一点，我们基本上只需反向执行每个步骤。</p><p id="c1f0" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">首先，我们将块乘以相应的量化矩阵。请注意，我们在这里丢失了一些信息，因为一些系数被四舍五入为0。然后，我们对块应用逆DCT，以将它们变换回空间域。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/29a6fc985ce258829afb0d22d35f4e2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1262/format:webp/1*tDXGlDay31_k2Vrts18_FQ.png"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">2D逆DCT来自<a class="ae na" href="https://en.wikipedia.org/wiki/JPEG#Decoding" rel="noopener ugc nofollow" target="_blank">维基百科</a>。</p></figure><p id="149d" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">我们可以再次利用Scipy中的DCT函数，这一次将type-III DCT的“Type”参数指定为“3 ”,这是(Type-II) DCT的逆运算。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="2379" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">以下是将量化矩阵相乘并反转DCT后的量化效果示例:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nb"><img src="../Images/01283452cd283395152e73824ac11d1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hXq5aGhk8x4CMKsDLz0VeQ.jpeg"/></div></div></figure><h1 id="fbe3" class="ma mb iq bd mc md me mf mg mh mi mj mk kf ml kg mm ki mn kj mo kl mp km mq mr bi translated">后加工</h1><p id="4f3f" class="pw-post-body-paragraph le lf iq lg b lh ms ka lj lk mt kd lm ln mu lp lq lr mv lt lu lv mw lx ly lz ij bi translated">使用上面的<strong class="lg ja">块分割</strong>部分中的<em class="nt"> ImageBlock </em>类的<em class="nt">向后</em>操作，我们可以将这些压缩的块重新排列成一个图像。我们还需要取消居中，将图像转换回RGB颜色空间，然后将其保存为JPEG文件。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="d32e" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">以下是最终结果:你能看出区别吗？</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nu"><img src="../Images/55a7094e14acee402301278f1387f65e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U3UzHIxWjcux_Ypi-Zxxjg.jpeg"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">当你放大时，蝴蝶上会有一些压缩伪影(黑点)。</p></figure><h1 id="fc2c" class="ma mb iq bd mc md me mf mg mh mi mj mk kf ml kg mm ki mn kj mo kl mp km mq mr bi translated">熵编码</h1><p id="7e36" class="pw-post-body-paragraph le lf iq lg b lh ms ka lj lk mt kd lm ln mu lp lq lr mv lt lu lv mw lx ly lz ij bi translated">简单说说熵编码；这是量化后JPEG的关键部分，其中图像数据以非常紧凑的方式编码，以使文件更小。它不是在我们的图像矩阵中存储每一个值，而是只存储非零条目，并计算它们之间的0的数量。因为我们的矩阵量化后是稀疏的，这是非常高效的。此外，只有位表示而不是实际值被写入文件。用于以比特表示矩阵条目的技术被称为<a class="ae na" href="https://en.wikipedia.org/wiki/Huffman_coding" rel="noopener ugc nofollow" target="_blank">霍夫曼编码</a>，实现起来相当繁琐(完全可以是一篇独立的文章)。我只想重申，这是一种无损压缩，因此在熵编码中不会丢失任何信息。</p><h1 id="7178" class="ma mb iq bd mc md me mf mg mh mi mj mk kf ml kg mm ki mn kj mo kl mp km mq mr bi translated">结论</h1><p id="67c0" class="pw-post-body-paragraph le lf iq lg b lh ms ka lj lk mt kd lm ln mu lp lq lr mv lt lu lv mw lx ly lz ij bi translated">我最终的JPEG图像(使用熵编码)大小略大于1MB，比我们开始时的25MB小了很多。当然，在文件大小和图像质量之间有一个权衡，但是如果你有足够的百万像素，并且你没有放大细节，JPEG文件看起来就很好。同时，由于SD卡现在很便宜，如果有人想要我的照片的真人大小的照片，我想保持最高的质量，我将继续以raw拍摄:)</p><p id="2371" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">一如既往，GitHub 上的全部代码。</p></div></div>    
</body>
</html>