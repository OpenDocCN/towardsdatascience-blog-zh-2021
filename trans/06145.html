<html>
<head>
<title>Take your SQL from Good to Great: Part 3</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让您的SQL从优秀走向卓越:第3部分</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/take-your-sql-from-good-to-great-part-3-687d797d1ede?source=collection_archive---------0-----------------------#2021-06-02">https://towardsdatascience.com/take-your-sql-from-good-to-great-part-3-687d797d1ede?source=collection_archive---------0-----------------------#2021-06-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="dae0" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">加入运动的时间到了</h2></div><p id="cece" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是关于我最看重的SQL“技巧”的4部分系列的第3部分。查看该系列中的其他内容:</p><p id="1fa8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第一部分:<a class="ae lb" rel="noopener" target="_blank" href="/take-your-sql-from-good-to-great-part-1-3ae61539e92a">常用表表达式</a></p><p id="6583" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第二部分:<a class="ae lb" rel="noopener" target="_blank" href="/take-your-sql-from-good-to-great-part-2-cb03b1b7981b">关于那些日子的一切</a></p><p id="e3f8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第3部分:其他连接(你在这里📍)</p><p id="c047" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第四部分:<a class="ae lb" rel="noopener" target="_blank" href="/take-your-sql-from-good-to-great-part-4-99a55fd0e7ff">窗口功能</a></p><p id="0681" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lc">有没有一个被低估的SQL技巧让你与众不同？</em> <a class="ae lb" href="mailto:hello@count.co" rel="noopener ugc nofollow" target="_blank"> <em class="lc">让我知道</em> </a> <em class="lc">！</em></p><h1 id="7983" class="ld le iq bd lf lg lh li lj lk ll lm ln jw lo jx lp jz lq ka lr kc ls kd lt lu bi translated">卑微的加入</h1><p id="850d" class="pw-post-body-paragraph kf kg iq kh b ki lv jr kk kl lw ju kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">联接不是任何人都喜欢的SQL部分。它们不像窗口函数那样华丽，也不像cte那样具有变革性。然而，它们无疑是我们访问和转换关系数据的最强大的工具。</p><p id="c0c7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以在进入我最喜欢的使用连接的方式之前，我想我应该提醒自己为什么我们应该更加关注这个长期被忽视的连接。</p><h2 id="3d58" class="ma le iq bd lf mb mc dn lj md me dp ln ko mf mg lp ks mh mi lr kw mj mk lt ml bi translated">1.优化能力</h2><p id="2b5c" class="pw-post-body-paragraph kf kg iq kh b ki lv jr kk kl lw ju kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">SQL查询不会按照它们被写入(或读取)的顺序运行。事实上，SELECT语句是查询运行时最后完成的步骤之一。</p><p id="a305" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">运行的查询的第一部分是FROM/JOIN子句，这意味着如果我们想提高查询性能(谁不想)，我们应该首先看看我们的老朋友JOIN。</p><figure class="mn mo mp mq gt mr gh gi paragraph-image"><div class="gh gi mm"><img src="../Images/f86ce40a2f7a5c6e6c83e4ad8ec7a7e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1152/format:webp/1*DM6l8zfqL1gv4HxkO8Eq4Q.jpeg"/></div><p class="mu mv gj gh gi mw mx bd b be z dk translated">朱莉娅·埃文斯拍摄的照片。</p></figure><h2 id="31bd" class="ma le iq bd lf mb mc dn lj md me dp ln ko mf mg lp ks mh mi lr kw mj mk lt ml bi translated">2.创造性解决问题</h2><p id="bd66" class="pw-post-body-paragraph kf kg iq kh b ki lv jr kk kl lw ju kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">我欣赏连接的另一个不太技术性的原因是，它们允许我们更有创造性地思考我们的数据分析。它们就像我们的乐高积木上的饰钉，允许我们建造比我们的单个表格数据库本身更大的东西。</p><p id="f43f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这种能力和灵活性是我们今天仍然使用关系数据库的主要原因之一，尽管它们已经有将近50年的历史了。</p><h1 id="e4f0" class="ld le iq bd lf lg lh li lj lk ll lm ln jw lo jx lp jz lq ka lr kc ls kd lt lu bi translated">默认连接</h1><figure class="mn mo mp mq gt mr"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="3553" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">尽管有太多的连接类型可供我们使用，但大多数人都默认使用左连接。这有一些非常合理的理由。我们(在西方世界中)从左向右阅读，从我们提到的第二个表中添加列对我们来说更容易概念化，并且它的计算开销更小。</p><p id="120d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是在有些情况下，将一串左连接链接在一起可能需要更多的工作，并且计算成本超出了您的承受能力。对于这些场景，我们可以看看一些更容易被忽略的连接类型:</p><figure class="mn mo mp mq gt mr gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi na"><img src="../Images/2e22ae35e2248e53b463db2f2582aa06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*av8Om3HpG1MC7YTLKvyftg.png"/></div></div><p class="mu mv gj gh gi mw mx bd b be z dk translated">常见连接类型。图片作者。</p></figure><h1 id="b634" class="ld le iq bd lf lg lh li lj lk ll lm ln jw lo jx lp jz lq ka lr kc ls kd lt lu bi translated">您没有充分使用的JOIN功能</h1><h2 id="15da" class="ma le iq bd lf mb mc dn lj md me dp ln ko mf mg lp ks mh mi lr kw mj mk lt ml bi translated">1.内部联接，而不是过滤掉空值</h2><p id="367e" class="pw-post-body-paragraph kf kg iq kh b ki lv jr kk kl lw ju kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">我经常看到人们做这样的事情:</p><pre class="mn mo mp mq gt nf ng nh ni aw nj bi"><span id="a626" class="ma le iq ng b gy nk nl l nm nn">SELECT ...<br/>FROM X<br/>LEFT JOIN Y<br/>ON X.KEY = Y.KEY<br/>WHERE Y.KEY IS NOT NULL</span></pre><p id="ea7b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这实际上只找到了表X和Y的共同点(也称为内部连接)。)</p><pre class="mn mo mp mq gt nf ng nh ni aw nj bi"><span id="1c31" class="ma le iq ng b gy nk nl l nm nn">SELECT ...<br/>FROM X<br/>INNER JOIN Y<br/>ON X.KEY = Y.KEY</span></pre><p id="33fc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">为什么喜欢:</strong> <em class="lc"> </em>刚刚好。但更具体地说，它更有效，因为你不需要那么多的WHERE语句，它更快更容易键入，也更容易让别人理解。这本身并不是一种黑客行为，而是提醒了一个事实，即内部连接是存在的，它通常可以为您处理大量的过滤工作。</p><p id="6a8f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">举例:</strong></p><p id="4c95" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我想找到Spotify每日播放量最高的10首歌曲，我可以:</p><ol class=""><li id="010e" class="no np iq kh b ki kj kl km ko nq ks nr kw ns la nt nu nv nw bi translated">查找流量最大的10首歌曲</li><li id="28f9" class="no np iq kh b ki nx kl ny ko nz ks oa kw ob la nt nu nv nw bi translated">使用内部连接将其连接回我们的每日流数据:</li></ol><figure class="mn mo mp mq gt mr gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/fe46379b8773ba9fe3e08f11203f00a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1100/format:webp/1*3icdFxAxJvJg_jbYs6rdhw.png"/></div><p class="mu mv gj gh gi mw mx bd b be z dk translated">内部联接示例。(<a class="ae lb" href="https://count.co/n/U4y4XkaeQLx#pSLvVsHNqFy" rel="noopener ugc nofollow" target="_blank">链接</a>)</p></figure><p id="9233" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这个例子中，上面的查询版本(带有top_tracks内部连接daily_streams)在BigQuery中处理27 MB的数据需要<strong class="kh ir"> 0.9 </strong>秒。</p><p id="1c04" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">左连接选项(daily _ streams LEFT JOIN top _ tracks…WHERE…)处理27 MB需要<strong class="kh ir"> 1.9 </strong>秒。</p><p id="a46b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">虽然这两种方法都很快，但是您可以看到它如何扩展到更大的数据。</p><h2 id="8f22" class="ma le iq bd lf mb mc dn lj md me dp ln ko mf mg lp ks mh mi lr kw mj mk lt ml bi translated">2.范围联接</h2><p id="57bd" class="pw-post-body-paragraph kf kg iq kh b ki lv jr kk kl lw ju kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">当我们想到连接时，我们倾向于只想到等式，例如key == key。但是我们经常需要一个更精确的逻辑来将两个表合并在一起。</p><p id="403f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为此，我们可以做一个范围连接，或者是一个不等式的连接。例如:</p><pre class="mn mo mp mq gt nf ng nh ni aw nj bi"><span id="b7d1" class="ma le iq ng b gy nk nl l nm nn">SELECT ...<br/>FROM X<br/>LEFT JOIN Y <br/>ON X.KEY &gt;=Y.RANGE_START AND X.KEY &lt;= Y.RANGE_END</span></pre><p id="928e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">为什么喜欢:</strong> <em class="lc"> </em>当你需要根据一些时间逻辑来联接两个表的时候，这些真的很棒。想想看，当你的用户购买了他们的第一个产品后，试图找到他们做X的实例，或者找到在他们的免费试用窗口内发生的所有行为。如果没有范围连接，所有这些都将是痛苦的，甚至是完全不可能的。</p><p id="18df" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">例如:</strong></p><p id="14f3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们继续我们的Spotify数据，假设我们希望找到热门歌曲的每日流媒体数据，但只针对歌曲发布后30天的数据。</p><figure class="mn mo mp mq gt mr gh gi paragraph-image"><div class="gh gi od"><img src="../Images/23f2de3684903a3575c001ad552c4118.png" data-original-src="https://miro.medium.com/v2/resize:fit:980/format:webp/1*csmRR7cTZve68TTBV2FcrQ.png"/></div><p class="mu mv gj gh gi mw mx bd b be z dk translated">范围联接示例(<a class="ae lb" href="https://count.co/n/U4y4XkaeQLx#P8xT4hByqsG" rel="noopener ugc nofollow" target="_blank">链接</a>)</p></figure><figure class="mn mo mp mq gt mr gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi oe"><img src="../Images/5061728593fece6cdf621e5d518f9222.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zwgeuHeKvnv6TmZvmRbJkA.png"/></div></div><p class="mu mv gj gh gi mw mx bd b be z dk translated">放大SQL</p></figure><p id="968b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这个例子中，你可以看到，我们简单地扩展了我们的第一个例子，在我们的内部连接中增加了一些条件，以确保我们只选择音轨发布后30天内的数据。</p><p id="786f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir"> ℹ️警告:</strong>不是每个SQL方言都支持不等式连接。这对我来说是相当惊人的，但在你开始尝试它并得到一个模糊的错误之前，检查一下仍然是一个好主意。然后切换到新的SQL方言。</p><h2 id="4eb6" class="ma le iq bd lf mb mc dn lj md me dp ln ko mf mg lp ks mh mi lr kw mj mk lt ml bi translated">3.横向连接</h2><p id="c6e6" class="pw-post-body-paragraph kf kg iq kh b ki lv jr kk kl lw ju kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">我参加横向加入派对的时间相对较晚，但我不得不说我喜欢到目前为止我所看到的。我花了一段时间才弄清楚它们到底是什么，但本质上理解横向连接有两个关键:</p><ol class=""><li id="8895" class="no np iq kh b ki kj kl km ko nq ks nr kw ns la nt nu nv nw bi translated">它们允许我们访问FROM语句后面的列。</li><li id="2d9a" class="no np iq kh b ki nx kl ny ko nz ks oa kw ob la nt nu nv nw bi translated">它们的操作类似于FOR EACH运算符，因为它们是针对查询的每一行进行计算的。</li></ol><p id="4f62" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">为什么喜欢:</strong> <em class="lc"> </em>对SQL中的每一个操作做的能力都非常得心应手，尤其是当你需要为你的基表中的每一行生成新行的时候。</p><p id="1a19" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，横向连接允许您在同一个查询中构建自己，从而简化查询逻辑。这种逻辑合并有两个例子<a class="ae lb" href="https://vladmihalcea.com/sql-lateral-join/" rel="noopener ugc nofollow" target="_blank">这里</a>和<a class="ae lb" href="https://popsql.com/learn-sql/postgresql/how-to-use-lateral-joins-in-postgresql#data-set" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><p id="92f6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">举例:</strong></p><p id="8f23" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了与Spotify保持一致，假设我们希望找到Spotify前10名艺术家的前5首歌曲。</p><p id="8e86" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为此，我们可以:</p><ol class=""><li id="7d4f" class="no np iq kh b ki kj kl km ko nq ks nr kw ns la nt nu nv nw bi translated">查找前10名艺术家</li><li id="89a6" class="no np iq kh b ki nx kl ny ko nz ks oa kw ob la nt nu nv nw bi translated">对于每位艺术家，使用横向连接找到他们的前5首曲目:</li></ol><figure class="mn mo mp mq gt mr gh gi paragraph-image"><div class="gh gi of"><img src="../Images/26a8d285aa4fc212eaf341ebf0e3dfa8.png" data-original-src="https://miro.medium.com/v2/resize:fit:984/format:webp/1*QXkkIT9OzgrsPUknD_38Aw.png"/></div><p class="mu mv gj gh gi mw mx bd b be z dk translated">看完整分析<a class="ae lb" href="https://count.co/n/W2O2UEyL4Em" rel="noopener ugc nofollow" target="_blank">这里</a>。</p></figure><figure class="mn mo mp mq gt mr gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi og"><img src="../Images/2f87134a8d9fbbd21f15e22fade68e0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UA57sgdeKVgOIUIr9M0e8w.png"/></div></div><p class="mu mv gj gh gi mw mx bd b be z dk translated">放大SQL</p></figure><p id="e660" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你也可以用一个窗口函数来做这件事，这恰好是本系列的下一个主题！</p><p id="4f5d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir"> ℹ️警告:</strong>不是每个SQL方言都有横向连接的概念。例如，BigQuery通过UNNEST使用隐式横向连接。亲自试用之前，请检查您的工具文档！</p><h1 id="e156" class="ld le iq bd lf lg lh li lj lk ll lm ln jw lo jx lp jz lq ka lr kc ls kd lt lu bi translated">进一步阅读</h1><p id="8ed1" class="pw-post-body-paragraph kf kg iq kh b ki lv jr kk kl lw ju kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">在研究今天的帖子时，我发现以下链接最有帮助:</p><ul class=""><li id="395a" class="no np iq kh b ki kj kl km ko nq ks nr kw ns la oh nu nv nw bi translated"><a class="ae lb" href="https://blog.crunchydata.com/blog/iterators-in-postgresql-with-lateral-joins" rel="noopener ugc nofollow" target="_blank">PostgreSQL中带有横向连接的迭代器</a></li><li id="e6b9" class="no np iq kh b ki nx kl ny ko nz ks oa kw ob la oh nu nv nw bi translated"><a class="ae lb" href="https://ddrscott.github.io/blog/2017/what-the-sql-lateral/#enough-nesting-lateral-join-save-me" rel="noopener ugc nofollow" target="_blank">什么SQL？！？横向连接</a></li><li id="48fd" class="no np iq kh b ki nx kl ny ko nz ks oa kw ob la oh nu nv nw bi translated"><a class="ae lb" href="https://www.vertica.com/blog/what-is-a-range-join-and-why-is-it-so-fastba-p223413/" rel="noopener ugc nofollow" target="_blank">什么是范围连接，为什么速度这么快？</a></li></ul><h1 id="3baf" class="ld le iq bd lf lg lh li lj lk ll lm ln jw lo jx lp jz lq ka lr kc ls kd lt lu bi translated">结束语</h1><p id="84bd" class="pw-post-body-paragraph kf kg iq kh b ki lv jr kk kl lw ju kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">所有使用的例子都是在<a class="ae lb" href="https://count.co" rel="noopener ugc nofollow" target="_blank">count.co</a>中构建的，这是为分析师构建的SQL笔记本。您可以与以下示例互动:</p><div class="oi oj gp gr ok ol"><a href="https://count.co/n/W2O2UEyL4Em" rel="noopener  ugc nofollow" target="_blank"><div class="om ab fo"><div class="on ab oo cl cj op"><h2 class="bd ir gy z fp oq fr fs or fu fw ip bi translated">PostgreSQL中的横向连接</h2><div class="os l"><h3 class="bd b gy z fp oq fr fs or fu fw dk translated">横向连接是一个强大的工具，可以添加到您的SQL武库中。这个笔记本浏览了一个例子。</h3></div><div class="ot l"><p class="bd b dl z fp oq fr fs or fu fw dk translated">count.co</p></div></div></div></a></div><p id="bd91" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">还有这里:</p><div class="oi oj gp gr ok ol"><a href="https://count.co/n/U4y4XkaeQLx" rel="noopener  ugc nofollow" target="_blank"><div class="om ab fo"><div class="on ab oo cl cj op"><h2 class="bd ir gy z fp oq fr fs or fu fw ip bi translated">加入的乐趣</h2><div class="os l"><h3 class="bd b gy z fp oq fr fs or fu fw dk translated">本笔记介绍了《让您的SQL从优秀走向卓越:第3部分》中的一些例子。</h3></div><div class="ot l"><p class="bd b dl z fp oq fr fs or fu fw dk translated">count.co</p></div></div></div></a></div><p id="ae91" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">直到下次我们讨论窗口函数的时候！</p><p id="e36c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lc">有我错过的一些加入SQL的技巧吗？请在评论中告诉我</em>👇</p></div></div>    
</body>
</html>