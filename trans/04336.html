<html>
<head>
<title>A Deeper Dive into Decoration</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">对装饰的深入探究</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/a-deeper-dive-into-decoration-ca4334ca5cf8?source=collection_archive---------45-----------------------#2021-04-12">https://towardsdatascience.com/a-deeper-dive-into-decoration-ca4334ca5cf8?source=collection_archive---------45-----------------------#2021-04-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="582a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何用Python编写灵活的、可重用的装饰器</h2></div><p id="0341" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">作者:<a class="ae le" href="https://www.linkedin.com/in/edkrueger/" rel="noopener ugc nofollow" target="_blank">爱德华·克鲁格</a>和<a class="ae le" href="https://www.linkedin.com/in/dougaf/" rel="noopener ugc nofollow" target="_blank">道格拉斯·富兰克林</a>。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi lf"><img src="../Images/79bc1529376b114de56da7d856fa9643.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0VWFslgG2sUzh_1KqL9bRw.jpeg"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">照片由澳门图片社在Unsplash上拍摄</p></figure><h1 id="3f5c" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">介绍</h1><p id="7d70" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">我们首先介绍一些函数式编程概念的背景知识，并讨论计时和跟踪。</p><p id="5326" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来，我们用两个例子来说明装饰模式及其语法，<code class="fe ms mt mu mv b">tracefunc </code>和<code class="fe ms mt mu mv b">timefunc</code>。为此，我们使用Python库<code class="fe ms mt mu mv b">functools</code>和<code class="fe ms mt mu mv b">time</code>。</p><p id="826f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们转到对<code class="fe ms mt mu mv b">functools.wraps</code>的更深入的讨论，以及它如何保存被修饰函数的元数据。最后，我们用一些例子来说明这种保护。</p><h2 id="33ca" class="mw lw it bd lx mx my dn mb mz na dp mf kr nb nc mh kv nd ne mj kz nf ng ml nh bi translated"><strong class="ak">为什么要跟踪和计时一个函数</strong></h2><p id="4546" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated"><strong class="kk iu">跟踪</strong>是在程序运行时记录函数的输入和输出。有经验的程序员使用跟踪来排除程序故障，通常作为调试器的替代品。这些程序员使用跟踪来识别生产中的问题，并使用跟踪来复制错误。对于正在学习语言的初学者来说，描摹也是极好的。</p><p id="9319" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">计时</strong>更直接。更快的功能是更好的功能。</p><blockquote class="ni"><p id="a14e" class="nj nk it bd nl nm nn no np nq nr ld dk translated">时间就是金钱，朋友。—加斯洛维</p></blockquote><p id="15c9" class="pw-post-body-paragraph ki kj it kk b kl ns ju kn ko nt jx kq kr nu kt ku kv nv kx ky kz nw lb lc ld im bi translated">为了用Python编写装饰函数，我们依赖于<code class="fe ms mt mu mv b">functools </code>和范围意识。我们来回顾一下范围和装饰。</p><h2 id="cd11" class="mw lw it bd lx mx my dn mb mz na dp mf kr nb nc mh kv nd ne mj kz nf ng ml nh bi translated">装饰、关闭和范围</h2><p id="c7db" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">修饰是Python中的一种设计模式，允许您修改函数的行为。装饰器是一个函数，它接受一个函数并返回一个函数的修改副本。</p><p id="2ca7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当编写闭包和装饰器时，必须记住每个函数的作用域。函数在Python中定义范围。闭包可以访问返回它们的函数的范围；装饰者的范围。</p><p id="cff2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有关这些概念的更多背景知识，请查看这篇3分钟的文章。</p><div class="nx ny gp gr nz oa"><a rel="noopener follow" target="_blank" href="/decorators-and-closures-by-example-in-python-382758321164"><div class="ob ab fo"><div class="oc ab od cl cj oe"><h2 class="bd iu gy z fp of fr fs og fu fw is bi translated">Python中的装饰器和闭包示例</h2><div class="oh l"><h3 class="bd b gy z fp of fr fs og fu fw dk translated">如何使用装饰器增强函数的行为</h3></div><div class="oi l"><p class="bd b dl z fp of fr fs og fu fw dk translated">towardsdatascience.com</p></div></div><div class="oj l"><div class="ok l ol om on oj oo lp oa"/></div></div></a></div><h1 id="15d9" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">跟踪装饰者:@tracefunc</h1><p id="07f9" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">让我们用跟踪装饰器来说明<code class="fe ms mt mu mv b">functools.wraps</code>的重要性。</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="op oq l"/></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">tracer.py</p></figure><p id="0023" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Functools在第11行变得很重要，在这里我们访问<code class="fe ms mt mu mv b">func.__name__</code>来打印一个跟踪。如果我们没有在第7行传递<code class="fe ms mt mu mv b">func</code>到<code class="fe ms mt mu mv b">functools.wraps</code>，当我们使用多个装饰器时，这个print语句可能会返回错误的<code class="fe ms mt mu mv b">func.__name__</code>。返回错误的元数据会导致跟踪器无效。</p><h2 id="b08e" class="mw lw it bd lx mx my dn mb mz na dp mf kr nb nc mh kv nd ne mj kz nf ng ml nh bi translated">functools.wraps对装饰者的重要性</h2><p id="7dd0" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">随着我们的代码变得越来越复杂，<code class="fe ms mt mu mv b">functools.wraps</code>对于保持我们的装饰器按预期工作变得越来越重要。让我们更深入地了解一下这个工具。</p><p id="3916" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">装饰器<code class="fe ms mt mu mv b">@functools.wraps</code>(见上面第7行)是一个方便的函数，用于在定义包装函数时调用<code class="fe ms mt mu mv b">update_wrapper</code>作为函数装饰器。<code class="fe ms mt mu mv b">update_wrapper</code>的目的是更新<em class="or">包装器</em>功能，使其看起来像<em class="or">包装的</em>功能。这就是我们如何通过装饰管道传递函数的元数据。</p><p id="b7f6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">文档说得很好:</p><blockquote class="os ot ou"><p id="e286" class="ki kj or kk b kl km ju kn ko kp jx kq ov ks kt ku ow kw kx ky ox la lb lc ld im bi translated">这个函数的主要用途是在<a class="ae le" href="https://docs.python.org/3/glossary.html#term-decorator" rel="noopener ugc nofollow" target="_blank">装饰器</a>函数中，它包装被装饰的函数并返回包装器。如果包装函数没有更新，返回函数的元数据将反映包装定义，而不是原始函数定义，这通常没有什么帮助。<br/> — <a class="ae le" href="https://docs.python.org/3/library/functools.html" rel="noopener ugc nofollow" target="_blank"> Python文档</a></p></blockquote><p id="0200" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">换句话说，如果不使用这个装饰器工厂，原始装饰函数的元数据将会丢失。这将使我们的<code class="fe ms mt mu mv b">tracefunc</code>返回包装器的踪迹，而不是被修饰的函数。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi lf"><img src="../Images/4cd6d961389b6f733ae9d7b4aa27043c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VFUmp26dFSb-XD07_WhyMw.jpeg"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">彼得·海因西乌斯在Unsplash上的照片</p></figure><h2 id="7f2c" class="mw lw it bd lx mx my dn mb mz na dp mf kr nb nc mh kv nd ne mj kz nf ng ml nh bi translated">这个装饰器的可重用性</h2><p id="0aac" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">注意<code class="fe ms mt mu mv b">func</code>被作为第4行的参数。然后在第8行，我们通过<code class="fe ms mt mu mv b">*args, **kwargs</code>，进入我们的闭包。这些<code class="fe ms mt mu mv b">*args, **kwargs</code>用于计算第10行<code class="fe ms mt mu mv b">func(*args, **kwargs)</code>的<code class="fe ms mt mu mv b">result</code>。</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="op oq l"/></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">再次使用tracer.py来保存滚动</p></figure><p id="c5e8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe ms mt mu mv b">*args</code>和<code class="fe ms mt mu mv b">**kwargs</code>的灵活性使得<code class="fe ms mt mu mv b">tracefunc</code>几乎可以处理任何功能。我们闭包的print语句是为了访问函数的<code class="fe ms mt mu mv b">__name__</code>、<code class="fe ms mt mu mv b">args</code>、<code class="fe ms mt mu mv b">kwargs</code>和<code class="fe ms mt mu mv b">result</code>来为<strong class="kk iu"> </strong> <code class="fe ms mt mu mv b">func</code>创建一个<strong class="kk iu">跟踪</strong>。</p><p id="046d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在编写自己的装饰器时，请记住这种灵活性。</p><h2 id="3b96" class="mw lw it bd lx mx my dn mb mz na dp mf kr nb nc mh kv nd ne mj kz nf ng ml nh bi translated">应用@tracefunc</h2><p id="953e" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">这是我们的追踪器在一个函数上的应用。我们在我们希望修饰的函数定义上方应用带有@符号的装饰器。</p><p id="e1d8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个例子很简单，但重点是<code class="fe ms mt mu mv b">tracefunc</code>对任何函数都有效。</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="op oq l"/></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">traced_func.py</p></figure><p id="5c0c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们看到<code class="fe ms mt mu mv b">args </code>和<code class="fe ms mt mu mv b">kwargs </code>在打印语句中各自的位置。函数的返回值跟随粗箭头；在这三种情况下，Python的默认结果是“无”</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi oy"><img src="../Images/2a568766dcd97f3253d5abce5d8b273e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1SE7k7JyPtbAqyvT7qYNtw.png"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated"><code class="fe ms mt mu mv b">Output of func.__name__ ,*args, **kwargs =&gt; result</code></p></figure><p id="71ad" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">该跟踪向我们显示了传递给函数的正确的函数名、args和/或kwargs，以及该函数的结果。将这个装饰器应用到一个函数中，可以让用户更清楚地看到函数执行时发生了什么。</p><p id="1a83" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在让我们讨论一下我们的时序装饰器。</p><h1 id="d11c" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">计时装饰:@timefunc</h1><p id="e1ad" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">这个装饰器看起来和<code class="fe ms mt mu mv b">tracefunc</code>非常相似，拥有相同的可重用/灵活的结构。注意<code class="fe ms mt mu mv b">functool.wraps</code>的位置。同样，它也是我们闭包的装饰者。回想一下，这是保存我们的<code class="fe ms mt mu mv b">func</code>的元数据，以便在我们的print语句中返回正确的名称。</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="op oq l"/></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">timer.py</p></figure><p id="cf0f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个装饰器返回传递给<code class="fe ms mt mu mv b">timefunc</code>的关于<code class="fe ms mt mu mv b">func </code>的信息。在第13行，<code class="fe ms mt mu mv b">start </code>启动计时。然后，第14行的<code class="fe ms mt mu mv b">result </code>存储<code class="fe ms mt mu mv b">func(*args, **kwargs).</code>的值，在此之后，在print语句报告函数执行所花费的时间之前<code class="fe ms mt mu mv b">time_elapsed</code>被计算。请注意，函数的结果被返回，但用户看不到。</p><h2 id="83a9" class="mw lw it bd lx mx my dn mb mz na dp mf kr nb nc mh kv nd ne mj kz nf ng ml nh bi translated">应用@timefunc</h2><p id="246e" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">我们再一次用<code class="fe ms mt mu mv b">@</code>符号来应用这个装饰器。</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="op oq l"/></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">用@timefunc装饰函数</p></figure><p id="e5ef" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当在第13行调用single_thread时，我们看到了<code class="fe ms mt mu mv b">func.__name__ </code>和它执行所用的时间。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi oz"><img src="../Images/e5666f6d44e2b145ac3c559205191dc8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IWXblR3EdFn6tYwBtvojXg.png"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">timefunc修饰的single_thread的输出</p></figure><h1 id="4d6a" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">同时计时和追踪</h1><p id="2c01" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">假设您想要查看一个函数的轨迹和执行时间。现在我们有了两个写得很好的装修工，就好办了！</p><p id="272c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们所要做的就是将两个装饰器都应用到正在讨论的函数中。</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="op oq l"/></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">装饰_管道. py</p></figure><p id="d45b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在计时器之前应用跟踪器可以确保我们不会将跟踪器的打印语句执行添加到我们正在记录的运行时中。</p><p id="19d1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在我们看到了这个函数的执行时间和轨迹。注意，在这种情况下，我们返回的是一个列表列表。这样的信息对于调试脚本是非常宝贵的！</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi pa"><img src="../Images/c82bb02b0c4729093c427a348f99887b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Bi_0prkNFqPSE7SMXOJK_Q.png"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">deco_pipe.py输出</p></figure><p id="20a9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们还看到了运行时，它对于优化函数和选择最佳代码非常有用。</p><h1 id="6048" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">结论</h1><p id="45a2" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">我们已经深入了解了decorators以及如何用Python对它们进行编码。装饰者返回一个闭包。闭包是装饰器返回的东西。</p><p id="d709" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们使用<code class="fe ms mt mu mv b">functools.wraps</code>通过装饰器的闭包来保存被装饰的<code class="fe ms mt mu mv b">func</code>的元数据。从而允许我们在decorators的print语句中返回func的名称。这变得越来越重要，我们通过多个装饰器传递函数。</p><p id="46ad" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Timefunc和Tracefunc有相似的代码模式，但用例不同。我们可以使用这些装饰器来分别或协同计时和跟踪函数。这些装饰器为我们提供了一个优雅的、可重用的模式来跟踪函数运行时和行为。</p></div></div>    
</body>
</html>