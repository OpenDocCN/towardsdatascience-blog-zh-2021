<html>
<head>
<title>Writing TensorFlow code that scales</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">编写可伸缩的张量流代码</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/writing-tensorflow-code-that-scales-c0c93aa3736d?source=collection_archive---------22-----------------------#2021-10-03">https://towardsdatascience.com/writing-tensorflow-code-that-scales-c0c93aa3736d?source=collection_archive---------22-----------------------#2021-10-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="30a2" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">添加两行代码来增强您的脚本</h2></div><p id="e38c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">大多数时候，我们在本地编写和调试代码。通过任何测试后，我们将脚本部署到远程环境中。如果幸运的话，我们可能可以访问多个GPU。这种转变曾经是错误的来源，但是对复杂计算设置的支持已经显著增加。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi le"><img src="../Images/d6da96b64fcdec927cb27e8121c2da58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*oz26VK9t00-bk8zW"/></div></div><p class="lq lr gj gh gi ls lt bd b be z dk translated">杰里米·贝赞格在<a class="ae lu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="0921" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您主要使用Keras的<em class="lv"> model.fit() </em>调用，那么您可以通过添加两行代码来快速地让您的脚本分发知晓。</p><h1 id="dff2" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">在分配工作负载之前</h1><p id="764f" class="pw-post-body-paragraph ki kj it kk b kl mo ju kn ko mp jx kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">最初，我们的代码可能是这样的:</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="mt mu l"/></div></figure><h1 id="95e9" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">分配工作负载后</h1><p id="8c90" class="pw-post-body-paragraph ki kj it kk b kl mo ju kn ko mp jx kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">为了让代码准备好发布，我们必须修改第1行到第4行。为此，我们创建了一个<em class="lv">策略</em>对象，这是TensorFlow处理计算环境的方式。然后，我们使用它来包装我们的代码，如下面的代码片段所示:</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="9ab0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在<strong class="kk iu">我们添加的第一行</strong>，第一行，我们设置了我们的策略对象。在示例中，我们使用了一个<em class="lv"> MirroredStrategy </em>，它告诉TensorFlow在一台机器上的多个计算设备上复制模型。对于其他环境，我们可以选择不同的策略，如文档中列出的<a class="ae lu" href="https://www.tensorflow.org/guide/distributed_training#types_of_strategies" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="115a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">除了我们将模型和优化器创建例程包装在所选的<em class="lv">策略</em>对象的范围内之外，其余代码基本相同。这是<strong class="kk iu">我们添加的第二行代码</strong>并且是必要的修改:<em class="lv">作用域</em>修改变量是如何创建的以及在哪里放置它们。</p><p id="78e3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">之后，我们可以照常进行，调用<em class="lv"> model.fit() </em>。然后，工作量会自动分配。我们在这里什么都不用做，因为TensorFlow在内部处理所有事情，这非常舒服！这也是一个巨大的进步:仅仅几年前，研究人员和从业者还必须自己编写分发算法。</p><p id="b371" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，必须一直手动实例化<em class="lv">策略</em>对象是令人厌烦的。然而，我们可以用下面的代码自动创建正确的对象，我通常喜欢把它放在一个单独的<em class="lv"> utils.py </em>文件中:</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="53ed" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这段代码<a class="ae lu" href="https://github.com/huggingface/transformers/blob/1c06240e1b3477728129bb58e7b6c7734bb5074e/src/transformers/training_args_tf.py#L191" rel="noopener ugc nofollow" target="_blank">取自Hugginface的存储库</a>，在创建分发策略之前检查计算环境。根据设置，返回的<em class="lv">策略</em>对象处理TPU、GPU以及混合精度训练。</p><p id="9009" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您使用这种方法，那么您只需更改这一行:</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="mt mu l"/></div></figure><h1 id="a3c9" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">摘要</h1><p id="b7d7" class="pw-post-body-paragraph ki kj it kk b kl mo ju kn ko mp jx kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">这就是你要在代码中修改的全部内容。总而言之，你</p><ul class=""><li id="353e" class="mv mw it kk b kl km ko kp kr mx kv my kz mz ld na nb nc nd bi translated">制定分销策略</li><li id="db52" class="mv mw it kk b kl ne ko nf kr ng kv nh kz ni ld na nb nc nd bi translated">将所有变量创建例程都包含在策略范围内</li><li id="f6dd" class="mv mw it kk b kl ne ko nf kr ng kv nh kz ni ld na nb nc nd bi translated">像平常一样调用model.fit()</li></ul><p id="102a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这些步骤涵盖了使用Keras的高级API进行任何计算的情况。但是，如果您正在使用自定义训练循环，则需要注意更多事项。在这种情况下，<a class="ae lu" rel="noopener" target="_blank" href="/a-template-for-custom-and-distributed-training-c24e17bd5d8d">我这里有你罩着</a>。</p></div></div>    
</body>
</html>