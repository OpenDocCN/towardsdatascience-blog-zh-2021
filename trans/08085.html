<html>
<head>
<title>RETURN Clauses in Natural Language Queries</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">自然语言查询中的返回子句</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/return-clauses-in-natural-language-queries-74a4a2fd53e6?source=collection_archive---------26-----------------------#2021-07-24">https://towardsdatascience.com/return-clauses-in-natural-language-queries-74a4a2fd53e6?source=collection_archive---------26-----------------------#2021-07-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ef97" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">将openCypher的元素整合到FEQL (FactEngine查询语言)中</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/35260f354400d887164cd0f34f96a67c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TwrccbFeM2xmreqir6bzeQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">包含RETURN子句的FEQL查询。图片作者。</p></figure><p id="791e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">FactEngine是一个从根本上重新思考如何从概念上定义、查看和查询数据库的计划。重点是利用<a class="ae lu" rel="noopener" target="_blank" href="/why-learn-object-role-modelling-4eebd93dcda2">对象-角色建模</a>主干在知识图上提供自然语言查询。典型的FactEngine查询如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lv"><img src="../Images/4ee89b39ae4b16dd8e18668db98643c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iNyLtXyO6HVLvj34r-IaEg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">典型的事实引擎查询。图片作者。</p></figure><p id="77c1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了实现查询编写的相对简单性，<a class="ae lu" rel="noopener" target="_blank" href="/the-factengine-architecture-6d90ac09b8b8"> FactEngine架构</a>首先要求数据库模式(或者是图形，或者是物理层的关系)被定义为对象-角色模型。</p><p id="fe55" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了证明这一点，我通常会查看一个影院预订数据库的概念模型:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lw"><img src="../Images/afebd96de48462ea3d6c4c351098ef22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B4yAHHbT7OwoXYBmYUhuXQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">点击放大。ORM图表示例。电影院预订模式。图片作者。</p></figure><p id="8ca7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在<a class="ae lu" rel="noopener" target="_blank" href="/what-is-a-graph-database-249cd7fdf24d">的一篇早期文章</a>中，我描述了同一个模式如何被视为一个图表或关系模式，对于外行来说，这看起来像是意大利面条出错了:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lx"><img src="../Images/5cb2858fed99391b35f1dbbf6c679f57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*59ShSvdDsUmWJicv9dx4PQ.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">属性图和实体关系图之间的态射。图片作者。</p></figure><p id="62b5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">论文的关键在于，当使用对象-角色模型覆盖时，关系数据库可以像图形数据库一样用自然语言查询；这是通过尊重图形和关系数据库之间的形态来实现的。</p><h2 id="6fed" class="ly lz it bd ma mb mc dn md me mf dp mg lh mh mi mj ll mk ml mm lp mn mo mp mq bi translated">但是有一个小问题</h2><p id="f57b" class="pw-post-body-paragraph ky kz it la b lb mr ju ld le ms jx lg lh mt lj lk ll mu ln lo lp mv lr ls lt im bi translated">自然语言查询是理想化的，但是处理自然语言查询的软件可能非常难以编写，有时需要使用机器学习的黑魔法式编程来解释自然语言。</p><p id="62a3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">机器学习类型安排的问题是，它们没有覆盖超出其训练范围的大量可感知的用例，并且需要就如何处理它们覆盖的用例进行训练。</p><p id="3336" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">相比之下，像SQL和openCypher这样的数据库查询语言，它们的语法可以清晰地表达几乎任何您想对数据库提出的查询。</p><p id="b421" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在我看来，需要使用机器学习来处理自然语言查询是不对的，所以FactEngine没有使用任何机器学习，只是一种受控的自然语言，凭借模式本身来适应所研究的模式。在这种程度上，查询语言更接近于新兴的图形查询语言标准。</p><h2 id="2c86" class="ly lz it bd ma mb mc dn md me mf dp mg lh mh mi mj ll mk ml mm lp mn mo mp mq bi translated">FEQL(事实引擎查询语言)中的返回类型查询</h2><p id="d7ee" class="pw-post-body-paragraph ky kz it la b lb mr ju ld le ms jx lg lh mt lj lk ll mu ln lo lp mv lr ls lt im bi translated">作为所面临问题的一个例子，最明显的莫过于对我们的影院预订模式提出以下问题:</p><blockquote class="mw mx my"><p id="ead4" class="ky kz mz la b lb lc ju ld le lf jx lg na li lj lk nb lm ln lo nc lq lr ls lt im bi translated">"每个电影院的每个区域有多少个座位？"</p></blockquote><p id="ab46" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">所有形式的机器学习和复杂的试探法都需要将该查询转换为对我们的影院预订模式的机器可解释的查询。</p><p id="9a9e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">FactEngine摒弃了令人费解的试探法，而是提供了一种受控的自然语言。</p><p id="57fb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了获得这个示例的结果，FactEngine借鉴了新兴的图形查询标准，将RETURN子句放在查询的自然语言部分下面…首先询问每个电影院的每个区域有哪些座位，然后返回所需的信息和数量，如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/35260f354400d887164cd0f34f96a67c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TwrccbFeM2xmreqir6bzeQ.png"/></div></div></figure><p id="d8af" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这感觉有点像作弊，将SQL和标准化图形查询语言的元素合并到基于自然语言的查询语言中，但这足够直观，对于熟悉SQL和一般图形查询语言的人来说会很自然。</p><h2 id="eb37" class="ly lz it bd ma mb mc dn md me mf dp mg lh mh mi mj ll mk ml mm lp mn mo mp mq bi translated">两全其美</h2><p id="05b2" class="pw-post-body-paragraph ky kz it la b lb mr ju ld le ms jx lg lh mt lj lk ll mu ln lo lp mv lr ls lt im bi translated">为什么要对数据库进行自然语言查询？嗯，因为我甚至不能用Cypher、<a class="ae lu" href="https://opencypher.org/" rel="noopener ugc nofollow" target="_blank"> openCypher </a>或<a class="ae lu" href="https://www.gqlstandards.org/" rel="noopener ugc nofollow" target="_blank"> GQL </a>编写上面的查询……我懒得学习语法。受控自然语言查询非常容易编写和理解，以至于用自然语言编写的图形查询的好处远远超过了编程工作，最终结果是易于使用和理解……依我看。</p><p id="9cd6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在我看来，到目前为止，在数据库上引入自然语言查询的努力是如此复杂和做作，以至于它们似乎永远也不会推向市场，也不会迷失在研究的好奇世界中。我更希望有一门容易理解和实际可用的语言，而不是沉溺于假设和可能的世界。虽然我为研究努力喝彩，但我最深切的感受是，需要有一个分界点，在这里你可以说，“已经够了。我们可以尝试解决世界上的所有问题，或者用一种不那么理想化的方法，推出一些在现实世界中实际可用的东西”。</p><p id="0e13" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，FEQL现在包含了一个RETURN子句，非常像您所熟悉的图形查询语言，同时尽可能地保留了自然语言查询的理想主义。"每个电影院的每个区域有多少个座位？"可以等到机器学习的努力赶上来。</p><p id="e489" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">感谢阅读。如果时间允许，我会写更多关于自然语言查询、对象-角色建模、图形查询和概念建模的文章。</p><p id="c42e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">【https://github.com/cjheath/activefacts】NB本文中表达的模型是DataConstellation的原始版权的衍生，正如之前在GitHub上的ActiveFacts项目下分享的:<a class="ae lu" href="https://github.com/cjheath/activefacts" rel="noopener ugc nofollow" target="_blank">T7】</a></p><p id="0c9e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">— — — — — —结束— — —</p></div></div>    
</body>
</html>