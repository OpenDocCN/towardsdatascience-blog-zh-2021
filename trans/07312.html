<html>
<head>
<title>Using For Loops in Python: Calculating Probabilities</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Python中使用For循环:计算概率</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/using-for-loops-in-python-calculating-probabilities-3960d8bcb06b?source=collection_archive---------9-----------------------#2021-07-03">https://towardsdatascience.com/using-for-loops-in-python-calculating-probabilities-3960d8bcb06b?source=collection_archive---------9-----------------------#2021-07-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="707c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">为什么循环对于构建完整的统计模型是不可或缺的</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/8405f0d471ab790518635db93239c021.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4Ilp8_Ltpuk1PYgYyETWbA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来源:照片由<a class="ae ky" href="https://pixabay.com/users/stevepb-282134/" rel="noopener ugc nofollow" target="_blank"> stevepb </a>从<a class="ae ky" href="https://pixabay.com/photos/pasta-spaghetti-noodles-pasta-nests-503952/" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>拍摄</p></figure><p id="356e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">循环是学习如何用Python编码的一个非常重要的部分，尤其是在实现大量数字的计算时。</p><p id="55cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于统计学家和数据科学家来说，最常见的诱惑是跳过编码中更平凡的方面——我们假设软件工程师可以简单地以适当的方式重新格式化代码。</p><p id="b033" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，在许多情况下，编写代码的人需要理解模型背后的统计数据以及如何通过循环迭代模型输出——这两个过程根本不能独立开发。</p><p id="e22f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里有一个例子，说明在Python中对循环使用<strong class="lb iu">可以极大地增强统计分析。</strong></p><h1 id="b18c" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">累积二项式概率的背景</h1><p id="d833" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在进行概率分析时，考虑事件发生几率的两个变量是<strong class="lb iu"> N </strong>(观察次数)和<strong class="lb iu">λ</strong>(λ——我们的命中率/在单个间隔内发生的几率)。当我们谈论累积二项式概率分布时，我们的意思是说试验次数越多，事件发生的总体概率越高。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="8384" class="mx lw it mt b gy my mz l na nb">probability = 1 — ((1 — λ)^N)</span></pre><p id="4e9c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，在公平骰子上掷出数字6的几率是1/6。然而，假设同一骰子滚动10次:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="851a" class="mx lw it mt b gy my mz l na nb">1 — ((1–0.1667)^10) = 0.8385</span></pre><p id="62a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们看到掷出数字6的概率现在增加到83.85%。</p><p id="6c00" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">基于大数定律，试验次数越大；事件发生的概率越大，即使单次试验中的概率非常低。因此，让我们生成一个累积二项式概率，来演示在试验次数增加的情况下概率是如何增加的。</p><h1 id="9aac" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">无循环模型</h1><p id="b350" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">这是一个不使用循环计算累积二项式概率的脚本。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="cb3a" class="mx lw it mt b gy my mz l na nb">import numpy as np<br/>import pandas as pd</span><span id="dbc0" class="mx lw it mt b gy nc mz l na nb">l = 0.02<br/>m = 0.04<br/>n = 0.06</span><span id="4093" class="mx lw it mt b gy nc mz l na nb">p=np.arange(0, 100, 1)</span><span id="4ae3" class="mx lw it mt b gy nc mz l na nb">h = 1 - l<br/>j = 1 - m<br/>k = 1 - n</span><span id="32e3" class="mx lw it mt b gy nc mz l na nb">q = 1-(h**p)<br/>r = 1-(j**p)<br/>s = 1-(k**p)</span></pre><ul class=""><li id="dbc3" class="nd ne it lb b lc ld lf lg li nf lm ng lq nh lu ni nj nk nl bi translated"><strong class="lb iu"> l </strong>、<strong class="lb iu"> m </strong>、<strong class="lb iu"> n </strong>代表三个个体概率。</li><li id="67dc" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated"><strong class="lb iu"> p </strong>代表试验次数(最多100次)</li><li id="8842" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated"><strong class="lb iu"> q </strong>、<strong class="lb iu"> r </strong>和<strong class="lb iu"> s </strong>代表累积二项式概率，即试验次数每增加一个单位，概率增加</li></ul><p id="0e0b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是生成的输出示例:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="fe74" class="mx lw it mt b gy my mz l na nb">&gt;&gt;&gt; q</span><span id="c36f" class="mx lw it mt b gy nc mz l na nb">array([0., 0.02, 0.0396, 0.058808, 0.07763184, 0.0960792, 0.11415762, 0.13187447, 0.14923698, 0.16625224, ..., 0.8532841, 0.85621842, 0.85909405, 0.86191217, 0.86467392])</span><span id="eed5" class="mx lw it mt b gy nc mz l na nb">&gt;&gt;&gt; r</span><span id="50bc" class="mx lw it mt b gy nc mz l na nb">array([0., 0.04, 0.0784, 0.115264, 0.15065344, 0.1846273, 0.21724221, 0.24855252, 0.27861042, 0.307466, ..., 0.97930968, 0.9801373, 0.9809318, 0.98169453, 0.98242675])</span><span id="3609" class="mx lw it mt b gy nc mz l na nb">&gt;&gt;&gt; s</span><span id="66cb" class="mx lw it mt b gy nc mz l na nb">array([0., 0.06, 0.1164, 0.169416, 0.21925104, 0.26609598, 0.31013022, 0.35152241, 0.39043106, 0.4270052, 0.46138489, 0.49370179, 0.52407969, 0.5526349, 0.57947681, ..., 0.99720008, 0.99736807, 0.99752599, 0.99767443, 0.99781396])</span></pre><p id="71a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们看到，对于概率<strong class="lb iu"> q </strong>、<strong class="lb iu"> r </strong>和<strong class="lb iu"> s </strong>，对于给定数量的试验，累积概率以不同的速率增加。</p><p id="e207" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">也就是说，在不使用循环的情况下开发这个模型有一个关键的缺点，即个体概率只能采用最终用户指定的值。如果我们希望从0.01连续迭代到0.99呢？</p><h1 id="9757" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">循环模型:列表理解和2D数组</h1><p id="24d5" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">这一次，将通过使用一个单独的概率变量来构建模型，该变量迭代值<strong class="lb iu"> 0.01 </strong>到<strong class="lb iu"> 0.99 </strong>，并且将使用100次试验来计算累积二项式概率。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="299e" class="mx lw it mt b gy my mz l na nb">import numpy as np<br/>import pandas as pd<br/></span><span id="4a0f" class="mx lw it mt b gy nc mz l na nb"># List comprehension<br/>probability=[x*0.01 for x in range(1,100)]<br/>probability=np.array(probability)<br/>probability</span><span id="9771" class="mx lw it mt b gy nc mz l na nb">h = 1 - probability<br/>h</span><span id="950c" class="mx lw it mt b gy nc mz l na nb"># Construct 2D array<br/>result = 1-h[:, np.newaxis] ** np.arange(1,100)<br/>result</span></pre><p id="e95a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">生成的概率变量的输出如下:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="d4d5" class="mx lw it mt b gy my mz l na nb">&gt;&gt;&gt; probability</span><span id="8ad1" class="mx lw it mt b gy nc mz l na nb">array([0.01, 0.02, 0.03, 0.04, 0.05, 0.06, 0.07, 0.08, 0.09, 0.1, ... 0.96, 0.97, 0.98, 0.99])</span></pre><p id="223c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，对于<strong class="lb iu">概率</strong>变量，有必要使用<strong class="lb iu">列表理解。</strong>这是因为Python的<strong class="lb iu"> range() </strong>函数只能处理整数，不能处理浮点值。更多信息见下面的<a class="ae ky" href="https://stackoverflow.com/questions/477486/how-to-use-a-decimal-range-step-value" rel="noopener ugc nofollow" target="_blank">堆栈溢出指南</a>。</p><p id="21a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当查看代码的最后两行时，您会注意到构建了一个2D数组来计算累积二项式概率。当最初尝试计算这些值而不是使用2D数组时，数组已被计算出来，但值并没有按预期的顺序排列。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="c7f3" class="mx lw it mt b gy my mz l na nb">&gt;&gt;&gt; for i in range(1,100,1):<br/>&gt;&gt;&gt;     print(1-(h**i))</span><span id="dfb9" class="mx lw it mt b gy nc mz l na nb">[0.01 0.02]<!-- --> <br/>[0.0199 0.0396]<br/>...<br/>[0.62653572 0.86191217]<br/>[0.63027036 0.86467392]</span></pre><p id="89b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">相反，我们希望数组的顺序为<strong class="lb iu"> [0.01，0.0199，…，0.62653572，0.63027036] </strong>和<strong class="lb iu"> [0.02，0.0396，…，0.86191217，0.86467392] </strong>。</p><p id="6b95" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如下面的<a class="ae ky" href="https://www.reddit.com/r/learnpython/comments/oczprm/unable_to_transpose_the_following_array/" rel="noopener ugc nofollow" target="_blank"> Reddit线程</a>中所解释的，转置上面的不会有任何用处，因为<strong class="lb iu"> h </strong>是一维数组。</p><p id="4107" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一种方法是计算2D数组，然后直接打印出来:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="1b27" class="mx lw it mt b gy my mz l na nb">&gt;&gt;&gt; result = 1-h[:, np.newaxis] ** np.arange(1,100)<br/>&gt;&gt;&gt; result</span><span id="b3f4" class="mx lw it mt b gy nc mz l na nb">array([[0.01, 0.0199, 0.029701, ..., 0.62653572, 0.63027036], </span><span id="3491" class="mx lw it mt b gy nc mz l na nb">[0.02, 0.0396, 0.058808, ..., 0.86191217, 0.86467392], </span><span id="2f2f" class="mx lw it mt b gy nc mz l na nb">[0.03, 0.0591, 0.087327, ..., 0.94946061, 0.9509768], ..., </span><span id="2a83" class="mx lw it mt b gy nc mz l na nb">[0.97, 0.9991, 0.999973, ..., 1., 1., 1.], </span><span id="0e20" class="mx lw it mt b gy nc mz l na nb">[0.98, 0.9996, 0.999992, ..., 1., 1., 1.], </span><span id="92b0" class="mx lw it mt b gy nc mz l na nb">[0.99, 0.9999, 0.999999, ..., 1., 1.,1.]])</span></pre><p id="57f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从上面可以看出，计算了从<strong class="lb iu"> 0.01 </strong>到<strong class="lb iu"> 0.99 </strong>的累积二项式概率。</p><p id="08b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以这种方式对循环使用<strong class="lb iu">允许我们自动从0.01迭代到0.99——试图手动这样做太麻烦且容易出错。</strong></p><h1 id="0ea2" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">结论</h1><p id="d466" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在本例中，您看到了如何:</p><ul class=""><li id="b234" class="nd ne it lb b lc ld lf lg li nf lm ng lq nh lu ni nj nk nl bi translated">用Python计算累积二项式概率</li><li id="ee68" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">使用<strong class="lb iu"> for </strong>循环遍历大范围的值</li><li id="5ecf" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">使用<strong class="lb iu">列表理解</strong>处理一系列浮点值</li><li id="776d" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">当无法转置1D数组中包含的值时，设计2D数组</li></ul><p id="e911" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">非常感谢您的宝贵时间，非常感谢您的任何问题或反馈。</p><p id="a306" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nr">免责声明:本文是在“原样”的基础上编写的，没有任何担保。它旨在提供数据科学概念的概述，不应被解释为专业建议。本文中的发现和解释是作者的发现和解释，不被本文中提到的任何第三方认可或隶属于任何第三方。</em></p></div></div>    
</body>
</html>