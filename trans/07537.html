<html>
<head>
<title>How to Parameterize Python Tests Using Pytest</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用Pytest参数化Python测试</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-parameterize-python-tests-using-pytest-e8800bf288c5?source=collection_archive---------2-----------------------#2021-07-10">https://towardsdatascience.com/how-to-parameterize-python-tests-using-pytest-e8800bf288c5?source=collection_archive---------2-----------------------#2021-07-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="941b" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">向夹具和测试函数传递参数</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/d44097bdff9abb81ed3bf335661a4112.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*TvrZCH0qmXWq-Hlm"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Joshua Lawrence 在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="c628" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">给不耐烦的人:</strong></p><ol class=""><li id="05fb" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated"><a class="ae kv" href="#6a5b" rel="noopener ugc nofollow">如何对Pytest夹具进行参数化</a></li><li id="6563" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><a class="ae kv" href="#803a" rel="noopener ugc nofollow">如何使用Pytest对测试函数进行参数化</a></li></ol></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="e2dc" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">介绍</h1><p id="a288" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">软件开发的一个固有挑战是随着功能和范围的增长，保持对代码库的控制。一个软件变得越复杂，这种复杂性失控的威胁就越大。</p><p id="7e5f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">自动化测试套件可以帮助开发人员处理这种复杂性。随着代码库的增长、发展和成熟，测试套件也在增长、发展和成熟，但是如何确保测试本身也是可管理的呢？</p><p id="fd7e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对python开发人员来说幸运的是，pytest提供了重用测试函数和作为测试例程的一部分创建的对象的机制，这有助于保持所有测试逻辑的组织性和可维护性。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="b756" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated"><strong class="ak">激励的例子</strong></h1><p id="727f" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">我正在开发一个实现单变量多项式的类，这是一个项和的数学表达式，其中每一项都是一个常数乘以变量的非负幂。</p><p id="f3d8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">举个例子，</p><p id="b8d3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> 4x - 2x </strong></p><p id="dbfe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">是一个多项式表达式。这个多项式可以被建模为一个列表，其中每个元素是一个项，每个项本身是一个具有系数和指数的列表。上述多项式可以用以下方式建模:</p><p id="f696" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> [[4，3]，[-2，1]] </strong></p><p id="d120" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用我的多项式类，我可以通过以下方式创建相应的多项式对象:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="7ec7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">随着多项式类功能的增加，我需要测试它。多项式的一个特征是指数是非负整数，所以我将编写一个测试来检查指数是否满足该条件。多项式的导数也是多项式，所以我也应该检查那些指数。此外，如果指数最大的系数是负的，那么我的多项式的字符串表示必须有一个前导负号，所以需要检查一下。</p><p id="2911" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在对于以上的poly，我有3个测试:</p><ol class=""><li id="ef11" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">所有指数都是非负整数吗？</li><li id="3391" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">导数的所有指数都是非负整数吗？</li><li id="3d90" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">如果指数最高的项的系数为负，字符串表示是否有前导负号？</li></ol><p id="d4fd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里有一种非常直接的方式来编写这些测试:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="45d0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这让我可以用那些特定的项来测试多项式对象的功能，但是如果我想用不同的项来测试一个多项式，那么我必须编写一个新的测试。</p><p id="256a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这可能适用于极少数的对象和边缘案例，但是随着更多的对象需要测试，每个对象需要检查更多的测试案例，它将很快变得势不可挡。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="b19e" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated"><strong class="ak">如何使用Pytest夹具</strong></h1><p id="5a81" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">Fixtures是返回可以被多个测试访问的对象的函数。在fixture函数上方用@pytest.fixture() decorator声明一个fixture。然后，将fixture函数名作为一个参数放入测试函数的定义中，测试函数现在可以使用fixture，而无需显式实例化它返回的对象。使用fixture，我可以如下重构我的测试:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="fb40" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我想添加的任何测试函数都可以访问同一个多项式，测试本身只有测试所需的逻辑。理所应当！</p><p id="51ff" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不幸的是，我认为我定义的单个多项式不足以真正测试我的字符串表示。它甚至不需要前导负号。我可以添加另一个装置，但是我必须为每个装置添加测试:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="6a5b" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">如何参数化Pytest夹具</h1><p id="0a2a" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">@pytest.fixture decorator允许您向fixture传递一个参数列表。对于每一个请求这个fixture的测试，这个测试会为这个fixture的每一个参数化版本运行一次。例如:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="f224" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我可以简单地向TERMS_LIST添加额外的多项式项列表，每个请求poly fixture的测试将使用TERMS_LIST中每组项的多项式对象运行一次。</p><p id="6f24" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果测试失败，pytest将让您知道哪些参数导致了失败的测试:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/d5e3e5644d5421fdcffc67add75336e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1132/format:webp/1*574fzcxQ7tKQ8aznYYQOsg.png"/></div></figure><p id="1c60" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面的“test_str_leading_minus[poly0]”指的是TERMS_LIST中参数在0索引处的poly fixture。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="d980" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated"><strong class="ak">另一个激励的例子</strong></h1><p id="4959" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">正如我上面写的，多项式必须有非负指数。当我为我的多项式类实现接口时，我决定如果一个多项式试图用无效的指数创建，我要抛出一个异常。我可以尝试创建一个带有无效术语列表的参数化fixture，</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="ea55" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但这是行不通的！fixture将尝试创建一个新的多项式对象，如果希望接口引发异常，那么任何引用该fixture的测试都不会完成。测试会因为异常而失败，但是失败是预期的结果，所以测试应该通过。那我该怎么办呢？</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="803a" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated"><strong class="ak">如何使用Pytest对测试函数进行参数化</strong></h1><p id="5109" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">@ py test . mark . parameterize()decorator允许您独立于您创建的fixtures来参数化测试函数的参数。现在，我可以传递一个无效参数列表，并使用pytest.raises(AssertionError)断言无效术语会导致预期的异常。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="9fc9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，只有当无效术语在对象初始化期间导致断言错误时，测试才会通过。此外，如果有我想定义为无效的其他术语列表，我可以简单地将它们添加到INVALID_TERMS_LIST中，而无需编写另一个测试。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="4043" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">摘要</h1><p id="ae48" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">您可以在fixture decorator中使用params关键字参数将参数传递给fixture，也可以使用@ py test . mark . parameter ize decorator将参数传递给单独测试的测试。</p><p id="0f54" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">编码快乐！</p></div></div>    
</body>
</html>