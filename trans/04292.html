<html>
<head>
<title>Kubeflow Pipelines: How to Build your First Kubeflow Pipeline from Scratch</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kubeflow管道:如何从零开始构建您的第一个Kubeflow管道</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/kubeflow-pipelines-how-to-build-your-first-kubeflow-pipeline-from-scratch-2424227f7e5?source=collection_archive---------1-----------------------#2021-04-12">https://towardsdatascience.com/kubeflow-pipelines-how-to-build-your-first-kubeflow-pipeline-from-scratch-2424227f7e5?source=collection_archive---------1-----------------------#2021-04-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="c3f2" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/hands-on-tutorials" rel="noopener" target="_blank">实践教程</a></h2><div class=""/><div class=""><h2 id="e394" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">如何设计、建造和运行Kubeflow管道的分步指南</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/a0bf70fd238586cd2d43c2a0cee45bd5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5kFQ9m6k_dcQynUc1fAIQQ.jpeg"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">图一。Kubeflow Pipelines |作者图片|来自<a class="ae lh" href="https://www.freepik.es/flaticon" rel="noopener ugc nofollow" target="_blank"> freepick </a>、<a class="ae lh" href="https://www.flaticon.es/autores/flat-icons" rel="noopener ugc nofollow" target="_blank">平面图标</a>的图标</p></figure><p id="f4b7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">Kubeflow [ <a class="ae lh" href="https://www.kubeflow.org/" rel="noopener ugc nofollow" target="_blank"> 1 </a> ]是一个平台，它提供了一套工具来开发和维护机器学习生命周期，并在kubernetes集群之上工作。在它的一套工具中，我们找到了Kubeflow管道。<em class="me">kube flow Pipelines</em>[<a class="ae lh" href="https://www.kubeflow.org/docs/components/pipelines/overview/pipelines-overview/" rel="noopener ugc nofollow" target="_blank">2</a>]是一个扩展，允许我们原型化、自动化、部署和调度机器学习工作流。这样的工作流由一组组件组成，这些组件仅仅是独立的功能，而这些功能又存在于docker容器中。然而，当您第一次使用kubeflow时，理解如何设计、构建和连接这些组件以创建和部署kubeflow管道变得很复杂，这就是为什么在本博客中，我们将通过理解其组件以及它们如何相互作用来了解如何创建<em class="me"> Kubeflow管道</em>，因此本博客将分为以下几个部分:</p><ul class=""><li id="8860" class="mf mg it lk b ll lm lo lp lr mh lv mi lz mj md mk ml mm mn bi translated"><strong class="lk jd">什么是Kubeflow管道？</strong></li><li id="cfdb" class="mf mg it lk b ll mo lo mp lr mq lv mr lz ms md mk ml mm mn bi translated"><strong class="lk jd">建立您的第一条Kubeflow管道</strong></li></ul><blockquote class="mt mu mv"><p id="0ff2" class="li lj me lk b ll lm kd ln lo lp kg lq mw ls lt lu mx lw lx ly my ma mb mc md im bi translated">如果你想知道如何在你的本地机器上安装和配置kubeflow，我推荐你看一下这篇文章:<a class="ae lh" rel="noopener" target="_blank" href="/kubeflow-how-to-install-and-launch-kubeflow-on-your-local-machine-e0d7b4f7508f"> Kubeflow:如何在你的本地机器上安装和启动kube flow</a></p></blockquote><p id="fccb" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们开始吧！</p><h1 id="6566" class="mz na it bd nb nc nd ne nf ng nh ni nj ki nk kj nl kl nm km nn ko no kp np nq bi translated">什么是Kubeflow管道？</h1><p id="d1fb" class="pw-post-body-paragraph li lj it lk b ll nr kd ln lo ns kg lq lr nt lt lu lv nu lx ly lz nv mb mc md im bi translated"><em class="me"> Kubeflow Pipelines </em>是Kubeflow扩展，它提供了创建机器学习工作流的工具。基本上，这些工作流是以图形形式设计的任务链，并且被表示为有向无环图(Dag)。图中的每个节点称为一个组件，该组件代表docker容器中的一个独立任务。在图2中，我们可以看到一个管道组件的可视化描述。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nw"><img src="../Images/e78ad234b71a7a587add8934a3cf3aff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q-Jn6YMX_1BViZVGlp1O_Q.jpeg"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">图二。<em class="nx">管道组件</em>。在(A)中，我们可以看到一个基于python函数的组件，它位于自定义docker容器中。在(B)中，我们可以看到一个由装饰器从<a class="ae lh" href="https://www.kubeflow.org/docs/components/pipelines/sdk/build-component/" rel="noopener ugc nofollow" target="_blank">kfp . components</a>| Image by author生成的组件</p></figure><p id="ed23" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">Kubeflow Pipelines基于Argo Workflows [ <a class="ae lh" href="https://github.com/argoproj/argo-workflows" rel="noopener ugc nofollow" target="_blank"> 3 </a> ]，这是一个用于kubernetes的容器本地工作流引擎。一般来说，Kubeflow管道由[ <a class="ae lh" href="https://www.amazon.com.mx/Kubeflow-Machine-Learning-Lab-Production/dp/1492050121" rel="noopener ugc nofollow" target="_blank"> 4 </a> ]组成:</p><ul class=""><li id="8a35" class="mf mg it lk b ll lm lo lp lr mh lv mi lz mj md mk ml mm mn bi translated"><strong class="lk jd"> Python SDK </strong>:允许你使用Kubeflow管道<em class="me">领域特定语言</em> (DSL)创建和操作管道及其组件。</li><li id="9ea8" class="mf mg it lk b ll mo lo mp lr mq lv mr lz ms md mk ml mm mn bi translated"><strong class="lk jd"> DSL编译器</strong>:它允许你将python代码中定义的管道转换成反映在YAML文件中的静态配置。</li><li id="6899" class="mf mg it lk b ll mo lo mp lr mq lv mr lz ms md mk ml mm mn bi translated"><strong class="lk jd">管道服务:</strong>从静态配置或YAML文件创建管道运行。</li><li id="8a3d" class="mf mg it lk b ll mo lo mp lr mq lv mr lz ms md mk ml mm mn bi translated"><strong class="lk jd"> Kubernetes资源:</strong>管道服务连接到kubernetes API，以便定义运行YAML文件中定义的管道所需的资源。</li><li id="49b9" class="mf mg it lk b ll mo lo mp lr mq lv mr lz ms md mk ml mm mn bi translated">工件存储:K  ubeflow管道存储元数据和工件。实验、作业、运行和指标等元数据存储在MySQL数据库中。诸如管道包、大规模度量和视图之类的工件存储在诸如MinIO server [ <a class="ae lh" href="https://min.io/" rel="noopener ugc nofollow" target="_blank"> 5 </a> ]之类的工件存储中。</li></ul><p id="1f44" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">此外，Kubeflow Pipelines提供了一个UI和一个客户端API来管理管道、组件、实验、运行和工件。</p><p id="510a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">Kubeflow管道建设的一个基本要素是组件之间的连接。这个连接是通过第三个服务的实现来实现的，默认情况下是MinIO。基本上每个组件的每个<code class="fe ny nz oa ob b">input</code>和<code class="fe ny nz oa ob b">output</code>被表示为存储在MinIO中的一个工件，这个工件将被一个URI定义和引用，该定义和引用指示这些<code class="fe ny nz oa ob b">input</code>或<code class="fe ny nz oa ob b">output</code>将被分别读取或写入的位置。在图3中，我们可以看到如何使用MinIO服务进行组件通信的可视化描述</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nw"><img src="../Images/032a5690631108eb4c68f34c8d1f056f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1tNEBlsKBx7QKLZndOPw5g.jpeg"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">图3。组件连接|作者图片</p></figure><p id="a2ec" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在上一个图像中，在左侧，我们可以看到组件之间的连接是如何通过每个元素的<code class="fe ny nz oa ob b">inputs</code>和<code class="fe ny nz oa ob b">outputs</code>进行的。从右边我们观察它是如何真正发生的，也就是说，每个进入或离开组件的工件都存储在一个存储服务中，比如MinIO，所以作为<code class="fe ny nz oa ob b">input</code>或<code class="fe ny nz oa ob b">output</code>值传递的是这个工件的引用。我们将在下一节构建第一个管道时详细了解这一点。</p><p id="5342" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在我们已经了解了Kubeflow管道是什么，它的组件以及它们如何相互作用，让我们创建并自动化一个管道，它涵盖了构建Kubeflow管道的大部分基础知识，所以让我们开始吧！</p><h1 id="af80" class="mz na it bd nb nc nd ne nf ng nh ni nj ki nk kj nl kl nm km nn ko no kp np nq bi translated">建造你的第一条库巴流管道</h1><p id="80ae" class="pw-post-body-paragraph li lj it lk b ll nr kd ln lo ns kg lq lr nt lt lu lv nu lx ly lz nv mb mc md im bi translated">在这个例子中，我们将为众所周知的<em class="me">乳腺癌</em>数据集建立一个解决<em class="me">分类问题</em>的管道。该管道将由4个组件组成，涵盖以下任务:下载和分割数据集，训练和验证两个分类模型(<em class="me">决策树</em>和<em class="me">逻辑回归</em>)，并最终显示结果。在图4中，您可以看到本例中将要构建的管道架构的可视化描述。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/bef165e507ce147c4c87a7c9e95066b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hBMGlNAE0__Uw7irscDMlA.jpeg"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">图4。管道架构|作者图片|来自<a class="ae lh" href="https://www.freepik.es/flaticon" rel="noopener ugc nofollow" target="_blank">自由选择</a>、<a class="ae lh" href="https://www.flaticon.es/autores/flat-icons" rel="noopener ugc nofollow" target="_blank">平面图标</a>的图标</p></figure><p id="f3dd" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">该示例将分为以下步骤:</p><ul class=""><li id="bfb6" class="mf mg it lk b ll lm lo lp lr mh lv mi lz mj md mk ml mm mn bi translated"><strong class="lk jd">流程描述</strong></li><li id="08e0" class="mf mg it lk b ll mo lo mp lr mq lv mr lz ms md mk ml mm mn bi translated"><strong class="lk jd">组件:下载_数据</strong></li><li id="f523" class="mf mg it lk b ll mo lo mp lr mq lv mr lz ms md mk ml mm mn bi translated"><strong class="lk jd">组件:决策树和逻辑回归</strong></li><li id="bd62" class="mf mg it lk b ll mo lo mp lr mq lv mr lz ms md mk ml mm mn bi translated"><strong class="lk jd">组件:显示结果</strong></li><li id="9497" class="mf mg it lk b ll mo lo mp lr mq lv mr lz ms md mk ml mm mn bi translated"><strong class="lk jd">编译并运行</strong></li></ul><p id="93f0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">所以让我们开始吧。</p><blockquote class="mt mu mv"><p id="8782" class="li lj me lk b ll lm kd ln lo lp kg lq mw ls lt lu mx lw lx ly my ma mb mc md im bi translated">如果你想访问完整的项目，我给你留下了资源库的链接:<a class="ae lh" href="https://github.com/FernandoLpz/Kubeflow_Pipelines" rel="noopener ugc nofollow" target="_blank">https://github.com/FernandoLpz/Kubeflow_Pipelines</a></p></blockquote><h2 id="3e1f" class="oc na it bd nb od oe dn nf of og dp nj lr oh oi nl lv oj ok nn lz ol om np iz bi translated">-流程描述</h2><p id="9f82" class="pw-post-body-paragraph li lj it lk b ll nr kd ln lo ns kg lq lr nt lt lu lv nu lx ly lz nv mb mc md im bi translated">首先，我们将为管道中的每个组件创建一个容器。出于实用和可解释的目的，组件<code class="fe ny nz oa ob b">download_data</code>、<code class="fe ny nz oa ob b">decision_tree</code>和<code class="fe ny nz oa ob b">logistic_regression</code>将是手工构建的docker容器，其映像将被托管在Docker Hub [6]上。组件<code class="fe ny nz oa ob b">show_results</code>将是由<code class="fe ny nz oa ob b">kfp.components</code>的扩展<code class="fe ny nz oa ob b">@func_to_container_op</code>生成的容器(我们将在后面看到)。然后，将为每个docker容器生成一组<code class="fe ny nz oa ob b">yaml</code>清单。稍后，我们将生成<em class="me"> python脚本</em> t，其目标是定义管道图。最后，我们将编译管道，将其托管在<em class="me"> Kubeflow管道</em>中并运行管道！</p><p id="949a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">所以，让我们从构建组件及其各自的<code class="fe ny nz oa ob b">yaml</code>文件的过程开始。</p><h2 id="009d" class="oc na it bd nb od oe dn nf of og dp nj lr oh oi nl lv oj ok nn lz ol om np iz bi translated">-组件:下载数据</h2><p id="6cb5" class="pw-post-body-paragraph li lj it lk b ll nr kd ln lo ns kg lq lr nt lt lu lv nu lx ly lz nv mb mc md im bi translated">该组件的目标是下载和分割数据集。正如我们已经提到的，我们将使用的数据集是众所周知的<em class="me">乳腺癌</em>，它是作为<em class="me"> scikit-learn </em>的扩展而发现的。那么，组件将如下所示:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="on oo l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">代码片段1。下载_数据. py</p></figure><p id="5fe4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如我们所见，在第12行和第13行，我们分别下载和分割数据集。接下来有趣的事情发生了，我们生成一个名为<code class="fe ny nz oa ob b">data</code>的<code class="fe ny nz oa ob b">dict</code>类型的结构(第23行)来托管训练集和测试集。然后我们将这个结构转换成一个<code class="fe ny nz oa ob b">json</code>类型的对象，最后我们在<code class="fe ny nz oa ob b">args.data</code>参数中定义的文件中转储这个对象。这个转储数据对象的过程是能够向其他组件(决策树和逻辑回归模型)公开生成的数据(在本例中是训练和测试数据集)的关键。关键是将我们的数据保存在一个文件中，在这种情况下，我们将它设为<code class="fe ny nz oa ob b">json</code>类型(这是推荐的),但它可以是任何格式。</p><p id="5125" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">嗯，一旦我们有了<code class="fe ny nz oa ob b">python script,</code>，我们需要生成<code class="fe ny nz oa ob b">Dockerfile</code>来生成我们将上传到DockerHub的图像。在这种情况下，我们的图像非常简单，看起来像这样:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="on oo l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">代码片段2。download_data.py组件的Dockerfile</p></figure><p id="687d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">一旦<code class="fe ny nz oa ob b">Dockerfile</code>准备好了，我们就开始构建映像并上传到容器注册中心。</p><p id="a5cf" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">很好，我们几乎为我们的<code class="fe ny nz oa ob b">download_data</code>组件准备好了一切，我们唯一缺少的是<code class="fe ny nz oa ob b">yaml</code>清单，它旨在描述我们组件的行为以及定义这样的组件需要的<code class="fe ny nz oa ob b">inputs</code>和<code class="fe ny nz oa ob b">outputs</code>的类型。因此，<code class="fe ny nz oa ob b">download_data</code>组件的清单如下所示:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="on oo l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">代码片段4。下载_数据. yaml</p></figure><p id="a41c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">正如我们所看到的，在第5行中，我们定义了组件的输出，在本例中，它被定义为名称<code class="fe ny nz oa ob b">Data</code>，类型为<code class="fe ny nz oa ob b">LocalPath</code>。请务必注意，数据类型是指组件输出的内容，在这种情况下，因为它是包含定型和测试数据集的结构，所以数据类型是存储该文件的位置。然而，不同的目的有不同的数据类型(例如<code class="fe ny nz oa ob b">String</code>、<code class="fe ny nz oa ob b">Float</code>、<code class="fe ny nz oa ob b">Integer</code>等)，对于数据类型，建议看一下文档[7]。在第9行中，我们引用了将从DockerHub中提取的图像(此时我们假设图像已经构建好并上传到容器注册中心)。最后，从第10行到第14行，我们引用了图像的使用，这种情况下只接收一个参数，即数据。</p><p id="a9c2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">很好，到目前为止，我们已经看到了如何构建组成<code class="fe ny nz oa ob b">download_data</code>组件的每个元素。在下图中，我们可以看到该组件生成过程的可视化描述。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi op"><img src="../Images/8c0efc1a852f30f61fb2ece4e371922a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kVlKu75Vazt6FQoe-uSZ7A.jpeg"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">图5。构建download_data组件的过程|作者图片|来自<a class="ae lh" href="https://www.freepik.es/flaticon" rel="noopener ugc nofollow" target="_blank">自由选择</a>、<a class="ae lh" href="https://www.flaticon.es/autores/flat-icons" rel="noopener ugc nofollow" target="_blank">平面图标</a>的图标</p></figure><p id="7553" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">开发<code class="fe ny nz oa ob b">decision_trees</code>和<code class="fe ny nz oa ob b">logisti_regression</code>组件的过程实际上与<code class="fe ny nz oa ob b">dowload_data</code>相同，唯一的区别在于参数的定义，因为这些组件接收由<code class="fe ny nz oa ob b">download_data</code>下载的数据集所在的路径作为输入，所以让我们看看我们是如何做到这一点的。</p><h2 id="6c6d" class="oc na it bd nb od oe dn nf of og dp nj lr oh oi nl lv oj ok nn lz ol om np iz bi translated">-组件:决策树和逻辑回归</h2><p id="adf7" class="pw-post-body-paragraph li lj it lk b ll nr kd ln lo ns kg lq lr nt lt lu lv nu lx ly lz nv mb mc md im bi translated"><code class="fe ny nz oa ob b">decision_tree</code>和<code class="fe ny nz oa ob b">logistic_regression</code>组件的构造实际上是相同的，唯一不同的是要实现的模型，因此出于实用目的，我们将只展示如何为<code class="fe ny nz oa ob b">decision_tree</code>组件实现。</p><p id="4d8e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe ny nz oa ob b">decision_tree.py</code>模块如下:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="on oo l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">代码片段5。决策树组件</p></figure><p id="2de1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">首先，我们来看看第44行和第45行。正如我们所看到的，我们定义了两个参数<code class="fe ny nz oa ob b">data</code>和<code class="fe ny nz oa ob b">accuracy</code>。<code class="fe ny nz oa ob b">data</code>参数指的是存储由<code class="fe ny nz oa ob b">download_data</code>组件生成的数据集的路径，而<code class="fe ny nz oa ob b">accuracy</code>参数指的是我们将保存在该组件中获得的精度的路径。正如我们在第50行中观察到的，生成了将这种准确性存储为文件的路径。接下来要做的就是读取数据集作为json对象的文件(第12–19行)，训练模型，评估模型，并在由<code class="fe ny nz oa ob b">args.accuracy</code>参数定义的路径中保存精度(第38行)，就这样！</p><p id="c17f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在，我们必须为该组件创建docker文件，如下所示:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="on oo l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">代码片段6。决策树组件的docker文件</p></figure><p id="3e44" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">最后，我们只需要在<code class="fe ny nz oa ob b">yaml</code>清单中定义<code class="fe ny nz oa ob b">decision_tree</code>组件的使用，如下所示:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="on oo l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">代码片段7。决策树. yaml</p></figure><p id="c34a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">要考虑两件事。第一个是我们正在定义一个输入和输出变量，它们分别对应于<code class="fe ny nz oa ob b">data</code>和<code class="fe ny nz oa ob b">accuracy</code>。第二个是将输入参数分别定义为<code class="fe ny nz oa ob b">data</code>和<code class="fe ny nz oa ob b">accuracy</code>的<code class="fe ny nz oa ob b">InputPath</code>和<code class="fe ny nz oa ob b">OutputPath</code>。</p><p id="10d7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">一旦定义了清单，<code class="fe ny nz oa ob b">decision_tree</code>组件就准备好了(正如我们所讨论的，<code class="fe ny nz oa ob b">logistic_regression</code>组件的构造方式与<code class="fe ny nz oa ob b">decision_tree</code>相同)。</p><p id="0cb3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">好了，现在让我们继续构建最后一个组件，开始吧！</p><h2 id="c9cc" class="oc na it bd nb od oe dn nf of og dp nj lr oh oi nl lv oj ok nn lz ol om np iz bi translated">-组件:显示结果</h2><p id="2f91" class="pw-post-body-paragraph li lj it lk b ll nr kd ln lo ns kg lq lr nt lt lu lv nu lx ly lz nv mb mc md im bi translated"><code class="fe ny nz oa ob b">show_results</code>组件的目的是显示从<code class="fe ny nz oa ob b">decision_tree</code>和<code class="fe ny nz oa ob b">logistic_regression</code>组件获得的精度。这个组件也将被定义在一个容器中，但是，与<code class="fe ny nz oa ob b">download_data</code>、<code class="fe ny nz oa ob b">decision_tree</code>和<code class="fe ny nz oa ob b">logistic_regression</code>组件相比，<code class="fe ny nz oa ob b">show_results</code>组件将使用<code class="fe ny nz oa ob b">kfp.componentes</code>的<code class="fe ny nz oa ob b">@func_to_container_op</code>扩展被转换成一个容器。当要开发的任务不需要多个依赖项，或者要解决的任务不像该组件那样非常广泛时，该扩展非常有用，因此，该组件如下所示:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="on oo l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">代码片段8。显示结果组件</p></figure><p id="78c3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">因为这个组件没有在容器注册表中定义，所以我们不需要<code class="fe ny nz oa ob b">yaml</code>清单。在这种情况下，<code class="fe ny nz oa ob b">@func_to_container_op</code>扩展负责为我们定义这样一个清单。</p><p id="e0e4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">太棒了，到目前为止，我们已经创建了管道的每个组件，我们只需要生成python脚本来定义组件之间的交互，从而能够执行管道，让我们开始吧！</p><h2 id="93d9" class="oc na it bd nb od oe dn nf of og dp nj lr oh oi nl lv oj ok nn lz ol om np iz bi translated">-编译并运行</h2><p id="654d" class="pw-post-body-paragraph li lj it lk b ll nr kd ln lo ns kg lq lr nt lt lu lv nu lx ly lz nv mb mc md im bi translated">最后，我们生成定义管道架构的脚本，也就是说，组件将如何交互。那么，这样的文件将如下所示:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="on oo l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">代码片段9。构建管道</p></figure><p id="94e2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">主要功能称为<code class="fe ny nz oa ob b">first_pipeline()</code>，由<code class="fe ny nz oa ob b">dsl.pipeline()</code>修饰。这个主要功能定义了组件将如何集成。因此，在第17、18和19行中，组件<code class="fe ny nz oa ob b">download</code>、<code class="fe ny nz oa ob b">decision_tree</code>和<code class="fe ny nz oa ob b">logistic_regression</code>从已经创建的<code class="fe ny nz oa ob b">yaml</code>清单中加载。在第22行，执行<code class="fe ny nz oa ob b">download_task</code>。稍后，在第26和27行中，通过将<code class="fe ny nz oa ob b">download_task</code>的输出作为输入参数来执行任务<code class="fe ny nz oa ob b">decision_tree_task</code>和<code class="fe ny nz oa ob b">logistic_regression_task</code>。最后，在第31行，通过将来自<code class="fe ny nz oa ob b">decision_tree_task</code>和<code class="fe ny nz oa ob b">logistic_regression_task</code>的输出作为输入来执行任务<code class="fe ny nz oa ob b">show_results</code>。</p><p id="4940" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">移动到Kubeflow管道UI之前的最后一步是编译前面的脚本，该脚本将生成一个<code class="fe ny nz oa ob b">yaml</code>清单(称为<code class="fe ny nz oa ob b">FirstPipeline.yaml</code>),该清单将被上传到Kubeflow管道服务，以便运行管道。在图6中，你可以看到一个关于如何上传和运行你的<code class="fe ny nz oa ob b">FirstPipeline.yaml</code>文件的可视化描述。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/0caccc47dfea9b2459bd7451b0c973c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1380/1*3V07HmwPTpXaoHoCaZvdyA.gif"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">图6。上传和运行管道</p></figure><p id="06f7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在图7中，您可以看到组件<code class="fe ny nz oa ob b">show_restuls</code>的输出。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/0f35781997122617e7b2c1f70a483153.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bncoqsrhRttoda6cL3eAgQ.jpeg"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">图7。结果</p></figure><blockquote class="mt mu mv"><p id="0481" class="li lj me lk b ll lm kd ln lo lp kg lq mw ls lt lu mx lw lx ly my ma mb mc md im bi translated">如果你想访问完整的项目，我给你留下了资源库的链接:【https://github.com/FernandoLpz/Kubeflow_Pipelines】T4</p></blockquote><p id="9af1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">太好了，我们已经到了教程博客的结尾！</p><h1 id="3bf0" class="mz na it bd nb nc nd ne nf ng nh ni nj ki nk kj nl kl nm km nn ko no kp np nq bi translated">结论</h1><p id="e0f4" class="pw-post-body-paragraph li lj it lk b ll nr kd ln lo ns kg lq lr nt lt lu lv nu lx ly lz nv mb mc md im bi translated">在这篇博客中，我们已经看到了什么是Kubeflow管道及其组件。为了向读者展示创建Kubeflow管道的实用方法，我们还开发了一个分步管道。</p><p id="da7c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">虽然在这篇博客中，我们看到了一个基本管道的开发，但是建议读者看一下文档，因为它在创建和部署Kubeflow管道时提供了多种选择和可能性。</p><h1 id="dc9f" class="mz na it bd nb nc nd ne nf ng nh ni nj ki nk kj nl kl nm km nn ko no kp np nq bi translated">参考</h1><p id="1fb6" class="pw-post-body-paragraph li lj it lk b ll nr kd ln lo ns kg lq lr nt lt lu lv nu lx ly lz nv mb mc md im bi translated">[1] <a class="ae lh" href="https://www.kubeflow.org/" rel="noopener ugc nofollow" target="_blank"> Kubeflow </a></p><p id="112c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">[2] <a class="ae lh" href="https://www.kubeflow.org/docs/components/pipelines/overview/pipelines-overview/" rel="noopener ugc nofollow" target="_blank">库伯流管道</a></p><p id="19a9" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">[3] <a class="ae lh" href="https://github.com/argoproj/argo-workflows" rel="noopener ugc nofollow" target="_blank"> Argo工作流程</a></p><p id="d9b7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">[4] <a class="ae lh" href="https://www.amazon.com.mx/Kubeflow-Machine-Learning-Lab-Production/dp/1492050121" rel="noopener ugc nofollow" target="_blank">机器学习的Kubeflow:从实验室到生产</a></p><p id="daf9" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">[5] <a class="ae lh" href="https://min.io/" rel="noopener ugc nofollow" target="_blank">迷你电脑</a></p><p id="e846" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">[6] <a class="ae lh" href="https://hub.docker.com/" rel="noopener ugc nofollow" target="_blank">码头工人中心</a></p><p id="3426" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">[7] <a class="ae lh" href="https://www.kubeflow.org/docs/components/pipelines/sdk/component-development/" rel="noopener ugc nofollow" target="_blank">创建可重用组件</a></p></div></div>    
</body>
</html>