<html>
<head>
<title>A friendly Guide for writing Recursive Functions with Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Python编写递归函数的友好指南</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/a-friendly-guide-for-writing-recursive-functions-with-python-52441bd7ff5f?source=collection_archive---------14-----------------------#2021-10-14">https://towardsdatascience.com/a-friendly-guide-for-writing-recursive-functions-with-python-52441bd7ff5f?source=collection_archive---------14-----------------------#2021-10-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5756" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解如何使用递归来优雅地编写代码</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/3c85aa7b1ff5fabf7cfc61deacf0cd75.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*1G3ldIivN7576-kz"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">凯文·杨在<a class="ae ky" href="https://unsplash.com/photos/Z5qD8T3wVvk" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="d1fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">起初，如果解释得很糟糕，递归似乎是不可能学会的。我仍然记得第一次遇到它时，我觉得它很有挑战性。为了深入理解它，我需要做许多练习。</p><p id="94bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这很难，因为我的大脑本能地使用迭代来解决问题，比如for循环和while。但是经过一些努力，我在做很多练习的同时，能够理解递归函数的基础。</p><p id="5fe5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，我想向你介绍什么是递归，并用插图展示递归函数的例子，这肯定有助于以更有效的方式理解这个主题。</p><h1 id="863b" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">递归函数</h1><p id="539f" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">从单词“recursive”中你可以直观地看出，当函数<strong class="lb iu">调用自身</strong>时，它就是递归的。因此，同一个函数被调用一次或多次。在编写任何递归函数之前，您需要考虑两种情况:</p><ol class=""><li id="4154" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu mx my mz na bi translated"><strong class="lb iu">基础案例</strong>是解决问题时需要考虑的最简单的案例。这也导致了递归的结束。</li><li id="e9f1" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated"><strong class="lb iu">递归案例</strong>包括解决问题的一般解法，使用递归函数。</li></ol><p id="dccf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，让我们尝试计算一个正数的阶乘:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="4195" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，我们可以确定两种不同的情况:</p><p id="cd55" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">基本情况</strong>:如果数字等于0或1，函数返回1</p><p id="8afb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">递归情况</strong>:我们考虑剩余的情况，其中数字大于1。</p><p id="cf16" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">比如我们算3的时候！，有一些步骤可以解决这个简单的问题:</p><ol class=""><li id="a74c" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu mx my mz na bi translated">呼叫<code class="fe ni nj nk nl b">fact(3)</code></li><li id="bb76" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated"><code class="fe ni nj nk nl b">fact(3)</code>返回<code class="fe ni nj nk nl b">3*fact(2)</code>，这里要调用的新函数是<code class="fe ni nj nk nl b">fact(2)</code></li><li id="fe8b" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated"><code class="fe ni nj nk nl b">fact(2)</code>返回<code class="fe ni nj nk nl b">2*fact(1)</code>，这里要调用的新函数是<code class="fe ni nj nk nl b">fact(1)</code></li><li id="3a9f" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated"><code class="fe ni nj nk nl b">fact(1)</code>返回<code class="fe ni nj nk nl b">1</code></li><li id="58bc" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">从第4步<strong class="lb iu">回到第1步</strong>解决问题</li></ol><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nm"><img src="../Images/75b14651bae22e3be958b6c717a523c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z49WJKn0yol2YFHryZ55AA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者插图。递归函数计算3！= 6</p></figure><h1 id="42fe" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">其他示例</h1><p id="77ec" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">让我们试试其他三个例子，看看你是否真正理解了递归函数的工作原理。</p><ol class=""><li id="fbc3" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu mx my mz na bi translated">写一个递归函数，当且仅当数字是偶数时返回True</li></ol><p id="001b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要再次确定这两种情况:</p><p id="96c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">基本情况</strong>:如果数字等于0，则数字为偶数</p><p id="8c2d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">递归情况</strong>:我们考虑所有情况，n=0除外。例如，当n=4时。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nn"><img src="../Images/08c95845b67d40e82cb93017a5ac6162.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lQslZaBjhnG9CPJuX-NKDg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者插图。当n=4时。</p></figure><p id="ae43" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">2.<strong class="lb iu">写一个递归函数，对一个列表的元素求和，这个列表至少需要有一个元素</strong></p><p id="c753" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这两种不同的情况是:</p><p id="f352" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">基本情况</strong>:如果列表中只有一个元素，函数返回列表的第一个元素</p><p id="ef8b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">递归情况</strong>:在剩下的情况下，我们使用递归函数。每次都删除列表中的第一个。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="d6a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">递归调用可以通过显示以下步骤来解释:</p><pre class="kj kk kl km gt no nl np nq aw nr bi"><span id="7855" class="ns lw it nl b gy nt nu l nv nw">sum_list([1,2,3,4])        #1st call with [1,2,3,4] <br/>1 + sum_list([2,3,4])      #2nd call with [2,3,4]<br/>1 + 2 + sum_list([3,4])    #3rd call with [3,4]<br/>1 + 2 + 3 + sum_list([4])  #4th call with [4]</span><span id="c379" class="ns lw it nl b gy nx nu l nv nw">1 + 2 + 3 + 4              #return from 4th call with <br/>                           sum_list([4])=4<br/>1 + 2 + 7                  #return from 3rd call <br/>1 + 9                      #return from 2nd call <br/>10                         #return from 1st call</span></pre><p id="bb6c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">3.给定一个列表(至少有一个元素)，写一个递归函数，只返回偶数元素</p><p id="7e8f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这一次，我们可以发现:</p><p id="7538" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">基础案例</strong>:如果只有一个元素，如果元素是偶数我们返回列表，否则返回[]。</p><p id="afb1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">递归情况</strong>:在剩下的情况下，应用递归功能。和以前一样，我们每次在递归函数中从列表中删除一个元素。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="b13e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，我们可以看到递归调用被分成不同的步骤:</p><pre class="kj kk kl km gt no nl np nq aw nr bi"><span id="8b5f" class="ns lw it nl b gy nt nu l nv nw">even_elements([0,1,2,3])       #1st call with [0,1,2,3]<br/>[0]+even_elements([1,2,3])     #2nd call with [1,2,3] <br/>[0]+[]+even_elements([2,3])    #3rd call with [2,3]<br/>[0]+[]+[2]+even_elements([3])  #4th call with [3]</span><span id="35b7" class="ns lw it nl b gy nx nu l nv nw">[0]+[]+[2]+[]                  #return from 4th call with <br/>                               even_elements([3])=[]<br/>[0]+[]+[2]                     #return from 3rd call<br/>[0]+[2]                        #return from 2nd call<br/>[0,2]                          #return from 1st call   </span></pre><h1 id="9734" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">最终想法:</h1><p id="a574" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">递归函数的概述终于结束了。现在，您应该对什么是递归以及如何编写递归函数有了更好的了解。它可以提供一些优势。首先，递归将一个复杂的任务分解成简单的子任务。此外，它适合处理Python数据结构，如堆栈、队列和链表。但是你也应该知道，这种类型的解决方案<strong class="lb iu">并不适用于所有问题</strong>。每个递归调用都等待下一个递归调用，然后，有时迭代会花费更多的时间。你应该比较迭代的时间和递归函数的时间来确定。无论如何，递归函数在数据科学领域有众所周知的应用，例如递归神经网络、决策树、随机树和隔离树，其中递归是使它们工作的必要条件。我希望这篇教程对你有用。感谢阅读。祝您愉快！</p></div><div class="ab cl ny nz hx oa" role="separator"><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od"/></div><div class="im in io ip iq"><p id="4649" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你喜欢我的文章吗？<a class="ae ky" href="https://eugenia-anello.medium.com/membership" rel="noopener"> <em class="of">成为会员</em> </a> <em class="of">每天无限获取数据科学新帖！这是一种间接的支持我的方式，不会给你带来任何额外的费用。如果您已经是会员，</em> <a class="ae ky" href="https://eugenia-anello.medium.com/subscribe" rel="noopener"> <em class="of">订阅</em> </a> <em class="of">每当我发布新的数据科学和python指南时，您都可以收到电子邮件！</em></p></div></div>    
</body>
</html>