<html>
<head>
<title>Identifying signs of tiredness using sequence classification</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用序列分类识别疲劳迹象</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/identifying-signs-of-tiredness-using-sequence-classification-f312e0adb6c?source=collection_archive---------39-----------------------#2021-08-31">https://towardsdatascience.com/identifying-signs-of-tiredness-using-sequence-classification-f312e0adb6c?source=collection_archive---------39-----------------------#2021-08-31</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="94da" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/hands-on-tutorials" rel="noopener" target="_blank">实践教程</a></h2><div class=""/><div class=""><h2 id="7b1c" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">使用可穿戴健康数据训练模型以对疲劳进行分类</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/72fc277b90573ad11fec2cb2bf988cd9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0kFCtjIpEF6AwlQZg-WG4Q.jpeg"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">由<a class="ae le" href="https://unsplash.com/@crisaur?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Cris Saur </a>在<a class="ae le" href="https://unsplash.com/s/photos/tired?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="8cf5" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi mb translated">我想你已经在路上开了一会儿，天开始黑了。你感觉你的眼睛越来越沉重，你知道你应该停下来休息一下，但你想继续前进，这样你就可以按时到达目的地…</p><p id="0f65" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我相信很多人在某个时候都经历过这种情况，这是一个典型的“昏昏欲睡驾驶”的例子，这使我们发生交通事故的可能性增加了3倍。</p><p id="588c" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">如果有一种方法可以识别我们何时开始感到疲劳，会怎么样？</p><blockquote class="mk ml mm"><p id="77af" class="lf lg mn lh b li lj ka lk ll lm kd ln mo lp lq lr mp lt lu lv mq lx ly lz ma ij bi translated">这是我们将尝试使用我的个人<a class="ae le" href="https://www.fitbit.com/global/us/home" rel="noopener ugc nofollow" target="_blank"> <strong class="lh ja"> Fitbit </strong> </a>数据来解决的问题陈述。我用Fitbit数据写的另一个例子可以在<a class="ae le" rel="noopener" target="_blank" href="/does-machine-learning-know-when-im-scared-anomaly-detection-in-wearable-health-data-72f537dd4370">这里</a>找到。</p></blockquote><h1 id="2838" class="mr ms iq bd mt mu mv mw mx my mz na nb kf nc kg nd ki ne kj nf kl ng km nh ni bi translated"><strong class="ak">挑战</strong></h1><p id="ed27" class="pw-post-body-paragraph lf lg iq lh b li nj ka lk ll nk kd ln lo nl lq lr ls nm lu lv lw nn ly lz ma ij bi translated">我们将使用从我的个人Fitbit手表收集的睡眠和心率数据。对于这项任务，睡眠数据给出了一个关于我何时开始睡眠的想法，并且可以用作一个点来划分清醒和睡眠。此外，这有助于我们估计疲劳的时间间隔；为了方便起见，这将被定义为睡觉前的最后三十分钟。定义这些不同的阶段有助于标记我们的心率数据，即测量每分钟的心跳次数。</p><p id="6b13" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">这为我们提供了由睡眠间隔分类的心率测量的<strong class="lh ja">标记的单变量序列</strong>，其将被用作我们的序列分类模型的输入。我们的模型将是一个用Keras建造的GRU。</p><p id="d248" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">在建立和训练我们的序列分类器后，我们将看到它在一些看不见的数据上的表现。</p><h2 id="e5e8" class="no ms iq bd mt np nq dn mx nr ns dp nb lo nt nu nd ls nv nw nf lw nx ny nh iw bi translated"><strong class="ak">数据加载和准备</strong></h2><p id="6b1e" class="pw-post-body-paragraph lf lg iq lh b li nj ka lk ll nk kd ln lo nl lq lr ls nm lu lv lw nn ly lz ma ij bi translated">睡眠和心率数据是存储在. csv或。json，它代表一个月中的某一天，因此我们需要加载所有这些文件并将它们附加在一起。</p><pre class="kp kq kr ks gt nz oa ob oc aw od bi"><span id="54a1" class="no ms iq oa b gy oe of l og oh">#Import sleep data data and combine files<br/>def Dataimport():<br/>    datasets = ['sleep_files *.csv']<br/>    for datatype in datasets:<br/>    <br/>        file_list=[]<br/>        path = 'folder pathway'<br/>        os.chdir(path)<br/>        for file in glob.glob(datatype):<br/>            file_list.append(file)<br/>        dfs = [] <br/>        for file in file_list:<br/>            data = pd.read_csv(path + file) <br/>            print('Reading: ' + str(file))<br/>            dfs.append(data)<br/>        concatenated = pd.concat(dfs, ignore_index=True)<br/>        concatenated = concatenated[['sleep_start','sleep_end']]<br/>    return concatenated</span><span id="1bd0" class="no ms iq oa b gy oi of l og oh">sleepdata = Dataimport()</span></pre><p id="4715" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">这为我们提供了一个睡眠开始和结束的时间表，值如下:</p><pre class="kp kq kr ks gt nz oa ob oc aw od bi"><span id="c160" class="no ms iq oa b gy oe of l og oh">Sleep start: 2021-01-12 22:10:00      Sleep end: 2021-01-13 05:37:30</span></pre><p id="20e2" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我们可以将日期和时间分开，因为我们稍后将只需要找到记录睡眠数据和心率数据的日期:</p><pre class="kp kq kr ks gt nz oa ob oc aw od bi"><span id="5000" class="no ms iq oa b gy oe of l og oh">#Splitting the date and time<br/>def Datasplit(sleepdata):<br/>    sleepdata['date_start'] = sleepdata['sleep_start'].str.split('T', 1, expand=True)[0]<br/>    sleepdata['time_start'] = sleepdata['sleep_start'].str.split('T', 1, expand=True)[1]<br/>    sleepdata['date_end'] = sleepdata['sleep_end'].str.split('T', 1, expand=True)[0]<br/>    sleepdata['time_end'] = sleepdata['sleep_end'].str.split('T', 1, expand=True)[1]<br/>    sleepdata['start_of_sleep'] = pd.to_datetime(sleepdata['date_start'] + ' ' + sleepdata['time_start'])<br/>    sleepdata['end_of_sleep'] = pd.to_datetime(sleepdata['date_end'] + ' ' + sleepdata['time_end'])<br/>    sleepdata = sleepdata[['start_of_sleep', 'end_of_sleep']]<br/>    sleepdata = sleepdata.sort_values(by="start_of_sleep")<br/>    return sleepdata</span><span id="4bda" class="no ms iq oa b gy oi of l og oh">sleepdata = Datasplit(sleepdata)</span></pre><p id="85d5" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">为了导入心率数据，我们可以重新使用相同的<em class="mn"> Dataimport() </em>函数，替换文件名，在文件名中包含<em class="mn">“心率”</em>。这些数据需要以稍微不同的方式进行清理，因为我们希望删除所有不必要的字符串，并以与睡眠数据相同的分辨率(即以分钟为单位)对时间序列进行重新采样:</p><pre class="kp kq kr ks gt nz oa ob oc aw od bi"><span id="300e" class="no ms iq oa b gy oe of l og oh">#cleaning the columns of the heart rate data<br/>def HRclean(heart):<br/> heart = heart.sort_values(by=”dateTime”)<br/> heart = heart.set_index(‘dateTime’)<br/> heart[“value”] = heart[“value”].apply(str)<br/> heart[“value”] = heart[“value”].str.split(“{‘bpm’:”).str[1]<br/> heart[“value”] = heart[“value”].str.split(“,”, 1, expand = True)[0]<br/> heart[“value”] = heart[“value”].astype(int)<br/> heart = heart.resample(‘1Min’).mean()<br/> heart[‘value’] = heart[‘value’].round(0)<br/> heart[‘date’] = heart.index<br/> heart = heart[[‘date’, ‘value’]]<br/> return heart</span><span id="2e56" class="no ms iq oa b gy oi of l og oh">heartdata = Dataimport()<br/>heart = HRclean(heartdata)</span></pre><p id="0c82" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">因为我们将我们的“疲劳”间隔定义为睡觉前的三十分钟，我们已经可以想象，与清醒和睡觉的时间相比，将会有<strong class="lh ja">一个大的等级不平衡</strong>。为了减轻这种情况，我们可以将心率数据过滤到更小的间隔，比如从傍晚到凌晨:</p><pre class="kp kq kr ks gt nz oa ob oc aw od bi"><span id="d80a" class="no ms iq oa b gy oe of l og oh">#selecting only values in the evening (times around the tiredness since mornings are irrelevant)<br/>heart = heart.between_time(‘19:00’, ‘03:00’)<br/>heart[“only_date”] = [d.date() for d in heart[“date”]]<br/>sleepdata[“only_date”] = [d.date() for d in sleepdata[“start_of_sleep”]]</span><span id="9eed" class="no ms iq oa b gy oi of l og oh">#Identifying rows where sleep data exists for the given day of heart rate data<br/>heart[‘sleep_data_exists’] = pd.Series(heart.only_date.isin(sleepdata.only_date).values.astype(int), heart.date.values)<br/>heart = heart[heart[‘sleep_data_exists’] == 1]</span></pre><p id="564f" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我们现在可以根据睡眠的日期时间范围将心率数据标记为睡眠或清醒:</p><pre class="kp kq kr ks gt nz oa ob oc aw od bi"><span id="15f7" class="no ms iq oa b gy oe of l og oh">#for each HR row, need to see if that time was during sleep or not, and label as 1 or 0<br/>def Labelling(heart):<br/> print(‘labelling the data…’)<br/> heart[‘sleep_label’] = 0</span><span id="8d22" class="no ms iq oa b gy oi of l og oh">#for each heartrate value, for each dt range, if hr date in dt range (per row), =1 else = continue<br/> for i in range(len(heart)):<br/> print(str(i) + ‘ of ‘+ str(len(heart)))<br/> for j in range(len(sleepdata)):<br/> if heart[‘date’][i] &gt;= sleepdata[‘start_of_sleep’][j] and heart[‘date’][i] &lt;= sleepdata[‘end_of_sleep’][j]:<br/> heart[‘sleep_label’][i] = 1<br/> else:<br/> continue<br/> return heart</span><span id="d33b" class="no ms iq oa b gy oi of l og oh">heart = Labelling(heart)</span></pre><p id="6e9c" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">最后的准备步骤将是给我们的“疲惫”类贴上标签:</p><pre class="kp kq kr ks gt nz oa ob oc aw od bi"><span id="498c" class="no ms iq oa b gy oe of l og oh">#selecting the time n rows before sleep starts<br/>idx = heart.index.get_indexer_for(heart[heart['sleep_label'] == 1].index)<br/><br/>subset = heart.iloc[np.unique(np.concatenate([np.arange(max(i-30,0), min(i-30+1, len(heart)))<br/>                                            for i in idx]))]<br/>subset = subset[subset.sleep_label == 0]<br/>heart['tired_label'] = pd.Series(heart.date.isin(subset.date).values.astype(int))</span><span id="5ef9" class="no ms iq oa b gy oi of l og oh">#cleaning the final labels into numerical values<br/>heart['label'] = pd.Series()<br/>heart['label'][heart.tired_label == 1] = 2<br/>heart['label'][heart.sleep_label == 1] = 1<br/>heart['label'] = heart['label'].fillna(0)<br/>heart = heart.dropna()</span></pre><h2 id="3616" class="no ms iq bd mt np nq dn mx nr ns dp nb lo nt nu nd ls nv nw nf lw nx ny nh iw bi translated"><strong class="ak">探索数据</strong></h2><p id="f198" class="pw-post-body-paragraph lf lg iq lh b li nj ka lk ll nk kd ln lo nl lq lr ls nm lu lv lw nn ly lz ma ij bi translated">我们现在可以开始更详细地查看我们的数据集。让我们从导入有用的库开始。这是一个很好的主意，我们可以将一些标记的心率数据可视化，这样<em class="mn">我们就可以</em> <em class="mn">了解每一类心率是如何变化的</em>:</p><pre class="kp kq kr ks gt nz oa ob oc aw od bi"><span id="b26c" class="no ms iq oa b gy oe of l og oh">import pandas as pd<br/>import numpy as np<br/>from sklearn.model_selection import train_test_split<br/>from tensorflow import keras<br/>import matplotlib.pyplot as plt<br/>import scipy.stats as stats<br/>import seaborn as sns<br/>from tensorflow.keras import backend as K<br/>from keras.layers import Dense, Dropout</span><span id="c190" class="no ms iq oa b gy oi of l og oh">sns.set(rc={"figure.figsize":(30, 8)})<br/>sns.scatterplot(x = df.index, y = df['heart_value'][:1500], hue = df.label, palette = 'Spectral')<br/>plt.xlabel("Heart Rate (BPM)")<br/>plt.ylabel("Time (Minutes)")<br/>plt.show()</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oj"><img src="../Images/58e83b067c2255706c7d1c9a9ed28190.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wzd0cCc3fZ_aSGA839jbSQ.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">按状态着色的心率数据(BPM)时间序列图。</p></figure><p id="2656" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我们可以清楚地看到<strong class="lh ja">心率在睡眠和清醒之间变化</strong>。标记为“疲劳”的心率值是过渡性的，因此不太明显，这将使我们的建模变得有趣。尽管缩短了面试时间，我们仍然有一个需要稍后解决的班级不平衡问题。</p><p id="e2dd" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">查看每类心率值的分布也是一个好主意:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ok"><img src="../Images/c9e2dee55165be3236e3c4f9ed3e2159.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8N0aW48u6NNAVGkE8Dx_eQ.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">比较不同类别心率分布的直方图</p></figure><p id="5e7d" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">并查看他们的汇总统计数据:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ol"><img src="../Images/8bf9288fdd5c7aab279f5a5e7a3a2d48.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QF481_h5AmgbUaDLGdv47Q.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">每类心率数据汇总表</p></figure><p id="fec4" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">在这种情况下，<strong class="lh ja"> 0是醒着的，1是睡着的，2是累着的</strong>。“疲劳”类具有与“睡眠”类相似的平均值，然而具有与“清醒”类相似的标准差。这与我们通过观察心率时间序列得出的第一轮观察结果相呼应。</p><h2 id="4afe" class="no ms iq bd mt np nq dn mx nr ns dp nb lo nt nu nd ls nv nw nf lw nx ny nh iw bi translated"><strong class="ak">序列预处理</strong></h2><p id="9d7e" class="pw-post-body-paragraph lf lg iq lh b li nj ka lk ll nk kd ln lo nl lq lr ls nm lu lv lw nn ly lz ma ij bi translated">现在让我们把数据分成固定长度的序列。<strong class="lh ja">我们的序列将是30分钟</strong>长，以符合我们的疲劳间歇的长度。我们还需要拆分我们的数据:</p><pre class="kp kq kr ks gt nz oa ob oc aw od bi"><span id="818f" class="no ms iq oa b gy oe of l og oh">def create_dataset(X, y, time_steps, step):</span><span id="8f7e" class="no ms iq oa b gy oi of l og oh">Xs, ys = [], []</span><span id="19d9" class="no ms iq oa b gy oi of l og oh">   for i in range(0, len(X) - time_steps, step):<br/>v = X.iloc[i:(i + time_steps)].values<br/>labels = y.iloc[i: i + time_steps]<br/>Xs.append(v)<br/>ys.append(stats.mode(labels)[0][0])<br/>   return np.array(Xs), np.array(ys).reshape(-1, 1)</span><span id="6903" class="no ms iq oa b gy oi of l og oh">interval = 30<br/>X_train_full, y_train_full = create_dataset(x1, y1, 1, interval)</span><span id="20e5" class="no ms iq oa b gy oi of l og oh">X_train, X_test, y_train, y_test = train_test_split(X_train_full, y_train_full, test_size=0.05, stratify = y_train_full, random_state=42, shuffle = True)</span></pre><p id="37ba" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我们可以使用Keras将我们的标签转换为编码类别，并进一步分割我们的数据集，这样我们就有了单独的训练集(76%)、验证集(19%)和测试集(5%)…事后回想起来，这是一个相当奇怪的分割:</p><pre class="kp kq kr ks gt nz oa ob oc aw od bi"><span id="a24c" class="no ms iq oa b gy oe of l og oh">y_train1 = keras.utils.to_categorical(y_train, num_classes = None)<br/>y_test1 = keras.utils.to_categorical(y_test, num_classes = None)</span><span id="9190" class="no ms iq oa b gy oi of l og oh">X_train = X_train.astype(np.float32)<br/>y_train1 = y_train1.astype(np.float32)</span><span id="ac91" class="no ms iq oa b gy oi of l og oh">#making the validation set separately<br/>X_train, X_val, y_train1, y_val = train_test_split(X_train, y_train1, test_size=0.2, stratify = y_train1, random_state=42, shuffle = True)</span></pre><p id="e2af" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我们在<em class="mn"> train_test_split() </em>中使用“分层”参数，以便我们的标签按比例分配给每个类。为了帮助解决类别不平衡，我们将使用<strong class="lh ja">类别权重</strong>，其中我们的模型将比其他类别对正确的“疲劳”预测赋予更高的权重。权重将与数据集中的观测值数量成比例:</p><pre class="kp kq kr ks gt nz oa ob oc aw od bi"><span id="3df2" class="no ms iq oa b gy oe of l og oh">class_weight = {3: 1., 1: 1., 2: int((sum(y_train1.iloc[:,0]) + sum(y_train1.iloc[:,2])) / sum(y_train1.iloc[:,1]))}</span></pre><p id="ddc9" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">在这种情况下，与醒着或睡着时相比，我们的“疲劳”类有<strong class="lh ja">13倍多的重量</strong>。由于这是一个<strong class="lh ja">多类序列分类</strong>，我们将使用F1分数来衡量准确性。可以在<a class="ae le" href="https://neptune.ai/blog/implementing-the-macro-f1-score-in-keras" rel="noopener ugc nofollow" target="_blank"> <strong class="lh ja">这里</strong> </a>找到这方面的有用指南以及Keras实现的代码。</p><h2 id="ef9e" class="no ms iq bd mt np nq dn mx nr ns dp nb lo nt nu nd ls nv nw nf lw nx ny nh iw bi translated"><strong class="ak">模型构建</strong></h2><p id="56f2" class="pw-post-body-paragraph lf lg iq lh b li nj ka lk ll nk kd ln lo nl lq lr ls nm lu lv lw nn ly lz ma ij bi translated">最后走上模型建筑。如前所述<strong class="lh ja">我们将使用GRU模式</strong> l，因为它的<strong class="lh ja">更快</strong>来训练。我们如下使用<strong class="lh ja"> Keras </strong>建立一个模型，确保添加漏失层以最小化过度拟合，并将输出序列从一个GRU传递到下一个。我们的GRU层将从32个单位开始，这些单位将在连续的层中增加。我们使用一个<strong class="lh ja"> Adam </strong>优化器，将激活设置为<strong class="lh ja"> softmax </strong>(因为我们有多个类)并测量<strong class="lh ja">交叉熵损失</strong>:</p><pre class="kp kq kr ks gt nz oa ob oc aw od bi"><span id="9431" class="no ms iq oa b gy oe of l og oh">def create_gru_model(unit):<br/>  inputs = keras.Input(shape=(X_train.shape[1],X_train.shape[2]))<br/>  x = layers.GRU(unit*1, activation='tanh', return_sequences=True)  (inputs)<br/>  x = layers.Dropout(0.25)(x)<br/>  x = layers.GRU(unit*2, activation='tanh', return_sequences=True)(x)<br/>  x = layers.Dropout(0.25)(x)<br/>  x = layers.GRU(unit*2, activation='tanh', return_sequences=True)(x)<br/>  x = layers.Dropout(0.25)(x)<br/>  x = layers.GRU(unit*3, activation='tanh')(x)</span><span id="f2ae" class="no ms iq oa b gy oi of l og oh">outputs = layers.Dense(y_train1.shape[1], activation="softmax")(x)<br/>model = keras.Model(inputs, outputs)</span><span id="84a5" class="no ms iq oa b gy oi of l og oh">opt = keras.optimizers.Adam(learning_rate=1e-3)<br/>model.compile(loss='categorical_crossentropy', optimizer= opt, metrics=[custom_f1])</span><span id="1091" class="no ms iq oa b gy oi of l og oh">  return model</span><span id="6bef" class="no ms iq oa b gy oi of l og oh">model_2 = create_gru_model(32)<br/>history2 = model_2.fit(X_train, y_train1, validation_data = (X_val, y_val), epochs = 200, batch_size = 256, shuffle= False, class_weight=class_weight)</span></pre><p id="5f89" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">经过200次训练和验证后，我们可以看到F1分数和模型损失:</p><pre class="kp kq kr ks gt nz oa ob oc aw od bi"><span id="b269" class="no ms iq oa b gy oe of l og oh">sns.set(rc={"figure.figsize":(12, 12)})<br/>plt.plot(history2.history['custom_f1'])<br/>plt.plot(history2.history['val_custom_f1'])<br/>plt.ylabel('F1 Score')<br/>plt.xlabel('Epoch')<br/>plt.legend()<br/>plt.show()</span><span id="d193" class="no ms iq oa b gy oi of l og oh">plt.plot(history2.history['loss'])<br/>plt.plot(history2.history['val_loss'])<br/>plt.ylabel('Loss')<br/>plt.xlabel('Epoch')<br/>plt.legend()<br/>plt.show()</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi om"><img src="../Images/557c54c2d87e7fe68333ad7b0e378a2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-FS1nutqAO9GbR0t3moGcw.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">200个时期后的模型损失和F1分数</p></figure><p id="7372" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">超过0.95 的最终确认分数看起来相当不错。最后，我们将对我们的测试集进行预测，并在混淆矩阵中评估结果。我们需要使用np.argmax()来帮助我们处理多个类:</p><pre class="kp kq kr ks gt nz oa ob oc aw od bi"><span id="38f4" class="no ms iq oa b gy oe of l og oh">y_pred = np.argmax(model_2.predict(X_test), axis=1)<br/>y_pred = np.expand_dims(y_pred, axis=-1)</span><span id="a3b0" class="no ms iq oa b gy oi of l og oh">from sklearn.metrics import plot_confusion_matrix<br/>matrix = confusion_matrix(y_test, y_pred)</span><span id="bd9b" class="no ms iq oa b gy oi of l og oh">sns.heatmap(matrix, annot=True, fmt=’g’, yticklabels= [ ‘Awake’, ‘Asleep’, ‘Tired’], xticklabels= [ ‘Awake’, ‘Asleep’, ‘Tired’])</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi on"><img src="../Images/d6ff9f3c1bc2d87fc0c2dd6f8ff205df.png" data-original-src="https://miro.medium.com/v2/resize:fit:644/format:webp/1*XEx9V7T7bXetxabKYWQq3w.png"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">不可见测试数据集上的混淆矩阵</p></figure><p id="1720" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">看起来大多数类都被正确预测了。我们看到疲劳和清醒之间的一些不正确的分类，这可以从我们之前看到的均值和直方图中理解。</p><h2 id="4bd3" class="no ms iq bd mt np nq dn mx nr ns dp nb lo nt nu nd ls nv nw nf lw nx ny nh iw bi translated"><strong class="ak">总结/后续步骤</strong></h2><p id="569f" class="pw-post-body-paragraph lf lg iq lh b li nj ka lk ll nk kd ln lo nl lq lr ls nm lu lv lw nn ly lz ma ij bi translated">我们采用了心率数据的单变量时间序列，结合从睡眠数据中获得的标签，<strong class="lh ja">来创建一个序列分类模型，能够判断我们何时处于睡眠、清醒或疲劳状态</strong>。我们的模型表现良好，但也许还有其他方面需要考虑:</p><ul class=""><li id="0501" class="oo op iq lh b li lj ll lm lo oq ls or lw os ma ot ou ov ow bi translated">对于二元序列分类，模型表现如何(即累/不累)？</li><li id="d6b2" class="oo op iq lh b li ox ll oy lo oz ls pa lw pb ma ot ou ov ow bi translated">衡量行走步数的数据有助于区分清醒和疲劳吗(假设疲劳时身体活动减少)？</li><li id="3940" class="oo op iq lh b li ox ll oy lo oz ls pa lw pb ma ot ou ov ow bi translated">如果我们延长时间间隔来记录我们醒来时的疲劳程度，与“晚间疲劳”相比，看起来是相同还是不同？</li></ul><p id="20cf" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">还有很多事情要做和探索，我会让你了解我的进展。感谢阅读！</p><p id="6de2" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated"><em class="mn">注意:本文并不声称预测或预防与疲劳相关的事故，仅应作为数据科学学习练习来阅读和使用。</em></p></div></div>    
</body>
</html>