<html>
<head>
<title>Huffman Decoding</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">霍夫曼解码</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/huffman-decoding-cca770065bab?source=collection_archive---------11-----------------------#2021-08-12">https://towardsdatascience.com/huffman-decoding-cca770065bab?source=collection_archive---------11-----------------------#2021-08-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1aa8" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">解压缩您的霍夫曼编码数据，以获得您的初始数据</h2></div><p id="751f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们已经在<a class="ae le" href="https://medium.com/data-structures-and-algorithms-with-python/huffman-encoding-python-implementation-8448c3654328" rel="noopener">霍夫曼编码&amp; Python实现</a>帖子中看到了如何使用霍夫曼编码对给定数据进行编码。现在我们将研究如何解码霍夫曼编码的数据，以再次获得初始的未压缩数据。</p><p id="b61d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有了我们在编码阶段获得的二进制霍夫曼树，解码是一个非常简单的过程。</p><p id="2d30" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们考虑我们有与霍夫曼编码post相同的例子，因此我们有AAAAAAABCCCCCCDDEEEEE作为我们的初始数据，000000000000110101010101110110101010101010101010101010101010作为具有以下霍夫曼树的编码输出:</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi lf"><img src="../Images/b10d0006d507ade333ea3af53f0d5be9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1202/format:webp/1*cjjRCN5zq9w04bpjZOxBbw.png"/></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">“作者提供的图像”</p></figure><p id="9f84" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在我们唯一要做的就是从哈夫曼树的头部开始，从编码数据的开始，每次我们遇到1就向右走，遇到0就向左走，穿过哈夫曼树。当我们到达一个叶节点时，我们获得符号！然后，我们只是从哈夫曼树的头部重新开始，同时向前移动编码数据。</p><p id="47aa" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">通过在huffman.py中添加几行来自<a class="ae le" href="https://medium.com/data-structures-and-algorithms-with-python/huffman-encoding-python-implementation-8448c3654328" rel="noopener"> Huffman编码&amp; Python实现</a>的代码，我们可以轻松实现Huffman_Decoding，结果如下:</p><pre class="lg lh li lj gt lr ls lt lu aw lv bi"><span id="3b49" class="lw lx it ls b gy ly lz l ma mb">def Huffman_Decoding(encoded_data, huffman_tree):<br/>    tree_head = huffman_tree<br/>    decoded_output = []<br/>    for x in encoded_data:<br/>        if x == '1':<br/>            huffman_tree = huffman_tree.right   <br/>        elif x == '0':<br/>            huffman_tree = huffman_tree.left<br/>        try:<br/>            if huffman_tree.left.symbol == None and huffman_tree.right.symbol == None:<br/>                pass<br/>        except AttributeError:<br/>            decoded_output.append(huffman_tree.symbol)<br/>            huffman_tree = tree_head<br/>        <br/>    string = ''.join([str(item) for item in decoded_output])<br/>    return string</span></pre><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi mc"><img src="../Images/260df81d82d2be71f21e649f29aeecc3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1394/format:webp/1*_wPevX67mmL-z4Iqpyrqcw.png"/></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">“作者提供的图像”</p></figure><p id="a2c4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一切似乎都没问题！可以查看<a class="ae le" href="https://github.com/YCAyca/Data-Structures-and-Algorithms-with-Python/tree/main/Huffman_Encoding" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu"> github </strong> </a> <strong class="kk iu"> </strong>链接到达代码，自己试试💁</p><p id="fbb3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">数据压缩是许多应用的主题，除了“基于频率”的霍夫曼算法之外，它还有各种不同类型的算法。你可以检查“基于字典”的方法，如LZ77·LZ78<strong class="kk iu">LZW</strong>对图像压缩特别有用。</p><p id="703f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你想进一步了解霍夫曼，你可以搜索一下<strong class="kk iu">自适应霍夫曼</strong>编码和解码，这是一种更新更复杂的数据压缩算法，以霍夫曼算法<strong class="kk iu">为基础，在编码的同时更新霍夫曼树</strong>，不像传统的霍夫曼编码是一步一步进行的🍀</p></div></div>    
</body>
</html>