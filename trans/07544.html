<html>
<head>
<title>Process Mining to assess app user behavior from clickstream data</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从点击流数据中评估应用用户行为的流程挖掘</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/process-mining-to-assess-app-user-behavior-from-clickstream-data-8e53a71428a4?source=collection_archive---------9-----------------------#2021-07-10">https://towardsdatascience.com/process-mining-to-assess-app-user-behavior-from-clickstream-data-8e53a71428a4?source=collection_archive---------9-----------------------#2021-07-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="df36" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">对pm4py python库的深入介绍</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c2fd0c9ed3062c7f6a89c86a26f5e14f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*72vanaofeGdPPYRm.jpg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由<a class="ae ky" href="https://pixabay.com/users/geralt-9301/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=1087845" rel="noopener ugc nofollow" target="_blank"> Gerd Altmann </a>从<a class="ae ky" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=1087845" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>拍摄</p></figure><p id="139f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不久前，我写了一篇<a class="ae ky" rel="noopener" target="_blank" href="/using-bigquery-firebase-analytics-to-engage-attract-and-assess-your-app-users-da02980daffa">文章</a>，描述了一些有用的查询，人们可以对点击流事件的数据进行查询，以收集一些可操作的见解。这篇文章可以被认为是它的自然继任者，因为(a)我们将在类似的数据集(点击流)上工作，以及(b)具有相同的潜在动机(收集一些见解)。然而，我们将从应用程序上的<code class="fe lv lw lx ly b">maximum_time_spent</code>和<code class="fe lv lw lx ly b">most_played_podcasts</code>等原始分析转向更全面的相关流程视图——从用户打开应用程序开始，到收听、评级、分享，最后关闭/卸载应用程序。</p><h2 id="2df3" class="lz ma it bd mb mc md dn me mf mg dp mh li mi mj mk lm ml mm mn lq mo mp mq mr bi translated">流程挖掘</h2><blockquote class="ms mt mu"><p id="ba6e" class="kz la mv lb b lc ld ju le lf lg jx lh mw lj lk ll mx ln lo lp my lr ls lt lu im bi translated">流程挖掘可以被认为是用户在你的应用上做什么的可视化描述。</p></blockquote><p id="e128" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">流程挖掘可以用来描绘用户如何在应用程序中导航的画面。它可用于指向:</p><ul class=""><li id="17db" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated">主要的棘手问题包括应用程序安装和用户参与播客应用程序之间的长时间延迟，</li><li id="7dc3" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">可以提高效率的流程，例如优化购物应用程序中的结账体验，</li><li id="6f8f" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">经常被触发的事件，例如紧随<em class="mv">播客下载</em>事件之后的<em class="mv">应用卸载</em>，</li></ul><p id="64c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">诸如此类…</p><p id="6669" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然有许多流程挖掘算法可供使用，其中一些在本文<a class="ae ky" rel="noopener" target="_blank" href="/introduction-to-process-mining-5f4ce985b7e5">中做了很好的总结，但是我们在</a><a class="ae ky" href="https://podurama.com/" rel="noopener ugc nofollow" target="_blank"> Podurama </a>的团队发现直接遵循Graph (DFG) &amp;启发式挖掘器(HM)最适合上面定义的用例。随后，这些就是我们将在本教程中重点关注的内容！</p><h2 id="907a" class="lz ma it bd mb mc md dn me mf mg dp mh li mi mj mk lm ml mm mn lq mo mp mq mr bi translated">直接跟随图表</h2><p id="b1a2" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">dfg是探索事件数据的很好的第一手段。它们背后的基本思想非常简单——它是一个图，节点对应于事件/活动，有向边对应于直接跟随关系。例如，连接事件<code class="fe lv lw lx ly b">e1</code>和<code class="fe lv lw lx ly b">e2</code>的边对应于观察到事件<code class="fe lv lw lx ly b">e1</code>紧接着事件<code class="fe lv lw lx ly b">e2</code>的<em class="mv">。连接两个事件的边可以用额外的信息来修饰，例如有多少实例沿着这条边被发现，或者每个实例从<code class="fe lv lw lx ly b">e1</code>到<code class="fe lv lw lx ly b">e2</code>花费的平均时间是多少。</em></p><h2 id="0fe8" class="lz ma it bd mb mc md dn me mf mg dp mh li mi mj mk lm ml mm mn lq mo mp mq mr bi translated">启发式挖掘器</h2><p id="09ea" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">HM是一种流行的流程挖掘算法，用于对事件流进行建模。与DFG的替代方案相比，HM试图找到事件遵循的规则。更具体地说，该算法能够滤除异常边缘，甚至检测两个事件(如<code class="fe lv lw lx ly b">sleeping</code>和<code class="fe lv lw lx ly b">snoring</code>)何时同时发生。因此，这些在图<em class="mv">中没有联系，即使</em>在事件日志中一个可能直接跟随另一个。在某种程度上，HM更适合处理日志中的噪音，并找到公共的结构(两个活动之间的依赖)。</p><p id="2cae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看他们的行动吧！</p><p id="90de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="mv">注意:在我们开始编码之前，请确保已经使用</em> <code class="fe lv lw lx ly b"><em class="mv">pip install pm4py</em></code> <em class="mv">安装了pm4py库。</em></p><h1 id="43ad" class="ns ma it bd mb nt nu nv me nw nx ny mh jz nz ka mk kc oa kd mn kf ob kg mq oc bi translated">让我们直接进入编码..</h1><h2 id="da35" class="lz ma it bd mb mc md dn me mf mg dp mh li mi mj mk lm ml mm mn lq mo mp mq mr bi translated">装置</h2><pre class="kj kk kl km gt od ly oe of aw og bi"><span id="9b3f" class="lz ma it ly b gy oh oi l oj ok">import pm4py<br/>import pandas as pd<br/>import numpy as np<br/>from pm4py.objects.conversion.log import converter as log_converter<br/>from pm4py.objects.log.util import dataframe_utils<br/>from pm4py.algo.discovery.heuristics import algorithm as heuristics_miner<br/>from pm4py.algo.discovery.dfg import algorithm as dfg_discovery<br/>from pm4py.visualization.heuristics_net import visualizer as hn_visualizer<br/>from pm4py.visualization.dfg import visualizer as dfg_visualization</span></pre><h2 id="02d6" class="lz ma it bd mb mc md dn me mf mg dp mh li mi mj mk lm ml mm mn lq mo mp mq mr bi translated">日常数据集</h2><p id="dc94" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">在我们看到实际数据集上的结果之前，我将使用一个(非常)小的虚拟事件数据集，因为我希望能够显示每个阶段的中间输出。如果你想跟着去，这里有一本<a class="ae ky" href="https://github.com/V-Sher/ProcessMining" rel="noopener ugc nofollow" target="_blank"> Jupyter笔记本</a>。</p><p id="dded" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="mv">注意:请随意用您选择的数据集替换虚拟数据集，只要它遵循我们稍后将讨论的命名约定。</em></p><pre class="kj kk kl km gt od ly oe of aw og bi"><span id="2f1d" class="lz ma it ly b gy oh oi l oj ok">dummy = pd.DataFrame(np.array([</span><span id="e23f" class="lz ma it ly b gy ol oi l oj ok">['A', '06/10/2021' , 'waking' ],<br/>['A', '06/11/2021' , 'eating'],<br/>['A', '06/12/2021' , 'sleeping'],<br/>['B', '06/12/2021' , 'waking'],<br/>['B', '06/13/2021' , 'eating'],<br/>['B', '06/14/2021' , 'sleeping'],<br/>['C', '06/06/2021' , 'waking'], <br/>['C', '06/11/2021' , 'sleeping'],<br/>['C', '06/12/2021' , 'eating'],<br/>['D', '06/15/2021' , 'eating'],<br/>['D', '06/16/2021' , 'eating'],<br/>['E', '06/15/2021' , 'eating'],<br/>['E', '06/26/2021' , 'eating'],<br/>['F', '06/11/2021' , 'waking'],<br/>['F', '06/15/2021' , 'sleeping']]),</span><span id="e451" class="lz ma it ly b gy ol oi l oj ok">columns=['case:concept:name', 'time:timestamp', 'concept:name'])</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi om"><img src="../Images/820db1e8cde7d0a59251ded5537c7cb2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5OYFWBZkDxm_MjwkK0dAnA.png"/></div></div></figure><p id="df40" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它包含三个主栏— <code class="fe lv lw lx ly b">case:concept:name</code>、<code class="fe lv lw lx ly b">time:timestamp</code>和<code class="fe lv lw lx ly b">concept:name</code>。这些分别对应于用户名、时间戳和事件类型。为简单起见，我们将处理六个用户— <code class="fe lv lw lx ly b">A</code> : <code class="fe lv lw lx ly b">F</code>和三种事件类型，即<code class="fe lv lw lx ly b">waking</code>、<code class="fe lv lw lx ly b">eating</code>和<code class="fe lv lw lx ly b">sleeping</code>。</p><p id="bdc8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在您可能想知道— <em class="mv">为什么要使用神秘的列名！为什么不简单地分别命名为“用户标识”、“时间戳”和“事件类型”?简短的回答是——因为pm4py喜欢那样。如果您的列有不同的名称，我强烈建议在进行进一步分析之前重命名它们。</em></p><p id="f145" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">需要记住的另一件重要事情是时间戳列应该遵循<code class="fe lv lw lx ly b">MM/DD/YYYY</code>格式。也就是说，用户<code class="fe lv lw lx ly b">A</code>决定在6月10日<code class="fe lv lw lx ly b">wake</code>起床，然后在6月11日<code class="fe lv lw lx ly b">eat</code>起床，接着在6月12日<code class="fe lv lw lx ly b">sleep</code>起床。原因是——pm4py对数据集中的时间戳列进行了一些预处理，从而自动转换为<code class="fe lv lw lx ly b">YYYY-MM-DD HH:MM:SS+MS:MS</code>格式。为了让这个预处理正确工作，它期望日志中使用<code class="fe lv lw lx ly b">MM/DD/YYYY</code>格式。</p><pre class="kj kk kl km gt od ly oe of aw og bi"><span id="a05f" class="lz ma it ly b gy oh oi l oj ok">dummy = dataframe_utils.convert_timestamp_columns_in_df(dummy)<br/>dummy.head()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi on"><img src="../Images/362202591655ef7382b569e32e38a650.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h6iDLxEA2-bLgYb5O-nRxw.png"/></div></div></figure><p id="a562" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="mv">注意:不要认为pm4py会根据列中的值自动确定时间戳格式。它盲目地将所有内容转换为</em> <code class="fe lv lw lx ly b"><em class="mv">MM-DD-YYYY</em></code> <em class="mv">格式，这可能会导致一些时间戳被错误地转换！</em></p><h1 id="2166" class="ns ma it bd mb nt nu nv me nw nx ny mh jz nz ka mk kc oa kd mn kf ob kg mq oc bi translated">直接跟随图表</h1><pre class="kj kk kl km gt od ly oe of aw og bi"><span id="6da9" class="lz ma it ly b gy oh oi l oj ok">log = log_converter.apply(dummy)<br/>variant=dfg_visualization.Variants.FREQUENCY<br/>dfg = dfg_discovery.apply(log)</span><span id="5567" class="lz ma it ly b gy ol oi l oj ok">gviz = dfg_visualization.apply(dfg, log=log, variant=variant)</span><span id="726d" class="lz ma it ly b gy ol oi l oj ok"># display viz<br/>dfg_visualization.view(gviz)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/96dd5ff2bd56bf8760597e58cb3401d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:768/format:webp/1*ieG23CRvk0E1qh4yziyoAg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="93fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">左边的DFG有几件事需要注意:</p><ul class=""><li id="42ca" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated">这些框表示事件类型，并遵循基于框内值的热图颜色。</li><li id="b3d3" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">方框内的值指示数据集中有多少行包含该特定事件。例如，event_type = <code class="fe lv lw lx ly b">waking</code>在<code class="fe lv lw lx ly b">dummy</code>数据集中出现了四次(在第0、3、6和13行)。</li><li id="b2ac" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">箭头/边上的数字表示<em class="mv">频率</em>，即该特定有向边观察到多少个实例。例如，围绕<code class="fe lv lw lx ly b">eating</code>的边缘刻有<code class="fe lv lw lx ly b">2</code>的循环指的是来自用户D和e的两个实例。类似地，在日志中只有一个实例，我们观察到一个<code class="fe lv lw lx ly b">sleeping</code>事件后跟一个<code class="fe lv lw lx ly b">eating</code>事件，即来自用户<code class="fe lv lw lx ly b">C</code>。最后，箭头越亮，意味着沿着这条路径找到的实例越多。</li></ul><p id="f550" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意:请记住<strong class="lb iu">而非</strong>的频率并不对应于遵循该路径的唯一用户数量。换句话说，如果我们在日志中为用户<code class="fe lv lw lx ly b">D</code>增加了两行数据，那么:</p><pre class="kj kk kl km gt od ly oe of aw og bi"><span id="16ba" class="lz ma it ly b gy oh oi l oj ok">dummy = pd.DataFrame(np.array([<br/>.<br/>.<br/>.<br/>['D', '06/16/2021' , 'eating'],<br/>['D', '06/16/2021' , 'eating'],<br/>.<br/>.<br/>.]),</span><span id="231d" class="lz ma it ly b gy ol oi l oj ok">columns=['case:concept:name', 'time:timestamp', 'concept:name'])</span></pre><p id="d46f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们创造了新的DFG，它会是这样的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi op"><img src="../Images/42e029f83d9363e5300f79a59bfa4faa.png" data-original-src="https://miro.medium.com/v2/resize:fit:712/format:webp/1*rj66zIBa6VhZ-6Jg4klWjw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="7978" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意围绕<code class="fe lv lw lx ly b">eating</code>的循环现在如何将频率值显示为4(而不是2 ),因为现在有4个<code class="fe lv lw lx ly b">eating</code>事件的实例，后面跟着另一个<code class="fe lv lw lx ly b">eating</code>事件，一个来自用户<code class="fe lv lw lx ly b">E</code>,三个来自用户<code class="fe lv lw lx ly b">D</code>。</p></div><div class="ab cl oq or hx os" role="separator"><span class="ot bw bk ou ov ow"/><span class="ot bw bk ou ov ow"/><span class="ot bw bk ou ov"/></div><div class="im in io ip iq"><p id="cd13" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您想在edges的顶部打印平均<strong class="lb iu">时间</strong>(而不是<strong class="lb iu">频率</strong>)，那么需要对代码进行一点修改，我们在<code class="fe lv lw lx ly b">apply</code>方法中引入一个名为<code class="fe lv lw lx ly b">variant</code>的参数，并将其值设置为<code class="fe lv lw lx ly b">PERFORMANCE</code>而不是<code class="fe lv lw lx ly b">FREQUENCY</code>:</p><pre class="kj kk kl km gt od ly oe of aw og bi"><span id="daac" class="lz ma it ly b gy oh oi l oj ok">log = log_converter.apply(dummy)<br/><strong class="ly iu">variant=dfg_visualization.Variants.PERFORMANCE<br/></strong>dfg = dfg_discovery.apply(log, <strong class="ly iu">variant=dfg_discovery.Variants.PERFORMANCE</strong>)</span><span id="7224" class="lz ma it ly b gy ol oi l oj ok">gviz = dfg_visualization.apply(dfg, log=log, variant=variant)</span><span id="d5d4" class="lz ma it ly b gy ol oi l oj ok"># display viz<br/>dfg_visualization.view(gviz)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ox"><img src="../Images/974f936a665f9b08c57433cb1f160a20.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/format:webp/1*sj3IVBx9ELhYrRQSQqlwNA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="0fd4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">produce树看起来与前面的树非常相似，但是，现在边对应于时间(以天<code class="fe lv lw lx ly b">D</code>和秒<code class="fe lv lw lx ly b">s</code>表示)。例如，根据DFG，刚吃完饭平均需要6天才能回到正餐，即<code class="fe lv lw lx ly b">eating-&gt;eating</code>(围绕<code class="fe lv lw lx ly b">event = eating</code>的循环)。让我们从<code class="fe lv lw lx ly b">dummy</code>数据集中验证这一点。</p><p id="4bf6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在那里，只找到了这个特定跟踪的两个实例(用户<code class="fe lv lw lx ly b">D</code>和<code class="fe lv lw lx ly b">E</code>各一个),分别花费了前一个用户一天的时间(6月15日-6月16日)和后十一天的时间(6月15日-6月26日)。平均花费的时间是(1+11 / 2) = 6天。</p><h2 id="1fe5" class="lz ma it bd mb mc md dn me mf mg dp mh li mi mj mk lm ml mm mn lq mo mp mq mr bi translated">dfg中的过滤边</h2><p id="2deb" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">有时候，你的DFG看起来会像一个意大利面条模型，尤其是当你要处理很多事情的时候。在这种情况下，我喜欢通过设置<code class="fe lv lw lx ly b">MAX_NO_EDGES_IN_DIAGRAM</code>参数来限制输出树中的边数。此外，通过分别设置<code class="fe lv lw lx ly b">START_ACTIVITIES</code>和<code class="fe lv lw lx ly b">END_ACTIVITIES</code>参数，根据事件日志标记开始和结束活动也是有用的。</p><pre class="kj kk kl km gt od ly oe of aw og bi"><span id="4e05" class="lz ma it ly b gy oh oi l oj ok">log = log_converter.apply(dummy)<br/><strong class="ly iu">_, start_activities, end_activities = pm4py.discover_dfg(log)</strong><br/>variant=dfg_visualization.Variants.FREQUENCY<strong class="ly iu"><br/></strong>dfg = dfg_discovery.apply(log)</span><span id="e084" class="lz ma it ly b gy ol oi l oj ok"><strong class="ly iu">parameters = {<br/>dfg_visualization.Variants.FREQUENCY.value.Parameters.MAX_NO_EDGES_IN_DIAGRAM: 3,</strong>    </span><span id="9758" class="lz ma it ly b gy ol oi l oj ok"><strong class="ly iu">dfg_visualization.Variants.FREQUENCY.value.Parameters.START_ACTIVITIES: start_activities,</strong></span><span id="dcf5" class="lz ma it ly b gy ol oi l oj ok"><strong class="ly iu">dfg_visualization.Variants.FREQUENCY.value.Parameters.END_ACTIVITIES: end_activities<br/>}</strong></span><span id="3134" class="lz ma it ly b gy ol oi l oj ok">gviz = dfg_visualization.apply(dfg, log=log, variant=variant, <strong class="ly iu">parameters= parameters</strong>)</span><span id="b283" class="lz ma it ly b gy ol oi l oj ok">dfg_visualization.view(gviz)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oy"><img src="../Images/105b907fdc04d71144e49d50320191c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*Cbs_b5DttznAsfYzy-AxKw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="318d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如你所看到的，我们已经成功地去除了一些混乱，只保留了那些权重最高的边。还有两个额外的节点—绿色和橙色。这些圆圈分别对应于流程流的开始和结束状态。这些可以解释为—观察到4个实例，其中<code class="fe lv lw lx ly b">waking</code>是第一个调用的事件。查看<code class="fe lv lw lx ly b">dummy</code>数据集，我们可以验证这对于用户<code class="fe lv lw lx ly b">A</code>、<code class="fe lv lw lx ly b">B</code>、<code class="fe lv lw lx ly b">C</code>和<code class="fe lv lw lx ly b">F</code>都成立。</p><p id="c7c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="mv">记住:尽管上图中看起来可能有3条以上的边，但请注意来自</em>  <em class="mv"> </em> <code class="fe lv lw lx ly b"><em class="mv">start_activity</em></code> <em class="mv">的所有边</em> <strong class="lb iu"> <em class="mv">和进入</em> </strong> <em class="mv"> </em> <code class="fe lv lw lx ly b"><em class="mv">end_activity</em></code> <em class="mv">的所有边都被排除在过滤过程之外。排除它们，我们可以确认只存在3条边:</em> <code class="fe lv lw lx ly b"><em class="mv">waking-&gt;eating</em></code> <em class="mv">、</em> <code class="fe lv lw lx ly b"><em class="mv">waking-&gt;sleeping</em></code> <em class="mv">和</em> <code class="fe lv lw lx ly b"><em class="mv">eating-&gt;sleeping</em></code> <em class="mv">。</em></p><h1 id="743a" class="ns ma it bd mb nt nu nv me nw nx ny mh jz nz ka mk kc oa kd mn kf ob kg mq oc bi translated">启发式挖掘器</h1><p id="5f20" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">为了确定是否有可以为日常日志建模的事件流，让我们生成一个启发式网络。</p><pre class="kj kk kl km gt od ly oe of aw og bi"><span id="7501" class="lz ma it ly b gy oh oi l oj ok">log = log_converter.apply(dummy)<br/>heu_net = heuristics_miner.apply_heu(log)</span><span id="7b92" class="lz ma it ly b gy ol oi l oj ok">gviz = hn_visualizer.apply(heu_net)</span><span id="5187" class="lz ma it ly b gy ol oi l oj ok">hn_visualizer.view(gviz)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oz"><img src="../Images/57d67329de1bd4390a10f84c53a2bc60.png" data-original-src="https://miro.medium.com/v2/resize:fit:1156/format:webp/1*WemB-7NXWVdXK-dppGxYyQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="0464" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">启发式网络的输出可以用和DFG一样的方式来解释。正如前面介绍中所述，主要区别在于算法试图确定事件遵循的一些规则。它不仅考虑了边沿的<em class="mv">频率</em>，还考虑了边沿的<em class="mv">重要性</em>。如果你想知道显著性是如何计算的，公式和算法可以在<a class="ae ky" href="https://www.futurelearn.com/info/courses/process-mining/0/steps/15639" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><p id="0efe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据上述启发式网络，在典型的日常工作流程中，用户通过<code class="fe lv lw lx ly b">waking</code>或<code class="fe lv lw lx ly b">eating</code>开始他们的一天。在后一种情况下，这是他们在一天结束前唯一做的事情(橙色圆圈),而在前一种情况下，他们决定在完成日常工作前做<code class="fe lv lw lx ly b">sleep</code>或<code class="fe lv lw lx ly b">eat</code>。</p><p id="f0b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你仔细观察，该算法已经发现了这样一个事实，即<code class="fe lv lw lx ly b">sleeping</code>和<code class="fe lv lw lx ly b">eating</code>是并发活动，因此它们之间没有边。</p><h2 id="f4e3" class="lz ma it bd mb mc md dn me mf mg dp mh li mi mj mk lm ml mm mn lq mo mp mq mr bi translated">在HM中过滤边缘</h2><p id="4d09" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">HN经常变得太乱，无法提供任何有用的见解。在这种情况下，我们可以基于最小频率值，仅过滤并保留一些边，同时保持所有节点(正方形块)完好无损。例如，在上面的启发式网络中，为了只保留DFG出现次数至少为4的边，我们将引入<code class="fe lv lw lx ly b">MIN_DFG_OCCURRENCES</code>参数。由于只有一条边<code class="fe lv lw lx ly b">START-&gt;waking</code>带有权重为4或更大的箭头，这应该是输出HN图中出现的唯一的<em class="mv">边:</em></p><pre class="kj kk kl km gt od ly oe of aw og bi"><span id="d31c" class="lz ma it ly b gy oh oi l oj ok">log = log_converter.apply(dummy)<br/>heu_net = heuristics_miner.apply_heu(log, <strong class="ly iu">parameters={ heuristics_miner.Variants.CLASSIC.value.Parameters.MIN_DFG_OCCURRENCES: 4}</strong>)</span><span id="c0b4" class="lz ma it ly b gy ol oi l oj ok">gviz = hn_visualizer.apply(heu_net)</span><span id="1284" class="lz ma it ly b gy ol oi l oj ok">hn_visualizer.view(gviz)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pa"><img src="../Images/a64a19e8f1e3c9bc098ba99bf3d6b12b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n7rig6_a7M2-T02mtaPJgQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="2531" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然修剪边缘的好处在这个虚拟示例中无法直接观察到，但我发现它在现实世界的数据集中非常有用。仅当边缘超过特定阈值时才过滤边缘，这有助于理解意大利面条模型。让我们来看看实际播客事件数据集上的流程挖掘结果。</p><h1 id="ff48" class="ns ma it bd mb nt nu nv me nw nx ny mh jz nz ka mk kc oa kd mn kf ob kg mq oc bi translated">播客数据集</h1><p id="1403" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">在Podurama，我们有兴趣使用流程挖掘来解决两个特别有趣的问题— (a)用户流失，以及(b)冷启动推荐。对于前者，我们决定对安装后15天内离开应用程序的(大约4k)用户进行进程发现，看看我们是否可以得出一些见解。对于后者，我们使用活跃用户的日志生成了一个DFG，以直观地检查他们在特定流派中收听的播客流。</p><h2 id="a942" class="lz ma it bd mb mc md dn me mf mg dp mh li mi mj mk lm ml mm mn lq mo mp mq mr bi translated">用户流失</h2><p id="72b2" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">我们没有调查所有记录的事件，而是决定把重点放在主要的事件上，比如<code class="fe lv lw lx ly b">app_open</code>、<code class="fe lv lw lx ly b">search</code>、<code class="fe lv lw lx ly b">podcastseries_click</code>和<code class="fe lv lw lx ly b">app_remove</code>。</p><p id="8c53" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事件数据的前几行如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pb"><img src="../Images/e35e2e5e1efac0d3ddcdfe640e6fc855.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_jaU0vQ7yQQ_2IYpyzfnnw.png"/></div></div></figure><p id="30fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在不修剪边的情况下生成DFG会产生意大利面模型:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pc"><img src="../Images/efe3dd654b60c95ee391324c870b6045.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*toNfUPHd4Q3AgUy-TKGkmQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="9ba1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将最大边数设置为10后，我们观察到:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pd"><img src="../Images/082ea53c3c28da5bc23f47f5498f9103.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BIJaJCal31uJ280PqaNxsA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="e707" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">快速浏览一下，很明显存在大量重复使用搜索功能的情况。然而，即使许多用户都在搜索播客，即<em class="mv">搜索</em>事件(~ 31k)，但只有少数情况(~ 8k)是通过点击任何搜索结果直接跟随的，即<em class="mv">播客系列点击</em>事件。同样，我们观察到在应用程序已经打开(<em class="mv"> app_open </em>)之后，播放播客(<em class="mv"> playAudio) </em>的情况非常少(~ 6k)。</p><p id="4e01" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一个有趣的观察是(在最大边上过滤后)，我们在图中没有发现<code class="fe lv lw lx ly b">app_remove</code>事件，这意味着它不经常被触发。换句话说，没有多少用户明确卸载应用程序，而是在一段时间后停止登录应用程序。这可能表明需要一个及时的(非侵入性的)轻推来提醒人们使用我们的应用。</p><p id="d9ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一个值得注意的观察是关于到达流程流中的最终状态(橙色圆圈)。我们观察到大多数实例从<em class="mv"> playAudio </em>事件到达结束状态，很少从<em class="mv"> subscribePodcast </em>事件到达结束状态。这不太理想，因为这意味着用户在决定退出之前不会通过我们的应用程序订阅播客(这可能表明对我们的应用程序的长期承诺)，而是简单地浏览一下，看看它是否坚持下来！总的来说，我们的目标是让新用户在加入应用程序的第一周订阅至少10个播客，因为他们订阅的播客越多，他们继续使用应用程序收听他们订阅的播客的新发布剧集的机会就越高！</p><h2 id="7b97" class="lz ma it bd mb mc md dn me mf mg dp mh li mi mj mk lm ml mm mn lq mo mp mq mr bi translated">冷启动建议</h2><p id="4f70" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">虽然使用流行的python库肯定有更好的方法来解决推荐系统的冷启动问题，但我们决定使用dfg来可视化用户收听的播客。这背后的主要思想很简单——一旦我们知道一个用户收听了播客A，尝试并推荐来自相同流派的其他播客，基于在DFG具有最高频率的输出优势。</p><p id="fdf0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了简洁起见，我们过滤了日志，删除了用户暂停并在下一次继续播放相同播客的事件。这允许我们摆脱事件周围的循环(类似于我们看到的<code class="fe lv lw lx ly b">eating</code>事件)</p><p id="a50a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是真实犯罪类型的DFG奖:</p><pre class="kj kk kl km gt od ly oe of aw og bi"><span id="378f" class="lz ma it ly b gy oh oi l oj ok">mask = (~usr_podcast['concept:name'].isna()) &amp; (usr_podcast.genre == '<strong class="ly iu">True Crime</strong>')<br/>log = log_converter.apply(usr_podcast.loc[mask])</span><span id="8e8c" class="lz ma it ly b gy ol oi l oj ok">parameters = {<br/>dfg_visualization.Variants.FREQUENCY.value.Parameters.MAX_NO_EDGES_IN_DIAGRAM: 10<br/>}</span><span id="4b9c" class="lz ma it ly b gy ol oi l oj ok">variant=dfg_visualization.Variants.FREQUENCY<br/>dfg = dfg_discovery.apply(log)<br/>gviz = dfg_visualization.apply(dfg, parameters=parameters, variant=variant)</span><span id="ce8d" class="lz ma it ly b gy ol oi l oj ok"># display viz<br/>dfg_visualization.view(gviz)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pe"><img src="../Images/56ae78643c1e0e5a9d74a41bfcc5087f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZRpSNi4oLBuYbf0x9hfpOw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="597a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从上面的图表中，很明显有更多的例子表明<em class="mv">犯罪爱好者</em>是用户收听的第一个真实犯罪播客。这是可以理解的，因为我们在主页上为新加入的用户提供了建议。基于边缘权重(越黑越好)，似乎有相当多的情况下，用户在犯罪爱好者之后收听<em class="mv">案件档案真实犯罪</em>和<em class="mv">未破谋杀案</em>。这是一条有用的信息，因为现在，在我们数据库中的所有真实犯罪播客中，我们可以开始向观看历史有限的用户推荐这两个播客(以及其他类似于<em class="mv">我最喜欢的谋杀</em>和<em class="mv"/><em class="mv">一代为什么</em>)推荐系统可能不会为他们提供有用的推荐。</p><p id="6487" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为另一个不同类型的例子，这是DFG科技播客的样子:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pf"><img src="../Images/39b73badb7a4705bf4fb0719f81e7c01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RuN7NRiBygUiluwYZyH_Nw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure></div><div class="ab cl oq or hx os" role="separator"><span class="ot bw bk ou ov ow"/><span class="ot bw bk ou ov ow"/><span class="ot bw bk ou ov"/></div><div class="im in io ip iq"><h1 id="3651" class="ns ma it bd mb nt pg nv me nw ph ny mh jz pi ka mk kc pj kd mn kf pk kg mq oc bi translated">结论</h1><p id="ef9d" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">让用户参与到你的应用中是相当棘手的，尤其是当80-90%的应用在试用一周内被删除。从用户那里评估事件的顺序会给你一个新的视角，让你明白为什么这个应用对他们不起作用。调查也有帮助，但是对于那些刚刚使用你的应用一周的用户来说，可能会显得很烦人。</p><p id="6799" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">流程建模的内容比本文所涵盖的要多得多，但这应该给你一个良好的开端，让你开始分析你的事件日志，并收集有用的见解，以提高保留率。</p><p id="f987" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">直到下次:)</p></div></div>    
</body>
</html>