<html>
<head>
<title>Building a Product Recommendation System with your Sales Data</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用你的销售数据建立一个产品推荐系统</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/similar-product-recommendations-data-to-deployment-970a085bafce?source=collection_archive---------5-----------------------#2021-05-19">https://towardsdatascience.com/similar-product-recommendations-data-to-deployment-970a085bafce?source=collection_archive---------5-----------------------#2021-05-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/1879fb0f2cc9ed00aa5126c8e6f40534.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*lwWC64EDdhgrpVH2"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">约翰·福勒在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><h1 id="5542" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated"><strong class="ak">简介</strong></h1><p id="23ad" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">这是一篇分享我从头到尾实现一个产品推荐系统的帖子。我构建的推荐系统是基于条目-条目协同过滤的。我们将通过共生矩阵构建产品的多维向量表示，并通过所有产品向量之间的余弦相似性来寻找相似的产品。</p><p id="e71e" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">在应用方面，该系统旨在为电子商务产品提供产品推荐。例如，当客户点击某个产品时，大多数网站会显示一个产品详情页面(PDP)，通常您可能会在该页面上看到更多共享的产品，标题为“<em class="me">您可能也喜欢“</em>或<em class="me">“类似产品”</em>。</p><h1 id="31d3" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated"><strong class="ak">概念</strong></h1><p id="4b92" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated"><strong class="ld ir">同现矩阵</strong></p><p id="da2f" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">我不会深入到同现矩阵的细节，因为这是已经写了很多的东西。但是我将从概念上介绍共现矩阵是如何工作的，以及为什么我们可以使用它来创建类似产品的推荐系统。我们正在利用的数据只是客户订单数据，特别是我们感兴趣的是产品与其他产品一起购买的订单。</p><p id="1748" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated"><strong class="ld ir"> <em class="me">简化示例</em> </strong></p><p id="7c1e" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">在我们的简化示例中，我们在整个历史中只有两个订单:</p><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mf"><img src="../Images/8aaafcc151cdef0fc5fbfd561ea1592c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iP7z4tXuAffoprxf0m1Qng.png"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">作者图片</p></figure><p id="7f4c" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">我们有3个独特的项目，两个不同颜色的牙刷都是独立购买的牙膏。利用这些信息，我们能够通过牙膏建立从蓝色牙刷到绿色牙刷的桥梁。</p><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/298992fed21b0ec2a8f08fbbdf6c1b3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*ufFvjbccO_jB-jo63WtkGA.png"/></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">作者图片</p></figure><p id="11fb" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">现在想象一下，我们有成千上万的订单。你可能会认为两种颜色的牙刷都和牙线、漱口水等一起出现。我们可以利用这些产品的共现来构建目录中所有产品的多维向量表示。</p><p id="c437" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated"><strong class="ld ir">余弦相似度</strong></p><p id="01bf" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">为了确定一个产品是否与另一个产品相似，我们从我们的共现矩阵中获取它们的向量表示之间的余弦相似性，并得到-1和1之间的分数。分数为1表示向量方向相同，分数为-1表示向量方向相反。你可以在这里找到余弦相似度<a class="ae kc" href="https://en.wikipedia.org/wiki/Cosine_similarity" rel="noopener ugc nofollow" target="_blank">的细节。</a></p><h1 id="b36c" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">数据</h1><p id="5985" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">如前所述，我们的数据是客户订单数据。对于大多数数据集，您可能希望将一个订单级表连接到一个订单行级表，以便可以看到特定订单id中出现的所有项目。</p><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ml"><img src="../Images/50aa1d6a7e2acd7000def99853b78048.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KFJjTO3l4JfT19-bdYMP6A.png"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">作者图片</p></figure><h1 id="7a52" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">模型代码</h1><p id="5143" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated"><em class="me">库依赖:</em></p><pre class="mg mh mi mj gt mm mn mo mp aw mq bi"><span id="e2fb" class="mr ke iq mn b gy ms mt l mu mv">import pandas as pd<br/>import numpy as np<br/>import s3fs<br/>import json<br/>from sklearn.metrics.pairwise import cosine_similarity<br/>import datetime</span></pre><p id="338b" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">首先以上面的格式加载您的客户订单数据，作为名为<em class="me"> sales_df的pandas数据框。</em></p><p id="f15b" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">加载数据后，您需要将数据转换为每行是一个订单，每列是一个产品，值是每个订单中产品的数量。<em class="me">注意:pandas会自动将pivot中的数据类型更改为float64。如果你有内存方面的考虑，你可能想向下传输数据</em></p><pre class="mg mh mi mj gt mm mn mo mp aw mq bi"><span id="955c" class="mr ke iq mn b gy ms mt l mu mv">pivot_df = pd.pivot_table(sales_df,index = 'order_id',columns = 'product_id',values = 'category',aggfunc = 'count')</span><span id="921c" class="mr ke iq mn b gy mw mt l mu mv">pivot_df.reset_index(inplace=True)<br/>pivot_df = pivot_df.fillna(0)<br/>pivot_df = pivot_df.drop('order_id', axis=1)</span></pre><p id="f80e" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">接下来，我们通过获取数据透视表及其转置的点积，将数据透视表转换为共生矩阵。</p><pre class="mg mh mi mj gt mm mn mo mp aw mq bi"><span id="ca12" class="mr ke iq mn b gy ms mt l mu mv">co_matrix = pivot_df.T.dot(pivot_df)<br/>np.fill_diagonal(co_matrix.values, 0)</span></pre><p id="934c" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">为了将共现矩阵转换为我们产品之间的余弦相似度矩阵，我们利用了来自<em class="me"> sklearn </em>的<em class="me">余弦相似度</em>函数。</p><pre class="mg mh mi mj gt mm mn mo mp aw mq bi"><span id="8bc3" class="mr ke iq mn b gy ms mt l mu mv">cos_score_df = pd.DataFrame(cosine_similarity(co_matrix))<br/>cos_score_df.index = co_matrix.index<br/>cos_score_df.columns = np.array(co_matrix.index)</span></pre><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mx"><img src="../Images/fc1fbd582ac1d0b530aad02355aa7087.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wbkl8mONwsYj8tLlHDwwHQ.png"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">产品x产品余弦相似性得分</p></figure><h1 id="e1b4" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">模型验证</h1><p id="e5f5" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">与大多数无监督学习模型一样，模型验证可能很棘手。对于我们的数据集，我们有一组不同的产品类别。由于我们正在创建一个推荐器来显示类似的产品，我们应该期望我们的模型返回与原始基本产品在同一类别的推荐。</p><p id="61bb" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated"><strong class="ld ir"> <em class="me">针对每个产品类别:</em> </strong></p><p id="1201" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated"><em class="me">计数(类别中每个产品的最佳推荐)/计数(类别中的产品)= %相同类别中的推荐</em></p><p id="4271" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated"><strong class="ld ir"> <em class="me">举例:</em> </strong></p><p id="672c" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">我们为735种健康产品生成了建议，根据我们对每种健康产品的最佳余弦相似度，我们有720种建议属于健康类别，或98%的同类建议。有了如此高比例的同类推荐，我们可以更加自信地认为，我们的购买数据中有一个强大的信号来推动我们的模型。</p><p id="c8e9" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated"><strong class="ld ir">下一步</strong></p><p id="d4d9" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">从这里开始，一旦我们将模型的第一个版本推广到生产，并开始AB测试，模型验证将继续进行。迭代模型时的一些参数调整考虑事项将有一个余弦相似性得分阈值或样本大小阈值，以将建议限制在我们有最高置信度的范围内。</p><h1 id="dd55" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">部署</h1><p id="7f6f" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">我们的部署过程相当简单。我们将带有前n条建议的JSON文件输出到S3桶中。这个JSON文件然后被我们的平台工程团队提取出来，并加载到Postgres数据库中，该数据库将用于前端产品服务。</p><p id="398e" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated"><em class="me">得分最高的五个推荐和JSON输出:</em></p><pre class="mg mh mi mj gt mm mn mo mp aw mq bi"><span id="dd07" class="mr ke iq mn b gy ms mt l mu mv">#Take top five scoring recs that aren't the original product</span><span id="2f71" class="mr ke iq mn b gy mw mt l mu mv">product_recs = []<br/>for i in cos_score_df.index:<br/>    product_recs.append(cos_score_df[cos_score_df.index!=i][i].sort_values(ascending = False)[0:5].index)<br/>    <br/>product_recs_df = pd.DataFrame(product_recs)<br/>product_recs_df['recs_list'] = product_recs_df.values.tolist()<br/>product_recs_df.index = cos_score_df.index</span><span id="fa4e" class="mr ke iq mn b gy mw mt l mu mv">#Semi-colon delimited JSON Output</span><span id="ac11" class="mr ke iq mn b gy mw mt l mu mv">product_recs_df['json_out'] = product_recs_df['recs_list'].apply(lambda x: [str(element) for element in x])<br/>product_recs_df['json_out'] = product_recs_df['json_out'].apply(lambda x: ";".join(x))<br/>product_recs_dict = product_recs_df.to_dict()<br/>json_out = json.dumps(product_recs_dict['json_out'],indent = 4,ensure_ascii = False).encode('UTF-8')</span></pre><p id="3756" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated"><em class="me">将JSON输出到S3桶:</em></p><pre class="mg mh mi mj gt mm mn mo mp aw mq bi"><span id="51ff" class="mr ke iq mn b gy ms mt l mu mv">ts = datetime.datetime.now().strftime("%Y-%m-%d_%H-%M")</span><span id="15c7" class="mr ke iq mn b gy mw mt l mu mv">fs = s3fs.S3FileSystem(key=s3_key, secret=s3_value)<br/>with fs.open('s3://yourbucket/key'+ts+'.json', 'wb') as f:<br/>    f.write(bytes(json_out))</span></pre><h1 id="ba27" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">结论</h1><p id="4f04" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">因此，我们已经为类似产品创建了一个端到端的产品推荐系统，只需使用历史销售数据。对于所有模型，模型输出的质量将取决于数据的质量。一般来说，每种产品的订单样本越大越好；因为我们期望在较大的样本量下减少来自随机产品共现的噪声。要为您的模型找到正确的样本大小阈值，您可以在不同的样本阈值下评估模型验证指标<em class="me">(同一类别中建议的百分比)</em>，以查看在哪个阈值下评估指标开始出现有意义的下降。</p></div></div>    
</body>
</html>