<html>
<head>
<title>Detecting Heart Abnormalities Using 1D CNN on Data You Cannot See</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用1D有线电视新闻网在你看不到的数据上检测心脏异常</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/detecting-heart-abnormalities-using-1d-cnn-on-data-you-cannot-see-with-pysyft-735481a952d8?source=collection_archive---------9-----------------------#2021-10-03">https://towardsdatascience.com/detecting-heart-abnormalities-using-1d-cnn-on-data-you-cannot-see-with-pysyft-735481a952d8?source=collection_archive---------9-----------------------#2021-10-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="17bd" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用分裂神经网络和PySyft保护敏感训练数据隐私</h2></div><h1 id="2d21" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated"><strong class="ak">TL；博士:</strong></h1><p id="ffce" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我们能否应用分裂学习架构来训练1D CNN心跳数据模型，并在保护数据隐私的同时准确检测心脏异常？</p><h2 id="b0d5" class="lt kg iq bd kh lu lv dn kl lw lx dp kp lg ly lz kr lk ma mb kt lo mc md kv me bi translated">嗯，那还是太长了，而且字数便宜，给我看看代码就行了！</h2><p id="5543" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><a class="ae mf" href="https://github.com/khoaguin/priv-sec-ai-blog/blob/master/ecg-split-1DCNN-PySyft/ecg-split-1DCNN.ipynb" rel="noopener ugc nofollow" target="_blank">这里</a>你去吧。尽情享受吧！</p><h1 id="53ae" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">介绍</h1><p id="dab9" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><a class="ae mf" href="https://en.wikipedia.org/wiki/Machine_learning" rel="noopener ugc nofollow" target="_blank">机器学习(ML) </a>是人工智能的一个子领域，算法被训练从海量数据集中发现模式。然后，这些模式被用于对新数据进行决策和预测。ML今天面临的一个问题是数据共享:数据科学家需要从数据所有者那里收集大量数据，以便训练他们的算法。这通常并不理想，尤其是对于医疗保健或金融等行业的敏感数据。分裂学习是隐私保护机器学习(PPML)中试图解决这一数据隐私问题的方法之一。</p><p id="ec75" class="pw-post-body-paragraph kx ky iq kz b la mg jr lc ld mh ju lf lg mi li lj lk mj lm ln lo mk lq lr ls ij bi translated">分裂学习是指将深度神经网络(DNN)切割成两个或更多部分的过程。在最简单的场景中，即只有一个数据所有者(客户端)和一个数据科学家(服务器)，DNN被分成两部分。DNN的第一部分在数据驻留的客户机上使用，第二部分在服务器端使用。客户端的模型将从数据集中学习一组特征(也称为“激活图”)，然后将这些激活图发送到服务器以继续训练过程。然后，在向后传递期间，服务器计算损失函数和直到分离层的损失梯度，然后将这些梯度发送回客户端，以便他可以继续向后传递。这样，服务器/数据科学家永远不会看到输入的训练数据，但仍然可以训练网络。你可以从这个<a class="ae mf" href="https://blog.openmined.org/split-neural-networks-on-pysyft/" rel="noopener ugc nofollow" target="_blank">教程</a>中学到更多关于拆分学习的基础知识。</p><p id="d7a9" class="pw-post-body-paragraph kx ky iq kz b la mg jr lc ld mh ju lf lg mi li lj lk mj lm ln lo mk lq lr ls ij bi translated">在这篇博文中，我们将通过使用OpenMined的框架<a class="ae mf" href="https://github.com/OpenMined/PySyft" rel="noopener ugc nofollow" target="_blank"> PySyft来训练分裂神经网络的过程:这是一个Python库，用于计算你不拥有也看不到的数据</a>。在OpenMined的免费课程“<a class="ae mf" href="https://courses.openmined.org/courses/foundations-of-private-computation" rel="noopener ugc nofollow" target="_blank">私人计算基础</a>”中，已经有一个教程，介绍如何使用PySyft的Duet和两个Jupyter笔记本来训练分裂的DNN:一个代表客户端，另一个代表服务器。然而，如果你正在开发一种新的分割学习方法，使用两个笔记本是相当麻烦的，因为你必须来回切换。幸运的是，PySyft的另一个特性叫做VirtualMachine，它允许我们只在一个jupyter笔记本或python文件中开发一个分割DNN。今天我们将学习如何使用它，以及PySyft的其他特性，如RemoteDataset和RemoteDataLoader，来加载自定义远程数据集。最重要的是，我们将基于[1]的工作，发现如何训练一个分裂1D CNN神经网络来检测从不离开客户端机器的输入数据上的心脏异常。</p><h1 id="7aab" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">让我们开始吧</h1><p id="2e19" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">首先，我们需要导入必要的包并定义必要文件的路径。我用了<code class="fe ml mm mn mo b">torch 1.8.1+cu102</code>和<code class="fe ml mm mn mo b">syft 0.5.0.</code></p><figure class="mp mq mr ms gt mt"><div class="bz fp l di"><div class="mu mv l"/></div><p class="mw mx gj gh gi my mz bd b be z dk translated">用于导入包的代码(图片由作者提供)</p></figure><figure class="mp mq mr ms gt mt"><div class="bz fp l di"><div class="mu mv l"/></div><p class="mw mx gj gh gi my mz bd b be z dk translated">为数据导入设置训练和测试文件名(图片由作者提供)</p></figure><h2 id="1962" class="lt kg iq bd kh lu lv dn kl lw lx dp kp lg ly lz kr lk ma mb kt lo mc md kv me bi translated">定义客户端和服务器</h2><p id="c33e" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">使用PySyft的VirtualMachine，我们可以在这个场景中定义抽象参与者，如下面的代码所示。</p><figure class="mp mq mr ms gt mt"><div class="bz fp l di"><div class="mu mv l"/></div><p class="mw mx gj gh gi my mz bd b be z dk translated">定义服务器和客户端虚拟机(图片由作者提供)</p></figure><h2 id="659a" class="lt kg iq bd kh lu lv dn kl lw lx dp kp lg ly lz kr lk ma mb kt lo mc md kv me bi translated">客户端:加载和浏览数据集</h2><p id="fd3b" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">首先，让我们假设是客户端(数据所有者)并发现数据集。我们将使用<a class="ae mf" href="https://physionet.org/content/mitdb/1.0.0/" rel="noopener ugc nofollow" target="_blank">麻省理工学院-BIH心律失常</a>，这是一个用于ECG信号分类或心律失常诊断的流行数据集[2]。您可以在这里找到原始数据集<a class="ae mf" href="https://physionet.org/content/mitdb/1.0.0/" rel="noopener ugc nofollow" target="_blank">，但是，我们在这里</a>使用来自<a class="ae mf" href="https://github.com/SharifAbuadbba/split-learning-1D/blob/master/preprocess/ecg_preprocess.ipynb" rel="noopener ugc nofollow" target="_blank">的处理数据。下面是从<code class="fe ml mm mn mo b">train_ecg.hdf5</code>和<code class="fe ml mm mn mo b">test_ecg.hdf5</code>加载数据集所需的代码。</a></p><figure class="mp mq mr ms gt mt"><div class="bz fp l di"><div class="mu mv l"/></div><p class="mw mx gj gh gi my mz bd b be z dk translated">用于加载ECG数据集的类(图片由作者提供)</p></figure><p id="826e" class="pw-post-body-paragraph kx ky iq kz b la mg jr lc ld mh ju lf lg mi li lj lk mj lm ln lo mk lq lr ls ij bi translated">后处理数据集由总共26 490个心跳样本组成，每个样本是长度为128的时间序列向量。有5种不同类型的心跳作为分类目标:正常搏动(0类)、左束支传导阻滞(1类)、右束支传导阻滞(2类)、房性早搏(3类)、室性早搏(4类)。我们可以在下面的图1中看到每个类的例子。</p><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div class="gh gi na"><img src="../Images/47d25bbdf5d9fd56a9d20582460816ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:772/format:webp/1*Sp1NC1Z2OrJ8VEmhK32I5w.png"/></div><p class="mw mx gj gh gi my mz bd b be z dk translated">图1:心电图数据集中的一些例子(图片由作者提供)</p></figure><p id="2e10" class="pw-post-body-paragraph kx ky iq kz b la mg jr lc ld mh ju lf lg mi li lj lk mj lm ln lo mk lq lr ls ij bi translated">然后，客户端加载数据集，保存到<code class="fe ml mm mn mo b">.pt</code>文件中，并使用下面的代码将它们发送到服务器。</p><figure class="mp mq mr ms gt mt"><div class="bz fp l di"><div class="mu mv l"/></div><p class="mw mx gj gh gi my mz bd b be z dk translated">客户端创建数据集并保存到<code class="fe ml mm mn mo b">.pt</code>文件中(图片由作者提供)</p></figure><p id="612b" class="pw-post-body-paragraph kx ky iq kz b la mg jr lc ld mh ju lf lg mi li lj lk mj lm ln lo mk lq lr ls ij bi translated">如果使用<code class="fe ml mm mn mo b">duet</code>，他可以用这个语法向服务器发送字符串路径(注意，这次我们没有使用<code class="fe ml mm mn mo b">duet</code>)</p><figure class="mp mq mr ms gt mt"><div class="bz fp l di"><div class="mu mv l"/></div><p class="mw mx gj gh gi my mz bd b be z dk translated">如果使用duet(按作者排序的图像),用于向数据集发送字符串路径的代码</p></figure><h2 id="bbe0" class="lt kg iq bd kh lu lv dn kl lw lx dp kp lg ly lz kr lk ma mb kt lo mc md kv me bi translated">服务器:创建远程数据集和远程数据加载器</h2><p id="e5d7" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">现在，在从客户端收到数据集的<code class="fe ml mm mn mo b">.pt</code>路径后，服务器在远程端创建RemoteDataset和RemoteDataLoader。</p><figure class="mp mq mr ms gt mt"><div class="bz fp l di"><div class="mu mv l"/></div><p class="mw mx gj gh gi my mz bd b be z dk translated">服务器创建远程数据集和远程数据加载器(图片由作者提供)</p></figure><p id="5a2b" class="pw-post-body-paragraph kx ky iq kz b la mg jr lc ld mh ju lf lg mi li lj lk mj lm ln lo mk lq lr ls ij bi translated">让我们遍历远程数据加载器，看看里面有什么。注意，我在调试时使用了来自<a class="ae mf" href="https://github.com/gruns/icecream" rel="noopener ugc nofollow" target="_blank">冰淇淋</a>包的<code class="fe ml mm mn mo b">ic</code>来打印变量；这很方便。</p><figure class="mp mq mr ms gt mt"><div class="bz fp l di"><div class="mu mv l"/></div><p class="mw mx gj gh gi my mz bd b be z dk translated">查看远程数据加载器中的训练数据(图片由作者提供)</p></figure><p id="9f46" class="pw-post-body-paragraph kx ky iq kz b la mg jr lc ld mh ju lf lg mi li lj lk mj lm ln lo mk lq lr ls ij bi translated">使用上面的代码，我们将得到<code class="fe ml mm mn mo b">X</code>和<code class="fe ml mm mn mo b">y</code>作为指向相应火炬张量的指针，但不是真正的张量本身，如下图所示。</p><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="gh gi nd"><img src="../Images/6cff66366a2892fe4830b99853329baa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DJttZzZkmaZYxHCg8FI8Hg.png"/></div></div><p class="mw mx gj gh gi my mz bd b be z dk translated">图2:循环访问远程数据加载器时的输出(图片由作者提供)</p></figure><p id="a7b3" class="pw-post-body-paragraph kx ky iq kz b la mg jr lc ld mh ju lf lg mi li lj lk mj lm ln lo mk lq lr ls ij bi translated">服务器可以通过使用<code class="fe ml mm mn mo b">X.get()</code>或<code class="fe ml mm mn mo b">X.get_copy()</code>请求访问张量，但是这需要被客户端接受。这里，为了方便起见，我们假设客户机接受来自服务器的所有请求。然而，我们将在后面的训练循环中看到，客户机永远不会请求访问训练输入数据。此外，由于我们只加载了50个示例，并且批次大小为32，因此只有两个批次，一个有32个样本，另一个有18个样本。</p><p id="44d0" class="pw-post-body-paragraph kx ky iq kz b la mg jr lc ld mh ju lf lg mi li lj lk mj lm ln lo mk lq lr ls ij bi translated">类似地，服务器为测试数据集创建远程数据集和数据加载器。</p><figure class="mp mq mr ms gt mt"><div class="bz fp l di"><div class="mu mv l"/></div><p class="mw mx gj gh gi my mz bd b be z dk translated">服务器为测试数据创建远程数据集和远程数据加载器(图片由作者提供)</p></figure><h2 id="516c" class="lt kg iq bd kh lu lv dn kl lw lx dp kp lg ly lz kr lk ma mb kt lo mc md kv me bi translated">服务器:定义分割神经网络架构以在ECG数据集上进行训练</h2><p id="3544" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">下图3显示了用于在心电图数据集上进行训练的1D CNN神经网络的架构。客户端的模型包含两个1D卷积层(我们将在后面了解更多)，带有<a class="ae mf" href="https://en.wikipedia.org/wiki/Rectifier_(neural_networks)#Leaky_ReLU" rel="noopener ugc nofollow" target="_blank">泄漏Relu </a>激活函数。每个conv层之后是一个<a class="ae mf" href="https://peltarion.com/knowledge-center/documentation/modeling-view/build-an-ai-model/blocks/global-max-pooling-1d" rel="noopener ugc nofollow" target="_blank"> 1D最大池</a>操作。服务器的模型包含两个完全连接的层，后面是softmax激活功能。使用的损失函数是<a class="ae mf" href="https://ml-cheatsheet.readthedocs.io/en/latest/loss_functions.html#cross-entropy" rel="noopener ugc nofollow" target="_blank">交叉熵损失</a>。</p><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="gh gi ni"><img src="../Images/09a5560961518b54000a39f6f0a8cec7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oNgrvQR11LLy3B243uEnMQ.png"/></div></div><p class="mw mx gj gh gi my mz bd b be z dk translated">图3:分裂学习1DCNN模型架构(图片由作者提供)</p></figure><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="gh gi nj"><img src="../Images/59acf49778e56801c7fcabd9db174ffe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OaxYy_jXbiCmR00CTHPmTg.png"/></div></div><p class="mw mx gj gh gi my mz bd b be z dk translated">图4: 1D卷积层vs 2D卷积层(图片由作者提供)</p></figure><p id="2473" class="pw-post-body-paragraph kx ky iq kz b la mg jr lc ld mh ju lf lg mi li lj lk mj lm ln lo mk lq lr ls ij bi translated">让我们了解一下1D卷积层。它只是一种沿一维滑动权重核的方法。图4显示了1D卷积与2D卷积运算的关系。1D卷积适用于1D数据，例如ECG信号中的时间序列。如果你想了解更多关于1D、2D和3D卷积的知识，<a class="ae mf" rel="noopener" target="_blank" href="/understanding-1d-and-3d-convolution-neural-network-keras-9d8f76e29610">这篇博文</a>提供了非常清晰的解释。</p><p id="5597" class="pw-post-body-paragraph kx ky iq kz b la mg jr lc ld mh ju lf lg mi li lj lk mj lm ln lo mk lq lr ls ij bi translated">现在我们可以继续，用下面的代码在客户端定义神经网络模型。这是一个继承自<code class="fe ml mm mn mo b">syft.Module</code>的类。注意，在第3行，我们将<code class="fe ml mm mn mo b">torch_ref</code>作为构造函数的参数，稍后我们将把<code class="fe ml mm mn mo b">remote_torch</code>传递给它。所有的层都是使用这个<code class="fe ml mm mn mo b">torch_ref</code>模块构建的。</p><figure class="mp mq mr ms gt mt"><div class="bz fp l di"><div class="mu mv l"/></div><p class="mw mx gj gh gi my mz bd b be z dk translated">在客户端定义分裂神经网络部分的代码(图片由作者提供)</p></figure><p id="0657" class="pw-post-body-paragraph kx ky iq kz b la mg jr lc ld mh ju lf lg mi li lj lk mj lm ln lo mk lq lr ls ij bi translated">服务器模型也继承自<code class="fe ml mm mn mo b">syft.Module</code>；它的构造函数仍然得到<code class="fe ml mm mn mo b">torch_ref</code>作为参数，但是，这些层是用普通的<code class="fe ml mm mn mo b">torch.nn</code>模块定义的，因为它们是在本地训练的。</p><figure class="mp mq mr ms gt mt"><div class="bz fp l di"><div class="mu mv l"/></div><p class="mw mx gj gh gi my mz bd b be z dk translated">在服务器端定义分裂神经网络部分的代码(图片由作者提供)</p></figure><p id="7e3c" class="pw-post-body-paragraph kx ky iq kz b la mg jr lc ld mh ju lf lg mi li lj lk mj lm ln lo mk lq lr ls ij bi translated">然后，服务器将客户端的模型发送到远程客户端(下面代码中的第2行)。</p><figure class="mp mq mr ms gt mt"><div class="bz fp l di"><div class="mu mv l"/></div><p class="mw mx gj gh gi my mz bd b be z dk translated">创建模型并发送客户的模型(图片由作者提供)</p></figure><h2 id="5f68" class="lt kg iq bd kh lu lv dn kl lw lx dp kp lg ly lz kr lk ma mb kt lo mc md kv me bi translated">服务器和客户端:训练和测试循环</h2><p id="e8ac" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">在训练和测试循环之前，我们需要定义一些超参数:</p><figure class="mp mq mr ms gt mt"><div class="bz fp l di"><div class="mu mv l"/></div><p class="mw mx gj gh gi my mz bd b be z dk translated">设置超参数和随机种子(图片来自作者)</p></figure><p id="ec44" class="pw-post-body-paragraph kx ky iq kz b la mg jr lc ld mh ju lf lg mi li lj lk mj lm ln lo mk lq lr ls ij bi translated">最后，让乐趣开始。下面是训练和测试循环的代码:</p><figure class="mp mq mr ms gt mt"><div class="bz fp l di"><div class="mu mv l"/></div><p class="mw mx gj gh gi my mz bd b be z dk translated">我们的分裂1D CNN模型的训练和测试循环</p></figure><p id="d1ec" class="pw-post-body-paragraph kx ky iq kz b la mg jr lc ld mh ju lf lg mi li lj lk mj lm ln lo mk lq lr ls ij bi translated">在正向传递中，我们首先获得指向批处理数据的指针(第12行)。在将所有梯度初始化为0之后(第15、16行)，客户端的模型从训练输入数据中提取激活图(第18行)。然后，服务器请求访问这些激活图(第20行)，并继续向前传递(第22行)。服务器还要求访问地面实况输出数据(第24行)以计算损失(第26行)。</p><p id="9536" class="pw-post-body-paragraph kx ky iq kz b la mg jr lc ld mh ju lf lg mi li lj lk mj lm ln lo mk lq lr ls ij bi translated">在反向传递中，服务器开始反向传播，直到分离层(第30行)，然后将梯度发送到客户端(第32行)。在接收时，客户继续反向传播并计算他的梯度(第34行)。最后，当计算了损失函数相对于权重的所有梯度时，客户端和服务器都可以更新参数。</p><p id="49be" class="pw-post-body-paragraph kx ky iq kz b la mg jr lc ld mh ju lf lg mi li lj lk mj lm ln lo mk lq lr ls ij bi translated">在每个时期的测试循环中，我们只需要进行正向传递并计算测试损耗。</p><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="gh gi nk"><img src="../Images/df3adc0b158715e5e0e03ce1e805dc82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tPpjX2WrXABuOcWtOf6fJw.png"/></div></div><p class="mw mx gj gh gi my mz bd b be z dk translated">图5:训练和测试循环的结果(图片由作者提供)</p></figure><p id="f512" class="pw-post-body-paragraph kx ky iq kz b la mg jr lc ld mh ju lf lg mi li lj lk mj lm ln lo mk lq lr ls ij bi translated">最后，在400个周期结束后，我们可以打印出最佳测试精度，并绘制训练/测试损耗和精度，如图6和7所示。正如我们所看到的，分裂学习1D CNN方法可以在351个时期后在测试数据集上达到98.85%的准确率。一点也不差。</p><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="gh gi nl"><img src="../Images/439f7b4657003aeb81efc3d493a9cbbb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HPpa0yrdcgsnC-eh9Yb5Kg.png"/></div></div><p class="mw mx gj gh gi my mz bd b be z dk translated">图6:打印出最佳测试精度(图片由作者提供)</p></figure><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="gh gi nm"><img src="../Images/854164ed533e117f3a3c1730bfc08baa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dGa9qOIgs8t5PECGBYbjKg.png"/></div></div><p class="mw mx gj gh gi my mz bd b be z dk translated">图7:培训/测试损失和准确性(图片由作者提供)</p></figure><h1 id="c7d1" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">缺点和未来方向</h1><p id="043a" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">虽然分裂学习方法取得了有希望的结果，但是还有几个问题需要解决。首先，服务器仍然需要访问地面实况输出数据来计算损失。为了解决这个问题，我们可以使用U型分裂学习配置[3]。其次，从客户端发送到服务器的激活映射仍然会泄露关于输入训练数据的信息。文献[1]的作者已经试验了差分隐私来解决这个问题，然而，它极大地阻碍了算法的准确性。第三，使用PySyft训练分裂网络所需的时间非常长，在英特尔至强CPU 2.60GHz和6核上几乎需要14个小时。用GPU在本地训练同一个网络只需要几分钟。目前，PySyft还不支持在GPU上训练。解决这些问题将是今后工作的重点。</p><h1 id="bfaa" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">结论</h1><p id="5fba" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">在这篇博文中，我们介绍了在心电图数据集上训练分裂1D CNN模型的过程。采用分裂学习架构，该算法可以预测高达98.85%的心脏异常，同时保持患者心跳数据的私密性。感谢你的阅读，希望你找到有用的东西。在其他关于安全和私人人工智能的博客文章中再见。</p><h1 id="956c" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">参考</h1><p id="0376" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">[1] <a class="ae mf" href="https://arxiv.org/search/cs?searchtype=author&amp;query=Abuadbba%2C+S" rel="noopener ugc nofollow" target="_blank"> Sharif Abuadbba </a>等，<a class="ae mf" href="https://arxiv.org/abs/2003.12365" rel="noopener ugc nofollow" target="_blank">我们能在1D CNN模型上使用分裂学习进行隐私保护训练吗？</a> (2020)，ACM亚洲计算机与通信安全会议(ACM ASIACCS 2020)</p><p id="3486" class="pw-post-body-paragraph kx ky iq kz b la mg jr lc ld mh ju lf lg mi li lj lk mj lm ln lo mk lq lr ls ij bi translated">[2]穆迪GB，马克RG。麻省理工学院-BIH心律失常数据库的影响(2001)，电气和电子工程师学会医学和生物工程20(3):45–50(2001年5月-6月)</p><p id="23d8" class="pw-post-body-paragraph kx ky iq kz b la mg jr lc ld mh ju lf lg mi li lj lk mj lm ln lo mk lq lr ls ij bi translated">[3] <a class="ae mf" href="https://arxiv.org/search/cs?searchtype=author&amp;query=Vepakomma%2C+P" rel="noopener ugc nofollow" target="_blank"> Praneeth Vepakomma </a>等，<a class="ae mf" href="https://arxiv.org/abs/1812.00564" rel="noopener ugc nofollow" target="_blank">分裂学习促进健康:不共享原始患者数据的分布式深度学习</a> (2018)</p></div></div>    
</body>
</html>