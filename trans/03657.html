<html>
<head>
<title>Let’s Jump on the Poetry Bandwagon</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让我们加入诗歌潮流吧</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/lets-jump-on-the-poetry-bandwagon-d0b650de17b6?source=collection_archive---------11-----------------------#2021-03-25">https://towardsdatascience.com/lets-jump-on-the-poetry-bandwagon-d0b650de17b6?source=collection_archive---------11-----------------------#2021-03-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="22c0" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">为什么应该在Python数据科学项目中使用诗歌</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/6611ec523fcd3cd608871f7db34746c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*h-icJ4hTaXMTu2Gn"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">丹尼·豪在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="3395" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://python-poetry.org/" rel="noopener ugc nofollow" target="_blank">诗歌</a>可能会彻底改变当前Python项目的创建和共享方式。它使用起来很直观，解决了Python开发人员抱怨多年的一些关键痛点。在学习打包Python项目时，我偶然发现了诗歌。对于那些不熟悉打包的人来说，它本质上包含了轻松共享代码所需的步骤。不幸的是，众所周知Python的打包生态系统错综复杂，对新来者不友好(<a class="ae ky" href="https://www.youtube.com/watch?v=AQsZsgJ30AE" rel="noopener ugc nofollow" target="_blank">这里是Python打包的伟大历史</a>)。诗歌将自己推销为更好的选择——一站式商店，可以使整个过程更加顺畅。我同意它在这方面有所作为。但是，即使您没有完成整个打包工作流，诗歌也可以在您的数据科学项目中让您受益匪浅。请继续阅读它的一些最佳特性。</p><div class="lv lw gp gr lx ly"><a href="https://python-poetry.org/" rel="noopener  ugc nofollow" target="_blank"><div class="lz ab fo"><div class="ma ab mb cl cj mc"><h2 class="bd iu gy z fp md fr fs me fu fw is bi translated">诗意</h2><div class="mf l"><h3 class="bd b gy z fp md fr fs me fu fw dk translated">Python依赖管理和打包变得简单。</h3></div><div class="mg l"><p class="bd b dl z fp md fr fs me fu fw dk translated">python-poetry.org</p></div></div></div></a></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/2e60b7daca752343bc7079c8ebc068f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OUUygtmhE4wwvSzGxQuZZg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在过去的一年里，诗歌变得更受欢迎了。版本1于2019年12月发布。来源:使用<a class="ae ky" href="https://github.com/ofek/pypinfo" rel="noopener ugc nofollow" target="_blank"> pypinfo </a>查询PyPI下载，参见<a class="ae ky" href="https://packaging.python.org/guides/analyzing-pypi-package-downloads/" rel="noopener ugc nofollow" target="_blank">本文</a>。作者创建的图表。</p></figure><h1 id="9a4e" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">诗歌确保新开发人员遵循一些最佳实践</h1><p id="764f" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">我记得在我的第一份数据科学工作中，我开始了一个项目，在开始编码之前，我被你必须要做的大量步骤所淹没。有Git和<a class="ae ky" href="https://github.com/" rel="noopener ugc nofollow" target="_blank"> GitHub </a>，我不确定它们是不是一回事。还有一种叫做<a class="ae ky" href="https://docs.conda.io/en/latest/" rel="noopener ugc nofollow" target="_blank">康达</a>的东西……或者是蟒蛇……或者我听到的是迷你蟒蛇？然后有人让我建立一个持续集成管道，我完全不知所措地盯着他们…</p><p id="0164" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关键是在开发任何软件时都有很多最佳实践。如果您的团队中有新的开发人员，或者如果您自己也是一名新的开发人员，诗歌将有助于执行一些标准实践。您的代码将受益于更有组织性和可重复性。这里有一些对新开发人员最有益的诗歌特性。</p><h2 id="579c" class="nf mj it bd mk ng nh dn mo ni nj dp ms li nk nl mu lm nm nn mw lq no np my nq bi translated">使用新项目创建一个目录结构</h2><p id="11af" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">从头开始一个新的诗歌项目需要运行<code class="fe nr ns nt nu b">poetry new &lt;project&gt;</code>。这个命令将创建一个简单的目录结构。它比你可能从诸如<a class="ae ky" href="https://drivendata.github.io/cookiecutter-data-science/" rel="noopener ugc nofollow" target="_blank"> Cookie Cutter Data Science </a>之类的目录结构中找到的更加简单，但是那些模板中的一些对于新手数据科学项目来说可能是多余的。诗歌仍然强调一些重要的组成部分，例如:</p><ul class=""><li id="b1ff" class="nv nw it lb b lc ld lf lg li nx lm ny lq nz lu oa ob oc od bi translated">主代码之外的测试</li><li id="f422" class="nv nw it lb b lc oe lf of li og lm oh lq oi lu oa ob oc od bi translated">包括自述文件</li><li id="6a25" class="nv nw it lb b lc oe lf of li og lm oh lq oi lu oa ob oc od bi translated">正在添加__init__。py脚本</li></ul><p id="91bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个诗歌项目的例子可能如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/e90169c50d712a3cd2b43e8b864a070b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1100/format:webp/1*VtTcHeuvT_zRyLRsb-vbVA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">诗歌项目的目录结构示例。图片作者。</p></figure><p id="b56f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于现有的项目，或者如果您已经有了一个特定的目录结构，那么您可以使用<code class="fe nr ns nt nu b">poetry init</code>来代替。</p><h2 id="b95c" class="nf mj it bd mk ng nh dn mo ni nj dp ms li nk nl mu lm nm nn mw lq no np my nq bi translated">诗歌加强了环境隔离</h2><p id="501c" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">为每个项目建立一个独立的虚拟环境非常重要，这也是经验丰富的开发人员的习惯。它将您需要的库从一个项目中分离出来。当不同的项目需要不同的版本时，这有助于防止错误。它还有助于再现性，因为您的项目的虚拟环境应该只包含项目的依赖项。如果被激活，does将只在一个虚拟环境中运行代码(所以不会在全局环境中运行它)，如果一个新环境还不存在，does将为您创建一个新环境。少了一个你必须记住要做的步骤。</p><h1 id="cf03" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">诗歌是一个依赖管理器</h1><p id="96be" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">依赖项是您导入的所有包(例如pandas、numpy、scitkit-learn等。)在您的项目中。对于Python项目，您可能已经使用了主要的Python安装程序<code class="fe nr ns nt nu b">pip</code>来安装依赖项(注意:<code class="fe nr ns nt nu b">pip</code>不是依赖项管理器)。依赖关系管理器帮助组织和维护这些依赖关系。它们很有用，因为它们可以确保在两个可能需要不同版本的子依赖项的包之间不会有版本冲突。它们还有助于确保您的环境是可复制的。当您希望更新依赖项的版本，并且不希望整个环境崩溃时，它们会有所帮助。让我们看看诗歌如何成功地成为一个依赖管理器。</p><h2 id="db4c" class="nf mj it bd mk ng nh dn mo ni nj dp ms li nk nl mu lm nm nn mw lq no np my nq bi translated">更好的依赖性组织和可再现性</h2><p id="b495" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">在Python中，维护所有依赖项列表的传统方法非常烦人。(<a class="ae ky" href="https://realpython.com/pipenv-guide/" rel="noopener ugc nofollow" target="_blank">这篇文章</a>很好地概述了当前的方法)。这个过程依赖于一些手动步骤来更新需求文件(或者environment.yml，如果您使用conda的话),只要依赖关系发生变化。这对新的和有经验的程序员来说都是容易出错的。诗歌用一个<code class="fe nr ns nt nu b">poetry.lock</code>文件代替了任何对<code class="fe nr ns nt nu b">requirements.txt</code>文件的需要。两者都实现了确保可再现环境的目标，但是当您在环境中修改包时，poems的文件会自动更新。</p><p id="7e50" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">诗歌的<code class="fe nr ns nt nu b">add</code>和<code class="fe nr ns nt nu b">remove</code>命令简化了这个过程。如果你输入<code class="fe nr ns nt nu b">poetry add</code>，它将自动下载、安装(假设没有冲突)，并更新<code class="fe nr ns nt nu b">pyproject.toml</code>文件中的依赖列表。安装的确切版本以及每个子依赖项版本都会在poetry.lock中更新。因此，团队不再需要依靠人们的组织技能来保持这些依赖项是最新的！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/03bdc852c198f10b2742c0e024ee4620.png" data-original-src="https://miro.medium.com/v2/resize:fit:1036/format:webp/1*YrwgjYx_fAlJSGN8G9oM7Q.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">pyproject.toml. Image中按作者列出的依赖关系示例。</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ol"><img src="../Images/bbfed27163ffb94a6e4f028b1fa5492e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j0_JSc7tbVit9K8QoIr1eQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">示例poetry.lock文件。图片作者。</p></figure><p id="5ef4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，如果您使用pip，您可能尝试过安装一个包，可能是<code class="fe nr ns nt nu b">pandas</code>，决定它不适合您的需要，然后卸载它。当你安装<code class="fe nr ns nt nu b">pandas</code>时，它依赖于另一个名为<code class="fe nr ns nt nu b">pytz</code>的包。Pip安装了<code class="fe nr ns nt nu b">pytz</code>和<code class="fe nr ns nt nu b">pandas</code>。然而，当您移除<code class="fe nr ns nt nu b">pandas</code>时，pip并没有最终移除<code class="fe nr ns nt nu b">pytz</code>。随着时间的推移，您的环境可能会因这些不需要的包而变得拥挤。从安全角度来看，安装这些不必要的设备是有问题的。这也使得重建您的环境变得更慢。有了诗歌，它会在你移除父包的时候移除这些未使用的子依赖，而你不会面临这个问题。</p><p id="7913" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">诗歌也很容易将开发需求和生产需求分开。只需在运行命令时添加一个标签，例如<code class="fe nr ns nt nu b">poetry add --dev pandas</code>，它就会为您适当地组织依赖关系。新的诗歌项目将自动在开发列表中有<code class="fe nr ns nt nu b">pytest</code>。</p><p id="ad28" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了版本号之外，poem的锁文件还包括散列。这些散列是额外的安全层，可以100%确信包的散列与预期的相匹配。在软件包的源代码被黑客攻击并被恶意软件替换的危险事件中，这个特性可以帮助保护您的系统。</p><h2 id="e81f" class="nf mj it bd mk ng nh dn mo ni nj dp ms li nk nl mu lm nm nn mw lq no np my nq bi translated">您可以避免冲突并更容易地更新您的依赖关系</h2><p id="ca57" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">你的依赖关系的依赖关系被称为<em class="om">传递</em>依赖关系。这些可传递的依赖关系通常会在安装时导致问题。Pip不能也不会以任何方式解析依赖关系。这意味着如果你运气不好，当你试图安装需要相同子依赖的不同版本的包时，你会得到<strong class="lb iu">安装失败</strong>错误。例如，假设您要在以下位置安装:</p><ul class=""><li id="a53b" class="nv nw it lb b lc ld lf lg li nx lm ny lq nz lu oa ob oc od bi translated">package_a依赖于package_c &gt;1.5</li><li id="85b2" class="nv nw it lb b lc oe lf of li og lm oh lq oi lu oa ob oc od bi translated">package_b依赖于package_c ≤ 2.0</li></ul><p id="8c26" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设package_c的最新版本是2.5。当pip首先安装package_a时，它可能会下载package_c=2.5。当它尝试安装package_b时会发生冲突，然后安装会失败。(例子来自<a class="ae ky" href="https://realpython.com/pipenv-guide/" rel="noopener ugc nofollow" target="_blank">本文</a>)。</p><p id="1fd8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">依赖项管理器通过巧妙的确定需要哪个版本来满足所有必需的包来帮助避免这些冲突。(想象一下必须手动完成这项工作！)在上面的例子中，package_c版本1.6将满足package_a和package _ b。poeting具有这种功能，因此您应该有较少的安装挑战。它将总是试图检索您试图添加的包的最新版本，除非您指定不同的版本。如果找不到依赖项的成功组合，poems将通过对有问题的包的详细描述来提醒您这个问题。在这一点上，您将不得不尝试解决冲突，但是错误消息会清楚地告诉您到哪里去找。</p><p id="e1f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，您可以想象保持每个依赖项和子依赖项都是最新的有多难。保持您的依赖项最新对于确保您拥有最新的功能和任何重要的安全修补程序非常重要。拥有一个可以更新所有依赖项的依赖项管理器，以便每个包都满足需求，这是您保持理智和环境成功的关键。使用<code class="fe nr ns nt nu b">poetry update</code>，它将检查所有包的最新版本，并在不引入冲突的情况下更新任何包。魔法。</p><h1 id="841a" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">用诗歌发布应用程序很容易</h1><p id="6a0d" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">最后，这一部分可能并不适用于那些对构建和分享他们的最终项目不感兴趣的人。但是如果你想这么做，诗歌会让它变得非常简单。</p><p id="fd81" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，对于任何熟悉包装的人来说，诗歌项目最引人注目的是它缺乏<code class="fe nr ns nt nu b">setup.py</code>。诗歌已经完全取代了对“T1”的需求，代之以“T2”。这个新文件是对<code class="fe nr ns nt nu b">setup.py</code> (PEP- <a class="ae ky" href="https://www.python.org/dev/peps/pep-0517/" rel="noopener ugc nofollow" target="_blank"> 517 </a>、<a class="ae ky" href="https://www.python.org/dev/peps/pep-0518/" rel="noopener ugc nofollow" target="_blank"> 518 </a>)的一些缺点提出的<a class="ae ky" href="https://www.python.org/dev/peps/pep-0518/" rel="noopener ugc nofollow" target="_blank">解决方案</a>，并取代了对<code class="fe nr ns nt nu b">setup.py</code>、<code class="fe nr ns nt nu b">requirements.txt</code>、<code class="fe nr ns nt nu b">setup.cfg</code>、<code class="fe nr ns nt nu b">MANIFEST.in</code>和<code class="fe nr ns nt nu b">Pipfile</code>的需求。这减少了打包新手的困惑，并为项目的构建提供了更大的灵活性。这也有利于更干净的回购。</p><p id="cdda" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">诗歌也通过给他们简单的命令来构建和发布帮助那些打包项目。改变你的包的版本就像运行<code class="fe nr ns nt nu b">poetry version</code>一样简单。构建你的包就像<code class="fe nr ns nt nu b">poetry build</code>一样简单，它生成轮子和源文件。并且发布就像<code class="fe nr ns nt nu b">poetry publish</code>一样简单。</p><h1 id="d212" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">结论</h1><p id="f633" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">poem有许多有益于Python社区的特性，对于不太熟悉编程最佳实践的数据科学家来说，它抽象出了一些关于打包和依赖管理的复杂性。它非常易于使用，从Python的新用户到有几十年经验的用户都可以从中受益。是时候下载诗歌了。让我们加入这股潮流吧。</p><h1 id="9a86" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">参考</h1><p id="1cfb" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated"><a class="ae ky" href="https://pypi.org/project/pypinfo/" rel="noopener ugc nofollow" target="_blank"> Pypinfo </a>用于诗歌的每月总下载量</p><p id="c0f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">介绍开发者如何使用诗歌来管理依赖关系</p><p id="c2dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">构建pipenv 的动机，pipenv是另一种依赖性管理器</p><p id="9d95" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://python-poetry.org/" rel="noopener ugc nofollow" target="_blank">诗歌文献</a></p></div></div>    
</body>
</html>