<html>
<head>
<title>Efficiently splitting an image into tiles in Python using NumPy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用NumPy在Python中高效地将图像分割成图块</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/efficiently-splitting-an-image-into-tiles-in-python-using-numpy-d1bf0dd7b6f7?source=collection_archive---------3-----------------------#2021-05-17">https://towardsdatascience.com/efficiently-splitting-an-image-into-tiles-in-python-using-numpy-d1bf0dd7b6f7?source=collection_archive---------3-----------------------#2021-05-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="7f83" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">发展对数组步长和numpy.reshape()的直觉</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/f7e463d8c94c444389ca3509dd2ea682.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cUpAdkDbBVsx5lQAZ50UZA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图一。问题图解。图片作者。</p></figure><p id="3d6f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在很多情况下，您需要将一幅大图像分解成小块(例如，作为ML预处理管道的一部分)来进行批处理。本文旨在探索用Python实现这一点的更低级的方法。</p></div><div class="ab cl lr ls hu lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ij ik il im in"><h2 id="450f" class="ly lz iq bd ma mb mc dn md me mf dp mg le mh mi mj li mk ml mm lm mn mo mp mq bi translated">1.嵌套for循环:低效的方法。</h2><p id="56be" class="pw-post-body-paragraph kv kw iq kx b ky mr jr la lb ms ju ld le mt lg lh li mu lk ll lm mv lo lp lq ij bi translated">我见过的创建图像块堆栈的最常见方法之一是使用嵌套的for循环，例如用所需的维度实例化一个新数组，并将其填充到这些循环中。然而，这种方法在Python中效率特别低(尤其是),并且根本不适合大型数据集(也不适合较小的切片)。</p><p id="498e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">嵌套的for-loops方法类似于下面的代码片段:</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="85e3" class="ly lz iq mx b gy nb nc l nd ne"># Nested for-loops method.<br/># Creating a stack of 2 x 2 tiles out of a 4 x 4<br/># RGB image with channels on the last axis.<br/><br/>import numpy as np<br/><br/>image = np.random.randn(4, 4, 3)<br/>tiles = np.zeros((4, 2, 2, 3))<br/><br/>c = 0<br/><br/>for i in range(0, image.shape[1], 2):  <br/><br/>    for j in range(0, image.shape[2], 2):<br/><br/>        tiles[c] = image[i:i+2, j:j+2, :]<br/>        c += 1</span></pre><p id="67db" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">随着迭代的增长<em class="nf">(图像大小与图块大小的比率)</em>，更不用说迭代大量的图像(第三个for-loop)，这可能会占用资源并迅速在您的管道中产生瓶颈。</p></div><div class="ab cl lr ls hu lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ij ik il im in"><h2 id="c061" class="ly lz iq bd ma mb mc dn md me mf dp mg le mh mi mj li mk ml mm lm mn mo mp mq bi translated">2.或者:内存视图</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ng"><img src="../Images/db7bbb84d1e9e9d6791f9e0557ef6fba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qWu4Fj7bTgUcPs0PJvkYuQ.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图2.1。阵列存储器布局。图片作者。</p></figure><p id="1c55" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果我们可以对同一块内存使用不同的视图，并将其显示为图块，会怎么样？让我们来谈谈数组。</p><p id="ef97" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">Numpy数组和一般意义上的数组在内存中以连续字节块的形式排列。然后可以使用<a class="ae nh" href="https://ajcr.net/stride-guide-part-1/" rel="noopener ugc nofollow" target="_blank">步长</a>以不同的形状查看那块连续的内存。</p><p id="902a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在数组的内存级别上，跨距表示为了到达数组中包含的下一个元素，需要向前跳转的字节数。这取决于数组中包含的数据类型的字节长度。</p><p id="bed6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="nf">例如，16位整数(2字节长)的一维数组的跨度为2字节。</em></p><p id="504f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">另外需要注意的是，数组必须包含相同数据类型的元素，以保证相等的字节长度间隔。当然，有多种方法可以在单个数组中表示不同的数据类型，但这超出了本文的范围。</p><h2 id="0cb5" class="ly lz iq bd ma mb mc dn md me mf dp mg le mh mi mj li mk ml mm lm mn mo mp mq bi translated">2.1.数组维度</h2><p id="8563" class="pw-post-body-paragraph kv kw iq kx b ky mr jr la lb ms ju ld le mt lg lh li mu lk ll lm mv lo lp lq ij bi translated">那么，数组中的元素是什么呢？只是按顺序排列的字节。元素的长度可以变化，这取决于表示每个元素所需的字节数。</p><p id="6a1b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因此，元素是字节的集合，而字节又是位的集合，特别是8位。都生活在同一个物理空间。那么，有没有可能将一个数组进一步聚合成更大的块呢？是的，它是。这正是数组维数的作用。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ng"><img src="../Images/0e3856a7672a479ad81715a6b716d9c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i8Fw_j7wdW_YU5-Lgx4ndQ.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图2.2。内存中C阶二维数组的图示。图片作者。</p></figure><p id="f449" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了将数组元素组织成行并创建第二维度，您需要做的就是定义第二个步幅来指向每一行的开头。在那个维度上，各个元素就是行。这也可以看作是将一个数组分割成多个大小相等的子数组。</p><p id="e0c4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在numpy.shape()返回的数组维度大小中，上面描述的示例将呈现为一个<strong class="kx ir">二维shape (3，3) </strong>。返回的维度顺序总是从最高级别的<em class="nf">(最左边)</em>开始，到最低级别的<em class="nf">(最右边)</em>。这意味着元组中第一个<strong class="kx ir">维度</strong> <em class="nf"> i </em>的大小3 <strong class="kx ir"> </strong>表示<strong class="kx ir">行</strong>的数量，而第二个<strong class="kx ir">维度</strong>的大小3表示每行的单个<strong class="kx ir">元素的数量。正如我们将在后面看到的，有一些numpy方法可以改变维度层次结构，但是上面的方法通常代表使用numpy.reshape()形成的数组视图以及numpy中新实例化的数组。</strong></p><p id="067b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="nf">注1:上面的维度顺序是指numpy.shape()返回的元组中访问的顺序，第一维度在索引位置0 (shape[0])，第二维度在索引位置1 (shape[1])。</em></p><p id="b65d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="nf">注2:有多种布局(行/列优先)，但本文仅讨论行优先顺序，因为这是我最熟悉的一种。更多布局信息</em> <a class="ae nh" href="https://eli.thegreenplace.net/2015/memory-layout-of-multi-dimensional-arrays" rel="noopener ugc nofollow" target="_blank"> <em class="nf">点击</em> </a> <em class="nf">。</em></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ng"><img src="../Images/546ce8e5bad4a72b9610e01d9ac6aff1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7xfgsvFjwLpjZrOwSMenVw.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图2.3。连续数组维数的图示。图片作者。</p></figure><p id="917c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="nf">出于我们的目的，我们将给出尺寸大小的一般定义如下:</em></p><p id="ef91" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">以shape <em class="nf"> (m，n，I，j) </em>的4维数组为例，第1个<em class="nf">(最高&amp;最左边)</em>维包含以shape<em class="nf">(n，I，j) </em>组织的<em class="nf"> m </em>个元素。第二维保存形状为<em class="nf"> (i，j) </em>的<em class="nf"> n </em>个元素，而第三维保存大小为<em class="nf"> ( j ) </em>的<em class="nf"> i </em>个元素。第四个也是最后一个维度只是一行<em class="nf"> j </em>元素。然后:</p><blockquote class="ni"><p id="4599" class="nj nk iq bd nl nm nn no np nq nr lq dk translated">尺寸大小:<strong class="ak"> </strong>后续<em class="ns">(下)</em>尺寸描述的元素个数。</p></blockquote><h2 id="43a1" class="ly lz iq bd ma mb nt dn md me nu dp mg le nv mi mj li nw ml mm lm nx mo mp mq bi translated">2.2.通过指定自定义步幅，将2D numpy图像数组分割成图块</h2><p id="b0ec" class="pw-post-body-paragraph kv kw iq kx b ky mr jr la lb ms ju ld le mt lg lh li mu lk ll lm mv lo lp lq ij bi translated">现在，表示为numpy数组的2D图像将具有形状<em class="nf"> (m，n)，</em>，其中<em class="nf"> m </em>将指示以像素为单位的<em class="nf">图像高度</em>，而<em class="nf"> n </em>将指示以像素为单位的<em class="nf">图像宽度</em>。作为一个例子，让我们以一个6×4、8位灰度图像阵列为例，通过使用步长创建一个新的内存视图，将它分成2×2的小块。记住，元素的长度必须相等，因此，两个数组的维数都必须能被2整除。</p><p id="0eb7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们的图像可以被认为是由6行4个元素组成的。我们示例的可视化如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ng"><img src="../Images/84acac9e9b4895663a1094d15b1e8fbb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hoZmthTNfm7Sy4ejE-YOOA.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图2.4。说明我们的瓷砖问题。图片作者。</p></figure><p id="d35c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">那么，我们怎么去呢？</p><p id="3446" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们一步一步来。看到我们总共需要6个图块，组织成3行2列，让我们首先尝试将当前行分成2列。我们当前的形状是(6，4)，因此，我们需要将最后一个维度减半，并添加一个更高的维度2，表示我们想要形成的列。这一步的目标三维形状是(2，6，2): <em class="nf"> 2列×6行×每行2个数组元素</em>。现在我们知道了我们需要的形状。我们可以继续计算步幅。</p><p id="b680" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们来观察下图。我们的2D形象的步幅是(4，1)。<strong class="kx ir">最低维度的步幅1 </strong>必须保持不变，因为对其进行改动会使我们失去像素级别的空间关系<em class="nf">(例如，增加它将意味着跳过像素)</em>。<strong class="kx ir">行尺寸的跨度4 </strong>也将保持不变，因为所需的行数保持为6。一般来说，如果你改变这两个步幅中的任何一个，最终都会扭曲图像。然后，我们需要做的就是计算出尺寸为2的最高维度的步幅，它代表我们正在定义的新的<em class="nf">更高级别的</em> <em class="nf">列</em>。记住，我们将原来的每行4个元素分成两半，这样它们可以包含在单独的列中，这给了我们一个提示。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ng"><img src="../Images/446dd5366e436c47e0b13409464531b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LGRmmCJg9IrLWKGEVnnlOQ.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图2.5。列跨距解决方案的插图。图片作者。</p></figure><p id="d865" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">查看图2.5。我们数组中的所有像素按照它们在内存中的排列顺序进行编号(C顺序)。以前，每4个元素我们必须改变一行，这个规则仍然有效。我们希望包含一个额外的规则:<em class="nf">在每一行中，</em> <strong class="kx ir"> <em class="nf">每隔2个元素</em> </strong>改变列。所以我们最高维度的步幅是<em class="nf"> 2 x element_byte_size </em>。在我们的8位整数的例子中，步距是<em class="nf"> 2x1字节= 2。</em></p><p id="6e2f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们打开一个终端并用代码测试它:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/c4f9e1e040db0be3bc56e5a454621df3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1048/format:webp/1*CdpxO6Emef6jbFTyn2mjgA.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图2.6。我们的示例数组的形状和大小。图片作者。</p></figure><p id="f183" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在numpy中，您可以使用<strong class="kx ir">numpy . lib . stride _ tricks . as _ strided()</strong>来操作数组的跨度。我们需要指定我们想要操作的数组、我们想要它的形状以及我们想要每个维度的步距:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nz"><img src="../Images/2ed9f0223d7f582f6a363f7c973510fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6QpBbc1msirnufcXrCmQVA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图2.7。将示例图像分成两列。图片作者。</p></figure><p id="6536" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们得到了包含我们想要的元素的两列！现在，我们可以继续将每列分为3组，每组2行，这样总共有6块瓷砖。</p><p id="0bf2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们当前的形状是(2，6，2)，6是我们在图像中的行数。类似于上一步，我们需要第3维元素(2列)来保存每一行(第1维元素)中只有2个数组元素的行，现在我们需要顶层层次结构中的第4维元素来保存每一行只有2个图像。因此，我们需要将“图像行”的维度从6减少到2。我们的目标形状将是(3，2，2，2)。</p><p id="5d29" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">总之，较低级别的元素仍然是2，我们的行减少到2，第3维的列仍然是2，我们现在添加第4维来将这些列分成3个部分。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ng"><img src="../Images/2b7047bef388cbdce0babd606cd6a830.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZpPCJbhU_64ytt2mIPIeLw.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图2.8。瓷砖步幅解决方案插图。图片作者。</p></figure><p id="a56b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们对这个4维数组的定义表明，最高维现在将改变每<em class="nf"> 2 </em>图像行的元素，而不是<em class="nf"> 1 </em>。因此，总之，新的步幅必须是图像行的两倍。那么，我们新维度的步距将是<em class="nf"> 2 x row_stride = 2x4 = 8字节</em>。</p><p id="239a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在代码中测试它:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oa"><img src="../Images/7a11b4fa21c59ac0c5c476602ff3de14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V7loBdx1dykmeTFKICXmuw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图2.9。自定义步长解决方案的实施。图片作者。</p></figure><p id="385e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们完事了。6块瓷砖全部成型。现在，我们可以使用numpy.reshape()合并2个最高维度，使我们的数组成为<em class="nf"> (number_of_tiles，tile_height，tile_width) </em>的三维形状，如果我们愿意的话，因为这是图像批处理的基本格式。我们首先需要4个维度而不是3个维度的原因是因为内存中每个区块的位置不能由一个单独的步幅来表示。我们的形象毕竟是二维的。</p><p id="3038" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们刚刚实现的使用步长将8位整数的6×4图像分割成2×2块的方法，可以推广到任何<em class="nf"> C排序的</em> 2D图像，如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ob"><img src="../Images/8178ce79fcd92bb2b0f44e66afe82e6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gP-biNgdG-pb571DZse8Nw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">情商。2.1.用于将灰度图像分割成图块的形状和步幅。图片作者。</p></figure><p id="5f28" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">事实证明，对于特定格式的多通道图像，我们也可以使用类似的公式。具体来说，它们是连续的C有序阵列，具有最低维度的通道<em class="nf">(具有彼此相邻的相同像素RGB值)</em>，否则在每种情况下步幅将不同。有些库像那样直接加载图像，有些库不这样，但是重塑它们并不是特别困难。</p><p id="1a6d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="nf">例如，GDAL将以通道作为最高(最左侧)维度加载图像。</em></p><p id="13bd" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当我们的多通道数组维度以这种方式格式化时，最低的维度将是每个像素的每通道值，我们可以通过只做一个字节长度的步骤来导航。因为，不是1个单个像素值，我们将有<em class="nf"> n </em>个像素值用于<em class="nf"> n </em>个通道，我们需要做的就是将所有其他步幅乘以通道数。总之，一切都保持不变，但我们现在每个像素有多个值要跳转，每个通道一个值:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oc"><img src="../Images/c766b777aa894be0ff2b6ff690b68d4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6yLllpUalGGeaCafrVrpNQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">情商。2.2.用于将多通道图像分割成小块。图片作者。</p></figure><p id="d2f4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这不是一种特别干净的方法，但是我们将在下一节中看到有一种更干净的方法。处理跨步是一个非常敏感的过程，需要非常小心。每次您都必须验证邻近性并采取必要的步骤。</p><p id="0975" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">幸运的是，numpy提供了一些更高级的方法来省去我们大部分的麻烦。</p><h2 id="c135" class="ly lz iq bd ma mb mc dn md me mf dp mg le mh mi mj li mk ml mm lm mn mo mp mq bi translated">2.3.Numpy.reshape()</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi od"><img src="../Images/66f94ebacb118a9a83330bacce1195c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:750/format:webp/1*uZt_9kZNUIfKyiRIjPxk6Q.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图2.10。numpy.reshape()的输出给出了错误的结果。图片作者。</p></figure><p id="e530" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><a class="ae nh" href="https://numpy.org/doc/stable/reference/generated/numpy.reshape.html" rel="noopener ugc nofollow" target="_blank">Numpy . shape()</a>是在numpy中操作数组形状的标准、最常见的方法。然而，如果我们在之前的6 x 4图像示例中简单地声明我们想要一个形状为(3，2，2，2)的数组，它就不会工作。</p><p id="f72b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这是因为默认情况下，numpy.reshape()试图保持后续值的连续性。这意味着在程序中使用的数组的顺序索引将继续存在于相邻的内存块中。不幸的是，为了得到我们的结果，我们需要打破连续性。<em class="nf">尽管如此，出于性能原因，我们可以在将它分成瓦片后使其再次连续。</em></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/21243dd4b4dd6086eb8900092e5c6201.png" data-original-src="https://miro.medium.com/v2/resize:fit:666/format:webp/1*P_R_1kq4aAlb_rJJV85i8Q.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图2.11。numpy.reshape()输出的步幅。步幅与我们在上一节中期望的解决方案不同。图片作者。</p></figure><p id="8677" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="nf"> &lt; &lt;步幅与我们之前的方案不同。</em></p><p id="757e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">它是如何工作的？它基本上接受一个维度(在任何级别)，将其分解为相等的相邻部分，并在更高的级别将它们堆叠在一起。在我们的例子中，它的作用如下:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi of"><img src="../Images/9ba9831aebe5bf1984462cc970e76301.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Uo7cWU9JkLZkPYG5oVErLQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图2.12。numpy.reshape()输出的图示。图片作者。</p></figure><p id="a095" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">相反，我们想要的是这个:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi og"><img src="../Images/175df9b7ffd02216d961ca43170a104c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C0Lwjvp1HGfe_CA1ObfFEg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图2.13。内存中我们想要的输出布局图。图片作者。</p></figure><p id="422f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">那么，我们该怎么解决呢？</p><p id="0976" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">作为两个数组步距提示的简单比较，我们需要做的就是在轴1和轴2(第一维和第二维)之间交换步距。具体来说，我们需要的步距是<em class="nf"> (8，2，4，1) </em>，但是numpy.reshape()返回一个步距为<em class="nf"> (8，4，2，1) </em>的数组。Numpy数组为此公开了一个方法，称为<em class="nf"> swapaxes: </em></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oh"><img src="../Images/8cf97f0342c44dc19d4014e504269d30.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*31cLrxKv2CTnEyPN9gyZdw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图2.14。使用numpy.reshape()和swapaxes方法更正解决方案。图片作者。</p></figure><p id="5b20" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然后，numpy.reshape()实现可以推广到最后维度中具有通道的任何2D或3D图像，如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oi"><img src="../Images/f79039761d1ee9b3842c571dedbaefb1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m7Tgf4t2hiYWpYp786gPDA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">情商。2.3.用于将多通道图像分割成拼贴的形状尺寸和swapaxes实现。对于灰度图像，您可以省略通道尺寸。图片作者。</p></figure></div><div class="ab cl lr ls hu lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ij ik il im in"><h2 id="fe51" class="ly lz iq bd ma mb mc dn md me mf dp mg le mh mi mj li mk ml mm lm mn mo mp mq bi translated">3.比较和结论</h2><p id="c7a9" class="pw-post-body-paragraph kv kw iq kx b ky mr jr la lb ms ju ld le mt lg lh li mu lk ll lm mv lo lp lq ij bi translated">我们来对比一下执行力！</p><p id="6afe" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们将使用这个看起来很酷的家伙的RGB JPEG:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oj"><img src="../Images/d9b0f163ff18ed607acd29de2b097f2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*le1eQV-ASAzMRfrfDonpqg.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><em class="ns">图3.1。测试图像。照片由</em> <a class="ae nh" href="https://unsplash.com/@tarasovaanastasiia?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> <em class="ns">安娜斯塔西娅</em> </a> <em class="ns">上</em> <a class="ae nh" href="https://unsplash.com/s/photos/fun?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> <em class="ns">下</em> </a></p></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/80fec169fccda259c3393e71f322d59d.png" data-original-src="https://miro.medium.com/v2/resize:fit:896/format:webp/1*dM11zznt15J85Xa1V0oU-g.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图3.2。图像检查。图片作者。</p></figure><p id="f4aa" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在我们探索了图像的尺寸之后，我们可以看到它们可以被25和12整除，所以让我们用它们来表示我们的平铺尺寸。</p><p id="86d6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们还将使用这个装饰器来为每次执行计时:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/50d8289de07b805af7f6876f59d19dcd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1088/format:webp/1*L5s5Cm9esYnxYuQpnbxGTw.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图3.3。我们的计时器装饰器和依赖项。它将用于记录每次进场的时间。图片作者。</p></figure><p id="8cf4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们的for循环实现如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi om"><img src="../Images/283de4859caae845b6a226ccd49f24f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1242/format:webp/1*U2_x1jnaey6BZ6i4Z6ozMA.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图3.4。For循环实现函数被修饰为定时。图片作者。</p></figure><p id="c4e7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">大踏步的实现是:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi on"><img src="../Images/af7eefa3a31939bcf26d41b980fed014.png" data-original-src="https://miro.medium.com/v2/resize:fit:1252/format:webp/1*RWs3eX2TG_JfIyJzyoYRjg.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图3.5。跨步装饰实现定时功能。图片作者。</p></figure><p id="2bab" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">numpy.reshape()的实现是:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/4aa646301b5d3d647d22f94a14684a62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1224/format:webp/1*zXLeqRzHsUFZfBaW88rpeg.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图3.6。Numpy.reshape()实现被修饰为计时。图片作者。</p></figure><p id="6e63" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们将加载我们的图像作为一个numpy数组，从命令行设置图块尺寸，运行每个函数并检查数组的相等性。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi op"><img src="../Images/86cfd3a35b1dd41cb6073fe11897d9ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1302/format:webp/1*f4uF8jTZdbkbPb5RZG1HQQ.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图3.7。我们的代码包括平等测试。图片作者。</p></figure><p id="015a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">关键时刻:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/cd05aa2bb132884a3dbe51ac990882f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1388/format:webp/1*yUfWG4390nrAMPHBAQlDJg.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图3.8。结果。Numpy.reshape()优于其他方法。图片作者。</p></figure><p id="295c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">numpy.reshape()方法似乎是最干净也是最有效的。此外，很明显，for循环实现不能真正与内存视图方法相比较。同样值得注意的是，内存视图性能几乎不受必须生成的切片“数量”的影响，而for循环的执行时间会随着工作负载的增加而增加。</p><p id="2727" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="nf">最后一点:正如大多数框架所期望的那样，还有一个额外的步骤来将我们的瓦片以批处理的形式带来。要在单个索引中合并我们的图块，我们所要做的就是</em><strong class="kx ir"><em class="nf">tiled _ arr . shape(-1，* tile _ dimensions)</em></strong><em class="nf">并使用</em><strong class="kx ir"><em class="nf">numpy . moveaxis()</em></strong><em class="nf">在适当的地方重新定位通道维度。通常为(n_tiles，n_channels，t_height，t_width)。</em></p><p id="95ca" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">感谢您的阅读！</p></div><div class="ab cl lr ls hu lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ij ik il im in"><p id="b04e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我希望这篇文章很有见地，你可以在自己的计算机视觉工作流程中实现这里演示的内容！</p><p id="79b9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在LibreOffice中创建了插图和公式。</p><p id="17c0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="nf">代码:您可以在这里</em>  <em class="nf">找到测试脚本</em> <a class="ae nh" href="https://1drv.ms/u/s!AvEi405pB_8lyAWJbNNVo8E1LZKy?e=UoXHhI" rel="noopener ugc nofollow" target="_blank"> <em class="nf">。</em></a></p><p id="0eee" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="nf">如有任何建议或修改，请随时联系我，地址:</em><strong class="kx ir"><em class="nf">iosif.doundoulakis@outlook.com</em></strong></p><p id="343c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="nf">你可以在</em><a class="ae nh" href="https://www.linkedin.com/in/jdoun/" rel="noopener ugc nofollow" target="_blank"><em class="nf">LinkedIn</em></a><em class="nf">上联系我。</em></p></div><div class="ab cl lr ls hu lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ij ik il im in"><p id="c8f6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="nf">来源:</em></p><p id="0c4f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><a class="ae nh" href="https://eli.thegreenplace.net/2015/memory-layout-of-multi-dimensional-arrays" rel="noopener ugc nofollow" target="_blank"><em class="nf">【1】:多维数组的内存布局</em> </a></p><p id="600b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><a class="ae nh" href="https://ajcr.net/stride-guide-part-1/" rel="noopener ugc nofollow" target="_blank"><em class="nf">【2】:形体与步幅图解指南(上)</em> </a></p><p id="936a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><a class="ae nh" href="https://numpy.org/doc/stable/reference/generated/numpy.lib.stride_tricks.as_strided.html" rel="noopener ugc nofollow" target="_blank"><em class="nf">【3】:Numpy文档:Numpy . lib . stride _ tricks . as _ strided()</em></a></p><p id="5f66" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><a class="ae nh" href="https://numpy.org/doc/stable/reference/generated/numpy.reshape.html" rel="noopener ugc nofollow" target="_blank"><em class="nf">【4】:Numpy文档:Numpy . shape()</em></a></p></div></div>    
</body>
</html>