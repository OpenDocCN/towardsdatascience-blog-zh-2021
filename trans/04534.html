<html>
<head>
<title>2 Must-Know OOP Concepts in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中两个必须知道的OOP概念</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/2-must-know-oop-concepts-in-python-48d643a7385?source=collection_archive---------0-----------------------#2021-04-19">https://towardsdatascience.com/2-must-know-oop-concepts-in-python-48d643a7385?source=collection_archive---------0-----------------------#2021-04-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d88a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">遗传和多态性</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/eee862480d235f2c011a5e433f151045.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tpt3rZzPp_LsZf_zPy8slw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在<a class="ae ky" href="https://unsplash.com/s/photos/two?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae ky" href="https://unsplash.com/@zmachacek?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">zdenk macha ek</a>拍摄的照片</p></figure><p id="5d2f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">面向对象编程(OOP)范式是围绕拥有属于特定类型的对象的思想而构建的。在某种意义上，类型是向我们解释对象的东西。</p><p id="f6fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Python中的一切都是对象，每个对象都有一个类型。这些类型是使用<a class="ae ky" rel="noopener" target="_blank" href="/a-comprehensive-guide-for-classes-in-python-e6bb72a25a5e">类</a>声明和定义的。因此，类可以被认为是OOP的核心。</p><p id="9c2b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了用Python开发健壮的、设计良好的软件产品，全面理解OOP是必不可少的。在本文中，我们将详细阐述OOP的两个关键概念，即继承和多态。</p><p id="c087" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">继承和多态都是设计健壮、灵活和易于维护的软件的关键因素。这些概念最好通过例子来解释。让我们从创建一个简单的类开始。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="4cd3" class="ma mb it lw b gy mc md l me mf">class Employee():</span><span id="de6f" class="ma mb it lw b gy mg md l me mf">   def __init__(self, emp_id, salary):<br/>      self.emp_id = emp_id<br/>      self.salary = salary</span><span id="e30b" class="ma mb it lw b gy mg md l me mf">  def give_raise(self):<br/>      self.salary = self.salary * 1.05</span></pre><p id="d62b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们创建了一个名为Employee的类。它有两个数据属性，即雇员id (emp_id)和薪金。我们还定义了一个名为give_raise的方法。它将雇员的工资提高了5%。</p><p id="3145" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以创建Employee类的一个实例(即一个Employee类型的对象),并如下应用give_raise方法:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="2948" class="ma mb it lw b gy mc md l me mf">emp1 = Employee(1001, 56000)</span><span id="c504" class="ma mb it lw b gy mg md l me mf">print(emp1.salary)<br/>56000</span><span id="9268" class="ma mb it lw b gy mg md l me mf">emp1.give_raise()</span><span id="ece8" class="ma mb it lw b gy mg md l me mf">print(emp1.salary)<br/>58800.0</span></pre><p id="49f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">OOP允许我们基于另一个类创建一个类。例如，我们可以基于Employee类创建Manager类。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="6057" class="ma mb it lw b gy mc md l me mf">class Manager(Employee):<br/>   pass</span></pre><p id="d4b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个场景中，Manager是Employee类的一个子类。子类从父类复制属性(数据和程序属性)。这个概念叫做<strong class="lb iu">继承。</strong></p><p id="37cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">需要注意的是，继承并不意味着复制一个类。我们可以部分继承父类(或基类)。Python还允许添加新属性以及修改现有属性。因此，继承带来了很大的灵活性。</p><p id="eb41" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在可以创建一个经理对象，就像创建一个雇员对象一样。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="aaa2" class="ma mb it lw b gy mc md l me mf">mgr1 = Manager(101, 75000)<br/>print(mgr1.salary)<br/>75000</span></pre><p id="6b17" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了从父类继承的属性之外，子类还可以有新的属性。此外，我们可以选择修改或覆盖继承的属性。</p><p id="2b57" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们更新give_raise方法，以便它为经理应用10%的加薪。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="e143" class="ma mb it lw b gy mc md l me mf">class Manager(Employee):</span><span id="6579" class="ma mb it lw b gy mg md l me mf">   def give_raise(self):<br/>      self.salary = self.salary * 1.10</span><span id="6d35" class="ma mb it lw b gy mg md l me mf">mgr1 = Manager(101, 75000)<br/>print(mgr1.salary)<br/>75000</span><span id="04e3" class="ma mb it lw b gy mg md l me mf">mgr1.give_raise()<br/>print(mgr1.salary)<br/>82500</span></pre><p id="1fee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将创建Employee类的另一个子类。Director类继承了Employee类的属性，并用20%的增量修改了give_raise方法。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="d71a" class="ma mb it lw b gy mc md l me mf">class Director(Employee):</span><span id="2066" class="ma mb it lw b gy mg md l me mf">   def give_raise(self):<br/>     self.salary = self.salary * 1.20</span></pre></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><p id="994b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在有三个不同类，它们都有一个give_raise方法。虽然方法的名称是相同的，但是对于不同类型的对象，它的行为是不同的。这是一个<strong class="lb iu">多态性</strong>的例子。</p><p id="2956" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">多态允许对不同的底层操作使用相同的接口。关于我们的manager和director对象的例子，我们可以像使用employee类的实例一样使用它们。</p><p id="bd0d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看多态性的作用。我们将定义一个将加薪应用于雇员列表的函数。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="cc3b" class="ma mb it lw b gy mc md l me mf">def bulk_raise(list_of_emps):<br/>   for emp in list_of_emps:<br/>      emp.give_raise()</span></pre><p id="e00c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">bulk_raise函数获取雇员列表，并将give_raise函数应用于列表中的每个对象。下一步是创建不同类型的员工列表。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="bd9b" class="ma mb it lw b gy mc md l me mf">emp1 = Employee(101, 45000)<br/>emp2 = Manager(103, 60000)<br/>emp3 = Director(105, 70000)</span><span id="ed91" class="ma mb it lw b gy mg md l me mf">list_of_emps = [emp1, emp2, emp3]</span></pre><p id="d962" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的列表包含一个雇员、一个经理和一个董事对象。我们现在可以调用bulk_raise函数。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="76ce" class="ma mb it lw b gy mc md l me mf">bulk_raise(list_of_emps)</span><span id="da89" class="ma mb it lw b gy mg md l me mf">print(emp1.salary)<br/>47250.0</span><span id="d67b" class="ma mb it lw b gy mg md l me mf">print(emp2.salary)<br/>66000.0</span><span id="9b96" class="ma mb it lw b gy mg md l me mf">print(emp3.salary)<br/>84000.0</span></pre><p id="88d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管列表中的每个对象都有不同的类型，但我们不必在函数中显式地声明它。Python知道应用哪个give_raise方法。</p><p id="41e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们在例子中看到的，多态性是通过继承实现的。子类(或子类)利用父类的方法来建立多态性。</p></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><h2 id="ccb7" class="ma mb it bd mo mp mq dn mr ms mt dp mu li mv mw mx lm my mz na lq nb nc nd ne bi translated">结论</h2><p id="395d" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">继承和多态都是面向对象编程的基本概念。这些概念帮助我们创建可扩展且易于维护的代码。</p><p id="587e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">继承是消除不必要的重复代码的好方法。子类可以部分或全部继承父类。Python在继承方面非常灵活。我们可以添加新的属性和方法以及修改现有的属性和方法。</p><p id="569c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">多态性也有助于Python的灵活性。具有特定类型的对象可以像属于不同类型一样使用。我们已经看到了一个使用give_raise方法的例子。</p><p id="dc47" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢您的阅读。如果您有任何反馈，请告诉我。</p></div></div>    
</body>
</html>