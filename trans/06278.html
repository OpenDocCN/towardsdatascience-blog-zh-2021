<html>
<head>
<title>A Quick and Easy Guide To Code Profiling in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中代码剖析的快速简易指南</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/a-quick-and-easy-guide-to-code-profiling-in-python-58c0ed7e602b?source=collection_archive---------19-----------------------#2021-06-05">https://towardsdatascience.com/a-quick-and-easy-guide-to-code-profiling-in-python-58c0ed7e602b?source=collection_archive---------19-----------------------#2021-06-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="b7d5" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">编程；编排</h2><div class=""/><div class=""><h2 id="35f6" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">使用线路分析器查找函数中的瓶颈</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/d8559693fd681330c5436394f1b018b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z5paOgW1oDPUYw4weK42Fg.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">来源:unDraw.co</p></figure><h2 id="97f3" class="li lj it bd lk ll lm dn ln lo lp dp lq lr ls lt lu lv lw lx ly lz ma mb mc iz bi translated"><strong class="ak">简介</strong></h2><p id="cb40" class="pw-post-body-paragraph md me it mf b mg mh kd mi mj mk kg ml lr mm mn mo lv mp mq mr lz ms mt mu mv im bi translated">作为一名数据科学家，你的大部分时间应该花在数据争论和/或训练机器学习模型等任务上。然而，您会发现，当您的代码似乎永远无法执行时，这种情况很快就会消失。出于这个原因，当您需要评估应用程序中的瓶颈并节省您的宝贵时间时，代码剖析就来了。我们今天文章的主角将是<a class="ae lh" href="https://pypi.org/project/line-profiler/" rel="noopener ugc nofollow" target="_blank"> line_profiler </a>包，我们将使用它来逐行剖析一个函数的运行时，这样我们就可以让您更接近代码效率天堂。开始侧写吧！</p><p id="2a09" class="pw-post-body-paragraph md me it mf b mg mw kd mi mj mx kg ml lr my mn mo lv mz mq mr lz na mt mu mv im bi translated">注意，对于本文，我将使用python笔记本(。ipynb ),因为我发现它们非常适合于实验，这使它们成为一个很好的代码剖析工具，因为您会频繁地对更高效的代码进行修改。</p></div><div class="ab cl nb nc hx nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="im in io ip iq"><h2 id="a835" class="li lj it bd lk ll lm dn ln lo lp dp lq lr ls lt lu lv lw lx ly lz ma mb mc iz bi translated">什么是代码剖析？</h2><p id="faa5" class="pw-post-body-paragraph md me it mf b mg mh kd mi mj mk kg ml lr mm mn mo lv mp mq mr lz ms mt mu mv im bi translated">简而言之，代码分析是一种用于检测每个函数或代码行运行时间以及执行频率的方法。这是找到代码中的瓶颈，从而理解如何优化代码的重要一步。我们的方法本质上是定量的，因为它在代码的各个行上产生汇总统计。因此，它为您的代码的哪些部分需要进一步优化提供了可操作的见解。</p><h2 id="e1ce" class="li lj it bd lk ll lm dn ln lo lp dp lq lr ls lt lu lv lw lx ly lz ma mb mc iz bi translated">如何分析一个函数</h2><p id="c506" class="pw-post-body-paragraph md me it mf b mg mh kd mi mj mk kg ml lr mm mn mo lv mp mq mr lz ms mt mu mv im bi translated">探索如何分析我们的代码的最好方法是用一个例子。假设我们有一个简单的函数，将磅转换为千克和克，如下所示:</p><pre class="ks kt ku kv gt ni nj nk nl aw nm bi"><span id="20e0" class="li lj it nj b gy nn no l np nq">def pounds_to_metric(pounds):<br/>  kilograms = pounds / 2.2<br/>  grams = kilograms * 1000<br/>  return 'The amount you entered is equal to {} kilograms and {} grams.'.format(int(kilograms), grams)</span></pre><p id="33b4" class="pw-post-body-paragraph md me it mf b mg mw kd mi mj mx kg ml lr my mn mo lv mz mq mr lz na mt mu mv im bi translated"><strong class="mf jd">快速肮脏的方法:%timeit </strong></p><p id="8745" class="pw-post-body-paragraph md me it mf b mg mw kd mi mj mx kg ml lr my mn mo lv mz mq mr lz na mt mu mv im bi translated">如果我们想得到这个函数的估计运行时间，我们可以使用IPython的timeit <a class="ae lh" href="https://ipython.readthedocs.io/en/stable/interactive/magics.html" rel="noopener ugc nofollow" target="_blank">神奇函数</a>，它将给出总的执行时间。</p><pre class="ks kt ku kv gt ni nj nk nl aw nm bi"><span id="2071" class="li lj it nj b gy nn no l np nq">%timeit pounds_to_metric(115)</span></pre><blockquote class="nr ns nt"><p id="2d13" class="md me nu mf b mg mw kd mi mj mx kg ml nv my mn mo nw mz mq mr nx na mt mu mv im bi translated">跑得最慢的人比跑得最快的人多花了11.57倍的时间。这可能意味着正在缓存中间结果。1000000次循环，最佳5次:每次循环1.27秒</p></blockquote><p id="0972" class="pw-post-body-paragraph md me it mf b mg mw kd mi mj mx kg ml lr my mn mo lv mz mq mr lz na mt mu mv im bi translated">从输出中，我们可以看到执行了多次运行和循环。% time它多次运行示例代码，并提供对代码执行时间的估计，使其更准确地表示实际运行时间，而不仅仅依赖于一次迭代。输出中显示的平均值是考虑到多次运行中的每一次运行的运行时间的汇总。</p><p id="b874" class="pw-post-body-paragraph md me it mf b mg mw kd mi mj mx kg ml lr my mn mo lv mz mq mr lz na mt mu mv im bi translated"><strong class="mf jd">严格的方法:线路剖面仪</strong></p><p id="8f82" class="pw-post-body-paragraph md me it mf b mg mw kd mi mj mx kg ml lr my mn mo lv mz mq mr lz na mt mu mv im bi translated">因为%timeit只对一行代码计时，所以当我们想要快速评估一个函数的运行时性能时，它就派上了用场。然而，不难看出为什么这不能很好地扩展到更大的代码块。因此，如果我们想知道函数中的每一行运行了多长时间，这就是line profiler包派上用场的地方。</p><p id="3775" class="pw-post-body-paragraph md me it mf b mg mw kd mi mj mx kg ml lr my mn mo lv mz mq mr lz na mt mu mv im bi translated">因为这个包不是Python标准库的一部分，我们需要单独安装它。这可以通过pip install命令轻松完成。接下来，我们将它加载到会话中，如下所示。</p><pre class="ks kt ku kv gt ni nj nk nl aw nm bi"><span id="764c" class="li lj it nj b gy nn no l np nq">%load_ext line_profiler</span></pre><p id="7d12" class="pw-post-body-paragraph md me it mf b mg mw kd mi mj mx kg ml lr my mn mo lv mz mq mr lz na mt mu mv im bi translated">我们现在可以使用line profiler的神奇命令%lprun来评估pounds_to_metric函数中特定代码行的运行时。首先，我们使用-f标志来指定我们要分析的函数，后跟我们要分析的函数。注意，函数名的传递不带任何括号。最后，我们指定我们想要分析的确切函数调用，以及任何必需的参数。我会像之前一样用115作为磅数。</p><pre class="ks kt ku kv gt ni nj nk nl aw nm bi"><span id="9f69" class="li lj it nj b gy nn no l np nq">%lprun -f pounds_to_metric pounds_to_metric(115)</span></pre><h2 id="c9f4" class="li lj it bd lk ll lm dn ln lo lp dp lq lr ls lt lu lv lw lx ly lz ma mb mc iz bi translated">分析统计数据</h2><p id="d0e5" class="pw-post-body-paragraph md me it mf b mg mh kd mi mj mk kg ml lr mm mn mo lv mp mq mr lz ms mt mu mv im bi translated">运行前面一行代码会生成一个总结分析统计信息的表，如下所示。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ny"><img src="../Images/8e3fcc709503af1ce254bfe3034ebee7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UXY6mmtJDgek6gh3Titfaw.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">作者图片</p></figure><p id="e1e5" class="pw-post-body-paragraph md me it mf b mg mw kd mi mj mx kg ml lr my mn mo lv mz mq mr lz na mt mu mv im bi translated">现在，让我们浏览一下汇总表的各个列！</p><p id="f639" class="pw-post-body-paragraph md me it mf b mg mw kd mi mj mx kg ml lr my mn mo lv mz mq mr lz na mt mu mv im bi translated">首先，显示指定函数<strong class="mf jd">行号</strong>的列，随后是显示该行被执行次数的<strong class="mf jd">命中</strong>列。接下来，<strong class="mf jd">时间</strong>列显示了每一行执行所花费的总时间。该列使用一个特定的计时器单位，可以在输出的第一行中找到。这里，计时器单位使用科学记数法(1e-06)以微秒为单位列出。例如，我们可以看到第五行花了12个定时器单位，或者说，大约13微秒来运行。</p><p id="c06a" class="pw-post-body-paragraph md me it mf b mg mw kd mi mj mx kg ml lr my mn mo lv mz mq mr lz na mt mu mv im bi translated">此外,<strong class="mf jd"> Per Hit </strong>列给出了执行一行所花费的平均时间，通过将time列除以Hits列来计算。假设我们在这个函数中的所有点击都等于1，那么Time和Per Hit列显示了类似的结果。<strong class="mf jd"> %这可以帮助我们检测在函数中占用最多时间的代码行。最后，在<strong class="mf jd">行内容</strong>列中显示每一行的源代码。很整洁，是吧？</strong></p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nz oa l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated"><a class="ae lh" href="http://gph.is/1Z8bdu6" rel="noopener ugc nofollow" target="_blank"> Giphy </a></p></figure><h2 id="8017" class="li lj it bd lk ll lm dn ln lo lp dp lq lr ls lt lu lv lw lx ly lz ma mb mc iz bi translated">结论</h2><p id="bf82" class="pw-post-body-paragraph md me it mf b mg mh kd mi mj mk kg ml lr mm mn mo lv mp mq mr lz ms mt mu mv im bi translated">至此，我们总结了Python中代码剖析的快速简单指南。回想一下，我们讨论了如何使用line-profiler模块评估函数的性能，以及为什么这种方法比使用%timeit更好。我希望这篇文章对你有用，欢迎在评论中提问。如果你喜欢这篇文章，一定要看看我在Medium上的其他文章。快乐剖析！</p></div></div>    
</body>
</html>