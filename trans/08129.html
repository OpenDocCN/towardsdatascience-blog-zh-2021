<html>
<head>
<title>5 Data Transformers to know from Scikit-Learn</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从Scikit了解5种数据转换器-了解</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/5-data-transformers-to-know-from-scikit-learn-612bc48b8c89?source=collection_archive---------19-----------------------#2021-07-26">https://towardsdatascience.com/5-data-transformers-to-know-from-scikit-learn-612bc48b8c89?source=collection_archive---------19-----------------------#2021-07-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8f22" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">您可能不知道存在数据转换技术。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/04360ee904d359696bb841290038739c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5FGF9WZH-W7V5gc0M2Yk8w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来自作者</p></figure><blockquote class="ky kz la"><p id="7b0f" class="lb lc ld le b lf lg ju lh li lj jx lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">如果您喜欢我的内容，并希望获得更多关于数据或数据科学家日常生活的深入知识，请考虑在此订阅我的<a class="ae ly" href="https://cornellius.substack.com/welcome" rel="noopener ugc nofollow" target="_blank">简讯。</a></p></blockquote><p id="dd2a" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">作为数据科学家，我们经常面临许多在探索数据和开发机器学习时遇到困难的情况。斗争可能来自于统计假设，谁不适合你的数据或数据中有太多的噪音。在这种情况下，您可能需要转换数据以获得更好的清晰度或满足统计方法的假设。</p><p id="4692" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">之前，我读过一篇适合初学者的关于数据转换的文章，你可以在这里阅读<a class="ae ly" rel="noopener" target="_blank" href="/beginner-explanation-for-data-transformation-9add3102f3bf?sk=a858653e1ecec13a74d1213f9d01393c"/>。</p><div class="mc md gp gr me mf"><a rel="noopener follow" target="_blank" href="/beginner-explanation-for-data-transformation-9add3102f3bf"><div class="mg ab fo"><div class="mh ab mi cl cj mj"><h2 class="bd iu gy z fp mk fr fs ml fu fw is bi translated">数据转换的初级解释</h2><div class="mm l"><p class="bd b dl z fp mk fr fs ml fu fw dk translated">towardsdatascience.com</p></div></div><div class="mn l"><div class="mo l mp mq mr mn ms ks mf"/></div></div></a></div><p id="831c" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">如果您不了解什么是数据转换以及转换数据的好处(或坏处),我建议您阅读上面的文章。如果你觉得已经理解了这些概念，那么我们可以进行更深入的讨论。</p><p id="0463" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">我要说的一个免责声明是，在进行数据转换时，您需要非常小心，因为您最终会得到一个转换后的数据，它不再是您的原始数据。你需要理解为什么你需要转换你的数据和转换后的数据输出，这就是我写这篇文章的原因。</p><p id="2c48" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">在本文中，我想从Scikit-Learn中概述一个更高级的数据转换，我们可以在特定的情况下使用它。它们是什么？让我们开始吧。</p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h1 id="f4ba" class="na nb it bd nc nd ne nf ng nh ni nj nk jz nl ka nm kc nn kd no kf np kg nq nr bi translated">1.分位数变压器</h1><p id="7ccd" class="pw-post-body-paragraph lb lc it le b lf ns ju lh li nt jx lk lz nu ln lo ma nv lr ls mb nw lv lw lx im bi translated">分位数转换是一种非参数数据转换技术，用于将数字数据分布转换为遵循特定的数据分布(通常为<strong class="le iu">高斯分布</strong>(正态分布))。在Scikit-Learn中，<a class="ae ly" href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.QuantileTransformer.html#sklearn.preprocessing.QuantileTransformer" rel="noopener ugc nofollow" target="_blank">分位数转换器</a>可以将数据转换成正态分布或均匀分布；这取决于您的发行参考。</p><p id="5c2d" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">分位数变换是如何工作的？从概念上讲，分位数转换器将<a class="ae ly" href="https://en.wikipedia.org/wiki/Quantile_function" rel="noopener ugc nofollow" target="_blank">分位数函数</a>应用到要转换的数据中。分位数函数本身是累积分布函数(CDF) 的<strong class="le iu">反函数，你可以在这里查看正态分布的<a class="ae ly" href="https://en.wikipedia.org/wiki/Normal_distribution#Quantile_function" rel="noopener ugc nofollow" target="_blank">。如果使用均匀分布，转换后的数据将是数据的分位数位置。让我们使用示例数据来更好地理解转换。</a></strong></p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="28cf" class="oc nb it ny b gy od oe l of og">import seaborn as sns<br/>import numpy as np<br/>from sklearn.preprocessing import QuantileTransformer</span><span id="6247" class="oc nb it ny b gy oh oe l of og">#Using mpg data<br/>mpg = sns.load_dataset('mpg')</span><span id="7102" class="oc nb it ny b gy oh oe l of og">#Quantile Transformation (by default it is Uniform)<br/>quantile_transformer = QuantileTransformer(random_state=0,  output_distribution='uniform')<br/>mpg['mpg_trans'] = pd.Series(quantile_transformer.fit_transform(np.array(mpg['mpg']).reshape(-1, 1))[:,0])</span><span id="4538" class="oc nb it ny b gy oh oe l of og">mpg[['mpg', 'mpg_trans']].head()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/6918348eafeed1dcba22ab8567895677.png" data-original-src="https://miro.medium.com/v2/resize:fit:408/format:webp/1*-tnMwzSIxoXfTQ6_XD05Ag.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="d7a7" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">上图可以看到，索引0中的真实数据是18，转换后的数据是0.28；为什么是0，28？让我们试着取mpg列的分位数0.28。</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="9e4c" class="oc nb it ny b gy od oe l of og">np.quantile(mpg['mpg'], 0.28)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/19f5f3f86d6755c290bb2057af7f0bc3.png" data-original-src="https://miro.medium.com/v2/resize:fit:264/format:webp/1*wrocVmcF04Uj9v7IXukXkQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="d906" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">结果是18；这意味着转换后的数据是实际数据的分位数位置的近似值。请注意，当您应用分位数转换时，您会丢失转换变量之间的线性相关性，因为分位数转换器是一个非线性转换器。然而，由于数据已经改变，因此不期望测量转换变量之间的线性相关性。</p><p id="a182" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">分位数转换通常用于移除异常值或拟合正态分布，尽管有许多类似的数据转换可供比较。</p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h1 id="ae17" class="na nb it bd nc nd ne nf ng nh ni nj nk jz nl ka nm kc nn kd no kf np kg nq nr bi translated">2.电力变压器</h1><p id="3b1c" class="pw-post-body-paragraph lb lc it le b lf ns ju lh li nt jx lk lz nu ln lo ma nv lr ls mb nw lv lw lx im bi translated">分位数变压器是应用分位数函数的非参数变压器，<strong class="le iu"> Power Transformer是通过</strong><a class="ae ly" href="https://en.wikipedia.org/wiki/Exponentiation#Power_functions" rel="noopener ugc nofollow" target="_blank"><strong class="le iu">Power Function</strong></a>实现的参数变压器。与分位数转换器一样，Power Transformer通常用于转换遵循正态分布的数据。</p><p id="9969" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">从Scikit-Learn中，电源变压器类中给出了两种方法:<a class="ae ly" href="https://en.wikipedia.org/wiki/Power_transform#Yeo%E2%80%93Johnson_transformation" rel="noopener ugc nofollow" target="_blank"> Yeo-Johnson变换</a>和<a class="ae ly" href="https://www.statisticshowto.com/box-cox-transformation/" rel="noopener ugc nofollow" target="_blank"> Box-Cox变换</a>。这两种方法的基本区别在于它们允许转换的数据— <strong class="le iu"> Box-Cox要求数据为正，而Yeo-Johnson允许数据同时为负和正</strong>。让我们使用示例数据来使用Scikit-Learn中的电源转换。我想使用以前的数据集，因为有些要素不是正态分布的，例如，权重要素。</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="cee3" class="oc nb it ny b gy od oe l of og">sns.distplot(mpg['weight'])</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/3cfea64b0fe45dd6867f321da9825c8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:996/format:webp/1*v8Ea9MNZNcOpN7OJppJQFQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="870a" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">正如我们在上面的图像中所看到的，分布明显偏右或正偏，这意味着它没有遵循正态分布。让我们使用电力变压器来转换数据，以密切遵循正态分布。</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="6cbe" class="oc nb it ny b gy od oe l of og">from sklearn.preprocessing import PowerTransformer<br/>pt = PowerTransformer(method = 'box-cox')<br/>mpg['weight_trans'] = pt.fit_transform(np.array(mpg['weight']).reshape(-1,1))[:,0]</span><span id="1ec8" class="oc nb it ny b gy oh oe l of og">sns.distplot(mpg['weight_trans'])</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/675d20a41b08e67222b67f35e7c64c95.png" data-original-src="https://miro.medium.com/v2/resize:fit:986/format:webp/1*6RUjQGPigNnhUiD_nQs2cQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="bea7" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">使用Power Transformer(本例中的Box-Cox)会使数据更接近正态分布。由于数据非常倾斜，转换后的数据并不完全遵循正态分布，但它比未转换的数据更接近正态分布。</p><p id="8aea" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">虽然Quantile Transformer和Power Transformer都可以通过保留等级将您的数据转换为另一种数据分布，但其用途可能仍取决于您的数据和您对转换的预期比例。没有确定的方式说一个变压器比另一个好；要知道哪种转换器适合您的数据，您可以做的就是应用它并衡量您使用的指标。</p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h1 id="b994" class="na nb it bd nc nd ne nf ng nh ni nj nk jz nl ka nm kc nn kd no kf np kg nq nr bi translated">3.k-bin离散化</h1><p id="1f3c" class="pw-post-body-paragraph lb lc it le b lf ns ju lh li nt jx lk lz nu ln lo ma nv lr ls mb nw lv lw lx im bi translated">离散化是一个<strong class="le iu">将连续特征转化为分类特征的过程，方法是将其划分为期望值范围(区间)</strong>内的几个区间。我将向您展示下表中的示例数据和离散化转换。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi om"><img src="../Images/05c4d1ad47bf7194bb0d09193fb74734.png" data-original-src="https://miro.medium.com/v2/resize:fit:304/format:webp/1*92UtTMzpbq74upjRAP_Tig.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="64c0" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">在上表中，我有五个数据点(10，15，20，25，30)，我将连续值离散化为一个分类特征，称为Bins，其中包含值1和2。在bin特性中，我将10–20之间的值输入到类别1中，其余的输入到类别2中——这就是离散化的基本工作方式。</p><p id="5351" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">在Scikit-Learn中，使用具有设定间隔(通常为分位数)的宁滨进行离散化的过程在KBinsDiscretization类中编译。让我们用数据集的例子来更好地理解这个函数。</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="8cb7" class="oc nb it ny b gy od oe l of og">from sklearn.preprocessing import KBinsDiscretizer</span><span id="1c7c" class="oc nb it ny b gy oh oe l of og">#Setting the divided bins into 5 bins with quantile interval and transformation into ordinal category</span><span id="151c" class="oc nb it ny b gy oh oe l of og">est = KBinsDiscretizer(n_bins = 5, encode = 'ordinal', strategy='quantile')</span><span id="5916" class="oc nb it ny b gy oh oe l of og">mpg['mpg_discrete'] = est.fit_transform(np.array(mpg['mpg']).reshape(-1,1))</span><span id="5118" class="oc nb it ny b gy oh oe l of og">mpg[['mpg', 'mpg_discrete']].sample(5)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi on"><img src="../Images/86f6bfaf329db9152ecfd10ddfb5be80.png" data-original-src="https://miro.medium.com/v2/resize:fit:478/format:webp/1*CV1S6tP5iZkPEpwAcc6VPg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="7656" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">从上表可以看出，连续特征mpg被离散化为有序分类特征。您通常会从离散化特性的一键编码中受益；这就是为什么KBinsDiscretizer还为您提供了One-Hot功能(事实上，默认的编码参数是‘One Hot’)。然而，我经常在OHE过程中使用Pandas get_dummies特性，因为它比直接从KBinsDiscretizer中处理更容易。</p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h1 id="f62c" class="na nb it bd nc nd ne nf ng nh ni nj nk jz nl ka nm kc nn kd no kf np kg nq nr bi translated">4.特征二值化</h1><p id="31ce" class="pw-post-body-paragraph lb lc it le b lf ns ju lh li nt jx lk lz nu ln lo ma nv lr ls mb nw lv lw lx im bi translated">特征二值化是一个<strong class="le iu">简单的离散化过程，使用一定的阈值将连续特征转换成分类特征</strong>。要素二值化的结果是布尔值-真或假(0或1)。让我们尝试使用Scikit中的二进制化类——学习理解概念。</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="9b3e" class="oc nb it ny b gy od oe l of og">from sklearn.preprocessing import Binarizer</span><span id="b92a" class="oc nb it ny b gy oh oe l of og">#Setting the threshold to 20<br/>transformer = Binarizer( threshold = 20)</span><span id="daa6" class="oc nb it ny b gy oh oe l of og">mpg['mpg_binary'] = transformer.fit_transform(np.array(mpg['mpg']).reshape(-1,1))</span><span id="396c" class="oc nb it ny b gy oh oe l of og">mpg[['mpg', 'mpg_binary']].sample(5)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/b5c683955278c623a46c35a3c1371a6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:440/format:webp/1*a-eiMOdCQ3xuwl4csjXmzg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="33c2" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">从上表可以看出，小于20的值将返回False (0)，其余的值将返回True (1)。门槛是我们经常设定的；您可能想知道为什么设置当前阈值。请注意，如果您将KBinsDiscretizer n_bins使用为2，那么如果阈值与bin边缘值相似，它将与二进制化器相似。</p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h1 id="a3a3" class="na nb it bd nc nd ne nf ng nh ni nj nk jz nl ka nm kc nn kd no kf np kg nq nr bi translated">5.功能变压器</h1><p id="0c6a" class="pw-post-body-paragraph lb lc it le b lf ns ju lh li nt jx lk lz nu ln lo ma nv lr ls mb nw lv lw lx im bi translated">Scikit-Learn为我们提供了许多可以用于数据预处理管道的转换方法。然而，我们想应用我们自己的函数进行数据转换，但是Scikit-Learn没有提供它。这就是为什么Scikit-Learn也提供了Function Transformers类来开发他们自己的数据转换函数。</p><p id="f8fe" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">为什么我们要用Scikit-Learn开发自己的自定义函数？您的模型只需要有一个Scikit-Learn管道，并且需要在您的数据管道中有一个自定义转换。使用模型和数据越多，您就会意识到自定义转换器的使用频率比您想象的要高。</p><p id="7ed6" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">让我们试着用函数变形金刚创造我们自己的变形金刚。我想在我的数据管道中将我的数据转换成日志值，但是Scikit-Learn没有提供该功能；这就是为什么我需要自己开发它。</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="0507" class="oc nb it ny b gy od oe l of og">from sklearn.preprocessing import FunctionTransformer</span><span id="4683" class="oc nb it ny b gy oh oe l of og">#Passing the log function from numpy which would be applied to every data in the column</span><span id="8174" class="oc nb it ny b gy oh oe l of og">transformer = FunctionTransformer(np.log, validate=True)</span><span id="6677" class="oc nb it ny b gy oh oe l of og">mpg['mpg_log'] = transformer.fit_transform(np.array(mpg['mpg']).reshape(-1,1))<br/>mpg[['mpg', 'mpg_log']].head(5)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi op"><img src="../Images/4a19462c9d59725a5938cb0509d81a81.png" data-original-src="https://miro.medium.com/v2/resize:fit:386/format:webp/1*T9HoUbIKOQlI9TB9KMiStA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="a1ad" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">使用函数转换器，您可以像上面的结果一样控制自己的转换结果。数据被转换成日志数据，您可以使用它进行进一步的处理。</p><p id="5096" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">你不一定需要依赖Numpy包；你总是可以创建你自己的函数——重要的是函数产生一个输出。例如，我在下面的代码中创建了自己的函数。</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="c66c" class="oc nb it ny b gy od oe l of og">def cust_func(x):<br/>    return x + 1</span></pre><p id="5f7e" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">该函数将通过加法过程返回一个数值(加1)。让我们将它传递到我们的自定义变压器中。</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="0805" class="oc nb it ny b gy od oe l of og">transformer = FunctionTransformer(cust_func, validate=True)<br/>mpg['mpg_cust'] = transformer.fit_transform(np.array(mpg['mpg']).reshape(-1,1))<br/>mpg[['mpg', 'mpg_cust']].head(5)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/8f208f73010396358bbfda5d85973eeb.png" data-original-src="https://miro.medium.com/v2/resize:fit:410/format:webp/1*cQet1UdvSfr3lYgdzL5qcw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="9f8a" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">从上表中可以看出，我们的值结果遵循我们之前开发的函数。Function Transformer听起来很简单，但从长远来看，它将有助于您的管道过程。</p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h1 id="01ac" class="na nb it bd nc nd ne nf ng nh ni nj nk jz nl ka nm kc nn kd no kf np kg nq nr bi translated">结论</h1><p id="6e1d" class="pw-post-body-paragraph lb lc it le b lf ns ju lh li nt jx lk lz nu ln lo ma nv lr ls mb nw lv lw lx im bi translated">数据转换是数据工作中的一个典型过程，如果您知道数据转换过程的结果，通常会对您的工作有所帮助。Scikit-Learn为我们提供了一些数据转换方法，包括:</p><ol class=""><li id="db5f" class="or os it le b lf lg li lj lz ot ma ou mb ov lx ow ox oy oz bi translated"><strong class="le iu">分位数转换器</strong></li><li id="583d" class="or os it le b lf pa li pb lz pc ma pd mb pe lx ow ox oy oz bi translated"><strong class="le iu">电力变压器</strong></li><li id="9a49" class="or os it le b lf pa li pb lz pc ma pd mb pe lx ow ox oy oz bi translated"><strong class="le iu"> K-Bins离散化器</strong></li><li id="9a01" class="or os it le b lf pa li pb lz pc ma pd mb pe lx ow ox oy oz bi translated"><strong class="le iu">特征二值化</strong></li><li id="0c8a" class="or os it le b lf pa li pb lz pc ma pd mb pe lx ow ox oy oz bi translated"><strong class="le iu">功能变压器</strong></li></ol><p id="ada2" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">希望有帮助！</p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><p id="a940" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">在我的<a class="ae ly" href="https://www.linkedin.com/in/cornellius-yudha-wijaya/" rel="noopener ugc nofollow" target="_blank"><strong class="le iu">LinkedIn</strong></a><strong class="le iu"/>或<a class="ae ly" href="https://twitter.com/CornelliusYW" rel="noopener ugc nofollow" target="_blank"> <strong class="le iu"> Twitter </strong> </a> <strong class="le iu">上访问我。</strong></p><blockquote class="pf"><p id="5a83" class="pg ph it bd pi pj pk pl pm pn po lx dk translated">如果您没有订阅为中等会员，请考虑通过<a class="ae ly" href="https://cornelliusyudhawijaya.medium.com/membership" rel="noopener">我的推荐</a>订阅。</p></blockquote></div></div>    
</body>
</html>