<html>
<head>
<title>Configuration Files in Python using dataclasses</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用数据类的Python配置文件</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/configuration-files-in-python-using-dataclasses-ec8528e72e01?source=collection_archive---------12-----------------------#2021-10-25">https://towardsdatascience.com/configuration-files-in-python-using-dataclasses-ec8528e72e01?source=collection_archive---------12-----------------------#2021-10-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="16d6" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用dataclasses对Python中的配置文件进行类型安全解析</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/5850422907bb6cfe072cf8c9c910a0c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*mfZCoqPc9AXHiPUg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><h1 id="43c8" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">TL；速度三角形定位法(dead reckoning)</h1><p id="de94" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">有了Python <code class="fe mj mk ml mm b">dataclasses</code>和新的<code class="fe mj mk ml mm b">dataconf</code>库，我们现在可以安全地将配置文件解析成数据类。对于来自Scala的用户来说，这是从case类和PureConfig类型安全解析的简单过渡。要查看Python和PySpark用例中的示例用法，请跳到用法。</p><h1 id="2099" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">介绍</h1><p id="ba65" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">啊，配置文件。一个人必须爱他们，对不对？也许吧？看情况。对于那些使用Scala和其他JVM语言的人，我们可以使用<a class="ae mn" href="https://github.com/lightbend/config" rel="noopener ugc nofollow" target="_blank"> HOCON </a>、json的人类可读格式、<code class="fe mj mk ml mm b">typesafe config</code>和<a class="ae mn" href="https://github.com/pureconfig/pureconfig" rel="noopener ugc nofollow" target="_blank"> pureconfig </a>轻松地将复杂的配置或属性文件直接加载到case类中。有了这些，生活是美好的。我们的Python用户呢？</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mo mp l"/></div></figure><h1 id="a6fc" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">数据类的介绍</h1><p id="b847" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">在Python 3.7中，<a class="ae mn" href="https://www.python.org/dev/peps/pep-0557/" rel="noopener ugc nofollow" target="_blank">数据类</a>通过简单的pip安装向后兼容Python 3.6。通过这个介绍，Python本质上引入了可变格式的Scala case类。但是，<code class="fe mj mk ml mm b">dataclasses</code>可以被冻结以实现不可变的变体。有了这个介绍，我们的Python用户能实现同样的简化的配置文件解析吗？还没有。的确，PyHocon已经存在了很多年，但是仍然缺少了一些东西。2020年5月，Github用户<a class="ae mn" href="https://github.com/zifeo" rel="noopener ugc nofollow" target="_blank"> @zifeo </a>将他的库<a class="ae mn" href="https://github.com/zifeo/dataconf" rel="noopener ugc nofollow" target="_blank"> dataconf </a>发布到PyPI，这是链中的最后一环。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mo mp l"/></div></figure><h1 id="f837" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">数据会议库</h1><p id="1f19" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated"><code class="fe mj mk ml mm b">dataconf</code>所做的是允许用户读入带有定义参数的配置文件，并直接输入到Python <code class="fe mj mk ml mm b">dataclass</code>中。大约在2021年8月，我在寻找一种将配置文件轻松传递到Python的方法时偶然发现了这个库。根据我使用Scala的经验和对Python的<code class="fe mj mk ml mm b">dataclasses</code>的了解，我很高兴看到这个功能。在过去的几个月里，我添加了一些已经在版本<code class="fe mj mk ml mm b">0.1.5</code>、<code class="fe mj mk ml mm b">0.1.6</code>和<code class="fe mj mk ml mm b">0.2.0</code>中发布的附加特性，以进一步复制<code class="fe mj mk ml mm b">pureconfig</code>。目前，<code class="fe mj mk ml mm b">dataconf</code>已经快速成熟，目前是版本<code class="fe mj mk ml mm b">0.3.0</code>。由于缺少Python <code class="fe mj mk ml mm b">3.7.x</code>中没有的更新，<code class="fe mj mk ml mm b">dataconf</code>将只能在Python <code class="fe mj mk ml mm b">&gt;= 3.8.x</code>上工作。</p><p id="c1bc" class="pw-post-body-paragraph ln lo iq lp b lq mq jr ls lt mr ju lv lw ms ly lz ma mt mc md me mu mg mh mi ij bi translated">在<a class="ae mn" href="https://www.truedigital.com/" rel="noopener ugc nofollow" target="_blank"> True Digital Group </a>这里，我们正在开发一个定制的MLOps管道，用Python以自动化的方式为我们的用户和客户服务。然而，为了编排这些管道，我们将使用类似于我们在Scala中构建的数据管道的配置文件。答案是。我添加了解析嵌套配置的能力，并使用Python中的抽象基类<code class="fe mj mk ml mm b">dataclasses</code>模拟Scala密封特征的行为。这个库可能并不完美，但是我们现在可以依赖它来满足我们的Python管道需求。</p><p id="5d11" class="pw-post-body-paragraph ln lo iq lp b lq mq jr ls lt mr ju lv lw ms ly lz ma mt mc md me mu mg mh mi ij bi translated">为了使用<code class="fe mj mk ml mm b">dataconf</code>，用户入口点主要是<code class="fe mj mk ml mm b">load</code>和<code class="fe mj mk ml mm b">loads</code>。然而，如果传递<code class="fe mj mk ml mm b">ConfigTree</code>对象，它们将需要使用<code class="fe mj mk ml mm b">__parse</code>。当前的计划是在未来的版本中，用<code class="fe mj mk ml mm b">from_config</code>、<code class="fe mj mk ml mm b">from_file</code>和<code class="fe mj mk ml mm b">from_string</code>重构用法，使之类似于<code class="fe mj mk ml mm b">pureconfig</code>或另一种类似的模式。带代码的演示报告可在<a class="ae mn" href="https://github.com/dwsmith1983/demo-dataconf" rel="noopener ugc nofollow" target="_blank">这里</a>找到。最后注意，版本<code class="fe mj mk ml mm b">0.2.0</code>和更低版本不能解析<code class="fe mj mk ml mm b">-</code>，所以使用版本<code class="fe mj mk ml mm b">0.2.1</code>或更高版本。</p><h1 id="b4b0" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">用法示例</h1><p id="d113" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">假设我们需要运行一个管道，接收数据或数据源，进行一些处理，然后将数据写出来。然而，数据可能来自Python中许多不同的文件格式，或者来自表、sql查询或HDFS路径。在这种情况下，使用配置文件、数据类和<code class="fe mj mk ml mm b">dataconf</code>可以简化我们的工作并避免分支。在示例中，我使用抽象元类来处理不同的输入类型。有了这个，我可以让<code class="fe mj mk ml mm b">PipeParams</code>或<code class="fe mj mk ml mm b">Params</code>手柄决定<code class="fe mj mk ml mm b">dataclass</code>匹配。所有的类都带有<code class="fe mj mk ml mm b">load_df</code>,所以我们可以使用相同的方法名调用来加载数据帧，而不管哪个被解析。下面的例子仅仅是关于如何使用dataclasses和<code class="fe mj mk ml mm b">dataconf</code>来简化你的产品编码的皮毛。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mo mp l"/></div></figure></div><div class="ab cl mv mw hu mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ij ik il im in"><p id="6fd3" class="pw-post-body-paragraph ln lo iq lp b lq mq jr ls lt mr ju lv lw ms ly lz ma mt mc md me mu mg mh mi ij bi translated"><em class="nc">原载于2021年10月25日</em><a class="ae mn" href="https://tech.trueanalytics.ai/posts/dataconf-at-tdg/" rel="noopener ugc nofollow" target="_blank"><em class="nc">https://tech . true analytics . ai</em></a><em class="nc">。</em></p></div></div>    
</body>
</html>