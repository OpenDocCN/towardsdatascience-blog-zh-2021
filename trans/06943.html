<html>
<head>
<title>Consistency of Bilinear Upsampling Layer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">双线性上采样层的一致性</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/consistency-of-bilinear-upsampling-layer-76458f52d817?source=collection_archive---------31-----------------------#2021-06-23">https://towardsdatascience.com/consistency-of-bilinear-upsampling-layer-76458f52d817?source=collection_archive---------31-----------------------#2021-06-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="592e" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/hands-on-tutorials" rel="noopener" target="_blank">实践教程</a></h2><div class=""/><div class=""><h2 id="bf6d" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">TensorFlow-Keras 2.5和Apple Core ML的代码，通过训练和预测产生一致的结果</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/3e68ca5ebb343e69a58dcea9df04c2a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*88rtEuwOF2nW21Jv"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">照片由<a class="ae lh" href="https://unsplash.com/@jstrippa?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">詹姆斯·哈里逊</a>在<a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><h1 id="de54" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">介绍</h1><p id="b5ac" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">深度学习狂热者中众所周知，TensorFlow中的双线性上采样层存在像素偏移问题。通过在TensorFlow 2.x中为它们添加“align_corner”属性，这一问题已得到部分修复。但问题仍然存在，当通过各种版本将TensorFlow中的训练模型导出到另一个DL框架时，会导致计算流不一致。</p><p id="30bd" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">在我的例子中，当使用<strong class="mc jd"> coremltools 3.4 </strong>将训练好的模型从<strong class="mc jd"> TensorFlow 2.5 </strong>转换为<strong class="mc jd"> Apple Core ML </strong>时，具有双线性上采样层的神经网络模型显示出怪异的行为。在无数次的编码、尝试、删除-删除-删除之后，我几乎放弃了TensorFlow和Core ML之间的上采样层的一致结果。</p><blockquote class="nb nc nd"><p id="3cae" class="ma mb ne mc b md mw kd mf mg mx kg mi nf my ml mm ng mz mp mq nh na mt mu mv im bi translated">我想在最新的TensorFlow 2.5中使用Keras进行Windows PC中的训练，我想使用以前的coremltools 3.4将训练好的模型转换为macOS笔记本电脑的Core ML。这是因为2.5版有稳定的自动混合精度计算，也是因为我因为macOS中anaconda和pip的依赖错误而无法使用TF 2.5的coremltools 4.x。</p></blockquote><h2 id="4d55" class="ni lj it bd lk nj nk dn lo nl nm dp ls mj nn no lu mn np nq lw mr nr ns ly iz bi translated">什么是像素偏移问题？</h2><p id="c6bb" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">一些尊敬的程序员对TensorFlow中定义的这个(麻烦的)规范提供了很好的解释。它们对我有帮助，也许对你也有帮助:</p><ul class=""><li id="6a47" class="nt nu it mc b md mw mg mx mj nv mn nw mr nx mv ny nz oa ob bi translated"><strong class="mc jd">Oleksandr Savsunenko</strong>——<a class="ae lh" href="https://medium.com/hackernoon/how-tensorflows-tf-image-resize-stole-60-days-of-my-life-aba5eb093f35" rel="noopener">tensor flow的tf.image.resize如何偷走了我生命中的60天</a></li><li id="aa15" class="nt nu it mc b md oc mg od mj oe mn of mr og mv ny nz oa ob bi translated"><strong class="mc jd">Matthijs holle mans</strong>—<a class="ae lh" href="https://machinethink.net/blog/coreml-upsampling/" rel="noopener ugc nofollow" target="_blank">岩心ML中的上采样</a></li><li id="bfc8" class="nt nu it mc b md oc mg od mj oe mn of mr og mv ny nz oa ob bi translated"><strong class="mc jd">巴特·沃伦斯基</strong>——<a class="ae lh" href="https://bartwronski.com/2021/02/15/bilinear-down-upsampling-pixel-grids-and-that-half-pixel-offset/" rel="noopener ugc nofollow" target="_blank">双线性下/上采样，对齐像素网格，以及臭名昭著的GPU半像素偏移</a></li></ul></div><div class="ab cl oh oi hx oj" role="separator"><span class="ok bw bk ol om on"/><span class="ok bw bk ol om on"/><span class="ok bw bk ol om"/></div><div class="im in io ip iq"><h1 id="c036" class="li lj it bd lk ll oo ln lo lp op lr ls ki oq kj lu kl or km lw ko os kp ly lz bi translated">待解决的问题</h1><p id="45be" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated"><strong class="mc jd"> <em class="ne"> "coremltools 3.4无法正确转换TensorFlow 2.5中的双线性上采样图层。"</em> </strong></p><p id="8ebd" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">这并不奇怪，<strong class="mc jd">只是版本不匹配</strong>其中TensorFlow 2.5可以对齐该层中的图像角，但coremltools 3.4使用原始方法，倾向于像TensorFlow 1.x一样移动图像。</p><blockquote class="nb nc nd"><p id="2cf7" class="ma mb ne mc b md mw kd mf mg mx kg mi nf my ml mm ng mz mp mq nh na mt mu mv im bi translated">然而，无论如何，我必须在我的macOS中使用TensorFlow从我训练过的Keras模型中获得一致的结果，<strong class="mc jd">不管它们的版本如何… </strong></p></blockquote></div><div class="ab cl oh oi hx oj" role="separator"><span class="ok bw bk ol om on"/><span class="ok bw bk ol om on"/><span class="ok bw bk ol om"/></div><div class="im in io ip iq"><h1 id="e425" class="li lj it bd lk ll oo ln lo lp op lr ls ki oq kj lu kl or km lw ko os kp ly lz bi translated">实现双线性上采样层</h1><p id="3c9e" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">我只是在这里上传我的努力。它们是用于双线性上采样的TF-Keras和Core ML的自定义层。</p><h2 id="ec1b" class="ni lj it bd lk nj nk dn lo nl nm dp ls mj nn no lu mn np nq lw mr nr ns ly iz bi translated">在喀拉斯</h2><p id="e3ce" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">这是一个简单的自定义层，没有任何可训练的参数。您必须实现<strong class="mc jd"> call() </strong>来计算张量。我用<a class="ae lh" href="https://www.tensorflow.org/api_docs/python/tf/compat/v1/image/resize_bilinear" rel="noopener ugc nofollow" target="_blank"><strong class="mc jd">TF . compat . v1 . image . resize _ bilinear()</strong></a>但是<a class="ae lh" href="https://www.tensorflow.org/api_docs/python/tf/compat/v1/image/resize" rel="noopener ugc nofollow" target="_blank"><strong class="mc jd">TF . compat . v1 . image . resize()</strong></a>会等价。注意，必须使用<strong class="mc jd"> align_corners=True </strong>。您可以在TensorFlow中使用其他上采样或图像缩放方法。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ot ou l"/></div></figure></div><div class="ab cl oh oi hx oj" role="separator"><span class="ok bw bk ol om on"/><span class="ok bw bk ol om on"/><span class="ok bw bk ol om"/></div><div class="im in io ip iq"><h2 id="d6d5" class="ni lj it bd lk nj nk dn lo nl nm dp ls mj nn no lu mn np nq lw mr nr ns ly iz bi translated">在核心ML中(目标C)</h2><blockquote class="nb nc nd"><p id="bade" class="ma mb ne mc b md mw kd mf mg mx kg mi nf my ml mm ng mz mp mq nh na mt mu mv im bi translated"><strong class="mc jd"> <em class="it">注:</em> </strong>我在2021年7月2日更新了核心ML实现。也请参考底部的最新内容。</p></blockquote><p id="211f" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">在您基于<strong class="mc jd"> MLCustomLayer </strong>的自定义图层类中，您必须实现<strong class="mc jd">encodecommandbuffer</strong>方法来激活GPU。苹果的金属性能着色器提供了效果很好的<a class="ae lh" href="https://developer.apple.com/documentation/metalperformanceshaders/mpscnnupsamplingbilinear?language=objc" rel="noopener ugc nofollow" target="_blank"><strong class="mc jd">mpscnnupsampling双线性</strong> </a>，结果似乎与<strong class="mc jd"> tf的一致...上面Keras中使用的image.resize_bilinear </strong>。多亏了这个<strong class="mc jd">mpscnnupnupsampling bilinear</strong>，我不用自己写METAL代码了。</p><p id="d3a0" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">老实说，我用的是<a class="ae lh" href="https://developer.apple.com/documentation/metalperformanceshaders/mpsimagebilinearscale?language=objc" rel="noopener ugc nofollow" target="_blank"><strong class="mc jd">MPSImageBilinearScale</strong></a>，不是<strong class="mc jd"> MPSCNN...</strong>，起初。结果明显不稳定，出乎意料。在我的理解中，它们应该是相同的“双线性”和“上采样(=重新缩放)”，具有对齐的角，但它们不是。我猜<strong class="mc jd">MPs CNN……</strong>是纯双线性上采样，因为结果也与CPU的裸代码一致。同时<strong class="mc jd">模拟...</strong>可能有一些定制，以保持在重新缩放的图像好看。</p><p id="7982" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">额外的工作是<strong class="mc jd">evaluateonpuwithinputs</strong>改为使用CPU。对于计算机无法使用或其中没有GPU的情况，您必须实现方法。我基于<a class="ae lh" href="https://machinethink.net/blog/coreml-upsampling/" rel="noopener ugc nofollow" target="_blank"> <strong class="mc jd"> Matthijs </strong>的网站</a>实现了双线性上采样代码(他的指导很有帮助)。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ot ou l"/></div></figure></div><div class="ab cl oh oi hx oj" role="separator"><span class="ok bw bk ol om on"/><span class="ok bw bk ol om on"/><span class="ok bw bk ol om"/></div><div class="im in io ip iq"><h2 id="1b2c" class="ni lj it bd lk nj nk dn lo nl nm dp ls mj nn no lu mn np nq lw mr nr ns ly iz bi translated">在转换器中(coremltools 3.4)</h2><p id="697c" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">使用之前的coremltools 3.4无法将TF-Keras 2.5的一个训练好的模型直接<strong class="mc jd"> <em class="ne">转换成核心ML模型</em> </strong>。<strong class="mc jd"> coremltools…convert() </strong>或<strong class="mc jd"> keras…load_model() </strong>方法不起作用。但是可以通过如下方式间接使用<strong class="mc jd"><em class="ne"/></strong>:</p><ol class=""><li id="9d31" class="nt nu it mc b md mw mg mx mj nv mn nw mr nx mv ov nz oa ob bi translated">我从我的神经网络代码中新建了一个裸模型，该代码已用于最新的TF-Keras 2.5中的训练。注意，这个空模型我用的是纯Keras 2.2.x，而不是TF-Keras。</li><li id="fe8e" class="nt nu it mc b md oc mg od mj oe mn of mr og mv ov nz oa ob bi translated">因为pure Keras 2.2.x和coremltools 3.4的版本匹配，所以裸模型可以被coremltools 3.4转换成核心ML模型。但是该模型没有经过训练的参数。</li><li id="ce68" class="nt nu it mc b md oc mg od mj oe mn of mr og mv ov nz oa ob bi translated">我用keras_model.load_weights()将TF-Keras 2.5训练好的参数加载到pure Keras 2.2.x新建的模型中，这个效果很好，coremltools 3.4可以从中创建一个训练好的核心ML模型。</li></ol><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ot ou l"/></div></figure></div><div class="ab cl oh oi hx oj" role="separator"><span class="ok bw bk ol om on"/><span class="ok bw bk ol om on"/><span class="ok bw bk ol om"/></div><div class="im in io ip iq"><h1 id="67bd" class="li lj it bd lk ll oo ln lo lp op lr ls ki oq kj lu kl or km lw ko os kp ly lz bi translated">最后，</h1><p id="af77" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">我感到欣慰的是，我可以通过TensorFlow 2.5和Core ML使用coremltools 3.4实现双线性上采样层，保持一致的计算结果。</p><p id="dcb0" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">我希望这将对尝试这个问题的人有所帮助。</p><p id="1c51" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated"><em class="ne"> P.S .我正在为即将到来的MacBook Pro 2021攒钱…但是当它到来的时候呢？</em></p></div><div class="ab cl oh oi hx oj" role="separator"><span class="ok bw bk ol om on"/><span class="ok bw bk ol om on"/><span class="ok bw bk ol om"/></div><div class="im in io ip iq"><h1 id="48f5" class="li lj it bd lk ll oo ln lo lp op lr ls ki oq kj lu kl or km lw ko os kp ly lz bi translated">更新[2021年7月2日]</h1><p id="648b" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">我发现了一些上面的<strong class="mc jd">mpscnnupsamplingb双线性</strong>显示<strong class="mc jd">不一致</strong>结果的情况，即使一开始在其他情况下看起来是一致的。因此，我尝试了另一个金属性能着色器函数，<strong class="mc jd">mpsnresizebilinear</strong>来实现内核ML中的Keras对应函数，<strong class="mc jd"> </strong>，并发现<strong class="mc jd">具有更好的结果。</strong></p><p id="2f9c" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">下图显示了使用上述Keras代码，使用双线性上采样层训练的神经网络模型的分割结果。</p><blockquote class="nb nc nd"><p id="0945" class="ma mb ne mc b md mw kd mf mg mx kg mi nf my ml mm ng mz mp mq nh na mt mu mv im bi translated">红色区域是CPU代码的结果，红线是<strong class="mc jd">mpsnresizebilinear</strong>的结果，黄色是<strong class="mc jd">mpscnnupsamplingb双线性</strong>。</p></blockquote><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ow"><img src="../Images/7f97421082f3ff3068a6556f127ba89c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9TYM5WhdF81-r88v7YnfdA.png"/></div></div></figure><p id="63dd" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">并且，我为核心ML更新了目标C代码，如下所示:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ot ou l"/></div></figure></div></div>    
</body>
</html>