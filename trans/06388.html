<html>
<head>
<title>3 Infinite Iterators in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的3个无限迭代器</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/3-infinite-iterators-in-python-98746f359d4b?source=collection_archive---------18-----------------------#2021-06-08">https://towardsdatascience.com/3-infinite-iterators-in-python-98746f359d4b?source=collection_archive---------18-----------------------#2021-06-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/193f7c5d307a55204568e19500cf70d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oaoi6FEKGU0nhczJtYrnhA.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">由<a class="ae jg" href="https://pixabay.com/users/deltaworks-37465/" rel="noopener ugc nofollow" target="_blank"> DeltaWorks </a>在<a class="ae jg" href="https://pixabay.com/photos/flower-field-flowers-field-trees-250016/" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>上拍摄的照片</p></figure><div class=""/><div class=""><h2 id="b4cb" class="pw-subtitle-paragraph kg ji jj bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dk translated">5个例子让你知道何时使用它们</h2></div><p id="8abf" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">毫无疑问，Python内置模块Itertools相当强大。的确，几乎没有人能用一篇文章把它介绍得里里外外。因此，我选择了三个迭代器函数来帮助我们产生无限数量的元素。当然，格局是我们自己定义的。</p><ul class=""><li id="5d59" class="lu lv jj la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated">数数</li><li id="63a6" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">循环</li><li id="7dd2" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">重复</li></ul><p id="d0b2" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我将演示这些函数，以及我们可以使用它们的典型场景。通过这些例子，你会对它们的设计有更好的了解。如果你有更有创意的方法来使用它们，请不要犹豫让我知道！</p><p id="e5f5" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们在任何演示之前导入它们。</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="3307" class="mr ms jj mn b gy mt mu l mv mw">from itertools import count, cycle, repeat</span></pre><h1 id="1d1d" class="mx ms jj bd my mz na nb nc nd ne nf ng kp nh kq ni ks nj kt nk kv nl kw nm nn bi translated">1.Itertools.count()</h1><figure class="mi mj mk ml gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/72180360bc4e1f845f879310ffee641b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8h_Q_iu-dfAJoxQxXI-M9g.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">由<a class="ae jg" href="https://pixabay.com/users/pexels-2286921/" rel="noopener ugc nofollow" target="_blank">像素</a>在<a class="ae jg" href="https://pixabay.com/photos/abacus-classroom-count-counter-1866497/" rel="noopener ugc nofollow" target="_blank">像素上拍摄的照片</a></p></figure><p id="7171" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">每个人都会数数。如果不叫我们停下来，理论上我们可以一直数下去。在Python世界中，使用<code class="fe no np nq mn b">range()</code>函数来生成数字序列是非常常见的。然而，我们必须让函数知道在哪个点上它需要停止。</p><p id="8d0d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但不用于<code class="fe no np nq mn b">count()</code>功能。我们不需要告诉它什么时候停下来，只是不停地下一个，下一个，下一个。</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="66c7" class="mr ms jj mn b gy mt mu l mv mw">iter_count = count(0)</span><span id="e5d5" class="mr ms jj mn b gy nr mu l mv mw">for i in range(10):<br/>    print(next(iter_count))</span></pre><figure class="mi mj mk ml gt iv gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/d0f5b28b1396779c43af7ae8e9b80830.png" data-original-src="https://miro.medium.com/v2/resize:fit:576/format:webp/1*BIIbocdipVFmKbPTXxv4xg.png"/></div></figure><p id="1356" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在上面的例子中，我们使用<code class="fe no np nq mn b">count()</code>函数定义了一个迭代器。我们告诉它应该从0开始，但不需要告诉什么时候停止。然后，我们使用<code class="fe no np nq mn b">next()</code>函数从中获取值。循环10次，迭代器会产生10个数字。</p><p id="52e3" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe no np nq mn b">count()</code>功能也接受定制步骤的第二个参数。如果未指定，默认步长为1。</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="73d3" class="mr ms jj mn b gy mt mu l mv mw">iter_count = count(0.5, 0.5)</span><span id="7443" class="mr ms jj mn b gy nr mu l mv mw">for i in range (10):<br/>    print(next(iter_count))</span></pre><figure class="mi mj mk ml gt iv gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/d84e2e2d2fb5d4348a13ee190e9045d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:650/format:webp/1*t1jwgZ173J6G2bUgRcD56A.png"/></div></figure><p id="86cb" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">所以，每次我们得到下一个数字，就会加0.5而不是1。</p><h2 id="659d" class="mr ms jj bd my nu nv dn nc nw nx dp ng lh ny nz ni ll oa ob nk lp oc od nm oe bi translated">示例1:获取偶数和奇数</h2><p id="d1ae" class="pw-post-body-paragraph ky kz jj la b lb of kk ld le og kn lg lh oh lj lk ll oi ln lo lp oj lr ls lt im bi translated">我们可以很容易地使用<code class="fe no np nq mn b">count()</code>函数来生成一个算术序列。例如，我们可以用它来生成奇数或偶数的列表。</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="f761" class="mr ms jj mn b gy mt mu l mv mw">iter_count_odd = count(1, 2)<br/>iter_count_even = count(0, 2)</span><span id="f206" class="mr ms jj mn b gy nr mu l mv mw">odds = [next(iter_count_odd) for _ in range(10)]<br/>evens = [next(iter_count_even) for _ in range(10)]</span><span id="3c8f" class="mr ms jj mn b gy nr mu l mv mw">print(odds)<br/>print(evens)</span></pre><figure class="mi mj mk ml gt iv gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/d40e880bc6c74febce2f375336a20b5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:954/format:webp/1*yybNXLiBpw2-Jb8IIbQoFg.png"/></div></figure><h2 id="3d26" class="mr ms jj bd my nu nv dn nc nw nx dp ng lh ny nz ni ll oa ob nk lp oc od nm oe bi translated">示例2:在zip函数中使用count</h2><p id="a19a" class="pw-post-body-paragraph ky kz jj la b lb of kk ld le og kn lg lh oh lj lk ll oi ln lo lp oj lr ls lt im bi translated">假设我们有一份学生名单。现在，我们想自动分配学生证给他们。学生证要从150000开始。我们可以使用<code class="fe no np nq mn b">count()</code>函数非常方便地做到这一点。</p><p id="e2d2" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们首先生成一个学生姓名的虚拟列表。</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="6306" class="mr ms jj mn b gy mt mu l mv mw">students = ['Alice', 'Bob', 'Chris', 'David', 'Eva']</span></pre><p id="8ab3" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后，让我们生成学生id。</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="8f3d" class="mr ms jj mn b gy mt mu l mv mw">for i in zip(count(150001), students):<br/>    print(i)</span></pre><figure class="mi mj mk ml gt iv gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/2b38657e23e81afaa05c6fd54b9e00f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*TZNAdAWV3vjaCbmpGXVdLw.png"/></div></figure><p id="a0e5" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这里，最重要的是，我们不必知道我们有多少学生。此外，如果需要，我们可以很容易地将结果转换成字典。</p><h1 id="0445" class="mx ms jj bd my mz na nb nc nd ne nf ng kp nh kq ni ks nj kt nk kv nl kw nm nn bi translated">2.Itertools.cycle</h1><figure class="mi mj mk ml gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/333623a7edef8a6a244cea715f4626b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3SULZdUvC9pOBMzrArZfNQ.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">由<a class="ae jg" href="https://pixabay.com/users/pexels-2286921/" rel="noopener ugc nofollow" target="_blank">像素</a>在<a class="ae jg" href="https://pixabay.com/photos/stone-circles-mystery-cult-1853340/" rel="noopener ugc nofollow" target="_blank">像素箱</a>上拍摄的照片</p></figure><p id="c62e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">第二个无限迭代器工厂是<code class="fe no np nq mn b">cycle()</code>函数。与一直朝一个方向计数的<code class="fe no np nq mn b">count()</code>功能不同，<code class="fe no np nq mn b">cycle()</code>功能会一遍又一遍地重复一个模式。</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="7715" class="mr ms jj mn b gy mt mu l mv mw">iter_cycle = cycle(['a', 'b', 'c'])</span><span id="03cf" class="mr ms jj mn b gy nr mu l mv mw">for i in range(10):<br/>    print(next(iter_cycle))</span></pre><figure class="mi mj mk ml gt iv gh gi paragraph-image"><div class="gh gi om"><img src="../Images/52a9a7f8ed4e05001fec974f7a28d18b.png" data-original-src="https://miro.medium.com/v2/resize:fit:778/format:webp/1*uabwsaWI55RxSXEqjv9DBg.png"/></div></figure><p id="6cd0" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在上面的例子中，我们传入的列表有3个元素。由<code class="fe no np nq mn b">cycle()</code>函数生成的迭代器将按顺序逐个填充它们。当所有的元素都被使用时，它会返回到开始处再次获取第一个元素。继续循环:)</p><h2 id="a74a" class="mr ms jj bd my nu nv dn nc nw nx dp ng lh ny nz ni ll oa ob nk lp oc od nm oe bi translated">示例3:使用cycle生成每日轮换花名册</h2><p id="5fb7" class="pw-post-body-paragraph ky kz jj la b lb of kk ld le og kn lg lh oh lj lk ll oi ln lo lp oj lr ls lt im bi translated">假设你在一个团队中，团队成员将轮流值班一天。为了公平起见，我们需要生成一个花名册。请注意，随机可能不够公平。还有，有可能有人会连续一天以上随叫随到，这绝对是我们需要避免的。</p><p id="5f71" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这种情况下，<code class="fe no np nq mn b">cycle()</code>功能会有所帮助。但在此之前，我们先生成一个日期列表。</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="f3d2" class="mr ms jj mn b gy mt mu l mv mw">from datetime import datetime, timedelta</span><span id="eaf4" class="mr ms jj mn b gy nr mu l mv mw">dates = [(datetime(2021, 1, 1) + timedelta(days=i)).strftime('%Y-%m-%d') for i in range(10)]</span></pre><figure class="mi mj mk ml gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi on"><img src="../Images/2f98fe967253dd42e68f653185bb42bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*99uSSmdWFVEXy6utnX0lIg.png"/></div></div></figure><p id="c453" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，我们可以使用带有循环迭代器的<code class="fe no np nq mn b">zip()</code>函数来生成花名册。</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="0544" class="mr ms jj mn b gy mt mu l mv mw">iter_cycle = cycle(['Alice', 'Bob', 'Chris'])</span><span id="5d8c" class="mr ms jj mn b gy nr mu l mv mw">for i in zip(dates, iter_cycle):<br/>    print(i)</span></pre><figure class="mi mj mk ml gt iv gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/fcec17013db9c4af555cddad03bd2315.png" data-original-src="https://miro.medium.com/v2/resize:fit:898/format:webp/1*cRsdRSoZAoGta11-R-oSUw.png"/></div></figure><p id="ead4" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我们有一年的生成时间，不用担心，就用<code class="fe no np nq mn b">cycle()</code>吧，因为它是无限的。</p><h1 id="042e" class="mx ms jj bd my mz na nb nc nd ne nf ng kp nh kq ni ks nj kt nk kv nl kw nm nn bi translated">3.Itertools .重复</h1><figure class="mi mj mk ml gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/aacfb93b8b4c00513f7aafdbfea12c95.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KwrUAftQzinOsdsztLEBHw.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">照片由<a class="ae jg" href="https://pixabay.com/users/stevepb-282134/" rel="noopener ugc nofollow" target="_blank"> stevepb </a>在<a class="ae jg" href="https://pixabay.com/photos/pawn-chess-pieces-strategy-chess-2430046/" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>上拍摄</p></figure><p id="b6fd" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我们想永远重复某件事或者重复某段时间，那么<code class="fe no np nq mn b">repeat()</code>函数总是Python中的最佳选择。首先，让我们生成一个无限迭代器，它重复地给我们同样的东西。</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="2bcc" class="mr ms jj mn b gy mt mu l mv mw">iter_repeat = repeat('Towards Data Science')</span><span id="cb26" class="mr ms jj mn b gy nr mu l mv mw">for i in range(10):<br/>    print(next(iter_repeat))</span></pre><figure class="mi mj mk ml gt iv gh gi paragraph-image"><div class="gh gi op"><img src="../Images/7e65911b59a27094a45354fa6fc89af1.png" data-original-src="https://miro.medium.com/v2/resize:fit:850/format:webp/1*ZCP3zSiRVqzMNxs3uh-rpQ.png"/></div></figure><p id="e2ea" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请注意,<code class="fe no np nq mn b">repeat()</code>函数也采用可选的第二个参数来变得有限。</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="3f78" class="mr ms jj mn b gy mt mu l mv mw">list(repeat('Towards Data Science', 5))</span></pre><figure class="mi mj mk ml gt iv gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/3f8d9e568af78ff8925bdf2775b90c27.png" data-original-src="https://miro.medium.com/v2/resize:fit:788/format:webp/1*zBdVARmKTLpgiqzqGgSMIA.png"/></div></figure><p id="8e48" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在上面的例子中，我们为5个副本生成了相同字符串的列表。</p><h2 id="322e" class="mr ms jj bd my nu nv dn nc nw nx dp ng lh ny nz ni ll oa ob nk lp oc od nm oe bi translated">示例4:比列表更快</h2><p id="864f" class="pw-post-body-paragraph ky kz jj la b lb of kk ld le og kn lg lh oh lj lk ll oi ln lo lp oj lr ls lt im bi translated">有理由问我们为什么需要<code class="fe no np nq mn b">repeat()</code>函数？例如，生成一个包含5个相同字符串的列表可以像下面这样简单。</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="0ac6" class="mr ms jj mn b gy mt mu l mv mw">['Towards Data Science'] * 5</span></pre><figure class="mi mj mk ml gt iv gh gi paragraph-image"><div class="gh gi or"><img src="../Images/e2b473212d8f0027b14a5d949b42f673.png" data-original-src="https://miro.medium.com/v2/resize:fit:592/format:webp/1*MpJlfwsLMSHpWjTYJgD4fQ.png"/></div></figure><p id="1409" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">的确，就可读性而言，这要好得多。然而，重复迭代器将缓存结果，而列表乘法将在内存中生成5个不同的字符串。</p><figure class="mi mj mk ml gt iv gh gi paragraph-image"><div class="gh gi os"><img src="../Images/847687edde4d696a05da833cf78a760a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1062/format:webp/1*mJQGQ9Tfk-P6tn0Pchl59g.png"/></div></figure><p id="fe8e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以看到，在这种情况下，重复迭代器大约快了4倍。如果我们需要5倍以上，速度差会更大。</p><h2 id="239f" class="mr ms jj bd my nu nv dn nc nw nx dp ng lh ny nz ni ll oa ob nk lp oc od nm oe bi translated">示例5:循环比range()更快</h2><p id="2627" class="pw-post-body-paragraph ky kz jj la b lb of kk ld le og kn lg lh oh lj lk ll oi ln lo lp oj lr ls lt im bi translated">当我们想要循环某些东西的时候，使用<code class="fe no np nq mn b">range()</code>是很常见的。比如<code class="fe no np nq mn b">for i in range(10)</code>会循环10次。</p><p id="8e97" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然而，当我们不需要那个<code class="fe no np nq mn b">i</code>，这意味着我们不关心循环次数，重复迭代器在性能方面将是一个更好的解决方案。</p><figure class="mi mj mk ml gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ot"><img src="../Images/0ec4eda080ee8a95816189c0d9d1e537.png" data-original-src="https://miro.medium.com/v2/resize:fit:846/format:webp/1*Zqdnb0dvEjqlwGyKAR-h2w.png"/></div></div></figure><p id="dd45" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以看到，使用<code class="fe no np nq mn b">repeat()</code>功能比使用<code class="fe no np nq mn b">range()</code>功能快2倍。前者胜出，因为它需要做的只是更新现有<code class="fe no np nq mn b">None</code>对象的引用计数。后者失败了，因为<code class="fe no np nq mn b">range()</code>或<code class="fe no np nq mn b">xrange()</code>需要制造10，000个不同的整数对象。</p><h1 id="606f" class="mx ms jj bd my mz na nb nc nd ne nf ng kp nh kq ni ks nj kt nk kv nl kw nm nn bi translated">摘要</h1><figure class="mi mj mk ml gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/3b6e630d6caf8567bc6bd56195f4ecc9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f3W0aTbA2QHeyq8q57pveg.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">由<a class="ae jg" href="https://pixabay.com/users/tanajona-2899402/" rel="noopener ugc nofollow" target="_blank">塔纳乔纳</a>在<a class="ae jg" href="https://pixabay.com/photos/racket-padel-ball-padel-tennis-6308994/" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>上拍摄的照片</p></figure><p id="5c4a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在本文中，我介绍了Python的Itertools模块的3个无限迭代器。通过了解它们，有时可以在很大程度上提高我们的生产力。然而，我也建议平衡可读性和性能。不要总是用代码来炫耀，只在必要的时候才使用它们。</p><p id="bbeb" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您对更多Python内置模块感兴趣，请查看这些相关文章。</p><div class="is it gp gr iu ou"><a href="https://medium.com/@qiuyujx/membership" rel="noopener follow" target="_blank"><div class="ov ab fo"><div class="ow ab ox cl cj oy"><h2 class="bd jk gy z fp oz fr fs pa fu fw ji bi translated">通过我的推荐链接加入Medium克里斯托弗·陶</h2><div class="pb l"><h3 class="bd b gy z fp oz fr fs pa fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="pc l"><p class="bd b dl z fp oz fr fs pa fu fw dk translated">medium.com</p></div></div><div class="pd l"><div class="pe l pf pg ph pd pi ja ou"/></div></div></a></div><p id="9f1b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你觉得我的文章有帮助，请考虑加入Medium会员来支持我和成千上万的其他作者！(点击上面的链接)</p></div></div>    
</body>
</html>