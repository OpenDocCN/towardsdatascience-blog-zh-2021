<html>
<head>
<title>Bayer’s Approach to Modelling and Loading Data at Scale</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">拜耳大规模建模和加载数据的方法</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/bayers-approach-to-modelling-and-loading-data-at-scale-abe83e2f460e?source=collection_archive---------40-----------------------#2021-08-16">https://towardsdatascience.com/bayers-approach-to-modelling-and-loading-data-at-scale-abe83e2f460e?source=collection_archive---------40-----------------------#2021-08-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="b96b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">早在4月份，我们就为我们的社区举办了一次在线会议，名为<a class="ae kl" href="https://youtube.com/c/vaticle" rel="noopener ugc nofollow" target="_blank"> Orbit 2021 </a>，通过聆听来自拜耳医药公司的Henning Kuich、Dan Plischke和Joren Retel，我们的社区得以一窥拜耳医药公司的一个团队如何使用<a class="ae kl" href="https://github.com/vaticle/typedb" rel="noopener ugc nofollow" target="_blank"> TypeDB </a>来加速他们的药物研发渠道。</p><h1 id="e843" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">目标</h1><p id="4366" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">拜耳的团队从根本上想要更好地了解疾病，以便他们能够创造更好的治疗干预措施。对疾病的更深入了解使得能够识别和开发具有很少或没有副作用的新治疗干预。</p><p id="6e34" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了实现这一点，他们需要建立一个模型，准确地表示疾病的生物系统，并将其映射到他们可用的大型生物医学数据集。</p><h1 id="ad82" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">挑战</h1><h2 id="c9d7" class="lp kn iq bd ko lq lr dn ks ls lt dp kw jy lu lv la kc lw lx le kg ly lz li ma bi translated">描述疾病—数据模型</h2><p id="2785" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">为了在TypeDB中模拟疾病，他们从可以调整的概念开始。将它们建模为TypeDB模式中的实体，如下所示:</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="362b" class="lp kn iq mg b gy mk ml l mm mn">define<br/>gene sub entity;<br/>variant sub entity;<br/>protein sub entity;<br/>complex sub entity;<br/>indication sub entity;</span></pre><p id="5a04" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里，<code class="fe mo mp mq mg b">gene</code>、<code class="fe mo mp mq mg b">variant</code>、<code class="fe mo mp mq mg b">protein</code>和<code class="fe mo mp mq mg b">complex</code>被选为实体，因为它们可以以某种形式与疾病相关联。通过实体<code class="fe mo mp mq mg b">indication</code>对感兴趣的疾病进行建模。在实践中，他们需要捕捉生物系统内部的内在相互关系，而生物是复杂的！当然，这意味着我们需要担心生物系统中大量的其他事情。</p><figure class="mb mc md me gt ms gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi mr"><img src="../Images/e8cd278ada001555b7bec4b31d7de8c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XCdxToU92zFQba_m-j6UhQ.jpeg"/></div></div></figure><p id="e9c0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">比如<code class="fe mo mp mq mg b">genes</code>在<code class="fe mo mp mq mg b">cells</code>中表示，<code class="fe mo mp mq mg b">cells</code>是<code class="fe mo mp mq mg b">tissues</code>的一部分，而<code class="fe mo mp mq mg b">tissues</code>在一个<code class="fe mo mp mq mg b">organisam</code>中。这些数据可以来自临床研究中的分析和实验。将所有这些放在一起，并建立正确的关系模型，可能会得出如下结果:</p><figure class="mb mc md me gt ms gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi mr"><img src="../Images/29807bb71f202def0a0ec61fc740b8f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QMDlm2N-hHNDZVczGU5XKg.jpeg"/></div></div><p class="mz na gj gh gi nb nc bd b be z dk translated">请注意，由于拜耳所做工作的性质，他们无法展示模型的全部细节</p></figure><h1 id="a095" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">为什么是强类型数据库？</h1><p id="e39a" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">为什么Bayer团队选择使用TypeDB作为这类建模的数据库？</p><p id="987f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">生物学中的一切都是极其相关和依赖于上下文的，这使得在传统的关系数据库中表示数据非常困难。正因为如此，Henning和他的团队认为TypeDB的类型系统是一种更自然的生物学建模方式。</p><p id="d484" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">生物医学实验是高度特定于环境的，因此在构建生物医学知识图时，您希望能够快速询问使用了哪些参数，实际的化验是什么，是在体外还是在细胞中？这需要一个能够捕捉这种复杂程度的数据库，以及一种允许我们轻松地对这些数据提出复杂问题的查询语言。有了TypeDB，Henning的团队就能做到这一点。</p><p id="9b74" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Bayer还利用了TypeDB中本机推理引擎的优势。推理可以为拥有类似复杂生物医学数据的团队做很多事情。例如，Henning和他的团队使用TypeDB的推理引擎，根据它们在染色体上的位置来推断<code class="fe mo mp mq mg b">variant</code>到<code class="fe mo mp mq mg b">gene</code>的连接。</p><p id="6181" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">基因本质上只是基因组中的序列，实际上是沿着一长串其他位置的位置。变体是这些序列的变体，也沿着相同的数字和位置延伸。使用type QL(TypeDB的查询语言)，该团队能够根据重叠位置将变异映射到基因，而不是依赖于其他需要他们导入变异和基因之间关系的数据库。重要的是，这避免了维护其他数据库的需要，因为定期更新和迁移这些数据库需要很长时间。所有这些都可以通过使用TypeDB的推理引擎来避免。</p><p id="ffaf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">TypeDB还允许您在数据库生命周期中的任何时间点重新定义模式。例如，我们可以添加一个新的定义，根据基因的位置来定义与基因相关的变异。这很重要，尤其是当我们添加新的数据集时。所有这些都使Henning的团队能够更有效地运作，并加速他们的药物发现过程。</p><p id="3dcd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通过<a class="ae kl" href="https://github.com/vaticle/biograkn-covid/blob/master/Schema/biograkn-covid.gql" rel="noopener ugc nofollow" target="_blank"> github </a>上的BioGrakn-Covid repo，你可以看到一个在生物学领域完全充实的模式的例子。</p><h1 id="6c8a" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">加载数据和开源的TypeDB加载器</h1><p id="b04c" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">既然有了一个模式来表示我们正在使用的系统，那么大规模加载数据就成了下一个挑战。为了以拜耳想要的方式做到这一点，亨宁和他的团队构建并开源了<a class="ae kl" href="https://github.com/bayer-science-for-a-better-life/grami" rel="noopener ugc nofollow" target="_blank"> TypeDB Loader </a>(以前的GraMi)，这是一个用于TypeDB的数据迁移工具。在这里，我们描述它是如何工作的，以及拜耳团队是如何使用它的。</p><p id="4e59" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Henning的团队决定构建他们自己的定制加载器的原因是，他们想要一种更好、更具可伸缩性的方式来将大量数据加载到TypeDB中。为了加载数据，最初的TypeDB文档建议构建一个读入文件(例如以表格格式)的函数，并构建一个生成插入查询的模板函数。然后，我们可以使用其中一个客户端驱动程序将其插入到TypeDB数据库中。但是，在大规模这样做时，会引入TypeDB Loader试图解决的许多挑战:</p><ul class=""><li id="7355" class="nd ne iq jp b jq jr ju jv jy nf kc ng kg nh kk ni nj nk nl bi translated">处理所需模板函数的重复逻辑</li><li id="c7d0" class="nd ne iq jp b jq nm ju nn jy no kc np kg nq kk ni nj nk nl bi translated">注意潜在的脏数据，防止插入过程中的错误</li><li id="f2b3" class="nd ne iq jp b jq nm ju nn jy no kc np kg nq kk ni nj nk nl bi translated">每个事务的插入查询的并行化和批处理</li><li id="27de" class="nd ne iq jp b jq nm ju nn jy no kc np kg nq kk ni nj nk nl bi translated">大数据容错</li></ul><figure class="mb mc md me gt ms gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi mr"><img src="../Images/c45a54379aa8739692f567af8a4458de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5t9F4bOwdJ0uG0Bv0tdmMQ.jpeg"/></div></div></figure><h2 id="db8f" class="lp kn iq bd ko lq lr dn ks ls lt dp kw jy lu lv la kc lw lx le kg ly lz li ma bi translated"><strong class="ak">TypeDB Loader是如何工作的？</strong></h2><figure class="mb mc md me gt ms gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi mr"><img src="../Images/ad4f487f648f11840557a6162f3a15ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZR9Ai3uv0VUl4e25K1GjDA.jpeg"/></div></div></figure><p id="3d43" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用已定义的TypeDB模式，我们的第一步是将数据映射到模式。这在两个配置文件中处理。第一个是<a class="ae kl" href="https://github.com/bayer-science-for-a-better-life/grami/blob/master/src/main/java/configuration/ProcessorConfigEntry.java" rel="noopener ugc nofollow" target="_blank">处理器配置</a>，它包含数据和模式之间的逻辑；例如，必须为每种类型生成哪些属性。这决定了某些属性是否是必需的，并确保获取的数据产生正确类型的正确属性。</p><p id="04d3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第二个配置文件是<a class="ae kl" href="https://github.com/bayer-science-for-a-better-life/grami/blob/master/src/main/java/configuration/DataConfigEntry.java" rel="noopener ugc nofollow" target="_blank">数据配置</a>文件。在这里，我们可以指定正在读取哪个数据文件，它是什么类型的文件，在处理器配置中使用什么类型的处理器，然后将数据中的列映射到处理器配置中的实际处理器。这确保了所有内容都被正确插入。</p><figure class="mb mc md me gt ms gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi mr"><img src="../Images/50f46778c7d14bd9f3bdbdb64efe2848.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7qNq5CgI3rwTy4gWcBlc7A.jpeg"/></div></div></figure><p id="684e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">拜耳团队还希望能够在数据迁移发生时对其进行监控。插入了什么，哪里可能发生了错误，以及由于什么原因在哪里停止了。这允许您从停止的确切位置重新开始迁移，消除了复制或丢失数据的风险。</p><h2 id="6789" class="lp kn iq bd ko lq lr dn ks ls lt dp kw jy lu lv la kc lw lx le kg ly lz li ma bi translated"><strong class="ak">现在如何使用TypeDB Loader？</strong></h2><p id="45cb" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">TypeDB Loader是一个Java应用程序和库，使您能够将其用作CLI工具或在自己的Java项目中使用。一旦决定了使用这两种方法中的哪一种，就可以指定正在与哪个TypeDB实例进行对话以及正在写入哪个数据库。然后提供您的数据配置、处理器配置、TypeDB模式，然后确定您希望在哪里跟踪迁移状态。这可以像一个JSON文件一样简单。</p><figure class="mb mc md me gt ms gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi mr"><img src="../Images/2141983f427ed79f027f2dac8922f786.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pSV50obb_wphmkDNvpztXQ.jpeg"/></div></div></figure><p id="7907" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">就是这里，TypeDB Loader从这里开始。Henning和他的团队正在继续发布更新，并鼓励任何感兴趣的人关注#typedb-loader频道中关于<a class="ae kl" href="https://vaticle.com/discord" rel="noopener ugc nofollow" target="_blank"> Discord </a>的进展。</p><h2 id="d928" class="lp kn iq bd ko lq lr dn ks ls lt dp kw jy lu lv la kc lw lx le kg ly lz li ma bi translated">TypeDB Loader的最新版本(GraMi 0.1.1)增加了哪些特性？</h2><ul class=""><li id="af19" class="nd ne iq jp b jq lk ju ll jy nr kc ns kg nt kk ni nj nk nl bi translated">将带有属性的嵌套关系作为角色扮演者导入</li><li id="132e" class="nd ne iq jp b jq nm ju nn jy no kc np kg nq kk ni nj nk nl bi translated">将属性追加到现有类型</li><li id="024f" class="nd ne iq jp b jq nm ju nn jy no kc np kg nq kk ni nj nk nl bi translated">向现有数据追加或插入数据</li><li id="ae5e" class="nd ne iq jp b jq nm ju nn jy no kc np kg nq kk ni nj nk nl bi translated">更新模式，包括更新规则</li><li id="48de" class="nd ne iq jp b jq nm ju nn jy no kc np kg nq kk ni nj nk nl bi translated">对数据插入进行大量测试，以防止数据丢失或错误</li><li id="d7f0" class="nd ne iq jp b jq nm ju nn jy no kc np kg nq kk ni nj nk nl bi translated">在迁移开始前捕捉错误的处理器和数据配置验证</li><li id="32ef" class="nd ne iq jp b jq nm ju nn jy no kc np kg nq kk ni nj nk nl bi translated">为快速入门自动生成处理器配置框架</li></ul><h2 id="46ed" class="lp kn iq bd ko lq lr dn ks ls lt dp kw jy lu lv la kc lw lx le kg ly lz li ma bi translated"><strong class="ak">TypeDB装载机路线图的下一步是什么？</strong></h2><ul class=""><li id="48e8" class="nd ne iq jp b jq lk ju ll jy nr kc ns kg nt kk ni nj nk nl bi translated">改进数据警告日志记录，这是一个更易于理解和解析的整合输出</li><li id="e6a1" class="nd ne iq jp b jq nm ju nn jy no kc np kg nq kk ni nj nk nl bi translated">规则管理，使应用和定义或未定义的规则变得更容易</li><li id="7992" class="nd ne iq jp b jq nm ju nn jy no kc np kg nq kk ni nj nk nl bi translated">直接从SQL表中读取，而不仅仅是文件</li><li id="c218" class="nd ne iq jp b jq nm ju nn jy no kc np kg nq kk ni nj nk nl bi translated">构建Kafka连接器，使其成为更大的数据处理基础设施的一部分</li></ul></div></div>    
</body>
</html>