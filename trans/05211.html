<html>
<head>
<title>Building Your First Classification Pipeline In Julia</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Julia中构建您的第一个分类管道</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/building-your-first-classification-pipeline-in-julia-47e661c097d7?source=collection_archive---------31-----------------------#2021-05-07">https://towardsdatascience.com/building-your-first-classification-pipeline-in-julia-47e661c097d7?source=collection_archive---------31-----------------------#2021-05-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a8f0" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用Julia语言创建分类管道的快速概述</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/fc85f8ea6d86ca1ba152f15a07b4c9e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yRhmyre2NH93rPH1OW78vA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(src =<a class="ae ky" href="https://pixabay.com/images/id-1566044/" rel="noopener ugc nofollow" target="_blank">https://pixabay.com/images/id-1566044/</a></p></figure><h1 id="a378" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">介绍</h1><p id="9b43" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi mn translated"><span class="l mo mp mq bm mr ms mt mu mv di"> C </span>分类是机器学习的一种形式，使用统计分析和概率论来预测类别集。这在机器学习领域是一项非常常见的任务，但Julian生态系统尚未对这一技术提供显著支持。虽然这并不是说在Julia编程语言中没有分类模型，但是您可能会很快发现它们非常稀少并且很难得到。再者，生态系统中的包彼此并不一致，更不用说Julia周围的其他语言的生态系统了。</p><p id="d512" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">当然，乍一看，有些人可能会将这些不一致归因于Julia所在的编程范例。像大多数其他现代编程语言一样，Julia是多范型的，并具有许多通用编程概念，这使得该语言更易于使用。然而，我认为Julia已经构建了一个全新的范例，我(以及Julia Computing)喜欢称之为多分派范例。</p><p id="5c6f" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">使用多分派范例，语法对于任何其他语言都是非常独特的，或者与另一种语言完全相同。例如，如果我们考虑Python，它当然是统计学、机器学习和数据科学最流行的语言，我们可以通过使用构造函数和多重分派来模仿该语言在Julia中的能力。这正是我们今天将要使用的软件，车床，所做的事情，目的是让Pythonic的科学家们非常容易地开始学习Julia语言——而不必学习大量新的语法规则。如果您想了解更多关于车床的信息，您可以访问车床网站:</p><div class="nb nc gp gr nd ne"><a href="https://lathe.ai/" rel="noopener  ugc nofollow" target="_blank"><div class="nf ab fo"><div class="ng ab nh cl cj ni"><h2 class="bd iu gy z fp nj fr fs nk fu fw is bi translated">车床</h2><div class="nl l"><h3 class="bd b gy z fp nj fr fs nk fu fw dk translated">车床使用更快的方法和简单的方法。使得包装快速、简单且轻便。许多工具和模型…</h3></div><div class="nm l"><p class="bd b dl z fp nj fr fs nk fu fw dk translated">车床. ai</p></div></div></div></a></div><p id="f99c" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">对于这个项目，我也有一个笔记本，您可以查看它，以便更好地掌握我将要查看的代码:</p><div class="nb nc gp gr nd ne"><a href="https://github.com/emmettgb/Emmetts-DS-NoteBooks/blob/master/Julia/Baltimore%20Crime%20Classification.ipynb" rel="noopener  ugc nofollow" target="_blank"><div class="nf ab fo"><div class="ng ab nh cl cj ni"><h2 class="bd iu gy z fp nj fr fs nk fu fw is bi translated">emmett GB/Emmetts-DS-笔记本电脑</h2><div class="nl l"><h3 class="bd b gy z fp nj fr fs nk fu fw dk translated">各种项目的随机笔记本。通过创建帐户，为emmettgb/Emmetts-DS笔记本电脑的开发做出贡献…</h3></div><div class="nm l"><p class="bd b dl z fp nj fr fs nk fu fw dk translated">github.com</p></div></div><div class="nn l"><div class="no l np nq nr nn ns ks ne"/></div></div></a></div></div><div class="ab cl nt nu hx nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="im in io ip iq"><h1 id="8165" class="kz la it bd lb lc oa le lf lg ob li lj jz oc ka ll kc od kd ln kf oe kg lp lq bi translated">数据</h1><p id="eb58" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">对于这个项目，我基本上决定选择我能找到的任何有类的数据。我并不太关心特性的统计意义，因为这意味着更多的是对车床软件包内部建模能力的演示，以及在Julia中使用数据的小教程。记住这一点，我们要做的第一件事就是用CSV.jl和DataFrames.jl包读入我们的数据。为了做到这一点，我们需要使用一个sink参数，就像这样:</p><pre class="kj kk kl km gt of og oh oi aw oj bi"><span id="d53d" class="ok la it og b gy ol om l on oo">using CSV<br/>using DataFrames<br/>using DataFrames; df = CSV.read("baltimore_crime.csv", DataFrame)</span></pre><p id="e098" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">如果你想了解更多关于什么是sink参数，以及它是如何工作的，那么你可以查看我在这里写的关于它的概述:</p><div class="nb nc gp gr nd ne"><a rel="noopener follow" target="_blank" href="/what-is-a-sink-argument-caf77dab6ac5"><div class="nf ab fo"><div class="ng ab nh cl cj ni"><h2 class="bd iu gy z fp nj fr fs nk fu fw is bi translated">什么是“下沉”论点？</h2><div class="nl l"><h3 class="bd b gy z fp nj fr fs nk fu fw dk translated">关于在Julia编程语言中使用接收器参数的介绍。</h3></div><div class="nm l"><p class="bd b dl z fp nj fr fs nk fu fw dk translated">towardsdatascience.com</p></div></div><div class="nn l"><div class="op l np nq nr nn ns ks ne"/></div></div></a></div><p id="4de0" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">DataFrames.jl的显示输出相当恐怖，这是我一直讨厌这个包的地方。实际上，我确实派生了这个包，并试图修改显示，但由于DataFrames.jl如此依赖于其他生态系统包，如PrettyTables.jl，我们决定等待PrettyTables.jl的下一个版本发布会更有意义。这当然是有意义的，但是在一段时间内使用这个包会有负面影响。渐渐地，我放弃了我不想要的列，因为它们变得可见。我是通过使用select！()方法和Not()方法——这当然是从数据帧中删除列的一种非常谨慎的方法。：</p><pre class="kj kk kl km gt of og oh oi aw oj bi"><span id="f755" class="ok la it og b gy ol om l on oo">df = select!(df, Not([:CrimeDate, :CrimeTime]))</span></pre><p id="8116" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">这样做了一次后，我厌倦了，决定打印所有的名字，去掉我认为不合适的名字。这样做的一个很大的缺点是我看不到每一列的数据类型，甚至看不到特性是什么样子。你也可以做</p><pre class="kj kk kl km gt of og oh oi aw oj bi"><span id="951f" class="ok la it og b gy ol om l on oo">show(df, allcols = true)</span></pre><p id="ae59" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">但是输出也很难辨认。</p><pre class="kj kk kl km gt of og oh oi aw oj bi"><span id="8223" class="ok la it og b gy ol om l on oo">for name in names(df)<br/>    println(name)<br/>end<br/>df = select!(df, Not([:Description, <br/>            Symbol("Inside/Outside"), :Weapon, :Post,<br/>            Symbol("Location 1"), Symbol("Total Incidents")]))</span></pre><p id="06c9" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">现在我们有了所有不需要的列，我们可以从数据框架中删除缺失的列:</p><pre class="kj kk kl km gt of og oh oi aw oj bi"><span id="b3c8" class="ok la it og b gy ol om l on oo">df = dropmissing(df)</span></pre><p id="6d1c" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">因为在一个有284，000行的数据帧中只有大约1，000个缺失，所以我认为这比尝试填充这些值更有意义。然而，填充这些值的一个有趣的方法是使用Lathe的多数类基线遍历它们，例如:</p><pre class="kj kk kl km gt of og oh oi aw oj bi"><span id="e5d1" class="ok la it og b gy ol om l on oo">using Lathe.models: ClassBaseline<br/>model = ClassBaseline(Array(df[!, :CrimeCode]))<br/>for val in df[!, CrimeCode]<br/>    val = model.predict([val])[1]<br/>end</span></pre><p id="094a" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">接下来，我选择了以下内容作为我的功能和目标:</p><pre class="kj kk kl km gt of og oh oi aw oj bi"><span id="6e73" class="ok la it og b gy ol om l on oo">feature = :CrimeCode<br/>target = :District</span></pre><h1 id="1f3f" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">建模</h1><p id="200d" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">例如，区列是表示区的数据，[东北、西、东南]。犯罪法典是某种专有系统，地方政府或联邦政府用来对不同类型的犯罪活动进行分类。接下来，我使用车床的火车测试分裂功能，以分裂我的数据:</p><pre class="kj kk kl km gt of og oh oi aw oj bi"><span id="794d" class="ok la it og b gy ol om l on oo">using Lathe.preprocess: TrainTestSplit<br/>train, test = TrainTestSplit(df)</span></pre><p id="16d1" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">然后，我相应地调用每个数据帧的列，以便将新数据放入一维数组。</p><pre class="kj kk kl km gt of og oh oi aw oj bi"><span id="82de" class="ok la it og b gy ol om l on oo">trainX = train[!, feature]<br/>trainy = train[!, target]<br/>testX = test[!, feature]<br/>testy = test[!, target]</span></pre><p id="af94" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">我们需要做的最后一件事是找到某种方式来编码我们的数据。对于这个任务，我决定使用顺序编码器。这可以在车床的预处理模块中找到:</p><pre class="kj kk kl km gt of og oh oi aw oj bi"><span id="8717" class="ok la it og b gy ol om l on oo">using Lathe.preprocess: OrdinalEncoder<br/>encoder = OrdinalEncoder(trainX)</span></pre><p id="1b24" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">最后，我对编码器使用预测函数，以便将数据转换成普通的编码形式:</p><pre class="kj kk kl km gt of og oh oi aw oj bi"><span id="6632" class="ok la it og b gy ol om l on oo">trainX_encoded = encoder.predict(trainX)</span></pre><p id="d7c5" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">最后，我们将从车床导入并安装随机森林分类器。模型:</p><pre class="kj kk kl km gt of og oh oi aw oj bi"><span id="6ec2" class="ok la it og b gy ol om l on oo">using Lathe.models: RandomForestClassifier<br/>model = RandomForestClassifier(Array(trainX_encoded), Array(trainy))</span></pre><p id="cff1" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">请注意，我必须将数组类型转换为我的两个数组，这是因为DataFrames.jl从. 24版本开始就在PooledArrays中存储数据，而Lathe的调度不是针对AbstractArrays，而是只针对数组。如果你想学习更多关于Julia语言中类型抽象的知识，我有另外一篇文章你也可以阅读:</p><div class="nb nc gp gr nd ne"><a rel="noopener follow" target="_blank" href="/overview-abstract-super-type-heirarchies-in-julia-26b7e64c9d10"><div class="nf ab fo"><div class="ng ab nh cl cj ni"><h2 class="bd iu gy z fp nj fr fs nk fu fw is bi translated">概述Julia中的抽象超类型层次结构</h2><div class="nl l"><h3 class="bd b gy z fp nj fr fs nk fu fw dk translated">Julia的酷类型抽象介绍！</h3></div><div class="nm l"><p class="bd b dl z fp nj fr fs nk fu fw dk translated">towardsdatascience.com</p></div></div><div class="nn l"><div class="oq l np nq nr nn ns ks ne"/></div></div></a></div><p id="ee8e" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">接下来，我将testX转换成数组类型:</p><pre class="kj kk kl km gt of og oh oi aw oj bi"><span id="1274" class="ok la it og b gy ol om l on oo">testX = Array(testX)</span></pre><p id="e905" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">最后，我建造了我的管道。在Lathe中，我们可以使用Julia的基本加法运算符来实现这一点。可以用减法运算符删除步骤，我认为这是一种非常酷的语法。另一件很酷的事情是，我们甚至不需要导入管道类型来使用它！</p><pre class="kj kk kl km gt of og oh oi aw oj bi"><span id="89b4" class="ok la it og b gy ol om l on oo">pipe = encoder + model</span></pre><p id="8517" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">我实际上写了一篇关于如何做到这一点的文章，如果你不熟悉Julia，我肯定认为它不值得一读:</p><div class="nb nc gp gr nd ne"><a rel="noopener follow" target="_blank" href="/extending-julias-operators-with-amazing-results-96c042369349"><div class="nf ab fo"><div class="ng ab nh cl cj ni"><h2 class="bd iu gy z fp nj fr fs nk fu fw is bi translated">用惊人的结果扩展Julia的算子</h2><div class="nl l"><h3 class="bd b gy z fp nj fr fs nk fu fw dk translated">如何在Julia中加载和扩展方法，用一个真正激动人心的例子。</h3></div><div class="nm l"><p class="bd b dl z fp nj fr fs nk fu fw dk translated">towardsdatascience.com</p></div></div><div class="nn l"><div class="or l np nq nr nn ns ks ne"/></div></div></a></div><p id="3021" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">最后，我们可以在新管道上调用predict()函数，该函数将对我们的值进行编码，然后将其传递给模型:</p><pre class="kj kk kl km gt of og oh oi aw oj bi"><span id="39ae" class="ok la it og b gy ol om l on oo">yhat = pipe.predict(testX)</span></pre><p id="f9d2" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">最后，我们可以使用Lathe.stats中的catacc()方法来评估精度:</p><pre class="kj kk kl km gt of og oh oi aw oj bi"><span id="3a9d" class="ok la it og b gy ol om l on oo">using Lathe.stats: catacc<br/>println("Accuracy: ", catacc(testy, yhat) * 100)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi os"><img src="../Images/37c0bd8f5bf779e56629b2051484146f.png" data-original-src="https://miro.medium.com/v2/resize:fit:984/format:webp/1*lannbEY4yXCDbXnfh_T7Xw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由作者制作的图像</p></figure><blockquote class="ot"><p id="ad7f" class="ou ov it bd ow ox oy oz pa pb pc mm dk translated">这太残忍了。</p></blockquote></div><div class="ab cl nt nu hx nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="im in io ip iq"><h1 id="6c0a" class="kz la it bd lb lc oa le lf lg ob li lj jz oc ka ll kc od kd ln kf oe kg lp lq bi translated">结论</h1><p id="9565" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">尽管这些特性之间缺乏统计意义，但很难否认Lathe.jl包中提供的很酷的语法和方法。我认为这些管道特别酷，我很高兴能继续深入研究它们。如果您对该模型与其他地方的实现相比如何感到好奇，您可以随时查看我对该模型和SkLearn之间的性能和准确性进行的比较，这无疑是很有启发性的:</p><div class="nb nc gp gr nd ne"><a rel="noopener follow" target="_blank" href="/performance-testing-python-and-sklearn-with-julia-and-lathe-f5516fa497d7"><div class="nf ab fo"><div class="ng ab nh cl cj ni"><h2 class="bd iu gy z fp nj fr fs nk fu fw is bi translated">性能测试——Python和SkLearn与Julia和Lathe</h2><div class="nl l"><h3 class="bd b gy z fp nj fr fs nk fu fw dk translated">在两个生态系统工具的最新版本上执行一些基本指标。</h3></div><div class="nm l"><p class="bd b dl z fp nj fr fs nk fu fw dk translated">towardsdatascience.com</p></div></div><div class="nn l"><div class="pd l np nq nr nn ns ks ne"/></div></div></a></div><p id="6665" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">非常感谢您的阅读，我希望这篇文章对您有所帮助，让您在Julia中成为一名更好的程序员！</p></div></div>    
</body>
</html>