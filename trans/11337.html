<html>
<head>
<title>Master Class Inheritance in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的主类继承</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/master-class-inheritance-in-python-c46bfda63374?source=collection_archive---------4-----------------------#2021-11-07">https://towardsdatascience.com/master-class-inheritance-in-python-c46bfda63374?source=collection_archive---------4-----------------------#2021-11-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d1fe" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用直观的例子理解Python继承</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/350bd6936909e33d4e4276063b798f0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*RpELpba9MjUjvh6I"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@psalms" rel="noopener ugc nofollow" target="_blank"> David Wirzba </a>在<a class="ae ky" href="https://unsplash.com/photos/AK9ufbcsqGk" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="7508" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">类和对象在Python中起着核心作用。每次你给一个变量赋值，你都在无意识地创建一个对象。这个对象属于一个特定的类，拥有特定的属性和方法。这些特征在<a class="ae ky" rel="noopener" target="_blank" href="/explaining-python-classes-in-a-simple-way-e3742827c8b5?sk=f2644219c7a1b71bd23c302987481ed3">之前的文章</a>中有所涉及，在那篇文章中我提供了Python中类的快速概述。</p><p id="b779" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是python类不仅仅局限于这一方面，它们还具有<strong class="lb iu">继承</strong>的特征。继承的目标是重用一个已经构建好的类来创建一个新的类。通过这种方式，你不需要总是从头开始创建一个类，这个被称为<strong class="lb iu">子类</strong>的类将从另一个类<strong class="lb iu">父类</strong>继承属性和方法，这允许你减少代码行和冗余。</p><h1 id="a320" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">1.创建父类</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mn"><img src="../Images/168f971f8277c12acc3cea32b07a9686.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1mKj4NP_z3C-K-04rn7XuQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者插图</p></figure><p id="2169" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如前所述，子类基于父类。因此，第一步是创建父类。这个类将允许创建一个子类，避免编写相同的代码行。</p><p id="9d29" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，让我们定义一个<code class="fe mo mp mq mr b">medium_user</code>类，它将使用<code class="fe mo mp mq mr b">__init__</code>方法收集姓名、姓氏、用户名、电子邮件和布尔属性“subscriber”等信息，以检查用户是否是成员。而且有<code class="fe mo mp mq mr b">read</code>、<code class="fe mo mp mq mr b">clap</code>、<code class="fe mo mp mq mr b">is_member</code>三种方法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="02a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们使用<code class="fe mo mp mq mr b">medium_user</code>类创建一个对象，并执行所有的方法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mu"><img src="../Images/ab8a3825f1cb8c5f0b103c09acc605fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K6whUSb7waQyKsU0sYMmtw.png"/></div></div></figure><p id="bd41" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">很好！我们定义了一个medium用户，它在Medium上没有任何订阅。但是在本例中，我们有一个中等会员，仍然缺少属性，比如他开始订阅的日期、会员类型和支付方式。要添加这些信息，我们需要定义子类。</p><h1 id="d716" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">2.创建子类</h1><p id="a0d9" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">让我们构建<code class="fe mo mp mq mr b">medium_subscriber</code>类，它将获得前面定义的<code class="fe mo mp mq mr b">medium_user</code>类的属性和方法。为了逐步理解类继承是如何工作的，我们可以创建一个空类，简单地继承其他类的功能。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="c4c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了不添加任何属性或方法，使用了<code class="fe mo mp mq mr b">pass</code>关键字。我们只指定了<code class="fe mo mp mq mr b">medium_subscriber</code>类是<code class="fe mo mp mq mr b">medium_user</code>类的子类。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi na"><img src="../Images/0d48c900bc32ad52307f1ae5950fbd44.png" data-original-src="https://miro.medium.com/v2/resize:fit:1156/format:webp/1*Wf6PsoKMtcZSF2Rz58JEvg.png"/></div></div></figure><p id="9103" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">和以前一样，我们构建了一个属于<code class="fe mo mp mq mr b">medium_subscriber</code>类的新对象。如果我们尝试打印为<code class="fe mo mp mq mr b">medium_user</code>类定义的属性和方法，我们肯定会注意到<code class="fe mo mp mq mr b">medium_subscriber</code>继承了父类的所有功能。</p><h1 id="edfb" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">3.使用super()函数</h1><p id="660d" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">在上一段中，我们只定义了一个空类，它继承了另一个类的属性和方法。但是我们想通过<code class="fe mo mp mq mr b">__init__</code>构造函数方法添加属性。</p><p id="d8c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mo mp mq mr b">medium_subscriber</code>类也需要<code class="fe mo mp mq mr b">super()</code>函数来继承父类的功能，否则，子类的构造函数方法<strong class="lb iu">会覆盖</strong>对父类<code class="fe mo mp mq mr b">__init__</code>方法的继承。</p><p id="7fcd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，让我们在不使用super()函数的情况下，看看它是如何工作的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nb"><img src="../Images/156f58e9edaaa482f6ad2bbb2ae7a635.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*skJtSKm8y1gdsJy5vmQ6UA.png"/></div></div></figure><p id="f47d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以观察到<code class="fe mo mp mq mr b">medium_subscriber</code>类没有从<code class="fe mo mp mq mr b">medium_user</code>类继承任何属性或方法。我们需要在<code class="fe mo mp mq mr b">__init__</code>函数中使用<code class="fe mo mp mq mr b">super()</code>函数添加一行代码。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nc"><img src="../Images/8cc3e726d0693d233bc1895487d57bd3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-NiNl4PEJyPRgY2Qr_QNgw.png"/></div></div></figure><p id="7780" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们正确地添加了属性，而没有丢失父类的特征。首先，我们对<code class="fe mo mp mq mr b">medium_subscriber</code>类说从另一个类获取属性和方法，然后，我们添加属性，比如他开始订阅的日期、成员类型和支付方式。</p><p id="6de7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个解决方案还有一个替代方案。您可以调用父级的<code class="fe mo mp mq mr b">__init__</code>函数，来代替带有<code class="fe mo mp mq mr b">super()</code>函数的行。是评论行，<code class="fe mo mp mq mr b">medium_user.__init__(self,s_name,s_surname,s_username,s_email)</code>。通常最好使用<code class="fe mo mp mq mr b">super()</code>函数来避免写入父类的名称。</p></div><div class="ab cl nd ne hx nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="im in io ip iq"><h1 id="607b" class="lv lw it bd lx ly nk ma mb mc nl me mf jz nm ka mh kc nn kd mj kf no kg ml mm bi translated">最后的想法</h1><p id="0653" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">这篇文章很好地总结了Python类中继承的概念。它提供了可重用性、可读性和冗余代码的减少。由于这些优点，它被广泛用于定义类。根据我的经验，我在使用Pytorch定义神经网络架构时遇到过这种情况。你可以在这里找到一个例子<a class="ae ky" href="https://medium.com/dataseries/convolutional-autoencoder-in-pytorch-on-mnist-dataset-d65145c132ac" rel="noopener">，我在这里建立了一个卷积自动编码器。在这种情况下，<code class="fe mo mp mq mr b">nn.Module</code>是父类，它提供了构建autoencoder类的所有构件，比如线性层、卷积层、激活函数等等。我希望这篇文章对你有用。感谢阅读。祝您愉快！</a></p></div><div class="ab cl nd ne hx nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="im in io ip iq"><p id="395d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你喜欢我的文章吗？<a class="ae ky" href="https://eugenia-anello.medium.com/membership" rel="noopener"> <em class="np">成为会员</em> </a> <em class="np">每天无限获取数据科学新帖！这是一种间接的支持我的方式，不会给你带来任何额外的费用。如果您已经是会员，</em> <a class="ae ky" href="https://eugenia-anello.medium.com/subscribe" rel="noopener"> <em class="np">订阅</em> </a> <em class="np">每当我发布新的数据科学和python指南时，您都会收到电子邮件！</em></p></div></div>    
</body>
</html>