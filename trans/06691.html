<html>
<head>
<title>Python Type-hints &amp; Docstrings</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python类型提示和文档字符串</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/python-type-hints-docstrings-7ec7f6d3416b?source=collection_archive---------7-----------------------#2021-06-16">https://towardsdatascience.com/python-type-hints-docstrings-7ec7f6d3416b?source=collection_archive---------7-----------------------#2021-06-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="eec7" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">将Python的类型提示(3.5+)中的变量类型自动插入到Google风格的文档字符串中</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/676032a07d087a5643a3bf3f701c225c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RpOZOq30_rdP8G_3USHCJw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">从类型提示到文档字符串，作者的图像。</p></figure><p id="c700" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这个故事中，您将跟随我从Python类型提示自动生成Google风格的文档字符串。我们将关注以下要素。</p><ul class=""><li id="301c" class="lu lv it la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated">Python类型提示</li><li id="95af" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">将类型提示插入函数文档字符串</li><li id="84b7" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">通过预提交Git挂钩实现自动化</li></ul></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="ff4c" class="mp mq it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">Python类型提示</h1><p id="b9a9" class="pw-post-body-paragraph ky kz it la b lb nh ju ld le ni jx lg lh nj lj lk ll nk ln lo lp nl lr ls lt im bi translated">从Python 3.5+开始，我们已经看到了下一代代码文档:<em class="nm">在函数/类参数和返回语句中提示</em>哪些<em class="nm">变量的类型</em>。这使得格式化程序、linters和IDE能够为类型检查提供运行时支持。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nn"><img src="../Images/8a79f6624172c8d85674943fe74bb837.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iIYHelPXEN75GPB_pZn4wA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Python类型提示示例</p></figure><h2 id="6c15" class="no mq it bd mr np nq dn mv nr ns dp mz lh nt nu nb ll nv nw nd lp nx ny nf nz bi translated">为什么是类型提示</h2><p id="4345" class="pw-post-body-paragraph ky kz it la b lb nh ju ld le ni jx lg lh nj lj lk ll nk ln lo lp nl lr ls lt im bi translated">简单地说，类型提示<strong class="la iu">增加了源代码文档和可读性</strong>。它们是Python的增强协议(PEP)的一部分，PEP是一个用于增加Python代码的清晰度和逻辑性的进化框架。</p><h2 id="6232" class="no mq it bd mr np nq dn mv nr ns dp mz lh nt nu nb ll nv nw nd lp nx ny nf nz bi translated">如何使用类型提示</h2><p id="9e27" class="pw-post-body-paragraph ky kz it la b lb nh ju ld le ni jx lg lh nj lj lk ll nk ln lo lp nl lr ls lt im bi translated">类型提示可以从<code class="fe oa ob oc od b">typing</code>模块导入。格式为<code class="fe oa ob oc od b">&lt;variable name&gt; : &lt;variable type&gt;</code>，可以直接插入函数参数中。您可以用<code class="fe oa ob oc od b">-&gt; &lt;return variable&gt;</code>包含返回声明。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><h2 id="1b3a" class="no mq it bd mr np nq dn mv nr ns dp mz lh nt nu nb ll nv nw nd lp nx ny nf nz bi translated">类型检查</h2><p id="bba1" class="pw-post-body-paragraph ky kz it la b lb nh ju ld le ni jx lg lh nj lj lk ll nk ln lo lp nl lr ls lt im bi translated">请注意，类型提示是可选的，因此Python解释器会完全忽略它们(带有错误格式的类型提示的Python代码仍然会运行)。然而，像Pycharm这样的ide已经集成了类型检查，并且像<code class="fe oa ob oc od b">mypy</code>这样的静态类型检查工具将类型错误作为bug挖掘出来。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/0794b8e290e7bfed34c59f2116bbb4aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pniOdEnSZxFAQBxGwBeg3Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">PyCharm中的类型检查</p></figure></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="4a7c" class="mp mq it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">将类型提示插入函数文档字符串</h1><p id="e119" class="pw-post-body-paragraph ky kz it la b lb nh ju ld le ni jx lg lh nj lj lk ll nk ln lo lp nl lr ls lt im bi translated">为了从函数定义中提取参数及其类型提示，我们将</p><ol class=""><li id="0802" class="lu lv it la b lb lc le lf lh lw ll lx lp ly lt oh ma mb mc bi translated">使用<code class="fe oa ob oc od b">abstract syntax trees</code>解析Python脚本并读取函数及其参数</li><li id="7562" class="lu lv it la b lb md le me lh mf ll mg lp mh lt oh ma mb mc bi translated">使用库从我们的函数参数中获取变量类型提示</li><li id="3437" class="lu lv it la b lb md le me lh mf ll mg lp mh lt oh ma mb mc bi translated">使用<code class="fe oa ob oc od b">regular expressions</code>将变量类型映射到Google风格的docstring格式</li></ol><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/0288dae2589370704fa6318cd62ffe72.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*TyBzQY_rgenKGhuxtuu0pg.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Google风格的文档字符串的自动变量类型添加</p></figure><h2 id="b3f4" class="no mq it bd mr np nq dn mv nr ns dp mz lh nt nu nb ll nv nw nd lp nx ny nf nz bi translated">抽象语法树</h2><p id="281c" class="pw-post-body-paragraph ky kz it la b lb nh ju ld le ni jx lg lh nj lj lk ll nk ln lo lp nl lr ls lt im bi translated"><code class="fe oa ob oc od b"><a class="ae oj" href="https://docs.python.org/3/library/ast.html#module-ast" rel="noopener ugc nofollow" target="_blank">ast</a></code>模块帮助Python应用程序处理Python抽象语法的树。我们现在可以通过<code class="fe oa ob oc od b">ast nodes</code>以编程方式读取语法，而不是将Python脚本作为文本文件读取。打印和理解这些节点的一个有用的包是<code class="fe oa ob oc od b">astpretty</code>。我们使用<code class="fe oa ob oc od b">ast</code>模块来获取脚本中的函数或类名。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="cfec" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe oa ob oc od b">pathlib.Path</code>模块创建了一个面向对象的文件系统路径，您可以查询这个路径的属性，比如最后一个路径组件<code class="fe oa ob oc od b">.stem</code>，没有它的后缀。我们可以用<code class="fe oa ob oc od b">importlib.import_module</code>将函数或类作为<em class="nm">字符串</em>导入。</p><p id="8a4f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe oa ob oc od b">getattr</code>从一个对象中提取命名属性，在本例中，是我们的Python模块中的函数，方式与我们做<code class="fe oa ob oc od b">from module import attribute</code>的方式相同。</p><h2 id="cceb" class="no mq it bd mr np nq dn mv nr ns dp mz lh nt nu nb ll nv nw nd lp nx ny nf nz bi translated">打字</h2><p id="a0cb" class="pw-post-body-paragraph ky kz it la b lb nh ju ld le ni jx lg lh nj lj lk ll nk ln lo lp nl lr ls lt im bi translated">来自<code class="fe oa ob oc od b">typing</code>模块的方法<code class="fe oa ob oc od b">get_type_hints()</code>返回包含函数、方法、模块或类对象的类型提示的字典。<code class="fe oa ob oc od b">get_type_hints</code> <em class="nm">不支持</em>字符串，因此我们使用<code class="fe oa ob oc od b">ast</code>库来解析模块中的方法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="ec93" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">本词典中的最后一个<code class="fe oa ob oc od b">key</code>是“return ”,包含返回变量type-hint(如果有),否则没有。我们可以用<code class="fe oa ob oc od b">.pop</code>方法从字典中排除这个键。</p><h2 id="0078" class="no mq it bd mr np nq dn mv nr ns dp mz lh nt nu nb ll nv nw nd lp nx ny nf nz bi translated">正则表达式</h2><p id="948c" class="pw-post-body-paragraph ky kz it la b lb nh ju ld le ni jx lg lh nj lj lk ll nk ln lo lp nl lr ls lt im bi translated">我们使用下面的正则表达式来理解函数参数在我们的<a class="ae oj" href="https://google.github.io/styleguide/pyguide.html" rel="noopener ugc nofollow" target="_blank"> Google风格的文档字符串</a>中的定义位置。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="95b1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">首先，我们从函数节点<code class="fe oa ob oc od b">get_docstring</code>开始，寻找三个属性<code class="fe oa ob oc od b">Args</code>、<code class="fe oa ob oc od b">Example[s]</code>和<code class="fe oa ob oc od b">Return[s]</code>(第8行)。然后我们迭代每个函数参数(第31行)，用它选择我们的<code class="fe oa ob oc od b">type_hints</code>字典中的值(第38行)，删除打印的type_hint的<code class="fe oa ob oc od b">&lt;class ''&gt;</code>部分(第39行)，并将其插入括号中(第43行)。</p><p id="43c5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请在这里找到完整的脚本，看看我们如何对函数返回参数的类型提示做同样的事情，并用新格式化的docstring文本覆盖我们的Python脚本。</p></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="1443" class="mp mq it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">通过预提交Git挂钩实现自动化</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ok"><img src="../Images/76cc635afaf1efd6a37b726430753b82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R9B5xSEwbnz3SOb7XQp3Qw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">预提交Git管道</p></figure><p id="881b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">通过Git钩子，我们可以在每次提交和推送到我们的库之前运行林挺和格式化工具，比如<code class="fe oa ob oc od b">mypy</code>、<code class="fe oa ob oc od b">autoflake</code>、<code class="fe oa ob oc od b">flake8</code>、<code class="fe oa ob oc od b">isort</code>、<code class="fe oa ob oc od b">black</code>。这使我们能够在Python项目中自动创建“编码标准”。这些Git挂钩是由<code class="fe oa ob oc od b">pre-commit</code>包提供的，它使用一个<code class="fe oa ob oc od b">pre-commit-config.yaml</code>文件来指定在预提交管道中包含哪些包。</p><p id="9ce8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请在下面的故事中找到更多关于预提交Git挂钩的有用提示👇</p><div class="ol om gp gr on oo"><a href="https://betterprogramming.pub/4-tips-to-automate-clean-code-in-python-527f59b5fe4e" rel="noopener  ugc nofollow" target="_blank"><div class="op ab fo"><div class="oq ab or cl cj os"><h2 class="bd iu gy z fp ot fr fs ou fu fw is bi translated">在Python中自动化干净代码的4个技巧</h2><div class="ov l"><h3 class="bd b gy z fp ot fr fs ou fu fw dk translated">通过这些林挺和格式化工具，使用预提交Git挂钩来自动化Python代码样式</h3></div><div class="ow l"><p class="bd b dl z fp ot fr fs ou fu fw dk translated">better编程. pub</p></div></div><div class="ox l"><div class="oy l oz pa pb ox pc ks oo"/></div></div></a></div><p id="705f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">除了林挺和格式化工具，您还可以通过bash命令在这些Git挂钩中包含Python脚本的执行，使我们能够自动化<code class="fe oa ob oc od b">docstring_from_type_hints()</code>功能。这样，在每次提交时，类型提示都会被插入到我们的docstring中。</p></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pd"><img src="../Images/e69a861ec807ac52fec333c915d07e3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2GXBH9B9RZZLc5BmYEExZQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">MkDocs中自动生成的Google风格的docstring示例</p></figure><p id="670e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">更进一步，我们可以用Mkdocs中的Python文档自动创建一个静态网站。以下是更多相关信息👇</p><div class="ol om gp gr on oo"><a rel="noopener follow" target="_blank" href="/five-tips-for-automatic-python-documentation-7513825b760e"><div class="op ab fo"><div class="oq ab or cl cj os"><h2 class="bd iu gy z fp ot fr fs ou fu fw is bi translated">自动化Python文档的五个技巧</h2><div class="ov l"><h3 class="bd b gy z fp ot fr fs ou fu fw dk translated">用这五个自动化步骤和预提交Git挂钩在MkDocs &amp; Material中创建漂亮的Python文档</h3></div><div class="ow l"><p class="bd b dl z fp ot fr fs ou fu fw dk translated">towardsdatascience.com</p></div></div><div class="ox l"><div class="pe l oz pa pb ox pc ks oo"/></div></div></a></div></div></div>    
</body>
</html>