<html>
<head>
<title>Build Your Neural Networks with Keras in Three Ways</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用 Keras 以三种方式建立你的神经网络</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/build-your-neural-networks-with-keras-in-three-ways-553cea182c6b?source=collection_archive---------13-----------------------#2021-12-16">https://towardsdatascience.com/build-your-neural-networks-with-keras-in-three-ways-553cea182c6b?source=collection_archive---------13-----------------------#2021-12-16</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="ef1b" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">如何、为什么以及何时使用每种方法</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/c931751862934530da6c84ffe49d8a71.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3PMOC8b0cHVkaZ5fdLt1Kg.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">如何使用 Keras API[图片由作者提供]</p></figure><p id="2d77" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi lv translated"><span class="l lw lx ly bm lz ma mb mc md di">我</span>仍然清晰而痛苦地记得我第一次面对神经网络及其实现的情景。好像我的困惑还不够大，试图让我的思想围绕着神经网络的内部工作方式，如何使用 Keras API 的不同方式使混乱更加彻底。所以我坐下来，拼命寻找这个问题的最终答案:实现神经网络的最佳方式是什么？</p><p id="860d" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">在接下来的几节中，我们将解开这些乱七八糟的东西。避免不同语法带来的不必要的麻烦，因此我们可以专注于更重要的问题，如使用哪种架构或如何提高模型的性能。</p></div><div class="ab cl mf mg hy mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="in io ip iq ir"><p id="09c5" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">Keras 或者更具体地说是<a class="ae mm" href="https://keras.io/api/models/" rel="noopener ugc nofollow" target="_blank">模型 API </a>可以分为三个部分，因此可以通过多种方式创建模型。接下来，我们将学习如何以及何时利用 API 的哪一部分。</p><p id="ec9c" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">我们将使用良好的 MNIST 数据集，以三种不同的方式构建相同的全连接神经网络。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="mn mo l"/></div></figure><h1 id="d8a9" class="mp mq iu bd mr ms mt mu mv mw mx my mz ka na kb nb kd nc ke nd kg ne kh nf ng bi translated">顺序模型</h1><p id="4146" class="pw-post-body-paragraph kz la iu lb b lc nh jv le lf ni jy lh li nj lk ll lm nk lo lp lq nl ls lt lu in bi translated">使用<code class="fe nm nn no np b">Sequential Model</code>非常简单。我们既可以通过向构造函数传递一个层列表来构建模型，也可以通过多次调用<code class="fe nm nn no np b">add()</code>方法来逐步构建模型。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="mn mo l"/></div></figure><p id="6cfe" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">顺序模型的作用类似于一个<em class="me">线性</em>或<em class="me">普通</em> <em class="me">层的堆叠</em>，其中每一层恰好有一个输入张量和一个输出张量。这使得我们一方面很容易使用和调试，而另一方面，我们失去了很多灵活性。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj nq"><img src="../Images/9b5d287f2bb0d8b2908ff24279970d54.png" data-original-src="https://miro.medium.com/v2/resize:fit:250/format:webp/1*a43pC2s7AdRl3-3ba_36MQ.png"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">层叠[图片由作者提供]</p></figure><p id="6639" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">因此，当我们的模型或我们的一个层具有多个输入或输出时，顺序模型是不合适的，我们需要进行层共享，或者我们想要使用非线性拓扑，例如剩余或跳过连接。</p><p id="fdcb" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">我们现在可以编译、训练并获得我们模型的摘要。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="mn mo l"/></div></figure><pre class="kk kl km kn gu nr np ns nt aw nu bi"><span id="e3fc" class="nv mq iu np b gz nw nx l ny nz">&gt;&gt; Total params: 119,306<br/>&gt;&gt; Trainable params: 118,794<br/>&gt;&gt; Non-trainable params: 512</span></pre></div><div class="ab cl mf mg hy mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="in io ip iq ir"><h1 id="c790" class="mp mq iu bd mr ms oa mu mv mw ob my mz ka oc kb nb kd od ke nd kg oe kh nf ng bi translated">功能 API</h1><p id="d265" class="pw-post-body-paragraph kz la iu lb b lc nh jv le lf ni jy lh li nj lk ll lm nk lo lp lq nl ls lt lu in bi translated"><code class="fe nm nn no np b">functional API</code>为我们提供了一种建立模型的方法，比顺序模型更加灵活。它使我们能够创建非线性拓扑、共享层，甚至多个输入或输出。作为功能 API 的基础，主要思想是构建一个<em class="me">层图</em>。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="mn mo l"/></div></figure><p id="8556" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">我们可以通过用输入维度(28x28 像素)定义一个输入节点来构建一个图层图。</p><p id="a779" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">接下来，我们定义更多的节点来重新创建之前的模型。然后，通过将前一个节点作为输入传递给下一个节点来连接这些节点。这些连接为我们提供了构建非线性拓扑所需的灵活性，例如通过连接非相邻节点和创建跳过连接。</p><p id="38b5" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">我们还可以编译、训练并获得我们的模型的摘要，它与序列模型具有相同的结构。</p><pre class="kk kl km kn gu nr np ns nt aw nu bi"><span id="4251" class="nv mq iu np b gz nw nx l ny nz">&gt;&gt; Total params: 119,306<br/>&gt;&gt; Trainable params: 118,794<br/>&gt;&gt; Non-trainable params: 512</span></pre></div><div class="ab cl mf mg hy mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="in io ip iq ir"><h1 id="e512" class="mp mq iu bd mr ms oa mu mv mw ob my mz ka oc kb nb kd od ke nd kg oe kh nf ng bi translated">模型子类化</h1><p id="6530" class="pw-post-body-paragraph kz la iu lb b lc nh jv le lf ni jy lh li nj lk ll lm nk lo lp lq nl ls lt lu in bi translated">用子类化创建模型为我们提供了最大的灵活性。然而，这种灵活性的代价是复杂性和冗长性的增加。</p><p id="837d" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><code class="fe nm nn no np b">Layer Class</code>是 Keras 中的核心抽象之一。一个层保存状态(<em class="me">层的权重</em>)和从输入到输出的转换(<em class="me">来自调用的前向传递</em>)。当模型的复杂性增加时，创建定制层特别有用，它为我们提供了在模型架构中创建可重用“块”的方法。</p><p id="585c" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">在我们的模型中，我们可以使用一个定制层来创建一个在我们的架构中多次出现的基本构建块。下面的类继承自 layer 类，初始化两层:Dense 和 BatchNormalization。然后，这两层都在正向传递中被简单地调用。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="mn mo l"/></div></figure><p id="63b9" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">接下来，我们利用上面的自定义层创建我们的模型。我们的类继承自<code class="fe nm nn no np b">Keras Model Class</code>，因此得名子类化。我们基于<code class="fe nm nn no np b">hidden_layer = [128,128]</code>初始化我们的自定义图层，以及另外两个图层:展平和我们的最终输出图层。然后，在模型的正向传递中，所有的层都被简单地调用。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="mn mo l"/></div></figure><p id="4868" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">然后，我们可以再次编译、训练并获得模型的摘要，这应该与之前相同。</p><pre class="kk kl km kn gu nr np ns nt aw nu bi"><span id="0839" class="nv mq iu np b gz nw nx l ny nz">&gt;&gt; Total params: 119,306<br/>&gt;&gt; Trainable params: 118,794<br/>&gt;&gt; Non-trainable params: 512</span></pre></div><div class="ab cl mf mg hy mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="in io ip iq ir"><h1 id="9e93" class="mp mq iu bd mr ms oa mu mv mw ob my mz ka oc kb nb kd od ke nd kg oe kh nf ng bi translated">结论</h1><p id="23fc" class="pw-post-body-paragraph kz la iu lb b lc nh jv le lf ni jy lh li nj lk ll lm nk lo lp lq nl ls lt lu in bi translated">在 Keras 中有三种创建模型的方法。根据我们要解决的问题和我们需要构建的模型，一种方法可能比另一种更适合，但一般来说没有绝对最好或正确的方法。</p><p id="1806" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">简单、线性和直观的模型可以而且可能应该用顺序 API 或函数 API 来构建。然而，更复杂、非线性和高度定制的模型将从子类化中受益匪浅。</p><p id="82ee" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">总之，一个人应该知道并尝试以上所有的方法，扩大他们的工具箱，以便有效地解决问题。</p><blockquote class="of og oh"><p id="30b6" class="kz la me lb b lc ld jv le lf lg jy lh oi lj lk ll oj ln lo lp ok lr ls lt lu in bi translated">感谢您的阅读！确保保持联系&amp;在<a class="ae mm" href="https://medium.com/@marvinlanhenke" rel="noopener"> Medium </a>、<a class="ae mm" href="https://www.kaggle.com/mlanhenke" rel="noopener ugc nofollow" target="_blank"> Kaggle </a>上关注我，或者在<a class="ae mm" href="https://www.linkedin.com/in/marvin-lanhenke-11b902211/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上说声“嗨”</p></blockquote></div><div class="ab cl mf mg hy mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="in io ip iq ir"><p id="f919" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">喜欢这篇文章吗？成为 <a class="ae mm" href="https://medium.com/@marvinlanhenke/membership" rel="noopener"> <em class="me">中等会员</em> </a> <em class="me">继续无限学习。如果你使用下面的链接，我会收到你的一部分会员费，不需要你额外付费。</em></p><div class="ol om gq gs on oo"><a href="https://medium.com/@marvinlanhenke/membership" rel="noopener follow" target="_blank"><div class="op ab fp"><div class="oq ab or cl cj os"><h2 class="bd iv gz z fq ot fs ft ou fv fx it bi translated">通过我的推荐链接加入 Medium-Marvin Lanhenke</h2><div class="ov l"><h3 class="bd b gz z fq ot fs ft ou fv fx dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="ow l"><p class="bd b dl z fq ot fs ft ou fv fx dk translated">medium.com</p></div></div><div class="ox l"><div class="oy l oz pa pb ox pc kt oo"/></div></div></a></div></div></div>    
</body>
</html>