<html>
<head>
<title>Augmented Assignment Expression in Python — The Walrus Operator := and Beyond</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的增广赋值表达式Walrus运算符:=及其他</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/augmented-assignment-expression-in-python-the-walrus-operator-and-beyond-9db36a219df3?source=collection_archive---------26-----------------------#2021-10-19">https://towardsdatascience.com/augmented-assignment-expression-in-python-the-walrus-operator-and-beyond-9db36a219df3?source=collection_archive---------26-----------------------#2021-10-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a235" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">不仅仅是关于海象算子，还有很多相关的概念</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/3b882f0a144744ec289fad0f1634f722.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*58qsJrvYh5W-ffxx"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">汤米·克兰巴赫在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="a15b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从3.8版本开始，Python中就包含了新的特征增强赋值表达式。特别是，结果出现了一个新的操作符——内联赋值操作符<code class="fe lv lw lx ly b">:=</code>。因为它的外观，这个操作符通常被称为海象操作符。在本文中，我将讨论这个操作符的关键方面，以帮助您理解这项技术。</p><p id="1fbb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事不宜迟，让我们开始吧。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h2 id="3970" class="mg mh it bd mi mj mk dn ml mm mn dp mo li mp mq mr lm ms mt mu lq mv mw mx my bi translated">表达式和语句的区别</h2><p id="d7bc" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">在Python或一般的编程语言中，有两个密切相关的概念:表达式和语句。让我们看两行简单的代码，如下所示。</p><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="a38d" class="mg mh it ly b gy ni nj l nk nl">&gt;&gt;&gt; 5 + 3    #A<br/>8<br/>&gt;&gt;&gt; a = 5 + 3    #B</span></pre><p id="75f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">#A是一个表达式，因为它的计算结果是一个整数。相比之下，#B是一个语句，确切地说是一个赋值语句。更一般地说，表达式是计算值或Python中的对象的代码(Python中的值都是对象)。例如，当你调用一个函数时(如<code class="fe lv lw lx ly b">abs(-5)</code>)，它是一个表达式。</p><p id="79da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">语句是不计算任何值的代码。简而言之，他们执行一个动作，或者做一些事情。例如，赋值语句创建一个变量。<code class="fe lv lw lx ly b">with</code>语句建立了一个上下文管理器。<code class="fe lv lw lx ly b">if…else…</code>语句创建逻辑分支。</p><p id="8e9e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，表达式和语句的最大区别在于代码是否计算为对象。</p><p id="6077" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可能想知道为什么我们在这里关心这种区别。我们继续吧。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h2 id="4a40" class="mg mh it bd mi mj mk dn ml mm mn dp mo li mp mq mr lm ms mt mu lq mv mw mx my bi translated">扩充赋值是一个语句</h2><p id="c13b" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">许多人熟悉的最常见的扩充任务形式是<code class="fe lv lw lx ly b">+=</code>。下面的代码向您展示了一个示例。</p><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="0658" class="mg mh it ly b gy ni nj l nk nl">&gt;&gt;&gt; num = 5<br/>&gt;&gt;&gt; num += 4</span></pre><p id="b807" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">判断一行代码是否是表达式的一个简单方法是简单地将它发送给内置的<code class="fe lv lw lx ly b">print</code>函数，该函数应该接受任何对象。当您发送一个要打印的语句时，它会引发一个<code class="fe lv lw lx ly b">SyntaxError</code>。让我们来试试:</p><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="26ce" class="mg mh it ly b gy ni nj l nk nl">&gt;&gt;&gt; print(num += 4)<br/>  File "&lt;input&gt;", line 1<br/>    print(num += 4)<br/>              ^<br/>SyntaxError: invalid syntax</span></pre><p id="f88c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事实上，我们不能在<code class="fe lv lw lx ly b">print</code>函数中使用增强赋值。或者，为了确定某些代码是否是表达式，有另一个内置函数<code class="fe lv lw lx ly b">eval</code>，它计算一个表达式。当代码不能被求值时，比如一个语句，就会发生错误，如下所示。</p><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="57be" class="mg mh it ly b gy ni nj l nk nl">&gt;&gt;&gt; eval("num += 4")<br/>Traceback (most recent call last):<br/>  File "&lt;input&gt;", line 1, in &lt;module&gt;<br/>  File "&lt;string&gt;", line 1<br/>    num += 4<br/>        ^<br/>SyntaxError: invalid syntax</span></pre><p id="d00b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事实上，<code class="fe lv lw lx ly b">x += y </code>是语句<code class="fe lv lw lx ly b">x = x + y</code>的简写，这是一个设计好的赋值。因为产生的变量与用于增量(y)的变量同名(即x)，所以它也被称为就地加法运算。</p><p id="7dc2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样的就地分配也适用于其他的扩充分配，例如<code class="fe lv lw lx ly b">-=</code>、<code class="fe lv lw lx ly b">*=</code>和<code class="fe lv lw lx ly b">/=</code>。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h2 id="8b4f" class="mg mh it bd mi mj mk dn ml mm mn dp mo li mp mq mr lm ms mt mu lq mv mw mx my bi translated">扩充赋值表达式是一个表达式</h2><p id="f16c" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">与这些扩充赋值语句不同，新的扩充赋值表达式是一个表达式。让我们从一个简单的例子开始。</p><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="6117" class="mg mh it ly b gy ni nj l nk nl">&gt;&gt;&gt; (another_num := 15)<br/>15</span></pre><p id="fd78" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如上图，因为我们使用的是交互式Python控制台，所以如果该行代码的求值结果是任何对象(除了<code class="fe lv lw lx ly b">None</code>，控制台在输出时会忽略它)，那么求值结果会自动显示。因此，上面的扩充赋值表达式确实是一个表达式。请注意，这里使用的一对括号是出于语法原因，因为这样一个增强的赋值表达式本身没有任何实际用途，因此不推荐使用。</p><p id="a4a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以证明扩充赋值表达式的本质是一个带有<code class="fe lv lw lx ly b">print</code>和<code class="fe lv lw lx ly b">eval</code>函数的表达式，如下所示。</p><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="2fbb" class="mg mh it ly b gy ni nj l nk nl">&gt;&gt;&gt; print(another_num := 15)<br/>15<br/>&gt;&gt;&gt; eval("(another_num := 15)")<br/>15</span></pre></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h2 id="93a1" class="mg mh it bd mi mj mk dn ml mm mn dp mo li mp mq mr lm ms mt mu lq mv mw mx my bi translated">实际用例是什么？</h2><p id="4865" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">扩充赋值表达式也称为内联扩充赋值。正如它的行所示，这是一个内联操作，因此我们在刚刚求值的地方定义一个变量——本质上，我们将求值和赋值合并到一个步骤中。</p><p id="5fcf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">也许这有点太专业，难以理解，但让我给出一个看似合理的用例。在一个典型的if…else…语句中，if或else子句只能接受表达式，这样子句就可以对运算的表达式求值为true或falsy。显然，在从句中，你不能使用陈述句。考虑下面这个看似合理的用例。</p><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="dd05" class="mg mh it ly b gy ni nj l nk nl">def withdraw_money(account_number):<br/>    if account := locate_account(account_number):<br/>        take_money_from(account)<br/>    else:<br/>        found_no_account()</span></pre><p id="8fe8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如上所示，<code class="fe lv lw lx ly b">locate_account</code>函数返回使用<code class="fe lv lw lx ly b">account_number</code>找到的账户。如果找到，从赋值表达式中创建的变量<code class="fe lv lw lx ly b">account</code>将进一步用于<code class="fe lv lw lx ly b">if</code>子句的主体中。否则，使用顺序方式，这里有一个可能的解决方案:</p><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="f283" class="mg mh it ly b gy ni nj l nk nl">def withdraw_money(account_number):<br/>    account = locate_account(account_number)<br/>    if account:<br/>        take_money_from(account)<br/>    else:<br/>        found_no_account()</span></pre><p id="b0c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这两种实现之间的差异可能微不足道。然而，实际的用例可能更复杂，涉及更多的分支，这证明了使用赋值表达式技术的合理性。考虑以下使用案例:</p><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="b8c1" class="mg mh it ly b gy ni nj l nk nl">def withdraw_money(account_number):<br/>    if account := locate_account_in_saving(account_number):<br/>        take_money_from_saving(account)<br/>    elif account := locate_account_in_checking(account_number):<br/>        take_money_from_checking(account)<br/>    elif account := locate_account_in_retirement(account_number):<br/>        take_money_from_retirement(account)<br/>    else:<br/>        pass</span></pre><p id="63ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如你所看到的，有了更多的分支，如果你选择分成两个独立的步骤:函数调用，然后赋值，上面的代码会变得复杂得多。不信的话，请自行尝试:)</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h2 id="c8a1" class="mg mh it bd mi mj mk dn ml mm mn dp mo li mp mq mr lm ms mt mu lq mv mw mx my bi translated">结论</h2><p id="9a21" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">在本文中，我们回顾了Python 3.8中增加的扩充赋值表达式技术。我们不仅研究了这项技术本身，还回顾了与这项技术相关的关键概念。我希望您对这种技术及其正确的用例有更好的理解。</p><p id="f4d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读这篇文章。通过<a class="ae ky" href="https://medium.com/subscribe/@yong.cui01" rel="noopener">注册我的简讯</a>保持联系。还不是中等会员？通过<a class="ae ky" href="https://medium.com/@yong.cui01/membership" rel="noopener">使用我的会员链接</a>支持我的写作(对你没有额外的费用，但是你的一部分会费作为奖励由Medium重新分配给我)。</p></div></div>    
</body>
</html>