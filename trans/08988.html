<html>
<head>
<title>Merging ONNX graphs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">合并ONNX图</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/merging-onnx-graphs-da088dbaf9b4?source=collection_archive---------10-----------------------#2021-08-19">https://towardsdatascience.com/merging-onnx-graphs-da088dbaf9b4?source=collection_archive---------10-----------------------#2021-08-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/b152e39e214c6e27dbdbfa10bed7ad00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KjBRWR0kdcl3ZDEqttT0XA.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">(图片由作者提供)</p></figure><div class=""/><div class=""><h2 id="9e61" class="pw-subtitle-paragraph kc je jf bd b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt dk translated">使用sclblonnx连接、合并、分割和连接ONNX图形。</h2></div><p id="6e0e" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">ONNX越来越火了。虽然最初主要被认为是一种简单存储AI/ML模型的文件格式，但近年来它的用途已经发生了变化。如今，我们看到许多数据科学家使用ONNX作为构建和管理完整数据处理管道的手段。随着ONNX使用的增长，对创建、检查和编辑ONNX图形的良好工具的需求也在增长。幸运的是，ONNX的大型生态系统正在出现；在这篇文章中，我们描述了由<code class="fe lq lr ls lt b"><a class="ae lu" href="https://pypi.org/project/sclblonnx/" rel="noopener ugc nofollow" target="_blank">sclblonnx</a></code>包(由<a class="ae lu" href="https://www.scailable.net" rel="noopener ugc nofollow" target="_blank"> Scailable </a>策划)提供的ONNX连接、分割、合并和连接功能。请注意，当您主动管理有用的ONNX“子图”时，合并、拆分和连接ONNX图非常有用:也就是说，您可能有以ONNX格式存储的数据管道中的首选预处理和后处理步骤，并且您希望将这些子图与您刚刚在TensorFlow或PyTorch中训练的模型连接起来。在这篇文章中，我试图解释这是如何做到的。</p><blockquote class="lv lw lx"><p id="f31d" class="ku kv ly kw b kx ky kg kz la lb kj lc lz le lf lg ma li lj lk mb lm ln lo lp ij bi translated"><strong class="kw jg">注:</strong>我之前写过ONNX编辑合并，见<a class="ae lu" rel="noopener" target="_blank" href="/creating-editing-and-merging-onnx-pipelines-897e55e98bb0">https://towardsdatascience . com/creating-editing-and-merging-ONNX-pipelines-897 e 55 e 98 bb 0</a>。然而，随着<code class="fe lq lr ls lt b"><a class="ae lu" href="https://pypi.org/project/sclblonnx/" rel="noopener ugc nofollow" target="_blank">sclblonnx</a></code> <code class="fe lq lr ls lt b">0.1.9</code>的发布，功能得到了极大的扩展。</p></blockquote><h1 id="e0fb" class="mc md jf bd me mf mg mh mi mj mk ml mm kl mn km mo ko mp kp mq kr mr ks ms mt bi translated">一些ONNX背景</h1><p id="32ed" class="pw-post-body-paragraph ku kv jf kw b kx mu kg kz la mv kj lc ld mw lf lg lh mx lj lk ll my ln lo lp ij bi translated">在讨论由<code class="fe lq lr ls lt b">sclblonnx 0.1.9</code>提供的ONNX图形的新的<code class="fe lq lr ls lt b">merge</code>、<code class="fe lq lr ls lt b">concat</code>、<code class="fe lq lr ls lt b">split</code>和<code class="fe lq lr ls lt b">join</code>功能之前，提供一点关于ONNX图形的背景是有用的。在本文的这一点上，我假设你知道一些ONNX的基础知识(如果不知道，请看<a class="ae lu" rel="noopener" target="_blank" href="/creating-onnx-from-scratch-4063eab80fcd">这篇文章</a>，或者<a class="ae lu" rel="noopener" target="_blank" href="/onnx-for-image-processing-from-scratch-6694f9b141b0">这篇文章</a>)。因此，你知道ONNX提供了一个有向计算图的描述，它指定了在(强类型)输入张量上执行哪个<a class="ae lu" href="http://onnx operators" rel="noopener ugc nofollow" target="_blank">操作</a>来产生期望的输出张量。而且，你知道ONNX对于存储经过训练的AI/ML模型很有用，<em class="ly">和</em>用于创建数据科学管道，以一种独立于平台和部署目标的方式。<em class="ly">也就是</em>大家一般都知道ONNX是好玩的东西。</p><p id="d39f" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">然而，为了理解如何合并、分割、连接和连接ONNX图，我们需要更多的背景知识。我们既需要理解<em class="ly">图中的边是如何创建的</em>，也需要更详细地理解图的输入和输出的<em class="ly">角色。</em></p><h2 id="5b9f" class="mz md jf bd me na nb dn mi nc nd dp mm ld ne nf mo lh ng nh mq ll ni nj ms nk bi translated">按名称隐式创建边</h2><p id="9b7d" class="pw-post-body-paragraph ku kv jf kw b kx mu kg kz la mv kj lc ld mw lf lg lh mx lj lk ll my ln lo lp ij bi translated">让我们从边的创建开始。尽管ONNX图仅仅是一个<a class="ae lu" href="https://en.wikipedia.org/wiki/Directed_graph" rel="noopener ugc nofollow" target="_blank">有向图</a>，因此可以用它的节点和边来描述，但这不是我们创建(也不是存储)ONNX图的方式。当创建ONNX图时，我们并不明确地创建邻接矩阵来标识节点之间的边。相反，我们创建一些<code class="fe lq lr ls lt b">type</code>(不同的操作符)的节点，每个节点都有一个命名的<code class="fe lq lr ls lt b">input</code>和<code class="fe lq lr ls lt b">output</code>。这也是ONNX文件(实际上只是一个protobuf)中存储的所有内容:该文件存储了一个操作符类型列表，每个类型都有自己命名的输入和输出。最后的名字允许在图中构造边:如果节点<code class="fe lq lr ls lt b">n1</code>有一个名为<code class="fe lq lr ls lt b">x1</code>的输出，节点<code class="fe lq lr ls lt b">n2</code>有一个名为<code class="fe lq lr ls lt b">x1</code>的输入，那么在<code class="fe lq lr ls lt b">n1</code>和<code class="fe lq lr ls lt b">n2</code>之间将创建一条(有向)边。如果随后添加另一个节点<code class="fe lq lr ls lt b">n3</code>，该节点<em class="ly">也</em>有一个命名输入<code class="fe lq lr ls lt b">x1</code>，我们最终得到下图:</p><figure class="nm nn no np gt is gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/ba494dc92cacf514ae15ba136a857102.png" data-original-src="https://miro.medium.com/v2/resize:fit:932/format:webp/1*1axrzjVKzUjbl1ZXK4BfZg.png"/></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">(图片由作者提供)</p></figure><p id="9819" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">因此，在合并、连接、连接和拆分ONNX(子)图时，了解最终组合的图中存在的输入和输出名称是非常重要的——在某种程度上是内部的，如果您已经从各种培训工具之一导出到ONNX，您可能不知道这些名称。如果两个图形中出现相同的名称，则不小心合并图形会导致绘制出可能不需要的边。</p><blockquote class="nq"><p id="6922" class="nr ns jf bd nt nu nv nw nx ny nz lp dk translated">如果两个图形中出现相同的名称，则不小心合并图形会导致绘制出可能不需要的边。</p></blockquote><h2 id="42e0" class="mz md jf bd me na oa dn mi nc ob dp mm ld oc nf mo lh od nh mq ll oe nj ms nk bi translated">图形的输入和输出</h2><p id="bdf0" class="pw-post-body-paragraph ku kv jf kw b kx mu kg kz la mv kj lc ld mw lf lg lh mx lj lk ll my ln lo lp ij bi translated">在合并、分割或编辑ONNX图时，另一个有点混乱但非常重要的概念是<em class="ly">节点</em>(正如我们刚刚讨论的，用于创建边)的输入和输出与<em class="ly">图</em>本身的输入和输出之间的区别。图形输入和输出分别表示输入到计算图形的张量，以及执行计算产生的张量。输入和输出以与创建边相同的方式隐式连接到图。实际上，图的输入和输出的一个合理的心理模型是，它们仅仅是只有一个输出(图的输入)或者只有一个输入(图的输出)的节点；这些不在张量上操作的特殊节点各自的输入和输出就是外界。</p><p id="0993" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">好吧，这有点神秘。</p><p id="1337" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">让我们用下面的符号举几个例子:</p><pre class="nm nn no np gt of lt og oh aw oi bi"><span id="6ecd" class="mz md jf lt b gy oj ok l ol om">I1(name)  # An input (to the graph) with a specific name<br/>O1(name)  # An output (to the graph) with a specific name<br/>N1({name, name, ...}, {name, name, ...}) # A node, with a list of inputs and outputs.</span></pre><p id="1b06" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">给定这个符号，我们可以例如表示</p><pre class="nm nn no np gt of lt og oh aw oi bi"><span id="f542" class="mz md jf lt b gy oj ok l ol om"># A simple graph:<br/>I1(x1)<br/>I2(x2)<br/>O3(x3)<br/>N1({x1,x2},{x3})</span></pre><p id="624d" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">这将生成(使用橙色表示输入和输出)下图:</p><figure class="nm nn no np gt is gh gi paragraph-image"><div class="gh gi on"><img src="../Images/fd1e0b7849b9bcf9a97017a1dd9c27dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*i9ny03XQ5dUwiaCHs_6HNA.png"/></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">(图片由作者提供)</p></figure><p id="7f24" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">如果<code class="fe lq lr ls lt b">N1</code>是加法运算符，这个图将简单编码为两个张量相加。</p><p id="b7df" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">让我们做一个稍微复杂一点的图表:</p><pre class="nm nn no np gt of lt og oh aw oi bi"><span id="1e81" class="mz md jf lt b gy oj ok l ol om">I1(x1)<br/>I2(x2)<br/>N1({x1, x2}, {x3})<br/>N2({x2, x3}, {x4})<br/>O1(x3)<br/>O2(x4)</span></pre><p id="b919" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">这将在图形上导致:</p><figure class="nm nn no np gt is gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/11e1644da5359715be5f50b800998f21.png" data-original-src="https://miro.medium.com/v2/resize:fit:494/format:webp/1*KrWTY6H6OBwiZtbIchQ5ug.png"/></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">(图片由作者提供)</p></figure><p id="9a95" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">好了，现在我们清楚了图的内部边、输入和输出是如何构造的；让我们仔细看看<code class="fe lq lr ls lt b">sclblonnx</code>包中的工具！</p><h1 id="0975" class="mc md jf bd me mf mg mh mi mj mk ml mm kl mn km mo ko mp kp mq kr mr ks ms mt bi translated">使用<code class="fe lq lr ls lt b">sclblonnx</code>操作ONNX图形</h1><p id="f638" class="pw-post-body-paragraph ku kv jf kw b kx mu kg kz la mv kj lc ld mw lf lg lh mx lj lk ll my ln lo lp ij bi translated">从版本<code class="fe lq lr ls lt b">0.1.9</code>的更新开始，<code class="fe lq lr ls lt b">sclblonnx</code>包包含了许多更高级的实用函数，将多个ONNX(子)图合并成一个图。尽管该包的早期版本已经包含了<code class="fe lq lr ls lt b">merge</code>函数来有效地将两个图形粘贴在一起(稍后将详细介绍)，但此次更新将<code class="fe lq lr ls lt b">merge</code>、<code class="fe lq lr ls lt b">join</code>和<code class="fe lq lr ls lt b">split</code>作为一个更高级别的包装器，围绕着一个更加通用、也更难使用的函数<code class="fe lq lr ls lt b">concat</code>。让我们从更高级的功能开始。</p><blockquote class="lv lw lx"><p id="5810" class="ku kv ly kw b kx ky kg kz la lb kj lc lz le lf lg ma li lj lk mb lm ln lo lp ij bi translated">这里描述的所有函数都可以在<code class="fe lq lr ls lt b">sclblonnx</code>包的例子中用python代码找到。这些可以在<a class="ae lu" href="https://github.com/scailable/sclblonnx/blob/master/examples/example_merge.py" rel="noopener ugc nofollow" target="_blank">https://github . com/scailable/sclblonnx/blob/master/examples/example _ merge . py</a>找到。另外，请参见所讨论的每个函数的文档:<a class="ae lu" href="https://github.com/scailable/sclblonnx/blob/master/sclblonnx/merge.py" rel="noopener ugc nofollow" target="_blank">https://github . com/scailable/sclblonnx/blob/master/sclblonnx/merge . py</a></p></blockquote><h2 id="9d87" class="mz md jf bd me na nb dn mi nc nd dp mm ld ne nf mo lh ng nh mq ll ni nj ms nk bi translated">合并</h2><p id="5975" class="pw-post-body-paragraph ku kv jf kw b kx mu kg kz la mv kj lc ld mw lf lg lh mx lj lk ll my ln lo lp ij bi translated"><code class="fe lq lr ls lt b">merge</code>有效地获取两个图形(父图形和子图形)，并将父图形的已识别输出粘贴到子图形的已识别输入。默认情况下，<code class="fe lq lr ls lt b">merge</code>假设两个图都是完整的(即所有的边都匹配得很好，并且所有的输入和输出都已定义)。<code class="fe lq lr ls lt b">merge</code>的签名是</p><pre class="nm nn no np gt of lt og oh aw oi bi"><span id="8928" class="mz md jf lt b gy oj ok l ol om">merge(sg1, sg2, io_match)</span></pre><p id="a0e6" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">其中<code class="fe lq lr ls lt b">sg1</code>是父子图，<code class="fe lq lr ls lt b">sg2</code>是子图，<code class="fe lq lr ls lt b">io_match</code>给出了需要与<code class="fe lq lr ls lt b">inputs</code> off <code class="fe lq lr ls lt b">sg2</code>匹配的<code class="fe lq lr ls lt b">sg1</code>输出名称对的列表。因此，根据我们在上一节中发展的符号，如果我们有:</p><pre class="nm nn no np gt of lt og oh aw oi bi"><span id="6ad8" class="mz md jf lt b gy oj ok l ol om"># Parent (sg1)<br/>I1(x1)<br/>N1({x1},{x2})<br/>O1(x2)</span><span id="d46c" class="mz md jf lt b gy op ok l ol om"># Child (sg2)<br/>I2(z1)<br/>N2({z1},{z2})<br/>O2(z2)</span></pre><p id="481f" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">对<code class="fe lq lr ls lt b">merge(sg1, sg2, [(x2,z1)])</code>的调用将创建:</p><pre class="nm nn no np gt of lt og oh aw oi bi"><span id="8d9c" class="mz md jf lt b gy oj ok l ol om">I1(x1)<br/>N1({x1},{x2})<br/>N2({x2},{z2})<br/>O2(z2)</span></pre><p id="cfbb" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">然而，正如你所想象的，我们可以使用这个函数进行更多的合并。注意<code class="fe lq lr ls lt b">merge</code>假设两个图的内部命名没有“冲突”;如果不是这样，并且你想更详细地控制这种行为，我推荐使用<code class="fe lq lr ls lt b">concat</code>；merge仅仅是围绕<code class="fe lq lr ls lt b">concat</code>的一个用户友好的包装器。</p><h2 id="1cd1" class="mz md jf bd me na nb dn mi nc nd dp mm ld ne nf mo lh ng nh mq ll ni nj ms nk bi translated"><code class="fe lq lr ls lt b">Split &amp; Join</code></h2><p id="bbfa" class="pw-post-body-paragraph ku kv jf kw b kx mu kg kz la mv kj lc ld mw lf lg lh mx lj lk ll my ln lo lp ij bi translated">和<code class="fe lq lr ls lt b">merge</code>一样，<code class="fe lq lr ls lt b">split</code>和<code class="fe lq lr ls lt b">join</code>也是围绕<code class="fe lq lr ls lt b">concat</code>的更高层次的包装器(我们将在下面详述)。行为相对简单:</p><ul class=""><li id="7cc8" class="oq or jf kw b kx ky la lb ld os lh ot ll ou lp ov ow ox oy bi translated"><code class="fe lq lr ls lt b">split</code>取一个有多个输出的“父”，将一个子图粘贴到这些输出的子集(通过匹配子图的输入)，将另一个子图粘贴到父输出的另一个子集。因此，实际上，<code class="fe lq lr ls lt b">split</code>创建了一个分支，父图在这个分支中馈入两个子图。</li><li id="e71e" class="oq or jf kw b kx oz la pa ld pb lh pc ll pd lp ov ow ox oy bi translated"><code class="fe lq lr ls lt b">join</code>在很多方面与分裂相反:它需要两个“父母”，并且只有一个孩子。父母的输出与孩子的输入相匹配。因此，<code class="fe lq lr ls lt b">join</code>有效地连接到更大的树中子图的分支。</li></ul><h2 id="d258" class="mz md jf bd me na nb dn mi nc nd dp mm ld ne nf mo lh ng nh mq ll ni nj ms nk bi translated">串联</h2><p id="5257" class="pw-post-body-paragraph ku kv jf kw b kx mu kg kz la mv kj lc ld mw lf lg lh mx lj lk ll my ln lo lp ij bi translated">上述<code class="fe lq lr ls lt b">merge</code>、<code class="fe lq lr ls lt b">split</code>和<code class="fe lq lr ls lt b">join</code>功能的工作台是更加通用的<code class="fe lq lr ls lt b">concat</code>功能。理解其功能的最简单方法也许是看一看签名和文档:</p><pre class="nm nn no np gt of lt og oh aw oi bi"><span id="84bb" class="mz md jf lt b gy oj ok l ol om">def concat(<br/>  sg1: xpb2.GraphProto,        <br/>  sg2: xpb2.GraphProto,        <br/>  complete: bool = False,        <br/>  rename_nodes: bool = True,        <br/>  io_match: [] = None,        <br/>  rename_io: bool = False,        <br/>  edge_match: [] = None,        <br/>  rename_edges: bool = False,        <br/>  _verbose: bool = False,       <br/>  **kwargs):    </span><span id="3abd" class="mz md jf lt b gy op ok l ol om">"""  concat concatenates two graphs.    </span><span id="1f51" class="mz md jf lt b gy op ok l ol om">Concat is the flexible (but also rather complex) workhorse for the merge, join, and split functions and can be used to pretty flexibly paste together two (sub)graphs. Contrary to merge, join, and split, concat does not by default assume the resulting onnx graph to be complete (i.e., to contain inputs and outputs and to pass check()), and it can thus be used as an intermediate function when constructing larger graphs.    </span><span id="a20f" class="mz md jf lt b gy op ok l ol om">Concat is flexible and versatile, but it takes time to master. See example_merge.py in the examples folder for a number of examples.    Args:        <br/>  sg1: Subgraph 1, the parent.        <br/>  sg2: Subgraph 2, the child.        <br/>  complete: (Optional) Boolean indicating whether the resulting     <br/>             graph should be checked using so.check(). <br/>             Default False.         <br/>  rename_nodes: (Optional) Boolean indicating whether the names of <br/>             the nodes in the graph should be made unique. <br/>             Default True.          <br/>  io_match: (Optional) Dict containing pairs of outputs of sg1 that <br/>             should be matched to inputs of sg2. <br/>             Default [].        <br/>  rename_io: (Optional) Boolean indicating whether the inputs and <br/>             outputs of the graph should be renamed. <br/>             Default False.        <br/>  edge_match: (Optional) Dict containing pairs edge names of sg1 <br/>             (i.e., node outputs) that should be matched to edges of <br/>             sg2 (i.e., node inputs). <br/>             Default [].        <br/>  rename_edges: (Optional) Boolean indicating whether the edges    <br/>             should be renamed. <br/>             Default False        <br/>  _verbose: (Optional) Boolean indicating whether verbose output <br/>             should be printed (default False)    </span><span id="018a" class="mz md jf lt b gy op ok l ol om">Returns: The concatenated graph g, or False if something goes wrong along the way.    <br/>"""</span><span id="493f" class="mz md jf lt b gy op ok l ol om">## The implementation...</span></pre><p id="2771" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">从签名中可以清楚地看出，更高级别的包装器<code class="fe lq lr ls lt b">merge</code>简单地调用<code class="fe lq lr ls lt b">concat</code>一次，几乎是用它的默认参数。函数<code class="fe lq lr ls lt b">split</code>和<code class="fe lq lr ls lt b">join</code>分别调用<code class="fe lq lr ls lt b">concat</code>两次，以获得它们想要的结果。请注意，参数<code class="fe lq lr ls lt b">rename_edges</code>允许用户控制是否应该重命名子图中的所有边(从而避免可能不需要的隐式边创建)，而<code class="fe lq lr ls lt b">complete</code>允许用户使用merge来操作部分图(即尚未定义所有边的图)。</p><h1 id="d08f" class="mc md jf bd me mf mg mh mi mj mk ml mm kl mn km mo ko mp kp mq kr mr ks ms mt bi translated">包裹</h1><p id="bda0" class="pw-post-body-paragraph ku kv jf kw b kx mu kg kz la mv kj lc ld mw lf lg lh mx lj lk ll my ln lo lp ij bi translated">我希望上面的内容能够揭示ONNX提供的巨大可能性，以及一些手动操作ONNX图形的工具。我们认为ONNX非常适合存储(子)图，这些图以独立于平台的方式存储与数据科学管道相关的有用信息。像<code class="fe lq lr ls lt b">sclblonnx</code>包这样的工具使用户能够使用子图作为构建块来创建完整的管道。</p><blockquote class="lv lw lx"><p id="73ae" class="ku kv ly kw b kx ky kg kz la lb kj lc lz le lf lg ma li lj lk mb lm ln lo lp ij bi translated">在这篇文章中，我有意忽略了关于匹配节点的输入和输出的维度和类型的问题；我希望通过关注所涉及的图表的粗略结构，操作更容易理解；当创建实际的功能图时，显然所涉及的各种张量的类型和维数是很重要的。</p></blockquote><h1 id="1af9" class="mc md jf bd me mf mg mh mi mj mk ml mm kl mn km mo ko mp kp mq kr mr ks ms mt bi translated">放弃</h1><p id="1fcf" class="pw-post-body-paragraph ku kv jf kw b kx mu kg kz la mv kj lc ld mw lf lg lh mx lj lk ll my ln lo lp ij bi translated"><em class="ly">值得注意的是我自己的参与:我是</em> <a class="ae lu" href="https://www.jads.nl/" rel="noopener ugc nofollow" target="_blank"> <em class="ly">杰罗尼姆斯数据科学院</em> </a> <em class="ly">的数据科学教授，也是</em><a class="ae lu" href="https://www.scailable.net/" rel="noopener ugc nofollow" target="_blank"><em class="ly">Scailable</em></a><em class="ly">的联合创始人之一。因此，毫无疑问，我对Scailable有既得利益；我有兴趣让它成长，这样我们就可以最终将人工智能投入生产并兑现它的承诺。这里表达的观点是我自己的。注意</em></p></div></div>    
</body>
</html>