<html>
<head>
<title>Optimizing complex simulations? Use Scipy interpolation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">优化复杂模拟？使用科学插值</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/optimizing-complex-simulations-use-scipy-interpolation-dc782c27dcd2?source=collection_archive---------23-----------------------#2021-10-27">https://towardsdatascience.com/optimizing-complex-simulations-use-scipy-interpolation-dc782c27dcd2?source=collection_archive---------23-----------------------#2021-10-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f80b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在许多情况下，我们可以使用简单插值(Scipy)进行快速优化，而不是使用复杂的优化算法</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f6c850bbe9067096bce64f0a82c2287d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AAUJn8MnbhpitjWQ-TMiHA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="bd ky">图片来源:</strong>作者创作</p></figure><h1 id="da92" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">背景</h1><p id="e11e" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在复杂的科学或商业研究中插入实验或模拟数据是一种相当普遍的做法。在我的上一篇文章中，我展示了如何使用简单的Scipy代码来实现一维或多维。</p><div class="mn mo gp gr mp mq"><a href="https://medium.com/productive-data-science/how-to-interpolate-data-with-scipy-d314143285bc" rel="noopener follow" target="_blank"><div class="mr ab fo"><div class="ms ab mt cl cj mu"><h2 class="bd iu gy z fp mv fr fs mw fu fw is bi translated">如何用Scipy内插数据</h2><div class="mx l"><h3 class="bd b gy z fp mv fr fs mw fu fw dk translated">Python Scipy包简化了一维或多维数据插值。</h3></div><div class="my l"><p class="bd b dl z fp mv fr fs mw fu fw dk translated">medium.com</p></div></div><div class="mz l"><div class="na l nb nc nd mz ne ks mq"/></div></div></a></div><p id="54c9" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">这种方法的一个关键好处是，我们从Scipy例程中获得了<strong class="lt iu">精确函数，并可以将其用于多种用途——其中之一是<strong class="lt iu">快速优化</strong>。</strong></p><p id="0d36" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">这对于单个实验成本高昂的情况<strong class="lt iu">尤其有用</strong>。在大多数情况下，成本方面远远超出了单纯的计算。想到与<strong class="lt iu">昂贵的产品设计迭代，或者医疗保健(药物测试)</strong>相关的优化问题。作为设计者或研究人员，你不会有无限的预算来进行数百个实验，因为每个实验可能花费数千美元。</p><p id="39a6" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">相反，你可以，</p><ul class=""><li id="1f7c" class="nk nl it lt b lu nf lx ng ma nm me nn mi no mm np nq nr ns bi translated">运行一组有限的间隔合理的实验(如果你有关于实验设计的知识，那会有很大的帮助)</li><li id="cca6" class="nk nl it lt b lu nt lx nu ma nv me nw mi nx mm np nq nr ns bi translated">使用线性、二次或三次样条创建插值函数</li><li id="4487" class="nk nl it lt b lu nt lx nu ma nv me nw mi nx mm np nq nr ns bi translated">运行插值函数以评估密集网格(即数千个点)上的实验/模拟结果</li><li id="d02c" class="nk nl it lt b lu nt lx nu ma nv me nw mi nx mm np nq nr ns bi translated">只需选择最大值或最小值以及相应的指数，即可根据您的要求了解哪个输入设置导致了最小值/最大值</li></ul><p id="398b" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated"><strong class="lt iu">没有花哨的优化算法。没有昂贵模拟的成本</strong>。只是一些实验设计知识和插值程序。</p><p id="4c9b" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">这种方法不能保证你在所有情况下都有最好的结果。但它在大多数实际情况下都有效。我们来看看为什么。</p><blockquote class="ny"><p id="6a70" class="nz oa it bd ob oc od oe of og oh mm dk translated">作为设计者或研究者，你不会有无限的预算来进行数百个实验，因为每个实验可能花费数千美元</p></blockquote><h1 id="7768" class="kz la it bd lb lc ld le lf lg lh li lj jz oi ka ll kc oj kd ln kf ok kg lp lq bi translated">为什么它能工作(在大多数情况下)？</h1><p id="d8c1" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">插值主要基于<em class="ol">平滑度</em>或<em class="ol">连续性</em>的假设。函数<strong class="lt iu">需要平滑，不要过于跳跃</strong>，以便以合理的精度进行插值。下图说明了这个想法，假设我们无法收集大量的数据点(实验)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi om"><img src="../Images/e53ad8bb4b997cc5f14345f9ff438d12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xZs714-coOcR1SbWKDlk8w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="bd ky">图片来源:</strong>作者创作</p></figure><p id="7286" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">而且，事实证明<strong class="lt iu">大多数现实生活中的连续数据问题也没有那么跳跃</strong>，也就是说，它们足够平滑，可以通过插值技术来处理。因此，在许多情况下，我们可以使用物理模拟和插值的<strong class="lt iu">组合来进行快速优化。</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi on"><img src="../Images/5affbd0532c4841bf065d1a81427eeff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jK3q0ATc6fCUUGtZkj9yBg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="bd ky">图片来源:</strong>作者创作</p></figure><p id="22b5" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">所以，在这里，</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oo"><img src="../Images/1f69cde54bd49d840401edfe7b65105d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H5ge7tXEKu3S1kYtp78e0g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="bd ky">图片来源:</strong>作者创作</p></figure><blockquote class="ny"><p id="034b" class="nz oa it bd ob oc op oq or os ot mm dk translated">这种方法不能保证你在所有情况下都有最好的结果。但它在大多数实际情况下都有效。</p></blockquote><h1 id="75af" class="kz la it bd lb lc ld le lf lg lh li lj jz oi ka ll kc oj kd ln kf ok kg lp lq bi translated">简单的演示</h1><p id="812c" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">样板代码在我的Github repo中。让我在本文中只展示一些相关的代码片段。</p><h2 id="44ac" class="ou la it bd lb ov ow dn lf ox oy dp lj ma oz pa ll me pb pc ln mi pd pe lp pf bi translated">模拟和实验功能</h2><p id="906b" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">假设我们有一个复杂的模拟任务，需要一些时间(这里是0.1秒)来完成。实际输出只是一个简单的非线性函数。这是代码，</p><pre class="kj kk kl km gt pg ph pi pj aw pk bi"><span id="cbe0" class="ou la it ph b gy pl pm l pn po">def complex_simulation(x):<br/>    """<br/>    A nonlinear simulation function with some time delay<br/>    """<br/>    time.sleep(0.1)<br/>    y = np.cos(-x**2/9.0)+np.sin(x/6)<br/>    return y</span></pre><p id="9ce5" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">我们还定义了一个函数<code class="fe pp pq pr ph b">run_experiment</code>来运行这个模拟固定的次数。它返回实验域和来自给定边界(低/高端点)的结果。</p><pre class="kj kk kl km gt pg ph pi pj aw pk bi"><span id="f9d0" class="ou la it ph b gy pl pm l pn po">def run_experiments(experiment_bounds,n=10):<br/>    results = []<br/>    low,high = experiment_bounds<br/>    domain = np.linspace(low, high, num=n, endpoint=True)<br/>    for i in domain:<br/>        y = complex_simulation(i)<br/>        results.append(y)<br/>    return (domain,results)</span></pre><p id="4329" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">比方说，我们运行它11次，得到这个数据，</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ps"><img src="../Images/2ed620b0b50075c6de9c87701a471e28.png" data-original-src="https://miro.medium.com/v2/resize:fit:1146/format:webp/1*1pPF97LaqKtubLVrk3WOKA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="bd ky">图片来源:</strong>作者创作</p></figure><h2 id="ee89" class="ou la it bd lb ov ow dn lf ox oy dp lj ma oz pa ll me pb pc ln mi pd pe lp pf bi translated">插值和优化</h2><p id="3f4a" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">一个简单的三次插值(使用Scipy)，将会给我们这个很好的拟合结果，也是一个新的函数，可以生成任何我们想要的中间结果。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pt"><img src="../Images/0840bc2c141647376d1f4614271f5276.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pBgC4lqZPMfh4UGvup3o9A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="bd ky">图片来源:</strong>作者创作</p></figure><p id="4796" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">现在，我们可以用详尽的模拟结果编写一个简单的搜索函数来找到最大值出现的点。</p><pre class="kj kk kl km gt pg ph pi pj aw pk bi"><span id="0ad2" class="ou la it ph b gy pl pm l pn po">def <strong class="ph iu">optimum_simulation</strong>(experiment_bounds,n=11):<br/>    """<br/>    Using exhaustive simulations<br/>    """<br/>    domain,results=np.array(run_experiments(experiment_bounds,n=n))<br/>    imax = np.argmax(results)<br/>    return (domain[imax])</span></pre><p id="4eb6" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">基本上，它运行实验一定次数(使用之前定义的<code class="fe pp pq pr ph b">run_experiment</code>函数)并搜索结果数组的<code class="fe pp pq pr ph b">argmax</code>。这在算法上很简单，但由于模拟的性质，速度并不快。当我们为<code class="fe pp pq pr ph b">n = 11</code>运行它时，需要大约1.1秒，因为每个模拟有0.1秒的时间延迟。它得出最佳x的结果为，<strong class="lt iu"> <em class="ol"> x = </em> 8.0 </strong>。</p><p id="0e99" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">或者，我们可以定义另一个使用插值函数而不是实际模拟函数的函数。当然，它利用了从有限规模的单次实验中获得的<code class="fe pp pq pr ph b">init_results</code>。</p><pre class="kj kk kl km gt pg ph pi pj aw pk bi"><span id="6d9b" class="ou la it ph b gy pl pm l pn po">def <strong class="ph iu">optimum_interpolation</strong>(domain,init_results,n=101):<br/>    """<br/>    Using interpolation<br/>    """<br/>    low,high = domain.min(),domain.max()<br/>    ip_interpolated = np.linspace(low, high, num=n, endpoint=True)<br/>    <strong class="ph iu">f3 = interp1d(domain, init_results, kind='cubic')</strong><br/>    results_interpolated=np.array(f3(ip_interpolated))<br/>    imax = np.argmax(results_interpolated)<br/>    return (ip_interpolated[imax])</span></pre><p id="4cc5" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">当我们用n = 101运行它时，它在大约900微秒内完成，并产生结果<strong class="lt iu"> <em class="ol"> x = </em> 7.54 </strong>。</p><p id="ce39" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">如果你回头看看实际的函数，你会意识到<strong class="lt iu"> <em class="ol"> x = </em> 7.54比<em class="ol"> x = </em> 8.0 </strong>更好的逼近最优值。</p><p id="ef00" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">这意味着插值方法不仅产生了更快而且更准确的结果。这可能并不适用于所有情况，但是<strong class="lt iu">的速度优势通常会抵消精度</strong>的微小牺牲。</p><h2 id="7f95" class="ou la it bd lb ov ow dn lf ox oy dp lj ma oz pa ll me pb pc ln mi pd pe lp pf bi translated">实验事项设计</h2><p id="8c1f" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">然而，我们必须注意实验的设计。通常，均匀采样的实验空间是最合适的起点。例如，即使对于我们的简单演示，如果我们用均匀随机的x值(不是线性间隔的)做实验，我们可能会得到一个次优的插值函数。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pu"><img src="../Images/1a9f19055da36a6288f2277ef62d3e20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s07hql3XzBZvPTQkeJ1gQA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="bd ky">图片来源:</strong>作者创作</p></figure><p id="b7e5" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">有关实验设计以及如何使用<a class="ae pv" href="https://doepy.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank"> <strong class="lt iu"> Python包生成健壮的实验计划</strong> </a>的更多信息，请参见我的文章。</p><div class="mn mo gp gr mp mq"><a rel="noopener follow" target="_blank" href="/design-your-engineering-experiment-plan-with-a-simple-python-command-35a6ba52fa35"><div class="mr ab fo"><div class="ms ab mt cl cj mu"><h2 class="bd iu gy z fp mv fr fs mw fu fw is bi translated">使用简单的Python命令设计您的工程实验计划</h2><div class="mx l"><h3 class="bd b gy z fp mv fr fs mw fu fw dk translated">使用简单的Python命令设计您的工程实验计划。</h3></div><div class="my l"><p class="bd b dl z fp mv fr fs mw fu fw dk translated">towardsdatascience.com</p></div></div><div class="mz l"><div class="pw l nb nc nd mz ne ks mq"/></div></div></a></div><h1 id="57c7" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">在高维空间中非常有用</h1><p id="473c" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">Scipy插值例程在二维情况下的工作就像在一维情况下一样简单。由于维数灾难，使用穷举模拟的优化在多个维度上更加复杂和耗时。在这些情况下，插值方法可以派上用场。</p><p id="a42f" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">这是一个示例结果，其中我们使用Scipy插值从稀疏数据中创建了一个平滑的插值2D表面。基本上，从400个实际数据点，我们创建了一个4900数据矩阵，它可以以更高的精度和速度为我们指出最佳点。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi px"><img src="../Images/eb4f429299114c2948006cadd7ac0134.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YCCmlVwmz0nstUaAeLDDGg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="bd ky">图片来源</strong>:作者创作(来自<a class="ae pv" href="https://medium.com/productive-data-science/how-to-interpolate-data-with-scipy-d314143285bc" rel="noopener">同一作者的另一篇文章</a></p></figure><h1 id="00c7" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">摘要</h1><p id="e224" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在本文中，我们展示了如何使用简单的插值例程和精心选择的、间隔良好的实验点，我们可以创建能够产生快速优化的插值函数。这种方法特别适用于复杂、耗时的科学或技术模拟，这些模拟的响应或多或少是平滑的。</p><p id="f451" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">请注意，虽然我们使用Python中的模拟函数展示了演示，但是<strong class="lt iu">实验数据可以来自任何来源</strong>(例如，数据库、MATLAB连接器或流式API)，Python中唯一的部分是基于Scipy的插值和后续的搜索例程。</p><p id="a0b7" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">应用领域，如半导体设计、化学工艺优化、生产计划等。，可以从这种方法中获益。</p></div><div class="ab cl py pz hx qa" role="separator"><span class="qb bw bk qc qd qe"/><span class="qb bw bk qc qd qe"/><span class="qb bw bk qc qd"/></div><div class="im in io ip iq"><p id="d5c0" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">喜欢这篇文章吗？成为 <a class="ae pv" href="https://medium.com/@tirthajyoti/membership" rel="noopener"> <strong class="lt iu"> <em class="ol">中等会员</em> </strong> </a> <em class="ol">继续</em> <strong class="lt iu"> <em class="ol">无限制学习</em> </strong> <em class="ol">。如果您使用下面的链接，</em> <strong class="lt iu"> <em class="ol">，我将收取您的一部分会员费，而不会对您产生额外费用</em> </strong> <em class="ol">。</em></p><p id="ae51" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated"><a class="ae pv" href="https://medium.com/@tirthajyoti/membership" rel="noopener">https://medium.com/@tirthajyoti/membership</a></p></div></div>    
</body>
</html>