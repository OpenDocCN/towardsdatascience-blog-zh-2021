<html>
<head>
<title>Simulating Traffic Flow in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Python模拟交通流</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/simulating-traffic-flow-in-python-ee1eab4dd20f?source=collection_archive---------0-----------------------#2021-09-05">https://towardsdatascience.com/simulating-traffic-flow-in-python-ee1eab4dd20f?source=collection_archive---------0-----------------------#2021-09-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="016e" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/hands-on-tutorials" rel="noopener" target="_blank">实践教程</a></h2><div class=""/><div class=""><h2 id="99d5" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">实现微观交通模型</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/952de414583cd864ada09ecea3f198b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ecS00hEIvnpVKhJI"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">约翰·马特丘克在<a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="df4f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">虽然交通并不总是顺畅，但汽车无缝穿越十字路口，在交通信号灯前转弯和停车，看起来会非常壮观。这种沉思让我想到了交通流量对人类文明的重要性。</p><p id="e57b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在这之后，我内心的书呆子忍不住想了一个模拟交通流量的方法。我花了几周时间做一个关于交通流量的本科项目。我深入研究了不同的模拟技术，最终选择了一种。</p><p id="bd48" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在这篇文章中，我将解释为什么流量模拟是重要的，比较不同的方法可能建模流量，并提出我的模拟(连同源代码)。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="a0df" class="ml mm it bd mn mo mp mq mr ms mt mu mv ki mw kj mx kl my km mz ko na kp nb nc bi translated">为什么要模拟交通流？</h1><p id="7e84" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">模拟交通的主要原因是在没有真实世界的情况下生成数据。您可以使用软件上运行的模型来预测交通流量，而不是测试如何在现实世界中管理交通系统或使用传感器收集数据的新想法。这有助于加速交通系统的优化和数据收集。模拟是真实世界测试的一种更便宜、更快速的替代方式。</p><p id="c48a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">训练机器学习模型需要庞大的数据集，收集和处理这些数据集可能很困难，成本也很高。通过模拟交通按程序生成数据可以很容易地适应所需数据的确切类型。</p><h1 id="293e" class="ml mm it bd mn mo ni mq mr ms nj mu mv ki nk kj mx kl nl km mz ko nm kp nb nc bi translated">建模</h1><p id="ada9" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">为了分析和优化交通系统，我们首先要对交通系统进行数学建模。这种模型应根据输入参数(路网几何形状、每分钟车辆数、车速等)真实地表现交通流量。</p><div class="ks kt ku kv gt ab cb"><figure class="nn kw no np nq nr ns paragraph-image"><img src="../Images/04d330fa9d216905aff2171eaccf0acc.png" data-original-src="https://miro.medium.com/v2/resize:fit:840/format:webp/1*UzQJRHYp6aRu0nNlmpeIUA.png"/></figure><figure class="nn kw nt np nq nr ns paragraph-image"><img src="../Images/949a80aef60e03a59da665ba7bf13734.png" data-original-src="https://miro.medium.com/v2/resize:fit:762/format:webp/1*AoIpeT8dsL8tv6K0gHug-Q.png"/><p class="ld le gj gh gi lf lg bd b be z dk nu di nv nw translated">微观模型(左)宏观模型(右)。图片作者。</p></figure></div><p id="502e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">交通系统模型通常分为三类，这取决于它们运行的级别:</p><ul class=""><li id="ef2c" class="nx ny it lk b ll lm lo lp lr nz lv oa lz ob md oc od oe of bi translated"><strong class="lk jd">微观模型:</strong>分别代表每一辆车，试图复制驾驶员的行为。</li><li id="7fc3" class="nx ny it lk b ll og lo oh lr oi lv oj lz ok md oc od oe of bi translated"><strong class="lk jd">宏观模型:</strong>用交通密度(每公里车辆数)和交通流量(每分钟车辆数)来描述车辆整体的运动。它们通常类似于流体流动。</li><li id="0618" class="nx ny it lk b ll og lo oh lr oi lv oj lz ok md oc od oe of bi translated"><strong class="lk jd">介观模型:</strong>是结合了微观和宏观模型特点的混合模型；他们将流量建模为车辆的“数据包”。</li></ul><p id="9b95" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在本文中，我将使用一个微观模型。</p><h2 id="1f3a" class="ol mm it bd mn om on dn mr oo op dp mv lr oq or mx lv os ot mz lz ou ov nb iz bi translated">微观模型</h2><p id="de44" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">微观驾驶员模型描述了单个驾驶员/车辆的行为。因此，它必须是一个多智能体系统，也就是说，每辆车都使用来自其环境的输入来独立运行。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ow"><img src="../Images/fc666fb9f3b5d0f50fa16c6d725c273d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WQcQB5WzZucg-JJeBGvoIw.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">图片作者。</p></figure><p id="cc61" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在微观模型中，每辆车都有编号<em class="ox"> i </em>。第<em class="ox"> i </em>辆跟随第(<em class="ox"> i-1 </em>)辆。对于第<em class="ox"> i </em>辆车，我们将用<strong class="lk jd"> xᵢ </strong>表示其在道路上的位置，<strong class="lk jd"> vᵢ </strong>表示其速度，<strong class="lk jd"> lᵢ </strong>表示其长度。每辆车都是如此。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi oy"><img src="../Images/c4deb4d1464e9e834a962dfece30559a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1378/format:webp/1*g0esLjCMMqm_GbKjKh5xeA.png"/></div></figure><p id="1d61" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们将用<strong class="lk jd"> sᵢ </strong>表示保险杠到保险杠的距离，用<strong class="lk jd">δvᵢ</strong>表示第<em class="ox"> i </em>辆车与其前车(车号<em class="ox"> i-1 </em>)之间的速度差。</p><h2 id="2975" class="ol mm it bd mn om on dn mr oo op dp mv lr oq or mx lv os ot mz lz ou ov nb iz bi translated">智能驱动模型(IDM)</h2><p id="1649" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">2000年，Treiber、Hennecke和Helbing开发了一种被称为<a class="ae lh" href="https://journals.aps.org/pre/abstract/10.1103/PhysRevE.62.1805" rel="noopener ugc nofollow" target="_blank">智能驾驶模型</a>的模型。它将第<em class="ox"> i </em>辆车的加速度描述为其变量和其前方车辆变量的函数。动力学方程定义为:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oz"><img src="../Images/6138fa745d7144b2513e2f5bb64ca6cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZSXp8pdkVAwLjuLXuyMA2w.png"/></div></div></figure><p id="7422" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在我解释这个模型背后的直觉之前，我应该解释一些符号代表什么。</p><p id="0287" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们已经讲过<strong class="lk jd"> sᵢ </strong>、<strong class="lk jd"> vᵢ、</strong>和<strong class="lk jd">t31】δ<strong class="lk jd">vᵢ</strong>。其他参数是:</strong></p><ul class=""><li id="9b5d" class="nx ny it lk b ll lm lo lp lr nz lv oa lz ob md oc od oe of bi translated"><strong class="lk jd"> s₀ᵢ </strong>:车辆<em class="ox"> i </em>和<em class="ox"> i-1之间的最小期望距离。</em></li><li id="3985" class="nx ny it lk b ll og lo oh lr oi lv oj lz ok md oc od oe of bi translated"><strong class="lk jd"> v₀ᵢ : </strong>是车辆的最大期望速度<em class="ox"> i. </em></li><li id="cf18" class="nx ny it lk b ll og lo oh lr oi lv oj lz ok md oc od oe of bi translated"><strong class="lk jd"> δ : </strong>是加速指数，它控制加速的“平滑度”。</li><li id="6bdc" class="nx ny it lk b ll og lo oh lr oi lv oj lz ok md oc od oe of bi translated"><strong class="lk jd"> Tᵢ : </strong>是第<em class="ox">辆车驾驶员的反应时间。</em></li><li id="14ab" class="nx ny it lk b ll og lo oh lr oi lv oj lz ok md oc od oe of bi translated"><strong class="lk jd"> aᵢ : </strong>为车辆的最大加速度<em class="ox">一、</em></li><li id="bc1f" class="nx ny it lk b ll og lo oh lr oi lv oj lz ok md oc od oe of bi translated"><strong class="lk jd"> bᵢ : </strong>是<strong class="lk jd"> </strong>车辆<em class="ox"> i. </em>的舒适减速度</li><li id="bbb2" class="nx ny it lk b ll og lo oh lr oi lv oj lz ok md oc od oe of bi translated"><strong class="lk jd"> s* </strong>:车辆<em class="ox"> i </em>和<em class="ox"> i-1之间的实际所需距离。</em></li></ul><p id="9cd2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">首先，我们将查看<strong class="lk jd"> s* </strong>，它是一个距离，由三项组成。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ow"><img src="../Images/4bbc31cb2ae8a553d14dd31c8fb3f279.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ipykEG4BKv-mMvM5K5gpcw.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">图片作者。</p></figure><ul class=""><li id="3885" class="nx ny it lk b ll lm lo lp lr nz lv oa lz ob md oc od oe of bi translated"><strong class="lk jd"> s₀ᵢ </strong> <strong class="lk jd"> : </strong>前面说过，是最小期望距离。</li><li id="9c49" class="nx ny it lk b ll og lo oh lr oi lv oj lz ok md oc od oe of bi translated"><strong class="lk jd"> vᵢTᵢ : </strong>是反应时间安全距离。它是驾驶员做出反应(刹车)之前车辆行驶的距离。<br/>既然速度是距离随时间的变化，那么距离就是速度乘以时间。</li></ul><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pa"><img src="../Images/ce98d94b264bd403e58be16e5b564a5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:946/format:webp/1*AqhJ_f0tu_zGFjTcFxTJOg.png"/></div></figure><ul class=""><li id="fdd4" class="nx ny it lk b ll lm lo lp lr nz lv oa lz ob md oc od oe of bi translated">(vᵢδvᵢ)/√(2aᵢbᵢ):这是一个有点复杂的术语。这是基于速度差的安全距离。它代表车辆减速(不撞上前方车辆)，不过度制动(减速度应小于<strong class="lk jd"> bᵢ </strong>)所需的距离。</li></ul><h2 id="ddc6" class="ol mm it bd mn om on dn mr oo op dp mv lr oq or mx lv os ot mz lz ou ov nb iz bi translated">智能驱动模型如何工作</h2><p id="fa85" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">假设车辆沿直线行驶，并遵循以下等式:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pb"><img src="../Images/4c6c13f6d256b6b93b3ba3e2f4724fd4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1314/format:webp/1*NxUkWqWNrUK1804JGwVNvg.png"/></div></figure><p id="732b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">为了更好地理解这个方程，我们可以把它分成两部分。我们有一个<strong class="lk jd">自由道路加速度</strong>和一个<strong class="lk jd">交互加速度</strong>。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pc"><img src="../Images/26f3330d9e9fae4b9e500d76e08ec67c.png" data-original-src="https://miro.medium.com/v2/resize:fit:782/format:webp/1*907YAA2c1vBFeoJKMqhY-g.png"/></div></figure><p id="2814" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">自由道路加速度</strong>是自由道路上的加速度，也就是前方没有车辆的空旷道路。如果我们将加速度绘制成速度<strong class="lk jd"> vᵢ </strong>的函数，我们得到<strong class="lk jd"> : </strong></p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pd"><img src="../Images/5bdb029011a6b27f2143f17226bdaf27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VZvV5yx6133B2QT1saZdTw.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">加速度是速度的函数。图片作者。</p></figure><p id="6e8b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们注意到，当车辆静止时(<strong class="lk jd"> vᵢ=0 </strong>)，加速度最大。当车速接近最大速度<strong class="lk jd"> v₀ᵢ </strong>时，加速度变为0。这表明<strong class="lk jd">自由道路加速</strong>将使车辆加速至最大速度。</p><p id="50bb" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果我们为不同的<strong class="lk jd"> δ、</strong>值绘制v-a图，我们会注意到，它控制着驾驶员在接近最大速度时减速的速度。这又控制加速/减速的平滑度</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pd"><img src="../Images/cbfade72baea86ac5642309a2e72ed78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xcKyan3HzPu7ZHdjTmMePw.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">加速度是速度的函数。图片作者。</p></figure></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pe"><img src="../Images/74a593bbebc310d4e15f218b31ca47b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WIpl1eCkUhZdMTe3qumvIw.png"/></div></div></figure><p id="580d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">互动加速度</strong>与前方车辆互动相关。为了更好地理解它是如何工作的，让我们考虑以下情况:</p><ul class=""><li id="594b" class="nx ny it lk b ll lm lo lp lr nz lv oa lz ob md oc od oe of bi translated"><strong class="lk jd">在自由路面上(sᵢ &gt; &gt; s*): <br/> </strong>当前方车辆很远，也就是距离<strong class="lk jd"> sᵢ </strong>是主导期望距离<strong class="lk jd"> s* </strong>时，交互加速度几乎为0。<br/>这意味着车辆将受到自由道路加速度的控制。</li></ul><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pf"><img src="../Images/f88993592e9d9347f53146cbb4a2abb4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1328/format:webp/1*G1vrXW32ehgxs2OvHZjmsw.png"/></div></figure><ul class=""><li id="f5a0" class="nx ny it lk b ll lm lo lp lr nz lv oa lz ob md oc od oe of bi translated"><strong class="lk jd">在高接近速率(δvᵢ):<br/></strong>)下，当速度差很大时，交互加速度试图通过使用分子中的<strong class="lk jd">(vᵢδvᵢ)</strong>项制动或减速来补偿，但太难了。这是通过分母<strong class="lk jd"> 4bᵢsᵢ </strong>实现的。(老实说，我不知道它如何将减速精确地限制在<strong class="lk jd"> bᵢ </strong>。</li></ul><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pg"><img src="../Images/0b85f9ece2acf58440612c5ca8daa56e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1372/format:webp/1*5cESvO7J4XjF4UWuVyfVSg.png"/></div></figure><ul class=""><li id="1cfd" class="nx ny it lk b ll lm lo lp lr nz lv oa lz ob md oc od oe of bi translated"><strong class="lk jd">在小距离差时(sᵢ &lt; &lt; 1和δvᵢ≈0):<br/></strong>)加速度变成简单的排斥力。</li></ul><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ph"><img src="../Images/5b33ca959b8a5486ecead88fbcccd984.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0nQNaJAYlBV3t6z47RffXQ.png"/></div></div></figure></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h2 id="9c0d" class="ol mm it bd mn om on dn mr oo op dp mv lr oq or mx lv os ot mz lz ou ov nb iz bi translated">交通道路网络模型</h2><div class="ks kt ku kv gt ab cb"><figure class="nn kw pi np nq nr ns paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><img src="../Images/c0a62054ae22df7399aa0f8cdcc1f4a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1142/format:webp/1*J9d4TnkQpBS-MNcQuVYTRg.png"/></div></figure><figure class="nn kw pj np nq nr ns paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><img src="../Images/d726acddf537004ca33087c147715d4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:860/format:webp/1*xdAf4ZApBkTqi-zyTKXgBg.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk pk di pl nw translated">有向图的例子。图表(左)集合(右)</p></figure></div><p id="b9a9" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们需要建立一个道路网的模型。为此，我们将使用一个<strong class="lk jd">有向图G=(V，E) </strong>。其中:</p><ul class=""><li id="ffd3" class="nx ny it lk b ll lm lo lp lr nz lv oa lz ob md oc od oe of bi translated"><strong class="lk jd"> V </strong>是顶点(或节点)的集合。</li><li id="bef0" class="nx ny it lk b ll og lo oh lr oi lv oj lz ok md oc od oe of bi translated">E是代表道路的边的集合。</li></ul><p id="d14f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">每辆车都有一条由多条道路(边)组成的路径。我们将对同一条道路(同一条边)上的车辆应用智能驾驶员模型。当一辆车到达路的尽头时，我们把它从那条路上移走，并把它附加到下一条路上。</p><p id="7288" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在模拟中，我们不会保留一组节点(数组),相反，每条道路都将由其起始和结束节点的值明确定义。</p><h2 id="b6de" class="ol mm it bd mn om on dn mr oo op dp mv lr oq or mx lv os ot mz lz ou ov nb iz bi translated">随机车辆生成器</h2><p id="4267" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">为了将车辆添加到我们的模拟中，我们有两个选项:</p><ul class=""><li id="87d0" class="nx ny it lk b ll lm lo lp lr nz lv oa lz ob md oc od oe of bi translated">通过创建一个新的<code class="fe pm pn po pp b">Vehicle</code>类实例并将其添加到车辆列表中，将每辆车手动添加到模拟中。</li><li id="4b5c" class="nx ny it lk b ll og lo oh lr oi lv oj lz ok md oc od oe of bi translated">根据预定义的概率随机添加车辆。</li></ul><p id="fea3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">对于第二个选项，我们必须定义一个随机车辆生成器。</p><p id="4ddd" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">随机车辆生成器由两个约束条件定义:</p><ul class=""><li id="448e" class="nx ny it lk b ll lm lo lp lr nz lv oa lz ob md oc od oe of bi translated"><strong class="lk jd">车辆生成率(τ): </strong>(每分钟车辆数)描述平均每分钟应添加多少车辆到模拟中。</li><li id="e7ed" class="nx ny it lk b ll og lo oh lr oi lv oj lz ok md oc od oe of bi translated"><strong class="lk jd">车辆配置列表(L): </strong>包含车辆配置和概率的元组列表。L = [(p₁，V₁)，(p₂，V₂)，(p₃，V₃)，…]</li></ul><p id="1374" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">随机车辆生成器以概率<strong class="lk jd"> pᵢ </strong>生成车辆<strong class="lk jd"> Vᵢ </strong>。</p><h2 id="1145" class="ol mm it bd mn om on dn mr oo op dp mv lr oq or mx lv os ot mz lz ou ov nb iz bi translated">交通灯</h2><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ow"><img src="../Images/e21a74507404386bf8942a274ec8196c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QI6XdLjVTmtPubabzy_Zxw.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">图片作者。</p></figure><p id="3512" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">交通灯位于顶点，由两个区域表征:</p><ul class=""><li id="674a" class="nx ny it lk b ll lm lo lp lr nz lv oa lz ob md oc od oe of bi translated"><strong class="lk jd">减速区:</strong>以一个<em class="ox">减速距离</em> <strong class="lk jd"> </strong>和一个<em class="ox">减速系数</em>为特征，是一个车辆使用减速系数降低其最大速度的区域。</li></ul><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pq"><img src="../Images/c0de828b087910ed68a04d391fec2d96.png" data-original-src="https://miro.medium.com/v2/resize:fit:856/format:webp/1*hRd_so9KpL4h5c6Vy9p6AQ.png"/></div></figure><ul class=""><li id="7aae" class="nx ny it lk b ll lm lo lp lr nz lv oa lz ob md oc od oe of bi translated"><strong class="lk jd">停车区:</strong>以<em class="ox">停车距离</em>为特征，是车辆停车的区域。这是通过以下动力学方程使用阻尼力实现的:</li></ul><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pr"><img src="../Images/ac62376ee53d85310bdf7affeb9d0946.png" data-original-src="https://miro.medium.com/v2/resize:fit:674/format:webp/1*HJOYfDu5k5DSKhTEALzueg.png"/></div></figure><h1 id="6efe" class="ml mm it bd mn mo ni mq mr ms nj mu mv ki nk kj mx kl nl km mz ko nm kp nb nc bi translated">模拟</h1><p id="239b" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">我们将采用面向对象的方法。每辆车和每条路都将被定义为一个类别。</p><p id="bc92" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们将在许多即将到来的课程中重复使用下面的<code class="fe pm pn po pp b">__init__</code>函数。它通过一个函数<code class="fe pm pn po pp b">set_default_config</code>设置当前类的默认配置。需要一个字典，并将字典中的每个属性设置为当前类实例的属性。这样我们就不用担心更新不同类的<code class="fe pm pn po pp b">__init__</code>功能，也不用担心以后的变化。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ps pt l"/></div></figure></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h2 id="8cc4" class="ol mm it bd mn om on dn mr oo op dp mv lr oq or mx lv os ot mz lz ou ov nb iz bi translated">路</h2><p id="5c88" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">我们将创建一个<code class="fe pm pn po pp b">Road</code>类:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ps pt l"/></div></figure><p id="06bf" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在屏幕上绘制道路时，我们需要道路的<code class="fe pm pn po pp b">length</code>及其角度的余弦和正弦值。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h2 id="aacc" class="ol mm it bd mn om on dn mr oo op dp mv lr oq or mx lv os ot mz lz ou ov nb iz bi translated">模拟</h2><p id="5134" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">还有一个<code class="fe pm pn po pp b">Simulation</code>班。我添加了一些方法来给模拟添加道路。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ps pt l"/></div></figure></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><p id="3fd4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们必须在屏幕上实时显示我们的模拟。为此，我们将使用<code class="fe pm pn po pp b">pygame</code>。我将创建一个期望一个<code class="fe pm pn po pp b">Simulation</code>类作为参数的<code class="fe pm pn po pp b">Window</code>类。</p><p id="f5de" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我定义了多个绘图函数来帮助绘制基本形状。</p><p id="730d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe pm pn po pp b">loop</code>方法创建一个<code class="fe pm pn po pp b">pygame</code>窗口，并在每一帧调用<code class="fe pm pn po pp b">draw</code>方法和<code class="fe pm pn po pp b">loop</code>参数。当我们的模拟需要每帧更新时，这将变得有用。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ps pt l"/></div></figure></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><p id="7d90" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我将名为<code class="fe pm pn po pp b">trafficSimulator</code>的文件夹中的每个文件与一个导入所有类名的<code class="fe pm pn po pp b">__init__.py</code>文件组合在一起。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ps pt l"/></div></figure><p id="7c45" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">每当一个新的类被定义时，它应该被导入到这个文件中</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><p id="2e06" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">将<code class="fe pm pn po pp b">trafficSimulator</code>文件夹放在我们的项目文件夹中，我们就可以使用这个模块了。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ps pt l"/></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pu"><img src="../Images/861b45d4bc9908be2fa81313912ec044.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OBTeKEbviFPIQIbKa95zXQ.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">模拟测试。图片作者。</p></figure></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h2 id="3faf" class="ol mm it bd mn om on dn mr oo op dp mv lr oq or mx lv os ot mz lz ou ov nb iz bi translated">车辆</h2><p id="7a0c" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">现在，我们必须增加车辆。</p><p id="b028" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们将使用<a class="ae lh" href="https://en.wikipedia.org/wiki/Taylor_series" rel="noopener ugc nofollow" target="_blank">泰勒级数</a>来近似本文建模部分讨论的动力学方程的解。</p><p id="3c2b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">无限微分函数<code class="fe pm pn po pp b">f</code>的泰勒级数展开式为:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pv"><img src="../Images/3961745ade8921a72c0ae8e0c35d0378.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DbYjvd5CKfssJg1sqKKLyQ.png"/></div></div></figure><p id="a9c3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">用<code class="fe pm pn po pp b">▲x</code>代替<code class="fe pm pn po pp b">a</code>，用<code class="fe pm pn po pp b">x+▲x</code>代替<code class="fe pm pn po pp b">x</code>，我们得到:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pv"><img src="../Images/3cd8566de5b75513d2bb2874e51e8803.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lhna63b-XXQ7khvnhFCm2A.png"/></div></div></figure><p id="ca8b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">用位置<code class="fe pm pn po pp b">x</code>替换<code class="fe pm pn po pp b">f</code>:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pv"><img src="../Images/d306dc55388d6927620b3937b589d0db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7IWydpFM1erzHnJ-iKP24A.png"/></div></div></figure><p id="bcb8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">作为近似，我们将在位置的2阶停止，因为加速度是最高阶导数。我们得到方程<strong class="lk jd"> (2) </strong>:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pv"><img src="../Images/d625cb44e6d722d4834bb25be949860f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O0uJS3PZVF83zz-FjHKUEQ.png"/></div></div></figure><p id="bbe7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">对于速度，我们将用<code class="fe pm pn po pp b">v</code>代替<code class="fe pm pn po pp b">x</code>:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pv"><img src="../Images/39d4df468413b6eeb7cc41c8f72cd238.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bv_H3gAYVejcXmQZWZUSJw.png"/></div></div></figure><p id="ab2d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们将停在1阶，因为我们的最高阶导数是加速度(1阶是速度)。方程式<strong class="lk jd"> (2) </strong>:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pw"><img src="../Images/225028ce7951e61f1c9c49cd8d0e5de2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z-ejPVUALM6bRxXkQF1peQ.png"/></div></div></figure><p id="4377" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在每次迭代(或帧)中，使用IDM公式计算加速度后，我们将使用以下两个公式更新位置和速度:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pv"><img src="../Images/ab966c828d6cf297587994ce9a47e58a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JjnH5oJrjDZlrT4UKFk4_A.png"/></div></div></figure><p id="adee" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在代码中是这样的:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ps pt l"/></div></figure><p id="eeff" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">因为这只是一个近似值，所以速度有时会变成负值(但是模型不允许这样)。当速度为负时，不稳定性出现，位置和速度发散到负无穷大。</p><p id="0e71" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">为了克服这个问题，每当我们预测一个负速度时，我们将它设置为零，并从那里计算出:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ow"><img src="../Images/01fc21bf7dea537a9fcc210b66cba0fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f5WFYZFj9qxzcz2-uCNU8w.png"/></div></div></figure><p id="5ee8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在代码中，这是按如下方式实现的:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ps pt l"/></div></figure><p id="9d73" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">为了计算IDM加速度，我们将前导车辆表示为<code class="fe pm pn po pp b">lead</code>，并计算当<code class="fe pm pn po pp b">lead</code>不是<code class="fe pm pn po pp b">None</code>时的交互项(表示为<code class="fe pm pn po pp b">alpha</code>)。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ps pt l"/></div></figure><p id="d1fd" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果车辆停止(例如在红绿灯处)，我们将使用阻尼方程:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ps pt l"/></div></figure><p id="747e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然后，我们在一个<code class="fe pm pn po pp b">Vehicle</code>类中的一个<code class="fe pm pn po pp b">update</code>方法中将所有东西组合在一起:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ps pt l"/></div></figure><p id="9283" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在<code class="fe pm pn po pp b">Road</code>类中，我们将添加一个<code class="fe pm pn po pp b">deque</code>(双端队列)来跟踪车辆。队列是存储车辆的更好的数据结构，因为队列中的第一辆车是道路上最远的一辆车，它是可以从队列中移除的第一辆车。要从<code class="fe pm pn po pp b">deque</code>中移除第一个项目，我们可以使用<code class="fe pm pn po pp b">self.vehicles.popleft()</code>。</p><p id="2a3a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们将在<code class="fe pm pn po pp b">Road</code>类中添加一个<code class="fe pm pn po pp b">update</code>方法:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ps pt l"/></div></figure><p id="39e0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">和<code class="fe pm pn po pp b">Simulation</code>类中的<code class="fe pm pn po pp b">update</code>方法:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ps pt l"/></div></figure><p id="7dd4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">回到<code class="fe pm pn po pp b">Window</code>类，我添加了一个<code class="fe pm pn po pp b">run</code>方法来实时更新模拟:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ps pt l"/></div></figure><p id="3c8b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在，我们将手动添加车辆:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ps pt l"/></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi px"><img src="../Images/9a541e2814ec3996361b4b8d062afdd6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*sUNk5uu8zBTIIp27m9mY2g.gif"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">车辆在移动！图片作者。</p></figure><h2 id="5c86" class="ol mm it bd mn om on dn mr oo op dp mv lr oq or mx lv os ot mz lz ou ov nb iz bi translated">车辆发电机</h2><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ps pt l"/></div></figure><p id="8d45" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">一个<code class="fe pm pn po pp b">VehicleGenerator</code>有一个包含<code class="fe pm pn po pp b">(odds, vehicle)</code>的元组数组。</p><p id="26bd" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">元组的第一个元素是在同一个元组中生成车辆的权重(不是概率)。我使用权重是因为它们更容易处理，因为我们可以只使用整数。</p><p id="754d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">例如，如果我们有3辆车，重量分别为<code class="fe pm pn po pp b">1</code>、<code class="fe pm pn po pp b">3</code>、<code class="fe pm pn po pp b">2</code>。这与<code class="fe pm pn po pp b">1/6</code>、<code class="fe pm pn po pp b">3/6</code>、<code class="fe pm pn po pp b">2/6</code>和<code class="fe pm pn po pp b">6=1+3+2.</code>相对应</p><p id="602c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">为了实现这一点，我们使用以下算法</p><ul class=""><li id="b42a" class="nx ny it lk b ll lm lo lp lr nz lv oa lz ob md oc od oe of bi translated">生成一个介于1和所有权重之和之间的数字。</li><li id="61d6" class="nx ny it lk b ll og lo oh lr oi lv oj lz ok md oc od oe of bi translated">当<strong class="lk jd"> r </strong>为非负时:<br/>遍历所有可能的车辆，并在每次迭代中减去其权重。</li><li id="09d1" class="nx ny it lk b ll og lo oh lr oi lv oj lz ok md oc od oe of bi translated">归还最后使用的车辆。</li></ul><p id="efbe" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果我们有权重:<strong class="lk jd"> W₁ </strong>、<strong class="lk jd"> W₂ </strong>、<strong class="lk jd"> W₃ </strong>。该算法将第一辆车分配到<strong class="lk jd"> 1 </strong>和<strong class="lk jd"> W₁ </strong>之间的号码，第二辆车分配到<strong class="lk jd"> W₁ </strong>和<strong class="lk jd"> W₁+W₂ </strong>之间的号码，第三辆车分配到<strong class="lk jd"> W₁+W₂+W₃ </strong>之间的号码。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ps pt l"/></div></figure><p id="dc70" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">至于何时添加车辆，每当生成器添加车辆时，名为<code class="fe pm pn po pp b">last_added_time</code>的属性被更新为当前时间。当当前时间与<code class="fe pm pn po pp b">last_added_time</code>之间的持续时间大于车辆生成周期时，增加一辆车辆。</p><p id="10ec" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">添加车辆的周期是<code class="fe pm pn po pp b">60/vehicle_rate</code>，因为<code class="fe pm pn po pp b">vehicle_rate</code>在<em class="ox">每分钟车辆</em>，<code class="fe pm pn po pp b">60</code>是1分钟或60秒。</p><p id="35bd" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们还必须检查道路是否还有空间来容纳即将到来的车辆。我们通过检查道路上最后一辆车之间的距离以及即将到来的车辆的长度和安全距离之和来做到这一点。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ps pt l"/></div></figure><p id="e4a6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">最后，我们应该从<code class="fe pm pn po pp b">Simulation</code>的<code class="fe pm pn po pp b">update</code>方法中调用<code class="fe pm pn po pp b">update</code>方法来生成<code class="fe pm pn po pp b">update</code>车辆。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ps pt l"/></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi px"><img src="../Images/7dd70366980330a3444f726ce4c4f605.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*E3g4o9fVpYxnPyIkJZzMUw.gif"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">车辆正在产卵！图片作者。</p></figure><h2 id="ca01" class="ol mm it bd mn om on dn mr oo op dp mv lr oq or mx lv os ot mz lz ou ov nb iz bi translated">红绿灯</h2><p id="00e4" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">交通信号的默认属性是:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ps pt l"/></div></figure><p id="5de8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe pm pn po pp b">self.cycle</code>是一个元组数组，包含<code class="fe pm pn po pp b">self.roads</code>中设置的每条道路的状态(<code class="fe pm pn po pp b">True</code>表示绿色，<code class="fe pm pn po pp b">False</code>表示红色)。</p><p id="bb58" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在默认配置中，<code class="fe pm pn po pp b">(False, True)</code>表示第一组道路是红色，第二组是绿色。<code class="fe pm pn po pp b">(True, False)</code>则相反。</p><p id="162a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">使用这种方法是因为它易于扩展。我们创造的交通灯包括两条以上的道路，交通灯有单独的右转和左转信号，甚至有多个交叉路口的同步交通信号。</p><p id="455f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">交通信号的<code class="fe pm pn po pp b">update</code>功能应该是可定制的。其默认行为是对称的固定时间循环。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ps pt l"/></div></figure><p id="1320" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们需要将这些方法添加到<code class="fe pm pn po pp b">Road</code>类中:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ps pt l"/></div></figure><p id="362c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">而这个，在<code class="fe pm pn po pp b">Road</code>的<code class="fe pm pn po pp b">update</code>方法中。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ps pt l"/></div></figure><p id="0dcd" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">并用<code class="fe pm pn po pp b">Simulation</code>的<code class="fe pm pn po pp b">update</code>方法检查交通灯状态:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ps pt l"/></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi px"><img src="../Images/7edc9efd62eb843300b5fc36d1cf9bca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*6dpXPhWK7U9h4dGxGschxg.gif"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">停下来。图片作者。</p></figure><h2 id="5308" class="ol mm it bd mn om on dn mr oo op dp mv lr oq or mx lv os ot mz lz ou ov nb iz bi translated">曲线</h2><p id="0e89" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">在现实世界中，道路是有曲线的。虽然从技术上讲，我们可以通过手写大量道路的坐标来近似一条曲线，从而在这个模拟中创建曲线，但我们也可以在程序上做同样的事情。</p><p id="be05" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">为此，我将使用<a class="ae lh" href="https://en.wikipedia.org/wiki/B%C3%A9zier_curve" rel="noopener ugc nofollow" target="_blank">贝塞尔曲线</a>。</p><p id="6a29" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我创建了一个<code class="fe pm pn po pp b">curve.py</code>文件，其中包含了帮助创建曲线并通过道路索引引用它们的函数。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ps pt l"/></div></figure><p id="8db0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">测试:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ps pt l"/></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi px"><img src="../Images/1dc2b806d73414c44572ea0c707a0591.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*EL4IOuXHz9VHzEjSuRucJg.gif"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">优美的曲线。图片作者。</p></figure><h1 id="74e9" class="ml mm it bd mn mo ni mq mr ms nj mu mv ki nk kj mx kl nl km mz ko nm kp nb nc bi translated">例子</h1><p id="f225" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">这些示例的代码可以在本文底部链接的Github资源库中找到。</p><h2 id="0d96" class="ol mm it bd mn om on dn mr oo op dp mv lr oq or mx lv os ot mz lz ou ov nb iz bi translated">高速公路上</h2><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi px"><img src="../Images/d04aa5b77e5dfc0a8e97efd26f08afc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*i2TEawoAHs9EZWXr7JL2DQ.gif"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">高速公路上。图片作者。</p></figure><h2 id="d629" class="ol mm it bd mn om on dn mr oo op dp mv lr oq or mx lv os ot mz lz ou ov nb iz bi translated">双向交叉路口</h2><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi px"><img src="../Images/1dd950ce95ddf88bdd790a395ba29eab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*t-iw_2L_flOclZBPh-tvFQ.gif"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">双向交叉路口。图片作者。</p></figure><h2 id="952b" class="ol mm it bd mn om on dn mr oo op dp mv lr oq or mx lv os ot mz lz ou ov nb iz bi translated">迂回的</h2><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi px"><img src="../Images/7a795dacd3b07186bba96b970b4f7588.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*rLGbs0-eCv09na-fukvINQ.gif"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">迂回。图片作者。</p></figure><h2 id="8b8a" class="ol mm it bd mn om on dn mr oo op dp mv lr oq or mx lv os ot mz lz ou ov nb iz bi translated">分叉菱形立交</h2><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi px"><img src="../Images/b128c1d41a55c58e1e9d56a799a1a7e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*YjpDbNMjuuIzTw5XYU3i-g.gif"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">分叉菱形立交。图片作者。</p></figure></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="ecf0" class="ml mm it bd mn mo mp mq mr ms mt mu mv ki mw kj mx kl my km mz ko na kp nb nc bi translated">限制</h1><p id="9b91" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">虽然我们可以修改<code class="fe pm pn po pp b">Simulation</code>类来存储关于我们稍后可以使用的模拟的数据，但是如果数据收集过程更加精简的话会更好。</p><p id="914e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这个模拟还欠缺很多。弯道的实施是糟糕和低效的，并导致车辆和交通信号之间的相互作用的问题。</p><p id="28b4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">虽然有些人可能认为智能司机模型有点矫枉过正，但拥有一个能够复制真实世界现象的模型很重要，如<a class="ae lh" href="https://en.wikipedia.org/wiki/Traffic_wave" rel="noopener ugc nofollow" target="_blank">交通波</a>(又名幽灵交通蛇)和司机反应时间的影响。出于这个原因，我选择使用智能驱动程序模型。但是对于准确性和极端真实性不重要的模拟，如视频游戏，IDM可以由更简单的基于逻辑的模型代替。</p><p id="9023" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">完全依赖基于模拟的数据会增加过度拟合的风险。您的ML模型可以针对只存在于模拟中而不存在于真实世界中的零食进行优化。</p><h1 id="a503" class="ml mm it bd mn mo ni mq mr ms nj mu mv ki nk kj mx kl nl km mz ko nm kp nb nc bi translated">结论</h1><p id="4bc2" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">仿真是数据科学和机器学习的重要组成部分。有时，从现实世界中收集数据要么是不可能的，要么是昂贵的。生成数据有助于以更好的价格建立庞大的数据集。模拟也有助于填补真实世界数据的空白。在某些情况下，真实世界的数据集缺乏可能对开发的模型至关重要的边缘案例。</p><p id="5acb" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这个模拟是我参与的一个大学项目的一部分。目的是优化城市十字路口的交通信号。我做这个模拟是为了测试和验证我的优化方法。</p><p id="f4af" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我从来没有想过要发表这篇文章，直到我在看特斯拉的AI day，在这篇文章中，他们谈到了他们如何使用模拟来为边缘案例生成数据。</p><h1 id="3f32" class="ml mm it bd mn mo ni mq mr ms nj mu mv ki nk kj mx kl nl km mz ko nm kp nb nc bi translated">源代码和贡献</h1><p id="5cc0" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">这里有一个到Github库 的链接，包含本文中的所有代码，包括例子。</p><p id="e774" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果您对代码有任何疑问或问题，请随时联系我，或者在GitHub上提交请求或问题。</p></div></div>    
</body>
</html>