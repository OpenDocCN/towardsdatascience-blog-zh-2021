<html>
<head>
<title>4 Useful Functions of the More-Itertools Library for Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python的More-Itertools库的4个有用函数</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/4-useful-functions-of-the-more-itertools-library-for-python-6915a10781ce?source=collection_archive---------20-----------------------#2021-12-08">https://towardsdatascience.com/4-useful-functions-of-the-more-itertools-library-for-python-6915a10781ce?source=collection_archive---------20-----------------------#2021-12-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7ab9" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使得使用Python iterables更加容易</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/88bbfae8b9ccd1386d21031c479bb806.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zs8fTifyOIbmGzHiJSs3xw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@chortsang?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Chor曾</a>在<a class="ae ky" href="https://unsplash.com/s/photos/levels?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="5006" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Python的itertools模块提供了几个函数，允许创建迭代器来执行高效的循环操作。</p><p id="6dbc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://more-itertools.readthedocs.io/en/stable/" rel="noopener ugc nofollow" target="_blank"> more-itertools </a>是一个Python库，为iterables带来了额外的功能。</p><p id="e003" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将浏览more-itertools库的5个非常有用的函数，并查看演示如何使用它们的示例。</p><p id="1079" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">先简单解释一下Python中的可迭代器和迭代器。</p><ul class=""><li id="4a8b" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">iterable是一个Python对象，它可以一次返回一个元素，比如列表和元组。iterable对象有一个返回迭代器的<code class="fe me mf mg mh b">__iter__</code>方法。</li><li id="854f" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated">迭代器是一个拥有<code class="fe me mf mg mh b">__next__</code>方法的对象。我们可以把迭代器想象成一个表示数据流的对象。每次调用__next__方法时，迭代器都返回行中的下一个元素。因此，迭代器有一个在迭代过程中记住当前位置的状态。</li></ul><p id="aab8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里有一个简单的例子来说明iterable和iterator之间的区别。</p><pre class="kj kk kl km gt mn mh mo mp aw mq bi"><span id="f23d" class="mr ms it mh b gy mt mu l mv mw">mylist = [3, 1, 4, 21, 13, 5]</span><span id="0f22" class="mr ms it mh b gy mx mu l mv mw">print(mylist)<br/>[3, 1, 4, 21, 13, 5]</span></pre><p id="577e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">变量“mylist”是一个列表，所以它是可迭代的。</p><pre class="kj kk kl km gt mn mh mo mp aw mq bi"><span id="da1f" class="mr ms it mh b gy mt mu l mv mw">myiterator = iter(mylist)</span><span id="573a" class="mr ms it mh b gy mx mu l mv mw">print(myiterator)<br/>&lt;list_iterator object at 0x000002C9E5860070&gt;</span></pre><p id="f20e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们在“mylist”上应用<code class="fe me mf mg mh b">iter</code>函数时，我们得到一个迭代器对象。我们不能像打印可迭代的那样打印迭代器。但是我们可以得到下一个项目。</p><pre class="kj kk kl km gt mn mh mo mp aw mq bi"><span id="3e12" class="mr ms it mh b gy mt mu l mv mw">next(myiterator)<br/>3</span><span id="9735" class="mr ms it mh b gy mx mu l mv mw">next(myiterator)<br/>1</span></pre><p id="22ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还可以使用如下的循环来打印每个项目:</p><pre class="kj kk kl km gt mn mh mo mp aw mq bi"><span id="9a01" class="mr ms it mh b gy mt mu l mv mw">for i in myiterator:<br/>    print(i)</span><span id="cd9f" class="mr ms it mh b gy mx mu l mv mw"># output<br/>4<br/>21<br/>13<br/>5</span></pre><p id="18b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们到达终点时它就停止了。如果我们现在调用下一个函数，我们会得到一个<code class="fe me mf mg mh b">StopIteration</code>错误。一旦我们到达一个迭代器的末尾，就是这样！我们不能从头开始。因此，从某种意义上说，迭代器是可任意使用的。</p></div><div class="ab cl my mz hx na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="im in io ip iq"><p id="5d0e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在已经理解了什么时候可迭代和迭代器。让我们开始探索more-itertools库的伟大特性。</p><p id="17ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它可以很容易地通过pip安装。然后，我们只需要导入它。</p><pre class="kj kk kl km gt mn mh mo mp aw mq bi"><span id="e2ae" class="mr ms it mh b gy mt mu l mv mw"># install from cmd<br/>pip install more-itertools</span><span id="486b" class="mr ms it mh b gy mx mu l mv mw"># install in jupyter notebook<br/>pip install more-itertools</span></pre><h1 id="fd43" class="nf ms it bd ng nh ni nj nk nl nm nn no jz np ka nq kc nr kd ns kf nt kg nu nv bi translated">1.块状的</h1><p id="c9ac" class="pw-post-body-paragraph kz la it lb b lc nw ju le lf nx jx lh li ny lk ll lm nz lo lp lq oa ls lt lu im bi translated">我们有一个需要分割成固定长度的小块的列表。有多种方法可以完成这个操作，但是使用<code class="fe me mf mg mh b">chunked</code>功能非常简单。</p><pre class="kj kk kl km gt mn mh mo mp aw mq bi"><span id="a808" class="mr ms it mh b gy mt mu l mv mw">from more_itertools import chunked</span><span id="086e" class="mr ms it mh b gy mx mu l mv mw">mylist = [1,2,3,4,5,6,7,8,9,10]</span><span id="462b" class="mr ms it mh b gy mx mu l mv mw">chunked_list = list(chunked(mylist, 3))</span><span id="6314" class="mr ms it mh b gy mx mu l mv mw">chunked_list<br/>[[1, 2, 3], [4, 5, 6], [7, 8, 9], [10]]</span></pre><p id="b1cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe me mf mg mh b">chunked</code>函数返回一个迭代器，使用<code class="fe me mf mg mh b">list</code>函数可以很容易地将它转换成一个列表。它接受要分块的列表和每个块的大小。</p><p id="b8bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的例子中，块大小是3，所以最后一个块只剩下一个项目。</p><p id="b010" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以通过使用列表索引来访问块:</p><pre class="kj kk kl km gt mn mh mo mp aw mq bi"><span id="f16a" class="mr ms it mh b gy mt mu l mv mw">chunked_list[0]<br/>[1, 2, 3]</span></pre></div><div class="ab cl my mz hx na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="im in io ip iq"><h1 id="b5ca" class="nf ms it bd ng nh ob nj nk nl oc nn no jz od ka nq kc oe kd ns kf of kg nu nv bi translated">2.变平</h1><p id="c95e" class="pw-post-body-paragraph kz la it lb b lc nw ju le lf nx jx lh li ny lk ll lm nz lo lp lq oa ls lt lu im bi translated"><code class="fe me mf mg mh b">flatten</code>函数接受嵌套的iterable并将它们转换成平面iterable。例如，我们可以通过使用列表的列表来创建列表。</p><pre class="kj kk kl km gt mn mh mo mp aw mq bi"><span id="00ca" class="mr ms it mh b gy mt mu l mv mw">nested_list = [[1,4], [3,8], [1,10]]</span><span id="9bed" class="mr ms it mh b gy mx mu l mv mw">list(flatten(nested_list))<br/>[1, 4, 3, 8, 1, 10]</span></pre><p id="c36a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">类似地，我们可以使用嵌套元组列表和列表。</p><pre class="kj kk kl km gt mn mh mo mp aw mq bi"><span id="b0cb" class="mr ms it mh b gy mt mu l mv mw">nested = [(5,2), (9,2), [1,5]]</span><span id="7f79" class="mr ms it mh b gy mx mu l mv mw">list(flatten(nested))<br/>[5, 2, 9, 2, 1, 5]</span></pre></div><div class="ab cl my mz hx na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="im in io ip iq"><h1 id="6378" class="nf ms it bd ng nh ob nj nk nl oc nn no jz od ka nq kc oe kd ns kf of kg nu nv bi translated">3.最小最大值</h1><p id="79f7" class="pw-post-body-paragraph kz la it lb b lc nw ju le lf nx jx lh li ny lk ll lm nz lo lp lq oa ls lt lu im bi translated"><code class="fe me mf mg mh b">minmax</code>函数是一种快速找到iterable中的最小值和最大值的方法。</p><pre class="kj kk kl km gt mn mh mo mp aw mq bi"><span id="6925" class="mr ms it mh b gy mt mu l mv mw">from more_itertools import minmax</span><span id="61ed" class="mr ms it mh b gy mx mu l mv mw">mylist = [3, 1, 4, 21, 13, 5]</span><span id="0269" class="mr ms it mh b gy mx mu l mv mw">minmax(mylist)<br/>(1, 21)</span></pre><p id="5ecf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它返回一个具有最小值和最大值的元组。</p><p id="326e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它还可以处理字符串，并根据字母顺序查找最小值和最大值。</p><pre class="kj kk kl km gt mn mh mo mp aw mq bi"><span id="a674" class="mr ms it mh b gy mt mu l mv mw">mylist = ["A", "C", "Z", "M"]</span><span id="842f" class="mr ms it mh b gy mx mu l mv mw">minmax(mylist)<br/>('A', 'Z')</span></pre></div><div class="ab cl my mz hx na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="im in io ip iq"><h1 id="ffae" class="nf ms it bd ng nh ob nj nk nl oc nn no jz od ka nq kc oe kd ns kf of kg nu nv bi translated">4.每个都是唯一的</h1><p id="6b53" class="pw-post-body-paragraph kz la it lb b lc nw ju le lf nx jx lh li ny lk ll lm nz lo lp lq oa ls lt lu im bi translated">假设我们有一组可重复项。<code class="fe me mf mg mh b">unique_to_each</code>函数给出了每个可迭代变量的唯一值。换句话说，这个函数返回的值只存在于相关的iterable中。</p><p id="5fef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们做一个例子时，它会变得更加清楚。</p><pre class="kj kk kl km gt mn mh mo mp aw mq bi"><span id="349b" class="mr ms it mh b gy mt mu l mv mw">from more_itertools import unique_to_each</span><span id="f272" class="mr ms it mh b gy mx mu l mv mw">A = ["John", "Jane"]<br/>B = ["John", "Max"]<br/>C = ["Jane", "Emily"]</span><span id="fe32" class="mr ms it mh b gy mx mu l mv mw">unique_to_each(A, B, C)<br/>[[], ['Max'], ['Emily']]</span></pre><p id="bbd5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">列表A中的值是同样存在于列表C中的“John”和同样存在于列表C中的“Jane”。因此，列表A没有唯一的值。正如我们在输出中看到的,<code class="fe me mf mg mh b">unique_to_each</code>函数为列表A返回一个空列表。</p><p id="6b68" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">列表B中的“Max”在任何其他列表中都不存在，因此它对于列表B是唯一的，我们也可以在输出中看到。</p><p id="abb6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们也可以在字符串上使用这个函数。请注意，字符串也是可迭代的。</p><pre class="kj kk kl km gt mn mh mo mp aw mq bi"><span id="c843" class="mr ms it mh b gy mt mu l mv mw">unique_to_each("John","Jane")<br/>[['o', 'h'], ['a', 'e']]</span></pre></div><div class="ab cl my mz hx na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="im in io ip iq"><p id="36b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们已经在more-itertools库中介绍了4个有用的函数。我强烈建议浏览一下这个库的<a class="ae ky" href="https://more-itertools.readthedocs.io/en/stable/index.html" rel="noopener ugc nofollow" target="_blank">文档</a>，因为它有更多的功能。</p><p id="9c90" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">文档组织得很好，因此您可以毫无问题地使用它。</p></div><div class="ab cl my mz hx na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="im in io ip iq"><p id="e8de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以成为一名<a class="ae ky" href="https://sonery.medium.com/membership" rel="noopener">媒介会员</a>来解锁我的作品的全部权限，以及媒介的其余部分。如果您使用以下链接，我将收取您的一部分会员费，无需您支付额外费用。</p><div class="og oh gp gr oi oj"><a href="https://sonery.medium.com/membership" rel="noopener follow" target="_blank"><div class="ok ab fo"><div class="ol ab om cl cj on"><h2 class="bd iu gy z fp oo fr fs op fu fw is bi translated">通过我的推荐链接加入Medium-Soner yl DRM</h2><div class="oq l"><h3 class="bd b gy z fp oo fr fs op fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="or l"><p class="bd b dl z fp oo fr fs op fu fw dk translated">sonery.medium.com</p></div></div><div class="os l"><div class="ot l ou ov ow os ox ks oj"/></div></div></a></div></div><div class="ab cl my mz hx na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="im in io ip iq"><p id="dceb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢您的阅读。如果您有任何反馈，请告诉我。</p></div></div>    
</body>
</html>