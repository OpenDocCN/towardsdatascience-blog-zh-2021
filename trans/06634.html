<html>
<head>
<title>Build a Serverless Delivery Command Center on GCP</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在GCP建立一个无服务器的交付指挥中心</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/build-a-serverless-parcel-delivery-command-center-on-gcp-7c2df99b3db1?source=collection_archive---------39-----------------------#2021-06-14">https://towardsdatascience.com/build-a-serverless-parcel-delivery-command-center-on-gcp-7c2df99b3db1?source=collection_archive---------39-----------------------#2021-06-14</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><div class=""/><div class=""><h2 id="7b21" class="pw-subtitle-paragraph jo iq ir bd b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf dk translated">结合地图，或工具，发送网格和云功能来征用一个送货车队</h2></div><blockquote class="kg kh ki"><p id="34bf" class="kj kk kl km b kn ko js kp kq kr jv ks kt ku kv kw kx ky kz la lb lc ld le lf ik bi translated">本文展示了如何:</p><p id="0733" class="kj kk kl km b kn ko js kp kq kr jv ks kt ku kv kw kx ky kz la lb lc ld le lf ik bi translated">1.在GCP建立一个云存储，当文件上传时触发云功能；</p><p id="a674" class="kj kk kl km b kn ko js kp kq kr jv ks kt ku kv kw kx ky kz la lb lc ld le lf ik bi translated">2.用谷歌地图和谷歌OR-Tools设置一个计算最优路线策略的云功能；</p><p id="570b" class="kj kk kl km b kn ko js kp kq kr jv ks kt ku kv kw kx ky kz la lb lc ld le lf ik bi translated">3.通过SendGrid向承运人发送说明电子邮件；</p><p id="4f7c" class="kj kk kl km b kn ko js kp kq kr jv ks kt ku kv kw kx ky kz la lb lc ld le lf ik bi translated">4.为持续部署设置云构建。</p></blockquote><p id="a984" class="pw-post-body-paragraph kj kk ir km b kn ko js kp kq kr jv ks lg ku kv kw lh ky kz la li lc ld le lf ik bi translated">令人惊讶的是，仅仅通过几项服务就可以在云上构建许多现代商业解决方案。开发人员可以将云组件结合起来，构建一个从数据接收到通过电子邮件发送结果的管道，只需点击几下鼠标。价格很灵活。硬件配置最少，尤其是使用无服务器选项时。因此，小型企业现在可以负担起大量的计算能力。计算能力的民主化使许多传统企业迅速现代化。其中之一一定是送货服务。</p><figure class="lk ll lm ln gu lo gi gj paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gi gj lj"><img src="../Images/4592bd6c627dc92828423fd4d7779e8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kSBb5YzsA41PHhtYrhfh3A.jpeg"/></div></div><p class="lv lw gk gi gj lx ly bd b be z dk translated">图一。Joshua Fernandez 在<a class="ae lz" href="https://unsplash.com/s/photos/delivery?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="7601" class="pw-post-body-paragraph kj kk ir km b kn ko js kp kq kr jv ks lg ku kv kw lh ky kz la li lc ld le lf ik bi translated">我在Medium上看到了两篇文章:一篇是由<a class="ae lz" href="https://dsdx.medium.com/" rel="noopener"> Sebastian Telsemeyer </a>写的，关于用Cloud Run和Pub/Sub在GCP建立一个时间序列预测管道；</p><div class="ma mb gq gs mc md"><a rel="noopener follow" target="_blank" href="/building-a-serverless-containerized-batch-prediction-model-using-google-cloud-run-and-terraform-82c97ab17515"><div class="me ab fp"><div class="mf ab mg cl cj mh"><h2 class="bd is gz z fq mi fs ft mj fv fx iq bi translated">使用Google Cloud Run和Terraform构建一个无服务器的容器化批量预测模型</h2><div class="mk l"><h3 class="bd b gz z fq mi fs ft mj fv fx dk translated">使用Google Cloud Run、云存储和发布/订阅的异步模型服务</h3></div><div class="ml l"><p class="bd b dl z fq mi fs ft mj fv fx dk translated">towardsdatascience.com</p></div></div><div class="mm l"><div class="mn l mo mp mq mm mr lt md"/></div></div></a></div><p id="9b1d" class="pw-post-body-paragraph kj kk ir km b kn ko js kp kq kr jv ks lg ku kv kw lh ky kz la li lc ld le lf ik bi translated">第二个是由Samir Saci 提出的，他使用Goolge OR-Tools来优化最后一英里的交付(然而<a class="ae lz" href="https://developers.google.com/optimization/routing/cvrp" rel="noopener ugc nofollow" target="_blank">解决方案</a>是由Goolge在2020年首先提出的):</p><div class="ma mb gq gs mc md"><a rel="noopener follow" target="_blank" href="/optimize-e-commerce-last-mile-delivery-with-python-ab9ba37d214c"><div class="me ab fp"><div class="mf ab mg cl cj mh"><h2 class="bd is gz z fq mi fs ft mj fv fx iq bi translated">使用Python优化电子商务的最后一英里交付</h2><div class="mk l"><h3 class="bd b gz z fq mi fs ft mj fv fx dk translated">使用python优化模型组织路径，以最少的驾驶员数量交付包裹</h3></div><div class="ml l"><p class="bd b dl z fq mi fs ft mj fv fx dk translated">towardsdatascience.com</p></div></div><div class="mm l"><div class="ms l mo mp mq mm mr lt md"/></div></div></a></div><p id="a1fb" class="pw-post-body-paragraph kj kk ir km b kn ko js kp kq kr jv ks lg ku kv kw lh ky kz la li lc ld le lf ik bi translated">塞巴斯蒂安的文章鼓舞人心。在他的管道中，一个Pub/Sub监控一个特定的GCP桶。上传TSV文件时，它会激活云运行计算，在第二个存储桶中生成结果。他的整个基础设施是无服务器的，并且是用Terraform编码的。在我看来，他的管道甚至可以更简单:一个<code class="fe mt mu mv mw b">Finalise/Create</code>事件触发的云函数，可以代替“Pub/Sub + Cloud Run”组合。更简单的版本需要更少的设置。因为云函数基本上是一个Lambda函数，所以它摆脱了整个Docker部分和Gunicorn + Flask依赖关系。</p><p id="97e9" class="pw-post-body-paragraph kj kk ir km b kn ko js kp kq kr jv ks lg ku kv kw lh ky kz la li lc ld le lf ik bi translated">Samir的文章展示了一个复杂的<em class="kl">有容量限制的车辆路线</em> <em class="kl">问题</em> (CVRP)如何通过Google OR-Tools解决。让我们假设有30个包裹需要由两个承运人从德国布伦瑞克的一个物流中心分发到九个不同的地方。每个承运人最多可以承运15个包裹。然后，Google OR-Tools会尝试以最低的成本规划路线，同时平衡每个承运人的负载和距离。示例输出如下所示:</p><pre class="lk ll lm ln gu mx mw my mz aw na bi"><span id="19f6" class="nb nc ir mw b gz nd ne l nf ng">Hello Driver A, your delivery route is: <br/> bring 2 Parcels to Institute of System Security, Muehlenpfordtstrasse 23, 38106 Braunschweig -&gt; <br/> bring 2 Parcels to Am Schuetzenpl. 1, 38114 Braunschweig -&gt; <br/> bring 3 Parcels to Humboldtstrasse 1, 38106 Braunschweig -&gt; <br/> bring 2 Parcels to Johanniterstrasse 5, 38104 Braunschweig -&gt; <br/> bring 6 Parcels to Willy-Brandt-Platz 1, 38102 Braunschweig -&gt;</span></pre><p id="6311" class="pw-post-body-paragraph kj kk ir km b kn ko js kp kq kr jv ks lg ku kv kw lh ky kz la li lc ld le lf ik bi translated">OR工具将十个位置的距离矩阵作为输入之一。在谷歌的原始帖子和萨米尔的文章中，距离矩阵是虚构位置的硬编码虚拟物，路线指示只是以文本形式打印出来。在真实的配送指挥中心，我们需要根据真实地址计算距离矩阵(见我之前的文章<a class="ae lz" href="https://medium.com/geekculture/get-geo-data-from-google-cloud-for-your-next-new-home-f0a02c185d5f" rel="noopener">此处</a>)并通知承运人他们的路线。</p><figure class="lk ll lm ln gu lo gi gj paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gi gj nh"><img src="../Images/9c27ca397ee5b7576c97774f1433db64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uNQeY9dbjgR3jNNTYMw1vg.png"/></div></div><p class="lv lw gk gi gj lx ly bd b be z dk translated">图二。GCP交付精简版架构。由<a class="ae lz" href="http://www.onlinewebfonts.com/icon" rel="noopener ugc nofollow" target="_blank">onlinewebfonts.com</a>承运图标，由CC 3.0授权。图片作者。</p></figure><p id="b98d" class="pw-post-body-paragraph kj kk ir km b kn ko js kp kq kr jv ks lg ku kv kw lh ky kz la li lc ld le lf ik bi translated">带着这些想法，站在Sebastian和Samir的肩膀上，我接受了挑战，并在GCP实施了一个简单的解决方案。云存储中的上传事件可以触发云函数通过Google Maps API构建距离矩阵。或工具然后计算路线。最后，它通过SendGrid将路线指示发送给运营商(图2。).作为奖励，我设置了云构建来持续部署应用程序。这个项目的代码存放在我的Github库中。</p><div class="ma mb gq gs mc md"><a href="https://github.com/dgg32/gcp-delivery-lite" rel="noopener  ugc nofollow" target="_blank"><div class="me ab fp"><div class="mf ab mg cl cj mh"><h2 class="bd is gz z fq mi fs ft mj fv fx iq bi translated">dgg 32/GCP-交付-精简版</h2><div class="mk l"><h3 class="bd b gz z fq mi fs ft mj fv fx dk translated">在GitHub上创建一个帐户，为dgg32/gcp-delivery-lite的开发做出贡献。</h3></div><div class="ml l"><p class="bd b dl z fq mi fs ft mj fv fx dk translated">github.com</p></div></div><div class="mm l"><div class="ni l mo mp mq mm mr lt md"/></div></div></a></div><h1 id="69d2" class="nj nc ir bd nk nl nm nn no np nq nr ns jx nt jy nu ka nv kb nw kd nx ke ny nz bi translated">1.准备输入Json数据</h1><p id="2c5f" class="pw-post-body-paragraph kj kk ir km b kn oa js kp kq ob jv ks lg oc kv kw lh od kz la li oe ld le lf ik bi translated">输入的Json数据包含两部分。第一部分包含所有位置的地址和包裹数量。第一个位置总是承运人装载包裹的物流中心。第二部分是承运人的信息，包括他们的姓名、能力和电子邮件地址。下面是我的input.json的缩略版。</p><figure class="lk ll lm ln gu lo"><div class="bz fq l di"><div class="of og l"/></div></figure><h1 id="4d3b" class="nj nc ir bd nk nl nm nn no np nq nr ns jx nt jy nu ka nv kb nw kd nx ke ny nz bi translated">2.设置发送网格</h1><p id="a563" class="pw-post-body-paragraph kj kk ir km b kn oa js kp kq ob jv ks lg oc kv kw lh od kz la li oe ld le lf ik bi translated">我们希望通过云功能向运营商发送说明电子邮件。Goolge建议我们使用可信的第三方提供商，比如SendGrid。SendGrid中的免费计划允许每天100封邮件永远免费，这对我们的项目来说足够了。</p><figure class="lk ll lm ln gu lo gi gj paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gi gj oh"><img src="../Images/8d97821e3851d5d55fc143d596506d4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kBfee38UZ524m0k12d62jw.png"/></div></div><p class="lv lw gk gi gj lx ly bd b be z dk translated">图3。发送网格API设置。图片作者。</p></figure><figure class="lk ll lm ln gu lo gi gj paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gi gj oi"><img src="../Images/296cd26a3db0eb1abe926f3c84fd55c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Am6-3o6r9SuNKZ8pBfgrvg.png"/></div></div><p class="lv lw gk gi gj lx ly bd b be z dk translated">图4。通过整合测试。图片作者。</p></figure><p id="d061" class="pw-post-body-paragraph kj kk ir km b kn ko js kp kq kr jv ks lg ku kv kw lh ky kz la li lc ld le lf ik bi translated">首先，用免费计划在<a class="ae lz" href="https://sendgrid.com/" rel="noopener ugc nofollow" target="_blank"> SendGrid </a>中注册一个账户。然后创建一个发送者身份。这是电子邮件中的“发件人”地址。之后，SendGrid会向您发送一封电子邮件。在发送电子邮件之前，您需要验证您的单一发件人是否遵循其说明。</p><p id="45b4" class="pw-post-body-paragraph kj kk ir km b kn ko js kp kq kr jv ks lg ku kv kw lh ky kz la li lc ld le lf ik bi translated">然后导航到用户仪表盘，点击打开<code class="fe mt mu mv mw b">Email API</code>和<code class="fe mt mu mv mw b">Integration Guide</code>。选择<code class="fe mt mu mv mw b">Web API</code>和<code class="fe mt mu mv mw b">Python</code>。然后创建一个API键(图3。)并遵循测试说明，直到您通过集成测试(图4。).将单个发件人的电子邮件和API密钥保存在安全的地方，以备后用。</p><h1 id="6168" class="nj nc ir bd nk nl nm nn no np nq nr ns jx nt jy nu ka nv kb nw kd nx ke ny nz bi translated">3.建立GCP</h1><p id="c4c1" class="pw-post-body-paragraph kj kk ir km b kn oa js kp kq ob jv ks lg oc kv kw lh od kz la li oe ld le lf ik bi translated">在你的GCP控制台上创建一个名为<code class="fe mt mu mv mw b">delivery-lite</code>的项目。启用<code class="fe mt mu mv mw b">Distance Matrix API</code>并为其创建一个限制性API密钥。这个过程涉及到许多点击，你可以在这里阅读我以前的文章<a class="ae lz" href="https://medium.com/geekculture/get-geo-data-from-google-cloud-for-your-next-new-home-f0a02c185d5f" rel="noopener">获得指导。</a></p><p id="d1f1" class="pw-post-body-paragraph kj kk ir km b kn ko js kp kq kr jv ks lg ku kv kw lh ky kz la li lc ld le lf ik bi translated">然后转到<code class="fe mt mu mv mw b">Cloud Function</code>并创建一个函数<code class="fe mt mu mv mw b">command-center</code>，选择<code class="fe mt mu mv mw b">Cloud Storage</code>作为触发类型，选择<code class="fe mt mu mv mw b">Finalize/Create</code>作为事件。单击“浏览”并创建一个存储桶。点击<code class="fe mt mu mv mw b">SAVE</code>。</p><figure class="lk ll lm ln gu lo gi gj paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gi gj oj"><img src="../Images/97b119b9a5c94809957497bb468ff699.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LxHJ2SIqrSHZPYqep0guUA.png"/></div></div><p class="lv lw gk gi gj lx ly bd b be z dk translated">图5。云功能配置。图片作者。</p></figure><p id="7d2f" class="pw-post-body-paragraph kj kk ir km b kn ko js kp kq kr jv ks lg ku kv kw lh ky kz la li lc ld le lf ik bi translated">展开<code class="fe mt mu mv mw b">RUNTIME</code>设置，添加四个环境变量:</p><ol class=""><li id="7388" class="ok ol ir km b kn ko kq kr lg om lh on li oo lf op oq or os bi translated"><code class="fe mt mu mv mw b">KEY</code>是你的距离矩阵API键。</li><li id="6689" class="ok ol ir km b kn ot kq ou lg ov lh ow li ox lf op oq or os bi translated"><code class="fe mt mu mv mw b">SENDGRID_API_KEY</code>是您的SendGrid API密钥。</li><li id="044f" class="ok ol ir km b kn ot kq ou lg ov lh ow li ox lf op oq or os bi translated"><code class="fe mt mu mv mw b">SENDER</code>是您的单一发件人电子邮件地址。</li><li id="6217" class="ok ol ir km b kn ot kq ou lg ov lh ow li ox lf op oq or os bi translated"><code class="fe mt mu mv mw b">PROJECT</code>是项目名称，在本例中是<code class="fe mt mu mv mw b">delivery-lite</code>。</li></ol><p id="2354" class="pw-post-body-paragraph kj kk ir km b kn ko js kp kq kr jv ks lg ku kv kw lh ky kz la li lc ld le lf ik bi translated">然后可以点击<code class="fe mt mu mv mw b">NEXT</code>按钮进入<code class="fe mt mu mv mw b">Code</code>页面。启用<code class="fe mt mu mv mw b">Cloud Build API</code>，并按照警告横幅中的说明创建凭证。完成后，返回到<code class="fe mt mu mv mw b">Code</code>页面。选择<code class="fe mt mu mv mw b">Python 3.9</code>作为运行时，输入<code class="fe mt mu mv mw b">main</code>作为进入点。</p><p id="d8c8" class="pw-post-body-paragraph kj kk ir km b kn ko js kp kq kr jv ks lg ku kv kw lh ky kz la li lc ld le lf ik bi translated">在内嵌编辑器中创建一个名为<code class="fe mt mu mv mw b">function.py</code>的文件。将我的存储库中的内容复制并粘贴到相应的文件中(图。6).或者你可以压缩并上传我的三个文件。按下<code class="fe mt mu mv mw b">DEPLOY</code>按钮，等待功能就绪。</p><figure class="lk ll lm ln gu lo gi gj paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gi gj oy"><img src="../Images/d29f92cc994a26c7a4982f9b0c85bcbb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R7FuVGQl4-SCmxQBuuxUFg.png"/></div></div><p class="lv lw gk gi gj lx ly bd b be z dk translated">图6。定义云函数。图片作者。</p></figure><figure class="lk ll lm ln gu lo"><div class="bz fq l di"><div class="of og l"/></div></figure><p id="d284" class="pw-post-body-paragraph kj kk ir km b kn ko js kp kq kr jv ks lg ku kv kw lh ky kz la li lc ld le lf ik bi translated"><code class="fe mt mu mv mw b">function.py</code>包含三个辅助功能。前两个用于通过Maps API计算地点列表的距离矩阵。第三个通过SendGrid发送电子邮件。</p><figure class="lk ll lm ln gu lo"><div class="bz fq l di"><div class="of og l"/></div></figure><p id="7555" class="pw-post-body-paragraph kj kk ir km b kn ko js kp kq kr jv ks lg ku kv kw lh ky kz la li lc ld le lf ik bi translated"><code class="fe mt mu mv mw b">main.py</code>利用了<code class="fe mt mu mv mw b">function.py</code>。在第12行收到距离矩阵后，脚本将它与运营商信息打包在一起，最后在第29行调用OR-Tools。如果找到了至少一个解决方案，脚本将制定路线指令，并通过第46行的SendGrid分别发送给每个承运人。在此，我感谢Samir和Google团队提供的OR-Tools代码示例。</p><h1 id="40f3" class="nj nc ir bd nk nl nm nn no np nq nr ns jx nt jy nu ka nv kb nw kd nx ke ny nz bi translated">4.测试管道</h1><p id="4803" class="pw-post-body-paragraph kj kk ir km b kn oa js kp kq ob jv ks lg oc kv kw lh od kz la li oe ld le lf ik bi translated">设置好一切之后，我们现在可以测试管道了。下面是<code class="fe mt mu mv mw b">input_test.json</code>文件。修改<code class="fe mt mu mv mw b">carrier</code>列表中的信息，特别是在<code class="fe mt mu mv mw b">email</code>字段中输入有效的电子邮件地址，以便接收输出指令。打开云存储页面的一个新选项卡，找到指定的存储桶。将<code class="fe mt mu mv mw b">input_test.json</code>文件上传到bucket中(图7。).这应该会触发我们的云功能运行。</p><figure class="lk ll lm ln gu lo"><div class="bz fq l di"><div class="of og l"/></div></figure><figure class="lk ll lm ln gu lo gi gj paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gi gj oz"><img src="../Images/7f88504ff0c9918be58d6aff16113ac0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MJKV-Gxpw4EFs9grxk_5jA.png"/></div></div><p class="lv lw gk gi gj lx ly bd b be z dk translated">图7。将输入数据上传到指定的桶中。图片作者。</p></figure><p id="27de" class="pw-post-body-paragraph kj kk ir km b kn ko js kp kq kr jv ks lg ku kv kw lh ky kz la li lc ld le lf ik bi translated">如果一切顺利，您可以在云功能页面的<code class="fe mt mu mv mw b">LOGS</code>中看到新的日志条目。它们是脚本的标准输出(图8。).</p><figure class="lk ll lm ln gu lo gi gj paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gi gj pa"><img src="../Images/fb8c166a2a31977edbca8ace819bd087.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-zVORjYzYryNFd_imFWeWA.png"/></div></div><p class="lv lw gk gi gj lx ly bd b be z dk translated">图8。成功执行管道的日志。图片作者。</p></figure><p id="1c23" class="pw-post-body-paragraph kj kk ir km b kn ko js kp kq kr jv ks lg ku kv kw lh ky kz la li lc ld le lf ik bi translated">你可以查看你的运营商的电子邮件。一封包含路由说明的新电子邮件应该很快就会到达(图9。).</p><figure class="lk ll lm ln gu lo gi gj paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gi gj pb"><img src="../Images/cc6b1bfe6397c95a2b1814a32f0caf6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pNYZwQqijmUmHj0eIs73MQ.png"/></div></div><p class="lv lw gk gi gj lx ly bd b be z dk translated">图9。带有路线说明的电子邮件。图片作者。</p></figure><h1 id="aa21" class="nj nc ir bd nk nl nm nn no np nq nr ns jx nt jy nu ka nv kb nw kd nx ke ny nz bi translated">5.为持续部署设置云构建</h1><p id="0c19" class="pw-post-body-paragraph kj kk ir km b kn oa js kp kq ob jv ks lg oc kv kw lh od kz la li oe ld le lf ik bi translated">使用云构建建立一个连续部署(CD)管道是非常容易的，这样新的修改就可以被自动和立即地部署。首先，建立一个Github存储库，并用这三个文件初始化它。或者你可以直接转到我的知识库。你还需要<a class="ae lz" href="https://medium.com/ci-t/how-to-set-up-a-deployment-pipeline-on-gcp-with-cloud-build-and-cloud-functions-88ef485728f9" rel="noopener">先启用</a><code class="fe mt mu mv mw b"><a class="ae lz" href="https://medium.com/ci-t/how-to-set-up-a-deployment-pipeline-on-gcp-with-cloud-build-and-cloud-functions-88ef485728f9" rel="noopener">Cloud Resource Manager</a></code><a class="ae lz" href="https://medium.com/ci-t/how-to-set-up-a-deployment-pipeline-on-gcp-with-cloud-build-and-cloud-functions-88ef485728f9" rel="noopener">API</a>。</p><figure class="lk ll lm ln gu lo gi gj paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gi gj pc"><img src="../Images/f3aa2c847805234bf0d1c8fbd3ec4093.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ehnucUzphPKfOLLmm6hd1Q.png"/></div></div><p class="lv lw gk gi gj lx ly bd b be z dk translated">图10。云构建触发器设置。图片作者。</p></figure><p id="2665" class="pw-post-body-paragraph kj kk ir km b kn ko js kp kq kr jv ks lg ku kv kw lh ky kz la li lc ld le lf ik bi translated">接下来，导航到<code class="fe mt mu mv mw b">Cloud Build</code>页面。创建一个名为<code class="fe mt mu mv mw b">CICD-delivery</code>的触发器。选择你的Github库和<code class="fe mt mu mv mw b">Source</code>的<code class="fe mt mu mv mw b">^master$</code>分支(你需要按照GCP的指示连接你的Github库)。选择<code class="fe mt mu mv mw b">Cloud Build configuration file (YAML or JSON)</code>，点击<code class="fe mt mu mv mw b">CREATE</code>。最后，在Settings选项卡中，启用<code class="fe mt mu mv mw b">Cloud Functions Developer</code>角色。</p><p id="4b80" class="pw-post-body-paragraph kj kk ir km b kn ko js kp kq kr jv ks lg ku kv kw lh ky kz la li lc ld le lf ik bi translated">然后，确保文件<code class="fe mt mu mv mw b">cloudbuild.yaml</code>位于您的存储库的顶层，并且包含以下内容:</p><figure class="lk ll lm ln gu lo"><div class="bz fq l di"><div class="of og l"/></div></figure><p id="a49a" class="pw-post-body-paragraph kj kk ir km b kn ko js kp kq kr jv ks lg ku kv kw lh ky kz la li lc ld le lf ik bi translated">该文件指示Cloud Build使用正确的区域、存储桶触发器和运行时来部署应用程序。从现在开始，每当你向存储库推送新的变更时，GCP将自动构建管道并将其部署为云功能。</p></div><div class="ab cl pd pe hv pf" role="separator"><span class="pg bw bk ph pi pj"/><span class="pg bw bk ph pi pj"/><span class="pg bw bk ph pi"/></div><div class="ik il im in io"><h1 id="e9d4" class="nj nc ir bd nk nl pk nn no np pl nr ns jx pm jy nu ka pn kb nw kd po ke ny nz bi translated">结论</h1><p id="623e" class="pw-post-body-paragraph kj kk ir km b kn oa js kp kq ob jv ks lg oc kv kw lh od kz la li oe ld le lf ik bi translated">成功！现在，我们有了一个简单的管道，作为递送业务的神经中枢。手动调度已经成为过去。每当您将新订单或新承运商的新Json文件上传到桶中时，云功能将自动计算最佳路线，并通知登记的承运商他们的指令。并且只有在运行时才会产生成本。此外，CD管道确保您的更改可以自动部署。</p><p id="8d74" class="pw-post-body-paragraph kj kk ir km b kn ko js kp kq kr jv ks lg ku kv kw lh ky kz la li lc ld le lf ik bi translated">承认，这个设计是我的指挥中心理念的一个基本实现。您可以在其中构建更多组件，使其更加强大。例如，一旦用完可用层配额，距离矩阵的成本可能会失控。如果我们能够将成对距离存储在数据库中，那就太好了。此外，我们可以将运营商放入一个池中，以便更好地管理他们的个人数据。</p><p id="eb7a" class="pw-post-body-paragraph kj kk ir km b kn ko js kp kq kr jv ks lg ku kv kw lh ky kz la li lc ld le lf ik bi translated">即使有了所有这些扩展，管道仍然只是一个大型现实世界优化问题的简单抽象。OR工具假设所有的订单都是已知的，并且在路线开始之前所有的承运人都已经在物流中心等待。在现实世界中，订单源源不断，承运人无处不在。但我认为，这些违规行为只会对结果产生轻微影响，管道仍然可以保持畅通。此外，距离有时并不是成本计算的最佳替代。幸运的是，距离矩阵API也返回两个地方之间的行驶时间，值得进行一些测试，看看哪个度量更好。</p><p id="2ebf" class="pw-post-body-paragraph kj kk ir km b kn ko js kp kq kr jv ks lg ku kv kw lh ky kz la li lc ld le lf ik bi translated">此外，我可以想象我们可以从这条管道中创造出非常不同的东西。因为谷歌或-Tools可以计算其他类型问题的解决方案，我们可以将管道转化为汽车共享指挥中心、公交路线设计师、班次规划服务甚至饮食计算器。</p><p id="1dbc" class="pw-post-body-paragraph kj kk ir km b kn ko js kp kq kr jv ks lg ku kv kw lh ky kz la li lc ld le lf ik bi translated">因此，现在是时候让你在这条管道上进一步构建一些东西，并向我展示你的想法。</p><div class="ma mb gq gs mc md"><a href="https://dgg32.medium.com/membership" rel="noopener follow" target="_blank"><div class="me ab fp"><div class="mf ab mg cl cj mh"><h2 class="bd is gz z fq mi fs ft mj fv fx iq bi translated">加入媒介与我的介绍链接-黄思兴</h2><div class="mk l"><h3 class="bd b gz z fq mi fs ft mj fv fx dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="ml l"><p class="bd b dl z fq mi fs ft mj fv fx dk translated">dgg32.medium.com</p></div></div><div class="mm l"><div class="pp l mo mp mq mm mr lt md"/></div></div></a></div></div></div>    
</body>
</html>