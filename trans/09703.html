<html>
<head>
<title>Fixed-Point DSP for Data Scientists</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面向数据科学家的定点DSP</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/fixed-point-dsp-for-data-scientists-d773a4271f7f?source=collection_archive---------3-----------------------#2021-09-10">https://towardsdatascience.com/fixed-point-dsp-for-data-scientists-d773a4271f7f?source=collection_archive---------3-----------------------#2021-09-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="ce11" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">了解如何使用C/C++和Arm的CMSIS-DSP库在Python中创建DSP管道，并将其转换为在基于Arm Cortex-M的MCU上运行。</h2></div><p id="443d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">作者</strong> : <a class="ae lb" href="https://twitter.com/sandeepmistry" rel="noopener ugc nofollow" target="_blank">桑德普·米斯特里</a>，<a class="ae lb" href="https://twitter.com/henriwoodcock" rel="noopener ugc nofollow" target="_blank">亨利·伍德库克</a>代表<a class="ae lb" href="https://twitter.com/ArmSoftwareDev" rel="noopener ugc nofollow" target="_blank"> Arm软件开发团队</a></p><h1 id="8c0f" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">介绍</h1><p id="1e49" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">当在音频系统中应用机器学习(ML)时，通常使用数字信号处理(DSP)技术将输入音频信号转换成2D“图像”，从而可以使用计算机视觉技术对音频进行分类。现实世界中的例子包括<a class="ae lb" href="https://www.tensorflow.org/tutorials/audio/simple_audio" rel="noopener ugc nofollow" target="_blank">音频或语音识别</a>，以及关键词识别。</p><p id="da40" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">本指南将使用<a class="ae lb" href="https://www.python.org/" rel="noopener ugc nofollow" target="_blank"> Python </a>和<a class="ae lb" href="https://numpy.org/" rel="noopener ugc nofollow" target="_blank"> NumPy </a>代码示例向您介绍这些系统中使用的DSP技术。一旦您熟悉了这些DSP技术，我们将介绍如何使用Python中的<a class="ae lb" href="https://arm-software.github.io/CMSIS_5/DSP/html/index.html" rel="noopener ugc nofollow" target="_blank"> Arm的CMSIS-DSP库</a>来使用定点数学执行相同的操作。</p><p id="a049" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，我们将演示如何用C语言创建一个等效的流水线，以便将其部署到基于<a class="ae lb" href="https://developer.arm.com/ip-products/processors/cortex-m" rel="noopener ugc nofollow" target="_blank"> Arm Cortex-M </a>的微控制器(MCU)上。<strong class="kh ir">在基于Arm Cortex-M的系统上使用定点数学可以大幅减少内存使用，同时提高运行时性能！</strong></p><p id="0c43" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">本指南的Jupyter笔记本版本也可以在GitHub 上找到，也可以使用Google Colab 访问。</p><h2 id="b7e5" class="lz ld iq bd le ma mb dn li mc md dp lm ko me mf lo ks mg mh lq kw mi mj ls mk bi translated">目录:</h2><ul class=""><li id="0a60" class="ml mm iq kh b ki lu kl lv ko mn ks mo kw mp la mq mr ms mt bi translated"><a class="ae lb" href="#a615" rel="noopener ugc nofollow">音频频谱图</a></li><li id="f309" class="ml mm iq kh b ki mu kl mv ko mw ks mx kw my la mq mr ms mt bi translated"><a class="ae lb" href="#de0e" rel="noopener ugc nofollow">Python中的音频声谱图</a></li><li id="cf78" class="ml mm iq kh b ki mu kl mv ko mw ks mx kw my la mq mr ms mt bi translated"><a class="ae lb" href="#5e1a" rel="noopener ugc nofollow">使用CMSIS-DSP的音频频谱图</a></li><li id="142a" class="ml mm iq kh b ki mu kl mv ko mw ks mx kw my la mq mr ms mt bi translated"><a class="ae lb" href="#f9a4" rel="noopener ugc nofollow">不同音频声音的声谱图示例</a></li><li id="757a" class="ml mm iq kh b ki mu kl mv ko mw ks mx kw my la mq mr ms mt bi translated"><a class="ae lb" href="#2960" rel="noopener ugc nofollow">将CMSIS-DSP代码从Python移植到C语言</a></li><li id="bdeb" class="ml mm iq kh b ki mu kl mv ko mw ks mx kw my la mq mr ms mt bi translated"><a class="ae lb" href="#5ad1" rel="noopener ugc nofollow">结论</a></li></ul><h1 id="a615" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">音频频谱图</h1><p id="9653" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">在这本笔记本中，我们将在NumPy和CMSIS-DSP中开发一个<em class="mz">音频声谱图</em>管道。这是用于音频数据的常见预处理管道。原始音频样本被转换成音频信号的可视表示，其显示频率随时间的变化。它通常被描绘成2D的形象。</p><p id="7b83" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">关于spectrograms更深入的解释，可以看看关于音频识别的TensorFlow <a class="ae lb" href="https://www.tensorflow.org/tutorials/audio/simple_audio#spectrogram" rel="noopener ugc nofollow" target="_blank">教程</a>。</p><p id="b7c8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了将音频信号转换到频域，使用了快速傅立叶变换(FFT)。这将按时间将幅度表示的音频信号转换到频域，因此您可以了解信号中包含的频率。然而，当对整个音频信号执行FFT时，您将丢失该音频信号的时域信息，为了抵消这一点，我们将音频分解为单独的片段。</p><h2 id="ae89" class="lz ld iq bd le ma mb dn li mc md dp lm ko me mf lo ks mg mh lq kw mi mj ls mk bi translated">光谱图步骤</h2><p id="9853" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">创建光谱图可分为以下步骤:</p><ol class=""><li id="a5b9" class="ml mm iq kh b ki kj kl km ko na ks nb kw nc la nd mr ms mt bi translated">音频信号被分解成称为“窗口”的更短的片段。这意味着当我们稍后应用FFT时，我们仍然保留一些时间信息，因为我们知道每个窗口出现的时间点。将音频信号分割成多个窗口时，窗口之间通常会有一些重叠，以帮助保持输出更加连续。</li><li id="55c5" class="ml mm iq kh b ki mu kl mv ko mw ks mx kw my la nd mr ms mt bi translated">然后将<em class="mz">窗口函数</em>应用于每个窗口。将我们的信号分解成重叠的窗口会给我们留下音频信号的不连续性，这将不能准确地表示真实世界的音频信号。为了减少这种影响，窗口函数将通过将窗口乘以0和1之间的平滑对称曲线来平滑每个窗口的幅度边缘。</li><li id="f942" class="ml mm iq kh b ki mu kl mv ko mw ks mx kw my la nd mr ms mt bi translated">然后用FFT将每个窗口转换到频域。因为FFT产生复数输出，所以从该输出中取出<em class="mz">绝对值</em>以保留幅度信息，但移除复数。</li><li id="1d39" class="ml mm iq kh b ki mu kl mv ko mw ks mx kw my la nd mr ms mt bi translated">最后，创建一个称为频谱图的2D阵列，其大小为(窗口数、FFT仓)。</li></ol><p id="b66c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们选择了一些示例音频输入及其音频频谱图，如下所示:</p><figure class="nf ng nh ni gt nj gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi ne"><img src="../Images/3a96e41198d184a9d1f4fdd4aa50e2bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*Ub-o0dMCvR2Ef9AoZd9w3w.gif"/></div></div></figure><h1 id="de0e" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">Python中的音频频谱图</h1><p id="e99e" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">现在你已经对什么是音频声谱图有了一个大概的了解，我们将通过Python和Numpy从一个预先录制的wave文件中创建一个声谱图。</p><h2 id="e1d4" class="lz ld iq bd le ma mb dn li mc md dp lm ko me mf lo ks mg mh lq kw mi mj ls mk bi translated">安装Python模块</h2><p id="f13d" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">您需要使用<code class="fe nq nr ns nt b">pip</code>安装<a class="ae lb" href="https://numpy.org/" rel="noopener ugc nofollow" target="_blank"> NumPy </a>、<a class="ae lb" href="https://matplotlib.org/" rel="noopener ugc nofollow" target="_blank"> Matplotlib </a>、<a class="ae lb" href="https://www.scipy.org/" rel="noopener ugc nofollow" target="_blank"> SciPy </a>和<a class="ae lb" href="https://requests.readthedocs.io/" rel="noopener ugc nofollow" target="_blank"> requests </a> Python模块:</p><pre class="nf ng nh ni gt nu nt nv nw aw nx bi"><span id="4a2d" class="lz ld iq nt b gy ny nz l oa ob">pip install numpy scipy matplotlib requests</span></pre><h2 id="ae3d" class="lz ld iq bd le ma mb dn li mc md dp lm ko me mf lo ks mg mh lq kw mi mj ls mk bi translated">下载样本音频文件</h2><p id="5ebe" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">我们将使用来自<a class="ae lb" href="https://github.com/karolpiczak/ESC-50" rel="noopener ugc nofollow" target="_blank">“ESC-50:环境声音分类数据集”GitHub repo </a>的“敲门”<code class="fe nq nr ns nt b">.wav</code>文件作为笔记本中DSP管道的输入信号。您可以使用Python的<code class="fe nq nr ns nt b">requests</code>库从GitHub下载<code class="fe nq nr ns nt b">.wav</code>文件:</p><figure class="nf ng nh ni gt nj"><div class="bz fp l di"><div class="oc od l"/></div></figure><h2 id="087b" class="lz ld iq bd le ma mb dn li mc md dp lm ko me mf lo ks mg mh lq kw mi mj ls mk bi translated">从样本音频文件中读取数据</h2><p id="f0f8" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">SciPy的<code class="fe nq nr ns nt b"><a class="ae lb" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.io.wavfile.read.html" rel="noopener ugc nofollow" target="_blank">scipy.io.wavfile.read(...)</a></code> API现在可以用来从<code class="fe nq nr ns nt b">.wav</code>文件中读取音频样本。</p><p id="0a38" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe nq nr ns nt b">.wav</code>文件的采样率为44.1 kHz，这意味着每1秒钟的音频由44100个样本表示。由于44.1 kHz采样率包含的分辨率超过了我们的需求，我们将使用SciPy的<code class="fe nq nr ns nt b"><a class="ae lb" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.resample.html" rel="noopener ugc nofollow" target="_blank">scipy.signal.resample(...)</a></code> API将音频数据的采样率从44.1 kHz降低到16 kHz，以减少分析中使用的样本数量。</p><figure class="nf ng nh ni gt nj"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="a56f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们已经从<code class="fe nq nr ns nt b">.wav</code>文件中读取了音频样本，让我们使用Matplotlib绘制一段时间内的音频信号:</p><figure class="nf ng nh ni gt nj gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/fd0862d5acad5a018588d252221611ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1032/format:webp/1*gXX9H-9CAbCz3NBbkWUilw.png"/></div></figure><p id="e411" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您也可以在您的电脑上下载并收听1–103995-A-30 . wav文件。</p><p id="e918" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">根据整个音频信号的图表，播放声音，我们知道开始时有大约1秒钟的声音，然后是寂静。让我们放大并使用Matplotlib仅绘制前1秒的音频信号，以便更仔细地观察:</p><figure class="nf ng nh ni gt nj gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/4ff96b499d3068973fe01efd752a6792.png" data-original-src="https://miro.medium.com/v2/resize:fit:1032/format:webp/1*0dmfgyusX25-Y1yFNyVjXQ.png"/></div></figure><h2 id="c115" class="lz ld iq bd le ma mb dn li mc md dp lm ko me mf lo ks mg mh lq kw mi mj ls mk bi translated">开窗术</h2><p id="2ae2" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">现在我们可以将音频样本分割成重叠的窗口。通常选择2的幂，例如16、32、64、128、256、512、1024或2048作为窗口大小。我们将使用大小为256的窗口，并在此时跨过音频信号128个样本。</p><figure class="nf ng nh ni gt nj gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi of"><img src="../Images/2b6616bfb982aa2ebe1d05791cd7a5d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jn-qyQGTfeoUpaGK1nEwgw.png"/></div></div></figure><p id="50a6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当前窗口在整个蓝色信号之上以绿色突出显示。你可以看到第一个窗口是从0到256，第二个窗口是从128到384 (128 + 256)，第三个窗口是从256到512，第四个窗口是从384到640。</p><p id="0801" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">的窗口总数。wav文件可以计算如下:</p><pre class="nf ng nh ni gt nu nt nv nw aw nx bi"><span id="9053" class="lz ld iq nt b gy ny nz l oa ob">number_of_windows = (len(audio_samples) - window_size) // step_size</span></pre><h2 id="8b25" class="lz ld iq bd le ma mb dn li mc md dp lm ko me mf lo ks mg mh lq kw mi mj ls mk bi translated">窗口函数和汉宁窗口</h2><p id="0aa6" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">当处理连续信号(如音频)时，在应用FFT变换之前会应用一个窗口函数，以便音频片段的边缘更平滑。窗口函数是(通常)范围在(0–1)之间的函数，可应用于窗口，如下所示:</p><p id="0671" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi">𝑦 = 𝑤𝑖𝑛𝑑𝑜𝑤_𝑓𝑢𝑛𝑐𝑡𝑖𝑜𝑛 × 𝑤𝑖𝑛𝑑𝑜𝑤</p><p id="ae8b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Hanning窗口是最常见的窗口函数之一(也是本例中使用的函数)。<a class="ae lb" href="https://numpy.org/doc/stable/reference/generated/numpy.hanning.html" rel="noopener ugc nofollow" target="_blank"> NumPy有一个内置的方法来计算任意窗口长度的汉宁窗口</a>:</p><pre class="nf ng nh ni gt nu nt nv nw aw nx bi"><span id="dee9" class="lz ld iq nt b gy ny nz l oa ob"><strong class="nt ir">import</strong> numpy <strong class="nt ir">as</strong> np</span><span id="bfe4" class="lz ld iq nt b gy og nz l oa ob">hanning_window = np.hanning(window_size)</span></pre><p id="79b3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们使用Matplotlib绘制汉宁窗口:</p><figure class="nf ng nh ni gt nj gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/07587207a2431ce329f6e1cc43c7b2e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:956/format:webp/1*UEFGkEfv4Yt8fU0RCPPCGw.png"/></div></figure><p id="d464" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，汉宁窗口可以应用于第一音频信号窗口，使用:</p><pre class="nf ng nh ni gt nu nt nv nw aw nx bi"><span id="d3a5" class="lz ld iq nt b gy ny nz l oa ob">window_1 <strong class="nt ir">=</strong> audio_samples[0:window_size]</span><span id="7cce" class="lz ld iq nt b gy og nz l oa ob">processed_window_1 <strong class="nt ir">=</strong> hanning_window <strong class="nt ir">*</strong> window_1</span></pre><p id="cb20" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们可以使用Matplotlib绘制第一个窗口和已处理的窗口</p><figure class="nf ng nh ni gt nj gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/187a49f9a86627f069d5c323cc3b6662.png" data-original-src="https://miro.medium.com/v2/resize:fit:978/format:webp/1*TyQu3pNEQRu3bcXVZ_02wQ.png"/></div></figure><p id="2aaf" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">可以看到，在整个窗口周期内，经过处理的窗口幅度从未超过汉宁窗口的值。</p><p id="3c48" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们扩展我们的图表，通过前几个窗口进行循环。</p><figure class="nf ng nh ni gt nj gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi oj"><img src="../Images/37611fbc9ee38806807b3374f917623c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*wbZQ3qlV4wTghAyXYD1sFA.gif"/></div></div></figure><h2 id="4bfc" class="lz ld iq bd le ma mb dn li mc md dp lm ko me mf lo ks mg mh lq kw mi mj ls mk bi translated">快速傅里叶转换（同fast Fourier transform）</h2><p id="6f7d" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">对于每个已处理的窗口，可以使用NumPy的<code class="fe nq nr ns nt b"><a class="ae lb" href="https://numpy.org/doc/stable/reference/generated/numpy.fft.rfft.html" rel="noopener ugc nofollow" target="_blank">np.fft.rfft(...)</a></code> API计算FFT，并使用<code class="fe nq nr ns nt b"><a class="ae lb" href="https://numpy.org/doc/stable/reference/generated/numpy.absolute.html" rel="noopener ugc nofollow" target="_blank">np.absolute(...)</a></code>获取FFT的绝对值:</p><pre class="nf ng nh ni gt nu nt nv nw aw nx bi"><span id="ef5e" class="lz ld iq nt b gy ny nz l oa ob"><em class="mz"># Calculate the FFT.<br/></em>fft_1 <strong class="nt ir">=</strong> np.fft.rfft(processed_window_1)</span><span id="fed8" class="lz ld iq nt b gy og nz l oa ob"><em class="mz"># Take the absolute value.<br/></em>fft_bins_1 <strong class="nt ir">=</strong> np.absolute(fft_1)</span></pre><p id="5842" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们可以使用Matplotlib绘制FFT频段。</p><figure class="nf ng nh ni gt nj gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/f4215d9268da30a239fc0149ceff0acc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1014/format:webp/1*VOXjlY5Kq91zkCEikzaGOg.png"/></div></figure><p id="2233" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们绘制前4个窗口随时间变化的FFT图，以便了解音频信号的频率成分如何随时间变化:</p><figure class="nf ng nh ni gt nj gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi ol"><img src="../Images/0a4b47a1af4277079f92c173781edfc2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RZ2W7QGfpjjIny3BqY7TSg.png"/></div></div></figure><h1 id="eea6" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">光谱图</h1><p id="79d5" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">我们可以创建一个单独的音频信号频域2D图，作为热图，也称为频谱图，而不是每个窗口周期随时间变化的单独FFT图。该频谱图在x轴上显示时间，在y轴上显示频率，最后用颜色显示振幅。</p><p id="d296" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们以重叠的步长和窗口大小遍历所有样本，计算信号随时间变化的频率，以显示为频谱图。这里我们计算1秒钟音频中的窗口数量。</p><figure class="nf ng nh ni gt nj"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="b90d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们已经计算了音频信号的频谱图，让我们绘制它:</p><figure class="nf ng nh ni gt nj gh gi paragraph-image"><div class="gh gi om"><img src="../Images/2a282dc0ef04a4a465286e30c53b70e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:916/format:webp/1*pf1eMngFr9IZ0AfKTEu3nA.png"/></div></figure><p id="5586" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从频谱图中，我们可以清楚地看到每个爆震的5个感兴趣的区域，频率低于4000 Hz的更普遍。</p><p id="8468" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们放大声谱图的下半部分，仔细看看:</p><figure class="nf ng nh ni gt nj gh gi paragraph-image"><div class="gh gi om"><img src="../Images/2c5be64b106836b887d14aafb7689379.png" data-original-src="https://miro.medium.com/v2/resize:fit:916/format:webp/1*eUvkn-SwR5Wq_kum2gLhvQ.png"/></div></figure><p id="6a52" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们再画一张图，但在声谱图上方加上时域中的信号。这样，我们可以看到信号幅度和频率计数与时间的相关性。</p><figure class="nf ng nh ni gt nj gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi on"><img src="../Images/55f7db4e3bdbbccb2a9f6da1aca3bbe7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y8W5T2G3d12Hcmbvut34AA.png"/></div></div></figure><h2 id="2501" class="lz ld iq bd le ma mb dn li mc md dp lm ko me mf lo ks mg mh lq kw mi mj ls mk bi translated">概述</h2><p id="e118" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">让我们回顾一下迄今为止我们所取得的成就:</p><ol class=""><li id="0c6d" class="ml mm iq kh b ki kj kl km ko na ks nb kw nc la nd mr ms mt bi translated">使用请求库从GitHub下载了一个敲门声音的. wav文件。</li><li id="738b" class="ml mm iq kh b ki mu kl mv ko mw ks mx kw my la nd mr ms mt bi translated">使用SciPy库从44.1 kHz的. wav文件中读入音频样本，并对它们进行重新采样，以获得16 kHz的采样速率。</li><li id="415d" class="ml mm iq kh b ki mu kl mv ko mw ks mx kw my la nd mr ms mt bi translated">理解什么是窗口，为什么需要窗口函数，比如汉宁窗口。</li><li id="d2bf" class="ml mm iq kh b ki mu kl mv ko mw ks mx kw my la nd mr ms mt bi translated">学习了如何在特定窗口周期内创建音频信号的FFT。</li><li id="e5f6" class="ml mm iq kh b ki mu kl mv ko mw ks mx kw my la nd mr ms mt bi translated">通过在一段时间内跨越音频信号、应用汉宁窗口并对每个窗口周期使用FFT函数来创建音频信号的频谱图表示。</li></ol><h1 id="5e1a" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">CMSIS-DSP音频频谱图</h1><p id="369d" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">现在您已经了解了如何使用NumPy创建音频频谱图，我们可以使用带有定点数学的CMSIS-DSP Python包装器做同样的事情。</p><h2 id="8ad7" class="lz ld iq bd le ma mb dn li mc md dp lm ko me mf lo ks mg mh lq kw mi mj ls mk bi translated">定点数学和CMSIS-DSP简介</h2><p id="1ca3" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">与浮点运算不同，定点数学数字以较低的精度表示实数，因为它们有固定的位数来表示小数点前后的数字。比如我们有一个1.15定点格式的16位数，这个16位的值可以代表-1到1之间的一个值，固定精度为<code class="fe nq nr ns nt b">1 / 2^15</code> = <code class="fe nq nr ns nt b">0.000030517578125</code>。</p><p id="3f05" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Arm Cortex-M处理器在基于整数的计算方面比浮点运算更快。Arm Cortex-M4、Cortex-M7和更高版本的处理器支持单指令多数据(SIMD)指令，允许它们一次对多个值执行相同的指令。CMSIS-DSP库利用这些SIMD指令实现更高性能的DSP处理。</p><p id="68e0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Arm的CMSIS-DSP库包含针对Arm Cortex-M处理器常见DSP操作的高度优化实现。</p><h2 id="ae96" class="lz ld iq bd le ma mb dn li mc md dp lm ko me mf lo ks mg mh lq kw mi mj ls mk bi translated">CMSIS-DSP Python包装器</h2><p id="955b" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">一般来说，在Arm Cortex-M设备上使用C或C++来使用CMSIS-DSP库。然而，<a class="ae lb" href="https://github.com/ARM-software/CMSIS_5/tree/develop/CMSIS/DSP/PythonWrapper" rel="noopener ugc nofollow" target="_blank"> CMSIS-DSP团队已经创建了一个Python包装器</a>来利用Python中的这些DSP功能。</p><p id="eeda" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该库包含针对Arm Cortex-M处理器的高度优化的DSP功能实现和针对非Arm处理器的通用C实现。如果您在PC(可能基于x86)上使用Arm CMSIS-DSP Python包装器，则从输入和输出角度来看，这些函数的行为将与它们在Arm处理器上的行为相同，但是您可能看不到运行时性能的提高。</p><p id="6988" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们继续安装CMSIS-DSP Python包装器:</p><pre class="nf ng nh ni gt nu nt nv nw aw nx bi"><span id="b422" class="lz ld iq nt b gy ny nz l oa ob">pip install git+<a class="ae lb" href="https://github.com/ARM-software/CMSIS_5.git@5.8.0-rc#egg=CMSISDSP\&amp;subdirectory=CMSIS/DSP/PythonWrapper" rel="noopener ugc nofollow" target="_blank">https://github.com/ARM-software/CMSIS_5.git@5.8.0#egg=CMSISDSP\&amp;subdirectory=CMSIS/DSP/PythonWrapper</a></span></pre><h2 id="ee3b" class="lz ld iq bd le ma mb dn li mc md dp lm ko me mf lo ks mg mh lq kw mi mj ls mk bi translated">量化输入信号</h2><p id="cea6" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">我们可以使用CMSIS-DSP的<code class="fe nq nr ns nt b"><a class="ae lb" href="https://arm-software.github.io/CMSIS_5/DSP/html/group__float__to__x.html#gac7696e64963e5051ebb950c88c6ba186" rel="noopener ugc nofollow" target="_blank">arm_float_to_q15(..,)</a></code>函数将浮点值转换为16位定点(Q15)值:</p><pre class="nf ng nh ni gt nu nt nv nw aw nx bi"><span id="6d2b" class="lz ld iq nt b gy ny nz l oa ob"><strong class="nt ir">from</strong> cmsisdsp <strong class="nt ir">import</strong> arm_float_to_q15</span><span id="baa1" class="lz ld iq nt b gy og nz l oa ob">audio_samples_q15 = arm_float_to_q15(audio_samples)</span></pre><p id="f2b8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，让我们将定点值与原始数值一起绘制成图表:</p><figure class="nf ng nh ni gt nj gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi oo"><img src="../Images/763c2954d6acee27543b45ac93d9b8e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XUHHQpyP38aCQUzHml-yXQ.png"/></div></div></figure><p id="2d4f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可以看到信号的形状与使用NumPy创建的信号相似，但是Y轴上的值的范围是从-32768到32767，而不是从0到1。</p><h2 id="a1e5" class="lz ld iq bd le ma mb dn li mc md dp lm ko me mf lo ks mg mh lq kw mi mj ls mk bi translated">CMSIS-DSP中的汉宁窗口</h2><p id="1a00" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">CMSIS-DSP没有为特定窗口大小创建汉宁窗口的内置功能。然而，我们可以利用内置的<code class="fe nq nr ns nt b"><a class="ae lb" href="https://arm-software.github.io/CMSIS_5/DSP/html/group__cos.html#gace15287f9c64b9b4084d1c797d4c49d8" rel="noopener ugc nofollow" target="_blank">arm_cos_f32(...)</a></code>和<code class="fe nq nr ns nt b">arm_float_to_q15(...)</code> API来创建一个定点汉宁窗口。让我们用<a class="ae lb" href="https://en.wikipedia.org/wiki/Hann_function" rel="noopener ugc nofollow" target="_blank">汉恩函数</a>的公式来做这个:</p><figure class="nf ng nh ni gt nj gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi op"><img src="../Images/4b64addf541a8e5997c79b3eb9b30e47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OniVxcmKoYgyj7kwODmFIQ.png"/></div></div></figure><figure class="nf ng nh ni gt nj"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="d6f8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在让我们使用Matplotlib绘制Q15 Hanning窗口和NumPy Hanning窗口:</p><figure class="nf ng nh ni gt nj gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi oo"><img src="../Images/a20f32e16a239fe1dd0d71b7c41ac4fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MrvOE_0AcWyunmd6kR_1zw.png"/></div></div></figure><p id="e5d1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可以看到它的形状与使用NumPy创建的形状相似，但是值的范围是从0到32767，而不是从0到1。</p><p id="bac0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要像在NumPy中那样应用汉宁窗口，我们可以使用<code class="fe nq nr ns nt b"><a class="ae lb" href="https://arm-software.github.io/CMSIS_5/DSP/html/group__BasicMult.html#gaeeda8cdc2c7e79c8a26e905342a0bb17" rel="noopener ugc nofollow" target="_blank">arm_mult_q15(...)</a></code>乘法函数将两个长度相等的向量相乘。</p><figure class="nf ng nh ni gt nj"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="7f06" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在让我们来看看在q15格式中应用Hanning窗口后的第一个窗口:</p><figure class="nf ng nh ni gt nj gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/06f02943add24837b6bf27bdf06ea107.png" data-original-src="https://miro.medium.com/v2/resize:fit:994/format:webp/1*m1kvManlqgAZ9MIs97F_kg.png"/></div></figure><p id="a901" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们将它与NumPy值并排绘制成图表:</p><figure class="nf ng nh ni gt nj gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi oo"><img src="../Images/7b5d3be6b72797e2f8115cbc83940455.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EqigP4pjYRTz2GiOBl-jRg.png"/></div></div></figure><h2 id="2f68" class="lz ld iq bd le ma mb dn li mc md dp lm ko me mf lo ks mg mh lq kw mi mj ls mk bi translated">采用CMSIS-DSP的FFT</h2><p id="7715" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated"><a class="ae lb" href="https://arm-software.github.io/CMSIS_5/DSP/html/group__groupTransforms.html" rel="noopener ugc nofollow" target="_blank"> CMSIS-DSP为各种数据类型提供了许多FFT功能</a>:q15、q31和f32。在本例中，我们将使用<a class="ae lb" href="https://arm-software.github.io/CMSIS_5/DSP/html/group__RealFFT.html" rel="noopener ugc nofollow" target="_blank">实数FFT函数</a>。要使用CMSIS-DSP的Q15 RFFT函数，我们首先需要创建一个<code class="fe nq nr ns nt b"><a class="ae lb" href="https://arm-software.github.io/CMSIS_5/DSP/html/structarm__rfft__instance__q15.html" rel="noopener ugc nofollow" target="_blank">arm_rfft_instance_q15</a></code>实例，并用<code class="fe nq nr ns nt b"><a class="ae lb" href="https://arm-software.github.io/CMSIS_5/DSP/html/group__RealFFT.html#ga053450cc600a55410ba5b5605e96245d" rel="noopener ugc nofollow" target="_blank">arm_rfft_init_q15(...)</a></code>函数初始化它。之后，过程类似于NumPy，你可以使用<code class="fe nq nr ns nt b"><a class="ae lb" href="https://arm-software.github.io/CMSIS_5/DSP/html/group__RealFFT.html#ga00e615f5db21736ad5b27fb6146f3fc5" rel="noopener ugc nofollow" target="_blank">arm_rfft_q15(...)</a></code>函数来计算FFT和<code class="fe nq nr ns nt b"><a class="ae lb" href="https://arm-software.github.io/CMSIS_5/DSP/html/group__cmplx__mag.html#ga0488e185f4631ac029b02f1759b287cf" rel="noopener ugc nofollow" target="_blank">arm_cmplx_mag_q15(...)</a></code>来计算FFT的幅度。</p><figure class="nf ng nh ni gt nj"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="60d4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们现在可以用Matplotlib绘制Q15定点值的图形:</p><figure class="nf ng nh ni gt nj gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi oo"><img src="../Images/a281a487afe3a5fa33141991c15812ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eckkXMGnbTaxxxHNGCKv9Q.png"/></div></div></figure><p id="60fb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在让我们将<code class="fe nq nr ns nt b">fft_bins_1_q15</code> Q15的值转换为浮点值，这样我们就可以将该值与NumPy计算的值进行比较。</p><p id="d4f3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当使用256的RFFT长度时，<code class="fe nq nr ns nt b">arm_rfft_q15(...)</code>功能的输出格式将是<code class="fe nq nr ns nt b">9.7</code>(而不是<code class="fe nq nr ns nt b">1.15</code>)。<code class="fe nq nr ns nt b"><a class="ae lb" href="https://arm-software.github.io/CMSIS_5/DSP/html/group__cmplx__mag.html#ga0488e185f4631ac029b02f1759b287cf" rel="noopener ugc nofollow" target="_blank">arm_cmplx_mag_q15(...)</a></code>功能的文档说明输入值为<code class="fe nq nr ns nt b">1.15</code>格式，输出为<code class="fe nq nr ns nt b">2.14</code>格式。因此，如果我们将一个<code class="fe nq nr ns nt b">9.7</code>格式的数字传递给<code class="fe nq nr ns nt b">arm_cmplx_mag_q15(...)</code>，输出将会有一个<code class="fe nq nr ns nt b">10.6</code>的格式——这意味着它的值的范围将会从<code class="fe nq nr ns nt b">-512</code>到<code class="fe nq nr ns nt b">511</code>。</p><p id="b014" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以通过使用<code class="fe nq nr ns nt b"><a class="ae lb" href="https://arm-software.github.io/CMSIS_5/DSP/html/group__q15__to__x.html#ga5a75381e7d63ea3a3a315344615281cf" rel="noopener ugc nofollow" target="_blank">arm_q15_to_float(...)</a></code>函数将其从Q15转换为浮点数并乘以<code class="fe nq nr ns nt b">512</code> ( <code class="fe nq nr ns nt b">2^9</code>)来将<code class="fe nq nr ns nt b">10.6</code>数转换为浮点值:</p><pre class="nf ng nh ni gt nu nt nv nw aw nx bi"><span id="3962" class="lz ld iq nt b gy ny nz l oa ob"><strong class="nt ir">from</strong> cmsisdsp <strong class="nt ir">import</strong> arm_q15_to_float</span><span id="851e" class="lz ld iq nt b gy og nz l oa ob"># Let's rescale them and compare the two<br/>fft_bins_1_q15_scaled = arm_q15_to_float(fft_bins_1_q15) * 512</span></pre><p id="138e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以叠加它们，看看它们有多接近:</p><figure class="nf ng nh ni gt nj gh gi paragraph-image"><div class="gh gi or"><img src="../Images/c6522763a18f118995c90b84cc6fe885.png" data-original-src="https://miro.medium.com/v2/resize:fit:966/format:webp/1*9wHuQlKpSs5vr8HWS5Atsw.png"/></div></figure><p id="4b48" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如我们从上面看到的，两条管道产生了视觉上非常相似的特征。</p><p id="9318" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">虽然使用定点函数会丢失一些信息，但我们设法计算出了类似的形状，并在相同的频率下显示出峰值。定点函数未能计算出的频率(在2000年的右侧)，都具有非常低的振幅，表明信息损失最小。</p><h2 id="d49b" class="lz ld iq bd le ma mb dn li mc md dp lm ko me mf lo ks mg mh lq kw mi mj ls mk bi translated">CMSIS-DSP谱图</h2><p id="d7dc" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">最后，我们需要像处理NumPy一样将所有这些放在一起。</p><figure class="nf ng nh ni gt nj"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="a0d8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在让我们用Matplotlib绘制输入信号和Q15频谱图:</p><figure class="nf ng nh ni gt nj gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi os"><img src="../Images/a248d788e4f3bee5587632cd28566420.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qiUvjjDcVvOgbraxIz6M2A.png"/></div></div></figure><p id="0c9d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后将Q15谱图与NumPy版本进行比较:</p><figure class="nf ng nh ni gt nj gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi oo"><img src="../Images/539d4dc7e4f75d62f026bbaf3da9b302.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0KIpL-2ubEyda92DoIHmZA.png"/></div></div></figure><h2 id="30ab" class="lz ld iq bd le ma mb dn li mc md dp lm ko me mf lo ks mg mh lq kw mi mj ls mk bi translated">概述</h2><p id="48eb" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">正如我们所见，CMSIS-DSP管道类似于NumPy管道。让我们回顾一下我们为创建它所做的工作:</p><ol class=""><li id="63c3" class="ml mm iq kh b ki kj kl km ko na ks nb kw nc la nd mr ms mt bi translated">使用<code class="fe nq nr ns nt b">arm_float_to_q15</code>功能将音频样本转换为Q15格式。</li><li id="6d38" class="ml mm iq kh b ki mu kl mv ko mw ks mx kw my la nd mr ms mt bi translated">使用汉恩函数公式通过<code class="fe nq nr ns nt b">arm_cos_f32</code>和<code class="fe nq nr ns nt b">arm_float_to_q15</code>函数计算汉宁窗口。</li><li id="720f" class="ml mm iq kh b ki mu kl mv ko mw ks mx kw my la nd mr ms mt bi translated">学习了如何使用<code class="fe nq nr ns nt b">arm_mult_q15</code>函数乘以相同长度的向量。</li><li id="41dd" class="ml mm iq kh b ki mu kl mv ko mw ks mx kw my la nd mr ms mt bi translated">了解如何使用<code class="fe nq nr ns nt b">arm_rfft_instance_q15</code>、<code class="fe nq nr ns nt b">arm_rfft_init_q15</code>和<code class="fe nq nr ns nt b">arm_rfft_q15</code>函数在CMSIS-DSP中计算Q15 FFT。</li><li id="349d" class="ml mm iq kh b ki mu kl mv ko mw ks mx kw my la nd mr ms mt bi translated">通过在一段时间内跨越音频信号、应用汉宁窗口并对每个窗口周期使用FFT函数来创建音频信号的频谱图表示。</li></ol><h1 id="f9a4" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">不同音频声音的频谱图示例</h1><p id="4ee3" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">现在让我们来看看<a class="ae lb" href="https://github.com/karolpiczak/ESC-50" rel="noopener ugc nofollow" target="_blank"> ESC-50存储库</a>中不同音频文件的一些不同频谱图。</p><figure class="nf ng nh ni gt nj gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi oo"><img src="../Images/212b027b7f5400cb4396794d6c0b64bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SnlkFObW0-LA3OMEGHzF0Q.png"/></div></div></figure><h1 id="2960" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">将CMSIS-DSP代码从Python移植到C</h1><p id="eab7" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">现在，我们已经从上一节中对如何使用Python中的各种CMSIS-DSP API有了一个大致的了解，我们可以开始将这些API映射到C语言，以便在基于Cortex-M的系统上运行。</p><h2 id="d3a9" class="lz ld iq bd le ma mb dn li mc md dp lm ko me mf lo ks mg mh lq kw mi mj ls mk bi translated">包含</h2><p id="7964" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">第一步是在<code class="fe nq nr ns nt b">.c</code>文件的顶部添加一个<code class="fe nq nr ns nt b">#include &lt;arm_math.h&gt;</code>:</p><pre class="nf ng nh ni gt nu nt nv nw aw nx bi"><span id="cfea" class="lz ld iq nt b gy ny nz l oa ob">#include &lt;arm_math.h&gt;</span></pre><h2 id="d456" class="lz ld iq bd le ma mb dn li mc md dp lm ko me mf lo ks mg mh lq kw mi mj ls mk bi translated">常数</h2><p id="d864" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">然后我们可以为窗口和步长定义一些常量变量:</p><pre class="nf ng nh ni gt nu nt nv nw aw nx bi"><span id="2a3b" class="lz ld iq nt b gy ny nz l oa ob">const int WINDOW_SIZE <strong class="nt ir">=</strong> 256;<br/>const int STEP_SIZE   <strong class="nt ir">=</strong> 128;</span></pre><h2 id="cd2e" class="lz ld iq bd le ma mb dn li mc md dp lm ko me mf lo ks mg mh lq kw mi mj ls mk bi translated">输入信号</h2><p id="7421" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">可以声明一个全局数组变量来存储输入信号:</p><pre class="nf ng nh ni gt nu nt nv nw aw nx bi"><span id="887c" class="lz ld iq nt b gy ny nz l oa ob">q15_t input_q15[WINDOW_SIZE];</span></pre><p id="9081" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">创建光谱的输入信号可存储在<code class="fe nq nr ns nt b">input_q15</code>变量中。</p><p id="5840" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">出于测试目的，我们将其设为频率为440 Hz、采样频率为16 kHz的固定正弦波。</p><pre class="nf ng nh ni gt nu nt nv nw aw nx bi"><span id="0c83" class="lz ld iq nt b gy ny nz l oa ob">for (int i = 0; i &lt; WINDOW_SIZE; i++) {<br/>    float32_t f = sin((2 * PI * 440) / 16000 * i);<br/>    <br/>    arm_float_to_q15(&amp;f, &amp;input_q15[i], 1);<br/>}</span></pre><h2 id="62e1" class="lz ld iq bd le ma mb dn li mc md dp lm ko me mf lo ks mg mh lq kw mi mj ls mk bi translated">汉宁窗户</h2><p id="2cd8" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">对于Hanning窗口函数，必须声明一个全局数组变量来存储窗口函数值:</p><pre class="nf ng nh ni gt nu nt nv nw aw nx bi"><span id="832c" class="lz ld iq nt b gy ny nz l oa ob">q15_t hanning_window_q15[WINDOW_SIZE];</span></pre><p id="7c7d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以创建一个C函数，在运行时初始化<code class="fe nq nr ns nt b">hanning_window_q15</code>数组:</p><pre class="nf ng nh ni gt nu nt nv nw aw nx bi"><span id="399c" class="lz ld iq nt b gy ny nz l oa ob">void hanning_window_init_q15(q15_t* hanning_window_q15, size_t size) {<br/>    for (size_t i = 0; i &lt; size; i++) {<br/>        <em class="mz">// calculate the Hanning Window value for i as a float32_t</em><br/>        float32_t f = 0.5 * (1.0 - arm_cos_f32(2 * PI * i / size ));<br/>        <br/>        <em class="mz">// convert value for index i from float32_t to q15_t and<br/>        // store in window at position i</em><br/>        arm_float_to_q15(&amp;f, &amp;hanning_window_q15[i], 1);<br/>    }<br/>}</span></pre><p id="b8c1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将需要另一个变量来存储输入信号上应用的汉宁窗口的值:</p><pre class="nf ng nh ni gt nu nt nv nw aw nx bi"><span id="fd1d" class="lz ld iq nt b gy ny nz l oa ob">q15_t processed_window_q15[WINDOW_SIZE];</span></pre><p id="0621" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，我们可以对输入信号应用汉宁窗口:</p><pre class="nf ng nh ni gt nu nt nv nw aw nx bi"><span id="9080" class="lz ld iq nt b gy ny nz l oa ob"><em class="mz">// equivalent to:<br/>//   processed_window_q15 = input_q15 * hanning_window_q15</em></span><span id="b694" class="lz ld iq nt b gy og nz l oa ob">arm_mult_q15(input_q15, hanning_window_q15, processed_window_q15,<br/>             WINDOW_SIZE);</span></pre><h2 id="d39a" class="lz ld iq bd le ma mb dn li mc md dp lm ko me mf lo ks mg mh lq kw mi mj ls mk bi translated">快速傅里叶转换（同fast Fourier transform）</h2><p id="aa37" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated"><strong class="kh ir">变量</strong></p><p id="8ab8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们需要FFT实例和输出的全局变量:</p><pre class="nf ng nh ni gt nu nt nv nw aw nx bi"><span id="7160" class="lz ld iq nt b gy ny nz l oa ob">arm_rfft_instance_q15 S_q15;</span><span id="b030" class="lz ld iq nt b gy og nz l oa ob"><em class="mz">// this is twice the size because each FFT output has a real and<br/>// imaginary part</em><br/>q15_t fft_q15[WINDOW_SIZE <strong class="nt ir">*</strong> 2];</span><span id="28d7" class="lz ld iq nt b gy og nz l oa ob"><em class="mz">// this is half the size of WINDOW_SIZE becase we just need the<br/>// magnitude from the first half of the FFT output</em><br/>q15_t fft_mag_q15[WINDOW_SIZE <strong class="nt ir">/</strong> 2];</span></pre><p id="dc10" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">初始化</strong></p><p id="d135" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们需要调用<code class="fe nq nr ns nt b">arm_rfft_init_q15</code>来初始化Q15 RFFT实例:</p><pre class="nf ng nh ni gt nu nt nv nw aw nx bi"><span id="072f" class="lz ld iq nt b gy ny nz l oa ob">arm_rfft_init_q15(&amp;S_q15, WINDOW_SIZE, 0, 1);</span></pre><p id="ab01" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">执行FFT </strong></p><p id="4fc5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">执行FFT并计算FFT的输出幅度现在可以通过下式完成:</p><pre class="nf ng nh ni gt nu nt nv nw aw nx bi"><span id="c750" class="lz ld iq nt b gy ny nz l oa ob">arm_rfft_q15(&amp;S_q15, processed_window_q15, fft_q15);</span><span id="cbd9" class="lz ld iq nt b gy og nz l oa ob">arm_cmplx_mag_q15(fft_q15, fft_mag_q15, WINDOW_SIZE / 2);</span></pre><h2 id="8774" class="lz ld iq bd le ma mb dn li mc md dp lm ko me mf lo ks mg mh lq kw mi mj ls mk bi translated">将所有东西连接在一起，就像一幅Arduino草图</h2><figure class="nf ng nh ni gt nj"><div class="bz fp l di"><div class="oc od l"/></div></figure><h2 id="3cd8" class="lz ld iq bd le ma mb dn li mc md dp lm ko me mf lo ks mg mh lq kw mi mj ls mk bi translated">性能基准</h2><p id="d9f0" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">现在，让我们在以下Arduino或Arduino兼容板上对上面的Arduino草图进行基准测试:</p><ul class=""><li id="e944" class="ml mm iq kh b ki kj kl km ko na ks nb kw nc la mq mr ms mt bi translated"><a class="ae lb" href="https://store.arduino.cc/usa/nano-33-iot" rel="noopener ugc nofollow" target="_blank"> Arduino Nano 33物联网</a></li><li id="2b14" class="ml mm iq kh b ki mu kl mv ko mw ks mx kw my la mq mr ms mt bi translated"><a class="ae lb" href="https://store.arduino.cc/usa/nano-33-ble" rel="noopener ugc nofollow" target="_blank"> Arduino Nano 33 BLE </a></li><li id="3d93" class="ml mm iq kh b ki mu kl mv ko mw ks mx kw my la mq mr ms mt bi translated"><a class="ae lb" href="https://www.pjrc.com/store/teensy40.html" rel="noopener ugc nofollow" target="_blank"> Teensy 4.0 </a></li></ul><p id="4be6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们已经创建了一个等效的草图，它使用32位浮点而不是定点来与上面的定点草图进行比较。这两张草图都可以在GitHub上找到:</p><ul class=""><li id="a490" class="ml mm iq kh b ki kj kl km ko na ks nb kw nc la mq mr ms mt bi translated"><a class="ae lb" href="https://github.com/ArmDeveloperEcosystem/fixed-point-dsp-for-data-scientists/blob/main/cmsis_dsp_fft_q15/cmsis_dsp_fft_q15.ino" rel="noopener ugc nofollow" target="_blank"> cmsis_dsp_fft_q15.ino </a></li><li id="208c" class="ml mm iq kh b ki mu kl mv ko mw ks mx kw my la mq mr ms mt bi translated"><a class="ae lb" href="https://github.com/ArmDeveloperEcosystem/fixed-point-dsp-for-data-scientists/blob/main/cmsis_dsp_fft_f32/cmsis_dsp_fft_f32.ino" rel="noopener ugc nofollow" target="_blank"> cmsis_dsp_fft_f32.ino </a></li></ul><p id="0c24" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir"> RAM使用情况</strong></p><p id="b79f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们使用16位Q15而不是32位浮点时，我们应该会看到DSP运算所需的缓冲器占用一半的空间。</p><p id="7a3c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们目前的缓冲包括:</p><figure class="nf ng nh ni gt nj"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="4c2b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，对于<code class="fe nq nr ns nt b">WINDOW_SIZE = 256</code>,我们预计:</p><ul class=""><li id="bc72" class="ml mm iq kh b ki kj kl km ko na ks nb kw nc la mq mr ms mt bi translated">F32: 22 x 256 = 5632字节</li><li id="b982" class="ml mm iq kh b ki mu kl mv ko mw ks mx kw my la mq mr ms mt bi translated">Q15: 11 x 256 = 2816字节</li></ul><p id="4e6e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这说明与F32使用浮点相比，Q15使用定点需要一半的RAM。</p><p id="a62a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们编译我们的草图，我们会得到下面的“<em class="mz">全局变量使用</em>”度量。</p><figure class="nf ng nh ni gt nj"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="fd79" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">来自Arduino的值与我们期望节省的内存量完全匹配。</p><p id="52e5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">运行时速度</strong></p><p id="f144" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，让我们将两张基准测试草图上传到评估板上，看看计算单个输入窗口的FFT仓需要多长时间:</p><figure class="nf ng nh ni gt nj"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="d0d2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Arduino Nano 33物联网板基于Arm Cortex-M0+ CPU，未配备FPU(浮点单元),使用16位定点DSP流水线完成流水线的速度比32位浮点版本快11倍。基于Arm Cortex-M4F CPU并配备FPU的Arduino Nano 33 BLE性能提升了37%。最后，基于配备FPU的Arm Cortex-M7 CPU的Teensy 4.0的性能提高了26%。</p><h1 id="5ad1" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">结论</h1><p id="48b5" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">本指南概述了将音频信号转换为声谱图的DSP流水线，声谱图可以与计算机视觉技术相结合，对音频信号进行分类。我们已经解释了什么是声谱图，以及如何使用以下DSP操作用Python和NumPy从. wav文件创建声谱图:开窗、汉宁窗和FFT。之后，您了解了定点数学，以及如何利用CMSIS-DSP Python包装器通过16位定点运算创建等效频谱图，同时精度损失最小。然后，我们介绍了如何将CMSIS-DSP管道从Python移植到C，以便在基于Arm Cortex-M的设备上运行。</p><p id="a3f1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们的基准测试中，当使用定点16位操作而不是32位浮点操作时，DSP流水线所需的全局缓冲区需要的内存减少了50%。当使用定点16位操作而不是浮点操作时，Cortex-M0+(无FPU)的速度提高了11倍。当使用定点16位运算而不是浮点运算时，具有内置FPU的Cortex-M4F和Cortex-M7F系统的速度分别提高了37%和26%。这些进步令人印象深刻。使用定点还可以节省一个转换步骤，当从模拟麦克风(使用ADC)或数字麦克风读取音频输入值时，这些值(通常)会存储为16位值。</p><p id="9d62" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">欲了解更多来自<a class="ae lb" href="https://developer.arm.com/" rel="noopener ugc nofollow" target="_blank"> Arm软件开发团队</a>的博客、指南、资源、视频和笔记本，请访问:</p><ul class=""><li id="e32a" class="ml mm iq kh b ki kj kl km ko na ks nb kw nc la mq mr ms mt bi translated"><a class="ae lb" href="https://twitter.com/ArmSoftwareDev" rel="noopener ugc nofollow" target="_blank">@推特上的armsoftwardev</a></li><li id="bd00" class="ml mm iq kh b ki mu kl mv ko mw ks mx kw my la mq mr ms mt bi translated"><a class="ae lb" href="https://www.youtube.com/c/ArmSoftwareDevelopers" rel="noopener ugc nofollow" target="_blank">Arm软件开发商YouTube频道</a></li><li id="5b1b" class="ml mm iq kh b ki mu kl mv ko mw ks mx kw my la mq mr ms mt bi translated"><a class="ae lb" href="https://github.com/ArmDeveloperEcosystem" rel="noopener ugc nofollow" target="_blank">@ GitHub上的ArmDeveloperEcosystem</a></li></ul><h2 id="cc65" class="lz ld iq bd le ma mb dn li mc md dp lm ko me mf lo ks mg mh lq kw mi mj ls mk bi translated">了解更多信息</h2><p id="d4c8" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">在即将到来的<a class="ae lb" href="https://devsummit.arm.com/en?utm_source=armdevsummit&amp;utm_medium=social&amp;utm_campaign=2021_armdevsummit_mk17_arm_na_na_conv&amp;utm_content=autoiot" rel="noopener ugc nofollow" target="_blank"> Arm开发峰会</a>上提升使用tinyML的技能并获得实践经验，这是一个在10月19日至21日之间举行的为期3天的虚拟活动。该活动包括针对真实嵌入式设备的tinyML计算机视觉研讨会，以及利用基于Arm Cortex-M的MCU构建大词汇量语音控制。我们希望在那里见到你！</p><p id="24ab" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">https://devsummit.arm.com<a class="ae lb" href="https://devsummit.arm.com/en?utm_source=armdevsummit&amp;utm_medium=social&amp;utm_campaign=2021_armdevsummit_mk17_arm_na_na_conv&amp;utm_content=autoiot" rel="noopener ugc nofollow" target="_blank"/></p></div></div>    
</body>
</html>