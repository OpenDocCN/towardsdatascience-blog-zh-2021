<html>
<head>
<title>MLOps with Docker and Jenkins: Automating Machine Learning Pipelines</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">与Docker和Jenkins的MLOps:自动化机器学习管道</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/mlops-with-docker-and-jenkins-automating-machine-learning-pipelines-a3a4026c4487?source=collection_archive---------7-----------------------#2021-09-28">https://towardsdatascience.com/mlops-with-docker-and-jenkins-automating-machine-learning-pipelines-a3a4026c4487?source=collection_archive---------7-----------------------#2021-09-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="8b0b" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何用Docker将你的ML模型容器化，用Jenkins将管道自动化</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/41ce528d640fc4064b4fb9418d99a06d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*jkAQfLtHjI9kXVAK"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae kv" href="https://unsplash.com/@hdbernd?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Bernd Dittrich </a>拍摄的照片</p></figure><h1 id="f850" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">介绍</h1><p id="e002" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">这篇文章的目的是提供一个例子，说明我们如何使用Docker和Jenkins这样的DevOps工具来自动化机器学习管道。在这篇文章的最后，你将知道如何用Docker封装一个机器学习模型，并使用Jenkins创建一个管道，该管道自动处理原始数据，训练模型，并在每次我们对我们的存储库进行更改时返回测试准确性。</p><p id="9098" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这个帖子需要的所有代码都可以在<a class="ae kv" href="https://github.com/Adricarpin/MLOps-with-Docker-and-Jenkins" rel="noopener ugc nofollow" target="_blank"> Github </a>中找到。</p><p id="c543" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">对于这项任务，我们将使用<a class="ae kv" href="https://www.kaggle.com/uciml/adult-census-income" rel="noopener ugc nofollow" target="_blank">成人人口普查收入数据集</a>。目标变量是收入:一个二元变量，表示个人年收入是否超过5万英镑。</p><p id="17ec" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">📒注意:由于本文的目的是自动化机器学习管道，我们不会深入研究EDA，因为这超出了范围。如果你对此感到好奇，你可以查看这个<a class="ae kv" href="https://www.kaggle.com/adro99/from-na-ve-to-xgboost-and-ann-adult-census-income" rel="noopener ugc nofollow" target="_blank"> Kaggle笔记本</a>，但这并不是强制性的，以便了解这里做了什么。</p><p id="e087" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">好，那我们开始吧！</p><h1 id="b524" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">制定战略</h1><p id="dedf" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">在开始编码之前，我认为重要的是理解计划是什么。如果你看一下<a class="ae kv" href="https://medium.com/@adro99/mlops-with-docker-and-jenkins-automating-machine-learning-pipelines-a3a4026c4487" rel="noopener"> Github库</a>你会看到三个python脚本:通过查看它们的名字就很容易知道它们是做什么的:)。我们还有原始数据集:成人. csv和一个docker文件(我们将在后面讨论)。但现在我想让你了解这个项目的工作流程，为此，我们需要做的第一件事是了解我们的Python脚本的输入和输出是什么:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/2b579552ece15d6e0105b49c2c2eeadb.png" data-original-src="https://miro.medium.com/v2/resize:fit:902/format:webp/0*r73KQ-Sn1HaunEPY.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="a41e" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">正如我们在图中看到的，preprocessing.py将原始数据作为输入，输出处理后的数据，分成训练和测试两部分。train.py将训练处理后的数据作为输入，并输出模型和一个json文件，我们将在其中存储验证准确性。test.py将测试处理后的数据和模型作为输入，并输出一个具有测试精度的json文件。</p><p id="55b0" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">考虑到这一点，现在我们有了一堆必须按一定顺序运行的脚本，它们创建了一堆我们需要存储和访问的文件。此外，我们希望自动化所有这一过程。</p><p id="d612" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">现在，处理这个问题的最好方法是使用Docker:使用这个工具，你可以创建一个独立的环境，拥有运行你的代码所需的所有依赖关系(解决“它在我的机器上工作”的问题！)那就更容易了。一旦我们有了这些，我们就能自动处理Jenkins的所有流程。</p><p id="a979" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">Docker基于3个概念:容器、图像和Docker文件。为了与Docker合作，了解他们的工作是不可或缺的。如果你不熟悉它们，这里有一个直观的定义:</p><ul class=""><li id="013c" class="mq mr iq lq b lr mk lu ml lx ms mb mt mf mu mj mv mw mx my bi translated">容器:一个标准的软件单元，它打包了运行应用程序所需的一切(依赖项、环境变量……)</li><li id="c1cb" class="mq mr iq lq b lr mz lu na lx nb mb nc mf nd mj mv mw mx my bi translated">Dockerfile:这是一个文件，你可以在其中定义你想在容器中包含的所有内容。</li><li id="c879" class="mq mr iq lq b lr mz lu na lx nb mb nc mf nd mj mv mw mx my bi translated">图片:这是运行容器所需的蓝图。您可以通过执行Dockerfile文件来构建映像。</li></ul><p id="ee27" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">所以，为了使用Docker，你将遵循以下步骤:</p><ol class=""><li id="ad28" class="mq mr iq lq b lr mk lu ml lx ms mb mt mf mu mj ne mw mx my bi translated">定义Dockerfile文件</li><li id="0c5d" class="mq mr iq lq b lr mz lu na lx nb mb nc mf nd mj ne mw mx my bi translated">建立形象</li><li id="0339" class="mq mr iq lq b lr mz lu na lx nb mb nc mf nd mj ne mw mx my bi translated">运行集装箱</li><li id="1b0a" class="mq mr iq lq b lr mz lu na lx nb mb nc mf nd mj ne mw mx my bi translated">在容器内运行命令</li></ol><p id="bfca" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我们一步一步来。</p><h1 id="cf84" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">定义Dockerfile文件</h1><p id="55cc" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">在这里，我们必须定义运行管道所需的一切。你可以看一下<a class="ae kv" href="https://github.com/Adricarpin/MLOps-with-Docker-and-Jenkins" rel="noopener ugc nofollow" target="_blank">库</a>中的Dockerfile，但是如果你不熟悉语法，一开始可能会有些不知所措。所以我们在这里要做的是谈论我们想要在它里面指定什么，并且一步一步地看语法。</p><p id="25f0" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">首先，我们需要指定我们希望在哪里运行管道。对于大多数容器化的应用程序，人们会选择轻量级的Linux发行版，比如alpine。然而，对于我们的管道，我们将只使用一个名为<code class="fe nf ng nh ni b">jupyter/scipy-notebook</code>的jupyter图像。在Dockerfile文件中，我们指定以下命令:</p><pre class="kg kh ki kj gt nj ni nk nl aw nm bi"><span id="7155" class="nn kx iq ni b gy no np l nq nr">FROM jupyter/scipy-notebook</span></pre><p id="0d10" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">然后，我们必须安装一些软件包。为此，我们使用命令<code class="fe nf ng nh ni b">RUN</code>:</p><pre class="kg kh ki kj gt nj ni nk nl aw nm bi"><span id="9831" class="nn kx iq ni b gy no np l nq nr">USER root </span><span id="6e74" class="nn kx iq ni b gy ns np l nq nr">RUN apt-get update &amp;&amp; apt-get install -y jq </span><span id="5a61" class="nn kx iq ni b gy ns np l nq nr">RUN pip install joblib</span></pre><p id="67aa" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">📒注意:现在这可能没有多大意义，但是我们需要<code class="fe nf ng nh ni b">jq</code>来访问json文件中的值，还需要<code class="fe nf ng nh ni b">joblib</code>来序列化和反序列化模型。</p><p id="45b2" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">接下来我们要设置的是容器中文件的分布。我们想建造一个内部具有这种结构的容器:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/81f3e23bdae58c7e6fca0934aab76c39.png" data-original-src="https://miro.medium.com/v2/resize:fit:690/format:webp/0*Dp94AwHaUlenbvob.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="c8b0" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">📒注意:“工作”文件夹由Docker自动生成。我们不会在里面放任何东西。</p><p id="7ad8" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">首先，我们创建文件夹:</p><pre class="kg kh ki kj gt nj ni nk nl aw nm bi"><span id="2eda" class="nn kx iq ni b gy no np l nq nr">RUN mkdir model raw_data processed_data results</span></pre><p id="f093" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">然后我们将目录设置为环境变量(这样我们就不会在整个代码中硬编码路径)</p><pre class="kg kh ki kj gt nj ni nk nl aw nm bi"><span id="d0ef" class="nn kx iq ni b gy no np l nq nr">ENV MODEL_DIR=/home/jovyan/model</span><span id="271a" class="nn kx iq ni b gy ns np l nq nr">ENV RAW_DATA_DIR=/home/jovyan/raw_data</span><span id="8458" class="nn kx iq ni b gy ns np l nq nr">ENV PROCESSED_DATA_DIR=/home/jovyan/processed_data</span><span id="ffd2" class="nn kx iq ni b gy ns np l nq nr">ENV RESULTS_DIR=/home/jovyan/results</span><span id="d8fa" class="nn kx iq ni b gy ns np l nq nr">ENV RAW_DATA_FILE=adult.csv</span></pre><p id="dc92" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">最后，我们设置从存储库中复制脚本和原始数据的顺序。一旦我们创建了容器，它们就会被粘贴到我们的容器中。</p><pre class="kg kh ki kj gt nj ni nk nl aw nm bi"><span id="d155" class="nn kx iq ni b gy no np l nq nr">COPY adult.csv ./raw_data/adult.csv </span><span id="a155" class="nn kx iq ni b gy ns np l nq nr">COPY preprocessing.py ./preprocessing.py </span><span id="5ad7" class="nn kx iq ni b gy ns np l nq nr">COPY train.py ./train.py </span><span id="9213" class="nn kx iq ni b gy ns np l nq nr">COPY test.py ./test.py</span></pre><h1 id="e8fb" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">建立形象</h1><p id="5928" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">一旦我们指定了docker文件，我们就可以构建映像了。执行此操作的命令是:</p><pre class="kg kh ki kj gt nj ni nk nl aw nm bi"><span id="3bb8" class="nn kx iq ni b gy no np l nq nr">sudo -S docker build -t adult-model .</span></pre><p id="b3d7" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我们用<code class="fe nf ng nh ni b">-t adult-model</code> (-t代表标签)指定图像的名称，用<code class="fe nf ng nh ni b">.</code>指定Dockerfile的路径。Docker会自动选择名为“Dockerfile”的文件。</p><h1 id="fd10" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">运行容器</h1><p id="f0c2" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">现在我们有了一个图像(一个容器的蓝图)，我们可以构建一个容器了！</p><p id="ad5c" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">📒注意:我们将只构建一个容器，但是如果你不知道，一旦我们有了一个图像，我们就可以构建任意多的容器了！这带来了广泛的可能性。</p><p id="0a17" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">运行容器的命令如下:</p><pre class="kg kh ki kj gt nj ni nk nl aw nm bi"><span id="0be5" class="nn kx iq ni b gy no np l nq nr">sudo -S docker run -d --name model adult-model</span></pre><p id="e1d6" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">其中-d标志表示分离(在后台运行容器)。我们将其命名为“模型”，并指定我们使用的图像(成人模型)。</p><h1 id="b15c" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">在容器内运行命令</h1><p id="7ca3" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">现在我们已经运行了我们的容器，我们可以通过使用<code class="fe nf ng nh ni b">docker exec</code>在里面运行命令。在这个项目中，我们需要按顺序执行脚本，然后显示结果。我们可以通过以下命令来实现:</p><ul class=""><li id="cf85" class="mq mr iq lq b lr mk lu ml lx ms mb mt mf mu mj mv mw mx my bi translated">运行预处理. py</li></ul><pre class="kg kh ki kj gt nj ni nk nl aw nm bi"><span id="c968" class="nn kx iq ni b gy no np l nq nr">sudo -S docker container exec model python3 preprocessing.py</span></pre><ul class=""><li id="0392" class="mq mr iq lq b lr mk lu ml lx ms mb mt mf mu mj mv mw mx my bi translated">运行train.py</li></ul><pre class="kg kh ki kj gt nj ni nk nl aw nm bi"><span id="0f0e" class="nn kx iq ni b gy no np l nq nr">sudo -S docker container exec model python3 train.py</span></pre><ul class=""><li id="ac08" class="mq mr iq lq b lr mk lu ml lx ms mb mt mf mu mj mv mw mx my bi translated">运行test.py</li></ul><pre class="kg kh ki kj gt nj ni nk nl aw nm bi"><span id="dd15" class="nn kx iq ni b gy no np l nq nr">sudo -S docker container exec model python3 test.py</span></pre><ul class=""><li id="285c" class="mq mr iq lq b lr mk lu ml lx ms mb mt mf mu mj mv mw mx my bi translated">显示验证准确性和测试准确性</li></ul><pre class="kg kh ki kj gt nj ni nk nl aw nm bi"><span id="a812" class="nn kx iq ni b gy no np l nq nr">sudo -S docker container exec model cat \<br/>/home/jovyan/results/train_metadata.json \<br/>/home/jovyan/results/test_metadata.json</span></pre><p id="c15f" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">📒注意:如果你足够好奇(我猜你是)，你会想知道每个脚本实际上是做什么的。别担心，如果你熟悉基本的机器学习工具(这里我基本用的是熊猫和SKlearn库)，你可以打开脚本看一下代码。没什么大不了的大部分台词都被评论了。如果你想深入了解或者你正在寻找比这里显示的更复杂的模型，你可以看看<a class="ae kv" href="https://www.kaggle.com/adro99/from-na-ve-to-xgboost-and-ann-adult-census-income" rel="noopener ugc nofollow" target="_blank">这个笔记本</a>。</p><h1 id="e9d8" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">测试步骤</h1><p id="1bb4" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">在构建管道时，通常会有一个专门的步骤来测试应用程序是否构建良好，是否足以部署到生产中。在这个项目中，我们将使用一个条件语句来测试验证准确性是否高于阈值。如果是，则部署该模型。如果没有，该过程停止。执行此操作的代码如下:</p><pre class="kg kh ki kj gt nj ni nk nl aw nm bi"><span id="d34f" class="nn kx iq ni b gy no np l nq nr">val_acc=$(sudo -S docker container exec model  jq .validation_acc \ /home/jovyan/results/train_metadata.json)</span><span id="400a" class="nn kx iq ni b gy ns np l nq nr">threshold=0.8<br/><br/>if echo "$threshold &gt; $val_acc" | bc -l | grep -q 1<br/>then<br/>	echo 'validation accuracy is lower than the threshold, process stopped'<br/>else<br/>   echo 'validation accuracy is higher than the threshold'<br/>   sudo -S docker container exec model python3 test.py<br/>   sudo -S docker container exec model cat \ /home/jovyan/results/train_metadata.json \ /home/jovyan/results/test_metadata.json <br/>fi</span></pre><p id="9135" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">如您所见，首先我们设置两个想要比较的变量(验证准确性和阈值)，然后我们通过一个条件语句传递它们。如果验证准确性高于阈值，我们将为测试数据执行模型，然后我们将显示测试和验证结果。否则，该过程将停止。</p><p id="0749" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我们做到了！我们的模型是完全容器化的，我们可以运行管道中的所有步骤！</p><h2 id="148e" class="nn kx iq bd ky nu nv dn lc nw nx dp lg lx ny nz li mb oa ob lk mf oc od lm oe bi translated">Docker初学者的问题:我们所做的有什么意义？</h2><p id="4703" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">如果你不熟悉Docker，现在你可能会问:好吧，这些都是好东西，但最终我只有我的模型和我的预测。我也可以通过运行我的Python代码来获得它们，而不需要学习Docker。那么，这一切有什么意义呢？</p><p id="5ef8" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我很高兴你问了😎。</p><p id="c2b6" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">首先，将您的机器学习模型放在Docker容器中对于将该模型部署到生产环境中非常有用。举个例子，你有多少次在教程或库中看到你试图复制的代码，当在你的机器上运行相同的代码时，你的屏幕充满了红色？如果我们不愿意经历这些，想象一下我们的客户会有什么感受。有了Docker容器，这个问题就解决了。</p><p id="10c8" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">Docker真正有用的另一个原因可能与您阅读本文的原因相同:帮助自动化整个管道。</p><p id="760f" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">所以，事不宜迟，我们开门见山吧！</p><h1 id="b590" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">利用Jenkins实现ML管道的自动化</h1><p id="c207" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">对于这一步，我们将使用Jenkins，这是一个非常著名的开源自动化服务器，它提供了一系列插件来支持构建、部署和自动化任何项目。</p><p id="7e59" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这一次，我们将使用名为jobs的工具来构建管道的步骤。每项工作都将是我们工作流程中的一步。</p><p id="c485" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">📒注意:为了让事情顺利运行，您可能需要配置一些东西:</p><ul class=""><li id="b833" class="mq mr iq lq b lr mk lu ml lx ms mb mt mf mu mj mv mw mx my bi translated">如果您在本地主机上使用Jenkins，那么您在尝试将Jenkins与Github连接时可能会遇到一些问题。如果是这种情况，请考虑创建一个到本地主机的安全URL。我发现最好的工具是<a class="ae kv" href="https://ngrok.com/" rel="noopener ugc nofollow" target="_blank"> ngrok </a>。</li><li id="72ce" class="mq mr iq lq b lr mz lu na lx nb mb nc mf nd mj mv mw mx my bi translated">由于jenkins使用自己的用户(称为Jenkins ),您可能需要授予它权限，以便在没有密码的情况下执行命令。你可以通过用<code class="fe nf ng nh ni b">sudo visudo /etc/sudoers</code>打开sudoers文件并粘贴<code class="fe nf ng nh ni b">jenkins ALL=(ALL) NOPASSWD: ALL</code>来实现。</li></ul><p id="6ff8" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">话虽如此，我们还是看看有什么计划吧。我们将创造4个就业机会:</p><ol class=""><li id="d32d" class="mq mr iq lq b lr mk lu ml lx ms mb mt mf mu mj ne mw mx my bi translated">“github-to-container”工作:在这项工作中，我们将Jenkins与github“连接”,每次在Github中提交时都会触发这项工作。我们还将构建Docker映像并运行一个容器。</li><li id="964d" class="mq mr iq lq b lr mz lu na lx nb mb nc mf nd mj ne mw mx my bi translated">“预处理”作业:在这一步中，我们将执行preprocessing.py脚本。该作业将由“github到容器”作业触发。</li><li id="e9ed" class="mq mr iq lq b lr mz lu na lx nb mb nc mf nd mj ne mw mx my bi translated">“train”作业:在这个作业中，我们将执行train.py脚本。该作业将由“预处理”作业触发。</li><li id="a072" class="mq mr iq lq b lr mz lu na lx nb mb nc mf nd mj ne mw mx my bi translated">“测试”工作:在这项工作中，我们将通过我们的条件语句传递验证分数。如果它高于阈值，我们将执行test.py脚本并显示元数据(验证和测试准确性)。如果验证分数低于阈值，则该过程将停止，并且不会提供元数据。</li></ol><p id="b391" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">一旦我们知道该做什么，让我们去做吧！</p><h1 id="d38c" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">创造詹金斯就业机会</h1><h2 id="04a0" class="nn kx iq bd ky nu nv dn lc nw nx dp lg lx ny nz li mb oa ob lk mf oc od lm oe bi translated">github到容器的工作</h2><p id="d8dc" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">对于github到容器的工作，首先我们需要在github和Jenkins之间创建一个“连接”。这是使用webhooks完成的。要创建Webhook，请转到Github中的存储库，选择settings并选择webhooks。选择添加webhook。在有效负载URL中，传递运行Jenkins的URL并添加“//github-webhook/”。对于内容类型，选择“应用程序/json”。对于“您希望哪个事件触发这个webhook？”，选择“仅推送事件”。在底部选择活动。选择添加webhook。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi of"><img src="../Images/d9044ad0811bee5fab440425a1ad9613.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*n3t-M1UkJdmpr3uY.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="9415" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">然后，您需要在Jenkins中创建一个凭证来访问Github。在詹金斯，转到管理詹金斯</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi og"><img src="../Images/d38c23c1a4d8e36e86f14024069904e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:424/format:webp/0*SsylwLx_fpTzByGl.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="6d4c" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">然后选择管理凭据，</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oh"><img src="../Images/d4024207782eff04e74b9e4b1c746239.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*eY-IDW1uecA8tn0e.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="ee9c" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在“Jenkins范围内的商店”中，选择Jenkins</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oi"><img src="../Images/a7a3e94a10446056eb6030e937c407a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*G7FAQ9YZH2h68P7D.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="b974" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">然后选择“全局凭证(无限制)”</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oj"><img src="../Images/4d9bc08028e0498dfa4c54e23156632d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*TtUqOU-bO79MLzZN.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="d9d5" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">并添加凭据</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/d5edde51eb936925186e4d3665d32f78.png" data-original-src="https://miro.medium.com/v2/resize:fit:838/format:webp/0*545r7b0Kff0gfQT8.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="e729" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在这里，对于范围选择“Global (Jenkins，nodes，items，all child items，etc)”，对于用户名和密码填写您的Github用户名和密码。您可以将ID留空，因为它将自动生成。您也可以添加描述。最后，单击确定。</p><p id="a193" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">现在让我们建立第一个工作！</p><p id="10fa" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在Jenkins中，转到新项目，</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/396892f2cb7c1195316aaff0dc33a297.png" data-original-src="https://miro.medium.com/v2/resize:fit:426/format:webp/0*mJrqUbh39mul6WY0.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="4546" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">然后给它起个名字，选择自由式项目。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi om"><img src="../Images/bcf59b95f4742bfee9e51a1ce2e3542b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*XHYk23WF5rKIEFEo.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="23b3" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">下一步是设置配置。对于这一步，在源代码管理中选择Git，然后粘贴您的存储库的URL和您的Github凭证。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi on"><img src="../Images/11550092997419bebf8ab679a97e1eb0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*rAKXZxXK3tMR3Swh.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="aae3" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">然后，在构建触发器中选择“GitHub hook trigger for git SCM polling”。最后在build部分选择Add build step，然后执行shell，然后编写构建映像和运行容器的代码(我们已经讨论过了):</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oo"><img src="../Images/415bfad4d914885752300197f6d9ed95.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ENVdJLPcSDR14bxx.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="b770" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">选择保存。</p><h2 id="661d" class="nn kx iq bd ky nu nv dn lc nw nx dp lg lx ny nz li mb oa ob lk mf oc od lm oe bi translated">预处理作业</h2><p id="d589" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">对于“预处理”作业，在源代码管理中将其保留为无。在“生成触发器”中，选择“在其他项目生成后生成”。然后在要监视的项目中输入第一个作业的名称，并选择“仅当构建稳定时触发”。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi op"><img src="../Images/f27fb39148c30db57a13616272609b74.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*GmSo0G2hctXK-YnA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="d69b" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在Build中，选择Add build step，然后执行shell，并编写运行preprocessing.py的代码:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oq"><img src="../Images/1918af9a25a610364733e63c2cf45321.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*tlGkn_KkLfoGwU-f.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><h2 id="9046" class="nn kx iq bd ky nu nv dn lc nw nx dp lg lx ny nz li mb oa ob lk mf oc od lm oe bi translated">火车工作</h2><p id="bf6d" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">“训练”作业与“预处理”作业的方案相同，但有一些不同。正如您可能猜到的，您需要在Build triggers部分写下第二个作业的名称:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi or"><img src="../Images/df8c5804257c8f685e7a1a04d0ff219b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*4S2-oGAPWMNNic4D.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="b668" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在构建部分编写运行train.py的代码。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi os"><img src="../Images/c1435dd75f66bfb9ee83e0e936232f05.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ZyxpbprUSfpbf9LQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><h2 id="a364" class="nn kx iq bd ky nu nv dn lc nw nx dp lg lx ny nz li mb oa ob lk mf oc od lm oe bi translated">测试工作</h2><p id="3207" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">对于“测试”作业，为构建触发器部分选择“训练”作业，</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ot"><img src="../Images/410dbb644c3b3f398e5216114db1636a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*xBT05IWtf53Ks9XM.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="bfd1" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">并在构建部分编写以下代码:</p><pre class="kg kh ki kj gt nj ni nk nl aw nm bi"><span id="94a0" class="nn kx iq ni b gy no np l nq nr">val_acc=$(sudo -S docker container exec model  jq .validation_acc \ /home/jovyan/results/train_metadata.json)</span><span id="9d57" class="nn kx iq ni b gy ns np l nq nr">threshold=0.8<br/><br/>if echo "$threshold &gt; $val_acc" | bc -l | grep -q 1<br/>then<br/>	echo 'validation accuracy is lower than the threshold, process stopped'<br/>else<br/>   echo 'validation accuracy is higher than the threshold'<br/>   sudo -S docker container exec model python3 test.py<br/>   sudo -S docker container exec model cat \ /home/jovyan/results/train_metadata.json \ /home/jovyan/results/test_metadata.json <br/>fi    <br/><br/>sudo -S docker rm -f model</span></pre><p id="7e52" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我已经写了，以防你想复制粘贴，但在詹金斯它应该是这样的:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ou"><img src="../Images/adcf91809ebff14a744fcec88e6447d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*OS40imr7rzPhbQ9l.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="1042" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">点击保存，我们就有了！我们的流水线现在完全自动化了！</p><p id="be67" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">您现在可以使用它了:尝试在Github中提交，看看每一步是如何自动进行的。最后，如果模型验证精度高于阈值，模型将计算测试精度并返回结果。</p><p id="e7b1" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">📒注意:为了查看每个步骤的输出，选择该步骤，单击左下方构建部分的第一个数字，然后选择控制台输出。对于最后一步，您应该看到验证和测试的准确性。</p><p id="52f0" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">希望你学到了很多！感谢阅读！</p></div><div class="ab cl ov ow hu ox" role="separator"><span class="oy bw bk oz pa pb"/><span class="oy bw bk oz pa pb"/><span class="oy bw bk oz pa"/></div><div class="ij ik il im in"><h2 id="7824" class="nn kx iq bd ky nu nv dn lc nw nx dp lg lx ny nz li mb oa ob lk mf oc od lm oe bi translated">参考</h2><p id="485d" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated"><a class="ae kv" href="https://mlinproduction.com/docker-for-ml-part-3/" rel="noopener ugc nofollow" target="_blank">机器学习的Docker第三部分</a></p><p id="b4cc" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><a class="ae kv" rel="noopener" target="_blank" href="/from-devops-to-mlops-integrate-machine-learning-models-using-jenkins-and-docker-79034dbedf1">从DevOps到MLOPS:使用Jenkins和Docker整合机器学习模型</a></p><p id="12d1" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><a class="ae kv" href="https://www.kaggle.com/adro99/from-na-ve-to-xgboost-and-ann-adult-census-income" rel="noopener ugc nofollow" target="_blank">从天真到XGBoost和ANN:成人人口普查收入</a></p></div></div>    
</body>
</html>