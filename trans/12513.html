<html>
<head>
<title>Implementing Naive Bayes From Scratch</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从头开始实现朴素贝叶斯</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/implementing-naive-bayes-from-scratch-df5572e042ac?source=collection_archive---------4-----------------------#2021-12-22">https://towardsdatascience.com/implementing-naive-bayes-from-scratch-df5572e042ac?source=collection_archive---------4-----------------------#2021-12-22</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><h2 id="64b5" class="is it iu bd b dl iv iw ix iy iz ja dk jb translated" aria-label="kicker paragraph">从头做起</h2><div class=""/><div class=""><h2 id="dc06" class="pw-subtitle-paragraph ka jd iu bd b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr dk translated">只用 Python 和 NumPy 编写内部工作代码</h2></div><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj ks"><img src="../Images/6d9f473138071ba27b7138de923abc7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ZT5qOsNaY0oVrPu-"/></div></div><p class="le lf gk gi gj lg lh bd b be z dk translated">照片由<a class="ae li" href="https://unsplash.com/@mikehindle?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">迈克·辛德尔</a>在<a class="ae li" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="276d" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi mf translated"><span class="l mg mh mi bm mj mk ml mm mn di">我</span>不喜欢“黑盒”。我个人有一种强烈的欲望想知道事情是如何运作的。我想摸摸它。我想修补一下。我想自己编码，即使已经存在一个即插即用的解决方案。这正是我们在这篇文章中要做的。</p><p id="3b8e" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">在接下来的部分中，我们将使用 Python 和 NumPy 一步一步地从头开始实现朴素贝叶斯分类器。</p><p id="823a" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">但是，在我们开始编码之前，让我们简单地谈谈朴素贝叶斯分类器的理论背景和假设。</p></div><div class="ab cl mo mp hy mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="in io ip iq ir"><h1 id="0755" class="mv mw iu bd mx my mz na nb nc nd ne nf kj ng kk nh km ni kn nj kp nk kq nl nm bi translated">朴素贝叶斯快速理论</h1><p id="7dfe" class="pw-post-body-paragraph lj lk iu ll b lm nn ke lo lp no kh lr ls np lu lv lw nq ly lz ma nr mc md me in bi translated">朴素贝叶斯分类器的基本原理是<em class="ns">贝叶斯定理</em>——因此得名。在我们的例子中，我们可以将贝叶斯定理表述如下:</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div class="gi gj nt"><img src="../Images/41591fa3052003f5564be3b86007be35.png" data-original-src="https://miro.medium.com/v2/resize:fit:844/0*LWS1IhtWS22a1kia"/></div></figure><p id="8010" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">我们的总体目标是用给定的数据预测一个类的条件概率。这个概率也可以称为<em class="ns">后验置信</em>。那么我们如何计算后验概率呢？</p><p id="d567" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">首先，我们需要确定数据属于某一类分布<code class="fe nu nv nw nx b">P(Data|Class)</code>的<em class="ns">可能性</em>。然后我们需要将它乘以之前的<code class="fe nu nv nw nx b">P(Class)</code><em class="ns">。为了计算先验，我们需要计算特定类的样本数<em class="ns">(行)</em>，然后除以数据集中的样本总数。</em></p><blockquote class="ny nz oa"><p id="98d9" class="lj lk ns ll b lm ln ke lo lp lq kh lr ob lt lu lv oc lx ly lz od mb mc md me in bi translated">注意:为了简化计算，我们可以省略分母，因为<code class="fe nu nv nw nx b">P(Data)</code>可以被视为一个归一化常数。然而，我们将不再收到从零到一的概率分数。</p></blockquote><p id="94dc" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">你可能会问，朴素贝叶斯有什么天真的？</p><p id="7ec1" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">朴素贝叶斯的一个重要假设是特征的独立性。这意味着，一个事件的发生不会影响另一个事件的发生。因此，这些特性之间的所有交互和关联都将被忽略。由于这个简化的前提，我们现在能够在计算具有多个特征的某个类的概率时应用<em class="ns">乘法规则</em>。</p><p id="e7fe" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">这基本上是我们从零开始实现朴素贝叶斯分类器所需要知道的全部。</p><div class="oe of gq gs og oh"><a rel="noopener follow" target="_blank" href="/deriving-bayes-theorem-the-easy-way-59f0c73496db"><div class="oi ab fp"><div class="oj ab ok cl cj ol"><h2 class="bd je gz z fq om fs ft on fv fx jd bi translated">贝叶斯定理的简易推导</h2><div class="oo l"><h3 class="bd b gz z fq om fs ft on fv fx dk translated">从基本概念到更深层次的理解</h3></div><div class="op l"><p class="bd b dl z fq om fs ft on fv fx dk translated">towardsdatascience.com</p></div></div><div class="oq l"><div class="or l os ot ou oq ov lc oh"/></div></div></a></div><div class="oe of gq gs og oh"><a rel="noopener follow" target="_blank" href="/understanding-probability-models-and-axioms-c0f498972b80"><div class="oi ab fp"><div class="oj ab ok cl cj ol"><h2 class="bd je gz z fq om fs ft on fv fx jd bi translated">理解概率模型和公理</h2><div class="oo l"><h3 class="bd b gz z fq om fs ft on fv fx dk translated">为什么还要关心样本空间、事件和概率度量？</h3></div><div class="op l"><p class="bd b dl z fq om fs ft on fv fx dk translated">towardsdatascience.com</p></div></div><div class="oq l"><div class="ow l os ot ou oq ov lc oh"/></div></div></a></div></div><div class="ab cl mo mp hy mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="in io ip iq ir"><h1 id="2381" class="mv mw iu bd mx my mz na nb nc nd ne nf kj ng kk nh km ni kn nj kp nk kq nl nm bi translated">概述</h1><p id="24e8" class="pw-post-body-paragraph lj lk iu ll b lm nn ke lo lp no kh lr ls np lu lv lw nq ly lz ma nr mc md me in bi translated">现在，我们简要地讨论了理论背景，我们可以考虑我们需要实施的不同步骤。这为我们提供了一个高层次的概述，我们可以将其用作某种蓝图。</p><ol class=""><li id="160a" class="ox oy iu ll b lm ln lp lq ls oz lw pa ma pb me pc pd pe pf bi translated"><em class="ns">拟合</em>:计算(训练)数据集中每个类的汇总统计和先验</li><li id="dc76" class="ox oy iu ll b lm pg lp ph ls pi lw pj ma pk me pc pd pe pf bi translated"><em class="ns">预测</em>:计算(测试)数据集中每个样本的每个类的概率。因此，获得给定类别(高斯)分布的数据的概率，并将其与先验结合。</li></ol><p id="cadc" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">在下面，我们将只实现一个类。下面可以看到<em class="ns">的骨架代码</em>，我们将在下一节逐步完成。</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="pl pm l"/></div></figure></div><div class="ab cl mo mp hy mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="in io ip iq ir"><h1 id="73d3" class="mv mw iu bd mx my mz na nb nc nd ne nf kj ng kk nh km ni kn nj kp nk kq nl nm bi translated">从头开始实施</h1><h2 id="504a" class="pn mw iu bd mx po pp dn nb pq pr dp nf ls ps pt nh lw pu pv nj ma pw px nl ja bi translated">拟合数据</h2><p id="1e3c" class="pw-post-body-paragraph lj lk iu ll b lm nn ke lo lp no kh lr ls np lu lv lw nq ly lz ma nr mc md me in bi translated">如概述中所述，我们需要计算每个类<em class="ns">(和特性)</em>以及先验的汇总统计数据。</p><p id="c78a" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">首先，我们需要收集数据集的一些基本信息，并创建三个零矩阵来存储每个类的均值、方差和先验。</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="pl pm l"/></div></figure><p id="d1de" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">接下来，我们迭代所有的类，计算统计数据并相应地更新我们的零矩阵。</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="pl pm l"/></div></figure><p id="0e28" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">例如，假设我们的数据集中有两个唯一的类(0，1)和两个要素。因此，存储平均值的矩阵将具有两行和两列(2x2)。每个类一行，每个功能一列。</p><p id="fd0e" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">先验只是一个向量(1x2)，包含单个类别的样本除以总样本量的比率。</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div class="gi gj py"><img src="../Images/586d8662e93cb5d695d90f6218bc21e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:686/format:webp/1*W8Uivle01iQTmKy3HIBbhA.png"/></div><p class="le lf gk gi gj lg lh bd b be z dk translated">汇总统计数据示例[图片由作者提供]</p></figure><h2 id="aafe" class="pn mw iu bd mx po pp dn nb pq pr dp nf ls ps pt nh lw pu pv nj ma pw px nl ja bi translated">做一个预测</h2><p id="5384" class="pw-post-body-paragraph lj lk iu ll b lm nn ke lo lp no kh lr ls np lu lv lw nq ly lz ma nr mc md me in bi translated">现在，稍微复杂一点的部分…</p><p id="25ad" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">为了进行预测，我们需要获得数据属于某一类的概率，或者更具体地说，来自同一分布的概率。</p><p id="a703" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">为了方便起见，我们假设数据的基本分布是高斯分布。我们创建一个类方法，它返回新样本的概率。</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div class="gi gj pz"><img src="../Images/7f08854be2cc5a63689ebbd06dea4505.png" data-original-src="https://miro.medium.com/v2/resize:fit:620/0*BxE6ZnIVfinGMU_Q"/></div><p class="le lf gk gi gj lg lh bd b be z dk translated">高斯函数。μ =均值；σ =方差；σ =标准偏差。</p></figure><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="pl pm l"/></div></figure><p id="6c0b" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">我们的方法接收单个样本并计算概率。然而，从参数中我们可以看出，我们还需要提供平均值和方差。</p><p id="a888" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">因此，我们创建另一个类方法。该方法遍历所有类，收集汇总统计数据、先验信息，并为单个样本计算新的后验置信。</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="pl pm l"/></div></figure><blockquote class="ny nz oa"><p id="ef61" class="lj lk ns ll b lm ln ke lo lp lq kh lr ob lt lu lv oc lx ly lz od mb mc md me in bi translated">请注意，我们应用了对数变换，以便通过增加概率来简化计算。我们还返回具有最高后验置信度的类索引。</p></blockquote><p id="f356" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">最后，我们可以用 predict 方法把它们联系起来。</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="pl pm l"/></div></figure></div><div class="ab cl mo mp hy mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="in io ip iq ir"><h1 id="a7e0" class="mv mw iu bd mx my mz na nb nc nd ne nf kj ng kk nh km ni kn nj kp nk kq nl nm bi translated">测试我们的分类器</h1><p id="d9ce" class="pw-post-body-paragraph lj lk iu ll b lm nn ke lo lp no kh lr ls np lu lv lw nq ly lz ma nr mc md me in bi translated">现在我们已经完成了朴素贝叶斯分类器，只剩下一件事要做了——我们需要测试它。</p><p id="1ef7" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">我们将使用虹膜数据集，它由 150 个样本组成，具有 4 个不同的特征<em class="ns">(萼片长度、萼片宽度、花瓣长度、花瓣宽度)</em>。我们的目标是在 3 种不同类型的虹膜中预测正确的类别。</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div class="gi gj qa"><img src="../Images/1d879236a5637980bb348abd20a0edf6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1218/format:webp/1*ucWGlFyRlgWMR3IcAxf8mA.png"/></div><p class="le lf gk gi gj lg lh bd b be z dk translated">通过绘制前两个特征对虹膜数据集进行概述[图片由作者提供]</p></figure><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="pl pm l"/></div></figure><p id="ccdb" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">通过运行上面的代码，我们加载并准备虹膜数据集，并训练我们的分类器。在对测试数据进行预测时，我们达到了大约 96.6%的准确率。</p><p id="356e" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">下面的混淆矩阵告诉我们，我们的分类器犯了一个错误，错误地将一类分类为二类。</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div class="gi gj qb"><img src="../Images/de3de8c4d305941195eb907cdb2643bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1066/format:webp/1*069HeoVlBa9ohAcn38AB1A.png"/></div><p class="le lf gk gi gj lg lh bd b be z dk translated">混淆矩阵(预测数量)[图片由作者提供]</p></figure></div><div class="ab cl mo mp hy mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="in io ip iq ir"><h1 id="327d" class="mv mw iu bd mx my mz na nb nc nd ne nf kj ng kk nh km ni kn nj kp nk kq nl nm bi translated">结论</h1><p id="e66b" class="pw-post-body-paragraph lj lk iu ll b lm nn ke lo lp no kh lr ls np lu lv lw nq ly lz ma nr mc md me in bi translated">在本文中，我们仅使用 Python 和 NumPy 从头实现了一个朴素贝叶斯分类器。我们了解了理论背景，并有机会以实际方式应用贝叶斯定理。</p><p id="c4e6" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">如果你不喜欢“黑盒”并且想要完全理解一个算法，从头开始实现它是获得关于内部工作的亲密和深入知识的最好方法之一。</p><p id="b286" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">你可以在我的 GitHub 上的这里找到完整的代码。</p><div class="oe of gq gs og"><div role="button" tabindex="0" class="ab bv gw cb fq qc qd bn qe lc ex"><div class="qf l"><div class="ab q"><div class="l di"><img alt="Marvin Lanhenke" class="l de bw qg qh fe" src="../Images/5b1b337a332bf18381aa650edc2190bd.png" width="20" height="20" loading="lazy" data-original-src="https://miro.medium.com/v2/resize:fill:40:40/1*iEJ9qn9i9dTw3uyXG2jsTA.jpeg"/><div class="fb bw l qg qh fc n aw fd"/></div><div class="hi l fp"><p class="bd b dl z fq fr fs ft fu fv fw fx dk translated"><a class="ae af ag ah ai aj ak al am an ao ap aq ar as" href="https://medium.com/@marvinlanhenke?source=post_page-----df5572e042ac--------------------------------" rel="noopener follow" target="_top">马文·兰亨克</a></p></div></div><div class="qk ql gx l"><h2 class="bd je vo ox fq vp fs ft on fv fx jd bi translated">从零开始的 ML 算法</h2></div><div class="ab q"><div class="l fp"><a class="bd b be z bi vq au vr vs vt sf vu an eh ei vv vw vx el em eo de bk ep" href="https://medium.com/@marvinlanhenke/list/ml-algorithms-from-scratch-7621d01922ad?source=post_page-----df5572e042ac--------------------------------" rel="noopener follow" target="_top">View list</a></div><div class="vy l fp"><span class="bd b dl z dk">6 stories</span></div></div></div><div class="qx dh qy fq ab qz fp di"><div class="di qp bv qq qr"><div class="dh l"><img alt="" class="dh" src="../Images/230471643f4baf6e91fca0422ddfb56b.png" width="194" height="194" loading="lazy" role="presentation" data-original-src="https://miro.medium.com/v2/resize:fill:388:388/1*qT41zaPnyJHQeGKz0FvkQA.png"/></div></div><div class="di qp bv qs qt qu"><div class="dh l"><img alt="" class="dh" src="../Images/ca1fa6207e26d895ef8ba30bb66ef3a2.png" width="194" height="194" loading="lazy" role="presentation" data-original-src="https://miro.medium.com/v2/resize:fill:388:388/0*67IA2OsmsNXtckdF"/></div></div><div class="di bv qv qw qu"><div class="dh l"><img alt="" class="dh" src="../Images/33c295e3ac2a12346fba6df057ae448b.png" width="194" height="194" loading="lazy" role="presentation" data-original-src="https://miro.medium.com/v2/resize:fill:388:388/0*HXXyDFWGhV7pvo8E"/></div></div></div></div></div><blockquote class="ny nz oa"><p id="9b44" class="lj lk ns ll b lm ln ke lo lp lq kh lr ob lt lu lv oc lx ly lz od mb mc md me in bi translated">感谢您的阅读！确保保持联系&amp;在<a class="ae li" href="https://medium.com/@marvinlanhenke" rel="noopener"> Medium </a>、<a class="ae li" href="https://www.kaggle.com/mlanhenke" rel="noopener ugc nofollow" target="_blank"> Kaggle </a>上关注我，或者在<a class="ae li" href="https://www.linkedin.com/in/marvin-lanhenke-11b902211/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上说声“嗨”</p></blockquote></div><div class="ab cl mo mp hy mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="in io ip iq ir"><p id="8d06" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated"><em class="ns">喜欢这篇文章吗？成为</em> <a class="ae li" href="https://medium.com/@marvinlanhenke/membership" rel="noopener"> <em class="ns">中级会员</em> </a> <em class="ns">继续无限学习。如果你使用下面的链接，我会收到你的一部分会员费，不需要你额外付费。</em></p><div class="oe of gq gs og oh"><a href="https://medium.com/@marvinlanhenke/membership" rel="noopener follow" target="_blank"><div class="oi ab fp"><div class="oj ab ok cl cj ol"><h2 class="bd je gz z fq om fs ft on fv fx jd bi translated">通过我的推荐链接加入 Medium-Marvin Lanhenke</h2><div class="oo l"><h3 class="bd b gz z fq om fs ft on fv fx dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="op l"><p class="bd b dl z fq om fs ft on fv fx dk translated">medium.com</p></div></div><div class="oq l"><div class="re l os ot ou oq ov lc oh"/></div></div></a></div></div></div>    
</body>
</html>