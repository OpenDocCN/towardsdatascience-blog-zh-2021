<html>
<head>
<title>9 Guidelines to master Scikit-learn without giving up in the middle</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">掌握Scikit的9个指南——学而不中途放弃</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/9-guidelines-to-master-scikit-learn-without-giving-up-in-the-middle-5102863d89d7?source=collection_archive---------18-----------------------#2021-04-05">https://towardsdatascience.com/9-guidelines-to-master-scikit-learn-without-giving-up-in-the-middle-5102863d89d7?source=collection_archive---------18-----------------------#2021-04-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="fb1a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">学习适合我的方法</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/efdb7855c3108773b9beb1a273c6cf5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mJQn4d4mq1jUjo-IzjpD8w.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">布拉登·科拉姆在<a class="ae ky" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><p id="41f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">毫无疑问，<strong class="lb iu"> Scikit-learn </strong>是当今最好的机器学习库之一。这有几个原因。Scikit-learn估值器之间的一致性是一个原因。你在任何其他机器学习库中都找不到这样的一致性。<strong class="lb iu">。fit()/。predict() </strong>范式最好地描述了这种一致性。另一个原因是Scikit-learn有多种用途。它可以用于分类、回归、聚类、降维、异常检测。</p><p id="4e09" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，Scikit-learn是您的数据科学工具包中必备的Python库。但是，学习使用Scikit-learn并不简单。事情没有你想象的那么简单。学之前你得设置一些背景。即使在学习Scikit-learn时，您也应该遵循一些指南和最佳实践。在这篇文章中，我很高兴分享9条指导方针，它们帮助我掌握了Scikit-learn，而没有中途放弃学习过程。只要有可能，我将包含我以前帖子的链接，这将帮助您设置背景并继续学习Scikit-learn。</p><h1 id="31dc" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">设置背景</h1><h2 id="5d29" class="mn lw it bd lx mo mp dn mb mq mr dp mf li ms mt mh lm mu mv mj lq mw mx ml my bi translated">准则1:在使用Scikit-learn进行stat之前，您应该熟悉Numpy</h2><p id="a7f0" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">Numpy是一个强大的库，用于在Python中执行数值计算。Scikit-learn和许多其他用于数据分析和机器学习的Python库都构建在Numpy之上。Scikit-learn估计器的输入和输出是Numpy数组的形式。</p><p id="2296" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">数据科学和机器学习所需的数学知识中，大约30–40%来自线性代数。矩阵运算在线性代数中起着重要的作用。我们经常使用Numpy在Python中进行矩阵运算。它也有矩阵运算的特殊类和子程序包。</p><p id="97ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从上面的事实来看，很明显你应该在stat使用Scikit-learn和机器学习之前熟悉Numpy。我写的以下文章涵盖了Numpy主题，如Numpy基础知识、数组创建、数组索引、使用Numpy执行算术运算和线性代数。这些课程是专门为在学习Numpy相关主题时获得实践经验而设计的。</p><ul class=""><li id="f35a" class="ne nf it lb b lc ld lf lg li ng lm nh lq ni lu nj nk nl nm bi translated"><a class="ae ky" rel="noopener" target="_blank" href="/numpy-for-data-science-part-1-21e2c5ddbbd3">面向数据科学的NumPy:第1部分— NumPy基础知识和数组创建</a></li><li id="7b33" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated"><a class="ae ky" href="https://medium.com/data-science-365/numpy-for-data-science-part-2-7399ffc605e5" rel="noopener">用于数据科学的NumPy:第2部分—数组索引和切片</a></li><li id="f218" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated"><a class="ae ky" href="https://medium.com/data-science-365/numpy-for-data-science-part-3-d4e65dbaedb2" rel="noopener">数据科学的NumPy:第三部分——NumPy数组上的算术运算</a></li><li id="8910" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated"><a class="ae ky" href="https://medium.com/data-science-365/numpy-for-data-science-part-4-67b5c6e2e9df" rel="noopener">用于数据科学的NumPy:第4部分—带有NumPy的线性代数</a></li><li id="9b4b" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated"><a class="ae ky" rel="noopener" target="_blank" href="/top-10-matrix-operations-in-numpy-with-examples-d761448cb7a8">Numpy中的10大矩阵运算及示例</a></li></ul><h2 id="cd85" class="mn lw it bd lx mo mp dn mb mq mr dp mf li ms mt mh lm mu mv mj lq mw mx ml my bi translated">准则2:平行学习更有效率</h2><p id="517c" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">一旦你熟悉了Numpy，你就为<strong class="lb iu"> <em class="ns">并行学习</em> </strong>做好了准备——一个可以用来同时学习几个Python包的学习过程。一旦你熟悉了Numpy，你可以同时开始学习Pandas，matplotlib和seaborn包。下面我写的文章涵盖了熊猫、matplotlib、seaborn相关的话题。</p><ul class=""><li id="9fa9" class="ne nf it lb b lc ld lf lg li ng lm nh lq ni lu nj nk nl nm bi translated"><a class="ae ky" href="https://medium.com/data-science-365/pandas-for-data-science-part-1-89bc231b3478" rel="noopener"> pandas for Data Science:第1部分—pandas中的数据结构</a></li><li id="5704" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated"><a class="ae ky" href="https://medium.com/data-science-365/pandas-for-data-science-part-2-c12c3ee876c2" rel="noopener">数据科学熊猫:第二部分——探索数据集</a></li><li id="fac9" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated"><a class="ae ky" href="https://medium.com/data-science-365/say-hello-to-the-world-of-plots-part-1-ce353a00076" rel="noopener">说“你好！”走向剧情世界</a></li></ul><h2 id="734e" class="mn lw it bd lx mo mp dn mb mq mr dp mf li ms mt mh lm mu mv mj lq mw mx ml my bi translated">准则3:建立你自己的编码环境</h2><p id="89b6" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">边学边练是在数据科学和机器学习领域取得成功的关键。电脑上最好有自己的编码环境。获得Python和其他数据科学库的最简单和最容易的方法是通过<strong class="lb iu"> Anaconda </strong>安装它们。对于数据科学来说，这是最受欢迎的Python发行版。它包括所有的东西:数百个包，ide，包管理器，导航器等等。它还提供了安装新库的工具。您需要做的就是通过Anaconda终端运行相关的命令。要开始使用Anaconda:</p><ul class=""><li id="49f2" class="ne nf it lb b lc ld lf lg li ng lm nh lq ni lu nj nk nl nm bi translated">去https://www.anaconda.com/products/individual</li><li id="2c38" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated">点击相关的下载选项</li><li id="5720" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated">下载安装文件后，双击它并按照屏幕上的说明在本地机器上安装Anaconda。安装时，请保持Anaconda推荐的默认设置。</li></ul><p id="8fb8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注意:</strong>在撰写本文时，Python 3.8 for Windows(64位和32位)、macOS和Linux都提供了Anaconda安装程序。您可以根据您的电脑下载相关的安装程序。</p><p id="5961" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">安装后，您可以在桌面上找到图标。双击它启动<strong class="lb iu">蟒蛇导航器</strong>。大多数常用的包，比如numpy、pandas、matplotlib、seaborn、scikit-learn和更多的包都已经附带了Anaconda。您不需要单独安装它们。从Anaconda navigator中，您可以启动Jupyter笔记本IDE来运行您自己的代码。</p><h1 id="6593" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">开始使用Scikit-learn</h1><h2 id="ed84" class="mn lw it bd lx mo mp dn mb mq mr dp mf li ms mt mh lm mu mv mj lq mw mx ml my bi translated">准则4:区分监督学习和非监督学习</h2><p id="6d4a" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated"><strong class="lb iu">监督学习</strong></p><p id="7d2f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在监督学习中，我们使用标记为 的<strong class="lb iu"> <em class="ns">数据来训练模型。<strong class="lb iu"> X </strong>和<strong class="lb iu"> y </strong>都参与了培训过程。<strong class="lb iu"> X </strong>包括输入变量。<strong class="lb iu"> y </strong>包括标签。在机器学习术语中，<strong class="lb iu"> X </strong>被称为<strong class="lb iu">特征矩阵</strong>(通常是二维numpy数组或pandas DataFrame)，而<strong class="lb iu"> y </strong>被称为<strong class="lb iu">目标向量</strong>(通常是一维numpy数组或pandas系列)。</em></strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/36ed6f010a68976843b7844f9a06a7bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1002/format:webp/1*c_vGSU8rhyQAeF2WzcI3AQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="90d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">数学上，当我们有<strong class="lb iu"> X </strong>和<strong class="lb iu"> y </strong>时，我们用监督学习算法学习输入到输出的映射函数，y=f(x)。监督学习的目标是很好地确定映射函数，以便为新的未知数据找到标签(在分类的情况下)或值(在回归的情况下)。</p><p id="8945" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">分类</strong>和<strong class="lb iu">回归</strong>是监督学习的两种类型。你可以通过阅读下面我写的文章来学习分类和回归算法。他们都会给你实践经验。在用Python和Scikit-learn实现这些算法时，您可以了解这些算法在幕后是如何工作的。</p><ul class=""><li id="b3bc" class="ne nf it lb b lc ld lf lg li ng lm nh lq ni lu nj nk nl nm bi translated"><a class="ae ky" href="https://medium.com/data-science-365/linear-regression-with-gradient-descent-895bb7d18d52" rel="noopener">带梯度下降的线性回归</a></li><li id="526e" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated"><a class="ae ky" href="https://medium.com/data-science-365/support-vector-machines-with-scikit-learn-555fa56cef25" rel="noopener">支持向量机与Scikit-learn </a></li><li id="e61e" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated"><a class="ae ky" rel="noopener" target="_blank" href="/train-a-regression-model-using-a-decision-tree-70012c22bcc1">使用决策树训练回归模型</a></li><li id="99ad" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated"><a class="ae ky" rel="noopener" target="_blank" href="/random-forests-an-ensemble-of-decision-trees-37a003084c6c">随机森林——决策树的集合</a></li><li id="feab" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated"><a class="ae ky" rel="noopener" target="_blank" href="/polynomial-regression-with-a-machine-learning-pipeline-7e27d2dedc87">具有机器学习流水线的多项式回归</a></li><li id="8c94" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated">【XGBoost之旅:里程碑1——设置背景</li><li id="3f8f" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated"><a class="ae ky" rel="noopener" target="_blank" href="/a-journey-through-xgboost-milestone-2-f3410109be5a">XGBoost之旅:里程碑2 —用XGBoost分类</a></li><li id="5e8a" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated"><a class="ae ky" rel="noopener" target="_blank" href="/a-journey-through-xgboost-milestone-3-a5569c72d72b">XGBoost之旅:里程碑3—XGBoost回归</a></li></ul><p id="1267" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">无监督学习</strong></p><p id="1bfb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在无监督学习中，我们仅使用输入变量(X)来训练模型，而不使用标签(y)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/5cb9163196e595cf826f1e1cb4711260.png" data-original-src="https://miro.medium.com/v2/resize:fit:842/format:webp/1*-DHwBcvwCBeeWzSTJbGMJQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="35b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">无监督学习的目标是在给定的输入数据中发现隐藏的模式或潜在的结构或异常值。</p><p id="c914" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">聚类</strong>、<strong class="lb iu">降维</strong>和<strong class="lb iu">异常(离群点)检测</strong>是无监督学习的三种类型。你可以通过阅读下面我写的文章来学习聚类、降维、异常检测算法。他们都会给你实践经验。在用Python和Scikit-learn实现这些算法时，您可以了解这些算法在幕后是如何工作的。</p><ul class=""><li id="648f" class="ne nf it lb b lc ld lf lg li ng lm nh lq ni lu nj nk nl nm bi translated"><a class="ae ky" href="https://medium.com/mlearning-ai/k-means-clustering-with-scikit-learn-e2af706450e4" rel="noopener">动手K均值聚类</a></li><li id="acc3" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated"><a class="ae ky" rel="noopener" target="_blank" href="/4-useful-clustering-methods-you-should-know-in-2021-ac61301e968e">2021年你应该知道的4种有用的聚类方法</a></li><li id="aa1f" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated"><a class="ae ky" rel="noopener" target="_blank" href="/principal-component-analysis-pca-with-scikit-learn-1e84a0c731b0">使用Scikit的主成分分析(PCA)-learn</a></li><li id="e963" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated"><a class="ae ky" rel="noopener" target="_blank" href="/principal-component-analysis-for-breast-cancer-data-with-r-and-python-b312d28e911f">用R和Python对乳腺癌数据进行主成分分析</a></li><li id="0a29" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated"><a class="ae ky" href="https://medium.com/data-science-365/statistical-and-mathematical-concepts-behind-pca-a2cb25940cd4" rel="noopener">PCA背后的统计和数学概念</a></li><li id="fa1a" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated"><a class="ae ky" rel="noopener" target="_blank" href="/factor-analysis-on-women-track-records-data-with-r-and-python-6731a73cd2e0">用R和Python对“女子跟踪记录”数据进行因子分析</a></li><li id="16f4" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated"><a class="ae ky" rel="noopener" target="_blank" href="/two-outlier-detection-techniques-you-should-know-in-2021-1454bef89331">2021年你应该知道的两种离群点检测技术</a></li><li id="522c" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated"><a class="ae ky" rel="noopener" target="_blank" href="/4-machine-learning-techniques-for-outlier-detection-in-python-21e9cfacb81d">4 Python中离群点检测的机器学习技术</a></li></ul><h2 id="c29a" class="mn lw it bd lx mo mp dn mb mq mr dp mf li ms mt mh lm mu mv mj lq mw mx ml my bi translated">准则5:熟悉sci kit-学习一致性</h2><p id="e4a3" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">在Scikit-learn中，机器学习模型通常被称为<strong class="lb iu">估计器</strong>。有两种主要类型的估计器:<strong class="lb iu">预测器</strong>和<strong class="lb iu">变压器</strong>。预测器进一步分为<strong class="lb iu">分类器</strong>和<strong class="lb iu">回归器</strong>。</p><p id="aba7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">。fit()/。predict() </strong>范例应用于<strong class="lb iu">预测器</strong>。<strong class="lb iu">。fit()/。trans inform()</strong>范例应用于<strong class="lb iu">变压器</strong>。例如:</p><pre class="kj kk kl km gt nv nw nx ny aw nz bi"><span id="9b1e" class="mn lw it nw b gy oa ob l oc od">from <!-- -->sklearn.linear_model import <!-- -->LinearRegression</span><span id="0129" class="mn lw it nw b gy oe ob l oc od">lin_reg = LinearRegression()<br/>lin_reg.fit(X_train, y_train)<br/>predictions = lin_reg.predict(X_test)</span></pre><p id="6f4d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们调用<strong class="lb iu"> lin_reg </strong>的<strong class="lb iu"> fit() </strong>方法时，模型开始从数据中学习(即寻找线性回归模型系数)。当我们调用<strong class="lb iu"> lin_reg </strong>的<strong class="lb iu"> predict() </strong>方法时，预测是在新的未见过的数据上进行的。这种<strong class="lb iu">。fit()/。predict() </strong>一致性适用于所有Scikit-learn预测器。另外，注意导入<strong class="lb iu"> LinearRegression() </strong>类时的一致性。该类位于<strong class="lb iu"> linear_model </strong>子包中。这就是为什么我们调用<strong class="lb iu">" from sk learn . sub _ package _ name "</strong>后跟<strong class="lb iu"> "import class_name" </strong>。当导入所有Scikit-learn预测器时，会应用这种一致性。</p><p id="b51d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> lin_reg </strong>的属性可以通过带下划线符号_的相关名称来访问。例如，<strong class="lb iu"> lin_reg.coef_ </strong>和<strong class="lb iu"> lin_reg.intercept_ </strong>给出线性回归模型系数和截距。下划线符号是评估器属性的另一个Scikit-learn一致性。</p><p id="e3de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们再举一个例子:</p><pre class="kj kk kl km gt nv nw nx ny aw nz bi"><span id="884c" class="mn lw it nw b gy oa ob l oc od">from <!-- -->sklearn.preprocessing import <!-- -->StandardScaler</span><span id="3f3b" class="mn lw it nw b gy oe ob l oc od">sc = StandardScaler()<br/>sc.fit(X)<br/>scaled_data = sc.transform(X)</span></pre><p id="3172" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们调用<strong class="lb iu"> sc </strong>的<strong class="lb iu"> fit() </strong>方法时，模型开始学习数据(即计算X的每一列的均值和标准差)。当我们调用<strong class="lb iu"> sc </strong>的<strong class="lb iu"> transform() </strong>方法时，转换发生(即缩放X的值)。这种<strong class="lb iu">。fit()/。transform() </strong>一致性适用于所有Scikit-learn转换器。另外，注意导入<strong class="lb iu"> StandardScaler() </strong>类时的一致性。那个类在<strong class="lb iu">预处理</strong>子包中。这就是为什么我们调用<strong class="lb iu">" from sk learn . sub _ package _ name "</strong>后跟<strong class="lb iu"> "import class_name" </strong>。这种一致性适用于导入所有Scikit-learn转换器。</p><p id="1758" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您还可以通过运行以下命令来同时调用<strong class="lb iu"> fit() </strong>和<strong class="lb iu"> transform() </strong>方法:</p><pre class="kj kk kl km gt nv nw nx ny aw nz bi"><span id="5737" class="mn lw it nw b gy oa ob l oc od">scaled_data = sc.fit_transform(X)</span></pre><h2 id="689e" class="mn lw it bd lx mo mp dn mb mq mr dp mf li ms mt mh lm mu mv mj lq mw mx ml my bi translated">准则6:不要记忆Scikit-learn语法，而是使用help()</h2><p id="1018" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">当进行机器学习时，您不需要记住Scikit-learn语法。你需要做的只是考虑你的模型的工作流程，并使用<strong class="lb iu"> help() </strong>函数来查看语法。例如:</p><pre class="kj kk kl km gt nv nw nx ny aw nz bi"><span id="c80b" class="mn lw it nw b gy oa ob l oc od">from <!-- -->sklearn.linear_model import <!-- -->LinearRegression</span><span id="e27e" class="mn lw it nw b gy oe ob l oc od">help(LinearRegression)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/694e244840c780f5a3d741d441833a72.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m_GbmdLVn87kHq4lKVbcVg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">获取关于Scikit的帮助-学习线性回归类(图片由作者提供)</p></figure><h2 id="89f7" class="mn lw it bd lx mo mp dn mb mq mr dp mf li ms mt mh lm mu mv mj lq mw mx ml my bi translated">准则7:区分模型参数和超参数</h2><p id="f943" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated"><strong class="lb iu"> <em class="ns">模型参数</em> </strong>在训练过程中学习它们的值。我们不手动设置参数值，它们从我们提供的数据中学习。例如，线性回归模型系数在训练过程中学习它们的值，以便找到最小化RMSE的最佳模型。</p><p id="539c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">相反，<strong class="lb iu"> <em class="ns">模型超参数</em> </strong>不从数据中学习它们的值。因此，我们必须手动为它们设置值。我们总是在创建特定模型时和开始训练过程之前设置模型超参数的值。例如，<strong class="lb iu"> n_estimators </strong>超参数是指集合模型中森林中的树木数量。<strong class="lb iu"> </strong>其默认值为100。我们可以将其更改为更高的值，以增加树的数量。这样做会提高模型性能，但也会消耗更多的计算能力。我们的目标是将它的值设置为最佳值，这样我们就可以在模型性能和计算能力之间保持平衡。</p><p id="0515" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Scikit-learn为其估计器中的超参数提供默认值。在大多数情况下，这些值不是最佳值，我们经常希望根据我们的数据和我们试图解决的问题找到最佳值。寻找超参数最佳值的过程称为<strong class="lb iu"> <em class="ns">超参数调整</em> </strong>。</p><p id="62c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要了解有关超参数调整过程的更多信息，请阅读我的“T22用简单英语解释k-fold交叉验证T23”文章和“T24验证曲线解释-绘制单个超参数的影响T25”文章的“使用k-fold交叉验证进行超参数调整”部分。</p><h2 id="9f27" class="mn lw it bd lx mo mp dn mb mq mr dp mf li ms mt mh lm mu mv mj lq mw mx ml my bi translated">准则8: Scikit-learn类不同于对象</h2><p id="9226" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">通过改变超参数的值，可以从相同的类创建不同的对象(模型)。让我们看一个例子:</p><pre class="kj kk kl km gt nv nw nx ny aw nz bi"><span id="1896" class="mn lw it nw b gy oa ob l oc od">from <!-- -->sklearn.decomposition import PCA</span><span id="a594" class="mn lw it nw b gy oe ob l oc od">pca_1 = PCA()</span></pre><p id="5038" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们以这种方式从<strong class="lb iu"> PCA() </strong>类创建<strong class="lb iu"> pca_1 </strong>对象时，下面的默认超参数值被应用。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/00a2cce8eefb14f448cf19474f3a39e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*03rcuhSBpRqIxa201mTd_Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="cc84" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，我们可以修改超参数的值来创建不同的对象。</p><pre class="kj kk kl km gt nv nw nx ny aw nz bi"><span id="fb62" class="mn lw it nw b gy oa ob l oc od">from <!-- -->sklearn.decomposition import PCA</span><span id="47d6" class="mn lw it nw b gy oe ob l oc od">pca_1 = PCA()<br/>pca_2 = PCA(n_components=2)<br/>pca_3 = PCA(n_components=3)<br/>pca_4 = PCA(n_components=2, <br/>            svd_solver='<em class="ns">randomized</em>')</span></pre><p id="4a17" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，您可以根据自己的需求自由更改超参数的值。</p><h2 id="8cc5" class="mn lw it bd lx mo mp dn mb mq mr dp mf li ms mt mh lm mu mv mj lq mw mx ml my bi translated">准则9:不要用与训练相同的数据来评估你的模型</h2><p id="1bb1" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">做任何类型的机器学习的主要意图是开发一个更通用的模型，它可以在<strong class="lb iu"> <em class="ns">看不见的数据</em> </strong>上执行得很好。人们可以在训练数据上建立一个100%准确或零误差的完美模型，但它可能无法对看不见的数据进行推广。一个好的ML模型不仅非常适合训练数据，而且可以推广到新的输入数据。模型的性能只能用在训练过程中从未使用过的数据点来衡量。这就是为什么我们经常将数据分为训练集和测试集。使用k重交叉验证可以更有效地完成数据拆分过程。要了解模型评估过程的更多信息，请阅读我的“<a class="ae ky" rel="noopener" target="_blank" href="/k-fold-cross-validation-explained-in-plain-english-659e33c0bc0">用简单英语解释k重交叉验证</a>”文章中的“使用k重交叉验证评估模型的性能”一节。</p><h1 id="7498" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">摘要</h1><p id="4b27" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">上述指导方针对我有效。本文包含的所有链接都是我自己的作品。您也可以阅读它们，并确定这些指南对学习Scikit-learn和机器学习的有效性。打下坚实的基础非常重要，这样你就不会中途放弃学习。</p><p id="70b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读！</p><p id="dfda" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本教程由<a class="ae ky" href="https://www.linkedin.com/in/rukshan-manorathna-700a3916b/" rel="noopener ugc nofollow" target="_blank"><em class="ns">Rukshan Pramoditha</em></a><em class="ns">，</em>数据科学365博客作者设计创作。</p><p id="70b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<a class="ae ky" href="https://rukshanpramoditha.medium.com/" rel="noopener">https://rukshanpramoditha.medium.com</a>阅读我的其他文章</p><p id="3bb3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi">2021–04–05</p></div></div>    
</body>
</html>