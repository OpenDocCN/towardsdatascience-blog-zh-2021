<html>
<head>
<title>Manipulate PDF Files, Extract Information with PyPDF2 and Regular Expression (Part-2)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">操作PDF文件，使用PyPDF2和正则表达式提取信息(第2部分)</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/manipulate-pdf-files-extract-information-with-pypdf2-and-regular-expression-39ff697db0ca?source=collection_archive---------3-----------------------#2021-07-27">https://towardsdatascience.com/manipulate-pdf-files-extract-information-with-pypdf2-and-regular-expression-39ff697db0ca?source=collection_archive---------3-----------------------#2021-07-27</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="b59a" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">使用PyPDF2和正则表达式简化PDF操作任务</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/f84cd61763a294ac1b94543aaa6bfdc0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*rH_yjDzFs3suLhUs"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">照片由<a class="ae kz" href="https://unsplash.com/@bgauzere?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Benoit Gauzere </a>在<a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><h2 id="005e" class="la lb iu bd lc ld le dn lf lg lh dp li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">介绍</h2><p id="596f" class="pw-post-body-paragraph lw lx iu ly b lz ma jv mb mc md jy me lj mf mg mh ln mi mj mk lr ml mm mn mo in bi mp translated">毫无疑问，现代科技使我们的生活变得容易了。甚至我们也无法想象没有现代技术的日子。自然语言处理是近来使用最多的技术之一。基本上，自然语言处理在我们的日常交流中起着重要的作用。如果我们开始了解对技术的见解，并能运用我们自己的技术，这将是我们的一大乐事。</p><p id="75a4" class="pw-post-body-paragraph lw lx iu ly b lz my jv mb mc mz jy me lj na mg mh ln nb mj mk lr nc mm mn mo in bi translated"><em class="nd">最开始，</em>我们要了解一下玩文本文件的各种技巧。如果你不熟悉，我推荐你看我之前的文章。</p><div class="ne nf gq gs ng nh"><a rel="noopener follow" target="_blank" href="/tips-and-tricks-to-work-with-text-files-in-python-89f14a755315"><div class="ni ab fp"><div class="nj ab nk cl cj nl"><h2 class="bd iv gz z fq nm fs ft nn fv fx it bi translated">使用Python处理文本文件的技巧和诀窍</h2><div class="no l"><h3 class="bd b gz z fq nm fs ft nn fv fx dk translated">使用文本文件并熟悉Python中令人惊叹的技术</h3></div><div class="np l"><p class="bd b dl z fq nm fs ft nn fv fx dk translated">towardsdatascience.com</p></div></div><div class="nq l"><div class="nr l ns nt nu nq nv kt nh"/></div></div></a></div><p id="2807" class="pw-post-body-paragraph lw lx iu ly b lz my jv mb mc mz jy me lj na mg mh ln nb mj mk lr nc mm mn mo in bi translated">然后，我们需要了解如何从pdf或其他格式的文本文件中提取文本信息。但是在本文中，我们将讨论如何使用<code class="fe nw nx ny nz b">PyPDF2</code>库来浏览pdf文档。从文本文件中提取信息的另一个最重要的工具是正则表达式。使用正则表达式，我们可以很容易地获得我们想要的信息，如电话号码、地址、电子邮件等等。特别地，正则表达式是一些符号和字母的组合，用于从成千上万的文本数据中获取我们想要的信息。</p><p id="8a48" class="pw-post-body-paragraph lw lx iu ly b lz my jv mb mc mz jy me lj na mg mh ln nb mj mk lr nc mm mn mo in bi translated"><strong class="ly iv"> <em class="nd">【注意——为了您的方便，我在结论的最后链接了文章的完整源代码。】</em> </strong></p><h2 id="99a4" class="la lb iu bd lc ld le dn lf lg lh dp li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">路标</h2><p id="c81d" class="pw-post-body-paragraph lw lx iu ly b lz ma jv mb mc md jy me lj mf mg mh ln mi mj mk lr ml mm mn mo in bi translated">本文旨在用python覆盖NLP的先决条件。以下主题将在下一篇文章中涉及。</p><p id="be1f" class="pw-post-body-paragraph lw lx iu ly b lz my jv mb mc mz jy me lj na mg mh ln nb mj mk lr nc mm mn mo in bi translated"><strong class="ly iv"> <em class="nd">第一部</em> </strong></p><ul class=""><li id="e6da" class="oa ob iu ly b lz my mc mz lj oc ln od lr oe mo of og oh oi bi translated"><code class="fe nw nx ny nz b">PyPDF2</code>概述</li><li id="c848" class="oa ob iu ly b lz oj mc ok lj ol ln om lr on mo of og oh oi bi translated">阅读PDF文件</li><li id="f953" class="oa ob iu ly b lz oj mc ok lj ol ln om lr on mo of og oh oi bi translated">向PDF添加文本</li><li id="f74c" class="oa ob iu ly b lz oj mc ok lj ol ln om lr on mo of og oh oi bi translated">从PDF中抓取所有文本</li></ul><p id="7df6" class="pw-post-body-paragraph lw lx iu ly b lz my jv mb mc mz jy me lj na mg mh ln nb mj mk lr nc mm mn mo in bi translated"><strong class="ly iv"> <em class="nd">第二部分</em> </strong></p><ul class=""><li id="126c" class="oa ob iu ly b lz my mc mz lj oc ln od lr oe mo of og oh oi bi translated">Python <code class="fe nw nx ny nz b">re</code>库概述</li><li id="fa36" class="oa ob iu ly b lz oj mc ok lj ol ln om lr on mo of og oh oi bi translated">搜索基本模式</li><li id="dea9" class="oa ob iu ly b lz oj mc ok lj ol ln om lr on mo of og oh oi bi translated">复杂模式概述</li><li id="617c" class="oa ob iu ly b lz oj mc ok lj ol ln om lr on mo of og oh oi bi translated">使用量词的模式搜索</li><li id="01f0" class="oa ob iu ly b lz oj mc ok lj ol ln om lr on mo of og oh oi bi translated">用<code class="fe nw nx ny nz b">re</code>库分组</li><li id="c611" class="oa ob iu ly b lz oj mc ok lj ol ln om lr on mo of og oh oi bi translated">or运算符</li><li id="778d" class="oa ob iu ly b lz oj mc ok lj ol ln om lr on mo of og oh oi bi translated">通配符</li><li id="46ec" class="oa ob iu ly b lz oj mc ok lj ol ln om lr on mo of og oh oi bi translated">以字符开始和结束</li><li id="4ed0" class="oa ob iu ly b lz oj mc ok lj ol ln om lr on mo of og oh oi bi translated">将字符分散成字符串</li><li id="bea7" class="oa ob iu ly b lz oj mc ok lj ol ln om lr on mo of og oh oi bi translated">从字符串中删除标点符号</li><li id="0c67" class="oa ob iu ly b lz oj mc ok lj ol ln om lr on mo of og oh oi bi translated">用于分组的括号</li><li id="6f2f" class="oa ob iu ly b lz oj mc ok lj ol ln om lr on mo of og oh oi bi translated">多个选项的括号</li><li id="31fb" class="oa ob iu ly b lz oj mc ok lj ol ln om lr on mo of og oh oi bi translated">实践问题</li></ul><p id="989a" class="pw-post-body-paragraph lw lx iu ly b lz my jv mb mc mz jy me lj na mg mh ln nb mj mk lr nc mm mn mo in bi translated">让我们开始吧</p></div><div class="ab cl oo op hy oq" role="separator"><span class="or bw bk os ot ou"/><span class="or bw bk os ot ou"/><span class="or bw bk os ot"/></div><div class="in io ip iq ir"><h2 id="a15b" class="la lb iu bd lc ld le dn lf lg lh dp li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">第一部分</h2><p id="5033" class="pw-post-body-paragraph lw lx iu ly b lz ma jv mb mc md jy me lj mf mg mh ln mi mj mk lr ml mm mn mo in bi translated">接下来的部分是关于python的<code class="fe nw nx ny nz b">PyPDF2</code>库，用于处理PDF文件。</p><ol class=""><li id="7a52" class="oa ob iu ly b lz my mc mz lj oc ln od lr oe mo ov og oh oi bi translated"><strong class="ly iv">概述</strong> <code class="fe nw nx ny nz b"><strong class="ly iv">PyPDF2</strong></code> <strong class="ly iv">库</strong></li></ol><p id="c592" class="pw-post-body-paragraph lw lx iu ly b lz my jv mb mc mz jy me lj na mg mh ln nb mj mk lr nc mm mn mo in bi translated">你经常需要处理PDF文件。Python中有许多用于处理PDF的库，每一个都有其优缺点，最常见的是PyPDF2。您可以安装它(注意区分大小写，您需要确保您的大写匹配):</p><pre class="kk kl km kn gu ow nz ox oy aw oz bi"><span id="18ba" class="la lb iu nz b gz pa pb l pc pd">pip install PyPDF2</span></pre><p id="f675" class="pw-post-body-paragraph lw lx iu ly b lz my jv mb mc mz jy me lj na mg mh ln nb mj mk lr nc mm mn mo in bi translated">请记住，不是所有的PDF文件都可以用这个库读取。太模糊、有特殊编码、加密的PDF，或者可能只是用不适合PyPDF2的特定程序创建的pdf，将无法被读取。如果你发现自己处于这种情况，尝试使用上面链接的库，但是记住，这些也可能不起作用。这是因为PDF有许多不同的参数，而且设置可能非常不标准，因此文本可以显示为图像，而不是utf-8编码。这方面要考虑的参数很多。</p><p id="591b" class="pw-post-body-paragraph lw lx iu ly b lz my jv mb mc mz jy me lj na mg mh ln nb mj mk lr nc mm mn mo in bi translated">就PyPDF2而言，它只能从PDF文档中读取文本，而不能从PDF中抓取图像或其他媒体文件。</p><p id="75a6" class="pw-post-body-paragraph lw lx iu ly b lz my jv mb mc mz jy me lj na mg mh ln nb mj mk lr nc mm mn mo in bi translated"><strong class="ly iv"> 2。阅读PDF文件</strong></p><p id="634a" class="pw-post-body-paragraph lw lx iu ly b lz my jv mb mc mz jy me lj na mg mh ln nb mj mk lr nc mm mn mo in bi translated">首先需要导入<code class="fe nw nx ny nz b">PyPDF2</code>库如下</p><pre class="kk kl km kn gu ow nz ox oy aw oz bi"><span id="334e" class="la lb iu nz b gz pa pb l pc pd"># note the capitalization<br/>import PyPDF2</span></pre><p id="1dfd" class="pw-post-body-paragraph lw lx iu ly b lz my jv mb mc mz jy me lj na mg mh ln nb mj mk lr nc mm mn mo in bi translated">现在，我们打开一个pdf，然后为它创建一个reader对象。注意我们是如何使用二进制阅读方法的，<code class="fe nw nx ny nz b">‘rb’</code>，而不仅仅是<code class="fe nw nx ny nz b">‘r’</code>。</p><pre class="kk kl km kn gu ow nz ox oy aw oz bi"><span id="3fff" class="la lb iu nz b gz pa pb l pc pd"># Notice we read it as a binary with 'rb'<br/>f = open('US_Declaration.pdf','rb')</span></pre><p id="921b" class="pw-post-body-paragraph lw lx iu ly b lz my jv mb mc mz jy me lj na mg mh ln nb mj mk lr nc mm mn mo in bi translated"><a class="ae kz" href="https://www.quora.com/What-does-opening-a-file-rb-in-Python-mean" rel="noopener ugc nofollow" target="_blank">阅读更多为什么用</a> <code class="fe nw nx ny nz b"><a class="ae kz" href="https://www.quora.com/What-does-opening-a-file-rb-in-Python-mean" rel="noopener ugc nofollow" target="_blank">‘rb’</a></code> <a class="ae kz" href="https://www.quora.com/What-does-opening-a-file-rb-in-Python-mean" rel="noopener ugc nofollow" target="_blank">代替</a> <code class="fe nw nx ny nz b"><a class="ae kz" href="https://www.quora.com/What-does-opening-a-file-rb-in-Python-mean" rel="noopener ugc nofollow" target="_blank">‘r’</a></code></p><p id="9d2e" class="pw-post-body-paragraph lw lx iu ly b lz my jv mb mc mz jy me lj na mg mh ln nb mj mk lr nc mm mn mo in bi translated">这里，文件<code class="fe nw nx ny nz b">‘US_Declaration.pdf’</code>位于与<code class="fe nw nx ny nz b">jupyter notebook</code>文件位置相同的目录中。</p><p id="73a8" class="pw-post-body-paragraph lw lx iu ly b lz my jv mb mc mz jy me lj na mg mh ln nb mj mk lr nc mm mn mo in bi translated"><a class="ae kz" href="https://drive.google.com/file/d/115DPlPclA69A2VvIAfrRPoSRWA26SDvd/view?usp=sharing" rel="noopener ugc nofollow" target="_blank"> <em class="nd">你可以从这里下载</em> </a> <code class="fe nw nx ny nz b"><a class="ae kz" href="https://drive.google.com/file/d/115DPlPclA69A2VvIAfrRPoSRWA26SDvd/view?usp=sharing" rel="noopener ugc nofollow" target="_blank"><em class="nd">US_Declaration.pdf</em></a></code> <a class="ae kz" href="https://drive.google.com/file/d/115DPlPclA69A2VvIAfrRPoSRWA26SDvd/view?usp=sharing" rel="noopener ugc nofollow" target="_blank"> <em class="nd">文件。</em>T12】</a></p><p id="423e" class="pw-post-body-paragraph lw lx iu ly b lz my jv mb mc mz jy me lj na mg mh ln nb mj mk lr nc mm mn mo in bi translated">是时候读这一页的课文了。下面这段代码将帮助我们阅读pdf格式的页面。</p><pre class="kk kl km kn gu ow nz ox oy aw oz bi"><span id="e90f" class="la lb iu nz b gz pa pb l pc pd">#pdfFileReader() reads the text  form the pdf<br/>pdf_reader = PyPDF2.PdfFileReader(f) </span><span id="f0b7" class="la lb iu nz b gz pe pb l pc pd">#the following lines of code will output the number of pages of the pdf<br/>pdf_reader.numPages</span><span id="b754" class="la lb iu nz b gz pe pb l pc pd">#getPage()reads the text of a specific page. Here the parameter 0 indicates the first page of the pdf<br/>page_one = pdf_reader.getPage(0)<br/>page_one_text = page_one.extractText()<br/>#Finally the extractText() extracts the the texts in a text format of page 1. </span></pre><p id="5df2" class="pw-post-body-paragraph lw lx iu ly b lz my jv mb mc mz jy me lj na mg mh ln nb mj mk lr nc mm mn mo in bi translated">如果您运行上面的代码并想看看<code class="fe nw nx ny nz b">page_one_text</code>变量包含什么，您会发现下面的输出。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj pf"><img src="../Images/9b405f0b78055b03d914ea38b6e7586a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bAvop-OafZMiHSBdjch5ZQ.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">作者照片</p></figure><p id="4223" class="pw-post-body-paragraph lw lx iu ly b lz my jv mb mc mz jy me lj na mg mh ln nb mj mk lr nc mm mn mo in bi translated"><strong class="ly iv"> 3。向pdf添加文本</strong></p><p id="38eb" class="pw-post-body-paragraph lw lx iu ly b lz my jv mb mc mz jy me lj na mg mh ln nb mj mk lr nc mm mn mo in bi translated">我们不能使用Python编写PDF，因为Python的单个字符串类型与PDF可能具有的各种字体、位置和其他参数之间存在差异。</p><p id="5818" class="pw-post-body-paragraph lw lx iu ly b lz my jv mb mc mz jy me lj na mg mh ln nb mj mk lr nc mm mn mo in bi translated"><em class="nd">我们能做的就是复制页面，把页面追加到最后。</em></p><p id="1837" class="pw-post-body-paragraph lw lx iu ly b lz my jv mb mc mz jy me lj na mg mh ln nb mj mk lr nc mm mn mo in bi translated">我们将提供一个向新的pdf文件添加文本的例子。很简单。</p><pre class="kk kl km kn gu ow nz ox oy aw oz bi"><span id="4969" class="la lb iu nz b gz pa pb l pc pd">f = open('US_Declaration.pdf','rb')<br/>pdf_reader = PyPDF2.PdfFileReader(f)</span><span id="ad05" class="la lb iu nz b gz pe pb l pc pd">first_page = pdf_reader.getPage(0)</span><span id="7172" class="la lb iu nz b gz pe pb l pc pd">#pdfFileWriter() enables to create a page<br/>pdf_writer = PyPDF2.PdfFileWriter()</span><span id="6f29" class="la lb iu nz b gz pe pb l pc pd">#addPage() adds the content of first_page to a new page<br/>pdf_writer.addPage(first_page)</span><span id="bf04" class="la lb iu nz b gz pe pb l pc pd">#The open() function with "wb" mode creates a document named "Some_New_Doc.pdf" to the directory<br/>pdf_output = open("Some_New_Doc.pdf","wb")</span><span id="920d" class="la lb iu nz b gz pe pb l pc pd">#finally we will get a pdf file with the contents of the first page of the previous pdf by write() function<br/>pdf_writer.write(pdf_output)</span></pre><p id="abec" class="pw-post-body-paragraph lw lx iu ly b lz my jv mb mc mz jy me lj na mg mh ln nb mj mk lr nc mm mn mo in bi translated"><strong class="ly iv"> <em class="nd">搞定！</em> </strong>现在我们已经复制了一页，并添加到另一个新文档中！</p><p id="96ef" class="pw-post-body-paragraph lw lx iu ly b lz my jv mb mc mz jy me lj na mg mh ln nb mj mk lr nc mm mn mo in bi translated"><strong class="ly iv"> 4。从pdf文件中抓取所有文本</strong></p><p id="0918" class="pw-post-body-paragraph lw lx iu ly b lz my jv mb mc mz jy me lj na mg mh ln nb mj mk lr nc mm mn mo in bi translated">从上面的代码中，我们知道使用<code class="fe nw nx ny nz b">PyPDF2,</code>我们一次只能阅读特定页面的文本。但是我们如何一次获得pdf的所有文本呢？有什么解决办法吗？耶！显然，一个简单的循环就可以解决这个问题。让我们看看实际情况。</p><pre class="kk kl km kn gu ow nz ox oy aw oz bi"><span id="be2a" class="la lb iu nz b gz pa pb l pc pd">f = open('US_Declaration.pdf','rb')</span><span id="b26b" class="la lb iu nz b gz pe pb l pc pd"># List of every page's text.<br/># The index will correspond to the page number.<br/>pdf_text = [0]  # zero is a placehoder to make page 1 = index 1</span><span id="1d86" class="la lb iu nz b gz pe pb l pc pd">pdf_reader = PyPDF2.PdfFileReader(f)</span><span id="d865" class="la lb iu nz b gz pe pb l pc pd">for p in range(pdf_reader.numPages):<br/>    <br/>    page = pdf_reader.getPage(p)<br/>    <br/>    pdf_text.append(page.extractText())</span></pre><p id="bd51" class="pw-post-body-paragraph lw lx iu ly b lz my jv mb mc mz jy me lj na mg mh ln nb mj mk lr nc mm mn mo in bi translated">代码的和平将有助于把所有的文本保存到一个列表对象中。现在，我们可以像<code class="fe nw nx ny nz b">print(pdf_text[1])</code>一样将索引插入列表，轻松打印出页面内容。它将打印第2页的文本。</p><p id="f43b" class="pw-post-body-paragraph lw lx iu ly b lz my jv mb mc mz jy me lj na mg mh ln nb mj mk lr nc mm mn mo in bi translated"><em class="nd">【注意——使用</em> <code class="fe nw nx ny nz b"><em class="nd">f.close()</em></code> <em class="nd">命令关闭文档总是一个好习惯。】</em></p><h2 id="9132" class="la lb iu bd lc ld le dn lf lg lh dp li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">第二部分</h2><ol class=""><li id="691b" class="oa ob iu ly b lz ma mc md lj pg ln ph lr pi mo ov og oh oi bi translated"><strong class="ly iv">正则表达式概述</strong></li></ol><p id="eeae" class="pw-post-body-paragraph lw lx iu ly b lz my jv mb mc mz jy me lj na mg mh ln nb mj mk lr nc mm mn mo in bi translated">正则表达式(有时简称为regex)允许用户使用他们能想到的几乎任何类型的规则来搜索字符串。例如，在字符串中查找所有大写字母，或者在文档中查找电话号码。</p><p id="5db9" class="pw-post-body-paragraph lw lx iu ly b lz my jv mb mc mz jy me lj na mg mh ln nb mj mk lr nc mm mn mo in bi translated">正则表达式因其看似奇怪的语法而臭名昭著。这种奇怪的语法是他们灵活性的副产品。正则表达式必须能够过滤掉你能想象到的任何字符串模式，这就是为什么它们具有复杂的字符串模式格式。</p><p id="19ca" class="pw-post-body-paragraph lw lx iu ly b lz my jv mb mc mz jy me lj na mg mh ln nb mj mk lr nc mm mn mo in bi translated">正则表达式使用Python内置的<strong class="ly iv"> re </strong>库来处理。更多信息参见<a class="ae kz" href="https://docs.python.org/3/library/re.html" rel="noopener ugc nofollow" target="_blank">文档</a>。</p><p id="86de" class="pw-post-body-paragraph lw lx iu ly b lz my jv mb mc mz jy me lj na mg mh ln nb mj mk lr nc mm mn mo in bi translated">让我们从解释如何在字符串中搜索基本模式开始！</p><p id="3f64" class="pw-post-body-paragraph lw lx iu ly b lz my jv mb mc mz jy me lj na mg mh ln nb mj mk lr nc mm mn mo in bi translated"><strong class="ly iv"> 2。搜索基本模式</strong></p><p id="2fec" class="pw-post-body-paragraph lw lx iu ly b lz my jv mb mc mz jy me lj na mg mh ln nb mj mk lr nc mm mn mo in bi translated">假设我们有以下字符串:</p><pre class="kk kl km kn gu ow nz ox oy aw oz bi"><span id="2a79" class="la lb iu nz b gz pa pb l pc pd">text = "The agent's phone number is 408-555-1234. Call soon!"</span></pre><p id="2231" class="pw-post-body-paragraph lw lx iu ly b lz my jv mb mc mz jy me lj na mg mh ln nb mj mk lr nc mm mn mo in bi translated">我们将首先尝试找出字符串“phone”是否在文本字符串中。现在，我们可以通过以下方式快速做到这一点:</p><pre class="kk kl km kn gu ow nz ox oy aw oz bi"><span id="9f88" class="la lb iu nz b gz pa pb l pc pd">'phone' in text</span></pre><p id="b3ca" class="pw-post-body-paragraph lw lx iu ly b lz my jv mb mc mz jy me lj na mg mh ln nb mj mk lr nc mm mn mo in bi translated">它将返回在语句中找到的<code class="fe nw nx ny nz b">True</code>。</p><p id="fb22" class="pw-post-body-paragraph lw lx iu ly b lz my jv mb mc mz jy me lj na mg mh ln nb mj mk lr nc mm mn mo in bi translated">但是让我们来展示正则表达式的格式，因为稍后我们将搜索没有如此简单解决方案的模式。看一个使用python正则表达式库<code class="fe nw nx ny nz b">re</code>的简单例子。</p><p id="787c" class="pw-post-body-paragraph lw lx iu ly b lz my jv mb mc mz jy me lj na mg mh ln nb mj mk lr nc mm mn mo in bi translated">首先，</p><pre class="kk kl km kn gu ow nz ox oy aw oz bi"><span id="3cf6" class="la lb iu nz b gz pa pb l pc pd">import re</span></pre><p id="2d15" class="pw-post-body-paragraph lw lx iu ly b lz my jv mb mc mz jy me lj na mg mh ln nb mj mk lr nc mm mn mo in bi translated">现在，</p><pre class="kk kl km kn gu ow nz ox oy aw oz bi"><span id="2655" class="la lb iu nz b gz pa pb l pc pd">pattern = 'phone'<br/>re.search(pattern,text)</span></pre><p id="be09" class="pw-post-body-paragraph lw lx iu ly b lz my jv mb mc mz jy me lj na mg mh ln nb mj mk lr nc mm mn mo in bi translated">输出</p><pre class="kk kl km kn gu ow nz ox oy aw oz bi"><span id="bf08" class="la lb iu nz b gz pa pb l pc pd">&lt;_sre.SRE_Match object; span=(12, 17), match='phone'&gt;</span></pre><p id="7c78" class="pw-post-body-paragraph lw lx iu ly b lz my jv mb mc mz jy me lj na mg mh ln nb mj mk lr nc mm mn mo in bi translated">表示<code class="fe nw nx ny nz b">phone</code>与变量<code class="fe nw nx ny nz b">text</code>的字符串匹配，并且存在该字符串的<code class="fe nw nx ny nz b">12</code>到<code class="fe nw nx ny nz b">17</code>索引。另一个例子可以如下。</p><pre class="kk kl km kn gu ow nz ox oy aw oz bi"><span id="cf54" class="la lb iu nz b gz pa pb l pc pd">pattern = "NOT IN TEXT"<br/>re.search(pattern,text)</span></pre><p id="deab" class="pw-post-body-paragraph lw lx iu ly b lz my jv mb mc mz jy me lj na mg mh ln nb mj mk lr nc mm mn mo in bi translated">它不会返回任何内容，因为没有找到匹配。现在我们已经看到re.search()将获取模式，扫描文本，然后返回一个匹配对象。如果没有找到模式，则返回None。</p><p id="51d5" class="pw-post-body-paragraph lw lx iu ly b lz my jv mb mc mz jy me lj na mg mh ln nb mj mk lr nc mm mn mo in bi translated">让我们仔细看看这个匹配对象。跨度<code class="fe nw nx ny nz b">match.span()</code>有开始和结束索引。如果我们运行代码<code class="fe nw nx ny nz b">match.start()</code>，它将输出<code class="fe nw nx ny nz b">12</code>。另一方面，<code class="fe nw nx ny nz b">match.end()</code>输出匹配字符串的结束索引，即<code class="fe nw nx ny nz b">17</code>。</p><p id="524c" class="pw-post-body-paragraph lw lx iu ly b lz my jv mb mc mz jy me lj na mg mh ln nb mj mk lr nc mm mn mo in bi translated"><em class="nd">但是如果这种模式出现不止一次呢？</em></p><pre class="kk kl km kn gu ow nz ox oy aw oz bi"><span id="a740" class="la lb iu nz b gz pa pb l pc pd">text = "my phone is a new phone"<br/>match = re.search("phone",text)</span></pre><p id="ecc6" class="pw-post-body-paragraph lw lx iu ly b lz my jv mb mc mz jy me lj na mg mh ln nb mj mk lr nc mm mn mo in bi translated">它将返回输出<code class="fe nw nx ny nz b">&lt;re.Match object; span=(3, 8), match=’phone’&gt;</code>。请注意，虽然字符串<code class="fe nw nx ny nz b">phone</code>有2个匹配，但只找到第一个匹配。</p><p id="162c" class="pw-post-body-paragraph lw lx iu ly b lz my jv mb mc mz jy me lj na mg mh ln nb mj mk lr nc mm mn mo in bi translated">如果我们想要所有匹配的列表，我们可以使用<code class="fe nw nx ny nz b">.findall()</code>方法:</p><pre class="kk kl km kn gu ow nz ox oy aw oz bi"><span id="d891" class="la lb iu nz b gz pa pb l pc pd">matches = re.findall("phone",text)</span></pre><p id="2dd3" class="pw-post-body-paragraph lw lx iu ly b lz my jv mb mc mz jy me lj na mg mh ln nb mj mk lr nc mm mn mo in bi translated">输出</p><pre class="kk kl km kn gu ow nz ox oy aw oz bi"><span id="6a25" class="la lb iu nz b gz pa pb l pc pd">['phone', 'phone']</span></pre><p id="383f" class="pw-post-body-paragraph lw lx iu ly b lz my jv mb mc mz jy me lj na mg mh ln nb mj mk lr nc mm mn mo in bi translated">如果您想要匹配的实际文本，您可以使用<code class="fe nw nx ny nz b">.group() </code>方法。</p><pre class="kk kl km kn gu ow nz ox oy aw oz bi"><span id="dea5" class="la lb iu nz b gz pa pb l pc pd">match.group()</span></pre><p id="c6b1" class="pw-post-body-paragraph lw lx iu ly b lz my jv mb mc mz jy me lj na mg mh ln nb mj mk lr nc mm mn mo in bi translated">输出</p><pre class="kk kl km kn gu ow nz ox oy aw oz bi"><span id="f631" class="la lb iu nz b gz pa pb l pc pd">'phone'</span></pre><p id="510c" class="pw-post-body-paragraph lw lx iu ly b lz my jv mb mc mz jy me lj na mg mh ln nb mj mk lr nc mm mn mo in bi translated"><strong class="ly iv"> 3。复杂模式概述</strong></p><p id="59fb" class="pw-post-body-paragraph lw lx iu ly b lz my jv mb mc mz jy me lj na mg mh ln nb mj mk lr nc mm mn mo in bi translated">到目前为止，我们已经学习了如何搜索一个基本字符串。更复杂的例子呢？比如试图在一大串文本中找到一个电话号码？或者电子邮件地址？</p><p id="df01" class="pw-post-body-paragraph lw lx iu ly b lz my jv mb mc mz jy me lj na mg mh ln nb mj mk lr nc mm mn mo in bi translated">如果我们知道确切的电话或电子邮件，我们可以使用搜索方法，但如果我们不知道呢？我们可能知道一般的格式，我们可以使用它和正则表达式在文档中搜索匹配特定模式的字符串。</p><p id="dbfe" class="pw-post-body-paragraph lw lx iu ly b lz my jv mb mc mz jy me lj na mg mh ln nb mj mk lr nc mm mn mo in bi translated">这是语法开始看起来奇怪的地方，但是要慢慢来；通常只需要查找模式代码。</p><p id="e039" class="pw-post-body-paragraph lw lx iu ly b lz my jv mb mc mz jy me lj na mg mh ln nb mj mk lr nc mm mn mo in bi translated">我们开始吧！</p><p id="0cbd" class="pw-post-body-paragraph lw lx iu ly b lz my jv mb mc mz jy me lj na mg mh ln nb mj mk lr nc mm mn mo in bi translated"><strong class="ly iv"> 4。模式中字符的标识符</strong></p><p id="de4c" class="pw-post-body-paragraph lw lx iu ly b lz my jv mb mc mz jy me lj na mg mh ln nb mj mk lr nc mm mn mo in bi translated">数字或单个字符串等字符有不同的代码来表示。您可以使用这些来构建模式字符串。注意这些是如何大量使用反斜线<code class="fe nw nx ny nz b">\ </code>的。因此，在为正则表达式定义模式字符串时，我们使用以下格式:</p><pre class="kk kl km kn gu ow nz ox oy aw oz bi"><span id="f3a5" class="la lb iu nz b gz pa pb l pc pd">r'mypattern'</span></pre><p id="d50b" class="pw-post-body-paragraph lw lx iu ly b lz my jv mb mc mz jy me lj na mg mh ln nb mj mk lr nc mm mn mo in bi translated">将r放在字符串前面可以让python理解模式字符串中的<code class="fe nw nx ny nz b"> \ </code>不是转义斜杠。</p><p id="5036" class="pw-post-body-paragraph lw lx iu ly b lz my jv mb mc mz jy me lj na mg mh ln nb mj mk lr nc mm mn mo in bi translated">下面是所有可能标识符的列表:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="pj pk l"/></div></figure><p id="9d81" class="pw-post-body-paragraph lw lx iu ly b lz my jv mb mc mz jy me lj na mg mh ln nb mj mk lr nc mm mn mo in bi translated">你可以边工作边看表格，因为记住这些符号是不可能的。</p><p id="9cce" class="pw-post-body-paragraph lw lx iu ly b lz my jv mb mc mz jy me lj na mg mh ln nb mj mk lr nc mm mn mo in bi translated">请看下面的代码</p><pre class="kk kl km kn gu ow nz ox oy aw oz bi"><span id="3b5d" class="la lb iu nz b gz pa pb l pc pd">text = "My telephone number is 408-555-1234"<br/>phone = re.search(r'\d\d\d-\d\d\d-\d\d\d\d',text)<br/>phone.group() #there are three groups separated with (-) symbol</span></pre><p id="65a2" class="pw-post-body-paragraph lw lx iu ly b lz my jv mb mc mz jy me lj na mg mh ln nb mj mk lr nc mm mn mo in bi translated">输出</p><pre class="kk kl km kn gu ow nz ox oy aw oz bi"><span id="d67a" class="la lb iu nz b gz pa pb l pc pd">'408-555-1234'</span></pre><p id="2fe6" class="pw-post-body-paragraph lw lx iu ly b lz my jv mb mc mz jy me lj na mg mh ln nb mj mk lr nc mm mn mo in bi translated">注意<code class="fe nw nx ny nz b">\d</code>的重复。这有点麻烦，尤其是当我们在寻找很长的数字串时。量词让这个任务变得简单了。</p><p id="3e85" class="pw-post-body-paragraph lw lx iu ly b lz my jv mb mc mz jy me lj na mg mh ln nb mj mk lr nc mm mn mo in bi translated"><strong class="ly iv"> 5。使用量词的模式搜索</strong></p><p id="1487" class="pw-post-body-paragraph lw lx iu ly b lz my jv mb mc mz jy me lj na mg mh ln nb mj mk lr nc mm mn mo in bi translated">让我们探索可能的量词。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="pj pk l"/></div></figure><p id="eb48" class="pw-post-body-paragraph lw lx iu ly b lz my jv mb mc mz jy me lj na mg mh ln nb mj mk lr nc mm mn mo in bi translated">现在，我们知道了特殊的字符标识，我们可以使用它们和量词来定义我们期望的数量。我们不需要重复使用标识符。</p><p id="ee4e" class="pw-post-body-paragraph lw lx iu ly b lz my jv mb mc mz jy me lj na mg mh ln nb mj mk lr nc mm mn mo in bi translated">让我们使用这些量词重写我们的模式:</p><pre class="kk kl km kn gu ow nz ox oy aw oz bi"><span id="2ca7" class="la lb iu nz b gz pa pb l pc pd">text = "My telephone number is 408-555-1234"<br/>phone = re.search(r'\d{3}-\d{3}-\d{4}',text)<br/>phone.group()</span></pre><p id="7fd3" class="pw-post-body-paragraph lw lx iu ly b lz my jv mb mc mz jy me lj na mg mh ln nb mj mk lr nc mm mn mo in bi translated">代码的输出和前面的一样。但现在它似乎很容易，可以很容易地用于复杂和大的模式。</p><p id="a8d3" class="pw-post-body-paragraph lw lx iu ly b lz my jv mb mc mz jy me lj na mg mh ln nb mj mk lr nc mm mn mo in bi translated"><strong class="ly iv"> 6。组有</strong> <code class="fe nw nx ny nz b"><strong class="ly iv">re</strong></code> <strong class="ly iv">库</strong></p><p id="6d35" class="pw-post-body-paragraph lw lx iu ly b lz my jv mb mc mz jy me lj na mg mh ln nb mj mk lr nc mm mn mo in bi translated">如果我们想做两个任务，查找电话号码，但也能够快速提取他们的区号(前三位数字)的上述例子。我们可以将组用于任何涉及到将正则表达式组合在一起的常规任务(以便我们稍后可以分解它们)。</p><p id="bd1a" class="pw-post-body-paragraph lw lx iu ly b lz my jv mb mc mz jy me lj na mg mh ln nb mj mk lr nc mm mn mo in bi translated">以电话号码为例，我们可以使用括号分隔正则表达式组:</p><pre class="kk kl km kn gu ow nz ox oy aw oz bi"><span id="8c11" class="la lb iu nz b gz pa pb l pc pd"># The entire result<br/>results.group()</span></pre><p id="8241" class="pw-post-body-paragraph lw lx iu ly b lz my jv mb mc mz jy me lj na mg mh ln nb mj mk lr nc mm mn mo in bi translated">输出</p><pre class="kk kl km kn gu ow nz ox oy aw oz bi"><span id="7bcd" class="la lb iu nz b gz pa pb l pc pd">'408-555-1234'</span></pre><p id="f82a" class="pw-post-body-paragraph lw lx iu ly b lz my jv mb mc mz jy me lj na mg mh ln nb mj mk lr nc mm mn mo in bi translated">然后</p><pre class="kk kl km kn gu ow nz ox oy aw oz bi"><span id="7e15" class="la lb iu nz b gz pa pb l pc pd"># Can also call by group position.<br/># remember groups were separated by parentheses ()<br/># Something to note is that group ordering starts at 1. Passing in 0 returns everything<br/>results.group(1)</span></pre><p id="b291" class="pw-post-body-paragraph lw lx iu ly b lz my jv mb mc mz jy me lj na mg mh ln nb mj mk lr nc mm mn mo in bi translated">这段代码返回第一组(电话号码的3位数)。</p><p id="2fdb" class="pw-post-body-paragraph lw lx iu ly b lz my jv mb mc mz jy me lj na mg mh ln nb mj mk lr nc mm mn mo in bi translated"><strong class="ly iv"> 7。</strong> <code class="fe nw nx ny nz b"><strong class="ly iv">or</strong></code> <strong class="ly iv">符</strong></p><p id="1be6" class="pw-post-body-paragraph lw lx iu ly b lz my jv mb mc mz jy me lj na mg mh ln nb mj mk lr nc mm mn mo in bi translated">使用钻杆操作器进行<strong class="ly iv">或</strong>定位。例如</p><pre class="kk kl km kn gu ow nz ox oy aw oz bi"><span id="5eef" class="la lb iu nz b gz pa pb l pc pd">re.search(r"man|woman","This man was here.")</span></pre><p id="aa8d" class="pw-post-body-paragraph lw lx iu ly b lz my jv mb mc mz jy me lj na mg mh ln nb mj mk lr nc mm mn mo in bi translated">输出</p><pre class="kk kl km kn gu ow nz ox oy aw oz bi"><span id="6310" class="la lb iu nz b gz pa pb l pc pd">&lt;_sre.SRE_Match object; span=(5, 8), match='man'&gt;</span></pre><p id="21b0" class="pw-post-body-paragraph lw lx iu ly b lz my jv mb mc mz jy me lj na mg mh ln nb mj mk lr nc mm mn mo in bi translated">又..</p><pre class="kk kl km kn gu ow nz ox oy aw oz bi"><span id="6ec5" class="la lb iu nz b gz pa pb l pc pd">re.search(r"man|woman","This woman was here.")</span></pre><p id="67ef" class="pw-post-body-paragraph lw lx iu ly b lz my jv mb mc mz jy me lj na mg mh ln nb mj mk lr nc mm mn mo in bi translated">输出</p><pre class="kk kl km kn gu ow nz ox oy aw oz bi"><span id="23fd" class="la lb iu nz b gz pa pb l pc pd">&lt;_sre.SRE_Match object; span=(5, 10), match='woman'&gt;</span></pre><p id="7b90" class="pw-post-body-paragraph lw lx iu ly b lz my jv mb mc mz jy me lj na mg mh ln nb mj mk lr nc mm mn mo in bi translated">8。通配符</p><p id="86b1" class="pw-post-body-paragraph lw lx iu ly b lz my jv mb mc mz jy me lj na mg mh ln nb mj mk lr nc mm mn mo in bi translated">使用<code class="fe nw nx ny nz b">“wildcard”</code>作为一个位置，它将匹配放置在那里的任何字符。可以用简单的句号<strong class="ly iv">。</strong>为此。例如:</p><pre class="kk kl km kn gu ow nz ox oy aw oz bi"><span id="256f" class="la lb iu nz b gz pa pb l pc pd">re.findall(r".at","The cat in the hat sat here.")</span></pre><p id="78c8" class="pw-post-body-paragraph lw lx iu ly b lz my jv mb mc mz jy me lj na mg mh ln nb mj mk lr nc mm mn mo in bi translated">输出</p><pre class="kk kl km kn gu ow nz ox oy aw oz bi"><span id="1622" class="la lb iu nz b gz pa pb l pc pd">['cat', 'hat', 'sat']</span></pre><p id="d679" class="pw-post-body-paragraph lw lx iu ly b lz my jv mb mc mz jy me lj na mg mh ln nb mj mk lr nc mm mn mo in bi translated">假设，我们想匹配前3个字母。</p><pre class="kk kl km kn gu ow nz ox oy aw oz bi"><span id="e724" class="la lb iu nz b gz pa pb l pc pd">re.findall(r"...at","The bat went splat")</span></pre><p id="6fb5" class="pw-post-body-paragraph lw lx iu ly b lz my jv mb mc mz jy me lj na mg mh ln nb mj mk lr nc mm mn mo in bi translated">它生成类似<code class="fe nw nx ny nz b">[‘e bat’, ‘splat’]</code>的输出。请注意，我们只匹配了前3个字母，这是因为我们需要为每个通配符字母添加一个<code class="fe nw nx ny nz b"> <strong class="ly iv">.</strong> </code>。或者使用上面描述的量词来设置自己的规则。</p><p id="c223" class="pw-post-body-paragraph lw lx iu ly b lz my jv mb mc mz jy me lj na mg mh ln nb mj mk lr nc mm mn mo in bi translated">如果我们想要以“at”结尾的单词，应该怎么做？</p><pre class="kk kl km kn gu ow nz ox oy aw oz bi"><span id="3f83" class="la lb iu nz b gz pa pb l pc pd"># One or more non-whitespace that ends with 'at'<br/>re.findall(r'\S+at',"The bat went splat")</span></pre><p id="7c89" class="pw-post-body-paragraph lw lx iu ly b lz my jv mb mc mz jy me lj na mg mh ln nb mj mk lr nc mm mn mo in bi translated">上面的代码已经完成了工作并返回输出<code class="fe nw nx ny nz b">[‘bat’, ‘splat’]</code>。</p><p id="ffa2" class="pw-post-body-paragraph lw lx iu ly b lz my jv mb mc mz jy me lj na mg mh ln nb mj mk lr nc mm mn mo in bi translated"><strong class="ly iv"> 9。开始和结束字符</strong></p><p id="10ab" class="pw-post-body-paragraph lw lx iu ly b lz my jv mb mc mz jy me lj na mg mh ln nb mj mk lr nc mm mn mo in bi translated">我们可以用<strong class="ly iv"/>来查找以字符开头的,<strong class="ly iv"> $ </strong>来查找以字符结尾的:</p><pre class="kk kl km kn gu ow nz ox oy aw oz bi"><span id="b1b6" class="la lb iu nz b gz pa pb l pc pd"># Ends with a number<br/>re.findall(r'\d$','This ends with a number 2')</span><span id="cafe" class="la lb iu nz b gz pe pb l pc pd"># Starts with a number<br/>re.findall(r'^\d','1 is the loneliest number.')</span></pre><p id="cec5" class="pw-post-body-paragraph lw lx iu ly b lz my jv mb mc mz jy me lj na mg mh ln nb mj mk lr nc mm mn mo in bi translated">上面的代码返回<code class="fe nw nx ny nz b">[‘2’]</code>，<code class="fe nw nx ny nz b">[‘1’]</code>作为字符串的结束和开始字符。</p><p id="19d9" class="pw-post-body-paragraph lw lx iu ly b lz my jv mb mc mz jy me lj na mg mh ln nb mj mk lr nc mm mn mo in bi translated"><em class="nd">注意，这是针对整个字符串，不是针对单个单词！</em></p><p id="a4db" class="pw-post-body-paragraph lw lx iu ly b lz my jv mb mc mz jy me lj na mg mh ln nb mj mk lr nc mm mn mo in bi translated"><strong class="ly iv"> 10。分散字符串中的字符</strong></p><p id="3f5a" class="pw-post-body-paragraph lw lx iu ly b lz my jv mb mc mz jy me lj na mg mh ln nb mj mk lr nc mm mn mo in bi translated">为了排除字符，我们可以将<code class="fe nw nx ny nz b">^</code>符号与一组方括号<code class="fe nw nx ny nz b">[]</code> <code class="fe nw nx ny nz b">.</code>一起使用，方括号内的任何内容都被排除在外。例如:</p><pre class="kk kl km kn gu ow nz ox oy aw oz bi"><span id="427b" class="la lb iu nz b gz pa pb l pc pd">phrase = "there are 3 numbers 34 inside 5 this sentence."<br/>re.findall(r'[^\d]',phrase)</span></pre><p id="ed65" class="pw-post-body-paragraph lw lx iu ly b lz my jv mb mc mz jy me lj na mg mh ln nb mj mk lr nc mm mn mo in bi translated">输出</p><pre class="kk kl km kn gu ow nz ox oy aw oz bi"><span id="4091" class="la lb iu nz b gz pa pb l pc pd">['t',<br/> 'h',<br/> 'e',<br/> 'r',<br/> 'e'<br/>....]</span></pre><p id="fd37" class="pw-post-body-paragraph lw lx iu ly b lz my jv mb mc mz jy me lj na mg mh ln nb mj mk lr nc mm mn mo in bi translated"><strong class="ly iv"> 11。去除标点符号</strong></p><pre class="kk kl km kn gu ow nz ox oy aw oz bi"><span id="c171" class="la lb iu nz b gz pa pb l pc pd">test_phrase = 'This is a string! But it has punctuation. How can we remove it?'<br/>re.findall('[^!.? ]+',test_phrase)</span></pre><p id="82dc" class="pw-post-body-paragraph lw lx iu ly b lz my jv mb mc mz jy me lj na mg mh ln nb mj mk lr nc mm mn mo in bi translated">它将只返回单词。</p><pre class="kk kl km kn gu ow nz ox oy aw oz bi"><span id="2bbd" class="la lb iu nz b gz pa pb l pc pd">['This',<br/> 'is',<br/> 'a',<br/> 'string',<br/> 'But',<br/> 'it',<br/> 'has',<br/> 'punctuation',<br/> 'How',<br/> 'can',<br/> 'we',<br/> 'remove',<br/> 'it']</span></pre><p id="af3a" class="pw-post-body-paragraph lw lx iu ly b lz my jv mb mc mz jy me lj na mg mh ln nb mj mk lr nc mm mn mo in bi translated">我们可以把这个词按如下顺序连接起来。</p><pre class="kk kl km kn gu ow nz ox oy aw oz bi"><span id="aa29" class="la lb iu nz b gz pa pb l pc pd">clean = ' '.join(re.findall('[^!.? ]+',test_phrase))<br/>clean</span></pre><p id="d772" class="pw-post-body-paragraph lw lx iu ly b lz my jv mb mc mz jy me lj na mg mh ln nb mj mk lr nc mm mn mo in bi translated">它将返回不带标点符号的字符串。</p><pre class="kk kl km kn gu ow nz ox oy aw oz bi"><span id="662a" class="la lb iu nz b gz pa pb l pc pd">'This is a string But it has punctuation How can we remove it'</span></pre><p id="c0b4" class="pw-post-body-paragraph lw lx iu ly b lz my jv mb mc mz jy me lj na mg mh ln nb mj mk lr nc mm mn mo in bi translated"><strong class="ly iv"> 12。用于分组的括号</strong></p><p id="24cc" class="pw-post-body-paragraph lw lx iu ly b lz my jv mb mc mz jy me lj na mg mh ln nb mj mk lr nc mm mn mo in bi translated">如上所示，我们可以使用括号将选项组合在一起，例如，如果我们想要查找带连字符的单词:</p><pre class="kk kl km kn gu ow nz ox oy aw oz bi"><span id="5126" class="la lb iu nz b gz pa pb l pc pd">text = 'Only find the hypen-words in this sentence. But you do not know how long-ish they are'<br/>re.findall(r'[\w]+-[\w]+',text)</span></pre><p id="3275" class="pw-post-body-paragraph lw lx iu ly b lz my jv mb mc mz jy me lj na mg mh ln nb mj mk lr nc mm mn mo in bi translated">输出</p><pre class="kk kl km kn gu ow nz ox oy aw oz bi"><span id="b6c0" class="la lb iu nz b gz pa pb l pc pd">['hypen-words', 'long-ish']</span></pre><p id="58be" class="pw-post-body-paragraph lw lx iu ly b lz my jv mb mc mz jy me lj na mg mh ln nb mj mk lr nc mm mn mo in bi translated">13。多个选项的括号</p><p id="4eef" class="pw-post-body-paragraph lw lx iu ly b lz my jv mb mc mz jy me lj na mg mh ln nb mj mk lr nc mm mn mo in bi translated">如果我们有多个匹配选项，我们可以使用括号列出这些选项。例如:</p><pre class="kk kl km kn gu ow nz ox oy aw oz bi"><span id="dece" class="la lb iu nz b gz pa pb l pc pd"><em class="nd"># Find words that start with cat and end with one of these options: 'fish','nap', or 'claw'</em></span><span id="0e16" class="la lb iu nz b gz pe pb l pc pd">text <strong class="nz iv">=</strong> 'Hello, would you like some catfish?'</span><span id="1393" class="la lb iu nz b gz pe pb l pc pd">re.search(r'cat(fish|nap|claw)',text)</span></pre><p id="ffa1" class="pw-post-body-paragraph lw lx iu ly b lz my jv mb mc mz jy me lj na mg mh ln nb mj mk lr nc mm mn mo in bi translated">输出</p><pre class="kk kl km kn gu ow nz ox oy aw oz bi"><span id="cd72" class="la lb iu nz b gz pa pb l pc pd">&lt;_sre.SRE_Match object; span=(27, 34), match='catfish'&gt;</span></pre><p id="8626" class="pw-post-body-paragraph lw lx iu ly b lz my jv mb mc mz jy me lj na mg mh ln nb mj mk lr nc mm mn mo in bi translated">14。练习题</p><p id="b338" class="pw-post-body-paragraph lw lx iu ly b lz my jv mb mc mz jy me lj na mg mh ln nb mj mk lr nc mm mn mo in bi translated">这是额外的任务。我已经上传了一个jupyter笔记本文件到<a class="ae kz" href="https://github.com/Zubair063/ML_articles/blob/fe3aabe41a68f1b0a305e63dd38cb91b5445d9bd/PDF%20manupulation%20an%20regular%20expression/Python-Text-Basics-Assessment.ipynb" rel="noopener ugc nofollow" target="_blank"><strong class="ly iv"><em class="nd">github</em></strong></a>。你可以从<a class="ae kz" href="https://github.com/Zubair063/ML_articles/blob/fe3aabe41a68f1b0a305e63dd38cb91b5445d9bd/PDF%20manupulation%20an%20regular%20expression/Python-Text-Basics-Assessment.ipynb" rel="noopener ugc nofollow" target="_blank">这里</a>下载文件，并根据指示填写单元格。有六项任务。试着做你自己的。我认为这很容易，也很有趣。如有任何问题或困惑，请在下面评论。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj pl"><img src="../Images/7c4fe1bdf085a08ab0cee507e080ff26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*yCKT2ncekKwzXub4"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated"><a class="ae kz" href="https://unsplash.com/@lamerbrain?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> M </a>在<a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</p></figure><h2 id="57bf" class="la lb iu bd lc ld le dn lf lg lh dp li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">结论</h2><p id="1a8c" class="pw-post-body-paragraph lw lx iu ly b lz ma jv mb mc md jy me lj mf mg mh ln mi mj mk lr ml mm mn mo in bi translated">我认为我们学到了很多。虽然主题和语法很简单，但对于自然语言处理(NLP)和其他数据科学任务来说，它们非常重要。我已经开始将这些文章作为一系列NLP。从下一篇文章中，我们将学习NLP的核心基础知识。和我保持联系。</p><p id="c169" class="pw-post-body-paragraph lw lx iu ly b lz my jv mb mc mz jy me lj na mg mh ln nb mj mk lr nc mm mn mo in bi translated"><em class="nd">第一部分完整的Jupyter笔记本如下</em></p><div class="ne nf gq gs ng nh"><a href="https://github.com/Zubair063/ML_articles/blob/fe3aabe41a68f1b0a305e63dd38cb91b5445d9bd/PDF%20manupulation%20an%20regular%20expression/Working-with-PDF-Text.ipynb" rel="noopener  ugc nofollow" target="_blank"><div class="ni ab fp"><div class="nj ab nk cl cj nl"><h2 class="bd iv gz z fq nm fs ft nn fv fx it bi translated">ML _ articles/Working-with-PDF-text . ipynb</h2><div class="no l"><h3 class="bd b gz z fq nm fs ft nn fv fx dk translated">在GitHub上创建一个帐户，为Zubair063/ML_articles的开发做出贡献。</h3></div><div class="np l"><p class="bd b dl z fq nm fs ft nn fv fx dk translated">github.com</p></div></div><div class="nq l"><div class="pm l ns nt nu nq nv kt nh"/></div></div></a></div><p id="fb8f" class="pw-post-body-paragraph lw lx iu ly b lz my jv mb mc mz jy me lj na mg mh ln nb mj mk lr nc mm mn mo in bi translated"><em class="nd">找到下面给出的完整正则表达式源代码</em></p><div class="ne nf gq gs ng nh"><a href="https://github.com/Zubair063/ML_articles/blob/fe3aabe41a68f1b0a305e63dd38cb91b5445d9bd/PDF%20manupulation%20an%20regular%20expression/Regular-Expressions.ipynb" rel="noopener  ugc nofollow" target="_blank"><div class="ni ab fp"><div class="nj ab nk cl cj nl"><h2 class="bd iv gz z fq nm fs ft nn fv fx it bi translated">ML _ articles/Regular-expressions . ipynb</h2><div class="no l"><h3 class="bd b gz z fq nm fs ft nn fv fx dk translated">在GitHub上创建一个帐户，为Zubair063/ML_articles的开发做出贡献。</h3></div><div class="np l"><p class="bd b dl z fq nm fs ft nn fv fx dk translated">github.com</p></div></div><div class="nq l"><div class="pn l ns nt nu nq nv kt nh"/></div></div></a></div><h1 id="d80f" class="po lb iu bd lc pp pq pr lf ps pt pu li ka pv kb lm kd pw ke lq kg px kh lu py bi translated">祖贝尔·侯赛因</h1><ul class=""><li id="2a84" class="oa ob iu ly b lz ma mc md lj pg ln ph lr pi mo of og oh oi bi translated"><em class="nd">如果你喜欢这篇文章，请关注我的</em> <a class="ae kz" href="https://mzh706.medium.com/" rel="noopener"> <strong class="ly iv"> <em class="nd">中型</em> </strong> </a> <em class="nd">了解更多。</em></li><li id="6a36" class="oa ob iu ly b lz oj mc ok lj ol ln om lr on mo of og oh oi bi translated"><em class="nd">在</em><a class="ae kz" href="https://www.linkedin.com/in/zubair063/" rel="noopener ugc nofollow" target="_blank"><strong class="ly iv"><em class="nd">LinkedIn</em></strong></a><em class="nd">上连接我进行协作。</em></li></ul></div></div>    
</body>
</html>