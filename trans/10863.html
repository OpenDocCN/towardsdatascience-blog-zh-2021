<html>
<head>
<title>The power of constrained language models</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">受约束语言模型的力量</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/the-power-of-constrained-language-models-cf63b65a035d?source=collection_archive---------12-----------------------#2021-10-21">https://towardsdatascience.com/the-power-of-constrained-language-models-cf63b65a035d?source=collection_archive---------12-----------------------#2021-10-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="19a5" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">为什么以及如何用自定义的波束搜索算法构建约束语言模型。一个拥抱脸代码的指南。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/e66a170a63140e0a4f322acbd9f828cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*J0AWj3deVArseT7x"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">迈克尔·泽兹奇在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><h1 id="eb24" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">概观</h1><ol class=""><li id="fa0b" class="lo lp iq lq b lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">介绍</li><li id="ddb9" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb mc md me mf bi translated">为什么要关心受约束的语言模型？</li><li id="5510" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb mc md me mf bi translated">波束搜索算法是什么？</li><li id="1f81" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb mc md me mf bi translated">如何用自定义的波束搜索算法约束任何语言模型？</li><li id="41f4" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb mc md me mf bi translated">拥抱脸的实现</li><li id="0e30" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb mc md me mf bi translated">结果呢</li><li id="9d2b" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb mc md me mf bi translated">结论</li></ol><h1 id="393d" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">介绍</h1><p id="af9f" class="pw-post-body-paragraph ml mm iq lq b lr ls jr mn lt lu ju mo lv mp mq mr lx ms mt mu lz mv mw mx mb ij bi translated">预先训练好的生成语言模型(如OpenAI的<a class="ae kv" href="https://openai.com/blog/better-language-models/" rel="noopener ugc nofollow" target="_blank"> GPT2 </a>和<a class="ae kv" href="https://openai.com/blog/openai-api/" rel="noopener ugc nofollow" target="_blank"> GPT3 </a>)或seq2seq模型(如<a class="ae kv" href="https://ai.googleblog.com/2020/02/exploring-transfer-learning-with-t5.html" rel="noopener ugc nofollow" target="_blank"> T5 </a>或最近发布的<a class="ae kv" href="https://huggingface.co/bigscience/T0pp" rel="noopener ugc nofollow" target="_blank"> T0 </a>)生成自由流动的自然语言。这意味着他们输出的句子可以是任何形状。为了从这些模型中获得最大价值，我们有时希望输出遵循某种结构——这被称为<em class="my">受限语言模型</em>。在这篇文章中，我将解释:</p><ul class=""><li id="575a" class="lo lp iq lq b lr mz lt na lv nb lx nc lz nd mb ne md me mf bi translated">为什么你想要一个受约束的语言模型。</li><li id="9fbd" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb ne md me mf bi translated">波束搜索算法的用途。</li><li id="2919" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb ne md me mf bi translated">如何用自定义的波束搜索算法轻松约束任何语言模型？</li><li id="e353" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb ne md me mf bi translated">如何使用拥抱脸来实现这一点？</li></ul><p id="12b5" class="pw-post-body-paragraph ml mm iq lq b lr mz jr mn lt na ju mo lv nf mq mr lx ng mt mu lz nh mw mx mb ij bi translated">读完这篇文章后，你将能够通过控制语言模型输出的形状，从语言模型中获得更多的价值。</p><p id="a12e" class="pw-post-body-paragraph ml mm iq lq b lr mz jr mn lt na ju mo lv nf mq mr lx ng mt mu lz nh mw mx mb ij bi translated">这篇文章与我的<a class="ae kv" rel="noopener" target="_blank" href="/almost-no-data-and-no-time-unlocking-the-true-potential-of-gpt3-a-case-study-b4710ca0614a">上一篇文章</a>有关，在这篇文章中，我解释了如何通过操纵输入的形状来释放GPT3的真正潜力(参见<em class="my">提示工程</em>)。</p><p id="cc98" class="pw-post-body-paragraph ml mm iq lq b lr mz jr mn lt na ju mo lv nf mq mr lx ng mt mu lz nh mw mx mb ij bi translated">包含示例代码的笔记本可从<a class="ae kv" href="https://colab.research.google.com/drive/1ezT24sogpVyr2HJLOvXHzjv61JZJ1gMT?usp=sharing" rel="noopener ugc nofollow" target="_blank">这里</a>获得。</p><h1 id="92b6" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">为什么要关心受约束的语言模型？</h1><p id="5f12" class="pw-post-body-paragraph ml mm iq lq b lr ls jr mn lt lu ju mo lv mp mq mr lx ms mt mu lz mv mw mx mb ij bi translated">如前所述，我们有时希望模型的输出遵循某种结构。例如，如果我们想要进一步处理输出，如果我们对它们的结构和属性有一些保证就好了。</p><p id="d928" class="pw-post-body-paragraph ml mm iq lq b lr mz jr mn lt na ju mo lv nf mq mr lx ng mt mu lz nh mw mx mb ij bi translated">在一个案例研究中，我在这里描述了<a class="ae kv" rel="noopener" target="_blank" href="/almost-no-data-and-no-time-unlocking-the-true-potential-of-gpt3-a-case-study-b4710ca0614a">和</a>，一个模型的输出需要被一个额外的组件解析。通过实施适当的结构，我可以保证输出易于解析。</p><p id="7b71" class="pw-post-body-paragraph ml mm iq lq b lr mz jr mn lt na ju mo lv nf mq mr lx ng mt mu lz nh mw mx mb ij bi translated">我们可以确保给定的模型永远不会输出两个特定单词同时出现的句子，或者我们可以确保这些单词总是同时出现。可能性是无限的。</p><p id="d5f4" class="pw-post-body-paragraph ml mm iq lq b lr mz jr mn lt na ju mo lv nf mq mr lx ng mt mu lz nh mw mx mb ij bi translated">或者，我们可能希望生成每个标记只有偶数个字符的句子，只是为了好玩。</p><h1 id="ebca" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">波束搜索算法是什么？</h1><p id="3f39" class="pw-post-body-paragraph ml mm iq lq b lr ls jr mn lt lu ju mo lv mp mq mr lx ms mt mu lz mv mw mx mb ij bi translated">我们可以通过使用定制的波束搜索算法来实现这种效果。</p><p id="cf99" class="pw-post-body-paragraph ml mm iq lq b lr mz jr mn lt na ju mo lv nf mq mr lx ng mt mu lz nh mw mx mb ij bi translated">简而言之，波束搜索算法(有时称为<em class="my">维特比算法</em>)用于生成一个句子的极有可能的延续。</p><p id="000d" class="pw-post-body-paragraph ml mm iq lq b lr mz jr mn lt na ju mo lv nf mq mr lx ng mt mu lz nh mw mx mb ij bi translated">生成语言模型被训练来预测给定输入序列的下一个最可能的标记。如果我们想要生成10个新令牌，我们可以将此视为10次生成1个新令牌。我们获取原始句子，生成第一个标记，并使用结果句子生成第二个标记，等等。这叫做<em class="my">贪婪解码</em>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ni"><img src="../Images/c04482411f06bcb19496966ae588197b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9mCwmy6k2xdpLPf0l6DdCw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">(图片由作者提供)贪婪解码——连续几次取最优的下一个记号并不能得到句子的最优延续。</p></figure><p id="e535" class="pw-post-body-paragraph ml mm iq lq b lr mz jr mn lt na ju mo lv nf mq mr lx ng mt mu lz nh mw mx mb ij bi translated">如果我们想要生成10个记号的最可能延续，这并不等于连续10次选择最可能的记号——贪婪解码不是最佳的。有时，在给定的步骤中不选择最有可能的下一个标记是有意义的，以便后面的标记可以通过更有可能来补偿这一点。</p><p id="cd05" class="pw-post-body-paragraph ml mm iq lq b lr mz jr mn lt na ju mo lv nf mq mr lx ng mt mu lz nh mw mx mb ij bi translated">波束搜索算法试图通过在每一步考虑K个最可能的下一个记号来减轻贪婪解码的问题。通过考虑更多的记号，我们可以发现这样的情况，在给定的步骤中选择一个不太可能的记号会在随后的步骤中产生更可能的记号。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ni"><img src="../Images/295f8892421f1fd8f1b2cd667cab94fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gzEUuzQrGiLe2jocSIkXFg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">(图片由作者提供)波束搜索—波束搜索算法如何通过考虑提示的多种可能的延续来获得更好的延续。</p></figure><p id="353a" class="pw-post-body-paragraph ml mm iq lq b lr mz jr mn lt na ju mo lv nf mq mr lx ng mt mu lz nh mw mx mb ij bi translated">举个例子，如果我们把句子‘我可爱的狗是a’延续为1 token，最有可能的延续就变成‘我可爱的狗是a little’。然而，如果我们使用波束搜索来找到3个令牌的最有可能的延续，“我可爱的狗有点a”成为最有可能的句子。如果我们只考虑1个标记，那么与“little”相比,“bit”是不太可能的延续，而3个标记的最终结果更可能是“bit”。</p><p id="2e5d" class="pw-post-body-paragraph ml mm iq lq b lr mz jr mn lt na ju mo lv nf mq mr lx ng mt mu lz nh mw mx mb ij bi translated">这个算法是一个启发式算法，这意味着它并不完美。如果K变得更大，并且我们在每一步考虑更多可能的下一个记号，我们将最终得到更可能的最终延续。然而，我们也通过增加算法的计算成本来为此付出代价。</p><p id="434b" class="pw-post-body-paragraph ml mm iq lq b lr mz jr mn lt na ju mo lv nf mq mr lx ng mt mu lz nh mw mx mb ij bi translated">如果你有兴趣了解更多关于语言模型的不同生成技术，我建议<a class="ae kv" href="https://huggingface.co/blog/how-to-generate" rel="noopener ugc nofollow" target="_blank">这篇</a>博客。</p><h1 id="7770" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">如何用自定义的波束搜索算法约束任何语言模型？</h1><p id="4c97" class="pw-post-body-paragraph ml mm iq lq b lr ls jr mn lt lu ju mo lv mp mq mr lx ms mt mu lz mv mw mx mb ij bi translated">通过操纵这种波束搜索算法，我们可以获得符合特定结构的输出。我们可以在特定的步骤动态地将一些下一个令牌的概率设置为零，以确保这些令牌永远不会生成。通过<em class="my">在适当的时候禁止</em>某些令牌，我们可以强制输出遵循任何模式。</p><p id="32cb" class="pw-post-body-paragraph ml mm iq lq b lr mz jr mn lt na ju mo lv nf mq mr lx ng mt mu lz nh mw mx mb ij bi translated">假设我们想要生成一个输出，其中第一个单词以字母“a”开头，第二个以字母“b”开头，第三个以字母“c”开头，第四个又以字母“a”开头，等等。在波束搜索算法的每个步骤中，我们需要检查前一个单词的第一个字母，然后将所有具有错误起始字母的下一个单词的概率设置为零。该模型现在将生成符合这种格式的最可能的句子。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ni"><img src="../Images/a70a67936415465ac2f2ebb0b1e855e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RUXOmELbdBOvNZzcZ0C12Q.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">(图片由作者提供)受约束的束搜索—通过在束搜索算法期间移除我们不需要的标记，我们可以将语言模型的输出约束到预定义的结构。</p></figure><p id="6794" class="pw-post-body-paragraph ml mm iq lq b lr mz jr mn lt na ju mo lv nf mq mr lx ng mt mu lz nh mw mx mb ij bi translated">虽然前面的例子相当简单，但我们可以使用这种技术对生成的句子实施任意约束。</p><h1 id="80c1" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">拥抱脸的实现</h1><p id="fbe4" class="pw-post-body-paragraph ml mm iq lq b lr ls jr mn lt lu ju mo lv mp mq mr lx ms mt mu lz mv mw mx mb ij bi translated">为了节省我们的大量工作，我们将利用<a class="ae kv" href="https://huggingface.co/" rel="noopener ugc nofollow" target="_blank">拥抱脸</a>做许多繁重的工作。实现上述“a - &gt; b - &gt; c”模式的文档代码(使用GPT2)可从<a class="ae kv" href="https://colab.research.google.com/drive/1ezT24sogpVyr2HJLOvXHzjv61JZJ1gMT?usp=sharing" rel="noopener ugc nofollow" target="_blank">这里</a>获得。</p><h1 id="4d77" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">结果呢</h1><p id="325c" class="pw-post-body-paragraph ml mm iq lq b lr ls jr mn lt lu ju mo lv mp mq mr lx ms mt mu lz mv mw mx mb ij bi translated">受限于“a -&gt; b -&gt; c”模式的GPT2以如下方式继续提示“我可爱的狗是a ”:</p><pre class="kg kh ki kj gt nj nk nl nm aw nn bi"><span id="62e7" class="no kx iq nk b gy np nq l nr ns">beam 0: My cute dog is a bit confused about being called a bitch<br/>beam 1: My cute dog is a bit confused about being called a baby<br/>beam 2: My cute dog is a big cat and big cats are big<br/>beam 3: My cute dog is a bit confused about being called a bunny<br/>beam 4: My cute dog is a bit confused about being called a big<br/>beam 5: My cute dog is a bit confused about being called a boy<br/>beam 6: My cute dog is a bit confused about being called a b<br/>beam 7: My cute dog is a bit confused about being called a bad<br/>beam 8: My cute dog is a bit confused about being confused about being<br/>beam 9: My cute dog is a bit confused about being called a black</span></pre><p id="532f" class="pw-post-body-paragraph ml mm iq lq b lr mz jr mn lt na ju mo lv nf mq mr lx ng mt mu lz nh mw mx mb ij bi translated">请注意，模型的输出是如何遵循这种“a -&gt; b -&gt; c”结构的，而我们不必在输入中为模型提供这种模式的任何示例。我特别喜欢该模型仍然设法产生一些连贯的句子——尽管有这种(相当严格的)限制，但如果你是一只狗，被称为兔子是有意义的。</p><h1 id="bde4" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">结论</h1><p id="51da" class="pw-post-body-paragraph ml mm iq lq b lr ls jr mn lt lu ju mo lv mp mq mr lx ms mt mu lz mv mw mx mb ij bi translated">通过编写我们自己版本的波束搜索算法，我们能够约束预训练语言模型的输出。这可以应用于生成型模型，如GPT2和GPT3，甚至seq2seq模型，如T5和T0。当我们希望模型的输出遵循某个预定义的结构或遵循一组规则时，这特别有用。</p><p id="462f" class="pw-post-body-paragraph ml mm iq lq b lr mz jr mn lt na ju mo lv nf mq mr lx ng mt mu lz nh mw mx mb ij bi translated">通过使用拥抱人脸库，我们可以轻松地自己实现这个自定义的波束搜索算法。代码可以在这里<strong class="lq ir">找到<a class="ae kv" href="https://colab.research.google.com/drive/1ezT24sogpVyr2HJLOvXHzjv61JZJ1gMT?usp=sharing" rel="noopener ugc nofollow" target="_blank">。</a></strong></p><p id="2b53" class="pw-post-body-paragraph ml mm iq lq b lr mz jr mn lt na ju mo lv nf mq mr lx ng mt mu lz nh mw mx mb ij bi translated">如果你对从你的语言模型中获得更多价值感兴趣，看看<a class="ae kv" rel="noopener" target="_blank" href="/almost-no-data-and-no-time-unlocking-the-true-potential-of-gpt3-a-case-study-b4710ca0614a">这篇</a>关于<em class="my">提示工程</em>如何帮助你释放你的生成语言模型的真正价值的帖子。</p></div></div>    
</body>
</html>