<html>
<head>
<title>Chest X-ray &amp; Pneumonia: Deep Learning with TensorFlow</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">胸部 x 光和肺炎:使用 TensorFlow 进行深度学习</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/chest-x-ray-pneumonia-deep-learning-with-tensorflow-a58a9e6ade70?source=collection_archive---------24-----------------------#2021-11-01">https://towardsdatascience.com/chest-x-ray-pneumonia-deep-learning-with-tensorflow-a58a9e6ade70?source=collection_archive---------24-----------------------#2021-11-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1fc4" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">处理班级失衡并有效使用预先训练的模型</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/25fd1eea62e666a2b14b2eb9d541f6e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z7lgWl3XrkUpP98vlW8xJA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@cdc?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">疾控中心</a>在<a class="ae ky" href="https://unsplash.com/s/photos/chest-x-ray?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍的胸部 x 光照片</p></figure><p id="3732" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在过去的几年里，我们已经看到以各种形式使用深度学习进行医学诊断的快速增长，特别是在医学图像的分析中。这里我们将建立一个管道，对肺炎患者和非肺炎患者的胸部 x 光图像进行分类。在知识共享许可下，完整的数据集可以在<a class="ae ky" href="https://www.kaggle.com/paultimothymooney/chest-xray-pneumonia" rel="noopener ugc nofollow" target="_blank"> Kaggle </a>获得。在我们建立管道之前，让我们看看你能从这篇文章中学到什么</p><ul class=""><li id="4f82" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><em class="me">使用深度神经网络(DNN)进行二元分类。</em></li><li id="f927" class="lv lw it lb b lc mf lf mg li mh lm mi lq mj lu ma mb mc md bi translated"><em class="me">使用 TensorFlow 数据集创建更快的数据分析管道。</em></li><li id="6b74" class="lv lw it lb b lc mf lf mg li mh lm mi lq mj lu ma mb mc md bi translated"><em class="me">更好的数据预处理技术(例如:标准化)。</em></li><li id="a35f" class="lv lw it lb b lc mf lf mg li mh lm mi lq mj lu ma mb mc md bi translated"><em class="me">tensor flow 模型中的 lambda 层的扩充、重新缩放等。</em></li><li id="065f" class="lv lw it lb b lc mf lf mg li mh lm mi lq mj lu ma mb mc md bi translated"><em class="me">阶层失衡与建筑自定义加权交叉熵损失。</em></li></ul><p id="ce68" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不要耽搁，让我们开始吧！【这里用到的所有代码都可以在<a class="ae ky" href="https://www.kaggle.com/suvoooo/detectpneumonia-inceptionresnetv2-class-imbalance/notebook" rel="noopener ugc nofollow" target="_blank"> Kaggle 笔记本</a>中找到】。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h2 id="ead4" class="mr ms it bd mt mu mv dn mw mx my dp mz li na nb nc lm nd ne nf lq ng nh ni nj bi translated">熟悉数据结构:</h2><p id="66b5" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">因为我们将直接访问 Kaggle 输入目录中的数据，所以让我们来看看标签“正常”和“肺炎”在 Train、Validation 和 Test 文件夹中的分布。下面是我用来检查每个文件夹中文件数量的代码块</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/9f9c28bd9eeddaab92317f6b68ecef6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:986/format:webp/1*TSlUUP1wRv-iGaoUhL690w.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图 1: X 标签代表文件夹名称。训练、测试、验证，N 代表正常，P 代表肺炎。来源:<a class="ae ky" href="https://github.com/suvoooo/Learn-TensorFlow/blob/master/detectpneumonia-inceptionresnetv2-class-imbalance.ipynb" rel="noopener ugc nofollow" target="_blank">作者笔记</a></p></figure><p id="09b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们看到训练图像<em class="me">是类别不平衡的，标记为“肺炎”的图像比“正常”的图像多得多。</em>此外，验证文件夹包含的示例非常少(准确地说是 8 个正常图像和 8 个肺炎图像)。</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="211c" class="mr ms it nt b gy nx ny l nz oa">tot_normal_train = len(train_im_n) + len(valid_im_n) <br/>tot_pneumonia_train = len(train_im_p) + len(valid_im_p)<br/>print ('total normal xray images: ', tot_normal_train)<br/>print ('total pneumonia xray images: ', tot_pneumonia_train)</span><span id="d75c" class="mr ms it nt b gy ob ny l nz oa">&gt;&gt;&gt; total normal xray images:  1349<br/>total pneumonia xray images:  3883</span></pre><p id="3f05" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们也可以想象一些正常和肺炎的图像，如下所示</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/0a37820a76b8ac62622f42f1829e93e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*moy3rnQnkDFyHpZkPw2BUg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">“正常”X 射线图像:原始数据来源:在<a class="ae ky" href="https://www.kaggle.com/paultimothymooney/chest-xray-pneumonia" rel="noopener ugc nofollow" target="_blank"> Kaggle </a>中可用。</p></figure><p id="470d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">类似地，我们也可以查看“肺炎”图像—</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/bbda3d0aba456ca21e73bac35e1831ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kOp1vIH2C6nPyVMCRk0-lg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">肺炎的 x 光图像:原始数据来源:可在<a class="ae ky" href="https://www.kaggle.com/paultimothymooney/chest-xray-pneumonia" rel="noopener ugc nofollow" target="_blank"> Kaggle </a>获得。</p></figure><p id="38e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在阅读了一些在线资源后，比如<a class="ae ky" href="https://www.wikidoc.org/index.php/Pneumonia_chest_x_ray" rel="noopener ugc nofollow" target="_blank">这个</a>，我注意到发现肺炎的通常方法是搜索胸部 x 光片中的阴影。从上面的图片来看，与普通 x 射线相比，这些图像通常看起来不透明。但同样重要的是要记住，胸部 x 光检查可能不会一直告诉我们全部情况，有时视觉结果可能会产生误导。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h2 id="4f7a" class="mr ms it bd mt mu mv dn mw mx my dp mz li na nb nc lm nd ne nf lq ng nh ni nj bi translated">预处理；标准化:</h2><p id="36c1" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">我们将调整图像数据，使数据的新平均值为零，数据的标准偏差为 1。稍后，我们将使用 TensorFlow 数据集，并定义一个函数，在该函数中，图像中的每个像素值都将替换为一个新值，该新值通过减去平均值并除以标准偏差(<em class="me">x</em><em class="me">μ)/σ计算得出。</em>让我们看看标准化如何帮助我们在一些随机示例中分配像素值——</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/a437e3f09673b8895c3f4d186236e11c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T-1DmuGPAfhKqQCs-MSsTw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">对于一些随机图像，标准化(A)之前(B)之后(A)的像素强度分布。来源:<a class="ae ky" href="https://github.com/suvoooo/Learn-TensorFlow/blob/master/detectpneumonia-inceptionresnetv2-class-imbalance.ipynb" rel="noopener ugc nofollow" target="_blank">作者笔记。</a></p></figure><p id="1452" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了包括这种类型的标准化，我们创建了一个函数，该函数将在模型构建中用作 lambda 层。因此，GPU 的能力也将用于这个过程—</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="4c0c" class="mr ms it nt b gy nx ny l nz oa">#### define a function that will be added as lambda layer later<br/>def standardize_layer(tensor):<br/>    tensor_mean = tf.math.reduce_mean(tensor)<br/>    tensor_std = tf.math.reduce_std(tensor)<br/>    new_tensor = (tensor-tensor_mean)/tensor_std<br/>    return new_tensor</span></pre></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h2 id="44f3" class="mr ms it bd mt mu mv dn mw mx my dp mz li na nb nc lm nd ne nf lq ng nh ni nj bi translated">使用 TensorFlow 数据集构建输入管道:</h2><p id="c0fd" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">在之前的一篇<a class="ae ky" rel="noopener" target="_blank" href="/time-to-choose-tensorflow-data-over-imagedatagenerator-215e594f2435">帖子</a>中，我详细描述了如何使用<a class="ae ky" href="https://www.tensorflow.org/api_docs/python/tf/data/Dataset" rel="noopener ugc nofollow" target="_blank"> TensorFlow 数据集 API </a>构建包括增强在内的输入管道来加速 DNN 训练。我将遵循类似的步骤。由于图像数据存在于训练、测试和验证文件夹中，我们可以从<code class="fe of og oh nt b"><a class="ae ky" href="https://keras.io/api/preprocessing/image/" rel="noopener ugc nofollow" target="_blank">image_dataset_from_directory</a></code>功能开始——</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="26ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们之前检查的，验证目录中只有 16 个文件，只使用 16 个图像进行验证并不是一个好主意。因此，我们需要添加训练和验证数据集，然后按照合理的百分比对它们进行拆分。首先，让我们检查“训练”和“有效”数据集中的元素数量。</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="38ae" class="mr ms it nt b gy nx ny l nz oa">num_elements = tf.data.experimental.cardinality(train_dir).numpy()<br/>print (num_elements)<br/>num_elements_val = tf.data.experimental.cardinality(val_dir).numpy()<br/>print (num_elements_val)</span><span id="6a4d" class="mr ms it nt b gy ob ny l nz oa">&gt;&gt;&gt; 82<br/>1</span></pre><p id="34cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们看到有 82 个训练批次和 1 个验证批次。为了增加验证批次，首先，让我们连接“训练”和“验证”数据集。然后，我们将总数据集的 20%分配给验证，并使用下面的代码块使用<code class="fe of og oh nt b">dataset.take</code>和<code class="fe of og oh nt b">dataset.skip</code>来创建新的数据集—</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="08a2" class="mr ms it nt b gy nx ny l nz oa">new_train_ds = train_dir.concatenate(val_dir)<br/><br/>print (new_train_ds, train_dir)<br/><br/>train_size = int(0.8 * 83) <em class="me"># 83 is the elements in dataset (train + valid)</em><br/>val_size = int(0.2 * 83)<br/>    <br/>train_ds = new_train_ds.take(train_size)<br/>val_ds = new_train_ds.skip(train_size).take(val_size)<br/><br/><br/><em class="me">#### check the dataset size back again </em><br/>num_elements_train = tf.data.experimental.cardinality(train_ds).numpy()<br/>print (num_elements_train)<br/>num_elements_val_ds = tf.data.experimental.cardinality(val_ds).numpy()<br/>print (num_elements_val_ds)</span><span id="629c" class="mr ms it nt b gy ob ny l nz oa">&gt;&gt;&gt; &lt;ConcatenateDataset shapes: ((None, 300, 300, 1), (None, 1)), types: (tf.float32, tf.float32)&gt; &lt;BatchDataset shapes: ((None, 300, 300, 1), (None, 1)), types: (tf.float32, tf.float32)&gt;<br/>66<br/>16</span></pre><p id="0aab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我已经描述了<a class="ae ky" rel="noopener" target="_blank" href="/time-to-choose-tensorflow-data-over-imagedatagenerator-215e594f2435"> <strong class="lb iu">【预取】技术</strong> </a>以及它比 ImageDataGenerator 快多少。让我们加上这个—</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="cd93" class="mr ms it nt b gy nx ny l nz oa">autotune = tf.data.AUTOTUNE ### most important function for speed up training<br/><br/><br/>train_data_batches = train_ds.cache().prefetch(buffer_size=autotune)<br/>valid_data_batches = val_ds.cache().prefetch(buffer_size=autotune)<br/>test_data_batches = test_dir.cache().prefetch(buffer_size=autotune)</span></pre><p id="110c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我还将添加一个重缩放层和一些增强层，这些都将作为 lambda 层包含在模型中。让我们把它们定义如下—</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="b9c2" class="mr ms it nt b gy nx ny l nz oa">from tensorflow.keras import layers<br/><br/>rescale_layer = tf.keras.Sequential([layers.experimental.preprocessing.Rescaling(1./255)])<br/><br/>data_augmentation = tf.keras.Sequential([<br/>  layers.experimental.preprocessing.RandomFlip(),<br/>  layers.experimental.preprocessing.RandomRotation(10), <br/>  layers.experimental.preprocessing.RandomZoom(0.1) ])</span></pre></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h2 id="0b04" class="mr ms it bd mt mu mv dn mw mx my dp mz li na nb nc lm nd ne nf lq ng nh ni nj bi translated">加权二元交叉熵损失；</h2><p id="afd8" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">使用加权 BCE 损失背后的想法是，由于我们有比“正常”更多的“肺炎”x 射线图像，该模型对它们的错误分类进行了加权。因此，我们改变了这种偏见，并试图迫使模型对正常和肺炎图像进行同等加权。我们根据每个类别的图像数量除以图像总数来计算频率项。这些权重随后用于构建<em class="me">定制加权 BCE 损失函数</em>。下面的代码块是用于给定问题的一个例子</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h2 id="39ef" class="mr ms it bd mt mu mv dn mw mx my dp mz li na nb nc lm nd ne nf lq ng nh ni nj bi translated">建立一个 DNN 模型，包括扩展:</h2><p id="b1a9" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">在定义了适当的定制损失函数之后，我们剩下的是构建一个包括作为 lambda 层的重新缩放和增强的模型。对于给定的工作，我使用了 InceptionResNetV2 预训练模型，你可以在这里检查 Keras 模块<a class="ae ky" href="https://keras.io/api/applications/inceptionresnetv2/" rel="noopener ugc nofollow" target="_blank"/>。在 Kaggle 比赛中，我们不允许使用互联网，所以我需要下载预先训练的重量，这解释了 InceptionResNetV2 函数中的<code class="fe of og oh nt b">weights</code>参数。在将图像批次馈送到模型之前，重新缩放、标准化&amp;增强都作为 lambda 层添加。让我们看看下面的代码块—</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="511a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">编译后，包括一些“回调”,我们准备好训练模型。为了评估模型对测试数据的性能，我们可以绘制混淆矩阵和 ROC 曲线。</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="9a6a" class="mr ms it nt b gy nx ny l nz oa">y_pred = model.predict(test_data_batches)<br/>true_categories = tf.concat([y for x, y in test_data_batches], axis=0)</span></pre><p id="60ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们设置一个 0.75 的阈值来分配标签“1”和任何低于标签“0”的值。</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="fb18" class="mr ms it nt b gy nx ny l nz oa">y_pred_th = (y_pred &gt; 0.75).astype(np.float32)</span><span id="0022" class="mr ms it nt b gy ob ny l nz oa">from sklearn.metrics import confusion_matrix<br/>cm = confusion_matrix(y_pred_th, true_categories)</span><span id="346e" class="mr ms it nt b gy ob ny l nz oa">class_names = train_dir.class_names</span><span id="84a6" class="mr ms it nt b gy ob ny l nz oa">plt.figure(figsize=(8,8))<br/>plt.title('CM for threshold 0.75')<br/>sns_hmp = sns.heatmap(cm, annot=True, xticklabels = [class_names[i] for i in range(len(class_names))], <br/>                      yticklabels = [class_names[i] for i in range(len(class_names))], fmt="d")<br/>fig = sns_hmp.get_figure()</span></pre><p id="e0b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的代码块导致了下面的混乱矩阵—</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/459aa0e1501b3ce52b08978e8dce1033.png" data-original-src="https://miro.medium.com/v2/resize:fit:916/format:webp/1*Wc3f4QrLh2mTkjy_DQCOjA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">二元分类的混淆矩阵。(来源:<a class="ae ky" href="https://github.com/suvoooo/Learn-TensorFlow/blob/master/detectpneumonia-inceptionresnetv2-class-imbalance.ipynb" rel="noopener ugc nofollow" target="_blank">作者笔记</a>)</p></figure><p id="7a78" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">类似地，我们也可以绘制 ROC 曲线，结果如下所示—</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/c3d5691410abbe1ea662e94f75a97662.png" data-original-src="https://miro.medium.com/v2/resize:fit:788/format:webp/1*rApyg0H-hh3RMOkptcT1Ig.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">ROC 曲线为‘正常’和‘肺炎’图像分类。(来源:<a class="ae ky" href="https://github.com/suvoooo/Learn-TensorFlow/blob/master/detectpneumonia-inceptionresnetv2-class-imbalance.ipynb" rel="noopener ugc nofollow" target="_blank">作者笔记</a>)</p></figure></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h2 id="201a" class="mr ms it bd mt mu mv dn mw mx my dp mz li na nb nc lm nd ne nf lq ng nh ni nj bi translated">最终注释:</h2><p id="0850" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">上面使用的所有代码都可以在我的<a class="ae ky" href="https://github.com/suvoooo/Learn-TensorFlow/blob/master/detectpneumonia-inceptionresnetv2-class-imbalance.ipynb" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到，你也可以查看<a class="ae ky" href="https://www.kaggle.com/suvoooo/detectpneumonia-inceptionresnetv2-class-imbalance" rel="noopener ugc nofollow" target="_blank"> Kaggle 笔记本</a>。所使用的数据集在许可<a class="ae ky" href="https://creativecommons.org/licenses/by/4.0/" rel="noopener ugc nofollow" target="_blank">知识共享</a>下的<a class="ae ky" href="https://www.kaggle.com/paultimothymooney/chest-xray-pneumonia" rel="noopener ugc nofollow" target="_blank"> Kaggle </a>中可用，因此我们可以自由使用和调整。最后，总结一下，我们经历了一个包括类不平衡数据集的数据分析管道，并学会了有效地使用 TensorFlow 数据集。</p><p id="1080" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">保持坚强，干杯！</p></div></div>    
</body>
</html>