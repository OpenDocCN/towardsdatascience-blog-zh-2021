<html>
<head>
<title>How to generate a vector of random numbers on a GPU</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在GPU上生成随机数向量</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-generate-a-vector-of-random-numbers-on-a-gpu-a37230f887a6?source=collection_archive---------29-----------------------#2021-07-13">https://towardsdatascience.com/how-to-generate-a-vector-of-random-numbers-on-a-gpu-a37230f887a6?source=collection_archive---------29-----------------------#2021-07-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/3fbd001b98a6d355493e65dcc5b50bde.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*vcqWDkuxglmdpaWh"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">蒂莫西·戴克斯在<a class="ae jd" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><div class=""/><div class=""><h2 id="77f9" class="pw-subtitle-paragraph kd jf jg bd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dk translated">解决老问题的现代硬件</h2></div><p id="a084" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">随机数是数据科学家生活中必不可少的一部分。例如，如果你需要初始化神经网络的矩阵，使用零模型执行数据分析，或者甚至在运行<a class="ae jd" href="https://en.wikipedia.org/wiki/Monte_Carlo_method" rel="noopener ugc nofollow" target="_blank">蒙特卡罗模拟</a>时，你必须生成它们。</p><p id="1c4d" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">想象一下，你必须生成<strong class="kx jh">许多独立的随机数序列</strong>，比方说，一组<a class="ae jd" href="https://en.wikipedia.org/wiki/Markov_chain_Monte_Carlo" rel="noopener ugc nofollow" target="_blank">蒙特卡罗马尔可夫链</a> (MCMC)。在这类问题中，给定一个起点和一个规则来产生状态<em class="lr"> n+1 </em>给定状态<em class="lr"> n </em>就有可能对给定分布的许多状态进行采样。也可以使用MCMC来执行<strong class="kx jh">自然语言处理</strong>【1】。</p><p id="50e1" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在多个独立对象上执行相同任务的理想硬件是图形处理单元。事实上，GPU可以被编程为运行多个独立的<strong class="kx jh">线程</strong>，这些线程同时执行相同的操作。</p><p id="8a49" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在这里，我将描述一个简单的例子，如何使用苹果金属框架生成随机数序列，以在快速<strong class="kx jh"> GPU硬件</strong>上运行操作。</p><h1 id="9353" class="ls lt jg bd lu lv lw lx ly lz ma mb mc km md kn me kp mf kq mg ks mh kt mi mj bi translated">随机数的向量</h1><p id="2529" class="pw-post-body-paragraph kv kw jg kx b ky mk kh la lb ml kk ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">这里的思路是生成一个<strong class="kx jh">独立</strong> <strong class="kx jh">随机</strong>数字<strong class="kx jh">均匀</strong> <strong class="kx jh">分布</strong>的向量。举例来说，每个数字可以代表马尔可夫链末端的一个状态。</p><p id="eb8a" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">该代码由三部分组成:</p><ul class=""><li id="976b" class="mp mq jg kx b ky kz lb lc le mr li ms lm mt lq mu mv mw mx bi translated">准备好初始状态(种子)的向量<strong class="kx jh"/></li><li id="2859" class="mp mq jg kx b ky my lb mz le na li nb lm nc lq mu mv mw mx bi translated">这个向量被传递给GPU和<strong class="kx jh">每个线程运行</strong>一个链并输出一个单一的数字(状态)</li><li id="6b57" class="mp mq jg kx b ky my lb mz le na li nb lm nc lq mu mv mw mx bi translated">状态从GPU<strong class="kx jh">复制</strong>到CPU，然后再复制到<strong class="kx jh">磁盘</strong>上的文件中，以便稍后进行分析。</li></ul><h1 id="ca41" class="ls lt jg bd lu lv lw lx ly lz ma mb mc km md kn me kp mf kq mg ks mh kt mi mj bi translated">在GPU上运行</h1><p id="13e5" class="pw-post-body-paragraph kv kw jg kx b ky mk kh la lb ml kk ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">我选择利用Apple Metal Framework来执行上述操作，并在GPU上执行操作。整个代码可以很容易地翻译成其他语言，如<a class="ae jd" href="https://opencl.org/" rel="noopener ugc nofollow" target="_blank"> OpenCL </a>或<a class="ae jd" href="https://developer.nvidia.com/cuda-zone" rel="noopener ugc nofollow" target="_blank"> CUDA </a>。</p><div class="ip iq gp gr ir nd"><a href="https://developer.apple.com/metal/" rel="noopener  ugc nofollow" target="_blank"><div class="ne ab fo"><div class="nf ab ng cl cj nh"><h2 class="bd jh gy z fp ni fr fs nj fu fw jf bi translated">金属苹果显影剂</h2><div class="nk l"><h3 class="bd b gy z fp ni fr fs nj fu fw dk translated">为了更好地实现最新的GPU渲染技术，您现在可以调用动态库，使用函数指针，以及…</h3></div><div class="nl l"><p class="bd b dl z fp ni fr fs nj fu fw dk translated">developer.apple.com</p></div></div><div class="nm l"><div class="nn l no np nq nm nr ix nd"/></div></div></a></div><p id="bc9e" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了对Metal上的数据执行流水线，我们需要创建一个<em class="lr">命令缓冲区</em>，将命令写入其中，并将缓冲区提交给命令队列。Metal将<a class="ae jd" href="https://developer.apple.com/documentation/metal/basic_tasks_and_concepts/performing_calculations_on_a_gpu?preferredLanguage=occ" rel="noopener ugc nofollow" target="_blank">发送命令</a>给GPU执行。</p><p id="47da" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在本例中，我们将使用<em class="lr"> ComputeCommandBuffer </em>，因为我们的任务是计算任务，而不是图形任务。</p><p id="7e77" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们用C++编写的包装了金属代码的程序将在Mac内置的GPU上高效运行。</p><figure class="nt nu nv nw gt is gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/db928adc743802a493f8f881f5764371.png" data-original-src="https://miro.medium.com/v2/resize:fit:1252/format:webp/1*iMoRLMlN6P3w47JNMMx9Ag.png"/></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">计算期间的GPU使用统计。图片作者。</p></figure><h1 id="281b" class="ls lt jg bd lu lv lw lx ly lz ma mb mc km md kn me kp mf kq mg ks mh kt mi mj bi translated">算法</h1><p id="ac77" class="pw-post-body-paragraph kv kw jg kx b ky mk kh la lb ml kk ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">(伪)随机数的生成从一个名为<em class="lr">种子</em>的整数值开始。然后，有<a class="ae jd" href="https://en.wikipedia.org/wiki/List_of_random_number_generators" rel="noopener ugc nofollow" target="_blank">种不同的方法</a>产生后续随机数；Mersenne Twister和xorshift就是两个例子。</p><h2 id="330a" class="nx lt jg bd lu ny nz dn ly oa ob dp mc le oc od me li oe of mg lm og oh mi oi bi translated">梅森扭结算法</h2><p id="1fe7" class="pw-post-body-paragraph kv kw jg kx b ky mk kh la lb ml kk ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated"><a class="ae jd" href="https://en.wikipedia.org/wiki/Mersenne_Twister" rel="noopener ugc nofollow" target="_blank">梅森扭结器</a>是一个<strong class="kx jh">伪随机数发生器</strong>，也是目前使用最广泛的<strong class="kx jh">通用型</strong>。它是由松本诚和西村拓治在1997年开发的，它是专门为纠正老式发电机的大部分缺陷而设计的。</p><p id="8af0" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">最常用的梅森扭转算法是基于梅森素数2 ⁹⁹ ⁷-1.它的标准实现，<em class="lr"> MT19937 </em>，使用32位<strong class="kx jh">字长。</strong></p><p id="65d9" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在这个例子中，我将使用Mersenne Twister 的<a class="ae jd" href="https://github.com/fvalle1/latentrees/blob/main/independentrees/metal/mersenne.metal" rel="noopener ugc nofollow" target="_blank">金属实现。</a></p><h2 id="b323" class="nx lt jg bd lu ny nz dn ly oa ob dp mc le oc od me li oe of mg lm og oh mi oi bi translated">马萨格里亚的xorshift</h2><p id="110f" class="pw-post-body-paragraph kv kw jg kx b ky mk kh la lb ml kk ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">另一个容易实现的生成随机数的算法是xorshift [3]。这是一种非常快速的发电机。它的创造者还建议对xorwow生成器进行改进，其中xorshift生成器的输出添加了一个<a class="ae jd" href="https://en.wikipedia.org/wiki/Weyl_sequence" rel="noopener ugc nofollow" target="_blank"> Weyl序列</a>。xorwow生成器是nVidia <a class="ae jd" href="https://en.wikipedia.org/wiki/CUDA" rel="noopener ugc nofollow" target="_blank"> CUDA </a>图形处理单元应用编程接口的CURAND库中的默认生成器。</p><p id="68e2" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx jh"> xorshift </strong>的GPU实现如下。</p><pre class="nt nu nv nw gt oj ok ol om aw on bi"><span id="e8fa" class="nx lt jg ok b gy oo op l oq or">uint rand_xorshift(uint rng_state){    <br/>    rng_state ^= (rng_state &lt;&lt; 13);<br/>    rng_state ^= (rng_state &gt;&gt; 17);    <br/>    rng_state ^= (rng_state &lt;&lt; 5);    <br/>    return rng_state;<br/>}</span></pre><p id="7c61" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这可以<a class="ae jd" href="https://github.com/fvalle1/latentrees/blob/main/independentrees/opencl/random.cl" rel="noopener ugc nofollow" target="_blank">方便地</a>移植到其他GPU编程语言，如<a class="ae jd" href="https://opencl.org/" rel="noopener ugc nofollow" target="_blank"> OpenCL </a>。</p><h1 id="6cda" class="ls lt jg bd lu lv lw lx ly lz ma mb mc km md kn me kp mf kq mg ks mh kt mi mj bi translated">示例和运行</h1><p id="1d38" class="pw-post-body-paragraph kv kw jg kx b ky mk kh la lb ml kk ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">在示例中，我将描述线程应该生成从边界为0和1000的<strong class="kx jh">均匀分布</strong>中抽取的随机数。</p><p id="0301" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">下面显示的Metal代码显示了在每个GPU线程上生成100个随机数并将最后一个存储到一个数组(vOut)的过程示例，该数组稍后将由CPU代码访问。</p><p id="a316" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">每个线程都有一个由主CPU线程通过<em class="lr"> vIn </em>数组传递的<em class="lr">种子</em>。然后每个线程创建自己的生成器</p><pre class="nt nu nv nw gt oj ok ol om aw on bi"><span id="e230" class="nx lt jg ok b gy oo op l oq or">#include &lt;metal_stdlib&gt;</span><span id="41b5" class="nx lt jg ok b gy os op l oq or">#include “mersenne.metal”<br/>using namespace metal;<br/>kernel void storyMersenne(<br/>const device uint *vIn [[ buffer(0) ]],<br/>device int *vOut [[ buffer(1) ]],<br/>uint id[[ thread_position_in_grid ]]){</span><span id="0d26" class="nx lt jg ok b gy os op l oq or">mt19937 generator;</span><span id="995b" class="nx lt jg ok b gy os op l oq or">generator(vIn[id]);</span><span id="28bf" class="nx lt jg ok b gy os op l oq or">uint r;<br/>for (uint l = 0; l &lt; 100; l++) r = generator.rand();</span><span id="6a4d" class="nx lt jg ok b gy os op l oq or">vOut[id] = r;</span><span id="e8a2" class="nx lt jg ok b gy os op l oq or">}</span></pre><p id="e49c" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当GPU的每个线程都生成了随机数时，就可以查看它们的分布，并验证它们是否如预期的那样<strong class="kx jh">均匀分布</strong>。</p><figure class="nt nu nv nw gt is gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/f1934a8c4db352350f64858b8c60aabd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*SCaM2fc4WmIyh7hoYlvOcA.png"/></div></figure><p id="1424" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">图中显示<strong class="kx jh">是的</strong>，它们分布均匀。</p><h2 id="e6a5" class="nx lt jg bd lu ny nz dn ly oa ob dp mc le oc od me li oe of mg lm og oh mi oi bi translated">如果有多次运行呢</h2><p id="d914" class="pw-post-body-paragraph kv kw jg kx b ky mk kh la lb ml kk ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">可以用来评估随机数生成器的另一个标准是，生成的随机数序列很有可能<strong class="kx jh">互不相同</strong>。</p><p id="80c4" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我测试了这个事实，生成了多个随机数序列，并研究了它们之间的相关性。该图显示不同运行中产生的点实际上<strong class="kx jh">不相关</strong>。</p><figure class="nt nu nv nw gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ou"><img src="../Images/da2542dfe2ad739f5669270630f166bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lZ697rrTYF_PxNTHDU5xzQ.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">不同运行的相关性。图片作者。</p></figure><h1 id="d81a" class="ls lt jg bd lu lv lw lx ly lz ma mb mc km md kn me kp mf kq mg ks mh kt mi mj bi translated">结论</h1><p id="0b7d" class="pw-post-body-paragraph kv kw jg kx b ky mk kh la lb ml kk ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">在许多应用中，拥有一个<strong class="kx jh">好的随机数来源</strong>是必要的。快速生成它们将是一个优势。</p><p id="4a40" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当您必须进行涉及随机数序列的计算或<strong class="kx jh">马尔可夫链蒙特卡罗</strong>时，只要它们是独立的，并且知道<strong class="kx jh"> GPU硬件已经过优化</strong>可以并行执行许多操作，那么使用Metal或OpenCL中实现的算法来生成它们可能是一个不错的选择。</p><p id="d5ca" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">一个简单的例子表明，利用MacBook GPU可以轻松生成均匀分布且不相关的随机数。</p><h1 id="c5ee" class="ls lt jg bd lu lv lw lx ly lz ma mb mc km md kn me kp mf kq mg ks mh kt mi mj bi translated">参考</h1><p id="2493" class="pw-post-body-paragraph kv kw jg kx b ky mk kh la lb ml kk ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">[1] Gerlach，m .，Pexioto T.P .，Altmann E.G. <a class="ae jd" href="https://advances.sciencemag.org/content/4/7/eaaq1360?intcmp=trendmd-adv&amp;utm_source=TrendMD&amp;utm_medium=cpc&amp;utm_campaign=TrendMD_1" rel="noopener ugc nofollow" target="_blank">主题模型的网络方法。</a> (2018)</p><p id="bf6f" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">[2]杰森·r·布莱文斯<a class="ae jd" href="https://github.com/naleksiev/mtlpp" rel="noopener ugc nofollow" target="_blank"> C++梅森扭扭器包装器类</a> (2006)。</p><p id="82c6" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">[3]乔治·马萨利亚。<a class="ae jd" href="https://doi.org/10.22237/jmasm/1051747320" rel="noopener ugc nofollow" target="_blank">随机数发生器</a>。(2003)现代应用统计方法杂志。</p></div></div>    
</body>
</html>