<html>
<head>
<title>Nearest Neighbor Analysis for Large Datasets in Helsinki Region</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">赫尔辛基地区大数据集的最近邻分析</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/nearest-neighbor-analysis-for-large-datasets-in-helsinki-79ebc7288c91?source=collection_archive---------26-----------------------#2021-12-29">https://towardsdatascience.com/nearest-neighbor-analysis-for-large-datasets-in-helsinki-79ebc7288c91?source=collection_archive---------26-----------------------#2021-12-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="87cf" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用于高效距离分析的 BallTree 函数:公交车站和餐馆</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/553f02f2665043ec73bcf21ad5e70840.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bfqOaBqUkJC2MTYiwE3C4A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由作者提供。离每个从 OSM 回来的餐馆(黄色)最近的公共汽车站(粉红色)。<a class="ae ky" href="https://bryanvallejo16.github.io/nearest_neighbor_large_dataset/" rel="noopener ugc nofollow" target="_blank">演示</a></p></figure><p id="f78f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在过去的几个月里，我作为一名研究助理参加了赫尔辛基大学著名的<a class="ae ky" href="https://autogis-site.readthedocs.io/en/latest/notebooks/L3/06_nearest-neighbor-faster.html" rel="noopener ugc nofollow" target="_blank"> <em class="lv">自动化 GIS </em> </a>课程。在给学生们讲解 GIS 自动化流程的过程中，我的经验非常丰富。我很高兴看到地理学家是如何用 python 语言编程接管 GIS 自动化的，我仍然对材料的高质量感到惊讶。在课程开始时，课程会就 python 的用法和 GIS 中常用对象的基本概念给出建议。然后，这些类变成了深入和高级的分析，在广泛的应用中非常有用。</p><p id="01f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我将永远记住的一课是最近邻分析。这是一种来自<a class="ae ky" href="https://shapely.readthedocs.io/en/stable/manual.html" rel="noopener ugc nofollow" target="_blank"> shapely </a>库的算法，可以从选定的点中检索最近的点。在此过程中，它使用一元并集函数，这会消耗内存并降低操作速度。因此，在本教程中，我们将使用<a class="ae ky" href="https://en.wikipedia.org/wiki/Ball_tree" rel="noopener ugc nofollow" target="_blank"> BallTree </a>函数，而不是一元并集，这样可以加快进程并消耗更少的内存。</p><blockquote class="lw"><p id="5da2" class="lx ly it bd lz ma mb mc md me mf lu dk translated">最终网络地图:<a class="ae ky" href="https://bryanvallejo16.github.io/nearest_neighbor_large_dataset/" rel="noopener ugc nofollow" target="_blank">演示</a> <br/>仓库代码:<a class="ae ky" href="https://github.com/bryanvallejo16/nearest_neighbor_large_dataset" rel="noopener ugc nofollow" target="_blank">回购</a></p></blockquote><p id="99d5" class="pw-post-body-paragraph kz la it lb b lc mg ju le lf mh jx lh li mi lk ll lm mj lo lp lq mk ls lt lu im bi translated">对于这个示例，我将使用赫尔辛基作为研究案例，并查找该城市中距离餐馆最近的所有公交车站。在此过程中，从 Geoff Boeing 开发的 python 库 OSMnx 中获取餐馆，从赫尔辛基地区的 GTFS 数据集(最新数据集)中获取公交车站。我们开始吧</p><h1 id="aa4e" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">数据集</h1><p id="9175" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">本文中使用的数据集和所用材料的许可证的简要描述。</p><ul class=""><li id="402f" class="nk nl it lb b lc ld lf lg li nm lm nn lq no lu np nq nr ns bi translated">赫尔辛基地区的 GTFS 数据集。根据<a class="ae ky" href="https://creativecommons.org/publicdomain/zero/1.0/legalcode" rel="noopener ugc nofollow" target="_blank">知识共享协议 CC0 </a>获得许可。这个数据集是通过<a class="ae ky" href="https://transitfeeds.com/about" rel="noopener ugc nofollow" target="_blank"> OpenMobilitydata </a>收集的，OpenMobilitydata 是一个为交通数据、应用开发者、网络开发者和交通机构提供的免费服务。</li><li id="54c7" class="nk nl it lb b lc nt lf nu li nv lm nw lq nx lu np nq nr ns bi translated"><strong class="lb iu">打开街道地图数据。</strong>根据<a class="ae ky" href="https://opendatacommons.org/licenses/odbl/" rel="noopener ugc nofollow" target="_blank">开放数据共享开放数据库许可证(ODbl) </a>或归属许可证获得许可。用户可以自由地复制、分发、传输和改编这些数据，只要这些数据是像<a class="ae ky" href="https://www.openstreetmap.org/copyright" rel="noopener ugc nofollow" target="_blank"> OpenStreetMap </a>贡献者这样的作者所拥有的。</li><li id="b602" class="nk nl it lb b lc nt lf nu li nv lm nw lq nx lu np nq nr ns bi translated"><strong class="lb iu">自动化 GIS 教学材料。</strong>根据<a class="ae ky" href="https://creativecommons.org/licenses/by-sa/4.0/legalcode" rel="noopener ugc nofollow" target="_blank">知识共享署名-相似分享 4.0 </a>国际许可证获得许可。用户可以在归属下自由分享和改编。课程是公开分享的，在使用资料后，建议也公开分享资料。</li></ul><h1 id="855c" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">编码实践</h1><p id="9f9b" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">从最重要的开始。导入所需的库。</p><pre class="kj kk kl km gt ny nz oa ob aw oc bi"><span id="bdc2" class="od mo it nz b gy oe of l og oh"><strong class="nz iu">import </strong>geopandas <strong class="nz iu">as </strong>gpd<br/><strong class="nz iu">import </strong>pandas <strong class="nz iu">as </strong>pd<br/><strong class="nz iu">import </strong>osmnx <strong class="nz iu">as </strong>ox<br/><strong class="nz iu">import </strong>matplotlib.pyplot <strong class="nz iu">as </strong>plt<br/><strong class="nz iu">from </strong>shapely.geometry <strong class="nz iu">import </strong>Point, LineString</span></pre><p id="91e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们用 OSMnx 获取感兴趣的区域。赫尔辛基</p><pre class="kj kk kl km gt ny nz oa ob aw oc bi"><span id="ae51" class="od mo it nz b gy oe of l og oh"><strong class="nz iu"># Specify the name that is used to seach for the data<br/></strong>place_name = “Helsinki, Finland”</span><span id="7687" class="od mo it nz b gy oi of l og oh"><strong class="nz iu"># Fetch OSM street network from the location<br/></strong>graph = ox.graph_from_place(place_name)</span><span id="9514" class="od mo it nz b gy oi of l og oh"><strong class="nz iu"># Plot the streets<br/></strong>fig, ax = ox.plot_graph(graph)</span><span id="86ab" class="od mo it nz b gy oi of l og oh"><strong class="nz iu"># Get place boundary related to the place name as a geodataframe<br/></strong>area = ox.geocode_to_gdf(place_name)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/6ac114e4c8ad6d031b1a982516f2c1e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1106/format:webp/1*LLfQISKtz_7QN1krJVudww.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由作者提供。图形对象的绘图</p></figure><p id="b066" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们从 OSMnx 获取并安排餐馆</p><pre class="kj kk kl km gt ny nz oa ob aw oc bi"><span id="9646" class="od mo it nz b gy oe of l og oh"><strong class="nz iu"># List key-value pairs for tags such as restaurants<br/></strong>tags = {‘amenity’: ‘restaurant’}</span><span id="5469" class="od mo it nz b gy oi of l og oh"><strong class="nz iu"># Retrieve restaurants<br/></strong>restaurants = ox.geometries_from_place(place_name, tags)</span><span id="bc37" class="od mo it nz b gy oi of l og oh"><strong class="nz iu"># getting centroids from restaurants to avoid polygon geometric objects<br/></strong>restaurants[‘geometry’] = [geom.centroid for geom in restaurants[‘geometry’]]</span><span id="0388" class="od mo it nz b gy oi of l og oh"><strong class="nz iu"># reset index<br/></strong>restaurants = restaurants.reset_index(drop=True)</span></pre><p id="0c8b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，餐馆已在格式化的地理数据框架中，我们将从赫尔辛基地区的<a class="ae ky" href="https://transitfeeds.com/p/helsinki-regional-transport/735" rel="noopener ugc nofollow" target="_blank"> GTFS 数据集中读取停靠点文件，并创建另一个地理数据框架</a></p><pre class="kj kk kl km gt ny nz oa ob aw oc bi"><span id="1c32" class="od mo it nz b gy oe of l og oh"><strong class="nz iu"># read the stops<br/></strong>stops = pd.read_csv(r’gtfs/stops.txt’, sep=’,’)</span><span id="1aac" class="od mo it nz b gy oi of l og oh"><strong class="nz iu"># creating geodataframe of stops<br/></strong>stops[‘geometry’] = None</span><span id="240b" class="od mo it nz b gy oi of l og oh">stops_gdf = gpd.GeoDataFrame(stops, geometry = ‘geometry’, crs=4326)</span><span id="0b9c" class="od mo it nz b gy oi of l og oh">stops_gdf[‘geometry’] = [Point(lon, lat) for lon, lat in zip(stops_gdf[‘stop_lon’], stops_gdf[‘stop_lat’])]</span><span id="78f2" class="od mo it nz b gy oi of l og oh"><strong class="nz iu"># Clip stops from the area of interest<br/></strong>stops_mask = gpd.clip(stops_gdf, area)</span></pre><p id="011e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们画一个图，看看到目前为止它看起来怎么样</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ok"><img src="../Images/d29540dc4b576d466576520eb4c1be35.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o-S161zmsoGcr3DiJHLw0g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由作者提供。公共汽车站(蓝色)和餐馆(红色)</p></figure><p id="5653" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们有了我们需要的东西，我们将定义几个函数来帮助找到最近的邻居</p><pre class="kj kk kl km gt ny nz oa ob aw oc bi"><span id="7b70" class="od mo it nz b gy oe of l og oh"><strong class="nz iu">from </strong>sklearn.neighbors <strong class="nz iu">import</strong> BallTree<br/><strong class="nz iu">import </strong>numpy <strong class="nz iu">as </strong>np</span></pre><p id="4b12" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一个功能。</p><pre class="kj kk kl km gt ny nz oa ob aw oc bi"><span id="d44a" class="od mo it nz b gy oe of l og oh"><strong class="nz iu">def </strong>get_nearest(src_points, candidates, k_neighbors=1):<br/> '''<br/><strong class="nz iu">Find nearest neighbors for all source points from a set of candidate points</strong><br/>'''</span><span id="94b4" class="od mo it nz b gy oi of l og oh"><strong class="nz iu"># Create tree from the candidate points<br/></strong> tree = BallTree(candidates, leaf_size=15, metric=’haversine’)</span><span id="83c3" class="od mo it nz b gy oi of l og oh"><strong class="nz iu"># Find closest points and distances<br/></strong> distances, indices = tree.query(src_points, k=k_neighbors)</span><span id="c839" class="od mo it nz b gy oi of l og oh"><strong class="nz iu"># Transpose to get distances and indices into arrays<br/></strong> distances = distances.transpose()<br/> indices = indices.transpose()</span><span id="8e64" class="od mo it nz b gy oi of l og oh"><strong class="nz iu"># Get closest indices and distances (i.e. array at index 0)<br/> # note: for the second closest points, you would take index 1, etc.<br/></strong> closest = indices[0]<br/> closest_dist = distances[0]</span><span id="1434" class="od mo it nz b gy oi of l og oh"><strong class="nz iu"># Return indices and distances<br/></strong> <strong class="nz iu">return </strong>(closest, closest_dist)</span></pre><p id="ba87" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第二个功能。</p><pre class="kj kk kl km gt ny nz oa ob aw oc bi"><span id="4d75" class="od mo it nz b gy oe of l og oh"><strong class="nz iu">def</strong> nearest_neighbor(left_gdf, right_gdf, return_dist=False):<br/>'''<br/><strong class="nz iu"> For each point in left_gdf, find closest point in right GeoDataFrame and return them.<br/> <br/> NOTICE: Assumes that the input Points are in WGS84 projection (lat/lon).</strong><br/>'''<br/> <br/> left_geom_col = left_gdf.geometry.name<br/> right_geom_col = right_gdf.geometry.name<br/> <br/><strong class="nz iu"> # Ensure that index in right gdf is formed of sequential numbers<br/></strong> right = right_gdf.copy().reset_index(drop=True)<br/> <br/><strong class="nz iu"> # Parse coordinates from points and insert them into a numpy array as RADIANS<br/> # Notice: should be in Lat/Lon format <br/></strong> left_radians = np.array(left_gdf[left_geom_col].apply(lambda geom: (geom.y * np.pi / 180, geom.x * np.pi / 180)).to_list())<br/> right_radians = np.array(right[right_geom_col].apply(lambda geom: (geom.y * np.pi / 180, geom.x * np.pi / 180)).to_list())<br/> <br/><strong class="nz iu"> # Find the nearest points<br/></strong> <strong class="nz iu"># — — — — — — — — — — — -<br/> # closest ==&gt; index in right_gdf that corresponds to the closest point<br/> # dist ==&gt; distance between the nearest neighbors (in meters)<br/></strong> <br/> closest, dist = get_nearest(src_points=left_radians, candidates=right_radians)</span><span id="ef43" class="od mo it nz b gy oi of l og oh"><strong class="nz iu"># Return points from right GeoDataFrame that are closest to points in left GeoDataFrame<br/></strong> closest_points = right.loc[closest]<br/> <br/><strong class="nz iu"> # Ensure that the index corresponds the one in left_gdf<br/></strong> closest_points = closest_points.reset_index(drop=True)<br/> <br/><strong class="nz iu"> # Add distance if requested <br/></strong> if return_dist:<br/><strong class="nz iu"> # Convert to meters from radians<br/></strong> earth_radius = 6371000 # meters<br/> closest_points[‘distance’] = dist * earth_radius<br/> <br/> <strong class="nz iu">return </strong>closest_points</span></pre><p id="8438" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们应用这些函数</p><pre class="kj kk kl km gt ny nz oa ob aw oc bi"><span id="cec5" class="od mo it nz b gy oe of l og oh"><strong class="nz iu"># Find closest public transport stop for each building and get also the distance based on haversine distance <br/># Note: haversine distance which is implemented here is a bit slower than using e.g. ‘euclidean’ metric <br/># but useful as we get the distance between points in meters</strong></span><span id="4fa5" class="od mo it nz b gy oi of l og oh">closest_stops = nearest_neighbor(restaurants, stops_mask, return_dist=True)</span></pre><p id="a1cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此时，相同数量的餐馆将会是相同数量的最近停靠点。这里我们总共有 1.111 个链接。</p><p id="d30f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们将合并餐馆和公共汽车站。这样，我们就可以在每一行中找到离公交车站最近的餐馆，我们可以创建一个线串作为链接。</p><pre class="kj kk kl km gt ny nz oa ob aw oc bi"><span id="d3a6" class="od mo it nz b gy oe of l og oh"><strong class="nz iu"># Rename the geometry of closest stops gdf so that we can easily identify it<br/></strong>closest_stops_geom = closest_stops.rename(columns={‘geometry’: ‘closest_stop_geom’})</span><span id="6059" class="od mo it nz b gy oi of l og oh"><strong class="nz iu"># Merge the datasets by index (for this, it is good to use ‘.join()’ -function)<br/></strong>restaurants = restaurants.join(closest_stops_geom)</span></pre><p id="7a6e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以在此具有距离属性的地理数据框架中应用描述性统计，我们可以看到从餐馆到公交车站的平均距离为 114 米，记录的最大距离为 4813 米。你会在最终地图中注意到一些餐馆位于群岛上:)</p><p id="28ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们继续创建链接。</p><pre class="kj kk kl km gt ny nz oa ob aw oc bi"><span id="f5bd" class="od mo it nz b gy oe of l og oh"><strong class="nz iu"># Create a link (LineString) between building and stop points<br/></strong>restaurants[‘link’] = restaurants.apply(lambda row: LineString([row[‘geometry’], row[‘closest_stop_geom’]]), axis=1)</span><span id="cf54" class="od mo it nz b gy oi of l og oh"><strong class="nz iu"># Set link as the active geometry<br/></strong>restaurants_links = restaurants.copy()<br/>restaurants_links = restaurants_links.set_geometry(‘link’)</span></pre><p id="d458" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，如果我们对我们的元素进行绘图。它看起来会像这样:</p><pre class="kj kk kl km gt ny nz oa ob aw oc bi"><span id="db10" class="od mo it nz b gy oe of l og oh"><strong class="nz iu"># Plot the connecting links between buildings and stops and color them based on distance<br/></strong>ax = restaurants_links.plot(column=’distance’, cmap=’Greens’, scheme=’quantiles’, k=4, alpha=0.8, lw=0.7, figsize=(13, 10))<br/>ax = restaurants.plot(ax=ax, color=’yellow’, markersize=4, alpha=0.7)<br/>ax = closest_stops.plot(ax=ax, markersize=8, marker=’o’, color=’red’, alpha=0.7, zorder=3)</span><span id="427a" class="od mo it nz b gy oi of l og oh"><strong class="nz iu"># Zoom closer<br/></strong>ax.set_xlim([24.924, 24.95])<br/>ax.set_ylim([60.16, 60.1740])</span><span id="a7db" class="od mo it nz b gy oi of l og oh"><strong class="nz iu"># Set map background color to black, which helps with contrast<br/></strong>ax.set_facecolor(‘black’)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ol"><img src="../Images/0dd2655ba0242869eb3d160aa0ec3d2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DVNkSd8LM5V-peqz8V4uxA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由作者提供。餐馆(黄色)和最近的公交车站(红色)之间的链接(绿色)</p></figure><p id="8441" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，它完成了。如果你想的话，你可以下载这些数据，并像我一样按照你自己的喜好进行格式化。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi om"><img src="../Images/c1dead2c423e1a745e6eeab62c5005ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*IbY3s_0D6s-cmEOt-mINEQ.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由作者提供。最终地图。</p></figure><h1 id="1bd3" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">结论</h1><p id="3d5c" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">BallTree 是一种有效的功能，有助于加速几何元素之间的距离分析过程。自己测试一下，你会发现它是如何快速工作的，避免了额外的计算机内存开销。此外，通过研究与最近邻居的距离，可以创建移动性报告。在这个例子中，公共汽车站和餐馆之间的平均距离是 114 米，步行不到 5 分钟。在这种情况下，您分析的是餐馆之外的其他元素，平均值太高，到达时间较长，显然存在可访问性问题。</p><p id="7e06" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">仅此而已。良好的编码实践和对未来的良好分析。你可以在我的网络地图中支持我的工作，或者在我的<a class="ae ky" href="https://www.linkedin.com/in/bryanrvallejo/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上找到我。</p></div></div>    
</body>
</html>