<html>
<head>
<title>What On Earth Is An Anonymous Function?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">匿名函数到底是什么？</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/what-on-earth-is-an-anonymous-function-f8043eb845f3?source=collection_archive---------27-----------------------#2021-12-27">https://towardsdatascience.com/what-on-earth-is-an-anonymous-function-f8043eb845f3?source=collection_archive---------27-----------------------#2021-12-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e108" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">揭开 Julia 中匿名函数和类型的来龙去脉</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/81c2f2dec2da7c5ed6d6dd652924d3e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nIivpeby3E0IqD7ppcQNMw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由<a class="ae ky" href="https://unsplash.com/photos/wJ7atxTNeQE" rel="noopener ugc nofollow" target="_blank">Unsplash.com</a>的 Bermix 工作室提供)</p></figure><h1 id="5d11" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">介绍</h1><p id="d09c" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi mn translated">ulia 是一种有很多疯狂的细节的语言，允许人们用许多编程概念来解释他们的包。这种事情的一个例子是在一个叫做匿名函数的 Julia 特性中。今天我想向你们介绍 Julia 中的一个概念，一些人可能不熟悉，匿名函数——以及一种创建匿名类型的简洁方法。</p><p id="1c4e" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">匿名函数的伟大之处在于，它们非常容易编写，有自己的作用域，但是是环境声明的。它的伟大之处在于它可以创建一些非常高级的语法。从很多方面来说，我们通常用匿名函数做的事情就是 Python 的 Lambda 在 Python 中做的事情，如果你想深入了解 Lambda 和 Python，我写了一整篇文章，你可以在这里读到:</p><div class="nb nc gp gr nd ne"><a rel="noopener follow" target="_blank" href="/scientific-python-with-lambda-b207b1ddfcd1"><div class="nf ab fo"><div class="ng ab nh cl cj ni"><h2 class="bd iu gy z fp nj fr fs nk fu fw is bi translated">带 Lambda 的科学 Python</h2><div class="nl l"><h3 class="bd b gy z fp nj fr fs nk fu fw dk translated">Python Lambda 函数的正确用法:Python 科学编程的最佳语法。</h3></div><div class="nm l"><p class="bd b dl z fp nj fr fs nk fu fw dk translated">towardsdatascience.com</p></div></div><div class="nn l"><div class="no l np nq nr nn ns ks ne"/></div></div></a></div><p id="c110" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">此外，像往常一样，Github 上有一个笔记本可用于这个项目，所以如果您想好好看看这个代码并自己使用它，您可以在这里:</p><div class="nb nc gp gr nd ne"><a href="https://github.com/emmettgb/Emmetts-DS-NoteBooks/blob/master/Julia/What%20is%20an%20anonymous%20function%3F.ipynb" rel="noopener  ugc nofollow" target="_blank"><div class="nf ab fo"><div class="ng ab nh cl cj ni"><h2 class="bd iu gy z fp nj fr fs nk fu fw is bi translated">emmetts-DS-NoteBooks/什么是匿名函数？。ipynb at master emmett GB/Emmetts-DS-笔记本电脑</h2><div class="nl l"><h3 class="bd b gy z fp nj fr fs nk fu fw dk translated">各种项目的随机笔记本。通过创建帐户，为 emmettgb/Emmetts-DS 笔记本电脑的开发做出贡献…</h3></div><div class="nm l"><p class="bd b dl z fp nj fr fs nk fu fw dk translated">github.com</p></div></div><div class="nn l"><div class="nt l np nq nr nn ns ks ne"/></div></div></a></div></div><div class="ab cl nu nv hx nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="im in io ip iq"><h1 id="6349" class="kz la it bd lb lc ob le lf lg oc li lj jz od ka ll kc oe kd ln kf of kg lp lq bi translated">匿名函数</h1><p id="f2e8" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我们可以通过使用“使用连字符的右箭头”标点符号<code class="fe og oh oi oj b">-&gt;</code>(我认为它基本上是一个操作符)来声明一个匿名函数或构造函数(稍后会详细介绍)。)我选择这些词来描述这个符号，因为这是这种语言的文档描述它的方式，它让我想到的只是 R，而是倒过来。我们将事先定义变量，我们也可以为这样的事情设置一个回报。</p><pre class="kj kk kl km gt ok oj ol om aw on bi"><span id="8386" class="oo la it oj b gy op oq l or os">x -&gt; x == 5<br/>#3 (generic function with 1 method)</span></pre><p id="b46b" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">我们看到当我们运行这段代码时，我们得到了一个方法。这可能很难识别，但是这里有一个简单的方法结构，它是内联的。首先我们有函数定义，它是用参数和-&gt;…来完成的，因此函数的等价形式是这样的:</p><pre class="kj kk kl km gt ok oj ol om aw on bi"><span id="8f14" class="oo la it oj b gy op oq l or os">function ourfunc(x)</span><span id="de9b" class="oo la it oj b gy ot oq l or os">end</span></pre><p id="437a" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">然后加上我们的算术，</p><pre class="kj kk kl km gt ok oj ol om aw on bi"><span id="310e" class="oo la it oj b gy op oq l or os">function ourfunc(x)<br/>    x == 5<br/>end</span></pre><p id="dee7" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">现在，如果我们调用我们的函数，它将反映我们的匿名函数的算法，但是我们如何调用匿名函数本身呢？匿名类型和函数不是在 Julia 的常规方法范围内声明的，而是包含在 Core.box 对象中。这使事情变得复杂和简单。它对于不同的应用程序肯定是有用的，在这些应用程序中，人们可能想做一些疯狂的事情，比如移动方法。我们所要做的就是断言一些等同于这个方法的东西，以及那个值的别名，并且永远带着这个装箱的方法。</p><pre class="kj kk kl km gt ok oj ol om aw on bi"><span id="60bd" class="oo la it oj b gy op oq l or os">our_otherfunc = x -&gt; x == 5</span></pre><p id="3cc3" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">现在我们看到，通过这两种方法传递 5 的结果是一样的:</p><pre class="kj kk kl km gt ok oj ol om aw on bi"><span id="7fe4" class="oo la it oj b gy op oq l or os">println(our_otherfunc(5))<br/>println(ourfunc(5))</span></pre><p id="4ca7" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">值得注意的是，这些方法的定义方式有一个关键的区别，因为我们的新“东西”是一些奇怪的 Julia 对象，有时这会导致许多非常奇怪和令人困惑的错误。我在开发 Hone.jl 包时经常遇到这种情况。如果你想看看我遇到的一些挣扎，你可以看看我在 Hone.jl 上写的一些文章:</p><div class="nb nc gp gr nd ne"><a rel="noopener follow" target="_blank" href="/metaprogramming-grids-and-labels-for-hone-jl-f434c8dc24ad"><div class="nf ab fo"><div class="ng ab nh cl cj ni"><h2 class="bd iu gy z fp nj fr fs nk fu fw is bi translated">Hone.jl 的元编程网格和标签</h2><div class="nl l"><h3 class="bd b gy z fp nj fr fs nk fu fw dk translated">为 Julia 修复我的网格并将轴标签添加到我的图形库中</h3></div><div class="nm l"><p class="bd b dl z fp nj fr fs nk fu fw dk translated">towardsdatascience.com</p></div></div><div class="nn l"><div class="ou l np nq nr nn ns ks ne"/></div></div></a></div><h1 id="d6d7" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">匿名类型</h1><p id="fa8e" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">匿名类型只是匿名函数的一个扩展功能——我们甚至可以定义在返回类型之前运行的算法。我们可以使用匿名函数很容易地在 Julia 中组装一个类型，但是技巧实际上是得到一个类型作为回报。如果我们使用断言操作符，并尝试在内联中这样做，Julia 会做算术，我们不会以类型结束。因此，必须通过快速方法返回该类型。首先让我们写一个快速结构来限制:</p><pre class="kj kk kl km gt ok oj ol om aw on bi"><span id="df07" class="oo la it oj b gy op oq l or os">mutable struct type1<br/>    data1::Dict<br/>    data2::Int64<br/>end</span></pre><p id="7fbb" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">现在，我们将定义要放入的数据:</p><pre class="kj kk kl km gt ok oj ol om aw on bi"><span id="493b" class="oo la it oj b gy op oq l or os">one = Dict(:A =&gt; [4, 1, 2], :B =&gt; [2, 3, 8])<br/>two = 5</span></pre><p id="e099" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">下面是我们的匿名 new()函数。这就好像我们正在编写一个内部构造函数。</p><pre class="kj kk kl km gt ok oj ol om aw on bi"><span id="1a52" class="oo la it oj b gy op oq l or os">function methodinstead(one, two)<br/>    (one)-&gt;(one;two)<br/>end</span></pre><p id="b1e4" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">现在我们需要调用这个方法来构造我们的类型:</p><pre class="kj kk kl km gt ok oj ol om aw on bi"><span id="d002" class="oo la it oj b gy op oq l or os">type2 = methodinstead(one, two)<br/>reg_const = type1(one, two)</span></pre><p id="fff4" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">这里有一个关键的区别，我们不能从这个构造函数的系统化版本中得到装箱的数据。有条理的版本中有装箱的类型和结构。</p></div><div class="ab cl nu nv hx nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="im in io ip iq"><h1 id="2ebb" class="kz la it bd lb lc ob le lf lg oc li lj jz od ka ll kc oe kd ln kf of kg lp lq bi translated">结论</h1><p id="5d8a" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">匿名函数是另一个激进特性的例子，在 Julia 语言中，这种激进特性的原因很模糊。这些函数可以以非常经典的科学计算方式使用，我非常喜欢 Julia 的这一部分提供的语法。我认为这对于使用方法技术中的类型进行虚拟化可能是有用的。也许它对一些东西的原型制作也是有用的。</p><p id="85d7" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">到目前为止，你在 Julia 中看到的这类函数的最大用法是在方法头中创建的。这是因为它们经常在 Julia 中使用，相当于 apply()之类的方法。例如，findall()和 filter()都经常使用这些类型的表达式。非常感谢你阅读这篇文章，我很高兴我能够对这个话题有点热情！</p></div></div>    
</body>
</html>