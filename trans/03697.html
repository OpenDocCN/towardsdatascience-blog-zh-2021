<html>
<head>
<title>Building a Naive Bayes Machine Learning Model to Classify Text</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建朴素贝叶斯机器学习模型对文本进行分类</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/building-a-naive-bayes-machine-learning-model-to-classify-text-71431ce20844?source=collection_archive---------8-----------------------#2021-03-26">https://towardsdatascience.com/building-a-naive-bayes-machine-learning-model-to-classify-text-71431ce20844?source=collection_archive---------8-----------------------#2021-03-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e649" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">这是一个快速入门指南，帮助您使用Python启动并运行一个简单而高度相关的NLP项目</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5c11216ee79cb4bbccae08622b521e2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cDoMaXqRYusuXQcZ0wWquQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Python中的朴素贝叶斯(所有图片由作者提供)</p></figure><h1 id="d84b" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">介绍</h1><p id="aca9" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">自然语言处理(NLP)是一个非常令人兴奋的领域。它位于计算机科学、语言学和人工智能的交汇点，关注人类语言和计算机之间的交互。更具体地说:它的目标是理解如何给计算机编程，以理解和解释我们的自然语言。</p><p id="d5e1" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">现在这是一个非常热门的研究领域，我很幸运能够在这个研究领域绝对前沿的大学就读。虽然作为一名卑微的本科生，我并不经常接触这种前沿工作——如果我接触了，我会理解的！</p><p id="4373" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">尽管如此，建立模型对自然语言进行分类还是相对简单的。这是一个很酷的练习，因为它是相关的。这是一个非常真实的ML应用，你可以在自己的项目中使用。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mr"><img src="../Images/bc9c8ffd4a5dfad928137df59c00fc98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dbFmxm83_y2BQjaDnWinTQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">贝叶斯定理</p></figure><h1 id="c0ad" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">朴素贝叶斯</h1><p id="8fe5" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">朴素贝叶斯算法是一种更简单的监督贝叶斯网络模型，它是一种基于贝叶斯定理的概率分类器(您可能还记得高中的统计数据)。但它的简单性并不使它成为一个糟糕的选择，即使数据集不是很大(只有几千个样本)，它也可以产生高度准确的预测。</p><p id="c50a" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">如果你真的是机器学习的新手，我建议阅读一些关于更基本算法的文章，然后回到这一篇，因为我将建立在这些文章中详细解释的概念上。</p><div class="ms mt gp gr mu mv"><a rel="noopener follow" target="_blank" href="/k-means-clustering-for-beginners-ea2256154109"><div class="mw ab fo"><div class="mx ab my cl cj mz"><h2 class="bd iu gy z fp na fr fs nb fu fw is bi translated">适用于初学者的k-均值聚类</h2><div class="nc l"><h3 class="bd b gy z fp na fr fs nb fu fw dk translated">一个深入的解释和一步一步的指导这个有趣和有用的机器学习算法在Python中，由…</h3></div><div class="nd l"><p class="bd b dl z fp na fr fs nb fu fw dk translated">towardsdatascience.com</p></div></div><div class="ne l"><div class="nf l ng nh ni ne nj ks mv"/></div></div></a></div><p id="8650" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">本质上，两个事件发生的条件概率是根据每个事件的条件概率计算出来的。因此，对于给定的一段文本，计算每个标签的概率，并输出具有最高概率的标签。</p><p id="7d5b" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">还有其他合适的选择，如支持向量机(SVM)，它需要更多的时间和计算资源来工作，但会产生比朴素贝叶斯更准确的预测。或者，您可以考虑基于神经网络的深度学习方法，但这将需要更多的训练数据。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/2bcc7f06abc6828b28732716a6c7ce80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*uCgyD-pcjQNN8tav"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">米卡·鲍梅斯特在<a class="ae nl" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><h1 id="c11a" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">这个例子</h1><p id="b193" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">这是一种方法:</p><ol class=""><li id="2f6f" class="nm nn it ls b lt mm lw mn lz no md np mh nq ml nr ns nt nu bi translated">导入和设置数据。</li><li id="b054" class="nm nn it ls b lt nv lw nw lz nx md ny mh nz ml nr ns nt nu bi translated">做一些分析以了解更多关于数据环境的信息。</li><li id="bf49" class="nm nn it ls b lt nv lw nw lz nx md ny mh nz ml nr ns nt nu bi translated">创建我们的因变量和自变量列表，用于训练和验证。</li><li id="ea78" class="nm nn it ls b lt nv lw nw lz nx md ny mh nz ml nr ns nt nu bi translated">给标签编码。</li><li id="d881" class="nm nn it ls b lt nv lw nw lz nx md ny mh nz ml nr ns nt nu bi translated">从描述中提取特征。</li><li id="3bc6" class="nm nn it ls b lt nv lw nw lz nx md ny mh nz ml nr ns nt nu bi translated">使数据符合模型。</li><li id="9018" class="nm nn it ls b lt nv lw nw lz nx md ny mh nz ml nr ns nt nu bi translated">检查模型的准确性。</li></ol><p id="c4ce" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">这个项目将演示如何根据银行交易的描述对其进行分类。我的数据集包含12500个样本，包括交易金额和交易类型等其他特征，您可以在模型中使用任意数量的特征，甚至可以选择一些特征来查看哪些特征对预测的影响最大，但为了简单起见，我们将只使用描述。</p><p id="c30a" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">在我的数据集中，描述是这样的:</p><pre class="kj kk kl km gt oa ob oc od aw oe bi"><span id="0a67" class="of kz it ob b gy og oh l oi oj">citylink<br/>1Jul19 OYSTER<br/>travelodge<br/>6Jul19 RINGGO<br/>SUNDRY DEBIT CONTACTLESS CAMDEN PARKING<br/>stgcoach<br/>trainline<br/>Fin: CMT UK LTD  Cash at Transact</span></pre><h2 id="3122" class="of kz it bd la ok ol dn le om on dp li lz oo op lk md oq or lm mh os ot lo ou bi translated">设置</h2><p id="074f" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">当然，从进口开始。</p><ol class=""><li id="cf55" class="nm nn it ls b lt mm lw mn lz no md np mh nq ml nr ns nt nu bi translated">创建数据框架的熊猫。</li><li id="1b78" class="nm nn it ls b lt nv lw nw lz nx md ny mh nz ml nr ns nt nu bi translated">sci kit-了解标签编码、特征提取、建模和测量成功指标</li></ol><pre class="kj kk kl km gt oa ob oc od aw oe bi"><span id="55dd" class="of kz it ob b gy og oh l oi oj">import pandas as pd<br/>from sklearn.preprocessing import LabelEncoder<br/>from sklearn.feature_extraction.text import CountVectorizer<br/>from sklearn import naive_bayes, metrics</span></pre><p id="67b8" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">接下来，让我们处理csv文件，并为模型做好准备。(当然，你可能没有处理csv文件，只是把你所有的数据导入到熊猫数据框架中):</p><pre class="kj kk kl km gt oa ob oc od aw oe bi"><span id="3287" class="of kz it ob b gy og oh l oi oj">features = pd.read_csv("bank_transaction_features.csv")<br/>labels = pd.read_csv("bank_transaction_labels.csv")</span></pre><p id="c54a" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">我有两个数据集:一个包含要素，一个包含标注(类别)。这些是它们各自的列:</p><pre class="kj kk kl km gt oa ob oc od aw oe bi"><span id="799c" class="of kz it ob b gy og oh l oi oj"><strong class="ob iu">bank_transaction_features:</strong><br/>bank_transaction_id, bank_transaction_amount, bank_transaction_type</span><span id="4117" class="of kz it ob b gy ov oh l oi oj"><strong class="ob iu">bank_transaction_labels:</strong><br/>bank_transaction_id, bank_transaction_category, bank_transaction_dataset</span></pre><p id="2893" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">它们有一个共同点，ID列。因此，我将在这一列中合并它们，并删除任何具有空条目的行(在我的数据中很少，您应该计算有多少，因此删除它们对预测的影响可以忽略不计):</p><pre class="kj kk kl km gt oa ob oc od aw oe bi"><span id="309a" class="of kz it ob b gy og oh l oi oj">combined_df = pd.merge(left=features, right=labels)<br/>combined_df = combined_df.dropna()</span></pre><h2 id="32eb" class="of kz it bd la ok ol dn le om on dp li lz oo op lk md oq or lm mh os ot lo ou bi translated">探索性分析</h2><p id="ea88" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">总是从一些探索性的数据分析开始。我的数据集有数以千计的样本，我无法通过扫描看到所有的类别。我们需要做一些简单的事情来更好地理解数据。</p><p id="612e" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">该数据集有一列指定样本是用于训练还是验证。这将在以后派上用场，因为我们不需要创建我们自己的训练/验证分割。但是对于探索性分析，我们可以删除该列(只从我们将创建的新dataframe变量中删除该列，保留包含该列的变量)。</p><pre class="kj kk kl km gt oa ob oc od aw oe bi"><span id="92c7" class="of kz it ob b gy og oh l oi oj">explore_df = combined_df.drop(labels=['bank_transaction_dataset'], axis=1)</span></pre><p id="3967" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">我们可以很容易地看到数据中存在哪些类别，以及每个类别中有多少个样本:</p><pre class="kj kk kl km gt oa ob oc od aw oe bi"><span id="2ed1" class="of kz it ob b gy og oh l oi oj">print(explore_df['bank_transaction_category'].value_counts())</span></pre><p id="1e64" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">结果是:</p><pre class="kj kk kl km gt oa ob oc od aw oe bi"><span id="4bbf" class="of kz it ob b gy og oh l oi oj">ACCOMMODATION_AND_MEALS    3765<br/>TRAVEL                     3166<br/>BANK_OR_FINANCE_CHARGES    2659<br/>MOTOR_EXPENSES             1609<br/>INSURANCE                  1170<br/>Name: bank_transaction_category, dtype: int64</span></pre><p id="caa2" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">现在，让我们检查一下培训/验证分割是什么(使用仍有相关列的数据帧):</p><pre class="kj kk kl km gt oa ob oc od aw oe bi"><span id="d8a7" class="of kz it ob b gy og oh l oi oj">train_set = combined_df.loc[combined_df["bank_transaction_dataset"] == "TRAIN"]<br/>val_set = combined_df.loc[combined_df["bank_transaction_dataset"] == "VAL"]<br/><br/>len_train = len(train_set)<br/>len_val = len(val_set)<br/>len_whole = len(explore_df)<br/>print('Amount of training data: ', len_train)<br/>print('Amount of validation data: ', len_val)</span></pre><p id="cba2" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">输出:</p><pre class="kj kk kl km gt oa ob oc od aw oe bi"><span id="d0a2" class="of kz it ob b gy og oh l oi oj">Amount of training data:  9891<br/>Amount of validation data:  2478</span></pre><p id="c1bd" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">这使得训练/验证的比例为80/20，这是一个很好的比例，所以根本不需要调整。</p><h2 id="1cb0" class="of kz it bd la ok ol dn le om on dp li lz oo op lk md oq or lm mh os ot lo ou bi translated">分类</h2><p id="165f" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">最后，有趣的部分。首先，创建x和y训练和验证子集。我们可以通过创建只包含相关列中数据的列表来实现这一点:</p><pre class="kj kk kl km gt oa ob oc od aw oe bi"><span id="44bb" class="of kz it ob b gy og oh l oi oj">y_train = train_set['bank_transaction_category'].values<br/>x_train = train_set['bank_transaction_description'].values<br/><br/>y_val = val_set['bank_transaction_category'].values<br/>x_val = val_set['bank_transaction_description'].values</span></pre><p id="def7" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">现在变得非常有趣了。需要记住的是，ML模型不“理解”文本和单词。他们理解数字。因此，准备数据以适合模型的第一件事是对标签进行编码。这意味着，给每个标签分配一个号码。例如:</p><pre class="kj kk kl km gt oa ob oc od aw oe bi"><span id="0827" class="of kz it ob b gy og oh l oi oj">ACCOMMODATION_AND_MEALS    =&gt; 0<br/>TRAVEL                     =&gt; 1<br/>BANK_OR_FINANCE_CHARGES    =&gt; 2<br/>MOTOR_EXPENSES             =&gt; 3<br/>INSURANCE                  =&gt; 4</span></pre><p id="198e" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">这是通过创建一个<em class="ow"> LabelEncoder </em>对象并对因变量数据(<em class="ow"> y </em>)使用其<em class="ow"> fit_transform </em>函数来实现的:</p><pre class="kj kk kl km gt oa ob oc od aw oe bi"><span id="0779" class="of kz it ob b gy og oh l oi oj">label_encoder = LabelEncoder()<br/>y_train = label_encoder.fit_transform(y_train)<br/>y_test = label_encoder.fit_transform(y_val)</span></pre><p id="f645" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">描述数据也是如此，只是这个稍微复杂一点。在一些模型中，你有一组统一的描述，并且你知道它们是什么，你可以把每一个编码成一个整数，它们就准备好了。但是在这里，每个事务描述都可能是唯一的。</p><p id="3858" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">解决方案是从文本中提取特征，并将这些特征转化为模型可以理解的向量。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mr"><img src="../Images/84f60785866ddb64a849be931bc0a794.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yHE91FmxcT649lHZuazVgg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">特征抽出</p></figure><p id="d725" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">虽然在技术上很复杂，但这可以简单地实现，通过使用<em class="ow">计数矢量器</em>将文本转换为令牌矩阵，并转换训练和验证独立变量(<em class="ow"> x </em>):</p><pre class="kj kk kl km gt oa ob oc od aw oe bi"><span id="155e" class="of kz it ob b gy og oh l oi oj">count_vector = CountVectorizer(analyzer='word', token_pattern=r'\w{1,}')<br/>count_vector.fit(combined_df['bank_transaction_description'])<br/><br/>x_train_count = count_vector.transform(x_train)<br/>x_valid_count = count_vector.transform(x_val)</span></pre><p id="a84c" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">就是这样！我们可以拟合数据、训练模型并做出预测:</p><pre class="kj kk kl km gt oa ob oc od aw oe bi"><span id="befe" class="of kz it ob b gy og oh l oi oj">classifier = naive_bayes.MultinomialNB()<br/>classifier.fit(x_train_count, y_train)<br/><br/>predictions = classifier.predict(x_valid_count)</span></pre><h2 id="c635" class="of kz it bd la ok ol dn le om on dp li lz oo op lk md oq or lm mh os ot lo ou bi translated">准确(性)</h2><p id="b06f" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">您可以使用几个指标来确定模型的工作情况。我们会用准确性。这将告诉我们模型正确预测银行交易类别的频率:</p><pre class="kj kk kl km gt oa ob oc od aw oe bi"><span id="ae6e" class="of kz it ob b gy og oh l oi oj">print(metrics.accuracy_score(predictions, y_test))</span></pre><p id="525c" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">该模型的精确度为:</p><pre class="kj kk kl km gt oa ob oc od aw oe bi"><span id="5055" class="of kz it ob b gy og oh l oi oj">0.91</span></pre><p id="7d8f" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">一点也不差。</p><h1 id="f19b" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">结论</h1><p id="0abd" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">这是一个有趣的例子，因为它是有形的。例如，在移动金融跟踪应用程序中将银行交易分类是这种算法的一个非常真实的用例。我希望您对朴素贝叶斯是如何工作的，以及如何实现它对文本进行分类有了很好的理解。</p><p id="95e5" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">如果你确实学到了一些东西，有任何问题，认为我错过了任何重要的东西，或者计划在你自己的项目中使用这个算法，请通过留下回复让我知道，我们可以讨论它。</p><p id="22f7" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">编码快乐！</p></div><div class="ab cl ox oy hx oz" role="separator"><span class="pa bw bk pb pc pd"/><span class="pa bw bk pb pc pd"/><span class="pa bw bk pb pc"/></div><div class="im in io ip iq"><p id="8074" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated"><a class="ae nl" href="https://medium.com/subscribe/@adenhaus" rel="noopener"> <strong class="ls iu">订阅</strong> </a>📚为了不错过我的一篇新文章，如果你还不是一个中等会员，<a class="ae nl" href="https://medium.com/@adenhaus/membership" rel="noopener">T9】加入 </a>🚀去读我所有的，还有成千上万的其他故事！</p></div><div class="ab cl ox oy hx oz" role="separator"><span class="pa bw bk pb pc pd"/><span class="pa bw bk pb pc pd"/><span class="pa bw bk pb pc"/></div><div class="im in io ip iq"><h1 id="babc" class="ky kz it bd la lb pe ld le lf pf lh li jz pg ka lk kc ph kd lm kf pi kg lo lp bi translated">资源</h1><p id="6fe2" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated"><strong class="ls iu">Scikit Learn</strong><em class="ow">sk Learn . preprocessing . label encoder</em><a class="ae nl" href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.LabelEncoder.html" rel="noopener ugc nofollow" target="_blank">https://Scikit-Learn . org/stable/modules/generated/sk Learn . preprocessing . label encoder . html</a></p><p id="b880" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated"><strong class="ls iu">Scikit Learn</strong><em class="ow">sk Learn . feature _ extraction . text . count vectorizer</em>T22】https://Scikit-Learn . org/stable/modules/generated/sk Learn . feature _ extraction . text . count vectorizer . html</p><p id="f61d" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated"><strong class="ls iu">维基百科</strong> <em class="ow">自然语言处理</em><a class="ae nl" href="https://en.wikipedia.org/wiki/Natural_language_processing" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Natural_language_processing</a></p><p id="20c4" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated"><strong class="ls iu"> MonkeyLearn </strong> <em class="ow">文本分类</em>【https://monkeylearn.com/text-classification/】T4</p></div></div>    
</body>
</html>