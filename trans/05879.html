<html>
<head>
<title>Build a News recommendation app from python with Vespa</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Vespa从python构建新闻推荐应用程序</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/build-a-news-recommendation-app-from-python-with-vespa-6aa37450eb32?source=collection_archive---------50-----------------------#2021-05-25">https://towardsdatascience.com/build-a-news-recommendation-app-from-python-with-vespa-6aa37450eb32?source=collection_archive---------50-----------------------#2021-05-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="097b" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">第3部分—通过亲子关系有效利用点击率</h2></div><p id="2edd" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这部分系列引入了一个新的排名信号:类别点击率(CTR)。这个想法是，我们可以为没有点击历史的用户推荐受欢迎的内容。我们不是仅仅根据文章进行推荐，而是根据类别进行推荐。然而，这些全局CTR值经常会不断变化，因此我们需要一种有效的方法来为所有文档更新这个值。我们将通过在Vespa中引入文档之间的父子关系来做到这一点。我们也会在排名中直接使用稀疏张量。这篇文章复制了<a class="ae lb" href="https://docs.vespa.ai/en/tutorials/news-7-recommendation-with-parent-child.html" rel="noopener ugc nofollow" target="_blank">这篇更详细的Vespa教程</a>。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi lc"><img src="../Images/1987d10e070cc36b00252186df8d968b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Gzqs1XjVgH-URnan5kwQDg.jpeg"/></div></div><p class="lo lp gj gh gi lq lr bd b be z dk translated">由<a class="ae lb" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae lb" href="https://unsplash.com/@freegraphictoday?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">absolute vision</a>拍摄的照片</p></figure><p id="0c9c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们假设您已经阅读了新闻推荐教程的<a class="ae lb" href="https://blog.vespa.ai/build-news-recommendation-app-from-python-with-vespa/" rel="noopener ugc nofollow" target="_blank">第2部分。因此，您应该有一个保存新闻应用程序定义的<code class="fe ls lt lu lv b">app_package</code>变量和一个名为<code class="fe ls lt lu lv b">news</code>的Docker容器来运行应用程序，该应用程序从MIND数据集的演示版本获取数据。</a></p><h2 id="879b" class="lw lx iq bd ly lz ma dn mb mc md dp me ko mf mg mh ks mi mj mk kw ml mm mn mo bi translated">设置全球类别CTR文档</h2><p id="b551" class="pw-post-body-paragraph kf kg iq kh b ki mp jr kk kl mq ju kn ko mr kq kr ks ms ku kv kw mt ky kz la ij bi translated">如果我们在<code class="fe ls lt lu lv b">news</code>文档中添加一个<code class="fe ls lt lu lv b">category_ctr</code>字段，那么每当这项运动的CTR统计数据发生变化时，我们就必须更新这项运动的所有文档。如果我们假设类别CTR会经常改变，这被证明是低效的。</p><p id="ca7c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">针对这些情况，Vespa引入了<a class="ae lb" href="https://docs.vespa.ai/en/parent-child.html" rel="noopener ugc nofollow" target="_blank">亲子关系</a>。父文档是全局文档，会自动分发到所有内容节点。其他文档可以引用这些父项并“导入”值以用于排名。好处是全局类别CTR值只需要写入一个地方:全局文档。</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="441d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们通过创建一个新的<code class="fe ls lt lu lv b">category_ctr</code>模式并设置<code class="fe ls lt lu lv b">global_document=True</code>来表示我们希望Vespa在所有内容节点上保留这些文档的副本，从而实现了这一点。在父子关系中使用文档时，需要将文档设置为全局文档。注意，我们使用一个具有单一稀疏维度的张量来保存<code class="fe ls lt lu lv b">ctrs</code>数据。</p><p id="4ce4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">稀疏张量将字符串作为维度地址，而不是数字索引。更具体地说，这种张量的一个例子是(使用<a class="ae lb" href="https://docs.vespa.ai/en/reference/tensor.html#tensor-literal-form" rel="noopener ugc nofollow" target="_blank">张量文字形式</a>):</p><pre class="ld le lf lg gt mw lv mx my aw mz bi"><span id="3b27" class="lw lx iq lv b gy na nb l nc nd">{<br/>    {category: entertainment}: 0.2 }, <br/>    {category: news}: 0.3 },<br/>    {category: sports}: 0.5 },<br/>    {category: travel}: 0.4 },<br/>    {category: finance}: 0.1 },<br/>    ...<br/>}</span></pre><p id="1829" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个张量包含所有类别的CTR分数。在更新这个张量的时候，我们可以更新单个的细胞，不需要更新整个张量。这个操作叫做<a class="ae lb" href="https://docs.vespa.ai/en/reference/document-json-format.html#tensor-modify" rel="noopener ugc nofollow" target="_blank">张量修改</a>，当你有大的张量时会很有帮助。</p><h2 id="b0f4" class="lw lx iq bd ly lz ma dn mb mc md dp me ko mf mg mh ks mi mj mk kw ml mm mn mo bi translated">在子文档中导入父值</h2><p id="299b" class="pw-post-body-paragraph kf kg iq kh b ki mp jr kk kl mq ju kn ko mr kq kr ks ms ku kv kw mt ky kz la ij bi translated">我们需要设置两个东西来使用<code class="fe ls lt lu lv b">category_ctr</code>张量对<code class="fe ls lt lu lv b">news</code>文档进行排序。我们需要引用父文档(本例中为<code class="fe ls lt lu lv b">category_ctr</code>),并从引用的父文档中导入<code class="fe ls lt lu lv b">ctrs</code>。</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="9e6d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">字段<code class="fe ls lt lu lv b">category_ctr_ref</code>是<code class="fe ls lt lu lv b">category_ctr</code>单据类型的类型引用字段。当输入这个字段时，Vespa需要完全合格的文档id。例如，如果我们的全局CTR文档有id <code class="fe ls lt lu lv b">id:category_ctr:category_ctr::global</code>，那就是我们需要提供给<code class="fe ls lt lu lv b">category_ctr_ref</code>字段的值。一个文档可以引用许多父文档。</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="147c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">导入的字段定义了我们应该从<code class="fe ls lt lu lv b">category_ctr_ref</code>字段中引用的文档中导入<code class="fe ls lt lu lv b">ctrs</code>字段。我们将其命名为<code class="fe ls lt lu lv b">global_category_ctrs</code>,我们可以在排序时将其引用为<code class="fe ls lt lu lv b">attribute(global_category_ctrs)</code>。</p><h2 id="87ad" class="lw lx iq bd ly lz ma dn mb mc md dp me ko mf mg mh ks mi mj mk kw ml mm mn mo bi translated">排序中的张量表达式</h2><p id="d571" class="pw-post-body-paragraph kf kg iq kh b ki mp jr kk kl mq ju kn ko mr kq kr ks ms ku kv kw mt ky kz la ij bi translated">每个<code class="fe ls lt lu lv b">news</code>文档都有一个类型为<code class="fe ls lt lu lv b">string</code>的<code class="fe ls lt lu lv b">category</code>字段，指示该文档属于哪个类别。我们希望使用这些信息来选择存储在<code class="fe ls lt lu lv b">global_category_ctrs</code>中的正确CTR分数。不幸的是，张量表达式只对张量起作用，所以我们需要添加一个名为<code class="fe ls lt lu lv b">category_tensor</code>的<code class="fe ls lt lu lv b">tensor</code>类型的新字段，以在张量表达式中使用的方式保存类别信息:</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="0395" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用上面定义的<code class="fe ls lt lu lv b">category_tensor</code>字段，我们可以使用张量表达式<code class="fe ls lt lu lv b">sum(attribute(category_tensor) * attribute(global_category_ctrs))</code>来选择与被排序的文档类别相关的特定CTR。我们在下面的等级配置文件中将该表达式实现为<code class="fe ls lt lu lv b">Function</code>:</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="907a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在新的rank-profile中，我们添加了第一阶段排名表达式，该表达式将最近邻得分与类别CTR得分相乘，分别用函数<code class="fe ls lt lu lv b">nearest_neighbor</code>和<code class="fe ls lt lu lv b">category_ctr</code>实现。作为第一次尝试，我们将最近邻与类别CTR分数相乘，这可能不是组合这两个值的最佳方式。</p><h2 id="0db8" class="lw lx iq bd ly lz ma dn mb mc md dp me ko mf mg mh ks mi mj mk kw ml mm mn mo bi translated">部署</h2><p id="94b0" class="pw-post-body-paragraph kf kg iq kh b ki mp jr kk kl mq ju kn ko mr kq kr ks ms ku kv kw mt ky kz la ij bi translated">我们可以重用在本教程第一部分中创建的同一个名为<code class="fe ls lt lu lv b">news</code>的容器。</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="mu mv l"/></div></figure><pre class="ld le lf lg gt mw lv mx my aw mz bi"><span id="22e5" class="lw lx iq lv b gy na nb l nc nd">Waiting for configuration server.<br/>Waiting for configuration server.<br/>Waiting for configuration server.<br/>Waiting for configuration server.<br/>Waiting for configuration server.<br/>Waiting for configuration server.<br/>Waiting for application status.<br/>Waiting for application status.<br/>Finished deployment.</span></pre><h2 id="52e5" class="lw lx iq bd ly lz ma dn mb mc md dp me ko mf mg mh ks mi mj mk kw ml mm mn mo bi translated">饲料</h2><p id="92e6" class="pw-post-body-paragraph kf kg iq kh b ki mp jr kk kl mq ju kn ko mr kq kr ks ms ku kv kw mt ky kz la ij bi translated">接下来，我们将下载全局类别CTR数据，该数据已经以具有类别维度的稀疏张量所期望的格式进行了解析。</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="mu mv l"/></div></figure><pre class="ld le lf lg gt mw lv mx my aw mz bi"><span id="200a" class="lw lx iq lv b gy na nb l nc nd">{'ctrs': {'cells': [{'address': {'category': 'entertainment'},<br/>    'value': 0.029266420380943244},<br/>   {'address': {'category': 'autos'}, 'value': 0.028475809103747123},<br/>   {'address': {'category': 'tv'}, 'value': 0.05374837981352176},<br/>   {'address': {'category': 'health'}, 'value': 0.03531784305129329},<br/>   {'address': {'category': 'sports'}, 'value': 0.05611187986670051},<br/>   {'address': {'category': 'music'}, 'value': 0.05471192953054426},<br/>   {'address': {'category': 'news'}, 'value': 0.04420778372641991},<br/>   {'address': {'category': 'foodanddrink'}, 'value': 0.029256852366228187},<br/>   {'address': {'category': 'travel'}, 'value': 0.025144552013730358},<br/>   {'address': {'category': 'finance'}, 'value': 0.03231013195899643},<br/>   {'address': {'category': 'lifestyle'}, 'value': 0.04423279317474416},<br/>   {'address': {'category': 'video'}, 'value': 0.04006693315980292},<br/>   {'address': {'category': 'movies'}, 'value': 0.03335647459420146},<br/>   {'address': {'category': 'weather'}, 'value': 0.04532171803495617},<br/>   {'address': {'category': 'northamerica'}, 'value': 0.0},<br/>   {'address': {'category': 'kids'}, 'value': 0.043478260869565216}]}}</span></pre><p id="0989" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以将该数据点输入到<code class="fe ls lt lu lv b">category_ctr</code>中定义的文档中。我们将为该文档分配<code class="fe ls lt lu lv b">global</code> id。可以通过使用Vespa id <code class="fe ls lt lu lv b">id:category_ctr:category_ctr::global</code>来参考本文档。</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="7953" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们需要对<code class="fe ls lt lu lv b">news</code>文档执行部分更新，以包含关于引用字段<code class="fe ls lt lu lv b">category_ctr_ref</code>和新<code class="fe ls lt lu lv b">category_tensor</code>的信息，该字段将具有与每个文档相关联的特定类别的值<code class="fe ls lt lu lv b">1.0</code>。</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="mu mv l"/></div></figure><pre class="ld le lf lg gt mw lv mx my aw mz bi"><span id="19c5" class="lw lx iq lv b gy na nb l nc nd">{'id': 'N3112',<br/> 'fields': {'category_ctr_ref': 'id:category_ctr:category_ctr::global',<br/>  'category_tensor': {'cells': [{'address': {'category': 'lifestyle'},<br/>     'value': 1.0}]}}}</span></pre><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="mu mv l"/></div></figure><h2 id="cd9f" class="lw lx iq bd ly lz ma dn mb mc md dp me ko mf mg mh ks mi mj mk kw ml mm mn mo bi translated">测试新的等级档案</h2><p id="0f39" class="pw-post-body-paragraph kf kg iq kh b ki mp jr kk kl mq ju kn ko mr kq kr ks ms ku kv kw mt ky kz la ij bi translated">我们将重新定义本教程第二部分中定义的<code class="fe ls lt lu lv b">query_user_embedding</code>函数，并使用它进行一个涉及用户<code class="fe ls lt lu lv b">U33527</code>和<code class="fe ls lt lu lv b">recommendation_with_global_category_ctr</code>等级档案的查询。</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="6c8d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面第一个命中的是一篇体育文章。这里还列出了全球CTR文档，体育类的CTR得分为<code class="fe ls lt lu lv b">0.0561</code>。因此，category_ctr函数的结果是预期的<code class="fe ls lt lu lv b">0.0561</code>。nearest _ neighborhood分数是<code class="fe ls lt lu lv b">0.149</code>，得到的相关性分数是<code class="fe ls lt lu lv b">0.00836</code>。所以，这和预期的一样有效。</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="mu mv l"/></div></figure><pre class="ld le lf lg gt mw lv mx my aw mz bi"><span id="8474" class="lw lx iq lv b gy na nb l nc nd">{'id': 'id:news:news::N5316',<br/> 'relevance': 0.008369192847921151,<br/> 'source': 'news_content',<br/> 'fields': {'sddocname': 'news',<br/>  'documentid': 'id:news:news::N5316',<br/>  'news_id': 'N5316',<br/>  'category': 'sports',<br/>  'subcategory': 'football_nfl',<br/>  'title': "Matthew Stafford's status vs. Bears uncertain, Sam Martin will play",<br/>  'abstract': "Stafford's start streak could be in jeopardy, according to Ian Rapoport.",<br/>  'url': "https://www.msn.com/en-us/sports/football_nfl/matthew-stafford's-status-vs.-bears-uncertain,-sam-martin-will-play/ar-BBWwcVN?ocid=chopendata",<br/>  'date': 20191112,<br/>  'clicks': 0,<br/>  'impressions': 1,<br/>  'summaryfeatures': {'attribute(category_tensor)': {'type': 'tensor&lt;float&gt;(category{})',<br/>    'cells': [{'address': {'category': 'sports'}, 'value': 1.0}]},<br/>   'attribute(global_category_ctrs)': {'type': 'tensor&lt;float&gt;(category{})',<br/>    'cells': [{'address': {'category': 'entertainment'},<br/>      'value': 0.029266420751810074},<br/>     {'address': {'category': 'autos'}, 'value': 0.0284758098423481},<br/>     {'address': {'category': 'tv'}, 'value': 0.05374838039278984},<br/>     {'address': {'category': 'health'}, 'value': 0.03531784191727638},<br/>     {'address': {'category': 'sports'}, 'value': 0.05611187964677811},<br/>     {'address': {'category': 'music'}, 'value': 0.05471193045377731},<br/>     {'address': {'category': 'news'}, 'value': 0.04420778527855873},<br/>     {'address': {'category': 'foodanddrink'}, 'value': 0.029256852343678474},<br/>     {'address': {'category': 'travel'}, 'value': 0.025144552811980247},<br/>     {'address': {'category': 'finance'}, 'value': 0.032310131937265396},<br/>     {'address': {'category': 'lifestyle'}, 'value': 0.044232793152332306},<br/>     {'address': {'category': 'video'}, 'value': 0.040066931396722794},<br/>     {'address': {'category': 'movies'}, 'value': 0.033356472849845886},<br/>     {'address': {'category': 'weather'}, 'value': 0.045321717858314514},<br/>     {'address': {'category': 'northamerica'}, 'value': 0.0},<br/>     {'address': {'category': 'kids'}, 'value': 0.043478261679410934}]},<br/>   'rankingExpression(category_ctr)': 0.05611187964677811,<br/>   'rankingExpression(nearest_neighbor)': 0.14915188666574342,<br/>   'vespa.summaryFeatures.cached': 0.0}}}</span></pre><h2 id="2f09" class="lw lx iq bd ly lz ma dn mb mc md dp me ko mf mg mh ks mi mj mk kw ml mm mn mo bi translated">结论</h2><p id="942b" class="pw-post-body-paragraph kf kg iq kh b ki mp jr kk kl mq ju kn ko mr kq kr ks ms ku kv kw mt ky kz la ij bi translated">本教程介绍了父子关系，并通过我们在排名中使用的全局CTR特性进行了演示。我们还引入了使用(稀疏)张量表达式的排序。</p></div></div>    
</body>
</html>