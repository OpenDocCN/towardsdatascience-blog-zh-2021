<html>
<head>
<title>Python Parse Library: A Simple Way For Reversing F-strings</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python解析库:反转F字符串的简单方法</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/python-parse-library-simple-way-for-reversing-f-strings-72ad4d59e7c4?source=collection_archive---------10-----------------------#2021-09-05">https://towardsdatascience.com/python-parse-library-simple-way-for-reversing-f-strings-72ad4d59e7c4?source=collection_archive---------10-----------------------#2021-09-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0a0a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">我们有时需要反过来。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/8c50136a9bd15f71718a4d37bef78e33.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z1fcMHHwl2ol-GoW--NHkg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">马修·斯特恩在<a class="ae ky" href="https://unsplash.com/s/photos/reverse?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="447c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">字符串插值是使用占位符修改字符串的过程。结果字符串包括占位符的值。在Python中，format方法和f字符串是两种常用的字符串插值方法。</p><p id="642e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在跳到<a class="ae ky" href="https://pypi.org/project/parse/" rel="noopener ugc nofollow" target="_blank">解析</a>库之前，做几个例子来演示什么是字符串插值是有帮助的。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="f152" class="ma mb it lw b gy mc md l me mf">folder = "notebook"<br/>subfolder = "parse"</span><span id="0730" class="ma mb it lw b gy mg md l me mf">file_path = f"documents/{folder}/{subfolder}"</span><span id="e2c7" class="ma mb it lw b gy mg md l me mf">print(file_path)<br/>documents/notebook/parse</span></pre><p id="9fda" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">占位符用花括号表示，它们的值包含在输出中。</p><p id="92b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是另一个例子。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="1afc" class="ma mb it lw b gy mc md l me mf">name = "John"<br/>age = "23"</span><span id="5952" class="ma mb it lw b gy mg md l me mf">print(f"{name} is {age} years old.")<br/>John is 23 years old.</span></pre><p id="0141" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在更熟悉f弦和一般意义上的弦插值。解析库所做的是字符串插值过程的逆过程。</p><p id="b875" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可以使用解析库提取字符串中的值。我们将做几个例子来解释清楚这个过程。</p><p id="02f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">解析库可以很容易地与pip一起安装。如果你用的是jupyter笔记本，就加“！”在匹普之前。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="3ca0" class="ma mb it lw b gy mc md l me mf">!pip install parse</span></pre></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><h2 id="26bd" class="ma mb it bd mo mp mq dn mr ms mt dp mu li mv mw mx lm my mz na lq nb nc nd ne bi translated">从语法上分析</h2><p id="9617" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">在第一个示例中，我们使用预定义的文件夹和子文件夹名称创建了一个文件路径。让我们使用解析库从路径中获取文件夹名。我们首先需要从解析库中导入<em class="nk">解析</em>函数。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="6222" class="ma mb it lw b gy mc md l me mf">from parse import parse</span><span id="4e24" class="ma mb it lw b gy mg md l me mf">file_path = "documents/notebook/pandas"</span><span id="ddb2" class="ma mb it lw b gy mg md l me mf">parse("documents/{folder}/{subfolder}", file_path)<br/>&lt;Result () {'folder': 'notebook', 'subfolder': 'pandas'}&gt;</span></pre><p id="537d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们传递文件路径以及表示占位符的字符串。parse函数返回一个结果对象，但是我们可以通过添加命名方法使它看起来更漂亮。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="a2bc" class="ma mb it lw b gy mc md l me mf">parse("documents/{folder}/{subfolder}", file_path).named<br/>{'folder': 'notebook', 'subfolder': 'pandas'}</span></pre><p id="373c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们有一个格式相同的路径列表，我们需要提取文件夹和子文件夹的名称。这个任务可以通过解析器功能和列表理解的完美结合来轻松完成。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="aca3" class="ma mb it lw b gy mc md l me mf">file_paths = [<br/>    "documents/notebook/pandas",<br/>    "documents/notebook/parse",<br/>    "documents/notes/python"<br/>]</span><span id="85cb" class="ma mb it lw b gy mg md l me mf">[parse("documents/{folder}/{subfolder}", path).named for path in file_paths]</span><span id="9be1" class="ma mb it lw b gy mg md l me mf">[{'folder': 'notebook', 'subfolder': 'pandas'},<br/> {'folder': 'notebook', 'subfolder': 'parse'},<br/> {'folder': 'notes', 'subfolder': 'python'}]</span></pre></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><h2 id="1b86" class="ma mb it bd mo mp mq dn mr ms mt dp mu li mv mw mx lm my mz na lq nb nc nd ne bi translated">搜索</h2><p id="c6eb" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">解析库还提供了一些其他函数，在特殊情况下会很方便。例如，<em class="nk"> search </em> <strong class="lb iu"> </strong>函数在字符串中查找某种格式。因此，我们不必提供整个字符串的确切格式。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="c754" class="ma mb it lw b gy mc md l me mf">from parse import search</span><span id="31b6" class="ma mb it lw b gy mg md l me mf">txt = "Name: Jane, Department: Engineering, Age: 22"</span><span id="5896" class="ma mb it lw b gy mg md l me mf">search("Name: {Name},", txt).named<br/>{'Name': 'Jane'}</span></pre><p id="cc02" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们不确定确切的字符串时，也可以使用搜索功能。因此，它提供了额外的灵活性。</p><p id="650e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">考虑以下字符串:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="17f7" class="ma mb it lw b gy mc md l me mf">txt = "The department of civil engineering has 23 employees"<br/>txt2 = "The civil engineering department has 23 employees"</span></pre><p id="8ec1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要找到文本中雇员的数量。我们可以用同样的子模式找到它。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="b7e8" class="ma mb it lw b gy mc md l me mf">search("has {number_of_employees} employees", txt).named<br/>{'number_of_employees': '23'}</span><span id="690a" class="ma mb it lw b gy mg md l me mf">search("has {number_of_employees} employees", txt2).named<br/>{'number_of_employees': '23'}</span></pre></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><h2 id="a5ec" class="ma mb it bd mo mp mq dn mr ms mt dp mu li mv mw mx lm my mz na lq nb nc nd ne bi translated">芬达尔</h2><p id="c11c" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">解析库中另一个有用的函数是<em class="nk"> findall </em>函数。如果有多个我们感兴趣的相同模式的部分，我们可以使用findall而不是parse。</p><p id="555b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下示例显示了findall函数的一种可能用法。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="aa5d" class="ma mb it lw b gy mc md l me mf">from parse import findall</span><span id="7295" class="ma mb it lw b gy mg md l me mf">paths = "documents/notebook/pandas/ documents/notebook/parse/ documents/notes/python/"</span><span id="7b10" class="ma mb it lw b gy mg md l me mf">findall("documents/{folder}/{subfolder}/", paths)<br/>&lt;parse.ResultIterator at 0x2056556ab80&gt;</span></pre><p id="e227" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们有一个很长的字符串，其中包含多个格式相同的文件路径。findall函数，顾名思义，查找给定路径结构的所有文件夹和子文件夹名称。</p><p id="4214" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">默认情况下，它返回一个迭代器，但我们可以很容易地将其转换成一个列表。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="2acd" class="ma mb it lw b gy mc md l me mf">list(findall("documents/{folder}/{subfolder}/", paths))</span><span id="fcda" class="ma mb it lw b gy mg md l me mf">[&lt;Result () {'folder': 'notebook', 'subfolder': 'pandas'}&gt;,<br/> &lt;Result () {'folder': 'notebook', 'subfolder': 'parse'}&gt;,<br/> &lt;Result () {'folder': 'notes', 'subfolder': 'python'}&gt;]</span></pre><p id="0452" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该列表包含3个结果对象。我们可以将命名方法分别应用于这些对象。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="d472" class="ma mb it lw b gy mc md l me mf">a = list(findall("documents/{folder}/{subfolder}/", paths))</span><span id="e58a" class="ma mb it lw b gy mg md l me mf">a[0].named<br/>{'folder': 'notebook', 'subfolder': 'pandas'}</span></pre></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><h2 id="53e8" class="ma mb it bd mo mp mq dn mr ms mt dp mu li mv mw mx lm my mz na lq nb nc nd ne bi translated">结论</h2><p id="8b3c" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">Parse是一个非常实用的函数库。正如我们在示例中看到的，它提供了在字符串中查找模式和值的简单方法。某种意义上是字符串插值的逆向运算。</p><p id="6641" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还有其他方法来执行相同的任务。例如，本文中的例子也可以用regex来完成。但是，对于某些操作来说，正则表达式可能太复杂了。我觉得解析库提供了更简单的解决方案。</p><p id="899a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想了解更多关于解析库的知识，请随意访问官方文档。</p><p id="b974" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢您的阅读。如果您有任何反馈，请告诉我。</p></div></div>    
</body>
</html>