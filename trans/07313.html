<html>
<head>
<title>The Auto-Sommelier — How to Implement HuggingFace Transformers and Build a Search Engine</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">自动侍酒师——如何实现HuggingFace Transformers并构建搜索引擎</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/the-auto-sommelier-how-to-implement-huggingface-transformers-and-build-a-search-engine-9e0f401b1bda?source=collection_archive---------10-----------------------#2021-07-03">https://towardsdatascience.com/the-auto-sommelier-how-to-implement-huggingface-transformers-and-build-a-search-engine-9e0f401b1bda?source=collection_archive---------10-----------------------#2021-07-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a2af" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">享受一些葡萄酒，现代自然语言处理，简单的代码，情节和破折号</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5b48e8320aa1c817b1c49a7419020c68.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Ld8OdDD2pdY9b6Tw"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">贾斯汀·艾金在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><h1 id="71d3" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">创建自动侍酒师</h1><p id="500a" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">回到2019年8月，我将我的第一个自然语言处理(NLP)项目投入生产，并在我的网站上主持了<a class="ae ky" href="http://robotsdodream.com" rel="noopener ugc nofollow" target="_blank">自动侍酒师。使用</a><a class="ae ky" rel="noopener" target="_blank" href="/generating-wine-recommendations-using-the-universal-sentence-encoder-d086edd13d00"> TensorFlow 1和通用语句编码器</a>，我允许用户描述他们理想的葡萄酒，并返回与查询相似的描述。该工具将葡萄酒评论和用户输入转换为向量，并计算用户输入和葡萄酒评论之间的余弦相似性，以找到最相似的结果。</p><p id="ee1b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><a class="ae ky" href="https://en.wikipedia.org/wiki/Cosine_similarity" rel="noopener ugc nofollow" target="_blank">余弦相似度</a>是一种比较文档相似度的常用方法，因为它适用于词频等对分析非常重要的数据。它反映了单个向量维度的相对比较，而不是绝对比较。在本文中，我不会深入探究余弦相似性背后的数学，但我知道它是内积空间的两个非零向量之间相似性的度量。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ms"><img src="../Images/0fc3d3ce000c10a76dc19b52e4328333.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N7KEcBOnrPhqKP0Ta0SH-Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">自动侍酒师(RobotsDoDreams.com)</p></figure><h1 id="f82e" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">增强时间到了</h1><p id="b5b4" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">虽然该模型仍然有效，但自2019年以来，自然语言处理取得了巨大进展。使用像HuggingFace的Transformers这样的工具，将句子或段落转换成可用于语义相似性等NLP任务的向量从未如此简单。使用最新的技术和语言模型重构我的代码将会使它更有性能。如果你是NLP新手，可以看看我的初学者教程。</p><div class="mt mu gp gr mv mw"><a rel="noopener follow" target="_blank" href="/how-to-vectorize-text-in-dataframes-for-nlp-tasks-3-simple-techniques-82925a5600db"><div class="mx ab fo"><div class="my ab mz cl cj na"><h2 class="bd iu gy z fp nb fr fs nc fu fw is bi translated">如何对自然语言处理任务的数据帧中的文本进行矢量化——3种简单的技术</h2><div class="nd l"><h3 class="bd b gy z fp nb fr fs nc fu fw dk translated">使用Texthero、Gensim和Tensorflow的简单代码示例</h3></div><div class="ne l"><p class="bd b dl z fp nb fr fs nc fu fw dk translated">towardsdatascience.com</p></div></div><div class="nf l"><div class="ng l nh ni nj nf nk ks mw"/></div></div></a></div><p id="c0a4" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在本教程中，我将解释如何使用<a class="ae ky" href="https://huggingface.co/" rel="noopener ugc nofollow" target="_blank">拥抱脸变形金刚库</a>、<a class="ae ky" href="https://github.com/nmslib/nmslib" rel="noopener ugc nofollow" target="_blank">非度量空间库</a>和<a class="ae ky" href="http://pythondashboards.com" rel="noopener ugc nofollow" target="_blank"> Dash库</a>来构建一个新的和改进的自动侍酒师。完整的代码和GitHub链接可以在文章的底部找到。</p><h1 id="1292" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">葡萄酒数据</h1><p id="901b" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">葡萄酒数据来自在<a class="ae ky" href="https://www.kaggle.com/" rel="noopener ugc nofollow" target="_blank">kaggle.com上找到的</a><a class="ae ky" href="https://www.kaggle.com/zynicide/wine-reviews" rel="noopener ugc nofollow" target="_blank">葡萄酒评论</a>数据集。原始数据包含大约130，000行数据，包括国家、描述、标题、品种、酒厂、价格和评级等列。</p><p id="a051" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><a class="ae ky" rel="noopener" target="_blank" href="/generating-wine-recommendations-using-the-universal-sentence-encoder-d086edd13d00">查看所有</a>数据工程代码的原文。</p><p id="ef21" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">将数据放入dataframe后，我删除了包含重复描述的行和价格为空的行。我还将数据限制在有超过200条评论的葡萄酒品种上。</p><p id="3381" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">通过排除少于200条评论的品种来减少数据，我得到了54种葡萄酒。在清除了空数据和重复数据之后，剩下100，228行。通过谷歌搜索剩下的品种，我可以添加一个颜色栏，这样用户就可以通过想要的葡萄酒颜色来限制他们的搜索。</p><h2 id="63e8" class="nl la it bd lb nm nn dn lf no np dp lj ma nq nr ll me ns nt ln mi nu nv lp nw bi translated">导入依赖项和数据</h2><p id="c5a7" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">很容易将数据连接并加载到dataframe中，因为它已经是一个sqlite文件。按照三个步骤加载库、数据和数据帧。</p><p id="9ba9" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">1.导入<em class="nx"> pandas </em>和<em class="nx"> sqlite3 </em>库。<br/> 2。连接到<strong class="lt iu"> sqlite </strong>文件。<br/> 3。将数据加载到熊猫数据框架中。</p><pre class="kj kk kl km gt ny nz oa ob aw oc bi"><span id="911f" class="nl la it nz b gy od oe l of og">#<em class="nx">Import dependencies <br/></em>import numpy as np<br/>import pandas as pd<br/>import sqlite3<br/>from sqlite3 import Error</span><span id="659b" class="nl la it nz b gy oh oe l of og">import texthero as hero<br/>from texthero import preprocessing<br/>from sentence_transformers import SentenceTransformer, util<br/>import nmslib</span><span id="5200" class="nl la it nz b gy oh oe l of og">import time<br/>import datetime</span><span id="9dc2" class="nl la it nz b gy oh oe l of og"><em class="nx"><br/>#Establish connection to sqlite database</em><br/>conn = sqlite3.connect("wine_data.sqlite")</span><span id="17cb" class="nl la it nz b gy oh oe l of og"><em class="nx">#load the data into a pandas DataFrame</em><br/>df = pd.read_sql("select * from wine_data", conn)</span></pre><p id="2e1e" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">注意，我还导入了将在教程中使用的其他库。我将更多地介绍他们。使用pandas <strong class="lt iu"> read_sql </strong>函数生成一个使用原始sql的数据帧。请注意，数据集中有16列和100228行。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/651d53dd2367073f592ba5c8722ffcee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hSQDQzTiuUVHnLSmbPVlxg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">葡萄酒数据df.head(3)</p></figure><p id="e338" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><strong class="lt iu"/></p></div><div class="ab cl oj ok hx ol" role="separator"><span class="om bw bk on oo op"/><span class="om bw bk on oo op"/><span class="om bw bk on oo"/></div><div class="im in io ip iq"><h1 id="9d85" class="kz la it bd lb lc oq le lf lg or li lj jz os ka ll kc ot kd ln kf ou kg lp lq bi translated">拥抱脸🤗变形金刚(电影名)</h1><p id="04ff" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">如果你在过去一年左右的时间里参与了自然语言处理(NLP)领域，你可能已经听说过HuggingFace🤗。HuggingFace是一个专注于NLP的人工智能和深度学习平台，目标是实现人工智能技术的民主化。他们精简和简化了应用和微调预先训练的语言模型。</p><p id="a06c" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">Transformers是一个开源库，具有一个模型中心，允许用户基于通用架构(如BERT、XLM、DistilBert等)实现最先进的深度学习模型...它构建在PyTorch、TensorFlow和Jax之上，并且已知在框架之间具有良好的互操作性。</p><p id="3668" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">他们刚刚发布了一个完整的课程，带你穿越拥抱脸生态系统。我强烈推荐它:</p><div class="mt mu gp gr mv mw"><a href="https://huggingface.co/course/chapter1" rel="noopener  ugc nofollow" target="_blank"><div class="mx ab fo"><div class="my ab mz cl cj na"><h2 class="bd iu gy z fp nb fr fs nc fu fw is bi translated">变形金刚模型——拥抱脸课程</h2><div class="nd l"><h3 class="bd b gy z fp nb fr fs nc fu fw dk translated">这门课将教你自然语言处理(NLP ),使用来自拥抱脸生态系统的库——🤗…</h3></div><div class="ne l"><p class="bd b dl z fp nb fr fs nc fu fw dk translated">huggingface.co</p></div></div><div class="nf l"><div class="ov l nh ni nj nf nk ks mw"/></div></div></a></div><p id="9f20" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">使用pip安装库</p><pre class="kj kk kl km gt ny nz oa ob aw oc bi"><span id="9a91" class="nl la it nz b gy od oe l of og">$ pip install transformers</span></pre><p id="b839" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在这个例子中，我将使用<a class="ae ky" href="https://huggingface.co/distilbert-base-uncased" rel="noopener ugc nofollow" target="_blank"><strong class="lt iu"><em class="nx">distilBERT-base-un cased</em></strong></a>模型，因为它与我们的用例、语义相似性表现良好。它将文本转换成768维向量。<a class="ae ky" href="https://huggingface.co/models?pipeline_tag=sentence-similarity" rel="noopener ugc nofollow" target="_blank">如果你不想使用distilBERT </a>，探索所有句子相似度的HuggingFace模型 <a class="ae ky" href="https://huggingface.co/models?pipeline_tag=sentence-similarity" rel="noopener ugc nofollow" target="_blank">。这个模型是不区分大小写的，这意味着它不区分英语和英语。</a><a class="ae ky" href="https://arxiv.org/abs/1910.01108" rel="noopener ugc nofollow" target="_blank">查看官方文件，了解关于该型号的详细信息</a>。</p><p id="9596" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">要实现该模型，请遵循以下步骤:</p><ol class=""><li id="6777" class="ow ox it lt b lu mn lx mo ma oy me oz mi pa mm pb pc pd pe bi translated">用<em class="nx">distil Bert-base-un cased</em>模型实例化<strong class="lt iu"> SentenceTransformer </strong>。</li><li id="b83e" class="ow ox it lt b lu pf lx pg ma ph me pi mi pj mm pb pc pd pe bi translated">调用<strong class="lt iu">编码</strong>并将葡萄酒描述传入其中。将参数<strong class="lt iu">convert _ to _ tensor</strong>=<em class="nx">设置为True。</em></li></ol><pre class="kj kk kl km gt ny nz oa ob aw oc bi"><span id="e5f5" class="nl la it nz b gy od oe l of og">#load the distilbert model <br/>distilbert = SentenceTransformer('distilbert-base-uncased')</span><span id="8f54" class="nl la it nz b gy oh oe l of og">#generate the embeddings for the wine reviews<br/>embeddings = distilbert.encode(df['description'], convert_to_tensor=True)</span></pre><p id="a34f" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><strong class="lt iu"> <em class="nx">注意</em> </strong>:如果您之前从未下载过该模型，您将看到它正在下载，并且可能会弹出一些消息。这很正常。</p><p id="cb65" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">一旦该过程完成，文本描述将被转换成长度为768的向量。我们可以检查长度和第一次嵌入，以确保它看起来像预期的那样:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pk"><img src="../Images/656e4c86a74a4c7af45c65f7e9738e6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1132/format:webp/1*7b3iys5DpKK781EaHmhhBQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">print(len(embeddings[0])<br/>print(embeddings[0])</p></figure><p id="824a" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">为了使向量更容易分析，使用numpy将数据从张量对象转换为列表对象，然后将列表附加到pandas数据帧。</p><pre class="kj kk kl km gt ny nz oa ob aw oc bi"><span id="23a6" class="nl la it nz b gy od oe l of og">#add embeddings to dataframe<br/>df['distilbert'] = np.array(embeddings).tolist()</span><span id="ac3b" class="nl la it nz b gy oh oe l of og">#show the top row<br/>df.head(1)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pl"><img src="../Images/2dfd0a7d5cb669cfe1d8c2f2cce84bda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KiSKDZIjo0dtTiuB3K_hug.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">数据帧中的嵌入df.head(1)</p></figure></div><div class="ab cl oj ok hx ol" role="separator"><span class="om bw bk on oo op"/><span class="om bw bk on oo op"/><span class="om bw bk on oo"/></div><div class="im in io ip iq"><h1 id="e6bb" class="kz la it bd lb lc oq le lf lg or li lj jz os ka ll kc ot kd ln kf ou kg lp lq bi translated">创建搜索索引</h1><p id="35fa" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">当使用像谷歌或必应这样的搜索引擎时，用户希望很快得到结果。为了以闪电般的速度搜索我们的结果集，我们可以使用轻量级且高效的<a class="ae ky" href="https://github.com/nmslib/nmslib" rel="noopener ugc nofollow" target="_blank">非度量空间库(NMSLIB) </a>。</p><p id="4a45" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">使用pip安装它:</p><pre class="kj kk kl km gt ny nz oa ob aw oc bi"><span id="119b" class="nl la it nz b gy od oe l of og">$ <!-- -->pip install nmslib</span></pre><p id="8170" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">如前所述，我们希望使用余弦相似度作为我们比较用户输入和葡萄酒描述的度量。我们需要能够找到与我们的搜索向量最近的向量。使用蛮力技术搜索和排序数据既昂贵又缓慢。相反，应该为数据点创建一个索引。</p><p id="1e9c" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">创建搜索余弦相似性索引相当简单:</p><ol class=""><li id="ae22" class="ow ox it lt b lu mn lx mo ma oy me oz mi pa mm pb pc pd pe bi translated">初始化一个新的索引，通过<em class="nx"> hnsw </em>作为<strong class="lt iu">方法</strong>和<em class="nx">余弦米尔</em>作为<strong class="lt iu">空间</strong>。</li><li id="5817" class="ow ox it lt b lu pf lx pg ma ph me pi mi pj mm pb pc pd pe bi translated">使用<strong class="lt iu"> addDataPointBatch </strong>方法将嵌入添加到索引中。</li><li id="8a16" class="ow ox it lt b lu pf lx pg ma ph me pi mi pj mm pb pc pd pe bi translated">使用<strong class="lt iu"> createIndex </strong>方法创建带有数据点的索引。</li></ol><pre class="kj kk kl km gt ny nz oa ob aw oc bi"><span id="887b" class="nl la it nz b gy od oe l of og"># initialize a new index, using a HNSW index on Cosine Similarity<br/>distilbert_index = nmslib.init(method='hnsw', space='cosinesimil')<br/>distilbert_index.addDataPointBatch(embeddings)<br/>distilbert_index.createIndex({'post': 2}, print_progress=True)</span></pre><p id="ed34" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">如果您希望保存索引并在以后加载它(比如在生产服务器上)，请使用以下代码:</p><pre class="kj kk kl km gt ny nz oa ob aw oc bi"><span id="37ca" class="nl la it nz b gy od oe l of og">#Save a meta index and the data<br/>index.saveIndex('index.bin', save_data=True)</span><span id="0ead" class="nl la it nz b gy oh oe l of og">#Re-intitialize the library, specify the space<br/>newIndex = nmslib.init(method='hnsw', space='cosinesimil_sparse')</span><span id="6596" class="nl la it nz b gy oh oe l of og"><em class="nx">#Re-load the index and the data<br/></em>newIndex.loadIndex('sparse_index.bin', load_data=<strong class="nz iu">True</strong>)</span></pre></div><div class="ab cl oj ok hx ol" role="separator"><span class="om bw bk on oo op"/><span class="om bw bk on oo op"/><span class="om bw bk on oo"/></div><div class="im in io ip iq"><h1 id="c16e" class="kz la it bd lb lc oq le lf lg or li lj jz os ka ll kc ot kd ln kf ou kg lp lq bi translated">创建搜索功能</h1><p id="7426" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">既然数据已经矢量化，搜索索引也已经填充，那么是时候创建接收用户查询并返回相似葡萄酒的函数了。</p><p id="02c8" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><strong class="lt iu"> search_wine </strong>函数将接受两个输入:<em class="nx"> DataFrame </em>和<em class="nx"> UserQuery </em>。用户查询将使用<strong class="lt iu">编码</strong>转换成一个向量，就像我们对葡萄酒描述所做的那样。然后NMSLIB可以用来返回用户查询向量的<a class="ae ky" href="https://en.wikipedia.org/wiki/K-nearest_neighbors_algorithm" rel="noopener ugc nofollow" target="_blank"> <em class="nx"> k近邻</em> </a>。我设置了<em class="nx"> k=20 </em>，不过可以随意实验。</p><pre class="kj kk kl km gt ny nz oa ob aw oc bi"><span id="d725" class="nl la it nz b gy od oe l of og">def search_wine(dataframe, userQuery):<br/>    <br/>    if dataframe is not None and userQuery is not None:<br/>        df = dataframe.copy()<br/>        query = distilbert.encode([userQuery], convert_to_tensor=True)<br/>        ids, distances = distilbert_index.knnQuery(query, k=20)</span><span id="15d6" class="nl la it nz b gy oh oe l of og">     matches = []</span><span id="414f" class="nl la it nz b gy oh oe l of og">     for i, j in zip(ids, distances):</span><span id="b952" class="nl la it nz b gy oh oe l of og">          matches.append({'country':df.country.values[i]<br/>                        , 'winery' : df.winery.values[i]<br/>                        , 'title' : df.title.values[i]<br/>                        , 'variety': df.variety.values[i]<br/>                        , 'color' : df.color.values[i]<br/>                        , 'description': df.description.values[i]<br/>                        , 'price': df.price.values[i]<br/>                        , 'rating': df.rating.values[i]<br/>                        , 'distance': j<br/>                       })</span><span id="16df" class="nl la it nz b gy oh oe l of og">     return pd.DataFrame(matches)</span></pre><p id="3aa8" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">注意结果被返回并作为字典附加到一个列表中。这使得将结果转换回数据帧变得容易。对于<strong class="lt iu"> <em class="nx">距离</em> </strong>值，越小越好。例如，距离为0意味着向量相同。</p><p id="c168" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">测试功能:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pm"><img src="../Images/047116fa6ee12e92db77f335f499704b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MCXwHU_UYYCa67UXMDza_g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">搜索_葡萄酒结果</p></figure><h1 id="1879" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">创建可视化资源管理器</h1><p id="3493" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">除了文本搜索之外，我们还可以使用降维技术在二维空间中绘制葡萄酒，从而提供一个可视化的浏览器。使用<a class="ae ky" href="https://texthero.org/docs/api/texthero.representation.tsne" rel="noopener ugc nofollow" target="_blank"> Texthero库</a>，很容易应用<a class="ae ky" href="https://en.wikipedia.org/wiki/T-distributed_stochastic_neighbor_embedding" rel="noopener ugc nofollow" target="_blank"> t-SNE算法</a>来降低向量的维数并将其可视化。在引擎盖下，Texthero使用<a class="ae ky" href="http://plotly.com" rel="noopener ugc nofollow" target="_blank"> Plotly </a>制作交互式图表。</p><p id="91bb" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">t-SNE(t-distributed random neighbor embedding)是一种用于可视化高维数据的<a class="ae ky" href="https://en.wikipedia.org/wiki/Machine_learning" rel="noopener ugc nofollow" target="_blank">机器学习</a>算法。t-SNE技术应用了<strong class="lt iu">非线性</strong>降维。</p><p id="a040" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">将t-SNE应用于数据帧中的<strong class="lt iu">蒸馏</strong>向量列。</p><pre class="kj kk kl km gt ny nz oa ob aw oc bi"><span id="a3d5" class="nl la it nz b gy od oe l of og">df['tsnedistilbert'] = hero.tsne(df['distilbert'])</span></pre><p id="b9ed" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">使用texthero创建散点图。</p><pre class="kj kk kl km gt ny nz oa ob aw oc bi"><span id="08b6" class="nl la it nz b gy od oe l of og">#create scatter plot of wines using the <br/>hero.scatterplot(df, col='tsnedistilbert'<br/>                 , color='variety'<br/>                 , title="Wine Explorer"<br/>                 , hover_data = ['title','variety','price','description'])</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pn"><img src="../Images/1ef4a4f3c5a0f005e14254fdd6a4a64b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I1i_HfkI0IDMWUz8ZTBSsw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">葡萄酒浏览器可视化</p></figure><p id="aa2b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">数据中有如此多的变化，以至于散点图看起来像宇宙背景辐射，但这没关系。将鼠标悬停在一个点上会显示更多信息。用户可以点击一个品种，将其从图表中删除。例如，这里是关于葡萄牙红色和白色的混合:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi po"><img src="../Images/21472c308b9cc15ad10d8f072f15568d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NfD-f4QlZxBFfxiIBJtZtg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">葡萄牙红色和白色混合</p></figure><p id="1b01" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">有趣的是，我们可以看到一些品种是如何聚集在一起的，而另一些品种是如何分散在各处的。</p></div><div class="ab cl oj ok hx ol" role="separator"><span class="om bw bk on oo op"/><span class="om bw bk on oo op"/><span class="om bw bk on oo"/></div><div class="im in io ip iq"><h1 id="14bf" class="kz la it bd lb lc oq le lf lg or li lj jz os ka ll kc ot kd ln kf ou kg lp lq bi translated">创建用户界面</h1><p id="75e1" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">为了允许用户与搜索功能进行交互，我们可以使用Dash by Plotly构建一个简单的用户界面。<a class="ae ky" href="https://dash.plot.ly/" rel="noopener ugc nofollow" target="_blank"> Dash是一个基于Flask、Plotly.js和React.js编写的Python框架</a>，如果你是Dash新手，想要掌握基础知识，请查看我的所有教程:</p><div class="mt mu gp gr mv mw"><a href="https://medium.com/swlh/dashboards-in-python-for-beginners-and-everyone-else-using-dash-f0a045a86644" rel="noopener follow" target="_blank"><div class="mx ab fo"><div class="my ab mz cl cj na"><h2 class="bd iu gy z fp nb fr fs nc fu fw is bi translated">Python中的仪表盘，适用于初学者和使用Dash的其他人</h2><div class="nd l"><h3 class="bd b gy z fp nb fr fs nc fu fw dk translated">使用Python中的Dash初学者教程构建一个基本的和高级的仪表板</h3></div><div class="ne l"><p class="bd b dl z fp nb fr fs nc fu fw dk translated">medium.com</p></div></div><div class="nf l"><div class="pp l nh ni nj nf nk ks mw"/></div></div></a></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pq"><img src="../Images/4de6a16d51d4b8a90bdc55098d57228a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7sb6z34I-RoGTTn5Vk53qg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">用户界面</p></figure><p id="495b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">如果您想在jupyter笔记本中构建dash应用程序，请安装Dash、Dash引导组件和jupyter-dash。</p><pre class="kj kk kl km gt ny nz oa ob aw oc bi"><span id="e94e" class="nl la it nz b gy od oe l of og">pip install dash<br/>pip install dash-bootstrap-components<br/>pip install jupyter-dash #if you want to build in a jupyter notebook</span></pre><p id="3397" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">Dash应用程序由<strong class="lt iu">布局</strong>和<strong class="lt iu">回调</strong>组成:</p><h2 id="3a47" class="nl la it bd lb nm nn dn lf no np dp lj ma nq nr ll me ns nt ln mi nu nv lp nw bi translated">布局</h2><p id="fe10" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated"><a class="ae ky" href="https://dash.plot.ly/getting-started" rel="noopener ugc nofollow" target="_blank">布局</a>由组件树组成，描述了应用程序的外观以及用户如何体验内容。</p><h2 id="5ac0" class="nl la it bd lb nm nn dn lf no np dp lj ma nq nr ll me ns nt ln mi nu nv lp nw bi translated">复试</h2><p id="aae6" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated"><a class="ae ky" href="https://dash.plot.ly/getting-started-part-2" rel="noopener ugc nofollow" target="_blank">回调</a>使Dash应用程序具有交互性。回调是Python函数，每当<em class="nx">输入</em>属性改变时，就会自动调用。</p><h1 id="2cae" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">构建布局</h1><p id="cffe" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">布局超级简单，采取极简的手法。使用一张卡片来放置搜索框，让用户按一个按钮，然后返回结果。这个例子使用了<a class="ae ky" href="https://dash-bootstrap-components.opensource.faculty.ai/docs/quickstart/" rel="noopener ugc nofollow" target="_blank">引导组件</a>。</p><pre class="kj kk kl km gt ny nz oa ob aw oc bi"><span id="4a21" class="nl la it nz b gy od oe l of og">import dash<br/>from jupyter_dash import JupyterDash<br/>import dash_bootstrap_components as dbc<br/>import dash_html_components as html<br/>import dash_core_components as dcc<br/>from dash.dependencies import Input, Output</span><span id="2ae6" class="nl la it nz b gy oh oe l of og">external_stylesheets = [dbc.themes.BOOTSTRAP]</span><span id="51b7" class="nl la it nz b gy oh oe l of og">app = JupyterDash(__name__, external_stylesheets = external_stylesheets)</span><span id="14e1" class="nl la it nz b gy oh oe l of og"># Create server variable with Flask server object for use with gunicorn<br/>server = app.server</span></pre><p id="213b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">添加boiler-plate代码以运行Dash应用程序后，创建将用作布局的组件树。我称第一个组件树为search_card。</p><p id="784a" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">search_card使用<strong class="lt iu">卡</strong>和<strong class="lt iu">卡体</strong>来包含<strong class="lt iu">文本区</strong>和<strong class="lt iu">按钮</strong>组件。在我看来，把它们放进卡片里会让它看起来更好一点。</p><pre class="kj kk kl km gt ny nz oa ob aw oc bi"><span id="57a9" class="nl la it nz b gy od oe l of og">search_card = dbc.Card(<br/>    dbc.CardBody(<br/>        [<br/>            html.H5("Auto-Sommelier", className="card-title")<br/>            , dbc.Textarea(id = 'user-input', bs_size="lg"<br/>                     , placeholder="Describe Ideal Wine")<br/>             ,dbc.Button('search', id = 'search', color="danger")<br/>        ]<br/>    )<br/>)</span></pre><p id="a0f8" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">第二个组件树充当<strong class="lt iu"> <em class="nx"> search_card </em> </strong>和包含葡萄酒结果的卡片的容器。该组件树将被设置为<strong class="lt iu"> app.layout </strong>。</p><pre class="kj kk kl km gt ny nz oa ob aw oc bi"><span id="7f42" class="nl la it nz b gy od oe l of og">app.layout = html.Div([html.H1("Find Your Wine!")<br/>                   , html.Br()<br/>                   , dbc.Row(dbc.Col(<strong class="nz iu">search_card</strong>,<br/>                        width={"size": 6, "offset": 3}))#end row<br/>                  , html.Br()<br/>                  , dbc.Card(dbc.CardBody(html.Div(id = 'results')))<br/>                  ])</span></pre><p id="2dcc" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">注意<strong class="lt iu"> <em class="nx"> search_card </em> </strong>被放到<strong class="lt iu">行</strong>和<strong class="lt iu">列</strong>组件中，这样更容易居中。在第二棵树的末尾，它包含另一个<strong class="lt iu">卡片</strong>和<strong class="lt iu">卡片主体</strong>，其中<strong class="lt iu"> </strong>只包含一个<strong class="lt iu"> <em class="nx"> html。Div </em> </strong>与<strong class="lt iu"> <em class="nx"> id =结果</em> </strong>。该应用程序将依靠回调来用搜索结果填充CardBody的Div组件。</p><p id="57bc" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">回调会将结果输出到结果<strong class="lt iu"> Div </strong>。作为输入，回调将接受用户的查询和按钮点击。如果都不是，查询将被传递给<strong class="lt iu"> search_wine </strong>函数，并以数据帧的形式返回结果。</p><pre class="kj kk kl km gt ny nz oa ob aw oc bi"><span id="eb13" class="nl la it nz b gy od oe l of og"><a class="ae ky" href="http://twitter.com/app" rel="noopener ugc nofollow" target="_blank">@app</a>.callback(Output("results", "children")<br/>              , [Input("user-input", "value")<br/>                , Input("search", "n_clicks")<br/>                ])<br/>def return_wine(userquery, n):<br/>    <br/>    if userquery is not None and n is not None:<br/>        <br/>        dff = df.copy()<br/>        results = search_wine(dff, userquery)<br/>        table = dbc.Table.from_dataframe(results, striped=True, bordered=True, hover=True)<br/>    <br/>        return table</span></pre><p id="b5f0" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">请注意，dataframe是使用bootstrap <strong class="lt iu"> Table </strong>组件转换成HTML表格的。</p><p id="9c7b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">要运行Dash应用程序，请使用以下命令:</p><pre class="kj kk kl km gt ny nz oa ob aw oc bi"><span id="b735" class="nl la it nz b gy od oe l of og">app.run_server()<br/>#Dash app running on <a class="ae ky" href="http://127.0.0.1:8050/" rel="noopener ugc nofollow" target="_blank">http://127.0.0.1:8050/</a></span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pr"><img src="../Images/b1a699d9570842dbe0582aadeda099fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kgy7YRiSv95ganBcmVxtzw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">自动侍酒师</p></figure><p id="bb23" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">恭喜你！你刚刚用拥抱脸变形、余弦相似度和破折号制作了你自己的葡萄酒搜索引擎！</p></div><div class="ab cl oj ok hx ol" role="separator"><span class="om bw bk on oo op"/><span class="om bw bk on oo op"/><span class="om bw bk on oo"/></div><div class="im in io ip iq"><h1 id="886a" class="kz la it bd lb lc oq le lf lg or li lj jz os ka ll kc ot kd ln kf ou kg lp lq bi translated">最后的想法和完整的代码</h1><p id="35aa" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">与我在2019年创建的原始自动侍酒师相比，这个版本的实现速度快得多，也简单得多。通过像HuggingFace这样的框架利用最先进的语言模型的能力为像我这样的机器学习爱好者打开了大门，让他们只用几行代码就可以构建一些令人敬畏的应用程序。现在是做一些分析的时候了，看看结果与原来的工具相比有什么改进！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ps"><img src="../Images/64fa9e5052592544549b79add4b1122f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nMUYk_9E4ksjBV4u8f5ysQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">比较同一查询的结果。新(顶部)</p></figure><p id="54c0" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">感谢阅读！以下是完整的代码:</p><div class="mt mu gp gr mv mw"><a href="https://github.com/bendgame/MediumWineRecommend2" rel="noopener  ugc nofollow" target="_blank"><div class="mx ab fo"><div class="my ab mz cl cj na"><h2 class="bd iu gy z fp nb fr fs nc fu fw is bi translated">bend game/medium wine推荐2</h2><div class="nd l"><h3 class="bd b gy z fp nb fr fs nc fu fw dk translated">更新了Wine推荐使用中等弯曲游戏的拥抱脸变形金刚/中等Wine推荐2</h3></div><div class="ne l"><p class="bd b dl z fp nb fr fs nc fu fw dk translated">github.com</p></div></div><div class="nf l"><div class="pt l nh ni nj nf nk ks mw"/></div></div></a></div><h1 id="be12" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">谢谢大家！</h1><ul class=""><li id="9f8b" class="ow ox it lt b lu lv lx ly ma pu me pv mi pw mm px pc pd pe bi translated"><em class="nx">如果你喜欢我的作品，</em> <a class="ae ky" href="https://medium.com/@erickleppen" rel="noopener"> <em class="nx">关注我中的</em> </a> <em class="nx">了解更多！</em></li><li id="d9b0" class="ow ox it lt b lu pf lx pg ma ph me pi mi pj mm px pc pd pe bi translated"><a class="ae ky" href="https://erickleppen.medium.com/membership" rel="noopener"> <em class="nx">通过订阅</em> </a>获得对我的内容的完全访问和帮助支持！</li><li id="75c5" class="ow ox it lt b lu pf lx pg ma ph me pi mi pj mm px pc pd pe bi translated"><em class="nx">我们来连线上</em><a class="ae ky" href="https://www.linkedin.com/in/erickleppen01/" rel="noopener ugc nofollow" target="_blank"><em class="nx">LinkedIn</em></a></li><li id="8488" class="ow ox it lt b lu pf lx pg ma ph me pi mi pj mm px pc pd pe bi translated"><em class="nx">用Python分析数据？查看我的</em> <a class="ae ky" href="https://pythondashboards.com/" rel="noopener ugc nofollow" target="_blank"> <em class="nx">网站</em> </a>！</li></ul><p id="0c04" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><a class="ae ky" href="http://pythondashboards.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="lt iu"> —埃里克·克莱彭</strong> </a></p><div class="mt mu gp gr mv mw"><a href="https://erickleppen.medium.com/the-ultimate-guide-to-erics-articles-d32df8241353" rel="noopener follow" target="_blank"><div class="mx ab fo"><div class="my ab mz cl cj na"><h2 class="bd iu gy z fp nb fr fs nc fu fw is bi translated">埃里克文章的终极指南</h2><div class="nd l"><h3 class="bd b gy z fp nb fr fs nc fu fw dk translated">我的所有内容按主题组织…</h3></div><div class="ne l"><p class="bd b dl z fp nb fr fs nc fu fw dk translated">erickleppen.medium.com</p></div></div><div class="nf l"><div class="py l nh ni nj nf nk ks mw"/></div></div></a></div></div></div>    
</body>
</html>