<html>
<head>
<title>Monitoring of an Underwater Drone</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">水下无人驾驶飞机的监控</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/monitoring-of-an-underwater-drone-3c5c8a6d1a21?source=collection_archive---------46-----------------------#2021-05-04">https://towardsdatascience.com/monitoring-of-an-underwater-drone-3c5c8a6d1a21?source=collection_archive---------46-----------------------#2021-05-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="2c92" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用Kafka和whylogs监控流数据</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/d810573053703a2dd30331a911fab37c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xtmkmF1y__wlKbMTf7bbaw.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">克里斯·利维拉尼在<a class="ae kv" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="189e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">数据在做出明智决策中的重要性现在已被几乎所有应用普遍认同。这也促进了对工具的需求，使我们能够以明智和有效的方式利用这些数据。</p><p id="4a41" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，我想分享一种方法，通过记录流数据的统计配置文件来设置监控仪表板，从而利用流数据。为此，我将使用水下遥控潜水器(<strong class="ky ir"> ROV </strong>)作为用例。更具体地说，我们将监测来自最新的OpenROV(现在的<a class="ae kv" href="https://www.sofarocean.com/" rel="noopener ugc nofollow" target="_blank"> Sofar </a>)的<a class="ae kv" href="https://openrov.dozuki.com/c/OpenROV_v2.8_%28Kit_Assembly%29" rel="noopener ugc nofollow" target="_blank"> OpenROV v2.8 </a>的故障，这是一种低成本的远程机器人水下无人机。为了增强我们的故障检测能力，我们将使用一个回归模型，通过<a class="ae kv" href="https://scikit-learn.org" rel="noopener ugc nofollow" target="_blank"> SKLearn </a>平台进行训练，对我们的车辆行为进行建模。这样，我们的监控仪表板将服务于两个目的:监控回归模型的性能和质量问题，以及(主要)监控车辆本身的健康状况。由于故意破坏ROV会很麻烦，我们将在我们的数据中手动注入一些传感器故障，并希望能够通过使用我们的仪表板来检测这些故障。</p><p id="3eca" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">作为选择的数据记录平台，我们将使用<a class="ae kv" href="https://github.com/whylabs/whylogs" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> whylogs </strong> </a>，这是一个来自<a class="ae kv" href="https://whylabs.ai/" rel="noopener ugc nofollow" target="_blank"> WhyLabs </a>的开源库，旨在监控来自ML/AI应用程序的数据。Whylogs为记录的记录计算近似的统计数据，这意味着它是具有大量数据的管道的合适选择。尽管这个例子使用了最少量的信息，但是知道所选择的工具考虑到了未来可能的扩展还是很好的。</p><p id="70fd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于我们要处理实时数据的连续流，我们需要选择一个合适的事件流平台。从这个意义上说，在这个项目中使用Kafka似乎是一个自然的选择，也是一个熟悉这个工具的好机会。这样，我们可以通过使用发布/订阅模式，将遥测信息的发送从模型预测和日志记录过程中分离出来。</p><p id="54e0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可以在这个项目的<a class="ae kv" href="https://github.com/whylabs/whylogs/blob/mainline/examples/rov_whylogs/ROV-whylogs.ipynb" rel="noopener ugc nofollow" target="_blank"> jupyter笔记本</a>中了解这里讨论的一切。在<a class="ae kv" href="https://github.com/whylabs/whylogs/tree/mainline/examples/rov_whylogs" rel="noopener ugc nofollow" target="_blank">项目的资源库</a>中，您还会发现贯穿本文的各个Python脚本和所需文件。</p><h1 id="3e4a" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">目录</h1><ol class=""><li id="ed06" class="mk ml iq ky b kz mm lc mn lf mo lj mp ln mq lr mr ms mt mu bi translated"><a class="ae kv" href="#3f55" rel="noopener ugc nofollow"> <em class="mv">概述</em> </a></li><li id="60f3" class="mk ml iq ky b kz mw lc mx lf my lj mz ln na lr mr ms mt mu bi translated"><a class="ae kv" href="#9212" rel="noopener ugc nofollow"> <em class="mv">我们以</em> </a>结束</li><li id="d77f" class="mk ml iq ky b kz mw lc mx lf my lj mz ln na lr mr ms mt mu bi translated"><a class="ae kv" href="#2447" rel="noopener ugc nofollow"> <em class="mv">故障注入</em> </a></li><li id="44a3" class="mk ml iq ky b kz mw lc mx lf my lj mz ln na lr mr ms mt mu bi translated"><a class="ae kv" href="#090f" rel="noopener ugc nofollow"> <em class="mv">开发应用程序</em></a><br/><em class="mv">∘</em><a class="ae kv" href="#2317" rel="noopener ugc nofollow"><em class="mv">设置Kafka</em></a><em class="mv"><br/>∘</em><a class="ae kv" href="#2f79" rel="noopener ugc nofollow"><em class="mv">创建Kafka客户端</em></a><em class="mv"><br/>∘</em><a class="ae kv" href="#6418" rel="noopener ugc nofollow"><em class="mv">遥测生产者</em></a><em class="mv"><br/>∘</em><a class="ae kv" href="#137f" rel="noopener ugc nofollow"><em class="mv">预测生产者</em> </a></li><li id="b2ec" class="mk ml iq ky b kz mw lc mx lf my lj mz ln na lr mr ms mt mu bi translated"><a class="ae kv" href="#d76c" rel="noopener ugc nofollow"> <em class="mv">监控仪表盘</em></a><br/><em class="mv">∘</em><a class="ae kv" href="#5823" rel="noopener ugc nofollow"><em class="mv">会话0 —恒定增益故障</em></a><br/><em class="mv">∘</em><a class="ae kv" href="#4fa7" rel="noopener ugc nofollow"><em class="mv">会话1 —卡在(零)</em></a><br/><em class="mv">∘</em><a class="ae kv" href="#e17c" rel="noopener ugc nofollow"><em class="mv">会话2 —卡在(最大值)</em> </a></li><li id="2325" class="mk ml iq ky b kz mw lc mx lf my lj mz ln na lr mr ms mt mu bi translated"><a class="ae kv" href="#7c4d" rel="noopener ugc nofollow"> <em class="mv">结论</em> </a></li></ol><h1 id="3f55" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">概观</h1><p id="d2d3" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">让我们仔细看看我们的实验。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ne"><img src="../Images/f86b1cb970a7c3b6c23214505c9dfe9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QILm2ndRnHFmaAj2HKJtOw.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="4aa5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">ROV以在线方式将其遥测信息发送到遥测主题中。这些信息只是JSON对象的集合，其中每个对象代表不同特征的一个采样点，例如车辆的角位置、电流、电压等。考虑到在这种情况下，信息已经收集完毕，我们将简单地通过Python脚本发送JSON内容，模拟ROV的实时操作。鉴于我们的目标是检查我们是否能够监控和验证一些常见传感器故障的存在，我们需要在将数据发送到遥测主题之前，在数据集中手动注入一些故障。传感器故障将在下一节详细解释。</p><p id="c535" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下一个组件是预测生成器，它使用遥测主题，以便通过训练好的回归模型生成预测，并将结果传输到单独的预测主题中。在这个用例中，回归模型使用遥测信息来预测一个特定特征的下一个时间步长— <strong class="ky ir"> GYROZ </strong>，这是ROV在<em class="mv">偏航</em>方向的角速度(潜水器转弯的速度)。回归模型是一个线性最小二乘回归模型，具有<em class="mv"> L2 </em>正则化和多项式基函数，使用<a class="ae kv" href="https://scikit-learn.org/stable/" rel="noopener ugc nofollow" target="_blank"> SKLearn </a>库在大约24小时的ROV操作中进行训练。</p><p id="ed35" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来的两个组件将持续监听遥测和预测主题，以建立我们数据的统计资料，这些资料将用于记录会话的后续人工检查阶段，以便有望检测到ROV操作期间可能出现的异常。在这种情况下，如果采样点距离上一个采样点超过5分钟，则认为新的操作会话已经开始，对于每个会话，我们将数据聚合为1分钟一批的数据。由于我们的采样频率为<strong class="ky ir"> 5 Hz </strong>，因此每批大约有300个采样点。</p><p id="5251" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，我们需要一种简单的方法来可视化统计结果。我决定将最相关的绘图类型集中在一个iPython小部件中。这样，我们只需使用jupyter笔记本就可以检查whylogs摘要的当前状态。</p><h1 id="9212" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">我们最终会得到什么</h1><p id="cfae" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">不要在整篇文章中建立结论，让我们从展示我们将如何监控我们的ROV操作和模型预测开始。一旦我们的所有流程都在发送和记录来自ROV操作的信息，最后一个组件就是监控仪表板本身，我们希望在这里集中所有必要的信息，以评估潜水器的行为。</p><p id="9e62" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">考虑到最终目标是检测不同种类的故障，我实现了一个带有可定制参数的监控仪表板，因此我们可以从whylogs中选择正确的图表来检测不同的情况。在这个仪表板中，我们基本上可以选择要选择的参数:</p><ul class=""><li id="89a5" class="mk ml iq ky b kz la lc ld lf nf lj ng ln nh lr ni ms mt mu bi translated">要检查的单个操作会话。</li><li id="c6d8" class="mk ml iq ky b kz mw lc mx lf my lj mz ln na lr ni ms mt mu bi translated">我们希望检查的遥测信息，如速度、位置、电机输入、CPU使用率等。</li><li id="3294" class="mk ml iq ky b kz mw lc mx lf my lj mz ln na lr ni ms mt mu bi translated">线性回归模型的预测，此处用于检查我们的ROV的行为是否与我们在标称条件下的预期有很大不同。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nj"><img src="../Images/02d7f53ce6b1902ab36f2f6ad535b977.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8_XswYgfUlBDsxihTe5Ndg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="ad68" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将在文章的结尾更详细地讨论这些结果，但最终的结论是，通过调整我们仪表板的正确参数，我们肯定能够检测到由我们车辆中的感官故障引起的异常情况。因为这里的重点不是开发完美的回归模型，我们的预测本身不足以检测某些情况下的错误。然而，通过结合来自我们的预测和输入特征可视化的见解，我们可以对我们检查的每个操作会话中发生的事情有所了解。</p><h1 id="2447" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">故障注入</h1><p id="8f68" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">在这个实验中，我们将使用来自<strong class="ky ir"> 4 </strong>个不同操作会话的数据，每个会话的持续时间从<strong class="ky ir"> 4 </strong>到<strong class="ky ir"> 9 </strong>分钟不等。在每个会话中，大约在一半时间注入一个持续时间为<strong class="ky ir"> 5s </strong>的<strong class="ky ir"> GYROZ </strong>传感器故障。你可以看看JSON文件，已经注入了错误，在项目的资源库中，在<strong class="ky ir"> rov_data </strong>文件夹下。</p><p id="45c0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在下图中，注入的故障类型用橙色表示，应用于样本正弦信号。在会话0中，注入一个<strong class="ky ir">恒定增益</strong>故障，其中真实值因乘以一个恒定因子而失真，如<strong class="ky ir"> a) </strong>所示。<strong class="ky ir">固定</strong>故障在会话1和会话2中均被模拟，不同之处在于其“固定”的值——而在会话1中，GYROZ值固定在值0，如<strong class="ky ir"> b) </strong>所示，会话2的固定值为5.56，这与ROV陀螺仪传感器的最大范围有关。最后，在会话3中注入一个<strong class="ky ir">漂移</strong>传感器故障，如<strong class="ky ir"> c) </strong>所示。该故障模拟的情况是，相对于故障开始时，随着时间的增加，实际值发生失真。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nk"><img src="../Images/b0ad33a9ff5a1c80d9d6f7cbad481307.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l-bUSv1i1li5ZUDhRcRWIA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="e14a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">除了这些传感器故障，会话3中还应用了<strong class="ky ir">丢失</strong>错误，模拟水下机器人长时间停止发送信息的情况。与之前的故障不同，该故障不仅影响<strong class="ky ir"> GYROZ </strong>值，还影响车辆传输的整套特征。这是通过在会话3运行结束时从我们的数据集中手动删除一些连续的数据点来模拟的。</p><h1 id="090f" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">开发应用程序</h1><p id="3368" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">现在我们已经有了用例的概述，让我们继续实际实现应用程序。接下来的几个部分将涵盖向我们在Kafka的主题发送/读取信息所需的代码，使用我们的回归模型进行预测，并使用whylogs记录我们的统计数据。</p><h2 id="2317" class="nl lt iq bd lu nm nn dn ly no np dp mc lf nq nr me lj ns nt mg ln nu nv mi nw bi translated">建立卡夫卡</h2><p id="863f" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">在继续之前，我们需要用Kafka设置我们的流平台。我们正在处理低生产者吞吐量，所以设置一个与Docker本地卡夫卡将足以为这个项目。为此，你可以遵循<a class="ae kv" href="https://betterprogramming.pub/your-local-event-driven-environment-using-dockerised-kafka-cluster-6e84af09cd95" rel="noopener ugc nofollow" target="_blank">本教程</a>。文章中详细解释了步骤，但是对于非常短的版本，您可以简单地将<strong class="ky ir"> docker-compose.yml </strong>文件复制到您想要的文件夹中，然后运行docker-compose up。对于这一步，您自然需要安装Docker。</p><p id="28f0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦容器启动，您可以使用以下命令进入<code class="fe nx ny nz oa b">kafka-tools</code>命令行界面:</p><p id="a362" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nx ny nz oa b">docker exec -it kafka /bin/sh</code></p><p id="1e67" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">并检查可用的主题，只是为了确保它的工作:</p><p id="bc31" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nx ny nz oa b">kafka-topics --list --bootstrap-server localhost:9092</code></p><h2 id="2f79" class="nl lt iq bd lu nm nn dn ly no np dp mc lf nq nr me lj ns nt mg ln nu nv mi nw bi translated">创造卡夫卡式的客户</h2><p id="1fc8" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">在接下来的Python脚本中，我们将不得不创建大量的Kafka消费者和生产者。让我们定义两个简单的函数来创建客户端，这样我们可以在将来重用它们:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="480e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这两种情况下，客户端都被告知应该联系的地址，以便引导初始群集元数据。此外，由于我们正在生成/消费JSON格式的值，我们需要用<code class="fe nx ny nz oa b">vaue_serializer</code> / <code class="fe nx ny nz oa b">value_deserializer</code>参数为它指定正确的处理方式。</p><p id="21aa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这个项目中，消费者被设置为总是从主题的开头开始，以确保每次运行都将记录整个内容。为此，在开始之前，我们首先必须手动将分区分配给我们想要的主题。</p><p id="192d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">关于whylogs与Kafka集成的更多信息，你可以参考这个<a class="ae kv" href="https://github.com/whylabs/whylogs-examples/blob/mainline/python/Kafka.ipynb" rel="noopener ugc nofollow" target="_blank">教程笔记本</a>和WhyLabs 上的这个<a class="ae kv" href="https://whylabs.ai/blog/posts/integrating-whylogs-into-your-kafka-ml-pipeline" rel="noopener ugc nofollow" target="_blank">博客帖子。</a></p><h2 id="6418" class="nl lt iq bd lu nm nn dn ly no np dp mc lf nq nr me lj ns nt mg ln nu nv mi nw bi translated">遥测生产者</h2><p id="1a25" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">现在我们已经运行了Kafka，我们可以开始将ROV数据发送到我们的遥测主题。首先，我们需要创建一个Kafka Producer客户端，它将记录发布到我们的集群，并读取<strong class="ky ir"> rov_data </strong>文件夹中的JSON编码文件，以创建一个字典列表:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="173e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如我们所看到的，我们的采样点由一系列特征组成:</p><ul class=""><li id="65f5" class="mk ml iq ky b kz la lc ld lf nf lj ng ln nh lr ni ms mt mu bi translated"><em class="mv"> mtarg1，mtarg2，mtarg3 </em>:向3个螺旋桨中的每一个发送输入指令。</li><li id="fe34" class="mk ml iq ky b kz mw lc mx lf my lj mz ln na lr ni ms mt mu bi translated"><em class="mv">侧倾、俯仰、偏航</em>:车辆绕<strong class="ky ir"> X、Y、Z </strong>轴的角度位置。</li><li id="7a6e" class="mk ml iq ky b kz mw lc mx lf my lj mz ln na lr ni ms mt mu bi translated"><em class="mv"> LACCX，LACCY，LACCZ: </em>车辆绕<strong class="ky ir"> X，Y，Z </strong>轴的角加速度。</li><li id="5d65" class="mk ml iq ky b kz mw lc mx lf my lj mz ln na lr ni ms mt mu bi translated"><em class="mv"> GYROX，GYROY，GYROZ: </em>车辆绕<strong class="ky ir"> X，Y，Z </strong>轴的角速度。</li><li id="35c5" class="mk ml iq ky b kz mw lc mx lf my lj mz ln na lr ni ms mt mu bi translated"><em class="mv"> SC1I，SC2I，SC3I: </em>每个螺旋桨的电流读数。</li><li id="88be" class="mk ml iq ky b kz mw lc mx lf my lj mz ln na lr ni ms mt mu bi translated"><em class="mv"> BT1I，BT2I: </em>电动<em class="mv"> </em>每个电池组的电流读数。</li><li id="0afb" class="mk ml iq ky b kz mw lc mx lf my lj mz ln na lr ni ms mt mu bi translated"><em class="mv"> vout、iout和CPU usage:</em>ROV的BeagleBone微型计算机的电压、电流和CPU使用率。</li></ul><p id="cccc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们现在可以在我们的主题中发布我们的数据点:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="e879" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您愿意，在发送信息之前，最好通过在<code class="fe nx ny nz oa b">kafka-tools</code>输入以下命令来创建带有适当分区/复制的Kafka主题:</p><pre class="kg kh ki kj gt od oa oe of aw og bi"><span id="14b6" class="nl lt iq oa b gy oh oi l oj ok">kafka-topics --create --bootstrap-server localhost:9092 --replication-factor 1 --partitions 1 --topic telemetry-rov</span></pre><p id="b153" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是您不必这样做，因为如果主题不存在，它会自动创建一个主题。</p><p id="5e05" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这个例子中，维护记录的顺序非常重要，所以我们调用了一个<code class="fe nx ny nz oa b">producer.flush()</code>来确保只有在前一个请求已经被提交时才发出新的请求。</p><h2 id="137f" class="nl lt iq bd lu nm nn dn ly no np dp mc lf nq nr me lj ns nt mg ln nu nv mi nw bi translated">预测生产者</h2><p id="5878" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">有了遥测数据，我们就能够开始用回归模型进行预测。鉴于我们正在对<em class="mv"> GYROZ </em>进行一步预测，我们只需要等待一个时间步就可以得到我们的地面真相。通过计算上一个时间步的预测值和当前实际值之间的差值，我们定义了所谓的<em class="mv">残差</em>。这个想法是，水下机器人的潜在异常会产生更高的残差，因为我们的预测会比通常的实际值更远。</p><p id="f7e1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">和前面一样，我们创建了<strong class="ky ir">消费者</strong>客户端(从遥测主题读取)和<strong class="ky ir">生产者客户端</strong>(发布到我们的预测主题)。我们还必须加载我们的<em class="mv"> SKLearn </em>模型，用<em class="mv"> joblib: </em>持久化</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="d189" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们的<em class="mv"> main </em>函数中，脚本将持续从主题中获取数据，并计算每个时间步长读取的残差。如果10秒钟过去了还没有收到新的记录，我们会输出一个警告来通知用户。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="8801" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦我们有了当前和先前时间步长的数据，就可以计算残差:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="b5dd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了进行预测，我们还需要加载在模型训练过程中安装的<strong class="ky ir">最小-最大</strong>定标器(<code class="fe nx ny nz oa b">BL_x.pickle</code>和<code class="fe nx ny nz oa b">BL_y.pickle</code>)，这样我们就可以对预测和逆变换的特征进行变换，以输出未缩放的残差。</p><p id="2759" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了保持遥测和预测主题之间的一致性，我们希望存储每个时间戳的残差，即使计算它是不可能的。因此，对于第一个采样点，或者当两个采样点在时间上相距太远时，残差被记录为一个<code class="fe nx ny nz oa b">nan</code>值。</p><h2 id="bc6f" class="nl lt iq bd lu nm nn dn ly no np dp mc lf nq nr me lj ns nt mg ln nu nv mi nw bi translated">遥测记录器</h2><p id="c7df" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">一旦适当地设置了两个Kafka生成器，我们就可以开始用whylogs记录我们的会话配置文件了。记录从遥测主题轮询，并分成单独的会话。如果下一个采样点与上一个采样点相隔超过5分钟，则当前会话将被结束并记录，然后再开始下一个会话。当超过10秒钟没有新信息时，我们也认为当前会话已经结束，并记录结果。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ob oc l"/></div></figure><h2 id="5d4a" class="nl lt iq bd lu nm nn dn ly no np dp mc lf nq nr me lj ns nt mg ln nu nv mi nw bi translated">预测记录器</h2><p id="b6e8" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">我们的预测题目也是这样。这里的不同之处在于，我们不仅要记录剩余要素，还要进行一些转换，以便创建和记录附加要素。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="83ce" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">即使对于车辆的标称条件，我们也可能在残值中有峰值，导致高比率的误报。为了减少这种情况，我们根据不同的时间框架计算残差的移动平均值。在本例中，除了未改变的残差，我们还将记录最后<strong class="ky ir"> 5 </strong>、<strong class="ky ir"> 10 </strong>和<strong class="ky ir"> 15 </strong>时间步长(<strong class="ky ir"> 1 </strong>、<strong class="ky ir"> 2 </strong>和<strong class="ky ir"> 3 </strong>秒)的移动平均值:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="4243" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果，对于给定的滑动窗口，我们有<code class="fe nx ny nz oa b">nan</code>值，或者我们没有足够的记录来计算移动平均值，那么对于给定的时间戳，<code class="fe nx ny nz oa b">nan</code>被记录。</p><h2 id="2a6d" class="nl lt iq bd lu nm nn dn ly no np dp mc lf nq nr me lj ns nt mg ln nu nv mi nw bi translated">会话记录器</h2><p id="951a" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">每当记录器结束一个会话时，就会调用<code class="fe nx ny nz oa b">log_session()</code>函数，该函数负责初始化一个日志记录会话，并记录给定会话的每个记录。</p><p id="3dc9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为此，让我们将数据组织成一个<strong class="ky ir"> Pandas数据帧</strong>，将我们的时间戳列转换成<strong class="ky ir"> datetime </strong>对象，然后使用<code class="fe nx ny nz oa b">df.groupby</code>将数据帧分成一批，每批1分钟。通过这种方式，每个操作阶段都将记录水下机器人每分钟活动的统计数据。<code class="fe nx ny nz oa b">key</code>和<code class="fe nx ny nz oa b">freq</code>参数分别告诉我们分组的列和分组的频率。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="cc9f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">将数据适当地分成批后，我们现在可以为每批数据调用<code class="fe nx ny nz oa b">session.logger()</code>，传递<code class="fe nx ny nz oa b">dataset_timestamp</code>来标记每个窗口的开始，并继续记录每批数据。</p><h1 id="d76c" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">监控仪表板</h1><p id="17f3" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">在这个阶段，我们让我们的消费者监听发送的任何新记录，并将它们记录到我们的whylogs输出文件夹中，根据配置文件<em class="mv"> .whylogs.yaml </em>，这个文件夹就是<strong class="ky ir"> whylogs-output </strong>文件夹。剩下要做的是使用生成的统计数据来检查操作会话，寻找注入故障的迹象。</p><p id="0ea0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Whylogs为我们提供了许多探索日志统计属性的方法。在这个例子中，我将把自己限制在内置的绘图上，这为我们提供了一种直观检查特性的方法，比如特性分布、缺失值和数据类型。</p><p id="2515" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">尽管要监控的主要遥测特征是<strong class="ky ir"> GYROZ，</strong>但有一种简单的方法来检查所有其余特征的曲线将是有用的。至于剩余特征，我们可能想要检查不同移动平均线的图。考虑到这些选项中的任何一个，我们都有3或4种可能感兴趣的图，将所有这些选项集中到一个交互式监控仪表板中会很有趣，用户可以在其中选择他感兴趣的特定图。在这个项目中，这是以一个<strong class="ky ir"> iPython小部件的形式完成的。</strong></p><p id="63dd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，我将只展示小部件的输出，但是您可以在附带的<a class="ae kv" href="https://github.com/whylabs/whylogs/blob/mainline/examples/rov_whylogs/ROV-whylogs.ipynb" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> jupyter笔记本</strong> </a>中查看完整的代码和详细的解释。在项目的存储库中，您会发现预先记录的信息已经准备好了，因此您可以直接跳到仪表板部分。只是一定要安装<strong class="ky ir"> ipywidgets: </strong></p><p id="91ed" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nx ny nz oa b">python -m pip install ipywidgets</code></p><p id="e9d1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">并启用小部件扩展:</p><p id="1f50" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nx ny nz oa b">jupyter nbextension enable --py widgetsnbextension</code></p><h2 id="5823" class="nl lt iq bd lu nm nn dn ly no np dp mc lf nq nr me lj ns nt mg ln nu nv mi nw bi translated">会话0 —恒定增益故障</h2><p id="0553" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">现在，让我们看一些输出示例。通过选择第一个会话，我们将看到ROV操作的日期和时间，以及遥测和残差图的不同选择:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ol"><img src="../Images/62ee04f85f1dcd2e6d9529cc1ee22a84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*kvL9twIvCi4hJLbb"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="39d3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该会话有一个<strong class="ky ir">恒定增益</strong>传感器故障。从上图来看，单独评估<strong class="ky ir"> GYROZ </strong>分布是困难的，因为不同的驾驶模式会导致不同的分布，这是正常的。不变的残值也不是很清楚。但是通过应用3s的移动平均线，我们肯定开始看到一些异常行为的迹象。在这种情况下，仅监控车辆的传感信息不足以检测故障。</p><h2 id="4fa7" class="nl lt iq bd lu nm nn dn ly no np dp mc lf nq nr me lj ns nt mg ln nu nv mi nw bi translated">会话1 —停留在(零)</h2><p id="ad08" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">让我们继续我们的第二个例子，<strong class="ky ir">会话1: </strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ol"><img src="../Images/5ecb56947c38c75ebcf78d5208b0e323.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-jlCHqvpVddGO3nd"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="a1c6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在此阶段，注入了一个<strong class="ky ir">固定0 </strong>故障。不幸的是，在这种情况下，遥测和残差分布都没有多大帮助。回归模型不够敏感，不足以捕捉故障。然而，<strong class="ky ir">数据类型</strong>图产生了一个有趣的结果。该特性的值通常是一个浮点数，但是whylogs将一系列恰好为0的值推断为一个整数序列，使其与众不同。</p><h2 id="e17c" class="nl lt iq bd lu nm nn dn ly no np dp mc lf nq nr me lj ns nt mg ln nu nv mi nw bi translated">会话2 —固定不变(最大)</h2><p id="2a38" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">第三个例子也是固定值，但固定在传感器的最大范围:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nj"><img src="../Images/2965d053164e721ab6f10cb540669fb2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*F0byeA9kbed8-JMZ"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="6872" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个很容易发现，因为最大值确实高于通常的分布。遥测和残差分布图都认为在<strong class="ky ir"> 21:13 </strong>附近有异常。</p><h2 id="74b8" class="nl lt iq bd lu nm nn dn ly no np dp mc lf nq nr me lj ns nt mg ln nu nv mi nw bi translated">第3部分—漂移和损失</h2><p id="430b" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">为了避免重复，我不会显示漂移传感器故障的分布图，因为这种情况下产生的图与<strong class="ky ir">会话0 </strong>非常相似。然而，应用于残差的<strong class="ky ir">缺失值</strong>图告诉我们一些关于注入损耗误差的信息:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi om"><img src="../Images/0e22b87c4145fb00ea36a5ea382cfec2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*cXyWANI_Jn_7vm0I"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="3e89" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">每当我们没有有效的先前时间步长时，残差就用<code class="fe nx ny nz oa b">nan</code>值记录。因此，预计第一个会话的采样点会有缺失值。但是，当它们出现在运行的中间时，这是两个采样点之间经过了一段延长的时间(<strong class="ky ir"> &gt; 0.5s </strong>)的标志，表明出现了损失错误。尽管我们没有直接监控丢失错误，但我们可以在运行结束时看到它的存在，大约在<strong class="ky ir"> 09:14 </strong>。</p><h1 id="7c4d" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">结论</h1><p id="69eb" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">在本文中，我想通过在一个特定的用例中应用它们来探索数据流和监控的可用工具:水下无人机的故障检测。尽管MLOps生态系统正在快速发展，但我觉得在生产中监控ML应用程序的解决方案仍然很少。这就是为什么像whylogs这样的开源工具是ML从业者工具集的一个非常受欢迎的补充。</p><p id="032c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这个项目中，我们的回归模型远非完美，在许多情况下，预测本身不足以捕捉我们注入的故障条件。然而，通过设置一个简单的监控仪表板，我们能够通过同时查看输入和输出图来获得更广泛的视图，此外，我们还能够从许多不同的图中选择不同的特性。对于这个项目，在仪表板中只包含来自whylogs的内置图就足够了，但是我们可以通过包含每个完整会话的可用摘要的单独选项卡来添加更多信息。</p><p id="bfd3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">至于应用程序本身，也有很大的扩展空间。在这个例子中，出于演示的目的，我们在本地使用了Kafka，但是我确信对于一个生产环境，事情会变得更加复杂。也许在未来，我们可以让整队的遥控潜水器被自动监控故障！</p><p id="06cf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">暂时就这样吧！感谢您的阅读，如果您有任何问题或建议，请随时联系我们！</p></div></div>    
</body>
</html>