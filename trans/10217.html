<html>
<head>
<title>Self-Parking Car in &lt;500 Lines of Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">&lt;500 Lines of Code</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/self-parking-car-in-500-lines-of-code-c1b2a57455af?source=collection_archive---------3-----------------------#2021-09-28">https://towardsdatascience.com/self-parking-car-in-500-lines-of-code-c1b2a57455af?source=collection_archive---------3-----------------------#2021-09-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="54a1" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/hands-on-tutorials" rel="noopener" target="_blank">动手教程</a>中的自动泊车车</h2><div class=""/><div class=""><h2 id="9e4d" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">使用遗传算法训练汽车自动泊车</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/5777198c7a3feb57f9c1def63d068e4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0SynGDT72UyykQdHeFAqWQ.jpeg"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">作者插图</p></figure><h1 id="831f" class="le lf iq bd lg lh li lj lk ll lm ln lo kf lp kg lq ki lr kj ls kl lt km lu lv bi translated">TL；速度三角形定位法(dead reckoning)</h1><p id="e0fc" class="pw-post-body-paragraph lw lx iq ly b lz ma ka mb mc md kd me mf mg mh mi mj mk ml mm mn mo mp mq mr ij bi translated">在本文中，我们将使用<a class="ae ms" href="https://en.wikipedia.org/wiki/Genetic_algorithm" rel="noopener ugc nofollow" target="_blank">遗传算法</a>来训练汽车进行自主泊车。</p><p id="e1bd" class="pw-post-body-paragraph lw lx iq ly b lz mt ka mb mc mu kd me mf mv mh mi mj mw ml mm mn mx mp mq mr ij bi translated">我们将用随机基因组创造出第一代汽车<strong class="ly ja">,其行为如下:</strong></p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi my"><img src="../Images/7cfb20c202834cfeeb80bf83567f5edb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*8U_xR9D4NX0BzqJMqT0BsQ.gif"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">第一代汽车。作者制作的动画</p></figure><p id="4513" class="pw-post-body-paragraph lw lx iq ly b lz mt ka mb mc mu kd me mf mv mh mi mj mw ml mm mn mx mp mq mr ij bi translated"><strong class="ly ja">在第40代</strong>上，汽车开始学习什么是自动泊车，并开始靠近泊车点:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi my"><img src="../Images/237f030840308cc734fb4913e3d0483e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*oP0_y0kyucPIcZp0mI0p6Q.gif"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">第40代车。作者制作的动画</p></figure><p id="40e8" class="pw-post-body-paragraph lw lx iq ly b lz mt ka mb mc mu kd me mf mv mh mi mj mw ml mm mn mx mp mq mr ij bi translated">另一个例子更具挑战性:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi my"><img src="../Images/55d0908aa264ccab265f60fb305bcfdd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*z4em7FIKsDo38ZE8WDSWeA.gif"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">第40代车。作者制作的动画</p></figure><blockquote class="mz na nb"><p id="14c2" class="lw lx nc ly b lz mt ka mb mc mu kd me nd mv mh mi ne mw ml mm nf mx mp mq mr ij bi translated">是啊，是啊，这些车在路上撞上了其他车，也不完全适合停车，但这只是自世界创造以来他们的第40代，所以请仁慈一点，给这些车一些空间让:D成长</p></blockquote><p id="b8c9" class="pw-post-body-paragraph lw lx iq ly b lz mt ka mb mc mu kd me mf mv mh mi mj mw ml mm mn mx mp mq mr ij bi translated">您可以启动🚕<a class="ae ms" href="https://trekhleb.dev/self-parking-car-evolution" rel="noopener ugc nofollow" target="_blank">自动泊车汽车进化模拟器</a>直接在浏览器中查看进化过程。模拟器为您提供了以下机会:</p><ul class=""><li id="d86c" class="ng nh iq ly b lz mt mc mu mf ni mj nj mn nk mr nl nm nn no bi translated">您可以<a class="ae ms" href="https://trekhleb.dev/self-parking-car-evolution?parking=evolution#/" rel="noopener ugc nofollow" target="_blank">从头开始训练汽车</a>并自行调整遗传参数</li><li id="821d" class="ng nh iq ly b lz np mc nq mf nr mj ns mn nt mr nl nm nn no bi translated">你可以<a class="ae ms" href="https://trekhleb.dev/self-parking-car-evolution?parking=automatic#/" rel="noopener ugc nofollow" target="_blank">看到训练过的自动泊车车在运行</a></li><li id="1c96" class="ng nh iq ly b lz np mc nq mf nr mj ns mn nt mr nl nm nn no bi translated">您也可以<a class="ae ms" href="https://trekhleb.dev/self-parking-car-evolution?parking=manual#/" rel="noopener ugc nofollow" target="_blank">尝试手动泊车</a></li></ul><p id="f335" class="pw-post-body-paragraph lw lx iq ly b lz mt ka mb mc mu kd me mf mv mh mi mj mw ml mm mn mx mp mq mr ij bi translated">这个项目的遗传算法是用TypeScript实现的。完整的遗传源代码将在本文中展示，但你也可以在<a class="ae ms" href="https://github.com/trekhleb/self-parking-car-evolution" rel="noopener ugc nofollow" target="_blank">进化模拟器资源库</a>中找到最终的代码示例。</p><blockquote class="mz na nb"><p id="c83e" class="lw lx nc ly b lz mt ka mb mc mu kd me nd mv mh mi ne mw ml mm nf mx mp mq mr ij bi translated">我们将使用遗传算法来完成进化汽车基因组的特殊任务。然而，这篇文章仅仅触及了算法的基础，并不是遗传算法主题的完整指南。</p></blockquote><p id="6e8a" class="pw-post-body-paragraph lw lx iq ly b lz mt ka mb mc mu kd me mf mv mh mi mj mw ml mm mn mx mp mq mr ij bi translated">话虽如此，让我们深入了解更多细节…</p><h1 id="2c12" class="le lf iq bd lg lh li lj lk ll lm ln lo kf lp kg lq ki lr kj ls kl lt km lu lv bi translated">这个计划</h1><p id="d836" class="pw-post-body-paragraph lw lx iq ly b lz ma ka mb mc md kd me mf mg mh mi mj mk ml mm mn mo mp mq mr ij bi translated">一步一步地，我们将把创建自动泊车汽车的高级任务分解为寻找<code class="fe nu nv nw nx b">180</code>位的最佳组合(寻找最佳汽车基因组)的简单低级优化问题。</p><p id="aa28" class="pw-post-body-paragraph lw lx iq ly b lz mt ka mb mc mu kd me mf mv mh mi mj mw ml mm mn mx mp mq mr ij bi translated">这是我们要做的:</p><ol class=""><li id="43fe" class="ng nh iq ly b lz mt mc mu mf ni mj nj mn nk mr ny nm nn no bi translated">💪🏻将<strong class="ly ja">肌肉</strong>(发动机、方向盘)给汽车，使其能够向停车点移动。</li><li id="91b3" class="ng nh iq ly b lz np mc nq mf nr mj ns mn nt mr ny nm nn no bi translated">👀给汽车装上<strong class="ly ja">眼睛</strong>(传感器)，这样它就能看到周围的障碍物。</li><li id="d688" class="ng nh iq ly b lz np mc nq mf nr mj ns mn nt mr ny nm nn no bi translated">🧠给汽车配备了大脑，它将根据汽车看到的东西(通过传感器看到的障碍物)来控制肌肉(运动)。大脑将只是一个纯粹的功能。</li><li id="6f0c" class="ng nh iq ly b lz np mc nq mf nr mj ns mn nt mr ny nm nn no bi translated">🧬 <strong class="ly ja">进化大脑</strong>根据传感器的输入做出正确的动作。这就是我们将应用遗传算法的地方。一代又一代，我们的大脑功能<code class="fe nu nv nw nx b">movements = f(sensors)</code>将学习如何将汽车驶向停车位。</li></ol><h1 id="b5c0" class="le lf iq bd lg lh li lj lk ll lm ln lo kf lp kg lq ki lr kj ls kl lt km lu lv bi translated">赋予汽车肌肉</h1><p id="8c1c" class="pw-post-body-paragraph lw lx iq ly b lz ma ka mb mc md kd me mf mg mh mi mj mk ml mm mn mo mp mq mr ij bi translated">为了能够移动，汽车需要“肌肉”。让我们给汽车两种类型的肌肉:</p><ol class=""><li id="f772" class="ng nh iq ly b lz mt mc mu mf ni mj nj mn nk mr ny nm nn no bi translated"><strong class="ly ja">发动机肌肉</strong> —允许汽车移动<em class="nc"> ↓后退</em>、<em class="nc"> ↑前进</em>或<em class="nc"> ◎立钢</em>(空挡)</li><li id="efae" class="ng nh iq ly b lz np mc nq mf nr mj ns mn nt mr ny nm nn no bi translated"><strong class="ly ja">方向盘肌肉</strong>——允许汽车在行驶中向左<em class="nc"> ←转</em>、<em class="nc"> →向右</em>或<em class="nc"> ◎直行</em></li></ol><p id="c843" class="pw-post-body-paragraph lw lx iq ly b lz mt ka mb mc mu kd me mf mv mh mi mj mw ml mm mn mx mp mq mr ij bi translated">有了这两块肌肉，汽车可以完成以下动作:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi my"><img src="../Images/aefa3ce18b97fb1efe80744cf7e82061.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*bDz73zR9j8jIRnPcPSTCzA.gif"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">汽车肌肉。作者制作的动画</p></figure><p id="f30c" class="pw-post-body-paragraph lw lx iq ly b lz mt ka mb mc mu kd me mf mv mh mi mj mw ml mm mn mx mp mq mr ij bi translated">在我们的例子中，肌肉是来自大脑的信号的接收器，每隔<code class="fe nu nv nw nx b">100ms</code>(毫秒)一次。根据大脑信号的价值，肌肉会做出不同的反应。我们将在下面讨论“大脑”部分，但现在，假设我们的大脑可能只向每块肌肉发送3种可能的信号:<code class="fe nu nv nw nx b">-1</code>、<code class="fe nu nv nw nx b">0</code>或<code class="fe nu nv nw nx b">+1</code>。</p><pre class="kp kq kr ks gt nz nx oa ob aw oc bi"><span id="09fc" class="od lf iq nx b gy oe of l og oh">type MuscleSignal = -1 | 0 | 1;</span></pre><p id="6d56" class="pw-post-body-paragraph lw lx iq ly b lz mt ka mb mc mu kd me mf mv mh mi mj mw ml mm mn mx mp mq mr ij bi translated">例如，大脑可能会向引擎肌肉发送值为<code class="fe nu nv nw nx b">+1</code>的信号，它将开始向前移动汽车。给引擎的信号<code class="fe nu nv nw nx b">-1</code>使汽车向后移动。同时，如果大脑将信号<code class="fe nu nv nw nx b">-1</code>发送给方向盘肌肉，它会将车转向左侧等。</p><p id="0a8b" class="pw-post-body-paragraph lw lx iq ly b lz mt ka mb mc mu kd me mf mv mh mi mj mw ml mm mn mx mp mq mr ij bi translated">在我们的例子中，大脑信号值是如何映射到肌肉动作的:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/f8f8d5cbc2718e3334761a230dc896fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wzSXMRTvg62msCMkbQq5BA.png"/></div></div></figure><blockquote class="mz na nb"><p id="41ea" class="lw lx nc ly b lz mt ka mb mc mu kd me nd mv mh mi ne mw ml mm nf mx mp mq mr ij bi translated">你可以<a class="ae ms" href="https://trekhleb.dev/self-parking-car-evolution?parking=manual#/" rel="noopener ugc nofollow" target="_blank">使用进化模拟器</a>尝试手动停车，看看汽车肌肉是如何工作的。每当你按下<code class="fe nu nv nw nx b">WASD</code>键盘上的一个键(或使用触摸屏操纵杆)，你就向引擎和方向盘肌肉发送这些<code class="fe nu nv nw nx b">-1</code>、<code class="fe nu nv nw nx b">0</code>或<code class="fe nu nv nw nx b">+1</code>信号。</p></blockquote><h1 id="b782" class="le lf iq bd lg lh li lj lk ll lm ln lo kf lp kg lq ki lr kj ls kl lt km lu lv bi translated">给汽车一双眼睛</h1><p id="d325" class="pw-post-body-paragraph lw lx iq ly b lz ma ka mb mc md kd me mf mg mh mi mj mk ml mm mn mo mp mq mr ij bi translated">在我们的汽车学会如何使用肌肉自动停车之前，它需要能够“看到”周围的环境。让我们以距离传感器的形式给它一双<code class="fe nu nv nw nx b">8</code>眼睛:</p><ul class=""><li id="479d" class="ng nh iq ly b lz mt mc mu mf ni mj nj mn nk mr nl nm nn no bi translated">每个传感器可以在<code class="fe nu nv nw nx b">0-4m</code>(米)的距离范围内探测障碍物。</li><li id="3f0f" class="ng nh iq ly b lz np mc nq mf nr mj ns mn nt mr nl nm nn no bi translated">每个传感器每隔<code class="fe nu nv nw nx b">100ms</code>都会向汽车的“大脑”报告它“看到”的障碍物的最新信息。</li><li id="22f1" class="ng nh iq ly b lz np mc nq mf nr mj ns mn nt mr nl nm nn no bi translated">只要传感器没有发现任何障碍物，它就会报告<code class="fe nu nv nw nx b">0</code>的值。相反，如果传感器的值很小但不为零(即<code class="fe nu nv nw nx b">0.01m</code>)，则意味着障碍物很近。</li></ul><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/5efb0b5d578055fe9c114f6832436d27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GYsW88SJA0EXlH6HhIRKmQ.jpeg"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">车眼。作者插图</p></figure><blockquote class="mz na nb"><p id="5ff4" class="lw lx nc ly b lz mt ka mb mc mu kd me nd mv mh mi ne mw ml mm nf mx mp mq mr ij bi translated">你可以使用进化模拟器，看看每个传感器的颜色是如何根据障碍物的远近而变化的。</p></blockquote><pre class="kp kq kr ks gt nz nx oa ob aw oc bi"><span id="7ae1" class="od lf iq nx b gy oe of l og oh">type Sensors = number[];</span></pre><h1 id="6a03" class="le lf iq bd lg lh li lj lk ll lm ln lo kf lp kg lq ki lr kj ls kl lt km lu lv bi translated">给汽车赋予大脑</h1><p id="2c8a" class="pw-post-body-paragraph lw lx iq ly b lz ma ka mb mc md kd me mf mg mh mi mj mk ml mm mn mo mp mq mr ij bi translated">此时此刻，我们的汽车可以“看见”和“移动”，但没有“协调器”，将“眼睛”的信号转换为“肌肉”的适当运动。我们需要给汽车一个“大脑”。</p><h1 id="4f39" class="le lf iq bd lg lh li lj lk ll lm ln lo kf lp kg lq ki lr kj ls kl lt km lu lv bi translated">大脑输入</h1><p id="ef4f" class="pw-post-body-paragraph lw lx iq ly b lz ma ka mb mc md kd me mf mg mh mi mj mk ml mm mn mo mp mq mr ij bi translated">作为来自传感器的输入，大脑每隔<code class="fe nu nv nw nx b">100ms</code>就会得到<code class="fe nu nv nw nx b">8</code>个浮点数，每个都在<code class="fe nu nv nw nx b">[0...4]</code>的范围内。例如，输入可能如下所示:</p><pre class="kp kq kr ks gt nz nx oa ob aw oc bi"><span id="b2d0" class="od lf iq nx b gy oe of l og oh">const sensors: Sensors = [s0, s1, s2, s3, s4, s5, s6, s7];<br/>// i.e. 🧠 ← [0, 0.5, 4, 0.002, 0, 3.76, 0, 1.245]</span></pre><h1 id="34ae" class="le lf iq bd lg lh li lj lk ll lm ln lo kf lp kg lq ki lr kj ls kl lt km lu lv bi translated">大脑输出</h1><p id="409d" class="pw-post-body-paragraph lw lx iq ly b lz ma ka mb mc md kd me mf mg mh mi mj mk ml mm mn mo mp mq mr ij bi translated">每一个<code class="fe nu nv nw nx b">100ms</code>大脑都应该产生两个整数作为输出:</p><ol class=""><li id="bc86" class="ng nh iq ly b lz mt mc mu mf ni mj nj mn nk mr ny nm nn no bi translated">一个数字作为发动机的信号:<code class="fe nu nv nw nx b">engineSignal</code></li><li id="76a2" class="ng nh iq ly b lz np mc nq mf nr mj ns mn nt mr ny nm nn no bi translated">一个数字作为方向盘的信号:<code class="fe nu nv nw nx b">wheelSignal</code></li></ol><p id="ac91" class="pw-post-body-paragraph lw lx iq ly b lz mt ka mb mc mu kd me mf mv mh mi mj mw ml mm mn mx mp mq mr ij bi translated">每个数字都应该是类型<code class="fe nu nv nw nx b">MuscleSignal</code>，并且可以取三个值之一:<code class="fe nu nv nw nx b">-1</code>、<code class="fe nu nv nw nx b">0</code>或<code class="fe nu nv nw nx b">+1</code>。</p><h1 id="8504" class="le lf iq bd lg lh li lj lk ll lm ln lo kf lp kg lq ki lr kj ls kl lt km lu lv bi translated">大脑公式/功能</h1><p id="5305" class="pw-post-body-paragraph lw lx iq ly b lz ma ka mb mc md kd me mf mg mh mi mj mk ml mm mn mo mp mq mr ij bi translated">记住上面提到的大脑的输入和输出，我们可以说大脑只是一种功能:</p><pre class="kp kq kr ks gt nz nx oa ob aw oc bi"><span id="d0b7" class="od lf iq nx b gy oe of l og oh">const { engineSignal, wheelSignal } = brainToMuscleSignal(<br/>  brainFunction(sensors)<br/>);<br/>// i.e. { engineSignal: 0, wheelSignal: -1 } ← 🧠 ← [0, 0.5, 4, 0.002, 0, 3.76, 0, 1.245]</span></pre><p id="9db7" class="pw-post-body-paragraph lw lx iq ly b lz mt ka mb mc mu kd me mf mv mh mi mj mw ml mm mn mx mp mq mr ij bi translated">其中<code class="fe nu nv nw nx b">brainToMuscleSignal()</code>是一个将原始脑信号(任何浮点数)转换为肌肉信号(转换为<code class="fe nu nv nw nx b">-1</code>、<code class="fe nu nv nw nx b">0</code>或<code class="fe nu nv nw nx b">+1</code>数)以便肌肉能够理解的函数。我们将在下面实现这个转换器函数。</p><p id="b3f0" class="pw-post-body-paragraph lw lx iq ly b lz mt ka mb mc mu kd me mf mv mh mi mj mw ml mm mn mx mp mq mr ij bi translated">现在的主要问题是<code class="fe nu nv nw nx b">brainFunction()</code>是一个什么样的函数。</p><p id="ec8f" class="pw-post-body-paragraph lw lx iq ly b lz mt ka mb mc mu kd me mf mv mh mi mj mw ml mm mn mx mp mq mr ij bi translated">为了让汽车更智能，让它的运动更复杂，我们可以用一个<a class="ae ms" href="https://en.wikipedia.org/wiki/Multilayer_perceptron" rel="noopener ugc nofollow" target="_blank">多层感知机</a>。这个名字有点吓人，但这是一个简单的神经网络，有一个基本的架构(把它想象成一个有许多参数/系数的大公式)。</p><blockquote class="mz na nb"><p id="d33c" class="lw lx nc ly b lz mt ka mb mc mu kd me nd mv mh mi ne mw ml mm nf mx mp mq mr ij bi translated">在我的<a class="ae ms" href="https://github.com/trekhleb/homemade-machine-learning#-multilayer-perceptron-mlp" rel="noopener ugc nofollow" target="_blank">自制机器学习</a>、<a class="ae ms" href="https://github.com/trekhleb/machine-learning-experiments#multilayer-perceptron-mlp-or-simple-neural-network-nn" rel="noopener ugc nofollow" target="_blank">机器学习实验</a>和<a class="ae ms" href="https://github.com/trekhleb/nano-neuron" rel="noopener ugc nofollow" target="_blank">纳米神经元</a>项目中，我已经详细介绍了多层感知器。你甚至可以挑战那个简单的网络<a class="ae ms" href="https://trekhleb.dev/machine-learning-experiments/#/experiments/DigitsRecognitionMLP" rel="noopener ugc nofollow" target="_blank">来识别你写的数字</a>。</p></blockquote><p id="6dd3" class="pw-post-body-paragraph lw lx iq ly b lz mt ka mb mc mu kd me mf mv mh mi mj mw ml mm mn mx mp mq mr ij bi translated">然而，为了避免引入全新的神经网络概念，我们将采用一种更简单的方法，我们将使用两个具有多个变量的线性多项式(更准确地说，每个多项式将正好有<code class="fe nu nv nw nx b">8</code>个变量，因为我们有<code class="fe nu nv nw nx b">8</code>个传感器)，如下所示:</p><pre class="kp kq kr ks gt nz nx oa ob aw oc bi"><span id="a16a" class="od lf iq nx b gy oe of l og oh">engineSignal = brainToMuscleSignal(<br/>  (e0 * s0) + (e1 * s1) + ... + (e7 * s7) + e8 // &lt;- brainFunction<br/>)</span><span id="efd0" class="od lf iq nx b gy oi of l og oh">wheelSignal = brainToMuscleSignal(<br/>  (w0 * s0) + (w1 * s1) + ... + (w7 * s7) + w8 // &lt;- brainFunction<br/>)</span></pre><p id="9826" class="pw-post-body-paragraph lw lx iq ly b lz mt ka mb mc mu kd me mf mv mh mi mj mw ml mm mn mx mp mq mr ij bi translated">其中:</p><ul class=""><li id="f94c" class="ng nh iq ly b lz mt mc mu mf ni mj nj mn nk mr nl nm nn no bi translated"><code class="fe nu nv nw nx b">[s0, s1, ..., s7]</code>-<code class="fe nu nv nw nx b">8</code>变量，即<code class="fe nu nv nw nx b">8</code>传感器值。这些是动态的。</li><li id="1713" class="ng nh iq ly b lz np mc nq mf nr mj ns mn nt mr nl nm nn no bi translated"><code class="fe nu nv nw nx b">[e0, e1, ..., e8]</code> -发动机多项式的<code class="fe nu nv nw nx b">9</code>系数。这些是汽车需要学习的，它们是静态的。</li><li id="5877" class="ng nh iq ly b lz np mc nq mf nr mj ns mn nt mr nl nm nn no bi translated"><code class="fe nu nv nw nx b">[w0, w1, ..., w8]</code> -方向盘多项式的<code class="fe nu nv nw nx b">9</code>系数。这些是汽车需要学习的，它们是静态的</li></ul><p id="1b04" class="pw-post-body-paragraph lw lx iq ly b lz mt ka mb mc mu kd me mf mv mh mi mj mw ml mm mn mx mp mq mr ij bi translated">为大脑使用更简单的功能的代价是，汽车将无法学习一些复杂的动作，也无法很好地概括和适应未知的环境。但是对于我们这个特殊的停车场来说，为了展示遗传算法的工作，这已经足够了。</p><p id="3e94" class="pw-post-body-paragraph lw lx iq ly b lz mt ka mb mc mu kd me mf mv mh mi mj mw ml mm mn mx mp mq mr ij bi translated">我们可以用下面的方式实现通用多项式函数(<a class="ae ms" href="https://trekhleb.dev/blog/2021/self-parking-car-evolution/" rel="noopener ugc nofollow" target="_blank">查看这篇文章的这个版本以获得更好的源代码格式</a>):</p><pre class="kp kq kr ks gt nz nx oa ob aw oc bi"><span id="cb1a" class="od lf iq nx b gy oe of l og oh">type Coefficients = number[];</span><span id="6441" class="od lf iq nx b gy oi of l og oh">// Calculates the value of a linear polynomial based on the coefficients and variables.<br/>const linearPolynomial = (coefficients: Coefficients, variables: number[]): number =&gt; {<br/>  if (coefficients.length !== (variables.length + 1)) {<br/>    throw new Error('Incompatible number of polynomial coefficients and variables');<br/>  }<br/>  let result = 0;<br/>  coefficients.forEach((coefficient: number, coefficientIndex: number) =&gt; {<br/>    if (coefficientIndex &lt; variables.length) {<br/>      result += coefficient * variables[coefficientIndex];<br/>    } else {<br/>      // The last coefficient needs to be added up without multiplication.<br/>      result += coefficient<br/>    }<br/>  });<br/>  return result;<br/>};</span></pre><p id="ee13" class="pw-post-body-paragraph lw lx iq ly b lz mt ka mb mc mu kd me mf mv mh mi mj mw ml mm mn mx mp mq mr ij bi translated">在这种情况下，汽车的大脑将由两个多项式组成，看起来像这样:</p><pre class="kp kq kr ks gt nz nx oa ob aw oc bi"><span id="5445" class="od lf iq nx b gy oe of l og oh">const engineSignal: MuscleSignal = brainToMuscleSignal(<br/>  linearPolynomial(engineCoefficients, sensors)<br/>);</span><span id="3b09" class="od lf iq nx b gy oi of l og oh">const wheelSignal: MuscleSignal = brainToMuscleSignal(<br/>  linearPolynomial(wheelCoefficients, sensors)<br/>);</span></pre><p id="f0ba" class="pw-post-body-paragraph lw lx iq ly b lz mt ka mb mc mu kd me mf mv mh mi mj mw ml mm mn mx mp mq mr ij bi translated"><code class="fe nu nv nw nx b">linearPolynomial()</code>函数的输出是一个浮点数。<code class="fe nu nv nw nx b">brainToMuscleSignal()</code>函数需要将大量的浮点数转换成三个特定的整数，它将分两步完成:</p><ol class=""><li id="8889" class="ng nh iq ly b lz mt mc mu mf ni mj nj mn nk mr ny nm nn no bi translated">将大范围浮动(即<code class="fe nu nv nw nx b">0.456</code>或<code class="fe nu nv nw nx b">3673.45</code>或<code class="fe nu nv nw nx b">-280</code>)转换为<code class="fe nu nv nw nx b">(0...1)</code>(即<code class="fe nu nv nw nx b">0.05</code>或<code class="fe nu nv nw nx b">0.86</code>)范围内的浮动</li><li id="60a5" class="ng nh iq ly b lz np mc nq mf nr mj ns mn nt mr ny nm nn no bi translated">将<code class="fe nu nv nw nx b">(0...1)</code>范围内的浮点值转换为<code class="fe nu nv nw nx b">-1</code>、<code class="fe nu nv nw nx b">0</code>或<code class="fe nu nv nw nx b">+1</code>三个整数值之一。比如靠近<code class="fe nu nv nw nx b">0</code>的浮动会转换成<code class="fe nu nv nw nx b">-1</code>，靠近<code class="fe nu nv nw nx b">0.5</code>的浮动会转换成<code class="fe nu nv nw nx b">0</code>，靠近<code class="fe nu nv nw nx b">1</code>的浮动会转换成<code class="fe nu nv nw nx b">1</code>。</li></ol><p id="a2dd" class="pw-post-body-paragraph lw lx iq ly b lz mt ka mb mc mu kd me mf mv mh mi mj mw ml mm mn mx mp mq mr ij bi translated">为了完成转换的第一部分，我们需要引入一个实现以下公式的<a class="ae ms" href="https://en.wikipedia.org/wiki/Sigmoid_function" rel="noopener ugc nofollow" target="_blank"> Sigmoid函数</a>:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi my"><img src="../Images/b94efd45bbc6b902f475b264d822b88c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U2StmB7jeSDG8ErKqPdlXw.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">Sigmoid公式</p></figure><p id="c0cc" class="pw-post-body-paragraph lw lx iq ly b lz mt ka mb mc mu kd me mf mv mh mi mj mw ml mm mn mx mp mq mr ij bi translated">它将宽范围的浮点数(<code class="fe nu nv nw nx b">x</code>轴)转换为有限范围的浮点数(<code class="fe nu nv nw nx b">(0...1)</code><code class="fe nu nv nw nx b">y</code>轴)。这正是我们所需要的。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/126f6cfbeb696151b42af8e35edbf347.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p1tsfhOYFRO329_DKGFeMg.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">Sigmoid函数</p></figure><p id="d8fe" class="pw-post-body-paragraph lw lx iq ly b lz mt ka mb mc mu kd me mf mv mh mi mj mw ml mm mn mx mp mq mr ij bi translated">这是转换步骤在Sigmoid图上的样子。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/65973419e3c5218f1462d8f023f48cc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HGFxAqUeP44Oa5GXY8f1Bg.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">作者插图</p></figure><p id="139a" class="pw-post-body-paragraph lw lx iq ly b lz mt ka mb mc mu kd me mf mv mh mi mj mw ml mm mn mx mp mq mr ij bi translated">上面提到的两个转换步骤的实现如下所示:</p><pre class="kp kq kr ks gt nz nx oa ob aw oc bi"><span id="ada5" class="od lf iq nx b gy oe of l og oh">// Calculates the sigmoid value for a given number.<br/>const sigmoid = (x: number): number =&gt; {<br/>  return 1 / (1 + Math.E ** -x);<br/>};</span><span id="49f6" class="od lf iq nx b gy oi of l og oh">// Converts sigmoid value (0...1) to the muscle signals (-1, 0, +1)<br/>// The margin parameter is a value between 0 and 0.5:<br/>// [0 ... (0.5 - margin) ... 0.5 ... (0.5 + margin) ... 1]<br/>const sigmoidToMuscleSignal = (sigmoidValue: number, margin: number = 0.4): MuscleSignal =&gt; {<br/>  if (sigmoidValue &lt; (0.5 - margin)) {<br/>    return -1;<br/>  }<br/>  if (sigmoidValue &gt; (0.5 + margin)) {<br/>    return 1;<br/>  }<br/>  return 0;<br/>};</span><span id="08c9" class="od lf iq nx b gy oi of l og oh">// Converts raw brain signal to the muscle signal.<br/>const brainToMuscleSignal = (rawBrainSignal: number): MuscleSignal =&gt; {<br/>  const normalizedBrainSignal = sigmoid(rawBrainSignal);<br/>  return sigmoidToMuscleSignal(normalizedBrainSignal);<br/>}</span></pre><h1 id="0c8f" class="le lf iq bd lg lh li lj lk ll lm ln lo kf lp kg lq ki lr kj ls kl lt km lu lv bi translated">汽车的基因组</h1><blockquote class="mz na nb"><p id="a58f" class="lw lx nc ly b lz mt ka mb mc mu kd me nd mv mh mi ne mw ml mm nf mx mp mq mr ij bi translated">从上面的“眼睛”、“肌肉”和“大脑”部分得出的主要结论应该是:系数<code class="fe nu nv nw nx b">[e0, e1, ..., e8]</code>和<code class="fe nu nv nw nx b">[w0, w1, ..., w8]</code>定义了汽车的行为。这些数字共同构成了独特的汽车基因组(或汽车的DNA)。</p></blockquote><h1 id="34f2" class="le lf iq bd lg lh li lj lk ll lm ln lo kf lp kg lq ki lr kj ls kl lt km lu lv bi translated">十进制形式的汽车基因组</h1><p id="4d8f" class="pw-post-body-paragraph lw lx iq ly b lz ma ka mb mc md kd me mf mg mh mi mj mk ml mm mn mo mp mq mr ij bi translated">让我们将<code class="fe nu nv nw nx b">[e0, e1, ..., e8]</code>和<code class="fe nu nv nw nx b">[w0, w1, ..., w8]</code>大脑系数连接在一起，以十进制形式构成一辆汽车的基因组:</p><pre class="kp kq kr ks gt nz nx oa ob aw oc bi"><span id="87db" class="od lf iq nx b gy oe of l og oh">// Car genome as a list of decimal numbers (coefficients).<br/>const carGenomeBase10 = [e0, e1, ..., e8, w0, w1, ..., w8];</span><span id="09e6" class="od lf iq nx b gy oi of l og oh">// i.e. carGenomeBase10 = [17.5, 0.059, -46, 25, 156, -0.085, -0.207, -0.546, 0.071, -58, 41, 0.011, 252, -3.5, -0.017, 1.532, -360, 0.157]</span></pre><h1 id="51ae" class="le lf iq bd lg lh li lj lk ll lm ln lo kf lp kg lq ki lr kj ls kl lt km lu lv bi translated">二进制形式的汽车基因组</h1><p id="6485" class="pw-post-body-paragraph lw lx iq ly b lz ma ka mb mc md kd me mf mg mh mi mj mk ml mm mn mo mp mq mr ij bi translated">让我们再深入一步(到基因的层面)，将汽车基因组的十进制数字转换成二进制格式(转换成普通的<code class="fe nu nv nw nx b">1</code> s和<code class="fe nu nv nw nx b">0</code> s)。</p><blockquote class="mz na nb"><p id="3131" class="lw lx nc ly b lz mt ka mb mc mu kd me nd mv mh mi ne mw ml mm nf mx mp mq mr ij bi translated">我已经在浮点数的二进制表示的文章<a class="ae ms" href="https://trekhleb.dev/blog/2021/binary-floating-point/" rel="noopener ugc nofollow" target="_blank">中详细描述了将浮点数转换成二进制数的过程。如果本节中的代码不清楚，您可能想查看一下。</a></p></blockquote><p id="8888" class="pw-post-body-paragraph lw lx iq ly b lz mt ka mb mc mu kd me mf mv mh mi mj mw ml mm mn mx mp mq mr ij bi translated">下面是一个如何将浮点数转换成二进制数的简单例子(如果这个例子令人困惑，请随意阅读第一个):</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oj"><img src="../Images/73d114d320b627dfc20c515a0250fc10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N8JsNK8SBpgKCfh89mbgRQ.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">浮点数的“十进制到二进制”转换示例。作者插图。</p></figure><p id="61e0" class="pw-post-body-paragraph lw lx iq ly b lz mt ka mb mc mu kd me mf mv mh mi mj mw ml mm mn mx mp mq mr ij bi translated">在我们的例子中，为了减少基因组长度，我们将把每个浮点系数转换成非标准的<code class="fe nu nv nw nx b">10 bits</code>二进制数(<code class="fe nu nv nw nx b">1</code>符号位、<code class="fe nu nv nw nx b">4</code>指数位、<code class="fe nu nv nw nx b">5</code>分数位)。</p><p id="542a" class="pw-post-body-paragraph lw lx iq ly b lz mt ka mb mc mu kd me mf mv mh mi mj mw ml mm mn mx mp mq mr ij bi translated">我们总共有<code class="fe nu nv nw nx b">18</code>个系数，每个系数都会被转换成<code class="fe nu nv nw nx b">10</code>位数。这意味着汽车的基因组将是一个长度为<code class="fe nu nv nw nx b">18 * 10 = 180 bits</code>的<code class="fe nu nv nw nx b">0</code>和<code class="fe nu nv nw nx b">1</code>的数组。</p><p id="ef9c" class="pw-post-body-paragraph lw lx iq ly b lz mt ka mb mc mu kd me mf mv mh mi mj mw ml mm mn mx mp mq mr ij bi translated">例如，对于上面提到的十进制格式的基因组，其二进制表示如下:</p><p id="3689" class="pw-post-body-paragraph lw lx iq ly b lz mt ka mb mc mu kd me mf mv mh mi mj mw ml mm mn mx mp mq mr ij bi translated">在我们的例子中，为了减少基因组长度，我们将把每个浮点系数转换成非标准的<code class="fe nu nv nw nx b">10 bits</code>二进制数(<code class="fe nu nv nw nx b">1</code>符号位、<code class="fe nu nv nw nx b">4</code>指数位、<code class="fe nu nv nw nx b">5</code>分数位)。</p><p id="14a4" class="pw-post-body-paragraph lw lx iq ly b lz mt ka mb mc mu kd me mf mv mh mi mj mw ml mm mn mx mp mq mr ij bi translated">我们总共有<code class="fe nu nv nw nx b">18</code>个系数，每个系数将被转换成<code class="fe nu nv nw nx b">10</code>位数。这意味着汽车的基因组将是一个长度为<code class="fe nu nv nw nx b">18 * 10 = 180 bits</code>的<code class="fe nu nv nw nx b">0</code>和<code class="fe nu nv nw nx b">1</code>的数组。</p><p id="e97f" class="pw-post-body-paragraph lw lx iq ly b lz mt ka mb mc mu kd me mf mv mh mi mj mw ml mm mn mx mp mq mr ij bi translated">例如，对于上面提到的十进制格式的基因组，其二进制表示如下:</p><pre class="kp kq kr ks gt nz nx oa ob aw oc bi"><span id="378c" class="od lf iq nx b gy oe of l og oh">type Gene = 0 | 1;<br/><br/>type Genome = Gene[];<br/><br/>const genome: Genome = [<br/>  // Engine coefficients.<br/>  0, 1, 0, 1, 1, 0, 0, 0, 1, 1, // &lt;- 17.5<br/>  0, 0, 0, 1, 0, 1, 1, 1, 0, 0, // &lt;- 0.059<br/>  1, 1, 1, 0, 0, 0, 1, 1, 1, 0, // &lt;- -46<br/>  0, 1, 0, 1, 1, 1, 0, 0, 1, 0, // &lt;- 25<br/>  0, 1, 1, 1, 0, 0, 0, 1, 1, 1, // &lt;- 156<br/>  1, 0, 0, 1, 1, 0, 1, 1, 0, 0, // &lt;- -0.085<br/>  1, 0, 1, 0, 0, 1, 0, 1, 0, 1, // &lt;- -0.207<br/>  1, 0, 1, 1, 0, 0, 0, 0, 1, 1, // &lt;- -0.546<br/>  0, 0, 0, 1, 1, 0, 0, 1, 0, 0, // &lt;- 0.071<br/><br/>  // Wheels coefficients.<br/>  1, 1, 1, 0, 0, 1, 1, 0, 1, 0, // &lt;- -58<br/>  0, 1, 1, 0, 0, 0, 1, 0, 0, 1, // &lt;- 41<br/>  0, 0, 0, 0, 0, 0, 1, 0, 1, 0, // &lt;- 0.011<br/>  0, 1, 1, 1, 0, 1, 1, 1, 1, 1, // &lt;- 252<br/>  1, 1, 0, 0, 0, 1, 1, 0, 0, 0, // &lt;- -3.5<br/>  1, 0, 0, 0, 1, 0, 0, 1, 0, 0, // &lt;- -0.017<br/>  0, 0, 1, 1, 1, 1, 0, 0, 0, 1, // &lt;- 1.532<br/>  1, 1, 1, 1, 1, 0, 1, 1, 0, 1, // &lt;- -360<br/>  0, 0, 1, 0, 0, 0, 1, 0, 0, 0, // &lt;- 0.157<br/>];</span></pre><p id="fbc9" class="pw-post-body-paragraph lw lx iq ly b lz mt ka mb mc mu kd me mf mv mh mi mj mw ml mm mn mx mp mq mr ij bi translated">我的天啊。二元基因组看起来如此神秘。但是你能想象吗，仅仅这些0和1就定义了汽车在停车场的行为！就像你黑了某人的DNA，知道每个基因的确切含义。太神奇了！</p><p id="e673" class="pw-post-body-paragraph lw lx iq ly b lz mt ka mb mc mu kd me mf mv mh mi mj mw ml mm mn mx mp mq mr ij bi translated">顺便说一下，你可以在<a class="ae ms" href="https://trekhleb.dev/self-parking-car-evolution?parking=evolution#/" rel="noopener ugc nofollow" target="_blank">进化模拟器</a>仪表盘上看到性能最好的汽车的基因组和系数的准确值:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/823db3726f506a611b4832e9431235ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VKrfxDBZvZvprIsCWB5pmA.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">进化模拟器仪表板截图</p></figure><p id="70fc" class="pw-post-body-paragraph lw lx iq ly b lz mt ka mb mc mu kd me mf mv mh mi mj mw ml mm mn mx mp mq mr ij bi translated">下面是执行浮点数从二进制到十进制格式转换的源代码(大脑需要它来解码基因组并根据基因组数据产生肌肉信号):</p><pre class="kp kq kr ks gt nz nx oa ob aw oc bi"><span id="29ff" class="od lf iq nx b gy oe of l og oh">type Bit = 0 | 1;</span><span id="4388" class="od lf iq nx b gy oi of l og oh">type Bits = Bit[];</span><span id="50e8" class="od lf iq nx b gy oi of l og oh">type PrecisionConfig = {<br/>  signBitsCount: number,<br/>  exponentBitsCount: number,<br/>  fractionBitsCount: number,<br/>  totalBitsCount: number,<br/>};</span><span id="add4" class="od lf iq nx b gy oi of l og oh">type PrecisionConfigs = {<br/>  custom: PrecisionConfig,<br/>};</span><span id="1c7c" class="od lf iq nx b gy oi of l og oh">const precisionConfigs: PrecisionConfigs = {<br/>  // Custom-made 10-bits precision for faster evolution progress.<br/>  custom: {<br/>    signBitsCount: 1,<br/>    exponentBitsCount: 4,<br/>    fractionBitsCount: 5,<br/>    totalBitsCount: 10,<br/>  },<br/>};</span><span id="a7b2" class="od lf iq nx b gy oi of l og oh">// Converts the binary representation of the floating-point number to decimal float number.<br/>function bitsToFloat(bits: Bits, precisionConfig: PrecisionConfig): number {<br/>  const { signBitsCount, exponentBitsCount } = precisionConfig;</span><span id="6043" class="od lf iq nx b gy oi of l og oh">  // Figuring out the sign.<br/>  const sign = (-1) ** bits[0]; // -1^1 = -1, -1^0 = 1</span><span id="a0d7" class="od lf iq nx b gy oi of l og oh">  // Calculating the exponent value.<br/>  const exponentBias = 2 ** (exponentBitsCount - 1) - 1;<br/>  const exponentBits = bits.slice(signBitsCount, signBitsCount + exponentBitsCount);<br/>  const exponentUnbiased = exponentBits.reduce(<br/>    (exponentSoFar: number, currentBit: Bit, bitIndex: number) =&gt; {<br/>      const bitPowerOfTwo = 2 ** (exponentBitsCount - bitIndex - 1);<br/>      return exponentSoFar + currentBit * bitPowerOfTwo;<br/>    },<br/>    0,<br/>  );<br/>  const exponent = exponentUnbiased - exponentBias;</span><span id="b59f" class="od lf iq nx b gy oi of l og oh">  // Calculating the fraction value.<br/>  const fractionBits = bits.slice(signBitsCount + exponentBitsCount);<br/>  const fraction = fractionBits.reduce(<br/>    (fractionSoFar: number, currentBit: Bit, bitIndex: number) =&gt; {<br/>      const bitPowerOfTwo = 2 ** -(bitIndex + 1);<br/>      return fractionSoFar + currentBit * bitPowerOfTwo;<br/>    },<br/>    0,<br/>  );</span><span id="25ee" class="od lf iq nx b gy oi of l og oh">  // Putting all parts together to calculate the final number.<br/>  return sign * (2 ** exponent) * (1 + fraction);<br/>}</span><span id="f227" class="od lf iq nx b gy oi of l og oh">// Converts the 8-bit binary representation of the floating-point number to decimal float number.<br/>function bitsToFloat10(bits: Bits): number {<br/>  return bitsToFloat(bits, precisionConfigs.custom);<br/>}</span></pre><h1 id="0590" class="le lf iq bd lg lh li lj lk ll lm ln lo kf lp kg lq ki lr kj ls kl lt km lu lv bi translated">大脑功能与二元基因组一起工作</h1><p id="c0e0" class="pw-post-body-paragraph lw lx iq ly b lz ma ka mb mc md kd me mf mg mh mi mj mk ml mm mn mo mp mq mr ij bi translated">以前，我们的大脑功能是直接处理十进制形式的<code class="fe nu nv nw nx b">engineCoefficients</code>和<code class="fe nu nv nw nx b">wheelCoefficients</code>多项式系数。然而，这些系数现在是以基因组的二进制形式编码的。让我们添加一个<code class="fe nu nv nw nx b">decodeGenome()</code>功能，从基因组中提取系数，让我们重写我们的大脑功能:</p><pre class="kp kq kr ks gt nz nx oa ob aw oc bi"><span id="c15e" class="od lf iq nx b gy oe of l og oh">// Car has 16 distance sensors.<br/>const CAR_SENSORS_NUM = 8;<br/><br/>// Additional formula coefficient that is not connected to a sensor.<br/>const BIAS_UNITS = 1;<br/><br/>// How many genes do we need to encode each numeric parameter for the formulas.<br/>const GENES_PER_NUMBER = precisionConfigs.custom.totalBitsCount;<br/><br/>// Based on 8 distance sensors we need to provide two formulas that would define car's behavior:<br/>// 1. Engine formula (input: 8 sensors; output: -1 (backward), 0 (neutral), +1 (forward))<br/>// 2. Wheels formula (input: 8 sensors; output: -1 (left), 0 (straight), +1 (right))<br/>const ENGINE_FORMULA_GENES_NUM = (CAR_SENSORS_NUM + BIAS_UNITS) * GENES_PER_NUMBER;<br/>const WHEELS_FORMULA_GENES_NUM = (CAR_SENSORS_NUM + BIAS_UNITS) * GENES_PER_NUMBER;<br/><br/>// The length of the binary genome of the car.<br/>const GENOME_LENGTH = ENGINE_FORMULA_GENES_NUM + WHEELS_FORMULA_GENES_NUM;<br/><br/>type DecodedGenome = {<br/>  engineFormulaCoefficients: Coefficients,<br/>  wheelsFormulaCoefficients: Coefficients,<br/>}<br/><br/>// Converts the genome from a binary form to the decimal form.<br/>const genomeToNumbers = (genome: Genome, genesPerNumber: number): number[] =&gt; {<br/>  if (genome.length % genesPerNumber !== 0) {<br/>    throw new Error('Wrong number of genes in the numbers genome');<br/>  }<br/>  const numbers: number[] = [];<br/>  for (let numberIndex = 0; numberIndex &lt; genome.length; numberIndex += genesPerNumber) {<br/>    const number: number = bitsToFloat10(genome.slice(numberIndex, numberIndex + genesPerNumber));<br/>    numbers.push(number);<br/>  }<br/>  return numbers;<br/>};<br/><br/>// Converts the genome from a binary form to the decimal form<br/>// and splits the genome into two sets of coefficients (one set for each muscle).<br/>const decodeGenome = (genome: Genome): DecodedGenome =&gt; {<br/>  const engineGenes: Gene[] = genome.slice(0, ENGINE_FORMULA_GENES_NUM);<br/>  const wheelsGenes: Gene[] = genome.slice(<br/>    ENGINE_FORMULA_GENES_NUM,<br/>    ENGINE_FORMULA_GENES_NUM + WHEELS_FORMULA_GENES_NUM,<br/>  );<br/><br/>  const engineFormulaCoefficients: Coefficients = genomeToNumbers(engineGenes, GENES_PER_NUMBER);<br/>  const wheelsFormulaCoefficients: Coefficients = genomeToNumbers(wheelsGenes, GENES_PER_NUMBER);<br/><br/>  return {<br/>    engineFormulaCoefficients,<br/>    wheelsFormulaCoefficients,<br/>  };<br/>};<br/><br/>// Update brain function for the engine muscle.<br/>export const getEngineMuscleSignal = (genome: Genome, sensors: Sensors): MuscleSignal =&gt; {<br/>  const {engineFormulaCoefficients: coefficients} = decodeGenome(genome);<br/>  const rawBrainSignal = linearPolynomial(coefficients, sensors);<br/>  return brainToMuscleSignal(rawBrainSignal);<br/>};<br/><br/>// Update brain function for the wheels muscle.<br/>export const getWheelsMuscleSignal = (genome: Genome, sensors: Sensors): MuscleSignal =&gt; {<br/>  const {wheelsFormulaCoefficients: coefficients} = decodeGenome(genome);<br/>  const rawBrainSignal = linearPolynomial(coefficients, sensors);<br/>  return brainToMuscleSignal(rawBrainSignal);<br/>};</span></pre><h1 id="9c57" class="le lf iq bd lg lh li lj lk ll lm ln lo kf lp kg lq ki lr kj ls kl lt km lu lv bi translated">自动驾驶汽车问题声明</h1><blockquote class="mz na nb"><p id="e472" class="lw lx nc ly b lz mt ka mb mc mu kd me nd mv mh mi ne mw ml mm nf mx mp mq mr ij bi translated">☝🏻所以，最后，我们已经到了让汽车成为自动泊车汽车的高层次问题被分解为寻找<code class="fe nu nv nw nx b">180</code>1和0的最佳组合(寻找“足够好”的汽车基因组)的简单优化问题的地步。听起来很简单，不是吗？</p></blockquote><h1 id="daf9" class="le lf iq bd lg lh li lj lk ll lm ln lo kf lp kg lq ki lr kj ls kl lt km lu lv bi translated">天真的方法</h1><p id="aba6" class="pw-post-body-paragraph lw lx iq ly b lz ma ka mb mc md kd me mf mg mh mi mj mk ml mm mn mo mp mq mr ij bi translated">我们可以用一种简单的方法来解决寻找“足够好”的基因组的问题，并尝试所有可能的基因组合:</p><ol class=""><li id="9689" class="ng nh iq ly b lz mt mc mu mf ni mj nj mn nk mr ny nm nn no bi translated"><code class="fe nu nv nw nx b">[0, ..., 0, 0]</code>，然后...</li><li id="e669" class="ng nh iq ly b lz np mc nq mf nr mj ns mn nt mr ny nm nn no bi translated"><code class="fe nu nv nw nx b">[0, ..., 0, 1]</code>，然后...</li><li id="b23a" class="ng nh iq ly b lz np mc nq mf nr mj ns mn nt mr ny nm nn no bi translated"><code class="fe nu nv nw nx b">[0, ..., 1, 0]</code>，然后...</li><li id="f250" class="ng nh iq ly b lz np mc nq mf nr mj ns mn nt mr ny nm nn no bi translated"><code class="fe nu nv nw nx b">[0, ..., 1, 1]</code>，然后...</li><li id="b0e7" class="ng nh iq ly b lz np mc nq mf nr mj ns mn nt mr ny nm nn no bi">…</li></ol><p id="cb3a" class="pw-post-body-paragraph lw lx iq ly b lz mt ka mb mc mu kd me mf mv mh mi mj mw ml mm mn mx mp mq mr ij bi translated">但是，让我们做一些数学计算。使用<code class="fe nu nv nw nx b">180</code>位，并且每个位等于<code class="fe nu nv nw nx b">0</code>或<code class="fe nu nv nw nx b">1</code>，我们将有<code class="fe nu nv nw nx b">2^180</code>(或<code class="fe nu nv nw nx b">1.53 * 10^54</code>)种可能的组合。假设我们需要给每辆车一个<code class="fe nu nv nw nx b">15s</code>,看看它是否能成功停车。我们还可以说，我们可能马上对<code class="fe nu nv nw nx b">10</code>汽车进行模拟。那么我们将需要<code class="fe nu nv nw nx b">15 * (1.53 * 10^54) / 10 = 2.29 * 10^54 [seconds]</code>，也就是<code class="fe nu nv nw nx b">7.36 * 10^46 [years]</code>。相当长的等待时间。就像一个侧面的想法，它只是在基督诞生后已经过去了。</p><h1 id="a0e2" class="le lf iq bd lg lh li lj lk ll lm ln lo kf lp kg lq ki lr kj ls kl lt km lu lv bi translated">遗传学方法</h1><p id="04ba" class="pw-post-body-paragraph lw lx iq ly b lz ma ka mb mc md kd me mf mg mh mi mj mk ml mm mn mo mp mq mr ij bi translated">我们需要一个更快的算法来寻找基因组的最优值。这就是遗传算法的救援之处。我们可能找不到基因组的最佳价值，但有可能找到它的最佳价值。更重要的是，我们不需要等那么久。有了进化模拟器，我能够在<code class="fe nu nv nw nx b">24 [hours]</code>中找到一个非常好的基因组。</p><h1 id="6598" class="le lf iq bd lg lh li lj lk ll lm ln lo kf lp kg lq ki lr kj ls kl lt km lu lv bi translated">遗传算法基础</h1><p id="6fbd" class="pw-post-body-paragraph lw lx iq ly b lz ma ka mb mc md kd me mf mg mh mi mj mk ml mm mn mo mp mq mr ij bi translated">一种<a class="ae ms" href="https://en.wikipedia.org/wiki/Genetic_algorithm" rel="noopener ugc nofollow" target="_blank">遗传算法</a> (GA)，受自然选择过程的启发，通常用于依靠生物启发算子生成优化问题的高质量解决方案，如<em class="nc">交叉</em>、<em class="nc">变异</em>和<em class="nc">选择</em>。</p><p id="5af8" class="pw-post-body-paragraph lw lx iq ly b lz mt ka mb mc mu kd me mf mv mh mi mj mw ml mm mn mx mp mq mr ij bi translated">为汽车找到“足够好”的基因组合的问题看起来像一个优化问题，所以GA很有可能在这里帮助我们。</p><p id="513e" class="pw-post-body-paragraph lw lx iq ly b lz mt ka mb mc mu kd me mf mv mh mi mj mw ml mm mn mx mp mq mr ij bi translated">我们不会涵盖遗传算法的所有细节，但在高层次上，这里是我们需要做的基本步骤:</p><ol class=""><li id="4aef" class="ng nh iq ly b lz mt mc mu mf ni mj nj mn nk mr ny nm nn no bi translated"><strong class="ly ja">创建</strong> —第一代汽车<a class="ae ms" href="https://en.wikipedia.org/wiki/Laws_of_thermodynamics" rel="noopener ugc nofollow" target="_blank">不可能无中生有</a>，所以我们会在最开始生成一组随机的汽车基因组(长度为<code class="fe nu nv nw nx b">180</code>的一组二进制数组)。例如，我们可以制造<code class="fe nu nv nw nx b">~1000</code>汽车。随着人口的增加，找到最优解(并且更快地找到)的机会也增加了。</li><li id="64f3" class="ng nh iq ly b lz np mc nq mf nr mj ns mn nt mr ny nm nn no bi translated">选择——我们需要从这一代中选择最合适的个体进行进一步的交配(见下一步)。每个个体的适应度将基于适应度函数来定义，在我们的情况下，适应度函数将显示汽车有多接近目标停车位。车离停车点越近越合适。</li><li id="df64" class="ng nh iq ly b lz np mc nq mf nr mj ns mn nt mr ny nm nn no bi translated"><strong class="ly ja">与</strong>交配——简单地说，我们将允许被选中的<em class="nc"> "♂父车"</em>"与被选中的<em class="nc"> "♀母车"</em>有<em class="nc">"性别"</em>，这样它们的基因组就可以按<code class="fe nu nv nw nx b">~50/50</code>比例混合，产生<em class="nc">"♀♀子车"</em>基因组。这个想法是，通过从父母那里获取最好(或最差)的部分，儿童汽车在自动停车方面可能会变得更好(或更差)。</li><li id="d0dc" class="ng nh iq ly b lz np mc nq mf nr mj ns mn nt mr ny nm nn no bi translated"><strong class="ly ja">突变</strong>——在交配过程中，一些基因可能会随机突变(子基因组中的<code class="fe nu nv nw nx b">1</code> s和<code class="fe nu nv nw nx b">0</code> s可能会翻转)。这可能会带来更广泛的儿童基因组，因此，更广泛的儿童汽车行为。想象一下，对于所有的<code class="fe nu nv nw nx b">~1000</code>汽车，第1位被意外设置为<code class="fe nu nv nw nx b">0</code>。第一位设置为<code class="fe nu nv nw nx b">1</code>时，测试汽车的唯一方法是通过随机突变。同时，广泛的突变可能会破坏健康的基因组。</li><li id="5f6e" class="ng nh iq ly b lz np mc nq mf nr mj ns mn nt mr ny nm nn no bi translated">除非代的数量已经达到极限(即<code class="fe nu nv nw nx b">100</code>代已经过去)或者除非表现最好的个体已经达到预期的适应度函数值(即最好的汽车已经比<code class="fe nu nv nw nx b">1 meter</code>更接近停车点)，否则转到“步骤2”。否则，退出。</li></ol><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ok"><img src="../Images/6a14a028cba4cc114e670f77e18e6177.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mDsnGAIIr1XKQyyuWNtKGQ.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">遗传算法流程。作者插图</p></figure><h1 id="9954" class="le lf iq bd lg lh li lj lk ll lm ln lo kf lp kg lq ki lr kj ls kl lt km lu lv bi translated">用遗传算法进化汽车大脑</h1><p id="9255" class="pw-post-body-paragraph lw lx iq ly b lz ma ka mb mc md kd me mf mg mh mi mj mk ml mm mn mo mp mq mr ij bi translated">在启动遗传算法之前，让我们为算法的“创建”、“选择”、“交配”和“变异”步骤创建函数。</p><h1 id="c6a9" class="le lf iq bd lg lh li lj lk ll lm ln lo kf lp kg lq ki lr kj ls kl lt km lu lv bi translated">创建步骤的函数</h1><p id="7fd1" class="pw-post-body-paragraph lw lx iq ly b lz ma ka mb mc md kd me mf mg mh mi mj mk ml mm mn mo mp mq mr ij bi translated"><code class="fe nu nv nw nx b">createGeneration()</code>函数将创建一个随机基因组数组(也称为群体或世代),并将接受两个参数:</p><ul class=""><li id="a23d" class="ng nh iq ly b lz mt mc mu mf ni mj nj mn nk mr nl nm nn no bi translated"><code class="fe nu nv nw nx b">generationSize</code> -定义代的大小。这一代人的规模将一代一代地保持下去。</li><li id="218e" class="ng nh iq ly b lz np mc nq mf nr mj ns mn nt mr nl nm nn no bi translated"><code class="fe nu nv nw nx b">genomeLength</code> -定义cars群体中每个个体的基因组长度。在我们的例子中，基因组的长度将是<code class="fe nu nv nw nx b">180</code>。</li></ul><p id="8b28" class="pw-post-body-paragraph lw lx iq ly b lz mt ka mb mc mu kd me mf mv mh mi mj mw ml mm mn mx mp mq mr ij bi translated">基因组中的每个基因都有<code class="fe nu nv nw nx b">50/50</code>的机会成为<code class="fe nu nv nw nx b">0</code>或<code class="fe nu nv nw nx b">1</code>。</p><pre class="kp kq kr ks gt nz nx oa ob aw oc bi"><span id="484d" class="od lf iq nx b gy oe of l og oh">type Generation = Genome[];<br/><br/>type GenerationParams = {<br/>  generationSize: number,<br/>  genomeLength: number,<br/>};<br/><br/>function createGenome(length: number): Genome {<br/>  return new Array(length)<br/>    .fill(null)<br/>    .map(() =&gt; (Math.random() &lt; 0.5 ? 0 : 1));<br/>}<br/><br/>function createGeneration(params: GenerationParams): Generation {<br/>  const { generationSize, genomeLength } = params;<br/>  return new Array(generationSize)<br/>    .fill(null)<br/>    .map(() =&gt; createGenome(genomeLength));<br/>}</span></pre><h1 id="0a12" class="le lf iq bd lg lh li lj lk ll lm ln lo kf lp kg lq ki lr kj ls kl lt km lu lv bi translated">变异步骤的函数</h1><p id="7598" class="pw-post-body-paragraph lw lx iq ly b lz ma ka mb mc md kd me mf mg mh mi mj mk ml mm mn mo mp mq mr ij bi translated"><code class="fe nu nv nw nx b">mutate()</code>函数会根据<code class="fe nu nv nw nx b">mutationProbability</code>值随机变异一些基因。</p><p id="a755" class="pw-post-body-paragraph lw lx iq ly b lz mt ka mb mc mu kd me mf mv mh mi mj mw ml mm mn mx mp mq mr ij bi translated">例如，如果<code class="fe nu nv nw nx b">mutationProbability = 0.1</code>那么每个基因组都有<code class="fe nu nv nw nx b">10%</code>的机会发生突变。比方说，如果我们有一个长度为<code class="fe nu nv nw nx b">10</code>的基因组，看起来像<code class="fe nu nv nw nx b">[0, 0, 0, 0, 0, 0 ,0 ,0 ,0 ,0]</code>，那么在突变之后，有可能1个基因会发生突变，我们可能会得到一个看起来像<code class="fe nu nv nw nx b">[0, 0, 0, 1, 0, 0 ,0 ,0 ,0 ,0]</code>的基因组。</p><pre class="kp kq kr ks gt nz nx oa ob aw oc bi"><span id="b18a" class="od lf iq nx b gy oe of l og oh">// The number between 0 and 1.<br/>type Probability = number;</span><span id="c3bf" class="od lf iq nx b gy oi of l og oh">// @see: https://en.wikipedia.org/wiki/Mutation_(genetic_algorithm)<br/>function mutate(genome: Genome, mutationProbability: Probability): Genome {<br/>  for (let geneIndex = 0; geneIndex &lt; genome.length; geneIndex += 1) {<br/>    const gene: Gene = genome[geneIndex];<br/>    const mutatedGene: Gene = gene === 0 ? 1 : 0;<br/>    genome[geneIndex] = Math.random() &lt; mutationProbability ? mutatedGene : gene;<br/>  }<br/>  return genome;<br/>}</span></pre><h1 id="a8ab" class="le lf iq bd lg lh li lj lk ll lm ln lo kf lp kg lq ki lr kj ls kl lt km lu lv bi translated">配对步骤的功能</h1><p id="f980" class="pw-post-body-paragraph lw lx iq ly b lz ma ka mb mc md kd me mf mg mh mi mj mk ml mm mn mo mp mq mr ij bi translated"><code class="fe nu nv nw nx b">mate()</code>函数将接受<code class="fe nu nv nw nx b">father</code>和<code class="fe nu nv nw nx b">mother</code>基因组，并将产生两个子代。我们将模仿真实世界的场景，并在交配过程中进行变异。</p><p id="3cb6" class="pw-post-body-paragraph lw lx iq ly b lz mt ka mb mc mu kd me mf mv mh mi mj mw ml mm mn mx mp mq mr ij bi translated">孩子基因组的每一位都将根据父亲或母亲基因组相应位的值来定义。孩子有可能继承父亲或母亲的一部分。例如，假设我们有长度为<code class="fe nu nv nw nx b">4</code>的基因组(为了简单起见):</p><pre class="kp kq kr ks gt nz nx oa ob aw oc bi"><span id="6ce8" class="od lf iq nx b gy oe of l og oh">Father's genome: [0, 0, 1, 1]<br/>Mother's genome: [0, 1, 0, 1]<br/>                  ↓  ↓  ↓  ↓<br/>Possible kid #1: [0, 1, 1, 1]<br/>Possible kid #2: [0, 0, 1, 1]</span></pre><p id="ab6f" class="pw-post-body-paragraph lw lx iq ly b lz mt ka mb mc mu kd me mf mv mh mi mj mw ml mm mn mx mp mq mr ij bi translated">在上面的例子中，突变没有考虑在内。</p><p id="5518" class="pw-post-body-paragraph lw lx iq ly b lz mt ka mb mc mu kd me mf mv mh mi mj mw ml mm mn mx mp mq mr ij bi translated">下面是该函数的实现:</p><pre class="kp kq kr ks gt nz nx oa ob aw oc bi"><span id="bf35" class="od lf iq nx b gy oe of l og oh">// Performs Uniform Crossover: each bit is chosen from either parent with equal probability.<br/>// @see: https://en.wikipedia.org/wiki/Crossover_(genetic_algorithm)<br/>function mate(<br/>  father: Genome,<br/>  mother: Genome,<br/>  mutationProbability: Probability,<br/>): [Genome, Genome] {<br/>  if (father.length !== mother.length) {<br/>    throw new Error('Cannot mate different species');<br/>  }</span><span id="bc40" class="od lf iq nx b gy oi of l og oh">  const firstChild: Genome = [];<br/>  const secondChild: Genome = [];</span><span id="a8b1" class="od lf iq nx b gy oi of l og oh">  // Conceive children.<br/>  for (let geneIndex = 0; geneIndex &lt; father.length; geneIndex += 1) {<br/>    firstChild.push(<br/>      Math.random() &lt; 0.5 ? father[geneIndex] : mother[geneIndex]<br/>    );<br/>    secondChild.push(<br/>      Math.random() &lt; 0.5 ? father[geneIndex] : mother[geneIndex]<br/>    );<br/>  }</span><span id="636d" class="od lf iq nx b gy oi of l og oh">  return [<br/>    mutate(firstChild, mutationProbability),<br/>    mutate(secondChild, mutationProbability),<br/>  ];<br/>}</span></pre><h1 id="2a8c" class="le lf iq bd lg lh li lj lk ll lm ln lo kf lp kg lq ki lr kj ls kl lt km lu lv bi translated">选择步骤的功能</h1><p id="e929" class="pw-post-body-paragraph lw lx iq ly b lz ma ka mb mc md kd me mf mg mh mi mj mk ml mm mn mo mp mq mr ij bi translated">为了选择最适合的个体进行进一步交配，我们需要一种方法来找出每个基因组的适合度。为此，我们将使用所谓的适应度函数。</p><p id="fa6c" class="pw-post-body-paragraph lw lx iq ly b lz mt ka mb mc mu kd me mf mv mh mi mj mw ml mm mn mx mp mq mr ij bi translated">适应度函数总是与我们试图解决的特定任务相关，它不是通用的。在我们的例子中，适应度函数将测量汽车和停车点之间的距离。车离停车点越近越合适。稍后我们将实现健身功能，但现在，让我们介绍它的接口:</p><pre class="kp kq kr ks gt nz nx oa ob aw oc bi"><span id="2d35" class="od lf iq nx b gy oe of l og oh">type FitnessFunction = (genome: Genome) =&gt; number;</span></pre><p id="6156" class="pw-post-body-paragraph lw lx iq ly b lz mt ka mb mc mu kd me mf mv mh mi mj mw ml mm mn mx mp mq mr ij bi translated">现在，假设我们有每个个体的适应值。我们还可以说，我们根据个体的健康值对所有个体进行了分类，因此第一个个体是最强壮的。我们应该如何从这个数组中选择父亲和母亲呢？我们需要以某种方式进行选择，个体的适应值越高，这个个体被选择交配的机会就越高。<code class="fe nu nv nw nx b">weightedRandom()</code>函数将在这方面帮助我们。</p><pre class="kp kq kr ks gt nz nx oa ob aw oc bi"><span id="ed39" class="od lf iq nx b gy oe of l og oh">// Picks the random item based on its weight.<br/>// The items with a higher weight will be picked more often.<br/>const weightedRandom = &lt;T&gt;(items: T[], weights: number[]): { item: T, index: number } =&gt; {<br/>  if (items.length !== weights.length) {<br/>    throw new Error('Items and weights must be of the same size');<br/>  }</span><span id="c641" class="od lf iq nx b gy oi of l og oh">  // Preparing the cumulative weights array.<br/>  // For example:<br/>  // - weights = [1, 4, 3]<br/>  // - cumulativeWeights = [1, 5, 8]<br/>  const cumulativeWeights: number[] = [];<br/>  for (let i = 0; i &lt; weights.length; i += 1) {<br/>    cumulativeWeights[i] = weights[i] + (cumulativeWeights[i - 1] || 0);<br/>  }</span><span id="b1b3" class="od lf iq nx b gy oi of l og oh">  // Getting the random number in a range [0...sum(weights)]<br/>  // For example:<br/>  // - weights = [1, 4, 3]<br/>  // - maxCumulativeWeight = 8<br/>  // - range for the random number is [0...8]<br/>  const maxCumulativeWeight = cumulativeWeights[cumulativeWeights.length - 1];<br/>  const randomNumber = maxCumulativeWeight * Math.random();</span><span id="4afa" class="od lf iq nx b gy oi of l og oh">  // Picking the random item based on its weight.<br/>  // The items with higher weight will be picked more often.<br/>  for (let i = 0; i &lt; items.length; i += 1) {<br/>    if (cumulativeWeights[i] &gt;= randomNumber) {<br/>      return {<br/>        item: items[i],<br/>        index: i,<br/>      };<br/>    }<br/>  }<br/>  return {<br/>    item: items[items.length - 1],<br/>    index: items.length - 1,<br/>  };<br/>};</span></pre><p id="d9b3" class="pw-post-body-paragraph lw lx iq ly b lz mt ka mb mc mu kd me mf mv mh mi mj mw ml mm mn mx mp mq mr ij bi translated">这个函数的用法非常简单。假设你真的很喜欢香蕉，想比草莓更常吃香蕉。然后你可以调用<code class="fe nu nv nw nx b">const fruit = weightedRandom(['banana', 'strawberry'], [9, 1])</code>，并且在<code class="fe nu nv nw nx b">10</code>之外的<code class="fe nu nv nw nx b">≈9</code>情况下<code class="fe nu nv nw nx b">fruit</code>变量将等于<code class="fe nu nv nw nx b">banana</code>，并且只有在<code class="fe nu nv nw nx b">10</code>之外的<code class="fe nu nv nw nx b">≈1</code>时间内它将等于<code class="fe nu nv nw nx b">strawberry</code>。</p><p id="2773" class="pw-post-body-paragraph lw lx iq ly b lz mt ka mb mc mu kd me mf mv mh mi mj mw ml mm mn mx mp mq mr ij bi translated">为了避免在交配过程中失去最好的个体(姑且称之为冠军),我们也可以引入一个所谓的<code class="fe nu nv nw nx b">longLivingChampionsPercentage</code>参数。例如，如果是<code class="fe nu nv nw nx b">longLivingChampionsPercentage = 10</code>，那么上一代最好的车中的<code class="fe nu nv nw nx b">10%</code>将被带到新一代。你可以这样想，因为有些长寿的个体可以长寿，可以看到他们的孩子甚至孙子。</p><p id="90f0" class="pw-post-body-paragraph lw lx iq ly b lz mt ka mb mc mu kd me mf mv mh mi mj mw ml mm mn mx mp mq mr ij bi translated">下面是<code class="fe nu nv nw nx b">select()</code>功能的实际实现:</p><pre class="kp kq kr ks gt nz nx oa ob aw oc bi"><span id="f121" class="od lf iq nx b gy oe of l og oh">// The number between 0 and 100.<br/>type Percentage = number;</span><span id="acfe" class="od lf iq nx b gy oi of l og oh">type SelectionOptions = {<br/>  mutationProbability: Probability,<br/>  longLivingChampionsPercentage: Percentage,<br/>};</span><span id="93a9" class="od lf iq nx b gy oi of l og oh">// @see: https://en.wikipedia.org/wiki/Selection_(genetic_algorithm)<br/>function select(<br/>  generation: Generation,<br/>  fitness: FitnessFunction,<br/>  options: SelectionOptions,<br/>) {<br/>  const {<br/>    mutationProbability,<br/>    longLivingChampionsPercentage,<br/>  } = options;</span><span id="21b8" class="od lf iq nx b gy oi of l og oh">  const newGeneration: Generation = [];</span><span id="609a" class="od lf iq nx b gy oi of l og oh">  const oldGeneration = [...generation];<br/>  // First one - the fittest one.<br/>  oldGeneration.sort((genomeA: Genome, genomeB: Genome): number =&gt; {<br/>    const fitnessA = fitness(genomeA);<br/>    const fitnessB = fitness(genomeB);<br/>    if (fitnessA &lt; fitnessB) {<br/>      return 1;<br/>    }<br/>    if (fitnessA &gt; fitnessB) {<br/>      return -1;<br/>    }<br/>    return 0;<br/>  });</span><span id="7bdb" class="od lf iq nx b gy oi of l og oh">  // Let long-liver champions continue living in the new generation.<br/>  const longLiversCount = Math.floor(longLivingChampionsPercentage * oldGeneration.length / 100);<br/>  if (longLiversCount) {<br/>    oldGeneration.slice(0, longLiversCount).forEach((longLivingGenome: Genome) =&gt; {<br/>      newGeneration.push(longLivingGenome);<br/>    });<br/>  }</span><span id="24ae" class="od lf iq nx b gy oi of l og oh">  // Get the data about he fitness of each individuum.<br/>  const fitnessPerOldGenome: number[] = oldGeneration.map((genome: Genome) =&gt; fitness(genome));</span><span id="bd71" class="od lf iq nx b gy oi of l og oh">  // Populate the next generation until it becomes the same size as a old generation.<br/>  while (newGeneration.length &lt; generation.length) {<br/>    // Select random father and mother from the population.<br/>    // The fittest individuums have higher chances to be selected.<br/>    let father: Genome | null = null;<br/>    let fatherGenomeIndex: number | null = null;<br/>    let mother: Genome | null = null;<br/>    let matherGenomeIndex: number | null = null;</span><span id="4cd7" class="od lf iq nx b gy oi of l og oh">    // To produce children the father and mother need each other.<br/>    // It must be two different individuums.<br/>    while (!father || !mother || fatherGenomeIndex === matherGenomeIndex) {<br/>      const {<br/>        item: randomFather,<br/>        index: randomFatherGenomeIndex,<br/>      } = weightedRandom&lt;Genome&gt;(generation, fitnessPerOldGenome);</span><span id="cb96" class="od lf iq nx b gy oi of l og oh">      const {<br/>        item: randomMother,<br/>        index: randomMotherGenomeIndex,<br/>      } = weightedRandom&lt;Genome&gt;(generation, fitnessPerOldGenome);</span><span id="01e3" class="od lf iq nx b gy oi of l og oh">      father = randomFather;<br/>      fatherGenomeIndex = randomFatherGenomeIndex;</span><span id="4bac" class="od lf iq nx b gy oi of l og oh">      mother = randomMother;<br/>      matherGenomeIndex = randomMotherGenomeIndex;<br/>    }</span><span id="10cd" class="od lf iq nx b gy oi of l og oh">    // Let father and mother produce two children.<br/>    const [firstChild, secondChild] = mate(father, mother, mutationProbability);</span><span id="163e" class="od lf iq nx b gy oi of l og oh">    newGeneration.push(firstChild);</span><span id="1513" class="od lf iq nx b gy oi of l og oh">    // Depending on the number of long-living champions it is possible that<br/>    // there will be the place for only one child, sorry.<br/>    if (newGeneration.length &lt; generation.length) {<br/>      newGeneration.push(secondChild);<br/>    }<br/>  }</span><span id="d50a" class="od lf iq nx b gy oi of l og oh">  return newGeneration;<br/>}</span></pre><h1 id="3bd3" class="le lf iq bd lg lh li lj lk ll lm ln lo kf lp kg lq ki lr kj ls kl lt km lu lv bi translated">适应度函数</h1><p id="b2c9" class="pw-post-body-paragraph lw lx iq ly b lz ma ka mb mc md kd me mf mg mh mi mj mk ml mm mn mo mp mq mr ij bi translated">汽车的适应性将由从汽车到停车点的距离来定义。距离越高，适合度越低。</p><p id="74ec" class="pw-post-body-paragraph lw lx iq ly b lz mt ka mb mc mu kd me mf mv mh mi mj mw ml mm mn mx mp mq mr ij bi translated">我们将计算的最终距离是从<code class="fe nu nv nw nx b">4</code>车轮到停车场相应的<code class="fe nu nv nw nx b">4</code>角落的平均距离。这个距离我们称之为<code class="fe nu nv nw nx b">loss</code>，它与<code class="fe nu nv nw nx b">fitness</code>成反比。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ol"><img src="../Images/8b325fb471b1810121cf37efad972e22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fTEgR7M06s7YcIM6ah4LdQ.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">测量汽车的适应性。作者插图。</p></figure><p id="6512" class="pw-post-body-paragraph lw lx iq ly b lz mt ka mb mc mu kd me mf mv mh mi mj mw ml mm mn mx mp mq mr ij bi translated">单独计算每个车轮和每个拐角之间的距离(而不是只计算从汽车中心到停车点中心的距离)将使汽车保持相对于停车点的正确方向。</p><p id="c28f" class="pw-post-body-paragraph lw lx iq ly b lz mt ka mb mc mu kd me mf mv mh mi mj mw ml mm mn mx mp mq mr ij bi translated">空间中两点之间的距离将根据<a class="ae ms" href="https://en.wikipedia.org/wiki/Pythagorean_theorem" rel="noopener ugc nofollow" target="_blank">勾股定理</a>计算，如下所示:</p><pre class="kp kq kr ks gt nz nx oa ob aw oc bi"><span id="be74" class="od lf iq nx b gy oe of l og oh">type NumVec3 = [number, number, number];</span><span id="6eab" class="od lf iq nx b gy oi of l og oh">// Calculates the XZ distance between two points in space.<br/>// The vertical Y distance is not being taken into account.<br/>const euclideanDistance = (from: NumVec3, to: NumVec3) =&gt; {<br/>  const fromX = from[0];<br/>  const fromZ = from[2];<br/>  const toX = to[0];<br/>  const toZ = to[2];<br/>  return Math.sqrt((fromX - toX) ** 2 + (fromZ - toZ) ** 2);<br/>};</span></pre><p id="1059" class="pw-post-body-paragraph lw lx iq ly b lz mt ka mb mc mu kd me mf mv mh mi mj mw ml mm mn mx mp mq mr ij bi translated">汽车和停车位之间的距离(T0)将这样计算:</p><pre class="kp kq kr ks gt nz nx oa ob aw oc bi"><span id="ba90" class="od lf iq nx b gy oe of l og oh">type RectanglePoints = {<br/>  fl: NumVec3, // Front-left<br/>  fr: NumVec3, // Front-right<br/>  bl: NumVec3, // Back-left<br/>  br: NumVec3, // Back-right<br/>};</span><span id="5396" class="od lf iq nx b gy oi of l og oh">type GeometricParams = {<br/>  wheelsPosition: RectanglePoints,<br/>  parkingLotCorners: RectanglePoints,<br/>};</span><span id="46f7" class="od lf iq nx b gy oi of l og oh">const carLoss = (params: GeometricParams): number =&gt; {<br/>  const { wheelsPosition, parkingLotCorners } = params;</span><span id="55ee" class="od lf iq nx b gy oi of l og oh">  const {<br/>    fl: flWheel,<br/>    fr: frWheel,<br/>    br: brWheel,<br/>    bl: blWheel,<br/>  } = wheelsPosition;</span><span id="aff5" class="od lf iq nx b gy oi of l og oh">  const {<br/>    fl: flCorner,<br/>    fr: frCorner,<br/>    br: brCorner,<br/>    bl: blCorner,<br/>  } = parkingLotCorners;</span><span id="3a2e" class="od lf iq nx b gy oi of l og oh">  const flDistance = euclideanDistance(flWheel, flCorner);<br/>  const frDistance = euclideanDistance(frWheel, frCorner);<br/>  const brDistance = euclideanDistance(brWheel, brCorner);<br/>  const blDistance = euclideanDistance(blWheel, blCorner);</span><span id="ffd1" class="od lf iq nx b gy oi of l og oh">  return (flDistance + frDistance + brDistance + blDistance) / 4;<br/>};</span></pre><p id="b928" class="pw-post-body-paragraph lw lx iq ly b lz mt ka mb mc mu kd me mf mv mh mi mj mw ml mm mn mx mp mq mr ij bi translated">由于<code class="fe nu nv nw nx b">fitness</code>应该与<code class="fe nu nv nw nx b">loss</code>成反比，我们将这样计算:</p><pre class="kp kq kr ks gt nz nx oa ob aw oc bi"><span id="dbc4" class="od lf iq nx b gy oe of l og oh">const carFitness = (params: GeometricParams): number =&gt; {<br/>  const loss = carLoss(params);<br/>  // Adding +1 to avoid a division by zero.<br/>  return 1 / (loss + 1);<br/>};</span></pre><p id="33d1" class="pw-post-body-paragraph lw lx iq ly b lz mt ka mb mc mu kd me mf mv mh mi mj mw ml mm mn mx mp mq mr ij bi translated">您可以在<a class="ae ms" href="https://trekhleb.dev/self-parking-car-evolution?parking=evolution#/" rel="noopener ugc nofollow" target="_blank">进化模拟器</a>仪表盘上看到特定基因组和当前汽车位置的<code class="fe nu nv nw nx b">fitness</code>和<code class="fe nu nv nw nx b">loss</code>值:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/5428c320226b38d5bf63440de653093a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HD9hzGGUQeA2W2fQGzJynA.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">进化模拟器仪表板截图</p></figure><h1 id="e9d9" class="le lf iq bd lg lh li lj lk ll lm ln lo kf lp kg lq ki lr kj ls kl lt km lu lv bi translated">启动进化</h1><p id="5030" class="pw-post-body-paragraph lw lx iq ly b lz ma ka mb mc md kd me mf mg mh mi mj mk ml mm mn mo mp mq mr ij bi translated">让我们把进化函数放在一起。我们将“创造世界”，启动进化循环，让时间前进，让一代人进化，让汽车学会如何停车。</p><p id="71c5" class="pw-post-body-paragraph lw lx iq ly b lz mt ka mb mc mu kd me mf mv mh mi mj mw ml mm mn mx mp mq mr ij bi translated">为了获得每辆车的适应值，我们需要在虚拟的3D世界中运行汽车行为的模拟。<a class="ae ms" href="https://trekhleb.dev/self-parking-car-evolution" rel="noopener ugc nofollow" target="_blank">进化模拟器</a>就是这么做的——它在模拟器中运行下面的代码，模拟器是用Three.js 制作的<a class="ae ms" href="https://github.com/trekhleb/self-parking-car-evolution" rel="noopener ugc nofollow" target="_blank">:</a></p><pre class="kp kq kr ks gt nz nx oa ob aw oc bi"><span id="d0ed" class="od lf iq nx b gy oe of l og oh">// Evolution setup example.<br/>// Configurable via the Evolution Simulator.<br/>const GENERATION_SIZE = 1000;<br/>const LONG_LIVING_CHAMPIONS_PERCENTAGE = 6;<br/>const MUTATION_PROBABILITY = 0.04;<br/>const MAX_GENERATIONS_NUM = 40;</span><span id="8420" class="od lf iq nx b gy oi of l og oh">// Fitness function.<br/>// It is like an annual doctor's checkup for the cars.<br/>const carFitnessFunction = (genome: Genome): number =&gt; {<br/>  // The evolution simulator calculates and stores the fitness values for each car in the fitnessValues map.<br/>  // Here we will just fetch the pre-calculated fitness value for the car in current generation.<br/>  const genomeKey = genome.join('');<br/>  return fitnessValues[genomeKey];<br/>};</span><span id="98a3" class="od lf iq nx b gy oi of l og oh">// Creating the "world" with the very first cars generation.<br/>let generationIndex = 0;<br/>let generation: Generation = createGeneration({<br/>  generationSize: GENERATION_SIZE,<br/>  genomeLength: GENOME_LENGTH, // &lt;- 180 genes<br/>});</span><span id="c17a" class="od lf iq nx b gy oi of l og oh">// Starting the "time".<br/>while(generationIndex &lt; MAX_GENERATIONS_NUM) {<br/>  // SIMULATION IS NEEDED HERE to pre-calculate the fitness values.</span><span id="f0b2" class="od lf iq nx b gy oi of l og oh">  // Selecting, mating, and mutating the current generation.<br/>  generation = select(<br/>    generation,<br/>    carFitnessFunction,<br/>    {<br/>      mutationProbability: MUTATION_PROBABILITY,<br/>      longLivingChampionsPercentage: LONG_LIVING_CHAMPIONS_PERCENTAGE,<br/>    },<br/>  );</span><span id="de95" class="od lf iq nx b gy oi of l og oh">  // Make the "time" go by.<br/>  generationIndex += 1;<br/>}</span><span id="b7cf" class="od lf iq nx b gy oi of l og oh">// Here we may check the fittest individuum of the latest generation.<br/>const fittestCar = generation[0];</span></pre><p id="4810" class="pw-post-body-paragraph lw lx iq ly b lz mt ka mb mc mu kd me mf mv mh mi mj mw ml mm mn mx mp mq mr ij bi translated">运行<code class="fe nu nv nw nx b">select()</code>函数后，<code class="fe nu nv nw nx b">generation</code>数组按照适合度值降序排序。因此，最合适的车将永远是数组中的第一辆车。</p><p id="1962" class="pw-post-body-paragraph lw lx iq ly b lz mt ka mb mc mu kd me mf mv mh mi mj mw ml mm mn mx mp mq mr ij bi translated"><strong class="ly ja">拥有随机基因组的第一代</strong>汽车将会有如下表现:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi my"><img src="../Images/7cfb20c202834cfeeb80bf83567f5edb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*8U_xR9D4NX0BzqJMqT0BsQ.gif"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">第一代汽车。作者制作的动画</p></figure><p id="420d" class="pw-post-body-paragraph lw lx iq ly b lz mt ka mb mc mu kd me mf mv mh mi mj mw ml mm mn mx mp mq mr ij bi translated"><strong class="ly ja">在第40代车型上</strong>汽车开始学习什么是自动泊车，并开始靠近泊车点:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi my"><img src="../Images/237f030840308cc734fb4913e3d0483e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*oP0_y0kyucPIcZp0mI0p6Q.gif"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">第40代车。作者制作的动画</p></figure><p id="0b7d" class="pw-post-body-paragraph lw lx iq ly b lz mt ka mb mc mu kd me mf mv mh mi mj mw ml mm mn mx mp mq mr ij bi translated">另一个例子更具挑战性:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi my"><img src="../Images/55d0908aa264ccab265f60fb305bcfdd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*z4em7FIKsDo38ZE8WDSWeA.gif"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">第40代车。作者制作的动画</p></figure><p id="2b51" class="pw-post-body-paragraph lw lx iq ly b lz mt ka mb mc mu kd me mf mv mh mi mj mw ml mm mn mx mp mq mr ij bi translated">这些车一路上撞上了其他一些车，也不完全适合停车点，但这只是自世界诞生以来它们的第40代，所以你可以给这些车一些时间来学习。</p><p id="743b" class="pw-post-body-paragraph lw lx iq ly b lz mt ka mb mc mu kd me mf mv mh mi mj mw ml mm mn mx mp mq mr ij bi translated">一代又一代，我们可能会看到损失值是如何下降的(这意味着适应值在上升)。<code class="fe nu nv nw nx b">P50 Avg Loss</code>显示最合适的<code class="fe nu nv nw nx b">50%</code>辆汽车的平均损失值(从汽车到停车位的平均距离)。<code class="fe nu nv nw nx b">Min Loss</code>显示每一代最适合的汽车的损失值。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi om"><img src="../Images/4e70a254212a22f215351bd5bcada128.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7dYsU23aOuAkZwJwoo8yhQ.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">损失历史。作者插图。</p></figure><p id="5494" class="pw-post-body-paragraph lw lx iq ly b lz mt ka mb mc mu kd me mf mv mh mi mj mw ml mm mn mx mp mq mr ij bi translated">你可能会看到，平均而言，这一代最健康的汽车中的<code class="fe nu nv nw nx b">50%</code>正在学习更靠近停车位(从远离停车位的<code class="fe nu nv nw nx b">5.5m</code>到35代中的<code class="fe nu nv nw nx b">3.5m</code>)。<code class="fe nu nv nw nx b">Min Loss</code>值的趋势不太明显(从<code class="fe nu nv nw nx b">1m</code>到<code class="fe nu nv nw nx b">0.5m</code>有一些噪声信号)，但是从上面的动画中你可以看到汽车已经学会了一些基本的停车动作。</p><h1 id="6de9" class="le lf iq bd lg lh li lj lk ll lm ln lo kf lp kg lq ki lr kj ls kl lt km lu lv bi translated">结论</h1><p id="b8c6" class="pw-post-body-paragraph lw lx iq ly b lz ma ka mb mc md kd me mf mg mh mi mj mk ml mm mn mo mp mq mr ij bi translated">在本文中，我们将创建自动泊车汽车的高级任务分解为寻找<code class="fe nu nv nw nx b">180</code>1和0的最佳组合(寻找最佳汽车基因组)的简单低级任务。</p><p id="23d2" class="pw-post-body-paragraph lw lx iq ly b lz mt ka mb mc mu kd me mf mv mh mi mj mw ml mm mn mx mp mq mr ij bi translated">然后我们应用遗传算法来寻找最佳的汽车基因组。它允许我们在几个小时的模拟中获得相当好的结果(而不是多年来运行这种幼稚的方法)。</p><p id="ce94" class="pw-post-body-paragraph lw lx iq ly b lz mt ka mb mc mu kd me mf mv mh mi mj mw ml mm mn mx mp mq mr ij bi translated">您可以启动🚕<a class="ae ms" href="https://trekhleb.dev/self-parking-car-evolution" rel="noopener ugc nofollow" target="_blank">自动泊车汽车进化模拟器</a>直接在浏览器中查看进化过程。模拟器为您提供了以下机会:</p><ul class=""><li id="3bd2" class="ng nh iq ly b lz mt mc mu mf ni mj nj mn nk mr nl nm nn no bi translated">您可以<a class="ae ms" href="https://trekhleb.dev/self-parking-car-evolution?parking=evolution#/" rel="noopener ugc nofollow" target="_blank">从头开始训练汽车</a>并自行调整遗传参数</li><li id="ee52" class="ng nh iq ly b lz np mc nq mf nr mj ns mn nt mr nl nm nn no bi translated">你可以<a class="ae ms" href="https://trekhleb.dev/self-parking-car-evolution?parking=automatic#/" rel="noopener ugc nofollow" target="_blank">看到训练过的自动泊车车在运行</a></li><li id="badb" class="ng nh iq ly b lz np mc nq mf nr mj ns mn nt mr nl nm nn no bi translated">您也可以<a class="ae ms" href="https://trekhleb.dev/self-parking-car-evolution?parking=manual#/" rel="noopener ugc nofollow" target="_blank">尝试手动泊车</a></li></ul><p id="ffbb" class="pw-post-body-paragraph lw lx iq ly b lz mt ka mb mc mu kd me mf mv mh mi mj mw ml mm mn mx mp mq mr ij bi translated">本文中展示的完整遗传源代码也可以在<a class="ae ms" href="https://github.com/trekhleb/self-parking-car-evolution" rel="noopener ugc nofollow" target="_blank">进化模拟库</a>中找到。如果你是那些真正会数并检查行数以确保少于500行(不包括测试)的人之一，请随意检查这里的代码<a class="ae ms" href="https://github.com/trekhleb/self-parking-car-evolution/tree/master/src/libs" rel="noopener ugc nofollow" target="_blank">🥸.</a></p><p id="7a8a" class="pw-post-body-paragraph lw lx iq ly b lz mt ka mb mc mu kd me mf mv mh mi mj mw ml mm mn mx mp mq mr ij bi translated">代码和模拟器仍有一些未解决的问题:</p><ul class=""><li id="02b7" class="ng nh iq ly b lz mt mc mu mf ni mj nj mn nk mr nl nm nn no bi translated">汽车的大脑过于简单，它使用线性方程，而不是神经网络。这使得汽车不能适应新的环境或新的停车场类型。</li><li id="08e2" class="ng nh iq ly b lz np mc nq mf nr mj ns mn nt mr nl nm nn no bi translated">当一辆车撞上另一辆车时，我们不会降低它的适应值。因此，汽车在制造交通事故时没有“感觉”到任何罪恶感。</li><li id="5726" class="ng nh iq ly b lz np mc nq mf nr mj ns mn nt mr nl nm nn no bi translated">进化模拟器不稳定。这意味着相同的汽车基因组可能产生不同的适应值，这使得进化效率更低。</li><li id="6aea" class="ng nh iq ly b lz np mc nq mf nr mj ns mn nt mr nl nm nn no bi translated">evolution模拟器在性能方面也非常笨重，因为我们无法一次性训练1000辆汽车，所以会减慢进化进度。</li><li id="c788" class="ng nh iq ly b lz np mc nq mf nr mj ns mn nt mr nl nm nn no bi translated">此外，Evolution Simulator要求浏览器选项卡处于打开和活动状态，以执行模拟。</li><li id="5c94" class="ng nh iq ly b lz np mc nq mf nr mj ns mn nt mr nl nm nn no bi translated">还有<a class="ae ms" href="https://github.com/trekhleb/self-parking-car-evolution/issues" rel="noopener ugc nofollow" target="_blank">更</a> …</li></ul><p id="7882" class="pw-post-body-paragraph lw lx iq ly b lz mt ka mb mc mu kd me mf mv mh mi mj mw ml mm mn mx mp mq mr ij bi translated">然而，本文的目的是在学习遗传算法如何工作的同时获得一些乐趣，而不是构建一个生产就绪的自动停车特斯拉。所以，即使有上面提到的问题，我还是希望您能愉快地阅读这篇文章。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/d0ded58baa97f405218cfef40b7b1a8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LbOuq67ZSLTAvfTzYcQrCQ.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">作者插图</p></figure></div></div>    
</body>
</html>