<html>
<head>
<title>Linear Regression and Gradient Descent Using Only Numpy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">仅使用Numpy的线性回归和梯度下降</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/linear-regression-and-gradient-descent-using-only-numpy-53104a834f75?source=collection_archive---------9-----------------------#2021-12-08">https://towardsdatascience.com/linear-regression-and-gradient-descent-using-only-numpy-53104a834f75?source=collection_archive---------9-----------------------#2021-12-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/654fbd7ac88727c76b5e34f021c210e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*SejC_kLye88MpNOy"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">在<a class="ae jd" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae jd" href="https://unsplash.com/@writecodenow?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Boitumelo Phetla </a>拍摄的照片</p></figure><div class=""/><div class=""><h2 id="ea55" class="pw-subtitle-paragraph kd jf jg bd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dk translated">了解如何从头开始实现线性回归模型！</h2></div><p id="c2f6" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果你正在学习机器学习，你可能已经了解了线性回归模型和梯度下降算法。问题是这些通常是使用sklearn这样的高级库来实现的，所以真正的工作仍然有点神秘。让我们发现从头开始编写代码的真正工作原理！</p><h2 id="bc20" class="lr ls jg bd lt lu lv dn lw lx ly dp lz le ma mb mc li md me mf lm mg mh mi mj bi translated">线性回归的目的是什么？</h2><p id="2e00" class="pw-post-body-paragraph kv kw jg kx b ky mk kh la lb ml kk ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">假设您有一个包含1000条记录的数据集，每条记录由5个要素组成。这个数据集可以非常简单地用一个<em class="mp"> 1000x5 </em>矩阵来表示。对于这些记录中的每一个<em class="mp"> X(i) </em>你也有一个相关的输出<em class="mp"> y(i) </em>，所以<em class="mp"> y </em>这一组输出可以简单地用一个大小为1000的向量来表示。</p><p id="ec74" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果我们在一个平面上绘制数据集，假设我们只有一个特征而不是5个，我们可以说我们的目标是找到一条线<strong class="kx jh"> <em class="mp"> y = mX +q </em> </strong>以这样一种方式与我们的数据相交，即数据集的各个点离发现的线不太远。</p><figure class="mr ms mt mu gt is gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/7eac7bcb7a99623c9ca958f4d386b9fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1102/format:webp/1*qaIfpJ52yn_R66qIJzhSOQ.png"/></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">作者图片</p></figure><p id="8fd0" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">观察一下，在我们要查找的行中，<em class="mp"> X </em>因为是我们的数据集而已知，所以<strong class="kx jh">隐藏参数</strong>只有<strong class="kx jh"> <em class="mp"> m </em> </strong> <em class="mp"> </em>和<strong class="kx jh"> <em class="mp"> q </em> </strong>。在更多的维度中，因此具有更多的特征，我们不应该找到一条线，但是一个<em class="mp">超平面</em>和<em class="mp"> m </em>和<em class="mp"> q </em>将是具有与特征数量一样多的条目的向量。</p><p id="09f6" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">更正式地说，要最小化的点与线的距离通过一个称为均方误差(MSE)的函数来测量，该函数由以下公式给出:</p><figure class="mr ms mt mu gt is gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/6e7a4b72d311c80f937853eab8913f65.png" data-original-src="https://miro.medium.com/v2/resize:fit:898/format:webp/1*WB4TJcQ0YC3Oam7f8mU6Ig.png"/></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">作者图片</p></figure><p id="4b04" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这个公式告诉我们的是，我们实际上想要最小化每个点到直线的平均平方距离。</p><p id="b504" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在公式中，y_i是已知的输出，由于<em class="mp"> ŷ_i </em>是由线给出的，我们想要找到ŷ_i <em class="mp"> = mX +q </em>，为了最小化这个函数，我们只需要找到最佳参数<em class="mp"> m </em>和<em class="mp"> q </em>。所以我们可以说<strong class="kx jh"> <em class="mp"> MSE </em> </strong>是一个依赖于两个参数<em class="mp"> m </em>和<em class="mp"> q </em> : <strong class="kx jh"> <em class="mp"> F(m，q) </em> </strong>的函数F</p><p id="9847" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">一旦我们找到这些参数，我们就可以进行一些预测，对于每个新记录，我们可以知道相关的输出是什么。</p><h2 id="eeb7" class="lr ls jg bd lt lu lv dn lw lx ly dp lz le ma mb mc li md me mf lm mg mh mi mj bi translated">梯度下降寻找隐藏参数</h2><p id="2a45" class="pw-post-body-paragraph kv kw jg kx b ky mk kh la lb ml kk ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">让我们用图形表示MSE(成本函数)。</p><figure class="mr ms mt mu gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mw"><img src="../Images/13d76dd3b1d440227356af4f19df9e3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9zRTIyB6R-HkLt8FEJJ6vQ.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">作者图片</p></figure><p id="0ec3" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">由于我们忽略了哪些参数使成本函数最小化，<em class="mp"> m </em>和<em class="mp"> q </em>将被随机初始化。因此，首先我们将在成本函数中的任何一点(见图表)。我们的目标是每次更新参数<em class="mp">θ=【m，q】</em>，以便找到成本函数的最小值<strong class="kx jh">，这保证了平均而言数据集的点不会离找到的线太远。</strong></p><p id="fdf8" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">梯度下降(<strong class="kx jh"> GD </strong>)算法简单地告诉我们这个更新必须遵循规则:</p><p id="49b6" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx jh"> θ = θ - α∇F(θ) </strong></p><p id="ae23" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">其中α <em class="mp"> </em>是称为学习率的先验选择数，而<em class="mp">【∇f(θ】</em>是一个向量，其中每个条目包含成本函数<em class="mp"> F </em>相对于<em class="mp"> θ </em>中的参数的偏导数。</p><p id="7f18" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因此让我们来计算这些偏导数。</p><figure class="mr ms mt mu gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mx"><img src="../Images/531258bfed3b1b04b74343fb8be8418a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1292/format:webp/1*iVHV8Y6ZMia_IjRS_Z1hqg.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">作者图片</p></figure><p id="07a6" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">太好了！作为最后一个技巧，我们从公式中注意到，只有在对所有n条记录求和之后，也就是在遍历了数据集的所有记录之后，我们才应该更新参数<em class="mp"> θ </em>。但是由于数据集通常很大，我们只能累加到数字<em class="mp"> k </em>并立即执行参数更新，然后继续更新缺失的记录。所以<em class="mp"> k </em>称为<strong class="kx jh"> <em class="mp">批次大小</em> </strong> <em class="mp"> </em>和定时取出的<em class="mp"> k </em>元素集合称为<strong class="kx jh"> <em class="mp">批次</em> </strong>。当你用尽所有可用的批次时，它完成了所谓的<strong class="kx jh"> <em class="mp">时期</em> </strong>。如果我想改善你对参数<em class="mp"> θ </em>的估计，你可以从新开始。</p><h2 id="537e" class="lr ls jg bd lt lu lv dn lw lx ly dp lz le ma mb mc li md me mf lm mg mh mi mj bi translated">在Numpy中实现</h2><p id="cc5c" class="pw-post-body-paragraph kv kw jg kx b ky mk kh la lb ml kk ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">让我们导入numpy，创建一个包含5个特性的随机数据集，并随机创建我们需要发现的<em class="mp"> m </em>和<em class="mp"> q </em>。我们还生成由线性关系给出的实际输出，并在其中添加一些噪声。</p><figure class="mr ms mt mu gt is"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="e147" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">请注意，无需区分m和q，注意输出为:</p><p id="80ad" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="mp">y = m1x 1+MW x2+m3x 3+m4x 4+m5x 5+q</em></p><p id="300a" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">但这和写作是一样的</p><p id="26e7" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="mp">y = m1x 1+MW x2+m3x 3+M4 x4+m5x 5+m6x 6</em></p><p id="7cb1" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">前提是<em class="mp"> m6 = q </em>和<em class="mp"> X6 </em>始终等于<em class="mp"> 1 </em>。</p><p id="f89b" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然后，我们需要添加一个“1”的特性，将它与我们已经拥有的数据集连接起来，并将<em class="mp"> q </em>添加到矢量<em class="mp"> m </em>中。</p><figure class="mr ms mt mu gt is"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="b36e" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们编写一个函数，它只计算相对于<em class="mp"> m </em>的偏导数的值(因为我们去掉了<em class="mp"> q </em>，它必须将原始参数的估计值<em class="mp"> m_stat </em>作为输入</p><figure class="mr ms mt mu gt is"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="d5d5" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们还需要定义MSE函数</p><figure class="mr ms mt mu gt is"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="e8c4" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在训练函数中，我们不断更新参数。第一个for循环遍历我们设置的历元数，而第二个嵌套的for循环遍历一个历元的所有批次。请注意，对于每个时期来说，打乱数据是很重要的！</p><figure class="mr ms mt mu gt is"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="cdbd" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们设置超参数并估计参数</p><figure class="mr ms mt mu gt is"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="f84b" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果我们打印估计的参数和原始参数，我们会发现它们几乎相同，所以我们找到了生成输出的原始行！现在我可以用这条线对新的测试数据进行预测。</p><figure class="mr ms mt mu gt is"><div class="bz fp l di"><div class="my mz l"/></div></figure><h2 id="0a6d" class="lr ls jg bd lt lu lv dn lw lx ly dp lz le ma mb mc li md me mf lm mg mh mi mj bi translated">结论</h2><p id="4fae" class="pw-post-body-paragraph kv kw jg kx b ky mk kh la lb ml kk ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">基于线性回归的模型解释起来相对简单，并且在生成预测时非常有用。线性回归可以应用于从医疗保健到商业的各个领域。在高级机器学习中，例如在文本分类中，线性模型仍然非常重要，尽管还有其他更好的模型。这是因为线性模型非常“稳定”，它不太可能太符合数据。线性回归的一个演变是<strong class="kx jh">多项式回归</strong>，这是一个更复杂的模型，也可以适合引入更复杂特征的非线性数据集，请查看这里:<a class="ae jd" href="https://en.wikipedia.org/wiki/Polynomial_regression" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Polynomial_regression</a>。</p><h2 id="bb48" class="lr ls jg bd lt lu lv dn lw lx ly dp lz le ma mb mc li md me mf lm mg mh mi mj bi translated">结束了</h2><p id="10e9" class="pw-post-body-paragraph kv kw jg kx b ky mk kh la lb ml kk ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">作者:<em class="mp">马赛洛·波利蒂</em></p><p id="dcf8" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><a class="ae jd" href="https://www.linkedin.com/in/marcello-politi/" rel="noopener ugc nofollow" target="_blank"> Linkedin </a>，<a class="ae jd" href="https://twitter.com/_March08_" rel="noopener ugc nofollow" target="_blank"> Twitter </a></p></div></div>    
</body>
</html>