<html>
<head>
<title>Generating Parameterized Powerpoint Documents in Python and R</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Python和R生成参数化的Powerpoint文档</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/generating-parameterized-powerpoint-documents-in-python-and-r-333368479038?source=collection_archive---------3-----------------------#2021-03-29">https://towardsdatascience.com/generating-parameterized-powerpoint-documents-in-python-and-r-333368479038?source=collection_archive---------3-----------------------#2021-03-29</a></blockquote><div><div class="fc ij ik il im in"/><div class="io ip iq ir is"><div class=""/><div class=""><h2 id="37bb" class="pw-subtitle-paragraph js iu iv bd b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj dk translated">通过自动生成Powerpoint控制您的报告工作流程</h2></div><p id="d082" class="pw-post-body-paragraph kk kl iv km b kn ko jw kp kq kr jz ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">许多商业报告领域的数据科学家被要求将他们的数据转换成Powerpoint演示文稿(不管他们喜不喜欢！).最常见的是许多参数化的演示，其中格式、图表和内容都是相同的，但数据会发生变化，例如按组织单位。经常需要从指定的示例模板生成数十、数百甚至数千个这样的报告。本教程给出了一个如何编写和自动化这样一个工作流的例子。</p><p id="32b0" class="pw-post-body-paragraph kk kl iv km b kn ko jw kp kq kr jz ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">本教程的所有代码都可以在我的<a class="ae lg" href="https://github.com/keithmcnulty/ppt-generation" rel="noopener ugc nofollow" target="_blank"> Github repo </a>中找到，整篇文章都引用了它。</p><h1 id="2e24" class="lh li iv bd lj lk ll lm ln lo lp lq lr kb ls kc lt ke lu kf lv kh lw ki lx ly bi translated">背景和先决条件</h1><p id="a37e" class="pw-post-body-paragraph kk kl iv km b kn lz jw kp kq ma jz ks kt mb kv kw kx mc kz la lb md ld le lf io bi translated">本教程涉及以下场景:</p><ul class=""><li id="5ba9" class="me mf iv km b kn ko kq kr kt mg kx mh lb mi lf mj mk ml mm bi translated">用户群需要以包含图表和表格的可编辑Powerpoint文档的形式交付结果。</li><li id="b743" class="me mf iv km b kn mn kq mo kt mp kx mq lb mr lf mj mk ml mm bi translated">存在完全填充有虚拟数据或示例数据的示例文档。</li><li id="b9ee" class="me mf iv km b kn mn kq mo kt mp kx mq lb mr lf mj mk ml mm bi translated">同一文档需要用不同组的不同数据重新创建，并用不同的文件名保存，以便在整个组织内分发。该工作流有助于创建任意数量的这种参数化文档。</li></ul><p id="3f0b" class="pw-post-body-paragraph kk kl iv km b kn ko jw kp kq kr jz ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">使用开源技术，这个工作流程是完全可执行的。对于Python中的执行，建议使用基于Python 3.7的conda环境或虚拟环境，并安装<code class="fe ms mt mu mv b">pandas</code>和<code class="fe ms mt mu mv b">python-pptx</code>包。为了进口到R，将需要<code class="fe ms mt mu mv b">reticulate</code>包。</p><p id="ce60" class="pw-post-body-paragraph kk kl iv km b kn ko jw kp kq kr jz ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">本教程分为三个部分:</p><ol class=""><li id="8f63" class="me mf iv km b kn ko kq kr kt mg kx mh lb mi lf mw mk ml mm bi translated">如何使用<code class="fe ms mt mu mv b">python-pptx</code>包编写一个函数来替换现有Powerpoint演示文稿中的数据。</li><li id="da9a" class="me mf iv km b kn mn kq mo kt mp kx mq lb mr lf mw mk ml mm bi translated">如何在Python中使用它来批量生成任意数量的参数化Powerpoint文档。</li><li id="72de" class="me mf iv km b kn mn kq mo kt mp kx mq lb mr lf mw mk ml mm bi translated">如何将函数导入到R中，并使用tidyverse批量生成任意数量的参数化Powerpoint文档。</li></ol><h1 id="ee89" class="lh li iv bd lj lk ll lm ln lo lp lq lr kb ls kc lt ke lu kf lv kh lw ki lx ly bi translated">入门指南</h1><p id="cc8a" class="pw-post-body-paragraph kk kl iv km b kn lz jw kp kq ma jz ks kt mb kv kw kx mc kz la lb md ld le lf io bi translated">假设我们为一个组织工作，该组织由20个销售小组组成，从A组到t组依次命名。一个名为<code class="fe ms mt mu mv b">ppt-template.pptx</code>的现有Powerpoint文档存在于回购的<code class="fe ms mt mu mv b">templates</code>文件夹中，其中的虚拟数据包含以下内容:</p><ul class=""><li id="48f7" class="me mf iv km b kn ko kq kr kt mg kx mh lb mi lf mj mk ml mm bi translated">一个标题页，我们希望根据特定的销售组名称对其进行定制。</li><li id="ed68" class="me mf iv km b kn mn kq mo kt mp kx mq lb mr lf mj mk ml mm bi translated">包含两个图表(条形图和饼图)的页面。我们将需要替换数据并重新命名这两个图表，以引用特定的销售组。</li><li id="c496" class="me mf iv km b kn mn kq mo kt mp kx mq lb mr lf mj mk ml mm bi translated">带有销售数据表的页面。我们希望用特定销售组的数据替换该表中的数据。</li></ul><figure class="my mz na nb gt nc gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi mx"><img src="../Images/c32445e4d36bcefc8e2b029390774f82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*g9TEtN3UcBXRlYCZ.png"/></div></div><p class="nj nk gj gh gi nl nm bd b be z dk translated">我们需要编辑的幻灯片(作者生成)</p></figure><p id="3d8b" class="pw-post-body-paragraph kk kl iv km b kn ko jw kp kq kr jz ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">我们需要替换到该文档中的数据可以在<code class="fe ms mt mu mv b">data</code>文件夹中找到。这是出于演示目的随机生成的数据。文件<code class="fe ms mt mu mv b">chart_df.csv</code>包含条形图和饼图的数据，以<code class="fe ms mt mu mv b">table_</code>为前缀的各种文件包含每个销售组的数据，这些数据将放入最后一张幻灯片的表格中。</p><h1 id="97fa" class="lh li iv bd lj lk ll lm ln lo lp lq lr kb ls kc lt ke lu kf lv kh lw ki lx ly bi translated">使用<code class="fe ms mt mu mv b">python-pptx</code>包替换Powerpoint演示文稿的元素</h1><p id="7ae4" class="pw-post-body-paragraph kk kl iv km b kn lz jw kp kq ma jz ks kt mb kv kw kx mc kz la lb md ld le lf io bi translated">我们从Python开始，从<code class="fe ms mt mu mv b">python-pptx</code>包中导入一些我们需要的函数。在这个例子中，我们只需要几个简单的函数，但是我鼓励您探索这个包中广泛可用的函数来编辑和定制Powerpoint元素。</p><pre class="my mz na nb gt nn mv no np aw nq bi"><span id="025a" class="nr li iv mv b gy ns nt l nu nv">from pptx import Presentation<br/>from pptx.chart.data import CategoryChartData</span></pre><p id="871c" class="pw-post-body-paragraph kk kl iv km b kn ko jw kp kq kr jz ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">接下来，我们将现有的虚拟演示加载到Python会话中:</p><pre class="my mz na nb gt nn mv no np aw nq bi"><span id="2627" class="nr li iv mv b gy ns nt l nu nv">pres = Presentation("templates/ppt-template.pptx")</span></pre><p id="913e" class="pw-post-body-paragraph kk kl iv km b kn ko jw kp kq kr jz ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">通过检查<code class="fe ms mt mu mv b">pres</code>，我们可以看到它是一个Powerpoint演示对象。</p><pre class="my mz na nb gt nn mv no np aw nq bi"><span id="3814" class="nr li iv mv b gy ns nt l nu nv">pres</span><span id="b963" class="nr li iv mv b gy nw nt l nu nv">## &lt;pptx.presentation.Presentation object at 0x7fb40af62140&gt;</span></pre><p id="953a" class="pw-post-body-paragraph kk kl iv km b kn ko jw kp kq kr jz ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated"><code class="fe ms mt mu mv b">pres</code>实际上是一个复杂的嵌套XML对象。但是正如你所料，它包含了一些幻灯片。我们可以创建一个幻灯片列表，并检查该列表是否包含我们期望的三张幻灯片。</p><pre class="my mz na nb gt nn mv no np aw nq bi"><span id="a7ec" class="nr li iv mv b gy ns nt l nu nv">slides = [slide for slide in pres.slides]<br/>len(slides)</span><span id="1787" class="nr li iv mv b gy nw nt l nu nv">## 3</span></pre><p id="123d" class="pw-post-body-paragraph kk kl iv km b kn ko jw kp kq kr jz ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">看起来不错。现在，每张幻灯片都包含一些形状，可以是从文本框到图表、表格或图示的任何形状。</p><h1 id="e958" class="lh li iv bd lj lk ll lm ln lo lp lq lr kb ls kc lt ke lu kf lv kh lw ki lx ly bi translated">编辑形状中的文本框</h1><p id="91ef" class="pw-post-body-paragraph kk kl iv km b kn lz jw kp kq ma jz ks kt mb kv kw kx mc kz la lb md ld le lf io bi translated">让我们看看标题幻灯片上有多少个形状:</p><pre class="my mz na nb gt nn mv no np aw nq bi"><span id="fe11" class="nr li iv mv b gy ns nt l nu nv">slide0 = slides[0]<br/>slide0_shapes = [shape for shape in slide0.shapes]<br/>len(slide0_shapes)</span><span id="41cd" class="nr li iv mv b gy nw nt l nu nv">## 3</span></pre><p id="c0fa" class="pw-post-body-paragraph kk kl iv km b kn ko jw kp kq kr jz ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">所以标题幻灯片上有三个形状。我们知道其中一个是标题占位符文本框，另一个是副标题占位符文本框，我们可以识别并抓取它们，因为它们都包含一个<code class="fe ms mt mu mv b">text_frame</code>(文本框的XML术语)。</p><pre class="my mz na nb gt nn mv no np aw nq bi"><span id="173a" class="nr li iv mv b gy ns nt l nu nv">title_shapes = [shape for shape in slide0.shapes if shape.has_text_frame]<br/>len(title_shapes)</span><span id="c1cc" class="nr li iv mv b gy nw nt l nu nv">## 2</span></pre><p id="21af" class="pw-post-body-paragraph kk kl iv km b kn ko jw kp kq kr jz ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">现在，由于这些是占位符对象，占位符文本可能会由于模板格式而与模板中的可见内容不匹配，因此我们需要查看每个占位符的文本:</p><pre class="my mz na nb gt nn mv no np aw nq bi"><span id="17ab" class="nr li iv mv b gy ns nt l nu nv">placeholder_text = [shape.text for shape in title_shapes if shape.has_text_frame]<br/>placeholder_text</span><span id="0f34" class="nr li iv mv b gy nw nt l nu nv">## ['Presentation title Alt', 'Subtitle comes here']</span></pre><p id="2f48" class="pw-post-body-paragraph kk kl iv km b kn ko jw kp kq kr jz ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">我们现在可以使用这些信息来替换这些文本框中的文本。让我们对A组演示文稿的标题文本也这样做，以检查它是否有效:</p><pre class="my mz na nb gt nn mv no np aw nq bi"><span id="cbdd" class="nr li iv mv b gy ns nt l nu nv">title = [shape for shape in title_shapes if shape.has_text_frame and shape.text == 'Presentation title Alt']<br/>title[0]. text = "Presentation for Group A"</span></pre><p id="3f3a" class="pw-post-body-paragraph kk kl iv km b kn ko jw kp kq kr jz ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">我们可以检查这是否有效:</p><pre class="my mz na nb gt nn mv no np aw nq bi"><span id="452d" class="nr li iv mv b gy ns nt l nu nv">new_placeholder_text = [shape.text for shape in title_shapes if shape.has_text_frame]<br/>new_placeholder_text</span><span id="54a0" class="nr li iv mv b gy nw nt l nu nv">## ['Presentation for Group A', 'Subtitle comes here']</span></pre><p id="c8a2" class="pw-post-body-paragraph kk kl iv km b kn ko jw kp kq kr jz ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">成功了！我们可以用类似的方法来编辑字幕。</p><h1 id="56b2" class="lh li iv bd lj lk ll lm ln lo lp lq lr kb ls kc lt ke lu kf lv kh lw ki lx ly bi translated">将新数据加载到图表中</h1><p id="6f88" class="pw-post-body-paragraph kk kl iv km b kn lz jw kp kq ma jz ks kt mb kv kw kx mc kz la lb md ld le lf io bi translated">我们可以使用形状的<code class="fe ms mt mu mv b">has_chart</code>属性来识别图表对象。让我们检查一下第二张幻灯片上是否有两张图表:</p><pre class="my mz na nb gt nn mv no np aw nq bi"><span id="779c" class="nr li iv mv b gy ns nt l nu nv">slide1 = slides[1]<br/>slide1_charts = [shape for shape in slide1.shapes if shape.has_chart]<br/>len(slide1_charts)</span><span id="1509" class="nr li iv mv b gy nw nt l nu nv">## 2</span></pre><p id="e751" class="pw-post-body-paragraph kk kl iv km b kn ko jw kp kq kr jz ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">我们不能完全确定这些图表是按照它们在幻灯片上出现的顺序排列的，但是我们可以通过标题来识别特定的图表，标题嵌套在chart对象的标题文本框架中。</p><pre class="my mz na nb gt nn mv no np aw nq bi"><span id="4533" class="nr li iv mv b gy ns nt l nu nv">bar_chart = [shape.chart for shape in slide1_charts if shape.chart.chart_title.text_frame.text == 'Statistics here']</span></pre><p id="a587" class="pw-post-body-paragraph kk kl iv km b kn ko jw kp kq kr jz ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">现在我们有了条形图，我们需要重写它的数据。我们注意到条形图有三个系列的条，每个代表四个类别中的一个。当我们重写此图表中的数据时，我们需要重写所有数据—不可能只重写其中的一部分。因此，我们从头开始定义类别，并将三个系列的数据写入一个<code class="fe ms mt mu mv b">CategoryChartData</code>对象。这里我就用一些随机的例子数据来说明。</p><pre class="my mz na nb gt nn mv no np aw nq bi"><span id="ca90" class="nr li iv mv b gy ns nt l nu nv">chart_data  = CategoryChartData()<br/>chart_data.categories = ['Category ' + str(i) for i in range(1,5)]<br/>chart_data.add_series('Series 1', range(1, 5))</span><span id="4c73" class="nr li iv mv b gy nw nt l nu nv">## &lt;pptx.chart.data.CategorySeriesData object at 0x7fb40b15df50&gt;</span><span id="5df3" class="nr li iv mv b gy nw nt l nu nv">chart_data.add_series('Series 2', range(2, 6))</span><span id="2174" class="nr li iv mv b gy nw nt l nu nv">## &lt;pptx.chart.data.CategorySeriesData object at 0x7fb40af9bc50&gt;</span><span id="047b" class="nr li iv mv b gy nw nt l nu nv">chart_data.add_series('Series 3', range(3, 7))</span><span id="9577" class="nr li iv mv b gy nw nt l nu nv">## &lt;pptx.chart.data.CategorySeriesData object at 0x7fb40af9bf90&gt;</span></pre><p id="3084" class="pw-post-body-paragraph kk kl iv km b kn ko jw kp kq kr jz ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">我们现在用这个数据替换条形图中的数据，并给它一个新的标题。</p><pre class="my mz na nb gt nn mv no np aw nq bi"><span id="1ef5" class="nr li iv mv b gy ns nt l nu nv">bar_chart[0].replace_data(chart_data)<br/>bar_chart[0].chart_title.text_frame.text = "Sales by Category: Group A"</span></pre><p id="ebc8" class="pw-post-body-paragraph kk kl iv km b kn ko jw kp kq kr jz ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">此时，我们可以保存我们的演示文稿并查看其中一页，看看这是否有效。</p><pre class="my mz na nb gt nn mv no np aw nq bi"><span id="58eb" class="nr li iv mv b gy ns nt l nu nv">pres.save("test1.pptx")</span></pre><p id="5e77" class="pw-post-body-paragraph kk kl iv km b kn ko jw kp kq kr jz ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">通过检查第二张幻灯片，我们可以看到我们的条形图已经成功地用新数据进行了更新。</p><figure class="my mz na nb gt nc gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi nx"><img src="../Images/7e6756d2d216c46908f7702e6904e6ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*3irCbv4Bu0bhDR9D.png"/></div></div><p class="nj nk gj gh gi nl nm bd b be z dk translated">条形图已成功更新(作者生成)</p></figure><p id="ba21" class="pw-post-body-paragraph kk kl iv km b kn ko jw kp kq kr jz ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">使用类似的方法，我们也能够更新这张幻灯片的饼图和标题。</p><h1 id="b9fb" class="lh li iv bd lj lk ll lm ln lo lp lq lr kb ls kc lt ke lu kf lv kh lw ki lx ly bi translated">编辑表格</h1><p id="68c0" class="pw-post-body-paragraph kk kl iv km b kn lz jw kp kq ma jz ks kt mb kv kw kx mc kz la lb md ld le lf io bi translated">让我们使用与获取图表和文本框类似的方法获取上一张幻灯片中的表格。我们只想要一张桌子。</p><pre class="my mz na nb gt nn mv no np aw nq bi"><span id="eff3" class="nr li iv mv b gy ns nt l nu nv">slide2 = pres.slides[2]<br/>table = [shape for shape in slide2.shapes if shape.has_table]<br/>len(table)</span><span id="44ae" class="nr li iv mv b gy nw nt l nu nv">## 1</span></pre><p id="d5ca" class="pw-post-body-paragraph kk kl iv km b kn ko jw kp kq kr jz ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">太好了！现在表格需要一个单元格一个单元格地编辑，这听起来很痛苦，但实际上使用索引很容易。我们注意到有一行列名，然后是八行数据，然后是一行总计。让我们从数据集中引入一个表格。</p><pre class="my mz na nb gt nn mv no np aw nq bi"><span id="cea4" class="nr li iv mv b gy ns nt l nu nv">import pandas as pd<br/>table_A = pd.read_csv("data/table_A.csv")<br/>table_A</span><span id="c2d9" class="nr li iv mv b gy nw nt l nu nv">##      A    B    C    D    E<br/>## 0  2.2  4.8  0.9  5.1  5.4<br/>## 1  3.1  4.4  3.4  4.0  3.8<br/>## 2  1.6  3.8  4.3  6.0  2.7<br/>## 3  5.4  5.1  0.7  0.3  2.8<br/>## 4  4.8  2.1  5.0  2.9  2.1<br/>## 5  5.3  5.8  3.9  5.5  4.1<br/>## 6  2.4  4.9  1.9  5.7  5.8<br/>## 7  4.7  3.1  3.7  1.3  0.6</span></pre><p id="940a" class="pw-post-body-paragraph kk kl iv km b kn ko jw kp kq kr jz ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">现在我们的表的第一行是一组列名，所以我们可以编辑文本以匹配我们的<code class="fe ms mt mu mv b">table_A</code>数据框架中的列名:</p><pre class="my mz na nb gt nn mv no np aw nq bi"><span id="8a53" class="nr li iv mv b gy ns nt l nu nv">for j in range(0,5):<br/>    table[0].table.cell(0, j).text = "Product " +    table_A.columns.values[j]</span></pre><p id="91d3" class="pw-post-body-paragraph kk kl iv km b kn ko jw kp kq kr jz ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">然后，我们可以直接从数据框中更新每个单元格中的值:</p><pre class="my mz na nb gt nn mv no np aw nq bi"><span id="4b41" class="nr li iv mv b gy ns nt l nu nv">for i in range(1,9):<br/>    for j in range(0,5):<br/>      table[0].table.cell(i,j).text = str(table_A.iloc[i-1, j])</span></pre><p id="7010" class="pw-post-body-paragraph kk kl iv km b kn ko jw kp kq kr jz ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">最后，我们将一些总数放在最后一行(确保我们格式化以避免任何Python的浮点行为):</p><pre class="my mz na nb gt nn mv no np aw nq bi"><span id="b2a9" class="nr li iv mv b gy ns nt l nu nv">for j in range(0,5):<br/>    table[0].table.cell(9,j).text = "{:.1f}".format(sum(table_A.iloc[:,j]))</span></pre><p id="c82a" class="pw-post-body-paragraph kk kl iv km b kn ko jw kp kq kr jz ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">让我们再次保存并检查该表是否更新了新数据:</p><pre class="my mz na nb gt nn mv no np aw nq bi"><span id="ca05" class="nr li iv mv b gy ns nt l nu nv">pres.save("test2.pptx")</span></pre><p id="a405" class="pw-post-body-paragraph kk kl iv km b kn ko jw kp kq kr jz ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">经过检查，我们似乎成功地更新了该表:</p><figure class="my mz na nb gt nc gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi ny"><img src="../Images/4cf1b8a9908014575ce89823be4e26a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*NxN6x_OF6fGsuE6K.png"/></div></div><p class="nj nk gj gh gi nl nm bd b be z dk translated">该表已成功更新(由作者生成)</p></figure><h1 id="804d" class="lh li iv bd lj lk ll lm ln lo lp lq lr kb ls kc lt ke lu kf lv kh lw ki lx ly bi translated">创建一个函数来更新演示</h1><p id="ab6d" class="pw-post-body-paragraph kk kl iv km b kn lz jw kp kq ma jz ks kt mb kv kw kx mc kz la lb md ld le lf io bi translated">既然我们已经了解了编辑此演示文稿的基本知识，我们可以通过编写一个Python函数来实现这一切，该函数需要五个输入，如下所示:</p><ul class=""><li id="13af" class="me mf iv km b kn ko kq kr kt mg kx mh lb mi lf mj mk ml mm bi translated"><code class="fe ms mt mu mv b">group</code>:单据的集团参数。</li><li id="3e11" class="me mf iv km b kn mn kq mo kt mp kx mq lb mr lf mj mk ml mm bi translated"><code class="fe ms mt mu mv b">data_chart</code>:包含各种图表统计数据的数据帧</li><li id="cb50" class="me mf iv km b kn mn kq mo kt mp kx mq lb mr lf mj mk ml mm bi translated"><code class="fe ms mt mu mv b">data_table</code>:用来替换表格的数据帧</li><li id="fbe7" class="me mf iv km b kn mn kq mo kt mp kx mq lb mr lf mj mk ml mm bi translated"><code class="fe ms mt mu mv b">input file</code>:待编辑文件的路径</li><li id="cf54" class="me mf iv km b kn mn kq mo kt mp kx mq lb mr lf mj mk ml mm bi translated"><code class="fe ms mt mu mv b">output_file</code>:新文件将被写入的路径</li></ul><p id="ec52" class="pw-post-body-paragraph kk kl iv km b kn ko jw kp kq kr jz ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">你可以在回购的<code class="fe ms mt mu mv b">edit_pres.py</code>文件中看到这个函数。让我们找到这个函数，并通过为销售组m生成一个文档来测试它。</p><pre class="my mz na nb gt nn mv no np aw nq bi"><span id="c766" class="nr li iv mv b gy ns nt l nu nv"># load data<br/>chart_df = pd.read_csv("data/chart_df.csv")<br/>table_M = pd.read_csv("data/table_M.csv")</span><span id="ca9d" class="nr li iv mv b gy nw nt l nu nv"># load function<br/>exec(open('edit_pres.py').read())</span><span id="fd58" class="nr li iv mv b gy nw nt l nu nv"># write Group M presentation<br/>edit_pres("M", chart_df, table_M, "templates/ppt-template.pptx", "test3.pptx")</span><span id="e5c7" class="nr li iv mv b gy nw nt l nu nv">## 'Successfully saved version M!'</span></pre><p id="4e16" class="pw-post-body-paragraph kk kl iv km b kn ko jw kp kq kr jz ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">我们可以检查看看结果:</p><figure class="my mz na nb gt nc gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi mx"><img src="../Images/da7e4d351d1caaffc0ea8399482049e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*u6imMrPEO8BLasx3.png"/></div></div><p class="nj nk gj gh gi nl nm bd b be z dk translated">所有幻灯片都已成功更新(作者生成)</p></figure><p id="9071" class="pw-post-body-paragraph kk kl iv km b kn ko jw kp kq kr jz ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">太好了！我们现在已经具备了开始批量生产参数化Powerpoint所需的一切。</p><h1 id="098e" class="lh li iv bd lj lk ll lm ln lo lp lq lr kb ls kc lt ke lu kf lv kh lw ki lx ly bi translated">Python中的批量生产</h1><p id="a069" class="pw-post-body-paragraph kk kl iv km b kn lz jw kp kq ma jz ks kt mb kv kw kx mc kz la lb md ld le lf io bi translated">既然我们已经设置了Python函数，我们只需要将它与所有数据一起加载到我们的会话中，我们将使用这些数据为每个销售组更新到twenty版本中。</p><pre class="my mz na nb gt nn mv no np aw nq bi"><span id="41b6" class="nr li iv mv b gy ns nt l nu nv">import glob<br/>import os</span><span id="1b0e" class="nr li iv mv b gy nw nt l nu nv"># load function<br/>exec(open('edit_pres.py').read())</span><span id="cc9c" class="nr li iv mv b gy nw nt l nu nv"># load all dataframes in data folder into a dict<br/>path = "data/"<br/>data_files = glob.glob(os.path.join(path, "*.csv"))<br/>dataframes = dict()<br/>for i in data_files:<br/>    path = os.path.basename(i)<br/>    name = path.split('.')[0]<br/>    dataframes[name] = pd.read_csv("data/" + name + ".csv")</span></pre><p id="8c95" class="pw-post-body-paragraph kk kl iv km b kn ko jw kp kq kr jz ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">现在让我们为每个组运行我们的函数，并将输出的Powerpoint作为一个适当命名的文件写在一个<code class="fe ms mt mu mv b">outputs</code>目录中。</p><pre class="my mz na nb gt nn mv no np aw nq bi"><span id="2092" class="nr li iv mv b gy ns nt l nu nv"># create outputs directory if it doesn't exist<br/>if not os.path.isdir("outputs"):<br/>  os.mkdir("outputs")</span><span id="d07a" class="nr li iv mv b gy nw nt l nu nv"># generate a ppt for each group<br/>for group in dataframes['chart_df'].group.values:<br/>  tables_data = dataframes['table_' + group]<br/>  edit_pres(group, dataframes['chart_df'], tables_data, <br/>  'templates/ppt-template.pptx', 'outputs/results_group_' + group + '.pptx')</span><span id="b4ee" class="nr li iv mv b gy nw nt l nu nv">## 'Successfully saved version A!'<br/>## 'Successfully saved version B!'<br/>## 'Successfully saved version C!'<br/>## 'Successfully saved version D!'<br/>## 'Successfully saved version E!'<br/>## 'Successfully saved version F!'<br/>## 'Successfully saved version G!'<br/>## 'Successfully saved version H!'<br/>## 'Successfully saved version I!'<br/>## 'Successfully saved version J!'<br/>## 'Successfully saved version K!'<br/>## 'Successfully saved version L!'<br/>## 'Successfully saved version M!'<br/>## 'Successfully saved version N!'<br/>## 'Successfully saved version O!'<br/>## 'Successfully saved version P!'<br/>## 'Successfully saved version Q!'<br/>## 'Successfully saved version R!'<br/>## 'Successfully saved version S!'<br/>## 'Successfully saved version T!'</span></pre><p id="2622" class="pw-post-body-paragraph kk kl iv km b kn ko jw kp kq kr jz ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">看起来成功了！我已经将这些输出放在repo的<code class="fe ms mt mu mv b">outputs_example</code>文件夹中。</p><h1 id="4376" class="lh li iv bd lj lk ll lm ln lo lp lq lr kb ls kc lt ke lu kf lv kh lw ki lx ly bi translated">将它导入到R中，并使用Tidyverse完成一个简洁的更新工作流</h1><p id="820b" class="pw-post-body-paragraph kk kl iv km b kn lz jw kp kq ma jz ks kt mb kv kw kx mc kz la lb md ld le lf io bi translated">为了在R中使用我们伟大的python函数<code class="fe ms mt mu mv b">edit_pres.py</code>，R需要知道在哪里可以找到包含它所使用的安装包的Python环境。最简单的方法是在R项目中创建一个名为<code class="fe ms mt mu mv b">.Rprofile</code>的文件，并用它来设置<code class="fe ms mt mu mv b">RETICULATE_PYTHON</code>环境变量。这将需要设置为Python环境中编写该函数的<em class="nz"> Python可执行文件</em>的路径。下面是我的<code class="fe ms mt mu mv b">.Rprofile</code>中的一个例子:</p><pre class="my mz na nb gt nn mv no np aw nq bi"><span id="a31a" class="nr li iv mv b gy ns nt l nu nv">Sys.setenv(RETICULATE_PYTHON="/home/rstudio/.local/share/r-miniconda/envs/pptx/bin/python3")</span></pre><p id="5478" class="pw-post-body-paragraph kk kl iv km b kn ko jw kp kq kr jz ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">为了让这个新变量生效，您需要重启R。一旦R重启，项目中的任何Python代码都将由<code class="fe ms mt mu mv b">RETICULATE_PYTHON</code>定义的Python可执行文件执行。</p><p id="f16a" class="pw-post-body-paragraph kk kl iv km b kn ko jw kp kq kr jz ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">设置好Python环境后，我们可以使用<code class="fe ms mt mu mv b">reticulate</code>包将Python函数加载到R中。这样，它立即成为一个R函数，可以处理R输入。</p><pre class="my mz na nb gt nn mv no np aw nq bi"><span id="6dbc" class="nr li iv mv b gy ns nt l nu nv">library(reticulate)</span><span id="d058" class="nr li iv mv b gy nw nt l nu nv">source_python("edit_pres.py")</span><span id="1293" class="nr li iv mv b gy nw nt l nu nv">edit_pres</span><span id="cfd7" class="nr li iv mv b gy nw nt l nu nv">## &lt;function edit_pres at 0x7fb40af17ef0&gt;</span></pre><p id="654c" class="pw-post-body-paragraph kk kl iv km b kn ko jw kp kq kr jz ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">我们可以将所有数据作为数据帧载入，并测试该功能是否有效:</p><pre class="my mz na nb gt nn mv no np aw nq bi"><span id="6ead" class="nr li iv mv b gy ns nt l nu nv"># load in data files<br/>for (file in list.files("data")) {<br/>  splits &lt;- strsplit(file, "\\.")<br/>  assign(splits[[1]][1],<br/>         read.csv(paste0("data/", file)))<br/>} </span><span id="0533" class="nr li iv mv b gy nw nt l nu nv"># test edit_pres function on Group M<br/>edit_pres("M", chart_df, table_M, "templates/ppt-template.pptx", "test4.pptx")</span><span id="0523" class="nr li iv mv b gy nw nt l nu nv">## [1] "Successfully saved version M!"</span></pre><h1 id="f34c" class="lh li iv bd lj lk ll lm ln lo lp lq lr kb ls kc lt ke lu kf lv kh lw ki lx ly bi translated">使用<code class="fe ms mt mu mv b">dplyr</code>在一个整洁的表格中完成这一切</h1><p id="794d" class="pw-post-body-paragraph kk kl iv km b kn lz jw kp kq ma jz ks kt mb kv kw kx mc kz la lb md ld le lf io bi translated">我们的<code class="fe ms mt mu mv b">chart_df</code>对象是一个常规的dataframe，其中每一行代表每个销售组的图表数据。然而，我们的表数据都存储在不同的数据帧中。我们可以添加一个<em class="nz">列表列</em>,通过在<code class="fe ms mt mu mv b">group</code>列上使用mutate来捕获所有不同的表数据集，使其与我们的图表数据保持一致:</p><pre class="my mz na nb gt nn mv no np aw nq bi"><span id="7491" class="nr li iv mv b gy ns nt l nu nv">library(dplyr)</span><span id="caac" class="nr li iv mv b gy nw nt l nu nv">full_data &lt;- chart_df %&gt;% <br/>  dplyr::rowwise() %&gt;% <br/>  dplyr::mutate(<br/>    table = list(get(paste0("table_", group)))<br/>  )</span></pre><p id="7059" class="pw-post-body-paragraph kk kl iv km b kn ko jw kp kq kr jz ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">如果我们检查一些列，我们可以看到我们的表存储在<code class="fe ms mt mu mv b">full_data</code>数据帧的行中。</p><pre class="my mz na nb gt nn mv no np aw nq bi"><span id="8e51" class="nr li iv mv b gy ns nt l nu nv">full_data %&gt;% <br/>  dplyr::select(group, starts_with("pie"), table)</span><span id="2103" class="nr li iv mv b gy nw nt l nu nv">## # A tibble: 20 x 6<br/>## # Rowwise: <br/>##    group  pie1  pie2  pie3  pie4 table           <br/>##    &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;list&gt;          <br/>##  1 A       4.3   5.5   1.8   1.2 &lt;df[,5] [8 × 5]&gt;<br/>##  2 B       2.2   2.7   4.6   2.3 &lt;df[,5] [8 × 5]&gt;<br/>##  3 C       4.1   5.1   3.2   4.4 &lt;df[,5] [8 × 5]&gt;<br/>##  4 D       5     5.7   1.3   5.9 &lt;df[,5] [8 × 5]&gt;<br/>##  5 E       5.1   5     0.4   5.3 &lt;df[,5] [8 × 5]&gt;<br/>##  6 F       3.9   1.2   5.2   1.9 &lt;df[,5] [8 × 5]&gt;<br/>##  7 G       5.7   5.3   5.4   5   &lt;df[,5] [8 × 5]&gt;<br/>##  8 H       3.5   1.5   4.5   3.5 &lt;df[,5] [8 × 5]&gt;<br/>##  9 I       4.4   5.4   4     0.7 &lt;df[,5] [8 × 5]&gt;<br/>## 10 J       0.7   6     2.7   5.5 &lt;df[,5] [8 × 5]&gt;<br/>## 11 K       2     4.8   4.4   1.6 &lt;df[,5] [8 × 5]&gt;<br/>## 12 L       2.8   1.6   1.1   0.5 &lt;df[,5] [8 × 5]&gt;<br/>## 13 M       3.3   3.9   0.6   2.4 &lt;df[,5] [8 × 5]&gt;<br/>## 14 N       4.2   2.2   2.5   5.7 &lt;df[,5] [8 × 5]&gt;<br/>## 15 O       5.6   4.5   5     2.7 &lt;df[,5] [8 × 5]&gt;<br/>## 16 P       0.5   2.3   3.5   2.1 &lt;df[,5] [8 × 5]&gt;<br/>## 17 Q       1     2.4   0.5   3.4 &lt;df[,5] [8 × 5]&gt;<br/>## 18 R       2.4   2.1   1.2   0.9 &lt;df[,5] [8 × 5]&gt;<br/>## 19 S       3.8   0.1   2.2   0.1 &lt;df[,5] [8 × 5]&gt;<br/>## 20 T       1.1   4     2     3.1 &lt;df[,5] [8 × 5]&gt;</span></pre><p id="6fbc" class="pw-post-body-paragraph kk kl iv km b kn ko jw kp kq kr jz ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">现在是最后的魔术步骤。我们可以做进一步的改变，在这个数据帧的行上运行我们的Python函数，以编写我们所有的Powerpoint文档:</p><pre class="my mz na nb gt nn mv no np aw nq bi"><span id="8d3d" class="nr li iv mv b gy ns nt l nu nv"># create outputs directory if it doesn't exist<br/>if (!dir.exists("outputs")) {<br/>  dir.create("outputs")<br/>}</span><span id="4339" class="nr li iv mv b gy nw nt l nu nv"># rowwise mutate to run function for all groups<br/>write_pptx &lt;- full_data %&gt;% <br/>  dplyr::rowwise() %&gt;% <br/>  dplyr::mutate(<br/>    pptx = edit_pres(group, ., table, <br/>                     "templates/ppt-template.pptx", <br/>                     paste0("outputs/results_group_", group, ".pptx" ))<br/>  )</span></pre><p id="9367" class="pw-post-body-paragraph kk kl iv km b kn ko jw kp kq kr jz ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">这个新的数据框将包含一个新列，其中包含写入文件的确认，您可以在<code class="fe ms mt mu mv b">outputs</code>文件夹中查找并检查它们。</p><pre class="my mz na nb gt nn mv no np aw nq bi"><span id="4866" class="nr li iv mv b gy ns nt l nu nv">write_pptx %&gt;% <br/>  dplyr::select(group, starts_with("pie"), table, pptx)</span><span id="9c3d" class="nr li iv mv b gy nw nt l nu nv">## # A tibble: 20 x 7<br/>## # Rowwise: <br/>##    group  pie1  pie2  pie3  pie4 table            pptx                         <br/>##    &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;list&gt;           &lt;chr&gt;                        <br/>##  1 A       4.3   5.5   1.8   1.2 &lt;df[,5] [8 × 5]&gt; Successfully saved version A!<br/>##  2 B       2.2   2.7   4.6   2.3 &lt;df[,5] [8 × 5]&gt; Successfully saved version B!<br/>##  3 C       4.1   5.1   3.2   4.4 &lt;df[,5] [8 × 5]&gt; Successfully saved version C!<br/>##  4 D       5     5.7   1.3   5.9 &lt;df[,5] [8 × 5]&gt; Successfully saved version D!<br/>##  5 E       5.1   5     0.4   5.3 &lt;df[,5] [8 × 5]&gt; Successfully saved version E!<br/>##  6 F       3.9   1.2   5.2   1.9 &lt;df[,5] [8 × 5]&gt; Successfully saved version F!<br/>##  7 G       5.7   5.3   5.4   5   &lt;df[,5] [8 × 5]&gt; Successfully saved version G!<br/>##  8 H       3.5   1.5   4.5   3.5 &lt;df[,5] [8 × 5]&gt; Successfully saved version H!<br/>##  9 I       4.4   5.4   4     0.7 &lt;df[,5] [8 × 5]&gt; Successfully saved version I!<br/>## 10 J       0.7   6     2.7   5.5 &lt;df[,5] [8 × 5]&gt; Successfully saved version J!<br/>## 11 K       2     4.8   4.4   1.6 &lt;df[,5] [8 × 5]&gt; Successfully saved version K!<br/>## 12 L       2.8   1.6   1.1   0.5 &lt;df[,5] [8 × 5]&gt; Successfully saved version L!<br/>## 13 M       3.3   3.9   0.6   2.4 &lt;df[,5] [8 × 5]&gt; Successfully saved version M!<br/>## 14 N       4.2   2.2   2.5   5.7 &lt;df[,5] [8 × 5]&gt; Successfully saved version N!<br/>## 15 O       5.6   4.5   5     2.7 &lt;df[,5] [8 × 5]&gt; Successfully saved version O!<br/>## 16 P       0.5   2.3   3.5   2.1 &lt;df[,5] [8 × 5]&gt; Successfully saved version P!<br/>## 17 Q       1     2.4   0.5   3.4 &lt;df[,5] [8 × 5]&gt; Successfully saved version Q!<br/>## 18 R       2.4   2.1   1.2   0.9 &lt;df[,5] [8 × 5]&gt; Successfully saved version R!<br/>## 19 S       3.8   0.1   2.2   0.1 &lt;df[,5] [8 × 5]&gt; Successfully saved version S!<br/>## 20 T       1.1   4     2     3.1 &lt;df[,5] [8 × 5]&gt; Successfully saved version T!</span></pre><h1 id="86c2" class="lh li iv bd lj lk ll lm ln lo lp lq lr kb ls kc lt ke lu kf lv kh lw ki lx ly bi translated">扩展这项工作</h1><p id="4c2b" class="pw-post-body-paragraph kk kl iv km b kn lz jw kp kq ma jz ks kt mb kv kw kx mc kz la lb md ld le lf io bi translated">您可以扩展这项工作，创建一个非常强大的报告基础结构，如下所示:</p><ul class=""><li id="a963" class="me mf iv km b kn ko kq kr kt mg kx mh lb mi lf mj mk ml mm bi translated">使用数据库连接来查询Powerpoint文档所需的数据</li><li id="918b" class="me mf iv km b kn mn kq mo kt mp kx mq lb mr lf mj mk ml mm bi translated">使用web前端(例如在Shiny或Django中),通过查询后端数据库、写入模板和提供下载的新文件，按需生成Powerpoint。</li></ul></div><div class="ab cl oa ob hz oc" role="separator"><span class="od bw bk oe of og"/><span class="od bw bk oe of og"/><span class="od bw bk oe of"/></div><div class="io ip iq ir is"><p id="9750" class="pw-post-body-paragraph kk kl iv km b kn ko jw kp kq kr jz ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">最初我是一名纯粹的数学家，后来我成为了一名心理计量学家和数据科学家。我热衷于将所有这些学科的严谨性应用到复杂的人的问题上。我也是一个编码极客和日本RPG的超级粉丝。在 <a class="ae lg" href="https://www.linkedin.com/in/keith-mcnulty/" rel="noopener ugc nofollow" target="_blank"> <em class="nz"> LinkedIn </em> </a> <em class="nz">或</em><a class="ae lg" href="https://twitter.com/dr_keithmcnulty" rel="noopener ugc nofollow" target="_blank"><em class="nz">Twitter</em></a><em class="nz">上找我。也可以看看我在</em><a class="ae lg" href="http://drkeithmcnulty.com/" rel="noopener ugc nofollow" target="_blank"><em class="nz">drkeithmcnulty.com</em></a><em class="nz">的博客。</em></p><figure class="my mz na nb gt nc gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi oh"><img src="../Images/71ad69a2195f5ff01e4655cb0394ee6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h0dG3tTiDZ1vOBUkGxgWOA.jpeg"/></div></div><p class="nj nk gj gh gi nl nm bd b be z dk translated">pixabay.com的好意</p></figure></div></div>    
</body>
</html>