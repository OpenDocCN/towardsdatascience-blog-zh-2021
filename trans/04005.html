<html>
<head>
<title>Load Yelp reviews (or other huge JSON files) with ease</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">轻松加载Yelp评论(或其他大型JSON文件)</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/load-yelp-reviews-or-other-huge-json-files-with-ease-ad804c2f1537?source=collection_archive---------14-----------------------#2021-04-04">https://towardsdatascience.com/load-yelp-reviews-or-other-huge-json-files-with-ease-ad804c2f1537?source=collection_archive---------14-----------------------#2021-04-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="830f" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">熊猫用户:这是你如何大块吃竹子，并尽快去掉不必要的部分。</h2></div><p id="d781" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Yelp数据集已经成为数据科学项目的热门去处，可能是因为它1)与日常生活相关；2)像生产数据一样“真实地”调整大小。例如，<code class="fe lc ld le lf b">yelp_academic_dataset_review.json</code>本身就占据了5.9 GB的磁盘空间，足以让现代的笔记本电脑在加载它的时候停下来。</p><p id="7b74" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我将分享一些关于如何高效加载Yelp JSON文件的技巧。希望这些提示可以转移到你可能从事的其他项目中去！</p><p id="9f1a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面显示的所有代码块都可以复制到Jupyter笔记本单元中，并以独立的方式执行。最后包含了一个基准来展示所实现的显著加速。</p><p id="c033" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">(补遗，2021年4月4日)</strong>从技术上讲，Yelp文件是由<a class="ae lb" href="https://hackernoon.com/json-lines-format-76353b4e588d" rel="noopener ugc nofollow" target="_blank"> <strong class="kh ir">行分隔的</strong> JSON文件</a>:每行代表一个单独的JSON对象，而不是整个文件是一个单一的、巨大的JSON对象。这类文件的正确扩展名是。但公司在发布数据时可能不会进行区分。感谢<a class="ae lb" href="https://www.linkedin.com/in/rongpengli/" rel="noopener ugc nofollow" target="_blank">罗恩李</a>指出这些事情。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi lg"><img src="../Images/ee4b437916ddc750ffcffa0be671de6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*VADcuO9p5eS2HIQl"/></div></div><p class="ls lt gj gh gi lu lv bd b be z dk translated">照片由<a class="ae lb" href="https://unsplash.com/@tongs?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Xtina Yu </a>在<a class="ae lb" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="09ff" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">可以用<code class="fe lc ld le lf b">modin</code>吗？</h1><p id="096b" class="pw-post-body-paragraph kf kg iq kh b ki mv jr kk kl mw ju kn ko mx kq kr ks my ku kv kw mz ky kz la ij bi translated">你可能知道<code class="fe lc ld le lf b"><a class="ae lb" href="https://modin.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank">modin</a></code>，它提供了<code class="fe lc ld le lf b">pandas</code> API，但是在幕后运行并行化的例程。不幸的是，由于无法解释的原因，我在这里演示的代码无法在<code class="fe lc ld le lf b">modin</code>上运行。截至2021年4月4日，<code class="fe lc ld le lf b">modin</code> <a class="ae lb" href="https://modin.readthedocs.io/en/latest/supported_apis/io_supported.html" rel="noopener ugc nofollow" target="_blank">的官方文档表明</a>仅“部分”支持<code class="fe lc ld le lf b">read_json</code>方法。</p><p id="71c2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">好的— — <code class="fe lc ld le lf b">pandas</code>是的。</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="3263" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">选择正确的数据类型</h1><p id="a8b3" class="pw-post-body-paragraph kf kg iq kh b ki mv jr kk kl mw ju kn ko mx kq kr ks my ku kv kw mz ky kz la ij bi translated">尽管有些Kaggle笔记本上显示的是，<code class="fe lc ld le lf b">pandas.read_json</code> <em class="na">可以直接读取Yelp JSON文件。对于我们的目的来说，一个重要的参数是<code class="fe lc ld le lf b">dtype</code>:我们可以指定每一列应该使用的数据类型，以减少不必要的RAM使用。</em></p><p id="13a4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">每个评论(行)由四个数字描述:星级(1-5)，以及它收到的有用/酷/有趣的投票数。知道星级只能在一个很窄的范围内，并且每个评论不太可能得到，比如说，数百万的投票，我们可以选择如下的数据类型。</p><p id="bb8a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意，我还指定了<code class="fe lc ld le lf b">lines=True</code>和<code class="fe lc ld le lf b">orient="records"</code>，这对<code class="fe lc ld le lf b">read_json</code>使用我们的文件是必要的。<code class="fe lc ld le lf b">lines=True</code>参数导致<code class="fe lc ld le lf b">pandas</code>将文件“作为json对象逐行读取”— —这对应于Yelp文件的结构。</p><pre class="lh li lj lk gt nb lf nc nd aw ne bi"><span id="d248" class="nf me iq lf b gy ng nh l ni nj">import numpy as np<br/>import pandas as pd</span><span id="c237" class="nf me iq lf b gy nk nh l ni nj">r_dtypes = {"stars": np.float16, <br/>            "useful": np.int32, <br/>            "funny": np.int32,<br/>            "cool": np.int32,<br/>           }</span><span id="c29d" class="nf me iq lf b gy nk nh l ni nj">with open("yelp_academic_dataset_review.json", "r") as f:<br/>    df = pd.read_json(f, orient="records", lines=True, dtype=r_dtypes)</span></pre></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="10c0" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">成块阅读--并尽快过滤</h1><p id="e82c" class="pw-post-body-paragraph kf kg iq kh b ki mv jr kk kl mw ju kn ko mx kq kr ks my ku kv kw mz ky kz la ij bi translated">我上面的代码将一次性读取整个5.9 GB的文件。然而，由于我们可能<em class="na">并不</em>需要整个审查数据集，我们应该尽快过滤它— —理想的是在文件I/O期间<em class="na">。</em></p><p id="f1c3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我是这样做的:首先在<code class="fe lc ld le lf b">read_json</code>中指定<code class="fe lc ld le lf b">chunksize</code>，这样我就得到一个迭代器，每次迭代都会产生一个对应于<code class="fe lc ld le lf b">chunksize</code>评论(行)的DataFrame。这样，我不会一下子耗尽笔记本电脑的内存--同时能够删除我不需要的列和行。</p><p id="ab33" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意<code class="fe lc ld le lf b"><a class="ae lb" href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.query.html" rel="noopener ugc nofollow" target="_blank">query</a></code>在选择所需行时的使用。如果你还没有了解它，你应该了解一下— —它允许你在复杂的条件下过滤行<em class="na">，而不需要</em>定义冗长的布尔掩码。比方说，我只对最近3年的数据感兴趣；因此，<code class="fe lc ld le lf b">.query(`date` ≥ ‘2017–12–01’)</code>中``包围了一个列名。</p><pre class="lh li lj lk gt nb lf nc nd aw ne bi"><span id="3ac8" class="nf me iq lf b gy ng nh l ni nj">import numpy as np<br/>import pandas as pd</span><span id="aa01" class="nf me iq lf b gy nk nh l ni nj">b_pandas = []<br/>r_dtypes = {"stars": np.float16, <br/>            "useful": np.int32, <br/>            "funny": np.int32,<br/>            "cool": np.int32,<br/>           }</span><span id="bbaf" class="nf me iq lf b gy nk nh l ni nj">with open("yelp_academic_dataset_review.json", "r") as f:<br/>    reader = pd.read_json(f, orient="records", lines=True, <br/>                          dtype=r_dtypes, chunksize=1000)<br/>        <br/>    for chunk in reader:<br/>        reduced_chunk = chunk.drop(columns=['review_id', 'user_id'])\<br/>                             .query("`date` &gt;= '2017-12-01'")<br/>        b_pandas.append(reduced_chunk)<br/>    <br/>b_pandas = pd.concat(b_pandas, ignore_index=True)</span></pre><p id="4013" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后调用<code class="fe lc ld le lf b">pandas.concat</code>将所有的块放在一个数据帧中，然后您可以将其与业务元数据等合并。</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="1da7" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">基准</h1><p id="00f8" class="pw-post-body-paragraph kf kg iq kh b ki mv jr kk kl mw ju kn ko mx kq kr ks my ku kv kw mz ky kz la ij bi translated">将数据加载时间从4分钟减少到2.5分钟，提高了38%！</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi nl"><img src="../Images/38af040d3492e558d7ccabb3dbc12565.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BrTpHKSfuCH0b9RE-opyCw.png"/></div></div><p class="ls lt gj gh gi lu lv bd b be z dk translated">速度基准比较一个天真的方法(上)和这篇文章的(下)。图片来自本文作者自己的实验。</p></figure></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="dd6f" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">包扎</h1><ol class=""><li id="64ff" class="nm nn iq kh b ki mv kl mw ko no ks np kw nq la nr ns nt nu bi translated">明智地使用<code class="fe lc ld le lf b">dtype</code>来指定列数据类型。这是<code class="fe lc ld le lf b">pandas</code>中I/O方法的一个常见论点。</li><li id="7d3c" class="nm nn iq kh b ki nv kl nw ko nx ks ny kw nz la nr ns nt nu bi translated">分块读取文件，积极向下过滤以节省内存。同样，<code class="fe lc ld le lf b">chunksize</code>参数由几个<code class="fe lc ld le lf b">pandas.read_*</code>方法共享，包括<code class="fe lc ld le lf b"><a class="ae lb" href="https://pandas.pydata.org/pandas-docs/dev/reference/api/pandas.read_csv.html" rel="noopener ugc nofollow" target="_blank">read_csv</a></code>！</li><li id="0e78" class="nm nn iq kh b ki nv kl nw ko nx ks ny kw nz la nr ns nt nu bi translated">学习如何使用<code class="fe lc ld le lf b">pandas.DataFrame.query</code>；这将节省大量布尔掩码的键入和命名。</li></ol></div></div>    
</body>
</html>