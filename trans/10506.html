<html>
<head>
<title>Understanding Python imports, __init__.py and pythonpath — once and for all</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解Python导入，__init__。py和pythonpath —一劳永逸</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/understanding-python-imports-init-py-and-pythonpath-once-and-for-all-4c5249ab6355?source=collection_archive---------0-----------------------#2021-10-07">https://towardsdatascience.com/understanding-python-imports-init-py-and-pythonpath-once-and-for-all-4c5249ab6355?source=collection_archive---------0-----------------------#2021-10-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="9e45" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">PYTHON基础</h2><div class=""/><div class=""><h2 id="1d9d" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">了解如何导入包和模块(以及两者之间的区别)</h2></div><p id="e801" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">在本教程结束时，这是您可以轻松使用的目录结构(针对<code class="fe ln lo lp lq b">Medium_Imports_Tutorial</code>项目)——从一个子目录导入任何脚本到另一个子目录(蓝色箭头)。<br/> <em class="lr">注:如果你愿意合作，这里有</em><a class="ae ls" href="https://github.com/V-Sher/Medium_Imports_Tutorial" rel="noopener ugc nofollow" target="_blank"><em class="lr">Github</em></a><em class="lr">回购。</em></p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi lt"><img src="../Images/d471a3c68c466bc60c249bbe3ee7eeeb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h2F5YX0Gy7bQYm6TfmhWMw.png"/></div></div><p class="mf mg gj gh gi mh mi bd b be z dk translated">学习Python导入的目录结构</p></figure><p id="ae5d" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">在我们开始之前，让我们了解一下<strong class="kt jd">包</strong>和<strong class="kt jd">模块</strong>之间的区别，因为我们将在整篇文章中多次提到它们。</p><blockquote class="mj mk ml"><p id="42e0" class="kr ks lr kt b ku kv kd kw kx ky kg kz mm lb lc ld mn lf lg lh mo lj lk ll lm im bi translated">模块:一个python脚本。</p><p id="89b2" class="kr ks lr kt b ku kv kd kw kx ky kg kz mm lb lc ld mn lf lg lh mo lj lk ll lm im bi translated">包:模块的集合。</p></blockquote><h1 id="30ec" class="mp mq it bd mr ms mt mu mv mw mx my mz ki na kj nb kl nc km nd ko ne kp nf ng bi translated">我们开始吧...</h1><p id="8a86" class="pw-post-body-paragraph kr ks it kt b ku nh kd kw kx ni kg kz la nj lc ld le nk lg lh li nl lk ll lm im bi translated">上图中的目录结构看起来有点复杂，我不会要求你一次创建它。</p><p id="ac3c" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">为了简单起见，让我们首先在项目目录中创建一个目录<code class="fe ln lo lp lq b">scripts</code>，并向其中添加两个模块——<code class="fe ln lo lp lq b">example1.py</code>和<code class="fe ln lo lp lq b">example2.py</code>。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/f4d5eb76eb8066cf6dfa63d65a49dd82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1300/format:webp/1*gdkvpHfG09imHLkCIa3JGQ.png"/></div></figure><p id="4a3b" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">这个想法是让在<code class="fe ln lo lp lq b">example1.py</code>中定义的任何函数/变量/类都可以在<code class="fe ln lo lp lq b">example2.py</code>中访问。该模块的内容如下:</p><pre class="lu lv lw lx gt nn lq no np aw nq bi"><span id="0153" class="nr mq it lq b gy ns nt l nu nv"><strong class="lq jd"><em class="lr">#example1.py</em></strong></span><span id="1811" class="nr mq it lq b gy nw nt l nu nv">MY_EX1_STRING = 'Welcome to Example1 module!'</span><span id="ab5d" class="nr mq it lq b gy nw nt l nu nv">def yolo(<em class="lr">x</em>: int):<br/>     print("You only LIve", <em class="lr">x</em>, "times.")</span></pre><p id="d2f2" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">要在<code class="fe ln lo lp lq b">example2.py</code>内导入这些项目:</p><pre class="lu lv lw lx gt nn lq no np aw nq bi"><span id="ee42" class="nr mq it lq b gy ns nt l nu nv"><strong class="lq jd"><em class="lr">#example2.py</em></strong></span><span id="c689" class="nr mq it lq b gy nw nt l nu nv">import example1</span><span id="a01a" class="nr mq it lq b gy nw nt l nu nv"><em class="lr"># imported string</em><br/>print("The imported string is: ", example1.MY_EX1_STRING)</span><span id="302d" class="nr mq it lq b gy nw nt l nu nv"><em class="lr"># imported function</em><br/>example1.yolo(10)</span></pre><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi nx"><img src="../Images/891726251e81520f14f71978173f8ddb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*88X9BS9hceBT_jVJ2hiiGg.png"/></div></div><p class="mf mg gj gh gi mh mi bd b be z dk translated">运行<strong class="bd ny"> example2.py </strong>的输出</p></figure><p id="7a82" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">只是重复一下显而易见的内容，可以使用点符号来访问导入模块中的项目——例如，<code class="fe ln lo lp lq b">example1.yolo()</code>或<code class="fe ln lo lp lq b">example1.MY_EX1_STRING</code>。如果你觉得每次都写<code class="fe ln lo lp lq b">example1.XXX</code>似乎有点太长，我们可以使用别名<code class="fe ln lo lp lq b">as</code>并重写<code class="fe ln lo lp lq b">example2.py</code>如下。正如您正确猜测的那样，输出仍然保持不变。</p><pre class="lu lv lw lx gt nn lq no np aw nq bi"><span id="0ff8" class="nr mq it lq b gy ns nt l nu nv"><strong class="lq jd"><em class="lr">#example2.py</em></strong></span><span id="5281" class="nr mq it lq b gy nw nt l nu nv">import example1 <strong class="lq jd">as e1</strong></span><span id="2c0e" class="nr mq it lq b gy nw nt l nu nv"><em class="lr"># imported string</em><br/>print("The imported string is: ", <strong class="lq jd">e1</strong>.MY_EX1_STRING)</span><span id="9640" class="nr mq it lq b gy nw nt l nu nv"><em class="lr"># imported function</em><br/><strong class="lq jd">e1</strong>.yolo(10)</span></pre><h2 id="0d26" class="nr mq it bd mr nz oa dn mv ob oc dp mz la od oe nb le of og nd li oh oi nf iz bi translated">当我们写一个' import '语句时，到底发生了什么？</h2><p id="dac2" class="pw-post-body-paragraph kr ks it kt b ku nh kd kw kx ni kg kz la nj lc ld le nk lg lh li nl lk ll lm im bi translated">python解释器试图寻找包含我们试图在<code class="fe ln lo lp lq b">sys.path</code>中导入的模块<em class="lr">的<em class="lr">目录</em>。这是一个目录列表，Python会在查看完缓存模块和Python标准库模块后搜索这些目录。</em></p><p id="d13c" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">让我们看看此时我们的系统路径包含了什么(通过注释掉<code class="fe ln lo lp lq b">example2.py</code>中的前几行代码)。</p><pre class="lu lv lw lx gt nn lq no np aw nq bi"><span id="b19f" class="nr mq it lq b gy ns nt l nu nv"><strong class="lq jd">#example2.py</strong></span><span id="dedf" class="nr mq it lq b gy nw nt l nu nv"><em class="lr"># import example1<br/># print("The imported string is: ", example1.MY_EX1_STRING)<br/># example1.yolo(10)</em></span><span id="aa0b" class="nr mq it lq b gy nw nt l nu nv">import sys<br/>print(sys.path)</span></pre><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi oj"><img src="../Images/6a0c47e27258603e9434d75915913c19.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UaUdi89EKwHs8h0HXDVitA.png"/></div></div><p class="mf mg gj gh gi mh mi bd b be z dk translated">sys.path的输出</p></figure><p id="3a64" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">正如你所看到的，由<code class="fe ln lo lp lq b">sys.path</code>返回的列表中的第一个元素指向<code class="fe ln lo lp lq b">Medium_Imports_Tutorial/scripts</code>目录，这是我们导入的模块即<code class="fe ln lo lp lq b">example1.py</code>所在的位置。请注意，这个目录神奇地出现在<code class="fe ln lo lp lq b">sys.path</code>中并不是巧合。</p><blockquote class="mj mk ml"><p id="0184" class="kr ks lr kt b ku kv kd kw kx ky kg kz mm lb lc ld mn lf lg lh mo lj lk ll lm im bi translated">来自<code class="fe ln lo lp lq b">sys.path</code>的输出将总是包含索引为0的当前目录！当前目录是正在运行的脚本所在的目录。</p></blockquote><p id="62a3" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">这就是当调用者和被调用者模块位于同一个目录中时，导入相当简单的原因。</p><h2 id="f1be" class="nr mq it bd mr nz oa dn mv ob oc dp mz la od oe nb le of og nd li oh oi nf iz bi translated">如果我只想从导入的模块中导入某些项目，而不是全部，该怎么办？</h2><p id="3203" class="pw-post-body-paragraph kr ks it kt b ku nh kd kw kx ni kg kz la nj lc ld le nk lg lh li nl lk ll lm im bi translated">在我们的例子中，我们只有一个字符串和一个在<code class="fe ln lo lp lq b">example1.py</code>模块中定义的函数。需要记住的一件重要事情是，每当执行一个import语句时，整个模块都将运行。为了证明这一点，让我们稍微修改一下<code class="fe ln lo lp lq b">example1.py</code>:</p><pre class="lu lv lw lx gt nn lq no np aw nq bi"><span id="72b8" class="nr mq it lq b gy ns nt l nu nv"><strong class="lq jd"><em class="lr">#example1.py</em></strong></span><span id="7787" class="nr mq it lq b gy nw nt l nu nv"><strong class="lq jd">print("Thanks for importing Example1 module.")</strong></span><span id="cd7b" class="nr mq it lq b gy nw nt l nu nv">MY_EX1_STRING = 'Welcome to Example1 module!'</span><span id="0968" class="nr mq it lq b gy nw nt l nu nv">def yolo(<em class="lr">x</em>: int):<br/>     print("You only LIve", <em class="lr">x</em>, "times.")</span><span id="40d4" class="nr mq it lq b gy nw nt l nu nv"><strong class="lq jd">yolo(10000)</strong></span></pre><p id="7881" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">现在试着运行<code class="fe ln lo lp lq b">example2.py</code>。您将看到打印语句以及<code class="fe ln lo lp lq b">yolo(10000)</code>的输出也将被打印出来(除了之前的输出)。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi ok"><img src="../Images/32a71367e7104fc81cc325356c147da4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MiHtOuKN8To-dyBa7XRfCA.png"/></div></div></figure><p id="706b" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><em class="lr">注意:有一个解决方法，我们可以控制语句在导入时是否运行。例如，请参见下面的代码片段。</em></p><pre class="lu lv lw lx gt nn lq no np aw nq bi"><span id="a8f2" class="nr mq it lq b gy ns nt l nu nv"><strong class="lq jd"><em class="lr">#example1.py</em></strong></span><span id="4bf4" class="nr mq it lq b gy nw nt l nu nv">print("Thanks for importing Example1 module.")</span><span id="fa6e" class="nr mq it lq b gy nw nt l nu nv">MY_EX1_STRING = 'Welcome to Example1 module!'</span><span id="172d" class="nr mq it lq b gy nw nt l nu nv">def yolo(<em class="lr">x</em>: int):<br/>     print("You only LIve", <em class="lr">x</em>, "times.")</span><span id="cb8d" class="nr mq it lq b gy nw nt l nu nv"><strong class="lq jd">if __name__ == '__main__':<br/>     yolo(10000)</strong></span></pre><p id="4a7e" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><em class="lr">在</em> <code class="fe ln lo lp lq b"><em class="lr">if__name__ == '__main__'</em></code> <em class="lr">语句里面的代码</em> <strong class="kt jd"> <em class="lr">在导入</em> </strong> <em class="lr">的时候不会运行，但是在外面定义的</em> <code class="fe ln lo lp lq b"><em class="lr">yolo()</em></code> <em class="lr">和</em> <code class="fe ln lo lp lq b"><em class="lr">MY_EX1_STRING</em></code> <em class="lr">可以通过导入使用。话虽如此，如果我们将</em> <code class="fe ln lo lp lq b">example1.py</code>作为独立模块运行，那么<code class="fe ln lo lp lq b">if</code>语句中的代码将被执行。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi ol"><img src="../Images/af3771349d7de43a17e88aedf458d680.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3ci83CWIELzZfhAKpWI8Pw.png"/></div></div><p class="mf mg gj gh gi mh mi bd b be z dk translated">运行<strong class="bd ny"> example1.py </strong>的输出</p></figure><p id="00af" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">总之，既然我已经证明了导入一个模块可以运行它的所有内容(如果不使用<code class="fe ln lo lp lq b">if __name__ == “__main__"</code>)，那么为什么只导入感兴趣的项目是有意义的就相当直观了。让我们看看如何在<code class="fe ln lo lp lq b">example2.py</code>中通过从<code class="fe ln lo lp lq b">example1.py</code>导入<code class="fe ln lo lp lq b">yolo</code>函数来实现这一点。这也有助于我们摆脱点符号，我们可以简单地使用<code class="fe ln lo lp lq b">yolo</code>功能。</p><pre class="lu lv lw lx gt nn lq no np aw nq bi"><span id="e389" class="nr mq it lq b gy ns nt l nu nv"><strong class="lq jd">#example2.py</strong></span><span id="b0e7" class="nr mq it lq b gy nw nt l nu nv"><strong class="lq jd">from example1 import yolo</strong><br/>yolo(10)</span></pre><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi ok"><img src="../Images/4e95e98b65150298618e8f8fe30925c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FQS3bBUnZAGQNHIO4ha9LA.png"/></div></div></figure><p id="71ad" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">类似地，我们可以通过<code class="fe ln lo lp lq b">from example1 import yolo, MY_EX1_STRING</code>从<code class="fe ln lo lp lq b">example1.py</code>导入两个对象。</p><p id="897c" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><em class="lr">注意:通常，存在包含进口陈述的代码，例如</em> <code class="fe ln lo lp lq b"><em class="lr">from example1 import *</em></code> <em class="lr">。这实质上意味着导入所有内容，但是，这被认为是一种不好的做法，因为它会对代码的可读性产生负面影响。</em></p><h2 id="da26" class="nr mq it bd mr nz oa dn mv ob oc dp mz la od oe nb le of og nd li oh oi nf iz bi translated">PYTHONPATH有什么用？</h2><p id="f81b" class="pw-post-body-paragraph kr ks it kt b ku nh kd kw kx ni kg kz la nj lc ld le nk lg lh li nl lk ll lm im bi translated">如果您注意到Github上项目的目录结构，通常会有一个<code class="fe ln lo lp lq b">utils</code>目录，其中包含一些用于预处理、数据清理等常见任务的实用程序脚本。这些脚本与主脚本分开保存，旨在重用。</p><p id="4626" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">让我们继续为我们的项目创建一个。<code class="fe ln lo lp lq b">utils</code>包将包含三个模块— <code class="fe ln lo lp lq b">length.py</code>、<code class="fe ln lo lp lq b">lower.py</code>和<code class="fe ln lo lp lq b">upper.py</code>，分别用于返回字符串输入的长度、小写和大写。</p><p id="dcda" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">我们还将在项目根目录下创建<code class="fe ln lo lp lq b">example3_outer.py</code>模块。这是我们将导入<code class="fe ln lo lp lq b">util</code>包中的模块的地方。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div class="gh gi om"><img src="../Images/2ea38b9bcd84b11d6c3a7b79c0f266dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1308/format:webp/1*ttG7TX7GgoRohE4JuF3ELg.png"/></div></figure><p id="e3d2" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">三个模块的内容如下:</p><pre class="lu lv lw lx gt nn lq no np aw nq bi"><span id="bd4e" class="nr mq it lq b gy ns nt l nu nv"><strong class="lq jd">#utils/length.py</strong></span><span id="09e4" class="nr mq it lq b gy nw nt l nu nv">def get_length(<em class="lr">name</em>: str):<br/>    return len(<em class="lr">name</em>)</span><span id="e43e" class="nr mq it lq b gy nw nt l nu nv"><strong class="lq jd">#utils/lower.py</strong></span><span id="bb60" class="nr mq it lq b gy nw nt l nu nv">def to_lower(<em class="lr">name</em>: str):<br/>    return <em class="lr">name</em>.lower()</span><span id="c88a" class="nr mq it lq b gy nw nt l nu nv"><strong class="lq jd">#utils/upper.py</strong></span><span id="98c8" class="nr mq it lq b gy nw nt l nu nv">def to_upper(<em class="lr">name</em>: str):<br/>    return <em class="lr">name</em>.upper()</span></pre><p id="e76a" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">现在，如果我们必须在<code class="fe ln lo lp lq b">example3_outer.py</code>中导入<code class="fe ln lo lp lq b">length.py</code>模块，这是我们通常的做法。</p><pre class="lu lv lw lx gt nn lq no np aw nq bi"><span id="16fd" class="nr mq it lq b gy ns nt l nu nv"><strong class="lq jd">#example3_outer.py</strong></span><span id="5d08" class="nr mq it lq b gy nw nt l nu nv">import utils.length</span><span id="c5a7" class="nr mq it lq b gy nw nt l nu nv">res = utils.length.get_length("Hello")<br/>print("The length of the string is: ",res)</span></pre><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi on"><img src="../Images/bfbb360661e2a7653caf82641dd18f00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DKbr-BGKa3-6WRdo81gQcA.png"/></div></div></figure><p id="fba2" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">需要注意的是，如果你要做的是<code class="fe ln lo lp lq b">import length</code>而不是<code class="fe ln lo lp lq b">import utils.length</code>，你会得到<code class="fe ln lo lp lq b">ModuleNotFoundError: No module named ‘length’</code>。这是因为<code class="fe ln lo lp lq b">sys.path</code>列表不包含<code class="fe ln lo lp lq b">../Medium_Imports_Tutorial/utils</code>目录(<em class="lr">但</em>)，该目录是它找到<code class="fe ln lo lp lq b">length.py</code>模块所需要的。让我们看看如何将它添加到<code class="fe ln lo lp lq b">sys.path</code>列表中。</p><p id="f551" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">有两种方法可以做到这一点:</p><p id="cdb0" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><strong class="kt jd">方法1 </strong>:使用<code class="fe ln lo lp lq b">sys.path.append</code></p><pre class="lu lv lw lx gt nn lq no np aw nq bi"><span id="02c9" class="nr mq it lq b gy ns nt l nu nv"><strong class="lq jd">#example3_outer.py</strong></span><span id="78c6" class="nr mq it lq b gy nw nt l nu nv">import os<br/>import sys</span><span id="0883" class="nr mq it lq b gy nw nt l nu nv">fpath = os.path.join(os.path.dirname(__file__), 'utils')<br/><strong class="lq jd">sys.path.append</strong>(fpath)<br/>print(sys.path)</span><span id="f72b" class="nr mq it lq b gy nw nt l nu nv">import length<br/>txt = "Hello"<br/>res_len = length.get_length(txt)<br/>print("The length of the string is: ",res_len)</span></pre><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi oj"><img src="../Images/248f81cebc655d4b69236a58ca9ab8d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bMjdH17lq3mvPav8ghodZg.png"/></div></div></figure><p id="e3c1" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">需要考虑的事情很少:</p><ul class=""><li id="f9d9" class="oo op it kt b ku kv kx ky la oq le or li os lm ot ou ov ow bi translated"><code class="fe ln lo lp lq b">imports</code>的顺序很重要——只有使用<code class="fe ln lo lp lq b">sys.path.append</code>将路径附加到<code class="fe ln lo lp lq b">utils</code>目录后，才能执行<code class="fe ln lo lp lq b">import length</code>语句。简而言之，不要为了整洁而将<code class="fe ln lo lp lq b">imports os</code>、<code class="fe ln lo lp lq b">import sys</code>和<code class="fe ln lo lp lq b">import length</code>都放在脚本的顶部！</li><li id="9081" class="oo op it kt b ku ox kx oy la oz le pa li pb lm ot ou ov ow bi translated"><code class="fe ln lo lp lq b">os.path.dirname(__file__)</code>返回当前工作目录的绝对路径。我们使用<code class="fe ln lo lp lq b">os.path.join</code>将<code class="fe ln lo lp lq b">utils</code>目录添加到这个路径中。</li><li id="0c86" class="oo op it kt b ku ox kx oy la oz le pa li pb lm ot ou ov ow bi translated">与往常一样，使用点符号(即<code class="fe ln lo lp lq b">length.get_length()</code>)可以方便地访问导入模块中定义的函数。</li></ul><p id="2b4d" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><strong class="kt jd">方法二</strong>:使用<code class="fe ln lo lp lq b">PYTHONPATH</code>环境变量</p><p id="b6bc" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">我经常发现修改pythonpath变量比使用方法1添加目录更容易。</p><blockquote class="mj mk ml"><p id="315e" class="kr ks lr kt b ku kv kd kw kx ky kg kz mm lb lc ld mn lf lg lh mo lj lk ll lm im bi translated">PYTHONPATH是一个环境变量，您可以设置它来添加额外的目录，python将在这些目录中查找模块和包。[ <a class="ae ls" href="https://www.tutorialspoint.com/What-is-PYTHONPATH-environment-variable-in-Python" rel="noopener ugc nofollow" target="_blank">来源</a></p></blockquote><p id="5491" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">在我们修改它之前，让我们在终端中使用<code class="fe ln lo lp lq b">echo $PYTHONPATH</code>检查它的内容(以确保我们没有覆盖它):</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi pc"><img src="../Images/7a3bc02dc2f879567423d9f6e86705ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k6kliS6Um-pwx0Gn4d5fjQ.png"/></div></div></figure><p id="f742" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">看起来它现在是空的，但是如果不是空的，我们总是建议<strong class="kt jd">修改pythonpath，以一种追加到它而不是覆盖它的方式</strong>。更具体地说，您必须将新目录添加到<code class="fe ln lo lp lq b">PYTHONPATH</code>，用冒号(<code class="fe ln lo lp lq b">:</code>)将其与现有内容隔开。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi pd"><img src="../Images/54f51bd91045c5441931c6bb5217da8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mrJTB0-hZthLzQGHbdAF6w.png"/></div></div></figure><p id="15af" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">有了pythonpath变量集，我们不再需要在<code class="fe ln lo lp lq b">example3_outer.py</code>中追加到<code class="fe ln lo lp lq b">sys.path</code>(为了清晰起见，我在下面的代码片段中把它们注释掉了)。</p><pre class="lu lv lw lx gt nn lq no np aw nq bi"><span id="d2aa" class="nr mq it lq b gy ns nt l nu nv"><strong class="lq jd">#example3_outer.py</strong></span><span id="3e71" class="nr mq it lq b gy nw nt l nu nv"><strong class="lq jd">#import os<br/>#import sys</strong></span><span id="7832" class="nr mq it lq b gy nw nt l nu nv"><strong class="lq jd">#fpath = os.path.join(os.path.dirname(__file__), 'utils')<br/>#sys.path.append(fpath)<br/>#print(sys.path)</strong></span><span id="ab3f" class="nr mq it lq b gy nw nt l nu nv">import length<br/>txt = "Hello"<br/>res_len = length.get_length(txt)<br/>print("The length of the string is: ",res_len)</span></pre><p id="faaf" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><em class="lr">注意:一旦关闭python，列表将恢复到以前的默认值。如果您想将一个目录永久添加到</em> <code class="fe ln lo lp lq b"><em class="lr">PYTHONPATH</em></code> <em class="lr">，请将导出命令(</em> <code class="fe ln lo lp lq b">export PYTHONPATH=$PYTHONPATH:$(pwd)/utils</code> ) <em class="lr">添加到您的</em> <code class="fe ln lo lp lq b"><em class="lr">~/.bashrc</em></code> <em class="lr">。(参见本</em><a class="ae ls" href="https://stackoverflow.com/questions/3402168/permanently-add-a-directory-to-pythonpath" rel="noopener ugc nofollow" target="_blank"><em class="lr">stack overflow</em></a><em class="lr">讨论)。</em></p><p id="7589" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">最后，定义了两个方法之后，让我们选择一个(基于您的偏好/用例)来导入剩余的两个模块—<code class="fe ln lo lp lq b">example3_outer.py</code>中的<code class="fe ln lo lp lq b">upper.py</code>和<code class="fe ln lo lp lq b">lower.py</code>。<br/> <em class="lr">(注:我用方法1只是为了好玩。)</em></p><pre class="lu lv lw lx gt nn lq no np aw nq bi"><span id="9cb5" class="nr mq it lq b gy ns nt l nu nv"><strong class="lq jd">#example3_outer.py</strong></span><span id="c4ba" class="nr mq it lq b gy nw nt l nu nv">import os<br/>import sys</span><span id="5449" class="nr mq it lq b gy nw nt l nu nv">fpath = os.path.join(os.path.dirname(__file__), 'utils')<br/>sys.path.append(fpath)</span><span id="8c3a" class="nr mq it lq b gy nw nt l nu nv">import length<br/><strong class="lq jd">import upper<br/>import lower</strong></span><span id="dc2b" class="nr mq it lq b gy nw nt l nu nv">txt = "Hello"</span><span id="1093" class="nr mq it lq b gy nw nt l nu nv">res_len = length.get_length(txt)<br/>print("The length of the string is: ",res_len)</span><span id="fe7a" class="nr mq it lq b gy nw nt l nu nv"><strong class="lq jd">res_up = upper.to_upper(txt)<br/>print("Uppercase txt: ", res_up)</strong></span><span id="c117" class="nr mq it lq b gy nw nt l nu nv"><strong class="lq jd">res_low = lower.to_lower(txt)<br/>print("Uppercase txt: ", res_low)</strong></span></pre><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi pe"><img src="../Images/1e0aa2b3989e9fb93e60c945d1cda312.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dfGq9E55lrI_ElkPFu93LA.png"/></div></div></figure><p id="7067" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">超级！这看起来真棒。然而，如果我们可以只做<code class="fe ln lo lp lq b">import utils</code>而不是单独导入其中的所有模块，那不是很好吗？毕竟，我们的用例表明我们确实需要所有这三个功能。那么我们该怎么做呢？</p><h2 id="1f45" class="nr mq it bd mr nz oa dn mv ob oc dp mz la od oe nb le of og nd li oh oi nf iz bi translated">我们什么时候需要__init__。py？</h2><p id="bca6" class="pw-post-body-paragraph kr ks it kt b ku nh kd kw kx ni kg kz la nj lc ld le nk lg lh li nl lk ll lm im bi translated">首先，让我们尝试在<code class="fe ln lo lp lq b">example3_outer.py</code>中导入<code class="fe ln lo lp lq b">utils</code>目录(在注释掉所有现有代码之后):</p><pre class="lu lv lw lx gt nn lq no np aw nq bi"><span id="033a" class="nr mq it lq b gy ns nt l nu nv"><strong class="lq jd">#example3_outer.py</strong></span><span id="a026" class="nr mq it lq b gy nw nt l nu nv">import utils</span></pre><p id="ec77" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">运行这个脚本不会导致任何错误，这是理所当然的——解释器会查看<code class="fe ln lo lp lq b">sys.path</code>内部，并在索引0处找到当前目录<code class="fe ln lo lp lq b">../Medium_Imports_Tutorial</code>。这就是找到<code class="fe ln lo lp lq b">utils</code>目录所需的全部内容。</p><p id="4d60" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">现在让我们尝试从<code class="fe ln lo lp lq b">utils</code>访问<code class="fe ln lo lp lq b">length.py</code>模块:</p><pre class="lu lv lw lx gt nn lq no np aw nq bi"><span id="22f8" class="nr mq it lq b gy ns nt l nu nv"><strong class="lq jd">#</strong><strong class="lq jd">example3_outer.py</strong></span><span id="f4ab" class="nr mq it lq b gy nw nt l nu nv">import utils</span><span id="4084" class="nr mq it lq b gy nw nt l nu nv">txt = "Hello"<br/>res = utils.length.get_length(txt)</span></pre><p id="d9c2" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">当您尝试运行这个脚本时，您会看到一个<code class="fe ln lo lp lq b">AttributeError: module ‘utils’ has no attribute ‘length’</code>。通俗地说，这意味着我们将无法访问<code class="fe ln lo lp lq b">utils</code>中的任何python脚本，因为解释器还不知道这是一个包！</p><p id="e547" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">我们可以通过在<code class="fe ln lo lp lq b">utils</code>文件夹中引入<code class="fe ln lo lp lq b">__init__.py</code>文件将这个目录变成一个包。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div class="gh gi pf"><img src="../Images/d49f1e3450dea218c403cceb71e969af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1296/format:webp/1*8Zhj0qhN3dF2Qr4E_R2exQ.png"/></div></figure><p id="d5b9" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">在<code class="fe ln lo lp lq b">__init__.py</code>中，我们导入所有我们认为对我们的项目必要的模块。</p><pre class="lu lv lw lx gt nn lq no np aw nq bi"><span id="7376" class="nr mq it lq b gy ns nt l nu nv"><strong class="lq jd"><em class="lr"># utils/__init__.py </em></strong><em class="lr">(incorrect way of importing)</em></span><span id="eeb2" class="nr mq it lq b gy nw nt l nu nv">from length import get_length<br/>from lower import to_lower<br/>from upper import to_upper</span></pre><p id="b75c" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">我们称之为<code class="fe ln lo lp lq b">example3_outer.py</code></p><pre class="lu lv lw lx gt nn lq no np aw nq bi"><span id="969a" class="nr mq it lq b gy ns nt l nu nv">import utils</span><span id="11da" class="nr mq it lq b gy nw nt l nu nv">txt = "Hello"<br/>res_low = utils.to_lower(txt)<br/>print(res_low)</span></pre><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi pg"><img src="../Images/e5148366b71a1d559a7c42460b68040d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DZyFiS12X_C3ucmLwKI--g.png"/></div></div></figure><p id="1bce" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">等一下！ <em class="lr">为什么运行</em> <code class="fe ln lo lp lq b"><em class="lr">example3_outer.py</em></code> <em class="lr">时会出现错误？</em> <br/>答:我们在上面的<code class="fe ln lo lp lq b">__init__.py</code>中导入模块的方式对你来说似乎是合理的——毕竟<code class="fe ln lo lp lq b">__init__.py</code>和<code class="fe ln lo lp lq b">length.py</code>(或<code class="fe ln lo lp lq b">lower.py</code>、<code class="fe ln lo lp lq b">upper.py</code>)在同一级别，所以没有理由<code class="fe ln lo lp lq b">from lower import to_lower</code>不工作。事实上，如果您单独运行这个<code class="fe ln lo lp lq b">init</code>文件，它将完美地执行(它不会给出任何输出，但仍然会成功执行)。</p><p id="5f7d" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">话虽如此，我们不能使用上述导入方式，因为即使<code class="fe ln lo lp lq b">length.py</code>和<code class="fe ln lo lp lq b">lower.py</code>与<code class="fe ln lo lp lq b">__init__.py</code>处于同一级别，这也不是调用<code class="fe ln lo lp lq b">init</code>的级别。实际上，我们从<code class="fe ln lo lp lq b">example3_outer.py</code>发出调用，因此<code class="fe ln lo lp lq b">sys.path</code>将只有<code class="fe ln lo lp lq b">example3_outer.py</code>的当前目录，即<code class="fe ln lo lp lq b">../Medium_Imports_Tutorial</code>来搜索<em class="lr">中的任何</em>导入。因此，当解释器在<code class="fe ln lo lp lq b">example3_outer.py</code>中遇到<code class="fe ln lo lp lq b">import utils</code>命令时，即使它移动到<code class="fe ln lo lp lq b">utils</code>目录中的<code class="fe ln lo lp lq b">__init__.py</code>，也不会自动更新<code class="fe ln lo lp lq b">sys.path</code>，解释器也无法知道在哪里可以找到名为<code class="fe ln lo lp lq b">length</code>的模块。我们必须以某种方式指向目录的位置。为此，我们可以在<code class="fe ln lo lp lq b">__init__.py </code>中使用相对或绝对导入(或如上所述设置<code class="fe ln lo lp lq b">PYTHONPATH</code>变量)。</p><blockquote class="mj mk ml"><p id="7c3d" class="kr ks lr kt b ku kv kd kw kx ky kg kz mm lb lc ld mn lf lg lh mo lj lk ll lm im bi translated">相对导入(不推荐):指定相对于调用脚本路径的路径。</p></blockquote><pre class="lu lv lw lx gt nn lq no np aw nq bi"><span id="9c5c" class="nr mq it lq b gy ns nt l nu nv"><strong class="lq jd"># utils/__init__.py</strong></span><span id="fe75" class="nr mq it lq b gy nw nt l nu nv">from .lower import to_lower<br/>from .upper import to_upper<br/>from .length import get_length</span></pre><p id="f554" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">我们使用点符号(<code class="fe ln lo lp lq b">.</code>或<code class="fe ln lo lp lq b">..</code>)来指定相对进口。lower前面的单个点指的是调用导入时所在的目录。这可以看作是从<code class="fe ln lo lp lq b">./lower.py</code>导入<code class="fe ln lo lp lq b">to_lower()</code>。类似地，模块名前的双点意味着从当前级别向上移动两级。</p><blockquote class="mj mk ml"><p id="e114" class="kr ks lr kt b ku kv kd kw kx ky kg kz mm lb lc ld mn lf lg lh mo lj lk ll lm im bi translated">绝对导入(更好的选择):指定从项目根目录(或sys.path可以访问的任何其他目录)导入的模块的绝对路径。</p></blockquote><pre class="lu lv lw lx gt nn lq no np aw nq bi"><span id="46ee" class="nr mq it lq b gy ns nt l nu nv"><strong class="lq jd"># utils/__init__.py</strong></span><span id="6736" class="nr mq it lq b gy nw nt l nu nv">from utils.lower import to_lower<br/>from utils.upper import to_upper<br/>from utils.length import get_length</span></pre><p id="d09e" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">现在，与相对进口相比，它包含了更多的信息，而且不容易被破解。此外，如上所述，<code class="fe ln lo lp lq b">sys.path</code>可以访问项目根目录，即<code class="fe ln lo lp lq b">../Medium_Imports_Tutorial</code>，从那里可以轻松搜索<code class="fe ln lo lp lq b">utils</code>目录。(为什么？因为它是项目根目录的直接子目录)。</p><p id="4905" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><strong class="kt jd">当我们导入一个定义了</strong> <code class="fe ln lo lp lq b"><strong class="kt jd">__init__.py</strong></code> <strong class="kt jd">的包时会发生什么？</strong>这是一个初始化步骤，是我们导入包时执行的第一个文件。考虑到我们在这里做了所有必要的导入，调用脚本中的代码要干净得多。例如:</p><pre class="lu lv lw lx gt nn lq no np aw nq bi"><span id="ef21" class="nr mq it lq b gy ns nt l nu nv"><strong class="lq jd">#example3_outer.py</strong></span><span id="4050" class="nr mq it lq b gy nw nt l nu nv"><strong class="lq jd">import utils</strong></span><span id="1c7b" class="nr mq it lq b gy nw nt l nu nv">txt = "Hello"<br/>res_len = <strong class="lq jd">utils.get_length</strong>(txt)<br/>print(res_len)</span><span id="5f1a" class="nr mq it lq b gy nw nt l nu nv">res_up = <strong class="lq jd">utils.to_upper</strong>(txt)<br/>print(res_up)</span><span id="ab0f" class="nr mq it lq b gy nw nt l nu nv">res_low = <strong class="lq jd">utils.to_lower</strong>(txt)<br/>print(res_low)</span></pre><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi ph"><img src="../Images/214bb90dfc19ce343524ee963d5c679a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qHucSt2jOi2Q7oTjOpySqA.png"/></div></div></figure><p id="a4ee" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">厉害！现在我们已经将我们的<code class="fe ln lo lp lq b">utils</code>目录转换成了一个包。这个包的美妙之处在于，它可以被导入到任何地方，并且几乎可以立即使用。让我们看看如何在<code class="fe ln lo lp lq b">scripts</code>目录中使用这个包。让我们在<code class="fe ln lo lp lq b">scripts</code>中创建一个名为<code class="fe ln lo lp lq b">example3.py</code>的新文件。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/8fd0177da4046d3282a29ef8f0b32f3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1300/format:webp/1*q_dh3G4Xb_s081Zt_tT-5g.png"/></div></figure><pre class="lu lv lw lx gt nn lq no np aw nq bi"><span id="bed1" class="nr mq it lq b gy ns nt l nu nv"><strong class="lq jd"># scripts/example3.py</strong></span><span id="75da" class="nr mq it lq b gy nw nt l nu nv">import os<br/>import sys</span><span id="cc2d" class="nr mq it lq b gy nw nt l nu nv">PROJECT_ROOT = os.path.abspath(os.path.join(<br/>                  os.path.dirname(__file__), <br/>                  os.pardir)<br/>)<br/>sys.path.append(PROJECT_ROOT)</span><span id="f247" class="nr mq it lq b gy nw nt l nu nv"><br/>import utils<br/>print(utils.get_length("Hello"))</span><span id="e44c" class="nr mq it lq b gy nw nt l nu nv">************** OUTPUT *********<br/>5</span></pre><p id="1f46" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">需要考虑的事情很少:</p><ul class=""><li id="7d58" class="oo op it kt b ku kv kx ky la oq le or li os lm ot ou ov ow bi translated">在导入<code class="fe ln lo lp lq b">utils</code>包之前，我们必须确保<code class="fe ln lo lp lq b">utils</code>的父目录，即项目根目录可以被Python解释器访问。假设它会默认发生是不明智的，主要是因为我们现在在项目根目录中的一个级别(我们从<code class="fe ln lo lp lq b">scripts/example3.py</code>运行脚本)，<code class="fe ln lo lp lq b">sys.path</code>将在索引0处有<code class="fe ln lo lp lq b">../Medium/Imports_Tutorial/scripts</code>。</li><li id="80ae" class="oo op it kt b ku ox kx oy la oz le pa li pb lm ot ou ov ow bi translated"><code class="fe ln lo lp lq b">os.path.dirname(__file__)</code>将给出当前脚本的目录名，而<code class="fe ln lo lp lq b">os.pardir</code>将使用点符号给出父目录的路径，即<code class="fe ln lo lp lq b">..</code>。总而言之，<code class="fe ln lo lp lq b">os.path.abspath</code>将提供项目根的绝对路径。</li></ul><p id="da7c" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">额外好处:我们甚至可以将其他目录中的模块添加到我们的<code class="fe ln lo lp lq b">__init__.py</code>中。例如，让我们引入在<code class="fe ln lo lp lq b">scripts/example1.py</code>中定义的<code class="fe ln lo lp lq b">yolo()</code>。</p><pre class="lu lv lw lx gt nn lq no np aw nq bi"><span id="e29c" class="nr mq it lq b gy ns nt l nu nv"><strong class="lq jd"># utils/__init__.py</strong></span><span id="a535" class="nr mq it lq b gy nw nt l nu nv">from utils.lower import to_lower<br/>from utils.upper import to_upper<br/>from utils.length import get_length</span><span id="8b27" class="nr mq it lq b gy nw nt l nu nv"><strong class="lq jd">from scripts.example1 import yolo</strong></span></pre><p id="596a" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">在<code class="fe ln lo lp lq b">example3.py</code>中调用该函数</p><pre class="lu lv lw lx gt nn lq no np aw nq bi"><span id="3605" class="nr mq it lq b gy ns nt l nu nv"><strong class="lq jd"># scripts/example3.py</strong></span><span id="1917" class="nr mq it lq b gy nw nt l nu nv">import os<br/>import sys</span><span id="6ff2" class="nr mq it lq b gy nw nt l nu nv">PROJECT_ROOT = os.path.abspath(os.path.join(<br/>                  os.path.dirname(__file__), <br/>                  os.pardir)<br/>)<br/>sys.path.append(PROJECT_ROOT)</span><span id="c313" class="nr mq it lq b gy nw nt l nu nv">import utils<br/>print(utils.get_length("Hello"))<br/><strong class="lq jd">utils.yolo(2)</strong></span><span id="fad4" class="nr mq it lq b gy nw nt l nu nv">************** OUTPUT *********<br/>5<br/><strong class="lq jd">You only LIve 2 times.</strong></span></pre></div><div class="ab cl pi pj hx pk" role="separator"><span class="pl bw bk pm pn po"/><span class="pl bw bk pm pn po"/><span class="pl bw bk pm pn"/></div><div class="im in io ip iq"><h1 id="b7e9" class="mp mq it bd mr ms pp mu mv mw pq my mz ki pr kj nb kl ps km nd ko pt kp nf ng bi translated">结论</h1><p id="b412" class="pw-post-body-paragraph kr ks it kt b ku nh kd kw kx ni kg kz la nj lc ld le nk lg lh li nl lk ll lm im bi translated">老实说，导入错误在开始的时候真的让我很害怕，因为这是我从来不需要担心的一个方面。多年来，我已经学会了一个有用的技巧——对于你试图使用<code class="fe ln lo lp lq b">import XYZ</code>导入的任何包/模块，确保Python解释器可以访问它。如果没有，更新<code class="fe ln lo lp lq b">sys.path</code>或者更好地将相关目录附加到<code class="fe ln lo lp lq b">PYTHONPATH</code>变量，避免在脚本中处理它。</p><p id="80f8" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">一如既往，如果有更简单的方法来做/解释本文中提到的一些事情，一定要让我知道。一般来说，避免不请自来的破坏性/垃圾/敌意评论！</p><p id="0c9e" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">直到下一次✨</p></div><div class="ab cl pi pj hx pk" role="separator"><span class="pl bw bk pm pn po"/><span class="pl bw bk pm pn po"/><span class="pl bw bk pm pn"/></div><div class="im in io ip iq"><p id="767e" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">我喜欢写循序渐进的初学者指南、操作指南、面试问题、ML/AI中使用的解码术语等。如果你想完全访问我的所有文章(以及其他作家在媒体上的文章)，那么你可以使用 <a class="ae ls" href="https://varshitasher.medium.com/membership" rel="noopener"> <strong class="kt jd"> <em class="lr">我的链接</em></strong></a><strong class="kt jd"><em class="lr"/></strong><em class="lr">这里</em> <strong class="kt jd"> <em class="lr">注册。</em> </strong></p><div class="pu pv gp gr pw px"><a rel="noopener follow" target="_blank" href="/step-by-step-guide-to-explaining-your-ml-project-during-a-data-science-interview-81dfaaa408bf"><div class="py ab fo"><div class="pz ab qa cl cj qb"><h2 class="bd jd gy z fp qc fr fs qd fu fw jc bi translated">在数据科学面试中解释你的ML项目的逐步指南。</h2><div class="qe l"><h3 class="bd b gy z fp qc fr fs qd fu fw dk translated">在结尾有一个额外的样本脚本，让你谨慎地展示你的技术技能！</h3></div><div class="qf l"><p class="bd b dl z fp qc fr fs qd fu fw dk translated">towardsdatascience.com</p></div></div><div class="qg l"><div class="qh l qi qj qk qg ql md px"/></div></div></a></div><div class="pu pv gp gr pw px"><a rel="noopener follow" target="_blank" href="/fine-tuning-hubert-for-emotion-recognition-in-custom-audio-data-using-huggingface-c2d516b41cd8"><div class="py ab fo"><div class="pz ab qa cl cj qb"><h2 class="bd jd gy z fp qc fr fs qd fu fw jc bi translated">使用Huggingface微调HuBERT用于定制音频数据中的情感识别</h2><div class="qe l"><h3 class="bd b gy z fp qc fr fs qd fu fw dk translated">构建自定义数据加载器、实验日志、改进指标的技巧和GitHub repo，如果您想了解…</h3></div><div class="qf l"><p class="bd b dl z fp qc fr fs qd fu fw dk translated">towardsdatascience.com</p></div></div><div class="qg l"><div class="qm l qi qj qk qg ql md px"/></div></div></a></div><div class="pu pv gp gr pw px"><a rel="noopener follow" target="_blank" href="/end-to-end-deep-learning-project-part-1-930af1e1e191"><div class="py ab fo"><div class="pz ab qa cl cj qb"><h2 class="bd jd gy z fp qc fr fs qd fu fw jc bi translated">端到端深度学习项目:第1部分</h2><div class="qe l"><h3 class="bd b gy z fp qc fr fs qd fu fw dk translated">用Keras实现迁移学习的高效网络图像分类模型</h3></div><div class="qf l"><p class="bd b dl z fp qc fr fs qd fu fw dk translated">towardsdatascience.com</p></div></div><div class="qg l"><div class="qn l qi qj qk qg ql md px"/></div></div></a></div><div class="pu pv gp gr pw px"><a href="https://varshitasher.medium.com/six-reasons-to-switch-to-this-podcast-app-today-3a396ada0a2b" rel="noopener follow" target="_blank"><div class="py ab fo"><div class="pz ab qa cl cj qb"><h2 class="bd jd gy z fp qc fr fs qd fu fw jc bi translated">今天切换到这个播客应用程序的六个理由！</h2><div class="qe l"><h3 class="bd b gy z fp qc fr fs qd fu fw dk translated">带上你的朋友。</h3></div><div class="qf l"><p class="bd b dl z fp qc fr fs qd fu fw dk translated">varshitasher.medium.com</p></div></div><div class="qg l"><div class="qo l qi qj qk qg ql md px"/></div></div></a></div></div></div>    
</body>
</html>