<html>
<head>
<title>Recursion vs Dynamic Programming — Fibonacci(Leetcode 509)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">递归与动态规划—斐波那契(李特代码509)</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/dynamic-programming-i-python-8b20387870f5?source=collection_archive---------2-----------------------#2021-10-03">https://towardsdatascience.com/dynamic-programming-i-python-8b20387870f5?source=collection_archive---------2-----------------------#2021-10-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/7255acc3fc9a4393232eb48cd767b1ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CpbL7dLFbdcl-aUSHfw05A.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">动态编程程序情节，图片由作者提供</p></figure><div class=""/><p id="4dfa" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在这篇博客中，我将使用Leetcode 509。以斐波那契数为例，用Python说明递归与动态编程的编码逻辑和复杂性。</p><p id="0509" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">该项目由<strong class="ke jg">马树恒</strong>建造。要查看使用的完整代码，请找到<a class="ae la" href="https://github.com/hzmsh/DynamicProgramming" rel="noopener ugc nofollow" target="_blank"> GitHub </a>。</p><h1 id="a802" class="lb lc jf bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">第1节:递归和动态编程简介</h1><h2 id="b6ff" class="lz lc jf bd ld ma mb dn lh mc md dp ll kn me mf lp kr mg mh lt kv mi mj lx mk bi translated"><strong class="ak"> 1.1背景</strong></h2><p id="eecc" class="pw-post-body-paragraph kc kd jf ke b kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv mp kx ky kz ij bi translated"><em class="mq">让我们从什么是递归开始</em></p><p id="1fba" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke jg">递归</strong>是一个函数调用自身直到到达基本用例的过程。而且在这个过程中，复杂的情况会被递归追踪，变得越来越简单。整个过程的结构是树状的。递归<strong class="ke jg">不存储任何值</strong>，直到到达最后一级(基本情况)。</p><p id="b192" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">而<strong class="ke jg">动态编程</strong>相比简单递归主要是一种优化。主要思想是将原始问题分解成可重复的模式，然后<strong class="ke jg">将结果存储为许多子答案</strong>。因此，我们<strong class="ke jg">不必在以后需要时重新计算</strong>前一步的答案。在大O方面，这种优化方法一般将时间复杂度从指数级降低到多项式级。</p><h2 id="f0a2" class="lz lc jf bd ld ma mb dn lh mc md dp ll kn me mf lp kr mg mh lt kv mi mj lx mk bi translated">1.2如何编写递归/动态编程脚本</h2><p id="0893" class="pw-post-body-paragraph kc kd jf ke b kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv mp kx ky kz ij bi translated"><em class="mq">动态编程和递归非常相似</em></p><ol class=""><li id="ae47" class="mr ms jf ke b kf kg kj kk kn mt kr mu kv mv kz mw mx my mz bi translated">递归和动态编程都是从我们初始化开始的基本情况开始的。</li></ol><p id="0c16" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">2.在我们写完基础案例之后，我们将试图找到问题逻辑流程所遵循的任何模式。一旦找到了，基本就完事了。</p><p id="80c7" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">3.主要区别在于，对于递归，我们<strong class="ke jg">不存储任何中间值</strong>，而动态编程却利用了这一点。</p><p id="f8ca" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">让我们更深入地了解一下斐波那契数列。</p><h1 id="d425" class="lb lc jf bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">第2部分:示例:Leetcode 509。斐波那契数</h1><h2 id="ab8e" class="lz lc jf bd ld ma mb dn lh mc md dp ll kn me mf lp kr mg mh lt kv mi mj lx mk bi translated">2.1问题提示</h2><blockquote class="na nb nc"><p id="6615" class="kc kd mq ke b kf kg kh ki kj kk kl km nd ko kp kq ne ks kt ku nf kw kx ky kz ij bi translated">通常表示为<code class="fe ng nh ni nj b">F(n)</code>的斐波那契数列形成了一个序列，称为斐波那契数列，从<code class="fe ng nh ni nj b">0</code>和<code class="fe ng nh ni nj b">1</code>开始，每个数字都是前面两个数字的和。也就是说，</p><p id="01e7" class="kc kd mq ke b kf kg kh ki kj kk kl km nd ko kp kq ne ks kt ku nf kw kx ky kz ij bi translated">F[0] = 0作为第一个数字</p><p id="9a18" class="kc kd mq ke b kf kg kh ki kj kk kl km nd ko kp kq ne ks kt ku nf kw kx ky kz ij bi translated">F[1] = 1作为我们的第二个数字</p><p id="8753" class="kc kd mq ke b kf kg kh ki kj kk kl km nd ko kp kq ne ks kt ku nf kw kx ky kz ij bi translated">之后的数字很容易计算:</p><p id="2c53" class="kc kd mq ke b kf kg kh ki kj kk kl km nd ko kp kq ne ks kt ku nf kw kx ky kz ij bi translated">F[n] = F[n-1] + F[n-2]</p><p id="c105" class="kc kd mq ke b kf kg kh ki kj kk kl km nd ko kp kq ne ks kt ku nf kw kx ky kz ij bi translated">给定n，我们如何找到F[n]?</p></blockquote><h2 id="b429" class="lz lc jf bd ld ma mb dn lh mc md dp ll kn me mf lp kr mg mh lt kv mi mj lx mk bi translated">2.2示例</h2><p id="2211" class="pw-post-body-paragraph kc kd jf ke b kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv mp kx ky kz ij bi translated">如果这是第一次听说斐波那契数，不要担心，这里有一些简单的例子来理解这个问题:</p><blockquote class="na nb nc"><p id="f769" class="kc kd mq ke b kf kg kh ki kj kk kl km nd ko kp kq ne ks kt ku nf kw kx ky kz ij bi translated">给定n = 2，F[2] = F[1] + F[0] = 0 + 1 = 1</p><p id="fc62" class="kc kd mq ke b kf kg kh ki kj kk kl km nd ko kp kq ne ks kt ku nf kw kx ky kz ij bi translated">给定n = 3，F[3] = F[2] + F[1] = 1+ 2= 3</p></blockquote><h1 id="13da" class="lb lc jf bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">第3节:两种方法</h1><h2 id="6356" class="lz lc jf bd ld ma mb dn lh mc md dp ll kn me mf lp kr mg mh lt kv mi mj lx mk bi translated">3.3递归方法</h2><p id="8b33" class="pw-post-body-paragraph kc kd jf ke b kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv mp kx ky kz ij bi translated">让我们从递归方法开始。</p><h2 id="35ed" class="lz lc jf bd ld ma mb dn lh mc md dp ll kn me mf lp kr mg mh lt kv mi mj lx mk bi translated">递归代码</h2><figure class="nk nl nm nn gt is"><div class="bz fp l di"><div class="no np l"/></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">递归代码，作者图片</p></figure><p id="5e1c" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">从上面的代码中，我们可以看到，我们做的第一件事总是寻找<strong class="ke jg">基本案例。</strong></p><p id="3d47" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在这种情况下，基本情况将是F[0] = 0和F[1] = 1，为了实现这种效果，我们将这两个条件显式地写在if下。</p><p id="3cc8" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在基本情况之后，下一步是考虑F[n]如何产生的一般模式。幸运的是，问题提示已经给出了模式:</p><blockquote class="na nb nc"><p id="aaa6" class="kc kd mq ke b kf kg kh ki kj kk kl km nd ko kp kq ne ks kt ku nf kw kx ky kz ij bi translated">F[n] = F[n-1] + F[n-2]</p></blockquote><p id="de15" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">因此，我们可以简单地返回结果F(n) = F(n-1) + F(n-2)。</p><h2 id="cfda" class="lz lc jf bd ld ma mb dn lh mc md dp ll kn me mf lp kr mg mh lt kv mi mj lx mk bi translated">3.3.2递归程序图</h2><p id="6417" class="pw-post-body-paragraph kc kd jf ke b kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv mp kx ky kz ij bi translated">如果n =4，该脚本将执行类似下面的操作:</p><figure class="nk nl nm nn gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nq"><img src="../Images/f65baa05339ff60146aee10d09be82ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WnzJmsVLxhXAhjXI9GUYDg.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">递归程序情节，图片由作者提供</p></figure><p id="d9c6" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们从最上面开始，这里F[4] = F[3] + F[2]。然后我们会试着求F[3]和F[2]的值。最终，当我们到达F[0] = 0，F[1] = 1的基本情况时，我们可以简单地从下往上求和，得到F[4] = 3。</p><h2 id="fc0f" class="lz lc jf bd ld ma mb dn lh mc md dp ll kn me mf lp kr mg mh lt kv mi mj lx mk bi translated">3.4动态规划方法</h2><h2 id="2a4e" class="lz lc jf bd ld ma mb dn lh mc md dp ll kn me mf lp kr mg mh lt kv mi mj lx mk bi translated">动态编程代码</h2><figure class="nk nl nm nn gt is"><div class="bz fp l di"><div class="no np l"/></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">动态编程代码，图片作者</p></figure><p id="df70" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">从上面的代码中，我们可以看到，我们做的第一件事是再次寻找<strong class="ke jg">的基本情况。</strong></p><p id="327a" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在这种情况下，基本情况将是F[0] = 0和F[1] = 1，为了实现这种效果，我们将这两个条件显式地写在if下。</p><p id="a7b3" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在我们完成基础案例之后，我们将<strong class="ke jg">创建一个空的动态编程数组</strong>来存储所有的中间和临时结果，以便更快地进行计算。由于n从0开始，我们将创建一个长度为n+1的列表。</p><p id="ebbe" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">下一步是考虑F[n]如何产生的一般模式。幸运的是，问题提示已经给出了模式:</p><blockquote class="na nb nc"><p id="56a0" class="kc kd mq ke b kf kg kh ki kj kk kl km nd ko kp kq ne ks kt ku nf kw kx ky kz ij bi translated">F[n] = F[n-1] + F[n-2]</p></blockquote><p id="7f99" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">因此，我们可以简单地返回结果F(n) = F(n-1) + F(n-2)。更具体地说:</p><blockquote class="na nb nc"><p id="7503" class="kc kd mq ke b kf kg kh ki kj kk kl km nd ko kp kq ne ks kt ku nf kw kx ky kz ij bi translated"><strong class="ke jg"> dp[i] = dp[i-2] + dp[i-1] </strong></p></blockquote><p id="bf06" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这实际上是动态编程和递归的主要区别。在递归中，我们不存储任何中间结果，而在动态编程中，我们存储所有中间步骤。</p><p id="ecb6" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">为了计算F[4]，我们会先计算F[2]，F[3]和<strong class="ke jg">将它们的值存储到我们事先创建的DP列表</strong>中。</p><h2 id="0bd6" class="lz lc jf bd ld ma mb dn lh mc md dp ll kn me mf lp kr mg mh lt kv mi mj lx mk bi translated">3.4.2动态编程程序图</h2><figure class="nk nl nm nn gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nr"><img src="../Images/8c72e72cd8cd47dc60de7ef00b6df1aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KeQ9h7cIMS5eI2SydsWT5A.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">动态编程程序情节，图片由作者提供</p></figure><p id="72c4" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们从最左边开始，这里F[0] =0，F[1] = 1。然后我们将试图找到F[4]的值，我们将首先找到F[3]和F[2]的值，并将它们的值存储到dp_list中。最终，当我们到达F[4] = 3的右边时，我们可以返回最终结果。</p><h1 id="b911" class="lb lc jf bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">第四节:时间和空间复杂性</h1><h2 id="1230" class="lz lc jf bd ld ma mb dn lh mc md dp ll kn me mf lp kr mg mh lt kv mi mj lx mk bi translated">4.1递归的大O</h2><p id="b018" class="pw-post-body-paragraph kc kd jf ke b kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv mp kx ky kz ij bi translated">对于递归，时间复杂度将是O(2^n，因为每个节点将分成两个子分支。</p><p id="e8fe" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">并且空间复杂度将是O(N ),因为树的深度将与N的大小成比例</p><p id="5028" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">以下是两者的Leetcode运行时结果:</p><figure class="nk nl nm nn gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ns"><img src="../Images/c81cabd76d652989671b26dc09e86953.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C8ZgTczBE7m_UK3NNpJYZA.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">Leetcode递归结果，图片由作者提供</p></figure><h2 id="cd79" class="lz lc jf bd ld ma mb dn lh mc md dp ll kn me mf lp kr mg mh lt kv mi mj lx mk bi translated">4.2动态编程的大O</h2><p id="0922" class="pw-post-body-paragraph kc kd jf ke b kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv mp kx ky kz ij bi translated">对于动态编程，时间复杂度是O(n ),因为我们只循环一次。正如你在动态编程程序图中看到的，它是线性的。</p><p id="bef3" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">并且空间复杂度将是O(N ),因为我们需要将所有中间值存储到dp_list中。所以我们需要的空间和给定的n一样。</p><p id="7378" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">以下是两者的Leetcode运行时结果:</p><figure class="nk nl nm nn gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ns"><img src="../Images/0ac31045d28548bb0ab370f45b12382c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iFb5zmXQZLZ0tjJei-_zAg.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">Leetcode动态编程结果，图片作者</p></figure><h2 id="4598" class="lz lc jf bd ld ma mb dn lh mc md dp ll kn me mf lp kr mg mh lt kv mi mj lx mk bi translated">4.2时间复杂性的可视化</h2><figure class="nk nl nm nn gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nt"><img src="../Images/31c4f1f6d530c5507943a1a7bc4e3639.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vK6WnzeZWJo3xC18j4rIRw.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">时间复杂度速度比较，图片作者</p></figure><p id="5d06" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">红线代表递归的时间复杂度，蓝线代表动态编程。x轴表示n的大小，y轴表示算法计算结果所需的时间。</p><h1 id="09a3" class="lb lc jf bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">第五部分:总结与结论</h1><p id="9d2d" class="pw-post-body-paragraph kc kd jf ke b kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv mp kx ky kz ij bi translated">简单回顾一下，下面总结了一些要点:</p><figure class="nk nl nm nn gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nu"><img src="../Images/abdce6089b0892516eedb3395a4a2d1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fEo6Uba_n03zbzdtRfbBhQ.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">两种算法的对照表，图片由作者提供</p></figure><p id="f8b5" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">从上面，我们可以观察到，尽管递归和动态编程都可以处理计算斐波那契数的任务，但它们在处理中间结果和<strong class="ke jg">时间消耗</strong>方面有很大的不同。动态编程使用同样多的空间，但是它比T4快得多。</p><p id="31ab" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">尽管这两种算法都需要几乎相同难度的努力来理解逻辑(我希望我的博客能对你有所帮助)，但在你掌握了算法的核心之后，这是值得的，因为大量的数组问题可以通过动态编程优雅而高效地解决。</p><p id="2f6f" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果你觉得你完全理解了上面的例子，并且想要更多的挑战，我计划在不久的将来使用动态编程来解决一系列博客中更困难和现实生活中的问题。感谢您的阅读！</p></div></div>    
</body>
</html>