<html>
<head>
<title>PyWriting A Command-Line Interface Simulation Game In Under 30 Minutes Using Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">py 使用 Python 在 30 分钟内编写一个命令行界面模拟游戏</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/writing-a-command-line-interface-simulation-game-in-under-30-minutes-using-python-239934f34365?source=collection_archive---------14-----------------------#2021-12-28">https://towardsdatascience.com/writing-a-command-line-interface-simulation-game-in-under-30-minutes-using-python-239934f34365?source=collection_archive---------14-----------------------#2021-12-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="251f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用一些简单的 Python 代码在几分钟内制作的快速游戏</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/dd9b78b0d66993437cdf6de9b3f0ef84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a1kI6Pxy4dYNYPjzYAehkA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><h1 id="2c44" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">介绍</h1><p id="9b66" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi mm translated">我非常喜欢给计算机编程，并让编程和软件工程变得如此诱人和有益的一点是，你可以通过一路上创建的数据系统，真正释放你的创造力和对问题的思考。我觉得有时候我有很酷的想法来处理问题，而且通常所有这些想法都可以很好地结合在一起，有时候——没那么好。这当然可以用来说明编码前计划的有效性。</p><p id="6074" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">也就是说，在最近写一篇关于 Click 模块的文章时，我决定用一个完整的软件来演示这个模块会很有趣，但是我也发现很难想象我到底想做什么。我认为这将是一个有趣的项目，因为这将是一个伟大的点击模块的应用程序，但我也认为这将是非常有趣的编程。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi na"><img src="../Images/3cabc685d5dcff5dfbf3617a64752b75.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XRPUgsc7NLR6pBbcr0emzg.png"/></div></div></figure><blockquote class="nb nc nd"><p id="7c49" class="lq lr ne ls b lt mv ju lv lw mw jx ly nf mx mb mc ng my mf mg nh mz mj mk ml im bi translated">看一下我的 Github 统计就知道了！</p></blockquote><p id="96c7" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">多有问题啊，看来我这辈子都没离开过笔记本。然而，本例中使用的语言有点像骗局，因为它是根据文件大小来确定的——Jupyter 笔记本包含各种不同内容的大量数据，它的代码比普通代码多得多，这就是我的观点。也就是说，Python 只占我在 Github 上的文件大小的 0.08%，我认为我应该着手开始一个 Python 项目。该项目的代码可在以下存储库中找到:</p><div class="ni nj gp gr nk nl"><a href="https://github.com/emmettgb/characterclash/tree/main" rel="noopener  ugc nofollow" target="_blank"><div class="nm ab fo"><div class="nn ab no cl cj np"><h2 class="bd iu gy z fp nq fr fs nr fu fw is bi translated">GitHub - emmettgb/characterclash:用 Python 编写的一个很酷的基于 repl 的小模拟</h2><div class="ns l"><h3 class="bd b gy z fp nq fr fs nr fu fw dk translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="nt l"><p class="bd b dl z fp nq fr fs nr fu fw dk translated">github.com</p></div></div><div class="nu l"><div class="nv l nw nx ny nu nz ks nl"/></div></div></a></div></div><div class="ab cl oa ob hx oc" role="separator"><span class="od bw bk oe of og"/><span class="od bw bk oe of og"/><span class="od bw bk oe of"/></div><div class="im in io ip iq"><h1 id="80fa" class="ky kz it bd la lb oh ld le lf oi lh li jz oj ka lk kc ok kd lm kf ol kg lo lp bi translated">获得基本视觉效果</h1><p id="d6ca" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">今天，我们将创建一个简洁的可视化界面，通过带有 ASCII 艺术的 CLI 来查看游戏的输出…这是本文前半部分的 Github 链接。以下是该分支机构的链接:</p><div class="ni nj gp gr nk nl"><a href="https://github.com/emmettgb/characterclash/tree/0.0.1-basic-functionality" rel="noopener  ugc nofollow" target="_blank"><div class="nm ab fo"><div class="nn ab no cl cj np"><h2 class="bd iu gy z fp nq fr fs nr fu fw is bi translated">GitHub-emmettgb/character clash 0 . 0 . 1-基本-功能</h2><div class="ns l"><h3 class="bd b gy z fp nq fr fs nr fu fw dk translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="nt l"><p class="bd b dl z fp nq fr fs nr fu fw dk translated">github.com</p></div></div><div class="nu l"><div class="om l nw nx ny nu nz ks nl"/></div></div></a></div><p id="c615" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">让我们首先导入我们所有的依赖项，以及我们可能得到的任何新的依赖项:</p><pre class="kj kk kl km gt on oo op oq aw or bi"><span id="d462" class="os kz it oo b gy ot ou l ov ow">import click as clk<br/>from numpy import random as rnd<br/>from time import sleep<br/>from os import system, name</span></pre><p id="01be" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">现在让我们开始学习一个基础课程，让我们可以开始制作这个的视觉效果:</p><pre class="kj kk kl km gt on oo op oq aw or bi"><span id="76ac" class="os kz it oo b gy ot ou l ov ow">class PlayGrid:</span><span id="cab5" class="os kz it oo b gy ox ou l ov ow">def __init__(self, players):<br/>        self.players = players</span></pre><p id="2291" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">我们真正需要初始化这个新类的是一个未来的玩家字典，每当我们加载这个游戏时，我们将在我们的主函数中提供这个字典。现在，我将编写一些未来的函数，随着我们逐步编写这些函数，它们将变得更加有用，让我们来看看结果:</p><pre class="kj kk kl km gt on oo op oq aw or bi"><span id="a01f" class="os kz it oo b gy ot ou l ov ow">class PlayGrid:</span><span id="1628" class="os kz it oo b gy ox ou l ov ow">def __init__(self, players):<br/>        self.players = players<br/>        draw_grid()<br/>    def update(self, message):<br/>        pass</span><span id="e8a1" class="os kz it oo b gy ox ou l ov ow">def move(dir, speed):<br/>        pass<br/>def draw_grid():<br/>    pass</span></pre><p id="eadb" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">像往常一样，我要练习提取技术。如果你想更深入地了解这项技术，以及它将如何应用到这个项目的未来代码中，我有一整篇关于它的文章，你可以在这里阅读——它有助于清理你的代码，使它运行得更好！</p><div class="ni nj gp gr nk nl"><a rel="noopener follow" target="_blank" href="/more-methods-means-better-code-1d3b237f6cf2"><div class="nm ab fo"><div class="nn ab no cl cj np"><h2 class="bd iu gy z fp nq fr fs nr fu fw is bi translated">更多的方法意味着更好的代码</h2><div class="nt l"><p class="bd b dl z fp nq fr fs nr fu fw dk translated">towardsdatascience.com</p></div></div><div class="nu l"><div class="oy l nw nx ny nu nz ks nl"/></div></div></a></div><p id="63f9" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">回到我们的网格，我还将创建一个单独的函数来绘制一个空网格。因为我们在其他地方不需要这个函数，所以我将私下声明它。现在，我不会太关注任何细节，所以我会画一些空白的地方。我将把这些值存储在一个字典中。字典将包含带有整数索引的字符串，类似于我可能用来处理不同玩家数量的玩家类的方法。</p><p id="445b" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">无论如何…如果我先写代码，然后再解释，这将会更好，因为我认为这样的组合可能会更合适，并使系统作为一个整体更有意义。</p><h2 id="a3d4" class="os kz it bd la oz pa dn le pb pc dp li lz pd pe lk md pf pg lm mh ph pi lo pj bi translated">网格</h2><pre class="kj kk kl km gt on oo op oq aw or bi"><span id="a196" class="os kz it oo b gy ot ou l ov ow">def empty_grid():<br/>        self.grid = dict()<br/>        str = ""<br/>        for row in range(1, 10):<br/>            str = ""<br/>            for i in range(1, 10):<br/>                str += "`"<br/>            self.grid[row] = str<br/>        return(self.grid)</span></pre><p id="03e1" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">我添加到这个类的第一个函数是用来创建一个空版本来添加我们的小玩家的函数。我将简单地用<code class="fe pk pl pm oo b">“`"</code>字符填充一些字符串。我们将能够通过调用 self.grid 字典来索引我们正在处理的实际行，并且我们将能够使用字典字符串值对来分别按 char 设置索引。我们将在另一个网格函数中调用它:</p><pre class="kj kk kl km gt on oo op oq aw or bi"><span id="807c" class="os kz it oo b gy ot ou l ov ow">def draw_grid():<br/>        self.empty_grid()</span></pre><p id="3591" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">请允许我通过一些简单的交互代码来解释这将会是什么，我将把这些代码写入我们的主函数中。在我们通过调用刚刚编写的 empty_grid()函数清空网格之后，我们现在将有一个新的表面可以查看。让我们继续绘制网格，首先用正则表达式创建一个新的打印字符串，返回 0 并跳过当前行。</p><pre class="kj kk kl km gt on oo op oq aw or bi"><span id="d1e3" class="os kz it oo b gy ot ou l ov ow">def draw_grid():<br/>        self.empty_grid()<br/>        print_s = "\n"</span></pre><p id="3ca7" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">别名 print_s 是 print string 的缩写。我们之前的数据，以及它未来的变化和一系列的正则表达式将成为我们最终的单行打印语句，只提供一种类型，这非常方便。我们将使用这个函数来测试 empty_grid()函数，方法是迭代地连接字符串，然后打印它们。这是我想到的:</p><pre class="kj kk kl km gt on oo op oq aw or bi"><span id="74b2" class="os kz it oo b gy ot ou l ov ow">def draw_grid():<br/>        empty_grid()<br/>        print_s = "\n"<br/>        for key in self.grid:<br/>            print_s = print_s + self.grid[key] + "\n"<br/>        return(print_s)</span><span id="4ab0" class="os kz it oo b gy ox ou l ov ow">def empty_grid():<br/>        self.grid = dict()<br/>        str = ""<br/>        for row in range(1, 10):<br/>            str = ""<br/>            for i in range(1, 10):<br/>                str += "`"<br/>            self.grid[row] = str</span></pre><p id="fb9b" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">这两个函数完美地结合在一起，在视觉上改变了我们的类型。我想说的一件事是，如果这没有意义，或者看起来像我们在随机组件上工作，这是对形势的明智看法。目前，这看起来并不多，但是在编程中最大的障碍总是开始。这是您开始软件流程的地方，事物被抽象地定义，以便它们可以适合另一个组件。在许多情况下，程序员可能会选择先做逻辑，再做视觉。然而，在这种情况下，我认为首先处理视觉效果是很有意义的，这样我们就可以根据屏幕上实际需要发生的事情来设计逻辑。毕竟，这个项目的主要组成部分是视觉效果。不管怎样，现在已经完成了，我们要测试这两个函数，以确保它能正常工作。</p><h2 id="7a81" class="os kz it bd la oz pa dn le pb pc dp li lz pd pe lk md pf pg lm mh ph pi lo pj bi translated">布局初始化</h2><p id="e363" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">现在，我们将花一点时间来关注初始化，以及更新整个打印输出所需的函数。这个更新函数现在将调用网格函数。我还必须创建一个清晰的()函数。</p><pre class="kj kk kl km gt on oo op oq aw or bi"><span id="462a" class="os kz it oo b gy ot ou l ov ow">def clear():<br/>    if name == 'nt':<br/>        _ = system('cls')<br/>    else:<br/>        _ = system('clear')</span></pre><p id="a05b" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">这个函数是系统化的，并且是全局定义的，因为它的目的是用这个命令快速清除整个 REPL。它只是为相应的终端类型调用系统的 clear 命令。我们问名字是不是 NT，就像在 Windows NT 中一样，如果是就用 cls。如果不是这样，我们使用 clear，因为在大多数情况下，其他系统将是 Unix-line。下面是更新函数:</p><pre class="kj kk kl km gt on oo op oq aw or bi"><span id="9311" class="os kz it oo b gy ot ou l ov ow">def update(self, message):<br/>        clear()<br/>        grid = self.draw_grid()<br/>        print(grid)<br/>        print(string("\n", message))</span></pre><p id="ce4a" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">这里发生了几件事，首先，任何先前的输出被清除。之后我们在这个函数的作用域里赋一个变量叫做 grid，这个变量就是 self.draw_grid 的返回。我们不需要在这里调用 return，但是在这种情况下这是很方便的，因为我们根本不希望我们的网格在工作的时候被改变。如果我们为这样的定义使用类作用域，那么当这个函数运行时，它可能会在其他地方发生变化。</p><p id="15e5" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">我们的 __init__ 函数就是用来总结所有这些的。将有更多的功能添加到这将扩展功能，但目前这是这个项目的核心功能。</p><pre class="kj kk kl km gt on oo op oq aw or bi"><span id="1c7d" class="os kz it oo b gy ot ou l ov ow">def __init__(self, players):<br/>        self.players = players<br/>        update()</span></pre><p id="152d" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">我在这里做的只是把类属性 players 赋给提供的参数 players，然后调用 update。现在，让我们全面看看这个类:</p><pre class="kj kk kl km gt on oo op oq aw or bi"><span id="c3e4" class="os kz it oo b gy ot ou l ov ow">class PlayGrid:</span><span id="727b" class="os kz it oo b gy ox ou l ov ow">def __init__(self, players):<br/>        self.players = players<br/>        self.update("Hello")</span><span id="8ae1" class="os kz it oo b gy ox ou l ov ow">def update(self, message):<br/>        clear()<br/>        grid = self.draw_grid()<br/>        print(grid)<br/>        print(string("\n", message))</span><span id="c52f" class="os kz it oo b gy ox ou l ov ow">def draw_grid(self):<br/>        self.empty_grid()<br/>        print_s = "\n"<br/>        for key in self.grid:<br/>            print_s = print_s + self.grid[key] + "\n"<br/>        return(print_s)</span><span id="23b8" class="os kz it oo b gy ox ou l ov ow">def empty_grid(self):<br/>        self.grid = dict()<br/>        str = ""<br/>        for row in range(1, 10):<br/>            str = ""<br/>            for i in range(1, 10):<br/>                str += "`"<br/>            self.grid[row] = str</span></pre><p id="7070" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">希望里面的一切都是正确的，但我想我们很快就会知道了。让我们运行这个宝贝:</p><pre class="kj kk kl km gt on oo op oq aw or bi"><span id="ec79" class="os kz it oo b gy ot ou l ov ow">[emmac@fedora CharacterClash]$ python3 character_clash.py<br/>`````````<br/>`````````<br/>`````````<br/>`````````<br/>`````````<br/>`````````<br/>`````````<br/>`````````<br/>`````````</span><span id="ce59" class="os kz it oo b gy ox ou l ov ow">Traceback (most recent call last):<br/>  File "/home/emmac/dev/CharacterClash/character_clash.py", line 48, in &lt;module&gt;<br/>    main()<br/>  File "/home/emmac/dev/CharacterClash/character_clash.py", line 8, in main<br/>    game = PlayGrid(players)<br/>  File "/home/emmac/dev/CharacterClash/character_clash.py", line 16, in __init__<br/>    self.update("Hello")<br/>  File "/home/emmac/dev/CharacterClash/character_clash.py", line 22, in update<br/>    print(string("\n", message))</span></pre><blockquote class="pn"><p id="d1d4" class="po pp it bd pq pr ps pt pu pv pw ml dk translated">哎哟</p></blockquote><p id="5e65" class="pw-post-body-paragraph lq lr it ls b lt px ju lv lw py jx ly lz pz mb mc md qa mf mg mh qb mj mk ml im bi translated">我犯了一个严重的“对不起，我是 Julia 程序员”的错误。我们需要使用加法运算符来连接这些字符串:</p><pre class="kj kk kl km gt on oo op oq aw or bi"><span id="720a" class="os kz it oo b gy ot ou l ov ow">print("\n" + message)</span><span id="11ca" class="os kz it oo b gy ox ou l ov ow">`````````<br/>`````````<br/>`````````<br/>`````````<br/>`````````<br/>`````````<br/>`````````<br/>`````````<br/>`````````</span><span id="031e" class="os kz it oo b gy ox ou l ov ow">Hello<br/>Hello</span></pre><h1 id="e4ad" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">演员</h1><p id="04e0" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">幸运的是，这个游戏是关于输出的—</p><blockquote class="pn"><p id="1a07" class="po pp it bd pq pr qc qd qe qf qg ml dk translated">在你的网络浏览器中，看着迷失的人工智能灵魂为你的娱乐而战斗到死。</p></blockquote><p id="215d" class="pw-post-body-paragraph lq lr it ls b lt px ju lv lw py jx ly lz pz mb mc md qa mf mg mh qb mj mk ml im bi translated">因此，这些类在某种程度上可以完全随机化。这就是作为旁观者的好处，你不必参与其中。因此，对于这个奇观，我们不需要编程任何类型的输入，这使得这个玩家的过程容易得多。在以后的文章中，我将添加命令行参数，并进一步推进这个小项目。</p><p id="55ac" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">另一件要注意的事情是，我们需要对网格做一些工作，也许是它未来的内容。我在想，如果我们在网格中添加一些不同的角色，它可能看起来更像随机的地面纹理——也就是说，因为它们不是让核心游戏工作所必需的，也许我会在未来的文章中讨论这个问题。让我们继续用所有的标准初始化材料创建一个玩家类，在此之前，我将为这个类列出一些数据值以供参考，以便为每个单独的类获得不同的统计数据:</p><pre class="kj kk kl km gt on oo op oq aw or bi"><span id="2550" class="os kz it oo b gy ot ou l ov ow"># Sword # bow # assassin<br/># Classes = ["o/", "o)", "o-"]<br/># stats = [speed, damage, range, time]</span><span id="2d83" class="os kz it oo b gy ox ou l ov ow">stats_dict = {"o/" : [2, 25, 2, 3],<br/>"o)" : [2, 35, 3, 5],<br/>"o-" : [3, 20, 3, 2]}</span></pre><p id="8e8d" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">这是我们的基本类:</p><pre class="kj kk kl km gt on oo op oq aw or bi"><span id="5dda" class="os kz it oo b gy ot ou l ov ow">class Player:<br/>    def __init__(self, pos):<br/>        pass</span></pre><h2 id="f456" class="os kz it bd la oz pa dn le pb pc dp li lz pd pe lk md pf pg lm mh ph pi lo pj bi translated">加载数据</h2><p id="7292" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">接下来，我们将把这些数据加载到这个类型中，还有一些其他的默认数据。</p><pre class="kj kk kl km gt on oo op oq aw or bi"><span id="1964" class="os kz it oo b gy ot ou l ov ow">class Player:<br/>    def __init__(self, pos):<br/>        self.pos = []<br/>        self.health = 100<br/>        self.blocking = True<br/>        self.attacking = False<br/>        type = random.choice(stats_dict.keys())<br/>        self.speed = stats_dict[type][1]</span></pre><p id="6a34" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">注意最后两行，首先我得到一个键的数组放入 random.choice 函数，然后产生一个选择，然后我们通过索引该键并从数组中提取值来应用数据。另外，Python 中的索引是从零开始的——所以我刚刚意识到代码中有一个小错误。无论如何，我们将对这些属性中的每一个都这样做:</p><pre class="kj kk kl km gt on oo op oq aw or bi"><span id="d38a" class="os kz it oo b gy ot ou l ov ow">class Player:<br/>    def __init__(self, pos):<br/>        self.pos = []<br/>        self.health = 100<br/>        self.blocking = True<br/>        self.attacking = False<br/>        type = random.choice(stats_dict.keys())<br/>        self.speed = stats_dict[type][0]<br/>        self.damage = stats_dict[type][1]<br/>        self.range = stats_dict[type][2]<br/>        self.time = stats_dict[type][3]</span></pre><p id="2b91" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">现在所有的数据都已经初始化了，让我们开始移动实际的字符。虽然我们可以使用 vector two 类型，或者类似的东西——也许可以创建我们自己的，但这不是我在这个例子中要做的。我觉得没有必要，因为索引这个位置向量很容易。查看添加了两个新方法头的完整类:</p><pre class="kj kk kl km gt on oo op oq aw or bi"><span id="40a8" class="os kz it oo b gy ot ou l ov ow">stats_dict = {"o/" : [2, 25, 2, 3],<br/>"o)" : [2, 35, 3, 5],<br/>"o-" : [3, 20, 3, 2]}<br/>class Player:<br/>    def __init__(self, pos):<br/>        self.pos = []<br/>        self.health = 100<br/>        self.blocking = True<br/>        self.attacking = False<br/>        type = random.choice(stats_dict.keys())<br/>        self.speed = stats_dict[type][0]<br/>        self.damage = stats_dict[type][1]<br/>        self.range = stats_dict[type][2]<br/>        self.time = stats_dict[type][3]<br/>        self.symbol = type</span><span id="47bf" class="os kz it oo b gy ox ou l ov ow">    def walk(self, pos):<br/>        pass</span><span id="287e" class="os kz it oo b gy ox ou l ov ow">    def move(self, players):<br/>        pass</span></pre><p id="1ffe" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">move(players)函数用于获取玩家数组，并基于此做出某种选择。现在，这一切都将被搁置，因为我们现在实际上要回到我们的旧 PlayGrid 类，然后开始映射这些球员的位置。</p><h1 id="c863" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">组合元素</h1><p id="6547" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">我们需要在我们的 PlayGrid 类中定义一个新函数，以便从前面的网格字典中获取并修改它来包含这些字符。好消息是，我们可以简单地使用索引在适当的位置显示我们的玩家。</p><pre class="kj kk kl km gt on oo op oq aw or bi"><span id="9a79" class="os kz it oo b gy ot ou l ov ow">class PlayGrid:<br/>        # Essentials<br/>    def __init__(self, players):<br/>        self.players = players<br/>        self.update("Character Crash Game Started")</span><span id="f5d7" class="os kz it oo b gy ox ou l ov ow">def update(self, message):<br/>        clear()<br/>        grid = self.draw_grid()<br/>        print(grid)<br/>        print("\n" + message)</span><span id="ce18" class="os kz it oo b gy ox ou l ov ow"># Player Management<br/>    def draw_players(grid):</span></pre><h2 id="2ffc" class="os kz it bd la oz pa dn le pb pc dp li lz pd pe lk md pf pg lm mh ph pi lo pj bi translated">绘图播放器</h2><p id="f3d8" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">我们的新功能 draw_players(grid)将简单地获取玩家及其各自的索引，然后将玩家角色放在这些索引处，取代之前的位置。我们要做的第一件事是决定向哪个方向绘制字符。换句话说，字符是面向右还是面向左:</p><pre class="kj kk kl km gt on oo op oq aw or bi"><span id="c34c" class="os kz it oo b gy ot ou l ov ow">for player in self.players:<br/>            # True = right, False = left<br/>            if player.facing == True<br/>                modifier = 1<br/>            else:<br/>                modifier = -1</span></pre><p id="c62c" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">我们需要将这个修饰符添加到一个索引中，以确定该值应该在字符的后面还是前面。我们将在玩家类中处理剩下的部分。我们暂时不会做所有的事情，因为我们有一个函数要写。你可能已经注意到我也打开了一个 for 循环。这是至关重要的，因为我们需要单独调用每个球员的数据来做我们需要用它做的工作。</p><p id="d523" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">这背后的方法很简单。在字典中，坐标平面的 y 是键。正如我们在 empty_grid()函数中所做的那样，这些只是由一个范围生成器生成的。然后我们有 x，它是字典的值对。记住，要在一个特定的位置设置一个字符，我们需要用我们的 y 键索引字典，这是我们的 pos 列表中的位置 2，然后我们需要用我们的 x 值索引它的返回，这是我们需要替换的字符在我们的字符串中的位置。</p><pre class="kj kk kl km gt on oo op oq aw or bi"><span id="b52f" class="os kz it oo b gy ot ou l ov ow"># [0] = x, [1] = y<br/>            newpos = player.pos<br/>            x, y = newpos[0]<br/>            grid[y][x] = player.symbol[0]<br/>            grid[y][x + modifier] = player.symbol[1]</span></pre><p id="3574" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">最后，我们将返回网格，正如我之前提到的，我们将不再使用 class 属性，因为我们将在最后更新它。</p><pre class="kj kk kl km gt on oo op oq aw or bi"><span id="27e0" class="os kz it oo b gy ot ou l ov ow">def draw_players(grid):<br/>        for player in self.players:<br/>            # True = right, False = left<br/>            if player.facing == True<br/>                modifier = 1<br/>            else:<br/>                modifer = -1<br/>                # [0] = x, [1] = y<br/>            newpos = player.pos<br/>            x, y = newpos[0]<br/>            grid[y][x] = player.symbol[0]<br/>            grid[y][x + modifier] = player.symbol[1]<br/>        return(grid)</span></pre><p id="bde8" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">现在我们已经写好了这个函数，我们要再写一个函数，叫做 make_moves(players)。这个函数将调用我们玩家的移动函数。</p><pre class="kj kk kl km gt on oo op oq aw or bi"><span id="add7" class="os kz it oo b gy ot ou l ov ow">def make_moves(players):<br/>        [player.move(players) for player in players]<br/>        return</span></pre><p id="7a6c" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">从这个意义上说，移动不像从[x，y]到[x，y]，这就是我们 walk()函数的作用。相反，我们的移动功能指定轮到他们做什么。现在，我们将回到我们的球员类，并整理出一个基本的结构，这个东西最初可能会对其环境作出反应。在未来，我将为这个项目实现一个机器学习算法，这将使这个项目变得更酷。</p><p id="0b30" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">现在，我只想看看一些运动可能是什么样子，记住，我要试着写一个简单的小行走模式:</p><pre class="kj kk kl km gt on oo op oq aw or bi"><span id="1ed5" class="os kz it oo b gy ot ou l ov ow">def move(self, players):<br/>        if self.blocking == False<br/>            self.pos += 1<br/>            self.blocking = True<br/>        elif self.blocking == True:<br/>            self.pos -= 1<br/>            self.blocking = False</span><span id="bca1" class="os kz it oo b gy ox ou l ov ow">self.blocking = False</span></pre><p id="1705" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">这个基本的小函数只是让我们的玩家在网格上走来走去，让我们稍微包装一下我们的主函数，测试一下数据和显示的关系。</p><pre class="kj kk kl km gt on oo op oq aw or bi"><span id="b8c5" class="os kz it oo b gy ot ou l ov ow">def move(self, players):<br/>        if self.blocking == False:<br/>            self.pos += 1<br/>            self.blocking = True<br/>        if self.blocking == True:<br/>            self.pos -= 1<br/>            self.blocking = False</span><span id="cac9" class="os kz it oo b gy ox ou l ov ow"># self.blocking = False</span></pre><p id="0b2b" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">在不久的将来，唯一保留下来的代码是被注释掉的部分。在未来，这将完全是随机的，直到我在下一篇文章中加入一些人工智能。既然我们在这里，我们不妨添加前面的 facing 属性:</p><pre class="kj kk kl km gt on oo op oq aw or bi"><span id="a4c2" class="os kz it oo b gy ot ou l ov ow">class Player:<br/>    def __init__(self, pos):<br/>        self.pos = []<br/>        self.health = 100<br/>        self.blocking = True<br/>        self.attacking = False<br/>        type = random.choice(stats_dict.keys())<br/>        self.speed = stats_dict[type][0]<br/>        self.damage = stats_dict[type][1]<br/>        self.range = stats_dict[type][2]<br/>        self.time = stats_dict[type][3]<br/>        self.symbol = type<br/>        self.facing = True</span></pre><h1 id="ad60" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">到目前为止…</h1><p id="f8af" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">到目前为止，我们已经制作了一个玩家网格和将居住在该网格上的玩家。我们需要看看到目前为止所有的代码是否都有效。我们现在需要做的就是稍微调整一下我们的主函数，将一个玩家添加到我们的玩家列表中。另一个随机注意，我也调整了 REPL 打印输出的尺寸。这意味着网格现在比以前大得多。</p><pre class="kj kk kl km gt on oo op oq aw or bi"><span id="aa33" class="os kz it oo b gy ot ou l ov ow">def main():<br/>    players = []<br/>    game = PlayGrid(players)<br/>    game.update("Hello")<br/>#    while len(game.players) &lt; 1:<br/>    sleep(2)</span></pre><p id="cd6f" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">我们需要在玩家列表中添加一个玩家。这相当简单，我们将创建一个新玩家——毕竟，它目前唯一需要的是一个位置。下面是修改后的 main()函数:</p><pre class="kj kk kl km gt on oo op oq aw or bi"><span id="afe7" class="os kz it oo b gy ot ou l ov ow">def main():<br/>    players = []<br/>    players.append(Player([5, 6]))<br/>    game = PlayGrid(players)<br/>    game.update("Up")<br/>#    while len(game.players) &lt; 1:<br/>    sleep(2)<br/>    game.update("Down")<br/>    sleep(2)<br/>    game.update("Up")<br/>    sleep(2)<br/>    game.update("Down")</span></pre><p id="50de" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">希望我没记错！</p><pre class="kj kk kl km gt on oo op oq aw or bi"><span id="833a" class="os kz it oo b gy ot ou l ov ow">[emmac@fedora CharacterClash]$ python3 character_clash.py</span><span id="2977" class="os kz it oo b gy ox ou l ov ow">File "/home/emmac/dev/CharacterClash/character_clash.py", line 43, in draw_players<br/>    x, y = newpos[0], newpos[1]<br/>IndexError: list index out of range</span></pre><blockquote class="nb nc nd"><p id="a03a" class="lq lr ne ls b lt mv ju lv lw mw jx ly nf mx mb mc ng my mf mg nh mz mj mk ml im bi translated">让我们看一看…</p></blockquote><p id="05af" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">问题来自这里:</p><pre class="kj kk kl km gt on oo op oq aw or bi"><span id="afb0" class="os kz it oo b gy ot ou l ov ow">class Player:<br/>    def __init__(self, pos):<br/>        self.pos = []</span></pre><p id="30b7" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">我的意思是提供 pos，然后把它设置成那样，但是它被设置成一个空列表——有趣。</p><pre class="kj kk kl km gt on oo op oq aw or bi"><span id="2c11" class="os kz it oo b gy ot ou l ov ow">File "/home/emmac/dev/CharacterClash/character_clash.py", line 44, in draw_players<br/>    grid[y][x] = player.symbol[0]<br/>TypeError: 'str' object does not support item assignment</span></pre><p id="f5fa" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">哦，糟糕，看起来我解决这个问题的方法是愚蠢的。这可能比预期的要多一点。幸运的是，有一些很好的方法可以解决这个问题，其中一些我可能在我的 Pythonic 标签处理综合指南中提到过，您可以在这里查看:</p><div class="ni nj gp gr nk nl"><a rel="noopener follow" target="_blank" href="/essential-python-string-processing-techniques-aa5be43a4f1f"><div class="nm ab fo"><div class="nn ab no cl cj np"><h2 class="bd iu gy z fp nq fr fs nr fu fw is bi translated">Python 字符串处理的基本技术</h2><div class="ns l"><h3 class="bd b gy z fp nq fr fs nr fu fw dk translated">在 Python 中处理字符串类型数据的完整过程</h3></div><div class="nt l"><p class="bd b dl z fp nq fr fs nr fu fw dk translated">towardsdatascience.com</p></div></div><div class="nu l"><div class="qh l nw nx ny nu nz ks nl"/></div></div></a></div><blockquote class="nb nc nd"><p id="dfc9" class="lq lr ne ls b lt mv ju lv lw mw jx ly nf mx mb mc ng my mf mg nh mz mj mk ml im bi translated">这次失败的真正原因是，Julia 允许你做任何事情，所以如果我想替换一个字符串索引，我可以导入并扩展索引方法来实现… Julia 太棒了，它毁了我的这个项目。</p></blockquote><h1 id="ce04" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">解决我们的问题</h1><p id="8f97" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">为了解决这个问题，我们将通过使它变得非常简单来反抗 Python 之类的东西。我们要做的第一件事是将字符串转换成列表类型。我们知道我们可以设置这种类型的索引，所以我们知道这种方法会有效。然后，我们将使用 str.join()将我们的字符串与新的字符串列表连接起来。</p><pre class="kj kk kl km gt on oo op oq aw or bi"><span id="390e" class="os kz it oo b gy ot ou l ov ow">&gt;&gt;&gt; list("Hello")<br/>['H', 'e', 'l', 'l', 'o']<br/>&gt;&gt;&gt; "".join(list("Hello"))<br/>'Hello'<br/>&gt;&gt;&gt;</span></pre><p id="7f35" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">让我们回头看看导致这种情况的函数:</p><pre class="kj kk kl km gt on oo op oq aw or bi"><span id="0b88" class="os kz it oo b gy ot ou l ov ow">def draw_players(self, grid):<br/>        for player in self.players:<br/>            # True = right, False = left<br/>            if player.facing == True:<br/>                modifier = 1<br/>            else:<br/>                modifer = -1<br/>                # [0] = x, [1] = y<br/>            newpos = player.pos<br/>            x, y = newpos[0], newpos[1]<br/>            grid[y][x] = player.symbol[0]<br/>            grid[y][x] + modifier] = player.symbol[1]<br/>        return(grid)</span></pre><p id="2ad8" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">我们将从将网格转换成 for 循环底部的列表开始:</p><pre class="kj kk kl km gt on oo op oq aw or bi"><span id="941b" class="os kz it oo b gy ot ou l ov ow">newpos = player.pos<br/>current = list(grid[newpos[1]])</span></pre><p id="8e17" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">现在我们有了 current，这是我们当前列的一个字符串，它是通过获取我们的 y 值获得的，y 值是我们的 newpos 列表中的第二个位置(1，不是 2)。</p><p id="1e5b" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">这是最后一个新函数:</p><pre class="kj kk kl km gt on oo op oq aw or bi"><span id="64e2" class="os kz it oo b gy ot ou l ov ow">def draw_players(self, grid):<br/>        for player in self.players:<br/>            # True = right, False = left<br/>            if player.facing == True:<br/>                modifier = 1<br/>            else:<br/>                modifer = -1<br/>                # [0] = x, [1] = y<br/>            newpos = player.pos<br/>            current = list(grid[newpos[1])</span><span id="b95d" class="os kz it oo b gy ox ou l ov ow">current[newpos[0]] = player.symbol[0]<br/>            current [newpos + modifier] = player.symbol[2]<br/>            current = "".join(current)<br/>            grid[y] = current<br/>        return(grid)</span></pre><p id="7304" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">老实说，这里有很多地方我不得不修改，但这里是对该函数的最后一次检查，它现在工作得非常完美:</p><pre class="kj kk kl km gt on oo op oq aw or bi"><span id="c4d2" class="os kz it oo b gy ot ou l ov ow">def draw_players(self, grid):<br/>        for player in self.players:<br/>            # True = right, False = left<br/>            if player.facing == True:<br/>                modifier = 1<br/>            else:<br/>                modifer = -1<br/>                # [0] = x, [1] = y<br/>            newpos = player.pos<br/>            current = list(grid[newpos[1]])<br/>            current[newpos[0]] = player.symbol[0]<br/>            current[newpos[0] + modifier] = player.symbol[1]<br/>            current = "".join(current)<br/>            self.grid[newpos[1]] = current</span></pre><p id="43a2" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">我也不得不在这里和那里做一些调整，主要是</p><ul class=""><li id="1250" class="qi qj it ls b lt mv lw mw lz qk md ql mh qm ml qn qo qp qq bi translated">不得不调整播放器的 move()函数，位置正在调用。由于某种原因，它们没有被编入索引。</li><li id="cce7" class="qi qj it ls b lt qr lw qs lz qt md qu mh qv ml qn qo qp qq bi translated">有几个愚蠢的索引错误，还有一些地方我忘了写自己。</li><li id="49ba" class="qi qj it ls b lt qr lw qs lz qt md qu mh qv ml qn qo qp qq bi translated">我必须稍微修改一下主函数，以及 draw_grid()、empty_grid()和 update()函数的返回。</li></ul><p id="69bc" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">这是我们的新班级:</p><pre class="kj kk kl km gt on oo op oq aw or bi"><span id="4c17" class="os kz it oo b gy ot ou l ov ow">class PlayGrid:<br/>        # Essentials<br/>    def __init__(self, players):<br/>        self.players = players<br/>        self.update("Character Clash Game Started")</span><span id="afc4" class="os kz it oo b gy ox ou l ov ow">def update(self, message):<br/>        clear()<br/>        self.empty_grid()<br/>        self.draw_players(self.grid)<br/>        self.make_moves()<br/>        print(self.draw_grid())<br/>        print("\n" + message)</span><span id="db47" class="os kz it oo b gy ox ou l ov ow"># Player Management<br/>    def draw_players(self, grid):<br/>        for player in self.players:<br/>            # True = right, False = left<br/>            if player.facing == True:<br/>                modifier = 1<br/>            else:<br/>                modifer = -1<br/>                # [0] = x, [1] = y<br/>            newpos = player.pos<br/>            current = list(grid[newpos[1]])<br/>            current[newpos[0]] = player.symbol[0]<br/>            current[newpos[0] + modifier] = player.symbol[1]<br/>            current = "".join(current)<br/>            self.grid[newpos[1]] = current</span><span id="8034" class="os kz it oo b gy ox ou l ov ow">def make_moves(self):<br/>        [player.move(self.players) for player in self.players]</span><span id="4940" class="os kz it oo b gy ox ou l ov ow"># Grid<br/>    def draw_grid(self):<br/>        print_s = "\n"<br/>        for key in self.grid:<br/>            print_s = print_s + self.grid[key] + "\n"<br/>        return(print_s)</span><span id="5ace" class="os kz it oo b gy ox ou l ov ow">def empty_grid(self):<br/>        self.grid = dict()<br/>        str = ""<br/>        for row in range(1, 30):<br/>            str = ""<br/>            for i in range(1, 100):<br/>                str += "`"<br/>            self.grid[row] = str</span></pre><p id="c768" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">这是我们新的 main()函数:</p><pre class="kj kk kl km gt on oo op oq aw or bi"><span id="9488" class="os kz it oo b gy ot ou l ov ow">def main():<br/>    players = []<br/>    players.append(Player([5, 6]))<br/>    game = PlayGrid(players)<br/>    game.update("Up")<br/>#    while len(game.players) &lt; 1:<br/>    sleep(2)<br/>    game.update("Down")<br/>    sleep(2)<br/>    game.update("Up")<br/>    sleep(2)<br/>    game.update("Down")</span></pre><p id="8019" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">现在让我们运行它！</p><pre class="kj kk kl km gt on oo op oq aw or bi"><span id="652c" class="os kz it oo b gy ot ou l ov ow">[emmac@fedora CharacterClash]$ python3 character_clash.py</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qw"><img src="../Images/7595e258b0e9554f0604b8476398f135.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5sDuoDGdb8YGHkWSErdKTQ.png"/></div></div></figure><blockquote class="pn"><p id="75f7" class="po pp it bd pq pr ps pt pu pv pw ml dk translated">还不错！</p></blockquote></div><div class="ab cl oa ob hx oc" role="separator"><span class="od bw bk oe of og"/><span class="od bw bk oe of og"/><span class="od bw bk oe of"/></div><div class="im in io ip iq"><h1 id="1531" class="ky kz it bd la lb oh ld le lf oi lh li jz oj ka lk kc ok kd lm kf ol kg lo lp bi translated">运动/寻路</h1><p id="9245" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">我们需要克服的下一个大障碍是运动。我们如何让角色决定如何在每一帧上移动？好吧，我们将从在课堂上加入一些新的数据开始，来表明我们周围世界的一些事情。每当我为这个项目编写一些人工智能程序时，这些都会成为我们模型的特征。在我们深入研究之前，我还想提一件事——到目前为止，该项目的代码在核心功能分支中，我们现在将转移到战斗分支。这个分支将会更加专注于移动和战斗，这样我们的新外形将会真正的发挥作用。</p><p id="2cc7" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">这是我们之前工作过的分支的链接:</p><div class="ni nj gp gr nk nl"><a href="https://github.com/emmettgb/characterclash/tree/0.0.1-basic-functionality" rel="noopener  ugc nofollow" target="_blank"><div class="nm ab fo"><div class="nn ab no cl cj np"><h2 class="bd iu gy z fp nq fr fs nr fu fw is bi translated">GitHub-emmettgb/character clash 0 . 0 . 1-基本-功能</h2><div class="ns l"><h3 class="bd b gy z fp nq fr fs nr fu fw dk translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="nt l"><p class="bd b dl z fp nq fr fs nr fu fw dk translated">github.com</p></div></div><div class="nu l"><div class="om l nw nx ny nu nz ks nl"/></div></div></a></div><p id="ca95" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">这里有一个链接指向我们现在所在的网站:</p><div class="ni nj gp gr nk nl"><a href="https://github.com/emmettgb/characterclash/tree/0.0.2-combat" rel="noopener  ugc nofollow" target="_blank"><div class="nm ab fo"><div class="nn ab no cl cj np"><h2 class="bd iu gy z fp nq fr fs nr fu fw is bi translated">GitHub-emmettgb/character clash 0 . 0 . 2-战斗</h2><div class="ns l"><h3 class="bd b gy z fp nq fr fs nr fu fw dk translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="nt l"><p class="bd b dl z fp nq fr fs nr fu fw dk translated">github.com</p></div></div><div class="nu l"><div class="qx l nw nx ny nu nz ks nl"/></div></div></a></div><p id="99a0" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">让我们回到移动函数:</p><pre class="kj kk kl km gt on oo op oq aw or bi"><span id="29ff" class="os kz it oo b gy ot ou l ov ow">def move(self, players):<br/>        if self.blocking == False:<br/>            self.pos[1] -= 1<br/>            self.blocking = True<br/>        elif self.blocking == True:<br/>            self.pos[1] += 1<br/>            self.blocking = False</span></pre><p id="fcb2" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">如前所述，我们可以删除所有这些代码，除了将 blocking 设置为 false 的第一件事，如果玩家决定阻止，可以在最后将其切换回来。</p><h2 id="5fba" class="os kz it bd la oz pa dn le pb pc dp li lz pd pe lk md pf pg lm mh ph pi lo pj bi translated">移动()</h2><pre class="kj kk kl km gt on oo op oq aw or bi"><span id="1dbd" class="os kz it oo b gy ot ou l ov ow">def move(self, players):<br/>         self.blocking = False</span></pre><p id="950e" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">我们需要做的第一件事是评估其他玩家的位置，以及我们作为玩家的状态。这个类可以帮我们做到这一点，所以我添加了更多的属性:</p><pre class="kj kk kl km gt on oo op oq aw or bi"><span id="2377" class="os kz it oo b gy ot ou l ov ow">class Player:<br/>    def __init__(self, pos):<br/>        self.pos = pos<br/>        self.health = 100<br/>        self.blocking = True<br/>        self.attacking = False<br/>        type = random.choice(["o/", "o)", "o-"])<br/>        self.speed = stats_dict[type][0]<br/>        self.damage = stats_dict[type][1]<br/>        self.range = stats_dict[type][2]<br/>        self.time = stats_dict[type][3]<br/>        self.symbol = type<br/>        self.facing = True<br/>        self.attacking = False<br/>        self.pursuing = None<br/>        self.attackavailable = False<br/>        self.attacks_available = []<br/>        self.turns = 0</span></pre><p id="3f39" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">self.turns 值将在 turn 系统中发挥作用，我们将在此之后为其创建一个经理。一旦我们到了那里，我们将详细讨论这个问题。现在，让我们把重点放在指导这些玩家做什么的功能上:</p><pre class="kj kk kl km gt on oo op oq aw or bi"><span id="3cfd" class="os kz it oo b gy ot ou l ov ow">def move(self, players):<br/>         self.blocking = False<br/>         self.attacking = False<br/>         selection = 1<br/>         selections = []<br/>         param = ""</span></pre><p id="c9b1" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">第一件事是初始化一些变量。有很多这样的方法，但有一个很好的理由——这是一种创建一些基于条件的行为的简单方法，但该算法肯定是有意义的，并且有可能被扩展。一旦该说的都说了，该做的都做了，我打算让这个类调用 AI。我还添加了将攻击设置为假，因为如果我们现在移动，我们不能做任何一件事——当我们回顾核心游戏规则和管理系统如何工作时，这可能更有意义。</p><p id="7b0a" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">接下来，我们将进入一个奇怪的迭代循环，它只需要评估事物，以得出三个结论之一，走到某个地方，阻止或攻击某个东西:</p><pre class="kj kk kl km gt on oo op oq aw or bi"><span id="6b2a" class="os kz it oo b gy ot ou l ov ow">for player in players:<br/>             if player.pos[1] == self.pos[1] and player.pos[0] == self.pos[0]:<br/>                 pass<br/>             else:<br/>                 if attackavailable == True:<br/>                     # walk = 1, block = 2, attack = 3<br/>                     if self.health &gt; 45 and index in attacks_available:<br/>                         if player.attacking == True:<br/>                             selection = 3<br/>                             self.pursuing = index<br/>                         else:<br/>                         if player.health &gt; 35 and self.health &lt; 50:<br/>                                 self.pursuing = player.pos<br/>                                 selection = 2<br/>                 else:<br/>                     selection = random.choice([1, 2, 3])<br/>             selections.append(selection)</span></pre><p id="1408" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">那里的格式转换很糟糕，但仍然清晰可辨，只是不要把这种缩进当成现实。这个循环也很可怕，而且它出现在主事件循环中有点吓人，但是我怀疑我们会遇到很多这样的问题，此外，这只是我将在以后的文章中做的一些迭代工作的临时占位符。无论如何，接下来我要对选择进行舍入，得到一组选择的平均值。</p><pre class="kj kk kl km gt on oo op oq aw or bi"><span id="db63" class="os kz it oo b gy ot ou l ov ow">mu = sum(selections) / len(selections)<br/>         selection = int(round(mu))</span></pre><p id="ef9e" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">最后，我会对每个决策进行函数调用:</p><pre class="kj kk kl km gt on oo op oq aw or bi"><span id="f489" class="os kz it oo b gy ot ou l ov ow">if selection == 1:<br/>             if self.pursuing != None:<br/>                 self.pursue()<br/>             else:<br/>                 self.random_walk()<br/>         if selection == 2:<br/>              pass<br/>         if selection == 3:<br/>              pass</span></pre><p id="7760" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">这也使得机器学习部分主要只是猜测分类特征，尽管只有一个参数。目前，我们所有可能被调用或实际执行的操作将是 random_walk()方法，这是我刚刚编写的——然而，我实际上并没有添加 pursue()函数，这是一个原因，我想用一秒钟的时间在这里展示，但首先让我们看看 random_walk 函数:</p><pre class="kj kk kl km gt on oo op oq aw or bi"><span id="873e" class="os kz it oo b gy ot ou l ov ow">def random_walk(self):<br/>                # 1 r, 2 l, 3 up, 4, down<br/>        dir = random.choice([1, 2, 3, 4])<br/>        if dir == 1:<br/>            self.pos[0] += self.speed<br/>        elif dir == 2:<br/>            self.pos[0] -= self.speed<br/>        elif dir == 3:<br/>            self.pos[1] += self.speed<br/>        self.turns = 1</span></pre><p id="d76a" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">这个函数所做的基本上就是选择一个随机的方向行走，然后朝那个方向行进。你可能已经注意到了最后的回合功能，每当我们用主控制器完成这个并运行我们的第一个 REPL 中角色间战争的模拟时，这个功能会更有意义。</p><h2 id="a095" class="os kz it bd la oz pa dn le pb pc dp li lz pd pe lk md pf pg lm mh ph pi lo pj bi translated">阻挡/攻击</h2><p id="83a3" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">如果您还记得，前面我说过我没有在这个类中添加 pursue()函数。我这样做的原因是为了测试追求价值的保真度。这是因为无论何时调用该方法，我们都会得到一个错误。然而，我们还需要一个函数来实现这个功能，这个函数就是攻击可用函数。为了开始这个函数，我要写一个和我们之前写的一样的循环。唯一不同的是，这次我想确定一个值是否在攻击范围内，这是我第一次尝试这样的函数:</p><pre class="kj kk kl km gt on oo op oq aw or bi"><span id="5d95" class="os kz it oo b gy ot ou l ov ow">def attack_available(self, players):<br/>        for player in players:<br/>            if player.pos[0] != self.pos[0] and self.pos[1] != player.pos[1]:<br/>                if abs(player.pos[0] - self.pos[0]) &lt;= self.range:<br/>                    self.attacks_available.append(player.id)<br/>                elif abs(player.pos[1] - self.pos[1]) &lt;= self.range:<br/>                    self.attacks_available.append(player.id)</span></pre><p id="7052" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">这有些完美，有些不完美。现在，我相信它会很好地为我们服务。现在让我们转到 main()函数，并向我们的输出添加另一个播放器类:</p><pre class="kj kk kl km gt on oo op oq aw or bi"><span id="1c96" class="os kz it oo b gy ot ou l ov ow">def main():<br/>    players = []<br/>    players.append(Player([5, 6], 1))<br/>    players.append(Player([40, 20], 2))<br/>    game = PlayGrid(players)<br/>    for i in range(1, 25):<br/>        sleep(3)<br/>        game.update("".join(["Iteration: ", str(i)]))</span></pre><p id="eee4" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">这段代码运行完美。现在让我们稍微润色一下。</p><h2 id="dd29" class="os kz it bd la oz pa dn le pb pc dp li lz pd pe lk md pf pg lm mh ph pi lo pj bi translated">润色</h2><p id="1e9b" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">我决定放弃任何级别的路径寻找，并期待将人工智能放在它的位置上，因为代码相当粗糙，也不是真的需要。所有这一切意味着，就目前而言，这些角色没有遵循任何策略，除了随机性。我想复习一下我做的修饰。首先，我重写了行走函数，包括随机行走和行走函数。</p><pre class="kj kk kl km gt on oo op oq aw or bi"><span id="6cf0" class="os kz it oo b gy ot ou l ov ow">def random_walk(self):<br/>                # 1 r, 2 l, 3 up, 4, down<br/>        dir = random.choice([1, 2, 3, 4])<br/>        self.walk(dir)</span><span id="5797" class="os kz it oo b gy ox ou l ov ow">def walk(self, dir):<br/>        if dir == 1:<br/>            if not self.pos[0] + self.speed &gt;= CHAR_H - 1:<br/>                self.pos[0] += self.speed<br/>                self.facing = True</span><span id="c71d" class="os kz it oo b gy ox ou l ov ow">elif dir == 2:<br/>            if not self.pos[0] - self.speed &lt;= 2:<br/>                self.pos[0] -= self.speed<br/>                self.facing = False</span><span id="b89c" class="os kz it oo b gy ox ou l ov ow">elif dir == 3:<br/>            if not self.pos[0] - self.speed &lt;= 2:<br/>                self.pos[1] -= self.speed<br/>        elif dir == 4:<br/>            if not self.pos[0] + self.speed &gt;= CHAR_W - 1:<br/>                self.pos[1] += self.speed<br/>        self.turns += 1</span></pre><p id="c81e" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">在这个函数中，我还必须添加一个条件来确保字符不会离开边缘。最后，我更新了主函数，它现在将运行 50 步棋，假设所有 50 步棋都有效，那么这应该是一个工作项目！这是最后一次查看这些类和 main()函数:</p><pre class="kj kk kl km gt on oo op oq aw or bi"><span id="01d0" class="os kz it oo b gy ot ou l ov ow">def main():<br/>    players = []<br/>    players.append(Player([11, 20], 0))<br/>    players.append(Player([5, 6], 1))<br/>    players.append(Player([20, 10], 2))<br/>    game = PlayGrid(players)<br/>    for i in range(1, 50):<br/>        sleep(.5)<br/>        game.update("".join(["Iteration: ", str(i)]))</span><span id="f30d" class="os kz it oo b gy ox ou l ov ow">class PlayGrid:<br/>        # Essentials<br/>    def __init__(self, players):<br/>        self.players = players<br/>        self.update("Character Clash Game Started")</span><span id="0083" class="os kz it oo b gy ox ou l ov ow">def update(self, message):<br/>        clear()<br/>        self.empty_grid()<br/>        self.draw_players(self.grid)<br/>        self.make_moves()<br/>        print(self.draw_grid())<br/>        print("\n" + message)</span><span id="d73d" class="os kz it oo b gy ox ou l ov ow"># Player Management<br/>    def draw_players(self, grid):<br/>        for player in self.players:<br/>            modifier = 0<br/>            # True = right, False = left<br/>            if player.facing == True:<br/>                modifier = 1<br/>            else:<br/>                modifer = -1<br/>                # [0] = x, [1] = y<br/>            newpos = player.pos<br/>            current = list(grid[newpos[1]])<br/>            current[newpos[0]] = player.symbol[0]<br/>            current[newpos[0] + modifier] = player.symbol[1]<br/>            current = "".join(current)<br/>            self.grid[newpos[1]] = current</span><span id="a388" class="os kz it oo b gy ox ou l ov ow">def make_moves(self):<br/>        [player.move(self.players) for player in self.players]</span><span id="dd65" class="os kz it oo b gy ox ou l ov ow"># Grid<br/>    def draw_grid(self):<br/>        print_s = "\n"<br/>        for key in self.grid:<br/>            print_s = print_s + self.grid[key] + "\n"<br/>        return(print_s)</span><span id="8147" class="os kz it oo b gy ox ou l ov ow">def empty_grid(self):<br/>        self.grid = dict()<br/>        str = ""<br/>        for row in range(1, CHAR_W):<br/>            str = ""<br/>            for i in range(1, CHAR_H):<br/>                str += "`"<br/>            self.grid[row] = str</span><span id="824b" class="os kz it oo b gy ox ou l ov ow"># Sword # bow # assassin<br/># Classes = ["o/", "o)", "o-"]<br/># stats = [speed, damage, range, time]</span><span id="f0f3" class="os kz it oo b gy ox ou l ov ow">stats_dict = {"o/" : [2, 25, 2, 3],<br/>"o)" : [2, 35, 3, 4],<br/>"o-" : [3, 20, 1, 2]}<br/>class Player:<br/>    def __init__(self, pos, id):<br/>        self.id = id<br/>        self.pos = pos<br/>        self.health = 100<br/>        self.blocking = True<br/>        self.attacking = False<br/>        type = random.choice(["o/", "o)", "o-"])<br/>        self.speed = stats_dict[type][0]<br/>        self.damage = stats_dict[type][1]<br/>        self.range = stats_dict[type][2]<br/>        self.time = stats_dict[type][3]<br/>        self.symbol = type<br/>        self.facing = True<br/>        self.attacking = False<br/>        self.pursuing = None<br/>        self.attackavailable = False<br/>        self.attacks_available = []<br/>        self.turns = 0<br/>        # Base<br/>    def random_walk(self):<br/>                # 1 r, 2 l, 3 up, 4, down<br/>        dir = random.choice([1, 2, 3, 4])<br/>        self.walk(dir)</span><span id="9779" class="os kz it oo b gy ox ou l ov ow">def walk(self, dir):<br/>        if dir == 1:<br/>            if not self.pos[0] + self.speed &gt;= CHAR_H - 1:<br/>                self.pos[0] += self.speed<br/>                self.facing = True</span><span id="ae60" class="os kz it oo b gy ox ou l ov ow">elif dir == 2:<br/>            if not self.pos[0] - self.speed &lt;= 2:<br/>                self.pos[0] -= self.speed<br/>                self.facing = False</span><span id="251b" class="os kz it oo b gy ox ou l ov ow">elif dir == 3:<br/>            if not self.pos[0] - self.speed &lt;= 2:<br/>                self.pos[1] -= self.speed<br/>        elif dir == 4:<br/>            if not self.pos[0] + self.speed &gt;= CHAR_W - 1:<br/>                self.pos[1] += self.speed<br/>        self.turns += 1</span><span id="2922" class="os kz it oo b gy ox ou l ov ow"># Behaviors<br/>    def attack_available(self, players):<br/>        for player in players:<br/>            if player.pos[0] != self.pos[0] and self.pos[1] != player.pos[1]:<br/>                if abs(player.pos[0] - self.pos[0]) &lt;= self.range:<br/>                    self.attacks_available.append(player.id)<br/>                elif abs(player.pos[1] - self.pos[1]) &lt;= self.range:<br/>                    self.attacks_available.append(player.id)</span><span id="c177" class="os kz it oo b gy ox ou l ov ow">def move(self, players):<br/>         self.attacks_available = []<br/>         self.blocking = False<br/>         self.attacking = False<br/>         self.attack_available(players)<br/>         selection = 1<br/>         selections = [1, 1, 1, 1, 2, 2]<br/>         if len(self.attacks_available) &gt; 0:<br/>             selections.append(3)<br/>         selection = random.choice(selections)<br/>         if selection == 1:<br/>             if self.pursuing != None:<br/>                 self.pursue()<br/>             else:<br/>                 self.random_walk()<br/>         if selection == 2:<br/>              self.blocking = True<br/>              self.turns += 1<br/>         if selection == 3:<br/>             self.attacking = True<br/>             self.call_attack()<br/>    def call_attack(self):<br/>        pass<br/>    def pursue(self):<br/>        pass</span></pre></div><div class="ab cl oa ob hx oc" role="separator"><span class="od bw bk oe of og"/><span class="od bw bk oe of og"/><span class="od bw bk oe of"/></div><div class="im in io ip iq"><h1 id="13aa" class="ky kz it bd la lb oh ld le lf oi lh li jz oj ka lk kc ok kd lm kf ol kg lo lp bi translated">结论</h1><p id="654f" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">我发现这个项目非常有趣和令人兴奋，我希望那些阅读的人也一样。我想通过构建这个软件来展示这么多随机的很酷的东西，但总的来说，我认为做这样的事情然后交流它们只是娱乐性的。这个项目肯定是一个了不起的项目。</p><p id="7b0b" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">当我们继续这部分的工作时，这段代码所需要的只是一些攻击代码，以及一个运行这些攻击的管理器，以及其他与游戏逻辑规则相比较的东西。非常感谢你的阅读，我希望这个项目对你来说是尽可能愉快的，我希望你对我将要把它进行到的长度感到兴奋！祝你有美好的一天！</p><blockquote class="nb nc nd"><p id="1a5f" class="lq lr ne ls b lt mv ju lv lw mw jx ly nf mx mb mc ng my mf mg nh mz mj mk ml im bi translated">还有一件事，这是我们创作的 GIF:</p></blockquote><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qy"><img src="../Images/621f6a5137b9d497c5d6dc50d769e852.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*egGtAmChZBf6mfxJM6MCFA.gif"/></div></div></figure></div></div>    
</body>
</html>