<html>
<head>
<title>Developing the Go Game (围棋) Using matplotlib and NumPy — Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Developing the Go Game (围棋) Using matplotlib and NumPy — Part 2</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/developing-the-go-game-%E5%9B%B4%E6%A3%8B-using-matplotlib-and-numpy-part-2-4985bef0ef39?source=collection_archive---------34-----------------------#2021-12-14">https://towardsdatascience.com/developing-the-go-game-%E5%9B%B4%E6%A3%8B-using-matplotlib-and-numpy-part-2-4985bef0ef39?source=collection_archive---------34-----------------------#2021-12-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="45bf" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">执行围棋规则</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/1e4ad5c6b783c33efa6f2442c8fd50e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UhEuWJDSz35sVJ83Ce76Wg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来源:<a class="ae ky" href="https://en.wikipedia.org/wiki/Go_(game)#/media/File:Four_Arts_China_Japan.jpg" rel="noopener ugc nofollow" target="_blank">https://en . Wikipedia . org/wiki/Go _(game)#/media/File:Four _ Arts _ China _ Japan . jpg</a></p></figure><p id="f069" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我之前的文章中，我讨论了如何使用 matplotlib 绘制围棋棋盘:</p><div class="lv lw gp gr lx ly"><a rel="noopener follow" target="_blank" href="/developing-the-go-game-围棋-using-matplotlib-and-numpy-part-1-3f94127d73e6"><div class="lz ab fo"><div class="ma ab mb cl cj mc"><h2 class="bd iu gy z fp md fr fs me fu fw is bi">Developing the Go Game (围棋) using matplotlib and NumPy — Part 1</h2><div class="mf l"><h3 class="bd b gy z fp md fr fs me fu fw dk translated">用 matplotlib 绘制围棋棋盘</h3></div><div class="mg l"><p class="bd b dl z fp md fr fs me fu fw dk translated">towardsdatascience.com</p></div></div><div class="mh l"><div class="mi l mj mk ml mh mm ks ly"/></div></div></a></div><p id="8546" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在你已经能够画出围棋棋盘了，是时候做下一步了，在棋盘上放置石头——这是这个项目最有趣的方面之一。也就是说，您将允许用户在棋盘上放置石头，并以编程方式实现 Go 规则。您的计划将:</p><ul class=""><li id="d56d" class="mn mo it lb b lc ld lf lg li mp lm mq lq mr lu ms mt mu mv bi translated">检查用户是否已将棋子放在围棋棋盘上的正确位置</li><li id="4fa5" class="mn mo it lb b lc mw lf mx li my lm mz lq na lu ms mt mu mv bi translated">确保被对手包围的一块(或一组相连的)石头将被从棋盘上移走</li><li id="7f24" class="mn mo it lb b lc mw lf mx li my lm mz lq na lu ms mt mu mv bi translated">确保用户不会将石头放在导致他自己的石头(或一组相连的石头)被移走的位置</li></ul><p id="d533" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们开始之前，这里是我们在上一篇文章中开发的程序(<strong class="lb iu"> go.py </strong>)。我们将从这里继续:</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="15e1" class="ng nh it nc b gy ni nj l nk nl">import matplotlib.pyplot as plt<br/>import numpy as np</span><span id="263c" class="ng nh it nc b gy nm nj l nk nl">def draw_board():<br/>    # create a figure to draw the board<br/>    fig = plt.figure(figsize=[9,9])</span><span id="9169" class="ng nh it nc b gy nm nj l nk nl">    # set the background color<br/>    fig.patch.set_facecolor((0.85,0.64,0.125))</span><span id="2cc7" class="ng nh it nc b gy nm nj l nk nl">    ax = fig.add_subplot(111)</span><span id="8220" class="ng nh it nc b gy nm nj l nk nl">    # turn off the axes<br/>    ax.set_axis_off()</span><span id="5722" class="ng nh it nc b gy nm nj l nk nl">    return fig, ax</span><span id="8751" class="ng nh it nc b gy nm nj l nk nl">def draw_grids(ax):<br/>    # draw the vertical lines<br/>    for x in range(19):<br/>        ax.plot([x, x], [0,18], 'k')</span><span id="67ab" class="ng nh it nc b gy nm nj l nk nl">    # draw the horizontal lines<br/>    for y in range(19):<br/>        ax.plot([0, 18], [y,y], 'k')</span><span id="3891" class="ng nh it nc b gy nm nj l nk nl">    ax.set_position([0,0.02,1,1])</span><span id="a1ec" class="ng nh it nc b gy nm nj l nk nl">def draw_star_points(ax, x, y):<br/>    ax.plot(x,y,'o',markersize=8,<br/>        markeredgecolor=(0,0,0),<br/>        markerfacecolor='k',<br/>        markeredgewidth=1)</span><span id="905d" class="ng nh it nc b gy nm nj l nk nl">#-----main-----<br/>fig, ax = draw_board()<br/>draw_grids(ax)</span><span id="1881" class="ng nh it nc b gy nm nj l nk nl"># draw the 9 star points on the board<br/>draw_star_points(ax, 3,3)<br/>draw_star_points(ax, 3,9)<br/>draw_star_points(ax, 3,15)<br/>draw_star_points(ax, 9,3)<br/>draw_star_points(ax, 9,9)<br/>draw_star_points(ax, 9,15)<br/>draw_star_points(ax, 15,3)<br/>draw_star_points(ax, 15,9)<br/>draw_star_points(ax, 15,15)</span><span id="29c3" class="ng nh it nc b gy nm nj l nk nl">plt.show()</span></pre><h1 id="f8aa" class="nn nh it bd no np nq nr ns nt nu nv nw jz nx ka ny kc nz kd oa kf ob kg oc od bi translated">处理代表围棋棋盘的图形上的事件</h1><p id="3edb" class="pw-post-body-paragraph kz la it lb b lc oe ju le lf of jx lh li og lk ll lm oh lo lp lq oi ls lt lu im bi translated">为了让用户在棋盘上放置石头，您需要处理 matplotlib 图形上的事件。要处理图形上的点击，使用<code class="fe oj ok ol nc b">canvas.mpl_connect()</code>函数将一个事件连接到一个函数(事件处理器):</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="3cc9" class="ng nh it nc b gy ni nj l nk nl"><strong class="nc iu"># event handler to handle click on the board<br/>def on_click(event):       <br/>    print(f'x: {event.xdata} y: {event.ydata}')</strong></span><span id="5bf2" class="ng nh it nc b gy nm nj l nk nl"><strong class="nc iu">fig.canvas.mpl_connect('button_press_event', on_click)</strong></span></pre><p id="6c65" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe oj ok ol nc b"><strong class="lb iu">button_press_event</strong></code> <strong class="lb iu"> </strong>事件是鼠标左键被按下时触发的事件。在连接到该事件的处理程序中，可以通过<code class="fe oj ok ol nc b">event</code>参数知道用户点击图形的位置(<code class="fe oj ok ol nc b">xdata</code>和<code class="fe oj ok ol nc b">ydata</code>):</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="a07d" class="ng nh it nc b gy ni nj l nk nl">def on_click(<strong class="nc iu">event</strong>):       <br/>    print(f'x: {<strong class="nc iu">event.xdata</strong>} y: {<strong class="nc iu">event.ydata</strong>}')</span></pre><p id="5028" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下图显示了代表 Go 板的图形的 x 和 y 坐标，供您参考:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi om"><img src="../Images/1180ee0f4be5adf13ceabfae0f13df99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ICTHLdRAwRv6P7vUUqXnOw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="95bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们将事件和事件处理程序添加到<strong class="lb iu"> go.py </strong>文件中:</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="5efe" class="ng nh it nc b gy ni nj l nk nl">import matplotlib.pyplot as plt<br/>import numpy as np</span><span id="71f2" class="ng nh it nc b gy nm nj l nk nl">def draw_board():<br/>    ...</span><span id="7bc6" class="ng nh it nc b gy nm nj l nk nl">def draw_grids(ax):<br/>    ...<br/>        <br/>def draw_star_points(ax, x, y):<br/>    ...</span><span id="0a88" class="ng nh it nc b gy nm nj l nk nl"><strong class="nc iu"># event handler to handle click on the board<br/>def on_click(event):<br/>    print(f'x: {event.xdata} y: {event.ydata}')<br/></strong>    <br/>fig, ax = draw_board()<br/>draw_grids(ax)</span><span id="2288" class="ng nh it nc b gy nm nj l nk nl"># draw the 9 star points on the board<br/>draw_star_points(ax, 3,3)<br/>draw_star_points(ax, 3,9)<br/>draw_star_points(ax, 3,15)<br/>draw_star_points(ax, 9,3)<br/>draw_star_points(ax, 9,9)<br/>draw_star_points(ax, 9,15)<br/>draw_star_points(ax, 15,3)<br/>draw_star_points(ax, 15,9)<br/>draw_star_points(ax, 15,15)</span><span id="104a" class="ng nh it nc b gy nm nj l nk nl"><strong class="nc iu">cid = fig.canvas.mpl_connect('button_press_event', on_click)</strong></span><span id="9a45" class="ng nh it nc b gy nm nj l nk nl">plt.show()</span></pre><p id="974e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们通过在终端中运行应用程序来试验代码:</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="a7d9" class="ng nh it nc b gy ni nj l nk nl">$ <strong class="nc iu">python go.py</strong></span></pre><p id="0b54" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当你运行它时，点击板上的一个点，观察打印的坐标。例如，如果您单击下图中用红点表示的点，您应该会看到类似的输出:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi on"><img src="../Images/7d8edab8681b8e15f7a8b4c3619b93da.png" data-original-src="https://miro.medium.com/v2/resize:fit:646/format:webp/1*YXSr84S_L9l94s-HL93m0Q.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="2b7d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们声明一些全局变量:</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="2121" class="ng nh it nc b gy ni nj l nk nl">...<br/>draw_star_points(ax, 15,9)<br/>draw_star_points(ax, 15,15)</span><span id="91bb" class="ng nh it nc b gy nm nj l nk nl"><strong class="nc iu">#  0 for empty<br/>#  1 for white<br/># -1 for black</strong></span><span id="b4e6" class="ng nh it nc b gy nm nj l nk nl"><strong class="nc iu"># color of the stone to start<br/>white = True</strong></span><span id="4bfd" class="ng nh it nc b gy nm nj l nk nl"><strong class="nc iu"># stones is for storing the plot (containing the stone)<br/>stones = np.full((19,19), None)</strong></span><span id="8802" class="ng nh it nc b gy nm nj l nk nl"><strong class="nc iu"># stones_values stores the value (color) of each point<br/>stones_values = np.full((19,19),0)</strong></span><span id="74b8" class="ng nh it nc b gy nm nj l nk nl">cid = fig.canvas.mpl_connect('button_press_event', on_click)<br/>plt.show()</span></pre><p id="0957" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码片段中，您有:</p><ul class=""><li id="70eb" class="mn mo it lb b lc ld lf lg li mp lm mq lq mr lu ms mt mu mv bi translated">全局变量<code class="fe oj ok ol nc b">white</code>指示当前石头颜色是否为白色。如果其值为<code class="fe oj ok ol nc b">True</code>，则当前石头颜色为<strong class="lb iu">白色</strong>，否则为<strong class="lb iu">黑色</strong>。</li><li id="dd54" class="mn mo it lb b lc mw lf mx li my lm mz lq na lu ms mt mu mv bi translated">2 个 NumPy 阵列— <code class="fe oj ok ol nc b">stones</code>和<code class="fe oj ok ol nc b">stones_values</code>。<code class="fe oj ok ol nc b">stones</code>数组用于存储显示每块石头的图形。当一个棋子被放置在棋盘上的一个特定的交叉点时，一个代表该棋子的图形被创建。这个情节然后被保存在<code class="fe oj ok ol nc b">stones</code> 2D 阵列中。在空白板上，数组中的每个值都被设置为<code class="fe oj ok ol nc b">None</code>。另一方面，<code class="fe oj ok ol nc b">stones_values</code>数组存储棋盘上每颗棋子的整数值。如果放置了白石，则存储值 1；如果石头是黑色的，那么值是-1。值为 0 表示板上有一个空的交叉点。</li></ul><p id="1f31" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当用户点击棋盘上的一个交叉点时，你就可以开始画石头了。为了在板上画一块石头，我将定义一个名为<code class="fe oj ok ol nc b">draw_stone()</code>的函数:</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="791a" class="ng nh it nc b gy ni nj l nk nl"># draw the stone on the board    <br/>def draw_stone(x,y,color):<br/>    stone = ax.plot(x,y,'o',markersize=28, <br/>                      markeredgecolor=(0,0,0), <br/>                      markerfacecolor=color, <br/>                      markeredgewidth=1)<br/>    return stone</span></pre><p id="dea5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该功能:</p><ul class=""><li id="615a" class="mn mo it lb b lc ld lf lg li mp lm mq lq mr lu ms mt mu mv bi translated">接受 3 个参数——放置石头的交叉点的<strong class="lb iu"> x </strong>和<strong class="lb iu"> y </strong>坐标，以及要绘制的石头的颜色</li><li id="526a" class="mn mo it lb b lc mw lf mx li my lm mz lq na lu ms mt mu mv bi translated">返回包含绘制的石头的图</li></ul><p id="2158" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要绘制石头，只需调用<code class="fe oj ok ol nc b">on_click()</code>事件处理程序中的<code class="fe oj ok ol nc b">draw_stone()</code>函数:</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="8693" class="ng nh it nc b gy ni nj l nk nl"># event handler to handle click on the board<br/>def on_click(event):    <br/><br/>    print(f'x: {event.xdata} y: {event.ydata}')</span><span id="fa7a" class="ng nh it nc b gy nm nj l nk nl"> <strong class="nc iu">   # reference the gloabl variable <br/>    global white</strong>   </span><span id="8fc8" class="ng nh it nc b gy nm nj l nk nl"><strong class="nc iu">    # get the points clicked on the board<br/>    if event.xdata == None or event.ydata == None:<br/>        return<br/>    x = int(round(event.xdata))<br/>    y = int(round(event.ydata))</strong></span><span id="149b" class="ng nh it nc b gy nm nj l nk nl"><strong class="nc iu">    #----------------------------<br/>    # Draw the stone on the board<br/>    #----------------------------<br/>    # make sure the area clicked is within the board<br/>    if 0&lt;=x&lt;=18 and 0&lt;=y&lt;=18:<br/>        # if the user left clicked to add a new stone on the board<br/>        if event.button == 1 and stones[x,y] == None:<br/>            stones[x,y] = draw_stone(x,y,'w' if white else 'k')<br/>            stones_values[x,y] = 1 if white else -1<br/>            white = not white                   # switch the color            </strong></span><span id="1c4a" class="ng nh it nc b gy nm nj l nk nl"><strong class="nc iu">        # when user right-clicked to remove a stone on the board  <br/>        elif event.button == 3 and stones[x,y] != None:<br/>            stones[x,y].pop().remove()          # remove the plot <br/>            stones[x,y] = None<br/>            stones_values[x,y] = 0<br/>        else:<br/>            return<br/>        plt.draw()                              # update the figure<br/></strong>        <strong class="nc iu">print(stones)<br/>        print(stones_values)<br/>    else:<br/>        return</strong></span></pre><p id="fd7d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码片段中，您:</p><ul class=""><li id="bc81" class="mn mo it lb b lc ld lf lg li mp lm mq lq mr lu ms mt mu mv bi translated">对 x 坐标和 y 坐标进行舍入，并将其转换为整数值</li><li id="8872" class="mn mo it lb b lc mw lf mx li my lm mz lq na lu ms mt mu mv bi translated">确保点击的坐标在板的范围内</li><li id="3023" class="mn mo it lb b lc mw lf mx li my lm mz lq na lu ms mt mu mv bi translated">如果用户点击左键(<code class="fe oj ok ol nc b"><strong class="lb iu">event.button == 1</strong></code>)并且当前点没有石头，则向棋盘添加一颗石头</li><li id="5fbd" class="mn mo it lb b lc mw lf mx li my lm mz lq na lu ms mt mu mv bi translated">如果用户右击(<code class="fe oj ok ol nc b"><strong class="lb iu">event.button == </strong></code> <strong class="lb iu"> 3 </strong>)鼠标，从棋盘上移除一颗棋子</li><li id="40fb" class="mn mo it lb b lc mw lf mx li my lm mz lq na lu ms mt mu mv bi translated">打印<code class="fe oj ok ol nc b">stones</code>和<code class="fe oj ok ol nc b">stones_values</code>数组的值</li><li id="6a90" class="mn mo it lb b lc mw lf mx li my lm mz lq na lu ms mt mu mv bi translated">一旦一块石头被放在棋盘上，就要改变它的颜色(白色变成黑色，黑色变成白色)</li></ul><blockquote class="oo op oq"><p id="d10a" class="kz la or lb b lc ld ju le lf lg jx lh os lj lk ll ot ln lo lp ou lr ls lt lu im bi translated">在围棋规则中，一旦棋子被放在棋盘上，玩家就不能移动(撤消)它，除非它被对手包围。在我们的实现中，出于测试目的，我允许这样做。</p></blockquote><p id="8e5b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们通过在<strong class="lb iu">终端</strong>中运行应用程序来测试代码:</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="dee3" class="ng nh it nc b gy ni nj l nk nl">$ <strong class="nc iu">python go.py</strong></span></pre><p id="b688" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们在棋盘的左下角添加一块白石:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ov"><img src="../Images/ef5bec89a5baa5f3e98c543cc924c870.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Jp6XDj3YNbRxlMhRHVIZcA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="8288" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您应该会看到以下输出。这是<code class="fe oj ok ol nc b">stones</code>数组的输出:</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="15a1" class="ng nh it nc b gy ni nj l nk nl">[[<strong class="nc iu">list([&lt;matplotlib.lines.Line2D object at 0x12b57bfd0&gt;])</strong> None None None None None None None None None None None None None None None None None None]<br/> [None None None None None None None None None None None None None None None None None None None]<br/> [None None None None None None None None None None None None None None None None None None None]<br/> [None None None None None None None None None None None None None None None None None None None]<br/> [None None None None None None None None None None None None None None None None None None None]<br/> [None None None None None None None None None None None None None None None None None None None]<br/> [None None None None None None None None None None None None None None None None None None None]<br/> [None None None None None None None None None None None None None None None None None None None]<br/> [None None None None None None None None None None None None None None None None None None None]<br/> [None None None None None None None None None None None None None None None None None None None]<br/> [None None None None None None None None None None None None None None None None None None None]<br/> [None None None None None None None None None None None None None None None None None None None]<br/> [None None None None None None None None None None None None None None None None None None None]<br/> [None None None None None None None None None None None None None None None None None None None]<br/> [None None None None None None None None None None None None None None None None None None None]<br/> [None None None None None None None None None None None None None None None None None None None]<br/> [None None None None None None None None None None None None None None None None None None None]<br/> [None None None None None None None None None None None None None None None None None None None]<br/> [None None None None None None None None None None None None None None None None None None None]]</span></pre><p id="520d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下一个输出是<code class="fe oj ok ol nc b">stones_values</code>数组的值:</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="b038" class="ng nh it nc b gy ni nj l nk nl">[[<strong class="nc iu">1</strong> 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]<br/> [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]<br/> [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]<br/> [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]<br/> [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]<br/> [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]<br/> [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]<br/> [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]<br/> [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]<br/> [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]<br/> [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]<br/> [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]<br/> [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]<br/> [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]<br/> [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]<br/> [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]<br/> [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]<br/> [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]<br/> [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]]</span></pre><p id="7ff2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在实际的围棋棋盘上，左下角截距的坐标是(0，0)，而在 2D 数组表示中，位置(0，0)在左上角。下图对此进行了描述:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ow"><img src="../Images/4651e0b25a0ef0a390b7dad7f9f03281.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*chpzMMUJJo-ev06pR_wwOA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="469d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您想看到棋盘和 2D 阵列在同一方向，您可以使用<code class="fe oj ok ol nc b">np.rot90()</code>功能将 2D 阵列<em class="or">逆时针旋转</em> 90 度:</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="aedb" class="ng nh it nc b gy ni nj l nk nl">print(<strong class="nc iu">np.rot90(stones)</strong>)<br/>print(<strong class="nc iu">np.rot90(stones_values)</strong>)</span></pre><p id="b598" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了测试这一点，让我们再次运行该程序，这一次，放置两块石头，如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ov"><img src="../Images/f8928c94dfea55ee6c0464ff9850c1d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a7YiKAtfGdeZOVyy6OYdlw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="1f1f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，输出应该与电路板布局相对应:</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="4945" class="ng nh it nc b gy ni nj l nk nl">[[None None None None None None None None None None None None None None None None None None <strong class="nc iu">list([&lt;matplotlib.lines.Line2D object at 0x11b383c70&gt;])</strong>]<br/> [None None None None None None None None None None None None None None None None None None None]<br/> [None None None None None None None None None None None None None None None None None None None]<br/> [None None None None None None None None None None None None None None None None None None None]<br/> [None None None None None None None None None None None None None None None None None None None]<br/> [None None None None None None None None None None None None None None None None None None None]<br/> [None None None None None None None None None None None None None None None None None None None]<br/> [None None None None None None None None None None None None None None None None None None None]<br/> [None None None None None None None None None None None None None None None None None None None]<br/> [None None None None None None None None None None None None None None None None None None None]<br/> [None None None None None None None None None None None None None None None None None None None]<br/> [None None None None None None None None None None None None None None None None None None None]<br/> [None None None None None None None None None None None None None None None None None None None]<br/> [None None None None None None None None None None None None None None None None None None None]<br/> [None None None None None None None None None None None None None None None None None None None]<br/> [None None None None None None None None None None None None None None None None None None None]<br/> [None None None None None None None None None None None None None None None None None None None]<br/> [None None None None None None None None None None None None None None None None None None None]<br/> [<strong class="nc iu">list([&lt;matplotlib.lines.Line2D object at 0x12eb0b070&gt;])</strong> None None None None None None None None None None None None None None None None None None]]</span><span id="0f1e" class="ng nh it nc b gy nm nj l nk nl">[[ 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0 <strong class="nc iu">-1</strong>]<br/> [ 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0]<br/> [ 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0]<br/> [ 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0]<br/> [ 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0]<br/> [ 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0]<br/> [ 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0]<br/> [ 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0]<br/> [ 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0]<br/> [ 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0]<br/> [ 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0]<br/> [ 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0]<br/> [ 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0]<br/> [ 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0]<br/> [ 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0]<br/> [ 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0]<br/> [ 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0]<br/> [ 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0]<br/> [ <strong class="nc iu">1</strong>  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0]]</span></pre><blockquote class="oo op oq"><p id="1f85" class="kz la or lb b lc ld ju le lf lg jx lh os lj lk ll ot ln lo lp ou lr ls lt lu im bi translated">要移除石头，只需右击石头，它就会从棋盘上被移除。</p></blockquote><h1 id="6477" class="nn nh it bd no np nq nr ns nt nu nv nw jz nx ka ny kc nz kd oa kf ob kg oc od bi translated">围棋规则</h1><p id="bbde" class="pw-post-body-paragraph kz la it lb b lc oe ju le lf of jx lh li og lk ll lm oh lo lp lq oi ls lt lu im bi translated">往棋盘上放石头是最简单的部分。最激动人心的部分是执行围棋规则。让我们在下面的章节中讨论围棋的规则。</p><h2 id="05a3" class="ng nh it bd no ox oy dn ns oz pa dp nw li pb pc ny lm pd pe oa lq pf pg oc ph bi translated">自由</h2><p id="a1ab" class="pw-post-body-paragraph kz la it lb b lc oe ju le lf of jx lh li og lk ll lm oh lo lp lq oi ls lt lu im bi translated">在围棋中，沿着水平轴和垂直轴与一颗石头相邻的一个空点被称为<em class="or">自由点</em>。下图显示了自由的例子:</p><ul class=""><li id="bec9" class="mn mo it lb b lc ld lf lg li mp lm mq lq mr lu ms mt mu mv bi translated">棋盘顶部的白色石头有 4 个自由度——它有四个相邻的空点——左、右、上、下。</li><li id="9545" class="mn mo it lb b lc mw lf mx li my lm mz lq na lu ms mt mu mv bi translated">左下角的白色石头只有一个自由——顶。</li><li id="2656" class="mn mo it lb b lc mw lf mx li my lm mz lq na lu ms mt mu mv bi translated">右下角的白色石头有两个自由度——上和右</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pi"><img src="../Images/e12e84f47f1f4508f131577073628d65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1326/format:webp/1*7t5vNJROgnWpW2__Q1XS2g.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="4dbf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">没有自由的石头被认为被对手包围，必须从棋盘上拿走:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pj"><img src="../Images/5dc7fe37f90e36eda8f63ea88a2f4f3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:946/format:webp/1*o6YxIlUzHZbVhsJ5tbJxUg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><h2 id="f3eb" class="ng nh it bd no ox oy dn ns oz pa dp nw li pb pc ny lm pd pe oa lq pf pg oc ph bi translated">成组的连锁石头</h2><p id="379b" class="pw-post-body-paragraph kz la it lb b lc oe ju le lf of jx lh li og lk ll lm oh lo lp lq oi ls lt lu im bi translated">石头也可以水平和/或垂直链接。如果一个团体没有至少一个自由，那么这个团体必须被移除。在下图中，一组白色石头被锁链锁住，并被黑色石头包围，因此必须全部移除:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pk"><img src="../Images/5941551992f5d0a24e30142f49c1ba0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:404/format:webp/1*hXeyLk_Hcn744eFhCsQ2Zg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><h2 id="6a4c" class="ng nh it bd no ox oy dn ns oz pa dp nw li pb pc ny lm pd pe oa lq pf pg oc ph bi translated">边缘案例</h2><p id="a065" class="pw-post-body-paragraph kz la it lb b lc oe ju le lf of jx lh li og lk ll lm oh lo lp lq oi ls lt lu im bi translated">放在棋盘边缘的石头呢？考虑下面的例子:</p><ul class=""><li id="10b7" class="mn mo it lb b lc ld lf lg li mp lm mq lq mr lu ms mt mu mv bi translated">黑色的石头被白色包围着:</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pl"><img src="../Images/87dd726fb545ab89f898efd7a4e04d3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:216/format:webp/1*YjByXNMdyFGll0y7hvNCCg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><ul class=""><li id="fff3" class="mn mo it lb b lc ld lf lg li mp lm mq lq mr lu ms mt mu mv bi translated">那群黑色的石头被白色包围着:</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pm"><img src="../Images/1e986cac52df5a14fb4150685e92eeba.png" data-original-src="https://miro.medium.com/v2/resize:fit:380/format:webp/1*pvjEmShGQBYS5BJeuvU4kw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><ul class=""><li id="3abc" class="mn mo it lb b lc ld lf lg li mp lm mq lq mr lu ms mt mu mv bi translated">这群白色的石头被黑色包围着:</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pn"><img src="../Images/8819e862479231685224e77027c1faaa.png" data-original-src="https://miro.medium.com/v2/resize:fit:238/format:webp/1*e3JWfyUGtZg00Ata0i3pHQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><ul class=""><li id="79fe" class="mn mo it lb b lc ld lf lg li mp lm mq lq mr lu ms mt mu mv bi translated">这群白色的石头被黑色包围着:</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi po"><img src="../Images/c26b7f6fb46b0184e654e5b7df10f124.png" data-original-src="https://miro.medium.com/v2/resize:fit:416/format:webp/1*mPgcS07PbAY3Q6s3rNdOkA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><ul class=""><li id="33c7" class="mn mo it lb b lc ld lf lg li mp lm mq lq mr lu ms mt mu mv bi translated">这群白色的石头被黑色包围着:</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pp"><img src="../Images/60d22f7f0b73520b1721daf99cb81804.png" data-original-src="https://miro.medium.com/v2/resize:fit:490/format:webp/1*2Q_CEhVbfAbrh5noOH_igg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><h2 id="489c" class="ng nh it bd no ox oy dn ns oz pa dp nw li pb pc ny lm pd pe oa lq pf pg oc ph bi translated">自杀案件</h2><p id="e7e4" class="pw-post-body-paragraph kz la it lb b lc oe ju le lf of jx lh li og lk ll lm oh lo lp lq oi ls lt lu im bi translated">自杀的情况是玩家将石头放在一个位置，导致他/她自己的石头被移走。一般来说，围棋中不允许自杀。</p><p id="62dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个自杀的例子，如果一个玩家在中间放一块黑色的石头:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pn"><img src="../Images/41c017526403f04fc201909e2a4dc6a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:238/format:webp/1*POhNNHaVvqH-VPnRYYc6Pw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="d6c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是另一个例子。如果将一块白石放在黑石组内的空交叉点上，这将导致现有的白石也被移除:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pq"><img src="../Images/644f64a246623725e2c8f1d63a89fd61.png" data-original-src="https://miro.medium.com/v2/resize:fit:478/format:webp/1*kJeoRa05KY4HRb1lbtAabg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="aa00" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，在有些情况下，看起来像自杀的案例是有效的。考虑下面左边的图。如果将一颗黑石放在一组白石中的空白交叉点上，这将基本上移除白石(见右图)。在这种情况下，此举是有效的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pr"><img src="../Images/7a29358f9bab2c5551d1771e3fd703e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1120/format:webp/1*ozGvmcordZ8CkUw9uW5PrA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><h1 id="b68f" class="nn nh it bd no np nq nr ns nt nu nv nw jz nx ka ny kc nz kd oa kf ob kg oc od bi translated">移除周围的石头</h1><p id="854f" class="pw-post-body-paragraph kz la it lb b lc oe ju le lf of jx lh li og lk ll lm oh lo lp lq oi ls lt lu im bi translated">既然您已经熟悉了 Go 的规则，那么是时候使用 Python 以编程方式实施所有这些规则了。让我们考虑几种不同的情况:</p><h2 id="8c42" class="ng nh it bd no ox oy dn ns oz pa dp nw li pb pc ny lm pd pe oa lq pf pg oc ph bi translated">简单案例</h2><p id="ee9b" class="pw-post-body-paragraph kz la it lb b lc oe ju le lf of jx lh li og lk ll lm oh lo lp lq oi ls lt lu im bi translated">最简单的情况是检查单个的石头是否被对手包围。假设当前玩家刚刚在以下位置放置了一颗白石:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ps"><img src="../Images/cc8aa830b6b3951111321eac4725f540.png" data-original-src="https://miro.medium.com/v2/resize:fit:746/format:webp/1*tjRBjzWmkrkmBP2FHH-faQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="6f90" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦放置了白棋，你只需要检查棋盘上是否有黑棋被白棋完全包围(即没有自由)。没有自由的石头可以从棋盘上移走。</p><h2 id="3df8" class="ng nh it bd no ox oy dn ns oz pa dp nw li pb pc ny lm pd pe oa lq pf pg oc ph bi translated">边缘情况</h2><p id="52e7" class="pw-post-body-paragraph kz la it lb b lc oe ju le lf of jx lh li og lk ll lm oh lo lp lq oi ls lt lu im bi translated">稍微复杂一点的情况是边缘情况。假设您刚刚将黑石放置在如下所示的位置:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pt"><img src="../Images/1691d9f53ea3e4447cf882e5b6d44cc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:712/format:webp/1*9KsMJFVNG7Qju3IhTUSG-w.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="a776" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">放置黑石后，你需要立即检查棋盘上是否有白石被包围。对于边缘情况，您需要将“假想的”石头放在边缘之外，如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pu"><img src="../Images/9298e0908bc3b9ec1de4e68e40ac64e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1298/format:webp/1*LyhzwSAUFfpfiVrN8b4mKg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="68a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果当前出的石头是白色的，那么边缘外的假想石头也是白色的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pv"><img src="../Images/a1c308e5e65cc08578b36d7aac14a28e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1282/format:webp/1*FlDtmZsDpfK5aMpYMJc0qw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="9f66" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后你可以继续移除被包围的石头。</p><h2 id="67f3" class="ng nh it bd no ox oy dn ns oz pa dp nw li pb pc ny lm pd pe oa lq pf pg oc ph bi translated">群体案例</h2><p id="6983" class="pw-post-body-paragraph kz la it lb b lc oe ju le lf of jx lh li og lk ll lm oh lo lp lq oi ls lt lu im bi translated">最复杂的情况是当石头被成组地用链子锁起来。你需要发现被对手包围的一群石头。考虑以下情况，白棋刚刚在棋盘上放了一颗石子，需要检查是否有任何黑棋需要被移走:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pw"><img src="../Images/4b38bbc9b973de93666b36f6df3dd3d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:684/format:webp/1*Hs57IJWthsN1J1YsBSSiqw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="5c22" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">哪块黑石头至少有一项自由，哪块没有任何自由？下图显示了至少有一个自由度的黑色石头，用值 8 表示，而没有自由度的石头则用它们现有的颜色代码表示(-1 表示黑色)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi px"><img src="../Images/5039daf80392adf31bfcb5468e6caa12.png" data-original-src="https://miro.medium.com/v2/resize:fit:680/format:webp/1*rYIp6VoX8oCWbF3q0xrFog.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="bc6d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如前所述，没有自由的石头可以从棋盘上移除。然而，上面的例子表明，黑色的石头形成了一个群体。显然，在这个群体的顶端有一种自由。这意味着黑色的石头群还活着。所以在这种情况下，你还不能移除黑石。为了确保所有其他黑色石头都不会被移除，你需要“感染”值为 8 的连接石头(这意味着该石头拥有自由):</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi py"><img src="../Images/f6392825e16b4b61a04c2804949ca26a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1080/format:webp/1*7OL21V5o299fEYOLKKHx6w.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="f18a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">重复这个过程，直到整组石头都是 8:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pz"><img src="../Images/208e1a52b5cbe5dd484521ccd2cfae42.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*QaSkoVByUu-00oH9UVnRiA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="65a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感染的最终结果表明，这一整组黑石头仍然活着，因此它们不应从棋盘上移除:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi qa"><img src="../Images/82f4f20c2d634486003628f976e53b86.png" data-original-src="https://miro.medium.com/v2/resize:fit:670/format:webp/1*UBEJjGr5KqD18HX2tRgkUg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="5e58" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在“感染”阶段结束时，所有没有自由的石头(用它们自己的颜色代码表示)将被移除。</p><h2 id="4da1" class="ng nh it bd no ox oy dn ns oz pa dp nw li pb pc ny lm pd pe oa lq pf pg oc ph bi translated">履行</h2><p id="e102" class="pw-post-body-paragraph kz la it lb b lc oe ju le lf of jx lh li og lk ll lm oh lo lp lq oi ls lt lu im bi translated">我们现在终于可以使用 Python 和 NumPy 实现 Go 的规则了。首先，让我们编写一个名为<code class="fe oj ok ol nc b">remove_stones()</code>的函数，它有以下参数和返回值:</p><ul class=""><li id="4a4c" class="mn mo it lb b lc ld lf lg li mp lm mq lq mr lu ms mt mu mv bi translated"><code class="fe oj ok ol nc b">color</code> —要移除的石头的颜色</li><li id="9a4a" class="mn mo it lb b lc mw lf mx li my lm mz lq na lu ms mt mu mv bi translated"><code class="fe oj ok ol nc b">remove</code> —如果你要从棋盘上拿走石头；该参数对于检查自杀案例非常有用(检查自杀时，将该参数设置为<code class="fe oj ok ol nc b">False</code>)</li><li id="8ee6" class="mn mo it lb b lc mw lf mx li my lm mz lq na lu ms mt mu mv bi translated">该函数返回移除(或需要移除)的石头数量。</li></ul><p id="d06c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面显示了<code class="fe oj ok ol nc b">remove_stones()</code>功能的实现:</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="5ba3" class="ng nh it nc b gy ni nj l nk nl"><strong class="nc iu">#------------------------------------------------<br/># Remove specified stones surrounded by opponent<br/>#------------------------------------------------<br/>def remove_stones(color, remove=True):  <br/>    # create a new array with 1 padding of 1 around the sides <br/>    # (for edge case)<br/>    temp_stones_values = np.full((21,21), color) <br/>    <br/>    # copy the current stones_values into the padded array<br/>    temp_stones_values[1:-1, 1:-1] = stones_values</strong></span><span id="92d0" class="ng nh it nc b gy nm nj l nk nl"><strong class="nc iu">    #-----------------------------------------------<br/>    # Checking the liberties of the opponent stones<br/>    #-----------------------------------------------<br/>    # for each of opponent's stones, check to see if it has an  <br/>    # liberty around it     <br/>    # you are looking inside the border, so [1:-1,1:-1]<br/>    for x,y in zip(<br/>        np.where(temp_stones_values[1:-1,1:-1] == color)[0],<br/>        np.where(temp_stones_values[1:-1,1:-1] == color)[1]):</strong></span><span id="82f9" class="ng nh it nc b gy nm nj l nk nl"><strong class="nc iu">        x+=1  # need to add one because of the padding<br/>        y+=1  # need to add one because of the padding<br/>        # as long as you have a surrounding that is 0 (empty), the <br/>        # stone is alive (at least one liberty)<br/>        if temp_stones_values[x-1,y] == 0 or \<br/>           temp_stones_values[x+1,y] == 0 or \<br/>           temp_stones_values[x,y-1] == 0 or \<br/>           temp_stones_values[x,y+1] == 0:<br/>            temp_stones_values[x,y] = 8      # stone is alive</strong></span><span id="b0dc" class="ng nh it nc b gy nm nj l nk nl"><strong class="nc iu">    #--------------------------------------<br/>    # Find groups of stones that are alive<br/>    #--------------------------------------<br/>    # if a stone is still alive, infect those of the same color<br/>    flipped=True</strong></span><span id="a6fc" class="ng nh it nc b gy nm nj l nk nl"><strong class="nc iu">    while flipped:        <br/>        flipped=False<br/>        # find all the opponent's stones<br/>        for x,y in zip(<br/>            np.where(temp_stones_values[1:-1,1:-1] == color)[0],<br/>            np.where(temp_stones_values[1:-1,1:-1] == color)[1]):   </strong></span><span id="06af" class="ng nh it nc b gy nm nj l nk nl"><strong class="nc iu">            x+=1  # need to add one because of the padding<br/>            y+=1  # need to add one because of the padding<br/>            if temp_stones_values[x-1,y] == 8 or \<br/>               temp_stones_values[x+1,y] == 8 or \<br/>               temp_stones_values[x,y-1] == 8 or \<br/>               temp_stones_values[x,y+1] == 8:<br/>                temp_stones_values[x,y] = 8      # alive<br/>                flipped = True                <br/>        <br/>    #----------------------------<br/>    # remove all the dead groups<br/>    #----------------------------<br/>    count = 0<br/>    for x in range(1,20):<br/>        for y in range(1,20):            <br/>            if temp_stones_values[x,y] == color:<br/>                if remove:<br/>                    stones[x-1,y-1].pop().remove()<br/>                    stones[x-1,y-1] = None<br/>                    stones_values[x-1,y-1] = 0<br/>                count += 1<br/>    plt.draw()</strong></span><span id="a522" class="ng nh it nc b gy nm nj l nk nl"><strong class="nc iu">    # return the number of stones removed<br/>    return count</strong></span></pre><p id="adf1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您将调用<code class="fe oj ok ol nc b">on_click()</code>函数中的<code class="fe oj ok ol nc b">remove_stones()</code>函数:</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="7e14" class="ng nh it nc b gy ni nj l nk nl"># event handler to handle click on the board<br/>def on_click(event):    <br/>    global white<br/>    print(f'x: {event.xdata} y: {event.ydata}')<br/>    <br/>    # get the points clicked on the board<br/>    if event.xdata == None or event.ydata == None:<br/>        return<br/>    x = int(round(event.xdata))<br/>    y = int(round(event.ydata))<br/>    <br/>    #-----------------------------<br/>    # Draw the stone on the board   <br/>    #-----------------------------<br/>    # make sure the area clicked is within the board<br/>    if 0&lt;=x&lt;=18 and 0&lt;=y&lt;=18:<br/>        # if the user left clicked to add a new stone on the board<br/>        if event.button == 1 and stones[x,y] == None:<br/>            stones[x,y] = draw_stone(x,y,'w' if white else 'k')<br/>            stones_values[x,y] = 1 if white else -1<br/>            white = not white                   # switch the color            <br/>        # when user right-clicked to remove a stone on the board  <br/>        elif event.button == 3 and stones[x,y] != None:<br/>            stones[x,y].pop().remove()<br/>            stones[x,y] = None<br/>            stones_values[x,y] = 0            <br/>        else:<br/>            return<br/>        plt.draw()     <br/>        # print(stones)<br/>        # print(stones_values)<br/>        print(np.rot90(stones)) <br/>        print(np.rot90(stones_values)) <br/>    else:<br/>        return</span><span id="692a" class="ng nh it nc b gy nm nj l nk nl"><strong class="nc iu">    #-----------------------------------<br/>    # Remove stones that are surrounded<br/>    #-----------------------------------<br/>    # color of the opponent<br/>    color = 1 if white else -1     # white is 1; black is -1    <br/>    <br/>    # remove stones of surrounded opponent<br/>    remove_stones(color)</strong></span></pre><p id="60d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你现在可以运行这个程序，被包围的石头会被自动移除。试试吧！很好玩！</p><h1 id="4948" class="nn nh it bd no np nq nr ns nt nu nv nw jz nx ka ny kc nz kd oa kf ob kg oc od bi translated">检查自杀事件</h1><p id="5d8d" class="pw-post-body-paragraph kz la it lb b lc oe ju le lf of jx lh li og lk ll lm oh lo lp lq oi ls lt lu im bi translated">如前所述，自杀是指玩家将石头放在某个位置，导致自己的石头被移走。在我们的实现中，每当玩家自杀，我们将播放一个音频通知。在 Python 中，可以使用<strong class="lb iu"> beepy </strong>模块来播放音频通知。</p><p id="b5d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您首先需要在终端中安装<strong class="lb iu"> beepy </strong>:</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="f2c7" class="ng nh it nc b gy ni nj l nk nl">$ <strong class="nc iu">pip install beepy</strong></span></pre><p id="3898" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后导入它:</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="9895" class="ng nh it nc b gy ni nj l nk nl">import matplotlib.pyplot as plt<br/>import numpy as np<br/><strong class="nc iu">import beepy</strong></span></pre><p id="b314" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们添加以下粗体陈述，以检查自杀情况(在评论中解释):</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="92e2" class="ng nh it nc b gy ni nj l nk nl"># event handler to handle click on the board<br/>def on_click(event):    <br/>    global white<br/>    print(f'x: {event.xdata} y: {event.ydata}')<br/>    <br/>    # get the points clicked on the board<br/>    if event.xdata == None or event.ydata == None:<br/>        return<br/>    x = int(round(event.xdata))<br/>    y = int(round(event.ydata))<br/>    <br/>    #----------------------------<br/>    # Draw the stone on the board   <br/>    #----------------------------<br/>    # make sure the area clicked is within the board<br/>    if 0&lt;=x&lt;=18 and 0&lt;=y&lt;=18:<br/>        # if the user left clicked to add a new stone on the board<br/>        if event.button == 1 and stones[x,y] == None:<br/>            stones[x,y] = draw_stone(x,y,'w' if white else 'k')<br/>            stones_values[x,y] = 1 if white else -1<br/>            white = not white                   # switch the color            <br/>        # when user right-clicked to remove a stone on the board  <br/>        elif event.button == 3 and stones[x,y] != None:<br/>            stones[x,y].pop().remove()<br/>            stones[x,y] = None<br/>            stones_values[x,y] = 0            <br/>        else:<br/>            return<br/>        plt.draw()     <br/>        # print(stones)<br/>        # print(stones_values)<br/>        print(np.rot90(stones)) <br/>        print(np.rot90(stones_values)) <br/>    else:<br/>        return</span><span id="253d" class="ng nh it nc b gy nm nj l nk nl">    #----------------------------------<br/>    # Remove stones that are surrounded<br/>    #----------------------------------<br/>    # color of the opponent<br/>    color = 1 if white else -1     # white is 1; black is -1    </span><span id="e640" class="ng nh it nc b gy nm nj l nk nl">    # remove stones of surrounded opponent</span><span id="9b0c" class="ng nh it nc b gy nm nj l nk nl"><strong class="nc iu">    #---Comment out the following statement---<br/>    # remove_stones(color)</strong></span><span id="52b2" class="ng nh it nc b gy nm nj l nk nl"><strong class="nc iu">    if remove_stones(color) == 0:  # if no stones are removed, check <br/>                                   # for suicide<br/>        white = not white          <br/>        color = 1 if white else -1 <br/>        if remove_stones(color, remove=False) == 0:  # there is no <br/>                                                     # suicide<br/>            white = not white<br/>        else:                                     # there is suicide<br/>            # UNDO - remove the stone that was placed on the board          <br/>            stones[x,y].pop().remove()    <br/>            stones[x,y] = None<br/>            stones_values[x,y] = 0<br/>            plt.draw()<br/>            beepy.beep(sound="ping")</strong></span></pre><p id="ae0a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">特别是，只有当用户放置石头时没有石头被移走，您才检查自杀情况。如果有自杀案例，石头会从棋盘上移走，并播放“ping”通知。</p><h1 id="3d27" class="nn nh it bd no np nq nr ns nt nu nv nw jz nx ka ny kc nz kd oa kf ob kg oc od bi translated">摘要</h1><p id="cd0b" class="pw-post-body-paragraph kz la it lb b lc oe ju le lf of jx lh li og lk ll lm oh lo lp lq oi ls lt lu im bi translated">到目前为止，我们已经实现了围棋规则。你现在准备好和你的朋友通过轮流在棋盘上放置石头来一决胜负。在下一篇文章中，我将展示如何确定游戏的获胜者，以及如何通过网络玩游戏。在那之前，玩得开心！</p><h1 id="ba1d" class="nn nh it bd no np nq nr ns nt nu nv nw jz nx ka ny kc nz kd oa kf ob kg oc od bi translated">完整的程序</h1><p id="9025" class="pw-post-body-paragraph kz la it lb b lc oe ju le lf of jx lh li og lk ll lm oh lo lp lq oi ls lt lu im bi translated">下面是完整的程序(<strong class="lb iu"> go.py </strong>):</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="e28f" class="ng nh it nc b gy ni nj l nk nl">import matplotlib.pyplot as plt<br/>import numpy as np<br/>import beepy</span><span id="c561" class="ng nh it nc b gy nm nj l nk nl">def draw_board():<br/>    # create a figure to draw the board<br/>    fig = plt.figure(figsize=[9,9])</span><span id="6618" class="ng nh it nc b gy nm nj l nk nl">    # set the background color<br/>    fig.patch.set_facecolor((0.85,0.64,0.125))</span><span id="054c" class="ng nh it nc b gy nm nj l nk nl">    ax = fig.add_subplot(111)</span><span id="a15d" class="ng nh it nc b gy nm nj l nk nl">    # turn off the axes<br/>    ax.set_axis_off()</span><span id="4c12" class="ng nh it nc b gy nm nj l nk nl">    return fig, ax</span><span id="f6eb" class="ng nh it nc b gy nm nj l nk nl">def draw_grids(ax):<br/>    # draw the vertical lines<br/>    for x in range(19):<br/>        ax.plot([x, x], [0,18], 'k')<br/>    <br/>    # draw the horizontal lines    <br/>    for y in range(19):<br/>        ax.plot([0, 18], [y,y], 'k')</span><span id="3c34" class="ng nh it nc b gy nm nj l nk nl">    ax.set_position([0,0.02,1,1])    <br/>        <br/>def draw_star_points(ax, x, y):<br/>    ax.plot(x,y,'o',markersize=8,<br/>            markeredgecolor=(0,0,0),<br/>            markerfacecolor='k',<br/>            markeredgewidth=1)</span><span id="4537" class="ng nh it nc b gy nm nj l nk nl"># draw the stone on the board    <br/>def draw_stone(x,y,color):<br/>    stone = ax.plot(x,y,'o',markersize=28, <br/>                      markeredgecolor=(0,0,0), <br/>                      markerfacecolor=color, <br/>                      markeredgewidth=1)<br/>    return stone</span><span id="08cd" class="ng nh it nc b gy nm nj l nk nl">#---------------------------------------------------------<br/># calculate the territories surrounded by black and white<br/>#---------------------------------------------------------<br/>def calculate_score():    <br/>    for color in [-1,1]:                # check black color first   <br/>        # create a new array with 1 padding of 1 around the sides <br/>        # (for edge case)<br/>        temp_stones_values = np.full((21,21), color)</span><span id="b10f" class="ng nh it nc b gy nm nj l nk nl">        # copy the current stones_values into the padded array<br/>        temp_stones_values[1:-1, 1:-1] = stones_values</span><span id="8d0f" class="ng nh it nc b gy nm nj l nk nl">        # look for empty spaces<br/>        for x,y in zip(<br/>            np.where(temp_stones_values[1:-1,1:-1] == 0)[0],<br/>            np.where(temp_stones_values[1:-1,1:-1] == 0)[1]):           <br/>            x+=1  # need to add one because of the padding<br/>            y+=1  # need to add one because of the padding<br/>            # as long as you have a surrounding that is the opposite <br/>            # color, the space is not occupied<br/>            if temp_stones_values[x-1,y] == -color or \<br/>               temp_stones_values[x+1,y] == -color or \<br/>               temp_stones_values[x,y-1] == -color or \<br/>               temp_stones_values[x,y+1] == -color:<br/>                temp_stones_values[x,y] = 8      # space is not <br/>                                                 # occupied</span><span id="f4ea" class="ng nh it nc b gy nm nj l nk nl">        flipped=True<br/>        while flipped:        <br/>            flipped=False<br/>            for x,y in zip(<br/>                np.where(temp_stones_values[1:-1,1:-1] == 0)[0],<br/>                np.where(temp_stones_values[1:-1,1:-1] == 0)[1]):   <br/>                x+=1  # need to add one because of the padding<br/>                y+=1  # need to add one because of the padding<br/>                if temp_stones_values[x-1,y] == 8 or \<br/>                   temp_stones_values[x+1,y] == 8 or \<br/>                   temp_stones_values[x,y-1] == 8 or \<br/>                   temp_stones_values[x,y+1] == 8:<br/>                    temp_stones_values[x,y] = 8      # not occupied<br/>                    flipped = True</span><span id="2b04" class="ng nh it nc b gy nm nj l nk nl">        print(f'Space occupied by {color}:',<br/>            len(temp_stones_values[temp_stones_values==0]))    <br/>        <br/>        # count the total number of stones for this color<br/>        print('Total stones: ',<br/>            len(stones_values[stones_values==color]))<br/>        print('------')</span><span id="cf24" class="ng nh it nc b gy nm nj l nk nl">#--------------------------------------<br/># Remove stones surrounded by opponent<br/>#--------------------------------------<br/>def remove_stones(color, remove=True):    <br/>    # create a new array with 1 padding of 1 around the sides <br/>    # (for edge case)<br/>    temp_stones_values = np.full((21,21), color) <br/>    <br/>    # copy the current stones_values into the padded array<br/>    temp_stones_values[1:-1, 1:-1] = stones_values</span><span id="3c98" class="ng nh it nc b gy nm nj l nk nl">    #-----------------------------------------------<br/>    # Checking the liberties of the opponent stones<br/>    #-----------------------------------------------<br/>    # for each of opponent's stones, check to see if it has an <br/>    # liberty around it     <br/>    # you are looking inside the border, so [1:-1,1:-1]<br/>    for x,y in zip(<br/>        np.where(temp_stones_values[1:-1,1:-1] == color)[0],<br/>        np.where(temp_stones_values[1:-1,1:-1] == color)[1]):           <br/>        x+=1  # need to add one because of the padding<br/>        y+=1  # need to add one because of the padding<br/>        # as long as you have a surrounding that is 0 (empty), the <br/>        # stone is alive (at least one liberty)<br/>        if temp_stones_values[x-1,y] == 0 or \<br/>           temp_stones_values[x+1,y] == 0 or \<br/>           temp_stones_values[x,y-1] == 0 or \<br/>           temp_stones_values[x,y+1] == 0:<br/>            temp_stones_values[x,y] = 8      # stone is alive</span><span id="a801" class="ng nh it nc b gy nm nj l nk nl">    #--------------------------------------<br/>    # Find groups of stones that are alive<br/>    #--------------------------------------<br/>    # if a stone is still alive, infect those of the same color    <br/>    flipped=True</span><span id="98e7" class="ng nh it nc b gy nm nj l nk nl">    while flipped:        <br/>        flipped=False<br/>        # find all the opponent's stones<br/>        for x,y in zip(<br/>            np.where(temp_stones_values[1:-1,1:-1] == color)[0],<br/>            np.where(temp_stones_values[1:-1,1:-1] == color)[1]):   <br/>            x+=1  # need to add one because of the padding<br/>            y+=1  # need to add one because of the padding<br/>            if temp_stones_values[x-1,y] == 8 or \<br/>               temp_stones_values[x+1,y] == 8 or \<br/>               temp_stones_values[x,y-1] == 8 or \<br/>               temp_stones_values[x,y+1] == 8:<br/>                temp_stones_values[x,y] = 8      # alive<br/>                flipped = True                <br/>        <br/>    #----------------------------<br/>    # remove all the dead groups<br/>    #----------------------------<br/>    count = 0<br/>    for x in range(1,20):<br/>        for y in range(1,20):            <br/>            if temp_stones_values[x,y] == color:<br/>                if remove:<br/>                    stones[x-1,y-1].pop().remove()<br/>                    stones[x-1,y-1] = None<br/>                    stones_values[x-1,y-1] = 0<br/>                count += 1<br/>    plt.draw()</span><span id="6348" class="ng nh it nc b gy nm nj l nk nl">    # return the number of stones removed<br/>    return count</span><span id="12ab" class="ng nh it nc b gy nm nj l nk nl"># event handler to handle click on the board<br/>def on_click(event):    <br/>    global white<br/>    print(f'x: {event.xdata} y: {event.ydata}')<br/>    <br/>    # get the points clicked on the board<br/>    if event.xdata == None or event.ydata == None:<br/>        return<br/>    x = int(round(event.xdata))<br/>    y = int(round(event.ydata))<br/>    <br/>    #-----------------------------<br/>    # Draw the stone on the board   <br/>    #-----------------------------<br/>    # make sure the area clicked is within the board<br/>    if 0&lt;=x&lt;=18 and 0&lt;=y&lt;=18:<br/>        # if the user left clicked to add a new stone on the board<br/>        if event.button == 1 and stones[x,y] == None:<br/>            stones[x,y] = draw_stone(x,y,'w' if white else 'k')<br/>            stones_values[x,y] = 1 if white else -1<br/>            white = not white                   # switch the color            <br/>        # when user right-clicked to remove a stone on the board  <br/>        elif event.button == 3 and stones[x,y] != None:<br/>            stones[x,y].pop().remove()          # remove the plot  <br/>            stones[x,y] = None<br/>            stones_values[x,y] = 0            <br/>        else:<br/>            return<br/>        <br/>        plt.draw()                              # update the figure<br/>        # print(stones)<br/>        # print(stones_values)<br/>        print(np.rot90(stones)) <br/>        print(np.rot90(stones_values)) <br/>    else:<br/>        return</span><span id="cb55" class="ng nh it nc b gy nm nj l nk nl">    #-----------------------------------<br/>    # Remove stones that are surrounded<br/>    #-----------------------------------<br/>    # color of the opponent<br/>    color = 1 if white else -1     # white is 1; black is -1    <br/>    <br/>    # remove stones of surrounded opponent<br/>    if remove_stones(color) == 0: # if no stones removed, check for <br/>                                  # suicide<br/>        white = not white<br/>        color = 1 if white else -1 <br/>        if remove_stones(color, remove=False) == 0:  # there is no <br/>                                                     # suicide<br/>            white = not white<br/>        else:                                     # there is suicide<br/>            # remove the stone that was placed on the board          <br/>            stones[x,y].pop().remove()    <br/>            stones[x,y] = None<br/>            stones_values[x,y] = 0<br/>            plt.draw()<br/>            beepy.beep(sound="ping")</span><span id="e2a2" class="ng nh it nc b gy nm nj l nk nl">#-----main-----<br/>fig, ax = draw_board()<br/>draw_grids(ax)</span><span id="3ecf" class="ng nh it nc b gy nm nj l nk nl"># draw the 9 star points on the board<br/>draw_star_points(ax, 3,3)<br/>draw_star_points(ax, 3,9)<br/>draw_star_points(ax, 3,15)<br/>draw_star_points(ax, 9,3)<br/>draw_star_points(ax, 9,9)<br/>draw_star_points(ax, 9,15)<br/>draw_star_points(ax, 15,3)<br/>draw_star_points(ax, 15,9)<br/>draw_star_points(ax, 15,15)</span><span id="2fc9" class="ng nh it nc b gy nm nj l nk nl">#-------<br/>#  0 for empty<br/>#  1 for white<br/># -1 for black<br/>#-------</span><span id="66bd" class="ng nh it nc b gy nm nj l nk nl"># color of the stone to start<br/>white = True</span><span id="459f" class="ng nh it nc b gy nm nj l nk nl"># stones is for storing the plot (containing the stone)<br/>stones = np.full((19,19), None)</span><span id="7dd3" class="ng nh it nc b gy nm nj l nk nl"># stones_values stores the value (color) of each point<br/>stones_values = np.full((19,19),0)</span><span id="d2a8" class="ng nh it nc b gy nm nj l nk nl">fig.canvas.mpl_connect('button_press_event', on_click)</span><span id="5e71" class="ng nh it nc b gy nm nj l nk nl">plt.show()</span></pre><div class="lv lw gp gr lx ly"><a href="https://weimenglee.medium.com/membership" rel="noopener follow" target="_blank"><div class="lz ab fo"><div class="ma ab mb cl cj mc"><h2 class="bd iu gy z fp md fr fs me fu fw is bi translated">加入媒介与我的介绍链接-李伟孟</h2><div class="mf l"><h3 class="bd b gy z fp md fr fs me fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="mg l"><p class="bd b dl z fp md fr fs me fu fw dk translated">weimenglee.medium.com</p></div></div><div class="mh l"><div class="qb l mj mk ml mh mm ks ly"/></div></div></a></div></div></div>    
</body>
</html>