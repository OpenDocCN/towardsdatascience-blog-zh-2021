<html>
<head>
<title>How to find all solutions to the SUBSET-SUM problem</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何找到子集和问题的所有解</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-find-all-solutions-to-the-subset-sum-problem-597f77677e45?source=collection_archive---------4-----------------------#2021-12-20">https://towardsdatascience.com/how-to-find-all-solutions-to-the-subset-sum-problem-597f77677e45?source=collection_archive---------4-----------------------#2021-12-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/fbe50212cecac9801bb52c9be8db5067.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qZDYjp8nLY-GAA92"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">照片由<a class="ae jg" href="https://unsplash.com/@antoine1003?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Antoine Dautry </a>在<a class="ae jg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><div class=""/><div class=""><h2 id="0f23" class="pw-subtitle-paragraph kg ji jj bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dk translated">适用于负数、正数和重复数字的动态编程解决方案</h2></div><p id="00b9" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">子集和问题涉及确定整数列表中的子集是否可以和为目标值。比如考虑一下<code class="fe lu lv lw lx b">nums = [1, 2, 3, 4]</code>的列表。如果<code class="fe lu lv lw lx b">target = 7</code>，有两个子集达到这个和:<code class="fe lu lv lw lx b">{3, 4}</code>和<code class="fe lu lv lw lx b">{1, 2, 4}</code>。如果<code class="fe lu lv lw lx b">target = 11</code>，没有解决方案。</p><p id="1d72" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一般来说，确定子集和是否有<em class="ly">甚至任意</em>个解是<a class="ae jg" href="https://en.wikipedia.org/wiki/NP-hardness" rel="noopener ugc nofollow" target="_blank"> NP 难</a>:如果<code class="fe lu lv lw lx b">nums</code>列表中有<code class="fe lu lv lw lx b">n</code>个整数，则存在<code class="fe lu lv lw lx b">2^n — 1</code>个子集需要检查(不包括空集)。在这篇文章中，我们将会看到一个更有效的解决方法，使用动态规划 (DP)。然而，与大多数教程不同，我们不仅要确定<strong class="la jk">是否存在</strong>一个解决方案，还要看看<strong class="la jk">如何发现所有解决方案</strong>。该算法适用于负的和正的输入值，以及<code class="fe lu lv lw lx b">nums</code>中重复的非唯一整数。</p><h2 id="55b6" class="lz ma jj bd mb mc md dn me mf mg dp mh lh mi mj mk ll ml mm mn lp mo mp mq mr bi translated">TLDR；Python 包🐍</h2><p id="fa65" class="pw-post-body-paragraph ky kz jj la b lb ms kk ld le mt kn lg lh mu lj lk ll mv ln lo lp mw lr ls lt im bi translated">寻找快速解决方案，但不一定想知道底层细节？我创建了一个名为“<a class="ae jg" href="https://pypi.org/project/subsetsum/" rel="noopener ugc nofollow" target="_blank"> subsetsum </a>的 Python 包，带有一个超快的求解器:<code class="fe lu lv lw lx b">pip install subsetsum</code></p><p id="0bad" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">求解器的逻辑用 C++实现，并使用<a class="ae jg" href="https://pybind11.readthedocs.io/en/stable/" rel="noopener ugc nofollow" target="_blank"> Pybind11 </a>来公开一个 Python 接口。GitHub 上的<a class="ae jg" href="https://github.com/trevphil/subsetsum" rel="noopener ugc nofollow" target="_blank">提供了源代码。</a></p><h1 id="825a" class="mx ma jj bd mb my mz na me nb nc nd mh kp ne kq mk ks nf kt mn kv ng kw mq nh bi translated">1.预处理</h1><p id="dde8" class="pw-post-body-paragraph ky kz jj la b lb ms kk ld le mt kn lg lh mu lj lk ll mv ln lo lp mw lr ls lt im bi translated">在进入 DP 解决方案之前，我们将对问题输入(<code class="fe lu lv lw lx b">nums</code>和<code class="fe lu lv lw lx b">target</code>)进行一些预处理。</p><h2 id="0149" class="lz ma jj bd mb mc md dn me mf mg dp mh lh mi mj mk ll ml mm mn lp mo mp mq mr bi translated">翻转标志🔄</h2><p id="d66c" class="pw-post-body-paragraph ky kz jj la b lb ms kk ld le mt kn lg lh mu lj lk ll mv ln lo lp mw lr ls lt im bi translated">我们要做的第一件事是翻转<code class="fe lu lv lw lx b">nums</code>中所有整数的符号，如果目标是负的，则翻转<code class="fe lu lv lw lx b">target</code>、<em class="ly">。这确保了我们的<code class="fe lu lv lw lx b">target</code>将总是 0 或更大，这只是让整个算法的生活更容易！我们可以不用担心，因为翻转符号前后的解是相同的:</em></p><pre class="ni nj nk nl gt nm lx nn no aw np bi"><span id="b3ff" class="lz ma jj lx b gy nq nr l ns nt">x0 + x1 + ... + x10 = target<br/># Multiply both sides by -1<br/>-x0 - x1 - ... - x10 = -target<br/># The equations are equivalent!</span></pre><h2 id="bbab" class="lz ma jj bd mb mc md dn me mf mg dp mh lh mi mj mk ll ml mm mn lp mo mp mq mr bi translated">对➡️的数字进行排序</h2><p id="6f94" class="pw-post-body-paragraph ky kz jj la b lb ms kk ld le mt kn lg lh mu lj lk ll mv ln lo lp mw lr ls lt im bi translated">下一个预处理步骤是按升序对<code class="fe lu lv lw lx b">nums</code>进行排序，这是 DP 算法工作所必需的(稍后描述)。如果你需要记住<code class="fe lu lv lw lx b">nums</code>的原始顺序，你可以执行一个<a class="ae jg" href="https://numpy.org/doc/stable/reference/generated/numpy.argsort.html" rel="noopener ugc nofollow" target="_blank"> argsort </a>，它从一个整数在列表中的当前位置映射到它在排序列表中的位置。如果需要，您可以随时重新映射回原始位置。</p><pre class="ni nj nk nl gt nm lx nn no aw np bi"><span id="decd" class="lz ma jj lx b gy nq nr l ns nt">nums = [-2, 1, -3, 0, 4, 5]<br/>index = argsort(nums) = [2, 0, 3, 1, 4, 5]<br/>nums[index] = [-3, -2, 0, 1, 4, 5]</span></pre><h2 id="8320" class="lz ma jj bd mb mc md dn me mf mg dp mh lh mi mj mk ll ml mm mn lp mo mp mq mr bi translated">检查目标是否过低或过高🛑</h2><p id="9d91" class="pw-post-body-paragraph ky kz jj la b lb ms kk ld le mt kn lg lh mu lj lk ll mv ln lo lp mw lr ls lt im bi translated">考虑<code class="fe lu lv lw lx b">nums = [-3, -2, -1, 1, 2, 3, 4]</code>的情况。可达到的最小总和是多少？<strong class="la jk"> -6 </strong>。最大的<em class="ly">金额可能是多少？<strong class="la jk"> 10 </strong>。如果<code class="fe lu lv lw lx b">target</code>之和比<code class="fe lu lv lw lx b">nums</code>中所有负整数之和少<em class="ly">或者比<code class="fe lu lv lw lx b">nums</code>中所有正整数之和多<em class="ly">则无解。</em></em></em></p><p id="7984" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们将在变量<code class="fe lu lv lw lx b">a</code>中存储所有负整数的和，在变量<code class="fe lu lv lw lx b">b</code>中存储所有正整数的和。如果<code class="fe lu lv lw lx b">target &lt; a</code>或者<code class="fe lu lv lw lx b">target &gt; b</code>，我们可以以“无解！”</p><h1 id="b8d7" class="mx ma jj bd mb my mz na me nb nc nd mh kp ne kq mk ks nf kt mn kv ng kw mq nh bi translated">2.动态规划</h1><figure class="ni nj nk nl gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nu"><img src="../Images/162536e8527830c51892fc6cdeeca0d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Z35_IDzdkCuT15BM"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">照片由<a class="ae jg" href="https://unsplash.com/@mbaumi?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">米卡·鲍梅斯特</a>在<a class="ae jg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="4499" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">预处理完成后，我们准备填充一个名为<code class="fe lu lv lw lx b">DP</code>的<a class="ae jg" href="https://en.wikipedia.org/wiki/Dynamic_programming" rel="noopener ugc nofollow" target="_blank">动态编程</a>表。<code class="fe lu lv lw lx b">DP</code>表将有<code class="fe lu lv lw lx b">n</code>行(给定<code class="fe lu lv lw lx b">n</code>数字)和<code class="fe lu lv lw lx b">target — a + 1</code>列。存储在表格中的值将只是<strong class="la jk">真</strong>或<strong class="la jk">假</strong>。行和列索引从 0 开始。</p><ul class=""><li id="c311" class="nv nw jj la b lb lc le lf lh nx ll ny lp nz lt oa ob oc od bi translated">如果我们在<code class="fe lu lv lw lx b">row i</code>上，我们会考虑使用整数<em class="ly">的所有子集，直到并包括排序后的<code class="fe lu lv lw lx b">nums</code>中的第<code class="fe lu lv lw lx b">i</code>个整数</em>。第<code class="fe lu lv lw lx b">i</code>个整数<strong class="la jk">不</strong>需要包含，但是如果我们想使用它，它是“可用”的。</li><li id="6ffc" class="nv nw jj la b lb oe le of lh og ll oh lp oi lt oa ob oc od bi translated">如果我们在<code class="fe lu lv lw lx b">column j</code>上，我们将试图找到总和为<code class="fe lu lv lw lx b">a + j</code>的“中间”目标的子集。注意，因为我们有<code class="fe lu lv lw lx b">target — a + 1</code>列，所以<code class="fe lu lv lw lx b">j</code>的最终值将是<code class="fe lu lv lw lx b">target — a</code>，这意味着最后，我们试图找到总和为<code class="fe lu lv lw lx b">a + j = a + target — a = target</code>的子集。</li><li id="9923" class="nv nw jj la b lb oe le of lh og ll oh lp oi lt oa ob oc od bi translated">因此，<code class="fe lu lv lw lx b">DP[i, j] = 1</code>意味着<code class="fe lu lv lw lx b">nums[0...i]</code>中存在一个子集，其总和为<code class="fe lu lv lw lx b">a + j</code>。如果<code class="fe lu lv lw lx b">DP[i, j] = 0</code>不存在这样的子集。</li><li id="a362" class="nv nw jj la b lb oe le of lh og ll oh lp oi lt oa ob oc od bi translated"><strong class="la jk">恢复解</strong>:如果<code class="fe lu lv lw lx b">DP[n — 1, target — a] == 1</code>，存在<code class="fe lu lv lw lx b">nums</code>的子集，总和为<code class="fe lu lv lw lx b">target</code>。</li></ul><h2 id="b427" class="lz ma jj bd mb mc md dn me mf mg dp mh lh mi mj mk ll ml mm mn lp mo mp mq mr bi translated">更新规则⭐️</h2><p id="9d58" class="pw-post-body-paragraph ky kz jj la b lb ms kk ld le mt kn lg lh mu lj lk ll mv ln lo lp mw lr ls lt im bi translated">我们首先用零初始化<code class="fe lu lv lw lx b">DP</code>表，并填充<code class="fe lu lv lw lx b">DP</code>的第一行，注意如果<code class="fe lu lv lw lx b">nums[0]</code>等于<code class="fe lu lv lw lx b">a + j</code>，则<code class="fe lu lv lw lx b">DP[0, j]</code>只能是<strong class="la jk"> 1 </strong>。</p><pre class="ni nj nk nl gt nm lx nn no aw np bi"><span id="b44d" class="lz ma jj lx b gy nq nr l ns nt">for j in range(0, target - a + 1):<br/>    DP[0, j] = (nums[0] == a + j)</span></pre><p id="27f7" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于剩余的行，<code class="fe lu lv lw lx b">DP[i, j]</code>可以在以下情况下标记为<strong class="la jk"> 1 </strong>:</p><ul class=""><li id="680c" class="nv nw jj la b lb lc le lf lh nx ll ny lp nz lt oa ob oc od bi translated"><code class="fe lu lv lw lx b">DP[i — 1, j] == 1</code>:如果仅使用来自<code class="fe lu lv lw lx b">nums[0...(i — 1)]</code>的子集就可以实现“中间”目标<code class="fe lu lv lw lx b">a + j</code>，那么很明显，如果允许第<code class="fe lu lv lw lx b">i</code>个数字在该子集中，也可以实现该目标。</li><li id="6ef5" class="nv nw jj la b lb oe le of lh og ll oh lp oi lt oa ob oc od bi translated"><code class="fe lu lv lw lx b">nums[i] == a + j</code>:在这种情况下，中间目标<code class="fe lu lv lw lx b">a + j</code>可以从单整数子集<code class="fe lu lv lw lx b">{nums[i]}</code>中得到。</li><li id="45fc" class="nv nw jj la b lb oe le of lh og ll oh lp oi lt oa ob oc od bi translated"><code class="fe lu lv lw lx b">DP[i — 1, j — nums[i]] == 1</code>:最棘手的规则，让人想起背包问题的动态编程解决方案<a class="ae jg" href="https://medium.com/@fabianterh/how-to-solve-the-knapsack-problem-with-dynamic-programming-eb88c706d3cf" rel="noopener">。如果有一个<code class="fe lu lv lw lx b">nums[0...(i — 1)]</code>的子集总计为<code class="fe lu lv lw lx b">a + j — nums[i]</code>，那么我们知道有<em class="ly">也是</em>的一个子集，通过将<code class="fe lu lv lw lx b">nums[i]</code>包含在该子集中而总计为<code class="fe lu lv lw lx b">a + j</code>。</a></li></ul><pre class="ni nj nk nl gt nm lx nn no aw np bi"><span id="9bf8" class="lz ma jj lx b gy nq nr l ns nt">for i in range(1, n):<br/>    for j in range(0, target - a + 1):<br/>        DP[i, j] = DP[i - 1, j] or nums[i] == (a + j)<br/>        if DP[i, j] == False:<br/>            next_j = j - nums[i]<br/>            if 0 &lt;= next_j &lt; target - a + 1:<br/>                DP[i, j] = DP[i - 1, next_j]</span></pre><h2 id="4622" class="lz ma jj bd mb mc md dn me mf mg dp mh lh mi mj mk ll ml mm mn lp mo mp mq mr bi translated">时间和空间复杂性⏱</h2><p id="7c48" class="pw-post-body-paragraph ky kz jj la b lb ms kk ld le mt kn lg lh mu lj lk ll mv ln lo lp mw lr ls lt im bi translated">这里描述的 DP 解决方案是所谓的<a class="ae jg" href="https://en.wikipedia.org/wiki/Pseudo-polynomial_time" rel="noopener ugc nofollow" target="_blank">伪多项式算法</a>。DP 表格的大小不仅(线性地)取决于<code class="fe lu lv lw lx b">nums</code>中元素的数量，还(线性地)取决于<code class="fe lu lv lw lx b">nums</code>和<code class="fe lu lv lw lx b">target</code>的值，因为表格中的列数是<code class="fe lu lv lw lx b">target</code>和<code class="fe lu lv lw lx b">nums</code>中负整数之和之间的距离。</p><p id="a735" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">表的每个单元格必须设置为 0 或 1 一次，这是使用对其他单元格的恒定数量的查询来确定的，因此算法的运行时与表的大小成比例。</p><h2 id="c1ec" class="lz ma jj bd mb mc md dn me mf mg dp mh lh mi mj mk ll ml mm mn lp mo mp mq mr bi translated">DP 有缺点，蛮干可以更好💪</h2><p id="0473" class="pw-post-body-paragraph ky kz jj la b lb ms kk ld le mt kn lg lh mu lj lk ll mv ln lo lp mw lr ls lt im bi translated">先说<code class="fe lu lv lw lx b">nums = [-1000000, 1000000]</code>和<code class="fe lu lv lw lx b">target = 999999</code>。使用 DP 方法，我们将有 2 行和<code class="fe lu lv lw lx b">999999 + 1000000 + 1 = 2000000</code>列。对于一个显然无法解决的问题来说，内存使用量太大了！如果<code class="fe lu lv lw lx b">nums</code>中的数字很少，但是值的范围很大，你最好强力检查所有可能的子集。</p><h1 id="47f8" class="mx ma jj bd mb my mz na me nb nc nd mh kp ne kq mk ks nf kt mn kv ng kw mq nh bi translated">3.寻找所有解决方案🤯</h1><figure class="ni nj nk nl gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oj"><img src="../Images/e6245164932a055658a81f09408b3962.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*KKP33DOsQiujVp_Z"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">我们会用栈，可惜不是这种栈！照片由<a class="ae jg" href="https://unsplash.com/@brigittetohm?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">布里吉特·托姆</a>在<a class="ae jg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="16aa" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们继续讨论可能是最具挑战性的话题，也是其他教程中最少讨论的话题:如何实际找出哪些子集达到了<code class="fe lu lv lw lx b">target</code>和！</p><p id="7031" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">要做到这一点，我们需要使用我们的<code class="fe lu lv lw lx b">DP</code>表，并通过它回溯。我们将使用一种非递归技术:一个<a class="ae jg" href="https://en.wikipedia.org/wiki/Stack_%28abstract_data_type%29" rel="noopener ugc nofollow" target="_blank">堆栈</a>。堆栈中的每一项都是一个简单的数据结构，我称之为<code class="fe lu lv lw lx b">StackItem</code>。</p><pre class="ni nj nk nl gt nm lx nn no aw np bi"><span id="b422" class="lz ma jj lx b gy nq nr l ns nt">class StackItem:<br/>    row: int  # Row index in the DP table<br/>    col: int  # Column index in the DP table<br/>    take: list[int]  # <strong class="lx jk">Indices</strong> of integers to include in the subset<br/>    togo: int  # Value "to go" until reaching the `target` sum</span></pre><p id="441c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在我们知道，如果<code class="fe lu lv lw lx b">DP</code>表格右下角的单元格是<strong class="la jk"> 1 </strong>，那么就有一个解决方案。否则，就不要费心去寻找解决方案了，因为根本就没有解决方案！我们将从右下角的单元格开始初始化堆栈/回溯。我们假设<code class="fe lu lv lw lx b">nums</code> <strong class="la jk">中的最后一个整数是子集包含的</strong>，那么<code class="fe lu lv lw lx b">togo</code>将是<code class="fe lu lv lw lx b">target</code>值减去<code class="fe lu lv lw lx b">nums[n — 1]</code>。</p><pre class="ni nj nk nl gt nm lx nn no aw np bi"><span id="64b2" class="lz ma jj lx b gy nq nr l ns nt">stack.push(<br/>    StackItem(<br/>        row=n - 1,<br/>        col=target - a,<br/>        take=[n - 1],<br/>        togo=target - nums[n - 1]<br/>    )<br/>)</span></pre><p id="f6a0" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，我们不断从堆栈中弹出项目，并添加新的项目，直到它是空的。一旦完成，我们将列举所有可能的解决方案。</p><p id="b3bb" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">假设我们刚刚弹出了一个项目:<code class="fe lu lv lw lx b">item = stack.pop()</code>的<code class="fe lu lv lw lx b">row = i</code>和<code class="fe lu lv lw lx b">col = j</code>。我们将检查<code class="fe lu lv lw lx b">item</code>的三个场景:</p><ol class=""><li id="1009" class="nv nw jj la b lb lc le lf lh nx ll ny lp nz lt ok ob oc od bi translated">如果<code class="fe lu lv lw lx b">DP[i — 1, j] == 1</code>，那么可能有一个不使用<code class="fe lu lv lw lx b">nums</code>中第<code class="fe lu lv lw lx b">i</code>个整数的解决方案。在这种情况下，我们将添加一个新的<code class="fe lu lv lw lx b">StackItem</code>，就好像第<code class="fe lu lv lw lx b">i</code>个整数<strong class="la jk">不包含在子集中，但是第<code class="fe lu lv lw lx b">(i-1)</code>个整数<strong class="la jk">是</strong>。</strong></li><li id="975f" class="nv nw jj la b lb oe le of lh og ll oh lp oi lt ok ob oc od bi translated">如果<code class="fe lu lv lw lx b">DP[i — 1, j — nums[i]] == 1</code>，那么有一个解决方案，使用剩余的<code class="fe lu lv lw lx b">nums[0...(i — 1)]</code>整数形成一个“中间”子集，其总和为<code class="fe lu lv lw lx b">a + j — nums[i]</code>。在这种情况下，我们将添加一个新的<code class="fe lu lv lw lx b">StackItem</code>，假设第<code class="fe lu lv lw lx b">i</code>个整数<strong class="la jk">是包含在“最终”子集中的</strong>。</li><li id="b97a" class="nv nw jj la b lb oe le of lh og ll oh lp oi lt ok ob oc od bi translated">如果<code class="fe lu lv lw lx b">item.togo == 0</code>那么我们已经有了解决方案！然后<code class="fe lu lv lw lx b">item.take</code>将整数的索引存储在(排序的)<code class="fe lu lv lw lx b">nums</code>中，形成一个子集，其和为<code class="fe lu lv lw lx b">target</code>。</li></ol><pre class="ni nj nk nl gt nm lx nn no aw np bi"><span id="05a2" class="lz ma jj lx b gy nq nr l ns nt">while len(stack) &gt; 0:<br/>    item = stack.pop()<br/>    i, j, take, togo = item.unpack()</span><span id="ed47" class="lz ma jj lx b gy ol nr l ns nt">    # Scenario 1<br/>    if i &gt; 0 and DP[i - 1, j]:<br/>        new_take = take.copy()<br/>        new_take[-1] = i - 1  # Replace the last element<br/>        new_togo = togo + nums[i] - nums[i - 1]<br/>        stack.push(StackItem(i - 1, j, new_take, new_togo))</span><span id="7a57" class="lz ma jj lx b gy ol nr l ns nt">    # Scenario 2<br/>    next_j = j - nums[i]<br/>    if i &gt; 0 and 0 &lt;= next_j &lt; (target - a + 1):<br/>        if DP[i - 1, next_j]:<br/>            new_take = take.copy()<br/>            new_take.append(row - 1)  # Add a new element<br/>            new_togo = togo - nums[i - 1]<br/>            stack.push(StackItem(i - 1, next_j, new_take, new_togo))</span><span id="e51d" class="lz ma jj lx b gy ol nr l ns nt">    # Scenario 3<br/>    if togo == 0:<br/>        yield [nums[t] for t in take]</span></pre><h1 id="4bc7" class="mx ma jj bd mb my mz na me nb nc nd mh kp ne kq mk ks nf kt mn kv ng kw mq nh bi translated">结论🎉</h1><p id="8068" class="pw-post-body-paragraph ky kz jj la b lb ms kk ld le mt kn lg lh mu lj lk ll mv ln lo lp mw lr ls lt im bi translated">我希望您喜欢学习如何使用动态编程解决子集和问题！有相当多的在线资源解释了如何确定<em class="ly">是否对于特定的一组(<code class="fe lu lv lw lx b">nums</code>，<code class="fe lu lv lw lx b">target</code>)存在</em>解，但是这些教程通常假设所有的数字都是正数。这里描述的算法也适用于负数！💡此外，几乎没有现有的教程解释如何利用 DP 表回溯所有解决方案，这是本文的主要动机。</p><p id="beb8" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">更具体的实现(C++和 Python，不是伪代码)请访问<a class="ae jg" href="https://github.com/trevphil/subsetsum" rel="noopener ugc nofollow" target="_blank"> GitHub </a>或通过<code class="fe lu lv lw lx b">pip install subsetsum</code>下载 pip 模块。</p></div></div>    
</body>
</html>