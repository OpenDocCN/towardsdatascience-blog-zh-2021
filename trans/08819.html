<html>
<head>
<title>The Single Responsibility Principle in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的单一责任原则</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/the-single-responsibility-principle-in-python-d0ab0a681853?source=collection_archive---------16-----------------------#2021-08-14">https://towardsdatascience.com/the-single-responsibility-principle-in-python-d0ab0a681853?source=collection_archive---------16-----------------------#2021-08-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="5c90" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">一个原则来统治他们</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/009dd7b7c355faab5e76649ccdc9ce81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*iZK7bpcvGOBuE6TW"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/@freestocks?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">自由股票</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="cef2" class="ld le iq bd lf lg lh li lj lk ll lm ln jw lo jx lp jz lq ka lr kc ls kd lt lu bi translated">介绍</h1><p id="2336" class="pw-post-body-paragraph lv lw iq lx b ly lz jr ma mb mc ju md me mf mg mh mi mj mk ml mm mn mo mp mq ij bi translated"><a class="ae kv" href="https://en.wikipedia.org/wiki/Single-responsibility_principle" rel="noopener ugc nofollow" target="_blank">单一责任原则</a> (SRP)声明一个功能或者一个类应该有一个责任。遵循这个原则将有助于保持你的功能小而易管理。</p><p id="ce8c" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">打破这个规则有时是合理的，但是你越依赖一个单独的功能，理解、更新、更改、调试或重构它就越困难。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h2 id="c4fc" class="mw le iq bd lf mx my dn lj mz na dp ln me nb nc lp mi nd ne lr mm nf ng lt nh bi translated">职能职责示例</h2><p id="08e3" class="pw-post-body-paragraph lv lw iq lx b ly lz jr ma mb mc ju md me mf mg mh mi mj mk ml mm mn mo mp mq ij bi translated">从数据库中获取数据是一项职责。</p><p id="9a57" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">过滤、排序或转换数据是另一项职责。</p><p id="6ad8" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">存储数据是不同的职责。</p><p id="b0e1" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">将数据呈现给用户也是如此。</p><p id="f024" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">处理一个以上责任的职能有一个以上的理由去改变。当你必须改变一个函数时，这个函数做的事情越多，在不引入不想要的行为的情况下改变它的实现就越困难。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="5ffe" class="ld le iq bd lf lg lh li lj lk ll lm ln jw lo jx lp jz lq ka lr kc ls kd lt lu bi translated">激励示例:从档案中提取数据</h1><p id="1e2d" class="pw-post-body-paragraph lv lw iq lx b ly lz jr ma mb mc ju md me mf mg mh mi mj mk ml mm mn mo mp mq ij bi translated">假设我有一个包含文件的目录，我需要访问这些文件中的数据。其中一些存档在。zip，。焦油或者。gz格式，所以我也需要先提取这些档案。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ni"><img src="../Images/76051d6e8c5099e1b53f1a65e47f5cb8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*4qQT2xNuQOgMaGCa"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Jason Pofahl 在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="cdd0" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">看看下面我要完成的功能:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="4140" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">这看起来很简单，对吗？简短易懂，为什么要拆分？</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h2 id="643b" class="mw le iq bd lf mx my dn lj mz na dp ln me nb nc lp mi nd ne lr mm nf ng lt nh bi translated">短函数并不总是足够的</h2><p id="976e" class="pw-post-body-paragraph lv lw iq lx b ly lz jr ma mb mc ju md me mf mg mh mi mj mk ml mm mn mo mp mq ij bi translated">可惜这个小功能做多了。你可以认为这个函数在5行代码中有<strong class="lx ir"> 3个职责:</strong></p><ol class=""><li id="b275" class="nl nm iq lx b ly mr mb ms me nn mi no mm np mq nq nr ns nt bi translated">它遍历给定目录中的文件。</li><li id="48d9" class="nl nm iq lx b ly nu mb nv me nw mi nx mm ny mq nq nr ns nt bi translated">它确定文件是否是归档文件。</li><li id="8078" class="nl nm iq lx b ly nu mb nv me nw mi nx mm ny mq nq nr ns nt bi translated">如果它将文件识别为归档文件，它会提取其中包含的文件。</li></ol></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h2 id="4487" class="mw le iq bd lf mx my dn lj mz na dp ln me nb nc lp mi nd ne lr mm nf ng lt nh bi translated">随着职责的增加，复杂性呈指数级增长</h2><p id="405b" class="pw-post-body-paragraph lv lw iq lx b ly lz jr ma mb mc ju md me mf mg mh mi mj mk ml mm mn mo mp mq ij bi translated">如果这个函数以它当前的形式做了你需要它做的所有事情，并且永远不会改变或被再次看到，那么它当前的形式就足够了。不是每个功能都需要不断地分解成更小的子功能。</p><p id="cf52" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">但是，请考虑以下情况:</p><ul class=""><li id="cde7" class="nl nm iq lx b ly mr mb ms me nn mi no mm np mq nz nr ns nt bi translated">您需要更改正则表达式，以指定更多需要提取的归档类型。</li><li id="2d64" class="nl nm iq lx b ly nu mb nv me nw mi nx mm ny mq nz nr ns nt bi translated">您有一个嵌套的目录结构，例如当一个归档包含一个目录或另一个归档时。</li><li id="a6a5" class="nl nm iq lx b ly nu mb nv me nw mi nx mm ny mq nz nr ns nt bi translated">您正在Windows上开发，归档中的一些文件路径超过了Windows的260个限制，这使得<code class="fe oa ob oc od b">shutil.unpack_archive</code>无法提取文件。</li><li id="3600" class="nl nm iq lx b ly nu mb nv me nw mi nx mm ny mq nz nr ns nt bi translated">除了归档文件之外，您还有另一种文件类型，必须以不同的方式准备。</li><li id="b041" class="nl nm iq lx b ly nu mb nv me nw mi nx mm ny mq nz nr ns nt bi translated">您有一个额外的归档格式，它不是由<code class="fe oa ob oc od b">shutil</code>处理的。</li><li id="9afc" class="nl nm iq lx b ly nu mb nv me nw mi nx mm ny mq nz nr ns nt bi translated">你不需要或者不能提取存档中的所有文件，所以你必须使用低级的存档处理函数，比如<code class="fe oa ob oc od b">zipfile</code>、<code class="fe oa ob oc od b">tarfile</code>和<code class="fe oa ob oc od b">gzip</code>，而不是<code class="fe oa ob oc od b">shutil.unpack_archive</code>。</li></ul><p id="172f" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">遇到这些情况中的任何一种，或者更有可能是它们的组合，都可能使您的小函数变得非常复杂。我在处理与我们的例子类似的任务时遇到了上述所有情况。</p><p id="2e29" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">如果这3项职责中的每一项都有3个单独的案例需要你去处理，那就是3或27个组合。你整洁的小功能很快就会变成一团乱麻。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oe"><img src="../Images/b6ba94ffe37084d8980328a27bba25f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ylLS-KwJTas5YGRB"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@patkrupa?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">帕特·克鲁帕</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="7af2" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">如果你确定你不会有任何更新或者棘手的情况(你没有)，上面的函数就足够好了。对我们其余的人来说——我们只是凡人，我们处理的不是微不足道的问题，所以我们必须防范不可预见的事情。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="d3f7" class="ld le iq bd lf lg lh li lj lk ll lm ln jw lo jx lp jz lq ka lr kc ls kd lt lu bi translated">基于单一责任原则的重构</h1><p id="b2e3" class="pw-post-body-paragraph lv lw iq lx b ly lz jr ma mb mc ju md me mf mg mh mi mj mk ml mm mn mo mp mq ij bi translated">假设我不需要或者不能从特定类型的归档中提取文件。对我来说幸运的是，这些档案的名字都带有前缀“skip_”。</p><p id="3fa4" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">现在，确定文件路径的逻辑变得越来越复杂，所以我想将文件路径的生成与函数的其余部分分开。</p><p id="046f" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">下面的代码将上述函数分成三部分，一部分用于创建文件路径列表，一部分用于确定是否应该提取文件路径，另一部分用于遍历这些文件并调用提取函数:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="aac5" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">注意<code class="fe oa ob oc od b">get_archive_filepaths</code>实际上和我们的原始函数长度相同！较短的函数通常更好，但在这种情况下不一定如此。</p><p id="116d" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">构建<code class="fe oa ob oc od b">archive_paths</code>的5行代码可以做成一个单行的列表理解，但是我认为结果会不太清楚。</p><p id="3e3b" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">随着职责的增加，我们的职能仍有改进的空间，但我们有了一个良好的开端。通过分离提取数据的逻辑和生成文件路径列表的逻辑，对一个函数的任何更改都不会影响另一个函数。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h2 id="11ce" class="mw le iq bd lf mx my dn lj mz na dp ln me nb nc lp mi nd ne lr mm nf ng lt nh bi translated">使用单一责任原则的经验法则</h2><p id="d85b" class="pw-post-body-paragraph lv lw iq lx b ly lz jr ma mb mc ju md me mf mg mh mi mj mk ml mm mn mo mp mq ij bi translated">尽量完整简洁地描述你的职能目的。如果不使用“和”这个词，你不能在一个简短的句子中完整地描述你的函数做什么，那么你的函数可能应该被拆分。</p><p id="9b7a" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">示例:"<code class="fe oa ob oc od b">prepare_files</code>遍历给定目录中的文件来定位归档文件<strong class="lx ir">和</strong>提取它们的所有文件。"</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="dc02" class="ld le iq bd lf lg lh li lj lk ll lm ln jw lo jx lp jz lq ka lr kc ls kd lt lu bi translated">使用单一责任原则来保持不断增长的代码有组织</h1><p id="cb46" class="pw-post-body-paragraph lv lw iq lx b ly lz jr ma mb mc ju md me mf mg mh mi mj mk ml mm mn mo mp mq ij bi translated">这么说吧，我除了解压存档，还需要准备excel文件。Excel文件可以在其中任何一个。xls或者。xlsx格式，我需要把它们转换成。csv格式。</p><p id="024b" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">以下是主要职责的概述:</p><ol class=""><li id="fb57" class="nl nm iq lx b ly mr mb ms me nn mi no mm np mq nq nr ns nt bi translated">遍历目录中的文件。</li><li id="6e95" class="nl nm iq lx b ly nu mb nv me nw mi nx mm ny mq nq nr ns nt bi translated">对于每个文件，确定它是归档文件还是excel文件。</li><li id="43df" class="nl nm iq lx b ly nu mb nv me nw mi nx mm ny mq nq nr ns nt bi translated">如果是归档文件，提取文件。</li><li id="28c7" class="nl nm iq lx b ly nu mb nv me nw mi nx mm ny mq nq nr ns nt bi translated">如果是excel文件，则转换为. csv。</li></ol><p id="7291" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">这里有一种方法来构建您的功能，使每个功能处理上述职责之一:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="39d4" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">现在每个功能都有一个单独的职责。因为职责之一是从已知的档案中提取数据，所以直接打电话给<code class="fe oa ob oc od b">shutil.unpack_archive</code>是合适的。没有必要将它包装在您自己的函数中，除非您必须用它做额外的事情。</p><p id="ee33" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">请注意，我不再构建文件路径列表。我可以制作一个归档文件路径列表和一个excel文件路径列表，类似于第一个例子中的<code class="fe oa ob oc od b">get_archive_filepaths</code>，但是由于附加的文件格式，遍历文件一次并在函数遇到相关文件时立即准备它们会更简单。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi of"><img src="../Images/4b169c526d55813f7346d655c0722c3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*tF7aThNa-1_c5M7S"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@quinoal?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Quino Al </a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="85ff" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">这样的结构变化是好的。不要被束缚在一个不再有意义的结构上。你控制着代码，所以当你找到更好的方法时，改变它的结构。</p><h2 id="f957" class="mw le iq bd lf mx my dn lj mz na dp ln me nb nc lp mi nd ne lr mm nf ng lt nh bi translated">提醒一句</h2><p id="79bb" class="pw-post-body-paragraph lv lw iq lx b ly lz jr ma mb mc ju md me mf mg mh mi mj mk ml mm mn mo mp mq ij bi translated">记住过早的优化是万恶之源。抵制根据你可能永远不会遇到的边缘情况拆分功能的冲动。你可能会浪费时间去制造一些你根本不需要的东西。</p><p id="8789" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">等到你被迫考虑那些边缘情况时，再考虑重构。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><p id="2c70" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">编码快乐！</p></div></div>    
</body>
</html>