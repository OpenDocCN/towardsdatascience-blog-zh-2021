<html>
<head>
<title>JAX First Impressions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JAX第一印象</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/jax-first-impressions-d85f3c498c21?source=collection_archive---------36-----------------------#2021-05-12">https://towardsdatascience.com/jax-first-impressions-d85f3c498c21?source=collection_archive---------36-----------------------#2021-05-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="ef13" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph">数值计算</h2><div class=""/><div class=""><h2 id="4078" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">Python中速度惊人的独立于硬件的数字代码</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/a0f71b6d4f7d1110b16fc994d42bcbbd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HCRKAOLuM9qcV_2PBgqaJA.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">JAX因服用类固醇而变得愚蠢</p></figure><p id="d196" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">最近我一直在探索JAX 图书馆。它是由Google工程师开发的用于数值计算的高性能库。目前，它是一个研究图书馆(还没有1.0版)，不是谷歌的官方产品。然而，它正在机器学习工程师中获得牵引力。我特别感兴趣的是用Python编写数值密集型算法，这些算法在CPU和GPU上都非常快。</p><p id="9e96" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">JAX有一个与NUMPY非常相似的API，尽管它不是NUMPY的直接替代品。JAX包括一个JIT(实时)编译器，它使用<a class="ae ma" href="https://www.tensorflow.org/xla/" rel="noopener ugc nofollow" target="_blank"> XLA </a>来转换基于JAX的函数。XLA(加速线性代数)是一个特定领域的线性代数编译器。这使得代码运行速度比普通Python实现快100倍。</p><p id="5659" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">JAX推广<a class="ae ma" href="https://en.wikipedia.org/wiki/Functional_programming" rel="noopener ugc nofollow" target="_blank">函数编程</a>。JIT只能编译纯函数。一个纯函数的输出仅仅基于它的输入，并且没有副作用。因此，在JAX编程需要一些小心。特别是，JAX中的数组类型，称为<code class="fe mb mc md me b">DeviceArray</code>，是一种不可变的数组类型。一旦创建了阵列，就不能修改。这使得编译器可以轻松地对代码进行推理，而不用担心任何副作用，并积极地对其进行优化。不可能修改数组中的单个条目。不过，JAX以<code class="fe mb mc md me b"><a class="ae ma" href="https://jax.readthedocs.io/en/latest/_autosummary/jax.ops.index_add.html" rel="noopener ugc nofollow" target="_blank">index_add</a></code>、<code class="fe mb mc md me b"><a class="ae ma" href="https://jax.readthedocs.io/en/latest/_autosummary/jax.ops.index_update.html" rel="noopener ugc nofollow" target="_blank">index_update</a></code>和类似操作符的形式提供了功能替代方案来实现同样的功能。</p><h2 id="e034" class="mf mg iq bd mh mi mj dn mk ml mm dp mn ln mo mp mq lr mr ms mt lv mu mv mw iw bi translated">JAX的一个行QR分解</h2><p id="852c" class="pw-post-body-paragraph le lf iq lg b lh mx ka lj lk my kd lm ln mz lp lq lr na lt lu lv nb lx ly lz ij bi translated">我不会在这里详细介绍JAX。你可以阅读同样的优秀文档。下面我展示一个我在JAX实现的<a class="ae ma" href="https://en.wikipedia.org/wiki/QR_decomposition" rel="noopener ugc nofollow" target="_blank"> QR分解</a>的实现。通常情况下，我们因式分解[A = QR]。因为Python是以行为主的，所以我按行进行因式分解[A = RQ],其中Q的行是正交的。使用改进的Gram-Schmidt过程实现因子分解。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="6406" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">注意在函数<code class="fe mb mc md me b">factor_mgs</code>中应用的装饰器<code class="fe mb mc md me b">jit</code>。它确保当函数被调用时，它被及时编译。还要注意Q中的一行是如何使用<code class="fe mb mc md me b">index_update</code>函数更新的。使用<code class="fe mb mc md me b">index_add</code>函数更新A中的行。</p><h2 id="1d14" class="mf mg iq bd mh mi mj dn mk ml mm dp mn ln mo mp mq lr mr ms mt lv mu mv mw iw bi translated">一点基准测试</h2><p id="429a" class="pw-post-body-paragraph le lf iq lg b lh mx ka lj lk my kd lm ln mz lp lq lr na lt lu lv nb lx ly lz ij bi translated">我在一台MacBook上测试了这个功能。对一个64x128矩阵(具有正态分布的随机条目)的因式分解的第一次调用花费了大约12秒。后来下降到300微秒左右。当心JAX的<a class="ae ma" href="https://jax.readthedocs.io/en/latest/async_dispatch.html" rel="noopener ugc nofollow" target="_blank">异步调度</a>。在结果数组上调用<code class="fe mb mc md me b">block_until_ready()</code>,确保所有的计算都正确地完成了基准测试。第一次调用时，128x256随机正态矩阵的因式分解需要大约35秒。随后的尝试减少到大约1毫秒。</p><h2 id="4e38" class="mf mg iq bd mh mi mj dn mk ml mm dp mn ln mo mp mq lr mr ms mt lv mu mv mw iw bi translated">一个逐行QR更新例程</h2><p id="673b" class="pw-post-body-paragraph le lf iq lg b lh mx ka lj lk my kd lm ln mz lp lq lr na lt lu lv nb lx ly lz ij bi translated">像正交匹配追踪这样的算法可以通过使用QR更新过程来优化，其中子矩阵A是从字典的原子逐步[逐行]构建的。因此，A的因式分解也可以逐行建立。下面的函数用逐行分解的矩阵A的第k行A更新Q和R。它使用了Gram-Schmidt算法的一个步骤。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="2223" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">让我们展示一些如何使用这个更新过程的代码。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="4815" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">在每次迭代中，我们发送A的第I行来更新因式分解。Q和R数组被更新并从update函数返回。由于update的输入参数是不可变的，因此，更新后的数组必须返回给调用者，以确保更新得到反映。XLA编译器将确保尽可能多地重用设备数组。</p><p id="c5ff" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">注意，我们没有在更新函数定义上直接使用jit装饰器。函数的第四个参数k是一个整数，它的值在不同的调用中是不同的。从JIT的角度来看，它被称为静态参数。不能直接JIT编译。然而，在这条线上</p><pre class="kp kq kr ks gt ne me nf ng aw nh bi"><span id="88d7" class="mf mg iq me b gy ni nj l nk nl">update = jit(update, static_argnums=(3,))</span></pre><p id="e55e" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">我们能够指定哪些参数适合JIT编译，哪些必须被视为静态的。这使我们能够在这样的函数上应用JIT。更多信息，请阅读<a class="ae ma" href="https://jax.readthedocs.io/en/latest/notebooks/Common_Gotchas_in_JAX.html" rel="noopener ugc nofollow" target="_blank">JAX——锋利的钻头</a>。</p><h2 id="b66b" class="mf mg iq bd mh mi mj dn mk ml mm dp mn ln mo mp mq lr mr ms mt lv mu mv mw iw bi translated">笔记</h2><ul class=""><li id="ddfb" class="nm nn iq lg b lh mx lk my ln no lr np lv nq lz nr ns nt nu bi translated">默认情况下，JAX创建float32数组并执行32位浮点运算。如果您想使用float64阵列，请启用该功能。</li><li id="bd06" class="nm nn iq lg b lh nv lk nw ln nx lr ny lv nz lz nr ns nt nu bi translated">如果您的函数不满足JIT的约束，使用它将抛出非常详细的错误。需要一些练习来学习如何编写简洁的数值算法的函数版本。</li><li id="06f9" class="nm nn iq lg b lh nv lk nw ln nx lr ny lv nz lz nr ns nt nu bi translated">异步调度可能会导致错误的基准。小心确保所有的计算都已完成。</li></ul></div></div>    
</body>
</html>