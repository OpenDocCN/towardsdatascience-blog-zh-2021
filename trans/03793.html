<html>
<head>
<title>Implementing Single Shot Detector (SSD) in Keras: Part V — Predictions Decoding</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Keras中实现单触发检测器(SSD ):第五部分——预测解码</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/implementing-single-shot-detector-ssd-in-keras-part-v-predictions-decoding-2305a6e4c7a1?source=collection_archive---------26-----------------------#2021-03-29">https://towardsdatascience.com/implementing-single-shot-detector-ssd-in-keras-part-v-predictions-decoding-2305a6e4c7a1?source=collection_archive---------26-----------------------#2021-03-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="021b" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/object-detection-in-keras" rel="noopener" target="_blank">Keras中的物体检测</a></h2><div class=""/><div class=""><h2 id="8702" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">构建Keras层以解码由SSD网络产生的预测</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi kr"><img src="../Images/3f6fe94b9eceb478160c171c9cc5894b.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/1*W-WGNy1KXE-AYEiv9WgIkA.gif"/></div><p class="kz la gj gh gi lb lc bd b be z dk translated">预测解码过程。由作者编辑。来源:<a class="ae ld" href="https://unsplash.com/@marciasoligo" rel="noopener ugc nofollow" target="_blank">玛西娅·索利戈</a></p></figure><h1 id="4019" class="le lf it bd lg lh li lj lk ll lm ln lo ki lp kj lq kl lr km ls ko lt kp lu lv bi translated">一.导言</h1><p id="792e" class="pw-post-body-paragraph lw lx it ly b lz ma kd mb mc md kg me mf mg mh mi mj mk ml mm mn mo mp mq mr im bi translated">根据前面的四篇文章，我们能够训练SSD网络，并生成能够根据输入图像进行预测的模型权重文件。对于具有VGG16主干的SSD300，网络产生(8732 * num_classes+1)个预测。显然，这是一个巨大的数量，其中大部分需要过滤掉。因此，本文将概述解码和过滤这些初步预测的步骤。此外，本文还提供了创建Keras层的代码片段，以达到同样的目的。</p><blockquote class="ms mt mu"><p id="088a" class="lw lx mv ly b lz mw kd mb mc mx kg me my mz mh mi na nb ml mm nc nd mp mq mr im bi translated"><em class="it">这篇文章是一个更大的系列的一部分，叫做在Keras中实现单次检测器(SSD)。下面是系列</em>的概要</p><p id="f4a4" class="lw lx mv ly b lz mw kd mb mc mx kg me my mz mh mi na nb ml mm nc nd mp mq mr im bi translated"><a class="ae ld" rel="noopener" target="_blank" href="/implementing-ssd-in-keras-part-i-network-structure-da3323f11cff?sk=2d12a3f967fd6f1c32518b30c56d0ca5"> <em class="it">第一部分:网络结构</em></a><em class="it"><br/></em><a class="ae ld" rel="noopener" target="_blank" href="/implementing-single-shot-detector-ssd-in-keras-part-ii-loss-functions-4f43c292ad2a?sk=5e1265989a1e250844b0674dc670f234"><em class="it">第二部分:损失函数</em></a><em class="it"><br/></em><a class="ae ld" rel="noopener" target="_blank" href="/implementing-single-shot-detector-ssd-in-keras-part-iii-data-preparation-624ba37f5924?sk=39164c76031c0f60785dd3aa559cc2a6"><em class="it">第三部分:数据准备</em></a><em class="it"><br/></em><a class="ae ld" rel="noopener" target="_blank" href="/implementing-single-shot-detector-ssd-in-keras-part-iv-data-augmentation-59c9f230a910?sk=cf25ff5e9e78ea56415f1f4c8be1fa32"><em class="it">第四部分:数据扩充</em> </a> <em class="it"> <br/>第五部分:预测解码(本文)<br/> </em> <a class="ae ld" rel="noopener" target="_blank" href="/implementing-single-shot-detector-ssd-in-keras-part-vi-model-evaluation-c519852588d1?sk=797df0a4bf29d36ddd1e7ee9fe5c81a3"> <em class="it">部分</em></a></p></blockquote><h1 id="7008" class="le lf it bd lg lh li lj lk ll lm ln lo ki lp kj lq kl lr km ls ko lt kp lu lv bi translated">二。该算法</h1><p id="7531" class="pw-post-body-paragraph lw lx it ly b lz ma kd mb mc md kg me mf mg mh mi mj mk ml mm mn mo mp mq mr im bi translated">为了对SSD网络输出的预测进行解码，SSD的作者设计了一种算法，该算法包括4个步骤:包围盒解码、置信阈值、非最大值抑制和Top-K滤波。下面详细讨论这些步骤。</p><blockquote class="ms mt mu"><p id="7100" class="lw lx mv ly b lz mw kd mb mc mx kg me my mz mh mi na nb ml mm nc nd mp mq mr im bi translated">下面的代码片段是基于NumPy的。下一节将把这些代码片段转换成Keras，并把它们放到Keras的层中。</p><p id="17d8" class="lw lx mv ly b lz mw kd mb mc mx kg me my mz mh mi na nb ml mm nc nd mp mq mr im bi translated">本文中显示的所有代码都可以在这个回购:<a class="ae ld" href="https://github.com/Socret360/object-detection-in-keras" rel="noopener ugc nofollow" target="_blank">https://github.com/Socret360/object-detection-in-keras</a>。GitHub repo中的许多代码都是从https://github.com/pierluigiferrari/ssd_keras的<a class="ae ld" href="https://github.com/pierluigiferrari/ssd_keras" rel="noopener ugc nofollow" target="_blank">中获取并修改而来的。</a></p></blockquote><h2 id="5d1f" class="ne lf it bd lg nf ng dn lk nh ni dp lo mf nj nk lq mj nl nm ls mn nn no lu iz bi translated">步骤1:边界框解码</h2><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="nq nr di ns bf nt"><div class="gh gi np"><img src="../Images/9e10328bfb579fc776cbc2c75bb814b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oDVOmcSwkzpAnRXW0kowew.png"/></div></div><p class="kz la gj gh gi lb lc bd b be z dk translated">图1:解码ssd(带有标准偏差编码的质心)边界框的公式。由作者创建。</p></figure><p id="e6da" class="pw-post-body-paragraph lw lx it ly b lz mw kd mb mc mx kg me mf mz mh mi mj nb ml mm mn nd mp mq mr im bi translated">从该系列的<a class="ae ld" rel="noopener" target="_blank" href="/implementing-single-shot-detector-ssd-in-keras-part-iii-data-preparation-624ba37f5924?sk=39164c76031c0f60785dd3aa559cc2a6">第三部分</a>中，我们了解到SSD的预测是用标准差进行质心编码的。因此，第一步是解码那些编码的预测，使它们回到<em class="mv"> cx，cy，width，height </em>的格式。这可以通过图1所示的公式来完成。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nu nv l"/></div></figure><h2 id="4c42" class="ne lf it bd lg nf ng dn lk nh ni dp lo mf nj nk lq mj nl nm ls mn nn no lu iz bi translated">步骤2:置信度阈值(针对每个类别)</h2><p id="1f01" class="pw-post-body-paragraph lw lx it ly b lz ma kd mb mc md kg me mf mg mh mi mj mk ml mm mn mo mp mq mr im bi translated">在解码包围盒预测之后，我们需要移除置信度得分低于特定阈值的包围盒。这个过滤过程是针对每个类进行的。由于SSD网络通过Softmax函数(<a class="ae ld" rel="noopener" target="_blank" href="/implementing-single-shot-detector-ssd-in-keras-part-ii-loss-functions-4f43c292ad2a?sk=5e1265989a1e250844b0674dc670f234">第二部分</a>)产生类别预测，我们可以通过特定类别在Softmax输出中的位置来获得其置信度得分。这个置信度分数告诉我们，模型有多确定该特定的对象存在于边界框内。下面的代码片段假设您已经创建了一个形状为(total_default_boxes，1 + 4)的y_pred numpy数组，其中1是我们感兴趣的类的<em class="mv">置信度得分</em>的，4是<em class="mv"> xmin、ymin、xmax、ymax </em>值。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nu nv l"/></div></figure><h2 id="5f77" class="ne lf it bd lg nf ng dn lk nh ni dp lo mf nj nk lq mj nl nm ls mn nn no lu iz bi translated">步骤3:非最大抑制(针对每个类别)</h2><p id="413c" class="pw-post-body-paragraph lw lx it ly b lz ma kd mb mc md kg me mf mg mh mi mj mk ml mm mn mo mp mq mr im bi translated">一旦我们过滤掉了类别置信度较低的包围盒，我们就需要将重叠的包围盒合并在一起。这个过程被称为非最大值抑制(NMS)。通过将重叠的预测合并成一个预测，有助于进一步减少预测的数量。类似于本系列第三部分中的将默认框与基础真值框匹配的过程，为了测量两个边界框预测之间的重叠程度，我们计算它们之间的IOU。以下代码片段执行了NMS版本:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nu nv l"/></div></figure><h2 id="068f" class="ne lf it bd lg nf ng dn lk nh ni dp lo mf nj nk lq mj nl nm ls mn nn no lu iz bi translated">步骤4: Top-K选择</h2><p id="f856" class="pw-post-body-paragraph lw lx it ly b lz ma kd mb mc md kg me mf mg mh mi mj mk ml mm mn mo mp mq mr im bi translated">即使在对每个类别执行置信度阈值和NMS之后，剩余预测的数量仍然可能是巨大的。然而，这些预测中的大多数是不需要的，因为可以出现在图像中的(我们感兴趣的)物体的数量是有限的。因此，我们可以根据它们的置信分值对这些预测进行排序，并选择最高置信分值的<em class="mv"> k </em>。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nu nv l"/></div></figure><h2 id="f9fc" class="ne lf it bd lg nf ng dn lk nh ni dp lo mf nj nk lq mj nl nm ls mn nn no lu iz bi translated">第五步:产生最终结果</h2><p id="3b42" class="pw-post-body-paragraph lw lx it ly b lz ma kd mb mc md kg me mf mg mh mi mj mk ml mm mn mo mp mq mr im bi translated">顶部K选择产生<em class="mv"> k </em>预测。这些<em class="mv"> k </em>预测每一个都有一定的置信度得分。为了产生最终结果，我们进一步缩小了预测的范围，只选择那些置信度高于某个阈值的预测。通常，该阈值是通过在模型评估期间选择产生最高贴图的阈值来选择的。我们将在下一篇文章中讨论如何评估这个模型。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nu nv l"/></div></figure><h1 id="1afd" class="le lf it bd lg lh li lj lk ll lm ln lo ki lp kj lq kl lr km ls ko lt kp lu lv bi translated">三。Keras的SSD预测解码层</h1><p id="081b" class="pw-post-body-paragraph lw lx it ly b lz ma kd mb mc md kg me mf mg mh mi mj mk ml mm mn mo mp mq mr im bi translated">在理解了解码SSD预测的每一个步骤之后，我们可以将它们放在一个Keras的层中。为解码过程创建Keras层的好处是，我们可以创建一个内置解码过程的模型文件。当我们想要在不同的平台上部署模型时，这是很有用的。下面是对SSD输出的预测进行解码的Keras层。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nu nv l"/></div></figure><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nu nv l"/></div></figure><h1 id="7e6f" class="le lf it bd lg lh li lj lk ll lm ln lo ki lp kj lq kl lr km ls ko lt kp lu lv bi translated">四。结论</h1><p id="dfc4" class="pw-post-body-paragraph lw lx it ly b lz ma kd mb mc md kg me mf mg mh mi mj mk ml mm mn mo mp mq mr im bi translated">本文概述了对SSD网络产生的预测进行解码的步骤，并提供了代码片段，说明如何实现Keras层来实现这一目的。在下一篇文章中，我们将学习如何评估模型的性能。</p></div><div class="ab cl nw nx hx ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="im in io ip iq"><p id="c134" class="pw-post-body-paragraph lw lx it ly b lz mw kd mb mc mx kg me mf mz mh mi mj nb ml mm mn nd mp mq mr im bi translated"><em class="mv">喜欢这篇文章并想表达您的支持？关注我或者给我买咖啡</em></p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><a href="https://www.buymeacoffee.com/socretlee"><div class="gh gi od"><img src="../Images/69716627feab2505c60838bbd29241a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gS6Sh6i8g535gOafY4Wl1w.png"/></div></a></figure><h1 id="6f0a" class="le lf it bd lg lh li lj lk ll lm ln lo ki lp kj lq kl lr km ls ko lt kp lu lv bi translated">参考</h1><p id="fcd1" class="pw-post-body-paragraph lw lx it ly b lz ma kd mb mc md kg me mf mg mh mi mj mk ml mm mn mo mp mq mr im bi translated">毛，L. (2019)。<em class="mv">物体检测中的包围盒编码和解码</em>。检索自<a class="ae ld" href="https://leimao.github.io/blog/Bounding-Box-Encoding-Decoding/" rel="noopener ugc nofollow" target="_blank">https://lei Mao . github . io/blog/Bounding-Box-Encoding-Decoding/</a></p><p id="987e" class="pw-post-body-paragraph lw lx it ly b lz mw kd mb mc mx kg me mf mz mh mi mj nb ml mm mn nd mp mq mr im bi translated">Sambasivarao。K. (2019年10月1日)。<em class="mv">非最大抑制(NMS) </em>。走向数据科学。检索自<a class="ae ld" rel="noopener" target="_blank" href="/non-maximum-suppression-nms-93ce178e177c">https://towardsdatascience . com/non-maximum-suppression-NMS-93ce 178 e 177 c</a></p></div></div>    
</body>
</html>