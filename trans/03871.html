<html>
<head>
<title>Build an Unbeatable Board Game AI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">建立一个无与伦比的棋盘游戏人工智能</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/build-an-unbeatable-board-game-ai-68719308a17?source=collection_archive---------18-----------------------#2021-03-31">https://towardsdatascience.com/build-an-unbeatable-board-game-ai-68719308a17?source=collection_archive---------18-----------------------#2021-03-31</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="70a3" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">一个详细的指南，以编码一个复杂的算法，掌握回合制战略游戏</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/88d23f02dde1fc9ce255129b04d5c30f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wXmxxonJ2CWN_8IX"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">阿瑟·奥西皮扬在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><h1 id="5371" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">介绍</h1><p id="f019" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">如果你想尝试人工智能，甚至是一点博弈论，那么建造一台赢棋的机器是一个很好的项目。</p><p id="17bf" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我实现了这个AI来玩Connect Four，但它适用于许多不同的游戏。不过，我还是推荐像Connect Four这样的游戏，因为游戏机制很简单。</p><p id="799d" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">以国际象棋为例:Minimax可以下棋，但你有几个不同的棋子，可以走不同的棋，有捕捉，阉割，检查和将死等。而使用Connect Four，您所能做的就是将一片放入一列中。这意味着每一步棋都非常简单，可以用一个整数来表示(棋子所在列的索引)，棋盘只是一个2D数组。</p><p id="1fb0" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">像井字游戏这样的游戏也是一个不错的选择，但是即使在那里，你也必须考虑列和行。</p><p id="f29c" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">现在让我们来谈谈这个人工智能将如何实际工作:<strong class="lt iu">极大极小算法。</strong></p><h1 id="8b87" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">Minimax如何工作</h1><p id="f836" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在博弈论中，极大极小是一种递归算法，它最大化自己的机会，同时最小化对手的机会。因此，这个名字不言自明。</p><p id="b240" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">假设对手先动。一旦移动完成，Minimax会查看游戏棋盘的状态，然后考虑它可能做出的每一步棋。对于每一个结果游戏状态，它会考虑对手可能采取的每一个可能的行动，等等…</p><p id="72b0" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这将一直进行，直到找到一个终端游戏状态(游戏获胜或棋盘已满)，或者直到达到某个深度。深度是有上限的，否则所有可能的游戏状态的树会快速增长，计算起来会变得非常慢。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ms"><img src="../Images/d5f57010d9ae3b616c735ce23682e34f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MVwmzsWdFiEy1Ttw2z-iwg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">最小最大算法考虑了所有可能的棋盘状态(所有图片由作者提供)</p></figure><p id="57fb" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">现在，在每个级别，这些棋盘状态中的每一个都将根据一组参数(由您定义)分配一个分数，以确定该状态对于最大化玩家或最小化玩家(无论轮到谁)在机会方面有多“好”或“坏”。例如，当前玩家的获胜棋盘将被分配极高的分数，而对手的获胜棋盘将被分配极低的分数。还必须分配中间分数，因为除了最简单的游戏，大多数棋都不是赢棋。</p><p id="6a83" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">然后，算法选择最终导致AI得分最高而对手得分最低的棋盘状态。这就是它将要采取的行动。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ms"><img src="../Images/06228beae651db07b592b80399c1bf28.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5h2_19AIJnmsHYemX-jwHQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">选择最高和最低分数的极大极小算法</p></figure><h1 id="a6f6" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">履行</h1><h2 id="cfe8" class="mt la it bd lb mu mv dn lf mw mx dp lj ma my mz ll me na nb ln mi nc nd lp ne bi translated">设置</h2><p id="e625" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">为了能够编写极大极小算法，你需要一些变量和函数，它们的实现取决于你的棋盘游戏:</p><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="3d2f" class="mt la it ng b gy nk nl l nm nn">npc =&gt; In my case, just a character that represents the AI's piece<br/>opponent =&gt; Another character to represent the opponent's piece</span><span id="88c9" class="mt la it ng b gy no nl l nm nn">isTerminalNode() =&gt; To determine if a board is terminal (boolean)<br/>isWinningMove()  =&gt; To determine if a move wins the game (boolean)<br/>getValidMoves()  =&gt; To get all possible valid moves (array)<br/>score()          =&gt; To calculate a board state's score (integer)<br/>tempBoard()      =&gt; To make a copy of the game board (2D array)<br/>makeMove()       =&gt; Make a hypothetical move on the board (void)</span></pre><p id="b39f" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">因为我的游戏是Connect Four，所以我的<em class="np"> isTerminalNode() </em>方法调用一系列帮助器方法来完成以下任务:</p><ol class=""><li id="dcbf" class="nq nr it lt b lu mn lx mo ma ns me nt mi nu mm nv nw nx ny bi translated">检查一行中是否有四个(对角、垂直或水平)。</li><li id="7eee" class="nq nr it lt b lu nz lx oa ma ob me oc mi od mm nv nw nx ny bi translated">检查棋盘是否已满，不能再移动了。</li></ol><p id="bda7" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">您需要<em class="np"> getValidMoves() </em>，因为一列可能会变满，因此Minimax不应该试图在该列中移动。</p><p id="699f" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">并且<em class="np"> score() </em>方法调用更多的帮助器方法，这些方法最终为当前棋盘分配一个分数。这是我如何分配分数的(这是你可以支付的——调整损失函数):</p><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="fef4" class="mt la it ng b gy nk nl l nm nn">Current player gets 4 in a row                              =&gt; 100<br/>Current player gets 3 in a row with an empty adjacent space =&gt; 5<br/>Current player gets 2 in a row with 2 empty adjacent spaces =&gt; 2<br/>Opponent has 3 in a row with an empty adjacent space        =&gt; -500</span></pre><p id="ffb7" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这将确保你的人工智能把它的棋子一个接一个地摆放，同时阻止对手连续获得4个。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/2a81e6cfa95164c6b013cc8623c0f8c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2sFNMjKD1HdAEEhm"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@sincerelymedia?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">真诚媒体</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><h2 id="fe4f" class="mt la it bd lb mu mv dn lf mw mx dp lj ma my mz ll me na nb ln mi nc nd lp ne bi translated">该算法</h2><p id="9aa2" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我用Java编写了我的代码，但是我打算在这里把它翻译成一种Java/Python风格的伪代码，以保持这篇文章的语言不可知。</p><ul class=""><li id="263d" class="nq nr it lt b lu mn lx mo ma ns me nt mi nu mm of nw nx ny bi translated">在第一部分中，检索所有可以进行的有效移动，并检查棋盘是否处于终止状态。</li><li id="a182" class="nq nr it lt b lu nz lx oa ma ob me oc mi od mm of nw nx ny bi translated">我们每次都会减少深度，所以当深度为0或者棋盘是终点时，检查游戏是NPC(非玩家角色)赢了还是对手赢了。</li><li id="df8e" class="nq nr it lt b lu nz lx oa ma ob me oc mi od mm of nw nx ny bi translated">如果是，分别返回一个很高或很低的分数。如果没有，返回该板的分数。</li></ul><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="380e" class="mt la it ng b gy nk nl l nm nn">minimax(board, depth, maximisingPlayer)<br/>    int[] validCols = <em class="np">getValidMoves</em>(board)<br/>    boolean isTerminalNode = <em class="np">isTerminalNode</em>(board)<br/>    if (depth == 0 || isTerminalNode)<br/>        if (isTerminalNode)<br/>            if (<em class="np">isWinningMove</em>(board, <em class="np">npc</em>))<br/>                return null, 1000000000<br/>            else if (<em class="np">isWinningMove</em>(board, <em class="np">opponent</em>))<br/>                return null, -2000000000<br/>            else<br/>                return null, 0<br/>        else<br/>            return null, <em class="np">score</em>(board, <em class="np">npc)</em></span></pre><p id="6c4e" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">注意这个函数返回两件事:分数和移动。</p><ul class=""><li id="f659" class="nq nr it lt b lu mn lx mo ma ns me nt mi nu mm of nw nx ny bi translated">创建两个变量:<em class="np">移动</em>(有效移动列表中的随机移动)和<em class="np">值</em>(分数)</li><li id="a768" class="nq nr it lt b lu nz lx oa ma ob me oc mi od mm of nw nx ny bi translated">现在检查当前回合是针对我们的AI(我们想要最大化的玩家)还是对手(我们想要最小化的玩家)。这作为一个参数传递到函数中—检查上面代码块中的签名。</li><li id="9877" class="nq nr it lt b lu nz lx oa ma ob me oc mi od mm of nw nx ny bi translated">如果轮到最大化玩家，将<em class="np">值</em>设置为非常低的值，比如负无穷大。</li><li id="8d13" class="nq nr it lt b lu nz lx oa ma ob me oc mi od mm of nw nx ny bi translated">接下来，遍历有效走法的数组，对每个走法进行走法(在棋盘的副本上，以便不改变原始棋盘的状态——我定义了一个函数来浅层复制我的棋盘)，递归调用<em class="np"> minimax()，</em>传入新的游戏棋盘，深度减1并为false(因为现在我们要为最小化玩家走法)。调用末尾的[1]表示我们希望返回第二个东西，即分数。</li><li id="5d55" class="nq nr it lt b lu nz lx oa ma ob me oc mi od mm of nw nx ny bi translated">如果<em class="np"> minimax() </em>返回的分数大于负无穷大，则给value赋值并移动。</li></ul><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="47ad" class="mt la it ng b gy nk nl l nm nn">    int move = validCols[(Math.<em class="np">random</em>() * validCols.length)]<br/>    double value</span><span id="1d78" class="mt la it ng b gy no nl l nm nn">    if (maximisingPlayer)<br/>        value = <em class="np">NEGATIVE_INFINITY</em>;<br/>        for (int validCol : validCols)<br/>            char[][] tempBoard = <em class="np">tempBoard</em>(board)<br/>            <em class="np">makeMove</em>(validCol, tempBoard, <em class="np">npc</em>, <em class="np">ROWS</em>)<br/>            int newScore = <em class="np">minimax</em>(tempBoard, depth - 1, false)[1]<br/>            if (newScore &gt; value)<br/>                value = newScore<br/>                move = validCol</span></pre><p id="c7fb" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">最后，在为最小化玩家调用函数的情况下，进行完全相反的操作。</p><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="3796" class="mt la it ng b gy nk nl l nm nn">    else<br/>        value = <em class="np">POSITIVE_INFINITY</em><br/>        for (int validCol : validCols)<br/>            char[][] tempBoard = <em class="np">tempBoard</em>(board)<br/>            <em class="np">makeMove</em>(validCol, tempBoard, <em class="np">opponent</em>, <em class="np">ROWS</em>)<br/>            int newScore = <em class="np">minimax</em>(tempBoard, depth - 1, true)[1]<br/>            if (newScore &lt; value)<br/>                value = newScore<br/>                move = validCol</span><span id="06d0" class="mt la it ng b gy no nl l nm nn">    return move, value</span></pre><p id="64a5" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">返回的移动是你最终想要的。就这么简单。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/5132032f1dd2423dad6220aa880ff4db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*t4KkgFSo9VDQtYCo"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@markuswinkler?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">马库斯·温克勒</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><h2 id="eee2" class="mt la it bd lb mu mv dn lf mw mx dp lj ma my mz ll me na nb ln mi nc nd lp ne bi translated">最佳化</h2><p id="bde1" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">你的人工智能对可能的棋盘看得越深，它就越复杂。然而，正如我前面提到的，这需要很高的计算成本。</p><p id="1339" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">当然，你可以通过一种叫做alpha-beta剪枝的方法来优化Minimax算法，我将在另一篇文章中讨论这一点，当它出来的时候在这里链接。</p><h1 id="590a" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">结论</h1><p id="7124" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">你会注意到，有了这些简单的规则，人工智能开始表现出优秀玩家推荐的行为。例如，当我的AI第一个移动的时候，它总是把它的棋子放在中间。我从来没有明确地编程让它这么做，这只是让人工智能的可能性最大化的一步。</p><p id="ccd3" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我已经把游戏发给了我的一个朋友，他认为自己是一个相当强大的Connect Four玩家，他是那个称人工智能为“不可战胜”的人。</p><p id="891f" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这应该给你实现你自己的棋盘游戏-粉碎人工智能所需要的东西。如果你真的做了一些很棒的东西，请留下回复。</p><p id="4da7" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">同时，祝您编码愉快！</p></div><div class="ab cl oh oi hx oj" role="separator"><span class="ok bw bk ol om on"/><span class="ok bw bk ol om on"/><span class="ok bw bk ol om"/></div><div class="im in io ip iq"><h1 id="a589" class="kz la it bd lb lc oo le lf lg op li lj jz oq ka ll kc or kd ln kf os kg lp lq bi translated">资源</h1><p id="1b90" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated"><strong class="lt iu">凯斯加利</strong>T10】连接四个极小极大艾T12】https://www.youtube.com/watch?v=MMLtza3CZFM</p><p id="45f3" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><strong class="lt iu">辉煌</strong> <em class="np">极大极小算法</em><a class="ae ky" href="https://brilliant.org/wiki/minimax/" rel="noopener ugc nofollow" target="_blank">https://brilliant.org/wiki/minimax/</a></p><p id="f249" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><strong class="lt iu">FreeCodeCamp</strong><em class="np">Minimax算法</em><a class="ae ky" href="https://www.freecodecamp.org/news/playing-strategy-games-with-minimax-4ecb83b39b4b/" rel="noopener ugc nofollow" target="_blank">https://www . FreeCodeCamp . org/news/playing-strategy-games-with-Minimax-4 ECB 83 b 39 B4 b/</a></p></div></div>    
</body>
</html>