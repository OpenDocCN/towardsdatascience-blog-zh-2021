<html>
<head>
<title>LeetCode Problem 2: Add Two Numbers Solution in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">LeetCode问题2:用Python添加两个数的解决方案</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/leetcode-problem-2-python-1c59efdf3367?source=collection_archive---------3-----------------------#2021-12-13">https://towardsdatascience.com/leetcode-problem-2-python-1c59efdf3367?source=collection_archive---------3-----------------------#2021-12-13</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><h2 id="7428" class="is it iu bd b dl iv iw ix iy iz ja dk jb translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/interview-questions" rel="noopener" target="_blank">面试问题</a></h2><div class=""/><div class=""><h2 id="1f73" class="pw-subtitle-paragraph ka jd iu bd b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr dk translated">理解如何用Python中的链表高效地解决两个数相加问题</h2></div><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj ks"><img src="../Images/19a71a8824e12000d9a93e35fae9cf3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZoYag6741hzjlSnlb-NRcA.jpeg"/></div></div><p class="le lf gk gi gj lg lh bd b be z dk translated">照片由<a class="ae li" href="https://unsplash.com/@daniele_franchi?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">丹尼尔·弗兰奇</a>在<a class="ae li" href="https://unsplash.com/s/photos/problem?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><h2 id="bedc" class="lj lk iu bd ll lm ln dn lo lp lq dp lr ls lt lu lv lw lx ly lz ma mb mc md ja bi translated">介绍</h2><p id="26a7" class="pw-post-body-paragraph me mf iu mg b mh mi ke mj mk ml kh mm ls mn mo mp lw mq mr ms ma mt mu mv mw in bi translated">当谈到技术面试准备时，最有用的平台之一是LeetCode，它给你提供了数千个不同难度的问题。</p><p id="c2cf" class="pw-post-body-paragraph me mf iu mg b mh mx ke mj mk my kh mm ls mz mo mp lw na mr ms ma nb mu mv mw in bi translated">在今天的指南中，我们将介绍平台上第二个问题的解决方案，名为将两个数字相加，涉及链表，难度中等。这个问题可能出现在任何工程和ML职位的技术面试中。</p><p id="4508" class="pw-post-body-paragraph me mf iu mg b mh mx ke mj mk my kh mm ls mz mo mp lw na mr ms ma nb mu mv mw in bi translated">请注意，如果您还没有尝试解决这个问题，我强烈建议您在查看解决方案之前尝试一下，该解决方案将在本文接下来的几个部分中详细介绍。</p></div><div class="ab cl nc nd hy ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="in io ip iq ir"><h2 id="0dfa" class="lj lk iu bd ll lm ln dn lo lp lq dp lr ls lt lu lv lw lx ly lz ma mb mc md ja bi translated">问题是</h2><blockquote class="nj"><p id="8509" class="nk nl iu bd nm nn no np nq nr ns mw dk translated">给你两个非空的<strong class="ak">链表，代表两个非负整数。数字以逆序存储在<strong class="ak">中</strong>，它们的每个节点包含一个数字。将两个数相加，并以链表的形式返回总和。</strong></p><p id="4538" class="nk nl iu bd nm nn no np nq nr ns mw dk translated">您可以假设这两个数字不包含任何前导零，除了数字0本身。</p></blockquote><p id="63f8" class="pw-post-body-paragraph me mf iu mg b mh nt ke mj mk nu kh mm ls nv mo mp lw nw mr ms ma nx mu mv mw in bi translated"><strong class="mg je">例1: </strong></p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div class="gi gj ny"><img src="../Images/58a326b6735f033561c36736adca1b1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:966/format:webp/1*UxM3tCqoeY2fgoUVziAf-w.jpeg"/></div></figure><pre class="kt ku kv kw gu nz oa ob oc aw od bi"><span id="c0b5" class="lj lk iu oa b gz oe of l og oh"><strong class="oa je">Input:</strong> l1 = [2,4,3], l2 = [5,6,4]<br/><strong class="oa je">Output:</strong> [7,0,8]<br/><strong class="oa je">Explanation:</strong> 342 + 465 = 807.</span></pre><p id="5aae" class="pw-post-body-paragraph me mf iu mg b mh mx ke mj mk my kh mm ls mz mo mp lw na mr ms ma nb mu mv mw in bi translated"><strong class="mg je">例2: </strong></p><pre class="kt ku kv kw gu nz oa ob oc aw od bi"><span id="a23a" class="lj lk iu oa b gz oe of l og oh"><strong class="oa je">Input:</strong> l1 = [0], l2 = [0]<br/><strong class="oa je">Output:</strong> [0]</span></pre><p id="db70" class="pw-post-body-paragraph me mf iu mg b mh mx ke mj mk my kh mm ls mz mo mp lw na mr ms ma nb mu mv mw in bi translated"><strong class="mg je">例3: </strong></p><pre class="kt ku kv kw gu nz oa ob oc aw od bi"><span id="ad87" class="lj lk iu oa b gz oe of l og oh"><strong class="oa je">Input:</strong> l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]<br/><strong class="oa je">Output:</strong> [8,9,9,9,0,0,0,1]</span></pre><blockquote class="nj"><p id="1b11" class="nk nl iu bd nm nn oi oj ok ol om mw dk translated">约束<strong class="ak"> : </strong></p><p id="b533" class="nk nl iu bd nm nn no np nq nr ns mw dk translated">每个链表中的节点数在范围<code class="fe on oo op oa b">[1, 100]</code>内。</p><p id="67e3" class="nk nl iu bd nm nn no np nq nr ns mw dk translated"><code class="fe on oo op oa b">0 &lt;= Node.val &lt;= 9</code></p><p id="d473" class="nk nl iu bd nm nn no np nq nr ns mw dk translated">保证该列表表示一个没有前导零的数字。</p></blockquote><p id="e490" class="pw-post-body-paragraph me mf iu mg b mh nt ke mj mk nu kh mm ls nv mo mp lw nw mr ms ma nx mu mv mw in bi translated">来源:<a class="ae li" href="https://leetcode.com/problems/add-two-numbers/" rel="noopener ugc nofollow" target="_blank"> LeetCode </a></p></div><div class="ab cl nc nd hy ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="in io ip iq ir"><h2 id="ba12" class="lj lk iu bd ll lm ln dn lo lp lq dp lr ls lt lu lv lw lx ly lz ma mb mc md ja bi translated">解决方案演练</h2><p id="c9bb" class="pw-post-body-paragraph me mf iu mg b mh mi ke mj mk ml kh mm ls mn mo mp lw mq mr ms ma mt mu mv mw in bi translated">首先，我们需要确保我们将<strong class="mg je">利用问题描述中</strong>提供的所有信息和细节。对于这个特定的例子，这些细节是:</p><ul class=""><li id="4ca8" class="oq or iu mg b mh mx mk my ls os lw ot ma ou mw ov ow ox oy bi translated">两个非空的链表</li><li id="2467" class="oq or iu mg b mh oz mk pa ls pb lw pc ma pd mw ov ow ox oy bi translated">表示<strong class="mg je">非负</strong>整数</li><li id="8f2c" class="oq or iu mg b mh oz mk pa ls pb lw pc ma pd mw ov ow ox oy bi translated">数字以相反的顺序存储在<strong class="mg je">中</strong></li></ul><p id="2125" class="pw-post-body-paragraph me mf iu mg b mh mx ke mj mk my kh mm ls mz mo mp lw na mr ms ma nb mu mv mw in bi translated">前两点实质上缩小了问题的范围，因为处理空链表或表示负和/或正整数的链表可能会更棘手一些。</p><p id="1a63" class="pw-post-body-paragraph me mf iu mg b mh mx ke mj mk my kh mm ls mz mo mp lw na mr ms ma nb mu mv mw in bi translated">现在，最后一点信息也很重要，我们实际上可以利用它。由于链表所表示的数字是逆序的，这实际上可以帮助我们在将两个数字相加时进行进位运算。</p><p id="04a6" class="pw-post-body-paragraph me mf iu mg b mh mx ke mj mk my kh mm ls mz mo mp lw na mr ms ma nb mu mv mw in bi translated">现在让我们开始研究我们的算法，它最终会给出问题的正确解决方案。</p><p id="b998" class="pw-post-body-paragraph me mf iu mg b mh mx ke mj mk my kh mm ls mz mo mp lw na mr ms ma nb mu mv mw in bi translated">首先，我们需要初始化3个变量。第一个将保存在每一步将被转发的进位，第二个将是一个表示最终结果的链表(最初设置为值0)，第三个将是我们的指针，它将被用来在每次迭代中移动到下一个节点。</p><pre class="kt ku kv kw gu nz oa ob oc aw od bi"><span id="bea4" class="lj lk iu oa b gz oe of l og oh"><strong class="oa je">carry = 0<br/>result = ListNode(0)<br/>pointer = result</strong></span></pre><p id="e2e8" class="pw-post-body-paragraph me mf iu mg b mh mx ke mj mk my kh mm ls mz mo mp lw na mr ms ma nb mu mv mw in bi translated">此时，您可能需要回忆一下Python中共享引用的工作方式，因为<code class="fe on oo op oa b">pointer</code>中的任何更新都会对<code class="fe on oo op oa b">result</code>产生直接影响，而且这两个变量共享同一个对象引用。</p><p id="9d44" class="pw-post-body-paragraph me mf iu mg b mh mx ke mj mk my kh mm ls mz mo mp lw na mr ms ma nb mu mv mw in bi translated">现在我们已经初始化了这些变量，我们可以开始遍历链表了。本质上，我们需要不断迭代，直到两个列表中不再有节点，并且不再有额外的单元。因此，一个具有如下所示条件的<code class="fe on oo op oa b">while</code>循环应该可以完成这个任务:</p><pre class="kt ku kv kw gu nz oa ob oc aw od bi"><span id="1447" class="lj lk iu oa b gz oe of l og oh">carry = 0<br/>result = ListNode(0)<br/>pointer = result</span><span id="c2b0" class="lj lk iu oa b gz pe of l og oh"><strong class="oa je">while (l1 or l2 or carry):</strong></span></pre><p id="0c95" class="pw-post-body-paragraph me mf iu mg b mh mx ke mj mk my kh mm ls mz mo mp lw na mr ms ma nb mu mv mw in bi translated">然后我们需要从单个节点中检索数字。由于链表可以有不同的大小(或者甚至到达两个链表的末尾，但是仍然有一个单元)，我们还需要处理节点的值为None的情况。</p><pre class="kt ku kv kw gu nz oa ob oc aw od bi"><span id="60ec" class="lj lk iu oa b gz oe of l og oh">carry = 0<br/>result = ListNode(0)<br/>pointer = result</span><span id="1263" class="lj lk iu oa b gz pe of l og oh">while (l1 or l2 or carry):</span><span id="e6b5" class="lj lk iu oa b gz pe of l og oh"><strong class="oa je">    first_num = l1.val if l1.val else 0<br/>    second_num = l2.val if l2.val else 0</strong></span></pre><p id="8e60" class="pw-post-body-paragraph me mf iu mg b mh mx ke mj mk my kh mm ls mz mo mp lw na mr ms ma nb mu mv mw in bi translated">然后我们需要执行加法，看看这是否会有任何影响。为此，我们首先将这两个数字以及<code class="fe on oo op oa b">carry</code>相加。然后，我们通过取总和与数字<code class="fe on oo op oa b">10</code>之间的模来计算解的下一位数字，然后通过执行总和与数字<code class="fe on oo op oa b">10</code>之间的地板除法来计算<code class="fe on oo op oa b">carry</code>。</p><p id="68c0" class="pw-post-body-paragraph me mf iu mg b mh mx ke mj mk my kh mm ls mz mo mp lw na mr ms ma nb mu mv mw in bi translated">例如，如果两位数之和为<code class="fe on oo op oa b">12</code>，则<code class="fe on oo op oa b">num</code>变量将被设置为<code class="fe on oo op oa b">2</code>(因为<code class="fe on oo op oa b">12 % 10 = 2</code>)，进位将为<code class="fe on oo op oa b">1</code>(因为<code class="fe on oo op oa b">12 // 10 = 1</code>)。</p><pre class="kt ku kv kw gu nz oa ob oc aw od bi"><span id="eae4" class="lj lk iu oa b gz oe of l og oh">carry = 0<br/>result = ListNode(0)<br/>pointer = result</span><span id="43cd" class="lj lk iu oa b gz pe of l og oh">while (l1 or l2 or carry):</span><span id="647d" class="lj lk iu oa b gz pe of l og oh">    first_num = l1.val if l1.val else 0<br/>    second_num = l2.val if l2.val else 0</span><span id="ac0c" class="lj lk iu oa b gz pe of l og oh"><br/><strong class="oa je">    summation = first_num + second_num + carry<br/>    num = summation % 10<br/>    carry = summation // 10</strong></span></pre><p id="07af" class="pw-post-body-paragraph me mf iu mg b mh mx ke mj mk my kh mm ls mz mo mp lw na mr ms ma nb mu mv mw in bi translated">最后，我们将结果存储到指针(这也将更新<code class="fe on oo op oa b">result</code>，因为这两个变量共享对同一对象的引用)并将指针移动到下一个节点(如果有):</p><pre class="kt ku kv kw gu nz oa ob oc aw od bi"><span id="4515" class="lj lk iu oa b gz oe of l og oh">carry = 0<br/>result = ListNode(0)<br/>pointer = result</span><span id="9c2d" class="lj lk iu oa b gz pe of l og oh">while (l1 or l2 or carry):</span><span id="4e97" class="lj lk iu oa b gz pe of l og oh">    first_num = l1.val if l1.val else 0<br/>    second_num = l2.val if l2.val else 0</span><span id="c254" class="lj lk iu oa b gz pe of l og oh">    summation = first_num + second_num + carry<br/>    num = summation % 10<br/>    carry = summation // 10</span><span id="71a4" class="lj lk iu oa b gz pe of l og oh"><strong class="oa je">    pointer.next = ListNode(num)<br/>            <br/>    pointer = pointer.next<br/>    l1 = l1.next if l1 else None<br/>    l2 = l2.next if l2 else None</strong></span></pre><p id="8c3d" class="pw-post-body-paragraph me mf iu mg b mh mx ke mj mk my kh mm ls mz mo mp lw na mr ms ma nb mu mv mw in bi translated">最后，我们返回<code class="fe on oo op oa b">result.next</code>，因为结果的初始节点实际上是一个<code class="fe on oo op oa b">0</code>。</p><pre class="kt ku kv kw gu nz oa ob oc aw od bi"><span id="d988" class="lj lk iu oa b gz oe of l og oh">carry = 0<br/>result = ListNode(0)<br/>pointer = result</span><span id="376d" class="lj lk iu oa b gz pe of l og oh">while (l1 or l2 or carry):</span><span id="56b4" class="lj lk iu oa b gz pe of l og oh">    first_num = l1.val if l1.val else 0<br/>    second_num = l2.val if l2.val else 0</span><span id="3918" class="lj lk iu oa b gz pe of l og oh">    summation = first_num + second_num + carry<br/>    num = summation % 10<br/>    carry = summation // 10</span><span id="3fa9" class="lj lk iu oa b gz pe of l og oh">    pointer.next = ListNode(num)<br/>            <br/>    pointer = pointer.next<br/>    l1 = l1.next if l1 else None<br/>    l2 = l2.next if l2 else None</span><span id="e79e" class="lj lk iu oa b gz pe of l og oh"><strong class="oa je">return result.next</strong></span></pre></div><div class="ab cl nc nd hy ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="in io ip iq ir"><h2 id="557b" class="lj lk iu bd ll lm ln dn lo lp lq dp lr ls lt lu lv lw lx ly lz ma mb mc md ja bi translated">解决方案的完整代码</h2><pre class="kt ku kv kw gu nz oa ob oc aw od bi"><span id="def5" class="lj lk iu oa b gz oe of l og oh">class Solution:<br/>    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -&gt; Optional[ListNode]:<br/>        carry = 0<br/>        result = ListNode(0)<br/>        pointer = result<br/>        <br/>        <br/>        while (l1 or l2 or carry):<br/>            <br/>            first_num = l1.val if l1.val else 0<br/>            second_num = l2.val if l2.val else 0<br/>            <br/>            summation = first_num + second_num + carry<br/>            <br/>            num = summation % 10<br/>            carry = summation // 10<br/>            <br/>            pointer.next = ListNode(num)<br/>            <br/>            pointer = pointer.next<br/>            l1 = l1.next if l1 else None<br/>            l2 = l2.next if l2 else None<br/>            <br/>        return result.next</span></pre></div><div class="ab cl nc nd hy ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="in io ip iq ir"><h2 id="f3f8" class="lj lk iu bd ll lm ln dn lo lp lq dp lr ls lt lu lv lw lx ly lz ma mb mc md ja bi translated">时间复杂度</h2><p id="dc42" class="pw-post-body-paragraph me mf iu mg b mh mi ke mj mk ml kh mm ls mn mo mp lw mq mr ms ma mt mu mv mw in bi translated">算法开发中最重要的一个方面是时间复杂度，在评估解决方案作为技术访谈的一部分时也要考虑到这一点。</p><p id="1fef" class="pw-post-body-paragraph me mf iu mg b mh mx ke mj mk my kh mm ls mz mo mp lw na mr ms ma nb mu mv mw in bi translated">假设<code class="fe on oo op oa b">l1</code>链表的长度是<code class="fe on oo op oa b">m</code>而<code class="fe on oo op oa b">l2</code>链表的长度是<code class="fe on oo op oa b">n</code>，那么我们最多迭代<code class="fe on oo op oa b">m</code>或<code class="fe on oo op oa b">n</code>次，这取决于两者中谁的节点更多。因此算法的时间复杂度为<code class="fe on oo op oa b">O(max(m, n))</code>。</p></div><div class="ab cl nc nd hy ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="in io ip iq ir"><h2 id="78f3" class="lj lk iu bd ll lm ln dn lo lp lq dp lr ls lt lu lv lw lx ly lz ma mb mc md ja bi translated">最后的想法</h2><p id="f311" class="pw-post-body-paragraph me mf iu mg b mh mi ke mj mk ml kh mm ls mn mo mp lw mq mr ms ma mt mu mv mw in bi translated">在今天的文章中，我们讨论了关于LeetCode的一个颇具挑战性的问题，这是第二个问题，叫做“两个数相加”，它涉及到最基本的数据结构之一，即链表。</p><p id="3ed9" class="pw-post-body-paragraph me mf iu mg b mh mx ke mj mk my kh mm ls mz mo mp lw na mr ms ma nb mu mv mw in bi translated">请注意，这个问题可能有其他解决方案。请随时留下任何潜在改进的评论，我非常乐意讨论您的意见！</p></div><div class="ab cl nc nd hy ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="in io ip iq ir"><p id="1b77" class="pw-post-body-paragraph me mf iu mg b mh mx ke mj mk my kh mm ls mz mo mp lw na mr ms ma nb mu mv mw in bi translated"><a class="ae li" href="https://gmyrianthous.medium.com/membership" rel="noopener"> <strong class="mg je">成为会员</strong> </a> <strong class="mg je">阅读介质上的每一个故事。你的会员费直接支持我和你看的其他作家。你也可以在媒体上看到所有的故事。</strong></p><div class="pf pg gq gs ph pi"><a href="https://gmyrianthous.medium.com/membership" rel="noopener follow" target="_blank"><div class="pj ab fp"><div class="pk ab pl cl cj pm"><h2 class="bd je gz z fq pn fs ft po fv fx jd bi translated">通过我的推荐链接加入Medium-Giorgos Myrianthous</h2><div class="pp l"><h3 class="bd b gz z fq pn fs ft po fv fx dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="pq l"><p class="bd b dl z fq pn fs ft po fv fx dk translated">gmyrianthous.medium.com</p></div></div><div class="pr l"><div class="ps l pt pu pv pr pw lc pi"/></div></div></a></div></div><div class="ab cl nc nd hy ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="in io ip iq ir"><p id="676e" class="pw-post-body-paragraph me mf iu mg b mh mx ke mj mk my kh mm ls mz mo mp lw na mr ms ma nb mu mv mw in bi translated"><strong class="mg je">你可能也会喜欢</strong></p><div class="pf pg gq gs ph pi"><a rel="noopener follow" target="_blank" href="/leetcode-problem-1-python-ec6cba23c20f"><div class="pj ab fp"><div class="pk ab pl cl cj pm"><h2 class="bd je gz z fq pn fs ft po fv fx jd bi translated">Python中的LeetCode问题1解决方案</h2><div class="pp l"><h3 class="bd b gz z fq pn fs ft po fv fx dk translated">讨论了LeetCode中两个和问题的最优解的方法</h3></div><div class="pq l"><p class="bd b dl z fq pn fs ft po fv fx dk translated">towardsdatascience.com</p></div></div><div class="pr l"><div class="px l pt pu pv pr pw lc pi"/></div></div></a></div></div></div>    
</body>
</html>