<html>
<head>
<title>gistyc — A Python based GitHub GIST management toolkit</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">GIS tyc——基于Python的GitHub GIST管理工具包</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/gistyc-a-python-based-github-gist-management-toolkit-ee507d5a0e7b?source=collection_archive---------33-----------------------#2021-03-18">https://towardsdatascience.com/gistyc-a-python-based-github-gist-management-toolkit-ee507d5a0e7b?source=collection_archive---------33-----------------------#2021-03-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="862d" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/tips-and-tricks" rel="noopener" target="_blank"> <em class="jb">小窍门</em> </a></h2><div class=""/><div class=""><h2 id="f992" class="pw-subtitle-paragraph ka jd it bd b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr dk translated">GitHub GISTs是在介质上显示代码片段的完美方式。但是，如何以可行的方式创建、更新和删除GISTs，并将这样的过程集成到CI/CD管道中呢？</h2></div><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi ks"><img src="../Images/e41f0b42f0a08b15367a11f1a8baf861.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*MO0LRoDWZFuV-Wlc"/></div></div><p class="le lf gj gh gi lg lh bd b be z dk translated">照片由<a class="ae li" href="https://unsplash.com/@richygreat?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">rich Great</a>在<a class="ae li" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><h1 id="1384" class="lj lk it bd ll lm ln lo lp lq lr ls lt kj lu kk lv km lw kn lx kp ly kq lz ma bi translated">使用GISTs</h1><p id="1d43" class="pw-post-body-paragraph mb mc it md b me mf ke mg mh mi kh mj mk ml mm mn mo mp mq mr ms mt mu mv mw im bi translated">媒体已经成为各种文章的重要来源。这还包括涵盖数据科学或机器学习主题的编程教程。但是覆盖实际的编码部分需要一样东西:适当的格式和编程语言依赖的颜色突出。有时人们会看到以下格式的代码片段:</p><pre class="kt ku kv kw gt mx my mz na aw nb bi"><span id="bf23" class="nc lk it my b gy nd ne l nf ng"># Import standard module<br/>import time</span><span id="4df6" class="nc lk it my b gy nh ne l nf ng"># Print the current Unix Time<br/>print(time.time())</span></pre><p id="f21b" class="pw-post-body-paragraph mb mc it md b me ni ke mg mh nj kh mj mk nk mm mn mo nl mq mr ms nm mu mv mw im bi translated">…这种格式对于几行代码来说完全没问题，但是用这些灰色的块来覆盖整个教程会让人读起来很累。相反，大多数Medium上的作者使用<a class="ae li" href="https://gist.github.com/" rel="noopener ugc nofollow" target="_blank"> GitHub GIST </a>。GitHub提供了一个创建要点的简单链接，允许用户在介质上显示正确格式化的代码。以下要点…</p><figure class="kt ku kv kw gt kx"><div class="bz fp l di"><div class="nn no l"/></div><p class="le lf gj gh gi lg lh bd b be z dk translated">要点示例</p></figure><p id="3c8b" class="pw-post-body-paragraph mb mc it md b me ni ke mg mh nj kh mj mk nk mm mn mo nl mq mr ms nm mu mv mw im bi translated">…只需在Medium文本编辑器中添加以下链接即可(灰色块样式阻止Medium正确格式化要点):</p><pre class="kt ku kv kw gt mx my mz na aw nb bi"><span id="aa51" class="nc lk it my b gy nd ne l nf ng"><a class="ae li" href="https://gist.github.com/ThomasAlbin/1b42f2fbe6470ae54286b83b57f5acd6" rel="noopener ugc nofollow" target="_blank">https://gist.github.com/ThomasAlbin/1b42f2fbe6470ae54286b83b57f5acd6</a></span></pre></div><div class="ab cl np nq hx nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="im in io ip iq"><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi ks"><img src="../Images/c64202661c6432b26c25d2d0ccc692a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wWv06Q8cv7-0Lvf-"/></div></div><p class="le lf gj gh gi lg lh bd b be z dk translated">由<a class="ae li" href="https://unsplash.com/@finnwhelen?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Finn Whelen </a>在<a class="ae li" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h1 id="0e4e" class="lj lk it bd ll lm ln lo lp lq lr ls lt kj lu kk lv km lw kn lx kp ly kq lz ma bi translated">维护要点的问题是</h1><p id="38da" class="pw-post-body-paragraph mb mc it md b me mf ke mg mh mi kh mj mk ml mm mn mo mp mq mr ms mt mu mv mw im bi translated">Medium有数百甚至数千篇文章，涵盖了编程相关的主题。但是，旧的文章可能会引用已经过时的库和更新的工具，它们的功能发生了变化。结果是一些显示的要点代码片段不再工作了。提出的异常、警告和错误结果会抑制阅读有希望的标题或摘要后的兴奋感。考虑到作者对代码进行了测试，并且审阅者或编辑对文章进行了彻底的检查，我们只能假设最近的文章工作正常。</p><p id="30e7" class="pw-post-body-paragraph mb mc it md b me ni ke mg mh nj kh mj mk nk mm mn mo nl mq mr ms nm mu mv mw im bi translated">但是一个人(例如，一篇文章的作者)如何保持要点的更新呢？手动编辑大量的GISTs既乏味又麻烦。还有一个<a class="ae li" href="https://docs.github.com/en/rest/reference/gists" rel="noopener ugc nofollow" target="_blank"> GitHub GIST REST API </a>，但是有一个简单的解决方案会更好。</p><p id="f9df" class="pw-post-body-paragraph mb mc it md b me ni ke mg mh nj kh mj mk nk mm mn mo nl mq mr ms nm mu mv mw im bi translated">为此，我开发了一个具有CLI功能的基于Python的工具包，我想在这里介绍一下:<strong class="md je"> <em class="nw"> gistyc </em> </strong>。<em class="nw"> GISTsyc </em>应使用户能够从外壳或Python程序中创建、更新和删除gist。它的功能、特性和GitHub动作集成(新的GIST代码的持续部署)是本文的一部分。</p><div class="nx ny gp gr nz oa"><a href="https://github.com/ThomasAlbin/gistyc" rel="noopener  ugc nofollow" target="_blank"><div class="ob ab fo"><div class="oc ab od cl cj oe"><h2 class="bd je gy z fp of fr fs og fu fw jd bi translated">ThomasAlbin/gistyc</h2><div class="oh l"><h3 class="bd b gy z fp of fr fs og fu fw dk translated">gistyc是一个基于Python的库，使开发者能够创建、更新和删除他们的GitHub GISTs。客户端…</h3></div><div class="oi l"><p class="bd b dl z fp of fr fs og fu fw dk translated">github.com</p></div></div><div class="oj l"><div class="ok l ol om on oj oo lc oa"/></div></div></a></div><p id="1959" class="pw-post-body-paragraph mb mc it md b me ni ke mg mh nj kh mj mk nk mm mn mo nl mq mr ms nm mu mv mw im bi translated">总的来说，gistyc 很容易理解。让我们举个例子:</p><ul class=""><li id="c10d" class="op oq it md b me ni mh nj mk or mo os ms ot mw ou ov ow ox bi translated">您有一个想要向全世界展示的Python文件！就叫牛逼吧. py。</li><li id="2203" class="op oq it md b me oy mh oz mk pa mo pb ms pc mw ou ov ow ox bi translated">awesome.py要在一篇中等文章里详细解释。这个文件很大，有200多行代码。一个要点对于一篇教程文章来说太大了。</li><li id="068d" class="op oq it md b me oy mh oz mk pa mo pb ms pc mw ou ov ow ox bi translated">无论如何，你可以简单地将你的代码分割成单独的要点或者要点中的“子部分”。手动完成这个过程是乏味的…如果你以后需要更新它，由于一些读者抱怨错误，它变得更糟… </li><li id="3cf1" class="op oq it md b me oy mh oz mk pa mo pb ms pc mw ou ov ow ox bi translated">awesome.py具有专用的“编码块”，例如由“# % %”(<a class="ae li" href="https://docs.spyder-ide.org/current/editor.html#defining-code-cells" rel="noopener ugc nofollow" target="_blank">Spyder-way</a>)分隔。这些单元格应该是你想要显示的要点部分。</li><li id="d6a6" class="op oq it md b me oy mh oz mk pa mo pb ms pc mw ou ov ow ox bi translated">现在是<em class="nw">GIS tyc</em>:<em class="nw">GIS tyc</em>获取你的文件，将它分割成单独的部分(取决于代码块分隔符)并自动创建要点。如果你已经有了一个名为“awesome.py”的要点，<em class="nw"> gistyc </em>会相应地更新要点！第一个GIST代码-cell的名称是“awesome.py”，第二个得到后缀“_1”，导致“awesome_1.py”等等。稍后你会看到一个例子。</li><li id="5d01" class="op oq it md b me oy mh oz mk pa mo pb ms pc mw ou ov ow ox bi translated">您更新的要点会自动与您的中型文章同步，您就大功告成了！</li></ul><p id="69b1" class="pw-post-body-paragraph mb mc it md b me ni ke mg mh nj kh mj mk nk mm mn mo nl mq mr ms nm mu mv mw im bi translated">这里只涉及几个陷阱:</p><ol class=""><li id="714a" class="op oq it md b me ni mh nj mk or mo os ms ot mw pd ov ow ox bi translated">您应该坚持在您的GIST存储库中使用唯一的文件名(否则<em class="nw"> gistyc </em>会与不明确的名称混淆并返回一个错误)。</li><li id="8aa5" class="op oq it md b me oy mh oz mk pa mo pb ms pc mw pd ov ow ox bi translated">您还应该坚持代码单元格分隔。只编辑错误或异常，但不要改变代码的逻辑！否则你的中型文章不符合代码和你的读者越来越困惑后，你更新它！</li></ol></div><div class="ab cl np nq hx nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="im in io ip iq"><h1 id="139c" class="lj lk it bd ll lm pe lo lp lq pf ls lt kj pg kk lv km ph kn lx kp pi kq lz ma bi translated">先决条件和安装</h1><p id="58e7" class="pw-post-body-paragraph mb mc it md b me mf ke mg mh mi kh mj mk ml mm mn mo mp mq mr ms mt mu mv mw im bi translated">在我们深入研究gistyc 之前，我们需要满足一些先决条件才能使用它的全部特性列表。除了安装Python，你还需要一个<a class="ae li" href="https://github.com/" rel="noopener ugc nofollow" target="_blank"> GitHub </a>帐户来创建和存储GISTs。之后，你只需要遵循这三个步骤:</p><ol class=""><li id="886a" class="op oq it md b me ni mh nj mk or mo os ms ot mw pd ov ow ox bi translated">安装Python ≥3.8(建议:使用虚拟环境)</li><li id="54db" class="op oq it md b me oy mh oz mk pa mo pb ms pc mw pd ov ow ox bi translated">您需要一个<em class="nw"> GitHub个人访问令牌</em>和GIST访问:</li></ol><ul class=""><li id="0a90" class="op oq it md b me ni mh nj mk or mo os ms ot mw ou ov ow ox bi translated">点击您的个人账户资料(右上角)</li><li id="1763" class="op oq it md b me oy mh oz mk pa mo pb ms pc mw ou ov ow ox bi translated">点击<strong class="md je">设置</strong></li><li id="3edc" class="op oq it md b me oy mh oz mk pa mo pb ms pc mw ou ov ow ox bi translated">在左侧菜单栏中，进入<strong class="md je">开发者设置</strong>，选择<strong class="md je">个人访问令牌</strong></li><li id="2db9" class="op oq it md b me oy mh oz mk pa mo pb ms pc mw ou ov ow ox bi translated"><strong class="md je">生成新的令牌</strong>并写下您的令牌的名称(注释)。注释不影响功能，但选择描述令牌用途的注释，例如<em class="nw"> GIST_token </em></li><li id="e3b9" class="op oq it md b me oy mh oz mk pa mo pb ms pc mw ou ov ow ox bi translated">在<strong class="md je">要点</strong> ( <em class="nw">创建要点</em>)处设置一个标记，并点击页面底部的<strong class="md je">生成令牌</strong></li><li id="6881" class="op oq it md b me oy mh oz mk pa mo pb ms pc mw ou ov ow ox bi translated">重要提示:显示的令牌只出现一次。将其复制并作为一个秘密存储在GitHub项目中和/或作为一个环境变量存储在本地。</li></ul><p id="0817" class="pw-post-body-paragraph mb mc it md b me ni ke mg mh nj kh mj mk nk mm mn mo nl mq mr ms nm mu mv mw im bi translated">3.通过以下方式安装<em class="nw"> gistyc </em>:</p><pre class="kt ku kv kw gt mx my mz na aw nb bi"><span id="59e4" class="nc lk it my b gy nd ne l nf ng">pip install gistyc</span></pre><p id="297f" class="pw-post-body-paragraph mb mc it md b me ni ke mg mh nj kh mj mk nk mm mn mo nl mq mr ms nm mu mv mw im bi translated">或者，可以随意下载<a class="ae li" href="https://github.com/ThomasAlbin/gistyc" rel="noopener ugc nofollow" target="_blank">库</a>来下载和使用所提供的测试。</p><p id="1c3a" class="pw-post-body-paragraph mb mc it md b me ni ke mg mh nj kh mj mk nk mm mn mo nl mq mr ms nm mu mv mw im bi translated">现在我们准备和吉斯泰克一起工作。以下部分描述了Python函数调用，第二部分概述了对CD管道更感兴趣的CLI功能！</p><h2 id="dbf1" class="nc lk it bd ll pj pk dn lp pl pm dp lt mk pn po lv mo pp pq lx ms pr ps lz iz bi translated">Python要点准备</h2><p id="56b0" class="pw-post-body-paragraph mb mc it md b me mf ke mg mh mi kh mj mk ml mm mn mo mp mq mr ms mt mu mv mw im bi translated"><strong class="md je"> <em class="nw">请注意:当前版本仍处于测试阶段，仅适用于Python(。py)文件。将来会有更新来涵盖更多的通用解决方案。</em>T25】</strong></p><p id="67ec" class="pw-post-body-paragraph mb mc it md b me ni ke mg mh nj kh mj mk nk mm mn mo nl mq mr ms nm mu mv mw im bi translated">为了测试或使用<em class="nw"> gistyc </em>在我们的设备上准备一个简单的Python文件。结局还得是<em class="nw">。py </em>。</p><p id="67e8" class="pw-post-body-paragraph mb mc it md b me ni ke mg mh nj kh mj mk nk mm mn mo nl mq mr ms nm mu mv mw im bi translated">此外，要点可以被分成几个文件。这可能有助于将您想要一步一步解释的较大的教程脚本分割开来。下面的例子(我们将在后面更详细地讨论这个例子)给你一个印象，它意味着什么:</p><p id="c687" class="pw-post-body-paragraph mb mc it md b me ni ke mg mh nj kh mj mk nk mm mn mo nl mq mr ms nm mu mv mw im bi translated">看一看gistyc提供的示例脚本:<a class="ae li" href="https://github.com/ThomasAlbin/gistyc/blob/main/examples/example_sub_dir/gistyc_example2.py" rel="noopener ugc nofollow" target="_blank">示例脚本</a></p><p id="1ea4" class="pw-post-body-paragraph mb mc it md b me ni ke mg mh nj kh mj mk nk mm mn mo nl mq mr ms nm mu mv mw im bi translated">作为一个单独的要点，脚本存储在…</p><pre class="kt ku kv kw gt mx my mz na aw nb bi"><span id="1554" class="nc lk it my b gy nd ne l nf ng"><a class="ae li" href="https://gist.github.com/ThomasAlbin/77974cc3e14b2de8caba007dfa3fccf9" rel="noopener ugc nofollow" target="_blank">https://gist.github.com/ThomasAlbin/77974cc3e14b2de8caba007dfa3fccf9</a></span></pre><p id="d077" class="pw-post-body-paragraph mb mc it md b me ni ke mg mh nj kh mj mk nk mm mn mo nl mq mr ms nm mu mv mw im bi translated">…格式为:</p><figure class="kt ku kv kw gt kx"><div class="bz fp l di"><div class="nn no l"/></div><p class="le lf gj gh gi lg lh bd b be z dk translated">另一个GIST示例名为“gistyc_example2.py”</p></figure><p id="4e32" class="pw-post-body-paragraph mb mc it md b me ni ke mg mh nj kh mj mk nk mm mn mo nl mq mr ms nm mu mv mw im bi translated">如你所见，提供了<a class="ae li" href="https://www.spyder-ide.org/" rel="noopener ugc nofollow" target="_blank"> Spyder </a>代码块分隔符“#%%”。gistyc识别这些代码分隔符，并在单个GIST中创建单独的文件(或“子GIST”)。分隔符可以由用户设置，但在本文中，我们将坚持Spyder风格。</p><p id="1d90" class="pw-post-body-paragraph mb mc it md b me ni ke mg mh nj kh mj mk nk mm mn mo nl mq mr ms nm mu mv mw im bi translated">以上示例是<em class="nw"> gistyc </em>官方GIST示例的一部分，可在以下位置找到:</p><pre class="kt ku kv kw gt mx my mz na aw nb bi"><span id="41cf" class="nc lk it my b gy nd ne l nf ng"><a class="ae li" href="https://gist.github.com/ThomasAlbin/caddb300ac663e60ae573b1117599fcc" rel="noopener ugc nofollow" target="_blank">https://gist.github.com/ThomasAlbin/caddb300ac663e60ae573b1117599fcc</a></span></pre><p id="26de" class="pw-post-body-paragraph mb mc it md b me ni ke mg mh nj kh mj mk nk mm mn mo nl mq mr ms nm mu mv mw im bi translated">此外，这三个独立的块可以通过以下方式调用:</p><h2 id="248f" class="nc lk it bd ll pj pk dn lp pl pm dp lt mk pn po lv mo pp pq lx ms pr ps lz iz bi translated">1.第一代码单元</h2><pre class="kt ku kv kw gt mx my mz na aw nb bi"><span id="1045" class="nc lk it my b gy nd ne l nf ng"><a class="ae li" href="https://gist.github.com/ThomasAlbin/caddb300ac663e60ae573b1117599fcc?file=gistyc_example2.py" rel="noopener ugc nofollow" target="_blank">https://gist.github.com/ThomasAlbin/caddb300ac663e60ae573b1117599fcc?file=gistyc_example2.py</a></span></pre><figure class="kt ku kv kw gt kx"><div class="bz fp l di"><div class="nn no l"/></div><p class="le lf gj gh gi lg lh bd b be z dk translated">gistyc_example2.py的第1部分—通过<a class="ae li" href="https://gist.github.com/ThomasAlbin/caddb300ac663e60ae573b1117599fcc?file=gistyc_example2.py" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/Thomas Albin/caddb 300 AC 663 e 60 AE 573 b 1117599 FCC调用？file=gistyc_example2.py </a></p></figure><h2 id="15b5" class="nc lk it bd ll pj pk dn lp pl pm dp lt mk pn po lv mo pp pq lx ms pr ps lz iz bi translated">2.第二代码单元</h2><pre class="kt ku kv kw gt mx my mz na aw nb bi"><span id="47ee" class="nc lk it my b gy nd ne l nf ng"><a class="ae li" href="https://gist.github.com/ThomasAlbin/caddb300ac663e60ae573b1117599fcc?file=gistyc_example2.py" rel="noopener ugc nofollow" target="_blank">https://gist.github.com/ThomasAlbin/caddb300ac663e60ae573b1117599fcc?file=gistyc_example2_1.py</a></span></pre><figure class="kt ku kv kw gt kx"><div class="bz fp l di"><div class="nn no l"/></div><p class="le lf gj gh gi lg lh bd b be z dk translated">gistyc_example2.py的第二部分—通过<a class="ae li" href="https://gist.github.com/ThomasAlbin/caddb300ac663e60ae573b1117599fcc?file=gistyc_example2_1.py" rel="noopener ugc nofollow" target="_blank">调用https://gist . github . com/Thomas Albin/caddb 300 AC 663 e 60 AE 573 b 1117599 FCC？file=gistyc_example2_1.py </a></p></figure><h2 id="cf84" class="nc lk it bd ll pj pk dn lp pl pm dp lt mk pn po lv mo pp pq lx ms pr ps lz iz bi translated">3.第三代码单元</h2><pre class="kt ku kv kw gt mx my mz na aw nb bi"><span id="f8d6" class="nc lk it my b gy nd ne l nf ng"><a class="ae li" href="https://gist.github.com/ThomasAlbin/caddb300ac663e60ae573b1117599fcc?file=gistyc_example2_2.py" rel="noopener ugc nofollow" target="_blank">https://gist.github.com/ThomasAlbin/caddb300ac663e60ae573b1117599fcc?file=gistyc_example2_2.py</a></span></pre><figure class="kt ku kv kw gt kx"><div class="bz fp l di"><div class="nn no l"/></div><p class="le lf gj gh gi lg lh bd b be z dk translated">gistyc_example2.py的第三部分—通过<a class="ae li" href="https://gist.github.com/ThomasAlbin/caddb300ac663e60ae573b1117599fcc?file=gistyc_example2_2.py" rel="noopener ugc nofollow" target="_blank">调用https://gist . github . com/Thomas Albin/caddb 300 AC 663 e 60 AE 573 b 1117599 FCC？file=gistyc_example2_2.py </a></p></figure><blockquote class="pt pu pv"><p id="08fb" class="mb mc nw md b me ni ke mg mh nj kh mj pw nk mm mn px nl mq mr py nm mu mv mw im bi translated">总体而言，用户的(<em class="it">用户</em> ) GIST及其值(<em class="it"> GIST_VALUE </em>)和相应的文件名(<em class="it"> GIST_NAME </em>)以及后缀依赖子节(<em class="it"> ID </em>)具有以下结构:</p><p id="268a" class="mb mc nw md b me ni ke mg mh nj kh mj pw nk mm mn px nl mq mr py nm mu mv mw im bi translated">https://gist.github.com/USER/GIST_VALUE?fileGIST_NAME_ID.py</p></blockquote></div><div class="ab cl np nq hx nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="im in io ip iq"><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi pz"><img src="../Images/4a52bf5581377186de26ef0641b6bfc2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*G5fnaz9xFUF7Ed7p"/></div></div><p class="le lf gj gh gi lg lh bd b be z dk translated"><a class="ae li" href="https://unsplash.com/@davidclode?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> David Clode </a>在<a class="ae li" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h1 id="e70f" class="lj lk it bd ll lm ln lo lp lq lr ls lt kj lu kk lv km lw kn lx kp ly kq lz ma bi translated">Python中的gistyc</h1><p id="387c" class="pw-post-body-paragraph mb mc it md b me mf ke mg mh mi kh mj mk ml mm mn mo mp mq mr ms mt mu mv mw im bi translated">Python API目前提供4个通用函数来创建、更新和删除GIST。此外，它允许用户获得所有可用gist的当前列表。</p><p id="6799" class="pw-post-body-paragraph mb mc it md b me ni ke mg mh nj kh mj mk nk mm mn mo nl mq mr ms nm mu mv mw im bi translated">我们有以下参数:</p><ul class=""><li id="ae9d" class="op oq it md b me ni mh nj mk or mo os ms ot mw ou ov ow ox bi translated">AUTH_TOKEN:是GIST访问令牌(字符串)</li><li id="f412" class="op oq it md b me oy mh oz mk pa mo pb ms pc mw ou ov ow ox bi translated">FILEPATH:是Python文件的绝对或相对路径(string或<a class="ae li" href="https://docs.python.org/3/library/pathlib.html#module-pathlib" rel="noopener ugc nofollow" target="_blank"> pathlib。路径</a></li><li id="b2d4" class="op oq it md b me oy mh oz mk pa mo pb ms pc mw ou ov ow ox bi translated">要点ID:要点(字符串)的ID<em class="nw">。我们一会儿会谈到这个参数</em></li></ul><h2 id="3151" class="nc lk it bd ll pj pk dn lp pl pm dp lt mk pn po lv mo pp pq lx ms pr ps lz iz bi translated"><em class="jb">创建一个要点</em></h2><p id="401a" class="pw-post-body-paragraph mb mc it md b me mf ke mg mh mi kh mj mk ml mm mn mo mp mq mr ms mt mu mv mw im bi translated">基本上所有的<em class="nw"> gistyc </em>调用都是从同样的两行代码开始的:首先是库的表面导入，其次是gistyc类的实例化(第5行)。这个类只需要GIST身份验证令牌。返回的类，这里命名为<em class="nw"> gist_api </em>，然后用于调用相关的方法。</p><p id="add9" class="pw-post-body-paragraph mb mc it md b me ni ke mg mh nj kh mj mk nk mm mn mo nl mq mr ms nm mu mv mw im bi translated">以下示例显示了如何创建要点。该类调用方法<em class="nw"> create_gist </em>，其输入是文件路径。返回值(<em class="nw"> response_data </em>)是来自GitHub服务器的回调JSON，包含新创建的GIST的元信息(如时间戳、GIST的ID等)。).</p><figure class="kt ku kv kw gt kx"><div class="bz fp l di"><div class="nn no l"/></div><p class="le lf gj gh gi lg lh bd b be z dk translated">使用gistyc Python API创建GIST</p></figure><h2 id="ffc5" class="nc lk it bd ll pj pk dn lp pl pm dp lt mk pn po lv mo pp pq lx ms pr ps lz iz bi translated">更新要点</h2><p id="f5c5" class="pw-post-body-paragraph mb mc it md b me mf ke mg mh mi kh mj mk ml mm mn mo mp mq mr ms mt mu mv mw im bi translated">有两种方法可以更新要点。首先，让我们假设所有的要点名称都是唯一的，不会重复。</p><p id="b8dd" class="pw-post-body-paragraph mb mc it md b me ni ke mg mh nj kh mj mk nk mm mn mo nl mq mr ms nm mu mv mw im bi translated">同样，我们创建了这个类(第5行)并在第8行调用了方法<em class="nw"> update_gist </em>,这里我们只是提供了文件路径作为输入。返回的JSON提供回调信息。</p><figure class="kt ku kv kw gt kx"><div class="bz fp l di"><div class="nn no l"/></div><p class="le lf gj gh gi lg lh bd b be z dk translated">使用gistyc Python API更新GIST(仅使用Python文件的文件路径)</p></figure><p id="51d2" class="pw-post-body-paragraph mb mc it md b me ni ke mg mh nj kh mj mk nk mm mn mo nl mq mr ms nm mu mv mw im bi translated">然而，让我们假设你有几个同名的gist<strong class="md je"><em class="nw">(顺便说一下:为了保持整洁，避免重复/同名的gist！)</em> </strong>。如果只使用文件名调用更新函数，就会引发一个异常(我称之为AmbiguityError)。在这种情况下，你还需要知道你要点的要点ID。然后，您可以通过以下方式更新您的要点:</p><figure class="kt ku kv kw gt kx"><div class="bz fp l di"><div class="nn no l"/></div><p class="le lf gj gh gi lg lh bd b be z dk translated">使用gistyc Python API更新GIST(仅使用Python文件的文件路径和相应的GIST ID)</p></figure><h2 id="f685" class="nc lk it bd ll pj pk dn lp pl pm dp lt mk pn po lv mo pp pq lx ms pr ps lz iz bi translated">获取所有GISTs</h2><p id="29e6" class="pw-post-body-paragraph mb mc it md b me mf ke mg mh mi kh mj mk ml mm mn mo mp mq mr ms mt mu mv mw im bi translated">有时候知道你所有的要点是有用的，尤其是当你有上百个要点的时候。在一个单独的数据库中维护它们或者手动获取所有的GIST IDs可能会令人精疲力尽…</p><p id="3bcc" class="pw-post-body-paragraph mb mc it md b me ni ke mg mh nj kh mj mk nk mm mn mo nl mq mr ms nm mu mv mw im bi translated">为此，实现了<em class="nw"> get_gists </em>方法，该方法通过所有的GIST页面调用REST API，并将所有结果附加到最终列表中。每个元素都是一个JSON元素，代表一个要点。</p><figure class="kt ku kv kw gt kx"><div class="bz fp l di"><div class="nn no l"/></div><p class="le lf gj gh gi lg lh bd b be z dk translated">使用gistyc Python API获得所有GitHub GISTs的列表</p></figure><h2 id="b051" class="nc lk it bd ll pj pk dn lp pl pm dp lt mk pn po lv mo pp pq lx ms pr ps lz iz bi translated">删除要点</h2><p id="4fd5" class="pw-post-body-paragraph mb mc it md b me mf ke mg mh mi kh mj mk ml mm mn mo mp mq mr ms mt mu mv mw im bi translated">最后，我们来看看如何删除一个要点。该过程类似于更新例程。如果您有具有唯一文件名的GISTs，那么FILEPATH是唯一需要的输入参数…</p><figure class="kt ku kv kw gt kx"><div class="bz fp l di"><div class="nn no l"/></div><p class="le lf gj gh gi lg lh bd b be z dk translated">使用gistyc Python API删除GIST(仅使用Python文件的文件路径)</p></figure><p id="288f" class="pw-post-body-paragraph mb mc it md b me ni ke mg mh nj kh mj mk nk mm mn mo nl mq mr ms nm mu mv mw im bi translated">…否则，您需要提供一个要点ID:</p><figure class="kt ku kv kw gt kx"><div class="bz fp l di"><div class="nn no l"/></div><p class="le lf gj gh gi lg lh bd b be z dk translated">使用gistyc Python API删除GIST(仅使用GIST_ID)</p></figure></div><div class="ab cl np nq hx nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="im in io ip iq"><h1 id="da3d" class="lj lk it bd ll lm pe lo lp lq pf ls lt kj pg kk lv km ph kn lx kp pi kq lz ma bi translated">gistyc作为CLI</h1><p id="40b5" class="pw-post-body-paragraph mb mc it md b me mf ke mg mh mi kh mj mk ml mm mn mo mp mq mr ms mt mu mv mw im bi translated">使用<a class="ae li" href="https://click.palletsprojects.com/en/7.x/" rel="noopener ugc nofollow" target="_blank"> click </a>可以创建基于Python的CLI工具，可以从shell中直接调用这些工具。gistyc 也具有部分基于上述功能的CLI功能。</p><p id="dd14" class="pw-post-body-paragraph mb mc it md b me ni ke mg mh nj kh mj mk nk mm mn mo nl mq mr ms nm mu mv mw im bi translated">我们有以下参数:</p><ul class=""><li id="03fb" class="op oq it md b me ni mh nj mk or mo os ms ot mw ou ov ow ox bi translated">AUTH_TOKEN:是GIST访问令牌(字符串)</li><li id="a717" class="op oq it md b me oy mh oz mk pa mo pb ms pc mw ou ov ow ox bi translated">FILEPATH:是Python文件(字符串)的绝对或相对路径</li><li id="8095" class="op oq it md b me oy mh oz mk pa mo pb ms pc mw ou ov ow ox bi translated">GIST _ ID:GIST(字符串)的ID</li></ul><p id="214f" class="pw-post-body-paragraph mb mc it md b me ni ke mg mh nj kh mj mk nk mm mn mo nl mq mr ms nm mu mv mw im bi translated"><strong class="md je"> <em class="nw">请注意:代码单元格分隔符必须是“#%%”。CLI的分隔符输入参数将跟在后面。</em>T15】</strong></p><h2 id="30c6" class="nc lk it bd ll pj pk dn lp pl pm dp lt mk pn po lv mo pp pq lx ms pr ps lz iz bi translated">创造一个要点</h2><p id="d682" class="pw-post-body-paragraph mb mc it md b me mf ke mg mh mi kh mj mk ml mm mn mo mp mq mr ms mt mu mv mw im bi translated">首先，<em class="nw"> gistyc </em>需要一个标记来指示所需的功能(创建、更新、删除),后跟输入参数。所有CLI调用都需要一个允许更改要点的身份验证令牌。</p><p id="3bf0" class="pw-post-body-paragraph mb mc it md b me ni ke mg mh nj kh mj mk nk mm mn mo nl mq mr ms nm mu mv mw im bi translated">下面的bash片段基于FILEPATH创建了一个GIST。</p><pre class="kt ku kv kw gt mx my mz na aw nb bi"><span id="2bf4" class="nc lk it my b gy nd ne l nf ng">gistyc --create --auth-token AUTH_TOKEN --file-name FILEPATH</span></pre><h2 id="1068" class="nc lk it bd ll pj pk dn lp pl pm dp lt mk pn po lv mo pp pq lx ms pr ps lz iz bi translated">更新要点</h2><p id="1ae4" class="pw-post-body-paragraph mb mc it md b me mf ke mg mh mi kh mj mk ml mm mn mo mp mq mr ms mt mu mv mw im bi translated">类似地，如前所示，我们有一个CLI调用来基于文件名称更新GIST，并且…</p><pre class="kt ku kv kw gt mx my mz na aw nb bi"><span id="953f" class="nc lk it my b gy nd ne l nf ng">gistyc --update --auth-token AUTH_TOKEN --file-name FILEPATH</span></pre><p id="f0e8" class="pw-post-body-paragraph mb mc it md b me ni ke mg mh nj kh mj mk nk mm mn mo nl mq mr ms nm mu mv mw im bi translated">…如果文件名不唯一，则带有相应的GIST ID:</p><pre class="kt ku kv kw gt mx my mz na aw nb bi"><span id="156f" class="nc lk it my b gy nd ne l nf ng">gistyc --update --auth-token AUTH_TOKEN --file-name FILEPATH --gist-id GIST_ID</span></pre><h2 id="ae36" class="nc lk it bd ll pj pk dn lp pl pm dp lt mk pn po lv mo pp pq lx ms pr ps lz iz bi translated">删除要点</h2><p id="de82" class="pw-post-body-paragraph mb mc it md b me mf ke mg mh mi kh mj mk ml mm mn mo mp mq mr ms mt mu mv mw im bi translated">类似地，可以通过CLI删除GISTs通过提供文件名…</p><pre class="kt ku kv kw gt mx my mz na aw nb bi"><span id="1a9f" class="nc lk it my b gy nd ne l nf ng">gistyc --delete --auth-token AUTH_TOKEN --file-name FILEPATH</span></pre><p id="7845" class="pw-post-body-paragraph mb mc it md b me ni ke mg mh nj kh mj mk nk mm mn mo nl mq mr ms nm mu mv mw im bi translated">…或要点ID:</p><pre class="kt ku kv kw gt mx my mz na aw nb bi"><span id="6c47" class="nc lk it my b gy nd ne l nf ng">gistyc --delete --auth-token AUTH_TOKEN --gist-id GIST_ID</span></pre></div><div class="ab cl np nq hx nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="im in io ip iq"><h1 id="485f" class="lj lk it bd ll lm pe lo lp lq pf ls lt kj pg kk lv km ph kn lx kp pi kq lz ma bi translated">gistyc目录CLI</h1><p id="1d59" class="pw-post-body-paragraph mb mc it md b me mf ke mg mh mi kh mj mk ml mm mn mo mp mq mr ms mt mu mv mw im bi translated">为单个文件调用gistyc CLI是管理您的GISTs的一种快速可行的方法。然而，让我们假设您有一个更大的教程系列，包含几十个Python脚本和数百个代码单元。多次调用<em class="nw"> gistyc </em>或者用几十个<em class="nw"> gistyc </em>调用创建一个bash脚本可能会变得令人困惑。</p><p id="bf4c" class="pw-post-body-paragraph mb mc it md b me ni ke mg mh nj kh mj mk nk mm mn mo nl mq mr ms nm mu mv mw im bi translated">为此，已经实现了第二个基于<em class="nw"> gistyc </em>的CLI:<em class="nw">GIS tyc _ dir</em>。</p><p id="5140" class="pw-post-body-paragraph mb mc it md b me ni ke mg mh nj kh mj mk nk mm mn mo nl mq mr ms nm mu mv mw im bi translated">我们假设您将所有Python文件存储在一个名为directory的目录中。现在，您需要创建和/或更新所有相应的GISTs。您只需拨打:</p><pre class="kt ku kv kw gt mx my mz na aw nb bi"><span id="e22d" class="nc lk it my b gy nd ne l nf ng">gistyc_dir --auth-token AUTH_TOKEN --directory DIRECTORY</span></pre><p id="47d7" class="pw-post-body-paragraph mb mc it md b me ni ke mg mh nj kh mj mk nk mm mn mo nl mq mr ms nm mu mv mw im bi translated">请注意:文件名在GIST repo中必须是唯一的，因为这里不能提供GIST ID。此外，您的文件也可以存储在子目录中。<em class="nw"> gistyc_dir </em>递归搜索目录以找到所有Python文件。</p><p id="e079" class="pw-post-body-paragraph mb mc it md b me ni ke mg mh nj kh mj mk nk mm mn mo nl mq mr ms nm mu mv mw im bi translated">调用<em class="nw"> GISTsyc_dir </em>后，新的GISTs被创建，现有的gist也被创建！</p></div><div class="ab cl np nq hx nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="im in io ip iq"><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi qa"><img src="../Images/e73132d78531d121789da32e49d85a3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-SqvqS80B8jE4dHj"/></div></div><p class="le lf gj gh gi lg lh bd b be z dk translated"><a class="ae li" href="https://unsplash.com/@yancymin?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Yancy Min </a>在<a class="ae li" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</p></figure><h1 id="13eb" class="lj lk it bd ll lm ln lo lp lq lr ls lt kj lu kk lv km lw kn lx kp ly kq lz ma bi translated">CI/CD中的gistyc</h1><p id="0bbd" class="pw-post-body-paragraph mb mc it md b me mf ke mg mh mi kh mj mk ml mm mn mo mp mq mr ms mt mu mv mw im bi translated"><em class="nw"> gistyc </em>的CLI功能和<em class="nw"> gistyc_dir </em>提供的目录功能是将其集成到类似CI/CD的管道中的良好基础。什么时候，为什么要为GISTs创造这样一个管道？</p><p id="3939" class="pw-post-body-paragraph mb mc it md b me ni ke mg mh nj kh mj mk nk mm mn mo nl mq mr ms nm mu mv mw im bi translated">让我们考虑下面的例子:</p><ul class=""><li id="69aa" class="op oq it md b me ni mh nj mk or mo os ms ot mw ou ov ow ox bi translated">您有一个主要的中型教程项目，其中涵盖了许多您希望存储在GitHub GIST上的Python示例。</li><li id="f48d" class="op oq it md b me oy mh oz mk pa mo pb ms pc mw ou ov ow ox bi translated">所有Python脚本都存储在一个名为<em class="nw">的目录下的相应GitHub存储库中。/例/ </em>。</li><li id="53a1" class="op oq it md b me oy mh oz mk pa mo pb ms pc mw ou ov ow ox bi translated">每次你在<em class="nw">上传新的脚本。/examples/ </em>(例如，通过Pull请求并合并到主分支)应自动创建新的GISTs。</li><li id="ff84" class="op oq it md b me oy mh oz mk pa mo pb ms pc mw ou ov ow ox bi translated">此外，Pull请求还可能包含一些读者已经解决的示例脚本的更正和错误修复。同样在这种情况下:您将您的更改合并到主分支中，管道会相应地自动更新相应的GISTs。无需在繁琐的手动过程中更新GISTs。</li></ul><p id="1ccf" class="pw-post-body-paragraph mb mc it md b me ni ke mg mh nj kh mj mk nk mm mn mo nl mq mr ms nm mu mv mw im bi translated">在GitHub上，CI/CD管道被称为动作。管道逻辑存储在YAML文件中。下面的YAML文件展示了我的<a class="ae li" href="https://github.com/ThomasAlbin/gistyc" rel="noopener ugc nofollow" target="_blank"> gistyc GitHub库</a>中提供的一个例子。看一看【行动】，<em class="nw">。github/workflow </em>目录和<em class="nw">。/examples/ </em>目录，以便更好地了解这个工作流是如何工作的。每次我在<em class="nw">里改变一些东西。/examples/ </em>，创建一个Pull请求，最后合并到主分支，所有代码部分来自<em class="nw">。/examples/ </em>创建新的GISTs或相应地更新现有的GISTs。</p><p id="bc20" class="pw-post-body-paragraph mb mc it md b me ni ke mg mh nj kh mj mk nk mm mn mo nl mq mr ms nm mu mv mw im bi translated">YAML <em class="nw"> gist-push.yml </em>如下所示，工作方式如下:</p><p id="2724" class="pw-post-body-paragraph mb mc it md b me ni ke mg mh nj kh mj mk nk mm mn mo nl mq mr ms nm mu mv mw im bi translated">第8–11行:如果<em class="nw">中有任何内容。/examples/ </em>文件夹发生变化，动作正在执行。</p><p id="3790" class="pw-post-body-paragraph mb mc it md b me ni ke mg mh nj kh mj mk nk mm mn mo nl mq mr ms nm mu mv mw im bi translated">第14–19行:管道进一步检查主分支上是否已经执行了更改。我们不想更新来自另一个未审查或未测试分支的GISTs。</p><p id="ca38" class="pw-post-body-paragraph mb mc it md b me ni ke mg mh nj kh mj mk nk mm mn mo nl mq mr ms nm mu mv mw im bi translated">第21–36行:GitHub准备环境，其中…</p><p id="51ec" class="pw-post-body-paragraph mb mc it md b me ni ke mg mh nj kh mj mk nk mm mn mo nl mq mr ms nm mu mv mw im bi translated">第37–38行:… <em class="nw"> gistyc </em>正在安装(这里，<em class="nw"> gistyc </em>是从pypi安装的)</p><p id="6718" class="pw-post-body-paragraph mb mc it md b me ni ke mg mh nj kh mj mk nk mm mn mo nl mq mr ms nm mu mv mw im bi translated">第39–40行:现在<em class="nw"> gistyc_dir </em>被应用到<em class="nw">上。/examples/ </em>文件夹。创建新的GISTs，并更新现有的GISTs。</p><figure class="kt ku kv kw gt kx"><div class="bz fp l di"><div class="nn no l"/></div><p class="le lf gj gh gi lg lh bd b be z dk translated"><a class="ae li" href="https://github.com/ThomasAlbin/gistyc/blob/main/.github/workflows/gist-push.yml" rel="noopener ugc nofollow" target="_blank"> gist-push.yml </a></p></figure><p id="7ffc" class="pw-post-body-paragraph mb mc it md b me ni ke mg mh nj kh mj mk nk mm mn mo nl mq mr ms nm mu mv mw im bi translated">这个YAML文件可以适用于任何其他GitHub存储的项目。您需要设置一个包含GIST标记的项目密码。此外，您还可以添加更多功能，例如，使用<a class="ae li" href="https://docs.pytest.org/en/stable/" rel="noopener ugc nofollow" target="_blank"><strong class="md je">pytest</strong></a><strong class="md je">测试您的Python脚本。现在，在成功合并到主分支之后，您就可以自动创建和/或更新GISTs了。也可以随意更改示例目录。</strong></p></div><div class="ab cl np nq hx nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="im in io ip iq"><h1 id="a15a" class="lj lk it bd ll lm pe lo lp lq pf ls lt kj pg kk lv km ph kn lx kp pi kq lz ma bi translated">进一步的支持和想法</h1><p id="5976" class="pw-post-body-paragraph mb mc it md b me mf ke mg mh mi kh mj mk ml mm mn mo mp mq mr ms mt mu mv mw im bi translated">官方的<em class="nw"> gistyc </em>库提供了一个示例目录和所示的GitHub动作YAML文件。如果您需要任何帮助或有任何想法，请使用GitHub <a class="ae li" href="https://github.com/ThomasAlbin/gistyc/issues" rel="noopener ugc nofollow" target="_blank">问题</a>页面，在本文下方写下评论或在<a class="ae li" href="https://twitter.com/MrAstroThomas" rel="noopener ugc nofollow" target="_blank"> Twitter </a>上给我发消息。</p><h2 id="1f42" class="nc lk it bd ll pj pk dn lp pl pm dp lt mk pn po lv mo pp pq lx ms pr ps lz iz bi translated">贡献</h2><p id="f3d0" class="pw-post-body-paragraph mb mc it md b me mf ke mg mh mi kh mj mk ml mm mn mo mp mq mr ms mt mu mv mw im bi translated">另外，随时欢迎投稿！需要做一些事情，比如CLI的代码块分隔参数，或者替换“<em class="nw"> gistyc </em>只考虑Python文件”——这是一个更通用的解决方案的功能。</p><p id="b94f" class="pw-post-body-paragraph mb mc it md b me ni ke mg mh nj kh mj mk nk mm mn mo nl mq mr ms nm mu mv mw im bi translated">请从一开始就为每个功能或测试驱动开发(TDD)风格的工作添加测试。严格执行PEP8标准、静态类型和其他要求，并对每个拉取请求进行检查。所有测试项目的列表可以在<a class="ae li" href="https://github.com/ThomasAlbin/gistyc/blob/main/.github/workflows/python-package.yml" rel="noopener ugc nofollow" target="_blank">YAML文件</a>中找到。相应的配置文件存储在存储库的根目录中。</p></div><div class="ab cl np nq hx nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="im in io ip iq"><p id="24c5" class="pw-post-body-paragraph mb mc it md b me ni ke mg mh nj kh mj mk nk mm mn mo nl mq mr ms nm mu mv mw im bi translated">现在，我祝大家编码愉快。我期待您的评论和反馈，</p><p id="54ab" class="pw-post-body-paragraph mb mc it md b me ni ke mg mh nj kh mj mk nk mm mn mo nl mq mr ms nm mu mv mw im bi translated">托马斯</p></div></div>    
</body>
</html>