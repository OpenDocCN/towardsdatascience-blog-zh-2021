<html>
<head>
<title>Revisiting My Meta-Programmed Plotting Library!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">重访我的元编程绘图库！</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/revisiting-my-meta-programmed-plotting-library-c6802d0171c0?source=collection_archive---------32-----------------------#2021-05-02">https://towardsdatascience.com/revisiting-my-meta-programmed-plotting-library-c6802d0171c0?source=collection_archive---------32-----------------------#2021-05-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="7f06" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">Hone.jl</h2><div class=""/><div class=""><h2 id="6bbc" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">回顾一下我过去做过的一个非常酷的项目！</h2></div><h1 id="0ed9" class="kr ks it bd kt ku kv kw kx ky kz la lb ki lc kj ld kl le km lf ko lg kp lh li bi translated">介绍</h1><p id="405f" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">一年多以前，我开始用Julia编程语言开发一个新项目。该项目旨在作为主要的实践，以及证明语言中的一些概念和想法，同时也用Julia的范式和方法进行一些实验。该项目名为Hone.jl，Hone.jl是一个面向对象的图形库，使用高级声明性调用来创建元代码。这有一些缺点，主要是Julia在一定数量的重复代码后中断了解释。如果您想阅读我写的介绍该软件的文章，您可以在这里查看:</p><div class="mf mg gp gr mh mi"><a rel="noopener follow" target="_blank" href="/introducing-hone-a-modular-object-oriented-graphing-library-for-julia-823b028b462a"><div class="mj ab fo"><div class="mk ab ml cl cj mm"><h2 class="bd jd gy z fp mn fr fs mo fu fw jc bi translated">介绍Hone:一个面向对象的模块化图形库</h2><div class="mp l"><h3 class="bd b gy z fp mn fr fs mo fu fw dk translated">为Julia对我的图形库的第一个版本进行最后的润色。</h3></div><div class="mq l"><p class="bd b dl z fp mn fr fs mo fu fw dk translated">towardsdatascience.com</p></div></div><div class="mr l"><div class="ms l mt mu mv mr mw mx mi"/></div></div></a></div><p id="058d" class="pw-post-body-paragraph lj lk it ll b lm my kd lo lp mz kg lr ls na lu lv lw nb ly lz ma nc mc md me im bi translated">不管这些问题，我认为这是一个超级酷的项目！不仅如此，编程真的很有趣！本着这个包已经正式推出一年的精神，我决定回去看看这个包是如何工作的，以及它能够产生什么样的结果。如果您想尝试使用Hone.jl，或者查看我将在本文中使用的代码，您可以在Github上查看它，或者查看我用来生成本文中的结果的笔记本:</p><blockquote class="nd"><p id="76b6" class="ne nf it bd ng nh ni nj nk nl nm me dk translated"><a class="ae nn" href="https://github.com/emmettgb/Emmetts-DS-NoteBooks/blob/master/Julia/revisiting%20Hone.ipynb" rel="noopener ugc nofollow" target="_blank">笔记本</a></p></blockquote><div class="no np nq nr ns mi"><a href="https://github.com/emmettgb/Hone.jl" rel="noopener  ugc nofollow" target="_blank"><div class="mj ab fo"><div class="mk ab ml cl cj mm"><h2 class="bd jd gy z fp mn fr fs mo fu fw jc bi translated">emmettgb/Hone.jl</h2><div class="mp l"><h3 class="bd b gy z fp mn fr fs mo fu fw dk translated">Julia的面向对象图形模块化库[已弃用] Permalink无法加载最新提交信息…</h3></div><div class="mq l"><p class="bd b dl z fp mn fr fs mo fu fw dk translated">github.com</p></div></div><div class="mr l"><div class="nt l mt mu mv mr mw mx mi"/></div></div></a></div><h1 id="3bdb" class="kr ks it bd kt ku kv kw kx ky kz la lb ki lc kj ld kl le km lf ko lg kp lh li bi translated">高级接口</h1><p id="0540" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">为了使用Hone.jl，我们需要添加这个包。它不在Julia General注册表中，所以我们必须通过git添加它:</p><pre class="nu nv nw nx gt ny nz oa ob aw oc bi"><span id="22b2" class="od ks it nz b gy oe of l og oh">julia&gt; ]<br/>pkg&gt; add <a class="ae nn" href="https://github.com/emmettgb/Hone.jl.git" rel="noopener ugc nofollow" target="_blank">https://github.com/emmettgb/Hone.jl.git</a></span></pre><p id="89bf" class="pw-post-body-paragraph lj lk it ll b lm my kd lo lp mz kg lr ls na lu lv lw nb ly lz ma nc mc md me im bi translated">现在，在我的笔记本中，我将使用DataFrames.jl创建一个新的数据框:</p><pre class="nu nv nw nx gt ny nz oa ob aw oc bi"><span id="8851" class="od ks it nz b gy oe of l og oh">using DataFrames<br/>df = DataFrame(:A =&gt; randn(20), :B =&gt; randn(20), :C =&gt; randn(20))</span></pre><p id="e60f" class="pw-post-body-paragraph lj lk it ll b lm my kd lo lp mz kg lr ls na lu lv lw nb ly lz ma nc mc md me im bi translated">现在我们可以使用Hone:</p><pre class="nu nv nw nx gt ny nz oa ob aw oc bi"><span id="4e4f" class="od ks it nz b gy oe of l og oh">using Hone</span></pre><p id="4f58" class="pw-post-body-paragraph lj lk it ll b lm my kd lo lp mz kg lr ls na lu lv lw nb ly lz ma nc mc md me im bi translated">包中的所有内容都被导出，所以我们现在可以使用？()方法。Hone.jl非常酷的一点是它是模块化的。这意味着我们可以单独创建散点图的各个部分，甚至可以随心所欲地添加新的形状。记住这一点，让我们来看看这个圆形:</p><pre class="nu nv nw nx gt ny nz oa ob aw oc bi"><span id="6f5b" class="od ks it nz b gy oe of l og oh">?(Circle)</span></pre><figure class="nu nv nw nx gt oj gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/1d388d9563df585223c8c66fb5d6c495.png" data-original-src="https://miro.medium.com/v2/resize:fit:888/format:webp/1*eBg7pGI_NUVTmkig7MAMcw.png"/></div><p class="ol om gj gh gi on oo bd b be z dk translated">作者图片</p></figure><p id="ac76" class="pw-post-body-paragraph lj lk it ll b lm my kd lo lp mz kg lr ls na lu lv lw nb ly lz ma nc mc md me im bi translated">我们现在将使用这些参数做一个圆。</p><pre class="nu nv nw nx gt ny nz oa ob aw oc bi"><span id="ad7c" class="od ks it nz b gy oe of l og oh">shape1 = Circle(.5, .5, .08, :orange)</span></pre><p id="0870" class="pw-post-body-paragraph lj lk it ll b lm my kd lo lp mz kg lr ls na lu lv lw nb ly lz ma nc mc md me im bi translated">我们可以使用show()函数显示圆:</p><pre class="nu nv nw nx gt ny nz oa ob aw oc bi"><span id="89fd" class="od ks it nz b gy oe of l og oh">shape1.show()</span></pre><figure class="nu nv nw nx gt oj gh gi paragraph-image"><div class="gh gi op"><img src="../Images/5f938f68d9858cd41c8771b9e232cebf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1066/format:webp/1*307eohGihULigy7OPT8z5Q.png"/></div><p class="ol om gj gh gi on oo bd b be z dk translated">作者图片</p></figure><p id="45ff" class="pw-post-body-paragraph lj lk it ll b lm my kd lo lp mz kg lr ls na lu lv lw nb ly lz ma nc mc md me im bi translated">由于我们的数据框具有多个要素，我们应该制作另一个形状以便绘制其他要素。我还会把这个做得小一点:</p><pre class="nu nv nw nx gt ny nz oa ob aw oc bi"><span id="835c" class="od ks it nz b gy oe of l og oh">shape1 = Circle(.5, .5, .02, :orange)<br/>shape2 = Circle(.5, .5, .04, :red)<br/>shape2.show()</span></pre><figure class="nu nv nw nx gt oj gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/34150f4e86848874aeac3f30c3f2cb30.png" data-original-src="https://miro.medium.com/v2/resize:fit:964/format:webp/1*RS8hHBT7ZMRrKTCemm9Dsg.png"/></div><p class="ol om gj gh gi on oo bd b be z dk translated">作者图片</p></figure><p id="5f5a" class="pw-post-body-paragraph lj lk it ll b lm my kd lo lp mz kg lr ls na lu lv lw nb ly lz ma nc mc md me im bi translated">现在我们将把这两个形状放入一个数组中，我们可以将它作为参数传递到散点图中:</p><pre class="nu nv nw nx gt ny nz oa ob aw oc bi"><span id="5c1e" class="od ks it nz b gy oe of l og oh">shapes = [shape1, shape2]</span></pre><p id="0acb" class="pw-post-body-paragraph lj lk it ll b lm my kd lo lp mz kg lr ls na lu lv lw nb ly lz ma nc mc md me im bi translated">现在看看我们的形状还需要什么，我们将使用相同的？()我们的散点类型方法:</p><pre class="nu nv nw nx gt ny nz oa ob aw oc bi"><span id="22ff" class="od ks it nz b gy oe of l og oh">?(Scatter)</span></pre><figure class="nu nv nw nx gt oj gh gi paragraph-image"><div role="button" tabindex="0" class="os ot di ou bf ov"><div class="gh gi or"><img src="../Images/6c983df157a154803e9790b5888bdea9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CvOPs5B_lsyzBasCkP0h8w.png"/></div></div><p class="ol om gj gh gi on oo bd b be z dk translated">作者图片</p></figure><p id="e335" class="pw-post-body-paragraph lj lk it ll b lm my kd lo lp mz kg lr ls na lu lv lw nb ly lz ma nc mc md me im bi translated">所有这些参数都是位置性的，对于某些参数，我们需要输入一些空值。回过头来看，这是一个糟糕的想法，但我并不介意，因为除了我之外，这个包并不打算由任何人添加，因为与Julia可用的其他包竞争并不一定在Hone.jl的目标列表中。因此，我们将X作为数据帧，y作为数组，并创建一个散点图。不过，我们需要做的第一件事是准备要通过这个函数传递的x数据帧和y数组。为此，我们将首先从我们的数据帧中提取我们的:C数组:</p><pre class="nu nv nw nx gt ny nz oa ob aw oc bi"><span id="a9b2" class="od ks it nz b gy oe of l og oh">y = df[!, :C]</span></pre><p id="fe9e" class="pw-post-body-paragraph lj lk it ll b lm my kd lo lp mz kg lr ls na lu lv lw nb ly lz ma nc mc md me im bi translated">现在我们需要在X数据帧中去掉这一列。我们将使用select()和Not()方法来实现这一点。</p><pre class="nu nv nw nx gt ny nz oa ob aw oc bi"><span id="19da" class="od ks it nz b gy oe of l og oh">x = select(df, Not(:C))</span></pre><p id="6a11" class="pw-post-body-paragraph lj lk it ll b lm my kd lo lp mz kg lr ls na lu lv lw nb ly lz ma nc mc md me im bi translated">现在我们可以做散点图了！</p><pre class="nu nv nw nx gt ny nz oa ob aw oc bi"><span id="56ad" class="od ks it nz b gy oe of l og oh">plot = Scatter(x, y, shapes)</span></pre><figure class="nu nv nw nx gt oj gh gi paragraph-image"><div role="button" tabindex="0" class="os ot di ou bf ov"><div class="gh gi ow"><img src="../Images/928341292a24054d75df30a2ac59e0cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_5rSj6z3_VJsJ7RL5Czq_Q.png"/></div></div><p class="ol om gj gh gi on oo bd b be z dk translated">作者图片</p></figure><blockquote class="nd"><p id="e47f" class="ne nf it bd ng nh ox oy oz pa pb me dk translated">哎呀。</p></blockquote><p id="74de" class="pw-post-body-paragraph lj lk it ll b lm pc kd lo lp pd kg lr ls pe lu lv lw pf ly lz ma pg mc md me im bi translated">看起来这个调用实际上将使用一个符号而不是一个数组，这个符号将调用数据帧上的列。这可能会产生问题，因为该包使用DataFrames.jl的旧版本，该版本可能支持对列进行索引，如下所示:</p><pre class="nu nv nw nx gt ny nz oa ob aw oc bi"><span id="2dc7" class="od ks it nz b gy oe of l og oh">df[:A]</span></pre><p id="49ea" class="pw-post-body-paragraph lj lk it ll b lm my kd lo lp mz kg lr ls na lu lv lw nb ly lz ma nc mc md me im bi translated">但是现在的语法应该是:</p><pre class="nu nv nw nx gt ny nz oa ob aw oc bi"><span id="793f" class="od ks it nz b gy oe of l og oh">df[!, :A]</span></pre><blockquote class="ph pi pj"><p id="88ea" class="lj lk pk ll b lm my kd lo lp mz kg lr pl na lu lv pm nb ly lz pn nc mc md me im bi translated">所以希望我们不会遇到这个问题。如果我们这样做了，我会简单地提供很长时间以来的第一次更新…</p></blockquote><p id="641c" class="pw-post-body-paragraph lj lk it ll b lm my kd lo lp mz kg lr ls na lu lv lw nb ly lz ma nc mc md me im bi translated">事实证明这个包有相当多的问题，为了解决一些问题，我们可能需要深入研究一下。幸运的是，我们完全有能力做到这一点！</p><h1 id="cbef" class="kr ks it bd kt ku kv kw kx ky kz la lb ki lc kj ld kl le km lf ko lg kp lh li bi translated">代码内部</h1><p id="6cc2" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">在我们开始修复这个包之前，我们应该看看里面的实际代码，这些代码实际上已经相当过时了。我知道这使用了装箱类型，这是一种在Julia中使用未知类型创建类型的过时方法，所以我们可能应该使用内部和外部构造函数将其更新为较新的方法。如果你想了解更多关于Julia中构造函数的知识，我也写了一篇文章，你可以点击这里:</p><div class="mf mg gp gr mh mi"><a rel="noopener follow" target="_blank" href="/an-advanced-look-at-constructors-in-julia-5b428882dde8"><div class="mj ab fo"><div class="mk ab ml cl cj mm"><h2 class="bd jd gy z fp mn fr fs mo fu fw jc bi translated">Julia中构造函数的高级视图</h2><div class="mp l"><h3 class="bd b gy z fp mn fr fs mo fu fw dk translated">用Julia完整地看一下如何创建复杂的构造函数。</h3></div><div class="mq l"><p class="bd b dl z fp mn fr fs mo fu fw dk translated">towardsdatascience.com</p></div></div><div class="mr l"><div class="po l mt mu mv mr mw mx mi"/></div></div></a></div><pre class="nu nv nw nx gt ny nz oa ob aw oc bi"><span id="2ace" class="od ks it nz b gy oe of l og oh">git clone <a class="ae nn" href="https://github.com/emmettgb/Hone.jl.git" rel="noopener ugc nofollow" target="_blank">https://github.com/emmettgb/Hone.jl.git</a> --branch Unstable</span></pre><p id="ae21" class="pw-post-body-paragraph lj lk it ll b lm my kd lo lp mz kg lr ls na lu lv lw nb ly lz ma nc mc md me im bi translated">这个包的排列方式有两个函数，_arrayscatter和_dfscatter。这两个方法与Scatter()方法一起被分派来处理不同的类型。使用内部构造函数可以更有效地做到这一点，但是这也是包装在一个完全不同的对象中的，这个对象叫做Frame。因此，我们不将散点图作为一种类型，而是保留分派，只改变框架的类型。举个例子，下面是一个新函数，用于创建包含两个数组的散点图:</p><pre class="nu nv nw nx gt ny nz oa ob aw oc bi"><span id="e848" class="od ks it nz b gy oe of l og oh">function Scatter(x::Array, y::Array; shape = Circle(.5,.5,25),<br/>        grid = Grid(4),<br/>        features = [Axis(:X), Axis(:Y)],<br/>        frame=Frame(1280,720,0mm,0mm),<br/>        )<br/>    points = Points(x, y, frame, shape)<br/>    frame.add(points)<br/>    glabels = GridLabels(x,y, grid)<br/>    frame.add(grid)<br/>    frame.add(glabels)<br/>    for feature in features<br/>        frame.add(feature);<br/>    end<br/>    return(frame)<br/>end</span></pre><p id="2030" class="pw-post-body-paragraph lj lk it ll b lm my kd lo lp mz kg lr ls na lu lv lw nb ly lz ma nc mc md me im bi translated">我更改的另一件事是更新DataFrames.jl调用，以反映最新版本的语法。由于DataFrames.jl没有compat绑定，所以可以假设它将使用最新版本。我还从Frame类型中删除了一些参数，我们现在要重构它。以下是现成的代码:</p><pre class="nu nv nw nx gt ny nz oa ob aw oc bi"><span id="f4c2" class="od ks it nz b gy oe of l og oh">function Frame(width::Int64, height::Int64, lm, bm)<br/>    base = string("compose(context(units=UnitBox(0,0,",<br/>    width, ",",<br/>    height, ",",<br/>    lm, ",", rm,",",<br/>    tm, ",", bm,<br/>        ")),")<br/>    objects = []<br/>    tag = base<br/>    composition = nothing<br/>    add(object) = composition,objects,tag = _frameup(base,objects,object)<br/>    show() = composition<br/>    tree() = introspect(composition)<br/>    save(name) = draw(SVG(name), composition)<br/>    (var)-&gt;(add;show;tag;base;objects;composition;save;tree;width;height;lm;bm;rm;tm)<br/>end</span></pre><p id="7eed" class="pw-post-body-paragraph lj lk it ll b lm my kd lo lp mz kg lr ls na lu lv lw nb ly lz ma nc mc md me im bi translated">我要做的第一件事是从底部去掉上边距和右边距，因为我想我不会再用这个方法了。我将用0替换它们。现在我们需要将它包装在一个可变结构中，并用new()方法传递我们的类型。我们将从在我们的函数上面添加这个开始:</p><pre class="nu nv nw nx gt ny nz oa ob aw oc bi"><span id="2d4d" class="od ks it nz b gy oe of l og oh">mutable struct Frame{A, S, T, SA}<br/>    add::A<br/>    show::S<br/>    tree::T<br/>    save::SA<br/>    tag::String<br/>    objects::Array</span></pre><p id="6311" class="pw-post-body-paragraph lj lk it ll b lm my kd lo lp mz kg lr ls na lu lv lw nb ly lz ma nc mc md me im bi translated">然后，我们将更改用于创建类型的最后一部分，并将其恢复为:</p><pre class="nu nv nw nx gt ny nz oa ob aw oc bi"><span id="8c35" class="od ks it nz b gy oe of l og oh">A, S, T, SA = typeof(add), typeof(show), typeof(tree), typeof(save)<br/>    new{A, S, T, SA}(add, show, tree, save, tag, objects)</span></pre><p id="7480" class="pw-post-body-paragraph lj lk it ll b lm my kd lo lp mz kg lr ls na lu lv lw nb ly lz ma nc mc md me im bi translated">我们也可以用它来创建一个完整的类型层次结构，并进行更多的转换——比如在objects类型中。我们可以将数组{Any}改为类似数组{HoneShape}的形式。现在我要更新并再次尝试使用该软件包！</p><pre class="nu nv nw nx gt ny nz oa ob aw oc bi"><span id="f445" class="od ks it nz b gy oe of l og oh">julia&gt; ]<br/>pkg&gt; update</span></pre><h1 id="582d" class="kr ks it bd kt ku kv kw kx ky kz la lb ki lc kj ld kl le km lf ko lg kp lh li bi translated">结论</h1><p id="3c35" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">现在我们终于可以创建一个散点图，如下所示:</p><pre class="nu nv nw nx gt ny nz oa ob aw oc bi"><span id="3f70" class="od ks it nz b gy oe of l og oh">plot = Scatter(df[!, :A], df[!, :B], shape = shapes[1], grid = Grid(4),<br/>    frame = frame)</span></pre><figure class="nu nv nw nx gt oj gh gi paragraph-image"><div role="button" tabindex="0" class="os ot di ou bf ov"><div class="gh gi pp"><img src="../Images/b01db342a6ece94ee3f4e17fb3d7dc49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yzGMJMMsC74GS5EM855d4g.png"/></div></div><p class="ol om gj gh gi on oo bd b be z dk translated">作者图片</p></figure><p id="7d07" class="pw-post-body-paragraph lj lk it ll b lm my kd lo lp mz kg lr ls na lu lv lw nb ly lz ma nc mc md me im bi translated">我认为这是一个非常酷和有趣的项目，有很大的潜力。做了一点工作后，我真的很好奇我能在这个包中实现多长时间的功能！我很想知道是否有人认为我应该继续在这个方案上工作，或者我应该让它保持原样并继续前进。你怎么想呢?我想把事情进一步与互动和可能的动画，以及更多的图形功能。我在Twitter上发起了一个投票，你可以提供你的答案！您可以在此查看投票结果并进行投票:</p><figure class="nu nv nw nx gt oj"><div class="bz fp l di"><div class="pq pr l"/></div></figure><blockquote class="nd"><p id="bba0" class="ne nf it bd ng nh ox oy oz pa pb me dk translated">感谢您的阅读！</p></blockquote></div></div>    
</body>
</html>