<html>
<head>
<title>Flattening JSON records using PySpark</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用PySpark展平JSON记录</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/flattening-json-records-using-pyspark-b83137669def?source=collection_archive---------1-----------------------#2021-05-01">https://towardsdatascience.com/flattening-json-records-using-pyspark-b83137669def?source=collection_archive---------1-----------------------#2021-05-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="f6e1" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用Apache PySpark通过嵌套模式结构扁平化JSON数据</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/5584a641c913e9b0a42def21ab8143fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7jZel5MFtByPM_G_"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@impatrickt?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">帕特里克·托马索</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><h1 id="e93b" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">介绍</h1><p id="ddcb" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">JavaScript Object Notation (JSON)是一种基于文本的、灵活的、轻量级的数据交换格式，用于半结构化数据。它大量用于在服务器、web应用程序和联网设备之间传输数据。</p><p id="3976" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">通常，由服务或产品生成的事件都是JSON格式的。这些JSON记录可以有多层嵌套、数组类型的字段，这些字段又有自己的模式。此外，这些字段中有些是必填的，有些是可选的。因此，检索模式并只提取所需的列变成了一项单调乏味的任务。</p><p id="93ec" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">本文介绍了一种方法，可以最大限度地减少检索JSON记录的模式以提取特定列的工作量，并展平作为输入传递的整个JSON数据。</p></div><div class="ab cl mp mq hu mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ij ik il im in"><h1 id="8ed1" class="kw kx iq bd ky kz mw lb lc ld mx lf lg jw my jx li jz mz ka lk kc na kd lm ln bi translated">履行</h1><p id="020b" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">假设两个人从一个在线交付平台订购了商品，生成的事件作为ORC文件被转储到S3的一个位置，这里是<code class="fe nb nc nd ne b">s3://mybucket/orders/</code>。要读取这些记录，请执行这段代码:</p><pre class="kg kh ki kj gt nf ne ng nh aw ni bi"><span id="b044" class="nj kx iq ne b gy nk nl l nm nn">df = spark.read.orc('s3://mybucket/orders/')</span></pre><p id="4320" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">当您执行<code class="fe nb nc nd ne b">df.show(5, False)</code>时，它最多显示5条记录，而不会截断每一列的输出。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi no"><img src="../Images/668c928a4faf244b6f5492d00c1d42e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z-mLJKKYqi_rTHEhPDBnWw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">JSON记录</p></figure><p id="4521" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">让我们打印JSON的模式并可视化它。为此，执行这段代码:</p><pre class="kg kh ki kj gt nf ne ng nh aw ni bi"><span id="89ff" class="nj kx iq ne b gy nk nl l nm nn">json_df = spark.read.json(df.rdd.map(lambda row: row.json))<br/>json_df.printSchema()</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi np"><img src="../Images/6c140e07e48c77d5a9f3d3ac867938a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gXoapd4Yv4kPFUNS8kj2aA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">JSON模式</p></figure><blockquote class="nq nr ns"><p id="fa6d" class="lo lp nt lq b lr mk jr lt lu ml ju lw nu mm lz ma nv mn md me nw mo mh mi mj ij bi translated"><strong class="lq ir">注意:</strong>从一个路径中读取一个文件集合可以确保在那些文件中存储的所有记录上捕获一个全局模式。</p></blockquote><p id="0771" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">JSON模式可以被视为一棵树，其中每个字段都可以被视为一个节点。如果一个字段包含子字段，那么该节点可以被认为具有多个子节点。该模式的树如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nx"><img src="../Images/3ba860149816af5d54336f04eb69c595.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RYSxrLNM5gR25gR7eHG4ug.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">JSON模式的树形可视化</p></figure><p id="66d7" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">JSON数据中的第一条记录属于一个名叫<code class="fe nb nc nd ne b">John</code>的人，他订购了2件商品。第二条记录属于订购了3件商品的<code class="fe nb nc nd ne b">Chris</code>。我们算法的期望是提取所有字段并生成总共5条记录，每条记录对应一个项目。</p><p id="b70a" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">展平这些JSON记录的关键是获得:</p><ol class=""><li id="0854" class="ny nz iq lq b lr mk lu ml lx oa mb ob mf oc mj od oe of og bi translated">每个<strong class="lq ir"> <em class="nt">叶节点</em> </strong>的路径(这些节点可以是string、bigint或timestamp等。类型，但不是结构类型或数组类型)</li><li id="4504" class="ny nz iq lq b lr oh lu oi lx oj mb ok mf ol mj od oe of og bi translated"><strong class="lq ir"> <em class="nt">展开顺序</em> </strong>(数组类型时，提供列展开的顺序)。</li><li id="76c2" class="ny nz iq lq b lr oh lu oi lx oj mb ok mf ol mj od oe of og bi translated"><strong class="lq ir"> <em class="nt">打开顺序</em> </strong>(如果struct-type是array-type的父级，则提供打开列的顺序)。</li></ol><h2 id="4c34" class="nj kx iq bd ky om on dn lc oo op dp lg lx oq or li mb os ot lk mf ou ov lm ow bi translated">代码实现</h2><p id="c228" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">使用火花配置至关重要:</p><pre class="kg kh ki kj gt nf ne ng nh aw ni bi"><span id="682a" class="nj kx iq ne b gy nk nl l nm nn">--conf spark.sql.caseSensitive=True</span></pre><p id="840e" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">由于可能有不同的字段，考虑到spark的默认不区分大小写，具有相同的叶名称(例如产品&amp; Product)是本质上不同的字段，但由于spark的默认不区分大小写属性，被认为是相同的。</p><p id="3cff" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">首先导入必要的库:</p><pre class="kg kh ki kj gt nf ne ng nh aw ni bi"><span id="e6fb" class="nj kx iq ne b gy nk nl l nm nn">import json</span></pre><p id="c0d9" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">接下来，定义类变量:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ox oy l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">类别变量</p></figure><p id="4553" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">其中<code class="fe nb nc nd ne b">get_fields_in_json</code>函数定义为:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ox oy l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">get _ fields _ in _ json</p></figure><p id="2296" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">下面给出了每个类变量的简要说明:</p><ol class=""><li id="9ce6" class="ny nz iq lq b lr mk lu ml lx oa mb ob mf oc mj od oe of og bi translated"><code class="fe nb nc nd ne b">fields_in_json</code>:该变量包含模式中字段的元数据。</li><li id="6db7" class="ny nz iq lq b lr oh lu oi lx oj mb ok mf ol mj od oe of og bi translated"><code class="fe nb nc nd ne b">all_fields</code>:该变量包含叶字段的路径和将出现在扁平数据帧中的列名之间的1-1映射。</li><li id="69a3" class="ny nz iq lq b lr oh lu oi lx oj mb ok mf ol mj od oe of og bi translated"><code class="fe nb nc nd ne b">cols_to_explode</code>:该变量是包含数组类型字段路径的集合。</li><li id="77b3" class="ny nz iq lq b lr oh lu oi lx oj mb ok mf ol mj od oe of og bi translated"><code class="fe nb nc nd ne b">structure</code>:该变量是一个字典，用于逐步节点遍历到<code class="fe nb nc nd ne b">cols_to_explode</code>中的数组类型字段。</li><li id="8be0" class="ny nz iq lq b lr oh lu oi lx oj mb ok mf ol mj od oe of og bi translated"><code class="fe nb nc nd ne b">order</code>:这是一个包含数组类型字段展开顺序的列表。<em class="nt">如果数组类型在结构类型内部，则结构类型必须首先打开，因此必须出现在数组类型之前。</em></li><li id="1372" class="ny nz iq lq b lr oh lu oi lx oj mb ok mf ol mj od oe of og bi translated"><code class="fe nb nc nd ne b">bottom_to_top</code>:这包含一个字典，其中每个键映射到每个数组类型/结构类型字段的互斥叶字段列表<em class="nt">(如果结构类型字段是数组类型字段的父字段)。</em></li><li id="f13a" class="ny nz iq lq b lr oh lu oi lx oj mb ok mf ol mj od oe of og bi translated"><code class="fe nb nc nd ne b">rest</code>:包含可直接访问的字段，无论有无点符号。</li></ol><p id="0a23" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">然后，所有这些类变量都用于执行字段的分解/打开。但是这些类变量是如何计算的呢？让我们逐步分析一下。</p><p id="1b85" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><strong class="lq ir">步骤1: </strong>当从<code class="fe nb nc nd ne b">AutoFlatten</code>类的对象调用<code class="fe nb nc nd ne b">compute</code>函数时，类变量得到更新，其中compute函数定义如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ox oy l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">计算</p></figure><p id="24d8" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">每个类变量看起来都像这样:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi no"><img src="../Images/847b63fda4f069a784e196f4ce89e24d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0FJC2J2tFc5Be7j7uaghSA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">类别变量(图像)</p></figure><p id="ba10" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><strong class="lq ir">步骤2:</strong><code class="fe nb nc nd ne b">unnest_dict</code>函数递归地解除<code class="fe nb nc nd ne b">json_schema </code>中字典的嵌套，每当遇到叶节点时，将字段的层次路径映射到<code class="fe nb nc nd ne b">all_fields</code>字典中的列名(在 <code class="fe nb nc nd ne b"><em class="nt">is_leaf</em></code> <em class="nt">函数</em>中完成<em class="nt">检查)。此外，它还存储了<code class="fe nb nc nd ne b">cols_to_explode</code>集合中数组类型字段的路径。</em></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ox oy l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">是叶子</p></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ox oy l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">unnest_dict</p></figure><p id="a880" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><strong class="lq ir">步骤3: </strong>接下来，通过检查<code class="fe nb nc nd ne b">all_fields</code>的元素是否以<code class="fe nb nc nd ne b">cols_to_explode</code>中的任何元素开始来获得所有的叶字段，并将其存储在<code class="fe nb nc nd ne b">all_cols_in_explode_cols</code>中。</p><p id="a15b" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><strong class="lq ir">步骤4: </strong>使用<code class="fe nb nc nd ne b">all_cols_in_explode_cols</code>，<code class="fe nb nc nd ne b">rest</code>被计算，其包含使用或不使用点符号可直接访问的字段，使用简单的集合差运算。</p><p id="2a2c" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><strong class="lq ir">步骤5: </strong>现在，使用<code class="fe nb nc nd ne b">cols_to_explode</code>来计算<code class="fe nb nc nd ne b">structure</code>，该<code class="fe nb nc nd ne b">cols_to_explode</code>用于逐步遍历节点以到达数组类型字段。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ox oy l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">获取_结构</p></figure><p id="676e" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><strong class="lq ir">步骤6: </strong>接下来，对<code class="fe nb nc nd ne b">structure</code>执行BFS遍历，以获得数组分解必须发生的顺序，该顺序存储在<code class="fe nb nc nd ne b">order</code>类变量中。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ox oy l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">提取_订单</p></figure><p id="d77e" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><strong class="lq ir">第7步:</strong>最后用<code class="fe nb nc nd ne b">order</code>和<code class="fe nb nc nd ne b">all_cols_in_explode_cols</code>获取<code class="fe nb nc nd ne b">order</code>中每个元素的所有<strong class="lq ir"> <em class="nt">互斥字段</em> </strong>。为此，使用自下而上的方法，即<code class="fe nb nc nd ne b">order</code>列表被反转，并且<code class="fe nb nc nd ne b">order</code>中每个字段内的叶字段被映射并存储在<code class="fe nb nc nd ne b">bottom_to_top</code>中。<em class="nt">注意</em> <code class="fe nb nc nd ne b"><em class="nt">'.order_details'</em></code> <em class="nt">键在</em> <code class="fe nb nc nd ne b"><em class="nt">bottom_to_top</em></code> <em class="nt">中没有元素它。如果它下面有叶节点，这些节点将可以直接访问并出现在</em> <code class="fe nb nc nd ne b"><em class="nt">rest</em></code> <em class="nt">中。</em></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ox oy l"/></div></figure><p id="bc02" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">结合所有的函数，这个类看起来像这样:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ox oy l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">AutoFlatten类</p></figure><p id="fca6" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">为了利用类变量来打开/分解，执行以下代码块:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ox oy l"/></div></figure><p id="974a" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这里，从S3路径读取JSON记录，并计算全局模式。然后，在创建初始化所有类变量的<code class="fe nb nc nd ne b">AutoFlatten</code>类的对象时，传递这个模式。当从<code class="fe nb nc nd ne b">AutoFlatten</code>类的对象调用<code class="fe nb nc nd ne b">compute</code>函数时，类变量被更新。</p><p id="d45b" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">打开/分解时，所有第一级列被选中，并且<code class="fe nb nc nd ne b">rest</code>中的列尚未出现。目标名称上有一个计数器，它对重复的目标列名称进行计数。任何计数大于1的目标列名都被重命名为<code class="fe nb nc nd ne b">&lt;path_to_target_field&gt;</code>，每个级别用一个<code class="fe nb nc nd ne b">&gt;</code>隔开。这些字段的所有路径都被添加到<code class="fe nb nc nd ne b">visited</code>路径集中。</p><p id="18f5" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">然后检查<code class="fe nb nc nd ne b">order</code>是否为空。空的<code class="fe nb nc nd ne b">order</code>列表意味着模式中没有数组类型的字段，反之亦然。如果<code class="fe nb nc nd ne b">order</code>列表不为空，则遍历<code class="fe nb nc nd ne b">order</code>中的每个元素，并基于其类型数组/结构<em class="nt">(仅当数组类型字段是结构类型字段的子字段时出现)</em>，分别展开/打开列，并且仅选择那些尚未出现的列。此外，重复的目标列名由<code class="fe nb nc nd ne b">&lt;path_to_target_field&gt;</code>替换，每个级别由<code class="fe nb nc nd ne b">&gt;</code>分隔，这些字段的路径被添加到<code class="fe nb nc nd ne b">visited</code>路径集中。</p><p id="e00c" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我们来看看<code class="fe nb nc nd ne b">final_df</code>里出现了哪些栏目。</p><pre class="kg kh ki kj gt nf ne ng nh aw ni bi"><span id="d206" class="nj kx iq ne b gy nk nl l nm nn">&gt;&gt;&gt; final_df.columns<br/>['city', 'country', 'house_number', 'street', 'pincode', 'state', 'email', 'id', 'name', 'discount', 'order_details&gt;id', 'price', 'product_name', 'quantity', 'ordered_time']</span></pre><p id="9d49" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">由于<code class="fe nb nc nd ne b">order_details</code>字段中的<code class="fe nb nc nd ne b">id</code>是重复的，因此将其重命名为<code class="fe nb nc nd ne b">order_details&gt;id</code>。</p><p id="0af8" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">查看初始数据帧<code class="fe nb nc nd ne b">df</code>和<code class="fe nb nc nd ne b">final_df</code>数据帧的计数，我们知道阵列爆炸已经正确发生。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oz"><img src="../Images/ea831c3e0ad7107472855b11cb4b5809.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qLXY_7Kf1rGeKJ9dF2U7Sg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">数据帧计数</p></figure><p id="9b19" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">现在让我们通过查看属于<code class="fe nb nc nd ne b">final_df</code>数据帧的记录来进行验证。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi no"><img src="../Images/592097fb83137ffb50ef179cdb1fd335.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9Vs3xVYoilpvrdKHlz8kog.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">最终_测向数据帧</p></figure><p id="dbf8" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">如您所见，购买的每件商品都有一条记录，并且该算法按预期工作。</p></div><div class="ab cl mp mq hu mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ij ik il im in"><h1 id="6eff" class="kw kx iq bd ky kz mw lb lc ld mx lf lg jw my jx li jz mz ka lk kc na kd lm ln bi translated">注意事项</h1><p id="ef49" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">使用这种方法时，需要记住一些事情。</p><ol class=""><li id="d2a1" class="ny nz iq lq b lr mk lu ml lx oa mb ob mf oc mj od oe of og bi translated">所有的目标列名都是通过使用JSON模式的元数据中的叶节点名来检索的。</li><li id="d902" class="ny nz iq lq b lr oh lu oi lx oj mb ok mf ol mj od oe of og bi translated">如果您在受约束的环境中工作，则在执行拼合后，必须根据合规标准更改列名。</li><li id="6acd" class="ny nz iq lq b lr oh lu oi lx oj mb ok mf ol mj od oe of og bi translated">合并<code class="fe nb nc nd ne b">regexp_replace</code>、<code class="fe nb nc nd ne b">epoch to timestamp conversion</code>、<code class="fe nb nc nd ne b">string to timestamp conversion</code>等被视为对从每一列提取的原始数据的定制转换。因此，它必须在执行<em class="nt">自动展平</em>操作后由开发者定义。</li><li id="3af5" class="ny nz iq lq b lr oh lu oi lx oj mb ok mf ol mj od oe of og bi translated">注意不要暴露个人身份信息(PII)列，因为此机制会暴露所有列。您必须对这些列执行定制操作，比如散列。</li></ol></div><div class="ab cl mp mq hu mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ij ik il im in"><p id="4de2" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">就是这样！我希望这能帮助那些希望简化JSON数据而不需要定义和传递模式来提取所需字段的人，以及那些希望学习新知识的人。</p><p id="5fe0" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">感谢<a class="pa pb ep" href="https://medium.com/u/819a37e8be1b?source=post_page-----b83137669def--------------------------------" rel="noopener" target="_blank"> Sandesh </a>在这件事上与我合作！</p><p id="b916" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">干杯！</p><p id="ce9d" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><strong class="lq ir">更新</strong>:大家好，上面描述的操作是开始了解核心autoflatten机制的好方法。我已经为这里的设计了一个优化的方法(其关键或多或少是相同的),与文章中描述的方法相比，它避免了占用大量内存。您可以通过调用返回展平数据帧的<code class="fe nb nc nd ne b">execute</code>函数开始。如果您有任何问题，请随时联系我！</p></div></div>    
</body>
</html>