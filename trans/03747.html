<html>
<head>
<title>3 tips to handle timestamps in C</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">处理C中时间戳的3个技巧</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/3-tips-to-handle-timestamps-in-c-ad5b36892294?source=collection_archive---------8-----------------------#2021-03-28">https://towardsdatascience.com/3-tips-to-handle-timestamps-in-c-ad5b36892294?source=collection_archive---------8-----------------------#2021-03-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e417" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">处理时间序列中时区的简明指南</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5217440e3cc58aa23095b0b5acc113b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Rm0wVLNA0taCsMer.jpg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来自<a class="ae ky" href="https://en.wikipedia.org/wiki/UTC%2B08:45#/media/File:Entering_Central_Western_Time_Zone.jpg" rel="noopener ugc nofollow" target="_blank">维基媒体</a>的图像。许可证CC BY-SA 4.0</p></figure><p id="dc61" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">无论是谁在时间序列分析中处理了带有时区的时间戳，总是会遇到一些令人头痛的问题。无论我处理时间序列多少次(在我的例子中不变地涉及处理时区)，我总是必须重新审视它是如何工作的，因为它通常是反直觉的。</p><h1 id="23c5" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">需求</h1><p id="8930" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">处理时间序列通常涉及处理不同的时区。即使只使用一个时区，您可能仍然希望可视化您当地时区的数据，这可能会根据用户所在的国家而变化。</p><p id="d84c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种情况使得使用世界协调时作为参考很方便。为什么？因为它不会经历夏令时变化，并且很容易转换到任何时区。</p><p id="dd93" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就如何表示时间戳而言，它可以是:</p><ul class=""><li id="794e" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu mx my mz na bi translated">语言特定的日期时间对象，</li><li id="2be4" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">基于整数的人类可读格式(即日期为20210126，时间为1530)，</li><li id="6c1e" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">人类可读文本格式(即1999–01–01t 00:00:29.75)，</li><li id="0dd5" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">UNIX纪元时间。</li></ul><p id="5bbf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我更喜欢最新的，因为它简化了时间的计算。要迭代一分钟，你只需要将你所处理的时间光标增加60。它还精确地定义了时间中的某个时刻。如果您有数百Gb或Tb的数据，纯数字表示是可行的方法。</p><p id="a40b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我将为这种情况提供一些例子，所有的例子都可以在文档和问答论坛中找到——这里没有什么新的或奇特的东西——但是这些信息经常被隐藏在其他解释中，通常是像将特定的本地化时间戳转换为UNIX Epoch这样简单的事情，而相反的事情并不像应该的那样简单。</p><h1 id="f859" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">时间戳需要时区</h1><p id="bcb7" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">如果你说是【2021年3月28日09:30 并且你认为你完成了，那你就错了。接下来的答案是，好的，是【2021年3月28日09:30 ，但是<strong class="lb iu"> <em class="ng">在哪里</em> </strong>？每个时间戳必须有一个位置或时区，可以是隐式的(按照惯例，该数据库中的所有时间戳都使用法兰克福时间),也可以是显式的。所以，如果你提供数据，帮你自己和其他人一个忙，做一个明确说明包含时间戳的时区的练习。这可能是显而易见的，但我向您保证，我所看到的涉及时间戳的数据集有一半以上都缺少这种信息。</p><h1 id="74e7" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">时区不是给定地点的时间</h1><p id="0b13" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我在处理这个问题时发现的第一个错误是很容易混淆概念。您经常会听到诸如“法兰克福比纽约早5个小时”或“纽约时区是美国东部时间”之类的错误说法。</p><p id="9022" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">法兰克福有时比纽约早5个小时，但在其他地方则是6个小时，具体时间取决于您所处理的具体年份。</p><p id="4da2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">纽约不是东部时间，纽约有一半时间是东部时间，另一半时间是东部时间。过渡发生的时间每年都不一样，甚至在不久的将来会消失。</p><p id="e4c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">东部时间不是东部时间，而是东部标准时间(当然也不是我听说的“复活节时间”)。如果你想说东部时间，那就是东部时间。</p><p id="cf9a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">犯这样的错误是可以的，因为我们都是从那里开始的，但是这些错误需要尽快改正，否则你将会做错误的计算。</p><p id="90fa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我发现处理与特定地点相关的时间序列(在我的行业中，是在给定交易所交易的金融数据)的最简单方法是处理实际的地区/城市。因此，说“纽约时间”意味着它将是美国东部时间或美国东部时间，这取决于具体的年份和日期，但时间戳是正确定义的。这通常也是存储数据的正确方法，因为无论发生什么情况，在给定的时间都会发生许多事件。股票交易所通常在每天9:30开门，你在每天下午的同一时间为你的孩子跑步，他们不会根据是否遵守夏令时来修改它。</p><p id="69ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">指定时区可能无法唯一地定义某个时刻，因为在夏令时调整期间，可能不清楚您指定的确切时刻，但所有夏令时调整都发生在周末。如果您的数据缺少周末(比如来自许多业务相关领域的数据)，那么您就不会关心这个细节。</p><p id="48b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果夏令时的变化很重要，因为您的数据可能发生在周末，那么您必须始终使用UTC，因为它不会经历任何变化。这就是为什么军方使用祖鲁语时间的原因，因为这是一种全球共享的指定时间的方式。</p><blockquote class="nh ni nj"><p id="42ca" class="kz la ng lb b lc ld ju le lf lg jx lh nk lj lk ll nl ln lo lp nm lr ls lt lu im bi translated"><strong class="lb iu">提示1 </strong>:当你指定一个时间戳的时候，一定要指定这个时间属于哪个特定的地点(城市)。如果您的时间序列涉及周末，请使用UTC。</p></blockquote><h1 id="c67b" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">使用UNIX纪元</h1><p id="9e3d" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">UNIX纪元时间被定义为自1970年1月1日00:00 UTC以来经过的秒数。请注意，UNIX Epoch是UTC，因此它可以准确无误地识别特定的时刻。永远不要询问UNIX epoch时间戳的时区，根据定义它是UTC。</p><p id="c10b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关于UNIX纪元的一个特别的警告是闰秒，但是除非您必须处理闰秒，否则UNIX纪元很好。还要记住，当使用32位有符号整数时，UNIX epoch可以表示多达2038个时间戳的时间。有关详细信息，请参见[1],但通常这些限制不会对您的应用产生影响。</p><blockquote class="nh ni nj"><p id="2930" class="kz la ng lb b lc ld ju le lf lg jx lh nk lj lk ll nl ln lo lp nm lr ls lt lu im bi translated"><strong class="lb iu">提示2 </strong> : UNIX epoch时间戳是一种存储给定时刻的便捷方式，它们通常足够准确，并且允许做一些简单的事情，比如加60来得到下一分钟。它们也很有效，因为只有4个字节可以用来存储时间戳。作为UTC的定义，不需要传递时区，您总是知道如何将时间戳转换成任何时区。</p></blockquote><p id="9d5b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">UNIX epoch给出的精度是一秒，尽管经常使用备用版本处理毫秒。</p><h1 id="bc18" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">ANSI C</h1><p id="af39" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我们将开始回顾C如何处理时区和时间戳。在C语言中，这个标准从来没有覆盖不同的时区，但是从80年代开始，它已经覆盖了所有的UNIX系统。</p><p id="9059" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可以使用32位整数存储UNIX纪元时间，在标准中，该类型是传统上为整数的<em class="ng"> time_t </em>。该标准没有定义具体的类型(在我的64位FreeBSD框中使用clang是一个<em class="ng">长的</em>)。</p><p id="13d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，如果您想指定一个UNIX纪元，您可以这样做:</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="d20f" class="ns lw it no b gy nt nu l nv nw">/* 1616927900 Epoch is Sunday, 28 March 2021 10:38:20 GMT <br/>   1616927900 Epoch is Sunday March 28, 2021 06:38:20 (am) in time zone America/New York (EDT)<br/>*/</span><span id="84ef" class="ns lw it no b gy nx nu l nv nw">time_t epoch_time = 1616927900;</span></pre><p id="87e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在POSIX系统(所有UNIX/Linux/BSD系统)中，您可以使用TZ变量将它转换成任何带有时区的时间戳。假设您想知道纽约特定UNIX纪元是什么时间。然后你做:</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="f3f1" class="ns lw it no b gy nt nu l nv nw">/* 1616927900 Epoch is Sunday, 28 March 2021 10:38:20 GMT <br/>   1616927900 Epoch is Sunday March 28, 2021 06:38:20 (am) in time zone America/New York (EDT)<br/>*/</span><span id="b387" class="ns lw it no b gy nx nu l nv nw">time_t epoch_time = 1616927900;</span><span id="2546" class="ns lw it no b gy nx nu l nv nw">/* CONVERT TO struct tm */<br/>struct tm *converted_time;<br/>converted_time = localtime(&amp;epoch_time);</span><span id="20ff" class="ns lw it no b gy nx nu l nv nw">/* GET SYSTEM TIME ZONE */<br/>tzset();</span><span id="02b8" class="ns lw it no b gy nx nu l nv nw">/* DISPLAY TIME */<br/>char buffer[26];<br/>strftime(buffer, 26, "%Y-%m-%d %H:%M:%S", converted_time);<br/>printf("Timestamp for %ld is %s according to system timezone.\n", epoch_time, buffer);</span><span id="df39" class="ns lw it no b gy nx nu l nv nw">/* DISPLAY TIME ZONE */<br/>printf("Timezone for %ld is %s.\n", epoch_time, tzname[converted_time-&gt;tm_isdst]);</span><span id="93c8" class="ns lw it no b gy nx nu l nv nw">---</span><span id="a4e9" class="ns lw it no b gy nx nu l nv nw">$ TZ='America/New_York' ./test<br/>Timestamp for 1616927900 is 2021-03-28 06:38:20 according to system timezone.<br/>Timezone for 1616927900 is EDT.</span></pre><p id="b800" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ny nz oa no b">struct tm</code>有一个名为<code class="fe ny nz oa no b">tm_isdst</code>的字段，可以是-1、0或1。</p><p id="1757" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">-1用于指定一个给定的时间戳(我将在后面介绍这种情况)，0表示没有实行夏令时，1表示实行夏令时。</p><p id="fa9d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ny nz oa no b">tzset</code>将检索计算机的特定区域，当使用<code class="fe ny nz oa no b">localtime</code>时，localtime将使用它来填充<code class="fe ny nz oa no b">tm_isdst</code>，以便struct的字段给你正确的struct。<code class="fe ny nz oa no b">tzset</code>还设置外部数组<code class="fe ny nz oa no b">tzname</code>，可用于获取时区名称。</p><p id="e2a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您想使用不同于系统使用的时区，您有两种选择:</p><ol class=""><li id="1c99" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu ob my mz na bi translated">你可以在你的程序前面加上正确的TZ变量:<code class="fe ny nz oa no b">$TZ='America/New_York' ./my_program</code>。这不是C的一部分，而是UNIX shell在调用命令时定制环境的方式。</li><li id="9f00" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu ob my mz na bi translated">在调用<code class="fe ny nz oa no b">tzset</code>之前，可以用<code class="fe ny nz oa no b">putenv("TZ=America/New_York");</code>显式设置TZ变量。</li></ol><p id="0767" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您想做相反的事情，即获得给定本地化时间戳的UNIX纪元(问题将是:<em class="ng">哪个UNIX纪元对应于纽约2021年3月28日星期日06:38:20？</em>)这是您将使用的代码:</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="c0b1" class="ns lw it no b gy nt nu l nv nw">/* 1616927900 Epoch is Sunday, 28 March 2021 10:38:20 GMT <br/>   1616927900 Epoch is Sunday March 28, 2021 06:38:20 (am) in time zone America/New York (EDT)<br/>*/</span><span id="44ed" class="ns lw it no b gy nx nu l nv nw">/* GET SYSTEM TIME ZONE, MUST BE NEW YORK */<br/>tzset();</span><span id="c10d" class="ns lw it no b gy nx nu l nv nw">/* DEFINE THE TIMESTAMP struct tm */<br/>struct tm localised_time;<br/>localised_time.tm_year = 2021 - 1900;<br/>localised_time.tm_mon = 3 - 1;<br/>localised_time.tm_mday = 28;<br/>localised_time.tm_hour = 6;<br/>localised_time.tm_min = 38;<br/>localised_time.tm_sec = 20;<br/>localised_time.tm_isdst = -1;<br/>time_t epoch_time = mktime(&amp;localised_time);</span><span id="54b1" class="ns lw it no b gy nx nu l nv nw">/* NOTICE HOW mktime FIXES tm_isdst */<br/>printf("Fixed tm_isdst is %d.\n", localised_time.tm_isdst);</span><span id="fa8d" class="ns lw it no b gy nx nu l nv nw">/* DISPLAY TIME ZONE */<br/>printf("Timezone is %s.\n", tzname[localised_time.tm_isdst]);</span><span id="e181" class="ns lw it no b gy nx nu l nv nw">/* DISPLAY EPOCH */<br/>printf("Epoch timestamp is %ld.\n", epoch_time);</span><span id="3ef0" class="ns lw it no b gy nx nu l nv nw">---</span><span id="e6d3" class="ns lw it no b gy nx nu l nv nw">$ TZ='America/New_York' ./test2<br/>Fixed tm_isdst is 1.<br/>Timezone is EDT.<br/>Epoch timestamp is 1616927900.</span></pre><p id="d5bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，在<code class="fe ny nz oa no b">struct tm</code>中，年份被指定为自1900年以来的年数，一月的月份为0。我们对<code class="fe ny nz oa no b">tm_isdst</code>使用-1，<code class="fe ny nz oa no b">mktime</code>使用<code class="fe ny nz oa no b">tzset</code>检索的时区来确定这个值，并确定在纽约的那一天和时间是美国东部时间还是美国东部时间。</p><p id="146e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">很明显，只有当你的计算机位于美洲时区，或者你明确地为程序设置或传递了TZ时，这种方法才有效。另请注意，这不适用于Microsoft Windows。</p><blockquote class="nh ni nj"><p id="14d0" class="kz la ng lb b lc ld ju le lf lg jx lh nk lj lk ll nl ln lo lp nm lr ls lt lu im bi translated"><strong class="lb iu">提示3 </strong>:在C UNIX/POSIX时区资源和基本struct tm中，mktime和localtime函数可以用来处理时区。它在大多数情况下都能很好地工作，并且可以与所有现成的C/C++标准一起工作。</p></blockquote><p id="74b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我在C语言中使用这些简单的方法成功地处理了时区。在其他情况下，这种简单性可能还不够。</p><p id="3ec3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">C++还有其他处理时区的方法，最相关的是C++20标准的<em class="ng"> chrono </em> [2】库部分(该库也可以为旧标准编译)。Boost【3】也包含了一个处理时区的库，但是显然，它缺少一些时区或者有限制——我没有试过——。还有ICU库[4]来处理本地化，这似乎是详尽和完整的，还有许多其他开源解决方案。所有这些的问题是，你给你的系统增加了另一个依赖，我发现它们不容易使用。</p><p id="6755" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我发现上面的方法对我的需求来说足够简单，但是它只对UNIX系统有效。它适用于任何C/C++标准。</p><p id="21ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">[1]<a class="ae ky" href="https://en.wikipedia.org/wiki/Unix_time" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Unix_time</a></p><p id="fb1b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">[2]<a class="ae ky" href="http://www.cplusplus.com/reference/chrono/" rel="noopener ugc nofollow" target="_blank">http://www.cplusplus.com/reference/chrono/</a></p><p id="b9f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">[3]<a class="ae ky" href="https://www.boost.org/doc/libs/1_74_0/libs/locale/doc/html/dates_times_timezones.html" rel="noopener ugc nofollow" target="_blank">https://www . boost . org/doc/libs/1 _ 74 _ 0/libs/locale/doc/html/dates _ times _ time zones . html</a></p><p id="01af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="http://site.icu-project.org/" rel="noopener ugc nofollow" target="_blank">http://site.icu-project.org/</a></p></div></div>    
</body>
</html>