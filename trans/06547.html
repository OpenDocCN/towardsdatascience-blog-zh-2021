<html>
<head>
<title>Efficient Cardinality Estimation using HLL with Spark and Postgres</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于Spark和Postgres的HLL的有效基数估计</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/efficient-cardinality-estimation-using-hll-with-spark-and-postgres-dcf1cd66ede9?source=collection_archive---------20-----------------------#2021-06-12">https://towardsdatascience.com/efficient-cardinality-estimation-using-hll-with-spark-and-postgres-dcf1cd66ede9?source=collection_archive---------20-----------------------#2021-06-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="f26d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl">帮助您使用超对数算法进行端到端有效基数估计的完整指南。</em></p><h1 id="e23c" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated"><strong class="ak">问题陈述</strong></h1><p id="e18a" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">基数估计问题是寻找数据块中不同元素的数量的问题，其中相同的元素被重复多次。这个问题非常普遍，在现实世界中有很多应用，比如网站的活跃用户、独特的实时会话等等。</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="bbd3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个问题似乎是小孩子的游戏，但我们必须将所有的值保存在一个集合中，以跟踪我们已经考虑的所有值，当我们谈论数百万或数十亿用户/会话时，这最终将是一个问题。我们当然不能在内存中保存和处理具有如此大基数的集合。</p><h1 id="28f5" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated"><strong class="ak">可能的解决方案</strong></h1><p id="7f15" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">我们可以使用以下任何一种方法来进行基数估计:</p><ol class=""><li id="6ad0" class="lw lx iq jp b jq jr ju jv jy ly kc lz kg ma kk mb mc md me bi translated">独特计数</li><li id="698d" class="lw lx iq jp b jq mf ju mg jy mh kc mi kg mj kk mb mc md me bi translated">线性计数</li><li id="bcd2" class="lw lx iq jp b jq mf ju mg jy mh kc mi kg mj kk mb mc md me bi translated">对数对数算法</li><li id="7cc7" class="lw lx iq jp b jq mf ju mg jy mh kc mi kg mj kk mb mc md me bi translated">超对数算法</li></ol><p id="b526" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">不同计数</strong></p><p id="da54" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">寻找基数的蛮力方法，我们上面讨论的关于保持所有唯一元素在一个集合中并找出基数的方法。就时间和空间复杂性而言，它是线性的O(n ),按原样存储所有对象。</p><p id="d5b0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">线性计数</strong></p><p id="248e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该技术使用容量为B位的哈希表，所有位初始化为0。当一个条目到达时，我们对它进行哈希运算，该位的值被改为1。重复数据删除通过对输入进行哈希处理来实现。该算法在时间和空间复杂度方面也是线性的，但是占用的空间少得多，因为我们只保存比特而不是精确的值。现在，让我们比较哈希表的大小和我们可以拥有的唯一元素的大小。假设您的集合中有N个唯一的条目:</p><ol class=""><li id="eb7b" class="lw lx iq jp b jq jr ju jv jy ly kc lz kg ma kk mb mc md me bi translated">当N &lt;&lt; B, then hash collisions would be less and the count of 1 bit in the hash table would be a good estimate of the cardinality.</li><li id="2ad1" class="lw lx iq jp b jq mf ju mg jy mh kc mi kg mj kk mb mc md me bi translated">When N ≈ B, then a significant number of hash collisions would surely occur. But we can estimate the number of collisions by checking how full the hash table is. Using this estimation of the number of collisions we can extrapolate to the approximate cardinality of the set.</li><li id="3de3" class="lw lx iq jp b jq mf ju mg jy mh kc mi kg mj kk mb mc md me bi translated">When N &gt; &gt; B时，散列表中的每一位都将被设置为1，这样就不可能计算出真正的基数。</li></ol><p id="b1fb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当我们知道先验的最大可能的独特元素时，这种方法似乎是一个很好的选择。</p><p id="6f7e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">对数对数算法</strong></p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi mk"><img src="../Images/972f9ab54091ea3f846c5b935cb39a8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y8cj7Pz4tyKfOcgaT6ZY7Q.png"/></div></div></figure><p id="6cf7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这种算法也是基于散列的，它跟踪散列值的二进制表示中出现的零的最大数量。让我们假设出现的零的最大数量是k，那么估计计数将是2^k.</p><p id="370b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它基于这样的想法:一半的值以1开始，四分之一以01开始，八分之一以001开始，依此类推，得到k个前导零的概率是1/2^(k+1).现在，这种估计会非常不稳定，并且会有非常高的方差，因为我们可以让第一个哈希值也有5个前导零。</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi mr"><img src="../Images/2e1e740e7e73e2a21840779f266ff608.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7K6O22q1jzCSJtfuwmW5MQ.png"/></div></div></figure><p id="d040" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了使它更稳定，我们采用由多个散列函数给出的估计值的平均值(算术平均值)。把我们带到另一个计算量很大的过程，哈希。现在，为了解决这个问题，LogLog将从已经散列的值获得的值转换成2个值，取前m位，它指向一个特定的值桶，然后取剩余的位作为获得最大数量的零的值。</p><p id="75bf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，如果我们假设我们的散列函数返回32位，并且我们用前14位来决定它所指向的桶，那么我们将有2^14桶来平均k的值。</p><p id="9bb9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">假设在每个桶中，我们想要存储N个元素，那么我们将必须只存储log(N)数量级的单个数字，并且为了存储，我们只需要log(log(N))个比特，这就是它的名字。</p><p id="bb38" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">举个例子，如果我们为每个桶取5位寄存器来存储该桶和2^14桶的k的最大值，这将允许我们为每个桶取从0到31的值，这意味着我们可能在每个桶中有2^31元素(使用上述概率)，这意味着我们可以仅通过使用空间(214 * 5) = 81920位(10 KBs)来近似地将2^(31+14的不同元素保持在最大值。</p><p id="8c0e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它将估计数量定义如下:</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/6c24ac41161692ee3587e09febd6a3d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:904/format:webp/1*aCWkUnuDp6ha0kn7lp2tlQ.png"/></div></figure><blockquote class="mt"><p id="4efd" class="mu mv iq bd mw mx my mz na nb nc kk dk translated">其中，α →估计因子(常数值)<br/>寄存器(i) →第I个桶的最大前导零计数的值</p></blockquote><h2 id="ee2b" class="nd kn iq bd ko ne nf dn ks ng nh dp kw jy ni nj la kc nk nl le kg nm nn li no bi translated">超对数算法</h2><p id="e99f" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">这是一个对数对数算法的改进算法。当组合多个桶的结果时，它使用调和平均值代替算术平均值，这迎合了最大前导零计数的异常高的值。此外，它还提供了对两种极端情况的修正，一种是不是所有的桶都被占用，另一种是哈希冲突导致低估。</p><h1 id="0e99" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">超对数实现</h1><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi np"><img src="../Images/1563a62ae6315ce1f439cfc27648abf4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nHy_Ze40g6-Vc_TA5fG5Fw.png"/></div></div></figure><p id="6bba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不同的图书馆都在实现HLL算法，我们选择使用聚合知识的HLL实现，原因如下:</p><ul class=""><li id="4f98" class="lw lx iq jp b jq jr ju jv jy ly kc lz kg ma kk nq mc md me bi translated">有一个可与Postgres DB(<a class="ae nr" href="https://github.com/citusdata/postgresql-hll" rel="noopener ugc nofollow" target="_blank">PostgreSQL-hll</a>)互操作的库，同样被Swoop的<a class="ae nr" href="https://github.com/swoop-inc/spark-alchemy" rel="noopener ugc nofollow" target="_blank"> Spark-Alchemy </a>使用。</li><li id="1fad" class="lw lx iq jp b jq mf ju mg jy mh kc mi kg mj kk nq mc md me bi translated">有能力联合两个hll。</li><li id="4e09" class="lw lx iq jp b jq mf ju mg jy mh kc mi kg mj kk nq mc md me bi translated">易于使用的API。</li></ul><h1 id="821f" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">履行</h1><p id="fbae" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">要在Mac系统上试用<a class="ae nr" href="https://github.com/citusdata/postgresql-hll" rel="noopener ugc nofollow" target="_blank"> postgresql-hll </a>扩展，请使用以下步骤:</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="0146" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以，扩展安装在Postgres中。现在，我们需要运行以下查询来激活特定DB中的扩展。</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="0753" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了测试上面的示例，使用以下查询创建一个表并插入一些数据:</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="d675" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后尝试Postgres中的hll与Java APIs的互操作性。使用以下查询创建了另一个表</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="91cb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后用一个Java程序创建hll，使用从0到n的一系列数字，这样我们就知道其中有多少唯一的条目，将它们推送到Postgres，然后对它们进行聚合和计数。因为我们这样知道了唯一的条目，所以我们可以计算user_id和session_id的错误百分比。</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="8333" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里需要注意的几件事是:</p><ul class=""><li id="4af9" class="lw lx iq jp b jq jr ju jv jy ly kc lz kg ma kk nq mc md me bi translated">如果我们想要联合两个hll或者合并两个hll，那么我们应该总是用相同的种子散列它们，否则相同的值也将给出两个不同的散列值，并且将被计为两个。</li><li id="d7c0" class="lw lx iq jp b jq mf ju mg jy mh kc mi kg mj kk nq mc md me bi translated">hll的标准误差可由以下公式给出，预计计算值分别在65%、95%和99%情况下的实际计数的σ、2σ和3σ范围内。σ = (1.04)/√(桶数)</li></ul><h1 id="b51b" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">Spark UDFs</h1><p id="6f34" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">我们使用Java APIs来编写UDF</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="lu lv l"/></div></figure><h1 id="d7d5" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">聚合知识的存储规范</h1><p id="e2ff" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">让我们来看看AgKn为提高基数估计的准确性而提出的HLLs类型。</p><h2 id="00b6" class="nd kn iq bd ko ne ns dn ks ng nt dp kw jy nu nj la kc nv nl le kg nw nn li no bi translated">类型</h2><ul class=""><li id="82ab" class="lw lx iq jp b jq lk ju ll jy nx kc ny kg nz kk nq mc md me bi translated"><strong class="jp ir">空</strong>T3】一个常数值表示空集。</li><li id="6358" class="lw lx iq jp b jq mf ju mg jy mh kc mi kg mj kk nq mc md me bi translated"><strong class="jp ir"> Explicit </strong>这样做是为了提高低基数时的准确性，因为我们可以直接将散列输入的显式集合保存为64位整数的排序列表。我们还可以调整expthresh，根据我们的用例保留更多或更少的数字，但是自动模式支持最佳的内存使用。</li><li id="4a58" class="lw lx iq jp b jq mf ju mg jy mh kc mi kg mj kk nq mc md me bi translated"><strong class="jp ir">稀疏</strong> <br/>它的思想是基于稀疏数组的，在稀疏数组中我们保存只有非零值的索引的值。类似地，它是HLL的基于映射的实现，只存储映射中非零寄存器的索引值，直到非零寄存器的数量超过固定基数。因此，它实际上只保存那些寄存器至少有1个非0位的桶的寄存器值。</li><li id="e562" class="lw lx iq jp b jq mf ju mg jy mh kc mi kg mj kk nq mc md me bi translated"><strong class="jp ir">完全</strong> <br/>完全具体化的、基于列表的HLL实现。在按寄存器索引排序的列表中显式存储每个寄存器的值。</li></ul><p id="97c0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不是，访问Schema布局和数据如何以字节数组格式排列，可以在这里<a class="ae nr" href="https://github.com/aggregateknowledge/hll-storage-spec/blob/master/STORAGE.md#storage" rel="noopener ugc nofollow" target="_blank">访问</a>。</p><h1 id="6133" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">聚合知识的参数定义和调整</h1><h2 id="1c10" class="nd kn iq bd ko ne ns dn ks ng nt dp kw jy nu nj la kc nv nl le kg nw nn li no bi translated">1.Log2m</h2><p id="ed28" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">这个值决定了桶或者寄存器的数量，m是这里实际的寄存器数量，我们可以用2(Log2m)来计算寄存器的数量。此外，该值决定了HLLs的精度。下面的表达式给出了标准误差估计。此外，需要注意的一点是，对于65%、95%和99%的情况，计算值预计分别在实际计数的σ、2σ和3σ范围内。σ = (1.04)/√(m)</p><h2 id="e33f" class="nd kn iq bd ko ne ns dn ks ng nt dp kw jy nu nj la kc nv nl le kg nw nn li no bi translated">2.RegWidth</h2><p id="1500" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">这是寄存器/桶的宽度或HLL算法中每个寄存器使用的位数。必须至少为1，最多为8。该参数与log2m结合使用，可以调整其基数可以估计的集合的最大基数。请参考<a class="ae nr" href="https://github.com/citusdata/postgresql-hll#regwidth" rel="noopener ugc nofollow" target="_blank">表</a>了解HLL大小和最大基数。</p><p id="bcba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> 3。ExpThresh </strong></p><p id="941c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">根据集的基数，在显式提升为稀疏提升时进行调整。</p><pre class="lp lq lr ls gt oa ob oc od aw oe bi"><span id="f251" class="nd kn iq ob b gy of og l oh oi">If the `EXPLICIT` representation is turned off, the `EMPTY` set is promoted directly to `SPARSE`. Must be -1 {Promote at whatever cutoff makes sense for optimal memory usage. ('auto' mode)}, 0 {Skip <!-- -->EXPLICIT<!-- --> representation in hierarchy. (Promotes directly to Sparse.)}, or 1-18 inclusive {Promote at 2^expthresh - 1 cardinality}.</span></pre><p id="43df" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以选择显式截断，这样它将比完整的hll表示占用更多的内存。这是允许的，因为在某些预设的基数范围内需要完美的精度和准确性，在此之后，基数的估计就足够了。</p><p id="d94c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> 4。斯巴森</strong></p><p id="8dd3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">启用或禁用稀疏表示。如果显式和稀疏表示都被禁用，空集将直接提升为完整集。如果启用了稀疏，当内部稀疏表示的内存占用超过完整版本的内存占用时，将从稀疏提升到完整版本。必须为真或假。True表示启用，false表示禁用。</p><h1 id="b4c5" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">结论</h1><p id="440c" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">超对数算法有助于在一定阈值内解决基数估计问题，而不会使存储空间过载以保留所有元素。</p><p id="7c72" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此外，聚合知识为HLL算法提供了强大的支持。其他可以尝试的库有<a class="ae nr" href="https://datasketches.apache.org/docs/HLL/HLL.html" rel="noopener ugc nofollow" target="_blank"> Datasketch </a>，<a class="ae nr" href="https://github.com/google/zetasketch" rel="noopener ugc nofollow" target="_blank"> Zetasketch </a>。</p><h1 id="be1d" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">参考</h1><ul class=""><li id="36a8" class="lw lx iq jp b jq lk ju ll jy nx kc ny kg nz kk nq mc md me bi translated"><a class="ae nr" href="https://mungingdata.com/apache-spark/hyperloglog-count-distinct/" rel="noopener ugc nofollow" target="_blank">https://mungingdata . com/Apache-spark/hyperlog log-count-distinct/</a></li><li id="381f" class="lw lx iq jp b jq mf ju mg jy mh kc mi kg mj kk nq mc md me bi translated"><a class="ae nr" href="https://github.com/swoop-inc/spark-alchemy/wiki/Spark-HyperLogLog-Functions" rel="noopener ugc nofollow" target="_blank">https://github . com/swoop-Inc/Spark-alchemy/wiki/Spark-HyperLogLog-Functions</a></li><li id="9f6c" class="lw lx iq jp b jq mf ju mg jy mh kc mi kg mj kk nq mc md me bi translated"><a class="ae nr" href="https://databricks.com/session_eu19/high-performance-advanced-analytics-with-spark-alchemy" rel="noopener ugc nofollow" target="_blank">https://data bricks . com/session _ eu19/高性能-高级-分析-火花-炼金术</a></li><li id="76ab" class="lw lx iq jp b jq mf ju mg jy mh kc mi kg mj kk nq mc md me bi translated">https://github.com/aggregateknowledge/java-hll<a class="ae nr" href="https://github.com/aggregateknowledge/java-hll" rel="noopener ugc nofollow" target="_blank"/></li><li id="b92a" class="lw lx iq jp b jq mf ju mg jy mh kc mi kg mj kk nq mc md me bi translated"><a class="ae nr" href="https://www.moderndescartes.com/essays/hyperloglog/index.html" rel="noopener ugc nofollow" target="_blank">https://www . moderndesartes . com/essays/hyperlog log/index . html</a></li><li id="a35a" class="lw lx iq jp b jq mf ju mg jy mh kc mi kg mj kk nq mc md me bi translated"><a class="ae nr" href="https://highlyscalable.wordpress.com/2012/05/01/probabilistic-structures-web-analytics-data-mining/" rel="noopener ugc nofollow" target="_blank">https://highly scalable . WordPress . com/2012/05/01/probability-structures-we B- analytics-data-mining/</a></li><li id="f840" class="lw lx iq jp b jq mf ju mg jy mh kc mi kg mj kk nq mc md me bi translated"><a class="ae nr" href="https://github.com/citusdata/postgresql-hll#explanation-of-parameters-and-tuning" rel="noopener ugc nofollow" target="_blank">https://github . com/citus data/PostgreSQL-hll #参数解释和调整</a></li><li id="fa70" class="lw lx iq jp b jq mf ju mg jy mh kc mi kg mj kk nq mc md me bi translated"><a class="ae nr" href="https://github.com/aggregateknowledge/hll-storage-spec/blob/master/STORAGE.md" rel="noopener ugc nofollow" target="_blank">https://github . com/aggregate knowledge/hll-storage-spec/blob/master/storage . MD</a></li><li id="dd88" class="lw lx iq jp b jq mf ju mg jy mh kc mi kg mj kk nq mc md me bi translated"><a class="ae nr" href="https://banner2.cleanpng.com/20190623/uxe/kisspng-logo-java-development-kit-portable-network-graphic-5d0f25d6871765.6875406615612738145533.jpg" rel="noopener ugc nofollow" target="_blank">https://banner 2 . clean png . com/2019 06 23/uxe/kiss png-logo-Java-development-kit-portable-network-graphic-5d 0f 25d 68733 . jpg</a></li><li id="aaa2" class="lw lx iq jp b jq mf ju mg jy mh kc mi kg mj kk nq mc md me bi translated"><a class="ae nr" href="https://upload.wikimedia.org/wikipedia/commons/thumb/f/f3/Apache_Spark_logo.svg/1200px-Apache_Spark_logo.svg.png" rel="noopener ugc nofollow" target="_blank">https://upload . wikimedia . org/Wikipedia/commons/thumb/f/F3/Apache _ Spark _ logo . SVG/1200 px-Apache _ Spark _ logo . SVG . png</a></li><li id="4ff1" class="lw lx iq jp b jq mf ju mg jy mh kc mi kg mj kk nq mc md me bi translated"><a class="ae nr" href="https://cpl.thalesgroup.com/sites/default/files/content/paragraphs/intro/2020-03/postgresql-logo.png" rel="noopener ugc nofollow" target="_blank">https://CPL . Thales group . com/sites/default/files/content/paragraphs/intro/2020-03/PostgreSQL-logo . png</a></li></ul></div></div>    
</body>
</html>