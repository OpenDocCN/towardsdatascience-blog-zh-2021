<html>
<head>
<title>How To Find DNA Needles in Genomic Haystacks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在基因组干草堆中找到DNA针</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/genomic-haystacks-947e6a46f9ae?source=collection_archive---------24-----------------------#2021-06-18">https://towardsdatascience.com/genomic-haystacks-947e6a46f9ae?source=collection_archive---------24-----------------------#2021-06-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ef0b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用Python寻找基因组中的调控基序</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/b8d6bfbb9a97a205f09a294a304d893b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tLaLC9SyKQh1yAmyu-VAUQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">穆尔托·希拉利</p></figure><p id="69b7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我请你帮我大海捞针，你只会出于礼节而答应。</p><p id="3c5e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我告诉你实际上干草堆里有10根针，而且它们看起来都略有不同，愤怒会像打掉我的牙齿一样吞噬你。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lu lv l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae lw" href="http://gph.is/2wbEcZR" rel="noopener ugc nofollow" target="_blank">吉菲</a></p></figure><p id="094e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是生物学家在寻找<strong class="la iu">调控基序</strong>时面临的任务。这些是基因组中的<strong class="la iu">短DNA片段</strong>，结合<strong class="la iu">转录因子</strong>。TF是提高或降低其他基因转录水平(<em class="lx">表达</em>)的蛋白质。</p><p id="419f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">像针一样，调控基序通常彼此相似，但不完全相同。生物信息学家面临的问题是<strong class="la iu">在他们拥有的所有遗传数据中找到彼此最相似的一组基序</strong>。</p><p id="e030" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一旦我们做到了，我们就能理解重要功能背后的机制，如光合作用或<strong class="la iu">结核休眠。</strong></p><p id="eb5d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我已经学会了如何使用Python来做这件事，你可以在Codeacademy上学习。你也可以这样做。</p><h2 id="3768" class="ly lz it bd ma mb mc dn md me mf dp mg lh mh mi mj ll mk ml mm lp mn mo mp mq bi translated">在本文中，我们将:</h2><ul class=""><li id="338b" class="mr ms it la b lb mt le mu lh mv ll mw lp mx lt my mz na nb bi translated">为DNA基序矩阵生成<strong class="la iu">计数</strong>和<strong class="la iu">图谱</strong>矩阵。</li><li id="6a16" class="mr ms it la b lb nc le nd lh ne ll nf lp ng lt my mz na nb bi translated">创建一个<strong class="la iu">一致性</strong>基序，以<strong class="la iu">对我们数据中所有基序之间的保守程度进行评分</strong>。</li><li id="1ac5" class="mr ms it la b lb nc le nd lh ne ll nf lp ng lt my mz na nb bi translated">根据我们的<strong class="la iu">轮廓矩阵</strong>确定任何可能的模体出现的<strong class="la iu">概率</strong>。</li><li id="884f" class="mr ms it la b lb nc le nd lh ne ll nf lp ng lt my mz na nb bi translated">将这些函数编译成一个<strong class="la iu">贪婪搜索算法</strong>来扫描MTB基因上游区域的基序。</li></ul><blockquote class="nh ni nj"><p id="37a9" class="ky kz lx la b lb lc ju ld le lf jx lg nk li lj lk nl lm ln lo nm lq lr ls lt im bi translated">这篇文章假设你有遗传学和Python的基础知识。</p></blockquote><h1 id="f299" class="nn lz it bd ma no np nq md nr ns nt mg jz nu ka mj kc nv kd mm kf nw kg mp nx bi translated">倒过来看</h1><p id="f44e" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh ny lj lk ll nz ln lo lp oa lr ls lt im bi translated">假设我们已经有了一个motfis矩阵，我们想要测量每个motfis之间的相似性——保守水平。(每列中最保守的核苷酸大写。)</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/54ded321a2b9d0b7a2493076189cab05.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qKfGYMAxSTHF3zlG882ndA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(这些是来自黑腹果蝇的NF-kB结合位点基序，来自生物信息学算法)。|作者图片</p></figure><p id="ebc9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们的工作:</p><ul class=""><li id="f777" class="mr ms it la b lb lc le lf lh og ll oh lp oi lt my mz na nb bi translated">计算每列中<strong class="la iu">最高度保守的核苷酸</strong>。(<code class="fe ob oc od oe b">Count()</code>)</li><li id="12bf" class="mr ms it la b lb nc le nd lh ne ll nf lp ng lt my mz na nb bi translated"><strong class="la iu">生成“共有”基序</strong>，其中每个碱基是来自<code class="fe ob oc od oe b">Motifs</code>中每列的最保守的核苷酸。(<code class="fe ob oc od oe b">Consensus())</code></li><li id="f030" class="mr ms it la b lb nc le nd lh ne ll nf lp ng lt my mz na nb bi translated"><strong class="la iu">对<code class="fe ob oc od oe b">Motifs</code>中每个模体与共有模体之间的相似度</strong>进行评分。(<code class="fe ob oc od oe b">Score()</code>)</li></ul><h1 id="3d62" class="nn lz it bd ma no np nq md nr ns nt mg jz nu ka mj kc nv kd mm kf nw kg mp nx bi translated">计数(图案)</h1><p id="efa1" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh ny lj lk ll nz ln lo lp oa lr ls lt im bi translated">创建一个字典<code class="fe ob oc od oe b">count</code>，其中关键字是核苷酸(<code class="fe ob oc od oe b">'A', 'C', 'T', ‘G’</code>)，值是列表。每个列表元素是关键字的核苷酸在<code class="fe ob oc od oe b">Motifs</code>的索引(列)中出现的次数:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/91a5b133a2934beb2d61f1136c2341c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sgfxo8hsZHiftKZLY1EJ4g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">' a '在列中出现两次，' C '出现一次，' T '出现七次。|作者</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ok"><img src="../Images/3d83cc10f2761ee0cbcffb41cc803e47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DfXQtzSEBskuFdh2O34xkQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">所有代码片段均由作者使用<a class="ae lw" href="http://ray.so" rel="noopener ugc nofollow" target="_blank"> ray.so </a></p></figure><p id="4245" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们初始化一个空字典<code class="fe ob oc od oe b">count</code>并用核苷酸键填充它。每一个值都是一个<code class="fe ob oc od oe b">0</code>的列表，只要是<code class="fe ob oc od oe b">Motifs</code>中的第一个母题。</p><p id="e318" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后我们迭代<code class="fe ob oc od oe b">Motifs</code>中的每一个元素；当我们在<code class="fe ob oc od oe b">Motifs[i][j]</code>遇到一个核苷酸<code class="fe ob oc od oe b">symbol</code>时，我们在第<code class="fe ob oc od oe b">j</code>个索引处增加那个<code class="fe ob oc od oe b">symbol</code>键的值。</p><h2 id="9c44" class="ly lz it bd ma mb mc dn md me mf dp mg lh mh mi mj ll mk ml mm lp mn mo mp mq bi translated">一个惊喜的工具，将帮助我们以后</h2><p id="8c37" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh ny lj lk ll nz ln lo lp oa lr ls lt im bi translated">将计数字典转换为具有<code class="fe ob oc od oe b">Profile(Motifs)</code>功能的频率字典；</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ok"><img src="../Images/f8050d6728ac4c49628c263e78d2a0e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*crIswqRCwGPlSCD27eZ-bQ.png"/></div></div></figure><p id="5cd7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">将<code class="fe ob oc od oe b">count</code>中的每个列表元素除以<code class="fe ob oc od oe b">Motifs</code>中的主题数。我们得到这样的结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/ccfaf30eda8190820457922d3092abe6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*plhrznwoszGI6JHKXcS0KA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">按作者</p></figure><p id="acdc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个以后会派上用场的。</p><h1 id="d8de" class="nn lz it bd ma no np nq md nr ns nt mg jz nu ka mj kc nv kd mm kf nw kg mp nx bi translated">共识(主题)</h1><p id="e572" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh ny lj lk ll nz ln lo lp oa lr ls lt im bi translated">现在，我们可以调用<code class="fe ob oc od oe b">Count()</code>作为子程序。在<code class="fe ob oc od oe b">count</code>字典的每个索引处取最高计数的核苷酸并附加到空字符串<code class="fe ob oc od oe b">consensus</code>:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ol"><img src="../Images/76ff9a8b6882e36c3b81319a4231dd49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Hoj_s9v47R8OoU4teSn_og.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">按作者</p></figure><p id="3b10" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在外部循环中，我们遍历来自<code class="fe ob oc od oe b">count</code>的列表值中的每个元素。在内部循环中，我们遍历每个核苷酸键。这让我们可以比较第<code class="fe ob oc od oe b">j</code>个索引处的每个键值。我们更新<code class="fe ob oc od oe b">m</code>总是最高值，让<code class="fe ob oc od oe b">frequentSymbol</code> =对应的核苷酸<code class="fe ob oc od oe b">symbol</code>。</p><pre class="kj kk kl km gt om oe on oo aw op bi"><span id="c926" class="ly lz it oe b gy oq or l os ot">Consensus(Motifs)<br/>&gt;&gt;'<strong class="oe iu">TCGGGGATTTCC'</strong></span></pre><h1 id="8c9e" class="nn lz it bd ma no np nq md nr ns nt mg jz nu ka mj kc nv kd mm kf nw kg mp nx bi translated">分数(主题)</h1><p id="9cf6" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh ny lj lk ll nz ln lo lp oa lr ls lt im bi translated">为了对基序中基序之间的保守程度进行评分，我们可以使用索引<code class="fe ob oc od oe b">motif[j]</code>遍历每个元素。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ou"><img src="../Images/eb3406946688f2a732fe62244f9be625.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nW5xWiHX59eXme94orVe-w.png"/></div></div></figure><p id="9273" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">外部循环的范围是行，内部循环的范围是列。</p><p id="b1a0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果<code class="fe ob oc od oe b">motif[j]</code>处的核苷酸符号与<code class="fe ob oc od oe b">consensus[j]</code>不匹配，我们增加<code class="fe ob oc od oe b">score</code>。分数越高=保守性越低。</p><h1 id="3ea4" class="nn lz it bd ma no np nq md nr ns nt mg jz nu ka mj kc nv kd mm kf nw kg mp nx bi translated">让我们变得贪婪</h1><p id="d6d6" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh ny lj lk ll nz ln lo lp oa lr ls lt im bi translated">我们有一种方法来衡量图案之间的保守性。现在，我们需要生成许多<em class="lx">潜在</em>矩阵<code class="fe ob oc od oe b">Motifs</code>，并找到最小化<code class="fe ob oc od oe b">score</code>的那个。</p><p id="075f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以用<strong class="la iu">贪婪搜索算法</strong>来做到这一点；这意味着我们的算法将在迭代的每一步选择最佳选项。更多<a class="ae lw" href="https://brilliant.org/wiki/greedy-algorithm/" rel="noopener ugc nofollow" target="_blank">此处</a>。</p><p id="3cd8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">贪婪算法有三个组成部分:</p><ol class=""><li id="4d4a" class="mr ms it la b lb lc le lf lh og ll oh lp oi lt ov mz na nb bi translated"><strong class="la iu">数据:</strong>它必须迭代一组<strong class="la iu">数据。</strong></li><li id="5884" class="mr ms it la b lb nc le nd lh ne ll nf lp ng lt ov mz na nb bi translated"><strong class="la iu">规则:</strong>它遵循<strong class="la iu">规则</strong>在迭代的每一步做什么。</li><li id="7de4" class="mr ms it la b lb nc le nd lh ne ll nf lp ng lt ov mz na nb bi translated"><strong class="la iu">结果:</strong>每一步都将该规则的<strong class="la iu">结果</strong>加到答案中。</li></ol><h2 id="df91" class="ly lz it bd ma mb mc dn md me mf dp mg lh mh mi mj ll mk ml mm lp mn mo mp mq bi translated">让我们定义GreedyMotifSearch(Dna，k，t)其中:</h2><ul class=""><li id="e847" class="mr ms it la b lb mt le mu lh mv ll mw lp mx lt my mz na nb bi translated"><code class="fe ob oc od oe b">Dna</code>是一个DNA字符串矩阵，我们正在扫描其中的图案。</li><li id="774e" class="mr ms it la b lb nc le nd lh ne ll nf lp ng lt my mz na nb bi translated"><code class="fe ob oc od oe b">k</code>是图案的长度。</li><li id="73cc" class="mr ms it la b lb nc le nd lh ne ll nf lp ng lt my mz na nb bi translated"><code class="fe ob oc od oe b">t</code>是<code class="fe ob oc od oe b">Dna</code>中DNA串的数量。</li></ul><p id="dfa2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们算法的组成部分:</p><ol class=""><li id="c20a" class="mr ms it la b lb lc le lf lh og ll oh lp oi lt ov mz na nb bi translated"><strong class="la iu">数据:</strong>遍历<code class="fe ob oc od oe b"><strong class="la iu">Dna</strong></code>第一个字符串中所有可能的k-mers。(外环)。</li><li id="2ead" class="mr ms it la b lb nc le nd lh ne ll nf lp ng lt ov mz na nb bi translated"><strong class="la iu">规则:从<code class="fe ob oc od oe b">Dna</code>中的每隔一个字符串中为那些k-mers找到最佳匹配</strong>。(内循环)。</li><li id="ad68" class="mr ms it la b lb nc le nd lh ne ll nf lp ng lt ov mz na nb bi translated"><strong class="la iu">结果:将结果</strong>追加到列表<code class="fe ob oc od oe b">Motifs</code>中。</li></ol><p id="9a0c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以从创建一个暂定列表<code class="fe ob oc od oe b">BestMotifs</code>开始，其中每个基序都是<code class="fe ob oc od oe b">Dna</code>中每个DNA串的第一个k-mer。如果我们以后创建一个有更好分数的矩阵，我们将更新这个列表。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ow"><img src="../Images/30c94c45eb0783d72d8b8e80ffc21137.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0t_58rlCowPRFezBZgPHRQ.png"/></div></div></figure><p id="ab1c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们从<code class="fe ob oc od oe b">Dna[0]</code>中取出第一个k-mer(再次)将其附加到一个新列表<code class="fe ob oc od oe b">Motifs</code>。我们将对第一个DNA链中每一个可能的k-mer都这样做——这是我们的外环。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ow"><img src="../Images/e69b7165471aa406e99d06ff0875131f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fiFDxnWgMiEmUVP6WfDzOg.png"/></div></div></figure><p id="f772" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们将基于从<code class="fe ob oc od oe b">Dna[0]</code>中提取的第一个k-mer来构建<code class="fe ob oc od oe b">Motifs</code>的其余部分。(这是第二步，规则)。</p><p id="db85" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用我们之前制作的<code class="fe ob oc od oe b">Profile</code>函数<strong class="la iu">的轮廓，我们想要在下一个DNA串</strong>、<code class="fe ob oc od oe b">Dna[1]</code>中找到最相似的k-mer。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ox"><img src="../Images/c563038ccc7341ac5a85caa2812472bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fkjIkstmnAbQivALiWB8mA.png"/></div></div></figure><p id="4780" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">怎么会？好吧，我们还没有这样做的函数，所以让我们写一个。</p><h2 id="7d41" class="ly lz it bd ma mb mc dn md me mf dp mg lh mh mi mj ll mk ml mm lp mn mo mp mq bi translated">公关(文本，个人资料)</h2><p id="3496" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh ny lj lk ll nz ln lo lp oa lr ls lt im bi translated">让我们看看我们的简介矩阵。每个元素是<strong class="la iu">该核苷酸出现在基序中该位置的概率。</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oy"><img src="../Images/254f319fe626dc21278a7f17d3d05e39.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uzVvf2yT4L0ehrXworVllg.png"/></div></div></figure><p id="60be" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果分布矩阵随机产生基序，共有序列将出现得最频繁。</p><p id="c330" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">我们还可以确定任何其他字符串基序出现的概率。</strong>简单地乘以每个碱基出现在各自位置的几率:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oz"><img src="../Images/9743810581acbf1a4280eba54b64b3d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H_unqJAex5PruZ5EB7xYhw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">每个红色碱基都是对共有字符串(顶部)的偏离。注意当我们远离共识字符串时，每个字符串的概率是如何下降的。</p></figure><p id="65d1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">更高的概率=根据<code class="fe ob oc od oe b">Profile</code>更好的匹配</strong>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ok"><img src="../Images/6a876183175d4c5764febe337d00ac2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EcvIESJCCG0rgVuv-2ErNw.png"/></div></div></figure><p id="6a26" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">参数是一个DNA字符串<code class="fe ob oc od oe b">Text</code>和一个档案矩阵<code class="fe ob oc od oe b">Profile</code>。<code class="fe ob oc od oe b">Text[i]</code>是<code class="fe ob oc od oe b">Text</code>中索引<code class="fe ob oc od oe b">i</code>处的核苷酸，也是<code class="fe ob oc od oe b">Profile</code>中列表的关键字。<code class="fe ob oc od oe b">Profile[Text[i]][i]</code>是同一索引<code class="fe ob oc od oe b">i</code>的概率值。</p><h2 id="29bb" class="ly lz it bd ma mb mc dn md me mf dp mg lh mh mi mj ll mk ml mm lp mn mo mp mq bi translated">profilemostparblepattern(Text，k，Profile)</h2><p id="937e" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh ny lj lk ll nz ln lo lp oa lr ls lt im bi translated">我们现在可以找到任何k-mer成为基序的概率——给定一个概率矩阵<code class="fe ob oc od oe b">Profile</code>。</p><p id="1521" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们遍历一长串DNA <code class="fe ob oc od oe b">Text</code>中的所有k-mers，并根据<code class="fe ob oc od oe b">Profile</code>找到最可能的一个(最佳匹配):</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pa"><img src="../Images/941e4b5bfe79d0b0480b52e8b150daf8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X7mxr-tSOkYcLjZx7EOFQQ.png"/></div></div></figure><p id="f681" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们生成一个包含k-mer及其概率的字典，然后返回第一个具有最高值的k-mer。(具体内联)。</p><p id="8003" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，给定一个<code class="fe ob oc od oe b">Profile</code>，一个长度<code class="fe ob oc od oe b">k</code>的基元，以及一个更长的字符串<code class="fe ob oc od oe b">Text</code>来扫描k-mers，我们可以返回到<code class="fe ob oc od oe b">GreedyMotifSearch</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pb"><img src="../Images/ca3422cf002528f44a975f7940d291a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u3jZt-wwnKqcTu-ZIkqX8g.png"/></div></div></figure><p id="ce45" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们在下一串DNA ( <code class="fe ob oc od oe b">Dna[1]</code>)中找到最可能的模式，并将其附加到<code class="fe ob oc od oe b">Motifs</code>。(这是第三步，结果)。我们更新这个新矩阵的轮廓<code class="fe ob oc od oe b">P</code>，并对每个DNA串重复这个过程。</p><p id="2d59" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当我们完成内部循环时，我们可以比较<code class="fe ob oc od oe b">Motifs</code>和<code class="fe ob oc od oe b">BestMotifs</code>的分数。如果<code class="fe ob oc od oe b">Motifs</code>得分降低，我们更新<code class="fe ob oc od oe b">BestMotifs</code>；在<code class="fe ob oc od oe b">Dna[0]</code>中对每个可能的k-mer重复该过程。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pc"><img src="../Images/d440bfcc410c8679be9d120ddd5e39cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ElugWP5Cil1KLPBSRdJTkw.png"/></div></div></figure><h1 id="f159" class="nn lz it bd ma no np nq md nr ns nt mg jz nu ka mj kc nv kd mm kf nw kg mp nx bi translated">熵(主题)</h1><p id="37b0" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh ny lj lk ll nz ln lo lp oa lr ls lt im bi translated">我们还没有完全完成。我们的得分函数是不完善的。请注意，一些列比其他列有更多的变化，但它们仍然得分相同(第二列和最后一列)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pd"><img src="../Images/fdc9863d0071d29882e16503fb487189.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MKDoxh4pwed2UGybARBkMA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在该图中，每列的分数被取下来并相加。这是为了视觉辅助；在代码中，我们不需要一定遵守这种模式，也不会遵守。</p></figure><p id="2527" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">跟踪每一列的守恒水平的更好的方法是测量熵。</p><p id="e28f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">配置文件矩阵中的每一列都是一个概率分布，即总和为1的正数。</p><p id="acf2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">熵是该分布的<strong class="la iu">不确定性</strong>，通过对每个概率乘以其二进制对数求和并乘以-1得出:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><a href="https://towardsdatascience.com/entropy-is-a-measure-of-uncertainty-e2c000301c2c"><div class="gh gi pe"><img src="../Images/7c1a2a0f9e58479b9807a7575c8860ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1122/format:webp/0*fEuJjw8yeUzlfNk-.png"/></div></a><p class="ku kv gj gh gi kw kx bd b be z dk translated">塞巴斯蒂安·科维亚特科夫斯基</p></figure><p id="9342" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">更低的熵=更少的不确定性和更大的守恒。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pf"><img src="../Images/8e0d860c03419a87858052501bb8a33d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UzI7n6-PHreg9JQ7DAUVpA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">因为我们要对所有的值求和，所以我们不必逐列进行。我还选择了减法，而不是加法，因为我们在公式中采用了最终答案的负数。结果是一样的。</p></figure><p id="1311" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">遍历<code class="fe ob oc od oe b">profile</code>中的每一个元素，如果概率值大于0就更新<code class="fe ob oc od oe b">entropy</code>(否则我们无法取其二进制对数)。这种公式在实践中更常用，但为了简单起见，这里只是一个脚注。</p><p id="6335" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们带着这个宝贝转一圈:</p><h1 id="821b" class="nn lz it bd ma no np nq md nr ns nt mg jz nu ka mj kc nv kd mm kf nw kg mp nx bi translated">用结核病进行测试</h1><p id="ad9a" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh ny lj lk ll nz ln lo lp oa lr ls lt im bi translated"><strong class="la iu">你可能得了肺结核而不自知</strong>。<em class="lx">结核分枝杆菌</em>结核分枝杆菌(MTB)可以在你的体内潜伏多年，然后才会产生任何影响。</p><p id="b8f7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">生物学家将缺氧(缺氧)与MTB潜伏期联系起来，并发现了帮助细菌在低氧条件下生存的转录因子(DosR)。</p><p id="f272" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们将观察DosR影响的一些基因的上游区域，试图找到一些它可能结合的基序。(我修改了<code class="fe ob oc od oe b">GreedyMotifSearch</code>，用<code class="fe ob oc od oe b">Entropy()</code>代替了<code class="fe ob oc od oe b">Score()</code>。)</p><p id="4505" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们正在查看的DNA字符串可以在这里找到<a class="ae lw" href="https://bioinformaticsalgorithms.com/data/challengedatasets/DosR.txt" rel="noopener ugc nofollow" target="_blank"/>，我已经将它们收集到一个名为<code class="fe ob oc od oe b">DosR</code>的列表中。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ow"><img src="../Images/9848f0a3e7b0c9d42ff80e9326207cfa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ItQU6a3Ia9O1urjwQ7sK4A.png"/></div></div></figure><p id="970f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您的结果:</p><pre class="kj kk kl km gt om oe on oo aw op bi"><span id="58b2" class="ly lz it oe b gy oq or l os ot">['ATGACCAGCGAGCTG',<br/> 'CCGATCGGCATCACT',<br/> 'ACCGTCGATGTGCCC',<br/> 'GGGTCAGGTATATTT',<br/> 'GTGACCGACGTCCCC',<br/> 'CCGCTGGCGACGCTG',<br/> 'GTGTCCGGCATGATC',<br/> 'CGGCCAGACAAGCTT',<br/> 'GCGATAGGTGAGATT',<br/> 'CTCATCGCTGTCATC'] </span><span id="4328" class="ly lz it oe b gy pg or l os ot">18.492751844642765 </span><span id="e43b" class="ly lz it oe b gy pg or l os ot">CCGACCGGCATGCTC</span></pre><p id="eca1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">恭喜你，成功了！亲吻你的配偶，和一只狗击掌，开着警车兜风。</p><p id="42dc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对吗？</p></div><div class="ab cl ph pi hx pj" role="separator"><span class="pk bw bk pl pm pn"/><span class="pk bw bk pl pm pn"/><span class="pk bw bk pl pm"/></div><div class="im in io ip iq"><p id="b250" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你看一下文献，这些不是你要找的主题。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="po lv l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae lw" href="https://tenor.com/uXNR.gif" rel="noopener ugc nofollow" target="_blank">期限</a></p></figure><p id="82ae" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">他们使用的<a class="ae lw" href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC140044/" rel="noopener ugc nofollow" target="_blank">算法</a>和数据更好——<strong class="la iu">贪婪算法的速度快，但准确性差。</strong></p><p id="97af" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">实际上，我们今天开发的算法永远不会被使用——就像我在精神崩溃时买的滚轴溜冰鞋一样。</p><h1 id="06e9" class="nn lz it bd ma no np nq md nr ns nt mg jz nu ka mj kc nv kd mm kf nw kg mp nx bi translated">关键要点</h1><ul class=""><li id="ab76" class="mr ms it la b lb mt le mu lh mv ll mw lp mx lt my mz na nb bi translated">这可能不是最重要的算法，但它为将来学习更复杂的算法奠定了基础。</li><li id="82ce" class="mr ms it la b lb nc le nd lh ne ll nf lp ng lt my mz na nb bi translated">复杂的问题可以有复杂的解决方案——但是你仍然可以使用简单的工具来构建它们(比如你可以在Codeacademy上免费学习的所有Python)。</li></ul></div><div class="ab cl ph pi hx pj" role="separator"><span class="pk bw bk pl pm pn"/><span class="pk bw bk pl pm pn"/><span class="pk bw bk pl pm"/></div><div class="im in io ip iq"><p id="6a7c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">感谢阅读！</p><p id="41d3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我写的其他生物信息学文章:</p><div class="pp pq gp gr pr ps"><a rel="noopener follow" target="_blank" href="/tanks-bioinformatics-c233fb76787b"><div class="pt ab fo"><div class="pu ab pv cl cj pw"><h2 class="bd iu gy z fp px fr fs py fu fw is bi translated">二战坦克如何教会你生物信息学</h2><div class="pz l"><p class="bd b dl z fp px fr fs py fu fw dk translated">towardsdatascience.com</p></div></div><div class="qa l"><div class="qb l qc qd qe qa qf ks ps"/></div></div></a></div><div class="pp pq gp gr pr ps"><a rel="noopener follow" target="_blank" href="/biology-code-match-518202a71d8d"><div class="pt ab fo"><div class="pu ab pv cl cj pw"><h2 class="bd iu gy z fp px fr fs py fu fw is bi translated">为什么生物学和代码是天作之合</h2><div class="pz l"><p class="bd b dl z fp px fr fs py fu fw dk translated">towardsdatascience.com</p></div></div><div class="qa l"><div class="qg l qc qd qe qa qf ks ps"/></div></div></a></div><div class="pp pq gp gr pr ps"><a rel="noopener follow" target="_blank" href="/genome-painting-c7e2398b4579"><div class="pt ab fo"><div class="pu ab pv cl cj pw"><h2 class="bd iu gy z fp px fr fs py fu fw is bi translated">你如何把基因组变成一幅画</h2><div class="pz l"><p class="bd b dl z fp px fr fs py fu fw dk translated">towardsdatascience.com</p></div></div><div class="qa l"><div class="qh l qc qd qe qa qf ks ps"/></div></div></a></div></div></div>    
</body>
</html>