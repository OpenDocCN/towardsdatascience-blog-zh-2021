<html>
<head>
<title>Forecasting with Machine Learning Models</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用机器学习模型进行预测</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/forecasting-with-machine-learning-models-95a6b6579090?source=collection_archive---------4-----------------------#2021-10-21">https://towardsdatascience.com/forecasting-with-machine-learning-models-95a6b6579090?source=collection_archive---------4-----------------------#2021-10-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="d465" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/notes-from-industry" rel="noopener" target="_blank">行业笔记</a></h2><div class=""/><div class=""><h2 id="a418" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">mlforecast通过机器学习快速轻松地进行预测</h2></div><p id="4393" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated"><em class="lk">乘</em><a class="ae ll" href="https://github.com/Nixtla/" rel="noopener ugc nofollow" target="_blank">T5】尼克斯队 </a> <em class="lk">。</em> <a class="lm ln ep" href="https://medium.com/u/2855bd3e0293?source=post_page-----95a6b6579090--------------------------------" rel="noopener" target="_blank"> <em class="lk">费德·加尔萨·拉米雷斯</em> </a>，<a class="lm ln ep" href="https://medium.com/u/76b639655285?source=post_page-----95a6b6579090--------------------------------" rel="noopener" target="_blank">马克斯·梅根塔尔</a></p><blockquote class="lo lp lq"><p id="f784" class="ko kp lk kq b kr ks ka kt ku kv kd kw lr ky kz la ls lc ld le lt lg lh li lj ij bi translated"><strong class="kq ja">TL；博士</strong>:我们介绍了mlforecast，这是一个来自<a class="ae ll" href="https://github.com/Nixtla/nixtla" rel="noopener ugc nofollow" target="_blank"> Nixtla </a>的开源框架，它使得在时间序列预测任务中使用机器学习模型变得快速而简单。它允许您关注模型和特性，而不是实现细节。使用mlforecast，您可以以更轻松的方式进行实验，它具有内置的回溯测试功能，可以帮助您找到性能最佳的模型。</p><p id="32b1" class="ko kp lk kq b kr ks ka kt ku kv kd kw lr ky kz la ls lc ld le lt lg lh li lj ij bi translated">您可以在自己的基础设施中使用mlforecast，或者使用我们的<a class="ae ll" href="https://github.com/Nixtla/nixtla" rel="noopener ugc nofollow" target="_blank">完全托管解决方案</a>。只需给我们发邮件到<a class="ae ll" href="http://federico@nixtla.io" rel="noopener ugc nofollow" target="_blank"> federico@nixtla.io </a>来测试私有测试版。</p><p id="f017" class="ko kp lk kq b kr ks ka kt ku kv kd kw lr ky kz la ls lc ld le lt lg lh li lj ij bi translated">虽然这个例子只包含了一个时间序列，但是这个框架能够处理成千上万的时间序列，并且在时间和内存上都非常有效。</p></blockquote><h2 id="2d05" class="lu lv iq bd lw lx ly dn lz ma mb dp mc kx md me mf lb mg mh mi lf mj mk ml iw bi translated">介绍</h2><p id="845f" class="pw-post-body-paragraph ko kp iq kq b kr mm ka kt ku mn kd kw kx mo kz la lb mp ld le lf mq lh li lj ij bi translated">我们在Nixtla，正试图让时间序列预测更容易被每个人接受。在本帖中，我们将讨论在预测任务中使用机器学习模型。我们将用一个例子来说明主要挑战是什么，然后我们将介绍<a class="ae ll" href="https://github.com/Nixtla/mlforecast" rel="noopener ugc nofollow" target="_blank"> mlforecast </a>，这是一个有助于在预测中使用机器学习模型的框架。<strong class="kq ja"> mlforecast </strong>为您进行特性工程并负责更新，用户只需提供一个遵循scikit-learn API(实现拟合和预测)的回归变量，并指定她想要使用的特性。这些功能可以是滞后、基于滞后的转换和日期功能。(如需进一步创建功能或自动预测管道，请检查<a class="ae ll" href="https://github.com/Nixtla/nixtla" rel="noopener ugc nofollow" target="_blank"> nixtla </a>。)</p><h2 id="34b0" class="lu lv iq bd lw lx ly dn lz ma mb dp mc kx md me mf lb mg mh mi lf mj mk ml iw bi translated">动机</h2><p id="ab1e" class="pw-post-body-paragraph ko kp iq kq b kr mm ka kt ku mn kd kw kx mo kz la lb mp ld le lf mq lh li lj ij bi translated">许多年来，像ARIMA和ETS这样的经典方法统治了预测领域。其中一个原因是，大多数用例涉及以月、季度或年为粒度预测低频序列。此外，没有很多时间序列数据集，因此为每个数据集拟合一个模型并从中获得预测是很简单的。</p><p id="1563" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">然而，近年来，对更大数据集、更高频率的预测需求有所上升。更大和更高频率的时间序列对传统的预测方法提出了挑战。这些方法并不意味着对许多时间序列一起建模，它们的实现是次优的和缓慢的(你必须训练许多模型)，此外，序列之间可能有一些共同或共享的模式，可以通过对它们一起建模来学习。</p><p id="123e" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">为了解决这个问题，已经有各种努力来提出不同的方法，这些方法可以在许多时间序列上训练单个模型。一些有趣的深度学习架构已经被设计出来，可以准确地预测许多时间序列，如ESRNN，DeepAR，NBEATS等。(检查<a class="ae ll" href="https://github.com/Nixtla/nixtlats" rel="noopener ugc nofollow" target="_blank"> nixtlats </a>和<a class="ae ll" href="https://nixtla.github.io/blog/deep%20learning/forecasting/m4/2021/06/25/esrnn-i.html" rel="noopener ugc nofollow" target="_blank">为我们的WIP复制ESRNN结果</a>。)</p><p id="4bb6" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">像梯度提升树这样的传统机器学习模型也已经被使用，并且已经表明它们也可以实现非常好的性能。但是，将这些模型与基于滞后的要素结合使用并不简单，因为您必须在每个时间步长中更新要素才能计算预测。此外，根据您的预测范围和您使用的滞后时间，在某个时间点，您会用完系列的实际值来更新您的要素，因此您必须采取措施来填补这些缺口。一种可能的方法是使用您的预测作为序列的值，并使用它们更新您的要素。这正是<strong class="kq ja"> mlforecast </strong>为你做的。</p><h2 id="1770" class="lu lv iq bd lw lx ly dn lz ma mb dp mc kx md me mf lb mg mh mi lf mj mk ml iw bi translated">例子</h2><p id="47ae" class="pw-post-body-paragraph ko kp iq kq b kr mm ka kt ku mn kd kw kx mo kz la lb mp ld le lf mq lh li lj ij bi translated">在下一节中，我们将展示一个非常简单的单序列示例，以强调在预测任务中使用机器学习模型的困难。这将在以后激发对mlforecast的使用，这是一个使整个过程更加容易和快速的库。</p><h2 id="2bd3" class="lu lv iq bd lw lx ly dn lz ma mb dp mc kx md me mf lb mg mh mi lf mj mk ml iw bi translated">图书馆</h2><figure class="mr ms mt mu gt mv"><div class="bz fp l di"><div class="mw mx l"/></div></figure><h2 id="7378" class="lu lv iq bd lw lx ly dn lz ma mb dp mc kx md me mf lb mg mh mi lf mj mk ml iw bi translated">数据</h2><figure class="mr ms mt mu gt mv"><div class="bz fp l di"><div class="mw mx l"/></div></figure><figure class="mr ms mt mu gt mv gh gi paragraph-image"><div class="ab gu cl my"><img src="../Images/0a3e6cf21969efe64ebbeae754cdec31.png" data-original-src="https://miro.medium.com/v2/format:webp/1*Z0eX1zbe7xqjqm6XH6-5RQ.png"/></div><p class="nb nc gj gh gi nd ne bd b be z dk translated">作者图片</p></figure><p id="9f1f" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">我们的数据具有每日季节性，正如您在创建中看到的，它基本上只是dayofweek + Uniform({-1，0，1})。</p><h2 id="f278" class="lu lv iq bd lw lx ly dn lz ma mb dp mc kx md me mf lb mg mh mi lf mj mk ml iw bi translated">培养</h2><p id="0c1e" class="pw-post-body-paragraph ko kp iq kq b kr mm ka kt ku mn kd kw kx mo kz la lb mp ld le lf mq lh li lj ij bi translated">假设我们想要未来14天的预测，第一步将是决定使用哪个模型和特性，因此我们将创建一个包含数据中最后14天的验证集。</p><figure class="mr ms mt mu gt mv"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="7995" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">作为起点，我们将尝试滞后7和滞后14。</p><figure class="mr ms mt mu gt mv"><div class="bz fp l di"><div class="mw mx l"/></div></figure><figure class="mr ms mt mu gt mv gh gi paragraph-image"><div class="ab gu cl my"><img src="../Images/8beab366c55dd285e5246e04171f8c62.png" data-original-src="https://miro.medium.com/v2/format:webp/1*x-KS1vgcbC0Jcg0hBoQnlA.png"/></div><p class="nb nc gj gh gi nd ne bd b be z dk translated">作者图片</p></figure><p id="06d5" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">我们可以看到滞后和目标之间的预期关系。例如，当<em class="lk"> lag-7 </em>为2时，<em class="lk"> y </em>可以是0、1、2、3或4。这是因为一周中的每一天都可以有值[day-1，day，day + 1]，所以当我们处于一周中的第2天时，我们可以得到值1、2或3。然而，值2可以来自第1周的某一天，其最小值为0，也可以来自第3周的某一天，其最大值为4。</p><p id="a9f0" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">计算滞后值会使一些行为空。</p><figure class="mr ms mt mu gt mv"><div class="bz fp l di"><div class="mw mx l"/></div></figure><figure class="mr ms mt mu gt mv gh gi paragraph-image"><div role="button" tabindex="0" class="ng nh di ni bf nj"><div class="gh gi nf"><img src="../Images/960e7c4f395c56ff2af3abe9814c0d79.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yGo4svNLBF_1Xl6eKfccag.png"/></div></div><p class="nb nc gj gh gi nd ne bd b be z dk translated">作者图片</p></figure><p id="48e6" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">我们会在训练前放下这些。</p><figure class="mr ms mt mu gt mv"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="471a" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">为了简单起见，我们将训练一个没有截距的线性回归。因为最好的模型是取一周中每一天的平均值，我们期望得到接近0.5的系数。</p><figure class="mr ms mt mu gt mv"><div class="bz fp l di"><div class="mw mx l"/></div></figure><figure class="mr ms mt mu gt mv gh gi paragraph-image"><div role="button" tabindex="0" class="ng nh di ni bf nj"><div class="gh gi nk"><img src="../Images/8083d7da46bd145e2f6ca25af369261e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QCuUmVG6INOlD_TEEwKaIA.png"/></div></div><p class="nb nc gj gh gi nd ne bd b be z dk translated">作者图片</p></figure><p id="08d5" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">这个模型取的是0.51 * lag_7 + 0.45 * lag_14。</p><h2 id="f01b" class="lu lv iq bd lw lx ly dn lz ma mb dp mc kx md me mf lb mg mh mi lf mj mk ml iw bi translated">预测</h2><p id="b180" class="pw-post-body-paragraph ko kp iq kq b kr mm ka kt ku mn kd kw kx mo kz la lb mp ld le lf mq lh li lj ij bi translated">太好了。我们有训练有素的模特。我们如何计算未来14天的天气预报？机器学习对特征矩阵<em class="lk"> X </em>建模，输出预测值<em class="lk"> y </em>。因此，我们需要为接下来的14天创建特征矩阵<em class="lk"> X </em>，并将其交给我们的模型。</p><p id="4a86" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">如果我们想得到第二天的<em class="lk"> lag-7 </em>，按照训练集，我们可以得到从末尾开始的第7个位置的值。训练集结束后两天的<em class="lk"> lag-7 </em>将是从末尾开始的第6个位置的值，依此类推。对于<em class="lk"> lag-14 </em>也是如此。</p><figure class="mr ms mt mu gt mv"><div class="bz fp l di"><div class="mw mx l"/></div></figure><figure class="mr ms mt mu gt mv gh gi paragraph-image"><div role="button" tabindex="0" class="ng nh di ni bf nj"><div class="gh gi nl"><img src="../Images/639325b5eb8acf0f18e34307c643b818.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XKCOoXwHDHfRVZoPZ9OrIg.png"/></div></div><p class="nb nc gj gh gi nd ne bd b be z dk translated">作者图片</p></figure><figure class="mr ms mt mu gt mv"><div class="bz fp l di"><div class="mw mx l"/></div></figure><figure class="mr ms mt mu gt mv gh gi paragraph-image"><div role="button" tabindex="0" class="ng nh di ni bf nj"><div class="gh gi nm"><img src="../Images/6c12126fbc8fed5ef32b1916a93b8f99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k_5hRfUuxDyYouKv5N4gNA.png"/></div></div><p class="nb nc gj gh gi nd ne bd b be z dk translated">作者图片</p></figure><p id="d9a0" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">您可能已经注意到，我们只能从历史记录中获得7个<em class="lk"> lag-7 </em>值，而我们可以获得所有14个<em class="lk"> lag-14 </em>值。有了这些信息，我们只能预测接下来的7天，所以我们只取<em class="lk">滞后-14 </em>的前7个值。</p><figure class="mr ms mt mu gt mv"><div class="bz fp l di"><div class="mw mx l"/></div></figure><figure class="mr ms mt mu gt mv gh gi paragraph-image"><div role="button" tabindex="0" class="ng nh di ni bf nj"><div class="gh gi nn"><img src="../Images/7d113303c4a41f952714275191e0268d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t3a3BEereO7hgfwr41F4MQ.png"/></div></div><p class="nb nc gj gh gi nd ne bd b be z dk translated">作者图片</p></figure><p id="5bce" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">有了这些功能，我们可以计算未来7天的天气预报。</p><figure class="mr ms mt mu gt mv"><div class="bz fp l di"><div class="mw mx l"/></div></figure><figure class="mr ms mt mu gt mv gh gi paragraph-image"><div role="button" tabindex="0" class="ng nh di ni bf nj"><div class="gh gi nn"><img src="../Images/4c2a45d10bbce45430f40ffeeb2cd6e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ntbWdxo_smaiVdFVR3YFVQ.png"/></div></div><p class="nb nc gj gh gi nd ne bd b be z dk translated">作者图片</p></figure><p id="8697" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">这些值可以解释为最后一次训练日期后接下来7天的系列值。为了计算该日期之后的预测，我们可以使用这些值，就像它们是我们系列的值一样，并将它们用作后续期间的<em class="lk"> lag-7 </em>。</p><p id="9379" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">换句话说，我们可以用这些值和<em class="lk"> lag-14 </em>的真实值填充特征矩阵的其余部分。</p><figure class="mr ms mt mu gt mv"><div class="bz fp l di"><div class="mw mx l"/></div></figure><figure class="mr ms mt mu gt mv gh gi paragraph-image"><div role="button" tabindex="0" class="ng nh di ni bf nj"><div class="gh gi no"><img src="../Images/872702a72d37e586f5dc8d53b6e512e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W_G41I8nwjWTmv0yWkKY1Q.png"/></div></div><p class="nb nc gj gh gi nd ne bd b be z dk translated">作者图片</p></figure><p id="ab8b" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">如你所见，我们仍在使用<em class="lk"> lag-14 </em>的真实值，并且我们插入了我们的预测值作为<em class="lk"> lag-7 </em>的值。我们现在可以使用这些特征来预测剩余的7天。</p><figure class="mr ms mt mu gt mv"><div class="bz fp l di"><div class="mw mx l"/></div></figure><figure class="mr ms mt mu gt mv gh gi paragraph-image"><div role="button" tabindex="0" class="ng nh di ni bf nj"><div class="gh gi np"><img src="../Images/12259249d5ec72ed94cc8ff73cc856a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JiaLHtmFGdKvaBE9erESzA.png"/></div></div><p class="nb nc gj gh gi nd ne bd b be z dk translated">作者图片</p></figure><p id="4ddb" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">现在我们有了未来14天的预测！这并不痛苦，但也不漂亮或容易。我们刚刚使用了滞后，这是我们可以拥有的最简单的功能。</p><p id="b833" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">如果我们使用了<em class="lk"> lag-1 </em>会怎么样？我们需要做这个预测更新步骤14次！</p><p id="25b1" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">如果我们有更精细的特征，比如在一段时间内的滚动平均值，会怎么样呢？正如你可以想象的那样，它会变得相当混乱，而且很容易出错。</p><h2 id="e777" class="lu lv iq bd lw lx ly dn lz ma mb dp mc kx md me mf lb mg mh mi lf mj mk ml iw bi translated">ml预测</h2><p id="cfbb" class="pw-post-body-paragraph ko kp iq kq b kr mm ka kt ku mn kd kw kx mo kz la lb mp ld le lf mq lh li lj ij bi translated">带着这些问题，我们创建了<a class="ae ll" href="https://github.com/Nixtla/mlforecast" rel="noopener ugc nofollow" target="_blank"> mlforecast </a>，这是一个帮助你使用机器学习模型预测时间序列的框架。它为你处理所有这些混乱的细节。你只需要给它一个模型，并定义你想要使用的功能，让<em class="lk"> mlforecast </em>做剩下的事情。</p><p id="13b0" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated"><strong class="kq ja"> mlforecast </strong>在<a class="ae ll" href="https://pypi.org/project/mlforecast/" rel="noopener ugc nofollow" target="_blank"> PyPI </a> ( <code class="fe nq nr ns nt b">pip install mlforecast</code>)以及<a class="ae ll" href="https://anaconda.org/conda-forge/mlforecast" rel="noopener ugc nofollow" target="_blank"> conda-forge </a> ( <code class="fe nq nr ns nt b">conda install -c conda-forge mlforecast</code>)中均有。</p><p id="6730" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">使用<strong class="kq ja"> mlforecast </strong>和以下代码可以解决之前描述的问题。</p><p id="80f7" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">首先，我们必须按照要求的格式设置数据。</p><figure class="mr ms mt mu gt mv"><div class="bz fp l di"><div class="mw mx l"/></div></figure><figure class="mr ms mt mu gt mv gh gi paragraph-image"><div role="button" tabindex="0" class="ng nh di ni bf nj"><div class="gh gi nu"><img src="../Images/6b3fd3d89b8a80a40f98463199daeac9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vhNkbtEVUgwYj_0lnKEP6A.png"/></div></div><p class="nb nc gj gh gi nd ne bd b be z dk translated">作者图片</p></figure><p id="8658" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">这是必需的输入格式。</p><ul class=""><li id="fd71" class="nv nw iq kq b kr ks ku kv kx nx lb ny lf nz lj oa ob oc od bi translated">一个名为<strong class="kq ja"> unique_id </strong>的索引，用于标识每个时间序列。在这种情况下，我们只有一个，但是你想要多少就有多少。</li><li id="9df5" class="nv nw iq kq b kr oe ku of kx og lb oh lf oi lj oa ob oc od bi translated">带有日期的<strong class="kq ja"> ds </strong>栏。</li><li id="be59" class="nv nw iq kq b kr oe ku of kx og lb oh lf oi lj oa ob oc od bi translated">带有值的<strong class="kq ja"> y </strong>列。</li></ul><p id="eb5f" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">现在我们将导入<a class="ae ll" href="https://nixtla.github.io/mlforecast/core.html#TimeSeries" rel="noopener ugc nofollow" target="_blank">时间序列</a>转换器，在这里我们定义我们想要使用的特性。我们还将导入<a class="ae ll" href="https://nixtla.github.io/mlforecast/forecast.html#Forecast" rel="noopener ugc nofollow" target="_blank">预测</a>类，它将保存我们的转换器和模型，并将为我们运行预测管道。</p><figure class="mr ms mt mu gt mv"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="9842" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">我们初始化我们的转换器，指定我们想要使用的滞后。</p><figure class="mr ms mt mu gt mv"><div class="bz fp l di"><div class="mw mx l"/></div></figure><figure class="mr ms mt mu gt mv gh gi paragraph-image"><div role="button" tabindex="0" class="ng nh di ni bf nj"><div class="gh gi oj"><img src="../Images/591b3ffa3537a2e77b85610b269cb81f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*220R5J6Q1v9HL3l_zLExkQ.png"/></div></div><p class="nb nc gj gh gi nd ne bd b be z dk translated">作者图片</p></figure><p id="8bf8" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">如你所见，该变压器将使用<em class="lk">滞后-7 </em>和<em class="lk">滞后-14 </em>作为特征。现在我们定义我们的模型。</p><figure class="mr ms mt mu gt mv"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="5434" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">我们用模型和时序转换器创建一个<a class="ae ll" href="https://nixtla.github.io/mlforecast/forecast.html" rel="noopener ugc nofollow" target="_blank">预测</a>对象，并使其适合我们的数据。</p><figure class="mr ms mt mu gt mv"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="2804" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">现在，我们只需调用我们想要的预测范围的预测。</p><figure class="mr ms mt mu gt mv"><div class="bz fp l di"><div class="mw mx l"/></div></figure><figure class="mr ms mt mu gt mv gh gi paragraph-image"><div role="button" tabindex="0" class="ng nh di ni bf nj"><div class="gh gi nk"><img src="../Images/4a2da0f21c0573e510328632bcd47c23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2aa4guARpt5vH57giMI73g.png"/></div></div><p class="nb nc gj gh gi nd ne bd b be z dk translated">作者图片</p></figure><p id="83ce" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">这要容易得多，在内部，这与我们以前做的一样。让我们快速验证一下。</p><p id="f1b5" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">检查我们是否得到了相同的预测:</p><figure class="mr ms mt mu gt mv"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="92f4" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">检查我们是否有相同的型号:</p><figure class="mr ms mt mu gt mv"><div class="bz fp l di"><div class="mw mx l"/></div></figure><h2 id="641d" class="lu lv iq bd lw lx ly dn lz ma mb dp mc kx md me mf lb mg mh mi lf mj mk ml iw bi translated">实验变得更容易</h2><p id="d883" class="pw-post-body-paragraph ko kp iq kq b kr mm ka kt ku mn kd kw kx mo kz la lb mp ld le lf mq lh li lj ij bi translated">有了这种高层次的抽象，我们就可以专注于定义最好的特性和模型，而不是担心实现细节。例如，我们可以通过编写一个利用<em class="lk"> mlforecast </em>的简单函数来非常容易地尝试不同的滞后:</p><figure class="mr ms mt mu gt mv"><div class="bz fp l di"><div class="mw mx l"/></div></figure><figure class="mr ms mt mu gt mv"><div class="bz fp l di"><div class="mw mx l"/></div></figure><figure class="mr ms mt mu gt mv gh gi paragraph-image"><div role="button" tabindex="0" class="ng nh di ni bf nj"><div class="gh gi nm"><img src="../Images/2a677c6779ec20e7cd896d5bdff9be45.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PJqGfDJk40Biu6NHlZQu_w.png"/></div></div><p class="nb nc gj gh gi nd ne bd b be z dk translated">作者图片</p></figure><figure class="mr ms mt mu gt mv"><div class="bz fp l di"><div class="mw mx l"/></div></figure><figure class="mr ms mt mu gt mv gh gi paragraph-image"><div role="button" tabindex="0" class="ng nh di ni bf nj"><div class="gh gi nm"><img src="../Images/e24872ac9c614c27f9ca9527ed25998d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BvsdT81OOtKOD7EwDZembQ.png"/></div></div><p class="nb nc gj gh gi nd ne bd b be z dk translated">作者图片</p></figure><figure class="mr ms mt mu gt mv"><div class="bz fp l di"><div class="mw mx l"/></div></figure><figure class="mr ms mt mu gt mv gh gi paragraph-image"><div role="button" tabindex="0" class="ng nh di ni bf nj"><div class="gh gi nn"><img src="../Images/2f3b6a98395c46a1283785625de50f26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K_tD7ig7R4RTBZ5ofxwkRw.png"/></div></div><p class="nb nc gj gh gi nd ne bd b be z dk translated">作者图片</p></figure><h2 id="9f3e" class="lu lv iq bd lw lx ly dn lz ma mb dp mc kx md me mf lb mg mh mi lf mj mk ml iw bi translated">回溯测试</h2><p id="9e52" class="pw-post-body-paragraph ko kp iq kq b kr mm ka kt ku mn kd kw kx mo kz la lb mp ld le lf mq lh li lj ij bi translated">在前面的例子中，我们手动分割数据。<strong class="kq ja">预测</strong>对象也有一个<a class="ae ll" href="https://nixtla.github.io/mlforecast/forecast.html#Backtesting" rel="noopener ugc nofollow" target="_blank">回溯测试</a>方法可以为我们做到这一点。</p><p id="8ca3" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">我们将首先把所有的数据转换成所需的格式。</p><figure class="mr ms mt mu gt mv"><div class="bz fp l di"><div class="mw mx l"/></div></figure><figure class="mr ms mt mu gt mv gh gi paragraph-image"><div role="button" tabindex="0" class="ng nh di ni bf nj"><div class="gh gi nl"><img src="../Images/30c46cd4a1d10b34f00918dbce2cc377.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wNXiiS4OBMFFUzXJqxhrmQ.png"/></div></div><p class="nb nc gj gh gi nd ne bd b be z dk translated">作者图片</p></figure><p id="c2ee" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">现在我们像以前一样实例化一个<code class="fe nq nr ns nt b">Forecast</code>对象，并调用<code class="fe nq nr ns nt b">backtest</code>方法。</p><figure class="mr ms mt mu gt mv"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="dc97" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">这将返回一个生成器，其中包含每个窗口的结果。</p><figure class="mr ms mt mu gt mv"><div class="bz fp l di"><div class="mw mx l"/></div></figure><figure class="mr ms mt mu gt mv gh gi paragraph-image"><div role="button" tabindex="0" class="ng nh di ni bf nj"><div class="gh gi nl"><img src="../Images/9c06164d5a4bcab40cb81a0fb25433c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KrBp9SWEPtFf7CNe7b60qw.png"/></div></div><p class="nb nc gj gh gi nd ne bd b be z dk translated">作者图片</p></figure><figure class="mr ms mt mu gt mv"><div class="bz fp l di"><div class="mw mx l"/></div></figure><figure class="mr ms mt mu gt mv gh gi paragraph-image"><div role="button" tabindex="0" class="ng nh di ni bf nj"><div class="gh gi nf"><img src="../Images/a40e1af79d3020e94e0ca5e877eac7f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0pi1T8d1cKRvKydDMTtHaw.png"/></div></div><p class="nb nc gj gh gi nd ne bd b be z dk translated">作者图片</p></figure><figure class="mr ms mt mu gt mv"><div class="bz fp l di"><div class="mw mx l"/></div></figure><figure class="mr ms mt mu gt mv gh gi paragraph-image"><div role="button" tabindex="0" class="ng nh di ni bf nj"><div class="gh gi ok"><img src="../Images/348da694e105f681c7d35cee13c6b4f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dNNp6TvIsKNZ5zyv-tB_Rw.png"/></div></div><p class="nb nc gj gh gi nd ne bd b be z dk translated">作者图片</p></figure><p id="4c50" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated"><code class="fe nq nr ns nt b">result2</code>这里和我们手动做的评估一样。</p><figure class="mr ms mt mu gt mv"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="c826" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">我们可以使用几个窗口为不同的滞后定义一个验证方案。</p><figure class="mr ms mt mu gt mv"><div class="bz fp l di"><div class="mw mx l"/></div></figure><figure class="mr ms mt mu gt mv"><div class="bz fp l di"><div class="mw mx l"/></div></figure><figure class="mr ms mt mu gt mv gh gi paragraph-image"><div role="button" tabindex="0" class="ng nh di ni bf nj"><div class="gh gi ol"><img src="../Images/96f829502a5b498f63ac58a52947a911.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-bPHZYasVxMCxGKQFRughw.png"/></div></div><p class="nb nc gj gh gi nd ne bd b be z dk translated">作者图片</p></figure><figure class="mr ms mt mu gt mv gh gi paragraph-image"><div class="ab gu cl my"><img src="../Images/5620bff6ccb080d807e6f60ecedaeac3.png" data-original-src="https://miro.medium.com/v2/format:webp/1*_O746H32Vw7iRBAxoatCcA.png"/></div><p class="nb nc gj gh gi nd ne bd b be z dk translated">作者图片</p></figure><figure class="mr ms mt mu gt mv"><div class="bz fp l di"><div class="mw mx l"/></div></figure><figure class="mr ms mt mu gt mv gh gi paragraph-image"><div role="button" tabindex="0" class="ng nh di ni bf nj"><div class="gh gi nn"><img src="../Images/d7fe36ff1eb5588894cb5e320c1382bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UbxVkXVOLHLrCOVh2xo55g.png"/></div></div><p class="nb nc gj gh gi nd ne bd b be z dk translated">作者图片</p></figure><figure class="mr ms mt mu gt mv gh gi paragraph-image"><div class="ab gu cl my"><img src="../Images/02d64fdc0e9438a4e862349233e2c239.png" data-original-src="https://miro.medium.com/v2/format:webp/1*1eB3pAl_fVnm_tituRXRqA.png"/></div><p class="nb nc gj gh gi nd ne bd b be z dk translated">作者图片</p></figure><figure class="mr ms mt mu gt mv"><div class="bz fp l di"><div class="mw mx l"/></div></figure><figure class="mr ms mt mu gt mv gh gi paragraph-image"><div role="button" tabindex="0" class="ng nh di ni bf nj"><div class="gh gi nm"><img src="../Images/4a292514215b83dc075556d0cc1e73b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*db_J6fD5u5BBQecN3dgUJw.png"/></div></div><p class="nb nc gj gh gi nd ne bd b be z dk translated">作者图片</p></figure><figure class="mr ms mt mu gt mv gh gi paragraph-image"><div class="ab gu cl my"><img src="../Images/de36cd1e6af70ba94844f0c08e1bf0d6.png" data-original-src="https://miro.medium.com/v2/format:webp/1*AkHuTf39Ecft0CHnd5X8kQ.png"/></div><p class="nb nc gj gh gi nd ne bd b be z dk translated">作者图片</p></figure><h2 id="3ff6" class="lu lv iq bd lw lx ly dn lz ma mb dp mc kx md me mf lb mg mh mi lf mj mk ml iw bi translated">滞后转换</h2><p id="6d91" class="pw-post-body-paragraph ko kp iq kq b kr mm ka kt ku mn kd kw kx mo kz la lb mp ld le lf mq lh li lj ij bi translated">我们可以指定滞后上的转换，也可以只指定滞后。<a class="ae ll" href="https://github.com/jose-moralez/window_ops" rel="noopener ugc nofollow" target="_blank"> window_ops </a>库有一些不同窗口函数的实现。您也可以定义自己的转换。</p><p id="8b95" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">让我们试试季节性滚动平均值，这是过去<code class="fe nq nr ns nt b">n</code>个季节的平均值，在这种情况下，它将是过去<code class="fe nq nr ns nt b">n</code>周一、周二等的平均值。计算这个特性的更新可能会有点烦人，但是，使用这个框架，我们可以把它传递给<em class="lk"> lag_transforms </em>。如果转换需要额外的参数(除了序列的值之外)，我们指定一个类似于<code class="fe nq nr ns nt b">(transform_function, arg1, arg2)</code>的元组，在本例中是<code class="fe nq nr ns nt b">season_length</code>和<code class="fe nq nr ns nt b">window_size</code>。</p><figure class="mr ms mt mu gt mv"><div class="bz fp l di"><div class="mw mx l"/></div></figure><pre class="mr ms mt mu gt om nt on oo aw op bi"><span id="a3f0" class="lu lv iq nt b gy oq or l os ot">help(seasonal_rolling_mean)</span><span id="1dbf" class="lu lv iq nt b gy ou or l os ot">Help on CPUDispatcher in module window_ops.rolling:<br/><br/>seasonal_rolling_mean(input_array: numpy.ndarray, season_length: int, window_size: int, min_samples: Union[int, NoneType] = None) -&gt; numpy.ndarray<br/>    Compute the seasonal_rolling_mean over the last non-na window_size samples of the<br/>    input array starting at min_samples.</span></pre><p id="0244" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated"><em class="lk"> lag_transforms </em>获取一个字典，其中键是我们想要应用转换的lag，值是转换本身。</p><figure class="mr ms mt mu gt mv"><div class="bz fp l di"><div class="mw mx l"/></div></figure><figure class="mr ms mt mu gt mv gh gi paragraph-image"><div role="button" tabindex="0" class="ng nh di ni bf nj"><div class="gh gi nf"><img src="../Images/2e1e4751c4a12abb7ea6a70c9f5b72ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rEh33GcCPs5aTpQYpSw9Ew.png"/></div></div><p class="nb nc gj gh gi nd ne bd b be z dk translated">作者图片</p></figure><figure class="mr ms mt mu gt mv gh gi paragraph-image"><div class="ab gu cl my"><img src="../Images/6a821ce042b4fa7c24ee29da525df0b8.png" data-original-src="https://miro.medium.com/v2/format:webp/1*Cz8l2uA8HdfIw1oiiLDszA.png"/></div><p class="nb nc gj gh gi nd ne bd b be z dk translated">作者图片</p></figure><h2 id="f3e0" class="lu lv iq bd lw lx ly dn lz ma mb dp mc kx md me mf lb mg mh mi lf mj mk ml iw bi translated">日期功能</h2><p id="e672" class="pw-post-body-paragraph ko kp iq kq b kr mm ka kt ku mn kd kw kx mo kz la lb mp ld le lf mq lh li lj ij bi translated">您还可以指定要计算的日期特性，这些特性是<strong class="kq ja"> ds </strong>列的属性，并且也在每个时间步长中更新。在本例中，最好的模型是取一周中每一天的平均值，这可以通过对一周中的某一天列进行一次性编码并拟合线性模型来实现。</p><figure class="mr ms mt mu gt mv"><div class="bz fp l di"><div class="mw mx l"/></div></figure><figure class="mr ms mt mu gt mv gh gi paragraph-image"><div role="button" tabindex="0" class="ng nh di ni bf nj"><div class="gh gi oj"><img src="../Images/3073d7d199edb99cb5d0814d0464d7eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GbCsgVPppo-rJJBhENVvGg.png"/></div></div><p class="nb nc gj gh gi nd ne bd b be z dk translated">作者图片</p></figure><figure class="mr ms mt mu gt mv gh gi paragraph-image"><div class="ab gu cl my"><img src="../Images/ef841fe8192c5c8104e40451fb34c835.png" data-original-src="https://miro.medium.com/v2/format:webp/1*q_jGr973Tgi5TiRrJj1XSg.png"/></div><p class="nb nc gj gh gi nd ne bd b be z dk translated">作者图片</p></figure><h2 id="4eb8" class="lu lv iq bd lw lx ly dn lz ma mb dp mc kx md me mf lb mg mh mi lf mj mk ml iw bi translated">后续步骤</h2><p id="0af0" class="pw-post-body-paragraph ko kp iq kq b kr mm ka kt ku mn kd kw kx mo kz la lb mp ld le lf mq lh li lj ij bi translated">mlforecast 拥有更多类似<a class="ae ll" href="https://nixtla.github.io/mlforecast/distributed.forecast.html#Example" rel="noopener ugc nofollow" target="_blank">分布式训练</a>和<a class="ae ll" href="https://nixtla.github.io/mlforecast/cli.html#Example" rel="noopener ugc nofollow" target="_blank"> CLI </a>的特性。如果您感兴趣，可以从以下资源中了解更多信息:</p><ul class=""><li id="01c3" class="nv nw iq kq b kr ks ku kv kx nx lb ny lf nz lj oa ob oc od bi translated">GitHub回购:<a class="ae ll" href="https://github.com/Nixtla/mlforecast" rel="noopener ugc nofollow" target="_blank">https://github.com/Nixtla/mlforecast</a></li><li id="0201" class="nv nw iq kq b kr oe ku of kx og lb oh lf oi lj oa ob oc od bi translated">文档:<a class="ae ll" href="https://nixtla.github.io/mlforecast/" rel="noopener ugc nofollow" target="_blank">https://nixtla.github.io/mlforecast/</a></li><li id="5f3c" class="nv nw iq kq b kr oe ku of kx og lb oh lf oi lj oa ob oc od bi translated">在https://www.kaggle.com/lemuz90/m5-mlforecast的M5竞赛中使用mlforecast的示例:<a class="ae ll" href="https://www.kaggle.com/lemuz90/m5-mlforecast" rel="noopener ugc nofollow" target="_blank"/></li></ul></div></div>    
</body>
</html>