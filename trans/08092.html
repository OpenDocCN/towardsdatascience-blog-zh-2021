<html>
<head>
<title>Gaps and Islands Problem with MySQL</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">MySQL的差距和孤岛问题</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/gaps-and-islands-with-mysql-b407040d133d?source=collection_archive---------6-----------------------#2021-07-25">https://towardsdatascience.com/gaps-and-islands-with-mysql-b407040d133d?source=collection_archive---------6-----------------------#2021-07-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="59a7" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何用SQL分析序列和时间序列，或者如何操作SQL语言使其对时间序列更加友好</h2></div></div><div class="ab cl kf kg hu kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="ij ik il im in"><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/8eb95ceaa3ba6005fc8b6b5592109bdf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y6WafkmicIy5nYTwHZLj3A.jpeg"/></div></div><p class="ky kz gj gh gi la lb bd b be z dk translated">信用:<a class="ae lc" href="https://pixabay.com/users/julius_silver-4371822/" rel="noopener ugc nofollow" target="_blank">朱利叶斯·西尔弗</a></p></figure><p id="1bde" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">随着世界变得越来越互联，物联网设备在我们的日常生活中占据越来越大的部分，我们周围有如此多的设备和传感器，特别是当其中一些设备和传感器位于并负责敏感功能时，我们必须知道如何监控它们。</p><p id="07bc" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">监控这些设备的一个重要方面是分析来自传感器数据的统计指标。这些数据通常以具有单一指标的时间序列格式存储，可以是二进制或连续数据，在本文中，我将展示如何使用SQL分析这两种选项。</p><p id="b34b" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">用MySQL分析时间序列可能具有挑战性，因为它不是处理这种数据的理想方法。在下面呈现的查询中，有许多子查询会降低查询的效率，因为子查询丢失了原始数据索引。</p><p id="ea5b" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">虽然有更好的方法来处理时间序列数据流，但在许多情况下，来自生产环境的原始数据是使用MySQL数据库存储的，因此使用这种方法可以避免漫长而昂贵的ETL管道，从而节省时间和金钱。</p><blockquote class="lz ma mb"><p id="e6d8" class="ld le mc lf b lg lh jr li lj lk ju ll md ln lo lp me lr ls lt mf lv lw lx ly ij bi translated">老实说，直到我写这篇文章的参考，我不知道这个问题有一个名字，这是一个已知的问题——差距和岛屿问题。岛的意思是“正常的”序列(在我们的例子中是1 ),而缺口是成为没有错误和中断的完美序列的障碍。所以我们正在解决一个已知的问题，在我看来，理解了问题就等于解决了一半。</p></blockquote><h2 id="36fc" class="mg mh iq bd mi mj mk dn ml mm mn dp mo lm mp mq mr lq ms mt mu lu mv mw mx my bi translated">二元序列</h2><p id="7e3e" class="pw-post-body-paragraph ld le iq lf b lg mz jr li lj na ju ll lm nb lo lp lq nc ls lt lu nd lw lx ly ij bi translated">给定一组数据序列，例如:传感器数据为0和1，1表示连接，0表示断开，您希望确定停机时间并更好地了解传感器的行为。信息包括:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/9f80d551a16342891d8afdfc8723873c.png" data-original-src="https://miro.medium.com/v2/resize:fit:720/0*0n81ZwPBjMpzJJSq"/></div><p class="ky kz gj gh gi la lb bd b be z dk translated">序列数据</p></figure><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi nf"><img src="../Images/8fb4191678a8fc823d87570edfa0a902.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*GNY59gSekTcDiSbF"/></div></div><p class="ky kz gj gh gi la lb bd b be z dk translated">传感器超时</p></figure><ol class=""><li id="56ab" class="ng nh iq lf b lg lh lj lk lm ni lq nj lu nk ly nl nm nn no bi translated">设备的总停机时间是多少？</li></ol><p id="286d" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">2.如何求不间断1值序列的最大长度？</p><p id="ec3f" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">3.传感器在两者之间切换多少次？</p><p id="3064" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">4.最长的停机/正常运行时间是多久？</p><p id="9376" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">5.平均停机时间是多少？</p><p id="b915" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">我们可以看到传感器几乎每分钟都在报告。要回答第一个问题“设备停机的总时间是多少？”我们可以估计值为0的行数，并乘以60秒。汇总这个数量可以为我们提供传感器的总停机时间，但这只是一个估计，如果探测之间存在延迟，并且每两个数据包之间的速率将上升到70秒甚至更长，该怎么办？</p><p id="1a65" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">目前计算这一停机时间的方法是将每个零序列分组，找出第一个和最后一个包之间的时间差，然后汇总这些差异。</p><p id="b87c" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">这可以通过使用MySQL的4个简单步骤来解决:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="np nq l"/></div><p class="ky kz gj gh gi la lb bd b be z dk translated">第一步</p></figure><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/3b70f32aa0f7a454f63d059c45c4bcc8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1006/format:webp/1*wbb_LFUbgXCheEZNTulGPQ.png"/></div><p class="ky kz gj gh gi la lb bd b be z dk translated">第一步的结果</p></figure><p id="4bd7" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">在第一步中，我们使用了两个窗口函数，第一个函数ROW_NUMBER()按时间对数据点进行编号，而第二个函数ROW_NUMBER()按值对数据点分区进行编号，这意味着第二个函数为每个值提供连续计数(分隔0和1的序列)。</p><p id="e82e" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">在第2步中，我们将计算<em class="mc">continues _ seq-</em>seq _ by _ value，并获得每个序列的唯一编号！</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="np nq l"/></div></figure><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/676d0c68a135a296eaf97fdf6438d42d.png" data-original-src="https://miro.medium.com/v2/resize:fit:670/format:webp/1*shnUy6YXXCPh5u6mPRZ1zA.png"/></div></figure><p id="5e09" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">现在，我们从传感器获得的数据中的每个序列都有一个唯一的id！从这里开始，可以很容易地从这些数据中查询统计数据，因为我们对每个停机时间都有一个唯一的名称。基于这种操作，我们可以使用基于值为0的seq _ ids的<code class="fe nt nu nv nw b">GROUP BY</code>来回答第一个问题，并将其与我们对<code class="fe nt nu nv nw b">number_row_0 * 60</code>的估计进行比较</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="np nq l"/></div></figure><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/bf0c4b8fe8b4e40fd141406d3b72d58f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1384/format:webp/1*ikE2RX3_QqbgAND4gA-dvQ.png"/></div><p class="ky kz gj gh gi la lb bd b be z dk translated">每个序列具有唯一id的数据</p></figure><p id="b59b" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">在上面显示的具体案例中，我们得到了预计停机时间的<code class="fe nt nu nv nw b">number_row_0 * 60 = 9120 secounds</code>和准确停机时间的<code class="fe nt nu nv nw b">sum(time_diff_s) = 5104 seconds</code>！</p><p id="c3ef" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">为了回答最大停机时间、平均停机时间等其他问题，我们可以使用以下查询:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="np nq l"/></div></figure><h2 id="435d" class="mg mh iq bd mi mj mk dn ml mm mn dp mo lm mp mq mr lq ms mt mu lu mv mw mx my bi translated">连续序列</h2><p id="57be" class="pw-post-body-paragraph ld le iq lf b lg mz jr li lj na ju ll lm nb lo lp lq nc ls lt lu nd lw lx ly ij bi translated">我们的下一个例子展示了带有累积数据的时间序列数据，其中的值可以表示任何累积的指标。例如，传输的数据、自最近一次重启以来的时间、或者从零开始并一直上升的任何度量。(无季节性)</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/bfae968a8c1eba77aac67613b11640f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:686/format:webp/1*E-baWQ3MtircEtcexragVg.png"/></div><p class="ky kz gj gh gi la lb bd b be z dk translated">累积值数据集</p></figure><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi nz"><img src="../Images/40f9892eb747e27e284de6c41240caac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*97a7N5ObOf_Fthpbzt6dxA.png"/></div></div><p class="ky kz gj gh gi la lb bd b be z dk translated">原始数据超时</p></figure><p id="e223" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">在这种情况下，我们可以问自己几个新问题:</p><ol class=""><li id="2812" class="ng nh iq lf b lg lh lj lk lm ni lq nj lu nk ly nl nm nn no bi translated">计数器重新开始了多少次？</li><li id="6d8b" class="ng nh iq lf b lg oa lj ob lm oc lq od lu oe ly nl nm nn no bi translated">每个序列中的最大值是多少？</li><li id="76c6" class="ng nh iq lf b lg oa lj ob lm oc lq od lu oe ly nl nm nn no bi translated">每个序列的平均周期是多少？</li></ol><p id="8555" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">对于这类数据，我们将使用窗口函数*LEAD*和*LAG*，在我们的第一部分之后，这将更加直观和简单</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="np nq l"/></div></figure><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi of"><img src="../Images/71d432b1e9e3d88b68e4fe54bc9f531f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1046/format:webp/1*0jr4jzWNXjFkvtvjmE3WEg.png"/></div><p class="ky kz gj gh gi la lb bd b be z dk translated">窗口函数</p></figure><p id="f21f" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">在步骤1中，我们使用了LEAD window函数，该函数用于提供当前行之后的行中的值，利用该功能，我们可以计算每个值与下一个值之间的差异——在我们的示例中，这些值是累积的，因此我们希望每个值都比前一个值高。</p><p id="6fc4" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">在第一步之后，我们可以很容易地识别每个序列的开始时间和结束时间，并定义每个序列的行为，只需从<code class="fe nt nu nv nw b">diff_min</code> [LAG()]中选择负值，从<code class="fe nt nu nv nw b">diff_plus</code> [LEAD()]中选择正值，然后找到其最大值。</p><p id="ec01" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">为了计算计数器重新开始的次数，我们只需要从<code class="fe nt nu nv nw b">diff_min</code>开始计算负值。</p><p id="e04b" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated"><strong class="lf ir">总结</strong></p><p id="3825" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">在这篇文章中，我展示了如何使用SQL分析类似序列的数据。第一部分重点介绍离散和二进制数据集，它们仅代表值为1和0的信号。我展示了如何使用<em class="mc"> ROW_NUMBER </em> () window函数为每个0 / 1序列提供一个惟一的id，这使得分析和统计计算更加简单。</p><p id="984e" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">第二章集中于连续的数据集，其中的值随着时间的推移而增加。我展示了如何使用LAG()和LEAD()窗口函数，并分析这种时间序列数据流。</p><p id="1784" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">我希望您发现这个用例的这些解决方案(使用MySQL来分析时间序列数据集)有趣且有用，就像我在日常工作中所做的那样。</p><h2 id="c4a5" class="mg mh iq bd mi mj mk dn ml mm mn dp mo lm mp mq mr lq ms mt mu lu mv mw mx my bi translated">额外阅读</h2><ol class=""><li id="dfc8" class="ng nh iq lf b lg mz lj na lm og lq oh lu oi ly nl nm nn no bi translated"><a class="ae lc" href="https://dev.mysql.com/doc/refman/8.0/en/window-function-descriptions.html" rel="noopener ugc nofollow" target="_blank">https://dev . MySQL . com/doc/ref man/8.0/en/window-function-descriptions . html</a></li><li id="d72e" class="ng nh iq lf b lg oa lj ob lm oc lq od lu oe ly nl nm nn no bi translated">【https://www.mysqltutorial.org/mysql-window-functions/ T4】</li><li id="6fc6" class="ng nh iq lf b lg oa lj ob lm oc lq od lu oe ly nl nm nn no bi translated"><a class="ae lc" href="https://stackoverflow.com/questions/58472798/mysql-how-to-find-the-maximum-length-of-an-uninterrupted-sequence-of-certain-va" rel="noopener ugc nofollow" target="_blank">https://stack overflow . com/questions/58472798/MySQL-how-to-find-the-maximum-length-of-an-uncontinued-sequence-of-a-determined-a-va</a></li><li id="5776" class="ng nh iq lf b lg oa lj ob lm oc lq od lu oe ly nl nm nn no bi translated"><a class="ae lc" href="https://www.red-gate.com/simple-talk/sql/t-sql-programming/the-sql-of-gaps-and-islands-in-sequences/#:~:text=The%20word%20'Gaps'%20in%20the,between%20them%20in%20a%20column" rel="noopener ugc nofollow" target="_blank">https://www . red-gate . com/simple-talk/SQL/t-SQL-programming/The-SQL-of-gap-and-islands-in-sequences/#:~:text = The % 20 word % 20 ' gap ' % 20in % 20th，between % 20 them % 20in % 20a % 20 column</a>。</li></ol></div></div>    
</body>
</html>