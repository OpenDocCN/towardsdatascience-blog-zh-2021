<html>
<head>
<title>Locality Sensitive Hashing in NLP</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">自然语言处理中的位置敏感哈希算法</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/locality-sensitive-hashing-in-nlp-1fb3d4a7ba9f?source=collection_archive---------12-----------------------#2021-10-01">https://towardsdatascience.com/locality-sensitive-hashing-in-nlp-1fb3d4a7ba9f?source=collection_archive---------12-----------------------#2021-10-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="348c" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">这是一个实践教程，介绍如何通过区域敏感散列法(LSH)减少搜索空间来加速文档检索</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/b985ef2a9ef74a4df062249ce1ac7854.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Nb0DqKExKBkJpLSA"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">马库斯·温克勒在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><h1 id="b097" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">眼前的问题</h1><p id="7664" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">在我最近的一个<a class="ae kv" href="https://github.com/rajlm10/Pharmacat" rel="noopener ugc nofollow" target="_blank">项目</a>中，我需要分析类似于病人投诉的医疗问题是否在早期得到了诊断和记录，以及这些投诉表明了什么疾病。为了将当前患者的症状和问题与过去的其他记录进行比较，我需要将当前的问题文本与数据集中的所有其他文档进行比较，并找出最相似的文档。对于n个项目，这将涉及与当前文档的n次比较。而且，我用<strong class="lq ir"> DistilBERT </strong>对这些句子进行了编码；因此，比较(余弦相似性)也与这些文档的嵌入维度(768)成比例。<em class="mk">我使用过的医学数据集在这里</em>   <em class="mk">可用</em> <a class="ae kv" href="https://archive.ics.uci.edu/ml/datasets/Drug+Review+Dataset+%28Drugs.com%29" rel="noopener ugc nofollow" target="_blank"> <strong class="lq ir"> <em class="mk">。</em>这是数据的样子。</strong></a></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ml mm l"/></div></figure><h1 id="88b4" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">我们能改进传统搜索吗？</h1><p id="8f73" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">如果我们能够以某种方式减少搜索空间，而不是将向量与所有文档进行比较，这不是很好吗？这正是位置敏感哈希(LSH)帮助我们做的。下面是我们如何使用LSH来减少搜索空间。</p><h1 id="42b5" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">LSH使用超平面背后的直觉</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/89cbc9c148da6219a2280e8dd34c3f98.png" data-original-src="https://miro.medium.com/v2/resize:fit:880/format:webp/1*arW6jjcqd-prsYFMwEs01A.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">使用线条分割搜索空间(图片由作者提供)</p></figure><p id="b899" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mq lz ma mb mr md me mf ms mh mi mj ij bi translated">在上图中，我们有用“X”表示的各种数据点。假设我们想要找到与点A 最相似的点<strong class="lq ir">。首先，我们<strong class="lq ir"> <em class="mk">随机</em> </strong>画两条线<strong class="lq ir">(红蓝线)。现在我们可以看到一个数据点相对于每条线的位置。数据点可以在线的0侧，也可以在线的另一侧(1侧)。首先，我们找出所有数据点相对于两条线的位置。请注意，为了减少混乱，我在下表中只显示了4点。更重要的是，由于我们的设置是二维的，我用了一条<strong class="lq ir"> <em class="mk">线</em>。在更高维度中，这些线类似于超平面。</strong> <em class="mk">更正式地说，在n维设置中，超平面由(n-1)维组成。</em></strong></strong></p><p id="9887" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mq lz ma mb mr md me mf ms mh mi mj ij bi translated">这是我们当前设置在表格中的样子</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/adf59cc8049aa6c0b4931b795d100f71.png" data-original-src="https://miro.medium.com/v2/resize:fit:632/format:webp/1*8dw6dpJqkvdFinB-8_gFqA.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">点相对于平面的位置(图片由作者提供)</p></figure><p id="5240" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mq lz ma mb mr md me mf ms mh mi mj ij bi translated">从表中，我们可以看到A点和B点位于两个平面的同一侧。我们需要量化这个表，并给每个点分配一个哈希值。下面是散列值的计算方法。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/c3fff0878c9be77183821e31f21561e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:590/format:webp/1*99fBIgbBWforQgbOmZSm0Q.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">哈希值(作者图片)</p></figure><p id="2f72" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mq lz ma mb mr md me mf ms mh mi mj ij bi translated">下面是我们将这个公式应用到我们的环境中得到的结果。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/79daaab2d9c6a750737faa04cf491804.png" data-original-src="https://miro.medium.com/v2/resize:fit:648/format:webp/1*QEHXn9YpMmZpyQZPoFsRrQ.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">哈希值(作者图片)</p></figure><p id="22c5" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mq lz ma mb mr md me mf ms mh mi mj ij bi translated">我们可以看到，点A和B具有相同的哈希值，因此如果我们要构建哈希表，它们将位于相同的条目(哈希桶)中。<strong class="lq ir">简单来说，哈希表是允许即时查找的数据结构</strong>。它们大多是通过Python中的字典实现的，其中键是哈希值，字典值是我们的向量(数据点)。让我们用上面的4点构建一个散列表。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/777104b68a36a176b172663161038a7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1366/format:webp/1*CXH_fWQ7yddnZVbeuxpJGw.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">哈希表(作者图片)</p></figure><p id="44c6" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mq lz ma mb mr md me mf ms mh mi mj ij bi translated">现在我们可以清楚地看到，A点和B点在哈希表的同一个条目中。这表明这些点是相似的。<strong class="lq ir">如果我们想要找到与点A相似的点，我们需要做的就是查看与点A具有相同哈希值的点。</strong>这种简单的直觉在实践中非常有效，但是在继续实施之前，我们必须讨论一些技术细节。</p><h1 id="637f" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">我如何确定飞机的数量？</h1><p id="9955" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">在上面的简单设置中，我们随机画了两条线，但是当我们有更多的数据时，我们该怎么办呢？在飞机数量和速度之间有一个折衷。我们的飞机越多，处决LSH的时间就越长。下面是如何计算出要使用的飞机数量。</p><p id="a857" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mq lz ma mb mr md me mf ms mh mi mj ij bi translated"><strong class="lq ir">当我们有n个文档(或n个向量)时，我们希望每个散列条目(桶)不超过16个向量。在这种情况下，我们需要n/16个桶。现在每个平面将搜索空间分成两部分(同侧和相对侧)。因此，如果我们有p个平面，我们希望2^p等于n/16。求解p，我们可以找到飞机的数量。</strong>注意，可以根据问题和搜索空间的大小而改变，理想情况下，应该尝试不同的值，看看什么能给我们最好的结果。</p><h1 id="1d65" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">用数学方法确定向量位于平面的哪一侧</h1><p id="c6d0" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">上面我已经手动指示了两边。在更高维度中，<strong class="lq ir">点积帮助我们确定一个向量相对于平面位于哪一侧。每个平面都有一个法向量，一个垂直于平面上所有点的向量。我们必须取一个矢量，计算它与法向量的点积，看它在平面的哪一边。非负的点积表示它位于法线的同一侧，负的点积表示它位于法线的相反侧。<strong class="lq ir">一般情况下，表示为Ax+By+Cz=D的平面具有法线&lt; A，B，C &gt;。</strong></strong></p><p id="412f" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mq lz ma mb mr md me mf ms mh mi mj ij bi translated">这里有一个简单的图表来帮助你形象化这个过程。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mx"><img src="../Images/85e906ed223d7cd5f3df1636c4d4accb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DhDZO3LEKuUhxOYTjwFa_w.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">确定向量相对于超平面的位置(作者图片)</p></figure><p id="3e94" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mq lz ma mb mr md me mf ms mh mi mj ij bi translated">在上图中，我们可以看到向量V1位于平面的一侧，而向量v2位于平面的另一侧。</p><h1 id="457e" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">通过创建多个哈希表来提高准确性</h1><p id="735c" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">因为我们随机生成平面，所以可能将一些相似的向量分配给不同的桶。为了最小化这种随机性的影响，我们可以用不同的平面创建多个哈希表。在搜索向量时，我们可以在所有这些哈希表中寻找具有相同哈希值的向量。这将相对增加搜索空间，但大大提高准确性。<strong class="lq ir"> ( <em class="mk">注</em>:搜索空间仍然比原来的搜索空间小很多)。</strong>在代码中，我创建了25个哈希表。</p><h1 id="c659" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">让我们开始吧！</h1><p id="804e" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">在我们开始之前，这是我们的代码将要表示的。另外，请注意，我没有展示完整的代码，因为它很冗长。<strong class="lq ir">随意查看全部代码</strong> <a class="ae kv" href="https://jovian.ai/rajbsangani/nlp-pharmacat" rel="noopener ugc nofollow" target="_blank"> <strong class="lq ir"> <em class="mk">这里</em> </strong> </a> <strong class="lq ir">。</strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi my"><img src="../Images/614065e5d5554d726419532943894b71.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9KITucwaZDrGmdY0qfOiYg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">代码的可视化概述(图片由作者提供)</p></figure><h2 id="bb8e" class="mz kx iq bd ky na nb dn lc nc nd dp lg lx ne nf li mb ng nh lk mf ni nj lm nk bi translated">1.使用<a class="ae kv" href="https://medium.com/huggingface/distilbert-8cf3380435b5" rel="noopener"> <strong class="ak"> DistilBERT </strong> </a>将整个文本数据集编码成矢量(768维)。</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ml mm l"/></div></figure><h2 id="e479" class="mz kx iq bd ky na nb dn lc nc nd dp lg lx ne nf li mb ng nh lk mf ni nj lm nk bi translated">2.确定要使用的飞机数量。同样，设置哈希表的数量(用n_repeats表示)</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ml mm l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ml mm l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ml mm l"/></div></figure><h2 id="b025" class="mz kx iq bd ky na nb dn lc nc nd dp lg lx ne nf li mb ng nh lk mf ni nj lm nk bi translated">3.现在，随机生成平面并创建一个函数来查找向量的散列。</h2><pre class="kg kh ki kj gt nl nm nn no aw np bi"><span id="6b5e" class="mz kx iq nm b gy nq nr l ns nt"><em class="mk">#Generate 11 planes randomly. This gives us a 768 X 11 dimensional matrix</em><br/>planes_l = [np.random.normal(size=(embedding_dims, n_planes)) for i in range(n_repeats)]<br/>print(len(planes_l))<br/>planes_l[0].shape</span></pre><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ml mm l"/></div></figure><h2 id="ed4f" class="mz kx iq bd ky na nb dn lc nc nd dp lg lx ne nf li mb ng nh lk mf ni nj lm nk bi translated">4.现在，创建多个哈希表以提高准确性</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ml mm l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ml mm l"/></div></figure><h2 id="5248" class="mz kx iq bd ky na nb dn lc nc nd dp lg lx ne nf li mb ng nh lk mf ni nj lm nk bi translated">5.创建一个函数，将问题文本作为输入，并使用LSH找到与之相似的向量</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="52fe" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mq lz ma mb mr md me mf ms mh mi mj ij bi translated"><strong class="lq ir"> <em class="mk">注意我们是如何针对所有25个哈希表</em> </strong>添加具有相同哈希值的潜在候选项作为我们的查询向量的</p><h2 id="5e12" class="mz kx iq bd ky na nb dn lc nc nd dp lg lx ne nf li mb ng nh lk mf ni nj lm nk bi translated">6.从这个简化的向量集中，使用余弦相似度找到三个最相似的向量</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ml mm l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ml mm l"/></div></figure><h2 id="6f43" class="mz kx iq bd ky na nb dn lc nc nd dp lg lx ne nf li mb ng nh lk mf ni nj lm nk bi translated">7.在LSH之后，比较使用整个搜索空间和使用缩小的搜索空间的结果</h2><p id="e33c" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated"><em class="mk">这是我们的查询向量，我们希望找到包含类似投诉和情况的历史文档。</em></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="61a3" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mq lz ma mb mr md me mf ms mh mi mj ij bi translated"><strong class="lq ir">这里是使用整个空间的搜索</strong></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ml mm l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="0999" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mq lz ma mb mr md me mf ms mh mi mj ij bi translated"><strong class="lq ir">这是LSH之后使用缩减空间的搜索</strong></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ml mm l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="3da6" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mq lz ma mb mr md me mf ms mh mi mj ij bi translated">哇，我们得到了完全相同的结果，但是用的时间却少得多！我们将墙壁时间从576毫秒减少到53毫秒！</p><h1 id="f84b" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">结论</h1><p id="a806" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">使用LSH，我们将搜索空间从25971个文档减少到2042个文档，将搜索时间从576毫秒减少到53毫秒，但仍然得到相同的结果！<strong class="lq ir">注意，这些结果可能不总是相同的，因为我们正在逼近缩小的搜索空间，但是仍然被认为与我们的查询向量相当相似。</strong></p><p id="511e" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mq lz ma mb mr md me mf ms mh mi mj ij bi translated">如果你喜欢这篇文章，这里有更多！</p><div class="nu nv gp gr nw nx"><a rel="noopener follow" target="_blank" href="/overfitting-is-not-the-only-problem-regularisation-can-help-with-6fcdbfdb9384"><div class="ny ab fo"><div class="nz ab oa cl cj ob"><h2 class="bd ir gy z fp oc fr fs od fu fw ip bi translated">过度适应并不是正规化可以帮助解决的唯一问题</h2><div class="oe l"><h3 class="bd b gy z fp oc fr fs od fu fw dk translated">从数学上理解岭回归在特征数量超过数据点时的作用</h3></div><div class="of l"><p class="bd b dl z fp oc fr fs od fu fw dk translated">towardsdatascience.com</p></div></div><div class="og l"><div class="oh l oi oj ok og ol kp nx"/></div></div></a></div><div class="nu nv gp gr nw nx"><a rel="noopener follow" target="_blank" href="/dealing-with-features-that-have-high-cardinality-1c9212d7ff1b"><div class="ny ab fo"><div class="nz ab oa cl cj ob"><h2 class="bd ir gy z fp oc fr fs od fu fw ip bi translated">处理具有高基数的要素</h2><div class="oe l"><h3 class="bd b gy z fp oc fr fs od fu fw dk translated">一个简单的实用程序，我用来处理具有许多唯一值的分类特征</h3></div><div class="of l"><p class="bd b dl z fp oc fr fs od fu fw dk translated">towardsdatascience.com</p></div></div><div class="og l"><div class="om l oi oj ok og ol kp nx"/></div></div></a></div><div class="nu nv gp gr nw nx"><a rel="noopener follow" target="_blank" href="/regex-essential-for-nlp-ee0336ef988d"><div class="ny ab fo"><div class="nz ab oa cl cj ob"><h2 class="bd ir gy z fp oc fr fs od fu fw ip bi translated">正则表达式对NLP至关重要</h2><div class="oe l"><h3 class="bd b gy z fp oc fr fs od fu fw dk translated">理解各种正则表达式，并将其应用于自然语言中经常遇到的情况…</h3></div><div class="of l"><p class="bd b dl z fp oc fr fs od fu fw dk translated">towardsdatascience.com</p></div></div><div class="og l"><div class="on l oi oj ok og ol kp nx"/></div></div></a></div><div class="nu nv gp gr nw nx"><a rel="noopener follow" target="_blank" href="/powerful-text-augmentation-using-nlpaug-5851099b4e97"><div class="ny ab fo"><div class="nz ab oa cl cj ob"><h2 class="bd ir gy z fp oc fr fs od fu fw ip bi translated">使用NLPAUG的强大文本增强！</h2><div class="oe l"><h3 class="bd b gy z fp oc fr fs od fu fw dk translated">通过文本增强技术处理NLP分类问题中的类别不平衡</h3></div><div class="of l"><p class="bd b dl z fp oc fr fs od fu fw dk translated">towardsdatascience.com</p></div></div><div class="og l"><div class="oo l oi oj ok og ol kp nx"/></div></div></a></div><div class="nu nv gp gr nw nx"><a rel="noopener follow" target="_blank" href="/scatter-plots-on-maps-using-plotly-79f16aee17d0"><div class="ny ab fo"><div class="nz ab oa cl cj ob"><h2 class="bd ir gy z fp oc fr fs od fu fw ip bi translated">使用Plotly在地图上散布图</h2><div class="oe l"><h3 class="bd b gy z fp oc fr fs od fu fw dk translated">了解如何用很少的代码创建交互式散点图来表示数据中的多个要素</h3></div><div class="of l"><p class="bd b dl z fp oc fr fs od fu fw dk translated">towardsdatascience.com</p></div></div><div class="og l"><div class="op l oi oj ok og ol kp nx"/></div></div></a></div><p id="5aab" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mq lz ma mb mr md me mf ms mh mi mj ij bi translated">查看我的<a class="ae kv" href="https://github.com/rajlm10" rel="noopener ugc nofollow" target="_blank"> <strong class="lq ir"> GitHub </strong> </a>其他一些项目。可以联系我<a class="ae kv" href="https://rajsangani.me/" rel="noopener ugc nofollow" target="_blank"> <strong class="lq ir"> <em class="mk">这里</em> </strong> </a> <strong class="lq ir"> <em class="mk">。</em> </strong>感谢您的宝贵时间！</p></div></div>    
</body>
</html>