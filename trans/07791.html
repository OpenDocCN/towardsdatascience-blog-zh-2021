<html>
<head>
<title>Pandas Melt, Stack and wide_to_long For Reshaping Columns into Rows</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">熊猫融化，堆叠，宽变长，把列变成行</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/wide-to-long-data-how-and-when-to-use-pandas-melt-stack-and-wide-to-long-7c1e0f462a98?source=collection_archive---------1-----------------------#2021-07-17">https://towardsdatascience.com/wide-to-long-data-how-and-when-to-use-pandas-melt-stack-and-wide-to-long-7c1e0f462a98?source=collection_archive---------1-----------------------#2021-07-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e75a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用实例了解如何重塑熊猫数据框架</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/873981e4a7586e0792231570777fdf25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jYBAzYZ_a47empFL0mlGdA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://www.pexels.com/@pixabay?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"> <strong class="bd kz"> Pixabay </strong> </a>来自<a class="ae ky" href="https://www.pexels.com/photo/multi-colored-folders-piled-up-159519/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"> <strong class="bd kz">像素</strong> </a></p></figure><p id="efb8" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">重塑数据帧通常需要将列转换为行，反之亦然。</p><p id="62c9" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">重塑数据帧有几个原因:</p><ul class=""><li id="bf85" class="lw lx it lc b ld le lg lh lj ly ln lz lr ma lv mb mc md me bi translated">整理混乱的数据集，使每个变量都在其列中，每个观察值都在其行中。</li><li id="b2e1" class="lw lx it lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated">为分析或可视化准备数据集的一部分。</li></ul><p id="4320" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">每当我需要使用这些功能并复制粘贴解决方案时，我通常会使用谷歌。谢谢stackoverflow！</p><p id="b1f9" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">在这篇文章中，我谈论熊猫。melt()，。stack()和。wide_to_long()。这些函数用于将列转换为行，也称为将数据帧从<strong class="lc iu">宽格式转换为长格式。</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/aef3890baae730c4caad0047be173bad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1090/format:webp/1*WyKcAuX2BmVdNpVrcc0JKQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者提供的宽而长的数据</p></figure><p id="d144" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">希望读完这篇文章后，现在唯一的谷歌搜索将是官方文档和语法！</p><p id="336d" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">对于前两个函数，我们将使用下面的数据集。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ml"><img src="../Images/2642742fd5b253f61c0c57cbf9e27087.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-cn7CIw209Uy-oiXg1YMJg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者的广泛数据框架</p></figure><p id="273b" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu">任务:</strong>将所有月份列移动到一个名为<code class="fe mm mn mo mp b">‘Month’</code>的列下。其单元格中的值将被放入另一个名为<code class="fe mm mn mo mp b">‘Score’.</code>的列中</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/387b840f0ae99549512cc9e04e7903d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:742/format:webp/1*ClLXTo5IPwZ5S0hrsJEnrQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者提供的预期数据框架示例</p></figure><h2 id="d82d" class="mr ms it bd mt mu mv dn mw mx my dp mz lj na nb nc ln nd ne nf lr ng nh ni nj bi translated">1.融化()</h2><p id="2ecf" class="pw-post-body-paragraph la lb it lc b ld nk ju lf lg nl jx li lj nm ll lm ln nn lp lq lr no lt lu lv im bi translated">熊猫<code class="fe mm mn mo mp b"><a class="ae ky" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.melt.html" rel="noopener ugc nofollow" target="_blank">.melt()</a></code>通常是将宽数据帧转换成长数据帧的首选函数，因为它既灵活又简单。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi np"><img src="../Images/e21ceb510eeccc479e52b4094f82e0e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1078/format:webp/1*PmglUxoNgeAQt_iNEop55w.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">。作者的熔化演示</p></figure><p id="5bda" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><code class="fe mm mn mo mp b">df.melt()</code>将具有公共值的相关列捆绑到<strong class="lc iu">一个</strong>列中，称为“变量”。最初在这些列中的值存储在另一个名为“value”的列中。</p><p id="5ce9" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><code class="fe mm mn mo mp b">.melt()</code>句法。</p><p id="0b81" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><code class="fe mm mn mo mp b">df.melt(<em class="nq">id_vars=None</em>, <em class="nq">value_vars=None</em>, <em class="nq">var_name=None</em>, <em class="nq">value_name='value'</em>, <em class="nq">col_level=None</em>, <em class="nq">ignore_index=True</em>)</code></p><p id="65c0" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">所有这些参数都是可选的。让我们看看他们是什么意思。</p><p id="5a79" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><code class="fe mm mn mo mp b">id_vars</code> —列名列表，将保持不变，不会被改变形状，也称为标识符变量。如果没有提供，<em class="nq">所有的</em>列将堆叠成一列。</p><p id="a010" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><code class="fe mm mn mo mp b">value_vars </code> —要堆叠成一列的列的列表。</p><p id="489d" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><code class="fe mm mn mo mp b">var_name</code>–新列的首选名称，用于保存重新调整后的列名。如果未提供，默认名称为“变量”。</p><p id="94a9" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><code class="fe mm mn mo mp b">value_name</code>–列的首选名称，其中包含来自重新调整的列的值。如果未提供，默认名称为“值”。</p><p id="a78c" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">让我们探索不同参数的<code class="fe mm mn mo mp b">.melt()</code>。</p><p id="752b" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu"> df.melt() — <em class="nq">未提供参数</em> </strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/394609d403815575cfd39f72389552df.png" data-original-src="https://miro.medium.com/v2/resize:fit:538/format:webp/1*RP2DvEuF4sR0Gsef-kQWIQ.png"/></div></figure><p id="7339" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">所有的列都被重新整形</p><p id="1276" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu"> df.melt ( id_vars= …) </strong></p><p id="b045" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">这里，我们提供了一个我们不想堆叠的标识符列的列表(你也可以在这里提供一个单独的列)。所有其他列都将被重塑。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/b843c3333d3171a8f8cc684b8aeaad79.png" data-original-src="https://miro.medium.com/v2/resize:fit:850/format:webp/1*YJvuiJqJ3tK0BPO3d4aEJg.png"/></div></figure><p id="ff4b" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">注意，这些<em class="nq">标识符列</em>将对每个重新整形的列重复。例如，播放器<code class="fe mm mn mo mp b"> names, team, and games</code>每隔<code class="fe mm mn mo mp b">month</code>重复一次。</p><p id="4c64" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu"> df.melt ( id_vars = …，value_vars = …) </strong></p><p id="8bf3" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><code class="fe mm mn mo mp b">value_vars</code>保存要堆叠的列(或列列表)。下面，只重塑了两列；<code class="fe mm mn mo mp b">‘February’ and ‘June’</code>还有一个id变量<code class="fe mm mn mo mp b">‘Name’</code>。其余的从结果数据帧中删除。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/1d5c7a7dcc8bac3e6322cafdfa31a004.png" data-original-src="https://miro.medium.com/v2/resize:fit:1062/format:webp/1*CRrfa8LI7RWJMKOGN1jw0A.png"/></div></figure><p id="4f2d" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu"> df.melt ( id_vars = …，value_vars = …，var_name = …，value_name = …) </strong></p><p id="db83" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><code class="fe mm mn mo mp b">var_name</code>和<code class="fe mm mn mo mp b">value_name</code>分别提供堆叠列的名称及其对应的值。默认名称为“变量”和“值”。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nu"><img src="../Images/58c228494b909617e9bc85ff13e6dba0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7FFs-s2jh9nc_AphlIPdbA.png"/></div></div></figure><p id="7836" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu">我们的预期任务结果:</strong>这里不提供要堆叠的<code class="fe mm mn mo mp b">value_vars</code>。因此，<em class="nq">而非</em> <code class="fe mm mn mo mp b">id_vars</code>的所有列将被堆叠。我们还传递堆叠列的名称。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nv"><img src="../Images/cd6950205831f0f0f4039ab2dff381f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zgey_5O0Nke4GTCuEvKpsw.png"/></div></div></figure><p id="0912" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu">融化后保存指数()</strong></p><p id="fc4d" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><code class="fe mm mn mo mp b">ignore_index = True</code>是融化功能的默认值。这意味着旧的索引被删除并用从0开始的<a class="ae ky" href="https://pandas.pydata.org/docs/reference/api/pandas.RangeIndex.html" rel="noopener ugc nofollow" target="_blank">范围索引</a>代替。</p><p id="5a82" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">如果索引对数据帧有意义(例如，它包含每个玩家的实际id)，首先重置索引。原始索引变成一列，并创建一个新的RangeIndex。</p><p id="38fe" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">第1步:使用<code class="fe mm mn mo mp b">reset_index()</code>将索引释放到名为“index”的列中。然后将此列重命名为“ID”。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nw"><img src="../Images/e9d95c06e09d34c1b66dffa0f2e0e50e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G-3Av5KOlua3jysmjZNkLg.png"/></div></div></figure><p id="f468" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">第二步:<code class="fe mm mn mo mp b">melt()</code>数据框。包括“ID”作为标识符变量，以便它不被整形。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/59fd1302d1d8ccbcc89c90cf0a7d3b19.png" data-original-src="https://miro.medium.com/v2/resize:fit:906/format:webp/1*gy7ZU6g-8E-X5V1WFJ9IEg.png"/></div></figure><h2 id="ff1c" class="mr ms it bd mt mu mv dn mw mx my dp mz lj na nb nc ln nd ne nf lr ng nh ni nj bi translated"><strong class="ak"> 2。stack() </strong></h2><p id="6d39" class="pw-post-body-paragraph la lb it lc b ld nk ju lf lg nl jx li lj nm ll lm ln nn lp lq lr no lt lu lv im bi translated">熊猫的<code class="fe mm mn mo mp b">.stack()</code>方法也将宽数据帧转换成高数据帧。</p><p id="edc6" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">最大的不同是<code class="fe mm mn mo mp b">.stack()</code> <strong class="lc iu">利用了索引</strong>，对所有不是索引的列进行了整形。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/8eafaad553923232b7ee64ecd7223ab2.png" data-original-src="https://miro.medium.com/v2/resize:fit:966/format:webp/1*aKbpwMdmAXcF2njjHGf75g.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者演示的df.stack()</p></figure><p id="1b69" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">让我们来看看我们的原始玩家分数数据集。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/639b31009f7fc850a547b3e1a30bc6bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KjeKELMFLApW9koQe2aqVw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">原始宽数据集</p></figure><p id="8610" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">现在让我们把它叠起来。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/4fd6046cbcd92bd8f0925324ead2f49f.png" data-original-src="https://miro.medium.com/v2/resize:fit:532/format:webp/1*q4AhrDHvc-KOt8-umqg0eA.png"/></div></figure><p id="8760" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">每个索引的所有列都已堆叠。结果是一个<a class="ae ky" href="https://pandas.pydata.org/pandas-docs/stable/user_guide/advanced.html" rel="noopener ugc nofollow" target="_blank">多级索引</a> <strong class="lc iu">系列</strong>对象。</p><p id="7ff9" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><code class="fe mm mn mo mp b">.stack()</code>方法获取所有的列，并将它们放到最内层的索引中。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/37e57d9d1016960d45603b4daa860f2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:932/format:webp/1*k16-2pDflNf2xg7yp0oTCw.png"/></div></figure><p id="63f4" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">现在，如果我们想要再现与上面的熔化函数相同的输出，我们需要经历一系列的步骤；</p><ol class=""><li id="9462" class="lw lx it lc b ld le lg lh lj ly ln lz lr ma lv oc mc md me bi translated"><code class="fe mm mn mo mp b">set_index()</code>。将索引设置为我们的标识符变量；<code class="fe mm mn mo mp b">Name, team,</code>和数量<code class="fe mm mn mo mp b">games</code>。</li></ol><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/f015ecb090404e078eec57af95e81870.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B7srV4mtvfwyNZOvdcFVaA.png"/></div></div></figure><p id="7fb9" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">2.<code class="fe mm mn mo mp b">stack()</code>。这将产生一个多级索引数据框架。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/0ca294e5b5e0348433429199939f419e.png" data-original-src="https://miro.medium.com/v2/resize:fit:908/format:webp/1*Qi8nhyqfTFZM-bOiIBba4A.png"/></div></figure><p id="6700" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">3.<code class="fe mm mn mo mp b">reset_index()</code>。这将释放多级索引并创建一个新的<a class="ae ky" href="https://pandas.pydata.org/docs/reference/api/pandas.RangeIndex.html" rel="noopener ugc nofollow" target="_blank"> RangeIndex。</a></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi of"><img src="../Images/1bcf6ae9cef0d88db630d25b145898d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1160/format:webp/1*L_qCGLEs0LEgFFB0bPc3cw.png"/></div></figure><p id="72e6" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">4.<code class="fe mm mn mo mp b">rename</code>与<code class="fe mm mn mo mp b">‘Month’</code>和<code class="fe mm mn mo mp b">‘Score’</code>匹配的列</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/fbc12c55b49883726df62cc838832238.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MsevAumwucB9Qulq6bElcQ.png"/></div></div></figure><p id="d9b0" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu">另一个</strong>的例子<code class="fe mm mn mo mp b"><strong class="lc iu">df.stack()</strong></code></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/ccccf080c209cc178a2a9ae3e33940ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:374/format:webp/1*--fWugfCdgEP6WgK-8Ih-w.png"/></div></figure><p id="40a5" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu">任务:</strong>将<code class="fe mm mn mo mp b">AA, BB and CC</code>列堆叠在一个名为<code class="fe mm mn mo mp b">‘Labels’</code>的列下。<code class="fe mm mn mo mp b">Date</code>不应被整形，因为它是标识符变量。</p><pre class="kj kk kl km gt oi mp oj ok aw ol bi"><span id="42d7" class="mr ms it mp b gy om on l oo op">df1 = df.set_index('date')<br/>df1 = df1.stack()<br/>df1 = df1.reset_index()<br/>df1 = df1.rename(columns = {'level_1':"Labels",<br/>                   0: 'Values'})<br/>df1</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/e8c2f46874b61a77042eccd46086f7c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:414/format:webp/1*gIqpkgsiUDR2tLCpJkHh1Q.png"/></div></figure><p id="5e45" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu">同样的例子使用</strong> <code class="fe mm mn mo mp b"><strong class="lc iu">df.melt()</strong></code></p><pre class="kj kk kl km gt oi mp oj ok aw ol bi"><span id="20a0" class="mr ms it mp b gy om on l oo op">df.melt(id_vars = 'date', <br/>       var_name = 'Labels',<br/>       value_name = 'Values')</span></pre><h2 id="1084" class="mr ms it bd mt mu mv dn mw mx my dp mz lj na nb nc ln nd ne nf lr ng nh ni nj bi translated">3.wide_to_long()</h2><p id="90a1" class="pw-post-body-paragraph la lb it lc b ld nk ju lf lg nl jx li lj nm ll lm ln nn lp lq lr no lt lu lv im bi translated">melt()和stack()函数获取几列并将它们堆叠到一个列中。</p><p id="1e4a" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">如果我们希望将几个列捆绑成两个有意义的列呢？例如，我们不再像以前那样按月分组分数，而是按月分组<strong class="lc iu">分数</strong>和按月分组<strong class="lc iu">游戏</strong>。</p><p id="0b34" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">输入熊猫<code class="fe mm mn mo mp b"><a class="ae ky" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.wide_to_long.html" rel="noopener ugc nofollow" target="_blank">.wide_to_long()</a></code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi or"><img src="../Images/46010a4fb6d0bc6884dab375b95bb90e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1278/format:webp/1*mzPvZ-305TV27AzGdqWhnw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">pd.wide_to_long()作者演示</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi os"><img src="../Images/1b569ef62c516985daef8b0cec0433d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1264/format:webp/1*Q1msFzqRnw9vnYsdN22RJQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者演示pd.wide_to_long的另一个例子</p></figure><p id="901e" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><code class="fe mm mn mo mp b">wide_to_long()</code>以一种非常特殊的方式工作，它实际上利用了熊猫的<code class="fe mm mn mo mp b">.melt()</code>。它需要四个必要的参数，但最重要的方面是列名的显示方式。</p><p id="3da8" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu">要堆叠的列名</strong>必须是特定的格式。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/dc5424e741d3ff05d3a60c8ced8e2c75.png" data-original-src="https://miro.medium.com/v2/resize:fit:782/format:webp/1*EMD1eTN1-M8iDHY9LgT6Ng.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">wide_to_long()函数的列格式</p></figure><p id="6a31" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">例如，对于上面的数据框架，下面是列。</p><ul class=""><li id="e723" class="lw lx it lc b ld le lg lh lj ly ln lz lr ma lv mb mc md me bi translated">要堆叠的df_1列；<code class="fe mm mn mo mp b">games_jan, games_feb, scores_jan, scores_feb.</code></li><li id="21e6" class="lw lx it lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated">df_2列；<code class="fe mm mn mo mp b">sick2017, sick2018, off2017, off2018</code></li></ul><p id="0ce0" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">群组名称为<code class="fe mm mn mo mp b">'games', ‘scores’, ‘sick’, ‘off’.</code></p><p id="7d2b" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">标签是<code class="fe mm mn mo mp b">‘jan’, ‘feb’, ‘2017’, ’2018'</code>。</p><p id="2efe" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">分隔符是<code class="fe mm mn mo mp b">‘_’ and empty string ''.</code></p><p id="191e" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">如果它们的格式不同，您需要<a class="ae ky" href="https://www.geeksforgeeks.org/how-to-rename-columns-in-pandas-dataframe/" rel="noopener ugc nofollow" target="_blank">重命名列</a>。</p><p id="0124" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu">语法</strong></p><p id="3679" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><code class="fe mm mn mo mp b">pandas.wide_to_long(<em class="nq">df</em>, <em class="nq">stubnames</em>, <em class="nq">i</em>, <em class="nq">j</em>, <em class="nq">sep=''</em>, <em class="nq">suffix='\\d+'</em>)</code></p><p id="6b01" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">前四个参数<em class="nq">必须</em>提供。</p><ol class=""><li id="fb8c" class="lw lx it lc b ld le lg lh lj ly ln lz lr ma lv oc mc md me bi translated"><code class="fe mm mn mo mp b">df </code> —要整形的数据帧。</li><li id="1761" class="lw lx it lc b ld mf lg mg lj mh ln mi lr mj lv oc mc md me bi translated"><code class="fe mm mn mo mp b">stubnames</code> —相关列的组(前缀)。以这些字符串开头的列将被组合在一起。</li><li id="f048" class="lw lx it lc b ld mf lg mg lj mh ln mi lr mj lv oc mc md me bi translated"><code class="fe mm mn mo mp b">i </code> —标识符变量，或不堆叠的列。</li><li id="3786" class="lw lx it lc b ld mf lg mg lj mh ln mi lr mj lv oc mc md me bi translated"><code class="fe mm mn mo mp b">j</code> —包含列的后缀或标签的列的名称。</li></ol><p id="42f9" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">可选参数</p><p id="6671" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">5.<code class="fe mm mn mo mp b"> sep</code> -分隔组名(前缀)和列名标签(后缀)的字符。默认分隔符是空字符串。</p><p id="1335" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">6.<code class="fe mm mn mo mp b">suffix</code> —后缀的格式(正则表达式)。默认情况下，该函数接受数字字符；后缀= <code class="fe mm mn mo mp b"> ‘\d+’</code>。如果后缀包含非数字字符，例如上面例子中的“jan”和“feb ”,使用正则表达式<code class="fe mm mn mo mp b">’.+’</code>搜索后缀中的任意数字字符。</p><p id="a3fe" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">让我们来探究熊猫的几个例子</p><p id="57ce" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu">例1。</strong></p><p id="d573" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">考虑下面数据帧；</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/ee329e337bf0842221fc4a00124a3ce2.png" data-original-src="https://miro.medium.com/v2/resize:fit:822/format:webp/1*NVqhAtkzNxPgRddSs58U3g.png"/></div></figure><p id="3d6d" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu">任务:</strong>这两个组(<code class="fe mm mn mo mp b">games </code>和<code class="fe mm mn mo mp b">scores</code>)每个都有自己的列保存值。季节标签(后缀1和2)位于“季节”一栏下。</p><pre class="kj kk kl km gt oi mp oj ok aw ol bi"><span id="516a" class="mr ms it mp b gy om on l oo op">pd.wide_to_long(data_d, <br/>                stubnames=['games','scores'], <br/>                i=['Name','Team'], <br/>                j='Season')</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ov"><img src="../Images/91789175e56cc14cf51a03d2f1a2b426.png" data-original-src="https://miro.medium.com/v2/resize:fit:672/format:webp/1*KXzgWvfJMjwVdx7l_Fst5Q.png"/></div></figure><p id="f54f" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">注意，我们没有提供参数<code class="fe mm mn mo mp b">sep</code>和<code class="fe mm mn mo mp b">suffix</code>，因为缺省值适用于我们的数据帧。</p><p id="0f68" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">最后一步是重置索引以消除multiIndex。</p><pre class="kj kk kl km gt oi mp oj ok aw ol bi"><span id="be5b" class="mr ms it mp b gy om on l oo op">wtl.reset_index()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ow"><img src="../Images/8c42cacae4b6280d19b1e06f7d64e55e.png" data-original-src="https://miro.medium.com/v2/resize:fit:724/format:webp/1*JUgIuasj4Hv7q_kVOyNFmA.png"/></div></figure><p id="a20f" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu">例2 </strong></p><p id="d8e6" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">这里我们有第一季和第二季玩家获得的奖牌。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ox"><img src="../Images/e5c50c597a7265707a1814b32e0bd145.png" data-original-src="https://miro.medium.com/v2/resize:fit:916/format:webp/1*FSbmH-dZ5Ri_YETCuZpg7w.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">每个赛季的奖牌数据框架</p></figure><p id="4d60" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu">任务:</strong>将<code class="fe mm mn mo mp b">medals</code>列聚合成一个名为‘奖牌’的列。标签堆叠在另一个名为“季节”的栏中。只显示<em class="nq"/><strong class="lc iu">一个</strong> id变量<em class="nq"> </em>的‘名称’。</p><pre class="kj kk kl km gt oi mp oj ok aw ol bi"><span id="10ef" class="mr ms it mp b gy om on l oo op">pd.wide_to_long(data_g,<br/>               stubnames=['medals'],<br/>               i=['Name'],<br/>               j='Season',<br/>               sep = '_',<br/>               suffix='.+')</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oy"><img src="../Images/b125bd3edd383e8d0cf5d85e0cfd501b.png" data-original-src="https://miro.medium.com/v2/resize:fit:730/format:webp/1*UOSpAItmdJuzhJCXORz8Mw.png"/></div></figure><p id="7efe" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">只有一个群体；<code class="fe mm mn mo mp b">‘medals’</code>。我们还提供了<code class="fe mm mn mo mp b">sep </code>和<code class="fe mm mn mo mp b">suffix </code>参数，因为它们不同于缺省值。</p><p id="0068" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">注意:我们使用了一个标识符列<code class="fe mm mn mo mp b">i= ‘Names’</code>，但是所有其他列仍然显示在结果中。当将<code class="fe mm mn mo mp b">df</code>参数传递给函数时，我们可以删除不需要的列。</p><pre class="kj kk kl km gt oi mp oj ok aw ol bi"><span id="4c04" class="mr ms it mp b gy om on l oo op">pd.wide_to_long(df = data_g.drop(['Team','Games'],axis=1) ,<br/>               stubnames=['medals'],<br/>               i=['Name'],<br/>               j='Season',<br/>               sep = '_',<br/>               suffix='.+').reset_index()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oz"><img src="../Images/a90989f30e8909ba3ef7dac737b596c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:494/format:webp/1*46DHOD9j9pGAd9UxtgspBg.png"/></div></figure><p id="96cf" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu">例3: </strong></p><p id="f499" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我在stackoverflow <a class="ae ky" href="https://stackoverflow.com/questions/53509471/stacking-pandas-dataframe?utm_source=pocket_mylist" rel="noopener ugc nofollow" target="_blank">这里</a>发现了这个问题。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pa"><img src="../Images/c3b65d9c51534fc88a1ac7a7d83d69a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*Pqyb1gEz1UPOtXW9rXEJnQ.png"/></div></figure><p id="69d6" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu">任务:</strong>将顶层列<code class="fe mm mn mo mp b">‘PSC’</code>和<code class="fe mm mn mo mp b">‘Intel’</code>调整到一个名为‘SAT’的列下。日期也应该堆叠在它们自己的称为“日期”的列中。他们的价值归入“NVAL”一栏。<em class="nq"> id变量</em>是<code class="fe mm mn mo mp b">‘FID’, ‘Lat’, and ‘Long’.</code></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pb"><img src="../Images/d04eba2dbecbb90e37d26d8ff1ea1947.png" data-original-src="https://miro.medium.com/v2/resize:fit:626/format:webp/1*OhU5OGPEbQB71WOWXn4haA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">按作者的多索引列</p></figure><p id="d780" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">步骤1:通过连接名称来合并两个列级别。请参见上面的列级别。我们需要<code class="fe mm mn mo mp b">PCS</code>和<code class="fe mm mn mo mp b">Intel</code>(级别I)作为列名的后缀(最后一部分),因此在下面的代码中是<code class="fe mm mn mo mp b">‘{j}{i}’</code>。</p><pre class="kj kk kl km gt oi mp oj ok aw ol bi"><span id="05c3" class="mr ms it mp b gy om on l oo op">#List comprehension.<br/>#every column has 2 names <br/>#on different levels.<br/>#return names joined</span><span id="9898" class="mr ms it mp b gy pc on l oo op">df.columns = [f'{j}{i}' for i,j in df.columns]<br/>df</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pd"><img src="../Images/e2bea033502dc947715d5bfc2df317c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1006/format:webp/1*ZZn7l5I7-oUvH9izFleM-Q.png"/></div></figure><p id="368a" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">第二步:使用<code class="fe mm mn mo mp b">wide_to_long</code>将标签<code class="fe mm mn mo mp b">PSC</code>和<code class="fe mm mn mo mp b">Intel </code>转换到一列“SAT”下。日期都不同，因此在<code class="fe mm mn mo mp b">‘stubnames’ </code>参数下有四组。</p><pre class="kj kk kl km gt oi mp oj ok aw ol bi"><span id="be60" class="mr ms it mp b gy om on l oo op">df_wtl = pd.wide_to_long(df, <br/>                stubnames = ['23-May','18-May','25-May','28-May'], <br/>                i=['FID','Lat','Lon'], <br/>                j='SAT', <br/>                suffix= '.+', <br/>                sep='')</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pe"><img src="../Images/10179539564a7b6c86c7fba3c5cb85b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:852/format:webp/1*VwWYM2Z4jOjljTVXeiGExA.png"/></div></figure><p id="1e5f" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我们看到很多“不”,因为<code class="fe mm mn mo mp b">Intel </code>和<code class="fe mm mn mo mp b">PSC </code>都适用于特定的日期。</p><p id="4c5a" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">第三步:使用<code class="fe mm mn mo mp b">df.melt</code>将日期堆叠在一个名为<code class="fe mm mn mo mp b">‘Date’</code>的列下。这些值进入另一个名为<code class="fe mm mn mo mp b">‘NVAL’</code>的栏目。记得在<code class="fe mm mn mo mp b">.melt()</code>前<code class="fe mm mn mo mp b">reset_index()</code>，在<code class="fe mm mn mo mp b">dropna()</code>后。上面创建的<code class="fe mm mn mo mp b">SAT</code>现在是标识符列之一。</p><pre class="kj kk kl km gt oi mp oj ok aw ol bi"><span id="8dbd" class="mr ms it mp b gy om on l oo op">#reset the index <br/>#melt<br/>#drop Nans </span><span id="2734" class="mr ms it mp b gy pc on l oo op">df_wtl = df_wtl.reset_index()</span><span id="c44e" class="mr ms it mp b gy pc on l oo op">df_wtl.melt(id_vars =['FID','Lat','Lon','SAT'],<br/>            var_name = 'Date',<br/>            value_name = 'NVAL').dropna()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pf"><img src="../Images/01a05e7a2fc6774ebcbb72a7b61f0e0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:648/format:webp/1*jNdi47qqxfK6C7NUpId1oA.png"/></div></figure><p id="64a9" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">最后，调用<code class="fe mm mn mo mp b">df.reset_index(drop=True)</code>从0开始创建一个新索引，并删除上图中的现有索引。</p></div><div class="ab cl pg ph hx pi" role="separator"><span class="pj bw bk pk pl pm"/><span class="pj bw bk pk pl pm"/><span class="pj bw bk pk pl"/></div><div class="im in io ip iq"><h2 id="d8b0" class="mr ms it bd mt mu mv dn mw mx my dp mz lj na nb nc ln nd ne nf lr ng nh ni nj bi translated">结论</h2><p id="e5d2" class="pw-post-body-paragraph la lb it lc b ld nk ju lf lg nl jx li lj nm ll lm ln nn lp lq lr no lt lu lv im bi translated">在本文中，我们研究了三种将列转换为行的方法。</p><p id="778f" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我们注意到<code class="fe mm mn mo mp b">df.melt()</code>和<code class="fe mm mn mo mp b">df.stack()</code>函数通过将几列捆绑成一列来做同样的事情。</p><p id="96e6" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><code class="fe mm mn mo mp b">df.stack()</code>获取列并将它们转置为最内层索引，保留原始索引，创建多级索引。不应堆叠的列应设置为索引。</p><p id="7246" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><code class="fe mm mn mo mp b">df.melt()</code>提供了选择要重塑的列以及结果列的名称的灵活性。但是，它会删除现有的索引并用新的索引替换它。</p><p id="8529" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><code class="fe mm mn mo mp b">pd.wide_to_long()</code>将多组列捆绑成两列或更多列。它还要求列名采用特定的格式。</p><p id="4413" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">在这里找到包含所有代码<a class="ae ky" href="https://github.com/suemnjeri/medium-articles/blob/e9f7672d6976189c6751ebb19f3134452a0f38bc/reshaping%20dataframes/Wide%20to%20long%20with%20melt,%20stack%20and%20wide_to_long-medium.ipynb" rel="noopener ugc nofollow" target="_blank">的Jupyter笔记本。感谢您的阅读！</a></p></div></div>    
</body>
</html>