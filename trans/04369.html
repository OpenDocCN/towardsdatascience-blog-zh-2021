<html>
<head>
<title>Joining DataFrames in Julia</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Julia中连接数据框架</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/joining-dataframes-in-julia-c435e3da32f3?source=collection_archive---------28-----------------------#2021-04-13">https://towardsdatascience.com/joining-dataframes-in-julia-c435e3da32f3?source=collection_archive---------28-----------------------#2021-04-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="efd3" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">学习所有连接——使用DataFrames.jl的内部、外部、交叉和半连接</h2></div><p id="64e6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi le translated"><span class="l lf lg lh bm li lj lk ll lm di"> W </span>帽子是什么加入的？我们为什么要这么做？我们如何使用DataFrames.jl来实现呢？在这篇文章中，我将展示一些关于如何连接数据帧的实用而简单的例子。</p><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi ln"><img src="../Images/7c278fe5bcb41f1a434dabbd52439fe4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bvkcSyb3EVYM4zZTsYOnQg.jpeg"/></div></div><p class="lz ma gj gh gi mb mc bd b be z dk translated">照片由<a class="ae md" href="https://unsplash.com/@mangofantasy?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">蒂姆·约翰逊</a>在<a class="ae md" href="https://unsplash.com/s/photos/join?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><blockquote class="me"><p id="a820" class="mf mg it bd mh mi mj mk ml mm mn ld dk translated">要获得所有媒体文章的完整访问权限，包括我的文章，请考虑在此订阅<a class="ae md" href="https://niczky12.medium.com/membership" rel="noopener"/>。</p></blockquote><h1 id="917b" class="mo mp it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">简单连接</h1><p id="f333" class="pw-post-body-paragraph ki kj it kk b kl ng ju kn ko nh jx kq kr ni kt ku kv nj kx ky kz nk lb lc ld im bi translated">上一次，我们弄清楚了如何使用DataFrames.jl 索引、排序和聚合我们的数据。Joins是另一个非常常见和重要的操作，出现在列表数据的世界中。跨两个数据框架的联接是基于两个表中存在的共享列值来组合两个数据集的操作。我们称这一列(或几列)为键。因此，第一个表中的每条记录都与第二个表中的一条记录匹配—只要记录的值相同。让我们通过一个小例子来证明这一点。首先，我们设置表A:</p><figure class="lo lp lq lr gt ls"><div class="bz fp l di"><div class="nl nm l"/></div></figure><pre class="lo lp lq lr gt nn no np nq aw nr bi"><span id="2d86" class="ns mp it no b gy nt nu l nv nw">5×2 DataFrame<br/> Row │ id     name<br/>     │ Int64  String<br/>─────┼───────────────<br/>   1 │     1  Alice<br/>   2 │     2  Bob<br/>   3 │     3  Claire<br/>   4 │     4  Daniel<br/>   5 │     5  Edward</span></pre><p id="d82d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">该表包含所有个人的id及其姓名。假设我们有另一个表，其中包含这些个人的收入:</p><figure class="lo lp lq lr gt ls"><div class="bz fp l di"><div class="nl nm l"/></div></figure><pre class="lo lp lq lr gt nn no np nq aw nr bi"><span id="d17c" class="ns mp it no b gy nt nu l nv nw">6×2 DataFrame<br/> Row │ id     salary<br/>     │ Int64  Int64<br/>─────┼───────────────<br/>   1 │     3    4078<br/>   2 │     4    2395<br/>   3 │     5    3662<br/>   4 │     6    2202<br/>   5 │     7    2564<br/>   6 │     8    4545</span></pre><p id="2edf" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们现在有两张桌子:</p><ul class=""><li id="2d11" class="nx ny it kk b kl km ko kp kr nz kv oa kz ob ld oc od oe of bi translated">保存人们的id和姓名</li><li id="fcf7" class="nx ny it kk b kl oj ko ok kr ol kv om kz on ld oc od oe of bi translated"><code class="fe og oh oi no b">B_earnings</code>保存id和收益。</li></ul><p id="eede" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们想合并这两个表，这样我们就可以一起看到姓名和收入。我们加入吧！</p><figure class="lo lp lq lr gt ls"><div class="bz fp l di"><div class="nl nm l"/></div></figure><pre class="lo lp lq lr gt nn no np nq aw nr bi"><span id="4d60" class="ns mp it no b gy nt nu l nv nw">3×3 DataFrame<br/> Row │ id     name    salary<br/>     │ Int64  String  Int64<br/>─────┼───────────────────────<br/>   1 │     3  Claire    4078<br/>   2 │     4  Daniel    2395<br/>   3 │     5  Edward    3662</span></pre><p id="c7c6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们详细讨论一下这个问题。参数1和2是我们要连接的两个表。参数3 ( <code class="fe og oh oi no b">on</code>)告诉我们<strong class="kk iu">键列</strong>是什么。我们将使用该列来匹配表中的观察值。</p><p id="65fe" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如您所见，我们最终得到了3行3列。现在回到开始，看看这两个原始数据集是什么样子的。请确保您理解为什么我们最后只有这些行。</p><p id="5662" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">由于我们使用了<code class="fe og oh oi no b">innerjoin</code>，我们只<strong class="kk iu">保留了出现在两个数据集</strong>中的ids其他的我们都丢弃了。</p><p id="2411" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">还有其他种类的连接:</p><ul class=""><li id="69ee" class="nx ny it kk b kl km ko kp kr nz kv oa kz ob ld oc od oe of bi translated"><strong class="kk iu">内部连接</strong>:获取出现在两个表中的id</li><li id="266f" class="nx ny it kk b kl oj ko ok kr ol kv om kz on ld oc od oe of bi translated"><strong class="kk iu">左连接</strong>:从左(第一个)表中取出所有的id和右表的值</li><li id="f1fd" class="nx ny it kk b kl oj ko ok kr ol kv om kz on ld oc od oe of bi translated"><strong class="kk iu">右连接</strong>:与左连接相同，但是保留第二个表中的所有id</li><li id="ffcf" class="nx ny it kk b kl oj ko ok kr ol kv om kz on ld oc od oe of bi translated"><strong class="kk iu">外部连接</strong>:从两个表中取出所有id，不管它们是否出现在另一个表中</li></ul><p id="b29b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">不要害怕，我们现在将逐一检查所有这些连接！首先，让我们做一个<strong class="kk iu">左连接</strong>，看看只在第一个数据集中的id会发生什么:</p><figure class="lo lp lq lr gt ls"><div class="bz fp l di"><div class="nl nm l"/></div></figure><pre class="lo lp lq lr gt nn no np nq aw nr bi"><span id="0a8e" class="ns mp it no b gy nt nu l nv nw">5×3 DataFrame<br/> Row │ id     name    salary<br/>     │ Int64  String  Int64?<br/>─────┼────────────────────────<br/>   1 │     1  Alice   missing<br/>   2 │     2  Bob     missing<br/>   3 │     3  Claire     4078<br/>   4 │     4  Daniel     2395<br/>   5 │     5  Edward     3662</span></pre><p id="9723" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这里，我们<strong class="kk iu">保留了表A中的所有观察值，不管表b中的</strong>发生了什么。对于表A中没有匹配的记录，收入列的值为<code class="fe og oh oi no b">missing</code>。这是有道理的，因为我们从来没有真正看到这些收入数字。<br/>当然也有右加入。这将保留第二个表中的所有行。</p><p id="895a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您想拥有两个表中的所有id，使用一个外部连接:</p><figure class="lo lp lq lr gt ls"><div class="bz fp l di"><div class="nl nm l"/></div></figure><pre class="lo lp lq lr gt nn no np nq aw nr bi"><span id="4232" class="ns mp it no b gy nt nu l nv nw">8×3 DataFrame<br/> Row │ id     name     salary<br/>     │ Int64  String?  Int64?<br/>─────┼─────────────────────────<br/>   1 │     1  Alice    missing<br/>   2 │     2  Bob      missing<br/>   3 │     3  Claire      4078<br/>   4 │     4  Daniel      2395<br/>   5 │     5  Edward      3662<br/>   6 │     6  missing     2202<br/>   7 │     7  missing     2564<br/>   8 │     8  missing     4545</span></pre><p id="3184" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">加载更多丢失的值，但是我们现在可以看到所有的id。查看id6–8的新的缺失名称！这是外部连接的作用。</p><p id="6c80" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这4个连接构成了表合并的基础。如果没有别的，记住这四个:</p><ul class=""><li id="46f2" class="nx ny it kk b kl km ko kp kr nz kv oa kz ob ld oc od oe of bi translated">inner:只保留键同时出现在两个表中的行</li><li id="27b2" class="nx ny it kk b kl oj ko ok kr ol kv om kz on ld oc od oe of bi translated">左/右:仅保留出现在左侧(第一个)或右侧(第二个)表格中的关键点</li><li id="2f52" class="nx ny it kk b kl oj ko ok kr ol kv om kz on ld oc od oe of bi translated">outer:保留两个表中的所有键</li></ul><h1 id="5b05" class="mo mp it bd mq mr ms mt mu mv mw mx my jz oo ka na kc op kd nc kf oq kg ne nf bi translated">更多奇异的连接</h1><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi or"><img src="../Images/6f8128c4497cfb990b3356e07cb9970f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P4FZujP4kfKx_62kIQvEPw.jpeg"/></div></div><p class="lz ma gj gh gi mb mc bd b be z dk translated">马克·巴宾在<a class="ae md" href="https://unsplash.com/s/photos/exotic?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="dbca" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面的连接<strong class="kk iu">会让你的数据分析需求</strong>走得很远，但是我想向你介绍一些不太为人所知，但是仍然有用的连接。</p><p id="e334" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">假设您想查看有收入数据的人的姓名，但实际上您并不想要第二个表中的所有列。这就是半连接的作用。它为您提供了与内部连接相同的<strong class="kk iu">行，但是没有添加第二个表</strong>中的任何列:</p><figure class="lo lp lq lr gt ls"><div class="bz fp l di"><div class="nl nm l"/></div></figure><pre class="lo lp lq lr gt nn no np nq aw nr bi"><span id="8e84" class="ns mp it no b gy nt nu l nv nw">3×2 DataFrame<br/> Row │ id     name<br/>     │ Int64  String<br/>─────┼───────────────<br/>   1 │     3  Claire<br/>   2 │     4  Daniel<br/>   3 │     5  Edward</span></pre><figure class="lo lp lq lr gt ls"><div class="bz fp l di"><div class="nl nm l"/></div><p class="lz ma gj gh gi mb mc bd b be z dk translated">这将返回true，表明半连接与只包含表a中的列的内部连接相同。</p></figure><p id="ca39" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我听到了，这很有用，但没那么疯狂。签出交叉联接:</p><figure class="lo lp lq lr gt ls"><div class="bz fp l di"><div class="nl nm l"/></div></figure><pre class="lo lp lq lr gt nn no np nq aw nr bi"><span id="acc6" class="ns mp it no b gy nt nu l nv nw">30×4 DataFrame<br/> Row │ id     name    id_1   salary<br/>     │ Int64  String  Int64  Int64<br/>─────┼──────────────────────────────<br/>   1 │     1  Alice       3    4078<br/>   2 │     1  Alice       4    2395<br/>   3 │     1  Alice       5    3662<br/>   4 │     1  Alice       6    2202<br/>   5 │     1  Alice       7    2564<br/>   6 │     1  Alice       8    4545<br/>   7 │     2  Bob         3    4078<br/>   8 │     2  Bob         4    2395<br/>   9 │     2  Bob         5    3662<br/>  10 │     2  Bob         6    2202<br/>  11 │     2  Bob         7    2564<br/>  ⋮  │   ⋮      ⋮       ⋮      ⋮<br/>  21 │     4  Daniel      5    3662<br/>  22 │     4  Daniel      6    2202<br/>  23 │     4  Daniel      7    2564<br/>  24 │     4  Daniel      8    4545<br/>  25 │     5  Edward      3    4078<br/>  26 │     5  Edward      4    2395<br/>  27 │     5  Edward      5    3662<br/>  28 │     5  Edward      6    2202<br/>  29 │     5  Edward      7    2564<br/>  30 │     5  Edward      8    4545<br/>                      9 rows omitted</span></pre><p id="896f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">哇，那爆炸得很快💥！交叉连接获取表A中的所有行，对于每一行，它都将其与表B中的每一行进行匹配。乍一看，这可能没有任何意义，但是这是一个查找所有两个表的组合的好方法。我们的新表有30行，即5(表A的行)x 6(表B的行)。</p><p id="b53f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让你相信这确实有用。假设你想通过改变成分来设计一款新的Twix。为了理解盈利能力，你还需要计算出巧克力的总成本:</p><figure class="lo lp lq lr gt ls"><div class="bz fp l di"><div class="nl nm l"/></div></figure><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div class="gh gi os"><img src="../Images/511001acfa42f4c4db628f908f442e3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1312/format:webp/1*NyzcNjlU3jMWeiVtZgt3MQ.png"/></div><p class="lz ma gj gh gi mb mc bd b be z dk translated">显示更好格式的结果截图。</p></figure><p id="2416" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在你相信我了吧？交叉连接使巧克力创新变得更容易，所以它们很有用！</p><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi ot"><img src="../Images/7218eca0b255c30e30f512d6226c3b46.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TxTJlCT3cq502Y_sSc5xxw.jpeg"/></div></div><p class="lz ma gj gh gi mb mc bd b be z dk translated">沃尔特·奥托在<a class="ae md" href="https://unsplash.com/s/photos/chocolate-factory?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><h1 id="4797" class="mo mp it bd mq mr ms mt mu mv mw mx my jz oo ka na kc op kd nc kf oq kg ne nf bi translated">要加入的多个键</h1><p id="7c71" class="pw-post-body-paragraph ki kj it kk b kl ng ju kn ko nh jx kq kr ni kt ku kv nj kx ky kz nk lb lc ld im bi translated">现在我们有了更好的巧克力，让我们学习如何在<strong class="kk iu">多栏</strong>中加入。将上述连接扩展到使用两个键是非常容易的。事实上，您所要做的就是将一个符号或字符串向量传递给连接函数的参数<code class="fe og oh oi no b">on</code>。为了演示这一点，让我们复制并添加另一列到我们的两个数据集。这将包含用户居住的城市名称。</p><figure class="lo lp lq lr gt ls"><div class="bz fp l di"><div class="nl nm l"/></div></figure><pre class="lo lp lq lr gt nn no np nq aw nr bi"><span id="cd75" class="ns mp it no b gy nt nu l nv nw">julia&gt; display(C_names)<br/>5×3 DataFrame<br/> Row │ id     name    city<br/>     │ Int64  String  String<br/>─────┼─────────────────────────<br/>   1 │     1  Alice   New York<br/>   2 │     2  Bob     London<br/>   3 │     3  Claire  London<br/>   4 │     4  Daniel  New York<br/>   5 │     5  Edward  London<br/><br/>julia&gt; display(D_earnings)<br/>6×3 DataFrame<br/> Row │ id     salary  city<br/>     │ Int64  Int64   String<br/>─────┼─────────────────────────<br/>   1 │     3    4078  New York<br/>   2 │     4    2395  New York<br/>   3 │     5    3662  New York<br/>   4 │     6    2202  London<br/>   5 │     7    2564  New York<br/>   6 │     8    4545  New York</span></pre><p id="a6d4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你可以这样想，我们有两个独立的数据库。一个在纽约，一个在伦敦。由于系统之间互不了解，它们分别跟踪用户的id。因此，伦敦用户1的姓名与纽约用户1的姓名不同。的确，他们是不同的用户！因此，当我们合并这两个表时，我们希望<strong class="kk iu">确保姓名和收入不仅在用户id上匹配，而且在数据库名称上匹配</strong>。让我们在两列上做一些连接:</p><figure class="lo lp lq lr gt ls"><div class="bz fp l di"><div class="nl nm l"/></div></figure><pre class="lo lp lq lr gt nn no np nq aw nr bi"><span id="fd64" class="ns mp it no b gy nt nu l nv nw">1×4 DataFrame<br/> Row │ id     name    city      salary<br/>     │ Int64  String  String    Int64<br/>─────┼─────────────────────────────────<br/>   1 │     4  Daniel  New York    2395</span></pre><p id="52db" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以看到，只有丹尼尔出现在两个数据集中，并且住在同一个地方。</p><h1 id="0ab0" class="mo mp it bd mq mr ms mt mu mv mw mx my jz oo ka na kc op kd nc kf oq kg ne nf bi translated">不同的列名</h1><p id="52bf" class="pw-post-body-paragraph ki kj it kk b kl ng ju kn ko nh jx kq kr ni kt ku kv nj kx ky kz nk lb lc ld im bi translated">您可能面临的一个问题是，您的<strong class="kk iu">键列在您的数据框架中没有相同的名称</strong>。如果是这样，你有两个选择:</p><ul class=""><li id="dba0" class="nx ny it kk b kl km ko kp kr nz kv oa kz ob ld oc od oe of bi translated">您可以使用<code class="fe og oh oi no b">rename!</code>重命名列</li><li id="8046" class="nx ny it kk b kl oj ko ok kr ol kv om kz on ld oc od oe of bi translated">或者您可以将名称映射作为<code class="fe og oh oi no b">on</code>参数传递</li></ul><figure class="lo lp lq lr gt ls"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="1692" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在我们想做的是用姓名连接新的收入表，但是我们想在新表中使用<code class="fe og oh oi no b">another_id</code>作为我们的连接键。</p><figure class="lo lp lq lr gt ls"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="eca3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里我们告诉Julia在进行连接时将<code class="fe og oh oi no b">=&gt;</code>列映射到<code class="fe og oh oi no b">id</code>列。当您需要重命名列时，会使用完全相同的格式。</p><h1 id="ac74" class="mo mp it bd mq mr ms mt mu mv mw mx my jz oo ka na kc op kd nc kf oq kg ne nf bi translated">摘要</h1><p id="0c6f" class="pw-post-body-paragraph ki kj it kk b kl ng ju kn ko nh jx kq kr ni kt ku kv nj kx ky kz nk lb lc ld im bi translated">阅读完本文后，您应该掌握了以下连接函数:</p><ul class=""><li id="f201" class="nx ny it kk b kl km ko kp kr nz kv oa kz ob ld oc od oe of bi translated">内部:用于查看重叠部分</li><li id="8c9a" class="nx ny it kk b kl oj ko ok kr ol kv om kz on ld oc od oe of bi translated">外层:用于保存所有东西</li><li id="fd5f" class="nx ny it kk b kl oj ko ok kr ol kv om kz on ld oc od oe of bi translated">左/右:用于保留一个表中的所有行</li><li id="dfc5" class="nx ny it kk b kl oj ko ok kr ol kv om kz on ld oc od oe of bi translated">semi:用于在进行内部连接时只保留第一个表中的列</li><li id="105c" class="nx ny it kk b kl oj ko ok kr ol kv om kz on ld oc od oe of bi translated">cross:用于创建两个表的乘积，即让每一行都与每一行匹配。</li></ul><p id="43ef" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您还知道如何连接多个键或不同的键名。感谢阅读！</p></div></div>    
</body>
</html>