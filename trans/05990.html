<html>
<head>
<title>Camera App with Flask and OpenCV</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带Flask和OpenCV的相机应用程序</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/camera-app-with-flask-and-opencv-bd147f6c0eec?source=collection_archive---------2-----------------------#2021-05-29">https://towardsdatascience.com/camera-app-with-flask-and-opencv-bd147f6c0eec?source=collection_archive---------2-----------------------#2021-05-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="bcc9" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用flask构建一个相机应用程序，应用Snapchat一样的过滤器，点击照片和录制视频…</h2></div><p id="090e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这篇博文中，我们将使用flask framework构建一个相机应用程序，在其中我们可以点击图片，录制视频，应用灰度、负片和“仅面部”滤镜等滤镜，就像Snapchat上出现的那样。我使用了一个非常基本的前端设计，因为这个项目背后的主要动机是让自己熟悉flask web-framework，还包括实时视频流。同样的功能也可以扩展，以增加更多的功能。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi lb"><img src="../Images/45545fe16031a4228f6d62ab64275249.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*oZDl6cwZe8aNUJQC"/></div></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">巴斯蒂安·里卡迪在<a class="ae lr" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="b64f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">演示:</strong></p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi ls"><img src="../Images/8d9a2d532b409efed8cd4c05e1cb6acb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*4Doljsl74ovmIBvkB6bTpg.gif"/></div></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">作者GIF</p></figure><p id="bd99" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们利用了像<em class="lt">线程、HTTP请求-响应、全局变量、错误处理</em>和<em class="lt">人脸检测</em>这样的概念。让我们详细看看所有这些是如何发生的。</p><h1 id="25d4" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated"><strong class="ak">前端:</strong></h1><p id="5fad" class="pw-post-body-paragraph kf kg iq kh b ki mm jr kk kl mn ju kn ko mo kq kr ks mp ku kv kw mq ky kz la ij bi translated">首先，前端是一个基本的HTML文件，带有接受输入的按钮和在后端预处理后显示输出帧的图像源标签。文件中的按钮将数据发送到服务器。该文件还显示了一些使用该应用程序的说明。该文件保存在项目目录的“templates”文件夹中。</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="mr ms l"/></div></figure><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi mt"><img src="../Images/1d76a65dff1148ce744ab92bf3532cdb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ek1auTHPx8rRUjqAO18WRg.png"/></div></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">作者截图</p></figure><h1 id="7c04" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">后端:</h1><p id="fec3" class="pw-post-body-paragraph kf kg iq kh b ki mm jr kk kl mn ju kn ko mo kq kr ks mp ku kv kw mq ky kz la ij bi translated">至于后端，它是一个完成所有魔术的python脚本。它保存在项目目录中。让我们分别看一下文件的各个部分，以便理解它的工作情况。</p><p id="0113" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">初始化:</strong></p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="14e9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，我们导入了所有必要的模块。</p><p id="2170" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Flask是一个微型的web框架，它就像是前端和后端之间的桥梁。从<em class="lt"> flask </em>中，我们导入'<em class="lt"> Response </em>和'<em class="lt"> request </em>模块来处理HTTP响应请求。<em class="lt"> render_template </em>用于渲染之前显示的HTML文件。OpenCV 是用于执行所有计算机视觉任务的模块。<em class="lt">线程</em>模块用于产生新的线程。</p><p id="327e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们声明所有的全局变量，它们就像一个“拨动开关”来执行不同的任务，如捕捉图像、开始/停止记录和应用过滤器。将变量初始化为0，将所有内容设置为false。</p><p id="fefb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在第18行，我们尝试创建一个名为“<em class="lt"> shots </em>的文件夹，如果它不存在的话。这是保存所有捕获图像的地方。</p><p id="346e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第24行加载了一个预训练的人脸检测模型供将来使用，第27行创建了Flask应用程序的一个实例。第30行为内置摄像头创建了一个视频捕获对象。</p><p id="eeef" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">功能:</strong></p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="04ce" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lt">记录</em>功能用于开始记录，即将帧写入avi文件，同时将变量<em class="lt"> rec </em>设置为真。它使用“<em class="lt"> out </em>，这是后来初始化的视频编写器的对象。(<em class="lt">注意:如果你觉得录制的视频快或慢，调整一下time.sleep的值</em>)。</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="0bd8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lt"> detect_face() </em>'将相机帧作为输入，并返回一个裁剪出的帧，其中只包含在该帧中检测到的人脸。它使用之前加载的预训练人脸检测模型。(<em class="lt">请访问</em> <a class="ae lr" href="https://www.pyimagesearch.com/2018/02/26/face-detection-with-opencv-and-deep-learning/" rel="noopener ugc nofollow" target="_blank"> <em class="lt">本网站</em> </a> <em class="lt">深入了解这是如何做到的</em>)。</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="207d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lt"> gen_frames </em>是一个重要的功能，在其中完成实际的帧捕捉(通过摄像机)和处理。它在一个无限的while循环中运行。第4行从相机对象中捕获帧。如果帧捕获成功，它将检查是否有任何过滤器开关为真。如果'<em class="lt">人脸'、'负片'</em>或'<em class="lt">灰度</em>'为真，则分别对读取帧应用人脸滤镜、负片滤镜和灰度滤镜。</p><p id="062b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果'<em class="lt"> capture </em>'变量被设置为true，它被重置为false(全局变量)，当前帧以' png '格式保存。如果'<em class="lt"> rec </em>'为真，帧被复制到' rec_frame '全局变量，该变量在被触发时被保存到视频文件中。</p><p id="65a0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第25行将帧编码到内存缓冲区，然后转换成字节数组。第27行产生了需要作为HTTP响应发送的格式的帧数据。</p><p id="2e9a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir"> HTTP路由:</strong></p><p id="f36b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是前端与服务器通信的地方。通信通过URL路由发生在<em class="lt">‘GET</em>’和<em class="lt"> POST </em>方法中。</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="ba9d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">@app。route('/')'是Flask提供的一个Python装饰器，用于轻松地将URL分配给我们应用程序中的函数。Route '/'是根URL，输入根URL时调用'<em class="lt"> index() </em>'函数。<em class="lt"> 'index.html' </em>文件从函数渲染到网页中。</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="7752" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在html文件中，Route ' <em class="lt"> /video_feed </em>'被设置为图像源。此函数返回由循环中的“<em class="lt"> gen_frames() </em>”生成的帧的响应块。</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="71c6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">路由'<em class="lt">/请求</em>'被分配给'<em class="lt">任务()</em>'功能，该功能处理所有开关和视频记录。该路由既有'<em class="lt"> POST </em>'又有<em class="lt"> 'GET </em>'方法，即接受信息，也发送信息。之前所有路线默认为'<em class="lt"> GET </em>'。</p><p id="84ea" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果来自客户端的HTTP方法是' POST '，那么'<em class="lt"> request.form.get </em>'接受来自用户按下的按钮的数据，并反转全局变量的先前状态，这些变量就像'<em class="lt"> gen_frame </em>函数中的开关。例如，当用户按下'<em class="lt">灰色</em>'按钮时，<em class="lt">灰色</em>'全局变量被设置为真，从而在'<em class="lt"> gen_frames </em>'函数中将帧转换为灰度。当再次按下<em class="lt">灰色</em>按钮时，“灰色”设置为假，将画面恢复正常。</p><p id="ab91" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在运行flask应用程序的同时将帧记录到视频中是非常棘手的。最简单的解决方案是启动一个新的<em class="lt">线程</em>。</p><blockquote class="mu mv mw"><p id="d189" class="kf kg lt kh b ki kj jr kk kl km ju kn mx kp kq kr my kt ku kv mz kx ky kz la ij bi translated">一个<strong class="kh ir">线程</strong>是一个独立的执行流。这意味着你的程序将同时发生两件事。一个<strong class="kh ir">线程</strong>共享数据段、代码段、文件等信息。与其对等<strong class="kh ir">线程</strong>，同时包含其自己的寄存器、堆栈、计数器等。</p></blockquote><p id="0209" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们的例子中，'<em class="lt">record()【T21]'函数有自己的while循环，所以这个循环在新线程中运行。首先，当'<em class="lt"> rec </em>'为真时，我们创建一个'<em class="lt"> VideoWriter </em>对象。在第37行，我们初始化一个新线程，目标是'<em class="lt"> record() </em>'函数，第38行启动新线程，其中'<em class="lt"> record()' </em>函数正在运行。再次按下录制按钮时，<em class="lt">【video writer】</em>对象被释放，录制停止，将视频保存到根目录。</em></p><p id="d1c2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，如果来自客户端的HTTP方法是'<em class="lt"> GET </em>'，则呈现' index.html '模板。</p><p id="faeb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">主要功能:</strong></p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="8bf3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lt"> 'app.run()' </em>用于启动默认地址<strong class="kh ir">:</strong><a class="ae lr" href="http://127.0.0.1:5000/" rel="noopener ugc nofollow" target="_blank"><strong class="kh ir">http://127 . 0 . 0 . 1:5000/</strong></a><strong class="kh ir">的烧瓶app。</strong>您可以通过将“主机”和“端口”参数添加到函数“<em class="lt">运行</em>”来设置不同的主机和端口号。将主机设置为广播地址<strong class="kh ir"> 0.0.0.0 </strong>将使应用程序在整个局域网(wifi等)中可见。因此，如果移动设备连接到同一个Wi-Fi，您就可以从移动设备访问该应用程序。这是一个很好的“间谍凸轮”。</p><h1 id="7213" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">结论:</h1><p id="db05" class="pw-post-body-paragraph kf kg iq kh b ki mm jr kk kl mn ju kn ko mo kq kr ks mp ku kv kw mq ky kz la ij bi translated">要运行这个应用程序，你应该在你的电脑上安装python、flask和OpenCV。要启动应用程序，请在命令提示符中移动到项目目录。键入并输入:</p><pre class="lc ld le lf gt na nb nc nd aw ne bi"><span id="4470" class="nf lv iq nb b gy ng nh l ni nj">python camera_flask_app.py</span></pre><p id="a1a3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，将<a class="ae lr" href="http://127.0.0.1:5000/" rel="noopener ugc nofollow" target="_blank"><strong class="kh ir">http://127 . 0 . 0 . 1:5000/</strong></a>复制粘贴到你最喜欢的互联网浏览器中即可。</p><p id="4abf" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你可以添加更多像人工智能滤镜这样的功能来构建一个Snapchat式的应用程序。您还可以增强用户界面，使其更具交互性和丰富多彩。<strong class="kh ir">你可以在</strong> <a class="ae lr" href="https://github.com/hemanth-nag/Camera_Flask_App" rel="noopener ugc nofollow" target="_blank"> <strong class="kh ir">我的GitHub账号</strong> </a> <strong class="kh ir">中获取这个项目的源代码。</strong></p><p id="0597" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">谢谢大家！！</p></div></div>    
</body>
</html>