<html>
<head>
<title>Top SQL Interview Test Questions &amp; Techniques (Part 1)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">顶级SQL面试测试问题和技巧(第1部分)</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/top-sql-interview-test-questions-techniques-part-1-971bdccc745c?source=collection_archive---------3-----------------------#2021-05-25">https://towardsdatascience.com/top-sql-interview-test-questions-techniques-part-1-971bdccc745c?source=collection_archive---------3-----------------------#2021-05-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f0b4" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">数据科学家招聘流程中一些最常见的SQL测试问题的解决方案和解释！</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/22db01d78781dd7d507dabac5c4eb7ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*odXy8TQi3XXeF6KA5GFuwQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">丹尼尔·伊德里在<a class="ae ky" href="https://unsplash.com/s/photos/coding?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="8d1c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">点击这里查看第二部<a class="ae ky" rel="noopener" target="_blank" href="/top-sql-interview-test-questions-techniques-part-2-ffccccf776b4">！</a></p><h1 id="7c89" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated"><strong class="ak">简介</strong></h1><p id="8dba" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">如果你申请的是数据科学、商业分析或任何与数据相关的领域的职位，你很有可能会被要求参加包含SQL组件的编码测试。该测试通常在Codility或HackerRank等平台上进行，通常是对申请数据导向角色的候选人进行初步筛选。</p><p id="d9b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管在这些测试平台上有许多可能的场景和案例，但是在这些SQL测试中还是会重复出现某些任务。这些任务并不总是以完全相同的格式出现，有时是最终解决方案的中间步骤的一部分。不，我说的不是像“显示最大值”或“计算不同值的数量”这样的基本查询。例如，我们正在谈论你将在中等难度的LeetCode上找到的那种任务。</p><p id="eb75" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我看来，你可以花上几个小时甚至几天的时间来尝试LeetCode和HackerRank上所有不同的挑战，但最终这些挑战并不能代表这类招聘测试中的实际测试问题。更多的时候，测试任务是面向实际的商业应用的；进行足够多的测试，你很快就会注意到某些任务的重复。</p><p id="7a65" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这篇文章的目标正是概述这些任务并提出解决方案，以便您可以更好地准备这些测试。在这篇文章的第一部分，我将分享两种非常常见的任务:</p><ol class=""><li id="c17c" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu mx my mz na bi translated"><strong class="lb iu">选择每个类别的前N个值</strong></li><li id="0f94" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated"><strong class="lb iu">选择满足条件的连续行数最少的行</strong></li></ol><p id="86d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注意</strong> : <em class="ng">根据您使用的SQL版本，可以使用的子句和函数之间可能会有一些差异，但一般来说应该不会有太多差异。有太多的细微差别需要讨论，所以如果你对任何功能不确定，只需做简单的搜索，通常会有人找到答案！</em></p><h1 id="8842" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">准确性和效率</h1><p id="4017" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">一般来说，评估SQL解决方案有两个关键方法:准确性和效率。在下面的例子中，我主要关注准确性，以展示SQL中某些技术或函数的用法和应用。然而，我也认识到效率在SQL中非常重要，尤其是在查询大量数据时。在我的解决方案中，我确保在给定基础-中级SQL学习者的假定知识的情况下实现非常合理的效率水平，并尽最大努力提供尽可能减少冗余的解决方案。如果你想了解更多关于效率的知识，可以考虑看看这个<a class="ae ky" href="https://www.freelancer.com/articles/web-development/how-to-make-your-sql-queries-faster" rel="noopener ugc nofollow" target="_blank">网站</a>或者这本<a class="ae ky" href="https://www.amazon.com/Performance-Explained-Everything-Developers-about/dp/3950307826?tag=" rel="noopener ugc nofollow" target="_blank">书</a>来了解更多。</p><p id="d4ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事不宜迟，我们来深入提问吧！</p></div><div class="ab cl nh ni hx nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="im in io ip iq"><h1 id="21c3" class="lv lw it bd lx ly no ma mb mc np me mf jz nq ka mh kc nr kd mj kf ns kg ml mm bi translated"><strong class="ak"> Q1:选出每个类别的前N名</strong></h1><p id="2d3e" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">对于这种类型的问题，您需要选择包含某个类别中前N个值的行。</p><p id="157c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">任务</strong>:提取学校每个班级的<strong class="lb iu">前2名考试成绩的姓名和班级，先按班级排序，再按分数排序。如果有任何平局，使用较低的学生id来打破平局。</strong></p><p id="b701" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">分数</strong>数据集包含学校所有学生的分数。每个学生都有一个唯一的<strong class="lb iu"> student_id </strong>，这是主键。<strong class="lb iu">班级</strong>数据集包含学校中所有学生的班级。这里的外键是<strong class="lb iu"> student_id </strong>，它匹配来自<strong class="lb iu"> scores </strong>的主键。类似地，<strong class="lb iu"> names </strong>数据集包含所有以<strong class="lb iu"> student_id </strong>作为外键的学生的姓名。</p><p id="b5c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注意</strong>:一个<strong class="lb iu">外键</strong>是一个表中的一个字段，它引用了另一个表中的一个<strong class="lb iu">主键</strong>。</p><pre class="kj kk kl km gt nt nu nv nw aw nx bi"><span id="b1cc" class="ny lw it nu b gy nz oa l ob oc"><strong class="nu iu">scores</strong></span><span id="13bb" class="ny lw it nu b gy od oa l ob oc">| student_id | scores |<br/>+------------+--------+<br/>| 1          | 90     |<br/>| 2          | 83     |<br/>| 3          | 79     |<br/>| 4          | 97     |<br/>| 5          | 90     |<br/>| 6          | 92     |<br/>| 7          | 94     |<br/>...</span><span id="1dab" class="ny lw it nu b gy od oa l ob oc"><strong class="nu iu">classes</strong></span><span id="96ad" class="ny lw it nu b gy od oa l ob oc">| student_id | class |<br/>+------------+--------+<br/>| 1          | A     |<br/>| 2          | B     |<br/>| 3          | A     | <br/>| 4          | B     |<br/>| 5          | D     |<br/>| 6          | B     |<br/>| 7          | A     |<br/>...</span><span id="d45c" class="ny lw it nu b gy od oa l ob oc"><strong class="nu iu">names</strong></span><span id="7904" class="ny lw it nu b gy od oa l ob oc">| student_id |   name   |<br/>+------------+----------+<br/>| 1          | James    |<br/>| 2          | Michael  |<br/>| 3          | Valarie  | <br/>| 4          | Jessie   |<br/>| 5          | Douglas  |<br/>| 6          | Shin     |<br/>| 7          | Joanne   |<br/>...</span></pre><p id="3d0e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，预期的结果应该是这样的:</p><pre class="kj kk kl km gt nt nu nv nw aw nx bi"><span id="f913" class="ny lw it nu b gy nz oa l ob oc"><strong class="nu iu">EXPECTED RESULT:</strong></span><span id="8ef8" class="ny lw it nu b gy od oa l ob oc">| class | name   | score |<br/>+-------+--------+-------+<br/>| A     | Joanne | 94    |<br/>| A     | James  | 90    |<br/>| B     | Jessie | 97    |<br/>| B     | Shin   | 92    |<br/>...  </span></pre><p id="13ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">解决方案</strong></p><pre class="kj kk kl km gt nt nu nv nw aw nx bi"><span id="faab" class="ny lw it nu b gy nz oa l ob oc">WITH class_ranking AS (<br/>SELECT<br/>    c.class, n.name, s.score,<br/>    ROW_NUMBER() OVER (PARTITION BY c.class ORDER BY s.score DESC, s.student_id) AS rank<br/>FROM scores s<br/>JOIN classes c ON s.student_id = c.student_id<br/>JOIN names n ON s.student_id = c.student_id <br/>)<br/>SELECT class, name, score<br/>FROM class_ranking<br/>WHERE rank &lt;= 2<br/>ORDER BY class ASC, score DESC;</span></pre><p id="1607" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这项任务的难点在于，不是为整个数据集而是为每个类别选择最高分。如果任务是针对整个数据集的，我们可以只使用组合<strong class="lb iu"> ORDER BY </strong>和<strong class="lb iu"> LIMIT </strong>来获得最高分。</p><p id="16c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了帮助我们以高效和简洁的方式解决这个任务，我们可以使用<strong class="lb iu">公共表表达式(CTE) </strong>来创建一个临时结果，该结果可以被类似于<strong class="lb iu"> SELECT </strong>和<strong class="lb iu"> INSERT </strong>、<strong class="lb iu"> UPDATE </strong>或<strong class="lb iu"> DELETE </strong>的子句引用。</p><p id="8427" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们使用分数、班级和姓名之间的一个<strong class="lb iu">连接</strong>来获得一个完整的数据集，其中每一行都包含每个人的所有相关数据。然后，除了选择这三个数据点之外，我们使用<strong class="lb iu"> PARTITION BY </strong>子句根据<strong class="lb iu"> c.class </strong>划分结果集，并根据<strong class="lb iu"> ORDER BY之后的字段从1开始分配一个<strong class="lb iu"> ROW_NUMER() </strong>。</strong>在这种情况下，在c类的每个<strong class="lb iu">分区</strong>中，我们首先按照<strong class="lb iu"> s.score </strong>在<strong class="lb iu"> DESC </strong>中进行排序，将每个类中的最高分排序为1，第二高的排序为2，以此类推。此外，我们使用<strong class="lb iu"> s.student_id </strong>作为排序依据的辅助字段，从而实现任务的目标，即<strong class="lb iu">使用较低的student_id消除联系</strong>。</p><p id="67a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有关如何使用子句的<strong class="lb iu">分区的更多详细信息，请点击此处链接查看。</strong></p><p id="044e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们利用CTE将这个划分的排名存储为一个临时结果集，称为<strong class="lb iu"> class_ranking。</strong>一般来说，CTE的用法如下:</p><pre class="kj kk kl km gt nt nu nv nw aw nx bi"><span id="a9b9" class="ny lw it nu b gy nz oa l ob oc">WITH temp_table AS (<br/>    SELECT ...<br/>)<br/>SELECT _ FROM temp_table</span></pre><p id="955c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你也可以用一个cte链来解决问题。这在解决方案需要对中间CTE进行连续处理以获得实际结果的最终CTE的情况下非常有用。格式如下所示:</p><pre class="kj kk kl km gt nt nu nv nw aw nx bi"><span id="f6a9" class="ny lw it nu b gy nz oa l ob oc">WITH temp_table AS (<br/>    SELECT ...<br/>),</span><span id="cf06" class="ny lw it nu b gy od oa l ob oc">WITH temp_table_2 AS (<br/>    SELECT ...<br/>),</span><span id="421e" class="ny lw it nu b gy od oa l ob oc">SELECT _ FROM temp_table_2</span></pre><p id="fd2d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="ng">关于使用多个cte的示例，敬请关注未来的帖子！</em></p><p id="4767" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于这个问题，CTE <strong class="lb iu"> class_ranking </strong>基本上是原始三重连接的扩展，增加了一个字段<strong class="lb iu"> rank </strong>来表示每个分区或类中每个学生的等级。</p><p id="2183" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了这个CTE，我们就可以选择相关的字段<strong class="lb iu"> class、name、score </strong>并使用<strong class="lb iu"> WHERE </strong>子句对<strong class="lb iu"> rank ≤ 2、</strong>的行进行子集化，从而有效地给出每个类的前2名分数，其平局被较低的student_id打破。我们在最终解决方案中省略了<strong class="lb iu">等级</strong>，因为这不是必需的。我们也按类别ASC进行排序，首先按字母顺序对类别进行评分，以获得想要的排序，分数较高的排在最上面。</p><p id="bab7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">变体:ROW_NUMBER()的替代方法</strong></p><p id="bcc0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个特定的任务中，使用student_id来打破平局，这可以通过为每个分区分配ROW_NUMBER()并首先按分数然后按student_id排序来简单地实现。这将确保只有一个学生排名1，一个学生排名2。</p><p id="4890" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，如果问题指定:让s1和s2是每个班级取得的前2名成绩，会怎么样呢？如果有一个以上的学生获得了s1和/或一个以上的学生获得了s2，只要他们获得了前两个分数中的一个，就包括所有的名字。</p><p id="c296" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">实际上，这意味着修改后的结果集可能类似于:</p><pre class="kj kk kl km gt nt nu nv nw aw nx bi"><span id="9490" class="ny lw it nu b gy nz oa l ob oc"><strong class="nu iu">MODIFIED RESULT:</strong></span><span id="ad5e" class="ny lw it nu b gy od oa l ob oc">| class | name   | score |<br/>+-------+--------+-------+<br/>| A     | Joanne | 94    |<br/>| A     | James  | 90    |<br/>| A     | Caleb  | 90    |<br/>| B     | Jessie | 97    |<br/>| B     | Shin   | 92    |<br/>...</span></pre><p id="026c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了说明这种变化，我们只需将<strong class="lb iu"> ROW_NUMBER() </strong>窗口函数更改为<strong class="lb iu"> DENSE_RANK() </strong>。假设James的student_id比Caleb小，ROW_NUMBER()会将rank=2分配给James，将rank=3分配给Caleb。但是，DENSE_RANK()会将rank=2分配给James和Caleb。此外，DENSE_RANK()和RANK()之间的差异也值得注意——DENSE _ RANK()是“密集的”,因为它不会在相同的排名后跳过排名，但RANK()会。因此，Caleb之后的下一个最高分在DENSE_rank()下将被排序为rank=3，但在RANK()下将被排序为rank=4。根据应用程序的情况，应该知道这些窗口应用程序之间的差异。</p><p id="7858" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于那些想知道什么是<strong class="lb iu">窗口函数</strong>以及它与其他函数如<strong class="lb iu">聚合函数的关系的人来说，</strong> PostgreSQL提供了一个很好的解释<strong class="lb iu"> : </strong></p><blockquote class="oe of og"><p id="100a" class="kz la ng lb b lc ld ju le lf lg jx lh oh lj lk ll oi ln lo lp oj lr ls lt lu im bi translated">一个<strong class="lb iu"> <em class="it">窗口函数</em> </strong>对一组与当前行有某种关系的表格行执行计算。这与聚合函数可以完成的计算类型相当。但是与常规的<strong class="lb iu">聚合函数</strong>不同，窗口函数的使用不会导致行被组合成一个输出行——这些行保持它们各自的身份。在后台，窗口函数能够访问的不仅仅是查询结果的当前行。</p></blockquote><p id="2eac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您的SQL方言不支持<strong class="lb iu"> ROW_NUMBER() </strong>函数或PARTITION BY子句，我们可以在一个<strong class="lb iu">相关子查询</strong>中使用<strong class="lb iu">等价连接</strong>和<strong class="lb iu">非等价连接</strong>逻辑的组合来获得想要的结果:</p><pre class="kj kk kl km gt nt nu nv nw aw nx bi"><span id="45db" class="ny lw it nu b gy nz oa l ob oc">SELECT c.class, n.name, s.score<br/>FROM scores s<br/>JOIN classes c ON s.student_id = c.student_id<br/>JOIN names n ON s.student_id = n.student_it<br/>WHERE<br/>(<br/>    SELECT COUNT(DISTINCT s.score)<br/>    FROM scores s2 JOIN classes c2 ON s2.student_id = c2.student_id<br/>    WHERE s2.score &gt; s.score<br/>        AND c2.class = c.class) &lt; 2</span></pre><p id="d28f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个<strong class="lb iu">等价连接</strong>是一个根据列中匹配值连接表的连接。<strong class="lb iu">非等价连接</strong>是一个条件不等于的连接。</p><p id="8376" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">子查询</strong>是嵌套在另一个查询中的查询。<strong class="lb iu">相关子查询</strong>是使用外部查询中的值的子查询。</p><p id="0c38" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，子查询使用外部查询中的<strong class="lb iu"> s.score </strong>和<strong class="lb iu"> c.class </strong>与来自同一个表<strong class="lb iu"> scores </strong>的值进行比较，但现在使用<strong class="lb iu">别名s2，</strong>并计算比原始表<strong class="lb iu"> scores s </strong>中的每一行都大的分数的数量。条件是选择具有少于2个对应匹配的那些，因为最高分数将具有0个匹配，第二高分数将具有1个匹配。</p><p id="c98a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">仅此而已！进入下一个问题…</p><h1 id="808b" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">Q2:条件连续选择</h1><p id="dac7" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated"><strong class="lb iu">选择满足条件的连续行数最少的行</strong></p><p id="31f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">SQL访谈中的一个常见任务是选择不仅满足特定标准，而且满足最少数量的行的行，通常按日期排序。这里我们将看一个例子，它解释了在给定我们要寻找的连续行之间的关系的情况下，我们如何使用<strong class="lb iu">交叉连接</strong>来过滤这种情况。</p><p id="f471" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">表格<strong class="lb iu">病例</strong>包含每个日期的新COVID病例数。</p><p id="1b3e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">任务</strong>:显示包含连续3天或以上的100例以上的行。</p><pre class="kj kk kl km gt nt nu nv nw aw nx bi"><span id="c2a2" class="ny lw it nu b gy nz oa l ob oc"><strong class="nu iu">cases</strong></span><span id="6b2d" class="ny lw it nu b gy od oa l ob oc">+------+------------+-----------+<br/>| id   |    date    |   new     |<br/>+------+------------+-----------+<br/>| 1    | 2021-01-01 | 20        |<br/>| 2    | 2021-01-02 | 149       |<br/>| 3    | 2021-01-03 | 150       |<br/>| 4    | 2021-01-04 | 99        |<br/>| 5    | 2021-01-05 | 145       |<br/>| 6    | 2021-01-06 | 200       |<br/>| 7    | 2021-01-07 | 199       |<br/>| 8    | 2021-01-08 | 188       |<br/>| 9    | 2021-01-09 | 88        |<br/>+------+------------+-----------+<br/>...</span></pre><p id="00c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">预期的结果将类似于:</p><pre class="kj kk kl km gt nt nu nv nw aw nx bi"><span id="36b9" class="ny lw it nu b gy nz oa l ob oc"><strong class="nu iu">EXPECTED RESULT</strong></span><span id="51cc" class="ny lw it nu b gy od oa l ob oc">+------+------------+-----------+<br/>| id   |    date    |    new    |<br/>+------+------------+-----------+<br/>| 5    | 2021-01-05 | 145       |<br/>| 6    | 2021-01-06 | 200       |<br/>| 7    | 2021-01-07 | 199       |<br/>| 8    | 2021-01-08 | 188       |<br/>+------+------------+-----------+<br/></span></pre><p id="06b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">解决方案</strong></p><pre class="kj kk kl km gt nt nu nv nw aw nx bi"><span id="53a2" class="ny lw it nu b gy nz oa l ob oc">WITH cases_over_hundred AS (<br/>  SELECT * FROM cases WHERE new &gt; 100<br/>)</span><span id="3c82" class="ny lw it nu b gy od oa l ob oc">SELECT DISTINCT c1.* <br/>FROM cases_over_hundred as c1,<br/>FROM cases_over_hundred as c3,<br/>FROM cases_over_hundred as c2,<br/>WHERE (c1.id = c2.id - 1 AND c1.id = c3.id - 2) <br/>  OR (c1.id = c2.id + 1 AND c1.id = c3.id - 1) <br/>  OR (c1.id = c2.id + 2 AND c1.id = c3.id + 1)<br/>ORDER BY c1.id;</span></pre><p id="1194" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了提高效率，我们首先创建一个CTE来选择超过100个案例的行。我们称这种CTE案例超过100例。</p><p id="2208" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们使用一个<strong class="lb iu">条件交叉连接</strong>来查找所有连续3天或以上超过100个案例的行。交叉联接，也称为笛卡尔积，其中一个表中的每一行都与另一个表中的每一行相结合。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ok"><img src="../Images/90bf3ccb19401212154a165dbf7a51f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OJDulanJ-e6lS21H2QRdjA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="1b6f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本例中，我们交叉连接三个表，因为我们想要比较三个日期的不同组合的日期，以检查它们是否连续。但是，我们将使用条件来确保只联接属于以下三个类别之一的日期，而不是完全交叉联接:</p><ul class=""><li id="8061" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu ol my mz na bi translated">c1日期比c2日期早一天，比c3日期早两天</li><li id="7ea6" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu ol my mz na bi translated">c1日期比c2日期晚一天，比c3日期早一天</li><li id="d2a5" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu ol my mz na bi translated">c1日期比c2日期晚两天，比c3日期晚一天</li></ul><p id="8592" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注意</strong>:对于这些条件中的任何一个，用c3替换c2都无关紧要，因为这里我们使用的是交叉连接，所以无论如何都要考虑所有的排列</p><p id="91ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这三种可能性分别由以下三个条件捕获:</p><pre class="kj kk kl km gt nt nu nv nw aw nx bi"><span id="0d61" class="ny lw it nu b gy nz oa l ob oc">WHERE (c1.id = c2.id - 1 AND c1.id = c3.id - 2) <br/>  OR (c1.id = c2.id + 1 AND c1.id = c3.id - 1) <br/>  OR (c1.id = c2.id + 2 AND c1.id = c3.id + 1)</span></pre><p id="ab99" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过这种条件交叉连接，我们成功地选择了所有的日期组合，这样，当排列正确时，行中的所有三个日期都是连续的，并且它们都有大于等于100的事例。</p><p id="024d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们需要使用<strong class="lb iu">选择(DISTINCT (c1。*)) </strong>删除所有重复。对于每个子集化的行，由于有条件的交叉连接，将会有两个重复，因此我们需要做的只是从c1中选择不同的日期值，以获得连续3天或更多天超过100个案例的日期序列。</p><p id="926b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">替代方案</strong></p><p id="26d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事实上，还有另一种方法可以解决这个问题，那就是使用<strong class="lb iu">窗口函数</strong>(再次)！对于这种情况，我们可以使用窗口函数<strong class="lb iu"> LAG() </strong>和<strong class="lb iu"> LEAD() </strong>。正如您可能已经预料到的，<strong class="lb iu"> LAG() </strong>允许我们获得给定字段的先前值，其中顺序由另一个字段决定。在这种情况下，我们根据<strong class="lb iu"> id </strong>的顺序得到<strong class="lb iu"> new </strong>的前几个值。同样，<strong class="lb iu"> LEAD() </strong>返回引用中当前行前面的us值。</p><p id="2071" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">标准语法如下:</p><pre class="kj kk kl km gt nt nu nv nw aw nx bi"><span id="54af" class="ny lw it nu b gy nz oa l ob oc">LAG(return_value ,offset [,default])  <br/>OVER ([PARTITION BY partition_expression, ... ]<br/>       ORDER BY sort_expression [ASC | DESC], ... )</span></pre><p id="8325" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个语法与我们在问题1中使用的非常相似，使用ROW_NUMBER()窗口函数。</p><p id="44ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于这个问题，我们首先使用LAG()和LEAD()窗口函数构造一个CTE，其中包含每行日期前后1、2天的值。随后，对于连续三天超过100个案例的条件得到满足的行，我们引用此CTE和条件。'</p><pre class="kj kk kl km gt nt nu nv nw aw nx bi"><span id="4b37" class="ny lw it nu b gy nz oa l ob oc">WITH interval_cases AS (<br/>    SELECT *,<br/>    LAG(new, 2) OVER (ORDER BY id) AS before_2,<br/>    LAG(new, 1) OVER (ORDER BY id) AS before_1,<br/>    LEAD(new, 1) OVER (ORDER BY id) AS after_1,<br/>    LEAD(new, 2) OVER (ORDER BY id) AS after_2<br/>FROM cases<br/>)<br/>SELECT id, date, new<br/>FROM cases<br/>WHERE new &gt; 100<br/>AND ((before_2 &gt; 100 AND before_1 &gt; 100)<br/>     OR (before_1 &gt; 100 AND after_1 &gt; 100)<br/>     OR (after_1 &gt; 100 AND after_2 &gt; 100))<br/>ORDER BY id;</span></pre><p id="fb34" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来看看查询逻辑:</p><p id="a441" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，CTE interval_cases将为每一行生成一个如下所示的结果集:</p><pre class="kj kk kl km gt nt nu nv nw aw nx bi"><span id="1229" class="ny lw it nu b gy nz oa l ob oc">+----+------------+-----+----------+----------+---------+---------+<br/>| id |    date    | new | before_2 | before_1 | after_1 | after_2 |<br/>+----+------------+-----+----------+----------+---------+---------+<br/>| 5  | 2021-01-05 | 145 | 150      | 99       | 200     | 199     |<br/>...</span></pre><p id="4a88" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">随后，我们筛选出那些<strong class="lb iu"> new </strong>大于100并且属于连续三天都大于300的行。这可能以三种方式之一发生，这就是为什么伴随新的&gt; 100条件有三种可选条件。这将得到与上一个解决方案相同的结果。</p><h1 id="4e2c" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">结论</h1><p id="37ce" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我希望这两个问题在演示如何处理SQL编码测试中最常见的问题时有用。如果你喜欢我分享的内容，请给我一个掌声并分享这篇文章！</p><p id="7cbe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果有足够的兴趣，我还会在第2部分<strong class="lb iu"> </strong>提出更多问题，如果您对如何解决这些问题有任何意见或建议(特别是从效率的角度)，请随时联系或发表评论！</p><p id="1f1f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">更新:点击这里查看第二部<a class="ae ky" rel="noopener" target="_blank" href="/top-sql-interview-test-questions-techniques-part-2-ffccccf776b4">！</a></p></div></div>    
</body>
</html>