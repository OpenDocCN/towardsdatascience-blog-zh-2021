<html>
<head>
<title>Recommender System from Scratch</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从零开始的推荐系统</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/recommender-system-from-scratch-fa6b70fc3e7f?source=collection_archive---------5-----------------------#2021-09-10">https://towardsdatascience.com/recommender-system-from-scratch-fa6b70fc3e7f?source=collection_archive---------5-----------------------#2021-09-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="64e8" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">直观的漫游</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/05a962e35ff40e70f6ef0777d4f04c1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bzaXusHcDzHN3INzH0pzLQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">来源:<a class="ae kv" href="https://creativecommons.org/licenses/by-sa/4.0/deed.en" rel="noopener ugc nofollow" target="_blank">知识共享</a></p></figure><h1 id="2853" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">介绍</h1><p id="1e6d" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">当我开始我的机器学习之旅时，有几个概念让我非常着迷，其中之一就是推荐系统。这是你在日常生活中经常看到的ML应用之一。在亚马逊购物、在Myntra买衣服、在网飞看电影的时候，我们到处都有推荐，当然，著名的<strong class="lq ir"/><strong class="lq ir"/><a class="ae kv" href="https://en.wikipedia.org/wiki/Netflix_Prize#:~:text=The%20Netflix%20Prize%20was%20an,numbers%20assigned%20for%20the%20contest." rel="noopener ugc nofollow" target="_blank"><strong class="lq ir">Netflix Prize competition</strong></a>，阅读关于比赛、球队以及他们两年来在比赛中的努力让我对推荐系统感到非常兴奋(我建议你们看一下<a class="ae kv" href="https://www.youtube.com/watch?v=ImpV70uLxyw" rel="noopener ugc nofollow" target="_blank">这部关于获胜球队的</a>纪录片)。这篇博客将尝试给出一个从零开始构建一个非常基本的推荐系统的直观演示。</p><h1 id="4060" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">推荐系统</h1><p id="cc04" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">首先，什么是推荐系统，这是维基百科对推荐系统的定义。</p><blockquote class="mk ml mm"><p id="ade9" class="lo lp mn lq b lr mo jr lt lu mp ju lw mq mr lz ma ms mt md me mu mv mh mi mj ij bi translated">推荐系统是一个信息过滤系统，它试图预测用户对一个项目的“评分”或“偏好”</p></blockquote><p id="b221" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mr lz ma mb mt md me mf mv mh mi mj ij bi translated">嗯，这基本上概括了，基于这些预测，系统向顾客建议/推荐相关商品。</p><p id="b027" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mr lz ma mb mt md me mf mv mh mi mj ij bi translated">概括地说，有三种方法可以用来创建推荐系统</p><ul class=""><li id="5794" class="mw mx iq lq b lr mo lu mp lx my mb mz mf na mj nb nc nd ne bi translated">协同过滤(我们将在博客中关注这一点)</li><li id="a847" class="mw mx iq lq b lr nf lu ng lx nh mb ni mf nj mj nb nc nd ne bi translated">基于内容的过滤</li><li id="1976" class="mw mx iq lq b lr nf lu ng lx nh mb ni mf nj mj nb nc nd ne bi translated">混合(以上两者的混合物)</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/d035423c78d990704213af9db11dba33.png" data-original-src="https://miro.medium.com/v2/resize:fit:1104/format:webp/1*YjXaIb5DxifSO_OXA6gdMA.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">来源:作者图片</p></figure><h1 id="227e" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">协作与内容</h1><p id="f24f" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">协同过滤使用<strong class="lq ir">过去的用户-项目交互来提出新的推荐，</strong>例如，如果一个人喜欢电影m1，并且另外5个人同时喜欢电影m1和电影m2，则电影m2可以被推荐给该用户(具体地说，这是用户-用户协同过滤的一个例子)，而基于内容的过滤需要<strong class="lq ir">关于用户(如年龄、性别等)和项目/电影(电影的类型、持续时间， etc) </strong>为了生成预测，协作方法的好处在于它们不需要<strong class="lq ir">关于用户/项目的额外信息</strong>而是从过去的用户-项目交互中提取有用的模式来创建它自己的特征，而不需要任何额外的信息</p><h1 id="bfa2" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated"><strong class="ak">协同过滤的类型</strong></h1><p id="c69a" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">有两种类型的协同过滤方法</p><ul class=""><li id="cb05" class="mw mx iq lq b lr mo lu mp lx my mb mz mf na mj nb nc nd ne bi translated">基于内存</li><li id="a65f" class="mw mx iq lq b lr nf lu ng lx nh mb ni mf nj mj nb nc nd ne bi translated">基于模型(我们将在这个博客中建立一个基于模型的推荐系统)</li></ul><h2 id="8c6c" class="nl kx iq bd ky nm nn dn lc no np dp lg lx nq nr li mb ns nt lk mf nu nv lm nw bi translated"><strong class="ak">基于内存的</strong></h2><p id="d2ef" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">基于记忆的协同过滤直接使用<strong class="lq ir">用户-项目交互矩阵</strong>，并获取相似的用户/项目。</p><ul class=""><li id="c69f" class="mw mx iq lq b lr mo lu mp lx my mb mz mf na mj nb nc nd ne bi translated"><strong class="lq ir">用户-用户相似度:</strong>它首先找到与我们给定的查询用户最相似的用户，然后根据最相似的客户评级预测项目偏好，例如，如果我们想预测客户C将如何获得电影m1的评级，那么我们将对与该用户相似的用户给出的评级进行加权求和，<strong class="lq ir">“与你相似的用户也喜欢..”</strong></li><li id="8e6f" class="mw mx iq lq b lr nf lu ng lx nh mb ni mf nj mj nb nc nd ne bi translated"><strong class="lq ir">项目-项目相似度:</strong>方法类似于用户-用户相似度，唯一的区别是这里相似度计算是以项目而不是用户为中心的，假设我们想为用户预测电影，那么我们将首先找到用户评分最高的电影，然后找到这部电影与所有其他电影的相似度，并建议前K部电影<strong class="lq ir">“喜欢这个项目的用户也喜欢..”</strong></li></ul><p id="2196" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mr lz ma mb mt md me mf mv mh mi mj ij bi translated">对于相似度计算，我们使用<strong class="lq ir">皮尔逊相关系数或调整后的余弦相似度</strong>(将评分集中在零附近，以避免将未评分的项目视为负面项目，0表示完全不喜欢)</p><p id="466c" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mr lz ma mb mt md me mf mv mh mi mj ij bi translated">基于模型的方法和基于记忆的方法之间的主要区别在于，我们<strong class="lq ir">不学习任何参数/解决任何优化问题</strong>在基于记忆的方法中，仅通过从用户-项目矩阵计算相似性来给出建议。</p><p id="b3b7" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mr lz ma mb mt md me mf mv mh mi mj ij bi translated">基于内存的方法的主要问题是它不可扩展，因为用户基数增加，用户-项目矩阵变得更加稀疏，计算相似性变得困难(尤其是计算用户-用户相似性)。</p><h2 id="4006" class="nl kx iq bd ky nm nn dn lc no np dp lg lx nq nr li mb ns nt lk mf nu nv lm nw bi translated">基于模型的</h2><p id="c71a" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">现在我们转到基于模型的方法，但在此之前，让我们讨论一下矩阵分解</p><p id="8a44" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mr lz ma mb mt md me mf mv mh mi mj ij bi translated">矩阵分解将矩阵分解成多个因子，在最大似然术语中，存在一个低维的潜在特征空间，其中我们可以表示项目和用户，用户-项目矩阵的近似可以通过乘以这些用户-项目矩阵来获得。</p><p id="c947" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mr lz ma mb mt md me mf mv mh mi mj ij bi translated">作为一个例子，让我们假设我们已经将用户-电影矩阵分解为3个潜在维度，这不是它的确切含义，但为了给你一个直觉，我们可以将这3个潜在向量视为电影类型，如动作片、喜剧片、浪漫片。因此，当我们把一个用户和一部电影分成这三个维度时，我们实际上试图把用户和电影分成这些概念/类型。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/a02d2ced81ee4d8332c467ae50afaa85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1020/format:webp/1*27ECaAvN1FkjjxWXKZ3hVQ.png"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/abe8b9eca185c69614c4220f3059a166.png" data-original-src="https://miro.medium.com/v2/resize:fit:1012/format:webp/1*Nbf2_T5m_3HkgbEdsdUUMw.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">来源:作者图片</p></figure><p id="44f9" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mr lz ma mb mt md me mf mv mh mi mj ij bi translated">像在上面的例子中，我们已经用他们的潜在维度表示来表示用户、电影，每个维度表示一个类型，这个潜在向量表示帮助<strong class="lq ir">计算用户和项目的交互，并最终帮助推荐项目，</strong>例如，用户A更喜欢动作电影，现在如果我们计算用户A与所有三部电影的余弦相似性，我们将发现Singham具有最高的相似性，因为它在动作类型中具有高值，因此暗示这很可能是一部动作电影。<em class="mn">(注:这只是一个获得事物直觉的例子，这些潜在向量不具备这种直接的可解释性)</em></p><h1 id="4a1c" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated"><strong class="ak">代号</strong></h1><p id="066b" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">理论说够了，让我们谈谈代码吧！我们将构建一个非常简单的基于模型的推荐系统。为了解决机器学习问题(受监督的),我们总是有一个<strong class="lq ir">优化问题，一个我们试图最大化/最小化</strong>的函数，以在不过度拟合数据的情况下降低成本，并在此过程中通过梯度下降等技术学习我们的模型参数。因此，首先让我们定义我们的优化问题</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nz"><img src="../Images/a82458660b27b7fa5c62f041c8ae2af5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*l5nqrruvmehyBeu9BhCvcQ.gif"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">来源:作者图片</p></figure><p id="2098" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mr lz ma mb mt md me mf mv mh mi mj ij bi translated">其中预测等级(r_hat)计算如下</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oa"><img src="../Images/ac65a9320a67a8f79bd674c3f86b606c.png" data-original-src="https://miro.medium.com/v2/resize:fit:754/1*Zq0jvRdCa2Dg7DKrRvxvVA.gif"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">来源:作者图片</p></figure><p id="eeb3" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mr lz ma mb mt md me mf mv mh mi mj ij bi translated">优化函数可能看起来有点吓人，但是让我们试着一点一点地分解它。</p><p id="b69d" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mr lz ma mb mt md me mf mv mh mi mj ij bi translated">就像任何其他成本函数一样，该成本函数可以分解为两个部分，与第一部分(实际-预测)计算的<strong class="lq ir">净成本相关联的</strong>，第二项是<strong class="lq ir">正则化项。</strong></p><p id="ec95" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mr lz ma mb mt md me mf mv mh mi mj ij bi translated">现在让我们把这些可学习的参数和最终的预测计算搞清楚。</p><p id="b8c4" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mr lz ma mb mt md me mf mv mh mi mj ij bi translated">我们可以将预测评级分为四个部分</p><ul class=""><li id="e295" class="mw mx iq lq b lr mo lu mp lx my mb mz mf na mj nb nc nd ne bi translated"><strong class="lq ir">全局平均值(mu): </strong>全局平均值是我们的训练数据集中所有评级的平均评级，这一术语可以被认为是<strong class="lq ir">我们的基线预测评级</strong>，并且模型学习对此进行多少调整以获得正确的预测。</li><li id="3e1b" class="mw mx iq lq b lr nf lu ng lx nh mb ni mf nj mj nb nc nd ne bi translated"><strong class="lq ir">用户偏见:</strong>用户偏见可以被认为是一个捕捉用户行为的<strong class="lq ir">术语，</strong>例如，与其他用户相比，一些用户过于挑剔，因此他们倾向于给出稍低的评级。</li><li id="d8b9" class="mw mx iq lq b lr nf lu ng lx nh mb ni mf nj mj nb nc nd ne bi translated"><strong class="lq ir">电影偏见:</strong>电影偏见可以被认为是一个术语<strong class="lq ir">捕捉一部电影的受欢迎程度</strong>例如，有一些像《阿凡达》、《肖申克的救赎》这样的邪教经典电影通常有很高的评级，因此这些电影往往有更高的推荐评级。</li><li id="2876" class="mw mx iq lq b lr nf lu ng lx nh mb ni mf nj mj nb nc nd ne bi translated"><strong class="lq ir">用户-电影交互:</strong>最后，我们有一个术语，它是通过计算相似性b/w用户和电影潜在向量，基于特定用户和电影之间的交互来计算的(在上面的部分中解释)</li></ul><p id="5a10" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mr lz ma mb mt md me mf mv mh mi mj ij bi translated">好了，差不多了，我们已经定义了优化函数，现在我们需要最小化成本，在这种情况下，我们将RMSE作为我们的性能指标。</p><h2 id="1ec5" class="nl kx iq bd ky nm nn dn lc no np dp lg lx nq nr li mb ns nt lk mf nu nv lm nw bi translated"><strong class="ak">数据集</strong></h2><p id="5a58" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">我们采用了一个非常受欢迎的数据集，名为<a class="ae kv" href="https://grouplens.org/datasets/movielens/100k/" rel="noopener ugc nofollow" target="_blank"> MovieLens 100k </a> [2]，该数据集包括从1到5的100k个评级，来自1682部电影的943个用户，并基于时间进行了80-20的训练测试划分，即使用前80%的评级进行训练，剩余的20%用于测试。</p><p id="1502" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mr lz ma mb mt md me mf mv mh mi mj ij bi translated">我们已经定义了成本函数，现在我们将计算梯度并更新模型参数以最小化成本。</p><pre class="kg kh ki kj gt ob oc od oe aw of bi"><span id="9dbe" class="nl kx iq oc b gy og oh l oi oj"><strong class="oc ir">for</strong> each epoch:</span><span id="c99f" class="nl kx iq oc b gy ok oh l oi oj">   <strong class="oc ir">for</strong> each pair of (user, movie):</span><span id="4d15" class="nl kx iq oc b gy ok oh l oi oj">   b_i =  b_i - learning_rate * dL/db_i</span><span id="44d2" class="nl kx iq oc b gy ok oh l oi oj">   c_j =  c_j - learning_rate * dL/dc_j</span></pre><p id="1e73" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mr lz ma mb mt md me mf mv mh mi mj ij bi translated">为了简单起见，我们只将<strong class="lq ir"> user_bias </strong>和<strong class="lq ir"> movie bias </strong>作为可训练参数，我们使用SVD来计算用户和电影向量(你可以将SVD视为一种矩阵分解技术)。</p><p id="0899" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mr lz ma mb mt md me mf mv mh mi mj ij bi translated">这里<strong class="lq ir"> b_i是用户偏差</strong>的数组，其中该数组的维数等于我们的训练集中的总用户数(最大用户指数)(每个用户都有偏差)，而<strong class="lq ir"> c_j指的是我们的训练集中的总电影数</strong>(最大电影指数)。</p><p id="c30f" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mr lz ma mb mt md me mf mv mh mi mj ij bi translated">她的<strong class="lq ir"> dl/db_i指衍生w.r.t用户偏差，dl/dc_j指衍生w.r.t电影偏差</strong>。</p><p id="7bf1" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mr lz ma mb mt md me mf mv mh mi mj ij bi translated">首先，让我们设定RMSE的上限，通过简单地设定所有预测评级到全球平均评级来计算RMSE。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ol"><img src="../Images/6055b1132de6f5ce891d5c2c5276a464.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jGes5zmW84bxHL4vb8t61g.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">来源:作者图片</p></figure><p id="b172" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mr lz ma mb mt md me mf mv mh mi mj ij bi translated">现在我们知道了上限，即3.5左右的任何值都可以作为全局平均值来预测所有值，我们已经为我们的推荐方法定义了定制方法，下面是代码</p><pre class="kg kh ki kj gt ob oc od oe aw of bi"><span id="cee0" class="nl kx iq oc b gy og oh l oi oj"><strong class="oc ir">def fit_recommender</strong>(total_epochs,learning_rate,train_sparse_matrix,train_df,test_df,svd_components = 5):<br/>    <em class="mn">'''learns parameters for the recommednder'''</em><br/>    total_train_mse = []<br/>    total_test_mse = []<br/>    U1, Sigma, V1 = randomized_svd(train_sparse_matrix,      n_components=svd_components,n_iter=2, random_state=24)<br/>    total_train_mse = []<br/>    total_test_mse = []<br/>    <strong class="oc ir">for</strong> epoch in range(total_epochs):<br/>        <strong class="oc ir">for</strong> user,movie,rate in train_df[['user','movie','rating']].values:<br/>            b_i[user] = b_i[user] - learning_rate *  <strong class="oc ir">derivative_db</strong>(user,movie,rate,U1,V1,mu,alpha) <br/>            c_j[movie] = c_j[movie] - learning_rate *  <strong class="oc ir">derivative_dc</strong>(user,movie,rate,U1,V1,mu,alpha)<br/>        train_error = get_prediction(train_df,b_i,c_j,mu)<br/>        test_error = get_prediction(test_df,b_i,c_j,mu)<br/>        total_train_mse.append(train_error)<br/>        total_test_mse.append(test_error)<br/>        <strong class="oc ir">print</strong>("After Epoch {}------Train rmse:{}  Test rmse:{}".format(epoch,train_error,test_error))<br/>     <strong class="oc ir">print</strong>("=======================================================")</span></pre><p id="7abc" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mr lz ma mb mt md me mf mv mh mi mj ij bi translated">我们的拟合方法首先使用truncatedSVD计算用户电影潜在向量表示(理想情况下，这些用户电影表示也应该在训练过程中学习)，然后通过执行梯度下降步骤在每个时期学习用户电影偏差，下面是我们运行定制拟合方法后的结果</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi om"><img src="../Images/33d030fb06cc7bb598a29668ce97ee29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NVbLYtzmHKbMnxcZD0dulA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">来源:作者图片</p></figure><p id="2e5a" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mr lz ma mb mt md me mf mv mh mi mj ij bi translated">训练和测试RMSE的都比我们的基线模型好，因此我们可以得出结论，模型确实从这些用户和电影偏见形式的数据中学习了一些隐藏的模式</p><p id="cb6b" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mr lz ma mb mt md me mf mv mh mi mj ij bi translated">现在你可能会觉得这是一个有点太多的手工工作，难道我们没有像scikit_learn这样的东西，我们只需要调用fit方法，所有的事情都是自动完成的，那么你将会得到一个<strong class="lq ir">惊喜，</strong>所有这些以及更多的事情都可以通过这个<strong class="lq ir">神奇的库来完成，这个库被称为用于构建和测试推荐系统的惊喜</strong>。</p><p id="0911" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mr lz ma mb mt md me mf mv mh mi mj ij bi translated">我们需要建立一个稍微不同的数据集来让惊奇发挥作用</p><pre class="kg kh ki kj gt ob oc od oe aw of bi"><span id="7b75" class="nl kx iq oc b gy og oh l oi oj"><strong class="oc ir">from</strong> surprise <strong class="oc ir">import</strong> Reader, Dataset<br/>reader = Reader(rating_scale=(1,5))<br/><em class="mn"># create the traindata from the dataframe...<br/></em>train_data = Dataset.load_from_df(train_df[['user', 'movie', 'rating']], reader)<br/><em class="mn"># build the trainset from traindata.., It is of dataset format from s</em>urprise library..<br/>trainset = train_data.build_full_trainset() # we have to convert testset into list tuples of user,movie,rating<br/>testset = list(zip(test_df.user.values, test_df.movie.values, test_df.rating.values))</span></pre><p id="f665" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mr lz ma mb mt md me mf mv mh mi mj ij bi translated">从数据集类中，我们调用load_from_df函数，该函数以所需的格式构建训练集，现在让我们构建我们的推荐系统</p><pre class="kg kh ki kj gt ob oc od oe aw of bi"><span id="60fc" class="nl kx iq oc b gy og oh l oi oj"><strong class="oc ir">def</strong> run_surpise(surprise_algo,trainset):<br/>    svd.fit(trainset)<br/>    train_preds = svd.test(trainset.build_testset())<br/>    train_actual_ratings, train_pred_ratings = <strong class="oc ir">get_ratings</strong>(train_preds)<br/>    train_rmse = <strong class="oc ir">get_errors</strong>(train_preds) <br/>    test_preds = svd.test(testset)<br/>    test_actual_ratings, test_pred_ratings = get_ratings(test_preds)<br/>    test_rmse = get_errors(test_preds)    <br/>    print("Train RMSE : {}  Test RMSE : {}".format(train_rmse,test_rmse))</span></pre><p id="4d4d" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mr lz ma mb mt md me mf mv mh mi mj ij bi translated">现在，让我们运行我们的惊喜模型，并查看结果(优化函数与我们之前讨论的相同，现在我们正在学习用户、电影偏差<strong class="lq ir">以及来自训练集的项目潜在向量</strong>，即使用机器学习来执行矩阵分解)</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi on"><img src="../Images/86cf66385261852d79de8f2bbe586e1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-Msmwk3BUKFswyTHU7KgXw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">来源:作者图片</p></figure><p id="6726" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mr lz ma mb mt md me mf mv mh mi mj ij bi translated">不错的训练和测试RMSE改进，这只是一种算法，惊喜有许多其他预测算法可以使用请随意阅读官方<a class="ae kv" href="https://surprise.readthedocs.io/en/stable/getting_started.html" rel="noopener ugc nofollow" target="_blank">文档</a>为惊喜和尝试其他，这就像scikit-learn，只是即插即用。</p><h2 id="49e4" class="nl kx iq bd ky nm nn dn lc no np dp lg lx nq nr li mb ns nt lk mf nu nv lm nw bi translated">冷启动问题</h2><p id="a1f4" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">在结束之前，我想讨论一下协同过滤方法的一个主要缺点，即冷启动问题。测试集中会有一些用户/电影根本没有出现在训练集中，因此你不能使用协作方法，因为你没有这些电影/用户的任何过去的交互。为了处理冷启动问题，我们可以引入额外的用户级、项目级特征，如用户年龄、电影类型等，基本上合并了基于内容和协作的方法以获得更好的预测。</p><h1 id="66d5" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated"><strong class="ak">结论</strong></h1><p id="c274" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">这个博客的目的是给你一个推荐系统的高层次概述，让你开始。对于那些感兴趣的人，我建议通过在实际数据集上进行尝试来获得一些实践经验。下面是博客中提到的代码的Github知识库的链接</p><p id="c696" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mr lz ma mb mt md me mf mv mh mi mj ij bi translated">资源库链接:<a class="ae kv" href="https://github.com/ravi207/RecommenderSystem/blob/main/recommender_system.ipynb" rel="noopener ugc nofollow" target="_blank">https://github . com/ravi 207/re commender system/blob/main/recommender _ system . ipynb</a></p><p id="56d3" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mr lz ma mb mt md me mf mv mh mi mj ij bi translated">这里有一些我觉得非常有用的好资源。</p><ul class=""><li id="0609" class="mw mx iq lq b lr mo lu mp lx my mb mz mf na mj nb nc nd ne bi translated"><a class="ae kv" href="https://www.researchgate.net/publication/223460749_The_BigChaos_Solution_to_the_Netflix_Grand_Prize" rel="noopener ugc nofollow" target="_blank">https://www . researchgate . net/publication/223460749 _ The _ big chaos _ Solution _ to _ The _网飞_Grand_Prize </a></li><li id="ba9d" class="mw mx iq lq b lr nf lu ng lx nh mb ni mf nj mj nb nc nd ne bi translated"><a class="ae kv" href="https://www.youtube.com/watch?v=UyAfmAZU_WI" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=UyAfmAZU_WI</a></li><li id="6008" class="mw mx iq lq b lr nf lu ng lx nh mb ni mf nj mj nb nc nd ne bi translated"><a class="ae kv" href="https://www.youtube.com/watch?v=h9gpufJFF-0" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=h9gpufJFF-0</a></li></ul><h1 id="5eaa" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated"><strong class="ak">参考文献</strong></h1><p id="3a67" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">[1]<a class="ae kv" href="https://en.wikipedia.org/wiki/Recommender_system" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Recommender_system</a></p><p id="c6f0" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mr lz ma mb mt md me mf mv mh mi mj ij bi translated">[2]麦克斯韦·哈珀和约瑟夫·康斯坦。2015.电影镜头数据集:历史和背景。美国计算机学会交互式智能系统汇刊5，4:19:1–19:19。<a class="ae kv" href="https://doi.org/10.1145/2827872" rel="noopener ugc nofollow" target="_blank">https://doi.org/10.1145/2827872</a></p></div></div>    
</body>
</html>