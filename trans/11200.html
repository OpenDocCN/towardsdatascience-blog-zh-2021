<html>
<head>
<title>C++: Optional Object that may contain another object</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">C++:可选对象，可能包含另一个对象</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/c-optional-object-that-may-contain-another-object-f04d5cfb6b63?source=collection_archive---------17-----------------------#2021-11-02">https://towardsdatascience.com/c-optional-object-that-may-contain-another-object-f04d5cfb6b63?source=collection_archive---------17-----------------------#2021-11-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="e3fe" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用第一原则思维来学习更好地编码以处理我们的数据。了解可选对象能解决什么问题，分解它，并重新构建它</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/8920530346f3ad6258c62725522e9bef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*CW7St9dPxLuFXgto"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">穆罕默德·拉赫马尼在<a class="ae le" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><h1 id="e5e7" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">概观</h1><p id="dd61" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">从C++17开始，C++标准库提供了<strong class="js iu"> std::optional </strong>，这是一个管理可选包含值的类模板。<em class="mi">可选的</em>类型或者有时也叫<em class="mi">可能</em>类型代表一个可选值的封装。</p><p id="d9f0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这篇文章中，我将介绍<strong class="js iu"> std::optional </strong>解决的问题，描述解决这些问题的需求，最后构建一个简单版本的可选类来演示它是如何工作的。</p><h1 id="3789" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">可选对象解决的问题</h1><p id="4425" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">在我们代码中的一些场景中，我们会面临这样的情况:我们希望从函数中返回一个可选对象，或者在函数中接受可选参数。例如，在下面的代码中，我们希望返回一个只有在满足某些条件时才可用的数据对象。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="e513" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">另一个例子是当我们想设置数据，但有时他们不可用，我们希望函数检查和决定。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="f352" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果不使用像<strong class="js iu"> std::optional </strong>这样的类模板来包装数据对象，在C++17之前，我们可以使用以下技术。</p><h2 id="2caa" class="ml lg it bd lh mm mn dn ll mo mp dp lp kb mq mr lt kf ms mt lx kj mu mv mb mw bi translated">用一个标志将我们的数据包装在一个结构/类中</h2><p id="4f1e" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">我们可以创建以下结构，<strong class="js iu"> OptionalData </strong>:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="dc13" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们是这样调用这个函数的:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="c96c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这种技术不仅增加了大小开销(bool + padding)，还增加了构造数据对象的时间开销，当数据对象无效时，这是不必要的。</p><h2 id="f116" class="ml lg it bd lh mm mn dn ll mo mp dp lp kb mq mr lt kf ms mt lx kj mu mv mb mw bi translated">使用指针包装我们的数据</h2><p id="87d5" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">为了避免在不需要的时候构造数据对象，我们可以使用智能指针，比如<strong class="js iu"> std::unique_ptr </strong>来包装我们的数据。当条件不满足时，我们可以返回<strong class="js iu"> nullptr </strong>。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="5064" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在呼叫者方面，它看起来是这样的:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="31f9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">与前一种技术相比，这种技术要好得多，但是代码不是很有表现力，因为为此目的使用指针不能很好地解释函数的意图。</p><p id="c580" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">返回多个值</strong></p><p id="7cdd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">从C++11开始，我们可以使用<strong class="js iu"> std::tuple </strong>返回多个值，或者在这种情况下我们想返回两个值，可以使用<strong class="js iu"> std::pair </strong>。这可能是最常用的技术。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="4109" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在呼叫端，它看起来是这样的:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="0004" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">从语义上来说，这种技术与我们的第一种技术相同，在第一种技术中，我们将数据对象包装在一个结构中。因此，它遭受同样的问题，此外，程序员必须记住是否使用“第一”或“第二”。</p><h2 id="79fe" class="ml lg it bd lh mm mn dn ll mo mp dp lp kb mq mr lt kf ms mt lx kj mu mv mb mw bi translated">传入指针并返回布尔状态</h2><p id="9133" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">我们也可以使用类似C的技术，传递一个指针并返回一个布尔值。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="185e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在呼叫端，它看起来是这样的:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="ffc0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们不仅在这里使用了可能被认为是不安全的原始指针，而且尽管它是有效的并且总是需要构造数据对象，但是它的表达性较差。</p><h2 id="0256" class="ml lg it bd lh mm mn dn ll mo mp dp lp kb mq mr lt kf ms mt lx kj mu mv mb mw bi translated">问题</h2><p id="0f50" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">我们现在可以列出上述各种技术存在的问题，如下所示。</p><ol class=""><li id="d6e0" class="mx my it js b jt ju jx jy kb mz kf na kj nb kn nc nd ne nf bi translated">他们没有清楚地传达意图。我们的目的不是获取一个指针或一对对象，而是希望在数据对象可用时可以选择获取它</li><li id="8ce0" class="mx my it js b jt ng jx nh kb ni kf nj kj nk kn nc nd ne nf bi translated">其中一些不必要地构造了数据对象</li><li id="8041" class="mx my it js b jt ng jx nh kb ni kf nj kj nk kn nc nd ne nf bi translated">对于类似C的技术，它是不安全的，尤其是如果指针是从空闲存储/堆中分配的</li></ol><h1 id="0e63" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">我们如何解决这些问题？</h1><p id="8727" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">从上面列出的问题来看，这些是我们的需求。</p><ol class=""><li id="b5d6" class="mx my it js b jt ju jx jy kb mz kf na kj nb kn nc nd ne nf bi translated">可选对象必须包含真实对象</li><li id="abf2" class="mx my it js b jt ng jx nh kb ni kf nj kj nk kn nc nd ne nf bi translated">包含的对象应该在可选对象内(不是动态分配的)</li><li id="46c2" class="mx my it js b jt ng jx nh kb ni kf nj kj nk kn nc nd ne nf bi translated">可选对象可能为空</li><li id="853a" class="mx my it js b jt ng jx nh kb ni kf nj kj nk kn nc nd ne nf bi translated">所包含的对象可以稍后设置</li><li id="abce" class="mx my it js b jt ng jx nh kb ni kf nj kj nk kn nc nd ne nf bi translated">包含的对象可能在可选对象之前被销毁</li></ol><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/4a840a05ef2d073b4239272d9183d0d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:402/format:webp/1*gGOaP63iGuW5BGy2ziFy7w.png"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">包含另一个对象的可选对象(图片由作者提供)</p></figure><h1 id="dac2" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">编写简单的可选对象</h1><p id="f366" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">我们构建可选对象来理解<strong class="js iu"> std::optional </strong>是如何工作的。我们省略了大部分接口，把注意力集中在存储对象的主要内容上。</p><p id="fa85" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">第一个要求是包含任何对象，并有一个标志来检查它是否为空。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="85ae" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是这和我们上面的第一个技术是一样的，只是现在它是一个类模板。我们希望可选对象在默认情况下不构造包含的对象。实现它的一种方法是使用<strong class="js iu"> std::aligned_storage </strong>为包含的对象保留空间。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="c206" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里发生的情况是，被包含的类型没有被存储，但是当我们构造可选对象时，存储它所必需的空间被保留。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/832d092d83e181e645c07e2aeed98d5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:322/format:webp/1*3C0HWhHABCyFBfhOqE6QXw.png"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">可选对象内存布局(图片由作者提供)</p></figure><p id="9f70" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当我们构造一个空的可选对象时，我们只初始化这两个对象。为了初始化包含的对象，我们使用<strong class="js iu">放置new </strong>，即使用new运算符在现有位置构造一个对象。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="968e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">另一种方法是使用<strong class="js iu">匿名联合</strong>，这可能是一种更好、更干净的方法。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="966b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下一个要求是，我们可能希望在销毁可选对象之前销毁包含的对象，为此我们添加了reset()函数。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="2561" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们可能还想稍后设置包含的对象，如下例所示:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="1f95" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为此，我们可以实现复制赋值和移动赋值操作符。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="672d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们可以用类似的方式实现移动赋值操作符。通过调用<strong class="js iu">可选&lt;数据&gt;(常量数据&amp; t) </strong>构造器，然后调用复制赋值操作符，首先将<strong class="js iu">数据</strong>对象隐式转换为<strong class="js iu">可选&lt;数据&gt; </strong>类型。</p><h2 id="27db" class="ml lg it bd lh mm mn dn ll mo mp dp lp kb mq mr lt kf ms mt lx kj mu mv mb mw bi translated">其余的接口</h2><p id="432f" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">为了获得包含的对象，我们可以很容易地实现<strong class="js iu"> value() </strong>函数，如果包含的对象存在，则返回该对象，否则抛出异常。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="b19a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">其余的接口可以很容易地实现，在这篇文章中没有全部展示，因为它可能会变得太长。可以看这个<a class="ae le" href="https://en.cppreference.com/w/cpp/utility/optional" rel="noopener ugc nofollow" target="_blank">页面</a>看其他界面。</p><h2 id="add7" class="ml lg it bd lh mm mn dn ll mo mp dp lp kb mq mr lt kf ms mt lx kj mu mv mb mw bi translated">现有std::optional的其他改进</h2><p id="da77" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">可以对现有的<strong class="js iu"> std::optional </strong>进行进一步的改进。在某些情况下，我们可能希望根据可选对象的状态调用其他函数。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="4cba" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为此，根据此<a class="ae le" href="https://en.cppreference.com/w/cpp/utility/optional" rel="noopener ugc nofollow" target="_blank">页面</a>，C++23将添加以下内容:</p><ul class=""><li id="d36a" class="mx my it js b jt ju jx jy kb mz kf na kj nb kn nn nd ne nf bi translated">and_then(f) <br/>如果返回的可选对象包含另一个对象，则执行可调用的‘f’可以返回<strong class="js iu">任何</strong>类型，否则返回空的可选对象。</li><li id="fef8" class="mx my it js b jt ng jx nh kb ni kf nj kj nk kn nn nd ne nf bi translated">transform(f) <br/>如果返回的可选对象包含另一个对象，则执行可调用的‘f’返回<strong class="js iu">可选的</strong>类型，否则返回空的可选对象。</li><li id="1281" class="mx my it js b jt ng jx nh kb ni kf nj kj nk kn nn nd ne nf bi translated">or_else(f) <br/>如果返回的可选对象为<strong class="js iu">空</strong>，则执行可调用的‘f’返回可选类型，否则返回可选对象。</li></ul><p id="c658" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">它们被称为<a class="ae le" href="https://en.wikipedia.org/wiki/Monad_(functional_programming)" rel="noopener ugc nofollow" target="_blank">一元函数</a>，其工作是抽象出样板代码，我们可以以更简单、更易读的形式修改上面的代码。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mj mk l"/></div></figure><h1 id="e4e6" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">Python中的类似功能</h1><p id="1b35" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">您可能已经意识到，在Python中，我们可以通过不返回任何对象来轻松实现可选对象。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="3892" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在C++中，我们必须使用C++标准库中的std::optional来实现这一点。</p><h1 id="daa0" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">摘要</h1><p id="2714" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">关键要点是:</p><ul class=""><li id="d39a" class="mx my it js b jt ju jx jy kb mz kf na kj nb kn nn nd ne nf bi translated">我们使用<strong class="js iu"> std::optional </strong>使我们的代码更具表现力</li><li id="0295" class="mx my it js b jt ng jx nh kb ni kf nj kj nk kn nn nd ne nf bi translated"><strong class="js iu"> std::optional </strong>包含对象本身，这取决于它的存储位置(堆栈/数据/堆)</li><li id="f5c6" class="mx my it js b jt ng jx nh kb ni kf nj kj nk kn nn nd ne nf bi translated"><strong class="js iu"> std::optional </strong>复制包含的对象</li><li id="6453" class="mx my it js b jt ng jx nh kb ni kf nj kj nk kn nn nd ne nf bi translated">一元函数将被添加到<strong class="js iu"> C++23 </strong>中，通过消除编写样板代码的需要来改进我们代码中的抽象</li></ul><div class="no np gp gr nq nr"><a href="https://debby-nirwan.medium.com/subscribe" rel="noopener follow" target="_blank"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd iu gy z fp nw fr fs nx fu fw is bi translated">每当王思然·尼旺发表文章时，就收到一封电子邮件。</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">每当王思然·尼旺发表文章时，就收到一封电子邮件。通过注册，您将创建一个中型帐户，如果您还没有…</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">debby-nirwan.medium.com</p></div></div><div class="oa l"><div class="ob l oc od oe oa of ky nr"/></div></div></a></div></div></div>    
</body>
</html>