<html>
<head>
<title>10 Fabulous Python Decorators</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">10个神话般的Python装饰者</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/10-fabulous-python-decorators-ab674a732871?source=collection_archive---------1-----------------------#2021-05-28">https://towardsdatascience.com/10-fabulous-python-decorators-ab674a732871?source=collection_archive---------1-----------------------#2021-05-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8c37" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Python编程语言中一些我最喜欢的装饰器的概述。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/016a56c77c7083c7f1f5a23b728af163.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vrgI2UAcoEK7uMEeQ7cHXg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(src =<a class="ae ky" href="https://pixabay.com/images/id-3359870/" rel="noopener ugc nofollow" target="_blank">https://pixabay.com/images/id-3359870/</a></p></figure><h1 id="344f" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">介绍</h1><p id="6ec7" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi mn translated"><span class="l mo mp mq bm mr ms mt mu mv di">Python编程语言的一个</span>伟大之处在于，它将所有的特性打包成一个非常有用的小软件包。许多上述特性可以完全改变Python代码的功能，这使得该语言更加通用。此外，如果使用得当，这些功能中的一些可以缩短编写有效软件所需的时间。Python特性很好地实现了这些目标的一个很好的例子是Python的decorators。</p><p id="c40e" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">装饰器是快速编程宏，可用于改变Python对象的行为。它们可以应用于类和函数，实际上可以做很多真正有趣的事情！装饰器可以用来缩短代码，加速代码，并完全改变代码在Python中的行为方式。不用说，这个肯定能派上用场！今天我想展示一些我认为值得一试的装饰者。有很多装饰者，但是我选择了一些我认为功能最酷的。</p></div><div class="ab cl nb nc hx nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="im in io ip iq"><h1 id="e0f2" class="kz la it bd lb lc ni le lf lg nj li lj jz nk ka ll kc nl kd ln kf nm kg lp lq bi translated">№1: @lru_cache</h1><p id="3014" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">这个列表中的第一个装饰器来自functools模块。这个模块包含在标准库中，非常容易使用。它还包含了比这个装饰器更酷的特性，但是这个装饰器肯定是我最喜欢的。这个装饰器可以用来加速使用缓存的函数和操作的连续运行。当然，在使用时应该注意交换和缓存，但是在一般用途的情况下，大多数时候这个装饰器是值得使用的。如果你想了解更多关于Functools的知识以及我喜欢它的原因，我实际上写了一整篇文章，你可以在这里阅读:</p><div class="nn no gp gr np nq"><a rel="noopener follow" target="_blank" href="/functools-an-underrated-python-package-405bbef2dd46"><div class="nr ab fo"><div class="ns ab nt cl cj nu"><h2 class="bd iu gy z fp nv fr fs nw fu fw is bi translated">FuncTools:一个被低估的Python包</h2><div class="nx l"><h3 class="bd b gy z fp nv fr fs nw fu fw dk translated">使用functools将您的Python函数提升到一个新的水平！</h3></div><div class="ny l"><p class="bd b dl z fp nv fr fs nw fu fw dk translated">towardsdatascience.com</p></div></div><div class="nz l"><div class="oa l ob oc od nz oe ks nq"/></div></div></a></div><p id="bc28" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">能够用一个简单的装饰器来加速代码是非常棒的。可以从这样的装饰器中获益的函数的一个很好的例子是递归函数，例如计算阶乘的函数:</p><pre class="kj kk kl km gt of og oh oi aw oj bi"><span id="de6a" class="ok la it og b gy ol om l on oo">def factorial(n):<br/>    return n * factorial(n-1) if n else 1</span></pre><p id="1616" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">递归在计算时间上相当困难，但是添加这个装饰器可以帮助显著地加速这个函数的连续运行。</p><pre class="kj kk kl km gt of og oh oi aw oj bi"><span id="1018" class="ok la it og b gy ol om l on oo"><a class="ae ky" href="http://twitter.com/lru_cache" rel="noopener ugc nofollow" target="_blank">@lru_cache</a><br/>def factorial(n):<br/>    return n * factorial(n-1) if n else 1</span></pre><p id="a0e4" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">现在，每当我们运行这个函数时，前几个阶乘计算将被保存到缓存中。因此，下一次我们去调用函数时，我们只需要计算我们之前使用的阶乘之后的阶乘。当然，并不是所有的阶乘计算都会被保存，但是很容易理解为什么这是这个装饰器的一个很好的应用，可以加速一些本来就很慢的代码。</p><h1 id="b3b7" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">№2: @jit</h1><p id="7983" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">JIT是实时编译的缩写。通常每当我们在Python中运行一些代码时，首先发生的是编译。这种编译会产生一些开销，因为类型会被分配内存并存储为未赋值但已命名的别名。通过即时编译，我们在执行时完成了大部分工作。从很多方面来说，我们可以认为这类似于并行计算，Python解释器同时处理两件事，以节省时间。</p><p id="0310" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">Numba JIT编译器因在Python中提供了这一概念而闻名。与@lru_cache类似，这个装饰器可以很容易地被调用，从而立即提高代码的性能。Numba包提供了jit decorator，这使得运行更密集的软件变得容易得多，而不必使用c。如果您想阅读关于这个包的更多内容，我还有另外一篇文章，您可以在这里查看:</p><div class="nn no gp gr np nq"><a rel="noopener follow" target="_blank" href="/numba-jit-compilation-but-for-python-373fc2f848d6"><div class="nr ab fo"><div class="ns ab nt cl cj nu"><h2 class="bd iu gy z fp nv fr fs nw fu fw is bi translated">Numba: JIT编译，但是用于Python</h2><div class="nx l"><h3 class="bd b gy z fp nv fr fs nw fu fw dk translated">快速浏览一下2020年让Python变得更好的神奇工具。</h3></div><div class="ny l"><p class="bd b dl z fp nv fr fs nw fu fw dk translated">towardsdatascience.com</p></div></div><div class="nz l"><div class="op l ob oc od nz oe ks nq"/></div></div></a></div><pre class="kj kk kl km gt of og oh oi aw oj bi"><span id="d740" class="ok la it og b gy ol om l on oo">from numba import jit<br/>import random<br/><br/>@jit(nopython=True)<br/>def monte_carlo_pi(nsamples):<br/>    acc = 0<br/>    for i in range(nsamples):<br/>        x = random.random()<br/>        y = random.random()<br/>        if (x ** 2 + y ** 2) &lt; 1.0:<br/>            acc += 1<br/>    return 4.0 * acc / nsamples</span></pre><h1 id="d28b" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">№3: @do_twice</h1><p id="31b0" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">do_twice装饰器完成了它名字中的大部分工作。这个装饰器可以用来在一次调用中运行一个函数两次。这当然有一些用途，我发现它对调试特别有帮助。它可以用来测量两个不同迭代的性能。以Functools为例，我们可以让一个函数运行两次，以检查是否有改进。这个函数是由Python中的decorators模块提供的，它在标准库中。</p><pre class="kj kk kl km gt of og oh oi aw oj bi"><span id="10bd" class="ok la it og b gy ol om l on oo">from decorators import do_twice<br/>@do_twice<br/>def timerfunc():<br/>    %timeit factorial(15)</span></pre><h1 id="f8d6" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">№4: @count_calls</h1><p id="e94f" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">伴随do_twice装饰器的简单性的是count_calls装饰器。这个装饰器可以用来提供一个函数在软件中被使用了多少次的信息。像do_twice一样，这对于调试来说肯定会很方便。当添加到一个给定的函数中时，我们将收到一个输出，告诉我们该函数每次运行时已经运行了多少次。这个装饰器也在标准库中的装饰器模块中。</p><pre class="kj kk kl km gt of og oh oi aw oj bi"><span id="d840" class="ok la it og b gy ol om l on oo">from decorators import count_calls<br/>@count_calls<br/>def function_example():<br/>    print("Hello World!"</span><span id="936a" class="ok la it og b gy oq om l on oo">function_example()<br/>function_example()<br/>function_example()</span></pre><h1 id="917e" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">№5:@数据类</h1><p id="7088" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">为了节省编写类的时间，我一直在使用的最好的装饰器之一是dataclass装饰器。这个装饰器可以用来快速编写我们编写的类中常见的标准方法。如果您想了解更多关于这个装饰者的信息，我也有一篇关于它的文章，您可以在这里阅读:</p><div class="nn no gp gr np nq"><a rel="noopener follow" target="_blank" href="/pythons-data-classes-are-underrated-cc6047671a30"><div class="nr ab fo"><div class="ns ab nt cl cj nu"><h2 class="bd iu gy z fp nv fr fs nw fu fw is bi translated">Python的数据类被低估了</h2><div class="ny l"><p class="bd b dl z fp nv fr fs nw fu fw dk translated">towardsdatascience.com</p></div></div><div class="nz l"><div class="or l ob oc od nz oe ks nq"/></div></div></a></div><p id="9bfc" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">这个装饰器来自dataclass模块。这个模块也在标准库中，所以不需要PIP来试用这个例子！</p><pre class="kj kk kl km gt of og oh oi aw oj bi"><span id="af5f" class="ok la it og b gy ol om l on oo">from dataclasses import dataclass<a class="ae ky" href="http://twitter.com/dataclass" rel="noopener ugc nofollow" target="_blank">@dataclass</a><br/>class Food:<br/>    name: str<br/>    unit_price: float<br/>    stock: int = 0<br/>        <br/>    def stock_value(self) -&gt; float:<br/>        return(self.stock * self.unit_price)</span></pre><p id="e465" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">这段代码将自动创建一个初始化函数__init__()，其中包含填充我们的类中的数据所必需的位置参数。它们也会自动提供给self，所以没有必要仅仅为了将一些数据参数放入一个类而编写一个很长的函数。</p><h1 id="1bc2" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">№6:@单身</h1><p id="7de4" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">为了理解单例装饰器的目的，我们需要首先理解什么是单例。从某种意义上说，单例是全局类型的一个版本。这意味着这些类型被定义为只存在一次。尽管这些在C++等语言中很常见，但在Python中却很少见。对于单例，我们创建一个只使用一次的类，并改变这个类，而不是一个初始化的构造类型。在这种情况下，类型不太像模板，而更像一个单独的受控对象。</p><p id="f287" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">通常情况下，单例装饰器是由用户制作的，实际上并不是导入的。这是因为singleton仍然是对我们的singleton decorator中提供的模板的引用。为了在我们的类中使用这个装饰器，我们可以命名一个单例函数并编写一个包装器:</p><pre class="kj kk kl km gt of og oh oi aw oj bi"><span id="e78e" class="ok la it og b gy ol om l on oo">def singleton(cls):<br/>    instances = {}<br/>    def wrapper(*args, **kwargs):<br/>        if cls not in instances:<br/>          instances[cls] = cls(*args, **kwargs)<br/>        return instances[cls]<br/>    return wrapper</span><span id="1e13" class="ok la it og b gy oq om l on oo">@singleton<br/>class cls:<br/>    def func(self):</span></pre><p id="2bff" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">解决这个问题的另一种方法是使用元类。如果你想了解更多关于元类的知识，我去年写了一篇文章，更详细地介绍了这些元类以及它们的用途，你可以在这里查看:</p><div class="nn no gp gr np nq"><a rel="noopener follow" target="_blank" href="/pythonic-metaprogramming-with-metaclasses-19b0df1e1760"><div class="nr ab fo"><div class="ns ab nt cl cj nu"><h2 class="bd iu gy z fp nv fr fs nw fu fw is bi translated">具有元类的Pythonic元编程</h2><div class="nx l"><h3 class="bd b gy z fp nv fr fs nw fu fw dk translated">你的装饰和元类生存指南。</h3></div><div class="ny l"><p class="bd b dl z fp nv fr fs nw fu fw dk translated">towardsdatascience.com</p></div></div><div class="nz l"><div class="os l ob oc od nz oe ks nq"/></div></div></a></div><pre class="kj kk kl km gt of og oh oi aw oj bi"><span id="9f88" class="ok la it og b gy ol om l on oo">class Singleton(type):<br/>    _instances = {}<br/>    def __call__(cls, *args, **kwargs):<br/>        if cls not in cls._instances:<br/>            cls._instances[cls] = super(Singleton, cls).__call__(*args, **kwargs)<br/>        return cls._instances[cls]<br/>        <br/>class Logger(object):<br/>    __metaclass__ = Singleton</span></pre><h1 id="0728" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">№7: <code class="fe ot ou ov og b">@use_unit</code></h1><p id="b77d" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">对于科学计算来说，一个可能经常派上用场的装饰器是use_unit装饰器。这个装饰器可以用来改变方法返回的输出。对于那些不想在数据中添加测量单位，但又想让人们知道这些单位是什么的人来说，这很有用。这个装饰器在任何模块中都不可用，但是非常常见，对于科学应用程序非常有用。</p><pre class="kj kk kl km gt of og oh oi aw oj bi"><span id="8350" class="ok la it og b gy ol om l on oo">def use_unit(unit):<br/>    """Have a function return a Quantity with given unit"""<br/>    use_unit.ureg = pint.UnitRegistry()<br/>    def decorator_use_unit(func):<br/>        @functools.wraps(func)<br/>        def wrapper_use_unit(*args, **kwargs):<br/>            value = func(*args, **kwargs)<br/>            return value * use_unit.ureg(unit)<br/>        return wrapper_use_unit<br/>    return decorator_use_unit<br/><br/>@use_unit("meters per second")<br/>def average_speed(distance, duration):<br/>    return distance / duration</span></pre><h1 id="8dfe" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">№7:<strong class="ak">@ wrapps</strong></h1><p id="a814" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">函数包装器是在Python中处理相对复杂的函数时使用的一种设计模式。包装器函数通常用于完成一些更低级的迭代任务。包装函数的好处是它可以用来显著提高性能。和lru_cache装饰器一样，这个装饰器是由FuncTools包提供的。</p><pre class="kj kk kl km gt of og oh oi aw oj bi"><span id="8b86" class="ok la it og b gy ol om l on oo">import functools as ft</span></pre><p id="4c57" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">包装装饰器本身只是一个方便的装饰器，用于更新给定函数的包装器。当这个装饰器被调用时，这个函数将在每次使用时更新它的包装器。这对于提高性能大有帮助，FuncTools中的许多可用工具就是如此。</p><pre class="kj kk kl km gt of og oh oi aw oj bi"><span id="1c75" class="ok la it og b gy ol om l on oo"><strong class="og iu">def</strong> my_decorator(f):<br/>    <strong class="og iu">@wraps</strong>(f)<br/>    <strong class="og iu">def</strong> wrapper(*args, **kwds):<br/>        print('Calling decorated function')<br/>        <strong class="og iu">return</strong> f(*args, **kwds)<br/>    <strong class="og iu">return</strong> wrapper</span></pre><p id="ef8b" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">包装器本身通常是装饰器，包装器装饰器调用通常用在装饰器调用中的包装器函数上。编写完代码后，我们可以用这个包装器来修饰我们的新函数:</p><pre class="kj kk kl km gt of og oh oi aw oj bi"><span id="61c4" class="ok la it og b gy ol om l on oo">@my_decorator<br/>def func(x):<br/>    print(x)</span></pre><h1 id="d5fd" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">№8:@静态方法</h1><p id="a722" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在某些情况下，可能会有这样的情况，人们可能希望能够访问在更广泛的意义上被私下定义的东西。有时，我们有一些函数包含在我们希望被系统化的类中，这正是staticmethod decorator的用途。</p><p id="6059" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">使用这个装饰器，我们可以制作C++静态方法来处理我们的类。通常，在类的范围内编写的方法对于该类是私有的，除非作为子类调用，否则不可访问。但是，在某些情况下，您可能希望在方法与数据交互的方式上采用更具功能性的方法。使用这个装饰器，我们可以创建两个选项，而不需要创建多个函数。</p><pre class="kj kk kl km gt of og oh oi aw oj bi"><span id="a801" class="ok la it og b gy ol om l on oo"><strong class="og iu">class</strong> Example:<br/>    <strong class="og iu">@staticmethod<br/></strong>    <strong class="og iu">def</strong> our_func(stuff):<br/>        print(stuff)</span></pre><p id="375f" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">我们也不需要显式地提供我们的类作为参数。staticmethod decorator为我们处理这个问题。</p><h1 id="f9c7" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">№9: @singledispatch</h1><p id="32d6" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">FuncTools用非常有用的singledispatch装饰器再次出现在这个列表中。单一分派是一种在许多编程语言中很常见的编程技术，因为它是一种非常好的编程方式。虽然我倾向于选择多个派遣，但我认为单个派遣可以在许多方面用于扮演相同的角色。</p><p id="bff8" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">这个装饰器使得在Python中处理类型更加容易。当我们处理多个类型，并且希望通过同一个方法传递时，情况就更是如此。我在我的FuncTools文章中写了更多关于这个的内容，所以如果你对使用单一分派方法感兴趣，我推荐你使用它(链接在#1中)。)</p><pre class="kj kk kl km gt of og oh oi aw oj bi"><span id="bb2b" class="ok la it og b gy ol om l on oo"><a class="ae ky" href="http://twitter.com/singledispatch" rel="noopener ugc nofollow" target="_blank">@singledispatch</a><br/>def fun(arg, verbose=False):<br/>        if verbose:<br/>            print("Let me just say,", end=" ")<br/>        print(arg)</span><span id="0950" class="ok la it og b gy oq om l on oo"><a class="ae ky" href="http://twitter.com/fun" rel="noopener ugc nofollow" target="_blank">@fun</a>.register<br/>def _(arg: int, verbose=False):<br/>    if verbose:<br/>        print("Strength in numbers, eh?", end=" ")<br/>    print(arg)<br/><a class="ae ky" href="http://twitter.com/fun" rel="noopener ugc nofollow" target="_blank">@fun</a>.register<br/>def _(arg: list, verbose=False):<br/>    if verbose:<br/>        print("Enumerate this:")<br/>    for i, elem in enumerate(arg):<br/>        print(i, elem)</span></pre><h1 id="7bee" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">№10:@注册</h1><p id="319e" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">寄存器函数来自模块atexit。给定该模块的名称和手法，您可能会想到这个装饰器可能与在终止时执行某些操作有关。寄存器装饰器命名一个在终止时运行的函数。例如，这将适用于一些需要在退出时保存的软件。</p><pre class="kj kk kl km gt of og oh oi aw oj bi"><span id="f1c5" class="ok la it og b gy ol om l on oo">from atexit import register<br/>@register<br/>def termin():<br/>    print(" Goodbye!")</span></pre><h1 id="4d90" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">结论</h1><p id="7ac9" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">不用说，Python的装饰器非常有用。它们不仅可以用来降低编写一些代码的时间，而且在加速代码方面也非常有帮助。当你发现装饰者时，他们不仅非常有用，而且编写自己的装饰者也是一个好主意。这些装饰器之所以强大，只是因为装饰器作为一个特性在Python中非常强大。感谢您阅读我的文章，我希望它能让您注意到Python的一些很酷的功能！</p></div></div>    
</body>
</html>