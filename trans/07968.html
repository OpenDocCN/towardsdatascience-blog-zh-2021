<html>
<head>
<title>Practical Python Pandas Tricks - Part 2: Data Preview and Subsetting</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">实用Python熊猫技巧-第2部分:数据预览和子集化</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/introduction-to-pandas-part-2-quick-data-exploration-582fc9b0de28?source=collection_archive---------40-----------------------#2021-07-21">https://towardsdatascience.com/introduction-to-pandas-part-2-quick-data-exploration-582fc9b0de28?source=collection_archive---------40-----------------------#2021-07-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a87a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">有用的熊猫函数和技巧来预览和子集化数据帧</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/b70f8e2964a0c1baa429cdddc9eac618.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*IBIz3v11UbjzBe1M"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@jaymantri?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">杰·曼特里</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="353d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这篇文章是熊猫系列<a class="ae ky" href="https://pandas.pydata.org/" rel="noopener ugc nofollow" target="_blank">的第二部分。请继续关注更多关于这个主题的文章。</a></p><p id="fa4e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" rel="noopener" target="_blank" href="/introduction-to-pandas-part-1-import-and-create-dataframe-e53326b6e2b1"> <strong class="lb iu">第1部分:导入并创建数据帧</strong> </a></p><p id="93ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" rel="noopener" target="_blank" href="/introduction-to-pandas-part-2-quick-data-exploration-582fc9b0de28"> <strong class="lb iu">第二部分:数据预览和子集化</strong> </a></p><p id="2c8d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" rel="noopener" target="_blank" href="/introduction-to-pandas-part-3-data-wrangling-b490f8e47ca2"> <strong class="lb iu">第三部分:数据角力</strong> </a></p><h1 id="3bd5" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">介绍</h1><p id="c57a" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在任何数据科学项目的开始，我们总是希望尽快熟悉数据。查看前n行并计算基本信息，如列名、数据类型、分布、统计汇总，将有助于我们理解数据。一旦我们对数据有了初步的了解，最常见的数据清理步骤之一就是子集化。</p><p id="b618" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我将使用“supermarket _ sales—sheet 1 . CSV”(<a class="ae ky" href="https://www.kaggle.com/aungpyaeap/supermarket-sales" rel="noopener ugc nofollow" target="_blank">下载链接</a>)作为数据源来介绍一些Pandas函数，这些函数允许我们进行快速数据探索和子集化。</p><h1 id="e4fe" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">先决条件</h1><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="ccf9" class="mx lw it mt b gy my mz l na nb"><strong class="mt iu"># Install pandas library</strong><br/>!pip install pandas</span><span id="bceb" class="mx lw it mt b gy nc mz l na nb"><strong class="mt iu"># Import pandas library</strong><br/>import pandas as pd</span><span id="5686" class="mx lw it mt b gy nc mz l na nb"><strong class="mt iu"># Import data source</strong><br/>df = pd.read_csv('supermarket_sales - Sheet1.csv')</span></pre><h1 id="1315" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">快速数据预览</h1><p id="182c" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated"><strong class="lb iu">头&amp;尾:</strong>我们不用回顾整个数据集，只需要几行记录就能轻松消化信息。这两个函数分别返回dataframe的前n行和后n行。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="5d80" class="mx lw it mt b gy my mz l na nb"><strong class="mt iu">df.head(5)</strong><br/>Out[65]: <br/>    Invoice ID Branch       City  ... gross margin percentage gross income Rating<br/>0  750-67-8428      A     Yangon  ...                4.761905      26.1415    9.1<br/>1  226-31-3081      C  Naypyitaw  ...                4.761905       3.8200    9.6<br/>2  631-41-3108      A     Yangon  ...                4.761905      16.2155    7.4<br/>3  123-19-1176      A     Yangon  ...                4.761905      23.2880    8.4<br/>4  373-73-7910      A     Yangon  ...                4.761905      30.2085    5.3</span><span id="4598" class="mx lw it mt b gy nc mz l na nb">[5 rows x 17 columns]</span><span id="b4be" class="mx lw it mt b gy nc mz l na nb"><strong class="mt iu">df.tail(5)</strong><br/>Out[66]: <br/>      Invoice ID Branch  ... gross income Rating<br/>995  233-67-5758      C  ...       2.0175    6.2<br/>996  303-96-2227      B  ...      48.6900    4.4<br/>997  727-02-1313      A  ...       1.5920    7.7<br/>998  347-56-2442      A  ...       3.2910    4.1<br/>999  849-09-3807      A  ...      30.9190    6.6</span><span id="2432" class="mx lw it mt b gy nc mz l na nb">[5 rows x 17 columns]</span></pre><p id="2a19" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">技巧1: </strong>当我们想要预览一个巨大的CSV文件(&gt; 10GB)时，我们可能不想等待很长时间来导入整个数据。有时，快速的数据片段对于确定数据文件及其数据结构中包含的信息非常有帮助。在这种情况下，我们可以使用<code class="fe nd ne nf mt b">read_csv</code>中的<code class="fe nd ne nf mt b">skiprows</code>和<code class="fe nd ne nf mt b">nrows</code>选项来指定我们想要跳过和读取的行数，这可能会将导入时间从几个小时减少到几秒钟。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="1d0e" class="mx lw it mt b gy my mz l na nb">skiprows = 0<br/>lenrow = 100<br/>preview_df = pd.read_csv('supermarket_sales - Sheet1.csv', skiprows = skiprows, nrows = lenrow, header=0, engine='python')</span></pre><p id="5c43" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">列&amp;信息:</strong>了解列名和数据类型对于初始检查非常重要。<code class="fe nd ne nf mt b">columns</code>和<code class="fe nd ne nf mt b">inf</code>函数可以输出列名、非空值的个数和每列的数据类型。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="3c8b" class="mx lw it mt b gy my mz l na nb"><strong class="mt iu">df.columns<br/></strong><br/>Index(['Invoice ID', 'Branch', 'City', 'Customer type', 'Gender',<br/>       'Product line', 'Unit price', 'Quantity', 'Tax 5%', 'Total', 'Date',<br/>       'Time', 'Payment', 'cogs', 'gross margin percentage', 'gross income',<br/>       'Rating'],<br/>      dtype='object')</span><span id="58b8" class="mx lw it mt b gy nc mz l na nb"><strong class="mt iu">df.info()</strong><br/>Data columns (total 17 columns):<br/> #   Column                   Non-Null Count  Dtype  <br/>---  ------                   --------------  -----  <br/> 0   Invoice ID               1000 non-null   object <br/> 1   Branch                   1000 non-null   object <br/> 2   City                     1000 non-null   object <br/> 3   Customer type            1000 non-null   object <br/> 4   Gender                   1000 non-null   object <br/> 5   Product line             1000 non-null   object <br/> 6   Unit price               1000 non-null   float64<br/> 7   Quantity                 1000 non-null   int64  <br/> 8   Tax 5%                   1000 non-null   float64<br/> 9   Total                    1000 non-null   float64<br/> 10  Date                     1000 non-null   object <br/> 11  Time                     1000 non-null   object <br/> 12  Payment                  1000 non-null   object <br/> 13  cogs                     1000 non-null   float64<br/> 14  gross margin percentage  1000 non-null   float64<br/> 15  gross income             1000 non-null   float64<br/> 16  Rating                   1000 non-null   float64<br/>dtypes: float64(7), int64(1), object(9)<br/>memory usage: 132.9+ KB</span></pre><p id="f401" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">技巧2: </strong>您可能会注意到上面输出中的<code class="fe nd ne nf mt b">object</code>数据类型。<code class="fe nd ne nf mt b">object</code>可以包含整数、浮点、字符串等多种不同类型，统称为<code class="fe nd ne nf mt b">object</code>。为了进一步检查给定列的数据类型，我们可以使用<code class="fe nd ne nf mt b">type</code>来输出更多的细节。</p><p id="59cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下面的示例中,“Salary”列包含整数值和字符串值。通过使用<code class="fe nd ne nf mt b">type</code>，我们能够产生频率计数并基于数据类型查看子集。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/d914938524dedb26a6d41add3b8c65a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1030/format:webp/1*OCzHmgZYjeUElrb3s7vTeg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(作者创作)</p></figure><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="b29c" class="mx lw it mt b gy my mz l na nb">data= {'Salary': [30000, 40000, 50000, 85000, '75,000'],            <br/>        'Exp': [1, 3, 5, 10, 25],          <br/>        'Gender': ['M','F', 'M', 'F', 'M']} <br/>df_salary = pd.DataFrame(data)<br/><strong class="mt iu">df_salary.info()</strong></span><span id="a27b" class="mx lw it mt b gy nc mz l na nb">Out[74]:<br/>Data columns (total 3 columns):<br/> #   Column  Non-Null Count  Dtype <br/>---  ------  --------------  ----- <br/> 0   Salary  5 non-null      object<br/> 1   Exp     5 non-null      int64 <br/> 2   Gender  5 non-null      object</span><span id="b1f8" class="mx lw it mt b gy nc mz l na nb"><strong class="mt iu">df_salary.apply(lambda x: type(x['Salary']), axis = 1).value_counts()</strong></span><span id="bac0" class="mx lw it mt b gy nc mz l na nb">Out[75]:<br/>&lt;class 'int'&gt;    4<br/>&lt;class 'str'&gt;    1<br/>dtype: int64</span><span id="8cd5" class="mx lw it mt b gy nc mz l na nb"><strong class="mt iu">df_salary[df_salary.apply(lambda x: type(x['Salary']), axis = 1)== str]</strong></span><span id="5f55" class="mx lw it mt b gy nc mz l na nb">Out[80]: <br/>   Salary  Exp Gender<br/>4  75,000   25      M</span></pre><p id="827e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">招数3: </strong>我上面提到过<strong class="lb iu"> value_counts </strong>。它输出给定列的唯一值的计数。有时，我们需要制作两列的交叉表格。交叉表是一个方便的函数。默认情况下，它通过数据帧中的任意两列生成一个<strong class="lb iu">频率表</strong>。也可以传递一个聚合函数，比如<code class="fe nd ne nf mt b">sum</code>。在下面的代码中，我们可以通过“产品线”和“城市”来计算总“数量”。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="89fa" class="mx lw it mt b gy my mz l na nb"><strong class="mt iu">df['City'].value_counts()</strong><br/>Out[19]: <br/>Yangon       340<br/>Mandalay     332<br/>Naypyitaw    328<br/>Name: City, dtype: int64</span><span id="ad21" class="mx lw it mt b gy nc mz l na nb"><strong class="mt iu">pd.crosstab(df['Product line'], df['City'])</strong><br/>Out[22]: <br/>City                    Mandalay  Naypyitaw  Yangon<br/>Product line                                       <br/>Electronic accessories        55         55      60<br/>Fashion accessories           62         65      51<br/>Food and beverages            50         66      58<br/>Health and beauty             53         52      47<br/>Home and lifestyle            50         45      65<br/>Sports and travel             62         45      59</span><span id="e001" class="mx lw it mt b gy nc mz l na nb"><strong class="mt iu">pd.crosstab(df['Product line'], df['City'], values = df['Quantity'], aggfunc= 'sum')<br/></strong>Out[98]: <br/>City                    Mandalay  Naypyitaw  Yangon<br/>Product line                                       <br/>Electronic accessories       316        333     322<br/>Fashion accessories          297        342     263<br/>Food and beverages           270        369     313<br/>Health and beauty            320        277     257<br/>Home and lifestyle           295        245     371<br/>Sports and travel            322        265     333</span></pre><p id="1a99" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">描述:</strong>该函数输出一个描述性的统计摘要，包括观察值、平均值、标准偏差、最小值、最大值和百分位数。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="27e9" class="mx lw it mt b gy my mz l na nb"><strong class="mt iu">df.describe()</strong><br/>Out[18]: <br/>        Unit price     Quantity  ...  gross income      Rating<br/>count  1000.000000  1000.000000  ...   1000.000000  1000.00000<br/>mean     55.672130     5.510000  ...     15.379369     6.97270<br/>std      26.494628     2.923431  ...     11.708825     1.71858<br/>min      10.080000     1.000000  ...      0.508500     4.00000<br/>25%      32.875000     3.000000  ...      5.924875     5.50000<br/>50%      55.230000     5.000000  ...     12.088000     7.00000<br/>75%      77.935000     8.000000  ...     22.445250     8.50000<br/>max      99.960000    10.000000  ...     49.650000    10.00000</span><span id="f65c" class="mx lw it mt b gy nc mz l na nb">[8 rows x 8 columns]</span></pre><p id="f5da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">招数四:描述</strong>有帮助，但是<strong class="lb iu">熊猫_侧写。ProfileReport </strong>更好。Python库，熊猫_剖析。ProfileReport <strong class="lb iu"> </strong>允许我们生成全面的数据探索报告。类似于describe，pandas_profiling。ProfileReport <strong class="lb iu"> </strong>将产生每一列的基本信息和描述性统计摘要。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="fc7b" class="mx lw it mt b gy my mz l na nb"><strong class="mt iu"># Install the library</strong><br/>!pip install pandas-profiling</span><span id="fa28" class="mx lw it mt b gy nc mz l na nb"><strong class="mt iu"># Import the library</strong><br/>import pandas_profiling</span><span id="66e0" class="mx lw it mt b gy nc mz l na nb">profile = pandas_profiling.ProfileReport(df, title = "Data Exploration")<br/>profile.to_file(output_file='Data Profile Output.html')</span></pre><p id="4ec9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它还可以生成每一列的快速直方图，并允许我们创建任意两个数字列的散点图。此外，它还包括不同类型的列相关性和缺失值的计数。所有这些有用的信息都可以用几行代码生成。</p><p id="fb5d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用此功能的另一个好处是，我们可以将报告保存为web格式，然后发送给其他人查看。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nh"><img src="../Images/139a6d73a48890b382b4fadbbb09cb1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9HRe9W90iEkea5oKPL7Mbw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(作者创作)</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ni"><img src="../Images/f0b9f28a7d29dbf0228537856898dfac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FmB_cAKuHAtC2nE3hi0Tkw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(作者创作)</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nj"><img src="../Images/cb4c028e780dac0bb385497c0324ae68.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Rnubt9q3SE_TGfD-L6-JLg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(作者创作)</p></figure><h1 id="cb5f" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">子集数据框架</h1><p id="7694" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">对于本节，让我们创建另一个示例数据帧。在该数据帧中，它包含['r1 '，' r2 '，' r3']的索引和['A '，' B '，' C']的列。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="658a" class="mx lw it mt b gy my mz l na nb"># Create a dataframe<br/>df2 = pd.DataFrame([[0, 2, 3], [0, 4, 1], [10, 20, 30]],                 index=['r1', 'r2', 'r3'], columns=['A', 'B', 'C'])</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/d7ce0e9b27b7730fa0958c6e92c0150d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1008/format:webp/1*jE0CZJv2XrTbUBCDIXYaKQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(作者创作)</p></figure><h2 id="e507" class="mx lw it bd lx nl nm dn mb nn no dp mf li np nq mh lm nr ns mj lq nt nu ml nv bi translated">使用括号进行行选择</h2><p id="0a4a" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated"><strong class="lb iu">df[开始行:结束行]: </strong>这将给<strong class="lb iu">连续数据行的子集</strong>。例如，df2[0:3]产生数据帧中的第一行到第三行。</p><p id="3fb2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">招数五:</strong> df2[0]不提取第一行。相反，这会给我们一个名为“0”的列，这在我们的数据列['A '，' B '，' C']中是不可用的。相反，我们应该使用df[0:1]来获取第一行。</p><p id="e88e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">df[condition(boolean)]:</strong>这将基于指定的条件创建数据帧的子集。例如，df2[df2[' C ']&gt;10]生成列“C”大于10的行。df2[df2[' C ']≥3&amp;df2[' A ']&gt;3]生成列“C”大于或等于3且列“A”大于3的行。</p><p id="adbb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">招数六:</strong>在指定多个条件时，我们也可以在布尔条件内部使用<code class="fe nd ne nf mt b">apply</code>，更加灵活。例如，<code class="fe nd ne nf mt b">axis = 1</code>允许我们以行的方式实现分析。我们可以通过<code class="fe nd ne nf mt b">bool</code>和<code class="fe nd ne nf mt b">regular expression </code>来输出真/假。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="fdf0" class="mx lw it mt b gy my mz l na nb">df2[df2.apply(lambda x: x['C']&gt;=3 &amp; x['A'] &gt; 3, axis = 1)]<br/>df[df.apply(lambda x: bool(re.findall('beauty', x['Product line'])) &amp; (x['Gender'] == 'Female'), axis = 1)]</span></pre><p id="91de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">招数7: </strong>我们可以用<code class="fe nd ne nf mt b">query</code>来指定一个布尔表达式。一个优点是我们不需要多次显式地写数据帧名称。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="267c" class="mx lw it mt b gy my mz l na nb"># df[df['Gender']=='Female']<br/>df.query('Gender == "Female"') </span><span id="286c" class="mx lw it mt b gy nc mz l na nb"># df[df['Quantity']&gt; 7]<br/>df.query('Quantity &gt; 7')</span></pre><h2 id="331e" class="mx lw it bd lx nl nm dn mb nn no dp mf li np nq mh lm nr ns mj lq nt nu ml nv bi translated">使用iloc选择行</h2><p id="4d6b" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated"><strong class="lb iu">df . iloc[所选行]:]:</strong><code class="fe nd ne nf mt b">iloc</code>允许我们根据<strong class="lb iu">行号</strong>提取一个子集。例如:df2.iloc[0:10，:]将生成前10行，而df2.iloc[[0，2，5]，:]将生成包含第一、第三和第六行的子集。方括号内的<code class="fe nd ne nf mt b">:</code>意味着我们将保留所有的列。</p><h2 id="050b" class="mx lw it bd lx nl nm dn mb nn no dp mf li np nq mh lm nr ns mj lq nt nu ml nv bi translated">使用loc进行行选择</h2><p id="bfd9" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated"><strong class="lb iu"> df.loc[Selected Index，:】</strong> : <code class="fe nd ne nf mt b">loc</code>允许根据<strong class="lb iu">索引</strong>提取子集。例如，df2.loc['r1 '，:]将生成一个带有“index = 'r1 '”的子集。df2.loc[['r1 '，' r2']，:]将生成一个带有“index = 'r1 '和' r2 '”的子集。</p><h2 id="5450" class="mx lw it bd lx nl nm dn mb nn no dp mf li np nq mh lm nr ns mj lq nt nu ml nv bi translated">使用双括号选择列</h2><p id="4614" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated"><strong class="lb iu">df[[选择的列]]: </strong>使用一个双括号，我们可以在一个数据帧中选择单个或多个列。例如，df[['单价'，'数量']]将提取数据帧中的'单价'和'数量'列。</p><p id="3816" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">招数八:单支架vs双支架。</strong>我们可以使用单个括号来提取单个列。但是输出将被存储为一个<strong class="lb iu">系列</strong>，而一个双括号将给我们一个<strong class="lb iu">数据帧</strong>。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="7965" class="mx lw it mt b gy my mz l na nb">test1 = df[['Quantity']]</span><span id="3d3b" class="mx lw it mt b gy nc mz l na nb">type(test1)<br/>Out[176]: pandas.core.frame.DataFrame</span><span id="9a5f" class="mx lw it mt b gy nc mz l na nb">test2 = df['Quantity']</span><span id="72c3" class="mx lw it mt b gy nc mz l na nb">type(test2)<br/>Out[178]: pandas.core.series.Series</span></pre><p id="6d19" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> df.iloc[:，Selected Columns]vs df . loc[:，Selected Columns]:</strong><code class="fe nd ne nf mt b">iloc</code>和<code class="fe nd ne nf mt b">loc</code>都可以从数据帧中提取列的子集。区别在于<code class="fe nd ne nf mt b">iloc</code>基于列号，而<code class="fe nd ne nf mt b">loc</code>使用实际的列名。例如，df2.iloc[:，0]将提取第一列而不提及列名，而df2.loc[:，' A']将从数据帧中提取列“A”。</p><h1 id="1d8a" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">感谢您的阅读！！！</h1><p id="af7a" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">如果你喜欢这篇文章，并且想<strong class="lb iu">请我喝杯咖啡，</strong>请<a class="ae ky" href="https://ko-fi.com/aaronzhu" rel="noopener ugc nofollow" target="_blank">点击这里</a>。</p><p id="3b5e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以注册一个<a class="ae ky" href="https://aaron-zhu.medium.com/membership" rel="noopener"> <strong class="lb iu">会员</strong> </a>来解锁我的文章的全部访问权限，并且可以无限制地访问介质上的所有内容。如果你想在我发表新文章时收到电子邮件通知，请订阅。</p></div></div>    
</body>
</html>