<html>
<head>
<title>Extracting Metadata from Medium Daily Digest Newsletters via Gmail API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过Gmail API从媒体每日文摘时事通讯中提取元数据</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/extracting-metadata-from-medium-daily-digest-newsletters-via-gmail-api-97eee890a439?source=collection_archive---------11-----------------------#2021-08-19">https://towardsdatascience.com/extracting-metadata-from-medium-daily-digest-newsletters-via-gmail-api-97eee890a439?source=collection_archive---------11-----------------------#2021-08-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="77a5" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">消化摘要:用主题建模对我的兴趣进行逆向工程(第1部分)</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/2f91fb145eddb1c760033ee638cffc52.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F_HFyHOm4jwFRxg_w48NSQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="be9f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我实话实说。我着迷于媒体的推荐系统经常比我自己更了解我。他们推荐的阅读材料是如此的诱人，以至于我希望每天早上醒来都能狼吞虎咽地阅读10-11篇完全符合我兴趣的文章。也就是说，生活会碍事。虽然承认这一点很尴尬，但在上班(从家里)之前，我几乎没有时间刷牙和穿上工作服。通常情况下，我会将这些摘要邮件标记为未读，直到清理收件箱的时候，这时我会将一些听起来最有趣的邮件添加到我的中等阅读列表中。</p><p id="e928" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我突然意识到，因为Medium非常了解我的兴趣，如果我着手一个项目，利用这些时事通讯作为数据来了解更多关于我的兴趣以及它们是如何随着时间的推移而演变的呢？</p><p id="31db" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个项目和我的大多数数据科学项目一样，将包括数据挖掘、数据清理、探索性数据分析和可视化的元素。然而，在我的下一篇文章中，我将通过与LDA和BERTopic讨论主题建模，将事情推向一个新的高度，敬请关注！在本文中，我们将重点讨论如何利用Gmail API来解析Medium Daily Digest时事通讯或任何其他格式一致的时事通讯。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mb"><img src="../Images/bba0b120346ce38d69d78079994e320b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oSlZ3WLbSQ9R6I2grolKbw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">斯蒂芬·菲利普斯-Hostreviews.co.uk在<a class="ae mc" href="https://unsplash.com/s/photos/gmail?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><h1 id="f397" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">工作区开发人员入门和启用Gmail API</h1><p id="10b1" class="pw-post-body-paragraph ky kz it la b lb mv ju ld le mw jx lg lh mx lj lk ll my ln lo lp mz lr ls lt im bi translated">Gmail API是一个RESTful API，可用于访问Gmail邮箱，甚至发送邮件。它适用于只读邮件提取(即我们将要做的事情)、自动化或程序化的邮件发送、电子邮件帐户迁移以及邮件的组织过滤和排序。为了使用此API对您的Gmail数据进行授权访问，我们必须获得对API的访问权限，并设置适当的凭据和范围。</p><h2 id="9741" class="na me it bd mf nb nc dn mj nd ne dp mn lh nf ng mp ll nh ni mr lp nj nk mt nl bi translated">第一步:在<a class="ae mc" href="https://console.cloud.google.com" rel="noopener ugc nofollow" target="_blank">谷歌云控制台</a>中创建一个新项目</h2><ol class=""><li id="afbc" class="nm nn it la b lb mv le mw lh no ll np lp nq lt nr ns nt nu bi translated">选择一个描述性的项目名称</li><li id="0641" class="nm nn it la b lb nv le nw lh nx ll ny lp nz lt nr ns nt nu bi translated">不需要组织</li></ol><h2 id="9643" class="na me it bd mf nb nc dn mj nd ne dp mn lh nf ng mp ll nh ni mr lp nj nk mt nl bi translated">第二步:启用<a class="ae mc" href="https://console.cloud.google.com/apis/library/gmail.googleapis.com?q=gmail&amp;id=869e4b9c-0da4-4cbe-8b8d-c77f7ae060cc&amp;project=medium-digest" rel="noopener ugc nofollow" target="_blank"> Gmail API </a></h2><ol class=""><li id="12f7" class="nm nn it la b lb mv le mw lh no ll np lp nq lt nr ns nt nu bi translated">在谷歌云平台仪表板的左上角，点击菜单☰按钮</li><li id="c32d" class="nm nn it la b lb nv le nw lh nx ll ny lp nz lt nr ns nt nu bi translated">单击API和服务</li><li id="aa9e" class="nm nn it la b lb nv le nw lh nx ll ny lp nz lt nr ns nt nu bi translated">单击启用API和服务</li><li id="0aee" class="nm nn it la b lb nv le nw lh nx ll ny lp nz lt nr ns nt nu bi translated">通过搜索或浏览找到Gmail API</li><li id="570a" class="nm nn it la b lb nv le nw lh nx ll ny lp nz lt nr ns nt nu bi translated">单击启用</li></ol><h2 id="2ced" class="na me it bd mf nb nc dn mj nd ne dp mn lh nf ng mp ll nh ni mr lp nj nk mt nl bi translated">步骤3:创建凭据</h2><ol class=""><li id="9b4a" class="nm nn it la b lb mv le mw lh no ll np lp nq lt nr ns nt nu bi translated">单击左侧菜单中的凭据</li><li id="4546" class="nm nn it la b lb nv le nw lh nx ll ny lp nz lt nr ns nt nu bi translated">单击顶部的创建凭据</li><li id="8adc" class="nm nn it la b lb nv le nw lh nx ll ny lp nz lt nr ns nt nu bi translated">单击OAuth客户端ID</li><li id="d06d" class="nm nn it la b lb nv le nw lh nx ll ny lp nz lt nr ns nt nu bi translated">选择桌面应用程序并选择一个客户端名称(没有太大关系)</li><li id="80a2" class="nm nn it la b lb nv le nw lh nx ll ny lp nz lt nr ns nt nu bi translated">单击Create，现在不用担心保存客户端ID和客户端密码</li></ol><h2 id="79e0" class="na me it bd mf nb nc dn mj nd ne dp mn lh nf ng mp ll nh ni mr lp nj nk mt nl bi translated">步骤4: OAuth同意屏幕</h2><ol class=""><li id="3fdc" class="nm nn it la b lb mv le mw lh no ll np lp nq lt nr ns nt nu bi translated">输入您的应用名称和用户支持电子邮件</li><li id="77fb" class="nm nn it la b lb nv le nw lh nx ll ny lp nz lt nr ns nt nu bi translated">忽略应用程序域部分，因为我们暂时不会通过任何托管网站访问数据</li><li id="8b3b" class="nm nn it la b lb nv le nw lh nx ll ny lp nz lt nr ns nt nu bi translated">输入开发者联系信息</li><li id="2460" class="nm nn it la b lb nv le nw lh nx ll ny lp nz lt nr ns nt nu bi translated">单击保存并继续</li></ol><h2 id="b38e" class="na me it bd mf nb nc dn mj nd ne dp mn lh nf ng mp ll nh ni mr lp nj nk mt nl bi translated">第五步:范围</h2><ol class=""><li id="d42d" class="nm nn it la b lb mv le mw lh no ll np lp nq lt nr ns nt nu bi translated">单击添加或删除范围</li><li id="3c19" class="nm nn it la b lb nv le nw lh nx ll ny lp nz lt nr ns nt nu bi translated">搜索“gmail.readonly”，点击弹出的范围</li><li id="2ded" class="nm nn it la b lb nv le nw lh nx ll ny lp nz lt nr ns nt nu bi translated">单击更新</li></ol><h2 id="6f4b" class="na me it bd mf nb nc dn mj nd ne dp mn lh nf ng mp ll nh ni mr lp nj nk mt nl bi translated">步骤6:测试用户</h2><p id="e6dc" class="pw-post-body-paragraph ky kz it la b lb mv ju ld le mw jx lg lh mx lj lk ll my ln lo lp mz lr ls lt im bi translated"><em class="oa">注意:有必要添加一个测试用户，因为如果您没有自己的组织，阅读和访问电子邮件是一个受限制的范围</em></p><ol class=""><li id="8aae" class="nm nn it la b lb lc le lf lh ob ll oc lp od lt nr ns nt nu bi translated">在测试用户下，单击添加用户</li><li id="f5c0" class="nm nn it la b lb nv le nw lh nx ll ny lp nz lt nr ns nt nu bi translated">输入您的电子邮件，然后点按“存储”</li></ol><h2 id="2cf6" class="na me it bd mf nb nc dn mj nd ne dp mn lh nf ng mp ll nh ni mr lp nj nk mt nl bi translated">步骤7:下载凭据</h2><ol class=""><li id="b133" class="nm nn it la b lb mv le mw lh no ll np lp nq lt nr ns nt nu bi translated">单击左侧菜单中的凭据</li><li id="46c2" class="nm nn it la b lb nv le nw lh nx ll ny lp nz lt nr ns nt nu bi translated">在OAuth 2.0客户端id下，单击下载图标</li><li id="82e1" class="nm nn it la b lb nv le nw lh nx ll ny lp nz lt nr ns nt nu bi translated">将凭证JSON文件移动到您的工作项目目录中</li><li id="ce3c" class="nm nn it la b lb nv le nw lh nx ll ny lp nz lt nr ns nt nu bi translated">为了便于使用，将其命名为<code class="fe oe of og oh b">credentials.json</code></li></ol><h1 id="116d" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">Python快速入门</h1><p id="d20f" class="pw-post-body-paragraph ky kz it la b lb mv ju ld le mw jx lg lh mx lj lk ll my ln lo lp mz lr ls lt im bi translated">下面的起始代码很大程度上是仿照<a class="ae mc" href="https://developers.google.com/gmail/api/quickstart/python" rel="noopener ugc nofollow" target="_blank">Gmail for Developers&gt;Gmail API&gt;Python quick start</a>页面编写的，但是让我们一起浏览一下，设置好我们的服务实例，并开始阅读电子邮件！</p><p id="60af" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">首先，我们必须注意导入和范围。如果您正在跟进，您将需要初始化一个名为<code class="fe oe of og oh b">quickstart.py</code>的新文件，并粘贴以下代码行。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="0212" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">接下来，我们必须完成授权流程并存储我们的访问/刷新令牌！注意，这一步需要我们之前下载的<code class="fe oe of og oh b">credentials.json</code>文件。下面的函数返回一个服务实例，我们将使用它来访问Gmail API中的方法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ok"><img src="../Images/bbcb3a4d09fb544b84eefcbee31303c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kMvTUCGDC8hXiTJm94VzRQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">展示Gmail标签|作者图片</p></figure><p id="edc7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在验证我们可以访问经过身份验证的用户数据之前，让我们先讨论一下标签。鉴于每日摘要电子邮件倾向于模板化并通过自动邮件服务发送，我们可以通过将感兴趣的电子邮件组织到单个标签分组中来使我们的生活变得更容易。为此，请在Gmail搜索栏中输入搜索词，选择全部，然后单击标签(🏷)图标将现有标签或新标签分配给所有选定的邮件。对于所有符合搜索标准的未来简讯，您可以设置一个高级Gmail过滤器，自动将它们分配到同一个标签。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="6bec" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当调用上述方法时，它将打印用户Gmail帐户中所有标签的列表。这个列表可能看起来类似于、<code class="fe oe of og oh b">INBOX</code>、<code class="fe oe of og oh b">SENT</code>、<code class="fe oe of og oh b">IMPORTANT</code>、<code class="fe oe of og oh b">TRASH</code>、<code class="fe oe of og oh b">DRAFT</code>、<code class="fe oe of og oh b">SPAM</code>、<code class="fe oe of og oh b">STARRED</code>等。值得注意的是，标签id并不总是与标签名称一致。例如，我新创建的<code class="fe oe of og oh b">MEDIUM</code>标签的id是<code class="fe oe of og oh b">Label_793897032304597046</code>。我们希望保留这个id，因为我们需要它来获取我们感兴趣的电子邮件。</p><pre class="kj kk kl km gt ol oh om on aw oo bi"><span id="02fe" class="na me it oh b gy op oq l or os">if __name__ == '__main__':<br/>    service = get_service()<br/>    get_all_email_labels(service)</span></pre><p id="e8ac" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">要执行这段代码，我们必须在快速入门中运行上述两个函数。为此，您只需打开一个终端窗口，并通过键入以下命令来执行包含所有代码片段的完整脚本:</p><p id="bfb3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe oe of og oh b">python quickstart.py</code></p><p id="717f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果是第一次执行quickstart，您可能会看到弹出如下提示。它们是为了让你确认，虽然你不是谷歌认证的开发人员，但你希望继续并允许应用程序/项目查看你的电子邮件。</p><div class="kj kk kl km gt ab cb"><figure class="ot kn ou ov ow ox oy paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/b2af54663cfd45b106216acce718ab22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1364/format:webp/1*aq0Q5U7GrpsDKmOOYAIsBQ.png"/></div></figure><figure class="ot kn oz ov ow ox oy paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/16177c0374aa9d854077c992531c229d.png" data-original-src="https://miro.medium.com/v2/resize:fit:638/format:webp/1*8i-t5KGHiD4U1d4We2uuzQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk pa di pb pc translated">作者提供的图片</p></figure></div><pre class="kj kk kl km gt ol oh om on aw oo bi"><span id="92b8" class="na me it oh b gy op oq l or os">The authentication flow has completed. You may close this window.</span></pre><p id="4937" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果一切顺利，您应该会看到包含上述消息的页面。这意味着我们可以走了！</p><h1 id="58cb" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">数据采集和清理</h1><p id="e789" class="pw-post-body-paragraph ky kz it la b lb mv ju ld le mw jx lg lh mx lj lk ll my ln lo lp mz lr ls lt im bi translated">为了获取数据，我们可以编写一个简单的函数<code class="fe oe of og oh b">get_data()</code>来获取带有指定标签id的所有用户消息。</p><h2 id="b7d4" class="na me it bd mf nb nc dn mj nd ne dp mn lh nf ng mp ll nh ni mr lp nj nk mt nl bi translated">执行API调用</h2><p id="6cd2" class="pw-post-body-paragraph ky kz it la b lb mv ju ld le mw jx lg lh mx lj lk ll my ln lo lp mz lr ls lt im bi translated">获取电子邮件元数据的代码大致如下:</p><pre class="kj kk kl km gt ol oh om on aw oo bi"><span id="11e2" class="na me it oh b gy op oq l or os">results = services.users().messages().list(userId='me', labelIds = ['XXXXXXXX'], maxResults=500).execute()</span></pre><p id="f4b0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">以下代码行为所有提取的消息编译一个元数据列表:</p><pre class="kj kk kl km gt ol oh om on aw oo bi"><span id="fcb7" class="na me it oh b gy op oq l or os">messages = results.get('messages', [])</span></pre><p id="4ef7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因为这种类型的API调用返回的最大结果数永远不会超过500，所以我们将从API调用中收集下一个页面标记，并实现一个简单的while条件。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="cd2e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">要调用这个方法，我们可以从<code class="fe oe of og oh b">quickstart</code>模块导入它，并指定我们想要获取中等的每日摘要电子邮件。在引擎盖下，这将找到正确的标签id。</p><pre class="kj kk kl km gt ol oh om on aw oo bi"><span id="7fd4" class="na me it oh b gy op oq l or os">from quickstart import get_service, get_data<br/>service = get_service()<br/>messages = get_data(service, 'Medium Daily Digest')<br/>print(len(messages))</span></pre><p id="27f4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">就这样，596条信息被获取了！我们能打印一份出来吗？嗯……不完全是。打印第一条消息实际上会返回以下元数据:</p><pre class="kj kk kl km gt ol oh om on aw oo bi"><span id="1c00" class="na me it oh b gy op oq l or os">{'id': '17b590fa1e590dfa', 'threadId': '17b590fa1e590dfa'}</span></pre><p id="7c56" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这意味着需要进行更多的API调用来检索电子邮件内容本身。要获得实际的消息，我们必须进行以下API调用:</p><pre class="kj kk kl km gt ol oh om on aw oo bi"><span id="e7dc" class="na me it oh b gy op oq l or os">msg = service.users().message().get(userId='me', id=message['id'], format='full').execute()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pd"><img src="../Images/f0c2c2db75bf24fabbe9922db8fa7086.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_mq7WSBL1WLh_AFu5-NRiA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="99ca" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">啊…混乱！这不完全是我们希望的精确提取的内容，但它是一个起点。原来我们的msg对象实际上是一个字典，它有以下键:<code class="fe oe of og oh b">dict_keys([‘id’, ‘threadId’, ‘labelIds’, ‘snippet’, ‘payload’, ‘sizeEstimate’, ‘historyId’, ‘internalDate’])</code>。</p><p id="8c70" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">打印出来的<code class="fe oe of og oh b">msg['snippet']</code>实际上很整洁，但是限制在200个字符左右。因此，必须使用<code class="fe oe of og oh b">'payload'</code>键提取所有有价值的信息。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pe"><img src="../Images/72abd4e30ac865eb1a8bf12390782d0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QziyeiM42I8gS3HwWlZCgg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="9185" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">有趣的是，电子邮件正文数据是MIME消息部分，这实质上意味着数据存储为base64url编码的字符串。要解码它，我们可以使用<code class="fe oe of og oh b">base64</code> Python库。完整的数据采集代码流程如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div></figure><h2 id="4b4c" class="na me it bd mf nb nc dn mj nd ne dp mn lh nf ng mp ll nh ni mr lp nj nk mt nl bi translated">使用正则表达式解析电子邮件正文</h2><p id="6bf4" class="pw-post-body-paragraph ky kz it la b lb mv ju ld le mw jx lg lh mx lj lk ll my ln lo lp mz lr ls lt im bi translated">专注于我们上面实验的示例电子邮件消息，让我们解码正文数据，并获得一些关于文章元数据在每日摘要中如何格式化的直觉。下面是与本文开头所包含的我的每日文摘截图相对应的邮件正文的转储:</p><pre class="kj kk kl km gt ol oh om on aw oo bi"><span id="2bc4" class="na me it oh b gy op oq l or os">Today's highlights<br/><br/>NLP Profiler: Profiling datasets with one or more text columns<br/><br/>Creating high-level insights from text dataset using NLP Profiler<br/><br/>Himanshu Sharma (https://medium.com/@hmix13?source=email-e353ddb0c125-1629269257172-digest.reader-7f60cf5620c9-9b791193db89----0-59------------------e4b04afc_f3d7_492e_98c5_a3c1bbb1304a-1-dbdc0eb5_2de9_432f_a90c_bcf2300858ca)<br/> in Towards Data Science (https://medium.com/towards-data-science?source=email-e353ddb0c125-1629269257172-digest.reader-7f60cf5620c9-9b791193db89----0-59------------------e4b04afc_f3d7_492e_98c5_a3c1bbb1304a-1-dbdc0eb5_2de9_432f_a90c_bcf2300858ca)<br/>·5 min read<br/><br/>Data Cleaning in Python with NumPy and Pandas<br/><br/>The first utilities that an aspiring, python-wielding data scientist must learn include numpy and pandas. All…<br/><br/>Mike Flanagan (https://medium.com/@mike-flanagan?source=email-e353ddb0c125-1629269257172-digest.reader-29038077e4c6-3776f9a6e77f----1-98------------------e4b04afc_f3d7_492e_98c5_a3c1bbb1304a-1-dbdc0eb5_2de9_432f_a90c_bcf2300858ca)<br/> in CodeX (https://medium.com/codex?source=email-e353ddb0c125-1629269257172-digest.reader-29038077e4c6-3776f9a6e77f----1-98------------------e4b04afc_f3d7_492e_98c5_a3c1bbb1304a-1-dbdc0eb5_2de9_432f_a90c_bcf2300858ca)<br/>·5 min read<br/><br/>A data scientist has a look at Japan's Coronavirus analytics<br/><br/>After having been post-posted until 2021, the summer olympics are being sponsored by Tokyo, Japan from 23…<br/><br/>Tracyrenee (https://medium.com/@tracyrenee61?source=email-e353ddb0c125-1629269257172-digest.reader-f19413a43ae4-4f3a1dbfd5e8----2-98------------------e4b04afc_f3d7_492e_98c5_a3c1bbb1304a-1-dbdc0eb5_2de9_432f_a90c_bcf2300858ca)<br/> in MLearning.ai (https://medium.com/mlearning-ai?source=email-e353ddb0c125-1629269257172-digest.reader-f19413a43ae4-4f3a1dbfd5e8----2-98------------------e4b04afc_f3d7_492e_98c5_a3c1bbb1304a-1-dbdc0eb5_2de9_432f_a90c_bcf2300858ca)<br/>·7 min read</span></pre><p id="533c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们希望从这种非结构化但格式松散的数据中提取的字段是<strong class="la iu">标题</strong>、<strong class="la iu">副标题</strong>、<strong class="la iu">作者</strong>、<strong class="la iu">出版物</strong>和<strong class="la iu">会议记录</strong>(例如，“X分钟阅读”)。我们想忽略所有链接，因为抓取文章内容是不道德的，如果我有时间自己阅读所有这些文章，我早就这样做了。</p><p id="662a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了提取想要的信息，我们将使用我们邪恶的敌人，他有时也是我们充满爱心和支持的朋友:<code class="fe oe of og oh b">regex</code>。regex是正则表达式的缩写，是指定搜索模式的字符序列。当我们可能不知道我们希望提取的具体文本，但我们知道它将呈现给我们的一般模式时，它可能是强大的。将这一概念应用到我们当前的任务中，每篇文章的信息都遵循以下一般结构:</p><pre class="kj kk kl km gt ol oh om on aw oo bi"><span id="a6ad" class="na me it oh b gy op oq l or os">[TITLE]</span><span id="7302" class="na me it oh b gy pf oq l or os">[SUBTITLE]</span><span id="c9e4" class="na me it oh b gy pf oq l or os">[AUTHOR] (link to profile) in [PUBLICATION] (link to article within publication)<br/>·[MINUTES] min read</span></pre><p id="c4e7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在正则表达式的世界中，我们可以通过两个强大的步骤提取这些信息:</p><p id="f2de" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">第一步:通过替换删除所有链接(</strong> <code class="fe oe of og oh b"><strong class="la iu">sub</strong></code> <strong class="la iu">方法)</strong></p><pre class="kj kk kl km gt ol oh om on aw oo bi"><span id="8204" class="na me it oh b gy op oq l or os">text = re.sub(r'\(https?:\S+.*\)', '', msg_body, flags=re.MULTILINE)</span></pre><p id="c033" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">第二步:通过</strong> <code class="fe oe of og oh b"><strong class="la iu">findall</strong></code> <strong class="la iu">方法</strong>进行模式匹配</p><pre class="kj kk kl km gt ol oh om on aw oo bi"><span id="fd93" class="na me it oh b gy op oq l or os"># \r\n means we expect a line break<br/># (.*) is a capture group, meaning we want to store the filler text</span><span id="9dca" class="na me it oh b gy pf oq l or os">re.findall('(.*)\r\n\r\n(.*)\r\n\r\n(.*) \r\n in (.*)\r\n*·(.*) min read', text, re.MULTILINE)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pg"><img src="../Images/07d70526444cbbcdd7ee42bdd2d6279e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pS5j6zIgCCyRN5GjPrQICg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者截图</p></figure><p id="28e3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在用regex快速地打了两下之后，我们已经获得了我们想要获得的所有5个字段的数据！又快又无痛，对吧？老实说，派生正则表达式模式来完成这个任务实际上是相当痛苦的。谢天谢地，regex101 帮我解决了问题，并帮助我对问题进行了分类。我强烈推荐在那里制定正则表达式，并准备了一个方便的测试用例来使用。</p><h2 id="d1b7" class="na me it bd mf nb nc dn mj nd ne dp mn lh nf ng mp ll nh ni mr lp nj nk mt nl bi translated">组装的数据帧</h2><p id="4e03" class="pw-post-body-paragraph ky kz it la b lb mv ju ld le mw jx lg lh mx lj lk ll my ln lo lp mz lr ls lt im bi translated">包含从API获取的文章中经过正则表达式解析的信息的数据如下所示:</p><pre class="kj kk kl km gt ol oh om on aw oo bi"><span id="6725" class="na me it oh b gy op oq l or os">[Timestamp('2021-08-18 11:40:00+0000', tz='UTC'), 'NLP Profiler: Profiling datasets with one or more text columns', 'Creating high-level insights from text dataset using NLP Profiler', 'Himanshu Sharma', 'Towards Data Science ', '5']<br/>[Timestamp('2021-08-18 11:40:00+0000', tz='UTC'), 'Data Cleaning in Python with NumPy and Pandas', 'The first utilities that an aspiring, python-wielding data scientist must learn include numpy and pandas. All…', 'Mike Flanagan', 'CodeX ', '5']<br/>[Timestamp('2021-08-18 11:40:00+0000', tz='UTC'), "A data scientist has a look at Japan's Coronavirus analytics", 'After having been post-posted until 2021, the summer olympics are being sponsored by Tokyo, Japan from 23…', 'Tracyrenee', 'MLearning.ai ', '7']</span></pre><p id="c15b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">只需一行代码，我们就可以组装一个由这些文章元数据组成的<code class="fe oe of og oh b">pandas</code>数据框架。</p><pre class="kj kk kl km gt ol oh om on aw oo bi"><span id="c654" class="na me it oh b gy op oq l or os">df = pd.DataFrame(data, columns = ['Date', 'Title', 'Subtitle', 'Author', 'Publication', 'Minutes'])</span></pre><p id="ef71" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">接下来是一个艺术作品，包含来自每封电子邮件的正则表达式匹配的解包元组值。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ph"><img src="../Images/02124a1362b352a6870d108c02ec0c88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Nc5fDla48pLKhhx2jWDTlA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><h1 id="75a0" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">一览式可视化</h1><div class="kj kk kl km gt ab cb"><figure class="ot kn pi ov ow ox oy paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/7677961b6ba7629035a853fdd62ad812.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*mjjP3bTEGIHIbVMW2hvMeQ.png"/></div></figure><figure class="ot kn pi ov ow ox oy paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/6d2bd28245b2d5d7c67b836ac6245b9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*4DXxgf3nW9cFIZG73QKqcQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk pj di pk pc translated">媒体每日文摘中出现的前10位出版物和作者|由</p></figure></div><p id="9e89" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以从上面简单的<code class="fe oe of og oh b">matplotlib</code>条形图中看到，阅读推荐文章的前3位出版物是关于数据科学、更好的编程和创业。这是有意义的，因为我对媒体的兴趣和互动倾向于数据科学相关的应用程序和软件开发技巧和工具。在我的推荐阅读清单中，前三名最多产的作者是里士满·阿拉克、马卡姆·海德和戴夫·格什格恩。我记得Parul Pandey是第一个让我迷上Medium的作者，所以很高兴看到她出现在这个前10名的名单中，还有TDS团队经常发布的综述和亮点！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pl"><img src="../Images/5d9b069503fd05613b27d57fc480a26a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sZAJkLurdYNsdVqvHefOog.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者创建的可视化</p></figure><p id="b1ac" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">制作“分钟”列的直方图，我们可以发现中等文章的长度/阅读时间分布遵循一个非常标准的钟形曲线，稍微向左倾斜。中篇文章最常见的长度是4分钟左右。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pl"><img src="../Images/c3259221576b2a002ef11b9f1c046627.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Xn0WK3RacPZqTRW8aPYjCA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者创建的可视化</p></figure><p id="1ef8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">按出版物细分阅读时间，我们可以观察到，面向数据科学的文章通常篇幅较长，因为它们倾向于深入研究更多的技术细节，并夹杂着大量引发评论的图表和数字。锻造物品的长度通常在3-5分钟之间，元素物品的长度通常在5-7分钟之间，有一些异常值。</p><h2 id="abf2" class="na me it bd mf nb nc dn mj nd ne dp mn lh nf ng mp ll nh ni mr lp nj nk mt nl bi translated">反文字云的视角</h2><p id="c543" class="pw-post-body-paragraph ky kz it la b lb mv ju ld le mw jx lg lh mx lj lk ll my ln lo lp mz lr ls lt im bi translated">如果你是一个热衷于数据科学的读者或数据可视化的爱好者，我相信你已经偶然发现了数百篇使用Python <code class="fe oe of og oh b">wordcloud</code>库的文章。在我看来——我是作为一个犯了这种错误的人这么说的——对于那些被自然语言处理(NLP)吓倒的人来说，生成一个词云是一种回避策略。wordcloud甚至没有触及可以通过新的和快速出现的自然语言处理技术利用的洞察力的表面，如主题建模、标记化、词条化、命名实体识别、文本摘要、单词嵌入等。但是为了完整起见，我们来做一个wordcloud。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pm"><img src="../Images/aaebad979d2244261a205b6d1ef760b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TXJcsvNuLVU3BFJ9OA1hgA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者生成的Wordcloud</p></figure><p id="e388" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">酷毙了。单词<em class="oa"> Python </em>、<em class="oa">机器学习</em>和<em class="oa">数据科学</em>在语料库中出现频率最高。希望这不会让任何人感到震惊。在我的下一篇文章中，我将挑战自己不要满足于文字云。相反，我将通过主题建模的方式对我的中等兴趣进行逆向工程——我也将向您展示如何做到这一点！</p><h1 id="1b0c" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">结论</h1><p id="37d6" class="pw-post-body-paragraph ky kz it la b lb mv ju ld le mw jx lg lh mx lj lk ll my ln lo lp mz lr ls lt im bi translated">这就结束了使用Gmail API从Medium Daily Digest电子邮件中提取文章元数据的教程。我希望你在阅读的过程中学到了一些新的东西。我想强调的是，我有意地决定避开一个以摘要为导向的项目，因为在我们生活的当前世界中，似乎一切都在被合成、优化，并且变得对我们更方便。我的目标不是避免阅读中等推荐的文章，而是通过人工制品来分析我自己的行为数据，人工制品是我通过算法整理的符合我最近兴趣的文章列表。我希望更多地了解我的兴趣在过去几年中是如何发展的，我希望你能决定一起来。</p><p id="7d4d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">所有源代码可在以下GitHub repo获得:</p><div class="pn po gp gr pp pq"><a href="https://github.com/sejaldua/digesting-the-digest" rel="noopener  ugc nofollow" target="_blank"><div class="pr ab fo"><div class="ps ab pt cl cj pu"><h2 class="bd iu gy z fp pv fr fs pw fu fw is bi translated">GitHub-sejaldua/digesting-the-digest:使用Gmail API对我推荐的媒体进行主题建模…</h2><div class="px l"><h3 class="bd b gy z fp pv fr fs pw fu fw dk translated">使用Gmail API对我推荐的媒体进行主题建模</h3></div><div class="py l"><p class="bd b dl z fp pv fr fs pw fu fw dk translated">github.com</p></div></div><div class="pz l"><div class="qa l qb qc qd pz qe ks pq"/></div></div></a></div></div></div>    
</body>
</html>