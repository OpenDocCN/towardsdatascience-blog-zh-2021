<html>
<head>
<title>Confused by Multi-Index in Pandas? 9 Essential Operations to Know</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">熊猫的多指标困惑？需要了解的9项基本操作</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/confused-by-multi-index-in-pandas-9-essential-operations-to-know-e6aec29ee6d8?source=collection_archive---------11-----------------------#2021-08-30">https://towardsdatascience.com/confused-by-multi-index-in-pandas-9-essential-operations-to-know-e6aec29ee6d8?source=collection_archive---------11-----------------------#2021-08-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5316" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解要领，不再有困惑</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/8743199b7a3a6a786800ac1db4a627bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Qbaz_fpzeOYnZwbF"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Erik Mclean 在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h2 id="cb9f" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">介绍</h2><p id="addb" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">在许多用例中，我们处理的是单级索引。在类似电子表格的表格中，最简单的情况是行号作为索引，列号作为列。你可能有一种误解，认为我永远不会处理多级索引。让我们考虑泰坦尼克号数据集。出于本教程的考虑，我们将只包括两个数字列:<code class="fe mo mp mq mr b">age</code>和<code class="fe mo mp mq mr b">fare</code>以及三个分类列:<code class="fe mo mp mq mr b">sex</code>、<code class="fe mo mp mq mr b">class</code>和<code class="fe mo mp mq mr b">embark_town</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">泰坦尼克号数据集</p></figure><p id="8144" class="pw-post-body-paragraph lv lw it lx b ly mu ju ma mb mv jx md li mw mf mg lm mx mi mj lq my ml mm mn im bi translated">我们数据处理中的一个常见操作是查看相关组的平均数据，如下所示。为了简化显示，我将<code class="fe mo mp mq mr b">age</code>和<code class="fe mo mp mq mr b">fare</code>的浮点数转换为整数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">分组平均数据</p></figure><p id="bace" class="pw-post-body-paragraph lv lw it lx b ly mu ju ma mb mv jx md li mw mf mg lm mx mi mj lq my ml mm mn im bi translated">如您所见，这个数据集的索引看起来不像典型的单个级别。的确，这个<code class="fe mo mp mq mr b">DataFrame</code>使用了分级索引，也就是俗称的多级索引。</p><p id="0865" class="pw-post-body-paragraph lv lw it lx b ly mu ju ma mb mv jx md li mw mf mg lm mx mi mj lq my ml mm mn im bi translated">你对多级索引了解多少？或者说，你有没有被多重索引迷惑过？让我们在本文中了解多级索引的基本方面。</p></div><div class="ab cl mz na hx nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="im in io ip iq"><h2 id="df3c" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">1.什么是MultiIndex？</h2><p id="cbbe" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">我们提到过，单级索引使用一系列标签来唯一地标识每一行或每一列。与单级索引不同，<strong class="lx iu">多级索引使用一系列元组，每个元组唯一标识一行或一列</strong>。为了简化术语，我们只关注行的索引，但是同样的规则也适用于列。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">多级索引</p></figure><p id="d7a6" class="pw-post-body-paragraph lv lw it lx b ly mu ju ma mb mv jx md li mw mf mg lm mx mi mj lq my ml mm mn im bi translated">如上所示，我们可以访问一个<code class="fe mo mp mq mr b">DataFrame</code>对象的index属性。您可能会注意到，我们将索引作为一个<code class="fe mo mp mq mr b">MultiIndex</code>对象来获取，这是pandas <code class="fe mo mp mq mr b">DataFrame</code>或<code class="fe mo mp mq mr b">Series</code>的多级或分层索引对象。这个对象有三个关键属性:<code class="fe mo mp mq mr b"><strong class="lx iu">names</strong></code>、<code class="fe mo mp mq mr b"><strong class="lx iu">levels</strong></code>和<code class="fe mo mp mq mr b"><strong class="lx iu">codes</strong></code>。我们来复习一下。</p><pre class="kj kk kl km gt ng mr nh ni aw nj bi"><span id="f76c" class="kz la it mr b gy nk nl l nm nn">&gt;&gt;&gt; df_mean.index.names<br/>FrozenList(['embark_town', 'class', 'sex'])<br/>&gt;&gt;&gt; df_mean.index.levels<br/>FrozenList([['Cherbourg', 'Queenstown', 'Southampton'], ['First', 'Second', 'Third'], ['female', 'male']])<br/>&gt;&gt;&gt; df_mean.index.codes<br/>FrozenList([[0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2], [0, 0, 1, 1, 2, 2, 0, 0, 1, 1, 2, 2, 0, 0, 1, 1, 2, 2], [0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1]])</span></pre><ul class=""><li id="80c7" class="no np it lx b ly mu mb mv li nq lm nr lq ns mn nt nu nv nw bi translated"><strong class="lx iu">名称</strong>:我们的指数对每一个指数级别都有三个名称:<code class="fe mo mp mq mr b">embark_town</code>、<code class="fe mo mp mq mr b">class</code>和<code class="fe mo mp mq mr b">sex</code>。</li><li id="4414" class="no np it lx b ly nx mb ny li nz lm oa lq ob mn nt nu nv nw bi translated"><strong class="lx iu">级别</strong>:每个级别的标签。<code class="fe mo mp mq mr b">embark_town</code>有三个标签，<code class="fe mo mp mq mr b">class</code>有三个标签，<code class="fe mo mp mq mr b">sex</code>有两个标签。</li><li id="90a8" class="no np it lx b ly nx mb ny li nz lm oa lq ob mn nt nu nv nw bi translated"><strong class="lx iu">代码</strong>:表示每一级指标的整数。例如，<code class="fe mo mp mq mr b">FrozenList</code>中的第一个列表指示所有行的'<code class="fe mo mp mq mr b">embark_town</code>级别(0 - &gt;'瑟堡'，1 - &gt;'昆斯敦，2 - &gt;'南安普顿)。</li></ul></div><div class="ab cl mz na hx nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="im in io ip iq"><h2 id="0477" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">2.将多索引转换为常规索引</h2><p id="c408" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">在示例<code class="fe mo mp mq mr b">DataFrame</code>(即<code class="fe mo mp mq mr b">df_mean</code>)中，作为使用<code class="fe mo mp mq mr b">groupby</code>功能的结果，自动创建多索引。如果我们从一个没有多索引的数据帧开始，但是一些列可以创建为多索引，那会怎么样呢？考虑下面的<code class="fe mo mp mq mr b">DataFrame</code>。</p><pre class="kj kk kl km gt ng mr nh ni aw nj bi"><span id="ebb3" class="kz la it mr b gy nk nl l nm nn">&gt;&gt;&gt; df = df_mean.reset_index()<br/>&gt;&gt;&gt; df.head()<br/>  embark_town   class     sex  age  fare<br/>0   Cherbourg   First  female   36   115<br/>1   Cherbourg   First    male   40    93<br/>2   Cherbourg  Second  female   19    25<br/>3   Cherbourg  Second    male   25    25<br/>4   Cherbourg   Third  female   14    14</span></pre><p id="9222" class="pw-post-body-paragraph lv lw it lx b ly mu ju ma mb mv jx md li mw mf mg lm mx mi mj lq my ml mm mn im bi translated">我们简单地重置了索引，创建了一个使用单级索引的<code class="fe mo mp mq mr b">DataFrame</code>，这种<code class="fe mo mp mq mr b">DataFrame</code>您可能更熟悉，对吧。需要注意的一点是，<code class="fe mo mp mq mr b">reset_index</code>方法带有一个参数<code class="fe mo mp mq mr b">drop</code>，该参数决定索引是被删除还是作为列保留。在我们的例子中，我们对<code class="fe mo mp mq mr b">drop</code>使用默认的<code class="fe mo mp mq mr b">False</code>，它会将多级索引转换为三列，这是我们想要的操作。</p></div><div class="ab cl mz na hx nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="im in io ip iq"><h2 id="1d44" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">3.重新创建多重索引</h2><p id="bffb" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">为了为这个<code class="fe mo mp mq mr b">DataFrame</code>创建多级索引，我们可以使用<code class="fe mo mp mq mr b">set_index</code>方法将适用的列指定为索引，如下所示。</p><pre class="kj kk kl km gt ng mr nh ni aw nj bi"><span id="f915" class="kz la it mr b gy nk nl l nm nn">&gt;&gt;&gt; df_mi = df.set_index(['embark_town', 'class', 'sex'])<br/>&gt;&gt;&gt; df_mi.head()<br/>                           age  fare<br/>embark_town class  sex              <br/>Cherbourg   First  female   36   115<br/>                   male     40    93<br/>            Second female   19    25<br/>                   male     25    25<br/>            Third  female   14    14</span></pre><p id="9e25" class="pw-post-body-paragraph lv lw it lx b ly mu ju ma mb mv jx md li mw mf mg lm mx mi mj lq my ml mm mn im bi translated">如您所见，<code class="fe mo mp mq mr b">df_mi</code>与<code class="fe mo mp mq mr b">df_mean</code> <code class="fe mo mp mq mr b">DataFrame</code>具有相同的多级索引。</p><p id="a51b" class="pw-post-body-paragraph lv lw it lx b ly mu ju ma mb mv jx md li mw mf mg lm mx mi mj lq my ml mm mn im bi translated">除了用现有的列设置索引之外，我们还可以手动创建<code class="fe mo mp mq mr b">MultiIndex</code>对象，如果愿意的话，将它分配给一个<code class="fe mo mp mq mr b">DataFrame</code>。如下所示，我们能够重新创建一个与我们在<code class="fe mo mp mq mr b">df_mean</code>中使用的对象相匹配的<code class="fe mo mp mq mr b">MultiIndex</code>对象。<code class="fe mo mp mq mr b">from_product</code>方法使用提供的列表顺序创建所有可能组合的产品。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">手动创建多索引</p></figure><p id="a4df" class="pw-post-body-paragraph lv lw it lx b ly mu ju ma mb mv jx md li mw mf mg lm mx mi mj lq my ml mm mn im bi translated">除了from_product方法之外，还有几种方法经常用来创建<code class="fe mo mp mq mr b">MultiIndex</code>对象，比如<code class="fe mo mp mq mr b"><a class="ae ky" href="https://pandas.pydata.org/docs/reference/api/pandas.MultiIndex.from_tuples.html#pandas.MultiIndex.from_tuples" rel="noopener ugc nofollow" target="_blank">from_tuples</a></code>、<code class="fe mo mp mq mr b"><a class="ae ky" href="https://pandas.pydata.org/docs/reference/api/pandas.MultiIndex.from_arrays.html#pandas.MultiIndex.from_arrays" rel="noopener ugc nofollow" target="_blank">from_arrays</a></code>和<code class="fe mo mp mq mr b"><a class="ae ky" href="https://pandas.pydata.org/docs/reference/api/pandas.MultiIndex.from_frame.html#pandas.MultiIndex.from_frame" rel="noopener ugc nofollow" target="_blank">from_frame</a></code>。用法应该很简单，感兴趣的读者可以参考各自的参考资料，了解如何使用它们(点击这些方法上的链接)。</p></div><div class="ab cl mz na hx nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="im in io ip iq"><h2 id="8a62" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated"><strong class="ak"> 4。选择特定级别</strong></h2><p id="4005" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">选择数据最直接的方法是使用带有<code class="fe mo mp mq mr b">loc</code>属性的基于元组的索引。如前所述，多级索引本质上是一个元组列表。因此，我们可以为想要检索的行指定所需的元组。下面是一些例子。</p><pre class="kj kk kl km gt ng mr nh ni aw nj bi"><span id="6313" class="kz la it mr b gy nk nl l nm nn">&gt;&gt;&gt; df_mean.loc[('Queenstown',)]<br/>               age  fare<br/>class  sex              <br/>First  female   33    90<br/>       male     44    90<br/>Second female   30    12<br/>       male     57    12<br/>Third  female   22    10<br/>       male     28    11<br/>&gt;&gt;&gt; df_mean.loc[('Southampton', 'Second')]<br/>        age  fare<br/>sex              <br/>female   29    21<br/>male     30    19</span></pre><ul class=""><li id="5b2b" class="no np it lx b ly mu mb mv li nq lm nr lq ns mn nt nu nv nw bi translated">您可以跳过元组中的前n个级别，这将检索更低级别的所有元素。例如，<code class="fe mo mp mq mr b">(‘Queenstown’,)</code>将选择该级别的所有行，而<code class="fe mo mp mq mr b">(‘Southampton’, ‘Second’)</code>将为<code class="fe mo mp mq mr b">embark_town</code>选择级别为<code class="fe mo mp mq mr b">‘Southampton’</code>的行，为<code class="fe mo mp mq mr b">class</code>选择级别为<code class="fe mo mp mq mr b">‘Second’</code>的行。</li><li id="cf29" class="no np it lx b ly nx mb ny li nz lm oa lq ob mn nt nu nv nw bi translated">检索到的数据没有指定的级别，因为所有数据都满足指定的级别。</li><li id="f9fa" class="no np it lx b ly nx mb ny li nz lm oa lq ob mn nt nu nv nw bi translated">示例中没有显示的是，您可以省略tuple外延，这可以作为这些操作的快捷方式。例如，代替<code class="fe mo mp mq mr b">df_mean.loc[(‘Queenstown’,)]</code>和<code class="fe mo mp mq mr b">df_mean.loc[(‘Southampton’, ‘Second’)]</code>，你可以分别做<code class="fe mo mp mq mr b">df_mean.loc[‘Queenstown’]</code>和<code class="fe mo mp mq mr b">df_mean.loc[‘Southampton’, ‘Second’]</code>。但是，通常不建议这样做，因为这会导致混乱。因此，我通常会列出所有适用的信息，这样就不会有歧义。</li><li id="7f16" class="no np it lx b ly nx mb ny li nz lm oa lq ob mn nt nu nv nw bi translated">另一件要注意的事情是，我省略了列的<code class="fe mo mp mq mr b">:</code>选择器，因为我确实想选择年龄和费用列。如果您只选择列的子集，请指定。</li></ul></div><div class="ab cl mz na hx nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="im in io ip iq"><h2 id="1f1a" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">5.使用xs选择横截面</h2><p id="76d6" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">除了使用<code class="fe mo mp mq mr b">loc</code>方法，您还可以使用<code class="fe mo mp mq mr b">DataFrame</code>的<code class="fe mo mp mq mr b">xs</code>方法，该方法检索横截面数据行。要检索特定级别，只需指定索引。下面是一些例子。</p><pre class="kj kk kl km gt ng mr nh ni aw nj bi"><span id="1733" class="kz la it mr b gy nk nl l nm nn">&gt;&gt;&gt; df_mean.xs('Queenstown')<br/>               age  fare<br/>class  sex              <br/>First  female   33    90<br/>       male     44    90<br/>Second female   30    12<br/>       male     57    12<br/>Third  female   22    10<br/>       male     28    11<br/>&gt;&gt;&gt; df_mean.xs(('Southampton', 'First', 'female'))<br/>age     32<br/>fare    99<br/>Name: (Southampton, First, female), dtype: int64</span></pre><p id="1c33" class="pw-post-body-paragraph lv lw it lx b ly mu ju ma mb mv jx md li mw mf mg lm mx mi mj lq my ml mm mn im bi translated">您可以为<code class="fe mo mp mq mr b">xs</code>设置的另一个有用的参数是<code class="fe mo mp mq mr b">level</code>，它指的是在多索引中使用的级别。例如，要检索<code class="fe mo mp mq mr b">DataFrame</code>中的所有第一类，我们可以执行以下操作，选择横截面数据。</p><pre class="kj kk kl km gt ng mr nh ni aw nj bi"><span id="915e" class="kz la it mr b gy nk nl l nm nn">&gt;&gt;&gt; df_mean.xs('First', level='class')<br/>                    age  fare<br/>embark_town sex              <br/>Cherbourg   female   36   115<br/>            male     40    93<br/>Queenstown  female   33    90<br/>            male     44    90<br/>Southampton female   32    99<br/>            male     41    52</span></pre></div><div class="ab cl mz na hx nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="im in io ip iq"><h2 id="d37f" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">6.同时选择多个级别</h2><p id="9bd2" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">当您想要选择具有不同级别的行时，可以在list对象中指定所需数据的索引。例如，假设我们要在第三名皇后镇(女性)和第一名南安普敦(男性)之间选择数据。下面是如何通过指定范围。请注意，该范围包括边界，就像您对单级索引使用<code class="fe mo mp mq mr b">loc</code>一样。</p><pre class="kj kk kl km gt ng mr nh ni aw nj bi"><span id="8db3" class="kz la it mr b gy nk nl l nm nn">&gt;&gt;&gt; df_mean.loc[('Queenstown', 'Third', 'female'):('Southampton', 'First', 'male')]<br/>                          age  fare<br/>embark_town class sex              <br/>Queenstown  Third female   22    10<br/>                  male     28    11<br/>Southampton First female   32    99<br/>                  male     41    52</span></pre><p id="c536" class="pw-post-body-paragraph lv lw it lx b ly mu ju ma mb mv jx md li mw mf mg lm mx mi mj lq my ml mm mn im bi translated">如果希望选择不连续的行，可以传递元组列表，这些元组是行的索引。考虑下面的例子，它只选择了两行数据。</p><pre class="kj kk kl km gt ng mr nh ni aw nj bi"><span id="ff74" class="kz la it mr b gy nk nl l nm nn">&gt;&gt;&gt; df_mean.loc[[('Queenstown', 'Third', 'female'), ('Southampton', 'First', 'male')]]<br/>                          age  fare<br/>embark_town class sex              <br/>Queenstown  Third female   22    10<br/>Southampton First male     41    52</span></pre><p id="4f21" class="pw-post-body-paragraph lv lw it lx b ly mu ju ma mb mv jx md li mw mf mg lm mx mi mj lq my ml mm mn im bi translated">与上面的例子密切相关的是，我们也可以通过传递一组列表来选择数据，但是它们做事情的方式不同。如下所示，列表元组将产生多级索引，每个列表引用每个级别的多个标签。</p><pre class="kj kk kl km gt ng mr nh ni aw nj bi"><span id="f1f2" class="kz la it mr b gy nk nl l nm nn">&gt;&gt;&gt; df_mean.loc[(['Queenstown', 'Southampton'], ['First', 'Second'], ['female', 'male'])]<br/>                           age  fare<br/>embark_town class  sex              <br/>Queenstown  First  female   33    90<br/>                   male     44    90<br/>            Second female   30    12<br/>                   male     57    12<br/>Southampton First  female   32    99<br/>                   male     41    52<br/>            Second female   29    21<br/>                   male     30    19</span></pre></div><div class="ab cl mz na hx nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="im in io ip iq"><h2 id="17eb" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">7.使用切片的高级选择</h2><p id="075a" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">当我们使用列表元组时，多级索引是从这些列表中创建的。但是，当某个级别有多个标签时，您可能希望使用slice对象来表示一系列标签，而不是逐一列出它们。考虑下面的例子。</p><pre class="kj kk kl km gt ng mr nh ni aw nj bi"><span id="4e9d" class="kz la it mr b gy nk nl l nm nn">&gt;&gt;&gt; # Instead of df_mean.loc[(['Cherbourg', 'Queenstown', 'Southampton'], 'Second', ['female', 'male'])]<br/>&gt;&gt;&gt; df_mean.loc[(slice('Cherbourg', 'Southampton'), 'Second', slice(None))]<br/>                           age  fare<br/>embark_town class  sex              <br/>Cherbourg   Second female   19    25<br/>                   male     25    25<br/>Queenstown  Second female   30    12<br/>                   male     57    12<br/>Southampton Second female   29    21<br/>                   male     30    19</span></pre><ul class=""><li id="c467" class="no np it lx b ly mu mb mv li nq lm nr lq ns mn nt nu nv nw bi translated"><code class="fe mo mp mq mr b">slice(start, end)</code>定义范围内的所有指数。</li><li id="5562" class="no np it lx b ly nx mb ny li nz lm oa lq ob mn nt nu nv nw bi translated">因为我们只有三个标签用于<code class="fe mo mp mq mr b">embark_town</code>级别，而不是使用<code class="fe mo mp mq mr b">slice(‘Cherbourg’, ‘Southampton’)</code>，我们可以使用<code class="fe mo mp mq mr b">slice(None)</code>，这被自动解释为引用所有标签。</li><li id="a07e" class="no np it lx b ly nx mb ny li nz lm oa lq ob mn nt nu nv nw bi translated">除了使用<code class="fe mo mp mq mr b">slice</code>函数，pandas还提供了一种更好的方法来引用多索引——<code class="fe mo mp mq mr b">IndexSlice</code>,这有点像NumPy中使用的引用。下面是一个例子。在本例中，<code class="fe mo mp mq mr b">:</code>表示该级别的所有标签。</li></ul><pre class="kj kk kl km gt ng mr nh ni aw nj bi"><span id="a6d7" class="kz la it mr b gy nk nl l nm nn">&gt;&gt;&gt; df_mean.loc[pd.IndexSlice[:, 'First', :]]<br/>                          age  fare<br/>embark_town class sex              <br/>Cherbourg   First female   36   115<br/>                  male     40    93<br/>Queenstown  First female   33    90<br/>                  male     44    90<br/>Southampton First female   32    99<br/>                  male     41    52</span></pre></div><div class="ab cl mz na hx nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="im in io ip iq"><h2 id="2eb3" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">8.重组级别</h2><p id="7ff0" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">到目前为止，数据帧已经有了原始顺序的多级索引。然而，我们可能希望索引以不同的顺序排列。为此，我们可以使用<code class="fe mo mp mq mr b">reorder_levels</code>方法。例如，期望的顺序是<code class="fe mo mp mq mr b">class-sex-embark_town</code>，而不是<code class="fe mo mp mq mr b">embark_town-class-sex</code>。这种操作如下所示。</p><pre class="kj kk kl km gt ng mr nh ni aw nj bi"><span id="fa3a" class="kz la it mr b gy nk nl l nm nn">&gt;&gt;&gt; df_mean.reorder_levels(['class', 'sex', 'embark_town']).head()<br/>                           age  fare<br/>class  sex    embark_town           <br/>First  female Cherbourg     36   115<br/>       male   Cherbourg     40    93<br/>Second female Cherbourg     19    25<br/>       male   Cherbourg     25    25<br/>Third  female Cherbourg     14    14</span></pre><p id="d0e1" class="pw-post-body-paragraph lv lw it lx b ly mu ju ma mb mv jx md li mw mf mg lm mx mi mj lq my ml mm mn im bi translated">除了指定级别的名称，还可以通过指定级别的数值来支持。因此，上述操作相当于<code class="fe mo mp mq mr b">df_mean.reorder_levels([1, 2, 0])</code>。</p><p id="2c59" class="pw-post-body-paragraph lv lw it lx b ly mu ju ma mb mv jx md li mw mf mg lm mx mi mj lq my ml mm mn im bi translated">如果你想切换两个级别的顺序，另一种方法是使用<code class="fe mo mp mq mr b">swaplevel</code>方法。顾名思义，该方法直接在两个级别之间翻转顺序。</p><pre class="kj kk kl km gt ng mr nh ni aw nj bi"><span id="0713" class="kz la it mr b gy nk nl l nm nn">&gt;&gt;&gt; df_mean.swaplevel(0, 1).head()<br/>                           age  fare<br/>class  embark_town sex              <br/>First  Cherbourg   female   36   115<br/>                   male     40    93<br/>Second Cherbourg   female   19    25<br/>                   male     25    25<br/>Third  Cherbourg   female   14    14</span></pre></div><div class="ab cl mz na hx nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="im in io ip iq"><h2 id="ae9f" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">9.排序多索引</h2><p id="22b6" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">多级索引重组后，<code class="fe mo mp mq mr b">DataFrame</code>看起来不再有组织，因为顺序还是用原来的那个，是根据<code class="fe mo mp mq mr b">embark_town-class-sex</code>的索引排序的。为了根据所需的级别聚合数据，我们可以对索引进行排序，以便更好地组织数据。</p><pre class="kj kk kl km gt ng mr nh ni aw nj bi"><span id="e90d" class="kz la it mr b gy nk nl l nm nn">&gt;&gt;&gt; df_mean.swaplevel(0, 1).sort_index().head()<br/>                          age  fare<br/>class embark_town sex              <br/>First Cherbourg   female   36   115<br/>                  male     40    93<br/>      Queenstown  female   33    90<br/>                  male     44    90<br/>      Southampton female   32    99</span></pre><p id="6517" class="pw-post-body-paragraph lv lw it lx b ly mu ju ma mb mv jx md li mw mf mg lm mx mi mj lq my ml mm mn im bi translated">在示例中，我们简单地使用了<code class="fe mo mp mq mr b">sort_index</code>方法，默认情况下，该方法使用第一级对数据进行排序。</p><p id="ddb3" class="pw-post-body-paragraph lv lw it lx b ly mu ju ma mb mv jx md li mw mf mg lm mx mi mj lq my ml mm mn im bi translated">但是，如果您喜欢使用不同的级别对数据进行排序，我们可以指定级别的数值或名称，如下所示。</p><pre class="kj kk kl km gt ng mr nh ni aw nj bi"><span id="b977" class="kz la it mr b gy nk nl l nm nn">&gt;&gt;&gt; df_mean.swaplevel(0, 1).sort_index(level='sex').head()<br/>                           age  fare<br/>class  embark_town sex              <br/>First  Cherbourg   female   36   115<br/>       Queenstown  female   33    90<br/>       Southampton female   32    99<br/>Second Cherbourg   female   19    25<br/>       Queenstown  female   30    12</span></pre></div><div class="ab cl mz na hx nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="im in io ip iq"><h2 id="3639" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">结论</h2><p id="f180" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">在本文中，我们回顾了您可能需要用来处理多级索引的基本操作。我知道对于许多初学者来说这是一个令人困惑的话题，但是如果你掌握了要点，当多级索引相关时，你应该能够处理大多数日常工作。</p><p id="5e15" class="pw-post-body-paragraph lv lw it lx b ly mu ju ma mb mv jx md li mw mf mg lm mx mi mj lq my ml mm mn im bi translated">感谢阅读这篇文章。通过<a class="ae ky" href="https://medium.com/subscribe/@yong.cui01" rel="noopener">注册我的简讯</a>保持联系。还不是中等会员？使用我的会员链接，通过<a class="ae ky" href="https://medium.com/@yong.cui01/membership" rel="noopener">支持我的写作。</a></p></div></div>    
</body>
</html>