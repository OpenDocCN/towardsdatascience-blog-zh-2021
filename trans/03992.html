<html>
<head>
<title>Intro to Markov Chain Multi-Touch Attribution</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">马尔可夫链多触点归因简介</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/into-to-markov-chain-multi-touch-attribution-bb1968ff1f54?source=collection_archive---------1-----------------------#2021-04-04">https://towardsdatascience.com/into-to-markov-chain-multi-touch-attribution-bb1968ff1f54?source=collection_archive---------1-----------------------#2021-04-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="878b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用R进行模拟和建模</h2></div><h1 id="eeae" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">什么是归因建模？</h1><p id="9b08" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">归因建模是<code class="fe lw lx ly lz b">Digital Marketing</code>中出现的一项任务。概括地说，归因建模的目标是改善驾驶<code class="fe lw lx ly lz b">Marketing Objectives</code>中各种<code class="fe lw lx ly lz b">Advertising Channels</code>的评估。在开始数据分析之前，让我们首先为<code class="fe lw lx ly lz b">Markov Chain Attribution</code>建模解决的问题设置一个背景。</p><p id="38eb" class="pw-post-body-paragraph la lb it lc b ld ma ju lf lg mb jx li lj mc ll lm ln md lp lq lr me lt lu lv im bi translated">在这篇文章中，我的目标是涵盖以下内容:</p><ol class=""><li id="b447" class="mf mg it lc b ld ma lg mb lj mh ln mi lr mj lv mk ml mm mn bi translated">什么是归因建模？</li><li id="81a3" class="mf mg it lc b ld mo lg mp lj mq ln mr lr ms lv mk ml mm mn bi translated">什么是多点触控归因？</li><li id="dfab" class="mf mg it lc b ld mo lg mp lj mq ln mr lr ms lv mk ml mm mn bi translated">马尔可夫链简介</li><li id="5dca" class="mf mg it lc b ld mo lg mp lj mq ln mr lr ms lv mk ml mm mn bi translated">使用R表示:</li></ol><ul class=""><li id="f144" class="mf mg it lc b ld ma lg mb lj mh ln mi lr mj lv mt ml mm mn bi translated">从马尔可夫链模拟消费者旅程</li><li id="e426" class="mf mg it lc b ld mo lg mp lj mq ln mr lr ms lv mt ml mm mn bi translated">从消费者旅程估计马尔可夫链</li><li id="239c" class="mf mg it lc b ld mo lg mp lj mq ln mr lr ms lv mt ml mm mn bi translated">使用马尔可夫链进行数据驱动的归因</li></ul><h1 id="f826" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">许多广告渠道</h1><p id="05c4" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">当营销人员在广告上花钱时，他们战略性地将预算分配给不同的活动，这些活动反过来使用大量的广告渠道。一些常见的广告渠道包括有线电视和流媒体电视、节目、社交、付费搜索、印刷品。这些是如何定义的，以及使用哪些媒体合作伙伴和平台来花费计划的预算各不相同，但广告商通过多种渠道进行沟通的事实仍然存在。</p><h1 id="e019" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">目标和KPI</h1><p id="8af4" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">让我们记住，营销人员不是为了做广告而做广告。他们有特定的目标和目的，围绕这些目标和目的建立营销传播战略。<code class="fe lw lx ly lz b">Analytics</code>的角色之一是帮助建立一个衡量计划，该计划将定义一组<code class="fe lw lx ly lz b">Key Performance Indicators</code> (KPI)来衡量营销工作的成功。根据目标和技术能力，选择这些KPI，并准备好测量它们的工具。例如，我们可能希望:</p><ul class=""><li id="2780" class="mf mg it lc b ld ma lg mb lj mh ln mi lr mj lv mt ml mm mn bi translated">产生对网站或网页的访问</li><li id="85db" class="mf mg it lc b ld mo lg mp lj mq ln mr lr ms lv mt ml mm mn bi translated">通过表单提交产生销售线索</li><li id="d14e" class="mf mg it lc b ld mo lg mp lj mq ln mr lr ms lv mt ml mm mn bi translated">让用户在我们的网站上执行某些操作</li><li id="8a55" class="mf mg it lc b ld mo lg mp lj mq ln mr lr ms lv mt ml mm mn bi translated">提高我们品牌的知名度</li><li id="29c3" class="mf mg it lc b ld mo lg mp lj mq ln mr lr ms lv mt ml mm mn bi translated">或者只是推动销售</li></ul><p id="dbfa" class="pw-post-body-paragraph la lb it lc b ld ma ju lf lg mb jx li lj mc ll lm ln md lp lq lr me lt lu lv im bi translated">无论KPI是什么，完成的KPI的一个单元被称为<code class="fe lw lx ly lz b">Conversion</code>。</p><h1 id="7973" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">投资回报率和归因</h1><p id="af49" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">在我们开展活动和花费预算时，我们需要回答一个关键问题:</p><blockquote class="mu mv mw"><p id="d2b9" class="la lb mx lc b ld ma ju lf lg mb jx li my mc ll lm mz md lp lq na me lt lu lv im bi translated">我们如何评估不同渠道在推动KPI方面的重要程度？</p></blockquote><p id="f93a" class="pw-post-body-paragraph la lb it lc b ld ma ju lf lg mb jx li lj mc ll lm ln md lp lq lr me lt lu lv im bi translated">显然，如果我们的目标是推动销售，但在其他条件相同的情况下，我们的销售没有增加，那么没有一个渠道工作得很好。但是，如果我们真的成功推动了增量销售，哪种渠道效果最好呢？换句话说，我们如何<code class="fe lw lx ly lz b">Attribute</code>不同渠道的增量销售并计算我们的投资回报(<code class="fe lw lx ly lz b">ROI</code>，有时被称为广告回报(<code class="fe lw lx ly lz b">ROAS</code>))？我们是否应该因为其中一个渠道的表现不如预期而从战术上改变我们的计划？回答这些问题是单向的<code class="fe lw lx ly lz b">Analytics</code>广告对<code class="fe lw lx ly lz b">Advertising</code>的价值。</p><h1 id="37d1" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">消费者路径中的最后一步</h1><p id="e867" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">有了数字广告，我们衡量消费者何时以及如何与广告互动的能力变得更加容易。这种易处理性允许我们收集数据并分析<code class="fe lw lx ly lz b">Consumer Path</code>到<code class="fe lw lx ly lz b">Conversion</code>的部分。无论是否被跟踪，消费者的旅程都是存在的，没有人能够真正跟踪整个旅程。我们能追踪的是一些<code class="fe lw lx ly lz b">Media Touchpoints</code>。往往<code class="fe lw lx ly lz b">Attribute</code>到<code class="fe lw lx ly lz b">Conversions</code>最简单的方法就是简单的看一下<code class="fe lw lx ly lz b">Consumer Path</code>中的<code class="fe lw lx ly lz b">Last-Touch</code>。这是因为默认情况下，这是我们看到的唯一接触点。对推动<code class="fe lw lx ly lz b">Conversion</code>的<code class="fe lw lx ly lz b">Last-Touch</code>给予完全的信任将导致对我们媒体效果的不公平评估，并且不能解释混合渠道旨在创造的<code class="fe lw lx ly lz b">Synergy</code>。</p><figure class="nc nd ne nf gt ng gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/61b1062920ad552dc3899f2b009d8fe9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1268/format:webp/1*WFHhN5T40NOuKu67ctBmqQ.png"/></div></figure><p id="f8d5" class="pw-post-body-paragraph la lb it lc b ld ma ju lf lg mb jx li lj mc ll lm ln md lp lq lr me lt lu lv im bi translated">幸运的是，如果做了足够的努力来跟踪我们的媒体，我们可以生成路径数据，并希望以一种更复杂的方式进行归因，即使用<code class="fe lw lx ly lz b">Multi-Touch Attribution</code> ( <code class="fe lw lx ly lz b">MTA</code>)。这使我们能够更好地判断所用渠道的有效性，并做出更好的投资决策。</p><figure class="nc nd ne nf gt ng gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/17cbdb9c7e4d95ea92aab94f421b01a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1356/format:webp/1*ujp5rLVSyZVue4Ra1YgxfQ.png"/></div></figure><h1 id="1605" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">多点触摸归因</h1><p id="23e9" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><code class="fe lw lx ly lz b">MTA</code>方法主要有两类；<code class="fe lw lx ly lz b">Rule-Based</code>和<code class="fe lw lx ly lz b">Data-Driven</code>。当然，这两种方法都使用数据，但区别在于它们如何对消费者路径上的接触点赋予重要性。<code class="fe lw lx ly lz b">Rule-Based</code>方法基于触摸点的位置启发式地为其分配权重。</p><p id="cd87" class="pw-post-body-paragraph la lb it lc b ld ma ju lf lg mb jx li lj mc ll lm ln md lp lq lr me lt lu lv im bi translated"><code class="fe lw lx ly lz b">Data-Driven</code>方法采取不同的方式。他们不是根据位置分配任意的规则，而是在接触点和他们在驱动中的角色之间建立概率关系<code class="fe lw lx ly lz b">Conversions</code>。</p><h1 id="bf53" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">马尔可夫链属性</h1><p id="7465" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><code class="fe lw lx ly lz b">Markov Chain Attribution</code>是一种比较流行的数据驱动方法，顾名思义，它利用了<code class="fe lw lx ly lz b">Markov Chains</code>。除非你在大学学过运筹学或数学，否则你可能不知道这些链是什么，所以让我们做一个高层次的介绍。</p><h1 id="5739" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">马尔可夫链</h1><p id="4477" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">关于<code class="fe lw lx ly lz b">Markov Chains</code>要记住的关键概念是<code class="fe lw lx ly lz b">Transition Matrix</code>。它们本身是描述(随机)系统的概念工具。所有这一切意味着，当一个过程存在随机性或概率性成分时，<code class="fe lw lx ly lz b">Markov Chains</code>可能是一个很好的工具来首先描述，然后分析这个过程。我们这里关注的过程是<code class="fe lw lx ly lz b">Customer Journeys</code>走向<code class="fe lw lx ly lz b">Conversions</code>。</p><h1 id="7215" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">基本面</h1><p id="4357" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我们可以把一个<code class="fe lw lx ly lz b">Markov Chain</code>想象成一个有向网络。每个节点都是一个<code class="fe lw lx ly lz b">State</code>,消费者可以在其中沿着一条路径前进。每个箭头都是一个<code class="fe lw lx ly lz b">Transition</code>，有了它，就有了关联的概率。因此，你可能有一组预先确定的接触点，但接下来会发生什么是不确定的。</p><figure class="nc nd ne nf gt ng gh gi paragraph-image"><div role="button" tabindex="0" class="nl nm di nn bf no"><div class="gh gi nk"><img src="../Images/a3b6454c222b7f5303865e96e5bd59b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M-mZ8EtfkwTukN8fo29Mxg.png"/></div></div></figure><p id="058c" class="pw-post-body-paragraph la lb it lc b ld ma ju lf lg mb jx li lj mc ll lm ln md lp lq lr me lt lu lv im bi translated">转换和非转换节点有从所有通道指向它们的箭头，但没有从它们发出的箭头。这些被称为<code class="fe lw lx ly lz b">Absorbing States</code>，对我们来说，它们意味着旅程的结束。当我们收集了从一个状态转移到下一个状态的所有概率时，我们将它们组织成一个正方形<code class="fe lw lx ly lz b">Transition Matrix</code>。</p><pre class="nc nd ne nf gt np lz nq nr aw ns bi"><span id="b111" class="nt kj it lz b gy nu nv l nw nx">M = t(matrix(c(1,0,0,0,0,<br/>               200,0,300,350,10,<br/>               160,300,0,350,8,<br/>               150,200,200,0,20,<br/>               0,0,0,0,1), nrow = 5))</span><span id="02bd" class="nt kj it lz b gy ny nv l nw nx">M = M/rowSums(M)  </span><span id="5f8b" class="nt kj it lz b gy ny nv l nw nx">colnames(M) = c("Non-Conversion","Display",<br/>"TV","Search", "Conversion")</span><span id="9939" class="nt kj it lz b gy ny nv l nw nx">row.names(M) = c("Non-Conversion","Display",<br/>"TV","Search","Conversion")</span></pre><figure class="nc nd ne nf gt ng gh gi paragraph-image"><div role="button" tabindex="0" class="nl nm di nn bf no"><div class="gh gi nz"><img src="../Images/27455050c4e051a552fc4f33260851e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1t7EdRkvvhkMewb9GnOmnQ.png"/></div></div></figure><p id="a0d1" class="pw-post-body-paragraph la lb it lc b ld ma ju lf lg mb jx li lj mc ll lm ln md lp lq lr me lt lu lv im bi translated">上面是一个例子<code class="fe lw lx ly lz b">Transition Matrix</code>，我只是把它放在一起举例说明。为了更现实，我将转换概率设置为相对较低的值。稍后我们将使用此矩阵进行<code class="fe lw lx ly lz b">Simulation</code>！</p><p id="4f84" class="pw-post-body-paragraph la lb it lc b ld ma ju lf lg mb jx li lj mc ll lm ln md lp lq lr me lt lu lv im bi translated">要记住的一个重要属性是，行的总和等于1，因为我们处理的是概率。行代表旅程中的当前状态，列代表下一个状态。</p><pre class="nc nd ne nf gt np lz nq nr aw ns bi"><span id="2ad6" class="nt kj it lz b gy nu nv l nw nx">rowSums(M)</span><span id="e8d1" class="nt kj it lz b gy ny nv l nw nx">## Non-Conversion Display   TV         Search     Conversion<br/>   1              1         1          1          1</span></pre><p id="8122" class="pw-post-body-paragraph la lb it lc b ld ma ju lf lg mb jx li lj mc ll lm ln md lp lq lr me lt lu lv im bi translated">关于<code class="fe lw lx ly lz b">Markov Chains</code>，还有一件更重要的事情需要了解，那就是<code class="fe lw lx ly lz b">Markov Property</code>或者无记忆性。对某些人来说，这可能是TMI，但这确实是用一个简单的<code class="fe lw lx ly lz b">Transition Matrix</code>来概括整个过程的原因。该属性是一个简化的假设，即<strong class="lc iu">你转移到下一个地方的概率</strong>只取决于你现在的位置，而不取决于你的整个旅程历史。需要说明的是，这并不意味着旅程历史不重要。这绝对会影响归因结果。不影响的是概率。从数学的角度来看，这使得分析变得非常简单。</p><h1 id="dd46" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">从链到路径(模拟)</h1><p id="af14" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">在实践中，给定一个消费者路径的数据集(构建这个数据集是一个很大的任务，所以“给定”是一个很强的词)，我们可以估计一个<code class="fe lw lx ly lz b">Transition Matrix</code>。反之亦然。给定一个<code class="fe lw lx ly lz b">Transition Matrix</code>，我们可以模拟一组消费者路径。事实上，模拟在得出每个通道的实际重要程度方面起着重要的作用，因此有必要了解一下这一过程的机制。</p><p id="1c85" class="pw-post-body-paragraph la lb it lc b ld ma ju lf lg mb jx li lj mc ll lm ln md lp lq lr me lt lu lv im bi translated">下面我们定义一个函数，它将与上面的样本矩阵<strong class="lc iu"> M </strong>一起工作。给定这个矩阵和我们想要执行的<code class="fe lw lx ly lz b">num_sim</code>步骤，我们执行以下操作:</p><ol class=""><li id="3b4d" class="mf mg it lc b ld ma lg mb lj mh ln mi lr mj lv mk ml mm mn bi translated">从一组媒体接触点中随机选择一个起点。</li></ol><ul class=""><li id="bf14" class="mf mg it lc b ld ma lg mb lj mh ln mi lr mj lv mt ml mm mn bi translated">在实践中，我们实际上会估计起点概率。</li></ul><p id="49f2" class="pw-post-body-paragraph la lb it lc b ld ma ju lf lg mb jx li lj mc ll lm ln md lp lq lr me lt lu lv im bi translated">2.对于每个步骤:</p><ul class=""><li id="3d9e" class="mf mg it lc b ld ma lg mb lj mh ln mi lr mj lv mt ml mm mn bi translated">从<strong class="lc iu"> M </strong>中选择一行与当前状态/触摸点相对应的概率。</li><li id="6a9b" class="mf mg it lc b ld mo lg mp lj mq ln mr lr ms lv mt ml mm mn bi translated">从概率设置为行的<code class="fe lw lx ly lz b">Multinomial</code>分布中抽取一个样本。</li><li id="b1f1" class="mf mg it lc b ld mo lg mp lj mq ln mr lr ms lv mt ml mm mn bi translated">将样本设置为新的当前状态并重复。</li></ul><p id="9206" class="pw-post-body-paragraph la lb it lc b ld ma ju lf lg mb jx li lj mc ll lm ln md lp lq lr me lt lu lv im bi translated">3.如果我们点击了<code class="fe lw lx ly lz b">Conversion</code>或<code class="fe lw lx ly lz b">Non-Conversion</code>，我们就结束了路径。</p><pre class="nc nd ne nf gt np lz nq nr aw ns bi"><span id="c4b1" class="nt kj it lz b gy nu nv l nw nx">simulate_path = function(M, num_sim){<br/>   num_sim = num_sim   <br/>   path = vector(mode = "integer", length = num_sim)   <br/>   path[1] = sample(2:(nrow(M)-1), 1) <br/>  <br/>   for(i in 1:(num_sim-1)){<br/>        p = M[path[i],]<br/>        sn = which(rmultinom(1, 1, p) == 1)<br/>        path[i+1] = sn     <br/>        if(sn == 1 | sn == 5){<br/>           break     <br/>        }   <br/>    }   <br/>    return(path[path &gt; 0]) <br/>}</span></pre><h1 id="9897" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">模拟一条路径</h1><p id="1182" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">让我们测试一下这个函数。第一个例子是非转换器。</p><pre class="nc nd ne nf gt np lz nq nr aw ns bi"><span id="7b13" class="nt kj it lz b gy nu nv l nw nx">set.seed(124) <br/>num_sim = 100 <br/>path = simulate_path(M, num_sim) <br/>plot(seq_along(path),path ,type = "l",<br/>     axes=FALSE, <br/>     ylim = c(1,5),<br/>     main = "Non-Converter",<br/>     ylab = "Channel Touchpoint",<br/>     xlab = "Touchpoint Number") <br/>points(seq_along(path), path) <br/>axis(side = 2, at = 1:5) <br/>axis(side = 1, at = seq_along(path))</span></pre><figure class="nc nd ne nf gt ng gh gi paragraph-image"><div role="button" tabindex="0" class="nl nm di nn bf no"><div class="gh gi oa"><img src="../Images/b378976fafc7a2e0430b7ee185ea12fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QNrCwiFjzdkp9VjGgk3m7A.png"/></div></div></figure><p id="9e72" class="pw-post-body-paragraph la lb it lc b ld ma ju lf lg mb jx li lj mc ll lm ln md lp lq lr me lt lu lv im bi translated">我们看到，我们从<code class="fe lw lx ly lz b">Display</code>开始，移动到<code class="fe lw lx ly lz b">Search</code>，然后<code class="fe lw lx ly lz b">TV</code>，继续这个旅程，直到第6步，在这里我们没有转换就退出。</p><p id="aa3c" class="pw-post-body-paragraph la lb it lc b ld ma ju lf lg mb jx li lj mc ll lm ln md lp lq lr me lt lu lv im bi translated">这是另一个例子，但这次我们有一个转换器。</p><pre class="nc nd ne nf gt np lz nq nr aw ns bi"><span id="789c" class="nt kj it lz b gy nu nv l nw nx">set.seed(007) <br/>num_sim = 100 <br/>path = simulate_path(M, num_sim) <br/>plot(seq_along(path),path ,type = "l",<br/>     axes=FALSE, <br/>     ylim = c(1,5),<br/>     main = "Non-Converter",<br/>     ylab = "Channel Touchpoint",<br/>     xlab = "Touchpoint Number") <br/>points(seq_along(path), path) <br/>axis(side = 2, at = 1:5) <br/>axis(side = 1, at = seq_along(path))</span></pre><figure class="nc nd ne nf gt ng gh gi paragraph-image"><div role="button" tabindex="0" class="nl nm di nn bf no"><div class="gh gi ob"><img src="../Images/ece11e876bfb266bf7d39f44ca550f72.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bRK6AKD9XPQHw5mKdjK28Q.png"/></div></div></figure><p id="33b5" class="pw-post-body-paragraph la lb it lc b ld ma ju lf lg mb jx li lj mc ll lm ln md lp lq lr me lt lu lv im bi translated">这一次，我们从<code class="fe lw lx ly lz b">TV</code>开始，在第8步进行转换，将<code class="fe lw lx ly lz b">Search</code>作为我们的最后一个接触点。</p><h1 id="0aef" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">模拟完整的旅程数据集</h1><p id="f552" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我们现在可以简单地通过重复函数调用<code class="fe lw lx ly lz b">simulate_path</code>来模拟一整套路径。随着更多的数据操作，我们有了一个<code class="fe lw lx ly lz b">pathdf</code>。这里我将生成<code class="fe lw lx ly lz b">10,000</code>路径。</p><pre class="nc nd ne nf gt np lz nq nr aw ns bi"><span id="dc90" class="nt kj it lz b gy nu nv l nw nx">num_sim = 100 <br/>num_paths = 10000  <br/>paths = purrr::map(1:num_paths, ~simulate_path(M, num_sim))  </span><span id="0f9a" class="nt kj it lz b gy ny nv l nw nx">conversion = <br/>    purrr::map(paths, ~ data.frame(<br/>    conversion = ifelse(.x[length(.x)] == 5, <br/>                        "converter", "non-converter"))) %&gt;%     bind_rows(.id = "path_num")  </span><span id="5aa5" class="nt kj it lz b gy ny nv l nw nx">pathdf = <br/>   map(paths, ~data.frame(touchpoint = 1:length(.x), channel = .x)) %&gt;% bind_rows(.id = "path_num") <br/>%&gt;% left_join(conversion) %&gt;% <br/>left_join(data.frame(channel_name = colnames(M), channel = 1:5)) </span><span id="dfc9" class="nt kj it lz b gy ny nv l nw nx"><br/>head(pathdf,10) %&gt;% <br/>       gt::gt() %&gt;%<br/>       gt::tab_header(title = "Simmulated Paths")</span></pre><figure class="nc nd ne nf gt ng gh gi paragraph-image"><div role="button" tabindex="0" class="nl nm di nn bf no"><div class="gh gi oc"><img src="../Images/b6e84dc5b308dffcc158c5ca3791220a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ugALXHoJJOVnCs_BT5b78g.png"/></div></div></figure><p id="4413" class="pw-post-body-paragraph la lb it lc b ld ma ju lf lg mb jx li lj mc ll lm ln md lp lq lr me lt lu lv im bi translated">现在让我们将所有这些路径一个接一个地绘制出来，看看这个<code class="fe lw lx ly lz b">Markov Chain</code>是如何工作的。</p><pre class="nc nd ne nf gt np lz nq nr aw ns bi"><span id="c791" class="nt kj it lz b gy nu nv l nw nx">plotly::ggplotly(<br/>    pathdf %&gt;% <br/>      ggplot(aes(touchpoint, channel, color = conversion, <br/>                 group = path_num)) + geom_line() +   <br/>      labs(x = "Touchpoint Number", <br/>           y = "Channel Touhcpoint") +  <br/>      theme_minimal() <br/>)</span></pre><figure class="nc nd ne nf gt ng gh gi paragraph-image"><div role="button" tabindex="0" class="nl nm di nn bf no"><div class="gh gi od"><img src="../Images/65d331073a5a3f4392ca735a5036803b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5jV2qfhGGTpvRtrmkkgjJg.png"/></div></div></figure><p id="850a" class="pw-post-body-paragraph la lb it lc b ld ma ju lf lg mb jx li lj mc ll lm ln md lp lq lr me lt lu lv im bi translated">从图中我们可以看到，更常见的是直线下降，这表示非转换器。这是意料之中的。我们可以看到模拟的转化率刚刚超过8%。</p><pre class="nc nd ne nf gt np lz nq nr aw ns bi"><span id="1d9a" class="nt kj it lz b gy nu nv l nw nx">table(conversion$conversion)/nrow(conversion)</span><span id="791c" class="nt kj it lz b gy ny nv l nw nx">##     converter non-converter  <br/>##        0.0808        0.9192</span></pre><h1 id="6917" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">从道路到锁链</h1><p id="8ab6" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">既然我们已经从我们的马尔可夫链<strong class="lc iu"> M </strong>中模拟了一组消费者路径，我们可以尝试用它们来估计最初的<strong class="lc iu"> M </strong>和<strong class="lc iu"> M^ </strong>，看看这种估计方法的效果如何。在这里，我将介绍大卫·阿尔托马雷创作的精彩的<code class="fe lw lx ly lz b">ChannelAttribution</code>软件包。它是开源的，托管在<a class="ae oe" href="https://gitlab.com/session-tech/ChannelAttribution" rel="noopener ugc nofollow" target="_blank"> GitLab这里</a>。这个包包含一个名为<code class="fe lw lx ly lz b">transition_matrix</code>的函数，它接收一组路径数据并估计<code class="fe lw lx ly lz b">Transition Matrix</code>。</p><h1 id="ee6f" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">数据准备</h1><p id="e7ca" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">首要任务是按照要求的格式组织数据。首先，我们需要解析出每个路径中的最终接触点，因为它们代表一个<code class="fe lw lx ly lz b">conversion</code> / <code class="fe lw lx ly lz b">non-conversion</code>事件。然后，我们总结按路径分组的数据，并对观察到的每个唯一路径计数<code class="fe lw lx ly lz b">converters</code>和<code class="fe lw lx ly lz b">non-converters</code>。</p><pre class="nc nd ne nf gt np lz nq nr aw ns bi"><span id="9904" class="nt kj it lz b gy nu nv l nw nx">named_paths =<br/>      pathdf %&gt;% group_by(path_num) %&gt;% <br/>      group_split() %&gt;% <br/>      map(~pull(.x,channel_name)) </span><span id="c88a" class="nt kj it lz b gy ny nv l nw nx">path_trim = <br/> map(named_paths, ~.x[.x != "Non-Conversion" &amp; .x != "Conversion"])  </span><span id="7893" class="nt kj it lz b gy ny nv l nw nx">journeydf = as_tibble(<br/> cbind(<br/>    as.data.frame(do.call(rbind,<br/>       map(path_trim, ~str_c(.x, collapse = " &gt; "))<br/>       )<br/>    ),conversion$conversion)<br/>) </span><span id="35d2" class="nt kj it lz b gy ny nv l nw nx">names(journeydf) = c("path","conversion")  <br/>journeydf = <br/>journeydf %&gt;% <br/>group_by(path) %&gt;% <br/>summarise(converters = <br/>    sum(if_else(conversion == "converter",1, 0)),             <br/>          non_converters = <br/>     sum(if_else(conversion == "non-converter", 1, 0)<br/>          )<br/>) %&gt;%  <br/>arrange(-converters, -non_converters)  </span><span id="3581" class="nt kj it lz b gy ny nv l nw nx">head(journeydf, 15) %&gt;% gt::gt() %&gt;% <br/>gt::tab_header(<br/>title = "Simmulated Journey Data (Top 15 Converters)"<br/>)</span></pre><figure class="nc nd ne nf gt ng gh gi paragraph-image"><div role="button" tabindex="0" class="nl nm di nn bf no"><div class="gh gi of"><img src="../Images/6d1d125bf77a24e7e639badad9e10c1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rS2z8S-diouqyr4JgfHg7g.png"/></div></div></figure><p id="ca20" class="pw-post-body-paragraph la lb it lc b ld ma ju lf lg mb jx li lj mc ll lm ln md lp lq lr me lt lu lv im bi translated">下面是一些关于生成的路径数据的快速汇总统计。</p><pre class="nc nd ne nf gt np lz nq nr aw ns bi"><span id="20e5" class="nt kj it lz b gy nu nv l nw nx">data.frame(<br/>metric = c("Converters",<br/>           "Non Converters",<br/>           "Number of Paths",<br/>           "Conversion Rate %",<br/>            "Unique Journeys"),<br/>value = c(sum(journeydf$converters),<br/>          sum(journeydf$non_converters),<br/>          sum(journeydf$non_converters) + sum(journeydf$converters),<br/>          100*sum(journeydf$converters) / num_paths,<br/>          nrow(journeydf))) %&gt;% <br/>gt::gt() %&gt;%<br/>gt::tab_header(title = "Summary")</span></pre><figure class="nc nd ne nf gt ng gh gi paragraph-image"><div class="gh gi og"><img src="../Images/1e1f60efb94cf11b0528c4b1b8f3c9c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:828/format:webp/1*YkK3sZggxZmJX0PCc_Yhvg.png"/></div></figure><p id="9b8f" class="pw-post-body-paragraph la lb it lc b ld ma ju lf lg mb jx li lj mc ll lm ln md lp lq lr me lt lu lv im bi translated">还有许多其他方法来探索这种数据。一个快一个交集一个是<code class="fe lw lx ly lz b">path lengths</code>的分布。</p><pre class="nc nd ne nf gt np lz nq nr aw ns bi"><span id="c96b" class="nt kj it lz b gy nu nv l nw nx">path_lengths = map_int(path_trim, ~length(.x)) <br/>summary(path_lengths)</span><span id="4058" class="nt kj it lz b gy ny nv l nw nx">##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max.  <br/>##   1.000   2.000   3.000   4.002   5.000  31.000</span><span id="a317" class="nt kj it lz b gy ny nv l nw nx">hist(path_lengths, main = "Path Length Distribution")</span></pre><figure class="nc nd ne nf gt ng gh gi paragraph-image"><div role="button" tabindex="0" class="nl nm di nn bf no"><div class="gh gi oh"><img src="../Images/c203ce6ec4746b9bcaa2d34bcb5efb6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d2tmdGsmMHuZtkMVRHMR9w.png"/></div></div></figure><h1 id="a307" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">转移矩阵估计</h1><p id="adc8" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">最后，现在我们有了已知转移矩阵m的模拟数据集，我们现在可以看到如何通过估计和计算M^从数据回到转移矩阵。这里我们将<code class="fe lw lx ly lz b">ChannelAttribution::transition_matrix()</code>函数应用于我们的数据。该函数返回频道id的查找表和转移概率表。</p><pre class="nc nd ne nf gt np lz nq nr aw ns bi"><span id="5b20" class="nt kj it lz b gy nu nv l nw nx">library(ChannelAttribution)  <br/>tM = transition_matrix(journeydf,<br/>                       var_path = "path",<br/>                       var_conv = "converters",<br/>                       var_null = "non_converters")  </span><span id="ceeb" class="nt kj it lz b gy ny nv l nw nx">tM$transition_matrix %&gt;% gt::gt() %&gt;% <br/>gt::tab_header(title = "Transition Probabilities")</span></pre><figure class="nc nd ne nf gt ng gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/3f0104150253de6aecdc05139c56a0dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1320/format:webp/1*wv14-Y-mdmBhyh30xfjZeQ.png"/></div></figure><p id="d8ea" class="pw-post-body-paragraph la lb it lc b ld ma ju lf lg mb jx li lj mc ll lm ln md lp lq lr me lt lu lv im bi translated">我们可以格式化表格并以某种方式输出，以便于我们比较估计的和真实的转移矩阵</p><figure class="nc nd ne nf gt ng gh gi paragraph-image"><div role="button" tabindex="0" class="nl nm di nn bf no"><div class="gh gi oj"><img src="../Images/7b48a8c7a65ced496d2c72e17e636cfc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4BPh8sQkd11H4tnxXUi6dg.png"/></div></div></figure><p id="51fd" class="pw-post-body-paragraph la lb it lc b ld ma ju lf lg mb jx li lj mc ll lm ln md lp lq lr me lt lu lv im bi translated">我们可以看到，估计工作得很好，特别是对于较大的概率。因为转换事件非常罕见，所以对它们的估计有更大的可变性/更低的精度。</p><h1 id="af1d" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">属性</h1><p id="45a6" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">到目前为止，我们以转移矩阵<strong class="lc iu"> M </strong>的形式引入了一个理论<code class="fe lw lx ly lz b">Markov Chain</code>，用它来模拟一个数据集<code class="fe lw lx ly lz b">Consumer Journeys</code>，并通过估计<strong class="lc iu"> M^ </strong>返回到一个<code class="fe lw lx ly lz b">Transition Matrix</code>。现在是转换的时候了，继续实际的归因模型！</p><h1 id="4c87" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">移除效应</h1><p id="8f06" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><code class="fe lw lx ly lz b">Markov Chains</code>作为<code class="fe lw lx ly lz b">Consumer Journeys</code>的样板似乎是个好主意。但是我们如何使用它们来实现属性转换还不是很清楚。</p><p id="973b" class="pw-post-body-paragraph la lb it lc b ld ma ju lf lg mb jx li lj mc ll lm ln md lp lq lr me lt lu lv im bi translated">这里的主要思想是计算<code class="fe lw lx ly lz b">Removal Effects</code>。<code class="fe lw lx ly lz b">Removal Effects</code>测量如果从路径中省略/移除一个通道，观察到的转换会减少多少。如果我们对<code class="fe lw lx ly lz b">Markov Chain</code>中的每个通道进行计算，那么<code class="fe lw lx ly lz b">Relative Removal Effects</code>将是我们缩放总转换量的因子。</p><h1 id="c4b5" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">运行归因</h1><p id="b986" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">正如我们刚刚了解到的，运行马尔可夫归因模型包括估计一个<code class="fe lw lx ly lz b">Transition Matrix</code>，然后计算<code class="fe lw lx ly lz b">Removal Effects</code>。为此，我们只需使用<code class="fe lw lx ly lz b">markov_model</code>函数，它以准备好的格式获取数据。通过指定<code class="fe lw lx ly lz b">out_more = TRUE</code>，除了属性结果之外，我们还可以获得<code class="fe lw lx ly lz b">transition matrix</code>和<code class="fe lw lx ly lz b">removal effects</code>。</p><pre class="nc nd ne nf gt np lz nq nr aw ns bi"><span id="c541" class="nt kj it lz b gy nu nv l nw nx">mm_res = markov_model(journeydf,<br/>                       var_path = "path",<br/>                       var_conv = "converters",<br/>                       var_null = "non_converters",<br/>                       out_more = TRUE)</span><span id="d628" class="nt kj it lz b gy ny nv l nw nx">##  <br/>## Number of simulations: 100000 - Convergence reached: 2.32% &lt; 5.00% ##  ## Percentage of simulated paths that successfully end before maximum number of steps (32)</span></pre><h1 id="7cf8" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">归因结果</h1><p id="d3ca" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">首先，我们来看看结果。转换总数为<code class="fe lw lx ly lz b">808</code>。下表显示了我们的<code class="fe lw lx ly lz b">Data-Driven</code>模型是如何确定这些属性的。</p><pre class="nc nd ne nf gt np lz nq nr aw ns bi"><span id="9b1f" class="nt kj it lz b gy nu nv l nw nx">mm_res$result %&gt;% gt::gt()</span></pre><figure class="nc nd ne nf gt ng gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/ef604dd91d2c7cb477d840c7dfa6bdd5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1184/format:webp/1*wGXM1OI5Nq5RQpPaSNL2TA.png"/></div></figure><p id="71e0" class="pw-post-body-paragraph la lb it lc b ld ma ju lf lg mb jx li lj mc ll lm ln md lp lq lr me lt lu lv im bi translated">我们看到，每个渠道的转换数量相似，但<code class="fe lw lx ly lz b">Search</code>的转换数量最多。这并不奇怪，因为转移概率被导向<code class="fe lw lx ly lz b">Search</code>，但只是轻微的。此外，在我们的模拟中，每个通道都同样有可能被选为第一接触点，而这在现实中是不会发生的。</p><p id="7297" class="pw-post-body-paragraph la lb it lc b ld ma ju lf lg mb jx li lj mc ll lm ln md lp lq lr me lt lu lv im bi translated">为了显示如何从移除效果计算这些结果，下面是显式代码:</p><pre class="nc nd ne nf gt np lz nq nr aw ns bi"><span id="85b6" class="nt kj it lz b gy nu nv l nw nx">total_coversions = sum(journeydf$converters)<br/>removal_effects =  mm_res$removal_effects$removal_effects<br/>relative_removal_effects = removal_effects/sum(removal_effects)<br/>attributed_conversions = total_coversions * relative_removal_effects</span><span id="a637" class="nt kj it lz b gy ny nv l nw nx">attributed_conversions</span><span id="fc83" class="nt kj it lz b gy ny nv l nw nx">## [1] 284.97 263.29 259.75</span></pre><p id="30ec" class="pw-post-body-paragraph la lb it lc b ld ma ju lf lg mb jx li lj mc ll lm ln md lp lq lr me lt lu lv im bi translated">去除效果本身可以容易地被访问和解释</p><pre class="nc nd ne nf gt np lz nq nr aw ns bi"><span id="525d" class="nt kj it lz b gy nu nv l nw nx">removal_effects</span><span id="b9c1" class="nt kj it lz b gy ny nv l nw nx">## [1] 0.7806 0.7212 0.7115</span></pre><p id="3f78" class="pw-post-body-paragraph la lb it lc b ld ma ju lf lg mb jx li lj mc ll lm ln md lp lq lr me lt lu lv im bi translated">从这些数字中，我们看到，如果移除<code class="fe lw lx ly lz b">Search</code>，将会观察到约78%的转换减少。对于这样一个小而相互关联的国家来说，这很有戏剧性，但并不奇怪。</p><h1 id="d3c0" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">与基于规则的模型进行快速比较</h1><p id="a9c3" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">使用<code class="fe lw lx ly lz b">ChannelAttribution</code>包也很容易获得一些基于规则的模型的结果，并将它们与数据驱动的结果进行比较。</p><pre class="nc nd ne nf gt np lz nq nr aw ns bi"><span id="7597" class="nt kj it lz b gy nu nv l nw nx">heuristic_models(journeydf, <br/>                 var_path = "path", <br/>                 var_conv = "converters") %&gt;% <br/>  left_join(mm_res$result) %&gt;% <br/>  gt::gt()</span></pre><p id="3956" class="pw-post-body-paragraph la lb it lc b ld ma ju lf lg mb jx li lj mc ll lm ln md lp lq lr me lt lu lv im bi translated">我们可以清楚地看到<code class="fe lw lx ly lz b">Last-Touch</code>和<code class="fe lw lx ly lz b">Markov Chain</code>模型结果之间的差异，因为<code class="fe lw lx ly lz b">Display</code>尤其是<code class="fe lw lx ly lz b">TV</code>的重要性被大大低估了。<code class="fe lw lx ly lz b">Last-Touch</code>与<code class="fe lw lx ly lz b">Markov Chain</code>车型相比，<code class="fe lw lx ly lz b">50</code>的电视转换率更低。这个例子清楚地说明了<code class="fe lw lx ly lz b">Markov Chain</code>属性如何能够纠正<code class="fe lw lx ly lz b">Last-Touch</code>属性的固有偏差。<code class="fe lw lx ly lz b">Linear Touch</code>这里的结果是相似的，再次因为通道之间的转移概率相差不太远。</p><pre class="nc nd ne nf gt np lz nq nr aw ns bi"><span id="5fa0" class="nt kj it lz b gy nu nv l nw nx">mta_res %&gt;% <br/>  pivot_longer(-channel_name, <br/>         names_to = "MTA_Model", values_to = "Conversions") %&gt;% <br/>  ggplot(aes(MTA_Model, Conversions, fill = channel_name)) + <br/>  geom_col(position = "dodge") +<br/>  labs(title = "MTA Model Result Comparison")<br/>  theme_minimal()</span></pre><figure class="nc nd ne nf gt ng gh gi paragraph-image"><div role="button" tabindex="0" class="nl nm di nn bf no"><div class="gh gi ol"><img src="../Images/727cb795783c927aa21ee3f064634d3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LLLvwTIwsvCk3EaO_vDOBg.png"/></div></div></figure><h1 id="9f41" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">主要考虑事项</h1><p id="d227" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">希望你和我一样对MTA和马尔可夫链归因这个话题感兴趣。尽管这篇介绍相当冗长，但这种类型的分析仍有许多方面需要考虑。下面是接下来需要考虑的几个关键问题:</p><ol class=""><li id="59b3" class="mf mg it lc b ld ma lg mb lj mh ln mi lr mj lv mk ml mm mn bi translated"><strong class="lc iu">数据是任何数据分析的关键要素，因此分析的质量取决于数据的质量。</strong></li><li id="c9c5" class="mf mg it lc b ld mo lg mp lj mq ln mr lr ms lv mk ml mm mn bi translated">数据质量取决于几个因素:</li></ol><ul class=""><li id="103c" class="mf mg it lc b ld ma lg mb lj mh ln mi lr mj lv mt ml mm mn bi translated">可测量性——一个通道可以测量到什么程度？数字广告很容易衡量，而OOH(街头横幅)很难追踪。</li><li id="04a3" class="mf mg it lc b ld mo lg mp lj mq ln mr lr ms lv mt ml mm mn bi translated">衡量——仅仅因为某样东西容易衡量并不意味着它被很好地衡量了。如果没有实施、维护和管理适当的工具，就无法正确收集数据。</li><li id="50d7" class="mf mg it lc b ld mo lg mp lj mq ln mr lr ms lv mt ml mm mn bi translated">数据管理—即使正确收集了数据，仍然需要对其进行管理，这意味着命名约定和数据分类必须到位。</li><li id="a824" class="mf mg it lc b ld mo lg mp lj mq ln mr lr ms lv mt ml mm mn bi translated">跨设备/跨平台(围墙花园)—为了将<code class="fe lw lx ly lz b">Customer Journey</code>数据缝合在一起，我们需要能够识别跨不同平台和设备的用户，并通过这些平台和设备联系他们。这也许是今天MTA的最大局限。</li></ul><p id="e35a" class="pw-post-body-paragraph la lb it lc b ld ma ju lf lg mb jx li lj mc ll lm ln md lp lq lr me lt lu lv im bi translated">3.如果需要频繁有效地交付MTA结果，数据工程方面是很重要的。灵活性越大，就会越复杂。</p><p id="991d" class="pw-post-body-paragraph la lb it lc b ld ma ju lf lg mb jx li lj mc ll lm ln md lp lq lr me lt lu lv im bi translated">4.我们可能还想考虑是否有更好的方法来估计转移矩阵，例如使用贝叶斯方法。</p></div></div>    
</body>
</html>