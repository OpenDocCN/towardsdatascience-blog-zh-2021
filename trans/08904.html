<html>
<head>
<title>The Best Python Sentiment Analysis Package (+1 Huge Common Mistake)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">最好的Python情绪分析包(+1个巨大的常见错误)</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/the-best-python-sentiment-analysis-package-1-huge-common-mistake-d6da9ad6cdeb?source=collection_archive---------3-----------------------#2021-08-17">https://towardsdatascience.com/the-best-python-sentiment-analysis-package-1-huge-common-mistake-d6da9ad6cdeb?source=collection_archive---------3-----------------------#2021-08-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="7c7a" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/tips-and-tricks" rel="noopener" target="_blank">提示和技巧</a></h2><div class=""/><div class=""><h2 id="9b64" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">如何在不训练自己模型的情况下获得近乎完美的性能</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/3b73cbbff9db8ada1331c358c182e474.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3lO10IrksNp8R5BO"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated"><a class="ae lh" href="https://unsplash.com/@thenewmalcolm?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">奥比·奥尼耶多尔</a>在<a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="be13" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">情感分析是最常被研究的自然语言处理任务之一，在从公司管理他们的社交媒体形象到情感股票交易到产品评论的使用案例中都可以看到。</p><div class="me mf gp gr mg mh"><a rel="noopener follow" target="_blank" href="/building-a-budget-news-based-algorithmic-trader-well-then-you-need-hard-to-find-data-f7b4d6f3bb2"><div class="mi ab fo"><div class="mj ab mk cl cj ml"><h2 class="bd jd gy z fp mm fr fs mn fu fw jc bi translated">建立一个基于预算新闻的算法交易者？那么你需要很难找到的数据</h2><div class="mo l"><h3 class="bd b gy z fp mm fr fs mn fu fw dk translated">创建一个零美元的算法交易者，分析免费的API，数据集和网页抓取器。</h3></div><div class="mp l"><p class="bd b dl z fp mm fr fs mn fu fw dk translated">towardsdatascience.com</p></div></div><div class="mq l"><div class="mr l ms mt mu mq mv lb mh"/></div></div></a></div><p id="7da7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">随着它越来越受欢迎，可用的软件包也越来越多，为了选出最好的，我把三个流行的软件包放在一起:NLTK (VADER)、TextBlob和Flair。</p><h2 id="123b" class="mw mx it bd my mz na dn nb nc nd dp ne lr nf ng nh lv ni nj nk lz nl nm nn iz bi translated"><strong class="ak"> NLTK (VADER)和TextBlob </strong></h2><p id="51ba" class="pw-post-body-paragraph li lj it lk b ll no kd ln lo np kg lq lr nq lt lu lv nr lx ly lz ns mb mc md im bi translated">这两个软件包都依赖于基于规则的情感分析器。因此，它会对某些单词(例如恐怖有负面联想)，注意否定是否存在，根据这些词返回值。这种方法工作起来很好，并且具有简单和速度极快的优点，但是也有一些缺点。</p><ul class=""><li id="68b2" class="nt nu it lk b ll lm lo lp lr nv lv nw lz nx md ny nz oa ob bi translated">随着句子变得越来越长，中性词就越来越多，因此，总得分也越来越趋于中性</li><li id="1153" class="nt nu it lk b ll oc lo od lr oe lv of lz og md ny nz oa ob bi translated">讽刺和行话经常被误解</li></ul><p id="b6b0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">NLTK可以使用以下代码找到文本的整个数据帧的极性得分(从-1到1)和情感:</p><pre class="ks kt ku kv gt oh oi oj ok aw ol bi"><span id="aaf6" class="mw mx it oi b gy om on l oo op">from nltk.sentiment import SentimentIntensityAnalyzer<br/>import operator<br/>sia = SentimentIntensityAnalyzer()<br/>df["sentiment_score"] = df["reviews.text"].apply(lambda x: sia.polarity_scores(x)["compound"])<br/>df["sentiment"] = np.select([df["sentiment_score"] &lt; 0, df["sentiment_score"] == 0, df["sentiment_score"] &gt; 0],<br/>                           ['neg', 'neu', 'pos'])</span></pre><p id="0638" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">而Textblob可以以更简洁的方式完成同样的工作</p><pre class="ks kt ku kv gt oh oi oj ok aw ol bi"><span id="49cd" class="mw mx it oi b gy om on l oo op">from textblob import TextBlob<br/>df["sentiment_score"] = df["reviews.text"].apply(lambda x: TextBlob(str(x)).sentiment.polarity)<br/>df["sentiment"] = np.select([df["sentiment_score"] &lt; 0, df["sentiment_score"] == 0, df["sentiment_score"] &gt; 0],<br/>                           ['neg', 'neu', 'pos'])</span></pre><h2 id="8a5e" class="mw mx it bd my mz na dn nb nc nd dp ne lr nf ng nh lv ni nj nk lz nl nm nn iz bi translated"><strong class="ak">天赋</strong></h2><p id="74bc" class="pw-post-body-paragraph li lj it lk b ll no kd ln lo np kg lq lr nq lt lu lv nr lx ly lz ns mb mc md im bi translated">Flair是一个预训练的基于嵌入的模型。这意味着每个单词都在一个向量空间中表示。具有与另一个单词最相似的矢量表示的单词经常在相同的上下文中使用。因此，这使得我们能够确定任何给定向量的情感，从而确定任何给定句子的情感。如果您对更多的技术方面感兴趣，这些嵌入是基于本文的。</p><p id="4363" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">Flair往往比基于规则的模型慢得多，但它的优势在于它是一个经过训练的NLP模型，而不是基于规则的模型，如果做得好，它会带来额外的性能。为了客观地看待慢了多少，在运行1200个句子时，NLTK花了0.78秒，Textblob花了令人印象深刻的0.55秒，而Flair花了49秒(长50-100倍)，这就引出了一个问题，即增加的准确性是否真正值得增加的运行时间。</p><p id="5537" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">一个完整的数据帧可以这样训练</p><pre class="ks kt ku kv gt oh oi oj ok aw ol bi"><span id="e4fc" class="mw mx it oi b gy om on l oo op">from flair.models import TextClassifier<br/>from flair.data import Sentence</span><span id="5133" class="mw mx it oi b gy oq on l oo op">sia = TextClassifier.load('en-sentiment')</span><span id="5141" class="mw mx it oi b gy oq on l oo op">def flair_prediction(x):<br/>    sentence = Sentence(x)<br/>    sia.predict(sentence)<br/>    score = sentence.labels[0]<br/>    if "POSITIVE" in str(score):<br/>        return "pos"<br/>    elif "NEGATIVE" in str(score):<br/>        return "neg"<br/>    else:<br/>        return "neu"</span><span id="4221" class="mw mx it oi b gy oq on l oo op">df["sentiment"] = df["reviews.text"].apply(flair_prediction)</span></pre><h2 id="48a5" class="mw mx it bd my mz na dn nb nc nd dp ne lr nf ng nh lv ni nj nk lz nl nm nn iz bi translated">对他们进行测试</h2><p id="be79" class="pw-post-body-paragraph li lj it lk b ll no kd ln lo np kg lq lr nq lt lu lv nr lx ly lz ns mb mc md im bi translated">为了测试这些包，我将使用由<a class="ae lh" href="https://datafiniti.co/" rel="noopener ugc nofollow" target="_blank">data inity</a>提供的来自Kaggle 的亚马逊评论的<a class="ae lh" href="https://www.kaggle.com/datafiniti/consumer-reviews-of-amazon-products/version/5" rel="noopener ugc nofollow" target="_blank">大型数据库。该数据集包括34，000条从1到5星的评论，其中大多数是5星评论。为了准确评估，我会从每个星级二次抽样300。为了确定我的准确性，我将只使用300个1星评论(假设它们都应该是负面的)和300个5星评论(假设它们都应该是正面的)</a></p><p id="f99a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我将使用的性能指标是准确性(所有预测中的正确预测)、精确度(有多少正面预测是正确的)、特异性(衡量有多少负面预测是正确的)和F1值(精确度和召回率的调和平均值)</p><p id="0fb7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">分数如下</p><pre class="ks kt ku kv gt oh oi oj ok aw ol bi"><span id="f6ae" class="mw mx it oi b gy om on l oo op">NLTK (VADER)<br/>Accuracy: 68.69712351945854<br/>Precision: 62.38938053097345<br/>Specificity: 42.17687074829932<br/>F1: 75.30040053404538<br/></span><span id="e194" class="mw mx it oi b gy oq on l oo op">TEXTBLOB<br/>Accuracy: 65.97582037996546<br/>Precision: 60.29411764705882<br/>Specificity: 33.45070422535211<br/>F1: 74.44876783398183</span><span id="fbde" class="mw mx it oi b gy oq on l oo op">FLAIR<br/>Accuracy: 96.0<br/>Precision: 95.69536423841059<br/>Specificity: 95.66666666666667<br/>F1: 96.01328903654486</span></pre><p id="a097" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">结果不言自明——基于规则的模型很难确定负面评论何时是真正负面的。VADER正确识别了280/300个五星评论，但只正确识别了126/300个负面评论(哎哟)，导致了可怕的42%特异性分数。我认为这是因为负面评论中大量使用了强调、行话和讽刺。</p><p id="bb94" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">另一方面，Flair没有落入这个陷阱，正确地识别了289/300的正面评论，以及287/300的负面评论。它在2星评价中也有类似的良好表现，290/300的评价是负面的。详细结果如下！</p><pre class="ks kt ku kv gt oh oi oj ok aw ol bi"><span id="14a4" class="mw mx it oi b gy om on l oo op">NLTK (VADER)<br/>reviews.rating  sentiment<br/>1.0             neg          124<br/>                neu            6<br/>                pos          170<br/>5.0             neg           15<br/>                neu            3<br/>                pos          282</span><span id="644f" class="mw mx it oi b gy oq on l oo op">TEXTBLOB<br/>reviews.rating  sentiment<br/>1.0             neg           95<br/>                neu           16<br/>                pos          189<br/>5.0             neg            8<br/>                neu            5<br/>                pos          287</span><span id="9f64" class="mw mx it oi b gy oq on l oo op">FLAIR<br/>reviews.rating  sentiment<br/>1.0             neg          287<br/>                pos           13<br/>5.0             neg           11<br/>                pos          289</span></pre><p id="1d61" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这些结果意味着您只需使用Flair的几行代码就可以获得一流的性能！</p><p id="b2e3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">一个常见的陷阱</strong></p><p id="796e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">大多数情感分析模型会建议拆分评论的每个句子，因为模型是在单个句子上训练的。我发现这既不准确又计算量大，我这样做的结果如下:</p><pre class="ks kt ku kv gt oh oi oj ok aw ol bi"><span id="9be8" class="mw mx it oi b gy om on l oo op">NLTK (VADER)<br/>Accuracy: 67.66666666666666<br/>Precision: 61.67400881057269<br/>Specificity: 42.0<br/>F1: 74.27055702917772<br/>Runtime: 0.825s (vs 0.784s)</span><span id="3f99" class="mw mx it oi b gy oq on l oo op">TEXTBLOB<br/>Accuracy: 65.86620926243569<br/>Precision: 60.475161987041034<br/>Specificity: 36.23693379790941<br/>F1: 73.78129117259552<br/>Runtime: 0.958s (vs 0.552s)</span><span id="1525" class="mw mx it oi b gy oq on l oo op">FLAIR<br/>Accuracy: 91.5<br/>Precision: 89.52380952380953<br/>Specificity: 89.0<br/>F1: 91.70731707317074<br/>Runtime: 121s (vs 49s)</span></pre><p id="6bbb" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">请注意所有这些值是如何变低的，即使我控制了超过100字的评论，这一点仍然是正确的。显然，一定要将超过200个单词的文本分割开来，但是对于长达1-2段的文本，我发现将文本分割成句子是一种误导，不值得追求。</p><h2 id="5b59" class="mw mx it bd my mz na dn nb nc nd dp ne lr nf ng nh lv ni nj nk lz nl nm nn iz bi translated">结论</h2><p id="c952" class="pw-post-body-paragraph li lj it lk b ll no kd ln lo np kg lq lr nq lt lu lv nr lx ly lz ns mb mc md im bi translated">对于仅使用预训练模型的出色性能，Flair提供了可能与定制模型相匹配的性能。我还了解到，所有这些模型对文本长度的鲁棒性都比它们各自的文档可能让您相信的要高。如果你想要源代码，我把它上传到这里。我从Neptune.ai 的<a class="ae lh" href="https://neptune.ai/blog/sentiment-analysis-python-textblob-vs-vader-vs-flair" rel="noopener ugc nofollow" target="_blank">这个博客中学到了很多关于如何使用这些模型的知识。我希望这对你的情绪分析之旅有所帮助，如果你喜欢你所读的，请随意</a><a class="ae lh" href="https://jerdibattista.medium.com/" rel="noopener">跟随我</a>，阅读我写的更多内容。我倾向于每个月深入一个主题一次(因为这些文章通常要花我3天以上的时间)！</p><div class="me mf gp gr mg mh"><a rel="noopener follow" target="_blank" href="/deep-learning-on-a-budget-450-egpu-vs-google-colab-494f9a2ff0db"><div class="mi ab fo"><div class="mj ab mk cl cj ml"><h2 class="bd jd gy z fp mm fr fs mn fu fw jc bi translated">深度学习预算:450美元eGPU vs谷歌Colab</h2><div class="mo l"><h3 class="bd b gy z fp mm fr fs mn fu fw dk translated">Colab对于开始深度学习来说是非凡的，但它如何与eGPU +超极本相抗衡？</h3></div><div class="mp l"><p class="bd b dl z fp mm fr fs mn fu fw dk translated">towardsdatascience.com</p></div></div><div class="mq l"><div class="or l ms mt mu mq mv lb mh"/></div></div></a></div></div></div>    
</body>
</html>