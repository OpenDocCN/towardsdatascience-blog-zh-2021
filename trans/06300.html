<html>
<head>
<title>Machine Learning to Cluster Cricket Players</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">机器学习对板球运动员进行聚类</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/machine-learning-to-cluster-cricket-players-1d53beeb69b4?source=collection_archive---------17-----------------------#2021-06-06">https://towardsdatascience.com/machine-learning-to-cluster-cricket-players-1d53beeb69b4?source=collection_archive---------17-----------------------#2021-06-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="78ac" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">k-means聚类、层次聚类和DBSCAN聚类的应用</h2></div><p id="37b9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">板球和数据科学这两者都一直令我着迷。当我偶然发现IPL(印度超级联赛)数据时，我很好奇要对这些数据进行某种数学分析，从中得出一些有趣的东西。这些数据包含了IPL中每个投球的细节。有趣的是，首先将这些数据转换成球员级别的数据，然后尝试识别数据中的模式，将具有相似表现的球员分组在一起。这完全符合聚类问题。</p><p id="a1ff" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">聚类是一种“无监督的机器学习”，没有定义的标签，模型可以基于该标签进行训练。相反，它在数据中寻找模式，并根据模式对数据进行逻辑分组。组合在一起的最后一组数据称为聚类，它包含一组同质点。</p><p id="46ef" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将应用一些流行的聚类算法，如k-means聚类、层次聚类和密度聚类(DBSCAN ),对在印度超级联赛(IPL)中表现相似的板球运动员进行分组。</p><p id="9cda" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将根据2008年至2020年的表现，提取IPL球员的内在素质。为了确保样本具有可比性，我们设定了一个最低标准，即每个玩家必须至少打了10局才有资格进行分析。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi lb"><img src="../Images/5381b59bc4739de5fdf70275d0e5b6a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0Ni5PCQNRJG866-HMRFUJg.png"/></div></div><p class="ln lo gj gh gi lp lq bd b be z dk translated"><strong class="bd lr">创建玩家集群—示例</strong>(图片由作者提供)</p></figure><h1 id="0c8e" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">数据集和源代码</h1><p id="d762" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">该数据集包含从2008年IPL第一版到2020年第13个赛季的所有比赛的详细信息和每场比赛的详细信息。</p><p id="8734" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请参考页面底部的数据集和源代码的链接。</p><h1 id="0cca" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">聚类玩家-属性</h1><p id="2398" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">以下是分析中考虑的球员的一些关键属性</p><ul class=""><li id="bc2f" class="mp mq iq kh b ki kj kl km ko mr ks ms kw mt la mu mv mw mx bi translated"><strong class="kh ir">击球统计</strong>像得分、击球、局数、4分、6分、击球率</li><li id="4091" class="mp mq iq kh b ki my kl mz ko na ks nb kw nc la mu mv mw mx bi translated"><strong class="kh ir">保龄球统计数据</strong>像三柱门被占，得分，失分，保龄球经济</li><li id="da06" class="mp mq iq kh b ki my kl mz ko na ks nb kw nc la mu mv mw mx bi translated">一般统计数据如比赛次数、接球次数、最佳球员人数</li></ul><h1 id="d1b2" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">聚集玩家——方法</h1><p id="0015" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">概括地说，该分析包括以下3个步骤:</p><p id="aaa3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">步骤1: </strong>将逐球原始数据转换为玩家级别的统计数据</p><p id="d977" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">步骤2: </strong>将不同的聚类技术应用于该玩家数据</p><p id="3088" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">第3步:</strong>使用ipywidgets构建一个简单的UI，使用超参数</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi nd"><img src="../Images/6f6ba1829c18b7241ba92a74e64bedd3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HzvJdAzUeuQrRE9lWapxhg.png"/></div></div><p class="ln lo gj gh gi lp lq bd b be z dk translated"><strong class="bd lr">基于击球、保龄球的玩家聚类&amp;综合统计</strong>(图片由作者提供)</p></figure><p id="2e5c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">注意:</strong>完整的源代码可以在上一节提到的GitHub repo中找到。这里只添加了部分代码流片段以供参考。</p><h1 id="71ba" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated"><em class="ne">偷窥期待什么</em></h1><p id="7077" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">带着一点乐趣学习集群——游戏开始！！</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="nf ng l"/></div><p class="ln lo gj gh gi lp lq bd b be z dk translated"><strong class="ak">玩家聚类——玩数据</strong></p></figure><p id="6b96" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这篇文章的结尾，你将能够应用不同的聚类算法来回答下面的一些问题</p><blockquote class="nh ni nj"><p id="1734" class="kf kg nk kh b ki kj jr kk kl km ju kn nl kp kq kr nm kt ku kv nn kx ky kz la ij bi translated">识别IPL中表现像Virat Kohli的球员？</p><p id="f140" class="kf kg nk kh b ki kj jr kk kl km ju kn nl kp kq kr nm kt ku kv nn kx ky kz la ij bi translated">找到类似Ravindra Jadeja的全才。</p><p id="bdd2" class="kf kg nk kh b ki kj jr kk kl km ju kn nl kp kq kr nm kt ku kv nn kx ky kz la ij bi translated">IPL里谁能打得像Jasprit Bumrah？</p><p id="5b46" class="kf kg nk kh b ki kj jr kk kl km ju kn nl kp kq kr nm kt ku kv nn kx ky kz la ij bi translated">有多少玩家和萨钦·坦杜尔卡尔一样掉进了同一个桶里？</p></blockquote><h1 id="4392" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">步骤1:从原始数据中创建玩家统计数据</h1><h2 id="fb19" class="no lt iq bd lu np nq dn ly nr ns dp mc ko nt nu me ks nv nw mg kw nx ny mi nz bi translated">窥探原始数据</h2><p id="8798" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">这里是原始数据的快速浏览——比赛数据和逐球数据</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi oa"><img src="../Images/c4610f991975aa6b59b3fcf87bf3012f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bG7fzNK9eke_6d0QpfMvvw.png"/></div></div><p class="ln lo gj gh gi lp lq bd b be z dk translated"><strong class="bd lr">偷窥比赛数据</strong>(图片由作者提供)</p></figure><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi ob"><img src="../Images/1dd0980ea094db1cdbeab0efe06390a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iVUo9xlkaQOy8N3CZpMHYQ.png"/></div></div><p class="ln lo gj gh gi lp lq bd b be z dk translated"><strong class="bd lr">逐球窥探数据</strong>(图片由作者提供)</p></figure><h2 id="8730" class="no lt iq bd lu np nq dn ly nr ns dp mc ko nt nu me ks nv nw mg kw nx ny mi nz bi translated">创建击球统计</h2><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="oc ng l"/></div><p class="ln lo gj gh gi lp lq bd b be z dk translated"><strong class="ak">每位选手的击球统计</strong></p></figure><h2 id="a515" class="no lt iq bd lu np nq dn ly nr ns dp mc ko nt nu me ks nv nw mg kw nx ny mi nz bi translated">创建保龄球统计</h2><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="oc ng l"/></div><p class="ln lo gj gh gi lp lq bd b be z dk translated"><strong class="ak">每位玩家的保龄球统计</strong></p></figure><h2 id="0b9d" class="no lt iq bd lu np nq dn ly nr ns dp mc ko nt nu me ks nv nw mg kw nx ny mi nz bi translated">合并数据</h2><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="oc ng l"/></div></figure><h2 id="1c06" class="no lt iq bd lu np nq dn ly nr ns dp mc ko nt nu me ks nv nw mg kw nx ny mi nz bi translated">过滤玩家</h2><p id="d3f2" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">让我们检查一下每个运动员参加的比赛的分布情况</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi od"><img src="../Images/d9e2af4a678b9893b119d2986493231a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kZWk8oMJFZDR6ZWw-Joncg.png"/></div></div><p class="ln lo gj gh gi lp lq bd b be z dk translated"><strong class="bd lr">比赛分布—过滤前</strong>(图片由作者提供)</p></figure><p id="7281" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如这里看到的，几乎50%的球员打了不到10场比赛。</p><p id="0019" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这个分析中，我们将只考虑至少打了10场比赛的玩家，这样最终创建的玩家集群才有意义。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi oe"><img src="../Images/38e980a79a00beb86c71aec2405b46a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cdXl43COQDuZz8n0wdyjKw.png"/></div></div><p class="ln lo gj gh gi lp lq bd b be z dk translated"><strong class="bd lr">比赛分布——过滤后</strong>(图片由作者提供)</p></figure><p id="0652" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">经过筛选，总共有336名球员将被考虑作进一步分析。</p><h2 id="fafc" class="no lt iq bd lu np nq dn ly nr ns dp mc ko nt nu me ks nv nw mg kw nx ny mi nz bi translated">缩放数据</h2><p id="ea5a" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">在运行聚类分析算法之前对数据进行缩放是一种很好的做法，这样可以防止具有较大缩放比例的变量控制聚类的定义方式。</p><p id="9702" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在此分析中，我们应用了标准定标器，以确保变量以平均值0为中心，标准差为1。</p><h1 id="9a13" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">步骤2:将聚类算法应用于玩家数据</h1><p id="635e" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">我们将探索以下三种流行的聚类技术:</p><ol class=""><li id="be5d" class="mp mq iq kh b ki kj kl km ko mr ks ms kw mt la of mv mw mx bi translated">k均值聚类</li><li id="4a61" class="mp mq iq kh b ki my kl mz ko na ks nb kw nc la of mv mw mx bi translated">分层聚类</li><li id="254b" class="mp mq iq kh b ki my kl mz ko na ks nb kw nc la of mv mw mx bi translated">DBSCAN聚类</li></ol><h1 id="2c21" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">k均值聚类</h1><p id="41a4" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">在k-均值聚类中，数据集中所需的聚类数(k)应该指定为算法的输入。下面是k-means聚类算法的内部工作原理。</p><h2 id="425c" class="no lt iq bd lu np nq dn ly nr ns dp mc ko nt nu me ks nv nw mg kw nx ny mi nz bi translated"><strong class="ak"> K-Means聚类算法</strong></h2><p id="82da" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated"><strong class="kh ir">先决条件</strong>:决定要创建的集群数量(k)</p><p id="2a6c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">第一步:</strong>随机挑选k个点作为聚类中心</p><p id="11b9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">步骤2: </strong>对于每个数据点，计算到每个聚类中心的欧几里德距离</p><p id="9f8c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">步骤3: </strong>将数据点分配给具有最小欧几里德距离的聚类。</p><p id="0300" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">步骤4: </strong>根据步骤3中分配的数据点重新计算聚类质心</p><p id="0b9e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">步骤-5: </strong>重复步骤2至4，直到质心不再更新或达到最大迭代次数</p><h2 id="aff6" class="no lt iq bd lu np nq dn ly nr ns dp mc ko nt nu me ks nv nw mg kw nx ny mi nz bi translated">K-均值聚类中的代价函数</h2><p id="ff21" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">我们在k-means聚类算法中试图最小化的成本函数是数据点和聚类质心之间的平方距离之和。这可以表示如下:</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi og"><img src="../Images/0e34c30b36be6947177a85520223f321.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1j0cwidKsnunnMEWZ3H7WA.png"/></div></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">成本函数—K-均值聚类</p></figure><p id="a3b1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通过最小化成本函数，K-Means算法旨在最大化聚类的紧密度/接近度，使得在给定特定特征向量的情况下，聚类内的数据点彼此相似。</p><h1 id="d7b5" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">寻找最佳的聚类数</h1><p id="9e81" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">有许多方法可以找到k的最佳值。在本文中，我们将通过两种这样的方法，即肘方法和剪影方法。</p><h2 id="c4b4" class="no lt iq bd lu np nq dn ly nr ns dp mc ko nt nu me ks nv nw mg kw nx ny mi nz bi translated">肘法</h2><ul class=""><li id="9c97" class="mp mq iq kh b ki mk kl ml ko oh ks oi kw oj la mu mv mw mx bi translated">elbow方法对k值范围运行k均值聚类算法。</li><li id="fa82" class="mp mq iq kh b ki my kl mz ko na ks nb kw nc la mu mv mw mx bi translated">对于k的每个值，它计算一个分数。</li><li id="96b6" class="mp mq iq kh b ki my kl mz ko na ks nb kw nc la mu mv mw mx bi translated">默认情况下，它会计算失真分数，即每个数据点到其指定中心的平方距离之和。</li><li id="fd03" class="mp mq iq kh b ki my kl mz ko na ks nb kw nc la mu mv mw mx bi translated">绘制k值与该分数的关系图会得到一个肘形图，因此得名。</li><li id="e884" class="mp mq iq kh b ki my kl mz ko na ks nb kw nc la mu mv mw mx bi translated">失真下降最多的点是<strong class="kh ir">肘点</strong>，这给出了k 的<strong class="kh ir">最佳值。</strong></li></ul><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="oc ng l"/></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">绘制肘形曲线Python代码</p></figure><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi ok"><img src="../Images/1370042908aa92cee7de5c24c823d920.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*79Vt3HVrWYZji-6xCGIljw.png"/></div></div><p class="ln lo gj gh gi lp lq bd b be z dk translated"><strong class="bd lr">肘子情节</strong> —作者图片</p></figure><p id="56a1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如这里看到的，一个好的k值看起来大约是5或6。</p><p id="b4e2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在肘图不能给出最佳聚类数的决定性结果的情况下，可以应用剪影方法。</p><h2 id="7d02" class="no lt iq bd lu np nq dn ly nr ns dp mc ko nt nu me ks nv nw mg kw nx ny mi nz bi translated">剪影法</h2><p id="4550" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">按照<a class="ae ol" href="https://en.wikipedia.org/wiki/Silhouette_(clustering)" rel="noopener ugc nofollow" target="_blank"> wiki </a>，<em class="nk">的说法，剪影值是一个对象与其自己的聚类(内聚)相比与其他聚类(分离)有多相似的度量。</em></p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi om"><img src="../Images/b8aba0528f0dc776f089d27a7ac727c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fHASQhaMyiQMtJNt0HYclg.png"/></div></div><p class="ln lo gj gh gi lp lq bd b be z dk translated"><strong class="bd lr">剪影评分</strong></p></figure><p id="7748" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">其中，<br/> ' <em class="nk"> b' </em>是到不属于<br/>的最近聚类中的点的平均距离。<em class="nk"> 'a' </em>是到其自己的聚类中所有点的平均聚类内距离</p><p id="7c59" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">剪影的分数范围在-1到1之间。分数越接近1表示该点与聚类中的其他点非常相似。接近-1的值表示该点与聚类中的其他点不太相似。</p><p id="a8ec" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对每个数据点都这样做，取平均值来确定k值的轮廓得分。轮廓得分的最大值将给出k的最佳值。</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="oc ng l"/></div><p class="ln lo gj gh gi lp lq bd b be z dk translated"><strong class="ak">用Python计算剪影分数</strong></p></figure><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi on"><img src="../Images/caf7defe800a4ac91f7cc9cd6c3c7632.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6GVNY2JFm6UwNuSSSM0p-Q.png"/></div></div><p class="ln lo gj gh gi lp lq bd b be z dk translated"><strong class="bd lr">不同k值的轮廓得分</strong></p></figure><p id="0842" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，k的最佳值应该根据业务需求和统计分析的结果来决定。</p><h2 id="7d34" class="no lt iq bd lu np nq dn ly nr ns dp mc ko nt nu me ks nv nw mg kw nx ny mi nz bi translated">Python中的K-Means聚类</h2><p id="abd4" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">既然我们已经了解了k-means聚类算法的工作原理，并且知道如何选择聚类数，那么让我们用Python来实现它。</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="oc ng l"/></div></figure><p id="6f28" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">群集的大小和分组将根据所需群集的数量而变化。下面显示了4个集群和7个集群的分布。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi oo"><img src="../Images/e847334b4d10e3687d9d933946720345.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e3DOJa8OlDqzMDig65l7qg.png"/></div></div><p class="ln lo gj gh gi lp lq bd b be z dk translated"><strong class="bd lr">K-均值聚类，k=4 </strong></p></figure><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi op"><img src="../Images/160a455adc8c7c5b463de77c2d09eb22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nYoTxR4mzD5pV-cFLtRoRA.png"/></div></div><p class="ln lo gj gh gi lp lq bd b be z dk translated"><strong class="bd lr">K = 7的K-均值聚类</strong></p></figure><p id="f6d8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">笔记本的末尾有一个“操场”。使用小部件来试验不同的k &amp; max_iter值。</p><h1 id="26a2" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">分层聚类</h1><p id="f3b1" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">分层聚类是用于识别数据集中的组的另一种聚类技术。它创建了数据点的基于树的表示，称为树状图。</p><h2 id="5051" class="no lt iq bd lu np nq dn ly nr ns dp mc ko nt nu me ks nv nw mg kw nx ny mi nz bi translated">分层聚类算法</h2><p id="805d" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">基于方法，层次聚类可以分为两种类型，凝聚型和分裂型。</p><p id="6e01" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">先决条件</strong>:决定相异度——通常是欧几里德距离</p><h2 id="cbb4" class="no lt iq bd lu np nq dn ly nr ns dp mc ko nt nu me ks nv nw mg kw nx ny mi nz bi translated">1.凝聚层次聚类</h2><ul class=""><li id="2d94" class="mp mq iq kh b ki mk kl ml ko oh ks oi kw oj la mu mv mw mx bi translated">这采用了自底向上的方法来形成集群。</li><li id="30ba" class="mp mq iq kh b ki my kl mz ko na ks nb kw nc la mu mv mw mx bi translated">首先将每个数据点视为一个集群</li><li id="3d87" class="mp mq iq kh b ki my kl mz ko na ks nb kw nc la mu mv mw mx bi translated">融合/合并具有最低相异度测量的点以创建新的更大的聚类</li><li id="93d8" class="mp mq iq kh b ki my kl mz ko na ks nb kw nc la mu mv mw mx bi translated">反复重复上述步骤，直到形成单个大簇</li></ul><h2 id="089c" class="no lt iq bd lu np nq dn ly nr ns dp mc ko nt nu me ks nv nw mg kw nx ny mi nz bi translated">2.分裂层次聚类</h2><ul class=""><li id="c9c3" class="mp mq iq kh b ki mk kl ml ko oh ks oi kw oj la mu mv mw mx bi translated">这种方法使用自顶向下的方法来形成集群</li><li id="b269" class="mp mq iq kh b ki my kl mz ko na ks nb kw nc la mu mv mw mx bi translated">首先考虑所有点都在一个聚类中</li><li id="d15a" class="mp mq iq kh b ki my kl mz ko na ks nb kw nc la mu mv mw mx bi translated">在迭代的每一步，最不均匀的集群被分成两部分。分割基于最远距离或最小相似度。</li><li id="b867" class="mp mq iq kh b ki my kl mz ko na ks nb kw nc la mu mv mw mx bi translated">迭代重复上述分割，直到所有数据点形成单独的聚类</li></ul><h2 id="967b" class="no lt iq bd lu np nq dn ly nr ns dp mc ko nt nu me ks nv nw mg kw nx ny mi nz bi translated">测量相异度——链接法</h2><p id="e387" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">有许多方法可以用来确定两个聚类之间的距离。连锁的选择对聚类的大小和树状图的形状有影响。</p><p id="5d0d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面列出了Scipy包提供的链接方法:</p><ul class=""><li id="312b" class="mp mq iq kh b ki kj kl km ko mr ks ms kw mt la mu mv mw mx bi translated"><strong class="kh ir">单一连锁</strong>:最小的相异度分数作为连锁标准</li><li id="a453" class="mp mq iq kh b ki my kl mz ko na ks nb kw nc la mu mv mw mx bi translated"><strong class="kh ir">完全连锁</strong>:以最大相异分数作为连锁标准</li><li id="e554" class="mp mq iq kh b ki my kl mz ko na ks nb kw nc la mu mv mw mx bi translated"><strong class="kh ir">平均连锁度</strong>:平均相异度分数作为连锁度标准</li><li id="365c" class="mp mq iq kh b ki my kl mz ko na ks nb kw nc la mu mv mw mx bi translated"><strong class="kh ir">质心连锁</strong>:被视为连锁标准的聚类的质心之间的不相似性</li><li id="4b1c" class="mp mq iq kh b ki my kl mz ko na ks nb kw nc la mu mv mw mx bi translated"><strong class="kh ir">中位数链接</strong>:使用中位数计算聚类之间的相异度得分</li><li id="0ca7" class="mp mq iq kh b ki my kl mz ko na ks nb kw nc la mu mv mw mx bi translated"><strong class="kh ir">加权联动</strong>:对精简距离矩阵进行加权/WPGMA联动</li><li id="bb2c" class="mp mq iq kh b ki my kl mz ko na ks nb kw nc la mu mv mw mx bi translated"><strong class="kh ir">沃德联动</strong>:使用沃德方差最小化算法。这里，具有最小聚类间距离的聚类被合并。</li></ul><h2 id="0a20" class="no lt iq bd lu np nq dn ly nr ns dp mc ko nt nu me ks nv nw mg kw nx ny mi nz bi translated">Python中的层次聚类</h2><p id="589f" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">Scipy包提供了非常易于使用的接口来创建树状图和执行聚类。下面的示例代码将通过应用完整的链接来创建一个树状图。该方法可以被改变为应用于聚类算法的任何上述链接类型。</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="oc ng l"/></div></figure><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/da067444e5f900f2ab6f5d5875f682f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*Wap0I-V68unfkizSgz3CAg.png"/></div><p class="ln lo gj gh gi lp lq bd b be z dk translated"><strong class="bd lr">树形图样本图像(50名玩家)</strong> —作者提供的图像</p></figure><p id="bb56" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从树状图中可以估计出聚类的数目。这被提供作为创建聚类的输入。</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="oc ng l"/></div></figure><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi or"><img src="../Images/36888e3fe92fec6be9b2c80c06143d60.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o7pXxElEAXlopO-IaeQyAQ.png"/></div></div><p class="ln lo gj gh gi lp lq bd b be z dk translated"><strong class="bd lr">形成的集群的样本输出摘要</strong> —图片由作者提供</p></figure><p id="8ef2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">尽管层次聚类的优点是不需要从已知数量的聚类开始，但它会计算每个点与其他点之间的距离，因此计算量会很大。因此，基于可用的资源和手头的问题，必须选择是否可以应用分层聚类。</p><h1 id="ff29" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">DBSCAN聚类</h1><p id="7182" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">DBSCAN(基于密度的含噪声应用程序空间聚类)是另一种流行的聚类技术，它将数据集划分为高密度区域。</p><h2 id="ab30" class="no lt iq bd lu np nq dn ly nr ns dp mc ko nt nu me ks nv nw mg kw nx ny mi nz bi translated">DBSCAN参数</h2><p id="7f5f" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">DBSCAN有两个主要参数</p><ol class=""><li id="e05b" class="mp mq iq kh b ki kj kl km ko mr ks ms kw mt la of mv mw mx bi translated"><strong class="kh ir">最小样本</strong>:形成密集区域或聚类的最小点数</li><li id="e0fd" class="mp mq iq kh b ki my kl mz ko na ks nb kw nc la of mv mw mx bi translated"><strong class="kh ir">ε</strong>:定义搜索附近邻居的半径</li></ol><h2 id="346d" class="no lt iq bd lu np nq dn ly nr ns dp mc ko nt nu me ks nv nw mg kw nx ny mi nz bi translated">DBSCAN聚类算法</h2><p id="cd40" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated"><strong class="kh ir">先决条件</strong>:定义ε的值和最小点数</p><p id="c817" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">步骤1 </strong> : <strong class="kh ir"> </strong>拾取数据集中的任意点</p><p id="eda8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">步骤2 </strong>:检查半径ε内该数据点周围的数据点数。如果数据点的数量至少是定义的最小样本大小，那么所有这些数据点被认为是在同一个聚类内。</p><p id="2bc2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">步骤3 </strong>:对所有数据点重复进行邻域计算</p><h2 id="8460" class="no lt iq bd lu np nq dn ly nr ns dp mc ko nt nu me ks nv nw mg kw nx ny mi nz bi translated">DBSCAN点</h2><p id="7be9" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">DBSCAN聚类完成后有三种类型的点。</p><ol class=""><li id="f215" class="mp mq iq kh b ki kj kl km ko mr ks ms kw mt la of mv mw mx bi translated"><strong class="kh ir">核心点</strong>:周围采样点数最少的数据点</li><li id="d29c" class="mp mq iq kh b ki my kl mz ko na ks nb kw nc la of mv mw mx bi translated"><strong class="kh ir">边界点</strong>:周围没有最小数量的采样点，但在半径ε内有一个核心点的数据点</li><li id="32cf" class="mp mq iq kh b ki my kl mz ko na ks nb kw nc la of mv mw mx bi translated"><strong class="kh ir">噪声点</strong>:既不是核心点也不是边界点的点。被视为数据中的异常值。</li></ol><h2 id="f8ec" class="no lt iq bd lu np nq dn ly nr ns dp mc ko nt nu me ks nv nw mg kw nx ny mi nz bi translated">Python中的DBSCAN聚类</h2><p id="67a6" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">Scipy包提供了包DBSCAN来执行这种基于密度的聚类。ε(EPS)和聚类中最小点数(min_samples)的值被用作函数中的参数。</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="oc ng l"/></div></figure><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi os"><img src="../Images/f104536ab34ecd43ae39afc8e98cd10d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AzpXatibVA17EWtjWqtD6Q.png"/></div></div><p class="ln lo gj gh gi lp lq bd b be z dk translated"><strong class="bd lr"> DBSCAN聚类总结</strong> (eps = 0.9，min_samples=5) —图片作者</p></figure><p id="2623" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">聚类值-1表示噪声点。在这个数据集中，对于eps和min_samples的给定值，有129个噪声点。其余的数据点被分成4组，如上面的分布所示。</p><h1 id="16c7" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">数据集和源代码</h1><p id="9edd" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">原始数据已从这里下载:<a class="ae ol" href="https://www.kaggle.com/patrickb1912/ipl-complete-dataset-20082020" rel="noopener ugc nofollow" target="_blank"> IPL原始数据</a> <a class="ae ol" href="https://www.kaggle.com/patrickb1912/ipl-complete-dataset-20082020" rel="noopener ugc nofollow" target="_blank"> <br/> </a>这包含了从2008年到2020年所有IPL比赛的逐球和比赛级别细节。</p><p id="af49" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Git路径:<a class="ae ol" href="https://github.com/Lakshmi-1212/IPL_PlayerClusters" rel="noopener ugc nofollow" target="_blank">https://github.com/Lakshmi-1212/IPL_PlayerClusters</a></p><h1 id="9c6a" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">摆弄配置</h1><p id="24cf" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">既然我们已经介绍了在数据上运行所有三种聚类算法的基础知识，我们就可以开始处理数据了，看看参与者是如何根据输入配置归入不同的聚类的。</p><p id="77d2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里我们已经使用ipywidgets在Jupyter笔记本上构建了UI。它易于使用，适合构建简单的ui。</p><p id="ea74" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">克隆GitHub repo，亲自体验一下吧！！</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi ot"><img src="../Images/7183cfa242e3c885acdbe309761aef37.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9Cil5g-DKKVQJP5kEzNi_g.png"/></div></div><p class="ln lo gj gh gi lp lq bd b be z dk translated"><strong class="bd lr">使用集群配置</strong></p></figure><h1 id="6c11" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">结论</h1><p id="f8b0" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">可以看到，我们可以试验不同的聚类技术，使用超参数来获得最佳模型。这里的目标仅限于理解不同类型的聚类，并将它们应用于cricket数据以获得一些有用的信息。</p><p id="e97a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦玩家被聚类，该数据可以进一步用于不同的目的。示例:教练可以使用它来为每个集群制定具体的策略，或者组建一个全面的团队。他们甚至可以在拍卖过程中使用这些信息来检查新玩家可能适合哪个集群。这样的例子不胜枚举:-)</p><p id="5c69" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir"> <em class="nk">实验&amp;边学边乐！！</em>T12】</strong></p></div></div>    
</body>
</html>