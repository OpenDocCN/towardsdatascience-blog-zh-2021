<html>
<head>
<title>How PostgreSQL aggregation works and how it inspired our hyperfunctions’ design</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">PostgreSQL聚合如何工作，以及它如何启发了我们的hyperfunctions设计</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-postgresql-aggregation-works-and-how-it-inspired-our-hyperfunctions-design-bb063cc874ee?source=collection_archive---------39-----------------------#2021-08-04">https://towardsdatascience.com/how-postgresql-aggregation-works-and-how-it-inspired-our-hyperfunctions-design-bb063cc874ee?source=collection_archive---------39-----------------------#2021-08-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/ea0e3a03aa4283c5a5f34cb04e19906c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*aIDlVCic8wjEWjB7.jpg"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">乔希·穆勒在<a class="ae kc" href="https://unsplash.com/photos/gq7CheNKrzc" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的图片</p></figure><p id="d2e4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb">获得关于PostgreSQL聚合的初级读本，PostgreSQL的实现如何启发我们构建TimescaleDB超函数及其与高级TimescaleDB功能的集成，以及这对开发人员意味着什么。</em></p><p id="556c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在时间尺度上，我们的目标是始终关注开发人员的体验，我们非常小心地设计我们的产品和API，使其对开发人员友好。我们相信，当我们的产品易于使用，并能为广大开发人员所用时，我们就能让他们解决各种不同的问题，从而构建解决大问题的解决方案。</p><p id="b50a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这种对开发人员体验的关注是我们在设计TimescaleDB的早期就决定在PostgreSQL 之上构建的原因。我们当时相信，就像现在一样，建立在世界上增长最快的数据库上将给我们的用户带来许多好处。</p><p id="8f02" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">也许这些优势中最大的是开发人员的生产力:开发人员可以使用他们了解和喜欢的工具和框架，并带来他们所有的SQL技能和专业知识。</p><p id="b341" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如今，有近300万个活跃的TimescaleDB数据库运行着各行各业的任务关键型时序工作负载。时间序列数据来得很快，有时每秒产生数百万个数据点(<a class="ae kc" href="https://blog.timescale.com/blog/what-the-heck-is-time-series-data-and-why-do-i-need-a-time-series-database-dcf3b1b18563/?utm_source=tds&amp;utm_medium=blog&amp;utm_campaign=hyperfunctions-1-0-2021&amp;utm_content=what-is-time-series-data" rel="noopener ugc nofollow" target="_blank">阅读更多关于时间序列数据的信息</a>)。由于信息量大，速度快，时间序列数据很难查询和分析。我们构建了TimescaleDB作为专门为时间序列构建的关系数据库，以降低复杂性，使开发人员可以专注于他们的应用程序。</p><p id="9e26" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我们以开发人员体验为核心，并不断发布功能来推进这一目标，包括<a class="ae kc" href="https://blog.timescale.com/blog/timescaledb-2-0-a-multi-node-petabyte-scale-completely-free-relational-database-for-time-series/?utm_source=tds&amp;utm_medium=blog&amp;utm_campaign=hyperfunctions-1-0-2021&amp;utm_content=timescaledb-2-0-blog" rel="noopener ugc nofollow" target="_blank">连续聚合、用户定义的操作、信息视图</a>，以及最近的<a class="ae kc" href="https://blog.timescale.com/blog/introducing-hyperfunctions-new-sql-functions-to-simplify-working-with-time-series-data-in-postgresql/?utm_source=tds&amp;utm_medium=blog&amp;utm_campaign=hyperfunctions-1-0-2021&amp;utm_content=hyperfunctions-announcement-blog" rel="noopener ugc nofollow" target="_blank">time scale db hyperfunctions</a>:time scale db中的一系列SQL函数，使得用更少的代码行在PostgreSQL中操作和分析时间序列数据变得更加容易。</p><p id="3792" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了确保我们在规划新的hyperfunctions功能时始终关注开发人员的体验，我们建立了一套“设计约束”来指导我们的开发决策。遵循这些准则可确保我们的API:</p><ul class=""><li id="f728" class="lc ld iq kf b kg kh kk kl ko le ks lf kw lg la lh li lj lk bi translated">在SQL语言中工作(没有新语法，只有函数和集合)</li><li id="6315" class="lc ld iq kf b kg ll kk lm ko ln ks lo kw lp la lh li lj lk bi translated">对于新的和有经验的SQL用户来说非常直观</li><li id="6425" class="lc ld iq kf b kg ll kk lm ko ln ks lo kw lp la lh li lj lk bi translated">仅对几行数据有用，对数十亿行数据具有高性能</li><li id="eade" class="lc ld iq kf b kg ll kk lm ko ln ks lo kw lp la lh li lj lk bi translated">很好地使用所有的TimescaleDB特性，理想情况下，让它们对用户更有用</li><li id="b4ed" class="lc ld iq kf b kg ll kk lm ko ln ks lo kw lp la lh li lj lk bi translated">使基本的事情变得简单，使更高级的分析成为可能</li></ul><p id="c0df" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这在实践中是什么样子的？在这篇文章中，我解释了这些约束如何使我们在整个TimescaleDB hyperfunctions中采用两步聚合，两步聚合如何与其他TimescaleDB特性交互，以及PostgreSQL的内部聚合API如何影响我们的实现。</p><p id="52fe" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们谈到两步聚合时，我们指的是以下调用约定:</p><figure class="lr ls lt lu gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lq"><img src="../Images/1d2354f35ae748ae0a01e7b317db9673.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*uTNddOgeXTOgORux.jpg"/></div></div></figure><p id="01af" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们有一个内在的集合调用:</p><figure class="lr ls lt lu gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lq"><img src="../Images/229940eb55541446bab748653c29ebf0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*fv-dOUu-hACPYgH3.jpg"/></div></div></figure><p id="78dc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">和一个外部访问器调用:</p><figure class="lr ls lt lu gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lq"><img src="../Images/7d19f4ac19cc53bd7bca5e4402426337.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*MJ_RaYh5mP74DAvf.jpg"/></div></div></figure><p id="6c2b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们选择了这种设计模式，而不是更常见(似乎更简单)的一步聚合方法，在这种方法中，一个函数封装了内部聚合和外部访问器的行为:</p><figure class="lr ls lt lu gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lv"><img src="../Images/b76017e0a5b60bd2bd67a636fbd317ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*HagFe3zIqV1nhc_z.jpg"/></div></div></figure><p id="6f5c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请继续阅读，了解为什么一步聚合方法在您开始做更复杂的事情(如将函数组合成更高级的查询)时会很快失效，以及几乎所有的PostgreSQL聚合都是如何执行两步聚合的。您将了解PostgreSQL实现如何启发我们构建TimescaleDB超函数、连续聚合和其他高级功能，以及这对开发人员意味着什么。</p><h1 id="c31a" class="lw lx iq bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">PostgreSQL聚合入门(通过图片)</h1><p id="1087" class="pw-post-body-paragraph kd ke iq kf b kg mu ki kj kk mv km kn ko mw kq kr ks mx ku kv kw my ky kz la ij bi translated">当我五六年前开始学习PostgreSQL时(我是一名电化学专家，处理大量的电池数据，正如我在<a class="ae kc" href="https://blog.timescale.com/blog/what-time-weighted-averages-are-and-why-you-should-care/?utm_source=tds&amp;utm_medium=blog&amp;utm_campaign=hyperfunctions-1-0-2021&amp;utm_content=time-weighted-averages" rel="noopener ugc nofollow" target="_blank">上一篇关于时间加权平均值的文章</a>中提到的)，我遇到了一些性能问题。我试图更好地了解数据库内部发生了什么，以提高其性能——这时候我通过图片找到了<a class="ae kc" href="https://momjian.us" rel="noopener ugc nofollow" target="_blank">布鲁斯·莫姆坚</a>关于<a class="ae kc" href="https://momjian.us/main/presentations/internals.html" rel="noopener ugc nofollow" target="_blank"> PostgreSQL内部的演讲。Bruce因其深刻的演讲(和他对领结的嗜好)而在社区中众所周知，他的会议对我来说是一个启示。</a></p><p id="c980" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从那以后，它们成了我理解PostgreSQL如何工作的基础。他把事情解释得非常清楚，当我能想象出正在发生的事情时，我总是学得最好，所以“通过图片”的部分真的帮助了我——并让我坚持下来。</p><p id="a46a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以下一点是我试图通过图片解释一些PostgreSQL的内部原理来引导Bruce。系好你的领结，准备学习吧。</p><figure class="lr ls lt lu gt jr gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/fb3b2c13f41fcc9639a68386a3bd7849.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/0*9IRfr6H7eBZ0kBoo"/></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">作者向Bruce Momjian致敬(看起来对自己相当满意，因为他第一次尝试就成功地打了一个领结)。作者大卫科恩的GIF。</p></figure><h1 id="1b99" class="lw lx iq bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">PostgreSQL聚合与函数</h1><p id="5336" class="pw-post-body-paragraph kd ke iq kf b kg mu ki kj kk mv km kn ko mw kq kr ks mx ku kv kw my ky kz la ij bi translated">我们已经写了关于如何使用定制函数和集合来扩展SQL的文章，但是我们还没有解释它们之间的区别。</p><p id="c803" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">SQL中聚合函数和“常规”函数的根本区别在于,<strong class="kf ir">聚合</strong>从相关行的<em class="lb">组</em>中产生一个结果，而常规<strong class="kf ir">函数</strong>为每行的<em class="lb">产生一个结果:</em></p><figure class="lr ls lt lu gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi na"><img src="../Images/468f36b5910beaef5372f3c051d4e0db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*0j3IxAh1m5MIlUyK"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">在SQL中，聚合从多行产生一个结果，而函数每行产生一个结果。作者图片</p></figure><p id="3e3f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这并不是说一个函数不能有来自多个列的输入；他们必须来自同一排。</p><p id="4a1b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另一种思考方式是，函数通常作用于行，而聚合作用于列。为了说明这一点，让我们考虑一个有两列的理论表<code class="fe nb nc nd ne b">foo</code>:</p><pre class="lr ls lt lu gt nf ne ng nh aw ni bi"><span id="2e97" class="nj lx iq ne b gy nk nl l nm nn">CREATE TABLE foo(<br/>	bar DOUBLE PRECISION,<br/>	baz DOUBLE PRECISION);</span></pre><p id="0738" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">只有几个值，所以我们可以很容易地看到发生了什么:</p><pre class="lr ls lt lu gt nf ne ng nh aw ni bi"><span id="71b6" class="nj lx iq ne b gy nk nl l nm nn">INSERT INTO foo(bar, baz) VALUES (1.0, 2.0), (2.0, 4.0), (3.0, 6.0);</span></pre><p id="b6fb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">函数<code class="fe nb nc nd ne b">greatest()</code>将为每行产生列<code class="fe nb nc nd ne b">bar</code>和<code class="fe nb nc nd ne b">baz</code>中的最大值:</p><pre class="lr ls lt lu gt nf ne ng nh aw ni bi"><span id="b039" class="nj lx iq ne b gy nk nl l nm nn">SELECT greatest(bar, baz) FROM foo; <br/> greatest <br/>----------<br/>        2<br/>        4<br/>        6</span></pre><p id="7be6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">而聚合<code class="fe nb nc nd ne b">max()</code>将从每一列中产生最大值:</p><pre class="lr ls lt lu gt nf ne ng nh aw ni bi"><span id="f677" class="nj lx iq ne b gy nk nl l nm nn">SELECT max(bar) as bar_max, max(baz) as baz_max FROM foo;<br/><br/> bar_max | baz_max <br/>---------+---------<br/>       3 |       6</span></pre><p id="d54b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用上面的数据，这里有一个当我们聚合一些东西时会发生什么的图片:</p><figure class="lr ls lt lu gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi no"><img src="../Images/eb256133ec59693552f367db11343a44.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*J4bQAC65sJGK4xew.jpg"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">“max()”聚合从多行中获取最大值。作者图片</p></figure><p id="0b10" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该聚合从多行中获取输入，并生成一个结果。这是它和函数的主要区别，但是它是怎么做到的呢？让我们看看它在引擎盖下做什么。</p><h1 id="4acb" class="lw lx iq bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">聚合内部:逐行</h1><p id="77f2" class="pw-post-body-paragraph kd ke iq kf b kg mu ki kj kk mv km kn ko mw kq kr ks mx ku kv kw my ky kz la ij bi translated">在后台，PostgreSQL中的聚合是逐行工作的。但是，聚合如何知道前面的行呢？</p><p id="8a33" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">好吧，一个聚合存储一些它以前看到的行的状态，当数据库看到新的行时，它更新内部状态。</p><p id="f998" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于我们一直在讨论的<code class="fe nb nc nd ne b">max()</code>集合，内部状态就是我们迄今为止收集到的最大值。</p><p id="113c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们一步一步来。</p><p id="9bdb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们开始时，我们的内部状态是<code class="fe nb nc nd ne b">NULL</code>，因为我们还没有看到任何行:</p><figure class="lr ls lt lu gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/e04087d3761f3a17e28ddf32e412d52c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*5c6S8V1yam6WfQnh.jpg"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">作者图片</p></figure><p id="1720" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们进入第一行:</p><figure class="lr ls lt lu gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/4885394e6e015c98662c3cd22e3bdd19.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*7q-rEeS08WM8uyHD.jpg"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">作者图片</p></figure><p id="051a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">由于我们的状态是<code class="fe nb nc nd ne b">NULL</code>，我们将其初始化为我们看到的第一个值:</p><figure class="lr ls lt lu gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/4e2c17a31d4116293f20a369d9df9b78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*k3-J1CAifiA0ev1r.jpg"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">作者图片</p></figure><p id="82da" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，我们得到第二行:</p><figure class="lr ls lt lu gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/76d39bc2ee7330189d4e5e3854a4e9c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*GCc7XPmvdDQULYwS.jpg"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">作者图片</p></figure><p id="32cf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们看到bar的值(2.0)大于我们当前的状态(1.0)，所以我们更新状态:</p><figure class="lr ls lt lu gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/5e63b71a682b2d1824084a53d17df975.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*e99VbbVinfpjDtwg.jpg"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">作者图片</p></figure><p id="4e38" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，下一行进入聚合:</p><figure class="lr ls lt lu gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/25b1ce68db63f8325eb3aa9f5c6131e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*xIQmrZ4_1Da97nw7.jpg"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">作者图片</p></figure><p id="e785" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将其与当前状态进行比较，取最大值，并更新我们的状态:</p><figure class="lr ls lt lu gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/dcf0d60e5f8d226c2efa3e0378fb0e70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*JIPy16-W7bO1zGQ8.jpg"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">作者图片</p></figure><p id="f007" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，我们没有更多要处理的行，所以我们输出结果:</p><figure class="lr ls lt lu gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/578d5a7a8393475dc28ddba367365001.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*fFK2rb7G9DD0O6R1.jpg"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">作者图片</p></figure><p id="1b2b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以，总结一下，每一行进来，与我们当前的状态进行比较，然后状态被更新以反映新的最大值。然后下一行进来，我们重复这个过程，直到我们处理完所有的行并输出结果。</p><figure class="lr ls lt lu gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi np"><img src="../Images/81ae6e84e4eb01f9eb15a862dbf947b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*Wj3l9D3yBouiYoO6Y69zlA.gif"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">最大聚集聚集过程，用gif表示。作者图片</p></figure><p id="252d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">处理每一行并更新内部状态的函数有一个名字:<a class="ae kc" href="https://www.postgresql.org/docs/current/sql-createaggregate.html" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">状态转换函数</strong> </a>(或者简称为“转换函数”)。)聚合的转换函数将当前状态和传入行中的值作为参数，并生成一个新状态。</p><p id="1d4a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它是这样定义的，其中<code class="fe nb nc nd ne b">current_value</code>表示来自传入行的值，<code class="fe nb nc nd ne b">current_state</code>表示在前面的行上构建的当前聚合状态(如果我们还没有得到任何值，则为NULL)，而<code class="fe nb nc nd ne b">next_state</code>表示分析传入行后的输出:</p><pre class="lr ls lt lu gt nf ne ng nh aw ni bi"><span id="52c0" class="nj lx iq ne b gy nk nl l nm nn">next_state = transition_func(current_state, current_value)</span></pre><h1 id="3bce" class="lw lx iq bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">聚集内部:复合状态</h1><p id="5c1a" class="pw-post-body-paragraph kd ke iq kf b kg mu ki kj kk mv km kn ko mw kq kr ks mx ku kv kw my ky kz la ij bi translated">因此，<code class="fe nb nc nd ne b">max()</code>聚合有一个简单的状态，只包含一个值(我们见过的最大值)。但并不是PostgreSQL中的所有聚合都有这样简单的状态。</p><p id="67fc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们考虑一下平均值的总数(<code class="fe nb nc nd ne b">avg</code>):</p><pre class="lr ls lt lu gt nf ne ng nh aw ni bi"><span id="d7c9" class="nj lx iq ne b gy nk nl l nm nn">SELECT avg(bar) FROM foo;</span></pre><p id="90c8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了刷新，平均值定义为:</p><p id="ae85" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">\ begin { equation } avg(x)= \ frac { sum(x)} { count(x)} \ end { equation }</p><p id="a15e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了计算它，我们将总和和计数存储为我们的内部状态，并在处理行时更新我们的状态:</p><figure class="lr ls lt lu gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi np"><img src="../Images/e91a919c8b7528406eed0e9712649785.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*FiHejOqsN0mSlJ0oG0auxA.gif"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">“avg()”聚合过程，用gif表示。对于“avg()”,转换函数必须更新更复杂的状态，因为sum和count在每个聚合步骤都是分开存储的。作者图片</p></figure><p id="5109" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是，当我们准备输出<code class="fe nb nc nd ne b">avg</code>的结果时，我们需要将<code class="fe nb nc nd ne b">sum</code>除以<code class="fe nb nc nd ne b">count</code>:</p><figure class="lr ls lt lu gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi no"><img src="../Images/6c57afe2bf03d722873216c538ab0ff9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*SAQChZWkwEZ026Zd.jpg"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">对于某些聚合，我们可以直接输出状态，但是对于其他聚合，我们需要在计算最终结果之前对状态执行操作。作者图片</p></figure><p id="75d7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">聚合内部还有另一个函数执行这个计算:最终函数<a class="ae kc" href="https://www.postgresql.org/docs/current/sql-createaggregate.html" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir">。一旦我们处理完所有的行，最后一个函数就会获取状态，并做任何需要的事情来产生结果。</strong></a></p><p id="e7d9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它是这样定义的，其中<code class="fe nb nc nd ne b">final_state</code>表示转换函数处理完所有行后的输出:</p><pre class="lr ls lt lu gt nf ne ng nh aw ni bi"><span id="1065" class="nj lx iq ne b gy nk nl l nm nn">result = final_func(final_state)</span></pre><p id="fa97" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">并且，通过图片:</p><figure class="lr ls lt lu gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi np"><img src="../Images/90d1d8c27ddeddb80c34a2948993dc09.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*NRUHwoVRWKVLL0AC4pmjmA.gif"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">平均总量是如何工作的，用gif来表示。这里，我们强调最后一个函数的作用。作者图片</p></figure><p id="b145" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">总结一下:当一个聚集扫描行时，它的<strong class="kf ir">转换函数</strong>更新它的内部状态。一旦聚合扫描了所有的行，它的<strong class="kf ir">最终函数</strong>就会产生一个结果，并返回给用户。</p><h1 id="2f76" class="lw lx iq bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">提高聚合函数的性能</h1><p id="33b1" class="pw-post-body-paragraph kd ke iq kf b kg mu ki kj kk mv km kn ko mw kq kr ks mx ku kv kw my ky kz la ij bi translated">这里要注意一件有趣的事情:transition函数被调用的次数比final函数多得多:每一行调用一次，而final函数每<em class="lb">组</em>行调用一次。</p><p id="3a59" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，在每次调用的基础上，转换函数本身并不比最终函数更昂贵，但是因为通常进入聚合的行数比出来的行数多几个数量级，所以转换函数步骤很快成为最昂贵的部分。当您以高速率摄取大量时间序列数据时，尤其如此；优化聚合转换函数调用对于提高性能非常重要。</p><p id="3057" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">幸运的是，PostgreSQL已经有了优化聚合的方法。</p><h1 id="02b8" class="lw lx iq bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">并行化和组合功能</h1><p id="fc68" class="pw-post-body-paragraph kd ke iq kf b kg mu ki kj kk mv km kn ko mw kq kr ks mx ku kv kw my ky kz la ij bi translated">因为转移函数是在每一行上运行的，<a class="ae kc" href="https://www.postgresql.org/message-id/flat/CA%2BTgmoYSL_97a--qAvdOa7woYamPFknXsXX17m0t2Pwc%2BFOvYw%40mail.gmail.com#fb9f2ae2a52ac605a4439a1879ff3c10" rel="noopener ugc nofollow" target="_blank">一些有进取心的PostgreSQL开发人员</a>问:<em class="lb">如果我们并行化转移函数计算会怎么样？</em></p><p id="cddd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们重温一下我们对转移函数和最终函数的定义:</p><pre class="lr ls lt lu gt nf ne ng nh aw ni bi"><span id="75c0" class="nj lx iq ne b gy nk nl l nm nn">next_state = transition_func(current_state, current_value)<br/><br/>result = final_func(final_state)</span></pre><p id="8a95" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以通过实例化转换函数的多个副本并将行的子集传递给每个实例来并行运行。然后，每个并行聚合将在其看到的行子集上运行转换函数，产生多个(部分)状态，每个并行聚合一个状态。但是，由于我们需要聚合整个<em class="lb">数据集，我们不能分别在每个并行聚合上运行最终函数，因为它们只有一些行。</em></p><p id="88ee" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以，现在我们已经陷入了一点困境:我们有多个部分聚合状态，而final函数只对单个最终状态起作用——就在我们将结果输出给用户之前。</p><p id="3a26" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了解决这个问题，我们需要一种新型的函数，它采用两个部分状态并将它们合并成一个状态，这样最终的函数就可以完成它的工作。这被(恰当地)称为<a class="ae kc" href="https://www.postgresql.org/docs/current/sql-createaggregate.html" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">合并功能</strong> </a>。</p><p id="f433" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以对并行化聚合时创建的所有部分状态迭代运行combine函数。</p><pre class="lr ls lt lu gt nf ne ng nh aw ni bi"><span id="b217" class="nj lx iq ne b gy nk nl l nm nn">combined_state = combine_func(partial_state_1, partial_state_2)</span></pre><p id="af98" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，在<code class="fe nb nc nd ne b">avg</code>中，组合功能会将计数和总和相加。</p><figure class="lr ls lt lu gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nq"><img src="../Images/7a73eece40f51e87b807bfd591350361.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*z-QzlQtPWLmOiF7Oe3K2LA.gif"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">并行聚合如何工作，用gif讲述。这里，我们突出显示了combine函数(我们添加了几行来说明并行聚合。)作者图片</p></figure><p id="59a1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，当我们从所有并行聚合中获得组合状态后，我们运行最终函数并获得结果。</p><h1 id="2945" class="lw lx iq bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">重复数据删除</h1><p id="b7df" class="pw-post-body-paragraph kd ke iq kf b kg mu ki kj kk mv km kn ko mw kq kr ks mx ku kv kw my ky kz la ij bi translated">并行化和组合函数是降低调用聚合成本的一种方法，但不是唯一的方法。</p><p id="b949" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">降低聚合成本的另一个内置PostgreSQL优化出现在如下语句中:</p><pre class="lr ls lt lu gt nf ne ng nh aw ni bi"><span id="403f" class="nj lx iq ne b gy nk nl l nm nn">SELECT avg(bar), avg(bar) / 2 AS half_avg FROM foo;</span></pre><p id="1c26" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">PostgreSQL将优化该语句，只对<code class="fe nb nc nd ne b">avg(bar)</code>计算求值一次，然后使用该结果两次。</p><p id="99d8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">并且，如果我们有不同的聚集，有相同的转移函数，但是不同的最终函数呢？PostgreSQL通过在所有行上调用转换函数(昂贵的部分),然后执行两个最终函数来进一步优化！相当整洁！</p><p id="5424" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，这不是PostgreSQL聚合所能做的全部，但这是一次很好的旅行，足以让我们今天到达我们需要去的地方。</p><h1 id="34f3" class="lw lx iq bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">时标超函数中的两步聚合</h1><p id="31e9" class="pw-post-body-paragraph kd ke iq kf b kg mu ki kj kk mv km kn ko mw kq kr ks mx ku kv kw my ky kz la ij bi translated">在TimescaleDB中，我们为聚合函数实现了两步聚合设计模式。这概括了PostgreSQL内部聚合API，并通过我们的聚合、访问器和汇总函数将其公开给用户。(换句话说，每个内部PostgreSQL函数在TimescaleDB hyperfunctions中都有一个等价的函数。)</p><p id="9908" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">作为复习，当我们谈论两步聚合设计模式时，我们指的是下面的约定，其中我们有一个内部聚合调用:</p><figure class="lr ls lt lu gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lq"><img src="../Images/93772066876f223fea99f2b0338c97ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*V4XimYPNfmu3W3-K.jpg"/></div></div></figure><p id="399a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">和一个外部访问器调用:</p><figure class="lr ls lt lu gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lq"><img src="../Images/da3967e910cfae29eaf489e43539fa21.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*pLAFm3GV6BdJxUub.jpg"/></div></div></figure><p id="c5fe" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">内部聚合调用返回内部状态，就像PostgreSQL聚合中的转换函数一样。</p><p id="9ffb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">外部访问器调用获取内部状态并将结果返回给用户，就像PostgreSQL中的final函数一样。</p><p id="5466" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还为每个聚合定义了特殊的<code class="fe nb nc nd ne b">rollup</code>函数<a class="ae kc" href="https://docs.timescale.com/api/latest/hyperfunctions/time-weighted-averages/rollup-timeweight/?utm_source=tds&amp;utm_medium=blog&amp;utm_campaign=hyperfunctions-1-0-2021&amp;utm_content=docs-time-weighted-averages" rel="noopener ugc nofollow" target="_blank">，其工作方式非常类似于PostgreSQL组合函数。</a></p><figure class="lr ls lt lu gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi no"><img src="../Images/83c36e8b74f7ec02036c789d3bee18f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*qRmD-I6k06_AJVj2.jpg"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">PostgreSQL内部聚合API及其TimescaleDB hyperfunctions的等效项。图片作者。</p></figure><h1 id="98a4" class="lw lx iq bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">为什么我们使用两步聚合设计模式</h1><p id="7f6a" class="pw-post-body-paragraph kd ke iq kf b kg mu ki kj kk mv km kn ko mw kq kr ks mx ku kv kw my ky kz la ij bi translated">我们向用户公开两步聚合设计模式，而不是将其作为内部结构，有四个基本原因:</p><ol class=""><li id="1a47" class="lc ld iq kf b kg kh kk kl ko le ks lf kw lg la nr li lj lk bi translated">允许多参数聚合重用状态，从而提高效率</li><li id="f234" class="lc ld iq kf b kg ll kk lm ko ln ks lo kw lp la nr li lj lk bi translated">清楚地区分影响聚合和访问器的参数，使性能含义更容易理解和预测</li><li id="10b7" class="lc ld iq kf b kg ll kk lm ko ln ks lo kw lp la nr li lj lk bi translated">在连续聚合和窗口函数(我们对连续聚合最常见的要求之一)中实现易于理解的汇总，并获得逻辑一致的结果</li><li id="bfa9" class="lc ld iq kf b kg ll kk lm ko ln ks lo kw lp la nr li lj lk bi translated">随着需求的变化，允许更容易的<em class="lb">追溯分析</em>连续聚合中的缩减采样数据，但是数据已经消失了</li></ol><p id="6227" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这有点理论性，所以让我们深入解释每一个。</p><h1 id="22e3" class="lw lx iq bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">重用状态</h1><p id="f69a" class="pw-post-body-paragraph kd ke iq kf b kg mu ki kj kk mv km kn ko mw kq kr ks mx ku kv kw my ky kz la ij bi translated">PostgreSQL非常擅长优化语句(正如我们在本文前面看到的，通过图片🙌)，但是你要用它能理解的方式给它东西。</p><p id="c6b1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，<a class="ae kc" href="https://blog.timescale.com/blog/how-postgresql-aggregation-works-and-how-it-inspired-our-hyperfunctions-design-2/?utm_source=tds&amp;utm_medium=blog&amp;utm_campaign=hyperfunctions-1-0-2021&amp;utm_content=how-aggregration-works-blog#deduplication" rel="noopener ugc nofollow" target="_blank">当我们谈到重复数据删除</a>时，我们看到PostgreSQL可以“发现”一个语句在查询中出现多次的情况(即<code class="fe nb nc nd ne b">avg(bar)</code>)，并且只运行该语句一次以避免重复工作:</p><pre class="lr ls lt lu gt nf ne ng nh aw ni bi"><span id="6122" class="nj lx iq ne b gy nk nl l nm nn">SELECT avg(bar), avg(bar) / 2 AS half_avg FROM foo;</span></pre><p id="f05c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是可行的，因为<code class="fe nb nc nd ne b">avg(bar)</code>出现多次而没有变化。</p><p id="bfa4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，如果我以稍微不同的方式写这个等式，并将圆括号内的除法<em class="lb">移到圆括号内，这样表达式<code class="fe nb nc nd ne b">avg(bar)</code>就不会那么整齐地重复，PostgreSQL <em class="lb">就不能</em>想出如何优化它:</em></p><pre class="lr ls lt lu gt nf ne ng nh aw ni bi"><span id="6482" class="nj lx iq ne b gy nk nl l nm nn">SELECT avg(bar), avg(bar / 2) AS half_avg FROM foo;</span></pre><p id="0970" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它不知道除法是可交换的，也不知道这两个查询是等价的。</p><p id="72c9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于数据库开发人员来说，这是一个需要解决的复杂问题，因此，作为PostgreSQL用户，您需要确保以数据库能够理解的方式编写查询。</p><p id="407c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">数据库不理解的等价语句导致的性能问题是相等的(或者在您编写的特定情况下相等，但在一般情况下不相等),这可能是用户需要解决的最棘手的SQL优化问题。</p><p id="4f4b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，<strong class="kf ir">当我们设计API时，我们试图让用户很难无意中编写低性能代码:换句话说，默认选项应该是高性能选项</strong>。</p><p id="aa39" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于下一点，将一个简单的表定义为以下内容会很有用:</p><pre class="lr ls lt lu gt nf ne ng nh aw ni bi"><span id="e4f2" class="nj lx iq ne b gy nk nl l nm nn">CREATE TABLE foo(<br/>	ts timestamptz, <br/>	val DOUBLE PRECISION);</span></pre><p id="80bf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们看一个例子，看看我们如何在百分位数近似超函数<a class="ae kc" href="https://docs.timescale.com/api/latest/hyperfunctions/percentile-approximation/?utm_source=tds&amp;utm_medium=blog&amp;utm_campaign=hyperfunctions-1-0-2021&amp;utm_content=docs-percentile-approximation" rel="noopener ugc nofollow" target="_blank">中使用两步聚合来允许PostgreSQL优化性能。</a></p><pre class="lr ls lt lu gt nf ne ng nh aw ni bi"><span id="cc59" class="nj lx iq ne b gy nk nl l nm nn">SELECT <br/>    approx_percentile(0.1, percentile_agg(val)) as p10, <br/>    approx_percentile(0.5, percentile_agg(val)) as p50, <br/>    approx_percentile(0.9, percentile_agg(val)) as p90 <br/>FROM foo;</span></pre><p id="a5a5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">…被视为等同于:</p><pre class="lr ls lt lu gt nf ne ng nh aw ni bi"><span id="d673" class="nj lx iq ne b gy nk nl l nm nn">SELECT <br/>    approx_percentile(0.1, pct_agg) as p10, <br/>    approx_percentile(0.5, pct_agg) as p50, <br/>    approx_percentile(0.9, pct_agg) as p90 <br/>FROM <br/>(SELECT percentile_agg(val) as pct_agg FROM foo) pct;</span></pre><p id="77f7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这种调用约定允许我们使用相同的聚合，因此，在后台，PostgreSQL可以对相同聚合的调用进行重复数据删除(因此速度更快)。</p><p id="e725" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，让我们将其与一步聚合方法进行比较。</p><p id="dab4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">PostgreSQL在这里无法对聚合调用进行重复数据删除，因为<code class="fe nb nc nd ne b">approx_percentile</code>聚合中的额外参数会随着每次调用而改变:</p><figure class="lr ls lt lu gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lq"><img src="../Images/97b3f9a38054363b42f36b7593796b87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*s_oGLeGziOF72zE4.jpg"/></div></div></figure><p id="7fdf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，即使所有这些函数都可以对所有行使用相同的近似值，PostgreSQL也无法知道。两步聚合方法使我们能够构建我们的调用，以便PostgreSQL可以优化我们的代码，并且它使开发人员能够了解什么时候东西会更贵，什么时候不会。具有不同输入的多个不同聚合的成本会很高，而对同一个聚合的多个访问器的成本会低得多。</p><h1 id="7aad" class="lw lx iq bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">清楚地区分聚合/访问器参数</h1><p id="e4c2" class="pw-post-body-paragraph kd ke iq kf b kg mu ki kj kk mv km kn ko mw kq kr ks mx ku kv kw my ky kz la ij bi translated">我们还选择了两步聚合方法，因为我们的一些聚合本身可以接受多个参数或选项，并且它们的访问器也可以接受选项:</p><pre class="lr ls lt lu gt nf ne ng nh aw ni bi"><span id="5a36" class="nj lx iq ne b gy nk nl l nm nn">SELECT<br/>    approx_percentile(0.5, uddsketch(1000, 0.001, val)) as median,--1000 buckets, 0.001 target err<br/>    approx_percentile(0.9, uddsketch(1000, 0.001, val)) as p90, <br/>    approx_percentile(0.5, uddsketch(100, 0.01, val)) as less_accurate_median -- modify the terms for the aggregate get a new approximation<br/>FROM foo;</span></pre><p id="058d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是一个<code class="fe nb nc nd ne b">uddsketch</code>的例子，一个<a class="ae kc" href="https://docs.timescale.com/api/latest/hyperfunctions/percentile-approximation/percentile-aggregation-methods/?utm_source=tds&amp;utm_medium=blog&amp;utm_campaign=hyperfunctions-1-0-2021&amp;utm_content=docs-hyperfunctions-perncentile-approx##choosing-the-right-algorithm-for-your-use-case" rel="noopener ugc nofollow" target="_blank">的高级聚集方法</a>，用于百分点近似值，可以采用自己的参数。</p><p id="24d3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">想象一下，如果这些参数混杂在一个集合中:</p><pre class="lr ls lt lu gt nf ne ng nh aw ni bi"><span id="aea9" class="nj lx iq ne b gy nk nl l nm nn">-- NB: THIS IS AN EXAMPLE OF AN API WE DECIDED NOT TO USE, IT DOES NOT WORK<br/>SELECT<br/>    approx_percentile(0.5, 1000, 0.001, val) as median<br/>FROM foo;</span></pre><p id="e391" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">很难理解哪个参数与功能的哪个部分相关。</p><p id="a50b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">相反，两步方法非常清楚地将访问器的参数与聚合的参数分开，其中聚合函数定义在最终函数输入的括号中:</p><pre class="lr ls lt lu gt nf ne ng nh aw ni bi"><span id="b6fa" class="nj lx iq ne b gy nk nl l nm nn">SELECT<br/>    approx_percentile(0.5, uddsketch(1000, 0.001, val)) as median<br/>FROM foo;</span></pre><p id="997b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通过明确哪个是哪个，用户可以知道，如果他们改变聚集的输入，他们将获得更多(昂贵的)聚集节点，而访问器的输入改变起来更便宜。</p><p id="ee2d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以，这是我们公开API的前两个原因——以及它允许开发人员做的事情。最后两个原因涉及连续聚集以及它们如何与超功能相关，所以首先，快速复习一下它们是什么。</p><h1 id="ab40" class="lw lx iq bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">两步聚合+时标连续聚合b</h1><p id="84af" class="pw-post-body-paragraph kd ke iq kf b kg mu ki kj kk mv km kn ko mw kq kr ks mx ku kv kw my ky kz la ij bi translated">TimescaleDB包括一个名为<a class="ae kc" href="https://docs.timescale.com/timescaledb/latest/how-to-guides/continuous-aggregates/?utm_source=tds&amp;utm_medium=blog&amp;utm_campaign=hyperfunctions-1-0-2021&amp;utm_content=docs-continuous-aggs" rel="noopener ugc nofollow" target="_blank">连续聚合</a>的特性，旨在使大型数据集上的查询运行得更快。TimescaleDB continuous聚合在后台连续并增量地存储聚合查询的结果，因此当您运行该查询时，只需要计算已更改的数据，而不是整个数据集。</p><p id="cfdd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面对组合函数<a class="ae kc" href="https://blog.timescale.com/blog/how-postgresql-aggregation-works-and-how-it-inspired-our-hyperfunctions-design-2/#deduplication" rel="noopener ugc nofollow" target="_blank">、</a>的讨论中，我们介绍了如何在每行上计算转换函数，并在多个并行聚合上拆分行，以加快计算速度。</p><p id="2193" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">TimescaleDB连续聚合做一些类似的事情，除了它们将计算工作分布在<em class="lb">时间</em>上，而不是在同时运行的并行进程之间。连续聚合对过去某个时间插入的行子集计算转换函数，存储结果，然后在查询时，我们只需要计算最近一小段时间的原始数据，我们还没有计算这些数据。</p><p id="4d8d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们设计TimescaleDB hyperfunctions时，我们希望它们能够在连续聚合中很好地工作，甚至为用户开辟新的可能性。</p><p id="9cd9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">假设我从上面的简单表格中创建了一个连续聚合，以15分钟为增量计算总和、平均值和百分比(后者使用了一个超函数):</p><pre class="lr ls lt lu gt nf ne ng nh aw ni bi"><span id="823b" class="nj lx iq ne b gy nk nl l nm nn">CREATE MATERIALIZED VIEW foo_15_min_agg<br/>WITH (timescaledb.continuous)<br/>AS SELECT id,<br/>    time_bucket('15 min'::interval, ts) as bucket,<br/>    sum(val),<br/>    avg(val),<br/>    percentile_agg(val)<br/>FROM foo<br/>GROUP BY id, time_bucket('15 min'::interval, ts);</span></pre><p id="d40a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我回来后想将数据重新聚合到小时或天，而不是15分钟，或者需要聚合所有id的数据，该怎么办？我可以为哪些集合这样做，哪些不可以？</p><h1 id="9001" class="lw lx iq bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">逻辑一致的汇总</h1><p id="3e24" class="pw-post-body-paragraph kd ke iq kf b kg mu ki kj kk mv km kn ko mw kq kr ks mx ku kv kw my ky kz la ij bi translated">我们希望通过两步聚合解决的一个问题是，如何向用户传达何时可以重新聚合，何时不可以。(所谓“好的”，我的意思是从重新聚合的数据中得到的结果与直接在原始数据上运行聚合得到的结果是一样的。)</p><p id="4aea" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如:</p><pre class="lr ls lt lu gt nf ne ng nh aw ni bi"><span id="6dbe" class="nj lx iq ne b gy nk nl l nm nn">SELECT sum(val) FROM tab;<br/>-- is equivalent to:<br/>SELECT sum(sum) <br/>FROM <br/>    (SELECT id, sum(val) <br/>    FROM tab<br/>    GROUP BY id) s;</span></pre><p id="7d38" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是:</p><pre class="lr ls lt lu gt nf ne ng nh aw ni bi"><span id="4fcf" class="nj lx iq ne b gy nk nl l nm nn">SELECT avg(val) FROM tab;<br/>-- is NOT equivalent to:<br/>SELECT avg(avg) <br/>FROM <br/>    (SELECT id, avg(val) <br/>    FROM tab<br/>    GROUP BY id) s;</span></pre><p id="c1f9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为什么重新聚合对<code class="fe nb nc nd ne b">sum</code>可以，对<code class="fe nb nc nd ne b">avg</code>不行？</p><p id="b1c1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从技术上讲，在以下情况下重新聚合在逻辑上是一致的:</p><ul class=""><li id="8eec" class="lc ld iq kf b kg kh kk kl ko le ks lf kw lg la lh li lj lk bi translated">聚合返回内部聚合状态。<code class="fe nb nc nd ne b">sum</code>的内部聚集状态是<code class="fe nb nc nd ne b">(sum)</code>，而对于平均而言，是<code class="fe nb nc nd ne b">(sum, count)</code>。</li><li id="12f3" class="lc ld iq kf b kg ll kk lm ko ln ks lo kw lp la lh li lj lk bi translated">集合的组合和转移函数是等价的。对于<code class="fe nb nc nd ne b">sum()</code>，状态和操作相同。对于<code class="fe nb nc nd ne b">count()</code>，状态<em class="lb">与状态</em>相同，但是转换和组合功能<em class="lb">对它们执行不同的操作</em>。<code class="fe nb nc nd ne b">sum()</code>的transition函数将传入的值添加到状态中，它的combine函数将两个状态相加，或者相加。相反地，<code class="fe nb nc nd ne b">count()</code> s转换函数为每个输入值增加状态，但是它的组合函数将两个状态相加，或者是计数的和。</li></ul><p id="582b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是，您必须对每个聚合的内部有深入的(有时甚至是晦涩的)了解，才能知道哪些符合上述标准，从而知道哪些可以重新聚合。</p><p id="f8fd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">使用两步聚合方法，当聚合允许时，我们可以通过公开组合函数的等价物来传达重新聚合在逻辑上是一致的。</strong></p><p id="0b39" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们称这个函数为<code class="fe nb nc nd ne b">rollup()</code>。<code class="fe nb nc nd ne b">Rollup()</code>从聚合中获取多个输入，并将它们组合成一个值。</p><p id="8bce" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们所有可以组合的聚合都有<code class="fe nb nc nd ne b">rollup</code>函数，该函数将组合来自两组不同行的聚合输出。(从技术上讲，<code class="fe nb nc nd ne b">rollup()</code>是一个聚合函数，因为它作用于多行。为了清楚起见，我将它们称为rollup函数，以区别于基本聚合)。然后就可以在组合输出上调用访问器了！</p><p id="d9cc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，使用我们创建的连续聚合来获得我们的<code class="fe nb nc nd ne b">percentile_agg</code>的1天重新聚合变得简单如:</p><pre class="lr ls lt lu gt nf ne ng nh aw ni bi"><span id="1871" class="nj lx iq ne b gy nk nl l nm nn">SELECT id, <br/>    time_bucket('1 day'::interval, bucket) as bucket, <br/>    approx_percentile(0.5, rollup(percentile_agg)) as median<br/>FROM foo_15_min_agg<br/>GROUP BY id, time_bucket('1 day'::interval, bucket);</span></pre><p id="5912" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">(正是因为这个原因，我们实际上建议您在不调用访问器函数的情况下创建连续聚合。然后，您可以在上面创建视图或将访问器调用放入您的查询中)。</p><p id="24bd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这就引出了我们的最后一个原因。</p><h1 id="96f0" class="lw lx iq bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">使用连续总量的回顾性分析</h1><p id="24e3" class="pw-post-body-paragraph kd ke iq kf b kg mu ki kj kk mv km kn ko mw kq kr ks mx ku kv kw my ky kz la ij bi translated">当我们创建一个连续的聚合时，我们定义了一个我们的数据视图，然后我们可能会坚持很长一段时间。</p><p id="a406" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可能有一个在X时间段后删除底层数据的数据保留策略。如果我们想要返回并重新计算任何东西，即使不是不可能，也是具有挑战性的，因为我们已经“丢弃”了数据。</p><p id="38cb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是，我们知道在现实世界中，你并不总是提前知道你需要分析什么。</p><p id="8332" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我们设计了使用两步聚合方法的超功能，因此它们可以更好地与连续聚合集成。因此，用户将聚集状态存储在连续聚集视图中，并修改访问器函数<em class="lb">，而不需要</em>要求他们重新计算可能难以(或不可能)重建的旧状态(因为数据被存档、删除等)。).</p><p id="8be8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">两步聚合设计还为连续聚合提供了更大的灵活性。例如，让我们来看一个连续聚合，其中我们执行两步聚合的聚合部分，如下所示:</p><pre class="lr ls lt lu gt nf ne ng nh aw ni bi"><span id="9169" class="nj lx iq ne b gy nk nl l nm nn">CREATE MATERIALIZED VIEW foo_15_min_agg<br/>WITH (timescaledb.continuous)<br/>AS SELECT id,<br/>    time_bucket('15 min'::interval, ts) as bucket,<br/>    percentile_agg(val)<br/>FROM foo<br/>GROUP BY id, time_bucket('15 min'::interval, ts);</span></pre><p id="a481" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们第一次创建聚合时，我们可能只想得到中位数:</p><pre class="lr ls lt lu gt nf ne ng nh aw ni bi"><span id="23aa" class="nj lx iq ne b gy nk nl l nm nn">SELECT<br/>    approx_percentile(0.5, percentile_agg) as median<br/>FROM foo_15_min_agg;</span></pre><p id="f617" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是后来，我们决定也想知道第95百分位。</p><p id="c246" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">幸运的是，我们不必修改连续集合；我们<strong class="kf ir">只需修改原始查询中访问器函数的参数，以从聚合状态</strong>返回我们想要的数据:</p><pre class="lr ls lt lu gt nf ne ng nh aw ni bi"><span id="42e0" class="nj lx iq ne b gy nk nl l nm nn">SELECT<br/>    approx_percentile(0.5, percentile_agg) as median,<br/>    approx_percentile(0.95, percentile_agg) as p95<br/>FROM foo_15_min_agg;</span></pre><p id="bd8c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，如果一年后，我们也想要第99百分位，我们也可以这样做:</p><pre class="lr ls lt lu gt nf ne ng nh aw ni bi"><span id="ad60" class="nj lx iq ne b gy nk nl l nm nn">SELECT<br/>    approx_percentile(0.5, percentile_agg) as median,<br/>    approx_percentile(0.95, percentile_agg) as p95,<br/>    approx_percentile(0.99, percentile_agg) as p99<br/>FROM foo_15_min_agg;</span></pre><p id="d172" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那只是触及表面。最终，我们的目标是提高开发人员的工作效率，增强PostgreSQL和TimescaleDB的其他功能，如聚合重复数据删除和连续聚合。</p><h1 id="9204" class="lw lx iq bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">两步聚合设计如何影响hyperfunctions代码的示例</h1><p id="b936" class="pw-post-body-paragraph kd ke iq kf b kg mu ki kj kk mv km kn ko mw kq kr ks mx ku kv kw my ky kz la ij bi translated">为了说明两步聚合设计模式如何影响我们对超函数的思考和编码，让我们看看<a class="ae kc" href="https://docs.timescale.com/api/latest/hyperfunctions/time-weighted-averages/?utm_source=tds&amp;utm_medium=blog&amp;utm_campaign=hyperfunctions-1-0-2021&amp;utm_content=docs-time-weighted-averages" rel="noopener ugc nofollow" target="_blank">时间加权平均函数族</a>。(我们的<a class="ae kc" href="https://blog.timescale.com/blog/what-time-weighted-averages-are-and-why-you-should-care/?utm_source=tds&amp;utm_medium=blog&amp;utm_campaign=hyperfunctions-1-0-2021&amp;utm_content=blog-time-weighted-averages" rel="noopener ugc nofollow" target="_blank">什么是时间加权平均值，为什么你应该关心这个问题</a>帖子为下一点提供了很多背景知识，所以如果你还没有阅读它，我们建议你阅读它。你也可以暂时跳过这一步。)</p><p id="9ba1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">时间加权平均值的计算公式如下:</p><p id="d90b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">\ begin { equation } time \ _ weighted \ _ average = \ frac { area \ _ under \ _ curve } \ end { equation }</p><p id="8823" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如我们在上述的<a class="ae kc" href="https://blog.timescale.com/blog/how-postgresql-aggregation-works-and-how-it-inspired-our-hyperfunctions-design-2/#agg-table" rel="noopener ugc nofollow" target="_blank">表中所指出的:</a></p><ul class=""><li id="162f" class="lc ld iq kf b kg kh kk kl ko le ks lf kw lg la lh li lj lk bi translated"><code class="fe nb nc nd ne b">time_weight()</code>是TimescaleDB hyperfunctions的聚合，对应于PostgreSQL内部API中的transition函数。</li><li id="b36d" class="lc ld iq kf b kg ll kk lm ko ln ks lo kw lp la lh li lj lk bi translated"><code class="fe nb nc nd ne b">average()</code>是访问器，对应PostgreSQL final函数。</li><li id="e1c1" class="lc ld iq kf b kg ll kk lm ko ln ks lo kw lp la lh li lj lk bi translated"><code class="fe nb nc nd ne b">rollup()</code> for re-aggregation对应于PostgreSQL的combine函数。</li></ul><p id="29e4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe nb nc nd ne b">time_weight()</code>函数返回一个集合类型，该集合类型必须可供该系列中的其他函数使用。</p><p id="6e3b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这种情况下，我们决定使用一个<code class="fe nb nc nd ne b">TimeWeightSummary</code>类型，它是这样定义的(用伪代码):</p><pre class="lr ls lt lu gt nf ne ng nh aw ni bi"><span id="858f" class="nj lx iq ne b gy nk nl l nm nn">TimeWeightSummary = (w_sum, first_pt, last_pt)</span></pre><p id="847a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe nb nc nd ne b">w_sum</code>是加权和(曲线下面积的另一个名称)，而<code class="fe nb nc nd ne b">first_pt</code>和<code class="fe nb nc nd ne b">last_pt</code>是进入<code class="fe nb nc nd ne b">time_weight()</code>聚合的行中的第一个和最后一个(时间，值)对。</p><p id="e73f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是这些元素的图形描述，它建立在我们的<a class="ae kc" href="https://blog.timescale.com/blog/what-time-weighted-averages-are-and-why-you-should-care/#mathy-bits-how-to-derive-a-time-weighted-average" rel="noopener ugc nofollow" target="_blank">如何导出时间加权平均理论描述</a>的基础上:</p><figure class="lr ls lt lu gt jr gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/f0c0e184dba143d56944231cd360fb6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1384/format:webp/0*kM6sa4oopVQlOfwL.jpg"/></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">我们存储在“TimeWeightSummary”表示中的值的描述。图片作者。</p></figure><p id="039c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，<code class="fe nb nc nd ne b">time_weight()</code>聚合在接收我们图表中的每个点时进行所有的计算，并为它“看到”的第一个和最后一个点之间的时间段(δT)构建一个加权和然后输出<code class="fe nb nc nd ne b">TimeWeightSummary</code>。</p><p id="85d9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe nb nc nd ne b">average()</code>访问器函数执行简单的计算，从<code class="fe nb nc nd ne b">TimeWeightSummary</code>返回时间加权平均值(在伪代码中，其中<code class="fe nb nc nd ne b">pt.time()</code>从该点返回时间):</p><pre class="lr ls lt lu gt nf ne ng nh aw ni bi"><span id="4245" class="nj lx iq ne b gy nk nl l nm nn">func average(TimeWeightSummary tws) <br/>	-&gt; float {<br/>		delta_t = tws.last_pt.time - tws.first_pt.time;<br/>		time_weighted_average = tws.w_sum / delta_t;<br/>		return time_weighted_average;<br/>	}</span></pre><p id="b300" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是，当我们构建<code class="fe nb nc nd ne b">time_weight</code> hyperfunction时，确保<code class="fe nb nc nd ne b">rollup()</code>函数按预期工作变得更加困难——并且引入了影响我们的<code class="fe nb nc nd ne b">TimeWeightSummary</code>数据类型设计的约束。</p><p id="a7bf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了理解rollup函数，让我们使用我们的图形示例，想象一下<code class="fe nb nc nd ne b">time_weight()</code>函数从不同的时间区域返回两个<code class="fe nb nc nd ne b">TimeWeightSummaries</code>，如下所示:</p><figure class="lr ls lt lu gt jr gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/9c8cec3df9bb07af99096980fe659441.png" data-original-src="https://miro.medium.com/v2/resize:fit:1344/format:webp/0*TzqKrL31fKtcXXRM.jpg"/></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">当我们有多个“TimeWeightSummaries”代表图形的不同区域时会发生什么？图片作者。</p></figure><p id="ba51" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe nb nc nd ne b">rollup()</code>函数需要接受并返回相同的<code class="fe nb nc nd ne b">TimeWeightSummary</code>数据类型，以便我们的<code class="fe nb nc nd ne b">average()</code>访问器能够理解它。(这反映了PostgreSQL的combine函数如何从transition函数接收两个状态，然后返回一个状态供最终函数处理)。</p><p id="e64f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还希望<code class="fe nb nc nd ne b">rollup()</code>的输出与我们对所有底层数据计算<code class="fe nb nc nd ne b">time_weight()</code>的输出相同。输出应该是代表整个区域的<code class="fe nb nc nd ne b">TimeWeightSummary</code>。</p><p id="380e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们输出的<code class="fe nb nc nd ne b">TimeWeightSummary</code>还应考虑这两个加权和状态之间的间隙面积:</p><figure class="lr ls lt lu gt jr gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/07001738d45537f88d1206213f607e32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1326/format:webp/0*FxuQxCaAny1fE24W.jpg"/></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">小心空隙！(在一个“TimeWeightSummary”和下一个之间)。图片作者。</p></figure><p id="fa1a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">差距区域很容易获得，因为我们有最后1个点和前2个点，这与我们通过对它们运行<code class="fe nb nc nd ne b">time_weight()</code>聚合获得的<code class="fe nb nc nd ne b">w_sum</code>相同。</p><p id="076e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，整个<code class="fe nb nc nd ne b">rollup()</code>函数需要做这样的事情(其中<code class="fe nb nc nd ne b">w_sum()</code>从<code class="fe nb nc nd ne b">TimeWeightSummary</code>中提取加权和):</p><pre class="lr ls lt lu gt nf ne ng nh aw ni bi"><span id="aa2f" class="nj lx iq ne b gy nk nl l nm nn">func rollup(TimeWeightSummary tws1, TimeWeightSummary tws2) <br/>	-&gt; TimeWeightSummary {<br/>		w_sum_gap = time_weight(tws1.last_pt, tws2.first_pt).w_sum;<br/>		w_sum_total = w_sum_gap + tws1.w_sum + tws2.w_sum;<br/>		return TimeWeightSummary(w_sum_total, tws1.first_pt, tws2.last_pt);<br/>	}</span></pre><p id="fd79" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从图形上看，这意味着我们将以一个代表整个区域的<code class="fe nb nc nd ne b">TimeWeightSummary</code>结束:</p><figure class="lr ls lt lu gt jr gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/3dd820ad41077e995cd09bc561e8efa9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1344/format:webp/0*bJRJNJ5JiJfc-SkH.jpg"/></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">合起来<code class="fe nb nc nd ne b">TimeWeightSummary</code>。图片作者。</p></figure><p id="f54a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这就是两步总体设计方法最终如何影响我们的时间加权平均超函数的现实世界实施。上面的解释有点浓缩，但是它们应该让您更具体地了解<code class="fe nb nc nd ne b">time_weight()</code>聚合、<code class="fe nb nc nd ne b">average()</code>访问器和<code class="fe nb nc nd ne b">rollup()</code>函数是如何工作的。</p></div><div class="ab cl nv nw hu nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="ij ik il im in"><h1 id="9464" class="lw lx iq bd ly lz oc mb mc md od mf mg mh oe mj mk ml of mn mo mp og mr ms mt bi translated">总结一下</h1><p id="e5a9" class="pw-post-body-paragraph kd ke iq kf b kg mu ki kj kk mv km kn ko mw kq kr ks mx ku kv kw my ky kz la ij bi translated">现在，您已经了解了PostgreSQL聚合API，它是如何启发我们开发TimescaleDB hyperfunctions两步聚合API的，以及它在实践中如何工作的几个示例，我们希望您亲自尝试一下，并告诉我们您的想法:)。</p><p id="8254" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">如果你想马上开始使用hyperfunctions，</strong> <a class="ae kc" href="https://console.forge.timescale.com/signup/?utm_source=tds&amp;utm_medium=blog&amp;utm_campaign=hyperfunctions-1-0-2021&amp;utm_content=forge-console-signup" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">启动一个完全托管的TimescaleDB服务并免费试用</strong> </a> <strong class="kf ir">。在时标Forge上，每个新的数据库服务都预装了Hyperfunctions，所以在你创建一个新的服务之后，你就可以使用它们了！</strong></p><p id="d9fc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">如果你喜欢管理自己的数据库实例，你可以</strong> <a class="ae kc" href="https://github.com/timescale/timescaledb-toolkit" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">下载并在GitHub上安装timescaledb_toolkit扩展</strong> </a>，之后你就可以使用<code class="fe nb nc nd ne b">time_weight</code>和所有其他的超功能了。</p><p id="22f4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">如果您对这篇博客文章有任何问题或评论，</strong> <a class="ae kc" href="https://github.com/timescale/timescaledb-toolkit/discussions/196" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">我们已经在GitHub页面上开始了讨论，我们希望收到您的回复</strong> </a>。</p><p id="e0dc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们喜欢在公共场合进行构建，你可以在GitHub 上查看我们<a class="ae kc" href="https://github.com/timescale/timescaledb-toolkit" rel="noopener ugc nofollow" target="_blank">即将发布的路线图，以获得提议的功能、我们当前正在实现的功能以及今天可以使用的功能的列表。作为参考，两步聚集体方法不仅仅用在这里讨论的稳定超函数中；它也用于我们的许多实验功能，包括</a></p><ul class=""><li id="f7be" class="lc ld iq kf b kg kh kk kl ko le ks lf kw lg la lh li lj lk bi translated"><code class="fe nb nc nd ne b">stats_agg()</code>使用两步聚合使简单的统计聚合，如平均值和标准差，更容易在连续聚合中工作，并<a class="ae kc" href="https://github.com/timescale/timescaledb-toolkit/blob/main/docs/rolling_average_api_working.md" rel="noopener ugc nofollow" target="_blank">简化滚动平均值的计算</a>。</li><li id="5c33" class="lc ld iq kf b kg ll kk lm ko ln ks lo kw lp la lh li lj lk bi translated"><code class="fe nb nc nd ne b"><a class="ae kc" href="https://github.com/timescale/timescaledb-toolkit/blob/main/docs/counter_agg.md" rel="noopener ugc nofollow" target="_blank">counter_agg()</a></code>使用两步聚合来提高计数器的工作效率和可组合性。</li><li id="c99f" class="lc ld iq kf b kg ll kk lm ko ln ks lo kw lp la lh li lj lk bi translated"><code class="fe nb nc nd ne b"><a class="ae kc" href="https://github.com/timescale/timescaledb-toolkit/blob/main/docs/hyperloglog.md" rel="noopener ugc nofollow" target="_blank">Hyperloglog</a></code>将两步聚合与连续聚合结合使用，为用户提供更长时间内更快的近似<code class="fe nb nc nd ne b">COUNT DISTINCT</code>汇总。</li></ul><p id="2f28" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这些功能将很快稳定下来，但我们希望在API仍在发展的时候收到您的反馈。什么会让它们更直观？比较好用？<a class="ae kc" href="https://github.com/timescale/timescaledb-toolkit/issues" rel="noopener ugc nofollow" target="_blank">提出问题</a>或<a class="ae kc" href="https://github.com/timescale/timescaledb-toolkit/discussions" rel="noopener ugc nofollow" target="_blank">开始讨论</a>！</p></div><div class="ab cl nv nw hu nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="ij ik il im in"><p id="21b3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb">原载于2021年8月4日https://blog.timescale.com</em><a class="ae kc" href="https://blog.timescale.com/blog/how-postgresql-aggregation-works-and-how-it-inspired-our-hyperfunctions-design-2/" rel="noopener ugc nofollow" target="_blank"><em class="lb"/></a><em class="lb">。</em></p></div></div>    
</body>
</html>