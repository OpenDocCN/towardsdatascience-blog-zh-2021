<html>
<head>
<title>A Guide for Optimizing Your Data Science Workflow</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">优化数据科学工作流程的指南</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/part-1-a-guide-for-optimizing-your-data-science-workflow-53add6481556?source=collection_archive---------20-----------------------#2021-08-31">https://towardsdatascience.com/part-1-a-guide-for-optimizing-your-data-science-workflow-53add6481556?source=collection_archive---------20-----------------------#2021-08-31</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="de17" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/hands-on-tutorials" rel="noopener" target="_blank">实践教程</a>，生产力</h2><div class=""/><div class=""><h2 id="82e3" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">第1部分:用这些提高工作效率的技巧来强化你的工作流程。从Jupyter笔记本到Python文件和模块。</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/88c43ad660fa8111ce6a2ebba1143518.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PlSHWoi09uC2dHBejP0j_g.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">作者图片</p></figure><p id="7764" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">本指南由两部分组成。我建议要么喝着咖啡跟着它走，要么一大块一大块地反复阅读，因为我会以<em class="ma">的令人麻木的</em>细节来回顾工作流程中的四个步骤，这样你就可以拿起它，定制它，让它成为你自己的。如果您对某一部分感兴趣，可以随意点击它向前跳(仅适用于桌面)。为此，我将从头到尾给出一个目录。</p><p id="0276" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">为了简洁起见，在这篇文章中我们将只讨论前两步，</p><p id="0f83" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated"><a class="ae mb" href="#ef9c" rel="noopener ugc nofollow"> <strong class="lg ja"> <em class="ma">第一步:</em> </strong> <em class="ma"> Jupyter笔记本</em></a><strong class="lg ja"><em class="ma"><br/></em></strong><a class="ae mb" href="#fb90" rel="noopener ugc nofollow"><strong class="lg ja"><em class="ma">第二步:</em> </strong> <em class="ma"> Python文件&amp;模块</em> </a></p><p id="cf56" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">建立工作流程是一件可怕的事情。没有一种解决方案适合所有人。从<a class="ae mb" href="https://thenewstack.io/spaces-vs-tabs-a-20-year-debate-and-now-this-what-the-hell-is-wrong-with-go/" rel="noopener ugc nofollow" target="_blank">制表符vs空格</a>开始，开发人员对他们的设置很挑剔，并对其他人的想法有强烈的意见。在这篇文章中，我回顾了如何优化我的工作流程。即使这不符合你的需要，你也可以把它的一点一滴收集起来，用你自己独特的方式组合起来。在一天结束的时候，开发人员的流动和生产力很重要，你应该努力去实现它。</p><p id="16b3" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">VS代码将用于设置工作流。尽管本文是针对VS代码的，但是您也可以将相同的思想应用到其他IDE中。</p></div><div class="ab cl mc md hu me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ij ik il im in"><h1 id="6c43" class="mj mk iq bd ml mm mn mo mp mq mr ms mt kf mu kg mv ki mw kj mx kl my km mz na bi translated">两个工作流程</h1><p id="750e" class="pw-post-body-paragraph le lf iq lg b lh nb ka lj lk nc kd lm ln nd lp lq lr ne lt lu lv nf lx ly lz ij bi translated">典型的数据科学工作流程始于在Jupyter笔记本上开发代码和构建代码原型，然后将其转移到python文件和模块中。</p><h2 id="59d4" class="ng mk iq bd ml nh ni dn mp nj nk dp mt ln nl nm mv lr nn no mx lv np nq mz iw bi translated">大团队</h2><p id="3271" class="pw-post-body-paragraph le lf iq lg b lh nb ka lj lk nc kd lm ln nd lp lq lr ne lt lu lv nf lx ly lz ij bi translated">如果你在一个大团队中工作，你的工作到此结束，你把你的代码交给开发人员，他们负责应用程序的归档和部署。</p><p id="1cb9" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated"><strong class="lg ja"> <em class="ma">数据科学家:</em> </strong> <em class="ma">笔记本→ Python文件/模块<br/> </em> <strong class="lg ja"> <em class="ma">开发运营:</em> </strong> <em class="ma"> Python文件/模块→ Dockerize →部署</em></p><h2 id="33a0" class="ng mk iq bd ml nh ni dn mp nj nk dp mt ln nl nm mv lr nn no mx lv np nq mz iw bi translated"><strong class="ak">中小型团队/副业项目</strong></h2><p id="b7db" class="pw-post-body-paragraph le lf iq lg b lh nb ka lj lk nc kd lm ln nd lp lq lr ne lt lu lv nf lx ly lz ij bi translated">但是如果你在一个中小型团队中工作，或者在你的副业项目中工作，你需要将你的应用程序dockerize并自己部署它。</p><p id="72d0" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated"><strong class="lg ja"> <em class="ma">数据科学家:</em> </strong> <em class="ma">笔记本→ Python文件/模块→ Dockerize →部署</em></p><p id="77d3" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">无论你属于哪个阵营，你都可以从这个指南中获得一些技巧，并将其融入到你自己的工作流程中。</p><h1 id="a303" class="mj mk iq bd ml mm nr mo mp mq ns ms mt kf nt kg mv ki nu kj mx kl nv km mz na bi translated">上下文开关程序</h1><p id="f411" class="pw-post-body-paragraph le lf iq lg b lh nb ka lj lk nc kd lm ln nd lp lq lr ne lt lu lv nf lx ly lz ij bi translated">上下文切换是工作流的祸根。每当你切换环境/工具时，你会失去你的心流，需要时间来适应。尽可能避免切换上下文。在过去的几年里，我一直将VS代码作为python开发的日常驱动程序，并且卓有成效。</p><blockquote class="nw"><p id="8a07" class="nx ny iq bd nz oa ob oc od oe of lz dk translated">你在一个工具上花的时间越多，你就越擅长它。VS Code拥有强大的社区、多语言支持、各种扩展和来自MSFT的支持。你最好向它过渡，宜早不宜迟。</p></blockquote><h1 id="f6b0" class="mj mk iq bd ml mm nr mo mp mq ns ms mt kf og kg mv ki oh kj mx kl oi km mz na bi translated">初始设置</h1><p id="0310" class="pw-post-body-paragraph le lf iq lg b lh nb ka lj lk nc kd lm ln nd lp lq lr ne lt lu lv nf lx ly lz ij bi translated">如果你想跟着做，确保你已经安装了VS代码。我将使用<code class="fe oj ok ol om b">pyenv</code>和<code class="fe oj ok ol om b">poetry</code>来设置项目。如果您需要参考资料，请查看我关于如何设置python环境的文章，</p><div class="on oo gp gr op oq"><a rel="noopener follow" target="_blank" href="/best-practices-for-setting-up-a-python-environment-d4af439846a"><div class="or ab fo"><div class="os ab ot cl cj ou"><h2 class="bd ja gy z fp ov fr fs ow fu fw iz bi translated">设置Python环境的最佳实践</h2><div class="ox l"><h3 class="bd b gy z fp ov fr fs ow fu fw dk translated">pyenv-&gt; Pipx-&gt; poem，python工具链的三大支柱</h3></div><div class="oy l"><p class="bd b dl z fp ov fr fs ow fu fw dk translated">towardsdatascience.com</p></div></div><div class="oz l"><div class="pa l pb pc pd oz pe ky oq"/></div></div></a></div><pre class="kp kq kr ks gt pf om pg ph aw pi bi"><span id="ab51" class="ng mk iq om b gy pj pk l pl pm">&gt;mkdir dream_ds_project<br/>&gt;cd dream_ds_project</span><span id="502e" class="ng mk iq om b gy pn pk l pl pm"># Setting python version<br/>dream_ds_project&gt;pyenv local 3.8.2</span><span id="0562" class="ng mk iq om b gy pn pk l pl pm"># Setting up poetry<br/>dream_ds_project&gt;poetry init</span></pre><h1 id="1274" class="mj mk iq bd ml mm nr mo mp mq ns ms mt kf nt kg mv ki nu kj mx kl nv km mz na bi translated">典型的数据科学代码编写工作流程</h1><blockquote class="nw"><p id="96d7" class="nx ny iq bd nz oa ob oc od oe of lz dk translated">打开jupyter笔记本-&gt;编写大量工作python语句→用函数包装→将相关函数分组到类抽象中→python文件中的相关类和函数→模块中的相关python文件</p></blockquote><figure class="pp pq pr ps pt kt gh gi paragraph-image"><div class="gh gi po"><img src="../Images/bbf33d03c09feecc53b0abe9dc16a0de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SBsIQ4yBJW9ni5woowEiDQ.png"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">作者图片</p></figure><h2 id="ef9c" class="ng mk iq bd ml nh ni dn mp nj nk dp mt ln nl nm mv lr nn no mx lv np nq mz iw bi translated">目录:</h2><p id="419e" class="pw-post-body-paragraph le lf iq lg b lh nb ka lj lk nc kd lm ln nd lp lq lr ne lt lu lv nf lx ly lz ij bi translated"><a class="ae mb" href="#332a" rel="noopener ugc nofollow"> <em class="ma"> Python互动</em></a><em class="ma"><br/></em><a class="ae mb" href="#a57a" rel="noopener ugc nofollow"><em class="ma">Jupyter快捷方式</em></a><em class="ma"><br/></em><a class="ae mb" href="#524d" rel="noopener ugc nofollow"><em class="ma">自动重新加载</em></a><em class="ma"><br/></em><a class="ae mb" href="http://1cee" rel="noopener ugc nofollow" target="_blank"><em class="ma">Pylance</em></a><em class="ma"><br/></em><a class="ae mb" href="#c0fc" rel="noopener ugc nofollow"><em class="ma">林挺</em></a><em class="ma"><br/></em><a class="ae mb" href="#d53a" rel="noopener ugc nofollow"><em class="ma">格式化</em></a></p><p id="3476" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi pu translated">L  et不要自欺欺人了。这是大部分时间花在开发和构建代码原型上的地方。Jupyter笔记本是一个很好的原型制作工具。除了快速运行一段代码和共享结果，笔记本在开发工作流程中效率不高。通常，开发从jupyter笔记本开始，然后复制到python文件中。</p><blockquote class="nw"><p id="b345" class="nx ny iq bd nz oa ob oc od oe of lz dk translated">如果我们能两全其美呢？在开发过程中，使用笔记本特性(如快速运行)制作python代码的原型，然后使用IDE特性(如林挺、格式化、代码导航、版本控制和自动完成等)?</p></blockquote><p id="c91e" class="pw-post-body-paragraph le lf iq lg b lh qd ka lj lk qe kd lm ln qf lp lq lr qg lt lu lv qh lx ly lz ij bi translated">如果我们能做到这一点，我们就可以轻松地从第一步进入第二步。通常，jupyter笔记本将用于原型制作，然后当您开始创建文件和模块时，代码将被转移到IDE。VS代码提供了这两种特性，你不需要切换工具。</p><h2 id="332a" class="ng mk iq bd ml nh ni dn mp nj nk dp mt ln nl nm mv lr nn no mx lv np nq mz iw bi translated">Python交互式</h2><p id="9d1b" class="pw-post-body-paragraph le lf iq lg b lh nb ka lj lk nc kd lm ln nd lp lq lr ne lt lu lv nf lx ly lz ij bi translated">VS Code有一个不太为人知的特性叫做<a class="ae mb" href="https://code.visualstudio.com/docs/python/jupyter-support-py" rel="noopener ugc nofollow" target="_blank"> Python交互式笔记本</a>。这允许您打开一个python文件，并使用<code class="fe oj ok ol om b"># %%</code>在文件上您想要的任何地方创建一个笔记本单元格。这样做的好处是，您仍然可以处理<code class="fe oj ok ol om b">.py</code>文件，同时获得IDE的所有好处。</p><p id="ff5e" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">让我们从安装包开始，</p><pre class="kp kq kr ks gt pf om pg ph aw pi bi"><span id="b26f" class="ng mk iq om b gy pj pk l pl pm">dream_ds_project&gt;poetry shell</span><span id="5209" class="ng mk iq om b gy pn pk l pl pm"># Install ipykernel as dev dependency<br/>dream_ds_project&gt;poetry add ipykernel --dev</span><span id="97ff" class="ng mk iq om b gy pn pk l pl pm"># Install prod dependency<br/>dream_ds_project&gt;poetry add fastpi uvicorn[standard]</span></pre><p id="d9ae" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">当您在这种模式下运行代码时，会弹出一个新的jupyter笔记本窗口并为您运行代码。您的输出、图表和内容与您的代码是分开的。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi qi"><img src="../Images/6a744f1061ba76208e8b116934cb21e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*dVhpVdSfLpn1-97rmI4h_Q.gif"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">Python与IDE功能交互，如林挺、自动完成、文档参考以及Jupyter笔记本快速运行功能。(图片由作者提供)</p></figure><h2 id="a57a" class="ng mk iq bd ml nh ni dn mp nj nk dp mt ln nl nm mv lr nn no mx lv np nq mz iw bi translated">Jupyter快捷方式</h2><p id="b952" class="pw-post-body-paragraph le lf iq lg b lh nb ka lj lk nc kd lm ln nd lp lq lr ne lt lu lv nf lx ly lz ij bi translated">您可以将交互式笔记本的行为更改为类似于Jupyter笔记本的行为。作为一个笔记本用户，我已经习惯了使用键盘快捷键来运行一个单元，运行和前进。通过使用<code class="fe oj ok ol om b">keybindings.json</code>文件中的以下设置，您可以在VSCode中做完全相同的事情。</p><pre class="kp kq kr ks gt pf om pg ph aw pi bi"><span id="33be" class="ng mk iq om b gy pj pk l pl pm"># For running the current cell<br/>{<br/>"key": "shift+enter",<br/>"command": "jupyter.execSelectionInteractive",<br/>"when": "editorTextFocus &amp;&amp; editorLangId == 'python'"<br/>},<br/># For running the cell and create a new cell below<br/>{<br/>"key": "ctrl+enter",<br/>"command": "jupyter.runcurrentcelladvance",<br/>"when": "editorTextFocus &amp;&amp; editorLangId == 'python'"<br/>}</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi qj"><img src="../Images/cc6b8f3b11fca9f23ac7a932a8cea2df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*M-a9jS7z1xp528C8R0la1g.gif"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">Shift+Enter运行当前单元格，Ctrl+Enter运行当前单元格并前进。(图片由作者提供)</p></figure><h2 id="524d" class="ng mk iq bd ml nh ni dn mp nj nk dp mt ln nl nm mv lr nn no mx lv np nq mz iw bi translated">自动重新加载</h2><p id="db24" class="pw-post-body-paragraph le lf iq lg b lh nb ka lj lk nc kd lm ln nd lp lq lr ne lt lu lv nf lx ly lz ij bi translated">一旦完成了函数的编写，就可以将块移动到不同的python文件中。唯一的问题是，如果你回去更新你的功能，jupyter笔记本需要重新加载，以适应新的变化。<code class="fe oj ok ol om b">Autoreload</code>是一款出色的笔记本扩展，使笔记本无需重新加载即可自动获取这些更改。通过将这两行添加到您的<code class="fe oj ok ol om b">settings.json</code>文件中，您可以获得完全相同的特性。</p><pre class="kp kq kr ks gt pf om pg ph aw pi bi"><span id="0c87" class="ng mk iq om b gy pj pk l pl pm"># Jupyter notebook startup command<br/>"jupyter.runStartupCommands": [<br/>    "%load_ext autoreload\n%autoreload 2"<br/>  ],</span></pre><p id="faff" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">通过此设置，自动重新加载会自动添加到您的所有交互式笔记本中。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi qk"><img src="../Images/ea3b979dd3ce166223e3f67dfd9213f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*hXQaL2Pitx1P3DSbTaxmQQ.gif"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated"><strong class="bd ql"> string_split </strong>函数更新会立即反映出来，无需重新加载内核或重新导入。(图片由作者提供)</p></figure><h2 id="1cee" class="ng mk iq bd ml nh ni dn mp nj nk dp mt ln nl nm mv lr nn no mx lv np nq mz iw bi translated">挂架</h2><p id="05d4" class="pw-post-body-paragraph le lf iq lg b lh nb ka lj lk nc kd lm ln nd lp lq lr ne lt lu lv nf lx ly lz ij bi translated">Pylance是VSCode中最好的python语言服务器。在VSCode中，扩展提供语言支持，pylance是支持VSCode中python特性的扩展。<br/>它具有以下特征但不限于:</p><p id="ace6" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">1.使用pyright的静态类型检查(类似于mypy) <br/> 2。代码自动完成，参数建议，文档字符串<br/> 3。语义高亮和自动导入。</p><div class="kp kq kr ks gt ab cb"><figure class="qm kt qn qo qp qq qr paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><img src="../Images/35b99639851eb614922caa343aed5908.png" data-original-src="https://miro.medium.com/v2/resize:fit:1392/1*72dKfgXaz2dXAu3GtrA2dQ.gif"/></div></figure><figure class="qm kt qs qo qp qq qr paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><img src="../Images/0d684e46255b143830e3c7f5c5c11415.png" data-original-src="https://miro.medium.com/v2/resize:fit:610/1*Ww9I7DlksyUmgFaT1ePtWQ.gif"/></div><p class="la lb gj gh gi lc ld bd b be z dk qt di qu qv translated"><strong class="bd ql"> 1: </strong> Pylance自动导入string_split函数。<strong class="bd ql"> 2: </strong> Pylance使用类型提示自动生成文档字符串(图片由作者提供)</p></figure></div><h2 id="c0fc" class="ng mk iq bd ml nh ni dn mp nj nk dp mt ln nl nm mv lr nn no mx lv np nq mz iw bi translated">林挺</h2><p id="4c0f" class="pw-post-body-paragraph le lf iq lg b lh nb ka lj lk nc kd lm ln nd lp lq lr ne lt lu lv nf lx ly lz ij bi translated">林挺对于动态编程语言来说是必不可少的。它有助于您尽早发现错误并维护代码标准。我使用flake8、Mypy和pylance的组合来验证每一个文件保存，保持我的代码没有bug并遵守代码标准。</p><ul class=""><li id="400c" class="qw qx iq lg b lh li lk ll ln qy lr qz lv ra lz rb rc rd re bi translated"><strong class="lg ja"> Flake8 <br/> </strong> Flake8是一款风格引导工具，具有出色的插件支持。您可以通过在根目录中使用一个<code class="fe oj ok ol om b">setup.cfg</code>来实施您自己的标准和插件。你可以把规则添加到忽略部分，但是在你添加到这个列表时要严格，因为你不想打开大门。您还可以设置最大线路长度。<br/> <strong class="lg ja">可读性</strong>:代码可读性对于长期项目来说至关重要，并且是高度主观的。当在团队中工作时，你可以使用flake8插件系统来设置你的复杂性阈值，以便每个人都遵守它们。你可以安装<a class="ae mb" href="https://radon.readthedocs.io/en/latest/flake8.html" rel="noopener ugc nofollow" target="_blank"> radon </a>，当你超过你设置的循环复杂度时，它会让你知道。类似地，你可以安装一个<a class="ae mb" href="https://pypi.org/project/flake8-expression-complexity/" rel="noopener ugc nofollow" target="_blank">表达式复杂度插件</a>来检查表达式复杂度是否超过限制。</li></ul><pre class="kp kq kr ks gt pf om pg ph aw pi bi"><span id="eb27" class="ng mk iq om b gy pj pk l pl pm">[flake8]<br/><em class="ma">ignore</em> = E203, W503, E251, E501, E402, F601<br/><em class="ma">max-line-length</em> = 88<br/># Keep circular complexity in check<br/><em class="ma">radon-max-cc</em> = 10<br/># Keep expression complexity in check<br/><em class="ma">max-expression-complexity</em>=3</span></pre><p id="7cee" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">例如，对于下面的代码，当最大表达式复杂度超过3时，您将得到一个林挺警告。这将确保在编写代码时，可读性也受到密切监控。</p><pre class="kp kq kr ks gt pf om pg ph aw pi bi"><span id="878a" class="ng mk iq om b gy pj pk l pl pm">open_file = <em class="ma">True<br/></em>valid_file = <em class="ma">False<br/></em>override_validitiy = <em class="ma">True<br/></em>dummy_flag = <em class="ma">True</em></span><span id="18a5" class="ng mk iq om b gy pn pk l pl pm"><em class="ma">if</em> open_file <em class="ma">and</em> (valid_file or override_validitiy)<em class="ma">and</em> dummy_flag:<br/>  <em class="ma">print</em>(<em class="ma">True</em>)</span><span id="a579" class="ng mk iq om b gy pn pk l pl pm">dream_ds_project&gt;flake8 --max-expression-complexity=3 test.py<br/>test.py: ECE001 Expression is too complex (4.0 &gt; 3)</span></pre><ul class=""><li id="1f66" class="qw qx iq lg b lh li lk ll ln qy lr qz lv ra lz rb rc rd re bi translated">Mypy是python开发者工具箱中的一个优秀工具。它可以帮助你在错误发生之前就抓住它。一旦你开始在你的论点中加入类型提示，它就会工作得特别好，随着<a class="ae mb" href="https://numpy.org/doc/stable/reference/typing.html#module-numpy.typing" rel="noopener ugc nofollow" target="_blank">在整个数据科学生态系统中得到越来越多的支持</a>，你不能要求更多。</li></ul><div class="kp kq kr ks gt ab cb"><figure class="qm kt rf qo qp qq qr paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><img src="../Images/1f0d7b5658f8134f78b2a11ab3e0becf.png" data-original-src="https://miro.medium.com/v2/resize:fit:626/1*l82JY03QPROsR0MbOub4Ow.gif"/></div></figure><figure class="qm kt rg qo qp qq qr paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><img src="../Images/9bb3c39cdcec74a5497410eac8071954.png" data-original-src="https://miro.medium.com/v2/resize:fit:1376/1*OUk4kpvjo5YL91Rz-5qaeg.gif"/></div><p class="la lb gj gh gi lc ld bd b be z dk rh di ri qv translated"><strong class="bd ql"> 1: </strong> Mypy使用来自python标准库的类型提示来正确地猜测os.getenv可能返回null，从而主动捕捉bug。<strong class="bd ql"> 2: </strong> Mypy使用用户定义的类型提示来正确通知split_string函数接受字符串输入。(图片由作者提供)</p></figure></div><p id="4813" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">使用pipx在你的系统中安装flake8和mypy 是一个<a class="ae mb" rel="noopener" target="_blank" href="/best-practices-for-setting-up-a-python-environment-d4af439846a">好主意。这样，您可以跨项目重用它们，并且只需安装一次。您可以使用user <code class="fe oj ok ol om b">settings.json</code>文件中的以下设置指向pipx安装位置，</a></p><pre class="kp kq kr ks gt pf om pg ph aw pi bi"><span id="2774" class="ng mk iq om b gy pj pk l pl pm">{<br/>“python.linting.flake8Enabled”: <em class="ma">true</em>,<br/>“python.linting.flake8Path”: “C:<em class="ma">\\</em>Users<em class="ma">\\</em>username<em class="ma">\\</em>.local<em class="ma">\\</em>pipx<em class="ma">\\</em>venvs<em class="ma">\\</em>flake8<em class="ma">\\</em>Scripts<em class="ma">\\</em>flake8.exe”,<br/>“python.linting.mypyEnabled”: <em class="ma">true</em>,<br/>“python.linting.mypyPath”: “C:<em class="ma">\\</em>Users<em class="ma">\\</em>username<em class="ma">\\</em>.local<em class="ma">\\</em>pipx<em class="ma">\\</em>venvs<em class="ma">\\</em>mypy<em class="ma">\\</em>Scripts<em class="ma">\\</em>mypy.exe”<br/>}</span></pre><p id="7dc8" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">通过mypy、flake8和pylance启用林挺，您甚至可以在原型开发期间安全地编写代码和捕获bug。</p><h2 id="d53a" class="ng mk iq bd ml nh ni dn mp nj nk dp mt ln nl nm mv lr nn no mx lv np nq mz iw bi translated">格式化</h2><ul class=""><li id="04f9" class="qw qx iq lg b lh nb lk nc ln rj lr rk lv rl lz rb rc rd re bi translated"><a class="ae mb" href="https://github.com/psf/black" rel="noopener ugc nofollow" target="_blank"> <strong class="lg ja">黑色</strong> </a> <strong class="lg ja"> <br/> </strong>格式化有助于在团队工作时维护代码格式化标准。你有没有让队友就PR的代码格式进行辩论？Black是一个python工具，它使用一组预定义的规则自动格式化代码。这是一个<em class="ma">固执己见的</em>自动格式化库。黑色在开发过程中特别有用，因为它可以用一种易于阅读的格式分解复杂的语句。重新格式化是确定性的，因此具有相同设置的用户可以获得完全相同的格式化，而不管格式化在什么操作系统、IDE或平台上运行。您可以使用pipx在您的机器上设置黑色。</li></ul><p id="ffbc" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated"><em class="ma">黑色格式化前，</em></p><pre class="kp kq kr ks gt pf om pg ph aw pi bi"><span id="1af2" class="ng mk iq om b gy pj pk l pl pm"><strong class="om ja">def</strong> very_important_function(template: str, *variables, file: os.PathLike, engine: str, header: bool = <strong class="om ja">True</strong>, debug: bool = <strong class="om ja">False</strong>):<br/>    <em class="ma">"""Applies `variables` to the `template` and writes to `file`."""</em><br/>    <strong class="om ja">with</strong> open(file, 'w') <strong class="om ja">as</strong> f:<br/>        ...</span></pre><p id="1cbe" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated"><em class="ma">黑色格式化后，</em></p><pre class="kp kq kr ks gt pf om pg ph aw pi bi"><span id="ac30" class="ng mk iq om b gy pj pk l pl pm"><strong class="om ja">def</strong> very_important_function(<br/>    template: str,<br/>    *variables,<br/>    file: os.PathLike,<br/>    engine: str,<br/>    header: bool = <strong class="om ja">True</strong>,<br/>    debug: bool = <strong class="om ja">False</strong>,<br/>):<br/>    <em class="ma">"""Applies `variables` to the `template` and writes to `file`."""</em><br/>    <strong class="om ja">with</strong> open(file, "w") <strong class="om ja">as</strong> f:<br/>        ...</span></pre><ul class=""><li id="308f" class="qw qx iq lg b lh li lk ll ln qy lr qz lv ra lz rb rc rd re bi translated"><a class="ae mb" href="https://github.com/PyCQA/isort" rel="noopener ugc nofollow" target="_blank"><strong class="lg ja">I-sort</strong></a><strong class="lg ja"><br/></strong>黑色不会格式化你的导入。用户在没有任何顺序的情况下随意地将东西导入到项目中。i-sort(导入排序)通过在导入中提供层次结构，为这种混乱提供了一些秩序。它格式化导入的方式是python标准库导入，然后是第三方库导入，最后是用户定义的库导入。在每个类别中，导入进一步以升序排序。这有助于在有大量进口时快速识别进口。</li></ul><p id="09e5" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated"><em class="ma">在i-sort之前，</em></p><pre class="kp kq kr ks gt pf om pg ph aw pi bi"><span id="b47f" class="ng mk iq om b gy pj pk l pl pm">from my_lib import Object<br/>import os<br/>from my_lib import Object3<br/>from my_lib import Object2<br/>import sys<br/>from third_party import lib15, lib1, lib2, lib3, lib4, lib5, lib6, lib7, lib8, lib9, lib10, lib11, lib12, lib13, lib14<br/><br/>import sys<br/><br/>from __future__ import absolute_import<br/>from third_party import lib3<br/><br/>print("Hey")<br/>print("yo")</span></pre><p id="4f23" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated"><em class="ma">在i-sort之后，</em></p><pre class="kp kq kr ks gt pf om pg ph aw pi bi"><span id="bd98" class="ng mk iq om b gy pj pk l pl pm">from __future__ import absolute_import</span><span id="c6f6" class="ng mk iq om b gy pn pk l pl pm"># Python Standard library<br/>import os<br/>import sys<br/></span><span id="fcba" class="ng mk iq om b gy pn pk l pl pm"># Third party library<br/>from third_party import (lib1, lib2, lib3, lib4, lib5, lib6, lib7,    lib8,lib9, lib10, lib11, lib12, lib13, lib14, lib15)<br/></span><span id="b805" class="ng mk iq om b gy pn pk l pl pm"># User defined libarary/modules<br/>from my_lib import Object, Object2, Object3<br/><br/>print("Hey")<br/>print("yo")</span></pre><p id="0dce" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">在您的<code class="fe oj ok ol om b">setup.cfg</code>文件中使用该设置来配置i-sort以处理黑色。默认情况下，88个字符的行配置为黑色。确保flake8和i-sort也配置为完全相同的设置。</p><pre class="kp kq kr ks gt pf om pg ph aw pi bi"><span id="2589" class="ng mk iq om b gy pj pk l pl pm">[flake8]<br/><em class="ma">max-line-length</em> = 88<br/>[isort]<br/><em class="ma">line_length</em> = 88</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi po"><img src="../Images/b7051601873d122348459e84b8d1a321.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zp8dSqP7h00vRCXXVpyEaQ.png"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">作者图片</p></figure><h2 id="fb90" class="ng mk iq bd ml nh ni dn mp nj nk dp mt ln nl nm mv lr nn no mx lv np nq mz iw bi translated">目录:</h2><p id="d424" class="pw-post-body-paragraph le lf iq lg b lh nb ka lj lk nc kd lm ln nd lp lq lr ne lt lu lv nf lx ly lz ij bi translated"><a class="ae mb" href="#f190" rel="noopener ugc nofollow"><em class="ma">Dotenv</em></a><em class="ma"><br/></em><a class="ae mb" href="#0b89" rel="noopener ugc nofollow"><em class="ma">预提交</em></a><em class="ma"><br/></em><a class="ae mb" href="#ca72" rel="noopener ugc nofollow"><em class="ma">触摸键入</em></a><em class="ma"><br/></em><a class="ae mb" href="#55d8" rel="noopener ugc nofollow"><em class="ma">VIM</em></a><em class="ma"><br/></em><a class="ae mb" href="#cedf" rel="noopener ugc nofollow"><em class="ma">VS代码扩展</em> </a></p><p id="ef59" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi pu translated">这是非常关键的一步，因为这是设计诸如函数、类和模块等抽象概念的地方。在这个步骤中，数据科学家可以从python开发人员的工作流程中学到很多东西。</p><h2 id="f190" class="ng mk iq bd ml nh ni dn mp nj nk dp mt ln nl nm mv lr nn no mx lv np nq mz iw bi translated">Dotenv</h2><p id="5d63" class="pw-post-body-paragraph le lf iq lg b lh nb ka lj lk nc kd lm ln nd lp lq lr ne lt lu lv nf lx ly lz ij bi translated">假设您有以下文件结构，</p><pre class="kp kq kr ks gt pf om pg ph aw pi bi"><span id="928a" class="ng mk iq om b gy pj pk l pl pm">dream_ds_project<br/>--dev # Jupyter notebook folder<br/>  --notebook1.py<br/>  --notebook2.py<br/>--src # Source code folder<br/>  --module1.py<br/>  --module2.py<br/>--.env # Environment variable file<br/>--setup.cfg # Configuration file for python tools</span></pre><p id="3b0a" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">你首先在dev/notebook1.py中构建一个函数<code class="fe oj ok ol om b">test_prototype</code>。然后你可以将这个函数移动到src/module1.py中。现在当你必须导入这个函数时，在根文件夹中的<code class="fe oj ok ol om b">.env</code>文件中设置<code class="fe oj ok ol om b">PYTHONPATH</code>,就像这样。</p><pre class="kp kq kr ks gt pf om pg ph aw pi bi"><span id="954c" class="ng mk iq om b gy pj pk l pl pm"># Set pythonpath to a relative path. In this case it sets where .env # file is present as the root path<br/>PYTHONPATH=.</span></pre><p id="15f9" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">现在您可以将dev/notebook1.py中的test_prototype导入为</p><pre class="kp kq kr ks gt pf om pg ph aw pi bi"><span id="3360" class="ng mk iq om b gy pj pk l pl pm">from src.module1 import test_prototype</span></pre><p id="7edb" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated"><code class="fe oj ok ol om b">.env</code>是一个特殊的文件。您可以使用它来存储敏感信息，如密码、密钥等。这不应该是git提交的一部分，应该保密。保留两份<code class="fe oj ok ol om b">.env</code>文件，一份用于生产，一份用于开发。</p><p id="0e8b" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated"><em class="ma">生产。env文件可能是这样的，</em></p><pre class="kp kq kr ks gt pf om pg ph aw pi bi"><span id="7f28" class="ng mk iq om b gy pj pk l pl pm">MONGODB_USER=prod_user<br/>MONGODB_PWD=prod_pwd<br/>MONGODB_SERVER=prod.server.com</span></pre><p id="21f3" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated"><em class="ma">反之发展。env文件可能类似于，</em></p><pre class="kp kq kr ks gt pf om pg ph aw pi bi"><span id="af53" class="ng mk iq om b gy pj pk l pl pm">MONGODB_USER=dev_user<br/>MONGODB_PWD=dev_pwd<br/>MONGODB_SERVER=dev.server.com</span></pre><p id="f431" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">您可以使用<a class="ae mb" href="https://github.com/theskumar/python-dotenv" rel="noopener ugc nofollow" target="_blank"> python-dotenv </a>库将这些变量加载到您的环境中。在python代码中，可以像这样访问这些变量，</p><pre class="kp kq kr ks gt pf om pg ph aw pi bi"><span id="3104" class="ng mk iq om b gy pj pk l pl pm">from dotenv import load_dotenv<br/>import os</span><span id="7dd7" class="ng mk iq om b gy pn pk l pl pm"># Call the function to read and load the .env file into local env<br/>load_dotenv()</span><span id="e7d3" class="ng mk iq om b gy pn pk l pl pm">print(os.getenv("MONGODB_SERVER"))<br/>&gt;&gt;prod.server.com # For prod .env file<br/>&gt;&gt;dev.server.com # For dev .env file</span></pre><p id="5c1c" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">这有助于保持prod和dev的通用代码，只需替换。基于代码运行环境的env文件。</p><h2 id="0b89" class="ng mk iq bd ml nh ni dn mp nj nk dp mt ln nl nm mv lr nn no mx lv np nq mz iw bi translated">预提交</h2><p id="c8de" class="pw-post-body-paragraph le lf iq lg b lh nb ka lj lk nc kd lm ln nd lp lq lr ne lt lu lv nf lx ly lz ij bi translated"><a class="ae mb" href="https://pre-commit.com/" rel="noopener ugc nofollow" target="_blank">预提交</a>有助于验证您的git提交。它有助于维护一个清晰的git提交历史，并提供了一种在每次提交之前进行用户定义的验证的机制。它有一个强大的生态系统，并且有一个你能想到的大多数常见提交验证的插件。</p><p id="a599" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated"><strong class="lg ja">内置钩子:</strong> <br/>我最喜欢的一些内置预提交钩子是，</p><ul class=""><li id="2a29" class="qw qx iq lg b lh li lk ll ln qy lr qz lv ra lz rb rc rd re bi translated"><strong class="lg ja">detect-AWS-credentials</strong>&amp;<strong class="lg ja">detect-private-key</strong>确保提交中不包含意外的敏感信息。</li><li id="d09b" class="qw qx iq lg b lh rm lk rn ln ro lr rp lv rq lz rb rc rd re bi translated"><strong class="lg ja">检查添加的大文件</strong>以确保提交不包括超过1MB的文件大小，这可以使用<code class="fe oj ok ol om b">maxkb</code>参数来控制。我发现这非常有用，因为代码文件很少大于1MB，这可以防止在数据科学工作流中意外提交大数据文件。</li><li id="6d5a" class="qw qx iq lg b lh rm lk rn ln ro lr rp lv rq lz rb rc rd re bi translated">check-ast 确保代码在语法上是有效的python代码。</li></ul><p id="41c3" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">安装预提交，<code class="fe oj ok ol om b">poetry add pre-commit — dev<br/></code>创建一个<code class="fe oj ok ol om b">.pre-commit-config.yaml</code>文件，</p><pre class="kp kq kr ks gt pf om pg ph aw pi bi"><span id="fe60" class="ng mk iq om b gy pj pk l pl pm">repos:<br/>- repo: <a class="ae mb" href="https://github.com/pre-commit/pre-commit-hooks" rel="noopener ugc nofollow" target="_blank">https://github.com/pre-commit/pre-commit-hooks</a><br/>  rev: v3.2.0<br/>  hooks:<br/>  - id: detect-aws-credentials<br/>  - id: detect-private-key<br/>  - id: check-added-large-files<br/>    args: ['--maxkb=1000']<br/>  - id: check-ast</span></pre><p id="5542" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">插件:<br/> 在内置钩子之上，预提交也提供了对插件的支持。我最喜欢的一些插件是，</p><ul class=""><li id="8c36" class="qw qx iq lg b lh li lk ll ln qy lr qz lv ra lz rb rc rd re bi translated"><strong class="lg ja">黑色</strong>确保所有提交文件的格式遵循黑色惯例。</li><li id="c339" class="qw qx iq lg b lh rm lk rn ln ro lr rp lv rq lz rb rc rd re bi translated"><strong class="lg ja"> Mypy </strong>验证静态类型检查没有错误。</li><li id="bbae" class="qw qx iq lg b lh rm lk rn ln ro lr rp lv rq lz rb rc rd re bi translated"><strong class="lg ja"> Flake8 </strong>确保遵守编码标准。</li><li id="fdde" class="qw qx iq lg b lh rm lk rn ln ro lr rp lv rq lz rb rc rd re bi translated"><strong class="lg ja"> pytest </strong>在提交之前确保所有的测试都通过。这对于小型项目特别有用，因为您没有CI/CD设置，测试可以在本地完成。</li></ul><pre class="kp kq kr ks gt pf om pg ph aw pi bi"><span id="cd0b" class="ng mk iq om b gy pj pk l pl pm">- repo: <a class="ae mb" href="https://github.com/psf/black" rel="noopener ugc nofollow" target="_blank">https://github.com/psf/black</a><br/>  rev: 20.8b1<br/>  hooks:<br/>  - id: black<br/>    args: ['--check']<br/>- repo: <a class="ae mb" href="https://github.com/pycqa/isort" rel="noopener ugc nofollow" target="_blank">https://github.com/pycqa/isort</a><br/>  rev: '5.6.3'<br/>  hooks:<br/>  - id: isort<br/>    args: ['--profile', 'black', '--check-only']<br/>- repo: <a class="ae mb" href="https://github.com/pre-commit/mirrors-mypy" rel="noopener ugc nofollow" target="_blank">https://github.com/pre-commit/mirrors-mypy</a><br/>  rev: v0.800<br/>  hooks:<br/>  - id: mypy<br/>  - repo: <a class="ae mb" href="https://gitlab.com/pycqa/flake8" rel="noopener ugc nofollow" target="_blank">https://gitlab.com/pycqa/flake8</a><br/>  rev: '3.8.3'<br/>  hooks:<br/>  - id: flake8<br/>    args: ['--config=setup.cfg']<br/>- repo: local<br/>  hooks:<br/>  - id: pytest-check<br/>    name: pytest-check<br/>    entry: pytest<br/>    language: system<br/>    pass_filenames: <em class="ma">false<br/>    </em>always_run: <em class="ma">true</em></span></pre><p id="2217" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">预提交仅读取文件并验证提交，它从不对文件执行格式化或任何写入操作。如果出现验证错误，它会取消提交，您可以在再次提交之前返回并修复错误。</p><p id="f2ac" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated"><em class="ma">由于提交大型数据文件而导致的预提交失败示例</em></p><pre class="kp kq kr ks gt pf om pg ph aw pi bi"><span id="d859" class="ng mk iq om b gy pj pk l pl pm">dream_ds_project&gt; git commit -m "precommit example - failure"<br/>Detect AWS Credentials...................................................Passed<br/>Detect Private Key.......................................................Passed<br/>Check for added large files..............................................<strong class="om ja">Failed</strong><br/>- hook id: check-added-large-files<br/>- exit code: 1</span><span id="3adc" class="ng mk iq om b gy pn pk l pl pm"><strong class="om ja">all_data.json (18317 KB) exceeds 1000 KB.</strong></span><span id="d5a2" class="ng mk iq om b gy pn pk l pl pm">Check python ast.........................(no files to check)Skipped<br/>black....................................(no files to check)Skipped<br/>mypy.....................................(no files to check)Skipped<br/>flake8...................................(no files to check)Skipped</span></pre><p id="09d6" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated"><em class="ma">预提交成功示例，</em></p><pre class="kp kq kr ks gt pf om pg ph aw pi bi"><span id="6637" class="ng mk iq om b gy pj pk l pl pm">dream_ds_project&gt; git commit -m “precommit example — success”<br/>Detect AWS Credentials……………………………………………Passed<br/>Detect Private Key……………………………………………….Passed<br/>Check for added large files……………………………………….Passed<br/>Check python ast…………………………………………………Passed<br/>black…………………………………………………………..Passed<br/>mypy……………………………………………………………Passed<br/>flake8………………………………………………………….Passed<br/>[master] precommit example — success<br/> 7 files changed, 54 insertions(+), 33 deletions(-)</span></pre><h2 id="ca72" class="ng mk iq bd ml nh ni dn mp nj nk dp mt ln nl nm mv lr nn no mx lv np nq mz iw bi translated">触摸打字</h2><p id="8e74" class="pw-post-body-paragraph le lf iq lg b lh nb ka lj lk nc kd lm ln nd lp lq lr ne lt lu lv nf lx ly lz ij bi translated">触摸打字是一个基本的生产力技巧，适用于任何计算机任务。如果你花大量的时间在电脑前，这是至关重要的。只要每天练习几分钟，你就能达到显著的打字速度。</p><p id="2578" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">触摸输入对程序员来说至关重要，因为重点更多的是输入特殊字符，当你思考逻辑时，你不想把注意力集中在键盘上。Keybr 是一个非常棒的培训触摸打字的网站。</p><div class="kp kq kr ks gt ab cb"><figure class="qm kt rr qo qp qq qr paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><img src="../Images/6c3f9c07fa984f08cc84290e78c313e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1142/format:webp/1*lw8V-VkCu06VvZrhccy08A.png"/></div></figure><figure class="qm kt rs qo qp qq qr paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><img src="../Images/5f2236f5c90d865d1a1ce28a2e479f3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:860/format:webp/1*PifpvU_2BGPtgDE8ugDAQA.png"/></div><p class="la lb gj gh gi lc ld bd b be z dk rt di ru qv translated"><strong class="bd ql"> 1: </strong>我的平均触摸打字速度从大约64 wpm逐渐增加到大约90wpm，有些测试的峰值为110 wpm，<strong class="bd ql"> 2: </strong>这是我在mercurial python代码库上进行的典型打字测试的结果，速度为42 wpm，比触摸打字慢得多。(图片由作者提供)</p></figure></div><p id="f791" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">除了触摸输入，编程还涉及到许多特殊字符，其中一些字符是语言特有的。出于这个原因，有一些网站可以让你练习并提高你的代码编写速度。如果你想练习从Python到PHP的任何编码语言，Typing.io 真的很棒。代码编写速度将比一般的触摸打字慢，因为它涉及到许多在英语散文中通常不使用的特殊字符。</p><h2 id="55d8" class="ng mk iq bd ml nh ni dn mp nj nk dp mt ln nl nm mv lr nn no mx lv np nq mz iw bi translated">精力</h2><p id="c3ce" class="pw-post-body-paragraph le lf iq lg b lh nb ka lj lk nc kd lm ln nd lp lq lr ne lt lu lv nf lx ly lz ij bi translated">VIM是程序员所有生产力工具之母。VIM是一种学习曲线很陡的工具，但是一旦你掌握了它，你就离不开它了。VIM使用户能够利用键盘快速浏览他们的代码库，编辑代码。如果你知道触摸输入并练习你的代码输入技巧，这将会更好。</p><p id="5a9d" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">只要看到VIM的可能性，就会激励你去学习它。下面，我提供了一系列gif来解释VIM如何简化您的工作流程。</p><div class="kp kq kr ks gt ab cb"><figure class="qm kt rv qo qp qq qr paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><img src="../Images/2aca12257de6fdb3aeacac6a4a50fa46.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/1*wEyRhyBHlcgfGh015zZSmw.gif"/></div></figure><figure class="qm kt rv qo qp qq qr paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><img src="../Images/49aa20af264684396fb7266ca7003099.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/1*ybcyacIwfdZEcxy2SEqM1Q.gif"/></div></figure><figure class="qm kt rv qo qp qq qr paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><img src="../Images/433fa535cb69ac443ea940e3b5548ab0.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/1*d8PNjRRixJ4_W3PlUKQ1Bw.gif"/></div><p class="la lb gj gh gi lc ld bd b be z dk rw di rx qv translated"><strong class="bd ql"> 1。</strong>无鼠标导航的快速跳转，后面是一个单词的重命名。<strong class="bd ql"> 2。</strong>使用点运算符重复上一个动作。<strong class="bd ql"> 3。</strong>使用VIM宏记录一系列VIM动作，并在多行上执行。(图片由作者提供)</p></figure></div><p id="8e75" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">VIM也鼓励你不要使用箭头，因为使用它们将需要你重新定位你的手。VIM鼓励保持在f和j的顶部，因此不要浪费时间移动和重新校准你的手。出于这个原因，我将所有IDE箭头的用法都配置为VIM的j和k。</p><p id="4d26" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">VIM启发的键盘快捷键，不使用箭头导航。将此添加到您的<code class="fe oj ok ol om b">keybindings.json</code>，</p><pre class="kp kq kr ks gt pf om pg ph aw pi bi"><span id="9750" class="ng mk iq om b gy pj pk l pl pm"># Move up and down jupyter notebook without arrows<br/>{<br/>"key": "ctrl+j",<br/>"command": "jupyter.gotoNextCellInFile",<br/>"when": "editorTextFocus &amp;&amp; editorLangId == 'python'"<br/>},<br/>{<br/>"key": "ctrl+k",<br/>"command": "jupyter.gotoPrevCellInFile",<br/>"when": "editorTextFocus &amp;&amp; editorLangId == 'python'"<br/>}</span><span id="1243" class="ng mk iq om b gy pn pk l pl pm"># Workbench quick select without arrows<br/>{<br/>"key": "ctrl+j",<br/>"command": "workbench.action.quickOpenSelectNext",<br/>"when": "vim.active &amp;&amp; inQuickOpen"<br/>},<br/>{<br/>"key": "ctrl+k",<br/>"command": "workbench.action.quickOpenSelectPrevious",<br/>"when": "vim.active &amp;&amp; inQuickOpen"<br/>},</span><span id="a51b" class="ng mk iq om b gy pn pk l pl pm"># Loop through autosuggestions without arrows<br/>{<br/>"key": "ctrl+j",<br/>"command": "selectNextSuggestion",<br/>"when": "suggestWidgetVisible &amp;&amp; vim.active"<br/>},<br/>{<br/>"key": "ctrl+k",<br/>"command": "selectPrevSuggestion",<br/>"when": "suggestWidgetVisible &amp;&amp; vim.active"<br/>},</span><span id="93a6" class="ng mk iq om b gy pn pk l pl pm"># Loop through search window without arrows<br/>{<br/>"key": "ctrl+j",<br/>"command": "search.action.focusNextSearchResult",<br/>"when": "vim.active &amp;&amp; searchViewletVisible"<br/>},<br/>{<br/>"key": "ctrl+k",<br/>"command": "search.action.focusPreviousSearchResult",<br/>"when": "vim.active &amp;&amp; searchViewletVisible"<br/>},</span><span id="7478" class="ng mk iq om b gy pn pk l pl pm"># Loop through multiple terminals with j and k<br/>{<br/>"key": "ctrl+shift+k",<br/>"command": "workbench.action.terminal.focusNext"<br/>},<br/>{<br/>"key": "ctrl+shift+j",<br/>"command": "workbench.action.terminal.focusPrevious"<br/>},</span></pre><h2 id="cedf" class="ng mk iq bd ml nh ni dn mp nj nk dp mt ln nl nm mv lr nn no mx lv np nq mz iw bi translated">VS代码扩展</h2><p id="9bcd" class="pw-post-body-paragraph le lf iq lg b lh nb ka lj lk nc kd lm ln nd lp lq lr ne lt lu lv nf lx ly lz ij bi translated">因为我们在笔记本上也使用了<code class="fe oj ok ol om b">.py</code>文件，所以所有常规的python扩展仍然可以在我们的笔记本开发过程中使用。下面列出了在这个阶段使用VsCode进行开发时要注意的一些扩展。</p><ul class=""><li id="3f00" class="qw qx iq lg b lh li lk ll ln qy lr qz lv ra lz rb rc rd re bi translated"><a class="ae mb" href="https://marketplace.visualstudio.com/items?itemName=christian-kohler.path-intellisense" rel="noopener ugc nofollow" target="_blank"> <strong class="lg ja">路径智能感知</strong> </a> <strong class="lg ja"> </strong>帮助自动完成路径。当你想读入一个csv文件来启动你的jupyter笔记本时，这是非常有用的。</li></ul><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ry"><img src="../Images/3467b6b862c7089b5297a0f035f32dd3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*YraAuYhMfFa5CORKZ_SUZA.gif"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">csv文件的智能感知自动完成路径。作者图片</p></figure><ul class=""><li id="4034" class="qw qx iq lg b lh li lk ll ln qy lr qz lv ra lz rb rc rd re bi translated"><a class="ae mb" href="https://marketplace.visualstudio.com/items?itemName=sourcery.sourcery" rel="noopener ugc nofollow" target="_blank"> <strong class="lg ja"> Sourcery </strong> </a>是一个漂亮的工具，它为重写代码提供建议，并为函数提供可读性度量。</li></ul><div class="kp kq kr ks gt ab cb"><figure class="qm kt rz qo qp qq qr paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><img src="../Images/3a0a4e2d40a7bf4454ff007140f52540.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/1*Avq0za86JGQsHLl3W4slXw.gif"/></div></figure><figure class="qm kt rz qo qp qq qr paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><img src="../Images/6aebcad39cf72061c75ab053c9ef389a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/1*PSWdokZDSN2b8hliuMAQkw.gif"/></div><p class="la lb gj gh gi lc ld bd b be z dk sa di sb qv translated"><strong class="bd ql"> 1。</strong> Sourcery重写代码以遵循python最佳实践。<strong class="bd ql"> 2。</strong>源代码库显示了代码重写前后的可读性指标。(图片由作者提供)</p></figure></div><ul class=""><li id="fe29" class="qw qx iq lg b lh li lk ll ln qy lr qz lv ra lz rb rc rd re bi translated"><a class="ae mb" href="https://marketplace.visualstudio.com/items?itemName=GitHub.copilot" rel="noopener ugc nofollow" target="_blank"><strong class="lg ja">Github copilot</strong></a><strong class="lg ja">，</strong>一个聪明的AI插件，自动完成你的代码和功能。</li></ul><div class="kp kq kr ks gt ab cb"><figure class="qm kt sc qo qp qq qr paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><img src="../Images/e46207c1e6f3772d5a5975d26cfa599f.png" data-original-src="https://miro.medium.com/v2/resize:fit:650/1*8hEwxBSo8r_FqmD8z5hjvQ.gif"/></div></figure><figure class="qm kt sd qo qp qq qr paragraph-image"><img src="../Images/6c2b3be0a4f8975c59ce602c20dc31c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1032/1*WNE75QidTF1C3X3Mrtr4Wg.gif"/></figure></div><div class="ab cb"><figure class="qm kt se qo qp qq qr paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><img src="../Images/b34fe786edeb5c68873341d5932e9121.png" data-original-src="https://miro.medium.com/v2/resize:fit:744/1*KhkLCqbtu0jwNSgsWSg0Lg.gif"/></div></figure><figure class="qm kt sf qo qp qq qr paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><img src="../Images/ae75dd321253d131d55ce299477893c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1258/1*EB4SQUBDhY6LWcXn0fXj_w.gif"/></div><p class="la lb gj gh gi lc ld bd b be z dk sg di sh qv translated"><strong class="bd ql"> 1。</strong> Copilot正在与第三方库进行模式匹配。<strong class="bd ql"> 2。</strong>使用来自函数和参数命名的上下文的函数自动完成<strong class="bd ql"> 3。</strong>使用当前范围前后的上下文自动完成。<strong class="bd ql"> 4。</strong>使用类型提示进行自动完成。(图片由作者提供)</p></figure></div><p id="524f" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">如果您想在工作流程中有效地使用GitHub copilot，请查看我的文章，</p><div class="on oo gp gr op oq"><a rel="noopener follow" target="_blank" href="/tips-for-using-github-copilot-in-everyday-python-programming-8ef9e91a9b47"><div class="or ab fo"><div class="os ab ot cl cj ou"><h2 class="bd ja gy z fp ov fr fs ow fu fw iz bi translated">GitHub copilot能为数据科学家做些什么？</h2><div class="ox l"><h3 class="bd b gy z fp ov fr fs ow fu fw dk translated">没有废话指南使用副驾驶今天</h3></div><div class="oy l"><p class="bd b dl z fp ov fr fs ow fu fw dk translated">towardsdatascience.com</p></div></div><div class="oz l"><div class="si l pb pc pd oz pe ky oq"/></div></div></a></div></div><div class="ab cl mc md hu me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ij ik il im in"><p id="9384" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">如果你喜欢本文中GIF格式的代码，可以看看我写的关于如何自己设置它的文章，</p><div class="on oo gp gr op oq"><a href="https://python.plainenglish.io/make-your-python-code-look-pretty-c65dc2ff2bfa" rel="noopener  ugc nofollow" target="_blank"><div class="or ab fo"><div class="os ab ot cl cj ou"><h2 class="bd ja gy z fp ov fr fs ow fu fw iz bi translated">让你的Python代码看起来很漂亮</h2><div class="ox l"><h3 class="bd b gy z fp ov fr fs ow fu fw dk translated">为什么JavaScript开发者应该享受所有的乐趣？</h3></div><div class="oy l"><p class="bd b dl z fp ov fr fs ow fu fw dk translated">python .平原英语. io</p></div></div><div class="oz l"><div class="sj l pb pc pd oz pe ky oq"/></div></div></a></div></div><div class="ab cl mc md hu me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ij ik il im in"><h1 id="4045" class="mj mk iq bd ml mm mn mo mp mq mr ms mt kf mu kg mv ki mw kj mx kl my km mz na bi translated">第二部分</h1><p id="9c82" class="pw-post-body-paragraph le lf iq lg b lh nb ka lj lk nc kd lm ln nd lp lq lr ne lt lu lv nf lx ly lz ij bi translated">请关注这篇文章第二部分的更新。</p><blockquote class="sk sl sm"><p id="0f66" class="le lf ma lg b lh li ka lj lk ll kd lm sn lo lp lq so ls lt lu sp lw lx ly lz ij bi translated">如果你喜欢这篇文章，并且想要更多这样的内容，请留下掌声，如果你有任何问题/建议来改进这个指南，请留下评论。</p></blockquote></div></div>    
</body>
</html>