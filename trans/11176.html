<html>
<head>
<title>How to Write Custom TensorFlow Callbacks — The Easy Way</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何编写自定义 TensorFlow 回调——简单的方法</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-write-custom-tensorflow-callbacks-the-easy-way-c7c4b0e31c1c?source=collection_archive---------33-----------------------#2021-11-01">https://towardsdatascience.com/how-to-write-custom-tensorflow-callbacks-the-easy-way-c7c4b0e31c1c?source=collection_archive---------33-----------------------#2021-11-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="59bc" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">你觉得内置 TensorFlow 回调有局限性吗？这是您一直在寻找的解决方案</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/35a83e02c554e00759ba87bbd2fe045e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GVWu_3pCy6bhXxNWVATmUA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">西蒙·艾布拉姆斯在 Unsplash<a class="ae ky" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">拍摄的照片</a></p></figure><p id="77f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你发现<a class="ae ky" rel="noopener" target="_blank" href="/tensorflow-callbacks-how-to-monitor-neural-network-training-like-a-pro-f02cb4e477d0">内置 TensorFlow 回调</a>有局限性吗？您很幸运，因为今天您将从头开始学习如何编写自定义 TensorFlow 回调！当您想修改默认回调的工作方式或者想做一些疯狂的事情时，它可能会派上用场。</p><p id="f2fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">今天，您将编写一个定制的回调函数来重新设计训练循环，在训练完成后在测试集上打印评估指标，并绘制每个时期的训练损失与验证损失以及训练精度与验证精度的关系图。</p><p id="137e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不想看书？请观看我的视频:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="5cdd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以在<a class="ae ky" href="https://github.com/better-data-science/TensorFlow" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上下载源代码。</p></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h1 id="8aad" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">使用的数据集和数据预处理</h1><p id="2525" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">我今天不打算花太多时间处理数据。我们将使用与前几篇文章相同的数据集——来自 Kaggle 的<a class="ae ky" href="https://www.kaggle.com/shelvigarg/wine-quality-dataset" rel="noopener ugc nofollow" target="_blank">葡萄酒质量数据集</a>。它是在数据库内容许可证下许可的开源数据集:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nb"><img src="../Images/22e312d8d26f36ca55853f206f206d63.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T0AUc1nOEi-cOsLhRfKSjg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片 1——来自 Kaggle 的葡萄酒质量数据集(图片由作者提供)</p></figure><p id="0a44" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以使用以下代码将其导入 Python，并随机打印几行:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc lw l"/></div></figure><p id="8131" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们忽略警告并更改默认的 TensorFlow 日志级别，这样我们就不会被输出淹没。</p><p id="bccc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是数据集的外观:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nd"><img src="../Images/064859850a5b3f766f39e99947941b22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_SajdZuYIzmh66qA_mDO7g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图 2——葡萄酒质量数据集的随机样本(图片由作者提供)</p></figure><p id="cd7d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">数据集基本上是干净的，但默认情况下不是为二元分类(好酒/劣酒)而设计的。取而代之的是，葡萄酒是按等级来评定的。我们现在将解决这个问题，还有许多其他问题:</p><ul class=""><li id="d653" class="ne nf it lb b lc ld lf lg li ng lm nh lq ni lu nj nk nl nm bi translated"><strong class="lb iu">删除缺失值</strong> —它们为数不多，所以我们不会在插补上浪费时间。</li><li id="2427" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated"><strong class="lb iu">处理分类特征</strong>——唯一的一个是<code class="fe ns nt nu nv b">type</code>，指示葡萄酒是白还是红。</li><li id="3184" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated"><strong class="lb iu">转换为二分分类任务</strong>——我们将把任何 6 分及以上的葡萄酒宣布为<em class="nw">好</em>，任何低于<em class="nw">的为差</em>。</li><li id="0aa4" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated"><strong class="lb iu">训练/测试拆分</strong>——经典的 80:20 拆分。</li><li id="1089" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated"><strong class="lb iu">缩放数据</strong> —预测值之间的比例差异很大，因此我们将使用<code class="fe ns nt nu nv b">StandardScaler</code>来拉近数值。</li></ul><p id="7f75" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是完整的数据预处理代码片段:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc lw l"/></div></figure><p id="3345" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，如果你想更详细地了解数据预处理背后的逻辑，请参考<a class="ae ky" rel="noopener" target="_blank" href="/how-to-train-a-classification-model-with-tensorflow-in-10-minutes-fd2b7cfba86">上一篇文章</a>。</p><p id="5173" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们看看如何在 TensorFlow 中声明回调。</p></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h1 id="ea7a" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">编写一个模型训练函数</h1><p id="eb32" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">让我们通过编写一个构建、编译和训练模型的函数来使我们的生活变得稍微容易一些。没有它也可以继续，但是您需要多次复制/粘贴模型训练代码，这并不理想。</p><p id="73b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该函数允许您指定回调列表，并更改模型将训练的时期数。默认情况下，历元数设置为 5。其他一切都是硬编码的，包括训练集、验证集和详细度参数。最好将其设置为 0，因为我们的回调会生成自己的训练进度语句。</p><p id="4e23" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是该函数的代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc lw l"/></div></figure><p id="70c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你了解 TensorFlow 的基础知识，应该感觉很熟悉。解决了这个问题，让我们写第一个回调函数。</p></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h1 id="0970" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">编写一个基本的自定义 TensorFlow 回调</h1><p id="7fdc" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">每个自定义 TensorFlow 回调类都必须扩展<code class="fe ns nt nu nv b">tf.keras.callbacks.Callback</code>类。它让你可以访问许多类方法，但是我们在这一节只讨论两个。这些是<code class="fe ns nt nu nv b">on_train_begin()</code>和<code class="fe ns nt nu nv b">on_train_end()</code>。TensorFlow 的开发团队确实确定了函数名，因此没有必要进一步解释它们的功能。</p><p id="eabf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与任何 Python 类一样，您可以声明一个构造函数。我们的将包含模型开始和结束训练的时间戳。我们最初将两者都设置为<code class="fe ns nt nu nv b">None</code>。</p><p id="9ed3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ns nt nu nv b">on_train_begin()</code>函数将当前时间设置为构造函数中的开始时间戳，并打印训练开始的时间。</p><p id="bf54" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ns nt nu nv b">on_train_end()</code>函数将当前时间设置为构造函数中的时间结束时间戳，计算并打印训练持续时间，并打印训练损失、训练准确度、验证损失和验证准确度的值。</p><p id="1454" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">代码如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc lw l"/></div></figure><p id="a65a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">简单吧？当然，但是开始定制训练日志输出就足够了。您可以使用以下代码为模型定型五个时期(默认):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc lw l"/></div></figure><p id="2a26" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是您将看到的输出:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/4c0afecb4c9152263b6aed203624b99a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WI8JRvsH0ZxYtmC0g90Uig.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图 3 —自定义 TensorFlow 回调 v1(图片由作者提供)</p></figure><p id="4486" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个不错的开始，但我们看不到每个时期会发生什么。接下来让我们改变它。</p></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h1 id="eb8f" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">使用自定义 TensorFlow 回调修改纪元行为</h1><p id="aa49" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">您可以用同样的方式修改每个时期开始和结束时发生的事情。我们将打印历元号、历元持续时间、训练损失和准确度，以及验证损失和准确度。</p><p id="d425" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们从向构造函数添加一个额外的变量开始— <code class="fe ns nt nu nv b">time_curr_epoch</code> —它将在每次新的纪元开始时被覆盖。</p><p id="4cbc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ns nt nu nv b">on_epoch_begin()</code>函数将当前时间的值设置为构造函数中的<code class="fe ns nt nu nv b">time_curr_epoch</code>变量。</p><p id="d015" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ns nt nu nv b">on_epoch_end()</code>函数将计算历元持续时间，并从历元日志中获取训练损失、训练精度、验证损失和验证精度。然后它会使用 Python 的 f-string 魔法将它们打印出来。</p><p id="0f69" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">代码如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc lw l"/></div></figure><p id="07dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们测试一下——记住，除了之前的内容之外，您应该会看到每个时期都打印了新的一行:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc lw l"/></div></figure><p id="1801" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是输出结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ny"><img src="../Images/96183cb2c72450c8f92f2ba30eae2be3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CaIioXfPbq0c_zh16bvdTw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图 4 —自定义 TensorFlow 回调 v2(图片由作者提供)</p></figure><p id="a74d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">整洁，对不对？故事并没有到此结束。接下来，让我们看看如何在培训完成后直观显示模型性能。</p></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h1 id="949d" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">通过自定义 TensorFlow 回调可视化模型性能</h1><p id="401a" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">绘制训练和验证度量会立即告诉您模型是否停滞或过度拟合，以及何时是停止训练的正确时间。这就是我们现在要做的。我们将声明一个可视化模型性能的辅助函数，然后在训练完成后调用它。</p><p id="c591" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，向构造函数添加几个变量。您将需要在训练集和验证集上跟踪历元数、损失和准确性。</p><p id="090c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ns nt nu nv b">_plot_model_performance()</code>函数将创建一个 1 行 2 列的图表，在左边显示训练和验证损失，在右边显示训练和验证准确性。</p><p id="6507" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe ns nt nu nv b">on_training_end()</code>里面只调用<code class="fe ns nt nu nv b">_plot_model_performance()</code>下面的一切。</p><p id="cf03" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe ns nt nu nv b">on_epoch_end()</code>中，增加历元数，将训练损失、训练精度、验证损失和验证精度的值追加到构造函数的列表中。</p><p id="d1e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">代码如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc lw l"/></div></figure><p id="14da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就是这样！现在让我们来测试一下——我们将训练 50 个时期的模型，这样图表就可以显示更多的数据:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc lw l"/></div></figure><p id="8714" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">培训结束后，您将看到以下内容:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/663a6664ddc18f541de4edb8769f1a77.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9sE1G6WoWo_zhfAJYLsPaA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图 5 —自定义 TensorFlow 回调 v3(图片由作者提供)</p></figure><p id="7ea7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">简而言之，用当前的架构和参数训练模型 50 个时代是没有意义的。验证损失大约在第 5 个历元之后开始增加，同时验证准确度或多或少处于平稳状态。</p><p id="2e22" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不过，这是你需要手动可视化的一件事。</p></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h1 id="1660" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">结论</h1><p id="3af3" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">这就是 TensorFlow 自定义回调的基础。我们只介绍了可用功能的一小部分，所以请务必浏览官方文档以获得更多资源。写得真的很好，你会发现关于编写自定义<em class="nw">提前停止</em>和<em class="nw">学习率调度器</em>回调的例子。</p><p id="63c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在从头开始编写自定义回调之前，请确保您需要的功能尚未内置到 TensorFlow 中。你可以查看我的前一篇文章，关于我在每个深度学习项目中使用的四个内置回调，以帮助你开始。</p><p id="c32c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请继续关注即将到来的文章，因为我们将从下面的文章开始深入研究 TensorFlow 和计算机视觉以及卷积神经网络。</p></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><p id="0f43" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nw">喜欢这篇文章吗？成为</em> <a class="ae ky" href="https://medium.com/@radecicdario/membership" rel="noopener"> <em class="nw">中等会员</em> </a> <em class="nw">继续无限制学习。如果你使用下面的链接，我会收到你的一部分会员费，不需要你额外付费。</em></p><div class="oa ob gp gr oc od"><a href="https://medium.com/@radecicdario/membership" rel="noopener follow" target="_blank"><div class="oe ab fo"><div class="of ab og cl cj oh"><h2 class="bd iu gy z fp oi fr fs oj fu fw is bi translated">通过我的推荐链接加入 Medium-Dario rade ci</h2><div class="ok l"><h3 class="bd b gy z fp oi fr fs oj fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="ol l"><p class="bd b dl z fp oi fr fs oj fu fw dk translated">medium.com</p></div></div><div class="om l"><div class="on l oo op oq om or ks od"/></div></div></a></div></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h1 id="1243" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">保持联系</h1><ul class=""><li id="345e" class="ne nf it lb b lc mw lf mx li os lm ot lq ou lu nj nk nl nm bi translated">注册我的<a class="ae ky" href="https://mailchi.mp/46a3d2989d9b/bdssubscribe" rel="noopener ugc nofollow" target="_blank">简讯</a></li><li id="724b" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated">订阅<a class="ae ky" href="https://www.youtube.com/c/BetterDataScience" rel="noopener ugc nofollow" target="_blank"> YouTube </a></li><li id="57ef" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated">在 LinkedIn 上连接</li></ul></div></div>    
</body>
</html>