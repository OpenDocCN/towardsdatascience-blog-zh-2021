<html>
<head>
<title>Search Algorithms — Concepts and Implementation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">搜索算法——概念和实现</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/search-algorithms-concepts-and-implementation-1073594aeda6?source=collection_archive---------17-----------------------#2021-08-13">https://towardsdatascience.com/search-algorithms-concepts-and-implementation-1073594aeda6?source=collection_archive---------17-----------------------#2021-08-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a2a0" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">A*、Dijkstra、动态规划、BFS、DFS和IDDFS</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/fb9493aab24f5ae7b197720a307a5b55.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*62aJ_5U6DGqm2MKZTo_smA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者照片</p></figure><p id="a4d7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在机器学习中，搜索问题是一种基于状态的模型，有许多应用。比如寻路，机器人运动规划，机器翻译。在本文中，我们将深入研究几种常见的搜索算法，并了解它们如何用于解决不同的任务。</p><p id="f7b9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">本文的其余部分将涵盖BFS、DFS、IDDFS、动态编程、Dijkstra算法和A*。我会简单说明每个算法的主要思想，提供一个问题，用Python编写算法来解决问题。</p><p id="f651" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">完整的代码可以在这里找到<a class="ae lu" href="https://github.com/VXU1230/Medium-Tutorials/tree/master/search" rel="noopener ugc nofollow" target="_blank">。</a></p><h1 id="cf5b" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated"><strong class="ak"> BFS、DFS、IDDFS </strong></h1><p id="f85c" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">BFS、DFS和IDDFS是流行的搜索算法，可用于树和图数据结构。在本文中，我使用术语“节点”来表示树节点或图形组件。</p><h2 id="e1d2" class="ms lw it bd lx mt mu dn mb mv mw dp mf lh mx my mh ll mz na mj lp nb nc ml nd bi translated">概念</h2><p id="b4fc" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated"><strong class="la iu"> BFS </strong>代表<strong class="la iu">广度优先搜索</strong>，其工作方式如下:从根节点开始，探索当前深度的所有节点，然后移动到下一深度级别的节点。它重复这个过程，直到到达最后一个深度或找到目标。通常使用队列来跟踪已经遇到但还没有探索的节点。</p><p id="140c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu"> DFS </strong>代表<strong class="la iu">深度优先搜索</strong>。与BFS相同，它从根节点开始。然而，DFS不是遍历不同的深度，而是在回溯并移动到新的分支之前，尽可能地沿着每个分支探索。这意味着DFS通常是递归实现。</p><p id="654d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu"> IDDFS </strong>代表<strong class="la iu">迭代深化深度优先搜索</strong>，实际上是DFS和BFS的混合。换句话说，它是深度受限的DFS版本。具体来说，它重复运行深度限制不断增加的DFS搜索，直到找到目标。尽管在每次迭代中它都运行一次DFS搜索，但它像BFS一样是最优的，并且通常可以在不探索所有节点的情况下找到目标，然而它不需要队列，并且使用的内存比BFS少得多。</p><p id="ac24" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们看看在搜索最短路径时，它们在时间和空间复杂性方面的不同表现。设<code class="fe ne nf ng nh b">D</code>为树的最大深度，<code class="fe ne nf ng nh b">d</code>为目标所在的最小深度。我们有<code class="fe ne nf ng nh b">d &lt;= D</code>。在二叉树<code class="fe ne nf ng nh b">b==2</code>的情况下，设<code class="fe ne nf ng nh b">b</code>为分支因子(每个节点的分裂数)。</p><p id="8013" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">时间复杂度</strong></p><p id="1c78" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们需要探索所有的节点。</p><p id="4bee" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">BFS: <code class="fe ne nf ng nh b">O(b^d)</code>我们只探索目标深度的节点。</p><p id="2743" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">IDDFS: <code class="fe ne nf ng nh b">O(b^d)</code>我们只探索节点直到目标所在的深度。</p><p id="46b2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">空间复杂度</strong></p><p id="8585" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">DFS: <code class="fe ne nf ng nh b">O(D)</code>递归中最大的栈是<code class="fe ne nf ng nh b">D</code></p><p id="fa20" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">BFS: <code class="fe ne nf ng nh b">O(b^d)</code>队列中的节点数</p><p id="ef7c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">IDDFS: <code class="fe ne nf ng nh b">O(d)</code>递归中最大的栈是<code class="fe ne nf ng nh b">d</code></p><p id="90c7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">注意，如果我们需要访问每一个节点以便找到目标(<code class="fe ne nf ng nh b">d==D</code>)，所有三个算法将具有相同的时间复杂度。</p><p id="3642" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在下一节中，我将向您展示如何实现这些算法来解决树搜索问题。</p><h2 id="35a7" class="ms lw it bd lx mt mu dn mb mv mw dp mf lh mx my mh ll mz na mj lp nb nc ml nd bi translated">问题陈述</h2><p id="c7fc" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">从根节点到值大于或等于10的节点的最短路径(深度)的长度是多少？</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ni"><img src="../Images/fe9564b59d6ca5f41354fc448012a798.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Mwr6sgSW8ypNaoaZ-6W6CQ.png"/></div></div></figure><h2 id="67b8" class="ms lw it bd lx mt mu dn mb mv mw dp mf lh mx my mh ll mz na mj lp nb nc ml nd bi translated"><strong class="ak">分析</strong></h2><p id="c16a" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">最短路径是1 → 2 →11，长度为2。请注意，1 → 6 → 4 → 9 → 10也是有效路径，但不是最短路径。</p><h2 id="f656" class="ms lw it bd lx mt mu dn mb mv mw dp mf lh mx my mh ll mz na mj lp nb nc ml nd bi translated">密码</h2><p id="06cd" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">为了解决这个问题，我们将每个树节点表示为一个<code class="fe ne nf ng nh b">Node</code>对象，并将它们链接在一起以表示上面的树。</p><p id="7ee8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用上面提到的复杂性注释，我们在这个问题上有了<code class="fe ne nf ng nh b">D=4, d=2, b=2</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="96f3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">首先让我们看看如何使用<strong class="la iu"> BFS来解决它。从根节点开始，我们将当前深度的所有节点添加到队列中，并逐个处理它们。所谓“处理”，是指我们从队列中弹出节点，检查它是否是值，如果它不是目标，就将它的子节点添加到队列中。由于队列的先进先出属性，只有在我们处理完当前深度的节点之后，才会处理下一深度级别的节点。一旦我们找到目标(深度为2的节点11)，我们马上返回它。</strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="7a56" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">另一方面，<strong class="la iu"> DFS </strong>沿着每个分支递归搜索。在这种情况下，它按照根→左子树→右子树的顺序访问所有节点。这被称为前序遍历。<strong class="la iu"> </strong>还有另外两种类型的树遍历方法:Inorder和Postorder。查看<a class="ae lu" href="https://www.geeksforgeeks.org/tree-traversals-inorder-preorder-and-postorder/" rel="noopener ugc nofollow" target="_blank">这里</a>了解更多详情。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="7c2a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">IDDFS的实现与DFS的实现非常相似。唯一的区别是它在每个深度限制停止DFS搜索。假设我们知道树的最大深度是4，我们可以从深度限制1开始运行DFS，并将其增加到4或直到找到目标。在这种情况下，它只需要运行2个DFS(深度限制为1和2)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="7874" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们运行这三个函数并比较输出。在输出中，我们看到所有三个算法都找到了最短的深度2，但是访问的节点不同。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/8ff2af8b97ef91d797f382ff2bafe220.png" data-original-src="https://miro.medium.com/v2/resize:fit:1072/format:webp/1*D0vPeblRxVu_rtTwVeUW2A.png"/></div></figure><p id="d0ea" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu"> BFS </strong>首先访问根节点1，然后移动到第一深度级别的节点:6，2，然后是第二深度的节点:4，5，3，11。由于我们的目标11是在这里发现的，它不会继续访问其他深度。</p><p id="5762" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu"> DFS </strong>以不同的顺序访问节点。从根节点1开始，它移动到根节点为6的左子树，并继续移动到根节点为4的左子树。一旦到达没有任何子节点的节点7，它就返回上一级(回溯)并以节点9为根搜索第一个右边的子树。注意，所有子树的遍历都遵循根→左子树→右子树的顺序，所以我们访问(9，8，10)而不是(8，9，10)或(10，8，9)。为了找到最短路径的长度，我们必须访问所有的节点。即使节点10已经满足标准，我们也不能就此止步，因为我们不知道它是否是最短路径。</p><p id="30eb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu"> IDDFS </strong>当深度阈值为1时，首先访问节点1、6、2，然后它再次从根开始访问深度为2 (1、6、4、5、2、3、11)的所有内容，并在此处停止，因为找到了目标。它访问与BFS相同的节点，但是顺序不同，因为每个内部DFS运行仍然遵循根→左子树→右子树的顺序。</p><h1 id="23cb" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated"><strong class="ak"> DP(动态编程)</strong></h1><h2 id="022d" class="ms lw it bd lx mt mu dn mb mv mw dp mf lh mx my mh ll mz na mj lp nb nc ml nd bi translated">概念</h2><p id="5ef5" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">当递归解决问题时，有时我们可能会多次访问相同的值，这增加了不必要的时间复杂度。解决这个问题的一种方法是缓存访问过的值以备将来使用。更好的是，如果我们将递归方法转换为重复使用之前的中间结果的迭代方法会怎么样？使用迭代法的优点是:1。将时间复杂度从指数降低到多项式；2.避免递归处理不当时经常发生的堆栈溢出。</p><p id="c955" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">动态规划的主要思想是存储子问题的中间结果，这样我们以后就不用重新计算了。让我们看一个例子来更好地理解DP。</p><h2 id="f23f" class="ms lw it bd lx mt mu dn mb mv mw dp mf lh mx my mh ll mz na mj lp nb nc ml nd bi translated">问题陈述</h2><p id="6660" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">给定一个<code class="fe ne nf ng nh b">m x n</code>网格，找出从左上角到右下角的唯一路径的数量。假设我们在任一时刻只能向下或向右移动。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nm"><img src="../Images/6b4d7cf801d3b70236c3ccd4afe0ecc7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m9yxAolQ_YwnQeiiGfIhrw.png"/></div></div></figure><h2 id="67cc" class="ms lw it bd lx mt mu dn mb mv mw dp mf lh mx my mh ll mz na mj lp nb nc ml nd bi translated">分析</h2><p id="f848" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">实现DP通常比提出解决方案容易得多，后者需要相当多的逆向思维。通常我们会通过从头开始迭代计算唯一路径的数量来解决这个问题。但是，请注意，网格中间的许多单元格被多次访问。这通常是某种缓存或DP的迹象。假设我们在单元格(1，6)，它位于完成单元格的正上方。从当前单元格开始，只有一条路径可以到达终点单元格:向下。这同样适用于单元格(2，5)。现在，如果我们在单元格(1，5)，有2条路径到达结束单元格:向右和向下；向右下走。这实际上是(1，6)和(2，5)处的值之和。从逻辑上讲，这是有意义的，因为在每个单元格中，我们可以向右或向下移动:如果我们向右移动，值(从这个单元格到结束单元格的唯一路径的数量)与其右边单元格的值相同，如果我们向下移动，同样的逻辑也适用。因此，我们可以得出，每个单元的值是其两个相邻单元(右和下)的值之和，这是DP中要解决的子问题。</p><p id="4bb5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">DP通常具有更好的时间复杂度，因为它避免了重新计算，但是这是以空间复杂度为代价的。根据问题的不同，有时我们可能需要存储所有子问题(所有单元/节点)的中间结果。</p><h2 id="c5db" class="ms lw it bd lx mt mu dn mb mv mw dp mf lh mx my mh ll mz na mj lp nb nc ml nd bi translated">密码</h2><p id="aa97" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">一旦我们有了解决方案，实现就非常简单了。我们从右下角的结束单元格开始，它的基线值为1，并迭代地向左上角的开始单元格移动。我们需要特别注意边界单元，因为它们只有一个相邻单元。一旦我们到达起始单元格，只需返回它的值。</p><p id="4b65" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">空间和时间复杂度都是<code class="fe ne nf ng nh b">(m*n)</code>。</p><p id="e0b9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">顺便说一下，我们在这里描述的DP方法使用了自底向上(制表)的方法。还有另一种自上而下的方法。更多详情，请参考<a class="ae lu" href="https://www.geeksforgeeks.org/tabulation-vs-memoization/" rel="noopener ugc nofollow" target="_blank">本帖</a>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/8348c4bf1fbab72a1ec04a06055aed58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1180/format:webp/1*4JTwfPE_9_Ic9NkleXulzA.png"/></div></figure><h1 id="d58c" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated"><strong class="ak">迪杰斯特拉算法</strong></h1><h2 id="7d56" class="ms lw it bd lx mt mu dn mb mv mw dp mf lh mx my mh ll mz na mj lp nb nc ml nd bi translated">概念</h2><p id="4363" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">Dijkstra算法用于查找图中节点之间的最短路径。与BFS算法和DFS算法只在无权重图中寻找最短路径不同，Dijkstra算法可以用于有权重图和无权重图。在下一节中，我将解释如何实现算法来解决最短路径问题。</p><h2 id="45ac" class="ms lw it bd lx mt mu dn mb mv mw dp mf lh mx my mh ll mz na mj lp nb nc ml nd bi translated">问题陈述</h2><p id="a773" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">在一个充满非负数的<code class="fe ne nf ng nh b">m x n</code>网格上，我们可以在任何时间点向下或向右移动。目标是找到一条从左上到右下的路径，使路径上所有数字的总和最小。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi no"><img src="../Images/5d9121747d4b1e63d765f24602623945.png" data-original-src="https://miro.medium.com/v2/resize:fit:852/format:webp/1*WKN3CeDi6ZMx67ZOJ54kug.png"/></div></figure><h2 id="623c" class="ms lw it bd lx mt mu dn mb mv mw dp mf lh mx my mh ll mz na mj lp nb nc ml nd bi translated">分析</h2><p id="a430" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">这个问题本质上是一个加权无环图问题。如果你不熟悉graph，<a class="ae lu" href="https://en.wikipedia.org/wiki/Graph_(abstract_data_type)" rel="noopener ugc nofollow" target="_blank">这里是定义</a>。Dijkstra的算法非常适合在这样的加权图中寻找最短路径。</p><p id="9530" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面我描述Dijkstra的算法是如何实现来解决这个具体问题的。关于更一般和更高层次的描述，请参考<a class="ae lu" href="https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm#Algorithm" rel="noopener ugc nofollow" target="_blank">这个维基页面</a>。</p><ol class=""><li id="fecd" class="np nq it la b lb lc le lf lh nr ll ns lp nt lt nu nv nw nx bi translated">创建一个优先级队列(min heap) <code class="fe ne nf ng nh b">heap</code>来跟踪被访问的节点(本例中是单元)。每个节点到起始单元的距离是动态计算的，并用作优先级。<code class="fe ne nf ng nh b">heap</code>最初只包含起始节点，其单元值为优先级。</li><li id="687c" class="np nq it la b lb ny le nz lh oa ll ob lp oc lt nu nv nw nx bi translated">创建一个集合<code class="fe ne nf ng nh b">seen</code>来跟踪被访问并被识别为最短路径轨迹一部分的节点。<code class="fe ne nf ng nh b">seen</code>最初是空的。</li><li id="f8fa" class="np nq it la b lb ny le nz lh oa ll ob lp oc lt nu nv nw nx bi translated">当<code class="fe ne nf ng nh b">heap</code>不为空时:<br/> 1 <strong class="la iu"> ) </strong>得到一个到起始节点距离最短的节点(优先级最高)，将其添加到<code class="fe ne nf ng nh b">seen</code> <em class="od"> </em>中作为最短路径树的一部分。如果这是终点，我们返回距离。否则，我们进行下一步。<br/> 2 <strong class="la iu"> ) </strong>如果这个节点有邻居节点(右下)，将每个邻居及其距离(邻居的单元格值+当前节点的距离)加到<code class="fe ne nf ng nh b">heap</code>。</li></ol><p id="bd96" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">本质上，<code class="fe ne nf ng nh b">heap</code>存储所有节点到起始单元的距离(我将简称为距离)。如果被几个不同的路径访问，一个节点可以在<code class="fe ne nf ng nh b">heap</code>中出现多次。相反，<code class="fe ne nf ng nh b">seen</code>只跟踪距离最短的节点。例如，如果经由路径(0，0) → (1，0) → (1，1)访问，则中心节点(1，1)的距离可以是7，或者如果经由(0，0) → (0，1) → (1，1)访问，则可以是9。<code class="fe ne nf ng nh b">heap</code>将存储(7，1，1)和(9，1，1)，但是当我们从<code class="fe ne nf ng nh b">heap</code>弹出(9，1，1)时，因为(1，1)已经在<code class="fe ne nf ng nh b">seen</code>中了，我们只是传递这个值。这就是我们如何确保我们返回的最终距离位于从起始像元开始的最短路径轨迹上。</p><h2 id="7dc4" class="ms lw it bd lx mt mu dn mb mv mw dp mf lh mx my mh ll mz na mj lp nb nc ml nd bi translated">密码</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/331922343f2deb0733a4b2f49b99c06c.png" data-original-src="https://miro.medium.com/v2/resize:fit:860/format:webp/1*RW7i8Kz3J3PtjWAgE2CxaA.png"/></div></figure><h1 id="bd12" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated"><strong class="ak">一颗*(一颗星星)</strong></h1><h2 id="b990" class="ms lw it bd lx mt mu dn mb mv mw dp mf lh mx my mh ll mz na mj lp nb nc ml nd bi translated">概念</h2><p id="6131" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">A*类似于Dijkstra算法，因为它也用于查找最短路径，但它比Dijkstra算法执行得更好，因为它减少了非最佳访问并更快地找到最佳路径。</p><p id="bd3c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">回想一下，在Dijkstra的算法中，我们试图找到从起点到当前点的最小距离，这意味着我们倾向于接近起点的顶点。但是，我们还需要考虑从目标到当前点的距离。因为靠近起点的顶点不一定具有到目标的最短距离，所以我们最终在找到最优顶点之前访问了许多次优顶点。最佳路径上的顶点到两端的距离应该最短。然而，我们不知道从当前点到目标的距离，除非我们进行彻底的搜索，这违背了我们的目的。如果我们用某种试探法来近似它呢？这是A*的主要思想。</p><p id="e352" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">假设我们有一个启发式的从当前点<code class="fe ne nf ng nh b">s</code>到目标的距离<code class="fe ne nf ng nh b">h(s)</code>，我们知道从起点到当前点<code class="fe ne nf ng nh b">g(s)</code>的准确距离。为了确保试探法是正确的，它必须是满足以下条件的真实距离的最优低估(<a class="ae lu" href="https://en.wikipedia.org/wiki/Consistent_heuristic" rel="noopener ugc nofollow" target="_blank">一致</a>和<a class="ae lu" href="https://en.wikipedia.org/wiki/Admissible_heuristic" rel="noopener ugc nofollow" target="_blank">容许</a>):</p><ol class=""><li id="766a" class="np nq it la b lb lc le lf lh nr ll ns lp nt lt nu nv nw nx bi translated"><code class="fe ne nf ng nh b">g(s') + h(s') — h(s) &gt;= 0</code></li><li id="0156" class="np nq it la b lb ny le nz lh oa ll ob lp oc lt nu nv nw nx bi translated"><code class="fe ne nf ng nh b">h(s_target) == 0</code></li></ol><p id="4622" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">(<code class="fe ne nf ng nh b">s'</code>是下一个潜在点，<code class="fe ne nf ng nh b">s_target</code>是目标点)</p><p id="831c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">找到一个好的启发更多的是一个建模问题，但通常我们可以通过放松约束(消除障碍等)来获得一个好的启发。)并使用距离度量作为近似值。让我们看看如何做到这一点。</p><h2 id="0760" class="ms lw it bd lx mt mu dn mb mv mw dp mf lh mx my mh ll mz na mj lp nb nc ml nd bi translated">问题陈述</h2><p id="db53" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">假设我们有一个<code class="fe ne nf ng nh b">n x n</code>网格(用二进制矩阵表示)。我们可以在网格内的8个方向移动(上、下、左、右和4条对角线)。我们希望找到从左上角单元格到右下角单元格的所有值都为0的最短路径的长度。</p><p id="17a0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/6768dfb3be0be4fc199d7529580aa737.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n6t1En2evVs7xAnAD0GH9w.png"/></div></div></figure><h2 id="ff5c" class="ms lw it bd lx mt mu dn mb mv mw dp mf lh mx my mh ll mz na mj lp nb nc ml nd bi translated">分析</h2><p id="ceaa" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">又一个最短路径问题，耶！现在我们知道如何用Dijkstra的算法解决它，我们需要做的就是找到一个好的启发式算法并插入。由于在所有8个方向上的移动都是允许的，对角距离将是这个问题的一个好的距离度量。注意，通过使用对角线距离，我们自动忽略了单元格的值约束(1或0 ),从而放松了约束。</p><h2 id="945b" class="ms lw it bd lx mt mu dn mb mv mw dp mf lh mx my mh ll mz na mj lp nb nc ml nd bi translated">密码</h2><p id="5921" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">首先，一个助手函数返回所有8个邻居。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="a0bc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在函数<code class="fe ne nf ng nh b">a_star</code>中，我们有一个实现对角线距离的内部函数<code class="fe ne nf ng nh b">get_heuristic</code>。其逻辑与我们在上一节中讨论的Dijkstra算法非常相似，唯一的区别是优先级是启发式值和距离的总和。我们还做了一个小的性能改进:缓存被访问单元的最高优先级(启发式值和距离的最小和)。这样，已经被访问过的并且先前具有较高优先级的单元将不会被再次添加到优先级队列中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="f766" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了比较，我们也实现了Dijkstra的算法来解决这个问题。我在这里就不赘述了，因为我们在上一节已经谈过了。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="55e6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们打印出结果和两个函数的轨迹。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="4c9c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">两种算法都能够找到最短距离11。然而，A*比Dijkstra算法更快地找到目标，因为它访问的次优单元更少，如打印输出所示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/d4412693063bc474203a58c4bc705447.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0ooarM59zE6cQ5m2hQJXHw.png"/></div></div></figure><h1 id="1037" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">结论</h1><p id="4133" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">在本文中，我们学习了几种有用的搜索算法，并从头开始实现了它们。我在开始时提到了一些搜索问题的用例，但事实上在今天的现实世界中，大多数这些问题都是通过强化学习(RL)来解决的。如果我们有一个人工智能的智能测量，我们会说搜索问题与RL相比处于较低的智能水平，因为:</p><p id="cab3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">1)仅当我们有已知的世界模型时才应用搜索，这意味着我们必须找出通常非常困难的模型。另一方面，RL对已知(基于模型)和未知模型(无模型)都有效；</p><p id="7489" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">2)搜索只能在小的问题空间上工作，而RL可以解决具有大的状态和动作空间的问题。</p><p id="c94e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你有兴趣了解更多关于强化学习的基础知识，请查看我的文章<a class="ae lu" rel="noopener" target="_blank" href="/an-overview-of-classic-reinforcement-learning-algorithms-part-1-f79c8b87e5af">强化学习算法的结构概述</a>。我也有关于实现两个流行的RL算法的教程:<a class="ae lu" rel="noopener" target="_blank" href="/deep-reinforcement-learning-build-a-deep-q-network-dqn-to-play-cartpole-with-tensorflow-2-and-gym-8e105744b998"/>和<a class="ae lu" rel="noopener" target="_blank" href="/policy-gradient-reinforce-algorithm-with-baseline-e95ace11c1c4">策略梯度</a>。</p><p id="8ce9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我希望你喜欢这篇文章。:)</p><h1 id="cd39" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">参考</h1><div class="oh oi gp gr oj ok"><a href="https://leetcode.com/problems/shortest-path-in-binary-matrix/" rel="noopener  ugc nofollow" target="_blank"><div class="ol ab fo"><div class="om ab on cl cj oo"><h2 class="bd iu gy z fp op fr fs oq fu fw is bi translated">二元矩阵中的最短路径- LeetCode</h2><div class="or l"><h3 class="bd b gy z fp op fr fs oq fu fw dk translated">给定一个n×n二进制矩阵网格，返回矩阵中最短畅通路径的长度。如果没有明确的…</h3></div><div class="os l"><p class="bd b dl z fp op fr fs oq fu fw dk translated">leetcode.com</p></div></div><div class="ot l"><div class="ou l ov ow ox ot oy ks ok"/></div></div></a></div><div class="oh oi gp gr oj ok"><a href="https://leetcode.com/problems/minimum-path-sum/" rel="noopener  ugc nofollow" target="_blank"><div class="ol ab fo"><div class="om ab on cl cj oo"><h2 class="bd iu gy z fp op fr fs oq fu fw is bi translated">最小路径和- LeetCode</h2><div class="or l"><h3 class="bd b gy z fp op fr fs oq fu fw dk translated">给定一个填充有非负数的m x n网格，找出一条从左上到右下的路径，使和最小化…</h3></div><div class="os l"><p class="bd b dl z fp op fr fs oq fu fw dk translated">leetcode.com</p></div></div><div class="ot l"><div class="oz l ov ow ox ot oy ks ok"/></div></div></a></div><div class="oh oi gp gr oj ok"><a href="https://leetcode.com/problems/unique-paths/" rel="noopener  ugc nofollow" target="_blank"><div class="ol ab fo"><div class="om ab on cl cj oo"><h2 class="bd iu gy z fp op fr fs oq fu fw is bi translated">唯一路径- LeetCode</h2><div class="or l"><h3 class="bd b gy z fp op fr fs oq fu fw dk translated">一个机器人位于一个m x n网格的左上角(在下图中标为“开始”)。机器人只能…</h3></div><div class="os l"><p class="bd b dl z fp op fr fs oq fu fw dk translated">leetcode.com</p></div></div><div class="ot l"><div class="pa l ov ow ox ot oy ks ok"/></div></div></a></div></div></div>    
</body>
</html>