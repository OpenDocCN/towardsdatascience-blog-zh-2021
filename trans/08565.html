<html>
<head>
<title>Machine Learning is Not All-Powerful: the No Free Lunch Theorem</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">机器学习不是万能的:没有免费的午餐定理</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/machine-learning-is-not-all-powerful-the-no-free-lunch-theorem-16bdcd84c36?source=collection_archive---------20-----------------------#2021-08-07">https://towardsdatascience.com/machine-learning-is-not-all-powerful-the-no-free-lunch-theorem-16bdcd84c36?source=collection_archive---------20-----------------------#2021-08-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="161b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">有没有单一的机器学习算法可以学习一切？遗憾的是，没有。请继续阅读，找出原因。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c54f6cb58917f87671ae2af2a5e0aa75.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*oP2MgmlFCkAjUFwG"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@possessedphotography?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">附身摄影</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</p></figure><p id="8d61" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">围绕机器学习有很多合理的炒作。过去十年中，机器学习完成的一些事情(例如AlphaGo)确实令人惊叹。然而，有些人夸大其词了——他们声称最终我们会找到一种可以学习宇宙中任何东西的机器学习算法。不幸的是，实际上有一个重要的定理表明情况不是这样的。这就是“没有免费的午餐”定理。该定理的名称与习语“天下没有免费的午餐”有关，该理论认为，如果你想要某样东西(在我们的例子中，在一个领域学得好)，你必须放弃某样东西(在我们的例子中，在另一个领域学得不好)。理解免费午餐定理的细节将有助于你更好地理解机器学习的理论基础，并防止你被关于机器学习的荒诞说法所欺骗。让我们从几个例子开始。</p><h1 id="36fd" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">例子</h1><p id="cc6a" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我们有一枚公平的硬币，我们抛两次。有四种可能的历史:HH，HT，TH，TT。我们的目标是给定第一次翻转，预测第二次翻转。因为硬币是公平的，所以四史的可能性是相等的。很明显，在这种情况下，没有“主算法”可以正确预测所有历史。例如，假设我的算法是，如果第一次翻转是H，则预测H，如果第一次翻转是T，则预测T。我将得到正确的HH和TT历史，而错误的ht和t H历史。我可以使用反向算法来正确预测HT和TH，但这样我会把HH和TT弄错。关键是，无论你如何努力，都不可能有超过50%的历史是正确的。这是满足“没有免费的午餐”定理的一种方式——这项任务如此困难，以至于没有有效的学习算法。</p><p id="b804" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，你可能会问:那么，如果硬币不公平呢？如果硬币的重量偏向正面，那么在第二次投掷时总是预测H的算法不是表现得很好吗？这是真的。然而，同样的算法在一枚硬币上表现不佳，硬币重于尾部。这是第二种，也是更常见的满足“没有免费的午餐”定理的方式。通常，对于任何给定的任务，都存在一个运行良好的算法(不像我们的第一个公平硬币的例子，没有算法工作)。关键是这个算法在其他任务上效果不好。</p><p id="d4e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这两个例子演示了两种不同的方法来证明没有免费的午餐算法。一种方法是找一个任务，这个任务太难了，所有算法都学不好。另一种方法是，对于任何给定的算法，找到该算法学习较差的任务。我们将采用第二种方法。下面的证明有一些实质性的符号，所以我们将首先解释设置。</p><h1 id="dd04" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">证据</h1><p id="d71f" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">设C是一组唯一的数据点。假设C中有2m个这样的数据点，换句话说，C的大小是2m。这可能看起来很奇怪，我们用2m来表示大小，而不仅仅是变量m，但这对以后的证明很重要。我们认为这是一个二元分类问题，所以所有这些数据点要么映射到0，要么映射到1。现在，我们要问的第一个问题是:C语言中有多少种可能的函数？因为c有2m个数据点，并且每个数据点映射到0或1 (2个选择)，所以总共有T = 2^(2m)个可能的函数。在这个证明中，我们将用I来索引这些函数——例如，第一个可能的函数我们记为f1，第二个函数是F2，第I个可能的函数是f1</p><p id="bd6f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，用A表示一个任意的学习算法，A的工作方式是，首先我们决定我们要学习什么函数f_i。然后，A将一系列数据点S(训练样本)作为输入，这些数据点根据f_i具有正确的{0，1}标签，然后在处理该序列后输出它学习A(S)的函数。训练样本的大小为m。因为c中总共有2m个元素，并且一个样本有m个元素，所以总共有K = (2m)^m)个可能的样本。我们用j来索引这些样本，例如，第j个可能的样本是S_ j。</p><p id="b74d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们需要讨论损失函数。假设我们已经决定用样本S_ j来学习函数f_i，学习算法A完成后，它会输出A(S_j)，这是它学习到的函数。我们的损失函数的目标是表示f_i和A(S_ j)之间的差异。在这个证明中，我们将使用0–1损失:我们将逐一检查C中的所有2m个元素，并找出f_i不同于A(S_ j)的实例数。我们将这个数字除以2m，得到最终的损失。简单来说:L(f_i，A(S_ j))是C中2m个元素的百分比，其中f_i和A(S_ j)不同。</p><p id="b3b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们继续证明之前，让我们再回顾一下设置。我们有一个大小为2m的域C，它的元素映射到{0，1}。存在T = 2^(2m)个可能的函数，索引为f_i。我们表示可以尝试学习这些f_i的任意学习算法a。学习过程的第一步是从c中抽取大小为m的样本，并决定要学习的函数。有K = (2m)^m)个可能的样本，索引为S_ j。然后在样本上训练a，将得到的学习函数与真实函数进行比较，损失为0–1。</p></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><p id="0256" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">证明的总体思路是这样的:对于任意的学习算法A，我们将证明存在某个函数f，其中A试图学习f(在所有可能的样本上)的期望误差大于1/4。换句话说，对于任何可能的学习算法，总有一些函数是学不好的。用数学术语来说，我们想表明:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mz"><img src="../Images/fb86c2bed133eb8e1d6ba9122e85fec9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eGg6oxXqtzRj8G7fef2Miw.png"/></div></div></figure><p id="df0f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了理解这个等式，我们从内部开始。总和内的损失函数表示当我们尝试使用样本S_j训练A来学习函数f_i时的损失，对所有可能的样本求和，然后除以样本总数K，得到A尝试在所有可能的样本上学习f_i的平均损失(换句话说，A对f_i的预期误差)。给定学习算法A，我们希望找到具有最高期望误差的函数，并证明它大于1/4，因此是I上的max。</p><p id="d2b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下一步是做一些操作:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi na"><img src="../Images/9890ab2392845a333fa1bba9ef151912.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GMw-2WdAPImkHA8HaA1zOg.png"/></div></div></figure><p id="3726" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们利用I上的最大值小于I上的平均值的性质。然后，我们交换求和的顺序。最后，我们使用j上的平均值大于j上的最小值的性质。接下来，我们的目标是扩展和的内部——损失函数。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nb"><img src="../Images/02eaf8adcf01ce0af81b7c5e727f7832.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3dIT15SUy-1K92l1-QOl_A.png"/></div></div></figure><p id="62b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如前所述，损失函数是真实函数f_i和学习函数A(S_ j)之间的0–1损失。奇怪字体的数字1是一个指示函数。简单来说，indicator函数在inside求值为true时求值为1，inside为false时求值为0。</p><p id="f748" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，考虑集合C \ S_ j，或者C中没有被选择包含在样本S_ j中的元素(在集合符号中，\符号表示排除)。设p代表这个集合中元素的个数。由于C的大小是2m，样本S_ j是用大小为m的替换来选择的，p = 2m -|S_ j| &gt;= m .我们将用r和v来索引C \ S_ j的元素(例如，C \ S_j的第r个元素是v_r)。这有什么意义？在上述损失函数的展开式中，我们可以用C \ S_j代替C，方法如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nc"><img src="../Images/7c05add8dc1f560800bc1c5b26c13c61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kka-IQTtKG9dEqAOqv06ww.png"/></div></div></figure><p id="3be5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我们使用了两个观察值。首先，我们使用p &gt;= m，如前所述。第二，我们利用了C \ S_ j(右边的和)中的每一个元素都包含在C(左边的和)中的事实。因此，左边的和更大。综合我们目前掌握的信息，我们有:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nd"><img src="../Images/0fc040a0df177ecd3cd49e94544a4e1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NOp-FwAistn-cmiDLnMuCw.png"/></div></div></figure><p id="9790" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们已经接近尾声了。看看这个表情:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/518d28779863568e054bd44096fa9612.png" data-original-src="https://miro.medium.com/v2/resize:fit:1376/format:webp/1*A4-YIh2tDsiyBqCEQc-Ztg.png"/></div></figure><p id="ba23" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们来看这个证明的关键。<strong class="lb iu">注意，对于任意函数f_i，我们可以构造另一个除v_r外与f_i完全相同的函数f _ I’</strong>换句话说，对于C中除v_r外的所有元素x，我们有f _ I(x)= f _ I’(x)。而对于v_r，我们有f_i(v_r) ≠ f_i'(v_r)。所有可能的函数都可以这样配对。对于每一对函数，上面的指示函数对其中一个函数的评估值为1，对另一个函数的评估值为0。因此，T/2对中的每一对将对总和贡献1 + 0 = 1。因此，表达式的计算结果为T/2。插上这个，我们有:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nf"><img src="../Images/0d872420496eb09b1d4168b5d4fe9b27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VnVg29_qeIGN-GQY0yfbkQ.png"/></div></div></figure><p id="3a19" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们结束了。</p><p id="092c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关于这个证明，我们应该再说一句。为什么我们要费这么大的劲去看集合C \ S_ j？难道我们不能在集合C本身上使用相同的自变量(将域中只有一个元素不同的函数配对)，而不是在C \ S_ j上吗？答案是否定的。原因是，如果f_i和f_i '之间的一个不同元素在S_ j中，则试图训练f_i的A(S_ j)将<strong class="lb iu">输出与试图训练f_i '的A(S_j)不同的函数</strong>。然后，配对论点不再有效，因为即使f_i(v_r)和f_i’(v _ r)仍然不同，我们也没有办法保证A(S_ j)(v_r)对于f _ I和f _ I’是相同的。</p></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><p id="1811" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们介绍了没有免费的午餐定理，看了几个简单的例子来建立我们的直觉，然后进行了数学证明。我知道这个证明有点复杂，所以请随时留下任何问题/评论。感谢阅读！</p></div></div>    
</body>
</html>