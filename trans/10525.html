<html>
<head>
<title>Tutorial on Surface Crack Classification with Visual Explanation (Part 1)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">表面裂纹分类及直观解释教程(一)</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/tutorial-on-surface-crack-classification-with-visual-explanation-part-1-14542d2ea7ac?source=collection_archive---------19-----------------------#2021-10-07">https://towardsdatascience.com/tutorial-on-surface-crack-classification-with-visual-explanation-part-1-14542d2ea7ac?source=collection_archive---------19-----------------------#2021-10-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="066a" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">用Pytorch开发可解释的人工智能对表面裂纹图像进行分类的分步指南。这是2部分系列的第1部分。</h2></div><h1 id="d74e" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated"><strong class="ak">简介</strong></h1><p id="5f9d" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我们处在人工智能时代。许多技术的发展使工程师的生活变得更加轻松。然而，土木工程领域似乎仍在努力跟上这一发展的步伐。</p><p id="9bf2" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">基础设施迅速恶化，接近其设计寿命。因为基础设施经常在恶劣的环境中运行。例如，在道路和桥梁上有持续的负载和振动。此外，还有多种灾害，如地震、洪水、飓风、龙卷风或海啸一年到头都会发生。如果只考虑美国的桥梁，全国桥梁库存中有60多万座公路桥。39%超过了50年的设计寿命。国家桥梁检查标准要求桥梁每两年检查一次，以确保没有裂缝、生锈或其他损坏。这意味着，每天都有数百座桥梁需要检查。当前的基础设施检查系统存在许多问题。例如，数据收集非常耗时，可能需要使用许多重型设备进行危险的野外活动。有时，对于高架桥梁结构来说，可达性是一个问题。此外，人类视觉检查可能存在偏见。因此，视觉检查的结果在不同的检查员之间会有很大的不同。</p><p id="688d" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">一种可能的解决方案是使用机器人平台来收集检查视频数据。使用空中平台收集检查视频数据减少或消除了劳动密集型的现场检查过程，并允许检查员从更安全的位置评估桥梁。</p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi ly"><img src="../Images/ea3d9dde2cb3c1240bd584e3d0db6b84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*LW4hobo4_t65eJYV"/></div></div><p class="mk ml gj gh gi mm mn bd b be z dk translated">照片由<a class="ae mo" href="https://unsplash.com/@jakobowens1?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">雅各布·欧文斯</a>在<a class="ae mo" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="c028" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">然而，机器人检测平台的使用仅仅解决了上述问题的一部分，高效、可靠的检测视频分析是另一项重要任务。让检查员观看收集的视频几个小时甚至几天来寻找漏洞是低效的。希望能够开发一种工具来帮助检查员从视频或图像中提取不同类型的裂纹。</p><p id="1bd9" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">为了自动化这个检查过程，本文将使用人工智能对图像进行分类，以找到图像中的裂缝。更具体地说，我们将使用Pytorch建立和训练一个深度神经网络来寻找图像中的裂缝，以取代人类对结构中的裂缝进行分类的繁琐任务。</p><p id="5adb" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">好了，今天的动力足够了。现在，让我们直奔主题。我们要做以下三件事:</p><ol class=""><li id="2c73" class="mp mq iq kz b la lt ld lu lg mr lk ms lo mt ls mu mv mw mx bi translated">使用PyTorch从头开始创建深度神经网络</li><li id="ad40" class="mp mq iq kz b la my ld mz lg na lk nb lo nc ls mu mv mw mx bi translated">实现一个可解释的人工智能工具来解释深度神经网络做出的决定</li></ol><p id="0fd2" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">为了不把博客写得太长，我把上面的两个内容分成了两个系列。这是这个系列的第一部分。另一部分的链接在这个博客的末尾。</p></div><div class="ab cl nd ne hu nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ij ik il im in"><h1 id="635b" class="kf kg iq bd kh ki nk kk kl km nl ko kp jw nm jx kr jz nn ka kt kc no kd kv kw bi translated"><strong class="ak"> 1。深度神经网络与Pytorch </strong></h1><p id="5810" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">现在，让我们使用PyTorch创建一个深度神经网络。我将向您展示创建用于图像分类的深度神经网络的所有步骤。作为一个应用程序，我将对图像中的表面裂纹进行分类。阅读完博客后，你将能够使用与本文相同的步骤，为你选择的任何不同应用领域进行图像分类。所以请原谅我。</p><p id="f647" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">要创建分类器，我们将遵循4个步骤:</p><ol class=""><li id="79c1" class="mp mq iq kz b la lt ld lu lg mr lk ms lo mt ls mu mv mw mx bi translated">数据准备</li><li id="2f13" class="mp mq iq kz b la my ld mz lg na lk nb lo nc ls mu mv mw mx bi translated">构建模型</li><li id="2c16" class="mp mq iq kz b la my ld mz lg na lk nb lo nc ls mu mv mw mx bi translated">培养</li><li id="c805" class="mp mq iq kz b la my ld mz lg na lk nb lo nc ls mu mv mw mx bi translated">测试和推理</li></ol><h1 id="7daa" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">数据准备</h1><p id="1b72" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">首先，我们要为我们的分类准备一个数据集。正如我已经提到的，我们将从图像中对表面裂缝进行分类，我们将使用裂缝数据集。我们将使用Mendeley [1] (License: CC BY 4.0)数据集的子集。你可以从这个<a class="ae mo" href="https://drive.google.com/drive/folders/1HMhZR9erch7OHL3X-HCrdU3-JCxxPDcx?usp=sharing" rel="noopener ugc nofollow" target="_blank">链接</a>下载数据集。如果你愿意，你可以从他们的网站上下载，直接使用门德利数据集。</p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi np"><img src="../Images/a3a0a6af83a95658d8cfcc16dbd7d94d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6uEEdR69fdHlV57UYkez7Q.png"/></div></div><p class="mk ml gj gh gi mm mn bd b be z dk translated">阳性门德利[1]数据。图片作者。</p></figure><p id="79c3" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">无论如何，我们将使用这个数据集的小子集，因为我们的主要目标是建立一个神经网络。该数据集总共有1200张(600张正片+ 600张底片)大小为227 x 227的图像。然后将其分成80%训练数据和20%测试数据。请下载数据集，并将其放在您的工作目录中。最初的文件夹结构将是这样的，蓝色的是文件夹，白色的是文件(我们稍后会添加更多的文件和文件夹)。</p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/5ebafeb738d8c4034a9558977dbdb507.png" data-original-src="https://miro.medium.com/v2/resize:fit:420/format:webp/1*lPo90ADz5fa-QZQQvQcjMA.png"/></div><p class="mk ml gj gh gi mm mn bd b be z dk translated">文件夹结构。图片作者。</p></figure><p id="493b" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">为了加载数据，我们将创建一个名为“dataloader.py”的python文件，如您在“src”文件夹中所见。</p><p id="77ae" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">首先，我们需要导入一些必需的包:</p><figure class="lz ma mb mc gt md"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="e862" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated"><strong class="kz ir"> torch.utils.data </strong>导入创建和使用数据集和数据加载器所需的函数。</p><p id="b01c" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">PIL是一个流行的计算机视觉库，用于在我们的python程序中加载图像。</p><p id="fc7b" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">现在让我们创建一个自定义数据集类，我们将该类命名为CrackDataset。</p><figure class="lz ma mb mc gt md"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="ece7" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated"><strong class="kz ir">类crack Dataset(Dataset):<em class="nt"/></strong>创建一个名为‘crack Dataset’的类。我们可以在任何地方调用这个类。它将被传递给我们之前导入的“数据集”模块。</p><p id="c07a" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated"><strong class="kz ir"> def __init__(self，data_path，phase，transform): </strong>初始化类后我们需要传递三个变量。data_path是我们数据集的目录。我们将通过阶段=训练或测试。转换来执行输入数据转换。当我们将这些信息传递给我们的类CrackDataset时，我们将对此进行更多的讨论。我们创建一个名为self.data的列表，其中包含图像路径对及其各自的标签。我们还希望将所有负类映射为0，正类映射为1。</p><p id="152c" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated"><strong class="kz ir"> def __len__(self): </strong>该函数返回标签的长度。</p><p id="3cc6" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated"><strong class="kz ir"> <em class="nt"> def __getitem__(self，idx):</em></strong>py torch的数据集模块使用该函数获取样本并构造数据集。初始化时，它将循环通过该函数，从数据集中的每个实例创建一个样本。它定义了(x，y)或(图像，标签)对。pytorch内部使用Index (idx)来跟踪所有数据并创建批处理。它还跟踪所有的批次。简单地说，它负责我们定制数据集的所有簿记工作。这里，self.data是包含图像路径及其类名的列表。对于每个索引，我们将有一对img_path和class_name。然后使用PIL图书馆，我们加载图像，并将其转换为RGB格式。之后，我们使用self.transform将图像转换为张量和其他一些东西(稍后你会看到我们将使用什么转换)。PyTorch损失函数的一个要求是，在馈送到CNN网络之前，输入必须是张量形式，所以我们将其转换为浮点和张量。</p><p id="1f47" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">现在，我们已经创建了自定义的数据加载器。编译文件“dataloader.py”中的所有代码，并将该文件放在文件夹“src”中。</p></div><div class="ab cl nd ne hu nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ij ik il im in"><h1 id="0396" class="kf kg iq bd kh ki nk kk kl km nl ko kp jw nm jx kr jz nn ka kt kc no kd kv kw bi translated">构建模型</h1><p id="e923" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">现在，让我们在model.py文件中创建我们的模型，并将其放在“src”文件夹中。</p><figure class="lz ma mb mc gt md"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="356c" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">我们将使用迁移学习。你可能知道迁移学习。这是一种技术，我们使用预先训练的模型，这些模型已经在大型数据集上进行了训练。我们将使用训练过的重量来开始我们的训练。我们唯一要做的事情是，我们需要修改模型的最后几层，并且只更新这些层的权重。</p><p id="7164" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">Torchvision有许多内置的CNN模型，如VGG16、ResNet、Inception等等。我们只需要导入它们。这里我们要用ResNet架构。</p><p id="b48e" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">我们将创建一个名为CrackClassifier的类。它将使用nn。PyTorch的模块。self.resnet将从torchvision下载预训练的resnet50模型。从代码中可以看出，我们修改了self.resnet.fc，依次添加了两个线性图层一个ReLU和一个LogSoftmax。您可以看到，在最后一个线性图层中，我们将输入要素映射到num_classes。这意味着我们的输出节点将等于我们的类的数量。如果您想使用自己的CNN架构，只需用它替换self.resnet即可。</p><p id="42d3" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">def forward函数定义了我们的模型在接受输入后将如何运行。这里，在我们的例子中，它将接受输入特征(x ),并将通过我们已经定义的self.resnet。</p></div><div class="ab cl nd ne hu nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ij ik il im in"><h1 id="f020" class="kf kg iq bd kh ki nk kk kl km nl ko kp jw nm jx kr jz nn ka kt kc no kd kv kw bi translated">训练网络</h1><p id="8d52" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我们将创建一个名为train.py的文件，并将其保存在主目录中，如图文件夹结构所示。首先，让我们导入所需的库:</p><figure class="lz ma mb mc gt md"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="0288" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">如果你看看代码，从第1–4行我们从torch导入了一些我们以前见过的库。在第6行和第7行，注意我们使用了“来自src.model”和“src.dataloader”。请记住，在“src”文件夹中，我们已经创建了两个python文件model和dataloader。我们将分别从这两个文件中导入class CrackClassifier和class CrackDataset。在第8行中，我们导入了tqdm，它将用于显示训练进度。操作系统模块将用于定义目录。我们将使用tensorboardX的SummaryWriter来可视化我们的培训和测试性能。第12行确保如果我们有GPU，那么它将使用GPU，否则将使用CPU进行计算。</p><figure class="lz ma mb mc gt md"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="bab8" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">torchvision.transform库帮助我们对输入图像进行大量处理。例如，这里的Resize选项确保我们所有的图像都是64 x 64的。然后，我们使用to tensor选项将图像转换为张量。最后，我们归一化图像。这里，在归一化选项中，第一个元组是平均值，第二个元组是所有批次的三个RGB通道的标准偏差。您还可以在这里使用不同的数据扩充技术。</p><figure class="lz ma mb mc gt md"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="4fa9" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">接下来，我们需要为我们的训练定义超参数。例如，时期数、学习率、批量大小。之后，我们需要设置数据集和数据加载器。对于训练和测试，我们使用CrackDataset类分别设置两个数据集。设置完这两个数据集后，我们使用pytorch的数据加载器来创建我们的训练和测试数据加载器，分别命名为train_dataloader和test_dataloader。</p><p id="80f5" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">现在，在我们进入训练循环之前，首先创建一个函数来检查我们模型的准确性。我们将调用训练循环中的函数来检查测试数据集的准确性。</p><figure class="lz ma mb mc gt md"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="75d5" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">使用我们的模型，我们将得到输出，该输出将与该图像的地面真实标签进行比较，以计算准确性。这非常简单，看代码就能很容易理解，所以我跳过了详细的解释。</p><p id="c173" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">现在我们将创建两个更简单的函数来使用tensorboard的summary writer。这样我们可以用图表的形式直观地显示每个时期的损失和精度。</p><figure class="lz ma mb mc gt md"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="172b" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">现在，让我们创建一个训练循环:</p><figure class="lz ma mb mc gt md"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="d014" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">从第2–8行，创建我们的目录来保存训练好的模型和我们的日志。第9行在我们的日志目录中创建了一个摘要编写器。</p><p id="efec" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">第11行，使用我们创建的名为CrackClassifier的类来创建我们的模型。标准是损失函数。我们将使用pytorch模块nn中的CrossEntropyLoss函数。然后，我们定义优化器，使用梯度下降优化网络。我们使用torch.optim中流行的Adam优化器。</p><p id="ea69" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">回想一下，我们的模型中有两个完全连接的层。我们只想更新这两层的权重。我们可以冻结其余层的权重。第16–22行将为我们做这些。我们的fc.0和fc.2是两个完全连接的层。我们希望更新这两层的权重和偏差项。因此，对于这两个层，我们设置param.requires_grad= True。对于其余的层，它是假的。那就是我们冻结了其余的层。</p><p id="bc41" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">第24行开始训练。然后我们循环遍历历元数。对于每个时期，我们在训练装载器中迭代所有批次的图像和标签。在每两个时期之后，我们使用test_loader检查测试数据集的准确性，并使用我们之前创建的write_test_scalars()函数将准确性写入记录器。我们使用模型的输出，并使用预定义的损失函数计算损失。在我们进行反向传播以计算梯度之前，我们必须执行optimizer.zero_grad()操作——这将清空前一批的梯度张量，以便重新计算新一批的梯度。现在，为了执行反向传播，我们使用loss.backward()。注意，我们使用了tqdm。这用于通过进度条显示训练进度。然后使用write_scalars()函数，我们写下每个时期的损失。当测试数据集上的精确度最高时，我们保存模型。最后，我们使用logger.close()关闭摘要编写器。</p><p id="7079" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">现在，我们已经准备好了所有的代码。我们需要运行代码。要运行训练代码，在您的终端上键入:“python train.py”。它将训练网络，将训练好的模型保存在“快照”中，并将日志保存在“日志”文件夹中。</p><p id="8630" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">要可视化您的tensorboard，请在您的终端上键入以下内容:</p><figure class="lz ma mb mc gt md"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="f412" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">之后，进入你的浏览器，在地址栏输入:“localhost:6006”。然后，您可以在tensorboard中看到您的训练表现，如下所示:</p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi nu"><img src="../Images/4e0c3c4e7f0f742bd73c5b97a309e3db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*03s6Xa6wB-tEKBopNkKa0Q.png"/></div></div><p class="mk ml gj gh gi mm mn bd b be z dk translated">作者图片</p></figure><p id="abcf" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">看，我们模型的性能逐渐提高。</p></div><div class="ab cl nd ne hu nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ij ik il im in"><h1 id="ad3c" class="kf kg iq bd kh ki nk kk kl km nl ko kp jw nm jx kr jz nn ka kt kc no kd kv kw bi translated">结论</h1><p id="ddc5" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">在这一部分中，您已经了解了如何创建自定义数据加载器，如何使用迁移学习构建CNN模型，如何训练网络，以及如何使用tensorboard记录训练表现。在下一部分中，我们将看到如何使用我们训练好的模型来预测不同图像上的裂缝类别。这意味着我们将使用训练好的模型进行推理。最后，我们将使用grad-cam工具来解释我们网络的决策。请点击查看本博客的下一部分。</p><p id="ed23" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">你可以在<a class="ae mo" href="https://github.com/monjurulkarim/crack_classification" rel="noopener ugc nofollow" target="_blank"> Github </a>中找到完整的代码。下载<a class="ae mo" href="https://drive.google.com/drive/folders/1HMhZR9erch7OHL3X-HCrdU3-JCxxPDcx?usp=sharing" rel="noopener ugc nofollow" target="_blank">数据集</a>。</p><p id="df79" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">参考资料:</p><ol class=""><li id="b94b" class="mp mq iq kz b la lt ld lu lg mr lk ms lo mt ls mu mv mw mx bi translated">奥兹杰内尔，恰拉尔·弗拉特(2019)，<a class="ae mo" href="https://data.mendeley.com/datasets/5y9wdsg2zt/2" rel="noopener ugc nofollow" target="_blank">“用于分类的混凝土裂缝图像”</a>，门德利数据，V2，doi: 10.17632/5y9wdsg2zt.2。(许可:CC BY 4.0)</li></ol></div></div>    
</body>
</html>