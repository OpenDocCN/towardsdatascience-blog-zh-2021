<html>
<head>
<title>Part 2 — Building a deep Q-network to play Gridworld — Catastrophic Forgetting and Experience Replay</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">第二部分——构建深度 Q 网络玩 grid world——灾难性遗忘和经验重演</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/part-2-building-a-deep-q-network-to-play-gridworld-catastrophic-forgetting-and-experience-6b2b000910d7?source=collection_archive---------10-----------------------#2021-12-05">https://towardsdatascience.com/part-2-building-a-deep-q-network-to-play-gridworld-catastrophic-forgetting-and-experience-6b2b000910d7?source=collection_archive---------10-----------------------#2021-12-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><blockquote class="jn jo jp"><p id="ac7e" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated">在这篇文章中，我们来讨论一下普通 Q 学习模型中的问题:灾难性遗忘。我们将使用经验回放来解决这个问题，看看我们在玩 GridWorld 时所做的改进</p></blockquote><p id="11c5" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">欢迎来到深度 Q-网络教程的第二部分。这是<a class="ae ks" href="https://nandakishorej8.medium.com/part-1-building-a-deep-q-network-to-play-gridworld-deepminds-deep-q-networks-78842007c631" rel="noopener">第一部</a>的延续。如果你还没有阅读第 1 部分，我强烈建议你通读一遍，因为这篇文章中的许多代码和解释将直接关系到那些已经在<a class="ae ks" href="https://nandakishorej8.medium.com/part-1-building-a-deep-q-network-to-play-gridworld-deepminds-deep-q-networks-78842007c631" rel="noopener">第 1 部分</a>中解释过的。</p><p id="58b9" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated"><strong class="jt ir">至今</strong> <a class="ae ks" href="https://nandakishorej8.medium.com/part-1-building-a-deep-q-network-to-play-gridworld-deepminds-deep-q-networks-78842007c631" rel="noopener"> <strong class="jt ir">第一部</strong> </a> <strong class="jt ir">！！</strong></p><ol class=""><li id="408f" class="kt ku iq jt b ju jv jy jz kp kv kq kw kr kx ko ky kz la lb bi translated">我们从理解什么是 Q 学习和用于更新 Q 学习的公式开始</li><li id="784c" class="kt ku iq jt b ju lc jy ld kp le kq lf kr lg ko ky kz la lb bi translated">后来我们看到了 GridWorld 游戏，并定义了它的状态、动作和奖励。</li><li id="f9a7" class="kt ku iq jt b ju lc jy ld kp le kq lf kr lg ko ky kz la lb bi translated">然后我们想出了一个强化学习的方法来赢得比赛</li><li id="60ea" class="kt ku iq jt b ju lc jy ld kp le kq lf kr lg ko ky kz la lb bi translated">我们学习了如何导入 GridWorld 环境和环境的各种模式</li><li id="dc8d" class="kt ku iq jt b ju lc jy ld kp le kq lf kr lg ko ky kz la lb bi translated">设计并建立了一个神经网络作为 Q 函数。</li><li id="6ac0" class="kt ku iq jt b ju lc jy ld kp le kq lf kr lg ko ky kz la lb bi translated">我们对 RL 代理进行了训练和测试，在解决静态网格世界问题上取得了很好的效果。但我们未能解决随机网格世界。</li><li id="324f" class="kt ku iq jt b ju lc jy ld kp le kq lf kr lg ko ky kz la lb bi translated">我们了解问题所在，并承诺在本文中解决问题</li></ol><p id="f4d1" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated"><strong class="jt ir">什么问题？？</strong></p><blockquote class="jn jo jp"><p id="067d" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated">我们能够在静态环境中训练我们的模型，每次模型在相同的位置看到物体、玩家和目标。但是当代理接受更复杂的初始化训练时，每次创建新的一集时，环境都会被随机初始化，它无法学习。</p></blockquote><p id="8830" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">上述问题的名称是灾难性遗忘。这是一个与基于梯度下降的训练相关的重要问题，当我们在游戏中的每个动作后反向移动时，我们称之为在线训练。</p><p id="15af" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">灾难性遗忘的想法是，当两个游戏状态非常相似，但却导致非常不同的结果时，Q 函数将变得“混乱”,无法知道该做什么。在下面的例子中，灾难性的遗忘发生了，因为 Q 函数从游戏 1 中得知向右移动会得到+1 的奖励，但是在游戏 2 中，看起来非常相似，向右移动后它会得到-1 的奖励。结果，该算法忘记了它先前学习的关于游戏 1 的内容，导致基本上根本没有显著的学习。</p><figure class="li lj lk ll gt lm gh gi paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="gh gi lh"><img src="../Images/fee256624faf002c28e95668b1c3a46b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C3TCXyDyrRQPTMPlcp0QqA.png"/></div></div><p class="lt lu gj gh gi lv lw bd b be z dk translated">图 1:紧密相关的状态导致灾难性遗忘</p></figure><p id="5c9e" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">灾难性遗忘的原因是我们在游戏的每一步棋后都在更新权重。在监督学习领域，我们通常没有这个问题，因为我们进行随机批量学习，直到我们迭代了训练数据的一些随机子集并计算了批量的总和或平均梯度，我们才更新我们的权重。这在目标上是平均的，并且稳定了学习。</p><p id="c099" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">我们能在 DQN 做吗？</p><p id="7c28" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">是的，这就是所谓的<em class="js">体验回放</em>。体验回放让我们在在线学习模式中批量更新。</p><figure class="li lj lk ll gt lm gh gi paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="gh gi lx"><img src="../Images/bccbc402bb33de5f7552f312a3095c08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Yn2MkDE3YYBDzhAQPyB5Vg.png"/></div></div><p class="lt lu gj gh gi lv lw bd b be z dk translated">图 2:体验回放</p></figure><p id="1a38" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">上图显示了经验重放的总体概况，这是一种缓解在线训练算法主要问题的方法:灾难性遗忘。其思想是通过存储过去的经验，然后使用这些经验的随机子集来更新 Q 网络，而不是仅使用单个最近的经验，来采用小型批处理。</p><p id="a708" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">体验回放涉及的步骤有</p><ol class=""><li id="7b1a" class="kt ku iq jt b ju jv jy jz kp kv kq kw kr kx ko ky kz la lb bi translated">在状态<em class="js"> s </em>，采取动作<em class="js"> a </em>，观察新状态<em class="js"> s(t </em> +1)，奖励<em class="js"> r(t </em> +1)。</li><li id="1b61" class="kt ku iq jt b ju lc jy ld kp le kq lf kr lg ko ky kz la lb bi translated">将此作为一个元组(<em class="js"> s </em>，<em class="js"> a </em>，<em class="js"> s(t </em> +1)，<em class="js"> r(t </em> +1))存储在一个列表中。</li><li id="3d4c" class="kt ku iq jt b ju lc jy ld kp le kq lf kr lg ko ky kz la lb bi translated">继续在这个列表中存储每个经历，直到你把列表填充到一个特定的长度(这个由你来定义)。</li><li id="5280" class="kt ku iq jt b ju lc jy ld kp le kq lf kr lg ko ky kz la lb bi translated">一旦体验回放内存被填满，随机选择一个子集(同样，您需要定义子集大小)。</li><li id="5516" class="kt ku iq jt b ju lc jy ld kp le kq lf kr lg ko ky kz la lb bi translated">遍历这个子集并计算每个子集的值更新；将这些存储在一个目标数组中(如<em class="js"> Y </em>，并将每个内存的状态<em class="js"> s </em>存储在<em class="js"> X </em>中。</li><li id="04cb" class="kt ku iq jt b ju lc jy ld kp le kq lf kr lg ko ky kz la lb bi translated">使用<em class="js"> X </em>和<em class="js"> Y </em>作为小批量进行批量训练。对于数组已满的后续时期，只需覆盖经验重放内存数组中的旧值。</li></ol><p id="2bd7" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">体验回放的实现如下图所示</p><pre class="li lj lk ll gt ly lz ma mb aw mc bi"><span id="add0" class="md me iq lz b gy mf mg l mh mi">from collections import deque<br/>epochs = 5000<br/>losses = []<br/>mem_size = 1000        <strong class="lz ir"><em class="js">1</em></strong>                                                     <br/>batch_size = 200       <strong class="lz ir"><em class="js">2</em></strong>                                                            <br/>replay = deque(maxlen=mem_size)   <strong class="lz ir"><em class="js">3</em></strong>                                             <br/>max_moves = 50      <strong class="lz ir"><em class="js">4</em></strong>                                                           <br/>h = 0<br/>for i in range(epochs):<br/>    game = Gridworld(size=4, mode='random')<br/>    state1_ = game.board.render_np().reshape(1,64) + np.random.rand(1,64)/100.0<br/>    state1 = torch.from_numpy(state1_).float()<br/>    status = 1<br/>    mov = 0<br/>    while(status == 1): <br/>        mov += 1<br/>        qval = model(state1)     <strong class="lz ir"><em class="js">5</em></strong>                                              <br/>        qval_ = qval.data.numpy()<br/>        if (random.random() &lt; epsilon):         <strong class="lz ir"><em class="js">6</em></strong>                               <br/>            action_ = np.random.randint(0,4)<br/>        else:<br/>            action_ = np.argmax(qval_)<br/>        <br/>        action = action_set[action_]<br/>        game.makeMove(action)<br/>        state2_ = game.board.render_np().reshape(1,64) + np.random.rand(1,64)/100.0<br/>        state2 = torch.from_numpy(state2_).float()<br/>        reward = game.reward()<br/>        done = True if reward &gt; 0 else False<br/>        exp =  (state1, action_, reward, state2, done)      <strong class="lz ir"><em class="js">7</em></strong>                   <br/>        replay.append(exp)                <strong class="lz ir"><em class="js">8</em></strong>                                     <br/>        state1 = state2<br/>        if len(replay) &gt; batch_size:     <strong class="lz ir"><em class="js">9</em></strong>                                      <br/>            minibatch = random.sample(replay, batch_size)     <strong class="lz ir"><em class="js">10</em></strong>                 <br/>            state1_batch = torch.cat([s1 for (s1,a,r,s2,d) in minibatch])      <strong class="lz ir"><em class="js">11</em></strong><br/>            action_batch = torch.Tensor([a for (s1,a,r,s2,d) in minibatch])<br/>            reward_batch = torch.Tensor([r for (s1,a,r,s2,d) in minibatch])<br/>            state2_batch = torch.cat([s2 for (s1,a,r,s2,d) in minibatch])<br/>            done_batch = torch.Tensor([d for (s1,a,r,s2,d) in minibatch])<br/>            <br/>            Q1 = model(state1_batch)        <strong class="lz ir"><em class="js">12</em></strong>                                   <br/>            with torch.no_grad():<br/>                Q2 = model(state2_batch)       <strong class="lz ir"><em class="js">13</em></strong>                                <br/>            <br/>            Y = reward_batch + gamma * ((1 - done_batch) * torch.max(Q2,dim=1)[0])      <strong class="lz ir"><em class="js">14</em></strong>                                             <br/>            X = \<br/>            Q1.gather(dim=1,index=action_batch.long().unsqueeze(dim=1)).squeeze()<br/>            loss = loss_fn(X, Y.detach())<br/>            optimizer.zero_grad()<br/>            loss.backward()<br/>            losses.append(loss.item())<br/>            optimizer.step()<br/> <br/>        if reward != -1 or mov &gt; max_moves:         <strong class="lz ir"><em class="js">15</em></strong>                           <br/>            status = 0<br/>            mov = 0<br/>losses = np.array(losses)</span></pre><ul class=""><li id="0507" class="kt ku iq jt b ju jv jy jz kp kv kq kw kr kx ko mj kz la lb bi translated"><strong class="jt ir"> <em class="js"> 1 </em> </strong>设置体验重放存储器的总容量</li><li id="cbd8" class="kt ku iq jt b ju lc jy ld kp le kq lf kr lg ko mj kz la lb bi translated"><strong class="jt ir"> <em class="js"> 2 </em> </strong>设置小批量</li><li id="9b3c" class="kt ku iq jt b ju lc jy ld kp le kq lf kr lg ko mj kz la lb bi translated"><strong class="jt ir"> <em class="js"> 3 </em> </strong>将内存重放创建为一个队列列表</li><li id="7489" class="kt ku iq jt b ju lc jy ld kp le kq lf kr lg ko mj kz la lb bi translated"><strong class="jt ir"> <em class="js"> 4 </em> </strong>设定游戏结束前的最大移动次数</li><li id="2eee" class="kt ku iq jt b ju lc jy ld kp le kq lf kr lg ko mj kz la lb bi translated"><strong class="jt ir"> <em class="js"> 5 </em> </strong>使用ε贪婪策略选择一个动作</li><li id="62ff" class="kt ku iq jt b ju lc jy ld kp le kq lf kr lg ko mj kz la lb bi translated"><strong class="jt ir"> <em class="js"> 6 </em> </strong>根据输入状态计算 Q 值，以选择一个动作</li><li id="419d" class="kt ku iq jt b ju lc jy ld kp le kq lf kr lg ko mj kz la lb bi translated"><strong class="jt ir"> <em class="js"> 7 </em> </strong>以元组的形式创建状态、奖励、动作和下一个状态的体验</li><li id="9b46" class="kt ku iq jt b ju lc jy ld kp le kq lf kr lg ko mj kz la lb bi translated"><strong class="jt ir"> <em class="js"> 8 </em> </strong>将体验添加到体验回放列表中</li><li id="9c84" class="kt ku iq jt b ju lc jy ld kp le kq lf kr lg ko mj kz la lb bi translated"><strong class="jt ir"> <em class="js"> 9 </em> </strong>如果重放列表至少与小批量一样长，则开始小批量训练</li><li id="67bd" class="kt ku iq jt b ju lc jy ld kp le kq lf kr lg ko mj kz la lb bi translated"><strong class="jt ir"> <em class="js"> 10 </em> </strong>随机抽取重放列表的一个子集</li><li id="9466" class="kt ku iq jt b ju lc jy ld kp le kq lf kr lg ko mj kz la lb bi translated"><strong class="jt ir"> <em class="js"> 11 </em> </strong>将每个体验的组成部分分离成单独的小批量张量</li><li id="9010" class="kt ku iq jt b ju lc jy ld kp le kq lf kr lg ko mj kz la lb bi translated"><strong class="jt ir"> <em class="js"> 12 </em> </strong>重新计算小批量状态的 Q 值以获得梯度</li><li id="6bd6" class="kt ku iq jt b ju lc jy ld kp le kq lf kr lg ko mj kz la lb bi translated"><strong class="jt ir"> <em class="js"> 13 </em> </strong>计算小批量下一状态的 Q 值，但不计算梯度</li><li id="0d65" class="kt ku iq jt b ju lc jy ld kp le kq lf kr lg ko mj kz la lb bi translated"><strong class="jt ir"> <em class="js"> 14 </em> </strong>计算我们希望 DQN 学习的目标 Q 值</li><li id="54ed" class="kt ku iq jt b ju lc jy ld kp le kq lf kr lg ko mj kz la lb bi translated"><strong class="jt ir"> <em class="js"> 15 </em> </strong>如果游戏结束，重置状态和 mov 号</li></ul><p id="dbd3" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">Y = reward_batch+gamma *(1—done_batch)* torch . max(Q2，dim=1)[0])中的 done _ batch 是一个布尔变量，它在游戏结束(一集结束)时将 reward _ batch 的权限设置为零</p><p id="5e2d" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">在随机模式下训练模型 5000 个纪元并运行游戏 1000 次后，我们能够赢得 90%的游戏，损失锁定如下</p><figure class="li lj lk ll gt lm gh gi paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="gh gi mk"><img src="../Images/665234b2e84ba0e07f724fa575323c40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uFkZbwJoDwNLASl_GcStuA.png"/></div></div><p class="lt lu gj gh gi lv lw bd b be z dk translated">图 3:带有经验回复的损失图</p></figure><p id="e8e6" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">从上面的数字我们可以看到，在训练中损失明显减少，而且我们有 90%的机会赢得比赛。我们必须明白，在游戏的某些状态下，赢是不可能的。所以 90%的胜率确实不错。</p><p id="ec01" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">但是，我们仍然看到，在以后的时代，损失增加，趋势是非常不稳定的。这在深度强化学习(DRL)问题中很常见。我们称之为学习不稳定性。是的，有一个解决方案。</p><p id="8aea" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">使用目标网络将解决学习不稳定的问题。我们将在第 3 部分中看到如何实现目标网络</p><p id="0530" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">这篇文章的代码可以在<a class="ae ks" href="https://github.com/NandaKishoreJoshi/Reinforcement_Lerning/blob/main/RL_course/Ch3_Gridworld/Part%202%20-%20Deep%20Q-Learning%20for%20GridWorld%20-%20Experience%20replay.ipynb" rel="noopener ugc nofollow" target="_blank">这个</a> GIT 链接中获得</p><p id="8309" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated"><strong class="jt ir">至今！！</strong></p><ol class=""><li id="0761" class="kt ku iq jt b ju jv jy jz kp kv kq kw kr kx ko ky kz la lb bi translated">我们学习了什么是灾难性遗忘，以及它如何影响 DQN 特工</li><li id="c0a9" class="kt ku iq jt b ju lc jy ld kp le kq lf kr lg ko ky kz la lb bi translated">我们通过实施经验回复解决了灾难性遗忘</li><li id="fe2c" class="kt ku iq jt b ju lc jy ld kp le kq lf kr lg ko ky kz la lb bi translated">DRL 学习不稳定。我们将在<a class="ae ks" href="https://nandakishorej8.medium.com/part-3-building-a-deep-q-network-to-play-gridworld-learning-instability-and-target-networks-fb399cb42616" rel="noopener">第三部分</a>中看到如何实现目标网络来消除学习不稳定性</li></ol><p id="9c4a" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">点击这里查看本文的第 1 部分:</p><div class="ml mm gp gr mn mo"><a href="https://nandakishorej8.medium.com/part-1-building-a-deep-q-network-to-play-gridworld-deepminds-deep-q-networks-78842007c631" rel="noopener follow" target="_blank"><div class="mp ab fo"><div class="mq ab mr cl cj ms"><h2 class="bd ir gy z fp mt fr fs mu fu fw ip bi translated">第 1 部分——构建深度 Q 网络来玩 grid world——deep mind 的深度 Q 网络</h2><div class="mv l"><h3 class="bd b gy z fp mt fr fs mu fu fw dk translated">在本文中，让我们构建一个类似于 DeepMind 的 Atari 代理的深度 Q 网络来玩 Gridworld 问题。我们会…</h3></div><div class="mw l"><p class="bd b dl z fp mt fr fs mu fu fw dk translated">nandakishorej8.medium.com</p></div></div><div class="mx l"><div class="my l mz na nb mx nc lr mo"/></div></div></a></div><p id="8c02" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">在这里查看这篇文章的第三部分:<br/><a class="ae ks" href="https://nandakishorej8.medium.com/part-3-building-a-deep-q-network-to-play-gridworld-learning-instability-and-target-networks-fb399cb42616" rel="noopener">https://nandakishorej 8 . medium . com/Part-3-building-a-deep-q-network-to-play-grid world-learning-unstability-and-target-networks-FB 399 CB 42616</a></p></div></div>    
</body>
</html>