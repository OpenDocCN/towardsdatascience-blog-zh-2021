<html>
<head>
<title>Run Your Python Code as Fast as C</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">像C语言一样快速运行您的Python代码</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/run-your-python-code-as-fast-as-c-4ae49935a826?source=collection_archive---------0-----------------------#2021-04-18">https://towardsdatascience.com/run-your-python-code-as-fast-as-c-4ae49935a826?source=collection_archive---------0-----------------------#2021-04-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="40ba" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何在不做任何改变的情况下提高python代码的性能。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/6b26c0ed20f7c9f90c3847edd212e3fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nvxt0bchTxpFVyrCxpwCXw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由来自Pixabay的Onur mer Yavuz提供</p></figure><p id="e941" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi lu translated">作为一名博士研究员，我的工作至关重要的一点是快速编写一个想法，看看它是否可行。<em class="md"> Python </em>是实现这一点的优秀工具。它允许专注于想法本身，而不是被样板代码和其他乏味的事情所困扰。</p><p id="d418" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然而，<em class="md"> Python </em>有一个很大的缺点:<strong class="la iu">它比像<em class="md"> C </em>或者<em class="md"> C++ </em>这样的编译语言要慢很多。</strong>那么，在我们通过构建一个<em class="md"> Python </em>原型测试了一个想法之后，现在我们想把它变成一个快速且高性能的工具，我们该怎么做呢？大多数情况下，我们最终会做两倍的工作，手动将<em class="md"> Python </em>代码转换成<em class="md"> C </em>。如果我们的<em class="md"> Python </em>原型本身能够运行得更快，那不是很好吗？所有花在实现每件事情两次上的时间可以用来做更有意义和有趣的事情。</p><p id="4968" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">幸运的是，我偶然发现了问题的解决方案:<strong class="la iu"> <em class="md"> PyPy </em>，这是<em class="md"> Python </em>的快速替代方案。</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi me"><img src="../Images/692471a62a24787b06967f91ee5e0e96.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G6TmV4MxaEsEZHja2UvH5A.png"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mf"><img src="../Images/6f6363d4f4f29da1e5362128262fbaea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*_hmA215CXeVQwb7mixssqg.gif"/></div></div></figure><p id="6de3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了说明<em class="md"> PyPy </em>可以提供多大的加速，我在下面的例子中运行了默认的<em class="md"> Python </em>解释器和<em class="md">PyPy py</em>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="c312" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">基本上，该脚本在一个循环中将0到100，000，000之间的所有整数相加，并在完成时打印一条消息和脚本的运行时。</p><p id="96aa" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">尽管这不是一个科学的评价，但这个生动的例子仍然令人振奋。与默认的<em class="md"> Python </em>解释器(大约需要10秒)相比，<strong class="la iu"> PyPy在0.22秒后就完成了它的执行！</strong>另外，请注意，我们可以直接将我们的<em class="md"> Python </em>代码输入到<em class="md">pypypy</em>中，不做任何修改。当你把它与速度大师<em class="md"> C </em>相比时，这个结果会更加令人印象深刻。在我的电脑上，<em class="md"> C </em>中的等效实现需要0.32秒。虽然总体来说C依然是速度大师，<strong class="la iu"> PyPy在某些情况下也能打败C。</strong></p><blockquote class="mi mj mk"><p id="a1d0" class="ky kz md la b lb lc ju ld le lf jx lg ml li lj lk mm lm ln lo mn lq lr ls lt im bi translated">"如果你想让你的代码神奇地运行得更快，你也许应该使用PyPy . "<br/> —吉多·范·罗苏姆(Python的创造者)<br/>来源:<a class="ae mo" href="https://youtu.be/2wDvzy6Hgxg?t=1012" rel="noopener ugc nofollow" target="_blank">youtu.be/2wDvzy6Hgxg?t=1012</a></p></blockquote><p id="ef3f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当我们的程序无论如何都很快时，或者当大部分运行时间用于调用非python库时，PyPy 就不那么有效了。然而，如果我们有一个很慢的程序，大部分时间花在执行<em class="md"> Python </em>代码上，<em class="md"> PyPy </em>可以创造奇迹。</p><h1 id="1033" class="mp mq it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">PyPy为什么这么快？</h1><p id="c568" class="pw-post-body-paragraph ky kz it la b lb nh ju ld le ni jx lg lh nj lj lk ll nk ln lo lp nl lr ls lt im bi translated">这是你可能会问自己的问题，如果你是第一次被<em class="md"> PyPy </em>绊倒，这是理所当然的。开始时，这看起来像是魔法。我们运行完全相同的代码，用<em class="md"> PyPy </em>获得了看似免费的巨大加速。</p><p id="d7ec" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">虽然代码完全相同，但是代码的执行方式却有天壤之别。<em class="md"> PyPy的</em>性能提升背后的秘密是<strong class="la iu">实时编译，简称JIT编译</strong>。</p><p id="9f96" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是让我们慢慢来。</p><h2 id="c3a9" class="nm mq it bd mr nn no dn mv np nq dp mz lh nr ns nb ll nt nu nd lp nv nw nf nx bi translated">超前编译</h2><p id="89c6" class="pw-post-body-paragraph ky kz it la b lb nh ju ld le ni jx lg lh nj lj lk ll nk ln lo lp nl lr ls lt im bi translated">像C、C++这样的编程语言，还有Swift、Haskell、Rust等等都是提前编译的。这意味着在你用那些语言写了一些代码之后，你点击一个按钮，编译器将源代码转换成机器可读的代码，可以被一个特定的计算机架构读取。每当程序执行的时候，你的原始源代码早就没了。执行的只是机器码。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ny"><img src="../Images/a5f794d059557b5756e81619408d72b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9a_LktZdxfrB_R-M62ruyQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">提前编译将源文件转换为机器码。</p></figure><h2 id="69a4" class="nm mq it bd mr nn no dn mv np nq dp mz lh nr ns nb ll nt nu nd lp nv nw nf nx bi translated">语言解释</h2><p id="8322" class="pw-post-body-paragraph ky kz it la b lb nh ju ld le ni jx lg lh nj lj lk ll nk ln lo lp nl lr ls lt im bi translated"><em class="md"> Python </em>，<em class="md"> JavaScript </em>，<em class="md"> PHP </em>，类似的语言则采取了不同的方式。它们被解释。与将源代码转换成机器码相比，源代码保持不变。每次程序运行时，解释器逐行“查看”代码并为我们运行。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/57e33b06a538f84108b825aa3d86c7a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W4wSbi-Y_CdQ1j41e2iueg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">解释器逐行运行程序。</p></figure><p id="11aa" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在JavaScript 的例子中，每个网络浏览器都内置了一个解释器。标准的<em class="md"> Python </em>解释器叫做<em class="md"> CPython。</em>然而，区分语言<em class="md"> Python </em>和运行我们代码的东西<em class="md"> CPython </em>是非常重要的。这是因为我们可以拥有完全不同的工具，都具有运行<em class="md"> Python </em>代码的能力。这就是PyPy进入画面的地方。</p><h2 id="9811" class="nm mq it bd mr nn no dn mv np nq dp mz lh nr ns nb ll nt nu nd lp nv nw nf nx bi translated">即时编译</h2><p id="c3e2" class="pw-post-body-paragraph ky kz it la b lb nh ju ld le ni jx lg lh nj lj lk ll nk ln lo lp nl lr ls lt im bi translated"><em class="md"> PyPy </em>是利用即时编译的<em class="md"> Python </em>的替代实现。正在发生的是<em class="md"> PyPy </em>像解释器一样直接从源文件中运行我们的<em class="md"> Python </em>代码。然而，<em class="md"> PyPy </em>并不是一行一行地运行代码，而是在执行代码之前将部分代码编译成机器码，可以说<em class="md">只是在时间上</em>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/f6abc55c0ec58c3281df672ec710baf6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zHtOfAO0Ve67hg-ffPvDFw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">JIT编译结合了提前编译和解释。</p></figure><p id="90a2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">从这个意义上说，JIT编译是解释和提前编译的结合。我们获得了提前编译的性能提升，以及解释语言的灵活性和跨平台可用性。</p><h1 id="5320" class="mp mq it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">你如何从PyPy中获益？</h1><p id="f64c" class="pw-post-body-paragraph ky kz it la b lb nh ju ld le ni jx lg lh nj lj lk ll nk ln lo lp nl lr ls lt im bi translated">既然我们已经理解了<em class="md"> PyPy </em>是如何实现惊人的性能提升的，我们就想使用它。<em class="md"> PyPy </em>在<a class="ae mo" href="https://www.pypy.org/" rel="noopener ugc nofollow" target="_blank">pypy.org</a>免费提供，安装简单。除了工具本身之外，该网站还包含大量关于微调python程序以进一步提高性能的提示和技巧。由于<em class="md"> PyPy </em>只是<em class="md"> Python </em>的替代实现，大多数时候它只是开箱即用，无需对您的<em class="md"> Python </em>项目做任何更改。它完全兼容web框架<em class="md"> Django </em>，科学计算包<em class="md"> Numpy </em>和众多其他包。它节省了我无数的用C重新实现原型的时间，我不想在我的编程工具包中错过它。</p></div><div class="ab cl ob oc hx od" role="separator"><span class="oe bw bk of og oh"/><span class="oe bw bk of og oh"/><span class="oe bw bk of og"/></div><div class="im in io ip iq"><p id="0d81" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">觉得这个故事有趣？你可以在这里成为灵媒会员来支持我的写作:<a class="ae mo" href="https://medium.com/@mmsbrggr/membership" rel="noopener">medium.com/@mmsbrggr/membership</a>。你将获得所有媒体的访问权，你的部分会员费将直接支持我的写作。</p><p id="4278" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">欢迎在LinkedIn上向我提出私人问题和评论。如果你喜欢这篇文章，让我告诉你我的时事通讯:<a class="ae mo" href="https://marcelmoos.com/newsletter" rel="noopener ugc nofollow" target="_blank">marcelmoos.com/newsletter</a>。</p><div class="oi oj gp gr ok ol"><a rel="noopener follow" target="_blank" href="/make-your-neural-net-confuse-dogs-with-pelicans-af7ad6ec95a5"><div class="om ab fo"><div class="on ab oo cl cj op"><h2 class="bd iu gy z fp oq fr fs or fu fw is bi translated">攻击神经网络</h2><div class="os l"><h3 class="bd b gy z fp oq fr fs or fu fw dk translated">使用PGD攻击为神经网络制造视错觉。</h3></div><div class="ot l"><p class="bd b dl z fp oq fr fs or fu fw dk translated">towardsdatascience.com</p></div></div><div class="ou l"><div class="ov l ow ox oy ou oz ks ol"/></div></div></a></div></div></div>    
</body>
</html>