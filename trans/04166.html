<html>
<head>
<title>Index, Sort and Aggregate your DataFrames in Julia</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Julia中索引、排序和聚集你的数据帧</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/index-sort-and-aggregate-your-dataframes-in-julia-38646daf6214?source=collection_archive---------18-----------------------#2021-04-08">https://towardsdatascience.com/index-sort-and-aggregate-your-dataframes-in-julia-38646daf6214?source=collection_archive---------18-----------------------#2021-04-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1dca" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用DataFrames.jl进行常见数据分析的教程</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/6fc41e8dc208800c11c8a31ae82d304e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZqqAco6e03afs7qxm7Etdw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@jeswinthomas?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">杰斯温·托马斯</a>在<a class="ae ky" href="https://unsplash.com/s/photos/banana-split?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="e864" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">深入到DataFrames.jl，我们将探索如何在DataFrames上做<strong class="lb iu">布尔索引</strong>，学习<strong class="lb iu">如何按列值对数据进行排序</strong>和<strong class="lb iu">聚合表</strong>以满足我们的需求。在最后一节，我们还将介绍一种超级强大的分析方法，称为:<strong class="lb iu">分割-应用-组合</strong>。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="3ea5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="mc">如果你需要复习DataFrames.jl，先看看这些文章:</em></p><div class="md me gp gr mf mg"><a rel="noopener follow" target="_blank" href="/julia-dataframes-jl-basics-95dba5146ef4"><div class="mh ab fo"><div class="mi ab mj cl cj mk"><h2 class="bd iu gy z fp ml fr fs mm fu fw is bi translated">Julia DataFrames.jl基础</h2><div class="mn l"><h3 class="bd b gy z fp ml fr fs mm fu fw dk translated">用DataFrames.jl戳戳你的数据</h3></div><div class="mo l"><p class="bd b dl z fp ml fr fs mm fu fw dk translated">towardsdatascience.com</p></div></div><div class="mp l"><div class="mq l mr ms mt mp mu ks mg"/></div></div></a></div><div class="md me gp gr mf mg"><a rel="noopener follow" target="_blank" href="/reading-csv-files-with-julia-e2623fb62938"><div class="mh ab fo"><div class="mi ab mj cl cj mk"><h2 class="bd iu gy z fp ml fr fs mm fu fw is bi translated">与Julia一起阅读CSV文件</h2><div class="mn l"><h3 class="bd b gy z fp ml fr fs mm fu fw dk translated">了解如何使用CSV.jl读取各种逗号分隔的文件</h3></div><div class="mo l"><p class="bd b dl z fp ml fr fs mm fu fw dk translated">towardsdatascience.com</p></div></div><div class="mp l"><div class="mv l mr ms mt mp mu ks mg"/></div></div></a></div><div class="md me gp gr mf mg"><a rel="noopener follow" target="_blank" href="/reading-csv-files-with-julia-part-2-51d74434358f"><div class="mh ab fo"><div class="mi ab mj cl cj mk"><h2 class="bd iu gy z fp ml fr fs mm fu fw is bi translated">与Julia一起阅读CSV文件—第2部分</h2><div class="mn l"><h3 class="bd b gy z fp ml fr fs mm fu fw dk translated">货币、布尔值等的自定义格式。</h3></div><div class="mo l"><p class="bd b dl z fp ml fr fs mm fu fw dk translated">towardsdatascience.com</p></div></div><div class="mp l"><div class="mw l mr ms mt mp mu ks mg"/></div></div></a></div></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><blockquote class="mx"><p id="6f61" class="my mz it bd na nb nc nd ne nf ng lu dk translated">要获得所有媒体文章的完整信息，包括我的文章，请点击这里订阅<a class="ae ky" href="https://niczky12.medium.com/membership" rel="noopener"/>。</p></blockquote><h1 id="c619" class="nh ni it bd nj nk nl nm nn no np nq nr jz ns ka nt kc nu kd nv kf nw kg nx ny bi translated">获取一些数据</h1><p id="1a3e" class="pw-post-body-paragraph kz la it lb b lc nz ju le lf oa jx lh li ob lk ll lm oc lo lp lq od ls lt lu im bi translated">首先，我们需要从<code class="fe oe of og oh b">RDatasets</code>包中挑选一个数据集。这样就省去了我们下载读入一个文件的麻烦。如果你想知道如何阅读CSV，请查看我之前在CSV.jl和数据导入上的帖子——上面的链接。让我们<strong class="lb iu">导入包并设置我们的数据集</strong>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ok"><img src="../Images/bf15c4aa85025a2c05fb6f118f6e448f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hMAMw1a8trK-WHQU-Du7Gw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">维多利亚博物馆在<a class="ae ky" href="https://unsplash.com/s/photos/factory-workers?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="c49b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个数据集追踪了超过500个人的时薪、工作经验、教育和其他可能与薪水相关的因素。你可以在这里找到更多关于数据集<a class="ae ky" href="https://cran.r-project.org/web/packages/plm/plm.pdf" rel="noopener ugc nofollow" target="_blank">的信息。在我们的练习中，我们将只使用以下各列:</a></p><ol class=""><li id="c141" class="ol om it lb b lc ld lf lg li on lm oo lq op lu oq or os ot bi translated"><code class="fe oe of og oh b">NR</code>:唯一的工人标识符。</li><li id="5d2c" class="ol om it lb b lc ou lf ov li ow lm ox lq oy lu oq or os ot bi translated"><code class="fe oe of og oh b">Year</code>:观测年份。</li><li id="7496" class="ol om it lb b lc ou lf ov li ow lm ox lq oy lu oq or os ot bi translated"><code class="fe oe of og oh b">Wage</code>:计时工资日志。</li><li id="a722" class="ol om it lb b lc ou lf ov li ow lm ox lq oy lu oq or os ot bi translated"><code class="fe oe of og oh b">Ethn</code>:工人的种族等级:黑人、hisp、其他</li><li id="833f" class="ol om it lb b lc ou lf ov li ow lm ox lq oy lu oq or os ot bi translated">多年的经验。</li></ol><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div></figure><pre class="kj kk kl km gt oz oh pa pb aw pc bi"><span id="3150" class="pd ni it oh b gy pe pf l pg ph">julia&gt; first(males, 5)<br/>5×5 DataFrame<br/> Row │ NR     Year   Wage     Ethn   Exper<br/>     │ Int32  Int32  Float64  Cat…   Int32<br/>─────┼─────────────────────────────────────<br/>   1 │    13   1980  1.19754  other      1<br/>   2 │    13   1981  1.85306  other      2<br/>   3 │    13   1982  1.34446  other      3<br/>   4 │    13   1983  1.43321  other      4<br/>   5 │    13   1984  1.56813  other      5</span></pre><h1 id="851a" class="nh ni it bd nj nk nl nm nn no np nq nr jz pi ka nt kc pj kd nv kf pk kg nx ny bi translated">索引</h1><p id="d8b1" class="pw-post-body-paragraph kz la it lb b lc nz ju le lf oa jx lh li ob lk ll lm oc lo lp lq od ls lt lu im bi translated">对数据帧的典型操作是<strong class="lb iu">根据值</strong> s上的一些标准对数据进行子集化。我们可以通过首先构建一个<strong class="lb iu">布尔索引</strong>(真/假值的向量)来实现这一点，该索引对于期望值为真，否则为假。然后，我们可以将它作为数据帧的第一个参数放入括号中，以选择所需的行。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div></figure><blockquote class="pl pm pn"><p id="2fe9" class="kz la mc lb b lc ld ju le lf lg jx lh po lj lk ll pp ln lo lp pq lr ls lt lu im bi translated">为了节省空间，我将只打印前5行。我用<code class="fe oe of og oh b">first(dataframe, 5)</code>来做这个。</p></blockquote><pre class="kj kk kl km gt oz oh pa pb aw pc bi"><span id="f5fe" class="pd ni it oh b gy pe pf l pg ph">5×5 DataFrame<br/> Row │ NR     Year   Wage     Ethn   Exper<br/>     │ Int32  Int32  Float64  Cat…   Int32<br/>─────┼─────────────────────────────────────<br/>   1 │    13   1980  1.19754  other      1<br/>   2 │    17   1980  1.67596  other      4<br/>   3 │    18   1980  1.51596  other      4<br/>   4 │    45   1980  1.89411  other      2<br/>   5 │   110   1980  1.94877  other      5</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pr"><img src="../Images/de37d47f70f02e92259fe26b7a6f3193.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c08V2cllVx7g1ZHjgICy1A.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@claybanks?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">粘土堤</a>在<a class="ae ky" href="https://unsplash.com/s/photos/selecting?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</p></figure><p id="ab5c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们使用冒号<code class="fe oe of og oh b">:</code>来表示我们想要所有可用的列。您应该这样阅读上面的内容:给我所有的男性行，其中<code class="fe oe of og oh b">my_index</code>为真，并返回所有可用的列。通常，你会<strong class="lb iu">在一个步骤</strong>中完成，因为真的没有必要分配一个单独的布尔索引向量:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">这给出了与上面相同的结果。</p></figure><p id="f8e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果有多个标准呢？假设我们需要1980年的观察数据，但只针对西班牙裔工人:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div></figure><pre class="kj kk kl km gt oz oh pa pb aw pc bi"><span id="772c" class="pd ni it oh b gy pe pf l pg ph">5×5 DataFrame<br/> Row │ NR     Year   Wage      Ethn  Exper<br/>     │ Int32  Int32  Float64   Cat…  Int32<br/>─────┼─────────────────────────────────────<br/>   1 │  1142   1980  1.41311   hisp      2<br/>   2 │  1641   1980  2.11169   hisp      4<br/>   3 │  1644   1980  0.560979  hisp      1<br/>   4 │  1721   1980  1.78447   hisp      5<br/>   5 │  1763   1980  0.6435    hisp      1</span></pre><p id="d487" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如你所见，解决方案是使用AND <code class="fe oe of og oh b">&amp;</code>逻辑运算符<strong class="lb iu">对两个布尔向量</strong>进行逐元素比较(因此我们用<code class="fe oe of og oh b">.&amp;</code>进行广播)。所以我们产生第三个向量，当且仅当年份是T6，Ethn是T7时，这个向量为真。</p><p id="b276" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">熟能生巧，所以让我们选择在1980年有3年以上工作经验的人:</p><pre class="kj kk kl km gt oz oh pa pb aw pc bi"><span id="5bbe" class="pd ni it oh b gy pe pf l pg ph">males[(males.Year .== 1980) .&amp; (males.Exper .&gt; 3), :]</span></pre><p id="8fcc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你需要其他的逻辑运算符，请查阅Julia手册中的本页。在那里你可以学习如何用<code class="fe oe of og oh b">!</code>求<strong class="lb iu">值</strong>的反，并与<strong class="lb iu">或运算符</strong> : <code class="fe oe of og oh b">|</code>交朋友。</p><p id="a670" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了完整起见，下面是如何用<code class="fe oe of og oh b">filter</code>函数做同样的事情:</p><pre class="kj kk kl km gt oz oh pa pb aw pc bi"><span id="796d" class="pd ni it oh b gy pe pf l pg ph">filter(df -&gt; (df.Year == 1980) &amp; (df.Exper &gt; 3), males)</span></pre><p id="8f1f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这在我之前的文章中有更详细的描述。</p><h1 id="a09b" class="nh ni it bd nj nk nl nm nn no np nq nr jz pi ka nt kc pj kd nv kf pk kg nx ny bi translated">排序数据帧</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ps"><img src="../Images/9967ce0c4209d2f8d8d2e3d70e1d5a08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4y_c5SIMunq1x7yDaas1_A.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@drew_beamer?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">德鲁·比默</a>在<a class="ae ky" href="https://unsplash.com/collections/5844710/sorting?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="7920" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们学习如何对数据集进行排序。正如你所想象的，这又是一个很常见的操作，幸运的是，它确实非常简单。首先，让我们按照<code class="fe oe of og oh b">Year</code>列对数据进行排序。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div></figure><pre class="kj kk kl km gt oz oh pa pb aw pc bi"><span id="4954" class="pd ni it oh b gy pe pf l pg ph">5×5 DataFrame<br/> Row │ NR     Year   Wage     Ethn   Exper<br/>     │ Int32  Int32  Float64  Cat…   Int32<br/>─────┼─────────────────────────────────────<br/>   1 │    13   1980  1.19754  other      1<br/>   2 │    17   1980  1.67596  other      4<br/>   3 │    18   1980  1.51596  other      4<br/>   4 │    45   1980  1.89411  other      2<br/>   5 │   110   1980  1.94877  other      5</span></pre><p id="c389" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">简单对吗？只需将一个数据帧传递给<strong class="lb iu">排序函数，并告诉它根据</strong>对哪一列(或哪些列)进行排序。你希望它减少吗？对此有一个关键词:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="1af1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可能想知道为什么我们必须传入一个列名数组来进行排序。这样我们可以同时指定多个列进行排序。这里有一个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div></figure><pre class="kj kk kl km gt oz oh pa pb aw pc bi"><span id="467c" class="pd ni it oh b gy pe pf l pg ph">5×5 DataFrame<br/> Row │ NR     Year   Wage     Ethn   Exper<br/>     │ Int32  Int32  Float64  Cat…   Int32<br/>─────┼─────────────────────────────────────<br/>   1 │    13   1980  1.19754  other      1<br/>   2 │    17   1980  1.67596  other      4<br/>   3 │    18   1980  1.51596  other      4<br/>   4 │    45   1980  1.89411  other      2<br/>   5 │   110   1980  1.94877  other      5</span></pre><p id="411c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，我们首先获得了1980年的所有观测数据，而<code class="fe oe of og oh b">NR</code>数字正在增加。</p><blockquote class="pl pm pn"><p id="2129" class="kz la mc lb b lc ld ju le lf lg jx lh po lj lk ll pp ln lo lp pq lr ls lt lu im bi translated"><code class="fe oe of og oh b">sort()</code>函数需要一个数组作为第二个参数，这样就可以同时对多列进行排序。</p></blockquote><p id="3eb5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">数据科学中一个重要的考虑因素是您的内存占用。以上所有操作<strong class="lb iu">都返回了DataFrame </strong>的副本，只留下我们的原始数据集。如果你不想改变你的原始数据集，这是很有用的，但是如果你想减少你的内存占用，你可以使用一个特殊版本的<code class="fe oe of og oh b">sort</code>，结尾有一个刘海:<code class="fe oe of og oh b">sort!</code>。这是Julia中的一个约定，函数通常是不可变的，如果一个函数改变了它的参数，那么它的名字应该以一个“砰”结束。下面是它在实践中的工作原理:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">这将修改原始数据帧。</p></figure><pre class="kj kk kl km gt oz oh pa pb aw pc bi"><span id="7363" class="pd ni it oh b gy pe pf l pg ph">julia&gt; first(males, 5)<br/>5×5 DataFrame<br/> Row │ NR     Year   Wage     Ethn   Exper<br/>     │ Int32  Int32  Float64  Cat…   Int32<br/>─────┼─────────────────────────────────────<br/>   1 │    13   1980  1.19754  other      1<br/>   2 │    17   1980  1.67596  other      4<br/>   3 │    18   1980  1.51596  other      4<br/>   4 │    45   1980  1.89411  other      2<br/>   5 │   110   1980  1.94877  other      5</span></pre><blockquote class="pl pm pn"><p id="35a0" class="kz la mc lb b lc ld ju le lf lg jx lh po lj lk ll pp ln lo lp pq lr ls lt lu im bi translated">以<code class="fe oe of og oh b">!</code>结尾的函数表示该函数正在改变其输入参数。</p></blockquote><h1 id="75e6" class="nh ni it bd nj nk nl nm nn no np nq nr jz pi ka nt kc pj kd nv kf pk kg nx ny bi translated">拆分-应用-组合范例</h1><p id="d182" class="pw-post-body-paragraph kz la it lb b lc nz ju le lf oa jx lh li ob lk ll lm oc lo lp lq od ls lt lu im bi translated">现在我们知道如何索引和排序我们的数据帧。这很有趣，但更有趣的是，如果我们不需要用眼睛来观察所有这些观察结果。如果我们能够以某种方式聚合我们的数据并收集一些有趣的统计数据会怎么样？嗯，这在SQL中称为GROUP BY操作，我们在DataFrames.jl中也有类似的东西。对于初学者，让我们做一些非常简单的事情。让我们算出我们每年有多少次观察(行):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div></figure><pre class="kj kk kl km gt oz oh pa pb aw pc bi"><span id="2311" class="pd ni it oh b gy pe pf l pg ph">8×2 DataFrame<br/> Row │ Year   nrow<br/>     │ Int32  Int64<br/>─────┼──────────────<br/>   1 │  1980    545<br/>   2 │  1981    545<br/>   3 │  1982    545<br/>   4 │  1983    545<br/>   5 │  1984    545<br/>   6 │  1985    545<br/>   7 │  1986    545<br/>   8 │  1987    545</span></pre><p id="4d09" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是如何工作的？涉及两个功能:</p><ul class=""><li id="e811" class="ol om it lb b lc ld lf lg li on lm oo lq op lu pt or os ot bi translated"><code class="fe oe of og oh b">groupby</code>:获取数据帧和我们想要对其进行分组的列。</li><li id="a28f" class="ol om it lb b lc ou lf ov li ow lm ox lq oy lu pt or os ot bi translated"><code class="fe oe of og oh b">combine</code>:获取<code class="fe oe of og oh b">groupby</code>的输出，并对每个组应用函数<code class="fe oe of og oh b">nrow</code>，汇总结果。</li></ul><blockquote class="pl pm pn"><p id="0438" class="kz la mc lb b lc ld ju le lf lg jx lh po lj lk ll pp ln lo lp pq lr ls lt lu im bi translated"><code class="fe oe of og oh b">nrow</code>函数只计算数据帧中的行数。</p></blockquote><p id="abe8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最终的结果是一个DataFrame，每个<code class="fe oe of og oh b">Year</code>——我们分组的列——都有一行。柱子也用<code class="fe oe of og oh b">Year</code>和<code class="fe oe of og oh b">nrow</code>来命名。</p><p id="3d7e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你也可以<strong class="lb iu">使用匿名(lambda)函数</strong>进行上述操作。如果您有一些快速功能要运行，这是很有用的，但要让我们开始，这里有与上面相当的功能:</p><pre class="kj kk kl km gt oz oh pa pb aw pc bi"><span id="7db1" class="pd ni it oh b gy pe pf l pg ph">combine(groupby(males, ["Year"]), df -&gt; nrow(df))</span></pre><p id="717d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我认为这告诉了我们更多关于它是如何工作的。我是这样理解的:</p><p id="3f1f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">按列<code class="fe oe of og oh b">Year</code>分割</strong>名为males的数据集，然后对每个更小的数据集<code class="fe oe of og oh b">df</code> <strong class="lb iu">应用</strong>函数<code class="fe oe of og oh b">nrow</code>。最后，<strong class="lb iu">将</strong>结果组合成一个数据帧，这样我们最终得到一个包含两列的表:一列表示拆分(年份)，另一列表示我们的函数结果。</p><p id="2986" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你在这里看到的实际上是<strong class="lb iu">拆分-应用-组合范式</strong>。了解如何快速有效地完成这项工作，您将能够从大多数数据集中提取您需要的所有信息！</p><p id="d0cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们多做一些练习。工人每年的平均工资是多少？</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div></figure><pre class="kj kk kl km gt oz oh pa pb aw pc bi"><span id="7c17" class="pd ni it oh b gy pe pf l pg ph">8×2 DataFrame<br/> Row │ Year   x1<br/>     │ Int32  Float64<br/>─────┼────────────────<br/>   1 │  1980  1.39348<br/>   2 │  1981  1.51287<br/>   3 │  1982  1.57167<br/>   4 │  1983  1.61926<br/>   5 │  1984  1.69029<br/>   6 │  1985  1.73941<br/>   7 │  1986  1.79972<br/>   8 │  1987  1.86648</span></pre><p id="1705" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我知道你在想什么。那个栏目为什么叫<code class="fe oe of og oh b">x1</code>？这很难看，而且当我不得不记住这些数字代表什么的时候，我的生活会变得更加艰难。不要担心，我们可以<strong class="lb iu">将几乎任何我们喜欢的函数</strong>传递到<code class="fe oe of og oh b">combine</code>中，这样我们实际上可以创建一个具有新列名的数据框架:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div></figure><pre class="kj kk kl km gt oz oh pa pb aw pc bi"><span id="cfe6" class="pd ni it oh b gy pe pf l pg ph">8×2 DataFrame<br/> Row │ Year   wage_avg<br/>     │ Int32  Float64<br/>─────┼─────────────────<br/>   1 │  1980   1.39348<br/>   2 │  1981   1.51287<br/>   3 │  1982   1.57167<br/>   4 │  1983   1.61926<br/>   5 │  1984   1.69029<br/>   6 │  1985   1.73941<br/>   7 │  1986   1.79972<br/>   8 │  1987   1.86648</span></pre><p id="64df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">整洁多了。让我们看看我们是否可以将这个扩展到<strong class="lb iu">在每次分割时收集多个统计数据</strong>——记住我们可以在<code class="fe oe of og oh b">combine</code>中做任何我们喜欢的事情:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div></figure><pre class="kj kk kl km gt oz oh pa pb aw pc bi"><span id="14a3" class="pd ni it oh b gy pe pf l pg ph">8×3 DataFrame<br/> Row │ Year   wage_avg  people<br/>     │ Int32  Float64   Int64<br/>─────┼─────────────────────────<br/>   1 │  1980   1.39348     545<br/>   2 │  1981   1.51287     545<br/>   3 │  1982   1.57167     545<br/>   4 │  1983   1.61926     545<br/>   5 │  1984   1.69029     545<br/>   6 │  1985   1.73941     545<br/>   7 │  1986   1.79972     545<br/>   8 │  1987   1.86648     545</span></pre><p id="d917" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，我们不仅收集每年的平均工资，还收集每年的样本量——独特工人的数量。以上真的很厉害，在调查数据集的时候可以帮到你很多。</p><h1 id="bb28" class="nh ni it bd nj nk nl nm nn no np nq nr jz pi ka nt kc pj kd nv kf pk kg nx ny bi translated">迂回到方法链接，又名管道</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pu"><img src="../Images/3386bf362fa91b290912d667c661223a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bsmsADz6uxtQpIoDWSJguQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">是的，这不是烟斗。乔纳森·卡罗尔在<a class="ae ky" href="https://unsplash.com/s/photos/this-is-not-a-pipe?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="733f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们在上面看到的，使用<strong class="lb iu">匿名函数可以非常有效地从数据集</strong>中快速获得一些统计数据。然而，当它们变得复杂时，可能有点难以阅读。我喜欢通过使用管道或方法链来解决这个问题。</p><p id="f1d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我将展示一个管道的例子。假设你有一个包含3个值的向量:<code class="fe oe of og oh b">[1,2,3]</code>你想对所有的值求平方，求和，然后求和的平方根。您可以使用标准函数来实现这一点:</p><pre class="kj kk kl km gt oz oh pa pb aw pc bi"><span id="d18f" class="pd ni it oh b gy pe pf l pg ph">julia&gt; sqrt(sum(([1,2,3] .^ 2)))<br/>3.7416573867739413</span></pre><p id="5988" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，我们必须像写数学函数一样，把上面的内容写出来。我们首先写<code class="fe oe of og oh b">sqrt</code>，然后写<code class="fe oe of og oh b">sum</code>等等，而不是像我们描述的那样从平方开始。这就是方法链发挥作用的地方。通过使用Julia中内置的管道操作符<code class="fe oe of og oh b">|&gt;</code>，我们可以将操作的结果传递给一个新函数。下面是与上面相同的操作，但是使用了管道:</p><pre class="kj kk kl km gt oz oh pa pb aw pc bi"><span id="fa24" class="pd ni it oh b gy pe pf l pg ph">julia&gt; [1,2,3] .^ 2 |&gt; sum |&gt; sqrt<br/>3.7416573867739413</span></pre><p id="ed8e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们为什么要用这个？嗯，这允许我们<strong class="lb iu">编写链接在一起的快速而肮脏的匿名函数</strong>来做一些奇特的聚合。</p><h1 id="24b7" class="nh ni it bd nj nk nl nm nn no np nq nr jz pi ka nt kc pj kd nv kf pk kg nx ny bi translated">把所有的放在一起</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pv"><img src="../Images/2e56a270888a9a86322abf8e7f8cf0e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*maurjo94aWjtzeoMZKkncA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">约翰·施诺布里奇在<a class="ae ky" href="https://unsplash.com/s/photos/together?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="d3ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们知道了如何使用管道，让我们看看如何在数据帧中使用它们。作为一个例子，假设我们想要<strong class="lb iu">获得每个人的第一个和最后一个记录的工资</strong>。因为我们知道如何排序和分割数据帧，所以我们可以这样做:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div></figure><pre class="kj kk kl km gt oz oh pa pb aw pc bi"><span id="2508" class="pd ni it oh b gy pe pf l pg ph">julia&gt; first(firstlast, 5)<br/>5×3 DataFrame<br/> Row │ NR     first    last<br/>     │ Int32  Float64  Float64<br/>─────┼─────────────────────────<br/>   1 │    13  1.19754  1.66919<br/>   2 │    17  1.67596  1.82033<br/>   3 │    18  1.51596  2.87316<br/>   4 │    45  1.89411  2.13569<br/>   5 │   110  1.94877  2.11239</span></pre><p id="3b50" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第一步中，我们对分割的数据帧进行排序，然后我们使用这个<code class="fe oe of og oh b">sorted_df</code>和<strong class="lb iu">应用另一个函数</strong>来提取第一个和最后一个工资值。让我们做一个快速的感觉检查，看看这是否确实是我们想要的:</p><pre class="kj kk kl km gt oz oh pa pb aw pc bi"><span id="4f9e" class="pd ni it oh b gy pe pf l pg ph">julia&gt; males[(males.NR .== 13) .&amp; (map(year-&gt;year ∈ [1980, 1987], males.Year)), [:NR, :Year, :Wage]]<br/>2×3 DataFrame<br/> Row │ NR     Year   Wage<br/>     │ Int32  Int32  Float64<br/>─────┼───────────────────────<br/>   1 │    13   1980  1.19754<br/>   2 │    13   1987  1.66919</span></pre><p id="e2cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">是的，这行得通，所以让我们简化一下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="66b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">很漂亮，对吧？想象一下你可以用这些做什么样的疯狂分析！💪</p><p id="eb04" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们多练习一些。让我们创建一个名为<code class="fe oe of og oh b">is_lower</code>的列，如果员工的最终工资<strong class="lb iu">低于他的最佳工资</strong>，则该列为真。我们需要像以前一样找出他们的第一份和最后一份工资，但是现在我们还需要存储最大工资值:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div></figure><pre class="kj kk kl km gt oz oh pa pb aw pc bi"><span id="fc1d" class="pd ni it oh b gy pe pf l pg ph">julia&gt; first(finishers, 5)<br/>5×5 DataFrame<br/> Row │ NR     first    max      last     is_lower<br/>     │ Int32  Float64  Float64  Float64  Bool<br/>─────┼────────────────────────────────────────────<br/>   1 │    13  1.19754  1.85306  1.66919      true<br/>   2 │    17  1.67596  1.82033  1.82033     false<br/>   3 │    18  1.51596  2.87316  2.87316     false<br/>   4 │    45  1.89411  2.13569  2.13569     false<br/>   5 │   110  1.94877  2.20252  2.11239      true</span></pre><p id="0afe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这看起来是可行的，所以让我们稍微清理一下我们的代码，因为我们实际上不需要存储第一个/最后一个值——我只是添加它们来做一个快速的感觉检查。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div></figure><pre class="kj kk kl km gt oz oh pa pb aw pc bi"><span id="353b" class="pd ni it oh b gy pe pf l pg ph">julia&gt; first(finishers, 5)<br/>5×2 DataFrame<br/> Row │ NR     is_lower<br/>     │ Int32  Bool<br/>─────┼─────────────────<br/>   1 │    13      true<br/>   2 │    17     false<br/>   3 │    18     false<br/>   4 │    45     false<br/>   5 │   110      true</span></pre><p id="28a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们可以将上述内容合并回原始数据集:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div></figure><pre class="kj kk kl km gt oz oh pa pb aw pc bi"><span id="3adf" class="pd ni it oh b gy pe pf l pg ph">julia&gt; first(new_males, 5)<br/>5×6 DataFrame<br/> Row │ NR     Year   Wage     Ethn   Exper  is_lower<br/>     │ Int32  Int32  Float64  Cat…   Int32  Bool<br/>─────┼───────────────────────────────────────────────<br/>   1 │    13   1980  1.19754  other      1      true<br/>   2 │    13   1981  1.85306  other      2      true<br/>   3 │    13   1982  1.34446  other      3      true<br/>   4 │    13   1983  1.43321  other      4      true<br/>   5 │    13   1984  1.56813  other      5      true</span></pre><h1 id="b520" class="nh ni it bd nj nk nl nm nn no np nq nr jz pi ka nt kc pj kd nv kf pk kg nx ny bi translated">结论</h1><p id="75db" class="pw-post-body-paragraph kz la it lb b lc nz ju le lf oa jx lh li ob lk ll lm oc lo lp lq od ls lt lu im bi translated">你现在已经掌握了可能是最强大的分析技术，并且知道如何在Julia中<strong class="lb iu">拆分-应用-组合你的数据框架</strong>。</p><p id="3797" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您还学习了如何:</p><ul class=""><li id="efbb" class="ol om it lb b lc ld lf lg li on lm oo lq op lu pt or os ot bi translated"><strong class="lb iu">使用布尔向量索引</strong>你的数据帧</li><li id="b850" class="ol om it lb b lc ou lf ov li ow lm ox lq oy lu pt or os ot bi translated"><strong class="lb iu">根据列值对数据帧进行排序</strong>——甚至可以使用<code class="fe oe of og oh b">sort!</code>就地排序</li><li id="4aaf" class="ol om it lb b lc ou lf ov li ow lm ox lq oy lu pt or os ot bi translated"><strong class="lb iu">根据</strong>对数据帧进行分组，并对其应用函数</li><li id="c047" class="ol om it lb b lc ou lf ov li ow lm ox lq oy lu pt or os ot bi translated">使用<strong class="lb iu">管道</strong>操作符<code class="fe oe of og oh b">|&gt;</code>让你的lambda函数更加强大</li></ul><p id="0546" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">谢谢你一路看完！👏</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="831f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想获得更多朱莉娅的乐趣，请访问DataFrames.jl和CSV.jl:</p><div class="md me gp gr mf mg"><a rel="noopener follow" target="_blank" href="/julia-dataframes-jl-basics-95dba5146ef4"><div class="mh ab fo"><div class="mi ab mj cl cj mk"><h2 class="bd iu gy z fp ml fr fs mm fu fw is bi translated">Julia DataFrames.jl基础</h2><div class="mn l"><h3 class="bd b gy z fp ml fr fs mm fu fw dk translated">用DataFrames.jl戳戳你的数据</h3></div><div class="mo l"><p class="bd b dl z fp ml fr fs mm fu fw dk translated">towardsdatascience.com</p></div></div><div class="mp l"><div class="mq l mr ms mt mp mu ks mg"/></div></div></a></div><div class="md me gp gr mf mg"><a rel="noopener follow" target="_blank" href="/reading-csv-files-with-julia-e2623fb62938"><div class="mh ab fo"><div class="mi ab mj cl cj mk"><h2 class="bd iu gy z fp ml fr fs mm fu fw is bi translated">与Julia一起阅读CSV文件</h2><div class="mn l"><h3 class="bd b gy z fp ml fr fs mm fu fw dk translated">了解如何使用CSV.jl读取各种逗号分隔的文件</h3></div><div class="mo l"><p class="bd b dl z fp ml fr fs mm fu fw dk translated">towardsdatascience.com</p></div></div><div class="mp l"><div class="mv l mr ms mt mp mu ks mg"/></div></div></a></div><div class="md me gp gr mf mg"><a rel="noopener follow" target="_blank" href="/reading-csv-files-with-julia-part-2-51d74434358f"><div class="mh ab fo"><div class="mi ab mj cl cj mk"><h2 class="bd iu gy z fp ml fr fs mm fu fw is bi translated">与Julia一起阅读CSV文件—第2部分</h2><div class="mn l"><h3 class="bd b gy z fp ml fr fs mm fu fw dk translated">货币、布尔值等的自定义格式。</h3></div><div class="mo l"><p class="bd b dl z fp ml fr fs mm fu fw dk translated">towardsdatascience.com</p></div></div><div class="mp l"><div class="mw l mr ms mt mp mu ks mg"/></div></div></a></div></div></div>    
</body>
</html>