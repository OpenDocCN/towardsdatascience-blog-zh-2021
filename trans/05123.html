<html>
<head>
<title>Improve Python Performances with ctypes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用ctypes提高Python性能</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/improve-python-performances-with-ctypes-ef51cee2eb59?source=collection_archive---------22-----------------------#2021-05-05">https://towardsdatascience.com/improve-python-performances-with-ctypes-ef51cee2eb59?source=collection_archive---------22-----------------------#2021-05-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="bede" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">ctypes的一个应用实例:Levenshtein距离计算</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/e7fbdf9c4b2457de0d6ed0c5c461f8da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F1vuFJg5UotXqRKVlUtWrA.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">unsplash上来自<a class="ae kv" href="https://unsplash.com/@chrisliverani" rel="noopener ugc nofollow" target="_blank"> @chrislivernani </a>的转速表</p></figure><h1 id="3ef7" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">语境</h1><p id="80c7" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">当谈到python的性能时，如果与C或C++之类的编译和低级语言相比，python通常被证明是非常慢的。大幅提高代码速度的一个方法是借助numpy将其矢量化。为了进一步提高速度，你可以看看numba，它通常是一个很好的选择，只需要一个装饰器就可以把一个缓慢的算法变成一个真正快速的算法。</p><p id="971f" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">也就是说，我喜欢回到像C这样的低级语言。Python内核是用C写的，所以我们为什么不试着为计算密集型部分建立自己的库呢？这就是下一篇文章的目标。</p><h1 id="d2c1" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">Python-C接口</h1><p id="b81a" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">当需要将python代码与一些C库接口时，您主要有两种选择:</p><ul class=""><li id="61e5" class="mp mq iq lq b lr mk lu ml lx mr mb ms mf mt mj mu mv mw mx bi translated">使用第三方工具/库，它用transpiler把你的代码翻译成相应的C代码</li><li id="66f3" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated">手动加载C库并将数据整理到相应的C部分</li></ul><h2 id="bd07" class="nd kx iq bd ky ne nf dn lc ng nh dp lg lx ni nj li mb nk nl lk mf nm nn lm no bi translated">运输工具</h2><p id="6d48" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">第一种方法不是我最喜欢的，是使用中间transpiler将python代码转换成C代码。我只知道Cython，但也许还有其他人存在。Cython非常接近python(支持原生python和numpy ),这是一个很大的优势。然而，我发现它太接近python了，调整代码以真正提高性能可能很难。有时候你必须声明变量的类型，有时候不需要。你有一个分析器来帮助你找到代码中的瓶颈，这很有帮助，但是真的，我发现这很难学，也很难达到最佳性能。</p><p id="f1a6" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">因此，与其尝试修改一些不那么python化、不那么C的代码，我们为什么不直接使用C代码呢？这就是ctypes发挥作用的地方。</p><h2 id="0efb" class="nd kx iq bd ky ne nf dn lc ng nh dp lg lx ni nj li mb nk nl lk mf nm nn lm no bi translated">用ctypes编组</h2><p id="ccaf" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">ctypes是python中的一个本地库，根据它的<a class="ae kv" href="https://docs.python.org/3/library/ctypes.html" rel="noopener ugc nofollow" target="_blank">文档</a></p><blockquote class="np nq nr"><p id="c736" class="lo lp ns lq b lr mk jr lt lu ml ju lw nt mm lz ma nu mn md me nv mo mh mi mj ij bi translated">ctypes提供了C兼容的数据类型，并允许调用dll或共享库中的函数。它可以用来用纯Python包装这些库。</p></blockquote><p id="2d8d" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">因此，ctypes真正有趣的是，您可以用纯C语言开发您的库，像使用任何C库一样编译和调试它，并直接在python中使用它！有点神奇。</p><p id="2431" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">加载C库非常简单:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="fe74" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我们现在能够调用库的任何函数，就像您调用python模块一样。唯一困难的是要意识到你调用了一个C函数，所以它需要类型化的参数，所以你必须给它正确的<a class="ae kv" href="https://docs.python.org/3/library/ctypes.html#fundamental-data-types" rel="noopener ugc nofollow" target="_blank">参数类型</a>。</p><p id="f7b9" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">为了说明所有这些，让我们举一个简单的例子。两弦间Levenshtein距离的计算</p><h1 id="a4e6" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">莱文斯坦距离</h1><p id="69ec" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">Levenshtein距离是一个距离(从数学上来说),它度量两个字符串之间的版本距离。它测量要插入、删除或替换的字符数，以匹配两个字符串。两根弦相差越大，距离就越大。</p><p id="0dd1" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">为了计算距离，我们允许三种编辑操作:删除、插入或替换一个字符。有时与每个操作相关的成本是相同的，等于1，有时我们将替换操作的成本设置为2，因为它可以被分解为一个删除操作和一个插入操作。该算法非常简单，包括构建一个秩为<code class="fe ny nz oa ob b">MxN</code>的矩阵，其中<code class="fe ny nz oa ob b">M</code>是源字符串的字符数加1，<code class="fe ny nz oa ob b">N</code>是目标字符串的字符数加1。于是，Levenshtein距离就是矩阵的元素<code class="fe ny nz oa ob b">D[M,N]</code>。</p><h2 id="093b" class="nd kx iq bd ky ne nf dn lc ng nh dp lg lx ni nj li mb nk nl lk mf nm nn lm no bi translated">矩阵初始化</h2><p id="af5b" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">计算矩阵<code class="fe ny nz oa ob b">D</code>的第一步是初始化它。我们构造一个秩为<code class="fe ny nz oa ob b">MxN</code>的空矩阵，其中<code class="fe ny nz oa ob b">M</code>是源字符串的字符数加1，而<code class="fe ny nz oa ob b">N</code>是目标字符串的字符数加1，以允许使用空字符<code class="fe ny nz oa ob b">#</code>。</p><p id="014c" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">然后，矩阵的第一行计算从空字符串到目标字符串的每个子字符串的距离。例如，让我们把单词<code class="fe ny nz oa ob b">levenshtein</code>作为我们的源字符串，把<code class="fe ny nz oa ob b">levenstein</code>作为我们的目标(这里省略了字母<code class="fe ny nz oa ob b">h</code>)。然后，对于目标的每个子字符串，我们在每一列中都有一个成本<code class="fe ny nz oa ob b">ins_cost</code>。的确，要从空字符串<code class="fe ny nz oa ob b">'#'</code>到达字符串<code class="fe ny nz oa ob b">'l'</code>，我们必须插入一个字母，所以距离<code class="fe ny nz oa ob b">'#' → 'l'</code>等于<code class="fe ny nz oa ob b">ins_cost</code>。我们用同样的方法计算第一行的距离<code class="fe ny nz oa ob b">'#' → 'le'</code>，它等于<code class="fe ny nz oa ob b">2 x ins_cost</code>，依此类推。推理与第一列相同，但是使用了<code class="fe ny nz oa ob b">del_cost</code>而不是<code class="fe ny nz oa ob b">ins_cost</code>，因为从<code class="fe ny nz oa ob b">'l'</code>到<code class="fe ny nz oa ob b">'#'</code>的距离是通过删除成本来测量的。删除和插入成本为1时，得到的初始矩阵为</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/103e04da4b6652a29feab248a2f29298.png" data-original-src="https://miro.medium.com/v2/resize:fit:970/format:webp/1*xwvgTMCOJW-dD9uTt0nKlA.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">距离矩阵初始化</p></figure><h2 id="c0bd" class="nd kx iq bd ky ne nf dn lc ng nh dp lg lx ni nj li mb nk nl lk mf nm nn lm no bi translated">矩阵元素计算</h2><p id="368d" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">一旦矩阵被初始化，就该根据Levenshtein算法填充它了:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi od"><img src="../Images/4d20f89387a2e9a42bc0ee1889a8e27e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_nZpj5EZn1_7fIYqn3uL9Q.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Levenshtein距离计算算法</p></figure><p id="f4c0" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">因此，我们从两个字符串的第一个字母开始，即我们感兴趣的单元格<code class="fe ny nz oa ob b">D[1, 1].</code></p><ul class=""><li id="cea9" class="mp mq iq lq b lr mk lu ml lx mr mb ms mf mt mj mu mv mw mx bi translated">该算法的第一行告诉我们获取当前列的前一行的内容(<code class="fe ny nz oa ob b">'#' → ‘l'</code>的成本)并将其添加到删除成本中</li><li id="5831" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated">第二行开始添加当前行前一列的插入成本(<code class="fe ny nz oa ob b">'l' → '#'</code>的成本)，因此它是总成本<code class="fe ny nz oa ob b">'l' → '#' → 'l'</code>，等于2</li><li id="9cc9" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated">对于最后一行，我们注意到对于这个单元格，源和目标的字母是相同的，所以我们简单地取前一行和前一列的成本，即我们不需要任何编辑来执行这个步骤。</li><li id="76c0" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated">最后，我们保留三个成本中的最小值，在本例中为0</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/9c3ded0ce99ae2784a7a405d8d43a2ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:424/format:webp/1*8kDbPclbB--lzRcS_yDmzg.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">矩阵计算</p></figure><p id="711f" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">使用这种算法，我们迭代矩阵的每个单元</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi of"><img src="../Images/752d4c2210d1eaa7ee27d15698532a44.png" data-original-src="https://miro.medium.com/v2/resize:fit:972/format:webp/1*RwShptPXnvGqFh4FM6n2ag.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">矩阵计算结果</p></figure><p id="8f7d" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">两个字符串<code class="fe ny nz oa ob b">'levenshtein'</code>和<code class="fe ny nz oa ob b">'levenstein'</code>之间的最小编辑距离等于1，这非常有意义，因为我们只需要从源字符串中删除一个字母就可以到达目标字符串。</p><h1 id="8b96" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">算法实现</h1><p id="562a" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">Levenshtein算法实现起来非常简单(您可以找到它的许多版本),使用C语言通常不会有什么挑战。尝试ctypes的最佳时机！这里是我的算法的简单C实现:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="bbc2" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我们已经遵循了算法的所有步骤，从初始化到每个单元的迭代。我选择了返回整个矩阵，但是我们也可以选择只输出距离。</p><p id="1e69" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">如果我们注意到在计算时只需要访问前一行(或前一列)的内容，那么前面的实现可以得到改进。因此，我们可以只使用一行，并在执行计算时更新其内容。实现的改进版本如下(注意，我们现在返回的是距离，而不是整个矩阵，因为我们没有把它保存在内存中)</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nw nx l"/></div></figure><h1 id="1827" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">从python调用C函数</h1><p id="9b48" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">现在我们已经构建了我们的C库，由于<code class="fe ny nz oa ob b">ctypes</code>，我们可以将它直接加载到python代码中，并调用其中的任何函数。</p><p id="240b" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">用<code class="fe ny nz oa ob b">ctypes</code>加载库很简单:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="7aa0" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">唯一棘手的部分是C是一种类型化语言，而不是python，因此<code class="fe ny nz oa ob b">ctypes</code>需要将python变量整理成相应的C类型。在第5行和第11行中，我们明确地告诉C函数它期望什么类型的变量，以及我们得到什么类型的结果。在我们的例子中，我们传递两个字符串(指向二进制格式的<code class="fe ny nz oa ob b">char</code>的指针)加上三个整数，我们期望结果是一个整数。</p><p id="2076" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我们现在只需要调用这个函数:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nw nx l"/></div></figure><h1 id="ec4d" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">结论</h1><p id="8920" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">我们在这里对<code class="fe ny nz oa ob b">ctypes</code>做了一个简单的介绍，以展示我们可以多么容易地用C库提高python代码的性能:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi og"><img src="../Images/b468ef7dbbff4a877338ba6afae94718.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cRIPvdVZaZC2ziR4o0ngng.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Levenshtein距离的C版本的性能</p></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oh"><img src="../Images/5e1dd18b113d93b32880d62a85bf2dec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LcjoVvYpFXXQ43adtlWhgQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Levenshtein距离的python版本的性能</p></figure><p id="5a46" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">正如我们已经提到的，<code class="fe ny nz oa ob b">numba</code>或<code class="fe ny nz oa ob b">cython</code>是可供选择的商品，但我个人觉得它们更难使用和优化。使用原始C代码对我来说非常有意义，我真的很喜欢使用<code class="fe ny nz oa ob b">ctypes</code>这样简单的代码。</p></div></div>    
</body>
</html>