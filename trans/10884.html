<html>
<head>
<title>Jigsaw Puzzle AI from A to Z</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">拼图玩具人工智能从A到Z</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/jigsaw-puzzle-ai-from-a-to-z-b4bdb53d8686?source=collection_archive---------6-----------------------#2021-10-22">https://towardsdatascience.com/jigsaw-puzzle-ai-from-a-to-z-b4bdb53d8686?source=collection_archive---------6-----------------------#2021-10-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="5fe6" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用基本的人工智能工具组装任意现实生活中的谜题</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/9fec9a5ad1e4dbff9d064d490017166c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6TVSlDfQG7xyN2wIDIpYEg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片(由卡斯特兰拼图公司的“北极冰层下的生活”制作)</p></figure><h1 id="b2c4" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">介绍</h1><p id="7367" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">自人工智能早期以来，我们已经看到了处理拼图难题的多种尝试。然而，爱好者主要集中在特定的方面:只有方瓦，只有非扫描，单色等。</p><p id="771d" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">在这里，我们来看一下全面的方法，这种方法在非常简单的同时处理了整个问题。这项工作的想法是展示我们如何能够利用今天的基本人工智能工具来处理拼图游戏解决方案的所有方面。</p><p id="5034" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">我们将使用Google Colab和Python来完成这项工作，这样每个人都能够轻松地理解和复制它，而无需任何特殊的软件。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/76efa1e1a1ef9ce42cab711fa0718979.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/1*ulGSeLyM1bLKyR9Xjj380g.gif"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">“用300行代码在60秒内解决”(图片由作者提供)</p></figure><h1 id="e485" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">概观</h1><p id="c517" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">我们将解决15块瓷砖的难题。对于计算机来说，这是一个复杂的问题，因为复杂性主要不是来自瓷砖的数量，而是来自瓷砖的几何形状。我们的拼图是不均匀的圆形，并且有扭曲的弯曲边缘。</p><p id="ba5b" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">提出的方法是为了证明我们可以不局限于任何特殊类型的瓷砖。反之亦然，这个想法是用任何几何形状的瓷砖来解谜。</p><p id="26c9" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">我们将浏览300行Python代码。不过，它只涵盖了3个主要步骤:</p><ol class=""><li id="4529" class="mp mq iq lp b lq mj lt mk lw mr ma ms me mt mi mu mv mw mx bi translated">图像处理。它处理如何从扫描中提取瓷砖。</li><li id="c41f" class="mp mq iq lp b lq my lt mz lw na ma nb me nc mi mu mv mw mx bi translated">匹配。这是如何找到匹配的瓷砖以及匹配方式的核心部分。</li><li id="1aa5" class="mp mq iq lp b lq my lt mz lw na ma nb me nc mi mu mv mw mx bi translated">组装。这是一个最终的算法，把瓷砖拼凑成一个整体的图像。</li></ol><p id="f9d2" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">数量少得惊人的基本模块将足以解决我们的彩色拼图。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><h1 id="3382" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">图像处理</h1><p id="be72" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">我们将零散瓷砖的扫描图像作为输入。它必须是一个良好的扫描没有明显的扫描仪伪影，如彩色条纹或黑边。我的扫描是A4格式，重采样为727 x 1000像素，大约相当于90 dpi。</p><p id="8d1b" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">首先，我们将图像绘制封装到函数中，以进一步简化代码。我们想关闭坐标轴，为单通道图像切换到“灰色”色图，等等。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="cdfa" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">然后，我们加载一个扫描，并使其RGBA进一步参与透明度维度。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/09bf77d09d077802e4c4125d06851176.png" data-original-src="https://miro.medium.com/v2/resize:fit:1090/format:webp/1*hKqz8hVC6AWLcQP16wNbng.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="ed55" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">我们可以看到天蓝色背景上的彩色瓷砖。为了能够对瓷砖做任何事情，我们必须首先检测它们。这是一个单一的图像，我们必须把它变成15个独立的瓷砖。检测单色背景上的对象的一种可能方法是自适应阈值处理。我们将对我们的图像应用<code class="fe ng nh ni nj b">adaptiveThreshold()</code>工具，以便从背景中分离瓷砖。<code class="fe ng nh ni nj b">GaussianBlur()</code>是可选的，但在这里是必要的，因为有些瓷砖有白色边缘，这些边缘与背景融为一体，产生我们必须填充的裂缝。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/22ac9e2cf17477c22f1fc826acc70636.png" data-original-src="https://miro.medium.com/v2/resize:fit:1090/format:webp/1*fjV3Hp4eNJ_QpSh4H99j3Q.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="05b7" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">这看起来不错。尽管如此，我们也无能为力。我们需要的是一个清晰的二值图像，其中每个像素要么是瓷砖，要么是背景。因此，我们将使用OpenCV轮廓检测和填充技术来完成这个简单的技巧。为了抑制由绘画形成的额外轮廓，我们按照长度降序对检测到的轮廓进行排序，并取15个最大的轮廓(手动，因为为了简化代码省略了自动化)。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/3f9ff154faf4efc1565691a314657b38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1088/format:webp/1*FM94x_GPPZB7h1hp3RpXdA.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="b766" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">还不好。我们可以看到瓷砖有粗糙的边界和由原始扫描图像中的阴影形成的突出尖峰。抑制尖峰的典型方法之一是中值滤波，即将每个元素转换为周围元素的平均样式。换句话说，如果你的同伴都很矮，而你很高，你也会变矮:)。在<code class="fe ng nh ni nj b">median_filter()</code>之后，我们通过画一个黑色的轮廓来修整我们的形状。这是为了去掉上面模糊操作产生的阴影和多余的像素。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/8b1ffa9d98c0367502cb67015ddb73c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1088/format:webp/1*WYdG1Htq-92WtqrN8tqGUg.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="125e" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">嗯，那很好！现在图像是二进制的:瓷砖对背景，没有半色调。我们可以将它叠加在原始图像上，一个接一个地提取彩色瓷砖。另一个聪明的工具<code class="fe ng nh ni nj b">boundingRect()</code>将帮助我们从大图像中切割出想要的区块。它的作用是检测包含一个形状的最小包围盒。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nl"><img src="../Images/5a108947da69a14a3d9e740fa62f5a1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1180/format:webp/1*RUgyJ7luzb1YbyQ8vGhjtA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="251e" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">我们终于拥有他们了！15块彩色瓷砖，位于300 x 300图像的中心，背景透明。前奏结束了，该是主幕了！</p><h1 id="638d" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">相称的</h1><p id="4690" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">匹配的关键思想是拿一对瓷砖，在它们的轮廓中寻找相似的部分，沿着那些部分比较颜色，然后尝试锁定那些部分而不丢失像素。</p><p id="afd3" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">我们从重新调整我们的瓷砖开始。让我们把它们放在1400 x 1400的画布上，这是我们将用来组装整个拼图的画布。这只是一个技术操作，没有任何秘密含义。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="1a52" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">在匹配算法中将使用四个辅助函数。所有这些都基于基本的2D几何学:</p><ul class=""><li id="25e5" class="mp mq iq lp b lq mj lt mk lw mr ma ms me mt mi nm mv mw mx bi translated"><code class="fe ng nh ni nj b">getColors()</code>被设计成沿着图像的子区域拍摄彩色像素。在子区域的每3个点上，我们取2个点与子区域的内部和外部正交，深度为3个像素(因为我们不知道瓷砖的确切位置)，将颜色转换为HSV并添加到列表中。</li><li id="b049" class="mp mq iq lp b lq my lt mz lw na ma nb me nc mi nm mv mw mx bi translated"><code class="fe ng nh ni nj b">putOnAnvil()</code>将输入图像作为NumPy数组，并使用PIL方法对其进行偏移/旋转，这只是一个技术问题。我们使用它来旋转和重新定位画布瓷砖，将其子上下文中心放入图像中心，以与匹配的瓷砖融合。</li><li id="7162" class="mp mq iq lp b lq my lt mz lw na ma nb me nc mi nm mv mw mx bi translated">在组装或装配过程中，当我们移动和旋转拼图和拼块时，<code class="fe ng nh ni nj b">rotatePoint()</code>有助于跟踪拼块中心。</li><li id="cb7a" class="mp mq iq lp b lq my lt mz lw na ma nb me nc mi nm mv mw mx bi translated"><code class="fe ng nh ni nj b">reScale()</code>又是一个技术上的东西，用来把点坐标从平铺图像的(300，300)平移到拼图画布的(1400，1400)。在两个空间中工作是必要的，以节省时间而不处理额外的零像素。</li></ul><p id="5826" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">所有进一步的代码请记住，OpenCV工作在(x，y)坐标域，而其他模块是(y，x)。因此，我们将不得不不断地交换和翻转。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="f044" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">在我们深入研究匹配算法之前，让我们先来看看我们将使用的一些主要概念。当我们进行匹配时，我们会谈到图块A和B、子区域和子区域中心(pointA和pointB)、边界矩形和图块中心、最小面积矩形及其中心(cA和cB)和角度(angleA、angleB)、typepointA和typepointB来说明它是tab还是空白、画布中心(“anvil”)以及我们用于颜色匹配的近子区域点。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/5a1e738d2610d3b022b386f501969628.png" data-original-src="https://miro.medium.com/v2/resize:fit:1336/format:webp/1*uubyBtuys-ewZq3aNegBgQ.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">关键概念(图片由作者提供)</p></figure><p id="3e14" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">然后我们来看匹配算法本身。看起来很吓人。尽管如此，结构还是很简单。我们用OpenCV <code class="fe ng nh ni nj b">findContours()</code>提取两块瓷砖的轮廓。然后，我们取图块A的小子图，并将其与图块b的小子图进行比较。子图是通过主轮廓的滚动和切片得到的。</p><p id="b9d9" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">我们一个接一个地经历3个匹配循环(轮廓匹配、颜色匹配和预拟合)。名字是不言自明的，而想法是不断减少匹配的数量，通过某些标准过滤掉不好的。例如，两个外形相似的轮廓，可能在颜色上完全不相容，所以它们甚至不会到达试衣间。此外，试衣间非常耗时，因此我们希望最少数量的匹配能够通过筛选。</p><p id="8bb1" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">让我们来看看每种情况下都发生了什么:</p><ul class=""><li id="2e5a" class="mp mq iq lp b lq mj lt mk lw mr ma ms me mt mi nm mv mw mx bi translated">轮廓匹配。这是用公开的简历<code class="fe ng nh ni nj b">matchShape()</code>完成的。虽然对于曲线来说不是100%好(我更喜欢用我的方式对待那些<a class="ae no" href="https://www.simple-ai.net/post/jigsaw-puzzle-geometrical-fit" rel="noopener ugc nofollow" target="_blank"/>)，我们在这里使用它来简化故事。在匹配之前，我们检测子上下文类型(标签或空白)和一般外观(使用<code class="fe ng nh ni nj b">minAreaRect()</code>)以节省时间和避免明显的失败。正确检测旋转角度需要两个辅助标志(“共线”和“共线”)。这是因为<code class="fe ng nh ni nj b">minAreaRect()</code>只返回象限III中的(0，-90°)角度，而<code class="fe ng nh ni nj b">matchShapes()</code>根本不返回任何角度。尽管如此，还是有出路的。</li><li id="ebd9" class="mp mq iq lp b lq my lt mz lw na ma nb me nc mi nm mv mw mx bi translated">配色。它遍历过滤后的表单匹配，沿着每个子上下文获取色点，并将它们与<code class="fe ng nh ni nj b">fastdtw()</code>距离度量进行比较(在这里解释为<a class="ae no" href="https://www.simple-ai.net/post/fit-a-split-canvas-picture" rel="noopener ugc nofollow" target="_blank"/>)。关键是我们必须将颜色转换成HSV格式。拼贴的原始RGB可能会产生误导，因为130与190一样接近160，交换两个通道可能会给你相同的度量，但颜色完全不同。HSV会做得更好。</li><li id="3d23" class="mp mq iq lp b lq my lt mz lw na ma nb me nc mi nm mv mw mx bi translated">预装配。这是一个直接尝试融合瓷砖，使用火柴达到这一水平。我们取两个画布块，将它们的子上下文中心叠加在画布的中心，旋转适当的角度，并计算度量。如果图块匹配良好，我们将拥有最小的像素损失(图块不重叠)和最小的结果对轮廓长度(关节边相互贴在一起并隐藏起来不被测量)。一个更健壮的版本包括子区域的叠加和交集比率的计算(此处省略)。</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="d563" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">匹配算法的参数化将需要从难题到难题的手动调整:</p><ul class=""><li id="7005" class="mp mq iq lp b lq mj lt mk lw mr ma ms me mt mi nm mv mw mx bi translated"><code class="fe ng nh ni nj b">LENGTH</code>。这里的子节点长度是160，大致接近最小节点长度。对于拼图来说，它必须是可变的，因为拼图的大小变化很大。</li><li id="6384" class="mp mq iq lp b lq my lt mz lw na ma nb me nc mi nm mv mw mx bi translated"><code class="fe ng nh ni nj b">PRECISION</code>。这只是一个粗略的过滤器，以消除明显的不匹配。精度允许在子区域边界矩形的尺寸上有差异。它必须非零，因为图像处理不是100%准确。</li><li id="20f9" class="mp mq iq lp b lq my lt mz lw na ma nb me nc mi nm mv mw mx bi translated"><code class="fe ng nh ni nj b">STEP_A</code>、<code class="fe ng nh ni nj b">STEP_B</code>。步骤只是我们用来获取另一个分包合同的转移。值1是一个梦，但它会永远循环，你必须寻找妥协。</li><li id="b242" class="mp mq iq lp b lq my lt mz lw na ma nb me nc mi nm mv mw mx bi translated"><code class="fe ng nh ni nj b">MAX_*.</code>这些参数决定了相应指标的上限。它们主要取决于分辨率和子区域长度。</li></ul><p id="c6e2" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">现在我们在一个循环中为所有可能的配对运行匹配算法。105对中每对大约0.5秒。在这里不到一分钟，但对于128块8192对的拼图来说，需要一个小时。因此，要快速处理大型拼图，我们需要优化(numba、并行线程)以及算法技巧，如早期拼图分组、预组装等。</p><p id="97bb" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">得到的匹配列表包含关于图块编号、滚动值、子区域中心坐标、旋转角度和度量的信息。如果没有满足我们限制的匹配，我们的结果将是空的。我们也可能会错过一些比赛，瓷砖可能会在组装过程中锁定。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="ec0c" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">当我们的匹配算法从图块0转到图块14时，我们只记录升序对，如(1，5)、(2，6)等。但是，如果(1，5)匹配，那么(5，1)也匹配。这就是为什么我们把比赛展开成一个完整的列表，翻转成对。最后，我们按照配对和匹配度量对匹配列表进行排序，得到如下结果:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi np"><img src="../Images/fb31a906b222578fe68f789899a9967d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PQNJHlVfqaScJt3Oy3C88g.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者形象</p></figure><h1 id="639d" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">装配</h1><p id="ef96" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">组装的关键思想是通过匹配找到并在画布上有一个图块，尝试将B图块锁定到它，根据匹配信息移动和旋转拼图和添加的图块。</p><p id="8c07" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">也就是说，我们通过匹配子块的中心来获取匹配块，在画布中心将一个点叠加在另一个点上，并按适当的角度旋转块。为了保持对旋转和定位的控制，我们总是在画布的中心做这个动作。我们可以认为这是把每对新的中心放在画布的中心，就像放在铁砧上融合一样。这使我们能够在装配过程中正确旋转和跟踪轮廓和图块中心坐标。</p><p id="bb03" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">我们将使用一个有用的函数来简化组装算法。当我们旋转拼图和瓷砖时，它的作用是在画布上记录瓷砖的中心和角度。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="808d" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">我们的拼图有22个关节，但是匹配算法返回了37个匹配。这意味着我们必须在装配过程中过滤正确的零件。我们通过控制像素损失来实现这一点。如果我们向拼图中添加一个新的图块，它出错并部分重叠，这将导致颜色像素的丢失。当像素损失低于某个比率(在我的例子中是所添加图块的f.i. 10%)时，我们接受该图块，如果它更高——可能我们的匹配是错误的，我们必须尝试另一个。</p><p id="539e" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">为了简单起见，我们在这个算法中放弃替换瓷砖，最多只做10次尝试来组装拼图，或者在画布上达到15个瓷砖时退出循环。这意味着，如果我们放错了瓷砖，或者把正确的瓷砖放错了，我们就不能回去重新做。然而，对于这个难题，这就足够了。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/eb843706b60defc51d440678e40ac7ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1070/format:webp/1*kTlga2XS93ySpd1mL9rjgQ.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者形象</p></figure><p id="340e" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">嗯，很管用！虽然…图像看起来有点破旧。这是由于多次旋转过程中信息失真造成的。此外，不要忘记我们从一开始就在低分辨率下工作。至少，我们可以看到水下的人们在微笑:)</p><p id="dab6" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">现在，我们找到了解决方案，可以用找到的匹配项标记原始切片。对于每一对，我们在锁的位置画出一个特定颜色的圆圈，并在两者里面放一个匹配的数字。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/e7a7df64b6e1044b131c266469aa6fcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1086/format:webp/1*0rMk3OPa6860yn3MH9yzKA.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者形象</p></figure><p id="a13f" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">如您所见，并非所有制表符和空格都已标记。这是因为14把锁就足够组装这个拼图了。其他人会自动锁定。</p><h1 id="8eb6" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">结论</h1><p id="6c94" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">在本文中，我们已经经历了拼图游戏解决的整个周期。它清楚地表明，我们可以做到这一点，而无需深入学习，简单地将算法逻辑与当今的高性能人工智能工具相结合。</p><p id="d038" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">许多解释和一些算法(如检测瓷砖的数量，在组装过程中更换瓷砖等)被删除，以使故事简短，并保持重点放在总路线上。</p><p id="9af6" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">虽然这不是最终的方法，但它是全面的，并显示了我们可以使用当今简单的负担得起的工具来处理现实生活中的问题的方法。</p><p id="cc86" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">学校几何和基本Python AI的知识恰好足以解决一个问题，这个问题就在昨天还令人头疼。</p><p id="901d" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated"><em class="ns">在:</em><a class="ae no" href="https://github.com/MaximTerleev/Jigsaw-Puzzle-AI.git" rel="noopener ugc nofollow" target="_blank"><em class="ns">GitHub \ Jigsaw-Puzzle-AI</em></a>找到源文件</p></div></div>    
</body>
</html>