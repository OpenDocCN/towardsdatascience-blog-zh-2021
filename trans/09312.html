<html>
<head>
<title>np.reshape in python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">python中的np.reshape</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/np-reshape-in-python-39b4636d7d91?source=collection_archive---------6-----------------------#2021-08-29">https://towardsdatascience.com/np-reshape-in-python-39b4636d7d91?source=collection_archive---------6-----------------------#2021-08-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="dee5" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">numpy中的形状和numpy.reshape的工作原理</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/9376262f1e9111fc1092213013110cde.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*JhjiJMC2vOA2vv4lAGOvwQ.gif"/></div></figure><h1 id="934c" class="kq kr it bd ks kt ku kv kw kx ky kz la jz lb ka lc kc ld kd le kf lf kg lg lh bi translated">介绍</h1><p id="0932" class="pw-post-body-paragraph li lj it lk b ll lm ju ln lo lp jx lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">numpy.reshape并不总是像预期的那样工作，很多次我几乎疯狂地在代码中搜索错误，最终是因为np.reshape没有像我预期的那样工作，旧数组的一些元素出现在了新数组中意想不到的地方。正因为如此，很多时候我都是围绕着np.reshape工作，但今天我将面对我的命运。</p><h1 id="0691" class="kq kr it bd ks kt ku kv kw kx ky kz la jz lb ka lc kc ld kd le kf lf kg lg lh bi translated">阵列形状</h1><h2 id="e0d8" class="me kr it bd ks mf mg dn kw mh mi dp la lr mj mk lc lv ml mm le lz mn mo lg mp bi translated">一维数组</h2><p id="9ddc" class="pw-post-body-paragraph li lj it lk b ll lm ju ln lo lp jx lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在NumPy中，数组有特定的形状。当我们用np.array创建数组时，numpy会自动推断形状。让我们创建一个一维数组。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/24c5adcf2eda39727b6228a3c69dbc3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:650/format:webp/1*vvLh6l6tc4WDYr3XnucKBg.png"/></div><p class="mr ms gj gh gi mt mu bd b be z dk translated">(所有图片均由作者提供)</p></figure><p id="8111" class="pw-post-body-paragraph li lj it lk b ll mv ju ln lo mw jx lq lr mx lt lu lv my lx ly lz mz mb mc md im bi translated">我们可以通过键入以下命令来打印数组的形状:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi na"><img src="../Images/b8c6bdb540bc4deeaf7b535fdee970ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:426/format:webp/1*Z4HPB-_x4bZatP2iVbSdTg.png"/></div></figure><p id="7da1" class="pw-post-body-paragraph li lj it lk b ll mv ju ln lo mw jx lq lr mx lt lu lv my lx ly lz mz mb mc md im bi translated">这个数组的形状是:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/c6b7f0dee38b485c86c7ea8221164d4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:90/format:webp/1*V-9hJkQ2Uj4uAnKORBL-tA.png"/></div></figure><p id="37de" class="pw-post-body-paragraph li lj it lk b ll mv ju ln lo mw jx lq lr mx lt lu lv my lx ly lz mz mb mc md im bi translated">不要被形状元组中的逗号分散注意力，它只是在那里，以便我们可以将它识别为一个元组。它仍然是一个一维数组。</p><h2 id="ce87" class="me kr it bd ks mf mg dn kw mh mi dp la lr mj mk lc lv ml mm le lz mn mo lg mp bi translated">二维数组</h2><p id="49bc" class="pw-post-body-paragraph li lj it lk b ll lm ju ln lo lp jx lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">当创建二维数组时，我们必须使用双括号。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi nc"><img src="../Images/b94ba97d85f29c2ec0b3e7abeb48b109.png" data-original-src="https://miro.medium.com/v2/resize:fit:834/format:webp/1*p-9b8fWM3Je1Aai3cJSyZQ.png"/></div></div></figure><p id="1cc0" class="pw-post-body-paragraph li lj it lk b ll mv ju ln lo mw jx lq lr mx lt lu lv my lx ly lz mz mb mc md im bi translated">我们可以通过键入以下命令来打印数组的形状:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi na"><img src="../Images/b8c6bdb540bc4deeaf7b535fdee970ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:426/format:webp/1*Z4HPB-_x4bZatP2iVbSdTg.png"/></div></figure><p id="df70" class="pw-post-body-paragraph li lj it lk b ll mv ju ln lo mw jx lq lr mx lt lu lv my lx ly lz mz mb mc md im bi translated">这个数组的形状是:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/121269c9402d19ede3afd44f232bcef9.png" data-original-src="https://miro.medium.com/v2/resize:fit:122/format:webp/1*d2hj_3dnwPH2Z_m-9GoHaw.png"/></div></figure><p id="4262" class="pw-post-body-paragraph li lj it lk b ll mv ju ln lo mw jx lq lr mx lt lu lv my lx ly lz mz mb mc md im bi translated">数组的形状是:(行数，列数)。或者换句话说(第一索引，第二索引)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/8ae3260e5ee712b282c9e295e3ef0533.png" data-original-src="https://miro.medium.com/v2/resize:fit:1122/format:webp/1*-neY_cDYtr78iiEYt3MCKA.png"/></div></figure><p id="8339" class="pw-post-body-paragraph li lj it lk b ll mv ju ln lo mw jx lq lr mx lt lu lv my lx ly lz mz mb mc md im bi translated">为了更好地理解第一个索引和第二个索引，想象一下整个数组像这样展开。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/eb4db5dbba8458293b60a87c422bbd12.png" data-original-src="https://miro.medium.com/v2/resize:fit:954/format:webp/1*_FCUBuYvJepDihoSokqeNQ.png"/></div></figure><p id="361f" class="pw-post-body-paragraph li lj it lk b ll mv ju ln lo mw jx lq lr mx lt lu lv my lx ly lz mz mb mc md im bi translated">当我们按以下方式索引数组时:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/a701124baf143fdd0b2db38eb011665d.png" data-original-src="https://miro.medium.com/v2/resize:fit:186/format:webp/1*_za5BJtSad0gDLcZlE60rw.png"/></div></figure><p id="0f37" class="pw-post-body-paragraph li lj it lk b ll mv ju ln lo mw jx lq lr mx lt lu lv my lx ly lz mz mb mc md im bi translated">我们应用第一个指数(1):</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/b1b637fb7f7716cf970c6e2a74126837.png" data-original-src="https://miro.medium.com/v2/resize:fit:1250/format:webp/1*7nOpJgXQ_WCrQAbmRa-IUg.png"/></div></figure><p id="e9a7" class="pw-post-body-paragraph li lj it lk b ll mv ju ln lo mw jx lq lr mx lt lu lv my lx ly lz mz mb mc md im bi translated">然后是第二个索引(2):</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/be007a388c1bfd8c1e38c1a8ee687f77.png" data-original-src="https://miro.medium.com/v2/resize:fit:758/format:webp/1*zNcJZxR-NzzHl4p9s0-3mA.png"/></div></figure><h2 id="2766" class="me kr it bd ks mf mg dn kw mh mi dp la lr mj mk lc lv ml mm le lz mn mo lg mp bi translated">三维阵列</h2><p id="8f48" class="pw-post-body-paragraph li lj it lk b ll lm ju ln lo lp jx lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们可以通过使用三层括号创建一个三维数组。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/4284dbfd47828e27e808fbe256f7ff13.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/format:webp/1*Ex6XuIgjMRXLcDGQadhBzw.png"/></div></figure><p id="5a10" class="pw-post-body-paragraph li lj it lk b ll mv ju ln lo mw jx lq lr mx lt lu lv my lx ly lz mz mb mc md im bi translated">然后我们有了第一、第二和第三个指数。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi no"><img src="../Images/8a57de5be5cb24cb880e1ebb96c50db3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1348/format:webp/1*yyNMXFsRx5Lw0gFIwEhvMw.png"/></div></figure><h2 id="ae2c" class="me kr it bd ks mf mg dn kw mh mi dp la lr mj mk lc lv ml mm le lz mn mo lg mp bi translated">多维数组</h2><p id="0ad6" class="pw-post-body-paragraph li lj it lk b ll lm ju ln lo lp jx lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">对于任何多维数组，我们可以应用相同的逻辑。第一个索引是最外层的索引，最后一个索引是最外层的索引。</p><h1 id="e9cf" class="kq kr it bd ks kt ku kv kw kx ky kz la jz lb ka lc kc ld kd le kf lf kg lg lh bi translated">np .重塑</h1><p id="d901" class="pw-post-body-paragraph li lj it lk b ll lm ju ln lo lp jx lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">重塑过程中有两个思考步骤。第一步是将数组展开成一条直线，第二步是将其卷回新的指定形状。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi np"><img src="../Images/3b07bc195c9ed81c860364965028ed2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yleHLCF_NkszkwhKFMO6wA.png"/></div></div></figure><p id="1580" class="pw-post-body-paragraph li lj it lk b ll mv ju ln lo mw jx lq lr mx lt lu lv my lx ly lz mz mb mc md im bi translated">现在的问题是:元素展开并卷成新形状的顺序是什么？有3种不同的顺序，我们可以这样做，我们可以指定我们想要使用哪一个。</p><h2 id="4457" class="me kr it bd ks mf mg dn kw mh mi dp la lr mj mk lc lv ml mm le lz mn mo lg mp bi translated">订单= 'C '</h2><p id="b7c7" class="pw-post-body-paragraph li lj it lk b ll lm ju ln lo lp jx lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">C实际上代表编程语言C。这是默认顺序，如果我们键入:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/9f4a373f625e2fc2fcb3044e4f549073.png" data-original-src="https://miro.medium.com/v2/resize:fit:472/format:webp/1*bUxDda_xUC8Pzkvwflf03A.png"/></div></figure><p id="8d8d" class="pw-post-body-paragraph li lj it lk b ll mv ju ln lo mw jx lq lr mx lt lu lv my lx ly lz mz mb mc md im bi translated">然后，数组“arr”被整形为shape (3，4)。顺序应该是C调。因此，它将与以下内容相同:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/3d21633bfeb52dda50a9e6b2ec282ce7.png" data-original-src="https://miro.medium.com/v2/resize:fit:842/format:webp/1*TMCyNy4zhU4yXuY0v5KA8w.png"/></div></figure><p id="70e3" class="pw-post-body-paragraph li lj it lk b ll mv ju ln lo mw jx lq lr mx lt lu lv my lx ly lz mz mb mc md im bi translated">对于C顺序，我们都展开和回滚，最后一个索引变化最快，第一个索引变化最慢。</p><p id="f5cd" class="pw-post-body-paragraph li lj it lk b ll mv ju ln lo mw jx lq lr mx lt lu lv my lx ly lz mz mb mc md im bi translated">对于二维数组，我们展开数组，最后一个(第二个)索引变化最快。我们回滚到变化最快的最后一个(第二个)索引。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi ns"><img src="../Images/cbb4d5eeafa00f5f073ef2d13a031a43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-c0V0_fKF_v-rkBIs8HcTw.png"/></div></div></figure><p id="abc6" class="pw-post-body-paragraph li lj it lk b ll mv ju ln lo mw jx lq lr mx lt lu lv my lx ly lz mz mb mc md im bi translated">整个过程也可以在下面的动画中看到:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/9376262f1e9111fc1092213013110cde.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*JhjiJMC2vOA2vv4lAGOvwQ.gif"/></div></figure><p id="199e" class="pw-post-body-paragraph li lj it lk b ll mv ju ln lo mw jx lq lr mx lt lu lv my lx ly lz mz mb mc md im bi translated">对于三维数组，我们展开数组，最后一个(第三个)索引变化最快。我们用变化最快的最后一个(第三个)索引进行回滚。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi nt"><img src="../Images/80b42c8f43e6361e36908f0697d7e3b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VwWsVLaL9R0BqQ5f10L-Tw.png"/></div></div></figure><p id="46cc" class="pw-post-body-paragraph li lj it lk b ll mv ju ln lo mw jx lq lr mx lt lu lv my lx ly lz mz mb mc md im bi translated">一旦你理解了它是如何工作的，你也可以直接从输入数组到输出数组，跳过展开。我们也可以把二维数组改造成三维数组，实际上是可以想象到的所有其他维度的组合。我可以在这里举更多的例子，但是如果你严格地按照展开的过程，并把它恢复成想要的形状，这应该很容易理解。</p><h2 id="588a" class="me kr it bd ks mf mg dn kw mh mi dp la lr mj mk lc lv ml mm le lz mn mo lg mp bi translated">order = 'F '</h2><p id="794a" class="pw-post-body-paragraph li lj it lk b ll lm ju ln lo lp jx lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">F实际上代表编程语言Fortran。要使用这个顺序，我们必须指定它，例如:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/84d8d7879a9a701412644fbe40dab50f.png" data-original-src="https://miro.medium.com/v2/resize:fit:818/format:webp/1*YkGKgfhjVgzdlHs6d2yfRw.png"/></div></figure><p id="9b3b" class="pw-post-body-paragraph li lj it lk b ll mv ju ln lo mw jx lq lr mx lt lu lv my lx ly lz mz mb mc md im bi translated">按照Fortran的顺序，我们展开时第一个索引变化最快，第二个索引变化最快，最后一个索引变化最慢。</p><p id="6bd1" class="pw-post-body-paragraph li lj it lk b ll mv ju ln lo mw jx lq lr mx lt lu lv my lx ly lz mz mb mc md im bi translated">对于二维数组，第一个索引变化最快，第二个索引变化最慢:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi nv"><img src="../Images/e13d57a30806f272fe4b44def82866db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4ij_5G9ZNiZ59qxsNMuufA.png"/></div></div></figure><p id="76d3" class="pw-post-body-paragraph li lj it lk b ll mv ju ln lo mw jx lq lr mx lt lu lv my lx ly lz mz mb mc md im bi translated">一个小动画:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/1dbb20a6cd44eaa3e7158e3eccc5458c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*a3cLm1frA0RmDyqXIr4i3Q.gif"/></div></figure><p id="068a" class="pw-post-body-paragraph li lj it lk b ll mv ju ln lo mw jx lq lr mx lt lu lv my lx ly lz mz mb mc md im bi translated">对于三维numpy阵列，第一个指数变化最快，第三个指数变化最慢。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi nt"><img src="../Images/b281ca79033534e9197be55da5cfdff7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*foU1edC45ieX-V1NOK6GOw.png"/></div></div></figure><h2 id="abc0" class="me kr it bd ks mf mg dn kw mh mi dp la lr mj mk lc lv ml mm le lz mn mo lg mp bi translated">order = 'A '</h2><p id="2236" class="pw-post-body-paragraph li lj it lk b ll lm ju ln lo lp jx lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">order = 'A '，根据数组在内存中的存储方式，按照C语言顺序或Fortran语言顺序重塑。如果它存储在内存中，就像在C编程语言中一样，那么order = 'A '将使用C order进行整形。如果数组像fortran编程语言一样存储在内存中，那么它将使用Fortran顺序重新整形。这可能会加速您的tcode，但我实际上从未使用过它，因为结果是不可预测的。</p><h2 id="dc24" class="me kr it bd ks mf mg dn kw mh mi dp la lr mj mk lc lv ml mm le lz mn mo lg mp bi translated">Fortran顺序展开，C顺序整形？</h2><p id="03b8" class="pw-post-body-paragraph li lj it lk b ll lm ju ln lo lp jx lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们可以使用np.ravel函数按照Fortran的顺序展开数组，使用np.reshape按照C的顺序对展开的数组进行整形。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi nw"><img src="../Images/102777ff6ebcdc65d42c3a7ac33efe6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WX7xjf9VgZLau1A9GghYuw.png"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi nx"><img src="../Images/1ec2f4cc4c3b368a416e302ef76ead0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2QTMjGrbB4dBlK6gLvwh3g.png"/></div></div></figure><p id="1e60" class="pw-post-body-paragraph li lj it lk b ll mv ju ln lo mw jx lq lr mx lt lu lv my lx ly lz mz mb mc md im bi translated">与动画一样的重塑:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/3c3df3ddbf51ad573ade6785135fc7f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*g0D5dnlb3cCu7YotgomLAQ.gif"/></div></figure><h2 id="81f0" class="me kr it bd ks mf mg dn kw mh mi dp la lr mj mk lc lv ml mm le lz mn mo lg mp bi translated">按C顺序展开，按F顺序整形</h2><p id="f7cb" class="pw-post-body-paragraph li lj it lk b ll lm ju ln lo lp jx lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们只是按照C顺序拉威尔，然后按照F顺序重塑，这应该很简单，但是这里有一个动画，这样你就可以看到了。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/60b5f18bcfdf7cd8c11e826ce627cea3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*JajZEue5-gIzNacRovk0kQ.gif"/></div></figure><p id="034a" class="pw-post-body-paragraph li lj it lk b ll mv ju ln lo mw jx lq lr mx lt lu lv my lx ly lz mz mb mc md im bi translated">就像在np.reshape中一样，np.ravel中的默认顺序是C，所以如果我们不指定它，np.ravel将按照C顺序展开。</p><h2 id="6167" class="me kr it bd ks mf mg dn kw mh mi dp la lr mj mk lc lv ml mm le lz mn mo lg mp bi translated">-1英寸np.reshape</h2><p id="b562" class="pw-post-body-paragraph li lj it lk b ll lm ju ln lo lp jx lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们可以在np.reshape中的形状中使用-1。-1是一个占位符，并自动获取正确的值，以便输入和输出形状最终匹配。如果我们写一个函数，但我们不知道输入数组的确切维数，但我们知道输出应该有2列，这就特别有用。但是请注意，一次只能用-1替换一个值。所以我们必须知道输出数组中除一维以外的所有内容。</p><p id="f846" class="pw-post-body-paragraph li lj it lk b ll mv ju ln lo mw jx lq lr mx lt lu lv my lx ly lz mz mb mc md im bi translated">例如，假设我们有三个不同的阵列:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi ny"><img src="../Images/ce44821815b33b8aac1d62cc1925ddf6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7HWW_AnTNhHIbnACmYQqjQ.png"/></div></div></figure><p id="19a4" class="pw-post-body-paragraph li lj it lk b ll mv ju ln lo mw jx lq lr mx lt lu lv my lx ly lz mz mb mc md im bi translated">当我们打字时:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/0af23929fcc39b36438cab5ee793d85d.png" data-original-src="https://miro.medium.com/v2/resize:fit:524/format:webp/1*n2WyARx6Y6-9CcFfdTtnEg.png"/></div></figure><p id="ffe5" class="pw-post-body-paragraph li lj it lk b ll mv ju ln lo mw jx lq lr mx lt lu lv my lx ly lz mz mb mc md im bi translated">然后-1取值<strong class="lk iu"> 6 </strong>。因为arr1有12个元素，2乘以<strong class="lk iu"> 6 </strong>等于12。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/99fb6e71df8346c27e568911d08fe361.png" data-original-src="https://miro.medium.com/v2/resize:fit:524/format:webp/1*KNFMAJaB7OnsXoQNuMFJXw.png"/></div></figure><p id="6a5a" class="pw-post-body-paragraph li lj it lk b ll mv ju ln lo mw jx lq lr mx lt lu lv my lx ly lz mz mb mc md im bi translated">然后-1取值<strong class="lk iu"> 3 </strong>。由于arr2有6个元素，2乘以<strong class="lk iu"> 3 </strong>等于6。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/f3f52aba891fe01ced04547312934e0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:524/format:webp/1*wwL9zEXG5R0-Oujf3ikt9w.png"/></div></figure><p id="6cb0" class="pw-post-body-paragraph li lj it lk b ll mv ju ln lo mw jx lq lr mx lt lu lv my lx ly lz mz mb mc md im bi translated">那么-1也取值<strong class="lk iu"> 3 </strong>。由于arr2有6个元素，2乘以<strong class="lk iu"> 3 </strong>等于6。</p><h1 id="e065" class="kq kr it bd ks kt ku kv kw kx ky kz la jz lb ka lc kc ld kd le kf lf kg lg lh bi translated">作者的其他文章</h1><div class="oa ob gp gr oc od"><a rel="noopener follow" target="_blank" href="/einstein-index-notation-d62d48795378"><div class="oe ab fo"><div class="of ab og cl cj oh"><h2 class="bd iu gy z fp oi fr fs oj fu fw is bi translated">爱因斯坦指数符号</h2><div class="ok l"><h3 class="bd b gy z fp oi fr fs oj fu fw dk translated">爱因斯坦求和、指数符号和数值</h3></div><div class="ol l"><p class="bd b dl z fp oi fr fs oj fu fw dk translated">towardsdatascience.com</p></div></div><div class="om l"><div class="on l oo op oq om or ko od"/></div></div></a></div><div class="oa ob gp gr oc od"><a rel="noopener follow" target="_blank" href="/backpropagation-in-neural-networks-6561e1268da8"><div class="oe ab fo"><div class="of ab og cl cj oh"><h2 class="bd iu gy z fp oi fr fs oj fu fw is bi translated">神经网络中的反向传播</h2><div class="ok l"><h3 class="bd b gy z fp oi fr fs oj fu fw dk translated">从零开始的神经网络，包括数学和python代码</h3></div><div class="ol l"><p class="bd b dl z fp oi fr fs oj fu fw dk translated">towardsdatascience.com</p></div></div><div class="om l"><div class="os l oo op oq om or ko od"/></div></div></a></div><div class="oa ob gp gr oc od"><a rel="noopener follow" target="_blank" href="/snake-with-policy-gradients-deep-reinforcement-learning-5e6e921db054"><div class="oe ab fo"><div class="of ab og cl cj oh"><h2 class="bd iu gy z fp oi fr fs oj fu fw is bi translated">具有策略梯度的Snake深度强化学习</h2><div class="ok l"><h3 class="bd b gy z fp oi fr fs oj fu fw dk translated">策略梯度深度强化学习在蛇游戏中的应用</h3></div><div class="ol l"><p class="bd b dl z fp oi fr fs oj fu fw dk translated">towardsdatascience.com</p></div></div><div class="om l"><div class="ot l oo op oq om or ko od"/></div></div></a></div><div class="oa ob gp gr oc od"><a rel="noopener follow" target="_blank" href="/how-you-can-use-gpt-j-9c4299dd8526"><div class="oe ab fo"><div class="of ab og cl cj oh"><h2 class="bd iu gy z fp oi fr fs oj fu fw is bi translated">如何使用GPT J</h2><div class="ok l"><h3 class="bd b gy z fp oi fr fs oj fu fw dk translated">GPT J解释了3种简单的方法，你可以如何访问它</h3></div><div class="ol l"><p class="bd b dl z fp oi fr fs oj fu fw dk translated">towardsdatascience.com</p></div></div><div class="om l"><div class="ou l oo op oq om or ko od"/></div></div></a></div><h2 id="8bb3" class="me kr it bd ks mf mg dn kw mh mi dp la lr mj mk lc lv ml mm le lz mn mo lg mp bi translated">想联系支持我？</h2><p id="1728" class="pw-post-body-paragraph li lj it lk b ll lm ju ln lo lp jx lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">领英<br/><a class="ae ov" href="https://www.linkedin.com/in/vincent-m%C3%BCller-6b3542214/" rel="noopener ugc nofollow" target="_blank">https://www.linkedin.com/in/vincent-m%C3%BCller-6b3542214/</a><br/>脸书<br/><a class="ae ov" href="https://www.facebook.com/profile.php?id=100072095823739" rel="noopener ugc nofollow" target="_blank">https://www.facebook.com/profile.php?id=100072095823739</a><br/>推特<br/><a class="ae ov" href="https://twitter.com/Vincent02770108" rel="noopener ugc nofollow" target="_blank">https://twitter.com/Vincent02770108</a><br/>中等<br/><a class="ae ov" href="https://medium.com/@Vincent.Mueller" rel="noopener">https://medium.com/@Vincent.Mueller</a><br/>成为中等会员并支持我(你的部分会员费直接归我)<br/><a class="ae ov" href="https://medium.com/@Vincent.Mueller/membership" rel="noopener">https://medium.com/@Vincent.Mueller/membership</a></p></div></div>    
</body>
</html>