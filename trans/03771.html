<html>
<head>
<title>Have you heard about our lord and savior Docker?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你听说过我们的救世主Docker吗？</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/docker-101-ee3d2b8ace11?source=collection_archive---------4-----------------------#2021-03-29">https://towardsdatascience.com/docker-101-ee3d2b8ace11?source=collection_archive---------4-----------------------#2021-03-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="e43e" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用Docker和创建自己的开发环境简介</h2></div><h1 id="cd6b" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">介绍</h1><p id="f911" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">在快速变化的环境中工作，越来越多的工具被开源，我的笔记本电脑变得一团糟。安装大量的应用程序，却忘记清理它们。类似地，我用python做了一些事情——没有虚拟环境，所以基本上，许多库可以在我的笔记本电脑上自由漫游。</p><p id="141a" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">最初的解决方案是从我的笔记本电脑中移除Python和所有其他杂乱的东西。但是后来我发现，如果我为一篇博客文章或与工作相关的事情进行PoC，我会在同一个地方结束(虽然如果我转移到虚拟环境，就不会使用python)。然后我找到了Docker。我花了一段时间才明白那里发生了什么，以及我如何利用它来获得优势。</p><h1 id="8cbc" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">准备</h1><p id="5af8" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">如果你想继续下去，你应该:</p><ul class=""><li id="b87a" class="ly lz iq kz b la lt ld lu lg ma lk mb lo mc ls md me mf mg bi translated">Docker来自<a class="ae mh" href="https://www.docker.com/" rel="noopener ugc nofollow" target="_blank">官方页面</a></li><li id="d130" class="ly lz iq kz b la mi ld mj lg mk lk ml lo mm ls md me mf mg bi translated">一些IDE，或者你可以使用终端或Jupyter笔记本</li></ul><h1 id="7c00" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">了解什么是docker</h1><p id="c279" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">那么这个docker是什么？这位魔术师大师是如何解决我的问题的？</p><p id="caf2" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">Docker是一个平台。您可以创建一个特定的配置包，并在您自己的隔离环境中运行它，我们称之为容器。在某种程度上，容器实际上类似于虚拟机。你可以很容易地创建一个轻量级的容器，只需要一些相关的库和应用程序，并在上面运行你的代码。如果您决定与他人共享您的代码，您唯一需要共享的就是docker映像。</p><p id="8490" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">好，我提到的这个形象是什么？一堆指令来设置一个包含所有配置的容器，相关文件在你的工作目录中。</p><p id="ba9a" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">因为它是一个平台，我们有一个服务器-客户端的关系。</p><ul class=""><li id="e852" class="ly lz iq kz b la lt ld lu lg ma lk mb lo mc ls md me mf mg bi translated">客户端——最有可能是与docker-engine交互的CLI</li><li id="d066" class="ly lz iq kz b la mi ld mj lg mk lk ml lo mm ls md me mf mg bi translated">服务器——在你的docker-engine中，是什么协调和映射了不同的东西</li><li id="8ff0" class="ly lz iq kz b la mi ld mj lg mk lk ml lo mm ls md me mf mg bi translated">注册表Docker图像存储在其中，以后其他用户可以提取这些图像</li></ul><p id="83b2" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">好了，理论够了，我们去实践吧。</p><h1 id="53ac" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">入门指南</h1><p id="da9c" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">好了，让我们从检查docker版本开始:</p><figure class="mn mo mp mq gt mr"><div class="bz fp l di"><div class="ms mt l"/></div><p class="mu mv gj gh gi mw mx bd b be z dk translated">作者图片</p></figure><p id="9016" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">如果我们看到我们有docker(任何输出的版本)，我们就可以开始了，至少现在是这样！</p><p id="4dd7" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">如果您至少了解终端的一些基础知识，您可能会熟悉</p><pre class="mn mo mp mq gt my mz na nb aw nc bi"><span id="fc4b" class="nd kg iq mz b gy ne nf l ng nh">ps</span></pre><p id="b772" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">该命令列出了所有正在运行的进程及其PID。幸运的是，我们为docker准备了类似的东西:</p><figure class="mn mo mp mq gt mr"><div class="bz fp l di"><div class="ms mt l"/></div><p class="mu mv gj gh gi mw mx bd b be z dk translated">作者图片</p></figure><p id="1746" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">我们可以看到，我有0个docker进程正在运行。我们如何让docker流程运行起来？</p><p id="5cba" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">你说跑？这就是答案！</p><figure class="mn mo mp mq gt mr"><div class="bz fp l di"><div class="ms mt l"/></div><p class="mu mv gj gh gi mw mx bd b be z dk translated">作者图片</p></figure><p id="12a7" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">让我们打破僵局:</p><p id="03a5" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated"><strong class="kz ir"> docker </strong> —我们正在docker上执行</p><p id="1da5" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated"><strong class="kz ir">运行</strong> —创建/拉动并运行容器</p><p id="2601" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated"><strong class="kz ir"> hello-world </strong> —加载到容器中的图像</p><h1 id="0564" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">Postgres数据库</h1><p id="8bad" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">因此，假设我们需要在我们的机器上运行Postgres DB来进行一些POC。为此，我们需要:</p><ul class=""><li id="7648" class="ly lz iq kz b la lt ld lu lg ma lk mb lo mc ls md me mf mg bi translated">在docker hub中找到docker图像(或者如果你在那里有一些私人回购)</li><li id="199f" class="ly lz iq kz b la mi ld mj lg mk lk ml lo mm ls md me mf mg bi translated">决定我们要用的版本</li><li id="b9ad" class="ly lz iq kz b la mi ld mj lg mk lk ml lo mm ls md me mf mg bi translated">码头工人运行它</li></ul><h2 id="e2fd" class="nd kg iq bd kh ni nj dn kl nk nl dp kp lg nm nn kr lk no np kt lo nq nr kv ns bi translated">第一步</h2><p id="54d3" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">如果我们在谷歌上搜索docker Postgres，我们会看到docker hub <a class="ae mh" href="https://hub.docker.com/_/postgres" rel="noopener ugc nofollow" target="_blank">链接</a>到顶部的Postgres图片。在那里，我们可以看到大量关于图像及其用法的信息。</p><p id="9e29" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated"><strong class="kz ir">第二步</strong></p><figure class="mn mo mp mq gt mr gh gi paragraph-image"><div role="button" tabindex="0" class="nu nv di nw bf nx"><div class="gh gi nt"><img src="../Images/ddecdb55ddb3947b557cef6653cc4016.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BAwt0KZt1RP5EpHFHNUUCQ.png"/></div></div><p class="mu mv gj gh gi mw mx bd b be z dk translated">作者图片</p></figure><p id="10e8" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">好，这里我们看到13.2，13，最新的，13-阿尔卑斯山。这是什么意思？</p><p id="4cf1" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">即13.2数字表示特定的Postgres版本。最新版——新版本，如果有新版本的话，会一直更新到新版本。最后但同样重要的是——阿尔卑斯山。Alpine是应用程序运行的最基本的框架。Alpine版本尽可能的轻便，只是因为它只有必需品，所以与其他版本相比，它的尺寸很小。使用alpine的好处——获得最少的东西，并且只添加相关的东西。你的docker容器将尽可能的小。易于移动和部署。</p><p id="1c28" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">好吧，那我们选13.2。</p><h2 id="5a7c" class="nd kg iq bd kh ni nj dn kl nk nl dp kp lg nm nn kr lk no np kt lo nq nr kv ns bi translated">第三步</h2><p id="7293" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">让我们做……</p><pre class="mn mo mp mq gt my mz na nb aw nc bi"><span id="01c5" class="nd kg iq mz b gy ne nf l ng nh">docker run postgres:13.2</span></pre><figure class="mn mo mp mq gt mr gh gi paragraph-image"><div role="button" tabindex="0" class="nu nv di nw bf nx"><div class="gh gi oa"><img src="../Images/0913620c4eba262d238230b3770cb259.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*87G5PabQDPbLYvp95rWT8Q.png"/></div></div><p class="mu mv gj gh gi mw mx bd b be z dk translated">作者图片</p></figure><p id="4faf" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">好的，它没有运行，但是我们看到了问题所在——我们需要为它传递一个密码，用-e. <strong class="kz ir"> -e </strong>表示环境变量</p><figure class="mn mo mp mq gt mr gh gi paragraph-image"><div role="button" tabindex="0" class="nu nv di nw bf nx"><div class="gh gi ob"><img src="../Images/986980a25699ae752169819b47ef6330.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sp8WaGSCIfHkjDNaS_hoYA.png"/></div></div><p class="mu mv gj gh gi mw mx bd b be z dk translated">作者图片</p></figure><p id="2fae" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">我们看到终端处于运行进程模式，为了在同一个会话中做一些事情，我们需要终止Postgres进程。有一种方法可以让Postgress docker进程运行，并在同一个终端会话上做一些事情。我们可以使用<strong class="kz ir"> -d </strong>来运行分离的流程。</p><figure class="mn mo mp mq gt mr gh gi paragraph-image"><div role="button" tabindex="0" class="nu nv di nw bf nx"><div class="gh gi oc"><img src="../Images/cbac34692f3821044e0d28141e0a8745.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O0d2zE_NIRJclEsSlXh77A.png"/></div></div><p class="mu mv gj gh gi mw mx bd b be z dk translated">作者图片</p></figure><p id="4714" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">现在我们有了一些长绳子。这个字符串是我们的docker容器ID。如果我们运行<strong class="kz ir"> docker ps </strong>，我们会看到docker容器已经启动并正在运行:</p><figure class="mn mo mp mq gt mr gh gi paragraph-image"><div role="button" tabindex="0" class="nu nv di nw bf nx"><div class="gh gi od"><img src="../Images/a9e11f98e749970892c0976bd69e812b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9HQ-ooOp-pxIXRAZBIIPsw.png"/></div></div><p class="mu mv gj gh gi mw mx bd b be z dk translated">作者图片</p></figure><p id="e971" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">我们可以看到，docker ps中的容器id与我们从docker run中获得的不一样，也不一样长。如果我们仔细观察，我们可以看到docker ps one是较长的一个子串。docker很酷的一点是，它匹配你的容器id的开始，你不需要粘贴它的完整版本！</p><p id="28c7" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">但是等等，我不是说过docker是一个隔离的环境吗？是的。我们不会对数据库做任何事情，因为我们没有暴露任何与它交互的端口。为此，我们需要使用<strong class="kz ir"> -p </strong></p><pre class="mn mo mp mq gt my mz na nb aw nc bi"><span id="05b4" class="nd kg iq mz b gy ne nf l ng nh">docker run -e POSTGRES_PASSWORD=myplaintextpassword <strong class="mz ir">-p HOST_PORT:DOCKER_CONTAINER</strong> -d postgres:13.2</span></pre><h1 id="f519" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">Dockerfile文件</h1><p id="6c57" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">好了，现在你可能会问自己，为什么这个人要向我解释，如何键入长命令来运行一些孤立的东西。重复，无聊。我该怎么分享？将命令发送给下一个人？效率不高…</p><p id="25ce" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">没错，吊儿郎当是有道理的，但是营造环境，就不是了。这就是我们有Dockerfile的原因。</p><p id="5e36" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">Dockerfile基本上就是所有这些用环境变量映射出来的指令。所以对于我们的Postgres，我们可以创建这样的:</p><figure class="mn mo mp mq gt mr gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/8b0e986a5045c50629cd5ff9d6782a29.png" data-original-src="https://miro.medium.com/v2/resize:fit:748/format:webp/1*1zKeCvBPvHPjWM4SUPYz9Q.png"/></div><p class="mu mv gj gh gi mw mx bd b be z dk translated">作者图片</p></figure><p id="166b" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">要构建它，请在Dockerfile的文件夹中运行:</p><pre class="mn mo mp mq gt my mz na nb aw nc bi"><span id="6176" class="nd kg iq mz b gy ne nf l ng nh">docker build .</span></pre><p id="b2dc" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">我们应该看到这样的东西</p><figure class="mn mo mp mq gt mr"><div class="bz fp l di"><div class="ms mt l"/></div><p class="mu mv gj gh gi mw mx bd b be z dk translated">作者图片</p></figure><p id="797f" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">bd9416c1457a —是新建的docker图像id。我们现在可以像这样运行我们的容器:</p><figure class="mn mo mp mq gt mr"><div class="bz fp l di"><div class="ms mt l"/></div><p class="mu mv gj gh gi mw mx bd b be z dk translated">作者图片</p></figure><p id="f7b3" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">需要提到的一点是，当docker在每个步骤中构建您的Dockerfile时，它会创建一个新的Docker映像，并将其传递给下一个映像。所有这些变量都将放在缓存中，如果有地方可以重用的话，也就是说，在末尾添加一个新的环境变量:</p><figure class="mn mo mp mq gt mr gh gi paragraph-image"><div role="button" tabindex="0" class="nu nv di nw bf nx"><div class="gh gi of"><img src="../Images/6711a7fc108050c17e79eb4f846e039b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iFI3A-hHb74XmF4kReUK9A.png"/></div></div><p class="mu mv gj gh gi mw mx bd b be z dk translated">作者图片</p></figure><p id="8a17" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">它的好处是，我们可以通过在底部添加更改来更快地构建映像。我们只需要从零开始构建新添加的部分！尽管如果我们交换密码和用户名的位置，我们将不得不再次构建映像:</p><figure class="mn mo mp mq gt mr gh gi paragraph-image"><div role="button" tabindex="0" class="nu nv di nw bf nx"><div class="gh gi of"><img src="../Images/392382da2ecdfc595d8fb41f4336a485.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_LarQ4v7cKHBx9-gztrgtA.png"/></div></div><p class="mu mv gj gh gi mw mx bd b be z dk translated">作者图片</p></figure><h1 id="fbda" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">与容器交互</h1><p id="eb32" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">如果您决定优雅地关闭docker进程，您可以使用</p><pre class="mn mo mp mq gt my mz na nb aw nc bi"><span id="9512" class="nd kg iq mz b gy ne nf l ng nh">docker stop CONTAINER_ID</span></pre><p id="e1d7" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">或者你想杀了它</p><pre class="mn mo mp mq gt my mz na nb aw nc bi"><span id="6853" class="nd kg iq mz b gy ne nf l ng nh">docker kill CONTAINER_ID</span></pre><p id="0240" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">稍后，您可以使用以下命令检查停止的进程</p><figure class="mn mo mp mq gt mr gh gi paragraph-image"><div role="button" tabindex="0" class="nu nv di nw bf nx"><div class="gh gi od"><img src="../Images/8d9ebe7a4f6dd3b9c55f7769b538b761.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*USvDsA__msZ6pBzNiAmzEg.png"/></div></div><p class="mu mv gj gh gi mw mx bd b be z dk translated">作者图片</p></figure><p id="1326" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">并恢复您的容器</p><figure class="mn mo mp mq gt mr gh gi paragraph-image"><div role="button" tabindex="0" class="nu nv di nw bf nx"><div class="gh gi og"><img src="../Images/b7ac46aae8d17a944e25d3cc592ee7d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iHL9149uCqhxLpO4zcBdag.png"/></div></div><p class="mu mv gj gh gi mw mx bd b be z dk translated">作者图片</p></figure><h1 id="5df1" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">运行几个docker进程。</h1><p id="d2f7" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">好吧，所以所有的都很容易与一个docker过程；我们创建一个Dockerfile文件并运行它。如果我需要一个额外的，我可以创建并运行它。但是在某些时候，它会很快失控，因为每次docker运行都需要设置端口和其他信息。</p><p id="adfc" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">有一个解决方案— <strong class="kz ir"> docker-compose。</strong></p><h2 id="5c08" class="nd kg iq bd kh ni nj dn kl nk nl dp kp lg nm nn kr lk no np kt lo nq nr kv ns bi translated">Docker撰写</h2><p id="ef41" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">这是一个YAML文件，包含了更多关于构建什么以及不同docker文件如何一起播放的信息。</p><figure class="mn mo mp mq gt mr gh gi paragraph-image"><div role="button" tabindex="0" class="nu nv di nw bf nx"><div class="gh gi oh"><img src="../Images/d78702daaa73ae9e858452cbf46984e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Il3vK2CbkJq3Dka_Z07dVQ.png"/></div></div><p class="mu mv gj gh gi mw mx bd b be z dk translated">作者图片</p></figure><p id="5676" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">让我们讨论一些事情:</p><ul class=""><li id="6ec4" class="ly lz iq kz b la lt ld lu lg ma lk mb lo mc ls md me mf mg bi translated">版本—合成文件格式的版本。通过查看<a class="ae mh" href="https://docs.docker.com/compose/compose-file/" rel="noopener ugc nofollow" target="_blank"> docker文档</a>来检查你的docker引擎是否与之兼容</li><li id="37de" class="ly lz iq kz b la mi ld mj lg mk lk ml lo mm ls md me mf mg bi translated">app —应用程序/服务将使用一些预定义的docker映像(即气流), 8080端口映射到我们的本地机器8080</li><li id="1ffb" class="ly lz iq kz b la mi ld mj lg mk lk ml lo mm ls md me mf mg bi translated">db—一个数据库应用程序，我们将使用Dockerfile对其进行容器化，该文件位于数据库目录中</li></ul><p id="ae53" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">好了，当我们准备好文件后，我们如何构建它呢？</p><p id="a02f" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">如果您在目录中，您有文件:</p><pre class="mn mo mp mq gt my mz na nb aw nc bi"><span id="df0d" class="nd kg iq mz b gy ne nf l ng nh">docker-compose up -d --build</span></pre><p id="d00d" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">此外，您可以指定文件的完整路径:</p><pre class="mn mo mp mq gt my mz na nb aw nc bi"><span id="abe9" class="nd kg iq mz b gy ne nf l ng nh">docker-compose -f "PATH/YOU/HAVE/PUT/DOCKERCOMPOSE/FILE/docker-compose.yml" up -d --build</span></pre><h1 id="ddbf" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">摘要</h1><p id="09d3" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">总而言之——Docker FTW。</p><p id="8f25" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">这使得开发变得更加容易。创建一个图像，在其上运行你的应用程序，看看它是否有效。</p><p id="1cb9" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">我个人的原因是:</p><ul class=""><li id="0c8d" class="ly lz iq kz b la lt ld lu lg ma lk mb lo mc ls md me mf mg bi translated">需要一个隔离的ENV用于基准测试/测试等。(使用GitHub actions和Travis，您可以在docker映像中测试您的应用程序)</li><li id="924f" class="ly lz iq kz b la mi ld mj lg mk lk ml lo mm ls md me mf mg bi translated">如果有问题，测试版本升级。</li><li id="b795" class="ly lz iq kz b la mi ld mj lg mk lk ml lo mm ls md me mf mg bi translated">如果你弄乱了你的本地环境，而你又懒得去清理它</li></ul><p id="0187" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">顺便说一下，代码以类似的方式保存在我的<a class="ae mh" href="https://github.com/TomasPel/workshops/tree/main/docker_101" rel="noopener ugc nofollow" target="_blank"> GitHub </a>的一个Jupyter笔记本中，在那里你可以交互地运行它并看到结果。基本上是一个后续的机会，看看它在实践中如何工作。</p></div></div>    
</body>
</html>