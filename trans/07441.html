<html>
<head>
<title>Why (and how) to put notebooks in production</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么(以及如何)将笔记本投入生产</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/why-and-how-to-put-notebooks-in-production-667fc3979dca?source=collection_archive---------8-----------------------#2021-07-07">https://towardsdatascience.com/why-and-how-to-put-notebooks-in-production-667fc3979dca?source=collection_archive---------8-----------------------#2021-07-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="62f4" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用现代开源工具部署、测试和调试Jupyter笔记本电脑。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/9542762e7cb4ad575876e3189746109d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u8y-ggU2O513KjXdGbdEuQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Jupyter实验室截图(鸣谢:【jupyter.org】T2)</p></figure><p id="45cf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">将<em class="ls">笔记本</em>和<em class="ls">生产</em>放在同一个句子中，肯定会引发一场激烈的网上辩论。这个话题经常出现，经常听到团队完全放弃笔记本电脑，因为<em class="ls">它们不是用于生产的</em>。不幸的是，讨论经常集中在当前工具已经解决的问题上，但是对于许多从业者来说，解决方案仍然是未知的。这篇文章展示了如何克服Jupyter notebook的一些限制，提出了一个工作流程来简化它们在生产中的使用，并讨论了仍然需要解决的问题。</p><h1 id="5e65" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">笔记本的简史</h1><p id="241c" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">计算笔记本的起源来自唐纳德·克努特介绍的识字编程。其核心是，这种思想提倡编写将源代码和文档交错的程序，以使程序更具可读性。笔记本电脑通过添加其他功能，如嵌入式图形和交互式代码执行，扩展了这一理念。</p><p id="8822" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">结合这三个元素(将代码与文档交错、嵌入图形和交互性)为数据探索提供了一个强大的界面。真实世界的数据总是带有特殊性；交叉文档有助于指出它们。数据模式仅在通过嵌入图形可视化数据时出现。最后，交互性允许我们迭代我们的分析，以避免每一次改变都要从头开始。</p><h1 id="547e" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">笔记本的问题</h1><p id="07a1" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">到目前为止，我还没有特别提到任何笔记本的实现。有<a class="ae kv" href="https://en.wikipedia.org/wiki/Notebook_interface#cite_note-2" rel="noopener ugc nofollow" target="_blank">多种风格可供选择</a>，但是对于这篇文章的剩余部分，我将参考Jupyter笔记本。</p><p id="c616" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了支持交错文档，Jupyter支持Markdown单元格。对于嵌入式图形，Jupyter使用<a class="ae kv" href="https://en.wikipedia.org/wiki/Base64" rel="noopener ugc nofollow" target="_blank"> base64 </a>序列化图像，对于交互性，它公开了一个web应用程序，允许用户添加和执行代码。</p><p id="9528" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种实现决策有很大的副作用:</p><ol class=""><li id="1e6c" class="mq mr iq ky b kz la lc ld lf ms lj mt ln mu lr mv mw mx my bi translated"><strong class="ky ir">文件大小。</strong>如果笔记本包含图像，文件大小会大大增加，很快就会破坏git存储库。</li><li id="a525" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated"><strong class="ky ir">版本控制。</strong> <code class="fe ne nf ng nh b">.ipynb</code>文件是JSON文件。<code class="fe ne nf ng nh b">git diff</code>输出版本之间难以辨认的比较，使得代码审查变得困难。</li><li id="4919" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated"><strong class="ky ir">隐藏状态。</strong>由于用户可以以任意顺序执行代码，这可能会产生中断的代码，当顺序运行单元时，其记录的输出不匹配。</li><li id="e5a4" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated"><strong class="ky ir">测试/调试。鉴于笔记本的交互性，代码行增长很快。很快，你就会得到一个有一百个难以测试和调试的电池的笔记本。</strong></li></ol><h1 id="8f81" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">文件大小和版本</h1><p id="dd37" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">前两个问题是<code class="fe ne nf ng nh b">.ipynb</code>实现的结果。幸运的是，它们很容易用当前的工具解决。例如，如果我们可以在git上存储相对较大的文件，我们可以配置git使用不同的算法为<code class="fe ne nf ng nh b">.ipynb</code>文件生成diff视图，<a class="ae kv" href="https://github.com/jupyter/nbdime" rel="noopener ugc nofollow" target="_blank"> nbdime </a>允许我们这样做。</p><p id="db17" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们关心git版本<em class="ls">和</em>文件大小，我们可以完全替换<code class="fe ne nf ng nh b">.ipynb</code>格式。<a class="ae kv" href="https://github.com/mwouts/jupytext" rel="noopener ugc nofollow" target="_blank"> Jupytext </a>允许Jupyter将<code class="fe ne nf ng nh b">.py</code>(以及其他)文件作为笔记本打开；警告是任何输出都会丢失，因为<code class="fe ne nf ng nh b">.py</code>文件不支持嵌入图形。但是，您可以使用jupytext <a class="ae kv" href="https://jupytext.readthedocs.io/en/latest/paired-notebooks.html" rel="noopener ugc nofollow" target="_blank">配对特性</a>将输出保存在一个单独的文件中。</p><p id="e7a8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">大多数人都不知道Jupyter不知道底层的文件格式。<strong class="ky ir">感觉像笔记本的东西并不意味着一定是</strong> <code class="fe ne nf ng nh b"><strong class="ky ir">.ipynb</strong></code> <strong class="ky ir">文件。</strong>改变底层文件格式解决了大小和版本问题；让我们来关注一下真题:<em class="ls">隐藏状态</em>。</p><h1 id="7bf4" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">隐藏状态</h1><p id="5e84" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">Jupyter允许用户交互地添加和执行代码单元。当处理新数据集时，这非常有用。它使我们能够探索和清理我们的数据，同时保留迄今为止我们所执行的记录(代码和输出)。但数据探索过程多是试错；我们经常修改并重新执行以前的单元格，导致单元格的历史不是线性的。最近，一项对GitHub上1000万台笔记本的<a class="ae kv" href="https://blog.jetbrains.com/datalore/2020/12/17/we-downloaded-10-000-000-jupyter-notebooks-from-github-this-is-what-we-learned/" rel="noopener ugc nofollow" target="_blank">分析</a>发现，36%的Jupyter笔记本拥有以非线性顺序执行的单元。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ni"><img src="../Images/0c9b490b27fb05e2ce106a4521722b02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*92Op8iW9dG-Fli7m2bkkiw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">笔记本的隐藏状态是迄今为止对笔记本最重要的(也是最有效的)批评。这是笔记本的悖论:<em class="nj">任意的单元格执行简化了数据探索，但是它的过度使用经常产生不可复制的代码。图片作者。</em></p></figure><h1 id="709f" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">调试/测试</h1><p id="c271" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">笔记本的隐藏状态是迄今为止对笔记本最重要的(也是最有效的)批评。这是笔记本的悖论:<em class="ls">任意的单元格执行简化了数据探索，但是它的过度使用经常产生不可复制的代码。</em></p><p id="c346" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但即使是完美的线性笔记本也有其他问题；主要是它们很难调试和测试。这有两个主要原因。首先，笔记本是有机进化的，一旦它们变得足够大，就会涉及太多的变量，以至于很难对执行流程进行推理。第二个原因是笔记本内部定义的函数不能进行单元测试(尽管<a class="ae kv" href="https://github.com/nteract/testbook" rel="noopener ugc nofollow" target="_blank">这正在改变</a>)，因为我们不能轻易地将<code class="fe ne nf ng nh b">.ipynb</code>文件中定义的函数导入测试模块。我们可能决定在一个<code class="fe ne nf ng nh b">.py</code>文件中定义函数，并将它们导入到笔记本中来解决这个问题。尽管如此，如果没有正确完成，这将导致手动编辑<code class="fe ne nf ng nh b">sys.path</code>或<code class="fe ne nf ng nh b">PYTHONPATH</code>，从而导致其他问题。</p><h1 id="b8e0" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">笔记本中原型问题然后被重构用于生产</h1><p id="1a48" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">考虑到这样的问题，团队不允许在产品代码中使用笔记本是很自然的。常见的做法是使用笔记本进行<em class="ls">原型制作</em>，并将代码重构为模块、函数和脚本进行部署。通常，数据科学家负责原型模型；然后，工程师接手，清理代码并部署。重构笔记本是一个痛苦、缓慢且容易出错的过程，会给数据科学家和工程师带来摩擦和挫折。</p><p id="21b2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在正常的重构过程中，工程师会做一些小的改动并运行测试套件，以确保一切都正常工作。不幸的是，数据科学家的代码很少附带全面的测试套件(为数据科学家辩护:当你的工作成果以你的模型有多好来衡量时，很难考虑代码测试)。缺乏测试极大地增加了重构过程的难度。</p><p id="7aee" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另一方面，软件项目需要维护。虽然工程师可能能够做到这一点，但数据科学家最适合完成诸如模型重新训练之类的任务。重构过程发生后，即使是编写原始代码的数据科学家也很难浏览工程师部署的重构版本。更糟糕的是，由于代码已经不在笔记本中，他们不能再交互地执行它。最终发生的是生产代码和新开发笔记本之间的大量复制粘贴。</p><p id="f0fd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如您所见，这是一个低效的过程，经常会导致管道中断，并大大降低部署更新所需的时间。所有这些都造成了过度的负担，在某些情况下，导致公司由于高昂的维护成本而放弃机器学习项目。</p><h1 id="920c" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">在生产中拥抱笔记本电脑</h1><p id="7df1" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">对于我职业生涯中完成的大多数机器学习项目，我负责端到端的过程:探索数据集以创建新的模型特征，训练模型，并部署它们。我亲身经历过这种痛苦的重构过程，我不得不在笔记本环境和产品代码库之间来回移动。在我与数据打交道的最初几年，我认为这个问题是理所当然的，并学会了忍受它。然而，随着我开始参与更重要的项目，这种方式对我来说风险太高，我无法继续工作，我开发了一个工作流程，让我在很大程度上克服了这些挑战。</p><p id="406a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在设计这个工作流程时，我把简单放在第一位。数据科学团队必须快速行动，因为他们的工作本质上是实验性的。这种方法不是最终的解决方案，但它是对当前实践的巨大改进。笔记本电脑和机器学习工具有很大的创新空间，可以支持一个工作流，为数据科学家提供交互式开发的能力，同时允许他们在部署过程中更好地与工程团队合作。</p><h1 id="959f" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">工作流摘要</h1><p id="2113" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">提议的工作流程如下:</p><ol class=""><li id="6e75" class="mq mr iq ky b kz la lc ld lf ms lj mt ln mu lr mv mw mx my bi translated">将脚本用作笔记本。</li><li id="64a8" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated">每个<code class="fe ne nf ng nh b">git push</code>上有一个数据样本的冒烟测试笔记本。</li><li id="fbfc" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated">在多个小笔记本中分解分析。</li><li id="5573" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated">打包项目(即添加一个<code class="fe ne nf ng nh b">setup.py</code>文件)。</li><li id="2951" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated">从笔记本之外的功能中抽象出逻辑片段，用于代码重用和单元测试。</li></ol><p id="4060" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在让我们详细讨论每一个。</p><h1 id="48cf" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">切换底层格式:作为笔记本的脚本</h1><p id="0f3b" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">如前所述，<code class="fe ne nf ng nh b">.ipynb</code>格式不能很好地与git兼容。然而，Jupyter的架构允许使用替代文件格式。<a class="ae kv" href="https://github.com/mwouts/jupytext" rel="noopener ugc nofollow" target="_blank"> Jupytext </a>使用户能够将<code class="fe ne nf ng nh b">.py</code>作为笔记本打开，有效地解决了git版本问题，方便了代码审查。数据科学家可以从Jupyter交互开发他们的代码，但是存储库将只包含<code class="fe ne nf ng nh b">.py</code>文件。本文的其余部分继续使用术语<em class="ls">笔记本</em>，但是请记住，我们指的是与Jupyter兼容的Python脚本。</p><h1 id="c781" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">隐藏状态、测试和调试</h1><p id="e9f3" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">这三个问题高度相关，解决起来更具挑战性。与任何其他软件项目一样，解决方案在于开发模块化和可测试的代码。然而，面临的挑战是如何将其应用于高度不确定的环境，这种环境需要快速迭代，并采用Jupyter笔记本作为其主要开发工具。</p><p id="c741" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们希望实现以下目标:</p><ol class=""><li id="5dbf" class="mq mr iq ky b kz la lc ld lf ms lj mt ln mu lr mv mw mx my bi translated">每一次代码变更都要做测试笔记。</li><li id="6bf3" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated">在多个小型笔记本中分离逻辑。</li><li id="9bfc" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated">模块化数据转换，并分别进行测试。</li></ol><h2 id="3f06" class="nk lu iq bd lv nl nm dn lz nn no dp md lf np nq mf lj nr ns mh ln nt nu mj nv bi translated">测试笔记本</h2><p id="5bf5" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">由于运行时的原因，测试数据处理代码本身就具有挑战性。我们不能在每次变更时都运行所有的处理代码，因为这可能需要几个小时才能完成。幸运的是，我们可以用少量数据检测最常见的错误:缺少列、错误的数组形状、不兼容的数据类型等。因此，一个有效的策略是在每次推送时使用数据样本运行所有笔记本，以消除笔记本损坏的可能性。然而，由于我们没有测试笔记本电脑的输出，这是不健全的；但是随着项目的成熟，我们可以加入更多完整的测试。如果你想了解更多关于测试数据科学管道的信息，请查看我在<a class="ae kv" href="https://www.youtube.com/watch?v=zvnjOzvsvXw" rel="noopener ugc nofollow" target="_blank"> PyData 2020 </a>的演讲。</p><p id="6678" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要自动执行笔记本，我们可以使用<a class="ae kv" href="https://github.com/nteract/papermill" rel="noopener ugc nofollow" target="_blank"> papermill </a>或<a class="ae kv" href="https://github.com/jupyter/nbclient" rel="noopener ugc nofollow" target="_blank"> nbclient </a>。注意，由于我们转换了底层格式，我们必须使用jupytext将<code class="fe ne nf ng nh b">.py</code>文件转换回<code class="fe ne nf ng nh b">.ipynb</code>，然后执行它们。</p><h2 id="64ab" class="nk lu iq bd lv nl nm dn lz nn no dp md lf np nq mf lj nr ns mh ln nt nu mj nv bi translated">在多个小型笔记本电脑中分离逻辑</h2><p id="8350" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">模块化代码是软件工程中的常规实践，因为它使代码更易测试和维护。然而，数据科学家在一个笔记本上编写整个项目的代码是很常见的。为什么？方便。一旦您将一个项目分解成多个部分，您就必须处理需要数据科学家额外工作的技术难题，在某些情况下，这种工作超出了他们的专业领域。简化模块化过程是dbt蓬勃发展的原因(以及许多其他原因):它允许数据分析师将庞大的SQL脚本分解成多个部分，组装成一个连贯的管道。我们可以把同样的逻辑应用到笔记本上。</p><p id="90b7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">笔记本模块化是大多数工具的不足之处。虽然许多<a class="ae kv" href="https://ploomber.io/posts/survey/" rel="noopener ugc nofollow" target="_blank">工作流程编排者</a>支持笔记本执行，但他们并没有让这个过程变得愉快。帮助数据科学家(包括我自己)编写更易维护和模块化的管道是我创建<a class="ae kv" href="https://github.com/ploomber/ploomber" rel="noopener ugc nofollow" target="_blank"> Ploomber </a>的主要动机。</p><p id="6725" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Ploomber允许数据科学家分两步从多个笔记本电脑创建数据管道:</p><ol class=""><li id="db86" class="mq mr iq ky b kz la lc ld lf ms lj mt ln mu lr mv mw mx my bi translated">在一个<code class="fe ne nf ng nh b">pipeline.yaml</code>文件中列出笔记本。</li><li id="541d" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated">通过引用其他笔记本的名称来声明笔记本依赖关系。</li></ol><p id="7f2a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，典型的<code class="fe ne nf ng nh b">pipeline.yaml</code>如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="0dc3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">得益于Ploomber(和jupytext)插件，Jupyter将<code class="fe ne nf ng nh b">.py</code>脚本识别为“笔记本”;因此，数据科学家可以交互开发。然而，在执行过程中，Ploomber将它们转换为<code class="fe ne nf ng nh b">.ipynb</code>并执行它们，从而允许我们将源(<code class="fe ne nf ng nh b">.py</code>)和输出(<code class="fe ne nf ng nh b">.ipynb</code>文件中的表格和图表)分开。此外，任务可以生成任何其他数量的输出，如数据文件。</p><p id="e1a4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要建立执行顺序，用户只需声明必须在我们正在处理的笔记本之前执行的笔记本。例如，为了清理数据，我们必须下载原始版本，所以我们将在<code class="fe ne nf ng nh b">clean.py</code>中做这样的事情:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="8e52" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">就是这样。如果我们重新加载笔记本，我们会在依赖项列表的正下方看到一个新的单元格:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="86da" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Ploomber解析我们的引用，并添加一个包含输入位置的新变量。我们可以继续以这种方式构建，并创建包含几十个任务的管道，而不必跟踪每个任务的输出。因为跨文件分割逻辑很简单，所以多人可以同时处理它。Ploomber帮助创建可维护的管道，感觉就像一个笔记本。</p><p id="98ac" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过使用<code class="fe ne nf ng nh b">upstream</code>变量引用其他任务，我们还可以确定执行顺序，从而允许我们创建一个这样的管道:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ny"><img src="../Images/7248c1fc06ae67bbd00d6068881d86f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EdJMxQf68jPHCIbonyFLXQ.png"/></div></div></figure><p id="b674" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了执行整个管道，我们运行:<code class="fe ne nf ng nh b">ploomber build</code>。</p><p id="9c96" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">笔记本模块化有许多好处:它允许我们隔离运行部件进行调试，添加集成测试以检查每个输出的完整性，参数化管道以使用不同的配置运行(开发、试运行、生产)，并行化独立任务等。</p><h2 id="396c" class="nk lu iq bd lv nl nm dn lz nn no dp md lf np nq mf lj nr ns mh ln nt nu mj nv bi translated">代码模块化和单元测试</h2><p id="ce4d" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">笔记本中声明的代码不能轻易从其他笔记本中导入，这导致了<code class="fe ne nf ng nh b">.ipynb</code>文件之间的大量复制粘贴。因此，当部署一个模型时，工程师经常不得不处理这样的项目结构:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="d120" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">重构一个像上面这样的项目是一个真正的噩梦。当工程师不得不重构这样的项目进行部署时，已经太晚了:笔记本可能很容易包含数千个单元，其中有几个部分是复制粘贴的，没有单元测试。相反，我们应该致力于在项目的所有阶段保持最低的代码质量。</p><p id="7668" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，使用<em class="ls">脚本作为笔记本</em>(如前所述)方便了代码审查，因为我们不再需要处理<em class="ls">不同</em> <code class="fe ne nf ng nh b">.ipynb</code>文件的复杂性。其次，通过为数据科学家提供预配置的项目布局，我们可以帮助他们更好地组织工作。例如，一个组织得更好的项目可能是这样的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="4a26" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">前面的示例布局明确地将项目组织为三个部分。首先，我们用<code class="fe ne nf ng nh b">.py</code>替换<code class="fe ne nf ng nh b">.ipynb</code>文件，并将它们放在<code class="fe ne nf ng nh b">tasks/</code>目录中。第二，将多次需要的逻辑抽象在函数中，存储在<code class="fe ne nf ng nh b">src/</code>下。最后，在<code class="fe ne nf ng nh b">src/</code>中定义的功能在<code class="fe ne nf ng nh b">tests/</code>中进行单元测试。</p><p id="cdeb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了确保该布局有效，在<code class="fe ne nf ng nh b">src/</code>中定义的代码必须可以从<code class="fe ne nf ng nh b">tasks/</code>和<code class="fe ne nf ng nh b">tests/</code>中导入。不幸的是，默认情况下这是行不通的。如果我们打开<code class="fe ne nf ng nh b">tasks/</code>中的任何“笔记本”，我们将无法从<code class="fe ne nf ng nh b">src/</code>中导入任何内容，除非我们修改<code class="fe ne nf ng nh b">sys.path</code>或<code class="fe ne nf ng nh b">PYTHONPATH</code>。尽管如此，如果数据科学家不能避开Python导入系统的有限性，他们会倾向于复制粘贴代码。</p><p id="f0b3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">幸运的是，这个问题很容易解决。添加一个<code class="fe ne nf ng nh b">setup.py</code>文件，让Python将您的项目识别为一个包，您将能够从项目中的任何地方(甚至在Python交互式会话中)从<code class="fe ne nf ng nh b">src/</code>导入函数。每当我与其他数据科学家分享这个技巧时，他们就开始编写更多可重用的代码。要了解更多关于Python打包的内容，<a class="ae kv" href="https://packaging.python.org/tutorials/packaging-projects/" rel="noopener ugc nofollow" target="_blank">点击这里</a>。</p><h1 id="68fa" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">思考生产中笔记本电脑的未来</h1><p id="f968" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">讨论笔记本在作品中的使用总是一场艰苦的战斗。大多数人认为<em class="ls">笔记本只是用来做原型</em>是不可否认的事实，但我不这么认为。笔记本是处理数据的绝佳工具，虽然当前的工具使使用笔记本编写生产就绪代码变得更加容易，但仍有大量工作要做。</p><p id="b470" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这项工作的一部分是开发更好的工具，而不仅仅是改善笔记本体验:毫无疑问，提供实时协作、与SQL更好的集成或云中托管Jupyter实验室等功能有很大的价值；然而，如果我们不在部署代码时更重要的领域(如编排、模块化和测试)进行创新，笔记本电脑仍将被视为一种<em class="ls">原型</em>工具。</p><p id="6406" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，这项工作的一部分是消除关于笔记本如何工作的神话。我希望数据科学领域的开发实践能够吸收笔记本电脑的精华并不断发展，而不是抛弃它们，回到前笔记本时代的相同方法。</p><p id="96cf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您想在生产中采用包含笔记本电脑的工作流程方面获得帮助<a class="ae kv" href="https://twitter.com/edublancas" rel="noopener ugc nofollow" target="_blank">，请联系</a>，我很乐意谈论这些话题。</p><p id="dcb4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ls">特别感谢Alana Anderson和Sarah Krasnik阅读早期草稿并提供宝贵反馈。</em></p></div><div class="ab cl nz oa hu ob" role="separator"><span class="oc bw bk od oe of"/><span class="oc bw bk od oe of"/><span class="oc bw bk od oe"/></div><div class="ij ik il im in"><p id="bfbb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ls">最初发布于</em><a class="ae kv" href="https://ploomber.io/posts/nbs-production/" rel="noopener ugc nofollow" target="_blank"><em class="ls">ploomber . io</em></a><em class="ls">。</em></p></div></div>    
</body>
</html>