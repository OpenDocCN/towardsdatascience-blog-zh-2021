<html>
<head>
<title>Replicating Python’s Pandas Library</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">复制Python的熊猫库</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/replicating-pythons-pandas-library-4c959f8bbbe3?source=collection_archive---------24-----------------------#2021-05-21">https://towardsdatascience.com/replicating-pythons-pandas-library-4c959f8bbbe3?source=collection_archive---------24-----------------------#2021-05-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="67ca" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">面向对象编程和熊猫如何在幕后工作</h2></div><h1 id="6f07" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">语境</h1><p id="2eb1" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我已经和Python——主要是熊猫——一起工作了好几年，我喜欢它；它使用起来非常简单，并且有足够的方法来为任何需求进行非常复杂的数据建模。</p><p id="dc08" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">然而，如果我所做的大部分都是<code class="fe ly lz ma mb b">read_csv, filtering, and groupby</code>的话，我声称了解Python可能有点原始。因此，为了在更有经验的Python程序员面前不显得无能，我决定稍微挖掘一下熊猫<a class="ae mc" href="https://github.com/pandas-dev/pandas" rel="noopener ugc nofollow" target="_blank">源代码</a>来找出事情是如何在引擎盖下工作的，<em class="md">就像深入了解本质的那种</em>，而不是成为其各种应用程序的盲目用户。我想带着几个目标离开这个练习:(1)对Python中的OOP有一些实践经验，(2)学习Python中的包是如何工作的，以及(3)理解Pandas是如何使用它的时髦功能的。</p><p id="91e7" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">在这篇文章中，我将详细介绍我的一些发现，以及通过一个简单的代码来内化所学到的知识，在这里，我试图重新创建pandas的一个核心组件的更简单的版本:<strong class="kz ir">它的DataFrame类</strong>。如果你是Python的新手，或者只是一个好奇的读者，那么这篇文章就是为你准备的！</p><p id="75ad" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">先不说这个，让我们把这篇文章分成几个部分:</p><ul class=""><li id="cfef" class="me mf iq kz b la lt ld lu lg mg lk mh lo mi ls mj mk ml mm bi translated">先决条件</li><li id="5a4c" class="me mf iq kz b la mn ld mo lg mp lk mq lo mr ls mj mk ml mm bi translated">设置我们的熊猫复制品工作空间</li><li id="d2bd" class="me mf iq kz b la mn ld mo lg mp lk mq lo mr ls mj mk ml mm bi translated">创建我们的DataFrame对象</li><li id="22ef" class="me mf iq kz b la mn ld mo lg mp lk mq lo mr ls mj mk ml mm bi translated">将数据读入我们的数据框架</li><li id="7c5a" class="me mf iq kz b la mn ld mo lg mp lk mq lo mr ls mj mk ml mm bi translated">实现一些数据框架方法</li><li id="1e72" class="me mf iq kz b la mn ld mo lg mp lk mq lo mr ls mj mk ml mm bi translated">在笔记本电脑环境中使用我们的数据框架</li></ul><p id="82ab" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">链接到<a class="ae mc" href="https://github.com/reubenlee3/pandas-replica" rel="noopener ugc nofollow" target="_blank">熊猫_副本源代码</a></p><h1 id="c071" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">先决条件</h1><p id="8075" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">在我做这个练习的时候，我发现对一些核心Python概念有一个坚实的理解对于阅读源代码是非常必要的。下面我列出了几个真正有帮助的地方——我不会详细介绍它们，但我会附上有用的文档和教程链接，以帮助那些不熟悉这些概念的人。</p><h2 id="67d7" class="ms kg iq bd kh mt mu dn kl mv mw dp kp lg mx my kr lk mz na kt lo nb nc kv nd bi translated">理解Python中的面向对象编程(OOP)</h2><p id="7ea2" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">对于任何想了解Python中OOP的人来说，有大量的资源可供参考，其中我特别喜欢的一个资源是科里·斯查费的这个<a class="ae mc" href="https://www.youtube.com/watch?v=ZDa-Z5JzLYM&amp;list=PL-osiE80TeTsqhIuOqKhwlXsIBIdSeYtc" rel="noopener ugc nofollow" target="_blank">演练</a>。他非常详细地描述了类的工作方式，为什么/如何使用它，什么是属性和方法，以及更高级的主题，如magic/dunder方法和decorators。因为这篇文章将依赖于对Python中的类的一些理解，所以请尝试一下这个演练吧！</p><h2 id="9a50" class="ms kg iq bd kh mt mu dn kl mv mw dp kp lg mx my kr lk mz na kt lo nb nc kv nd bi translated">Python中的包</h2><p id="c750" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">因为我们将使用pandas(它最终是一个包)，所以理解包是如何构造的(特别是常规包)是有帮助的。当谈到与Python中的包相关的概念时，<a class="ae mc" href="https://docs.python.org/3/reference/import.html#importlib" rel="noopener ugc nofollow" target="_blank"> importlib </a>文档和<a class="ae mc" href="https://docs.python.org/3/tutorial/modules.html#packages" rel="noopener ugc nofollow" target="_blank">包</a>文档解释得相当直截了当。</p><h2 id="8bbf" class="ms kg iq bd kh mt mu dn kl mv mw dp kp lg mx my kr lk mz na kt lo nb nc kv nd bi translated">数据帧的定义</h2><p id="5116" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">在我们开始复制任何东西之前，理解数据帧到底是什么是很重要的。来自<a class="ae mc" href="https://pandas.pydata.org/pandas-docs/stable/user_guide/dsintro.html#dataframe" rel="noopener ugc nofollow" target="_blank">熊猫文档</a>:</p><blockquote class="ne nf ng"><p id="5e6c" class="kx ky md kz b la lt jr lc ld lu ju lf nh lv li lj ni lw lm ln nj lx lq lr ls ij bi translated">二维、大小可变、潜在异构的表格数据。</p><p id="026d" class="kx ky md kz b la lt jr lc ld lu ju lf nh lv li lj ni lw lm ln nj lx lq lr ls ij bi translated">数据结构还包含带标签的轴(行和列)。</p></blockquote><p id="9321" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">让我们快速浏览一下上述定义的含义:</p><ul class=""><li id="96c6" class="me mf iq kz b la lt ld lu lg mg lk mh lo mi ls mj mk ml mm bi translated">二维:<em class="md">你可以把它想象成一个excel电子表格。</em></li><li id="61df" class="me mf iq kz b la mn ld mo lg mp lk mq lo mr ls mj mk ml mm bi translated">Size-mutable: <em class="md">您可以增加/减少行数或列数。</em></li><li id="3643" class="me mf iq kz b la mn ld mo lg mp lk mq lo mr ls mj mk ml mm bi translated">潜在的异构表格数据:<em class="md">列可能有不同的类型(int、str等)。</em></li><li id="4406" class="me mf iq kz b la mn ld mo lg mp lk mq lo mr ls mj mk ml mm bi translated">带标签的轴:<em class="md">你可以给你的行加标签，给你的列命名。</em></li></ul><h1 id="eccb" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">设置我们的熊猫复制品工作空间</h1><p id="74d5" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">在做任何事情之前，我给自己设置了一个快速挑战:找到DataFrame模块在<a class="ae mc" href="https://github.com/pandas-dev/pandas/tree/master/pandas" rel="noopener ugc nofollow" target="_blank"> Pandas Github repo </a>上的位置。<em class="md">快速提示—检查__init__文件以找到DataFrame模块的引用。</em></p><p id="9fc1" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">眯着眼看了几分钟后，我终于在<a class="ae mc" href="https://github.com/pandas-dev/pandas/blob/master/pandas/core/frame.py" rel="noopener ugc nofollow" target="_blank">熊猫&gt;内核&gt; frame.py </a>里找到了它。根据我们可以在回购上找到的目录树，我们可以制作一个相当简单的工作区，如下所示:</p><pre class="nk nl nm nn gt no mb np nq aw nr bi"><span id="fe96" class="ms kg iq mb b gy ns nt l nu nv">pandas_replica<br/>|<br/>|- core<br/>|    |-__init__.py<br/>|    |- frame.py<br/>|<br/>|- __init__.py<br/>|- test_notebook.ipynb</span></pre><p id="96de" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">让我们创建这些文件，并让它们暂时为空，我们将在以后填充它们。快速浏览一下我们拥有的文件:</p><ul class=""><li id="4f9e" class="me mf iq kz b la lt ld lu lg mg lk mh lo mi ls mj mk ml mm bi translated">__init__。顾名思义，py初始化“pandas_replica”主包和“core”子包。这也复制了熊猫的<a class="ae mc" href="https://docs.python.org/3/reference/import.html#packages" rel="noopener ugc nofollow" target="_blank">常规包</a>结构。导入pandas_replica.core将隐式执行<code class="fe ly lz ma mb b">pandas_replica/__init__.py</code>和<code class="fe ly lz ma mb b">pandas_replica/core/__init__.py</code>。</li><li id="cd21" class="me mf iq kz b la mn ld mo lg mp lk mq lo mr ls mj mk ml mm bi translated">py本质上是我们的DataFrame模块，类似于我们在pandas repo中看到的。</li><li id="6c54" class="me mf iq kz b la mn ld mo lg mp lk mq lo mr ls mj mk ml mm bi translated">ipynb是一个加载了autoreload扩展的笔记本环境，供我们试验和测试我们的熊猫复制品。</li></ul><h1 id="bfde" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">创建我们的DataFrame对象</h1><p id="ff8e" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">首先，让我们创建并测试我们自己的DataFrame对象。</p><p id="ab1c" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">英寸/core/frame.py:</p><pre class="nk nl nm nn gt no mb np nq aw nr bi"><span id="77ff" class="ms kg iq mb b gy ns nt l nu nv">class DataFrame:<br/>    def __init__(self):<br/>        print('I am a pandas-replica DataFrame!!')</span></pre><p id="b287" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated"><a class="ae mc" href="https://realpython.com/python3-object-oriented-programming/#how-to-define-a-class" rel="noopener ugc nofollow" target="_blank"> <em class="md">有用资源:什么是__init__？什么是“自我”？</em> </a></p><p id="bc3d" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">英寸/__init__。py:</p><pre class="nk nl nm nn gt no mb np nq aw nr bi"><span id="7ca0" class="ms kg iq mb b gy ns nt l nu nv">from pandas_replica.core.frame import DataFrame</span></pre><p id="b8fa" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">打开jupyter笔记本，运行以下程序:</p><pre class="nk nl nm nn gt no mb np nq aw nr bi"><span id="b670" class="ms kg iq mb b gy ns nt l nu nv">import pandas_replica as pdr</span><span id="44bc" class="ms kg iq mb b gy nw nt l nu nv">pdr.DataFrame()</span><span id="cdd0" class="ms kg iq mb b gy nw nt l nu nv"><strong class="mb ir">Expected Output:</strong><br/>I am a pandas-replica dataframe!!<br/>&lt;pandas_replica.core.frame.DataFrame at xxxxxxxxxxx&gt;</span></pre><p id="96ee" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">太好了！如果您获得了预期的输出，那么恭喜您，我们已经创建了自己的数据框架(虽然在功能性方面有所欠缺，但我们会实现的)。<code class="fe ly lz ma mb b">I am a pandas-replica dataframe!!</code>成功打印的事实表明我们的类正在以正确的方式初始化，现在我们准备用更多的属性和方法来充实它。</p><h1 id="c9ce" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">将数据读入我们的数据框架</h1><p id="f232" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">数据帧的主要思想是存储数据。直观地说，这意味着当我们初始化数据帧时，我们应该将传递给它的数据赋值为属性。为了更进一步，还应该有适当的检查来确保我们传递到我们的数据框架中的数据类型满足特定的标准。</p><h2 id="b403" class="ms kg iq bd kh mt mu dn kl mv mw dp kp lg mx my kr lk mz na kt lo nb nc kv nd bi translated">从字典中读取数据</h2><p id="694b" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">熊猫文档中列出的构建数据帧的方法之一是通过<a class="ae mc" href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.html" rel="noopener ugc nofollow" target="_blank">字典</a>。为了简单起见，我们将使用字典的方式，注意将这篇文章中的思想外推至其他输入类型(pd。Series，np.array)是非常可行的。</p><h2 id="78c1" class="ms kg iq bd kh mt mu dn kl mv mw dp kp lg mx my kr lk mz na kt lo nb nc kv nd bi translated">对输入类型建立检查</h2><p id="8ae8" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">当我们在pandas的数据框架上修改输入类型时，会出现两个明显的错误。</p><p id="7b97" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">错误1: <code class="fe ly lz ma mb b">ValueError: DataFrame constructor not properly called!</code></p><p id="d4ee" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">尝试运行下面的代码，您将得到错误1，因为输入类型是int而不是dict(或者是pandas支持的类型)。</p><pre class="nk nl nm nn gt no mb np nq aw nr bi"><span id="bb7e" class="ms kg iq mb b gy ns nt l nu nv">import pandas as pd </span><span id="a449" class="ms kg iq mb b gy nw nt l nu nv">pd.DataFrame(100000)</span></pre><p id="e934" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">错误2: <code class="fe ly lz ma mb b">ValueError: arrays must all be same length</code></p><p id="4f64" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">在下面的代码中，col1和col2的长度不同，因此抛出了上面的错误。<em class="md">注意:我们应该把数组改成pd吗？不会引发错误，但这只是不同输入类型的单独情况。</em></p><pre class="nk nl nm nn gt no mb np nq aw nr bi"><span id="9b86" class="ms kg iq mb b gy ns nt l nu nv">import pandas as pd</span><span id="47f1" class="ms kg iq mb b gy nw nt l nu nv">col1 = [3.6, 3.5, 5.2, 6.1] # len = 4<br/>col2 = [45, 40, 30] # len = 3<br/>data = {'col1': col1, 'col2': col2}<br/>pd.DataFrame(data)</span></pre><p id="88bf" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">复制错误1相当简单。pandas的源代码中穿插了内置的<code class="fe ly lz ma mb b">isinstance</code>,如果输入符合它的众多标准，它就像一百万个不同的检查。我们可以利用这一点来检查输入类型是否是dict类型。类似地，对于错误2，我们只需要检查字典中的每个键，它的值的长度与其他键的值的长度相同(本质上是<code class="fe ly lz ma mb b">len(col1) == len(col2)</code>)。</p><p id="afed" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">让我们删除我们在初始DataFrame类中编写的所有代码，并添加以下代码。</p><p id="1092" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">英寸/core/frame.py:</p><pre class="nk nl nm nn gt no mb np nq aw nr bi"><span id="4083" class="ms kg iq mb b gy ns nt l nu nv">class DataFrame:</span><span id="b919" class="ms kg iq mb b gy nw nt l nu nv"><strong class="mb ir">    def __init__(self, data):<br/>        self._check_dict(data)<br/>        self._check_array_length(data)</strong></span><span id="87ef" class="ms kg iq mb b gy nw nt l nu nv"><strong class="mb ir">    def _check_dict(self, data):<br/>        if not isinstance(data, dict):<br/>            raise ValueError('DataFrame constructor not properly called!')</strong></span><span id="ad36" class="ms kg iq mb b gy nw nt l nu nv"><strong class="mb ir">    def _check_array_length(self, data):<br/>        raw_lengths = [len(x) for x in data.values()]<br/>        lengths = list(set(raw_lengths))<br/>        if len(lengths) &gt; 1:<br/>            raise ValueError('arrays must all be same length')</strong></span></pre><p id="bfee" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">好东西！让我们回到jupyter笔记本，运行下面的代码来测试我们新制作的数据帧。</p><pre class="nk nl nm nn gt no mb np nq aw nr bi"><span id="bb10" class="ms kg iq mb b gy ns nt l nu nv"><strong class="mb ir">Recreate Error 1:</strong><br/>import pandas_replica as pdr</span><span id="f3d9" class="ms kg iq mb b gy nw nt l nu nv">pdr.DataFrame(100000)</span><span id="062e" class="ms kg iq mb b gy nw nt l nu nv"><strong class="mb ir">Recreate Error 2:</strong><br/>import pandas_replica as pdr</span><span id="b92c" class="ms kg iq mb b gy nw nt l nu nv">col1 = [3.6, 3.5, 5.2, 6.1] # len = 4<br/>col2 = [45, 40, 30] # len = 3<br/>data = {'col1': col1, 'col2': col2}<br/>pdr.DataFrame(data)</span><span id="72ce" class="ms kg iq mb b gy nw nt l nu nv"><strong class="mb ir">Run with no Error:</strong><br/>import pandas_replica as pdr</span><span id="077d" class="ms kg iq mb b gy nw nt l nu nv">col1 = [3.6, 3.5, 5.2, 6.1] # len = 4<br/>col2 = [45, 40, 30, 50] # len = 4<br/>data = {'col1': col1, 'col2': col2}<br/>pdr.DataFrame(data)</span></pre><h2 id="68e3" class="ms kg iq bd kh mt mu dn kl mv mw dp kp lg mx my kr lk mz na kt lo nb nc kv nd bi translated">设置数据属性</h2><p id="7afe" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">现在上面的问题已经解决了，剩下的就是将输入“附加”到我们的数据帧上。它就像在我们的__init__方法中添加下面一行一样简单。</p><pre class="nk nl nm nn gt no mb np nq aw nr bi"><span id="c3f4" class="ms kg iq mb b gy ns nt l nu nv">self.data = data</span></pre><h1 id="dc10" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">实现一些数据框架方法</h1><h2 id="3a77" class="ms kg iq bd kh mt mu dn kl mv mw dp kp lg mx my kr lk mz na kt lo nb nc kv nd bi translated">列方法</h2><p id="ccbe" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">在pandas中，columns方法返回一个包含数据帧的列标签(或者只是列标题)的列表。</p><p id="4924" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">在熊猫身上:</p><pre class="nk nl nm nn gt no mb np nq aw nr bi"><span id="85b2" class="ms kg iq mb b gy ns nt l nu nv">import pandas as pd</span><span id="ed87" class="ms kg iq mb b gy nw nt l nu nv">col1 = [3.6, 3.5, 5.2, 6.1] # len = 4<br/>col2 = [45, 40, 30, 50] # len = 4<br/>data = {'col1': col1, 'col2': col2}<br/>pd.DataFrame(data).columns</span><span id="b295" class="ms kg iq mb b gy nw nt l nu nv"><strong class="mb ir">Expected Output:</strong><br/>Index(['col1', 'col2'], dtype='object')</span></pre><p id="3dd1" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">注意，这实际上是输入字典的键，因此要在我们的熊猫崇拜者身上复制它，我们需要一个函数来返回输入字典的键。幸运的是，在dict上调用<code class="fe ly lz ma mb b">list</code>函数实际上会返回dict的键列表。让我们在DataFrame类中添加一个名为<code class="fe ly lz ma mb b">columns</code>的方法。<a class="ae mc" href="https://www.youtube.com/watch?v=ZDa-Z5JzLYM&amp;list=PL-osiE80TeTsqhIuOqKhwlXsIBIdSeYtc" rel="noopener ugc nofollow" target="_blank">我们包含了</a> <code class="fe ly lz ma mb b"><a class="ae mc" href="https://www.youtube.com/watch?v=ZDa-Z5JzLYM&amp;list=PL-osiE80TeTsqhIuOqKhwlXsIBIdSeYtc" rel="noopener ugc nofollow" target="_blank">property</a></code> <a class="ae mc" href="https://www.youtube.com/watch?v=ZDa-Z5JzLYM&amp;list=PL-osiE80TeTsqhIuOqKhwlXsIBIdSeYtc" rel="noopener ugc nofollow" target="_blank">装饰器，这样我们可以像调用属性一样调用它，而不是方法</a>(本质上是使用<code class="fe ly lz ma mb b">df.columns</code>而不是<code class="fe ly lz ma mb b">df.columns()</code>来调用它)。</p><pre class="nk nl nm nn gt no mb np nq aw nr bi"><span id="557a" class="ms kg iq mb b gy ns nt l nu nv">class DataFrame:</span><span id="d2f6" class="ms kg iq mb b gy nw nt l nu nv">    def __init__(self, data):<br/>        self._check_dict(data)<br/>        self._check_array_length(data)</span><span id="bc8f" class="ms kg iq mb b gy nw nt l nu nv">    def _check_dict(self, data):<br/>        if not isinstance(data, dict):<br/>            raise ValueError('DataFrame constructor not properly called!')</span><span id="95ec" class="ms kg iq mb b gy nw nt l nu nv">    def _check_array_length(self, data):<br/>        raw_lengths = [len(x) for x in data.values()]<br/>        lengths = list(set(raw_lengths))<br/>        if len(lengths) &gt; 1:<br/>            raise ValueError('arrays must all be same length')</span><span id="2bb0" class="ms kg iq mb b gy nw nt l nu nv">    <strong class="mb ir">@property<br/>    def columns(self):<br/>        return list(self.data.keys())</strong></span></pre><p id="fee6" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">现在让我们回到笔记本上来测试一下:</p><pre class="nk nl nm nn gt no mb np nq aw nr bi"><span id="a7d6" class="ms kg iq mb b gy ns nt l nu nv">import pandas_replica as pdr</span><span id="cbea" class="ms kg iq mb b gy nw nt l nu nv">col1 = [3.6, 3.5, 5.2, 6.1] # len = 4<br/>col2 = [45, 40, 30, 50] # len = 4<br/>data = {'col1': col1, 'col2': col2}<br/>pdr.DataFrame(data).columns</span><span id="5369" class="ms kg iq mb b gy nw nt l nu nv"><strong class="mb ir">Expected Output:</strong><br/>['col1', 'col2']</span></pre><p id="7699" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">瞧啊。非常管用！</p><h2 id="fd13" class="ms kg iq bd kh mt mu dn kl mv mw dp kp lg mx my kr lk mz na kt lo nb nc kv nd bi translated">形状方法</h2><p id="f5e5" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">在pandas中，shape方法返回一个表示数据帧的行数和列数的元组。</p><p id="fc94" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">在熊猫身上:</p><pre class="nk nl nm nn gt no mb np nq aw nr bi"><span id="02d7" class="ms kg iq mb b gy ns nt l nu nv">import pandas as pd</span><span id="27e1" class="ms kg iq mb b gy nw nt l nu nv">col1 = [3.6, 3.5, 5.2, 6.1] # len = 4<br/>col2 = [45, 40, 30, 50] # len = 4<br/>data = {'col1': col1, 'col2': col2}<br/>pd.DataFrame(data).shape</span><span id="defc" class="ms kg iq mb b gy nw nt l nu nv"><strong class="mb ir">Expected Output:</strong><br/>(4, 2)</span></pre><p id="e180" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">注意，这实际上是我们计算(1)字典中数组的长度和(2)字典中键的数量。假设我们已经通过了<code class="fe ly lz ma mb b">_check_array_length</code>方法，我们应该能够相当容易地检索(1 ),我们将把它作为我们可以在字典中找到的第一个数组的长度。类似地，对于(2)，使用<code class="fe ly lz ma mb b">len()</code>功能可以很容易地计算键的数量。</p><pre class="nk nl nm nn gt no mb np nq aw nr bi"><span id="66ef" class="ms kg iq mb b gy ns nt l nu nv">class DataFrame:</span><span id="1793" class="ms kg iq mb b gy nw nt l nu nv">    def __init__(self, data):<br/>        self._check_dict(data)<br/>        self._check_array_length(data)</span><span id="5312" class="ms kg iq mb b gy nw nt l nu nv">    def _check_dict(self, data):<br/>        if not isinstance(data, dict):<br/>            raise ValueError('DataFrame constructor not properly called!')</span><span id="9f14" class="ms kg iq mb b gy nw nt l nu nv">    def _check_array_length(self, data):<br/>        raw_lengths = [len(x) for x in data.values()]<br/>        lengths = list(set(raw_lengths))<br/>        if len(lengths) &gt; 1:<br/>            raise ValueError('arrays must all be same length')</span><span id="32e0" class="ms kg iq mb b gy nw nt l nu nv">    @property<br/>    def columns(self):<br/>        return list(self.data.keys())</span><span id="369d" class="ms kg iq mb b gy nw nt l nu nv"><strong class="mb ir">    @property<br/>    def shape(self):<br/>        return (len(list(self.data.values())[0]), len(self.data))</strong></span></pre><p id="228c" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">回到我们值得信赖的笔记本:</p><pre class="nk nl nm nn gt no mb np nq aw nr bi"><span id="aceb" class="ms kg iq mb b gy ns nt l nu nv">import pandas_replica as pdr</span><span id="de01" class="ms kg iq mb b gy nw nt l nu nv">col1 = [3.6, 3.5, 5.2, 6.1] # len = 4<br/>col2 = [45, 40, 30, 50] # len = 4<br/>data = {'col1': col1, 'col2': col2}<br/>pdr.DataFrame(data).shape</span><span id="eb08" class="ms kg iq mb b gy nw nt l nu nv"><strong class="mb ir">Expected Output:</strong><br/>(4, 2)</span></pre><h1 id="b993" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">在笔记本电脑环境中使用我们的数据框架</h1><p id="00c8" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我们上面所做的一切都很酷，但是如果我想将我的数据快照打印到笔记本上呢？</p><figure class="nk nl nm nn gt ny gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/737e12924870cca13e4f2904fb8a006a.png" data-original-src="https://miro.medium.com/v2/resize:fit:682/format:webp/1*kSajij23eeuT7V8VY1RxuA.png"/></div><p class="ob oc gj gh gi od oe bd b be z dk translated">熊猫数据框笔记本输出</p></figure><p id="4de2" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">关于jupyter notebook如何显示这些项目的快速背景:因为jupyter notebook在浏览器上运行，输出的格式必须是一个<a class="ae mc" href="https://www.w3schools.com/html/html_tables.asp" rel="noopener ugc nofollow" target="_blank"> html表格格式</a>。在<a class="ae mc" href="https://github.com/pandas-dev/pandas/blob/master/pandas/core/frame.py#L996" rel="noopener ugc nofollow" target="_blank"> pandas源代码</a>中，他们有一个叫做<code class="fe ly lz ma mb b">_repr_html_</code>的方法，将输入数据格式化成一个时髦的html表格，适合浏览器。我们重建这个的想法是这样的:</p><ul class=""><li id="9f86" class="me mf iq kz b la lt ld lu lg mg lk mh lo mi ls mj mk ml mm bi translated">创建包含列标题的第一行。</li><li id="675a" class="me mf iq kz b la mn ld mo lg mp lk mq lo mr ls mj mk ml mm bi translated">然后，我们将使用索引以及array[index]的相应值来填充这些行。</li></ul><p id="e6fd" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">让我们试一试。在DataFrame类的底部，我们添加以下代码:</p><pre class="nk nl nm nn gt no mb np nq aw nr bi"><span id="5e55" class="ms kg iq mb b gy ns nt l nu nv">class DataFrame:</span><span id="4e91" class="ms kg iq mb b gy nw nt l nu nv">...</span><span id="630c" class="ms kg iq mb b gy nw nt l nu nv">    def _repr_html_(self):</span><span id="ef0d" class="ms kg iq mb b gy nw nt l nu nv">        <strong class="mb ir"># Part 1</strong><br/>        html = '&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;&lt;/th&gt;' <br/>        for col in self.columns:<br/>            html += f'&lt;th&gt;{col}&lt;/th&gt;' </span><span id="b790" class="ms kg iq mb b gy nw nt l nu nv">        html += '&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;'</span><span id="d82a" class="ms kg iq mb b gy nw nt l nu nv">        <strong class="mb ir"># Part 2</strong><br/>        for i in range(len(list(self.data.values())[0])):<br/>            html += f'&lt;tr&gt;&lt;td&gt;&lt;strong&gt;{i}&lt;/strong&gt;&lt;/td&gt;'<br/>            for _, values in self.data.items():<br/>                html += f'&lt;td&gt;{values[i]}&lt;/td&gt;'<br/>            html += '&lt;/tr&gt;'</span><span id="03bb" class="ms kg iq mb b gy nw nt l nu nv">        html += '&lt;/tbody&gt;&lt;/table&gt;'</span><span id="9b0b" class="ms kg iq mb b gy nw nt l nu nv">        return html</span></pre><p id="9580" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">第1部分:我们在这里做的是准备好表格元素来存储数据。然后我们将继续用列标题填充我们的<thead>。注意，第一个列标题<th>是空的，因为我们需要它作为索引列。一旦我们完成了这些，我们就关闭<thead>并准备向我们的表体添加数据。</thead></th></thead></p><p id="2b36" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">第2部分:然后我们继续遍历dict中的数组长度，添加索引<em class="md"> i </em>，并将该特定索引处的值添加到一行中。一旦我们填充了整行，然后我们继续下一行。完成后，我们关闭表格并返回刚刚创建的html。</p><p id="8744" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">回到美好的老沙盒:</p><pre class="nk nl nm nn gt no mb np nq aw nr bi"><span id="c8fc" class="ms kg iq mb b gy ns nt l nu nv">import pandas_replica as pdr</span><span id="87b8" class="ms kg iq mb b gy nw nt l nu nv">col1 = [3.6, 3.5, 5.2, 6.1] # len = 4<br/>col2 = [45, 40, 30, 50] # len = 4<br/>data = {'col1': col1, 'col2': col2}<br/>pdr.DataFrame(data)</span></pre><figure class="nk nl nm nn gt ny gh gi paragraph-image"><div class="gh gi of"><img src="../Images/2382d6b44afd0bf04a2560c0a13965f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:630/format:webp/1*k3W5xPBKmZtj1GswuBtSSg.png"/></div><p class="ob oc gj gh gi od oe bd b be z dk translated">熊猫_副本数据框笔记本输出</p></figure><p id="915f" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">我看不错！</p><h1 id="2be2" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">结论</h1><p id="2b7b" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">所以我知道这篇文章有点长，是时候停下来了。让我们回顾一下上面的三个目标，看看我们是否已经成功检查了我们要达到的所有学习点:</p><ol class=""><li id="ba5b" class="me mf iq kz b la lt ld lu lg mg lk mh lo mi ls og mk ml mm bi translated">对Python中的OOP有一些实践经验——我们能够创建、实例化和添加方法/属性到我们的DataFrame类中。除此之外，我们还接触了一点property decorator(这非常酷)。</li><li id="186b" class="me mf iq kz b la mn ld mo lg mp lk mq lo mr ls og mk ml mm bi translated">了解Python中的包是如何工作的——我们成功复制了pandas的包结构，并将其导入到我们的笔记本环境中。</li><li id="13ad" class="me mf iq kz b la mn ld mo lg mp lk mq lo mr ls og mk ml mm bi translated">理解Pandas如何使用其时髦的函数——我们能够进行一些初始输入类型检查，运行<code class="fe ly lz ma mb b">df.columns</code>和<code class="fe ly lz ma mb b">df.shape</code>方法，并将表格输出打印到我们的笔记本环境中。</li></ol><p id="1fac" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">这绝不是pandas包的复杂性和全面性，但有了这种理解，它减少了理解pandas源代码中所发生的一切的障碍，并让像我这样的普通人深入了解那些如此融入我们日常生活的包是如何工作的。这是一个非常有趣的练习，我期待着将来能有更多的练习！</p></div></div>    
</body>
</html>