<html>
<head>
<title>Forecasts in Snowflake: Facebook Prophet on Cloud Run with SQL</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">雪花中的预测:用SQL运行云上的脸书预言家</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/forecasts-in-snowflake-facebook-prophet-on-cloud-run-with-sql-71c6f7fdc4e3?source=collection_archive---------15-----------------------#2021-05-14">https://towardsdatascience.com/forecasts-in-snowflake-facebook-prophet-on-cloud-run-with-sql-71c6f7fdc4e3?source=collection_archive---------15-----------------------#2021-05-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="91ff" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">通过创建一个雪花外部函数，我们可以得到脸书预言家对任何时间序列的预测。了解如何轻松地将这些预测集成到您的SQL管道中Snowflake连接到在Google Cloud Run内的Docker容器上运行的Prophet。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/c71d6061916d26c66fc914d0daee36b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yG1KfBEQLjHTuvCQb_U9hg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片:<a class="ae kv" href="https://pixabay.com/photos/woman-spirit-ball-5439365/" rel="noopener ugc nofollow" target="_blank"> Pixabay </a></p></figure><h1 id="0ca7" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">2022–09更新</h1><blockquote class="lo"><p id="90cc" class="lp lq iq bd lr ls lt lu lv lw lx ly dk translated"><a class="ae kv" href="https://hoffa.medium.com/facebook-prophet-forecasts-running-in-snowflake-with-snowpark-14fc870b56ae" rel="noopener">脸书先知现在运行在雪花</a>内部，不需要外部函数。</p></blockquote><div class="lz ma mb mc md me"><a href="https://hoffa.medium.com/facebook-prophet-forecasts-running-in-snowflake-with-snowpark-14fc870b56ae" rel="noopener follow" target="_blank"><div class="mf ab fo"><div class="mg ab mh cl cj mi"><h2 class="bd ir gy z fp mj fr fs mk fu fw ip bi translated">脸书先知预测运行在雪花与雪地公园</h2><div class="ml l"><h3 class="bd b gy z fp mj fr fs mk fu fw dk translated">现在脸书预言家在雪花内部运行——不需要外部函数。让我们看看怎么做。</h3></div><div class="mm l"><p class="bd b dl z fp mj fr fs mk fu fw dk translated">hoffa.medium.com</p></div></div><div class="mn l"><div class="mo l mp mq mr mn ms kp me"/></div></div></a></div><h1 id="1efd" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">目标</h1><p id="dbe0" class="pw-post-body-paragraph mt mu iq mv b mw mx jr my mz na ju nb nc nd ne nf ng nh ni nj nk nl nm nn ly ij bi translated">这篇文章的目标是构建一个可以在Snowflake中用来预测时间序列的函数。一个很棒的开源工具是<a class="ae kv" href="https://facebook.github.io/prophet/" rel="noopener ugc nofollow" target="_blank">脸书先知</a>，我们只需要一种在我们的雪花环境中使用它的方法。这很容易，因为雪花能够运行<a class="ae kv" href="https://docs.snowflake.com/en/sql-reference/external-functions-introduction.html" rel="noopener ugc nofollow" target="_blank">外部函数</a>——因此我们只需要托管Prophet的一个实例，并添加必要的管道，以在雪花中完成<code class="fe no np nq nr b">prophetize(timeseries)</code>函数。</p><p id="78a4" class="pw-post-body-paragraph mt mu iq mv b mw ns jr my mz nt ju nb nc nu ne nf ng nv ni nj nk nw nm nn ly ij bi translated">先来个演示，雪花里任何时间序列都行:比如纽瓦克机场2018年以来纽约市周边的气温:</p><pre class="kg kh ki kj gt nx nr ny nz aw oa bi"><span id="bf3e" class="ob kx iq nr b gy oc od l oe of">select date, temp<br/>from noaa_gsod<br/>where country_fips='US'<br/>and station = 'NEWARK LIBERTY INTERNATIONAL AP';</span><span id="14be" class="ob kx iq nr b gy og od l oe of">-- TODO: Show how to get NOAA GSOD from Knoema in a future post.</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oh"><img src="../Images/9f70dd3bcd27c4e4b922a6ad56fe1296.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kifPyhE9OloDlmBmS3psyg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">纽瓦克机场的每日温度</p></figure><p id="aae6" class="pw-post-body-paragraph mt mu iq mv b mw ns jr my mz nt ju nb nc nu ne nf ng nv ni nj nk nw nm nn ly ij bi translated">然后我们可以调用我们的函数<code class="fe no np nq nr b">prophetize()</code>(见下面如何创建它),将之前的时间序列聚合到一个包含日期和值的数组中:</p><pre class="kg kh ki kj gt nx nr ny nz aw oa bi"><span id="d7df" class="ob kx iq nr b gy oc od l oe of">select prophetize(array_construct(<br/>        array_agg(temp::float) <br/>          within group(order by date)<br/>        , array_agg(date::date) <br/>          within group(order by date))::string) str<br/>from table(result_scan(last_query_id(-1)));</span></pre><p id="5ae2" class="pw-post-body-paragraph mt mu iq mv b mw ns jr my mz nt ju nb nc nu ne nf ng nv ni nj nk nw nm nn ly ij bi translated">仅此而已。我们得到的是一个带有预测的数组。可视化这些结果的一个简单方法是将前面两个查询的值结合起来:</p><pre class="kg kh ki kj gt nx nr ny nz aw oa bi"><span id="a07d" class="ob kx iq nr b gy oc od l oe of">select date, temp::float avg_temp<br/>    , 0 forecast, 0 fore_min, 0 fore_max<br/>from table(result_scan(last_query_id(-2)))<br/>union all<br/>select x.value[0]::date, 0, x.value[1]::int forecast, x.value[2]::int fore_min, x.value[3]::int fore_max<br/>from table(result_scan(last_query_id(-1))) a, table(flatten(a.$1)) x;</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oi"><img src="../Images/12e36dc604061f238a75b10f942c3124.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6fS-3Tvz-cz_fxBKgdpKcg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">纽瓦克机场的每日温度，加上未来365天的预报波段。</p></figure><p id="b8b7" class="pw-post-body-paragraph mt mu iq mv b mw ns jr my mz nt ju nb nc nu ne nf ng nv ni nj nk nw nm nn ly ij bi translated">上面有趣的笔记:</p><ul class=""><li id="a018" class="oj ok iq mv b mw ns mz nt nc ol ng om nk on ly oo op oq or bi translated">Prophet能够轻松检测季节模式并预测未来值。</li><li id="1715" class="oj ok iq mv b mw os mz ot nc ou ng ov nk ow ly oo op oq or bi translated">Prophet的许多工作方式都是可调的，但是开箱即用也是可行的。</li><li id="ba75" class="oj ok iq mv b mw os mz ot nc ou ng ov nk ow ly oo op oq or bi translated">在雪花上，我使用了<code class="fe no np nq nr b">last_query_id(-1)</code>和<code class="fe no np nq nr b">last_query_id(-2)</code>来组合前面两个查询的结果。这是一个很棒的功能。</li></ul><p id="8da8" class="pw-post-body-paragraph mt mu iq mv b mw ns jr my mz nt ju nb nc nu ne nf ng nv ni nj nk nw nm nn ly ij bi translated">现在让我们检查一下如何将雪花SQL世界<code class="fe no np nq nr b">prophetize()</code>中的一个函数连接到运行在Cloud Run上的脸书先知的细节。</p><h1 id="fc70" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">如何</h1><h2 id="f749" class="ob kx iq bd ky ox oy dn lc oz pa dp lg nc pb pc li ng pd pe lk nk pf pg lm ph bi translated">将Prophet部署到云运行的容器上</h2><p id="c1e3" class="pw-post-body-paragraph mt mu iq mv b mw mx jr my mz na ju nb nc nd ne nf ng nh ni nj nk nl nm nn ly ij bi translated">构建这个容器的<code class="fe no np nq nr b">requirements.txt</code>非常简单:</p><pre class="kg kh ki kj gt nx nr ny nz aw oa bi"><span id="4122" class="ob kx iq nr b gy oc od l oe of">flask==1.1.4<br/>requests==2.25.1<br/>gunicorn==20.1.0<br/>pandas==1.2.4<br/>pystan==2.19.1.1  # &lt;3.0<br/>fbprophet==0.7.1</span></pre><p id="1673" class="pw-post-body-paragraph mt mu iq mv b mw ns jr my mz nt ju nb nc nu ne nf ng nv ni nj nk nw nm nn ly ij bi translated">正如<code class="fe no np nq nr b">Dockerfile</code>:</p><pre class="kg kh ki kj gt nx nr ny nz aw oa bi"><span id="5f80" class="ob kx iq nr b gy oc od l oe of">FROM python:3.8</span><span id="6080" class="ob kx iq nr b gy og od l oe of"># Allow statements and log messages to immediately appear in the Cloud Run logs<br/>ENV PYTHONUNBUFFERED True</span><span id="4501" class="ob kx iq nr b gy og od l oe of">COPY requirements.txt .<br/>RUN pip install -r requirements.txt</span><span id="908c" class="ob kx iq nr b gy og od l oe of">ENV APP_HOME /app<br/>WORKDIR $APP_HOME<br/>COPY main.py ./</span><span id="6373" class="ob kx iq nr b gy og od l oe of">CMD exec gunicorn --bind :$PORT --workers 1 --threads 1 --timeout 0 main:app</span></pre><p id="f959" class="pw-post-body-paragraph mt mu iq mv b mw ns jr my mz nt ju nb nc nu ne nf ng nv ni nj nk nw nm nn ly ij bi translated">这是<code class="fe no np nq nr b">main.py</code>，一个基本的web服务器，它将传入的数组解析成一个数据帧，Prophet用它来预测任意数量的周期。然后，它返回一个序列化数组，其中包含雪花将收到的预测和不确定性间隔:</p><pre class="kg kh ki kj gt nx nr ny nz aw oa bi"><span id="cc5c" class="ob kx iq nr b gy oc od l oe of">import json<br/>import logging<br/>import os</span><span id="7382" class="ob kx iq nr b gy og od l oe of">from fbprophet import Prophet<br/>from flask import Flask, request<br/>import pandas as pd</span><span id="7f4b" class="ob kx iq nr b gy og od l oe of">log = logging.getLogger()<br/>app = Flask(__name__)</span><span id="f5ce" class="ob kx iq nr b gy og od l oe of">def forecast(df: pd.DataFrame, periods=365) -&gt; pd.DataFrame:<br/>    df["ds"] = pd.to_datetime(df["ds"])</span><span id="ec39" class="ob kx iq nr b gy og od l oe of">    model = Prophet()<br/>    model.fit(df)</span><span id="7033" class="ob kx iq nr b gy og od l oe of">    future_df = model.make_future_dataframe(<br/>      periods=periods, include_history=False)</span><span id="36e3" class="ob kx iq nr b gy og od l oe of">    return model.predict(future_df)[["ds", "yhat", "yhat_lower", "yhat_upper"]]</span><span id="400f" class="ob kx iq nr b gy og od l oe of"><a class="ae kv" href="http://twitter.com/app" rel="noopener ugc nofollow" target="_blank">@app</a>.route("/", methods=["POST"])<br/>def index():<br/>    payload = request.get_json()<br/>    logging.info(payload)<br/>    # <a class="ae kv" href="https://docs.snowflake.com/en/sql-reference/external-functions-data-format.html" rel="noopener ugc nofollow" target="_blank">https://docs.snowflake.com/en/sql-reference/external-functions-data-format.html</a></span><span id="7f4c" class="ob kx iq nr b gy og od l oe of">    rows = payload["data"]<br/>    return_value = []<br/>    for row in rows:<br/>        row_number = row[0]<br/>        function_input = json.loads(row[1])<br/>        df = pd.DataFrame({'ds': function_input[1], 'y': function_input[0]})<br/>        fc = forecast(df)<br/>        fc['ds'] = fc['ds'].dt.strftime('%Y-%m-%d')<br/>        row_to_return = [row_number, fc.to_numpy().tolist()]<br/>        return_value.append(row_to_return)</span><span id="bfe7" class="ob kx iq nr b gy og od l oe of">    json_compatible_string_to_return = json.dumps({"data": return_value})<br/>    return (json_compatible_string_to_return)</span><span id="22f3" class="ob kx iq nr b gy og od l oe of">if __name__ == "__main__":<br/>    app.run(debug=True, host="0.0.0.0", port=int(os.environ.get("PORT", 8080)))</span></pre><p id="d686" class="pw-post-body-paragraph mt mu iq mv b mw ns jr my mz nt ju nb nc nu ne nf ng nv ni nj nk nw nm nn ly ij bi translated">如果我们想在Google Cloud run上构建和运行这个容器，我们需要运行:</p><pre class="kg kh ki kj gt nx nr ny nz aw oa bi"><span id="595f" class="ob kx iq nr b gy oc od l oe of">gcloud builds submit --config cloudbuild.yaml;<br/>gcloud run deploy --image gcr.io/fhoffa/prophetize --platform managed</span></pre><p id="baa5" class="pw-post-body-paragraph mt mu iq mv b mw ns jr my mz nt ju nb nc nu ne nf ng nv ni nj nk nw nm nn ly ij bi translated">第一次在云构建上构建映像很慢，因为编译Prophet需要时间——但这个<code class="fe no np nq nr b">cloudbuild.yaml</code>在以后的构建中使用映像缓存使它变得很快:</p><pre class="kg kh ki kj gt nx nr ny nz aw oa bi"><span id="b140" class="ob kx iq nr b gy oc od l oe of">steps:<br/>- name: 'gcr.io/cloud-builders/docker'<br/>  entrypoint: 'bash'<br/>  args:<br/>  - '-c'<br/>  - |<br/>    docker pull gcr.io/fhoffa/prophetize:latest || exit 0</span><span id="f4d1" class="ob kx iq nr b gy og od l oe of">- name: 'gcr.io/cloud-builders/docker'<br/>  args: [<br/>          'build',<br/>          '--cache-from', 'gcr.io/fhoffa/prophetize:latest',<br/>          '-t', 'gcr.io/fhoffa/prophetize:latest',<br/>          '.'<br/>        ]</span><span id="5cf6" class="ob kx iq nr b gy og od l oe of">images: ['gcr.io/fhoffa/prophetize:latest']</span></pre><h2 id="bb09" class="ob kx iq bd ky ox oy dn lc oz pa dp lg nc pb pc li ng pd pe lk nk pf pg lm ph bi translated">云运行在Google API网关之后</h2><p id="2ac6" class="pw-post-body-paragraph mt mu iq mv b mw mx jr my mz na ju nb nc nd ne nf ng nh ni nj nk nl nm nn ly ij bi translated">我在这个项目背后的主要目标之一是庆祝<a class="ae kv" href="https://docs.snowflake.com/en/sql-reference/external-functions-creating-gcp.html" rel="noopener ugc nofollow" target="_blank"> Snowflake现在支持GCP </a>的外部功能。因此我选择部署在云上运行。</p><p id="0ec5" class="pw-post-body-paragraph mt mu iq mv b mw ns jr my mz nt ju nb nc nu ne nf ng nv ni nj nk nw nm nn ly ij bi translated">现在，要通过GCP运行外部函数，我们需要建立一个从Snowflake到Google API Gateway，以及从API Gateway到Cloud Run的连接。</p><p id="b3bc" class="pw-post-body-paragraph mt mu iq mv b mw ns jr my mz nt ju nb nc nu ne nf ng nv ni nj nk nw nm nn ly ij bi translated">首先，我们需要一个用于API Gateway的<code class="fe no np nq nr b">gateway.yaml</code>,让它知道它将充当我们在Cloud Run上部署的服务的代理:</p><pre class="kg kh ki kj gt nx nr ny nz aw oa bi"><span id="6915" class="ob kx iq nr b gy oc od l oe of">swagger: '2.0'<br/>info:<br/>  title: API Gateway config for Snowflake external function.<br/>  description: This configuration file connects the API Gateway resource to the remote service (Cloud Run).<br/>  version: 1.0.0<br/>schemes:<br/>  - https<br/>produces:<br/>  - application/json<br/>paths:<br/>  /test:<br/>    post:<br/>      summary: Prophetize<br/>      operationId: prophetize<br/>      x-google-backend:<br/>        address: <a class="ae kv" href="https://prophetize-zqnzinxyeq-wl.a.run.app/" rel="noopener ugc nofollow" target="_blank">https://prophetize-zqnzinxyeq-wl.a.run.app/</a> <br/>        protocol: h2<br/>      responses:<br/>        '200':<br/>          description: &lt;DESCRIPTION&gt;<br/>          schema:<br/>            type: string</span></pre><p id="54ad" class="pw-post-body-paragraph mt mu iq mv b mw ns jr my mz nt ju nb nc nu ne nf ng nv ni nj nk nw nm nn ly ij bi translated">然后你可以按照GCP的文档<a class="ae kv" href="https://console.cloud.google.com/api-gateway/gateway/create" rel="noopener ugc nofollow" target="_blank">用这个配置创建一个API网关</a>。哦，请确保用您自己的服务URL替换上面的值。</p><h2 id="fc69" class="ob kx iq bd ky ox oy dn lc oz pa dp lg nc pb pc li ng pd pe lk nk pf pg lm ph bi translated">雪花到谷歌API网关</h2><p id="7374" class="pw-post-body-paragraph mt mu iq mv b mw mx jr my mz na ju nb nc nd ne nf ng nh ni nj nk nl nm nn ly ij bi translated">这是我如何连接雪花上的点，以创建与API Gateway的集成:</p><pre class="kg kh ki kj gt nx nr ny nz aw oa bi"><span id="2782" class="ob kx iq nr b gy oc od l oe of">use role accountadmin;<br/>use schema temp.public;</span><span id="f411" class="ob kx iq nr b gy og od l oe of">create or replace api integration prophet_test<br/>    api_provider = google_api_gateway<br/>    google_audience = 'test1-3s4aecfho43ih.apigateway.fhoffa.cloud.goog'<br/>    api_allowed_prefixes = ('<a class="ae kv" href="https://prophetize-4r3ddv95.wl.gateway.dev'" rel="noopener ugc nofollow" target="_blank">https://prophetize-4r3ddv95.wl.gateway.dev'</a>)<br/>    enabled = true;<br/>    <br/>describe integration prophet_test;<br/>create or replace external function prophetize(x string)<br/>    returns variant<br/>-- IMMUTABLE<br/>    api_integration = prophet_test<br/>    as '<a class="ae kv" href="https://prophetize-4r3ddv95.wl.gateway.dev/test'" rel="noopener ugc nofollow" target="_blank">https://prophetize-4r3ddv95.wl.gateway.dev/test'</a> ;<br/>grant usage on function prophetize(string) to role sysadmin;</span></pre><p id="7f37" class="pw-post-body-paragraph mt mu iq mv b mw ns jr my mz nt ju nb nc nu ne nf ng nv ni nj nk nw nm nn ly ij bi translated">这就是你所需要的，现在你可以像在Snowflake中的任何其他查询一样调用刚刚生成的<code class="fe no np nq nr b">prophetize()</code>:</p><pre class="kg kh ki kj gt nx nr ny nz aw oa bi"><span id="623e" class="ob kx iq nr b gy oc od l oe of">select prophetize('[[41,43,62,43],["2019-12-30","2020-01-06","2020-01-13","2020-01-20"]]');</span></pre><p id="98d5" class="pw-post-body-paragraph mt mu iq mv b mw ns jr my mz nt ju nb nc nu ne nf ng nv ni nj nk nw nm nn ly ij bi translated">其结果如下:</p><pre class="kg kh ki kj gt nx nr ny nz aw oa bi"><span id="0985" class="ob kx iq nr b gy oc od l oe of">[<br/>  [<br/>    "2020-01-21",<br/>    51.3641167654911,<br/>    40.85673826625397,<br/>    61.745184538148166<br/>  ],<br/>  [<br/>    "2020-01-22",<br/>    51.72223221323965,<br/>    41.87259513681375,<br/>    61.29144225035811<br/>  ],<br/>  [<br/>    "2020-01-23",<br/>    52.0803476609882,<br/>    41.66374622035821,<br/>    61.55883149200517<br/>  ], [...]<br/>]</span></pre><h2 id="9294" class="ob kx iq bd ky ox oy dn lc oz pa dp lg nc pb pc li ng pd pe lk nk pf pg lm ph bi translated">保护流量</h2><p id="5010" class="pw-post-body-paragraph mt mu iq mv b mw mx jr my mz na ju nb nc nd ne nf ng nh ni nj nk nl nm nn ly ij bi translated">你可能已经注意到了上面我的配置中的许多URLs现在你已经看到了它们，你可能想开始从你的帐户调用我的函数。那很好，但我更想保护他们。</p><p id="7aa3" class="pw-post-body-paragraph mt mu iq mv b mw ns jr my mz nt ju nb nc nu ne nf ng nv ni nj nk nw nm nn ly ij bi translated">雪花使这变得容易。创建上述集成后，将自动提供GCP的服务帐户。您可以用<code class="fe no np nq nr b">describe integration prophet_test</code>获取它的值，然后使用该服务帐户更新<code class="fe no np nq nr b">gateway.yaml</code>，这样其他人就不能调用它了:</p><pre class="kg kh ki kj gt nx nr ny nz aw oa bi"><span id="b7fd" class="ob kx iq nr b gy oc od l oe of">swagger: '2.0'<br/>info:<br/>  title: API Gateway config for Snowflake external function.<br/>  description: This configuration file connects the API Gateway resource to the remote service (Cloud Function).<br/>  version: 1.0.0<br/>securityDefinitions:<br/>  snowflakeAccess01:<br/>    authorizationUrl: ""<br/>    flow: "implicit"<br/>    type: "oauth2"<br/>    x-google-issuer: "ftyqmxcfyo@sfc-prod2-1-947.iam.gserviceaccount.com"<br/>    x-google-jwks_uri: "<a class="ae kv" href="https://www.googleapis.com/robot/v1/metadata/x509/" rel="noopener ugc nofollow" target="_blank">https://www.googleapis.com/robot/v1/metadata/x509/</a>ftyqmxcfyo@sfc-prod2-1-947.iam.gserviceaccount.com"<br/>schemes:<br/>  - https<br/>produces:<br/>  - application/json<br/>paths:<br/>  /test:<br/>    post:<br/>      summary: Prophetize.<br/>      operationId: prophetize<br/>      security:<br/>        - snowflakeAccess01: []<br/>      x-google-backend:<br/>        address: <a class="ae kv" href="https://prophetize-zqnzinxyeq-wl.a.run.app/" rel="noopener ugc nofollow" target="_blank">https://prophetize-zqnzinxyeq-wl.a.run.app/</a> <br/>        protocol: h2<br/>      responses:<br/>        '200':<br/>          description: &lt;DESCRIPTION&gt;<br/>          schema:<br/>            type: string</span></pre><p id="1c1f" class="pw-post-body-paragraph mt mu iq mv b mw ns jr my mz nt ju nb nc nu ne nf ng nv ni nj nk nw nm nn ly ij bi translated">然后按照这些<a class="ae kv" href="https://docs.snowflake.com/en/sql-reference/external-functions-creating-gcp-set-security-policy.html#reload-the-updated-configuration-file" rel="noopener ugc nofollow" target="_blank">雪花文档，用上面的安全配置更新您的GCP API网关</a>。</p><p id="d071" class="pw-post-body-paragraph mt mu iq mv b mw ns jr my mz nt ju nb nc nu ne nf ng nv ni nj nk nw nm nn ly ij bi translated">请注意，这个GCP服务帐户是由雪花提供的，无论您使用什么云来托管您的雪花帐户。在这种情况下，我在AWS上的雪花上运行了整个演示，它能够毫不费力地调用GCP服务。</p><p id="bc9f" class="pw-post-body-paragraph mt mu iq mv b mw ns jr my mz nt ju nb nc nu ne nf ng nv ni nj nk nw nm nn ly ij bi translated">同时，在云运行中，确保停止允许未经验证的调用。这样，只有通过API网关授权的呼叫才能得到服务:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pi"><img src="../Images/30f17eb204b5d6b0a7195df0e0c233cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wCmG7goQ9O02E8ou8UPidA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">停止允许云运行上未经身份验证的调用。</p></figure><h1 id="2dec" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">了解更多信息</h1><p id="d222" class="pw-post-body-paragraph mt mu iq mv b mw mx jr my mz na ju nb nc nd ne nf ng nh ni nj nk nl nm nn ly ij bi translated"><a class="ae kv" href="https://facebook.github.io/prophet/" rel="noopener ugc nofollow" target="_blank">脸书预言家</a>是一款多功能工具，拥有许多调节杠杆和方法:</p><blockquote class="pj pk pl"><p id="9094" class="mt mu pm mv b mw ns jr my mz nt ju nb pn nu ne nf po nv ni nj pp nw nm nn ly ij bi translated">Prophet是一种基于加法模型预测时间序列数据的过程，在该模型中，非线性趋势与每年、每周和每天的季节性以及假日影响相适应。它最适用于具有强烈季节效应的时间序列和几个季节的历史数据。Prophet对缺失数据和趋势变化非常稳健，通常能够很好地处理异常值。</p></blockquote><p id="1e8b" class="pw-post-body-paragraph mt mu iq mv b mw ns jr my mz nt ju nb nc nu ne nf ng nv ni nj nk nw nm nn ly ij bi translated">阅读更多信息，请访问:</p><ul class=""><li id="4da8" class="oj ok iq mv b mw ns mz nt nc ol ng om nk on ly oo op oq or bi translated"><a class="ae kv" href="https://blog.doit-intl.com/seven-tips-for-predicting-the-future-with-facebooks-prophet-51cf8d6c89dc" rel="noopener ugc nofollow" target="_blank">预测云成本的七个技巧(与FB的预言家一起)</a>来自<a class="pq pr ep" href="https://medium.com/u/b45fa95a7293?source=post_page-----71c6f7fdc4e3--------------------------------" rel="noopener" target="_blank"> Gad Benram </a>。</li><li id="2f5d" class="oj ok iq mv b mw os mz ot nc ou ng ov nk ow ly oo op oq or bi translated"><a class="ae kv" rel="noopener" target="_blank" href="/building-a-serverless-containerized-batch-prediction-model-using-google-cloud-run-and-terraform-82c97ab17515">使用Google Cloud Run、Pub/Sub、云存储和Terraform </a>构建无服务器、容器化的批量预测模型<a class="pq pr ep" href="https://medium.com/u/b7f2b6fc948e?source=post_page-----71c6f7fdc4e3--------------------------------" rel="noopener" target="_blank"> Sebastian Telsemeyer </a>。</li><li id="a849" class="oj ok iq mv b mw os mz ot nc ou ng ov nk ow ly oo op oq or bi translated"><a class="ae kv" href="https://github.com/ahmetb/cloud-run-faq" rel="noopener ugc nofollow" target="_blank">云运行成本和特性</a>，由<a class="pq pr ep" href="https://medium.com/u/2cac56571879?source=post_page-----71c6f7fdc4e3--------------------------------" rel="noopener" target="_blank"> Ahmet Alp Balkan </a></li></ul><h1 id="6852" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">后续步骤</h1><ul class=""><li id="95e4" class="oj ok iq mv b mw mx mz na nc ps ng pt nk pu ly oo op oq or bi translated">用一个<a class="ae kv" href="http://bit.ly/sf-free-trial" rel="noopener ugc nofollow" target="_blank">雪花免费试用</a>账户试试吧——你只需要一个电子邮件地址就可以开始了。</li><li id="1a35" class="oj ok iq mv b mw os mz ot nc ou ng ov nk ow ly oo op oq or bi translated">我将用所有这些文件建立一个GitHub项目(完成后在这里更新)</li></ul><h2 id="c86b" class="ob kx iq bd ky ox oy dn lc oz pa dp lg nc pb pc li ng pd pe lk nk pf pg lm ph bi translated">玩弄先知:比特币预测</h2><p id="2941" class="pw-post-body-paragraph mt mu iq mv b mw mx jr my mz na ju nb nc nd ne nf ng nh ni nj nk nl nm nn ly ij bi translated"><a class="ae kv" href="https://medium.com/snowflake/knoema-datasets-and-the-snowflake-data-marketplace-challenge-95ff0d7ac6eb" rel="noopener"> Knoema </a>已经对雪花市场中的多个加密硬币进行了估值，因此使用Prophet构建时间序列预测非常简单:</p><pre class="kg kh ki kj gt nx nr ny nz aw oa bi"><span id="7d86" class="ob kx iq nr b gy oc od l oe of">-- define the time series<br/>select "Value" value, "Date" date<br/>from KNOEMA_FINANCE_DATA_ATLAS.FINANCE.CMCCD2019 <br/>where "Cryptocurrency Name" = 'Bitcoin (btc)' <br/>and "Measure" = 'PriceUSD' <br/>and date &gt; '2017-01-01'<br/>order by "Date";</span><span id="2fab" class="ob kx iq nr b gy og od l oe of">-- prophetize<br/>select prophetize(array_construct(<br/>        array_agg(value::float) within group(order by date)<br/>        , array_agg(date::date) within group(order by date))::string) str<br/>from table(result_scan(last_query_id(-1)));</span><span id="fb87" class="ob kx iq nr b gy og od l oe of">-- prepare the viz<br/>select date, value, 0 forecast, 0 fore_min, 0 fore_max<br/>from table(result_scan(last_query_id(-2)))<br/>union all<br/>select x.value[0]::date, 0, x.value[1]::int forecast, x.value[2]::int fore_min, x.value[3]::int fore_max<br/>from table(result_scan(last_query_id(-1))) a, table(flatten(a.$1)) x;</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pv"><img src="../Images/e7f88092eaf935ee21f086fc1f252936.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Qkr8NN9tNnnNo34q"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">预言家对比特币价格的预测——用来自<a class="ae kv" href="https://medium.com/snowflake/knoema-datasets-and-the-snowflake-data-marketplace-challenge-95ff0d7ac6eb" rel="noopener"> Knoema </a>的数据在雪花上运行</p></figure><p id="2613" class="pw-post-body-paragraph mt mu iq mv b mw ns jr my mz nt ju nb nc nu ne nf ng nv ni nj nk nw nm nn ly ij bi translated">你和Prophet玩得越多，你就越会发现预测在很大程度上取决于你给它输入什么值，以及你如何调整它。在这种情况下，根据我对时间序列使用的起始日期，预测会有很大不同——从2016年开始意味着Prophet将观察到一个更复杂的模式，从2018年开始向它提供数据，以此类推。</p><p id="6602" class="pw-post-body-paragraph mt mu iq mv b mw ns jr my mz nt ju nb nc nu ne nf ng nv ni nj nk nw nm nn ly ij bi translated">对我来说最好的部分？我可以在不离开舒适的雪花SQL web UI的情况下完成这一切:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pw"><img src="../Images/4a9289529da1a70384f1da62a23cad51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kBU4pf-7szi12-SjG8zRXw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">在Snowsight(雪花的网络用户界面)中可视化预测</p></figure><h1 id="9a68" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">想要更多吗？</h1><p id="dd52" class="pw-post-body-paragraph mt mu iq mv b mw mx jr my mz na ju nb nc nd ne nf ng nh ni nj nk nl nm nn ly ij bi translated">我是Felipe Hoffa，雪花的数据云倡导者。谢谢你和我一起冒险。你可以<a class="ae kv" href="https://twitter.com/felipehoffa" rel="noopener ugc nofollow" target="_blank">在Twitter </a>和<a class="ae kv" href="https://www.linkedin.com/in/hoffa/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>关注我，查看【reddit.com/r/snowflake】的<a class="ae kv" href="https://www.reddit.com/r/snowflake/" rel="noopener ugc nofollow" target="_blank">了解最有趣的雪花新闻。</a></p><div class="px py gp gr pz me"><a href="https://github.com/Snowflake-Labs/awesome-snowflake" rel="noopener  ugc nofollow" target="_blank"><div class="mf ab fo"><div class="mg ab mh cl cj mi"><h2 class="bd ir gy z fp mj fr fs mk fu fw ip bi translated">雪花实验室/棒极了雪花</h2><div class="ml l"><h3 class="bd b gy z fp mj fr fs mk fu fw dk translated">关于雪花社区和内容的主要链接的令人敬畏的资源的策划列表，记得订阅:活动…</h3></div><div class="mm l"><p class="bd b dl z fp mj fr fs mk fu fw dk translated">github.com</p></div></div><div class="mn l"><div class="qa l mp mq mr mn ms kp me"/></div></div></a></div><div class="px py gp gr pz me"><a href="https://medium.com/snowflake/knoema-datasets-and-the-snowflake-data-marketplace-challenge-95ff0d7ac6eb" rel="noopener follow" target="_blank"><div class="mf ab fo"><div class="mg ab mh cl cj mi"><h2 class="bd ir gy z fp mj fr fs mk fu fw ip bi translated">Knoema数据集和雪花数据市场挑战</h2><div class="ml l"><h3 class="bd b gy z fp mj fr fs mk fu fw dk translated">雪花数据市场挑战赛已经开始。要赢，你需要想出一个有创意的问题答案，通过…</h3></div><div class="mm l"><p class="bd b dl z fp mj fr fs mk fu fw dk translated">medium.com</p></div></div><div class="mn l"><div class="qb l mp mq mr mn ms kp me"/></div></div></a></div></div></div>    
</body>
</html>