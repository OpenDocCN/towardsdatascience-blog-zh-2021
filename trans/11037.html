<html>
<head>
<title>Not-So-Trivial Behavior of the df.sum() Pandas Method in the Presence of Missing Values</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在缺少值的情况下，df.sum() Pandas方法的行为非常重要</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/not-so-trivial-behavior-of-the-df-sum-pandas-method-in-the-presence-of-missing-values-a6cbfcacd5b8?source=collection_archive---------25-----------------------#2021-10-27">https://towardsdatascience.com/not-so-trivial-behavior-of-the-df-sum-pandas-method-in-the-presence-of-missing-values-a6cbfcacd5b8?source=collection_archive---------25-----------------------#2021-10-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e66e" class="pw-subtitle-paragraph ju is it bd b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl dk translated">一些潜在的问题以及如何解决它们</h2></div><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/cc55a408be0da42f4e9d83a11c13737d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ztbDIArpd7KggIK44UiUfA.jpeg"/></div></div><p class="ky kz gj gh gi la lb bd b be z dk translated">来自<a class="ae lc" href="https://pixabay.com/photos/abacus-beads-mathematics-numeral-3116200/" rel="noopener ugc nofollow" target="_blank"> Pixabay </a></p></figure><p id="92dd" class="pw-post-body-paragraph ld le it lf b lg lh jy li lj lk kb ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">尽管是最常用的pandas方法之一，<code class="fe jq jr js jt b">df.sum()</code>在数据集中有缺失值的情况下会变得很麻烦。在本文中，我们将看看它可能导致的一些潜在问题以及修复它们的方法。</p><p id="4e23" class="pw-post-body-paragraph ld le it lf b lg lh jy li lj lk kb ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">让我们导入必要的库，并为我们的进一步实验创建一个带有许多缺失值的虚拟数据帧:</p><pre class="kn ko kp kq gt lz jt ma mb aw mc bi"><span id="d7bb" class="md me it jt b gy mf mg l mh mi">import pandas as pd<br/>import numpy as np</span><span id="c3e4" class="md me it jt b gy mj mg l mh mi">df = pd.DataFrame({'A': [np.nan, 5, np.nan],<br/>                   'B': [2, np.nan, np.nan],<br/>                   'C': [np.nan, 6, np.nan],<br/>                   'D': [True, False, np.nan]})<br/>print(df)</span><span id="3f2f" class="md me it jt b gy mj mg l mh mi"><strong class="jt iu">Output:<br/></strong>     A    B    C      D<br/>0  NaN  2.0  NaN   True<br/>1  5.0  NaN  6.0  False<br/>2  NaN  NaN  NaN    NaN</span></pre><p id="baeb" class="pw-post-body-paragraph ld le it lf b lg lh jy li lj lk kb ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">现在，我们将按列(<code class="fe jq jr js jt b">axis=0</code>默认)和行(<code class="fe jq jr js jt b">axis=1</code>)计算值的总和:</p><pre class="kn ko kp kq gt lz jt ma mb aw mc bi"><span id="8f41" class="md me it jt b gy mf mg l mh mi">print(f'Summing up by column: \n{df.sum()}\n\n'<br/>      f'Summing up by row: \n{df.sum(axis=1)}')</span><span id="f50a" class="md me it jt b gy mj mg l mh mi"><strong class="jt iu">Output:<br/></strong>Summing up by column:<br/>A    5.0<br/>B    2.0<br/>C    6.0<br/>D      1<br/>dtype: object<br/><br/>Summing up by row:<br/>0     3.0<br/>1    11.0<br/>2     0.0<br/>dtype: float64</span></pre><p id="a31d" class="pw-post-body-paragraph ld le it lf b lg lh jy li lj lk kb ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">我们可以注意到两个可能的问题:</p><ol class=""><li id="f23b" class="mk ml it lf b lg lh lj lk lm mm lq mn lu mo ly mp mq mr ms bi translated">在最后一列中，布尔值就像数字一样(<code class="fe jq jr js jt b">True</code> =1，<code class="fe jq jr js jt b">False</code> =0)，并被求和。</li><li id="b7af" class="mk ml it lf b lg mt lj mu lm mv lq mw lu mx ly mp mq mr ms bi translated">在具有所有NaN值的最后一行中，NaN的总和为0.0。</li></ol><p id="7112" class="pw-post-body-paragraph ld le it lf b lg lh jy li lj lk kb ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">让我们更详细地探讨这些观察结果。</p><h1 id="8357" class="my me it bd mz na nb nc nd ne nf ng nh kd ni ke nj kg nk kh nl kj nm kk nn no bi translated">1.布尔值就像数字一样，是相加的。</h1><p id="72b5" class="pw-post-body-paragraph ld le it lf b lg np jy li lj nq kb ll lm nr lo lp lq ns ls lt lu nt lw lx ly im bi translated">从“pythonic”的角度来看，布尔的这种行为没有任何问题。事实上:</p><pre class="kn ko kp kq gt lz jt ma mb aw mc bi"><span id="e1ac" class="md me it jt b gy mf mg l mh mi">True + False</span><span id="6691" class="md me it jt b gy mj mg l mh mi"><strong class="jt iu">Output:<br/></strong>1</span></pre><p id="f8ab" class="pw-post-body-paragraph ld le it lf b lg lh jy li lj lk kb ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">然而，在许多情况下，我们实际上只对实际数值求和感兴趣，而忽略了布尔值。让我们看看<code class="fe jq jr js jt b">numeric_only</code>参数是否有用:</p><pre class="kn ko kp kq gt lz jt ma mb aw mc bi"><span id="595a" class="md me it jt b gy mf mg l mh mi">print(f'Summing up by column: \n{df.sum()}\n\n'<br/>      f'Summing up only numeric values by column: \n{df.sum(numeric_only=True)}')</span><span id="5d8a" class="md me it jt b gy mj mg l mh mi"><strong class="jt iu">Output:<br/></strong>Summing up by column:<br/>A    5.0<br/>B    2.0<br/>C    6.0<br/>D      1<br/>dtype: object<br/><br/>Summing up only numeric values by column:<br/>A    5.0<br/>B    2.0<br/>C    6.0<br/>dtype: float64</span></pre><p id="ee0d" class="pw-post-body-paragraph ld le it lf b lg lh jy li lj lk kb ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">我们看到，在第二种情况下，尽管在原生Python中有布尔的数值行为，但是<code class="fe jq jr js jt b">D</code>列被排除在计算之外。但是是因为布尔值吗？此外，这个列是布尔型的吗？</p><pre class="kn ko kp kq gt lz jt ma mb aw mc bi"><span id="7ed6" class="md me it jt b gy mf mg l mh mi">df.dtypes</span><span id="56cd" class="md me it jt b gy mj mg l mh mi"><strong class="jt iu">Output:<br/></strong>A    float64<br/>B    float64<br/>C    float64<br/>D     object<br/>dtype: object</span></pre><p id="85d4" class="pw-post-body-paragraph ld le it lf b lg lh jy li lj lk kb ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">遗憾的是，要成为布尔数据类型，列必须只包含<code class="fe jq jr js jt b">True</code> / <code class="fe jq jr js jt b">False</code>值，不接受任何nan。否则，该列将包含混合数据类型，并将自动转换为对象数据类型。事实上，在Python中，NaN值实际上是一种浮点类型:</p><pre class="kn ko kp kq gt lz jt ma mb aw mc bi"><span id="4dba" class="md me it jt b gy mf mg l mh mi">type(np.nan)</span><span id="eb49" class="md me it jt b gy mj mg l mh mi"><strong class="jt iu">Output:<br/></strong>float</span></pre><p id="4e22" class="pw-post-body-paragraph ld le it lf b lg lh jy li lj lk kb ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">我们可以通过应用<code class="fe jq jr js jt b">convert_dtypes()</code>方法来解决这个问题，该方法使用支持<code class="fe jq jr js jt b">pd.NA</code>的dtypes将列转换为可能的最佳数据类型:</p><pre class="kn ko kp kq gt lz jt ma mb aw mc bi"><span id="2d17" class="md me it jt b gy mf mg l mh mi">df1 = df.convert_dtypes()</span><span id="1aa8" class="md me it jt b gy mj mg l mh mi">print(f'{df1}\n\n'<br/>      f'Column data types: \n{df1.dtypes}\n\n'<br/>      f'Summing up by column: \n{df1.sum()}\n\n'<br/>      f'Summing up only numeric values by column: \n{df1.sum(numeric_only=True)}')</span><span id="70ec" class="md me it jt b gy mj mg l mh mi"><strong class="jt iu">Output:<br/></strong>      A     B     C      D<br/>0  &lt;NA&gt;     2  &lt;NA&gt;   True<br/>1     5  &lt;NA&gt;     6  False<br/>2  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;   &lt;NA&gt;<br/><br/>Column data types:<br/>A      Int64<br/>B      Int64<br/>C      Int64<br/>D    boolean<br/>dtype: object<br/><br/>Summing up by column:<br/>A    5<br/>B    2<br/>C    6<br/>D    1<br/>dtype: int64<br/><br/>Summing up only numeric values by column:<br/>A    5<br/>B    2<br/>C    6<br/>D    1<br/>dtype: int64</span></pre><p id="dcad" class="pw-post-body-paragraph ld le it lf b lg lh jy li lj lk kb ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">既然<code class="fe jq jr js jt b">D</code>列是布尔数据类型，那么<code class="fe jq jr js jt b">numeric_only</code>参数就没用了。似乎该参数在分配给<code class="fe jq jr js jt b">True</code>时，只能有助于过滤掉包含布尔值和NaN值的列。在包含字符串值的对象数据类型的列上，使用vs .不使用此参数会产生以下不明显的影响:</p><pre class="kn ko kp kq gt lz jt ma mb aw mc bi"><span id="a724" class="md me it jt b gy mf mg l mh mi">df2 = pd.DataFrame({'A': [1, 1, 1, 1, 1],<br/>                    'B': ['H', 'e', 'l', 'l', 'o'],<br/>                    'C': ['W', 'o', 'r', 'l','d'],<br/>                    'D': [1, 2, 3, 4, 5]})</span><span id="d50e" class="md me it jt b gy mj mg l mh mi">print(f'{df2}\n\n'<br/>      f'Summing up by column: \n{df2.sum()}\n\n'<br/>      f'Summing up only numeric values by column: \n{df2.sum(numeric_only=True)}')</span><span id="6281" class="md me it jt b gy mj mg l mh mi"><strong class="jt iu">Output:<br/></strong>   A  B  C  D<br/>0  1  H  W  1<br/>1  1  e  o  2<br/>2  1  l  r  3<br/>3  1  l  l  4<br/>4  1  o  d  5<br/><br/>Summing up by column:<br/>A        5<br/>B    Hello<br/>C    World<br/>D       15<br/>dtype: object<br/><br/>Summing up only numeric values by column:<br/>A     5<br/>D    15<br/>dtype: int64</span></pre><h1 id="a822" class="my me it bd mz na nb nc nd ne nf ng nh kd ni ke nj kg nk kh nl kj nm kk nn no bi translated">2.在包含所有nan的Series对象中，值的总和为0。</h1><p id="a7d7" class="pw-post-body-paragraph ld le it lf b lg np jy li lj nq kb ll lm nr lo lp lq ns ls lt lu nt lw lx ly im bi translated">让我们回到最初的数据框架:</p><pre class="kn ko kp kq gt lz jt ma mb aw mc bi"><span id="a6c5" class="md me it jt b gy mf mg l mh mi">print(df)</span><span id="17f7" class="md me it jt b gy mj mg l mh mi"><strong class="jt iu">Output:<br/></strong>     A    B    C      D<br/>0  NaN  2.0  NaN   True<br/>1  5.0  NaN  6.0  False<br/>2  NaN  NaN  NaN    NaN</span></pre><p id="5305" class="pw-post-body-paragraph ld le it lf b lg lh jy li lj lk kb ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">对于我们在开始时概述的第二个问题:为什么最后一行中所有NaN值的总和为0，而不是一个NaN？事实上，这与Python中NaN和NA值的正常行为相矛盾，不仅是当它们相加在一起时，而且当我们试图向它们添加任何值时:</p><pre class="kn ko kp kq gt lz jt ma mb aw mc bi"><span id="52c2" class="md me it jt b gy mf mg l mh mi">print(np.nan + np.nan)<br/>print(np.nan + 1)<br/>print(np.nan + True)<br/>print(pd.NA + pd.NA)<br/>print(pd.NA + np.nan)</span><span id="295c" class="md me it jt b gy mj mg l mh mi"><strong class="jt iu">Output:<br/></strong>nan<br/>nan<br/>nan<br/>&lt;NA&gt;<br/>&lt;NA&gt;</span></pre><p id="517e" class="pw-post-body-paragraph ld le it lf b lg lh jy li lj lk kb ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">如果我们尝试手动对数据帧的所有列求和(即逐行求和)，我们将得到以下输出:</p><pre class="kn ko kp kq gt lz jt ma mb aw mc bi"><span id="e868" class="md me it jt b gy mf mg l mh mi">df['A'] + df['B'] + df['C'] + df['D']</span><span id="5737" class="md me it jt b gy mj mg l mh mi"><strong class="jt iu">Output:<br/></strong>0    NaN<br/>1    NaN<br/>2    NaN<br/>dtype: object</span></pre><p id="5151" class="pw-post-body-paragraph ld le it lf b lg lh jy li lj lk kb ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">这是因为每行至少有一个NaN值。</p><p id="83af" class="pw-post-body-paragraph ld le it lf b lg lh jy li lj lk kb ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">然而，在之前的所有实验中，我们从未在输出中看到任何NaN值。显然在<code class="fe jq jr js jt b">df.sum()</code>方法中，有一个抑制NaNs影响的参数——<code class="fe jq jr js jt b">skipna</code>(默认为<code class="fe jq jr js jt b">True</code>):</p><pre class="kn ko kp kq gt lz jt ma mb aw mc bi"><span id="c417" class="md me it jt b gy mf mg l mh mi">print(f'Summing up by row excluding NaNs:\n{df.sum(axis=1)}\n\n'<br/>      f'Summing up by row including NaNs:\n{df.sum(axis=1, skipna=False)}')</span><span id="f147" class="md me it jt b gy mj mg l mh mi"><strong class="jt iu">Output:<br/></strong>Summing up by row excluding NaNs:<br/>0     3.0<br/>1    11.0<br/>2     0.0<br/>dtype: float64<br/><br/>Summing up by row including NaNs:<br/>0   NaN<br/>1   NaN<br/>2   NaN<br/>dtype: float64</span></pre><p id="8615" class="pw-post-body-paragraph ld le it lf b lg lh jy li lj lk kb ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">在第一种情况下，数据帧最后一行中的所有nan的总和为0，这在现实生活中可能非常误导，并导致错误的统计数据，从而导致错误的见解。另一方面，在第二种情况下，将<code class="fe jq jr js jt b">skipna</code>参数赋给<code class="fe jq jr js jt b">False</code>并恢复值的正常“pythonic式”行为，我们丢失了许多有效信息。事实上，在本例中，计算对一行中至少存在一个NaN变得非常敏感。有时候，这种方法正是我们所需要的。然而，在许多情况下，我们感兴趣的是考虑任何有效值，并且只考虑这样的值。为此，我们可以使用代表所需有效值数量的参数<code class="fe jq jr js jt b">min_count</code>来执行操作。为了考虑<em class="nu">任何</em>有效数据，我们必须将其赋值为1:</p><pre class="kn ko kp kq gt lz jt ma mb aw mc bi"><span id="2ffc" class="md me it jt b gy mf mg l mh mi">print(f'Summing up by row excluding NaNs: \n{df.sum(axis=1)}\n\n'<br/>      f'Summing up by row including NaNs: \n{df.sum(axis=1, skipna=False)}\n\n'<br/>      f'Summing up by row considering any valid value: \n{df.sum(axis=1, min_count=1)}')</span><span id="4ec9" class="md me it jt b gy mj mg l mh mi"><strong class="jt iu">Output:<br/></strong>Summing up by row excluding NaNs:<br/>0     3.0<br/>1    11.0<br/>2     0.0<br/>dtype: float64<br/><br/>Summing up by row including NaNs:<br/>0   NaN<br/>1   NaN<br/>2   NaN<br/>dtype: float64<br/><br/>Summing up by row considering any valid value:<br/>0     3.0<br/>1    11.0<br/>2     NaN<br/>dtype: float64</span></pre><p id="04c6" class="pw-post-body-paragraph ld le it lf b lg lh jy li lj lk kb ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">最后一种方法给出了最有意义的输出。</p><p id="c071" class="pw-post-body-paragraph ld le it lf b lg lh jy li lj lk kb ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">当然，根据任务的不同，可以为这个参数指定另一个阈值，强制每行或每列都有最小数量的有效数据。</p><h1 id="251b" class="my me it bd mz na nb nc nd ne nf ng nh kd ni ke nj kg nk kh nl kj nm kk nn no bi translated">结论</h1><p id="fe73" class="pw-post-body-paragraph ld le it lf b lg np jy li lj nq kb ll lm nr lo lp lq ns ls lt lu nt lw lx ly im bi translated">在本文中，我们讨论了在缺少值的数据集上使用<code class="fe jq jr js jt b">df.sum()</code> pandas方法的潜在复杂性:值的不可预测的、非pythonic行为的情况，列数据类型的隐式转换及其后果，有时会导致不良结果的方法的不明显的默认参数，以及如何防止它。</p><p id="303d" class="pw-post-body-paragraph ld le it lf b lg lh jy li lj lk kb ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">感谢阅读！</p></div><div class="ab cl nv nw hx nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="im in io ip iq"><p id="6f61" class="pw-post-body-paragraph ld le it lf b lg lh jy li lj lk kb ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">你会发现这些文章也很有趣:</p><div class="oc od gp gr oe of"><a rel="noopener follow" target="_blank" href="/going-beyond-value-counts-creating-visually-engaging-frequency-tables-with-only-3-lines-of-code-3021c7756991"><div class="og ab fo"><div class="oh ab oi cl cj oj"><h2 class="bd iu gy z fp ok fr fs ol fu fw is bi translated">超越value_counts():只用3行代码创建视觉上引人入胜的频率表…</h2><div class="om l"><h3 class="bd b gy z fp ok fr fs ol fu fw dk translated">一些你可能不知道的简单而有用的生活窍门</h3></div><div class="on l"><p class="bd b dl z fp ok fr fs ol fu fw dk translated">towardsdatascience.com</p></div></div><div class="oo l"><div class="op l oq or os oo ot kw of"/></div></div></a></div><div class="oc od gp gr oe of"><a rel="noopener follow" target="_blank" href="/an-unconventional-yet-convenient-matplotlib-broken-barh-function-and-when-it-is-particularly-88887b76c127"><div class="og ab fo"><div class="oh ab oi cl cj oj"><h2 class="bd iu gy z fp ok fr fs ol fu fw is bi translated">一个非常规但方便的Matplotlib Broken_Barh函数，当它特别…</h2><div class="om l"><h3 class="bd b gy z fp ok fr fs ol fu fw dk translated">它是什么，如何使用和定制，何时使用</h3></div><div class="on l"><p class="bd b dl z fp ok fr fs ol fu fw dk translated">towardsdatascience.com</p></div></div><div class="oo l"><div class="ou l oq or os oo ot kw of"/></div></div></a></div><div class="oc od gp gr oe of"><a href="https://levelup.gitconnected.com/when-a-python-gotcha-leads-to-wrong-results-2447f379fdfe" rel="noopener  ugc nofollow" target="_blank"><div class="og ab fo"><div class="oh ab oi cl cj oj"><h2 class="bd iu gy z fp ok fr fs ol fu fw is bi translated">当Python陷阱导致错误结果时</h2><div class="om l"><h3 class="bd b gy z fp ok fr fs ol fu fw dk translated">一个奇怪的难以调试的带有舍入数字的Python故障</h3></div><div class="on l"><p class="bd b dl z fp ok fr fs ol fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="oo l"><div class="ov l oq or os oo ot kw of"/></div></div></a></div></div></div>    
</body>
</html>