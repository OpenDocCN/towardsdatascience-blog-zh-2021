<html>
<head>
<title>What’s New in Python 3.10?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 3.10有什么新特性？</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/whats-new-in-python-3-10-a757c6c69342?source=collection_archive---------0-----------------------#2021-06-08">https://towardsdatascience.com/whats-new-in-python-3-10-a757c6c69342?source=collection_archive---------0-----------------------#2021-06-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="546f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">最酷功能的概述</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/86f73868fff37c3ec2a8c199ac03150f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*___940eBWdbX-F4IBLAzOA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图案由<a class="ae ky" href="https://unsplash.com/@alexander_ant?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">亚历山大蚁</a>在<a class="ae ky" href="https://unsplash.com/t/wallpapers?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">上展开</a></p></figure><p id="c7dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi lv translated"><span class="l lw lx ly bm lz ma mb mc md di"> P </span> ython 3.10截至2021年10月4日发布！你可以在这里<a class="ae ky" href="https://www.python.org/downloads/release/python-3100/" rel="noopener ugc nofollow" target="_blank">下载最新版本</a>。</p><p id="2edf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将介绍Python中一些最有趣的新增内容——结构化模式匹配、带括号的上下文管理器、<em class="me">更多的</em>类型，以及新的和改进的错误消息。</p><p id="fbfc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">点击这里查看文章的视频版本:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mf mg l"/></div></figure></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><h1 id="2e7f" class="mo mp it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">结构模式匹配</h1><p id="2023" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">结构模式匹配是Python中一个不可思议的特性——真的很棒。</p><p id="9eb3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">想象一个如下所示的if-else语句:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl mg l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Python 3.9中的If-else逻辑</p></figure><p id="353a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你拿着它，修改语法，使它看起来更像这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl mg l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Python 3.10中的大小写匹配逻辑</p></figure><p id="e818" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是新的<code class="fe nm nn no np b">match-case</code>说法——很酷，但目前为止没什么特别的。</p><p id="f67c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让<code class="fe nm nn no np b">match-case</code>语句如此有趣的是一种叫做<em class="me">结构模式匹配</em>的东西。</p><p id="f5b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">结构模式匹配允许我们执行相同的匹配用例逻辑，但是基于我们的比较对象<strong class="lb iu"> <em class="me">的<strong class="lb iu"> <em class="me">结构</em> </strong>是否与给定的<strong class="lb iu"> <em class="me">模式</em> </strong>匹配。</em></strong></p><p id="5a96" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以让我们定义两个字典，两个都有不同的结构。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl mg l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">我们定义<strong class="ak"> dict_a </strong>和<strong class="ak">dict _ b</strong>——两者包含相似的信息，但是在不同的字典结构中</p></figure><p id="4b32" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们可以像这样写一个模式来匹配<code class="fe nm nn no np b">dict_a</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl mg l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="ak">字典_a </strong>的模式</p></figure><p id="ce45" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还有一个模式来匹配<code class="fe nm nn no np b">dict_b</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl mg l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="ak"> dict_b </strong>的模式</p></figure><p id="35d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们将这两者放在一个匹配案例语句中，加上实际上是一个<code class="fe nm nn no np b">else</code>/包含所有内容的<code class="fe nm nn no np b">case _</code>——我们得到:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl mg l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">我们循环遍历<strong class="ak"> dict_a </strong>和<strong class="ak">dict _ b</strong>——由于结构模式匹配，两者都在我们期望的地方匹配</p></figure><p id="1242" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">很酷吧？我已经发现这对于数据处理非常有用——你可以在<a class="ae ky" href="https://youtu.be/2qJavL-VX9Y?t=923" rel="noopener ugc nofollow" target="_blank">15:22处的视频</a>中找到一个例子。</p></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><h1 id="469b" class="mo mp it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">带括号的上下文管理器</h1><p id="9852" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">一个较小的变化源于Python 3.9中出现的一个更大的变化——新的基于PEG的解析器。</p><p id="959e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以前的Python解析器有很多限制，这限制了Python开发者可以使用哪些语法。</p><p id="8edd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Python 3.9的基于PEG的解析器消除了这些障碍，从长远来看，这可能会导致更优雅的语法——这种变化的第一个例子是新的<strong class="lb iu">带括号的上下文管理器</strong>。</p><p id="d3fa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Python 3.9之前，我们可以编写类似这样的代码来打开两个(或更多)文件I/O流:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl mg l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在新的解析器之前，如果两个上下文管理器都在同一行上，我们只能使用两个上下文管理器</p></figure><p id="9e88" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一行很长，事实上太长了。但是由于解析器的限制，我们将这一行拆分成多行的唯一方法是使用<code class="fe nm nn no np b">\</code>行继续符:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl mg l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">或者，我们可以使用行继续符<strong class="ak"> \ </strong></p></figure><p id="3bae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可以用，但不是Pythonic。有了新的解析器，我们现在可以使用<em class="me">括号</em>将这一行拆分成多行，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl mg l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">有了新的解析器，并且从Python 3.10开始正式支持，我们现在可以用括号括起我们的上下文管理器</p></figure><p id="99a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">哪个<em class="me">是</em>蟒。</p><p id="59a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，在我们继续之前——在这个<em class="me">新</em>特性中有一个小小的奇怪之处。<em class="me">这并不是全新的… </em></p><p id="569d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们写:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl mg l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">尽管直到Python 3.10才被“引入”,但由于新的PEG解析器，CPython接受了新的语法变化——所以我们有了一个完全兼容3.9的新特性</p></figure><p id="3b15" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Python 3.9中，这是可行的。这是因为新的解析器支持这种语法，尽管直到Python 3.10才正式支持<a class="ae ky" href="https://docs.python.org/3.10/whatsnew/3.10.html#parenthesized-context-managers" rel="noopener ugc nofollow" target="_blank"><em class="me"/></a>。</p></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><h1 id="d184" class="mo mp it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">更多打字</h1><p id="3710" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">Python的类型特性也有更多的更新，如果你感兴趣，我在这里写了更多的细节。</p><p id="5ec7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">很容易，这里最有趣的添加是包含了一个新的操作符，它的行为类似于类型的<em class="me">或</em>逻辑，这是我们之前使用<code class="fe nm nn no np b">Union</code>方法做的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl mg l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">3.9中类型的联合方法</p></figure><p id="28dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们不需要写<code class="fe nm nn no np b">from typing import Union</code>，<code class="fe nm nn no np b">Union[int, float]</code>已经简化为<code class="fe nm nn no np b">int | float</code>——看起来干净多了:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl mg l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">3.10中类型的联合运算符</p></figure></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><h1 id="504e" class="mo mp it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">更好的错误消息</h1><p id="05c5" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">告诉我你第一次看的时候没有直接跳到谷歌上:</p><pre class="kj kk kl km gt nq np nr ns aw nt bi"><span id="1cc3" class="nu mp it np b gy nv nw l nx ny">SyntaxError: unexpected EOF while parsing</span></pre><p id="c86a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在谷歌上输入语法错误的第一个结果表明，我们中的许多人在某个时候确实如此。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/9168ce83a1b0f287b6e84b8c371ab045.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qB5SUFu4E9az49Ag8d7ngg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">解析时出现意外的EOF这是一种简单而优雅的方式，说明我们遗漏了一个括号</p></figure><p id="baf6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这不是一个明确的错误消息，Python充满了不太理想的错误消息<em class="me">。幸运的是，有人注意到了——并且这些信息中的许多已经得到了显著的改进。</em></p><div class="kj kk kl km gt ab cb"><figure class="oa kn ob oc od oe of paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/21eca03d3745dbb8b1e8ff66a4bfb80f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1002/format:webp/1*3zPzj8vEiKcy3FQZMjTqaA.png"/></div></figure><figure class="oa kn ob oc od oe of paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/bab9109613524349e7c5e90aff623713.png" data-original-src="https://miro.medium.com/v2/resize:fit:1002/format:webp/1*iVrxB9xUcqrdKACqLVU5Vg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk og di oh oi translated">缺少带3.9(左)和3.10(右)的括号— <a class="ae ky" href="https://gist.github.com/jamescalam/589f59b38d784152cdbb5f80774a1248" rel="noopener ugc nofollow" target="_blank">点击此处</a>查看包含<strong class="bd oj">所有</strong>三种对比的笔记本</p></figure></div><div class="ab cb"><figure class="oa kn ok oc od oe of paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/ae11532293ad3273dd6d10ace5a8b438.png" data-original-src="https://miro.medium.com/v2/resize:fit:1042/format:webp/1*cARf3h5H1z3Ug81ksPqRjw.png"/></div></figure><figure class="oa kn ol oc od oe of paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/1f6b476969525e96f5d79419813cb0e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/1*fJO_C6XxBXqXRxe1loz4yA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk om di on oi translated">3.9和3.10中未闭合的字符串</p></figure></div><div class="ab cb"><figure class="oa kn oo oc od oe of paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/4a32ab1357b67fb5b1eb453098d2900f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1066/format:webp/1*6d-VF0Td9eOL9k-d0P6uWQ.png"/></div></figure><figure class="oa kn op oc od oe of paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/364a186092a1a821f6ad9b56c000de7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:936/format:webp/1*5mLBsB9GkSOvguyJQowgCg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk oq di or oi translated">在3.9和3.10中使用赋值运算符，而不是比较运算符</p></figure></div><p id="5ce7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">官方变更列表中提到了更多的变更，但在测试中似乎没有显示出来，包括:</p><pre class="kj kk kl km gt nq np nr ns aw nt bi"><span id="258d" class="nu mp it np b gy nv nw l nx ny">from collections import namedtoplo</span><span id="c539" class="nu mp it np b gy os nw l nx ny">&gt; AttributeError: module 'collections' has no attribute 'namedtoplo'. <strong class="np iu">Did you mean: namedtuple?</strong></span></pre><p id="5e17" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，<code class="fe nm nn no np b">AttributeError</code>与之前相同，但是增加了一个<em class="me">建议的</em>属性名称— <code class="fe nm nn no np b">namedtoplo</code>被识别为属性<code class="fe nm nn no np b">namedtuple</code>的潜在错别字。</p><p id="1413" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，我们看到<code class="fe nm nn no np b">NameError</code>消息也有同样的改进:</p><pre class="kj kk kl km gt nq np nr ns aw nt bi"><span id="0e03" class="nu mp it np b gy nv nw l nx ny">new_var = 5<br/>print(new_vr)</span><span id="696f" class="nu mp it np b gy os nw l nx ny">&gt; NameError: name 'new_vr' is not defined. <strong class="np iu">Did you mean: new_var?</strong></span></pre><p id="9e13" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">错误信息还有很多其他的更新！在这里把它们都检查出来<a class="ae ky" href="https://docs.python.org/3.10/whatsnew/3.10.html#better-error-messages" rel="noopener ugc nofollow" target="_blank">。</a></p></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><p id="46d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，它们是Python 3.10引入的一些关键新特性！</p><p id="7d6c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">完整版于2021年10月4日发布，在过去的几个月中，所有的功能都在几个预发布版本中可用(因此这篇文章！).</p><p id="c5e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想自己看看，3.10可以从<a class="ae ky" href="https://www.python.org/downloads/release/python-3100/" rel="noopener ugc nofollow" target="_blank">这里</a>下载。</p><p id="2477" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望你喜欢这篇文章！如果你有任何问题，请通过<a class="ae ky" href="https://twitter.com/jamescalam" rel="noopener ugc nofollow" target="_blank"> Twitter </a>或在下面的评论中告诉我。如果你想要更多这样的内容，我也在YouTube上发了帖子。</p><p id="387c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读！</p></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><p id="8ad6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://bit.ly/nlp-transformers" rel="noopener ugc nofollow" target="_blank">🤖《变形金刚》NLP课程70%的折扣</a></p></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><p id="9cbb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="me">*所有图片均由作者提供，除非另有说明</em></p></div></div>    
</body>
</html>