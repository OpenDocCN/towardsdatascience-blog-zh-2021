<html>
<head>
<title>Adding confidence intervals to maximum likelihood estimates using sympy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用sympy将置信区间添加到最大似然估计</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/adding-confidence-intervals-to-maximum-likelihood-estimates-using-sympy-efe0552653f7?source=collection_archive---------24-----------------------#2021-06-03">https://towardsdatascience.com/adding-confidence-intervals-to-maximum-likelihood-estimates-using-sympy-efe0552653f7?source=collection_archive---------24-----------------------#2021-06-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/98380dc8446743830e275125967da6d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U0hBA8NnTD6l7L8Z2j-eiQ.jpeg"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">由<a class="ae jd" href="https://unsplash.com/@amadorloureiroblanco?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">阿玛多·洛雷罗</a>在<a class="ae jd" href="https://unsplash.com/" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上创作的符号</p></figure><h2 id="a1ce" class="je jf jg bd b dl jh ji jj jk jl jm dk jn translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/thoughts-and-theory" rel="noopener" target="_blank">思想和理论</a></h2><div class=""/><div class=""><h2 id="9ec1" class="pw-subtitle-paragraph kq jp jg bd b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh dk translated">不漂亮，但很有趣</h2></div><p id="010f" class="pw-post-body-paragraph li lj jg lk b ll lm ku ln lo lp kx lq lr ls lt lu lv lw lx ly lz ma mb mc md ij bi translated">当在Python中为极值理论开发名为<code class="fe km kn ko kp b">evt</code>的<a class="ae jd" href="https://github.com/spmvg/evt" rel="noopener ugc nofollow" target="_blank">包</a>时，有必要为最大似然估计值添加置信区间。基于设计考虑，被认为是最佳的实现并不是最漂亮的。然而，它将为感兴趣的人提供一个有趣的读物。这篇文章涉及了统计学中一些有趣的部分，并以展示符号代数在实际代码中的威力的例子作为结束。首先，快速介绍一下发行版。</p><h2 id="fc01" class="me mf jg bd mg mh mi dn mj mk ml dp mm lr mn mo mp lv mq mr ms lz mt mu mv jm bi translated">广义极值分布</h2><p id="4821" class="pw-post-body-paragraph li lj jg lk b ll mw ku ln lo mx kx lq lr my lt lu lv mz lx ly lz na mb mc md ij bi translated">广义极值分布(GEV)是在统计极值研究中出现的一种分布。极值理论不会是这篇文章的主题。精彩介绍，见<a class="ae jd" href="https://link.springer.com/book/10.1007/0-387-34471-3" rel="noopener ugc nofollow" target="_blank">本书</a>。GEV的概率密度函数<em class="nb"> f </em>将在后面提及。它被定义为</p><figure class="nd ne nf ng gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nc"><img src="../Images/a55783d06f04d0e6062767a5ef43d88f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j3j6YgWncs7VdX3bk0EGEg.png"/></div></div></figure><p id="cf15" class="pw-post-body-paragraph li lj jg lk b ll lm ku ln lo lp kx lq lr ls lt lu lv lw lx ly lz ma mb mc md ij bi translated">在哪里</p><ul class=""><li id="da9d" class="nh ni jg lk b ll lm lo lp lr nj lv nk lz nl md nm nn no np bi translated"><em class="nb"> x </em>是随机变量，</li><li id="5aa9" class="nh ni jg lk b ll nq lo nr lr ns lv nt lz nu md nm nn no np bi translated"><em class="nb"> γ </em>为极值指数，</li><li id="2d69" class="nh ni jg lk b ll nq lo nr lr ns lv nt lz nu md nm nn no np bi translated"><em class="nb"> μ </em>是位置参数，并且</li><li id="ef4d" class="nh ni jg lk b ll nq lo nr lr ns lv nt lz nu md nm nn no np bi translated"><em class="nb"> σ </em>是刻度参数。</li></ul><p id="adc9" class="pw-post-body-paragraph li lj jg lk b ll lm ku ln lo lp kx lq lr ls lt lu lv lw lx ly lz ma mb mc md ij bi translated">GEV也定义为<em class="nb"> γ </em>零，但这超出了范围。我们将很快回到GEV，但是首先:让我们提供一些背景。像在最大似然估计中一样，我们将假设一个模型，并尝试用一个数据集来拟合它。幸运的是，<code class="fe km kn ko kp b">scipy</code>有我们<a class="ae jd" href="https://docs.scipy.org/doc/scipy/reference/tutorial/stats/continuous_genextreme.html" rel="noopener ugc nofollow" target="_blank">掩护</a>。接下来一个琐碎的步骤是问:这个估计有多确定？这就是置信区间的由来。不幸的是，置信区间通常带有星号。</p><h2 id="4caa" class="me mf jg bd mg mh mi dn mj mk ml dp mm lr mn mo mp lv mq mr ms lz mt mu mv jm bi translated">解释置信区间</h2><p id="b576" class="pw-post-body-paragraph li lj jg lk b ll mw ku ln lo mx kx lq lr my lt lu lv mz lx ly lz na mb mc md ij bi translated">理想情况下，<em class="nb"> α </em> %置信区间表示:平均而言，在<em class="nb"> α </em> %的情况下，实际值在此范围内。然而，事实往往并非如此。在解释置信区间时，记住以下几点很重要。</p><ul class=""><li id="76ba" class="nh ni jg lk b ll lm lo lp lr nj lv nk lz nl md nm nn no np bi translated"><strong class="lk jq">置信区间不考虑模型误差。</strong>例如，如果假设正态分布计算误差线，但数据不是正态分布，误差线通常会关闭。</li><li id="947f" class="nh ni jg lk b ll nq lo nr lr ns lv nt lz nu md nm nn no np bi translated"><strong class="lk jq">置信区间是随机变量。这不需要解释，但也不应该忘记。</strong></li><li id="0de2" class="nh ni jg lk b ll nq lo nr lr ns lv nt lz nu md nm nn no np bi translated">置信区间通常不考虑偏差。置信区间通常表示估计值的方差，而不是偏差。在解释它们的时候要考虑到这一点。给定一个估计量和一个数据集，估计偏差通常成为一个先有鸡还是先有蛋的问题。使用多重估值器总是一个好的选择，尽管不是一种补救措施。</li></ul><h2 id="00b7" class="me mf jg bd mg mh mi dn mj mk ml dp mm lr mn mo mp lv mq mr ms lz mt mu mv jm bi translated">估计最大似然的置信区间</h2><p id="8da2" class="pw-post-body-paragraph li lj jg lk b ll mw ku ln lo mx kx lq lr my lt lu lv mz lx ly lz na mb mc md ij bi translated">在最大似然估计中，估计置信区间有多种选择。例如:</p><ul class=""><li id="7331" class="nh ni jg lk b ll lm lo lp lr nj lv nk lz nl md nm nn no np bi translated">计算<a class="ae jd" href="https://en.wikipedia.org/wiki/Observed_information" rel="noopener ugc nofollow" target="_blank">观测费希尔信息</a>的估计值。在这种情况下，我们需要区分所有参数组合的PDF。</li><li id="daa9" class="nh ni jg lk b ll nq lo nr lr ns lv nt lz nu md nm nn no np bi translated">将<a class="ae jd" href="https://en.wikipedia.org/wiki/Wilks%27_theorem" rel="noopener ugc nofollow" target="_blank">威尔克斯定理</a>应用于对数似然比统计。在GEV的情况下，这需要数值求根，特别是:最近的根。祝你好运找到那个数字并保持你的代码的通用性。</li><li id="bdcc" class="nh ni jg lk b ll nq lo nr lr ns lv nt lz nu md nm nn no np bi translated">如果你幸运的话，一个概率学家已经得到了估计值的渐近行为。据我所知，GEV的情况并非如此。</li><li id="8a9a" class="nh ni jg lk b ll nq lo nr lr ns lv nt lz nu md nm nn no np bi translated">对数据集进行重新采样，并多次估计参数。这是计算密集型的。</li></ul><p id="f052" class="pw-post-body-paragraph li lj jg lk b ll lm ku ln lo lp kx lq lr ls lt lu lv lw lx ly lz ma mb mc md ij bi translated">因为<code class="fe km kn ko kp b">evt</code>包的代码应该尽可能通用，所以我选择使用观察到的Fisher信息。因此，我需要区分关于所有参数组合的GEV的PDF。手动这是一个相当大的野兽。唯一现实的选择是:符号代数。这就是<code class="fe km kn ko kp b">sympy</code>发挥作用的地方。</p><h2 id="bcbc" class="me mf jg bd mg mh mi dn mj mk ml dp mm lr mn mo mp lv mq mr ms lz mt mu mv jm bi translated">计算观察到的费希尔信息</h2><p id="87dd" class="pw-post-body-paragraph li lj jg lk b ll mw ku ln lo mx kx lq lr my lt lu lv mz lx ly lz na mb mc md ij bi translated">简单来说，Fisher信息表示样本数据提供了多少关于分布<em class="nb"> f </em> ( <em class="nb"> x </em>的未知参数<em class="nb"> θ </em>的信息；<em class="nb"> θ </em>，其中<em class="nb"> x </em>为随机变量。在GEV的情况下，需要估计3个参数:<em class="nb"> γ </em>、<em class="nb"> μ </em>和<em class="nb"> σ </em>。基于观察到的费希尔信息的<a class="ae jd" href="https://en.wikipedia.org/wiki/Observed_information" rel="noopener ugc nofollow" target="_blank">定义</a>，我们将需要估计以下形式的矩阵元素:</p><figure class="nd ne nf ng gt is gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/5ab09d4cb2a90b78ccf2e5febc3d4582.png" data-original-src="https://miro.medium.com/v2/resize:fit:720/format:webp/1*MI2jFY4wJSeDB68uivV7lA.png"/></div></figure><p id="3172" class="pw-post-body-paragraph li lj jg lk b ll lm ku ln lo lp kx lq lr ls lt lu lv lw lx ly lz ma mb mc md ij bi translated">其中<em class="nb"> i </em>和<em class="nb"> j </em>是矩阵索引，其列举了参数向量<em class="nb"> θ </em>的维数，即3。现在，有趣的部分开始了。</p><h2 id="b77b" class="me mf jg bd mg mh mi dn mj mk ml dp mm lr mn mo mp lv mq mr ms lz mt mu mv jm bi translated">设计考虑</h2><p id="d145" class="pw-post-body-paragraph li lj jg lk b ll mw ku ln lo mx kx lq lr my lt lu lv mz lx ly lz na mb mc md ij bi translated">知道微分将使用符号代数来执行，我们有几个选项来将结果集成到<code class="fe km kn ko kp b">evt</code>包中:</p><ul class=""><li id="8058" class="nh ni jg lk b ll lm lo lp lr nj lv nk lz nl md nm nn no np bi translated">使用一个临时脚本做一次，然后将其复制粘贴到源代码中。这是容易出错的，在写这个的时候会很疼。</li><li id="7b9c" class="nh ni jg lk b ll nq lo nr lr ns lv nt lz nu md nm nn no np bi translated">在运行时评估符号差异。这是浪费。</li><li id="df04" class="nh ni jg lk b ll nq lo nr lr ns lv nt lz nu md nm nn no np bi translated">对符号微分求值一次，<a class="ae jd" href="https://docs.sympy.org/latest/modules/utilities/lambdify.html" rel="noopener ugc nofollow" target="_blank">修改</a>该函数，并为以后序列化该函数。例如，这必须依赖于<code class="fe km kn ko kp b">pickle</code>(在此插入版本问题)。另外，<code class="fe km kn ko kp b">evt</code>包依赖于<code class="fe km kn ko kp b">sympy</code>，而<code class="fe km kn ko kp b">sympy</code>的实际使用是一次性的。尽可能限制依赖性是最佳实践。</li><li id="d584" class="nh ni jg lk b ll nq lo nr lr ns lv nt lz nu md nm nn no np bi translated">对差异进行一次评估，并将结果作为Python代码存储在存储库中(ouch)。尽管它并不漂亮，但与其他选择相比，它看起来是最好的方法。</li></ul><p id="bfd0" class="pw-post-body-paragraph li lj jg lk b ll lm ku ln lo lp kx lq lr ls lt lu lv lw lx ly lz ma mb mc md ij bi translated">这就是我如何开始写一段我并不引以为豪的代码，但是写起来很有趣。让我们一步一步地实现。</p><h2 id="35f1" class="me mf jg bd mg mh mi dn mj mk ml dp mm lr mn mo mp lv mq mr ms lz mt mu mv jm bi translated">履行</h2><p id="8bc3" class="pw-post-body-paragraph li lj jg lk b ll mw ku ln lo mx kx lq lr my lt lu lv mz lx ly lz na mb mc md ij bi translated">第一部分是生成模块的<a class="ae jd" href="https://github.com/spmvg/evt/blob/master/sympy/create_compiled_expressions.py" rel="noopener ugc nofollow" target="_blank">脚本</a>，该模块计算观察到的Fisher信息。生成的模块以一个fat免责声明开始:</p><pre class="nd ne nf ng gt nw kp nx ny aw nz bi"><span id="25bd" class="me mf jg kp b gy oa ob l oc od">...<br/>    'This file is not intended to be human-readable. It is generated by ``sympy/create_compiled_expressions.py``:',<br/>    'see the generation file for further details.',<br/>...</span></pre><p id="3d1c" class="pw-post-body-paragraph li lj jg lk b ll lm ku ln lo lp kx lq lr ls lt lu lv lw lx ly lz ma mb mc md ij bi translated">符号微分由<code class="fe km kn ko kp b">sympy</code>处理:</p><pre class="nd ne nf ng gt nw kp nx ny aw nz bi"><span id="ed30" class="me mf jg kp b gy oa ob l oc od">from sympy import symbols, exp, log, diff<br/><br/>x, g, a, s = symbols('x g a s')<br/>variables = [g, a, s]<br/><br/>...<br/><br/>for row_variable in variables:<br/>    row = []<br/>    for column_variable in variables:<br/>        row.append(str(<br/>            -diff(<br/>                diff(<br/>                    log_f,<br/>                    column_variable<br/>                ),<br/>                row_variable<br/>            )<br/>        )<br/>...</span></pre><p id="8793" class="pw-post-body-paragraph li lj jg lk b ll lm ku ln lo lp kx lq lr ls lt lu lv lw lx ly lz ma mb mc md ij bi translated">通过将函数转换为<code class="fe km kn ko kp b">str</code>并使用其等价的<code class="fe km kn ko kp b">numpy</code>替换数学函数的表示来存储函数。期望值是通过取平均值得到的近似值。最后，生成的代码被存储为<a class="ae jd" href="https://github.com/spmvg/evt/blob/master/src/evt/_compiled_expressions/compiled_expressions.py" rel="noopener ugc nofollow" target="_blank">私有模块</a>，以防止用户认为我是个疯子。</p><p id="90c9" class="pw-post-body-paragraph li lj jg lk b ll lm ku ln lo lp kx lq lr ls lt lu lv lw lx ly lz ma mb mc md ij bi translated">就是这样！好看吗？不。有用吗？是的。它能表演吗？很好。是时候关注更重要的问题了，让我们忘记我曾经写过这个。但首先，让我们发表一篇关于它的博文。</p><p id="4f54" class="pw-post-body-paragraph li lj jg lk b ll lm ku ln lo lp kx lq lr ls lt lu lv lw lx ly lz ma mb mc md ij bi translated"><em class="nb">通信:steven@vangemert.dev </em></p></div></div>    
</body>
</html>