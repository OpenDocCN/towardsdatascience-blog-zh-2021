<html>
<head>
<title>How to Analyze a PDF with the layout-parser package.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用布局解析器包分析PDF？</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-analyze-a-pdf-with-the-layout-parser-package-177b1c1600f2?source=collection_archive---------12-----------------------#2021-05-23">https://towardsdatascience.com/how-to-analyze-a-pdf-with-the-layout-parser-package-177b1c1600f2?source=collection_archive---------12-----------------------#2021-05-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/57c3198775630e1fa609771a04b98194.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0A-iCZgFcv-be5IB-wsTAg.png"/></div></div></figure><p id="ca19" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我最近参与了一个项目，该项目需要解析PDF，以便识别页面的区域并从这些区域返回文本。然后，文本区域将被馈送到Q/A模型(<a class="ae kz" href="https://pypi.org/project/farm-haystack/" rel="noopener ugc nofollow" target="_blank"> farm-haystack </a>)，并从PDF返回提取的数据。本质上，我们希望计算机为我们读取PDF文件，并告诉我们它找到了什么。目前，有一些流行的模块以不同的效率执行这项任务，即<a class="ae kz" href="https://pypi.org/project/pdfminer/" rel="noopener ugc nofollow" target="_blank"> pdfminer </a>和<a class="ae kz" href="https://pypi.org/project/py2pdf/" rel="noopener ugc nofollow" target="_blank"> py2pdf </a>。问题是表数据很难解析/检测。解决办法？取出表格和图表，只返回文本块。</p><h2 id="b2e8" class="la lb it bd lc ld le dn lf lg lh dp li km lj lk ll kq lm ln lo ku lp lq lr ls bi translated">下载<a class="ae kz" href="https://layout-parser.github.io/" rel="noopener ugc nofollow" target="_blank">布局解析器</a>。</h2><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="cdfd" class="la lb it ly b gy mc md l me mf">pip install layoutparser</span></pre><h2 id="1c99" class="la lb it bd lc ld le dn lf lg lh dp li km lj lk ll kq lm ln lo ku lp lq lr ls bi translated">将. pdf转换为图像。</h2><p id="eb20" class="pw-post-body-paragraph kb kc it kd b ke mg kg kh ki mh kk kl km mi ko kp kq mj ks kt ku mk kw kx ky im bi translated">我们需要将PDF的每一页转换成图像，以便对其执行<a class="ae kz" href="https://en.wikipedia.org/wiki/Optical_character_recognition" rel="noopener ugc nofollow" target="_blank"> OCR </a>并提取文本块。有许多不同的方法可以做到这一点。您可以转换PDF并在本地机器上保存图像。但是出于我们的目的，我们希望将pdf页面的图像临时保存在内存中- &gt;提取文本- &gt;丢弃图像，因为在我们执行OCR之后，我们不再需要该图像(我们仍然拥有原始的PDF文件)。为了解决这个问题，我们将使用<a class="ae kz" href="https://pypi.org/project/pdf2image/" rel="noopener ugc nofollow" target="_blank"> pdf2image </a>包:</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="d9cd" class="la lb it ly b gy mc md l me mf">pip install pdf2image </span></pre><p id="6025" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这个软件包将允许我们输入一个PDF文件，并输出一个图像的每一页。我们可以选择将图像保存在存储介质上，或者暂时将PDF作为PIL图像列表进行处理，然后在完成后将其丢弃。</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="2f81" class="la lb it ly b gy mc md l me mf">images = convert_from_bytes(open('FILE PATH', 'rb').read())</span></pre><p id="f457" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，您将拥有一个可以循环浏览的图像列表。</p><figure class="lt lu lv lw gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ml"><img src="../Images/6449cff60a725e764d5069c67c54fef4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ekk29JeIM9vwIk7Z24SKnw.png"/></div></div></figure><p id="c4d7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了让布局解析器包能够读取这些图像，您需要将它们转换成像素值的数组，这可以通过numpy轻松实现。</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="7843" class="la lb it ly b gy mc md l me mf">image = np.array(image)</span></pre><h2 id="04ce" class="la lb it bd lc ld le dn lf lg lh dp li km lj lk ll kq lm ln lo ku lp lq lr ls bi translated">实例化您的OCR工具并提取文本。</h2><p id="d1fb" class="pw-post-body-paragraph kb kc it kd b ke mg kg kh ki mh kk kl km mi ko kp kq mj ks kt ku mk kw kx ky im bi translated">目前，有两个OCR工具，你可以用这个包:谷歌云视觉(GCV)和宇宙魔方。我们将使用宇宙魔方。为了检测页面的区域，存在可用于各种用例(表格、杂志出版物、学术期刊)的预先训练的深度学习模型。我们将使用专门用于学术期刊的名为PubLayNet的模型。<a class="ae kz" href="https://github.com/Layout-Parser/layout-model-training" rel="noopener ugc nofollow" target="_blank">请记住，有多种方法可以为您的特定用例训练定制模型</a>。</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="ff2e" class="la lb it ly b gy mc md l me mf">model = lp.Detectron2LayoutModel(<br/>            config_path ='lp://PubLayNet/mask_rcnn_X_101_32x8d_FPN_3x/config', # In model catalog<br/>            label_map   = {0: "Text", 1: "Title", 2: "List", 3:"Table", 4:"Figure"}, # In model`label_map`<br/>            extra_config=["MODEL.ROI_HEADS.SCORE_THRESH_TEST", 0.8] # Optional<br/>        )</span><span id="d540" class="la lb it ly b gy mm md l me mf">#loop through each page<br/>for image in images:<br/>    ocr_agent = lp.ocr.TesseractAgent()<br/>    <br/>    image = np.array(image)<br/>    <br/>    layout = model.detect(image)</span><span id="17a3" class="la lb it ly b gy mm md l me mf">text_blocks = lp.Layout([b for b in layout if b.type == 'Text']) #loop through each text box on page.<br/>    <br/>    for block in text_blocks:<br/>        segment_image = (block<br/>                        .pad(left=5, right=5, top=5, bottom=5)<br/>                        .crop_image(image))<br/>        text = ocr_agent.detect(segment_image)<br/>        block.set(text=text, inplace=True)<br/>    <br/>    <br/>    for i, txt in enumerate(text_blocks.get_texts()):<br/>            my_file = open("OUTPUT FILE PATH/FILENAME.TXT","a+")<br/>            my_file.write(txt)</span></pre><p id="09c3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">运行上述代码后，您可以使用以下语法挑选出每个页面中您感兴趣的区域:</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="c201" class="la lb it ly b gy mc md l me mf">text_blocks = lp.Layout([b for b in layout if b.type == 'Text'])</span><span id="d203" class="la lb it ly b gy mm md l me mf">title_blocks = lp.Layout([b for b in layout if b.type == 'Title'])</span><span id="9a40" class="la lb it ly b gy mm md l me mf">list_blocks = lp.Layout([b for b in layout if b.type == 'List'])</span><span id="4aa5" class="la lb it ly b gy mm md l me mf">table_blocks = lp.Layout([b for b in layout if b.type == 'Table'])</span><span id="a020" class="la lb it ly b gy mm md l me mf">figure_blocks = lp.Layout([b for b in layout if b.type == 'Figure'])</span></pre><p id="f55d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，你可以从你感兴趣的部分提取文本，忽略你不需要的部分。</p><h2 id="435c" class="la lb it bd lc ld le dn lf lg lh dp li km lj lk ll kq lm ln lo ku lp lq lr ls bi translated">结论</h2><p id="d3a8" class="pw-post-body-paragraph kb kc it kd b ke mg kg kh ki mh kk kl km mi ko kp kq mj ks kt ku mk kw kx ky im bi translated">到目前为止，布局解析器包已经被证明是分析页面结构的最可靠和最简单的工具。在这个简短的教程中，我们重点介绍了如何获取一个完整的(多页)PDF，并提取页面中机器可读的部分，然后输入到NLP模型中进行分析。有关更多信息，请参考文档！</p></div></div>    
</body>
</html>