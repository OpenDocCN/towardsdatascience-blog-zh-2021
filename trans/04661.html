<html>
<head>
<title>Your guide to intermediate SQL while learning Ethereum at the same time</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">您的中级SQL指南，同时学习以太坊</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/your-guide-to-intermediate-sql-while-learning-ethereum-at-the-same-time-7b25119ef1e2?source=collection_archive---------8-----------------------#2021-04-22">https://towardsdatascience.com/your-guide-to-intermediate-sql-while-learning-ethereum-at-the-same-time-7b25119ef1e2?source=collection_archive---------8-----------------------#2021-04-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/e311cb91e9443b3ad05fafb1bd884f58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8jMFzunn7XGSehe9FHYBKw.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">照片由<a class="ae jg" href="https://unsplash.com/s/photos/electric?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae jg" href="https://unsplash.com/@othentikisra?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> israel palacio </a>拍摄</p></figure><h2 id="5274" class="jh ji jj bd b dl jk jl jm jn jo jp dk jq translated" aria-label="kicker paragraph">实践教程</h2><div class=""/><div class=""><h2 id="d5e4" class="pw-subtitle-paragraph kp js jj bd b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg dk translated">让我们使您的查询更高效、更易读，同时也帮助您理解像以太坊上的Uniswap这样的去中心化交换。</h2></div><p id="e20f" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><em class="md">如果你正在寻找更多的web3数据内容，请查看我的</em> <a class="ae jg" href="https://ournetwork.mirror.xyz/gP16wLY-9BA1E_ZuOSv1EUAgYGfK9mELNza8cfgMWPQ" rel="noopener ugc nofollow" target="_blank"> <em class="md"> 30天免费课程(带视频)</em> </a> <em class="md">！</em></p><p id="1f1b" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">如果你错过了SQL和以太坊基础的第一部分，请务必先阅读第一部分。在SQL方面，今天我们将讨论这些稍微难一点的主题:</p><ol class=""><li id="4f1d" class="me mf jj lj b lk ll ln lo lq mg lu mh ly mi mc mj mk ml mm bi translated">公共表表达式(cte)</li><li id="5e46" class="me mf jj lj b lk mn ln mo lq mp lu mq ly mr mc mj mk ml mm bi translated">自连接</li><li id="89e8" class="me mf jj lj b lk mn ln mo lq mp lu mq ly mr mc mj mk ml mm bi translated">窗口功能，如分割、超前、滞后、整体</li><li id="b324" class="me mf jj lj b lk mn ln mo lq mp lu mq ly mr mc mj mk ml mm bi translated">在查询中使用索引来提高操作速度。</li><li id="f5a2" class="me mf jj lj b lk mn ln mo lq mp lu mq ly mr mc mj mk ml mm bi translated">子查询以及子查询对查询效率的影响</li></ol><p id="401e" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在以太坊方面，上次我们学习了贷款池和抵押债务头寸。这一次，我将向你介绍一种分散式交易所(DEX)——把它想象成一种外汇，你可以把美元换成欧元，但你的汇率取决于你当地银行里每种货币的剩余量。把“货币”换成代币(<a class="ae jg" href="https://etherscan.io/token/0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48" rel="noopener ugc nofollow" target="_blank">还记得我上次讲的USDC智能合约</a>)把“银行”换成DEX智能合约就行了。我们将关注的DEX smart合约是Uniswap，它在上周(4/11/21)处理了价值<a class="ae jg" href="https://duneanalytics.com/hagaetc/dex-metrics" rel="noopener ugc nofollow" target="_blank">8，870，691，188美元的交易</a>。</p><p id="e6ee" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">像往常一样，在<a class="ae jg" href="https://duneanalytics.com/hagaetc/example-dashboard" rel="noopener ugc nofollow" target="_blank"> Dune Analytics </a>上保存了所有这些查询的链接，所以你可以随时编辑和运行它们。如果你没有回头看上一篇文章，那么这是帮助理解<em class="md">我们正在查询什么</em>的初级读本:</p><blockquote class="ms mt mu"><p id="764f" class="lh li md lj b lk ll kt lm ln lo kw lp mv lr ls lt mw lv lw lx mx lz ma mb mc im bi translated"><em class="jj">记住，以太坊是</em> <strong class="lj jt"> <em class="jj">数据库</em> </strong> <em class="jj">，智能合约是</em> <strong class="lj jt"> <em class="jj">数据表</em> </strong> <em class="jj">，从钱包发送的交易是</em> <strong class="lj jt"> <em class="jj">每个表中的行</em> </strong> <em class="jj">。钱包和智能合约都有地址，</em> <strong class="lj jt">在以太坊上永远是唯一的。</strong></p></blockquote><h1 id="d983" class="my mz jj bd na nb nc nd ne nf ng nh ni ky nj kz nk lb nl lc nm le nn lf no np bi translated">公共表表达式(cte)</h1><p id="2e9f" class="pw-post-body-paragraph lh li jj lj b lk nq kt lm ln nr kw lp lq ns ls lt lu nt lw lx ly nu ma mb mc im bi translated">从技术上来说，Uniswap不仅仅是一个单一的智能合同，它会遇到某些合同大小限制(<a class="ae jg" href="https://cointelegraph.com/news/new-standard-to-avoid-ethreum-contract-size-limitation-developed#:~:text=As%20Ethereum%20contracts%20can%20hit,developed%20to%20help%20combat%20it." rel="noopener ugc nofollow" target="_blank"> 24 KB </a>)，并且开发起来极其复杂。正因为如此，我们的查询将大量地与子查询交织在一起，以获得我们想要的跨契约的数据。将子查询放在查询中是没有效率或可读性的，尤其是在多次使用同一个子查询的情况下。这就是cte发挥作用的地方！</p><p id="d6dd" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">如果你以前用面向对象的语言编写过脚本，比如Python，那么你应该熟悉在变量中存储数据。cte就像SQL的变量，在这里，您将一个子查询作为一个可重用的表存储在查询的其余部分中。</p><p id="6245" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在我们开始查询之前，先快速回顾一下契约模式。Uniswap遵循契约工厂模式，这意味着两个令牌之间的交换有一个基本模板(<a class="ae jg" href="https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2Pair.sol" rel="noopener ugc nofollow" target="_blank"> UniswapV2Pair.sol </a>)，用于<a class="ae jg" href="https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2Factory.sol#L23" rel="noopener ugc nofollow" target="_blank">从Uniswap工厂契约部署新的令牌对</a>。</p><figure class="nw nx ny nz gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nv"><img src="../Images/80381b2e0b0dcea9510c0ee70f913b97.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5f4KhQ6x9A1DfyOxYX6hgg.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">图片作者(<a class="ae jg" href="https://docs.openzeppelin.com/contracts/2.x/api/token/erc20" rel="noopener ugc nofollow" target="_blank"> ERC20参考</a>)</p></figure><p id="2d4a" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">现在，让我们看看是否可以获得上个月创建的所有对以及它们最近的储备余额(即，每个令牌还剩多少)</p><figure class="nw nx ny nz gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oa"><img src="../Images/edb4286b2ffb52604d294de2b6cf3c6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aGe_zWSMMXsCxf3KaEmNZg.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated"><a class="ae jg" href="https://duneanalytics.com/queries/35061" rel="noopener ugc nofollow" target="_blank">https://duneanalytics.com/queries/35061</a></p></figure><p id="9309" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">不要被长度吓到！让我们一行一行地完成这个查询。<code class="fe ob oc od oe b">WITH</code>标志着CTE的开始，随后是我们的第一个CTE <code class="fe ob oc od oe b">cp</code>，它是过去7天内创建的所有配对的集合。<code class="fe ob oc od oe b">r</code>是所有储备余额在过去7天内更新的货币对的集合。<code class="fe ob oc od oe b">r_recent</code>仅保留来自<code class="fe ob oc od oe b">r</code>的每个唯一配对合同(<code class="fe ob oc od oe b">contract_address</code>)的最新更新。现在不要担心<code class="fe ob oc od oe b">partition</code>和<code class="fe ob oc od oe b">row_number()</code>，稍后我会解释这些概念。最后，我对协定地址对<code class="fe ob oc od oe b">cp</code>和<code class="fe ob oc od oe b">r_recent</code>做了一个<code class="fe ob oc od oe b">INNER JOIN</code>运算，得到了我们的最终表。</p><figure class="nw nx ny nz gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi of"><img src="../Images/ad828101c5069c04d3c0022da9df8683.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nXZ4xDjkp8H4yGkPG4GEjA.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">根据行计数，我们可以看到在过去7天中创建了390个新对。请注意，pair_address是UniswapV2Pair.sol的以太网地址，它是在从UniswapV2Factory.sol协定调用createPair()后为特定的tokenA/tokenB对部署的。</p></figure><p id="1eb5" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">您能想象使用子查询完成所有这些吗？不仅其他人很难读懂，调试起来也更加困难和耗时。使用cte，我可以单独构建和测试每个视图，而不必等待整个查询重新运行。</p><h1 id="5113" class="my mz jj bd na nb nc nd ne nf ng nh ni ky nj kz nk lb nl lc nm le nn lf no np bi translated">自连接</h1><p id="f90f" class="pw-post-body-paragraph lh li jj lj b lk nq kt lm ln nr kw lp lq ns ls lt lu nt lw lx ly nu ma mb mc im bi translated">上面提到的工厂和配对基础契约都是非常低级的，不经常被直接调用。相反，Uniswap创建了一个Router02契约，它以一种用户/开发人员友好的方式抽象出了大部分契约复杂性。一旦创建了新的货币对合约，你现在可以通过Router02合约将流动性添加到其流动性池中(这些储备必须以某种方式进入合约中！).流动性池在分散金融中是一个非常重要的概念，所以我会花一些时间来解释它。</p><p id="6c97" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">当增加一对货币的流动性时，你是在增加来自其他流动性提供者(<strong class="lj jt">LP</strong>)的储备的流动性。uni WAP要求您根据每个令牌的$值添加50/50的令牌，然后您将获得一个uni WAP池令牌，代表您在总池中的份额。下面是某人通过Router02增加流动性的例子:</p><figure class="nw nx ny nz gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi og"><img src="../Images/a024dc9925c3be733e832fd4372b355b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LDHfOi2DU90f3bUpQ8iKJQ.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated"><a class="ae jg" href="https://etherscan.io/tx/0x036ee02f7ad27fb5248b5ec1155e0bffdc0a561065b9361d95051d951c0ff8f7" rel="noopener ugc nofollow" target="_blank">USDC/USDT资金池增加流动性并收回统一V2令牌交易示例</a></p></figure><p id="2280" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">当有人想用一个代币交换另一个代币时，他们会增加一个代币的储备，并从另一个代币的储备中提取——从而影响两个代币之间的汇率。我们将在下一节更深入地探讨互换和汇率定价曲线。</p><p id="7095" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">现在，假设我们想要获得所有向同一个池中添加了流动性的有限合伙人的集合。这就是<code class="fe ob oc od oe b">SELF JOIN</code>真正有用的地方，因为我们可以基于第二列在同一列的行之间建立关系。一个很好的例子是，当你有一列姓名和一列地点时，你用<code class="fe ob oc od oe b">SELF JOIN</code>来显示<a class="ae jg" href="https://www.w3schools.com/sql/sql_join_self.asp" rel="noopener ugc nofollow" target="_blank">谁(原始姓名列)和谁(重复姓名列)</a>住在同一个地点。这里，我们有一列按地址排列的有限合伙人，我们希望看到哪些有限合伙人向同一个池中添加了流动性。</p><figure class="nw nx ny nz gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oh"><img src="../Images/8b7587f8fa2f6882228aa5265f3ef0cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_wo0QLee1y4p3TBZsuW-qQ.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated"><a class="ae jg" href="https://duneanalytics.com/queries/35058" rel="noopener ugc nofollow" target="_blank">https://duneanalytics.com/queries/35058</a></p></figure><p id="f778" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我的查询创建了在<code class="fe ob oc od oe b">LP</code>的过去7天中为每个令牌对增加流动性的唯一LP的CTE。在最后一个查询中，我使用了<code class="fe ob oc od oe b">CASE WHEN</code>使该列比合同地址(存储在<code class="fe ob oc od oe b">pair</code>中)更具可读性，这只是一个“if-else”语句。<code class="fe ob oc od oe b">SELF JOIN</code>的关键是在最后两行，我选择了所有提供给同一个池的LP作为所选择的锚定LP。然后，这将遍历该表，并列出每个配对契约的相关LP，因此，如果我有4个LP提供给同一个配对契约，那么我将得到12行(4个uniques充当锚，每个锚有3行/related _ LP)。第20行中的“不等于”操作符<code class="fe ob oc od oe b">&lt;&gt;</code>确保我们跳过锚点，否则它也会显示为一行。最后，第21行充当一个典型连接的<code class="fe ob oc od oe b">ON</code>操作符，用于连接<code class="fe ob oc od oe b">LP1</code>和<code class="fe ob oc od oe b">LP2</code>。</p><figure class="nw nx ny nz gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oi"><img src="../Images/0d5f07b32d2618762729c819704f1759.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*raRjXBtxqVWC0yHW83HNgA.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">请注意，WETH与ETH相同，只是在一个令牌包装器中实现了标准一致性</p></figure><p id="edf2" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">如果您的列有许多共享一个目标列的惟一id，那么这个查询将很快耗尽内存(在本文末尾讨论相关子查询时，我们将回到这个问题)。这就是为什么我限制了日期间隔并预先选择了两个标记对(否则77，000个LP和10，000对可能会有超过一百万行)。我们现在不会对这些数据做任何其他事情，但我们可以使用它来开始对用户进行聚类，或者对成对的流动性池市场进行图形节点分析。</p><h1 id="2f1d" class="my mz jj bd na nb nc nd ne nf ng nh ni ky nj kz nk lb nl lc nm le nn lf no np bi translated">窗口功能，如分割、引导、滞后、整体等</h1><p id="3958" class="pw-post-body-paragraph lh li jj lj b lk nq kt lm ln nr kw lp lq ns ls lt lu nt lw lx ly nu ma mb mc im bi translated">到目前为止，我们已经引入了许多新概念，所以你可能会感到不知所措。如果是这样的话，休息一下或者玩一下链接查询，不要强迫自己一次完成所有这些！</p><p id="04aa" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在本节中，我们将讨论互换交易，例如，如果我想用我的天气换USDC。为了理解这一点，我们需要了解DEX如何对互换进行定价:</p><blockquote class="oj"><p id="165f" class="ok ol jj bd om on oo op oq or os mc dk translated">x*y = k</p></blockquote><p id="b19d" class="pw-post-body-paragraph lh li jj lj b lk ot kt lm ln ou kw lp lq ov ls lt lu ow lw lx ly ox ma mb mc im bi translated">这是一个非常简单的公式！<code class="fe ob oc od oe b">x</code>是WETH的合约准备金，<code class="fe ob oc od oe b">y</code>是USDC的合约准备金，<code class="fe ob oc od oe b">k</code>是他们的总流动性。这给了我们一个类似这样的定价曲线:</p><figure class="nw nx ny nz gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oy"><img src="../Images/4cf5f707d7fdcaf2183750f4108f51a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*kPgPZsTLmSWVEiVt.jpg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated"><a class="ae jg" href="https://uniswap.org/docs/v2/protocol-overview/how-uniswap-works/" rel="noopener ugc nofollow" target="_blank">https://unis WAP . org/docs/v2/protocol-overview/how-unis WAP-works/</a></p></figure><p id="0ca1" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这意味着，当我用令牌A交换令牌B时，令牌A的储备增加，而令牌B的储备减少，这使得将来用令牌A交换令牌B的成本略微增加。如果这对你有意义，那么拍拍你自己的背——这篇文章的其余部分不再有新的以太坊概念了！</p><p id="9ed1" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">但是还有很多SQL需要学习，从窗口函数开始。可以认为这是允许聚合、偏移和统计函数，而不需要使用<code class="fe ob oc od oe b">GROUP BY</code>并保持原始表不变——您只是根据每行中的值添加列。</p><p id="408a" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">通常我们有一些特殊的功能，后面是<code class="fe ob oc od oe b">OVER</code>，然后是窗口<code class="fe ob oc od oe b">(PARTITION BY column_name)</code>。之前，我们的特殊函数是<code class="fe ob oc od oe b">ROW_NUMBER()</code>，它从1开始为每个唯一分区计算新行<code class="fe ob oc od oe b">rn</code>(在这种情况下，每个唯一对在<code class="fe ob oc od oe b">contract_address</code>中收缩)。这就是我们如何能够保持每对合同保留同步的最近一行(<code class="fe ob oc od oe b">rn=1</code>)。</p><pre class="nw nx ny nz gt oz oe pa pb aw pc bi"><span id="e8f8" class="pd mz jj oe b gy pe pf l pg ph">ROW_NUMBER() OVER (PARTITION BY contract_address) rn</span></pre><p id="a198" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">另一种看待window/ <code class="fe ob oc od oe b">PARTITION</code>的方式是将它视为最初用于<code class="fe ob oc od oe b">GROUP BY</code>的列，尽管它也可以是只有一个唯一值的列。让我们试着计算一下过去7天里从WETH到USDC的所有掉期交易的百分位数。我们仍然使用Router02契约，但是使用了<code class="fe ob oc od oe b">swapExactTokensForTokens()</code>函数而不是<code class="fe ob oc od oe b">addLiquidity()</code>。</p><figure class="nw nx ny nz gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pi"><img src="../Images/3a5326e812b5fe241304c166ccb7aeba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_oqONgsxF9hU24crNeAacg.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated"><a class="ae jg" href="https://duneanalytics.com/queries/35980" rel="noopener ugc nofollow" target="_blank">https://duneanalytics.com/queries/35980</a></p></figure><p id="966a" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这里我们使用统计函数<code class="fe ob oc od oe b">NTILE()</code>代替计数器<code class="fe ob oc od oe b">ROW_NUMBER()</code>。<code class="fe ob oc od oe b">NTILE()</code>将根据瓷砖总数(四分位数<code class="fe ob oc od oe b">NTILE(4)</code>、五分位数<code class="fe ob oc od oe b">NTILE(5)</code>、百分位数<code class="fe ob oc od oe b">NTILE(100)</code>等)为每行分配瓷砖。因为我们两次使用同一个窗口，所以我们可以创建一个<code class="fe ob oc od oe b">WINDOW</code>变量来减少冗长。<code class="fe ob oc od oe b">contract_address</code>对于整个列只有一个唯一值，因为它总是被调用Router02，否则我们将有多个分区，并且<code class="fe ob oc od oe b">contract_address</code>中的每个唯一值将得到它自己的100个<code class="fe ob oc od oe b">NTILE</code>的集合。</p><p id="b4e2" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">下面的图表显示了我们的查询结果:</p><figure class="nw nx ny nz gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pj"><img src="../Images/cdea720fffa0bbfcb8a3648d4db7bcbd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Rk9g4nLZKgLndWBUKgRTJw.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">视觉化告诉我们的不仅仅是这里的表格。这个数据严重失真，所以从技术上来说对数会是一个更好的观点。</p></figure><p id="f9b9" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">对于在windows中使用聚合，这里有一些基本的例子<a class="ae jg" href="https://mode.com/sql-tutorial/sql-window-functions/" rel="noopener ugc nofollow" target="_blank">你可以遵循，因为我不会在这里展示任何例子。我确实想涵盖像<code class="fe ob oc od oe b">LEAD</code>和<code class="fe ob oc od oe b">LAG</code>这样的偏移函数，因为它们对于时间序列趋势分析非常有用。</a></p><figure class="nw nx ny nz gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pk"><img src="../Images/f071d450a5b1bc05874c9b377f5e6dfa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w7sLu7zfG0cngYmdtWuljw.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated"><a class="ae jg" href="https://duneanalytics.com/queries/36082" rel="noopener ugc nofollow" target="_blank">https://duneanalytics.com/queries/36082</a></p></figure><p id="12cd" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这里我们创建一个名为<code class="fe ob oc od oe b">DAL</code>的CTE来代表过去28天wet到USDC互换的每日总量<code class="fe ob oc od oe b">amountIn</code>。然后，当从<code class="fe ob oc od oe b">DAL</code>查询时，我们创建两个<code class="fe ob oc od oe b">LAG</code>列，一个滞后1行(天),另一个滞后7行(天):</p><figure class="nw nx ny nz gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pl"><img src="../Images/85d258d6f79a8d496fd6d3fff0fdde04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*md639bdbCYJYeiom32yUZA.png"/></div></div></figure><p id="8cd0" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">如果我们在每个<code class="fe ob oc od oe b">LAG</code>栏前添加一个<code class="fe ob oc od oe b">ETH_swapped_to_USDC -</code>，那么我们可以得到掉期交易量的每日和每周差异:</p><figure class="nw nx ny nz gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pm"><img src="../Images/b4a96d5b7ca09a04bd51070968854001.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*727z19x9UPokHtL8r_ecyQ.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">我将查询从28天更改为100天，以提供更好的图表。</p></figure><h1 id="04a3" class="my mz jj bd na nb nc nd ne nf ng nh ni ky nj kz nk lb nl lc nm le nn lf no np bi translated">在查询中使用索引来提高操作速度。</h1><p id="3fd3" class="pw-post-body-paragraph lh li jj lj b lk nq kt lm ln nr kw lp lq ns ls lt lu nt lw lx ly nu ma mb mc im bi translated">每当您进行查询时，都会根据脚本中的操作运行一个执行计划。虽然已经为您处理了大量优化工作，但是您希望以最有效的方式组织查询和表。我们将在下一节讨论子查询的排序，首先让我们讨论索引。</p><p id="e600" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">如果列是主键，这意味着您可以创建一个链接到它的聚集索引。如果列是外键(非唯一值)，则可以为其附加非聚集索引。在查询数据时，拥有这些索引会导致很大的差异，尤其是在使用<code class="fe ob oc od oe b">WHERE</code>和/或<code class="fe ob oc od oe b">JOIN</code>时。如果没有索引，您的查询将作为表扫描运行(即线性通过每一行)。对于索引，将改为运行索引扫描/查找。这就是二分搜索法搜索与线性搜索的区别，<a class="ae jg" href="https://stackoverflow.com/questions/700241/what-is-the-difference-between-linear-search-and-binary-search#:~:text=A%20linear%20search%20looks%20down,at%20a%20time%2C%20without%20jumping.&amp;text=A%20binary%20search%20is%20when,second%20half%20of%20the%20list." rel="noopener ugc nofollow" target="_blank">导致O(log n)对O(n)的搜索时间</a>。最终，创建索引会导致更长的写时间(因为每次添加新数据时，索引都必须重新排序)，但最终会获得更快的读时间。如果你想要一个更长的浏览和索引与非索引查询的比较，我强烈推荐你看一下这个视频。</p><p id="f897" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">即使表没有索引，您也可以通过在您正在过滤或连接的列上使用<code class="fe ob oc od oe b">ORDER BY</code>来改进线性扫描。这可以使查询更加高效，尤其是对于连接。</p><h1 id="339f" class="my mz jj bd na nb nc nd ne nf ng nh ni ky nj kz nk lb nl lc nm le nn lf no np bi translated">子查询以及子查询对查询效率的影响</h1><p id="e2be" class="pw-post-body-paragraph lh li jj lj b lk nq kt lm ln nr kw lp lq ns ls lt lu nt lw lx ly nu ma mb mc im bi translated">最后，让我们谈谈子查询。有两种类型的子查询:相关子查询和非相关子查询，在相关子查询中，必须为外部查询的每一行重新计算子查询，在非相关子查询中，子查询只计算一次，然后用作外部查询的常数。</p><p id="350d" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">下面是一个不相关的子查询，因为在检查外部查询中的每一行<code class="fe ob oc od oe b">“amountIn”</code>之前，<code class="fe ob oc od oe b">SELECT MAX(“amountIn”)/2 FROM swaps</code>只被评估一次。</p><figure class="nw nx ny nz gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pn"><img src="../Images/6d4b94c5f42e95a229a52a1d4a74c66b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qkI7zB8I2Cx7LZL3e-wT5w.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated"><a class="ae jg" href="https://duneanalytics.com/queries/36434" rel="noopener ugc nofollow" target="_blank">https://duneanalytics.com/queries/36434</a></p></figure><figure class="nw nx ny nz gt iv gh gi paragraph-image"><div class="gh gi po"><img src="../Images/a45373ae1069d331626ad5f66142e3a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:618/format:webp/1*mFJB0wLhw4R9iDKl1BgJ5A.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">在过去的7天里，只有4个掉期交易大于最大掉期交易的一半，根据之前的NTILE(100)图，这是有意义的。</p></figure><p id="7960" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">下一个查询是一个相关子查询，它看起来非常类似于一个<code class="fe ob oc od oe b">SELF JOIN</code>，但是只将行与其自身进行比较，而不是进行连接。我们只想获得Uniswap中每一对的平均互换金额:</p><figure class="nw nx ny nz gt iv gh gi paragraph-image"><div class="gh gi pp"><img src="../Images/dde926ee39ac2b3b0e578e0ceffca76c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1248/format:webp/1*fQ5OjZWTKP7VyoMEEdLwLQ.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated"><a class="ae jg" href="https://duneanalytics.com/queries/36436" rel="noopener ugc nofollow" target="_blank">https://duneanalytics.com/queries/36436</a>注意，我正在检查交换路径是否相同，因为这通常表示一个令牌对。</p></figure><p id="d259" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">尽管这仍然是一个聚合函数比较(使用AVG而不是最大值)，但这个比较在超过30分钟后超时，而非相关查询用时不到5秒。您可以通过将相关子查询转换为连接子查询来加快查询速度，这只是需要一些心理准备。我们用这种方法把它缩短到28秒:</p><figure class="nw nx ny nz gt iv gh gi paragraph-image"><div class="gh gi pq"><img src="../Images/3667731db2ce6219f1ebccc27dfda83d.png" data-original-src="https://miro.medium.com/v2/resize:fit:826/format:webp/1*a-Cp-akVVconX-TT99r3gg.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated"><a class="ae jg" href="https://duneanalytics.com/queries/36436" rel="noopener ugc nofollow" target="_blank">https://duneanalytics.com/queries/36436</a>(上次查询的扩展)</p></figure><figure class="nw nx ny nz gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pr"><img src="../Images/b7df234c517f8167106cbc9bc32e8c7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n2ZZARtbKry56KXcM_ED2w.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">有些路径不止一次交换，我认为这是存在的，如果没有直接对交换，所以它必须通过令牌A -&gt; WETH -&gt;令牌B</p></figure><p id="d0aa" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">如果您绝对必须使用相关子查询，那么您应该利用我们在上一节中讨论的索引——否则它会花费很长时间运行，因为它变成了一个<code class="fe ob oc od oe b">n_rows*n_rows = O(n²)</code>比较操作。</p><p id="ea6a" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">最后，如果任何父查询中有多个子查询，请确保所有子查询都以最有效的方式排序。尤其是在加入时，确保在加入之前使用<code class="fe ob oc od oe b">WHERE</code>和<code class="fe ob oc od oe b">HAVING</code>T7进行过滤，而不是之后。如果您的查询花费的时间太长，请尝试考虑子查询的类型以及您在逻辑和排序方面的其他选项，以使它更快。这是另一个例子，将子查询分解成cte可以帮助您以更快、更干净的方式重新组织和部署代码。</p><h1 id="9f87" class="my mz jj bd na nb nc nd ne nf ng nh ni ky nj kz nk lb nl lc nm le nn lf no np bi translated">你(又)成功了！🎉</h1><p id="51df" class="pw-post-body-paragraph lh li jj lj b lk nq kt lm ln nr kw lp lq ns ls lt lu nt lw lx ly nu ma mb mc im bi translated">如果你(再次)走到这一步，那么恭喜你！您现在知道如何使用SQL进行更高级、更快速的查询。如果你想更多地了解以太坊，可以看看我的另一篇文章，这篇文章深入探讨了它是如何工作的。</p><p id="74c4" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">如果您还没有点击任何查询链接，我强烈建议您这样做，因为Dune Analytics是一个测试查询和快速创建可视化甚至仪表板的好地方。当我开始学习SQL时，我希望有一个这样的工具来练习，而不是依赖hackerank或leetcode中的表(或者摆弄本地服务器，用网上的基本模拟数据表填充它)。</p><p id="048b" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">请关注本系列的最后一部分！</p></div></div>    
</body>
</html>