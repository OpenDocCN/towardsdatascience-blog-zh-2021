<html>
<head>
<title>The Power of Memoization in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中记忆化的力量</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/the-power-of-memoization-in-python-9fd6d284e9e7?source=collection_archive---------39-----------------------#2021-12-06">https://towardsdatascience.com/the-power-of-memoization-in-python-9fd6d284e9e7?source=collection_archive---------39-----------------------#2021-12-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2fab" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解如何用内存换取速度——让您的代码更快</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/6248fe4bd441df807e8ffc72c65e2c17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*51z4skxtCOXnpIJU"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae ky" href="https://unsplash.com/@chuttersnap?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> CHUTTERSNAP </a>拍摄</p></figure><p id="6e5d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不，这不是拼写错误……<strong class="lb iu">记忆</strong>是一个东西。</p><p id="fe23" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我第一次了解这项技术时，我被一种极致的美感所震撼。这种感觉我只在数学领域有过，在那里你会感受到更高层次的结构美。</p><p id="baea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">记忆化对我产生了影响，因为我很快意识到这是计算中更普遍现象的一个特例。最大的秘密是内存和执行速度是一个硬币的两面。</p><p id="1539" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我不仅能够更快地运行我的代码，而且从整体上让我对编程有了更细致的了解。</p><p id="bbc5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将把它作为一个简单的Python解决方案来实现。</p><h1 id="0730" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">速度与内存</h1><p id="8fba" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">拿起一杯咖啡和你的笔记本电脑，哦，你可能想坐下来看看这个！</p><p id="779d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在编程中，有三种速度。</p><p id="4e0a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">编程语言的原始能力与程序的设计无关，而是语言本身固有的特性。例如，Go比Java快，比Python快得多，而C++和Rust比Go快。</p><p id="33e3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们有了另一种速度。算法的有效性。也称为“复杂性”。Go和Rust的速度很快，但是如果你选择了错误的算法，那么你的编程语言有多快真的无关紧要——它会很慢。</p><p id="2757" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一会儿我们会看到一个例子。</p><p id="9b1d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第三，我们有“发展速度”。在许多情况下，这比语言速度的小幅提升更重要。例如，Go和它的快速编译器在这个指标上击败了Rust，尽管Rust在上述意义上更快，而Python击败了几乎所有其他语言，因为Python有大量的库和围绕它的巨大社区。</p><p id="ae0a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有时候语言的原始性能是最重要的，然后我们不应该(必须)选择Python，但是如果你在Python中使用正确的算法，在Rust中使用错误的算法，纯Python会比Rust快得多。</p><p id="5d29" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一般来说，记忆和速度的关系有点像物理学中能量和质量的关系。它们是同一枚硬币的两面，从某种意义上说，你可以将其中一面转换成另一面。</p><p id="150f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">也就是说，您可以通过“正确的方式”增加内存使用来提高速度(或者等效地，减少时间)。这叫做<em class="ms">记忆</em>。</p><blockquote class="mt"><p id="7b3e" class="mu mv it bd mw mx my mz na nb nc lu dk translated">记忆化是一种降低功能的时间成本以换取空间成本的方法。也就是说，内存化的函数在速度上得到优化，以换取更高的计算机内存空间利用率。</p><p id="8fdd" class="mu mv it bd mw mx my mz na nb nc lu dk translated">算法的时间/空间“成本”在计算中有一个特定的名称:<strong class="ak">计算复杂度</strong>。所有函数在时间和空间上都有计算复杂度。</p><p id="c2c0" class="mu mv it bd mw mx my mz na nb nc lu dk translated">维基百科。</p></blockquote><p id="d6df" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">因此，让我们看看如何利用Python中用内存换取速度的思想来优化代码。</p><h1 id="8622" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">Python中的记忆化</h1><p id="abb2" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">假设我们想计算斐波那契数。谁不会呢？此外，我们想用Python实现一个优雅的递归算法。</p><p id="ae6d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们试试那个。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="ca54" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们瞬间得到<em class="ms"> 610 </em>。你知道什么？有用！</p><p id="7c0b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，当我们拿着一杯新咖啡回到椅子上，然后试图计算第100个斐波纳契数时，什么也没发生！！！</p><p id="66fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">很长一段时间都没有输出。这里出了什么问题？我们之前刚刚看到了一个快如闪电的结果。</p><p id="39fa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个算法实际上具有指数复杂性，这意味着运行时间随着输入成指数增长。</p><p id="97d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这可不好。</p><p id="5b20" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">原因是对函数<code class="fe nk nl nm nn b">fib </code>的每个调用都需要在所有数字上运行自己，直到1 - <em class="ms">每个函数</em>！我们多次调用<code class="fe nk nl nm nn b">fib</code>。这意味着我们疯狂地计算<code class="fe nk nl nm nn b">fib(2)</code>很多次。</p><p id="a551" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这当然可以优化。</p><p id="01d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">考虑下面的代码，其中我们使用一个字典来保存兑现的输出值。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="1e35" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们得到输出<em class="ms"> 354224848179261915075 </em>。它工作了。</p><p id="4bcd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，我们不希望变量出现在全局范围内，对吗？如果在函数执行完毕时清除了<code class="fe nk nl nm nn b">memory</code>字典，那就更好了。</p><p id="ca0a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">嗯，我们需要在某个局部范围内有一个随函数一起消失的cashing字典。这听起来像是装修问题。</p><p id="3878" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">考虑一下这个。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="4b76" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这同样快速地打印出上面的数字，但是这一次所有的数据都在函数返回后被清除。可以这么说，我们已经将兑现包裹在函数周围，这使得Python运行这个计算的速度快了数百万倍！</p><p id="4ad6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们当然可以不用记忆技术来构建一个快速的Fibonacci函数，但是这需要一个循环来代替递归，从逻辑的角度来看，递归真的很好。</p><p id="9c73" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">递归可以简单得多，可读性更好，事实上也很漂亮...而谁不想要简单、美观、快捷的结合呢？也就是说，我们应该小心Python中的递归，因为我们很容易遇到堆栈溢出，这意味着调用堆栈变得太大。</p><p id="cb79" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Python有一个相对较低的堆栈限制，尽管你可以修改它。</p><p id="4159" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一般来说，递归更像是一种函数式的方法，因为在(真正的)函数式语言中，你没有循环，因为循环需要你改变变量，而函数式语言没有这种功能。</p><p id="9784" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Python是一种面向对象的语言，如果你需要深入研究，那么就使用循环吧！尤其是你不知道自己要去多深的地方。也许递归的债务将是用户定义的(例如，如果你正在构建一个递归文件爬虫)。</p><p id="48f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">得到一个您没有预料到的堆栈溢出错误是很烦人的，因为您在一个比用户更浅的文件系统/文件夹上测试了它。</p><p id="77c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">顺便问一下，如何使用循环创建这个<code class="fe nk nl nm nn b">fib</code>函数？</p><p id="c093" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好吧…我想我已经折磨你够久了。记忆化这个词来源于拉丁语<em class="ms">备忘录</em>，意思是:<em class="ms">“被记住”</em>。</p><p id="03c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">幸运的是，您不需要为了使用它而记住它！</p></div><div class="ab cl no np hx nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="im in io ip iq"><p id="5330" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">喜欢在Medium上阅读像这样的文章？ <a class="ae ky" href="https://kaspermuller.medium.com/membership" rel="noopener"> <em class="ms">获得会员资格</em> </a> <em class="ms">获得完全权限。</em></p></div></div>    
</body>
</html>