<html>
<head>
<title>Merging tables using SQL</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用SQL合并表</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/merging-tables-using-sql-a2e60ff687e9?source=collection_archive---------0-----------------------#2021-09-13">https://towardsdatascience.com/merging-tables-using-sql-a2e60ff687e9?source=collection_archive---------0-----------------------#2021-09-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="bb73" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">本文讨论了如何使用SQL通过行和列合并多个表，并给出了一些例子</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/149ab6467c56258987ed042a92961a05.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n_O8u0NPhG_QUK3FYVgsSA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="9095" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">实际上，很少会有只涉及一个表的SQL查询。我们可能需要按行(记录)或列(字段)合并多个表，以获得所需的结果。在本文中，我们将讨论SQL中的操作符/命令，这些操作符/命令支持按行或列合并表。</p><h1 id="3981" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">按列合并表格</h1><p id="b3cf" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">在SQL中，可以使用联接通过列来合并多个表。联接基于指定的列(通常是一个表的主键和另一个表的外键)合并两个表。下面是SQL连接的一般语法。</p><pre class="kg kh ki kj gt mo mp mq mr aw ms bi"><span id="67da" class="mt ls iq mp b gy mu mv l mw mx"><strong class="mp ir">SELECT </strong><br/> *<br/>  <strong class="mp ir">FROM</strong> table_1<br/>   <strong class="mp ir">JOIN</strong> table_2<br/>    <strong class="mp ir">USING</strong> (id);</span></pre><p id="8f8e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在上面的语法中，<strong class="kx ir"> <em class="my"> table_1 </em> </strong>和<strong class="kx ir"> <em class="my"> table_2 </em> </strong>是带有key列的两个表(两个表中的匹配列)，<strong class="kx ir"> <em class="my"> id </em> </strong>。只有当键列在两个表中具有相同的名称时，我们才使用关键字<strong class="kx ir">和</strong>。否则，我们需要明确提到两个表的键列，如下所示。</p><pre class="kg kh ki kj gt mo mp mq mr aw ms bi"><span id="ee15" class="mt ls iq mp b gy mu mv l mw mx"><strong class="mp ir">SELECT</strong> <br/> *<br/>  <strong class="mp ir">FROM</strong> table_1 t1<br/>   <strong class="mp ir">JOIN</strong> table_2 t2<br/>    <strong class="mp ir">ON</strong> t1.t1_id = t2.t2_id;</span></pre><p id="6ab2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在上面的语法中，<strong class="kx ir"> <em class="my"> t1 </em> </strong>是<strong class="kx ir"> <em class="my"> table_1 </em> </strong>的别名，<strong class="kx ir"> <em class="my"> t2 </em> </strong>是<strong class="kx ir"> <em class="my"> table_2 </em> </strong>的别名。当两个表中键列的名称不相同时，我们需要使用关键字上的<strong class="kx ir">来匹配它们，如上所示。我们现在将讨论SQL中几个重要的连接。</strong></p><h2 id="cd69" class="mt ls iq bd lt mz na dn lx nb nc dp mb le nd ne md li nf ng mf lm nh ni mh nj bi translated">内部连接</h2><p id="a7b9" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">内部联接按列合并两个表，并只返回两个表中匹配的记录(基于指定的列)。在下面的查询结果中，我们可以看到只返回了<strong class="kx ir"> <em class="my"> left_table </em> </strong>和<strong class="kx ir"> <em class="my"> right_table </em> </strong>中id  相同的记录。</p><pre class="kg kh ki kj gt mo mp mq mr aw ms bi"><span id="f4af" class="mt ls iq mp b gy mu mv l mw mx"><strong class="mp ir">SELECT </strong><br/> *<br/>  <strong class="mp ir">FROM</strong> left_table<br/>   <strong class="mp ir">INNER JOIN</strong> right_table<br/>    <strong class="mp ir">USING </strong>(id);</span></pre><p id="6d93" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">或</strong></p><pre class="kg kh ki kj gt mo mp mq mr aw ms bi"><span id="9738" class="mt ls iq mp b gy mu mv l mw mx"><strong class="mp ir">SELECT </strong><br/> *<br/>  <strong class="mp ir">FROM</strong> left_table l<br/>   <strong class="mp ir">INNER JOIN</strong> right_table r<br/>    <strong class="mp ir">ON</strong> l.id = r.id;</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nk"><img src="../Images/c3b0499f4e39e31ee7566b9be46932d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f-x7RIbxMOaQ_zTWiybzNQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">内部连接(作者图片)</p></figure><h2 id="fae6" class="mt ls iq bd lt mz na dn lx nb nc dp mb le nd ne md li nf ng mf lm nh ni mh nj bi translated">左连接</h2><p id="f2fe" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">Left join按列合并两个表，并返回左表中的所有记录，但只返回右表中的匹配记录(基于指定的列)。在下面的查询结果中，我们可以看到两个表中id为<strong class="kx ir"><em class="my"/></strong>的记录以及<strong class="kx ir"> <em class="my"> left_table </em> </strong>的所有记录。<strong class="kx ir"> <em class="my">中记录右_表</em> </strong>中没有匹配的<strong class="kx ir"><em class="my">id</em></strong><em class="my"/><strong class="kx ir"><em class="my">左_表</em> </strong>中有空值。</p><pre class="kg kh ki kj gt mo mp mq mr aw ms bi"><span id="0637" class="mt ls iq mp b gy mu mv l mw mx"><strong class="mp ir">SELECT </strong><br/> *<br/>  <strong class="mp ir">FROM</strong> left_table<br/>   <strong class="mp ir">LEFT</strong> <strong class="mp ir">JOIN</strong> right_table<br/>    <strong class="mp ir">USING </strong>(id);</span></pre><p id="6962" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">或</strong></p><pre class="kg kh ki kj gt mo mp mq mr aw ms bi"><span id="36f1" class="mt ls iq mp b gy mu mv l mw mx"><strong class="mp ir">SELECT </strong><br/> *<br/>  <strong class="mp ir">FROM</strong> left_table l<br/>   <strong class="mp ir">LEFT</strong> <strong class="mp ir">JOIN</strong> right_table r<br/>    <strong class="mp ir">ON</strong> l.id = r.id;</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nk"><img src="../Images/a3070933dea09f61df077f953bbbc1fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vWqjEUH5D9kxd4xAktuS3g.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">左连接(图片由作者提供)</p></figure><h2 id="749c" class="mt ls iq bd lt mz na dn lx nb nc dp mb le nd ne md li nf ng mf lm nh ni mh nj bi translated">右连接</h2><p id="a8cf" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">Right join按列合并两个表，并返回右表中的所有记录，但只返回左表中的匹配记录(基于指定的列)。在下面的查询结果中，我们可以看到两个表中具有相同<strong class="kx ir"> <em class="my"> id </em> </strong>的记录以及<strong class="kx ir"> <em class="my"> right_table </em> </strong>的所有记录。<strong class="kx ir"> <em class="my">中的记录左_表</em> </strong>中没有匹配的<strong class="kx ir"><em class="my">id</em></strong><em class="my"/><strong class="kx ir"><em class="my">右_表</em> </strong>中有空值。</p><pre class="kg kh ki kj gt mo mp mq mr aw ms bi"><span id="2fd4" class="mt ls iq mp b gy mu mv l mw mx"><strong class="mp ir">SELECT </strong><br/> *<br/>  <strong class="mp ir">FROM</strong> left_table<br/>   <strong class="mp ir">RIGHT</strong> <strong class="mp ir">JOIN</strong> right_table<br/>    <strong class="mp ir">USING </strong>(id);</span></pre><p id="925f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">或</strong></p><pre class="kg kh ki kj gt mo mp mq mr aw ms bi"><span id="6b91" class="mt ls iq mp b gy mu mv l mw mx"><strong class="mp ir">SELECT </strong><br/> *<br/>  <strong class="mp ir">FROM</strong> left_table l<br/>   <strong class="mp ir">RIGHT</strong> <strong class="mp ir">JOIN</strong> right_table r<br/>    <strong class="mp ir">ON</strong> l.id = r.id;</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nk"><img src="../Images/055ad500bb86360e17d5e91e13e0759d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZcZwKvWG5v1uVlh_Ux4FgA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">右连接(作者图片)</p></figure><h2 id="1ace" class="mt ls iq bd lt mz na dn lx nb nc dp mb le nd ne md li nf ng mf lm nh ni mh nj bi translated">完全连接</h2><p id="f386" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">完全连接可以被认为是左连接和右连接的组合。完全联接按列合并两个表，并返回左表和右表中的所有记录。在下面的查询结果中，我们可以看到两个表的所有记录都被返回。另一个表中没有匹配<strong class="kx ir"> <em class="my"> id </em> </strong>的记录为空。</p><pre class="kg kh ki kj gt mo mp mq mr aw ms bi"><span id="12df" class="mt ls iq mp b gy mu mv l mw mx"><strong class="mp ir">SELECT </strong><br/> *<br/>  <strong class="mp ir">FROM</strong> left_table<br/>   <strong class="mp ir">FULL</strong> <strong class="mp ir">JOIN</strong> right_table<br/>    <strong class="mp ir">USING </strong>(id);</span></pre><p id="ebd7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">或</strong></p><pre class="kg kh ki kj gt mo mp mq mr aw ms bi"><span id="f621" class="mt ls iq mp b gy mu mv l mw mx"><strong class="mp ir">SELECT </strong><br/> *<br/>  <strong class="mp ir">FROM</strong> left_table l<br/>   <strong class="mp ir">FULL</strong> <strong class="mp ir">JOIN</strong> right_table r<br/>    <strong class="mp ir">ON</strong> l.id = r.id;</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nk"><img src="../Images/9a44cffd991ea5f9180ee915d53bfefb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tn_gD2iZsK_rY2Nc7lATfg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">完全加入(图片由作者提供)</p></figure><h2 id="4de2" class="mt ls iq bd lt mz na dn lx nb nc dp mb le nd ne md li nf ng mf lm nh ni mh nj bi translated">交叉连接</h2><p id="27c0" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">交叉连接返回两个表的笛卡尔积。两个集合的笛卡尔积A = {1，2}，B = {3，4}是A x B = {(1，3)，(1，4)，(2，3)，(2，4)}。我们不需要在交叉连接中指定键列。</p><pre class="kg kh ki kj gt mo mp mq mr aw ms bi"><span id="425a" class="mt ls iq mp b gy mu mv l mw mx"><strong class="mp ir">SELECT</strong> <br/> *<br/>  <strong class="mp ir">FROM</strong> left_table<br/>   <strong class="mp ir">CROSS JOIN</strong> right_table</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nl"><img src="../Images/cc672200334d013a7de574bb851dfea6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h2Xlk4Qb71gAAn7qy84XUQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">交叉连接(图片由作者提供)</p></figure><h2 id="71f0" class="mt ls iq bd lt mz na dn lx nb nc dp mb le nd ne md li nf ng mf lm nh ni mh nj bi translated">半连接</h2><p id="3721" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">从技术上讲，半连接不是SQL连接，但其工作方式类似于连接。Semi join根据右表中的键列返回左表中的匹配记录。半连接在查询结果中不包括右表的列。在下面的例子中，我们要返回来自<strong class="kx ir"> <em class="my">左_表</em><em class="my"/>中的记录，匹配<em class="my"/><strong class="kx ir"><em class="my">id</em></strong><em class="my"/><em class="my"/><strong class="kx ir"><em class="my">右_表</em> </strong> <em class="my">。</em>换句话说，我们希望<em class="my"> </em> <strong class="kx ir"> <em class="my">中的记录出现在</em></strong><em class="my"/>left _ table<em class="my"/><strong class="kx ir"><em class="my">id</em></strong><em class="my"/>中<em class="my"/><strong class="kx ir"><em class="my">right _ table</em></strong><em class="my">。</em></strong></p><pre class="kg kh ki kj gt mo mp mq mr aw ms bi"><span id="238b" class="mt ls iq mp b gy mu mv l mw mx"><strong class="mp ir">SELECT</strong> <br/> * <br/>  <strong class="mp ir">FROM</strong> left_table<br/>  <strong class="mp ir">WHERE</strong> <br/>   id <strong class="mp ir">IN</strong> <br/>   (<br/>    <strong class="mp ir">SELECT</strong> id <strong class="mp ir">FROM</strong> right_table<br/>   )</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nm"><img src="../Images/16617f541dae0f0b9abc969be714b110.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jmMJ12OA-PhWOEiZz4i4ZA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">半连接(图片由作者提供)</p></figure><h2 id="a75d" class="mt ls iq bd lt mz na dn lx nb nc dp mb le nd ne md li nf ng mf lm nh ni mh nj bi translated">反连接</h2><p id="e808" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">从技术上讲，反联接也不是SQL联接，但其工作方式类似于联接。Anti join根据右表中的键列返回左表中不匹配的记录。反联接在查询结果中也不包括右表的列。在下面的例子中，我们要返回来自<strong class="kx ir"> <em class="my">左_表</em> </strong> <em class="my"> </em>中id<em class="my">与id<strong class="kx ir"><em class="my"/></strong><em class="my"/><em class="my"/><em class="my"/><strong class="kx ir"><em class="my">右_表</em> </strong> <em class="my">的记录。</em>换句话说，我们要的记录在<em class="my"/><strong class="kx ir"><em class="my">left _ table</em></strong><em class="my"/>who<em class="my"/><strong class="kx ir"><em class="my">id</em></strong><em class="my"/>中不存在于<em class="my"/><strong class="kx ir"><em class="my">right _ table</em></strong><em class="my">。</em></em></p><pre class="kg kh ki kj gt mo mp mq mr aw ms bi"><span id="92fd" class="mt ls iq mp b gy mu mv l mw mx"><strong class="mp ir">SELECT </strong><br/> * <br/>  <strong class="mp ir">FROM</strong> left_table<br/>  <strong class="mp ir">WHERE</strong> <br/>   id<br/>    <strong class="mp ir">NOT IN</strong> <br/>     (<br/>      <strong class="mp ir">SELECT</strong> id <strong class="mp ir">FROM</strong> right_table<br/>     )</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nm"><img src="../Images/01c8a6b81171bcf3255354e8fb9953ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*guSDQgc4_6NVbIpTijat2g.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">反对加入(图片由作者提供)</p></figure><h2 id="eba1" class="mt ls iq bd lt mz na dn lx nb nc dp mb le nd ne md li nf ng mf lm nh ni mh nj bi translated">自连接</h2><p id="757e" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">自联接使我们能够将一个表与其自身联接起来。在下面的查询中，我们需要找到具有相同<strong class="kx ir"> <em class="my">左</em> </strong>值的记录。为此，我们将表与自身连接起来，过滤掉具有相同<strong class="kx ir"><em class="my"/></strong>值但不同<strong class="kx ir"> <em class="my"> id </em> </strong>的记录。</p><pre class="kg kh ki kj gt mo mp mq mr aw ms bi"><span id="4339" class="mt ls iq mp b gy mu mv l mw mx"><strong class="mp ir">SELECT</strong> <br/> *<br/>  <strong class="mp ir">FROM</strong> left_table l1, left_table l2<br/>  <strong class="mp ir">WHERE</strong> <br/>   l1.left = l2.left<br/>   <strong class="mp ir">AND</strong> <br/>   l1.id &lt;&gt; l2.id<br/>  <strong class="mp ir">ORDER BY</strong> l1.left</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/439efbf3b69cfa4c3d211824d032a017.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/format:webp/1*uTO9YD8A1A9_ivbLznImZw.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">自连接(图片由作者提供)</p></figure></div><div class="ab cl no np hu nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="ij ik il im in"><h1 id="a618" class="lr ls iq bd lt lu nv lw lx ly nw ma mb jw nx jx md jz ny ka mf kc nz kd mh mi bi translated">按行合并表格</h1><h2 id="6989" class="mt ls iq bd lt mz na dn lx nb nc dp mb le nd ne md li nf ng mf lm nh ni mh nj bi translated">联盟</h2><p id="4d95" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">Union按行合并两个表，前提是一个表的列的数据类型与另一个表的列的数据类型相匹配。我们不能将列数据类型为integer和text的表与列数据类型为text和integer的表合并。然而，我们可以合并两个表，即使一个表的列名与另一个表的列名不匹配。Union只返回两个表的唯一记录。</p><pre class="kg kh ki kj gt mo mp mq mr aw ms bi"><span id="685a" class="mt ls iq mp b gy mu mv l mw mx">(<br/> <strong class="mp ir">SELECT</strong> <br/>  * <br/>   <strong class="mp ir">FROM</strong> left_table<br/>)<br/><strong class="mp ir">UNION</strong><br/>(<br/> <strong class="mp ir">SELECT</strong> <br/>  * <br/>   <strong class="mp ir">FROM</strong> right_table<br/>)</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oa"><img src="../Images/612b360a3b0adf882441f5ee67b9f020.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T7gX8ZGZ9J2RIQzlH8iD5Q.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">工会(图片由作者提供)</p></figure><h2 id="54f0" class="mt ls iq bd lt mz na dn lx nb nc dp mb le nd ne md li nf ng mf lm nh ni mh nj bi translated">联合所有</h2><p id="a4fa" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">与Union类似，Union All也按行合并表。与Union不同，Union All保留两个表的重复记录。在下面的查询结果中，我们合并了<strong class="kx ir"> <em class="my">的<strong class="kx ir"><em class="my">id</em></strong>left _ table</em></strong>和<strong class="kx ir"> <em class="my"> right_table。我们可以在结果中看到一些重复。</em></strong></p><pre class="kg kh ki kj gt mo mp mq mr aw ms bi"><span id="135f" class="mt ls iq mp b gy mu mv l mw mx">(<br/> <strong class="mp ir">SELECT</strong> <br/>  id <br/>   <strong class="mp ir">FROM</strong> left_table<br/>)<br/><strong class="mp ir">UNION ALL</strong><br/>(<br/> <strong class="mp ir">SELECT</strong> <br/>  id <br/>   <strong class="mp ir">FROM</strong> right_table<br/>)</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oa"><img src="../Images/ed741a6e3841661b7bc6fa8405748fc7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CIetVVChn828qKl-c2pXLw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">联合所有(图片由作者提供)</p></figure><h2 id="128c" class="mt ls iq bd lt mz na dn lx nb nc dp mb le nd ne md li nf ng mf lm nh ni mh nj bi translated">横断</h2><p id="22f3" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">Intersect返回两个表的公共记录。在下面的查询结果中，我们可以看到常见的<strong class="kx ir"><em class="my">id</em></strong>s<strong class="kx ir"><em class="my">left _ table</em></strong>和<strong class="kx ir"> <em class="my"> right_table </em> </strong>。</p><pre class="kg kh ki kj gt mo mp mq mr aw ms bi"><span id="c429" class="mt ls iq mp b gy mu mv l mw mx">(<br/> <strong class="mp ir">SELECT </strong><br/>  id <br/>   <strong class="mp ir">FROM</strong> left_table<br/>)<br/><strong class="mp ir">INTERSECT</strong><br/>(<br/> <strong class="mp ir">SELECT</strong> <br/>  id <br/>   <strong class="mp ir">FROM</strong> right_table<br/>)</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oa"><img src="../Images/582c438f44b9e64cb9eb17bf38e3378c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yhhOuNuemOXeUx6wgPesfw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">相交(作者图片)</p></figure><h2 id="0e32" class="mt ls iq bd lt mz na dn lx nb nc dp mb le nd ne md li nf ng mf lm nh ni mh nj bi translated">除...之外</h2><p id="fad5" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">Except返回第一个表(左表)中不存在于第二个表(右表)中的记录。在下面的查询结果中，我们可以看到<strong class="kx ir"> <em class="my"> left_table </em> </strong>的<strong class="kx ir"> <em class="my"> id </em> </strong> s在<strong class="kx ir"> <em class="my"> right_table </em> </strong>中没有。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oa"><img src="../Images/c85b6d9a00a4d06c4561ce1ad8aaadc8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2mCoyiPf-DdSt49pfbA0-Q.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">除外(图片由作者提供)</p></figure></div><div class="ab cl no np hu nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="ij ik il im in"><h1 id="11dc" class="lr ls iq bd lt lu nv lw lx ly nw ma mb jw nx jx md jz ny ka mf kc nz kd mh mi bi translated">示例查询</h1><p id="b20c" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">我们将使用从<a class="ae ob" href="https://www.postgresqltutorial.com/postgresql-sample-database/" rel="noopener ugc nofollow" target="_blank">这里</a>下载的dvd_rental数据库并恢复它。下面是在PostgreSQL中恢复数据库的文档。</p><div class="oc od gp gr oe of"><a href="https://www.pgadmin.org/docs/pgadmin4/development/restore_dialog.html" rel="noopener  ugc nofollow" target="_blank"><div class="og ab fo"><div class="oh ab oi cl cj oj"><h2 class="bd ir gy z fp ok fr fs ol fu fw ip bi translated">还原对话框- pgAdmin 4 5.2文档</h2><div class="om l"><h3 class="bd b gy z fp ok fr fs ol fu fw dk translated">“还原”对话框提供了一种简单的方法来使用自定义、tar或目录格式的备份，这些备份是通过pgAdmin对话框进行的…</h3></div><div class="on l"><p class="bd b dl z fp ok fr fs ol fu fw dk translated">www.pgadmin.org</p></div></div></div></a></div><h2 id="f32d" class="mt ls iq bd lt mz na dn lx nb nc dp mb le nd ne md li nf ng mf lm nh ni mh nj bi translated">1.五大常客</h2><p id="befa" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">在本例中，我们需要找到租赁最多的前5名客户。为此，我们将</p><ol class=""><li id="8094" class="oo op iq kx b ky kz lb lc le oq li or lm os lq ot ou ov ow bi translated">使用<strong class="kx ir"> <em class="my"> customer_id </em> </strong>连接<strong class="kx ir"> <em class="my">客户</em> </strong>和<strong class="kx ir"> <em class="my">租赁</em> </strong>表。</li><li id="5821" class="oo op iq kx b ky ox lb oy le oz li pa lm pb lq ot ou ov ow bi translated">通过分组<strong class="kx ir"><em class="my">【customer _ id】</em></strong><em class="my">对客户进行计数(如<strong class="kx ir"> <em class="my"> rental_count </em> </strong>)。</em></li><li id="539a" class="oo op iq kx b ky ox lb oy le oz li pa lm pb lq ot ou ov ow bi translated">按照<strong class="kx ir"> <em class="my"> rental_count </em> </strong>降序排列结果。</li><li id="7e98" class="oo op iq kx b ky ox lb oy le oz li pa lm pb lq ot ou ov ow bi translated">将结果限制为前5条记录。</li></ol><pre class="kg kh ki kj gt mo mp mq mr aw ms bi"><span id="613b" class="mt ls iq mp b gy mu mv l mw mx"><strong class="mp ir">SELECT</strong> <br/>  c.customer_id,<br/>  c.first_name,<br/>  c.last_name, <br/>  <strong class="mp ir">COUNT</strong>(c.customer_id) <strong class="mp ir">AS</strong> rental_count<br/>  <strong class="mp ir">FROM</strong> customer c<br/>    <strong class="mp ir">INNER JOIN</strong> rental r<br/>      <strong class="mp ir">USING</strong> (customer_id)<br/>  <strong class="mp ir">GROUP BY</strong> customer_id<br/>  <strong class="mp ir">ORDER BY</strong> <br/>   <strong class="mp ir">COUNT</strong>(c.customer_id) <strong class="mp ir">DESC</strong><br/>  <strong class="mp ir">LIMIT</strong> 5;</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pc"><img src="../Images/06d9bfd756b8f79c8d68963186b1e32b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1288/format:webp/1*ehHvb7ekeG-GRjqn9GSSag.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure></div><div class="ab cl no np hu nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="ij ik il im in"><h2 id="fd69" class="mt ls iq bd lt mz na dn lx nb nc dp mb le nd ne md li nf ng mf lm nh ni mh nj bi translated">2.按产生的收入排列的前5名和后5名客户</h2><p id="8c29" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">在这个例子中，我们将使用通用表表达式(CTE)。使用cte，我们可以为特定查询创建临时表。下面是cte的官方Postgres文档。</p><div class="oc od gp gr oe of"><a href="https://www.postgresql.org/docs/9.1/queries-with.html" rel="noopener  ugc nofollow" target="_blank"><div class="og ab fo"><div class="oh ab oi cl cj oj"><h2 class="bd ir gy z fp ok fr fs ol fu fw ip bi translated">带查询(公共表表达式)</h2><div class="om l"><h3 class="bd b gy z fp ok fr fs ol fu fw dk translated">WITH提供了一种编写辅助语句的方法，以便在更大的查询中使用。这些经常被提及的陈述…</h3></div><div class="on l"><p class="bd b dl z fp ok fr fs ol fu fw dk translated">www.postgresql.org</p></div></div><div class="pd l"><div class="pe l pf pg ph pd pi kp of"/></div></div></a></div><p id="0818" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在本例中，我们需要找出收入最高的前5名和后5名客户。为此，我们将</p><p id="efbf" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">1.创建一个名为<strong class="kx ir">的CTE<em class="my">revenue _ per _ customer</em>by</strong></p><ul class=""><li id="aeab" class="oo op iq kx b ky kz lb lc le oq li or lm os lq pj ou ov ow bi translated">使用<strong class="kx ir"><em class="my">customer _ id</em></strong><em class="my"><em class="my">连接<strong class="kx ir"> <em class="my">客户</em><strong class="kx ir"><em class="my">租赁</em> </strong>表。</strong></em></em></li><li id="dae0" class="oo op iq kx b ky ox lb oy le oz li pa lm pb lq pj ou ov ow bi translated">使用<strong class="kx ir"> <em class="my">租金_id </em> </strong> <em class="my">将结果表与<strong class="kx ir"><em class="my"/></strong>付款表连接起来。</em></li><li id="da1f" class="oo op iq kx b ky ox lb oy le oz li pa lm pb lq pj ou ov ow bi translated">计算客户为每笔租赁交易支付的总金额(如<strong class="kx ir"> <em class="my"> total_amount </em> </strong>)按<strong class="kx ir"><em class="my">customer _ id</em></strong><em class="my">分组。</em></li><li id="fa9c" class="oo op iq kx b ky ox lb oy le oz li pa lm pb lq pj ou ov ow bi translated">最后，选择<strong class="kx ir"> <em class="my"> customer_id </em> </strong> <em class="my">，</em><strong class="kx ir"><em class="my">first _ name</em></strong><em class="my">，</em><strong class="kx ir"><em class="my">last _ name</em></strong>和<strong class="kx ir"><em class="my">total _ amount</em></strong><em class="my">。</em></li></ul><p id="f1ff" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">2.从上述CTE中按收入选择前5名客户</p><ul class=""><li id="c99f" class="oo op iq kx b ky kz lb lc le oq li or lm os lq pj ou ov ow bi translated">对<strong class="kx ir"> <em class="my">【收入_每_客户】</em></strong>【CTE结果】中的<strong class="kx ir"> <em class="my">合计_金额</em> </strong> <em class="my"> </em>进行降序排序。</li><li id="a85e" class="oo op iq kx b ky ox lb oy le oz li pa lm pb lq pj ou ov ow bi translated">将结果限制为前5条记录。</li><li id="f128" class="oo op iq kx b ky ox lb oy le oz li pa lm pb lq pj ou ov ow bi translated">添加注释，将记录指定为“前5条”。</li></ul><p id="f9a7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">3.根据上述CTE的收入选择排名后5位的客户</p><ul class=""><li id="752b" class="oo op iq kx b ky kz lb lc le oq li or lm os lq pj ou ov ow bi translated">对<strong class="kx ir"> <em class="my">【收入_每_客户】</em></strong>【CTE结果】中的<strong class="kx ir"> <em class="my">合计_金额</em> </strong> <em class="my"> </em>进行升序排序。</li><li id="a9e1" class="oo op iq kx b ky ox lb oy le oz li pa lm pb lq pj ou ov ow bi translated">将结果限制为前5条记录。</li><li id="4aed" class="oo op iq kx b ky ox lb oy le oz li pa lm pb lq pj ou ov ow bi translated">添加注释，将记录指定为“底部5”。</li></ul><p id="94f7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">4.使用<strong class="kx ir">合并上述两个结果。</strong></p><pre class="kg kh ki kj gt mo mp mq mr aw ms bi"><span id="f372" class="mt ls iq mp b gy mu mv l mw mx"><strong class="mp ir">WITH</strong> revenue_per_customer <strong class="mp ir">AS</strong> <br/> (<strong class="mp ir">SELECT</strong> <br/>   c.customer_id, <br/>   c.first_name,<br/>   c.last_name,<br/>   <strong class="mp ir">SUM</strong>(p.amount) <strong class="mp ir">AS</strong> "total_amount"<br/>   <strong class="mp ir">FROM</strong> customer c<br/>    <strong class="mp ir">INNER JOIN</strong> rental r<br/>     <strong class="mp ir">USING</strong> (customer_id)<br/>    <strong class="mp ir">INNER JOIN</strong> payment p<br/>     <strong class="mp ir">USING</strong> (rental_id)<br/>   <strong class="mp ir">GROUP BY</strong> c.customer_id)</span><span id="15c2" class="mt ls iq mp b gy pk mv l mw mx">(<strong class="mp ir">SELECT</strong> <br/>  *,<br/>  'Top 5' <strong class="mp ir">AS</strong> comment<br/>  <strong class="mp ir">FROM</strong> revenue_per_customer<br/>  <strong class="mp ir">ORDER BY</strong> total_amount <strong class="mp ir">DESC</strong><br/>  <strong class="mp ir">LIMIT</strong> 5)</span><span id="2b74" class="mt ls iq mp b gy pk mv l mw mx"><strong class="mp ir">UNION</strong></span><span id="4c85" class="mt ls iq mp b gy pk mv l mw mx">(<strong class="mp ir">SELECT</strong> <br/>  *,<br/>  'Bottom 5' <strong class="mp ir">AS</strong> comment<br/>  <strong class="mp ir">FROM</strong> revenue_per_customer<br/>  <strong class="mp ir">ORDER BY</strong> total_amount <strong class="mp ir">ASC</strong><br/>  <strong class="mp ir">LIMIT</strong> 5)<br/><strong class="mp ir">ORDER BY</strong> comment <strong class="mp ir">DESC</strong>, total_amount <strong class="mp ir">DESC</strong>;</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pl"><img src="../Images/72f73c2619669ce2c1fb5739b3027426.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VJv0bzxv8zyJ74WGsJkP1A.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="32c7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们也可以使用窗口函数得到上面的查询结果。下面是关于窗口函数的官方Postgres文档。</p><div class="oc od gp gr oe of"><a href="https://www.postgresql.org/docs/9.1/tutorial-window.html" rel="noopener  ugc nofollow" target="_blank"><div class="og ab fo"><div class="oh ab oi cl cj oj"><h2 class="bd ir gy z fp ok fr fs ol fu fw ip bi translated">窗口功能</h2><div class="om l"><h3 class="bd b gy z fp ok fr fs ol fu fw dk translated">窗口函数对一组与当前行有某种关系的表行执行计算。这个…</h3></div><div class="on l"><p class="bd b dl z fp ok fr fs ol fu fw dk translated">www.postgresql.org</p></div></div><div class="pd l"><div class="pm l pf pg ph pd pi kp of"/></div></div></a></div><p id="5f6d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了找出使用窗口函数产生最多收入的前5名和后5名客户，我们将</p><p id="29dc" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">1.创建一个名为<strong class="kx ir">T45】total _ AMT _ rankT47】的CTE</strong></p><ul class=""><li id="2556" class="oo op iq kx b ky kz lb lc le oq li or lm os lq pj ou ov ow bi translated">使用<strong class="kx ir"><em class="my">customer _ id</em></strong><em class="my">加入<strong class="kx ir"> <em class="my">客户</em> </strong>和<strong class="kx ir"> <em class="my">租赁</em> </strong>表。</em></li><li id="274d" class="oo op iq kx b ky ox lb oy le oz li pa lm pb lq pj ou ov ow bi translated">将结果表与<strong class="kx ir"> <em class="my">付款</em> </strong>表连接使用<strong class="kx ir"> <em class="my">租金_id </em> </strong> <em class="my">。</em></li><li id="aa1a" class="oo op iq kx b ky ox lb oy le oz li pa lm pb lq pj ou ov ow bi translated">计算客户为每笔租赁交易支付的总金额(如<strong class="kx ir"> <em class="my"> total_amount </em> </strong>)按<strong class="kx ir"><em class="my">customer _ id</em></strong><em class="my">分组。</em></li><li id="7b20" class="oo op iq kx b ky ox lb oy le oz li pa lm pb lq pj ou ov ow bi translated">最后，选择<strong class="kx ir"><em class="my">customer _ id</em></strong><em class="my">，</em> <strong class="kx ir">，<em class="my"> first_name </em> </strong> <em class="my">，</em><strong class="kx ir"><em class="my">last _ name</em></strong><em class="my">，</em><strong class="kx ir"><em class="my">total _ amount</em></strong><em class="my"/>和排名<strong class="kx ir"> <em class="my"> total_amount </em>这将等级1赋予最高金额，依此类推。</strong></li></ul><p id="3650" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">2.从上述CTE中选择<strong class="kx ir"><em class="my">total _ amount _ rank</em></strong><em class="my"/>在 1到5之间<strong class="kx ir">的客户，选择收入排名前5的客户。</strong></p><p id="f1bb" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">3.从上述CTE中按收入选择排名后5位的客户</p><ul class=""><li id="87ff" class="oo op iq kx b ky kz lb lc le oq li or lm os lq pj ou ov ow bi translated">将<strong class="kx ir"><em class="my">【total _ AMT _ rank</em></strong>【CTE结果】中的<strong class="kx ir"><em class="my">total _ amount _ rank</em></strong><em class="my"/>按降序排序。</li><li id="d611" class="oo op iq kx b ky ox lb oy le oz li pa lm pb lq pj ou ov ow bi translated">将结果限制为前5条记录。</li></ul><p id="c4c0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">4.使用<strong class="kx ir"> UNION合并上述两个结果。</strong></p><pre class="kg kh ki kj gt mo mp mq mr aw ms bi"><span id="7b78" class="mt ls iq mp b gy mu mv l mw mx"><strong class="mp ir">WITH</strong> total_amt_rank <strong class="mp ir">AS</strong><br/> (<br/>  <strong class="mp ir">SELECT</strong><br/>      c.customer_id, <br/>      c.first_name,<br/>      c.last_name,<br/>      <strong class="mp ir">SUM</strong>(p.amount) <strong class="mp ir">AS</strong> "total_amount",<br/>      <strong class="mp ir">RANK</strong>() <strong class="mp ir">OVER</strong> (<strong class="mp ir">ORDER BY SUM</strong>(p.amount) <strong class="mp ir">DESC</strong>) <strong class="mp ir">AS</strong> total_amount_rank<br/>       <strong class="mp ir">FROM</strong> customer c<br/>        <strong class="mp ir">INNER JOIN</strong> rental r<br/>          <strong class="mp ir">USING</strong> (customer_id)<br/>        <strong class="mp ir">INNER JOIN</strong> payment p<br/>          <strong class="mp ir">USING</strong> (rental_id)<br/>       <strong class="mp ir">GROUP BY</strong> c.customer_id<br/>  )<br/>(<br/> <strong class="mp ir">SELECT</strong> *<br/>  <strong class="mp ir">FROM</strong> total_amt_rank<br/>    <strong class="mp ir">WHERE</strong> <br/>     total_amount_rank <strong class="mp ir">BETWEEN</strong> 1 <strong class="mp ir">AND</strong> 5<br/>)<br/> <br/><strong class="mp ir">UNION</strong><br/> <br/>(<br/> <strong class="mp ir">SELECT</strong> *<br/>   <strong class="mp ir">FROM</strong> total_amt_rank<br/>    <strong class="mp ir">ORDER BY</strong> total_amount_rank <strong class="mp ir">DESC</strong><br/>  <strong class="mp ir">LIMIT</strong> 5<br/>)<br/> <br/><strong class="mp ir">ORDER BY</strong> total_amount_rank;</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pn"><img src="../Images/89bac1c78e04b4493535f8dbd532376f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9FEjMpA9c-HbOf3k3U2GwQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure></div><div class="ab cl no np hu nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="ij ik il im in"><h2 id="8add" class="mt ls iq bd lt mz na dn lx nb nc dp mb le nd ne md li nf ng mf lm nh ni mh nj bi translated">3.租金最高的前5个国家</h2><p id="57fe" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">在本例中，我们需要找到租金最高的前5个国家。为此，我们将</p><ol class=""><li id="8cb0" class="oo op iq kx b ky kz lb lc le oq li or lm os lq ot ou ov ow bi translated">使用<strong class="kx ir"> <em class="my"> country_id </em> </strong>加入<strong class="kx ir"> <em class="my"> country </em> </strong>和<strong class="kx ir"> <em class="my"> city </em> </strong>表。</li><li id="a993" class="oo op iq kx b ky ox lb oy le oz li pa lm pb lq ot ou ov ow bi translated">使用<strong class="kx ir"> <em class="my"> city_id </em> </strong>将结果表与<strong class="kx ir"> <em class="my">地址</em> </strong>表连接。</li><li id="3781" class="oo op iq kx b ky ox lb oy le oz li pa lm pb lq ot ou ov ow bi translated">使用<strong class="kx ir"> <em class="my"> address_id </em> </strong>将结果表与<em class="my">客户</em> 表连接起来。</li><li id="7e11" class="oo op iq kx b ky ox lb oy le oz li pa lm pb lq ot ou ov ow bi translated">使用<strong class="kx ir"> <em class="my"> customer_id </em> </strong>将结果表与<strong class="kx ir"> <em class="my">租赁</em> </strong>表连接起来。</li><li id="25be" class="oo op iq kx b ky ox lb oy le oz li pa lm pb lq ot ou ov ow bi translated">计数<strong class="kx ir"> <em class="my"> country_id </em> </strong>(为<strong class="kx ir"> <em class="my">出租_计数</em> </strong>)按分组<strong class="kx ir"><em class="my">country _ id</em></strong><em class="my">。</em>我们也可以用<strong class="kx ir"><em class="my">rental _ id</em></strong><em class="my"/>来得到<em class="my"/><strong class="kx ir"><em class="my">rental _ count</em></strong><em class="my">。</em></li><li id="2a24" class="oo op iq kx b ky ox lb oy le oz li pa lm pb lq ot ou ov ow bi translated">按<strong class="kx ir"> <em class="my"> rental_count </em> </strong>降序排列结果。</li><li id="8a39" class="oo op iq kx b ky ox lb oy le oz li pa lm pb lq ot ou ov ow bi translated">将结果限制为5条记录。</li></ol><pre class="kg kh ki kj gt mo mp mq mr aw ms bi"><span id="298c" class="mt ls iq mp b gy mu mv l mw mx"><strong class="mp ir">SELECT</strong> <br/> co.country_id, <br/> co.country,<br/> <strong class="mp ir">COUNT</strong>(co.country_id) <strong class="mp ir">AS</strong> rental_count<br/>  <strong class="mp ir">FROM</strong> country co<br/>   <strong class="mp ir">INNER JOIN</strong> city ci<br/>    <strong class="mp ir">USING</strong> (country_id)<br/>   <strong class="mp ir">INNER JOIN</strong> address a<br/>    <strong class="mp ir">USING </strong>(city_id)<br/>   <strong class="mp ir">INNER JOIN</strong> customer cu<br/>    <strong class="mp ir">USING</strong> (address_id)<br/>   <strong class="mp ir">INNER JOIN</strong> rental r<br/>    <strong class="mp ir">USING</strong> (customer_id)<br/>  <strong class="mp ir">GROUP BY</strong> co.country_id<br/>  <strong class="mp ir">ORDER BY</strong> <br/>   <strong class="mp ir">COUNT</strong>(co.country_id) <strong class="mp ir">DESC</strong><br/>  <strong class="mp ir">LIMIT</strong> 5;</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi po"><img src="../Images/a45390713168ed6a46b0c032dc3a6572.png" data-original-src="https://miro.medium.com/v2/resize:fit:892/format:webp/1*lzMlSzM4js2qnsEnJgyILg.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="e602" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">有几个地址和城市没有客户。使用inner join可以省略这些记录。在下面的查询中，我们将看看在使用left join时，结果如何包括没有客户的地址。</p></div><div class="ab cl no np hu nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="ij ik il im in"><h2 id="7476" class="mt ls iq bd lt mz na dn lx nb nc dp mb le nd ne md li nf ng mf lm nh ni mh nj bi translated">4.没有客户的城市/地址？</h2><p id="3a21" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">有几个城市和地址没有任何客户(这些可能是商店地址)。使用内部连接会将它们从结果中忽略，因为在另一个表中没有匹配的条目。例如，加拿大一个名为伦敦的城市在地址表中没有匹配的<strong class="kx ir"> <em class="my"> city_id </em> </strong>。使用inner join会从结果中忽略加拿大的伦敦。同样，加拿大和澳大利亚的四个地址在<strong class="kx ir"> <em class="my">客户</em> </strong>表中没有匹配的<strong class="kx ir"> <em class="my"> address_id </em> </strong>。</p><pre class="kg kh ki kj gt mo mp mq mr aw ms bi"><span id="9e92" class="mt ls iq mp b gy mu mv l mw mx"><strong class="mp ir">SELECT</strong> <br/> co.country, <br/> ci.city, <br/> a.address, <br/> cu.customer_id <br/>  <strong class="mp ir">FROM</strong> country co<br/>   <strong class="mp ir">LEFT JOIN</strong> city ci<br/>    <strong class="mp ir">USING</strong> (country_id)<br/>   <strong class="mp ir">LEFT JOIN</strong> address a<br/>    <strong class="mp ir">USING</strong> (city_id)<br/>   <strong class="mp ir">LEFT JOIN</strong> customer cu<br/>    <strong class="mp ir">USING </strong>(address_id)<br/>  <strong class="mp ir">WHERE</strong> cu.address_id <strong class="mp ir">IS NULL</strong>;</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pp"><img src="../Images/350371ae458ef58fbf53fe640df39023.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Jyg6pu8pZe6YDprE_rnVQA.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure></div><div class="ab cl no np hu nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="ij ik il im in"><h2 id="ed6d" class="mt ls iq bd lt mz na dn lx nb nc dp mb le nd ne md li nf ng mf lm nh ni mh nj bi translated">5.没有客户的国家</h2><p id="82ef" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">在本例中，我们将通过查找没有客户的国家</p><p id="6ade" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">1.通过创建子查询来查找至少有一个客户的国家</p><ul class=""><li id="9f52" class="oo op iq kx b ky kz lb lc le oq li or lm os lq pj ou ov ow bi translated">加入<strong class="kx ir"> <em class="my">国家</em> </strong>表与<strong class="kx ir"> <em class="my">城市</em> </strong>表使用<strong class="kx ir"> <em class="my">国家_id </em> </strong> <em class="my">。</em></li><li id="726b" class="oo op iq kx b ky ox lb oy le oz li pa lm pb lq pj ou ov ow bi translated">使用<strong class="kx ir"> <em class="my"> city_id </em> </strong>将余数表与<strong class="kx ir"> <em class="my">地址</em> </strong>表连接起来。</li><li id="1544" class="oo op iq kx b ky ox lb oy le oz li pa lm pb lq pj ou ov ow bi translated">使用<strong class="kx ir"> <em class="my"> address_id </em> </strong>将剩余表与<strong class="kx ir"> <em class="my">客户</em> </strong>表连接。</li></ul><p id="11a1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">2.从<em class="my"> </em> <strong class="kx ir"> <em class="my">国家</em> </strong> <em class="my"> </em>表中选择<strong class="kx ir"> <em class="my">国家</em></strong><em class="my"><em class="my">国家</em> <strong class="kx ir"> <em class="my">国家_id </em> </strong> <em class="my"> </em>不在上述子查询的<strong class="kx ir"> <em class="my">国家_id </em> </strong> <em class="my"> </em>中。</em></p><pre class="kg kh ki kj gt mo mp mq mr aw ms bi"><span id="8024" class="mt ls iq mp b gy mu mv l mw mx"><strong class="mp ir">SELECT </strong><br/> country <br/>    <strong class="mp ir">FROM</strong> country<br/>     <strong class="mp ir">WHERE</strong> country_id <br/>       <strong class="mp ir">NOT IN</strong> <br/>        (<br/>         <strong class="mp ir">SELECT</strong> <br/>          co.country_id<br/>           <strong class="mp ir">FROM</strong> country co<br/>            <strong class="mp ir">INNER JOIN</strong> city ci<br/>              <strong class="mp ir">USING</strong> (country_id)<br/>            <strong class="mp ir">INNER JOIN</strong> address a<br/>              <strong class="mp ir">USING</strong> (city_id)<br/>            <strong class="mp ir">INNER JOIN</strong> customer<br/>              <strong class="mp ir">USING</strong> (address_id)<br/>        );</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pq"><img src="../Images/da1a65682d88055d37bc7f969e3316c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:386/format:webp/1*TFQoL28TekNVciBllUu9ow.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure></div><div class="ab cl no np hu nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="ij ik il im in"><h2 id="c5bf" class="mt ls iq bd lt mz na dn lx nb nc dp mb le nd ne md li nf ng mf lm nh ni mh nj bi translated">6.澳大利亚有商店吗？</h2><p id="01a4" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">在上面的例子中，我们看到澳大利亚没有客户。在本例中，我们将查看澳大利亚是否有商店</p><ol class=""><li id="d114" class="oo op iq kx b ky kz lb lc le oq li or lm os lq ot ou ov ow bi translated">加入<strong class="kx ir"> <em class="my">国家</em> </strong>表与<strong class="kx ir"> <em class="my">城市</em> </strong>表使用<strong class="kx ir"> <em class="my">国家_id </em> </strong>。</li><li id="486a" class="oo op iq kx b ky ox lb oy le oz li pa lm pb lq ot ou ov ow bi translated">使用<strong class="kx ir"> <em class="my"> city_id </em> </strong>将结果表与<strong class="kx ir"> <em class="my">地址</em> </strong>表连接起来。</li><li id="6d6b" class="oo op iq kx b ky ox lb oy le oz li pa lm pb lq ot ou ov ow bi translated">使用<strong class="kx ir"> <em class="my"> address_id </em> </strong>将结果表与<strong class="kx ir"> <em class="my"> store </em> </strong>表连接。</li><li id="c779" class="oo op iq kx b ky ox lb oy le oz li pa lm pb lq ot ou ov ow bi translated">选择在澳大利亚<strong class="kx ir"><em class="my">store _ id</em></strong><strong class="kx ir">不为空</strong>的记录。</li></ol><p id="4bea" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">Left join确保没有城市的国家和没有商店的城市也包含在查询结果中。</p><pre class="kg kh ki kj gt mo mp mq mr aw ms bi"><span id="552f" class="mt ls iq mp b gy mu mv l mw mx"><strong class="mp ir">SELECT </strong><br/> st.store_id, <br/> co.country, <br/> ad.address<br/>  <strong class="mp ir">FROM</strong> country co<br/>   <strong class="mp ir">LEFT JOIN</strong> city ci<br/>    <strong class="mp ir">USING</strong> (country_id)<br/>   <strong class="mp ir">LEFT JOIN</strong> address ad<br/>    <strong class="mp ir">USING</strong> (city_id)<br/>   <strong class="mp ir">LEFT JOIN</strong> store st<br/>    <strong class="mp ir">USING</strong> (address_id)<br/>  <strong class="mp ir">WHERE</strong> <br/>   (st.store_id <strong class="mp ir">IS NOT NULL</strong>) <br/>    <strong class="mp ir">AND</strong> <br/>     (co.country = 'Australia');</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pr"><img src="../Images/b56f9831b154d90616560a533ab0c582.png" data-original-src="https://miro.medium.com/v2/resize:fit:1022/format:webp/1*bteclpfo_AX6jsX2EkXPJw.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="841c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">澳大利亚有一家商店。事实上，整个数据库中只有两家商店。我们将使用下面的查询来查看它们。</p><pre class="kg kh ki kj gt mo mp mq mr aw ms bi"><span id="ccac" class="mt ls iq mp b gy mu mv l mw mx"><strong class="mp ir">SELECT </strong>* <strong class="mp ir">FROM</strong> store;</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ps"><img src="../Images/6a7866edd3b100ba74b3eeb544aca889.png" data-original-src="https://miro.medium.com/v2/resize:fit:1374/format:webp/1*HeIGT8PxRUzwbt9OlMZVjw.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure></div><div class="ab cl no np hu nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="ij ik il im in"><h2 id="6c46" class="mt ls iq bd lt mz na dn lx nb nc dp mb le nd ne md li nf ng mf lm nh ni mh nj bi translated">7.没有电影的语言</h2><p id="b381" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">在这个例子中，我们将看看是否有没有电影的语言</p><ol class=""><li id="8f6b" class="oo op iq kx b ky kz lb lc le oq li or lm os lq ot ou ov ow bi translated">加入<strong class="kx ir"> <em class="my">语言</em> </strong>表格与<strong class="kx ir"> <em class="my">电影</em> </strong>表格使用<strong class="kx ir"> <em class="my">语言_id </em> </strong>。左连接确保没有任何电影的语言也包括在内。</li><li id="a3a8" class="oo op iq kx b ky ox lb oy le oz li pa lm pb lq ot ou ov ow bi translated">过滤<strong class="kx ir"> <em class="my"> film_id </em>为空</strong>的记录。</li></ol><pre class="kg kh ki kj gt mo mp mq mr aw ms bi"><span id="1c41" class="mt ls iq mp b gy mu mv l mw mx"><strong class="mp ir">SELECT </strong><br/> *<br/>  <strong class="mp ir">FROM</strong> language l<br/>   <strong class="mp ir">LEFT JOIN</strong> film f<br/>    <strong class="mp ir">USING</strong> (language_id)<br/>  <strong class="mp ir">WHERE</strong> f.film_id <strong class="mp ir">IS NULL</strong>;</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pt"><img src="../Images/ba6951635b9ed0cb7040c48bcc488f41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ag3-OydScGVUa2CVLOG5_Q.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="6382" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们看到一些语言在数据库中没有电影。我们将通过从<strong class="kx ir"> <em class="my">电影</em> </strong>表中选择(2，3，4，5，6)中带有<strong class="kx ir"> <em class="my"> language_id </em> </strong>的电影来确保这不是一个错误。查询结果不应返回任何记录。</p><pre class="kg kh ki kj gt mo mp mq mr aw ms bi"><span id="93c7" class="mt ls iq mp b gy mu mv l mw mx"><strong class="mp ir">SELECT </strong><br/> * <br/>  <strong class="mp ir">FROM</strong> film<br/>   <strong class="mp ir">WHERE</strong> language_id <strong class="mp ir">IN</strong> (2,3,4,5,6);</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pu"><img src="../Images/12fcfb369b3b7ad274e6695f19b56f91.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H5x-wm2aagBCrtsNmd-u2g.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure></div><div class="ab cl no np hu nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="ij ik il im in"><h2 id="95bf" class="mt ls iq bd lt mz na dn lx nb nc dp mb le nd ne md li nf ng mf lm nh ni mh nj bi translated">8.电影在印度的受欢迎程度</h2><p id="6182" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">在本例中，我们将通过连接前面的示例和中讨论的所需表来查找印度每个电影类别的租赁数量</p><ol class=""><li id="f975" class="oo op iq kx b ky kz lb lc le oq li or lm os lq ot ou ov ow bi translated">按<strong class="kx ir"> <em class="my">国家</em> </strong>和<strong class="kx ir"> <em class="my">类别</em> </strong>分组，过滤来自印度的记录，统计电影类别名称(如<strong class="kx ir"><em class="my">film _ category _ count</em></strong>)。</li><li id="a69b" class="oo op iq kx b ky ox lb oy le oz li pa lm pb lq ot ou ov ow bi translated">按国家升序排序结果，按<strong class="kx ir"> <em class="my">降序排序</em> </strong>电影_类别_数量。</li></ol><pre class="kg kh ki kj gt mo mp mq mr aw ms bi"><span id="741f" class="mt ls iq mp b gy mu mv l mw mx"><strong class="mp ir">SELECT</strong> <br/> co.country, <br/> cat.name <strong class="mp ir">AS</strong> film_category,<br/> <strong class="mp ir">COUNT</strong>(cat.name) <strong class="mp ir">AS</strong> film_category_count<br/>  <strong class="mp ir">FROM</strong> country co<br/>   <strong class="mp ir">INNER JOIN</strong> city ci<br/>    <strong class="mp ir">USING</strong> (country_id)<br/>   <strong class="mp ir">INNER JOIN</strong> address ad<br/>    <strong class="mp ir">USING</strong> (city_id)<br/>   <strong class="mp ir">INNER JOIN</strong> customer cu<br/>    <strong class="mp ir">USING</strong> (address_id)<br/>   <strong class="mp ir">INNER JOIN</strong> rental re<br/>    <strong class="mp ir">USING</strong> (customer_id)<br/>   <strong class="mp ir">INNER JOIN</strong> inventory inv<br/>    <strong class="mp ir">USING</strong> (inventory_id)<br/>   <strong class="mp ir">INNER JOIN</strong> film fi<br/>    <strong class="mp ir">USING</strong> (film_id)<br/>   <strong class="mp ir">INNER JOIN</strong> film_category fc<br/>    <strong class="mp ir">USING</strong> (film_id)<br/>   <strong class="mp ir">INNER JOIN</strong> category cat<br/>    <strong class="mp ir">USING</strong> (category_id)<br/>   <em class="my">/* <br/>    Using<br/>    WHERE co.country = 'India'<br/>    here, instead of <br/>    HAVING co.country = 'India'<br/>    reduces the query execution time.<br/>   */</em><br/>  <strong class="mp ir">GROUP BY</strong> (co.country, cat.name)<br/>  <strong class="mp ir">HAVING</strong> co.country = 'India'<br/>  <strong class="mp ir">ORDER BY</strong> <br/>   co.country <strong class="mp ir">ASC</strong>, <br/>   <strong class="mp ir">COUNT</strong>(cat.name) <strong class="mp ir">DESC</strong>;</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pv"><img src="../Images/b6a3f591385d90fb374a117ee20c8143.png" data-original-src="https://miro.medium.com/v2/resize:fit:1202/format:webp/1*d_PRK0jgT9Ki_jcrotZShg.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure></div><div class="ab cl no np hu nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="ij ik il im in"><h2 id="59b8" class="mt ls iq bd lt mz na dn lx nb nc dp mb le nd ne md li nf ng mf lm nh ni mh nj bi translated">9.只有一个演员的电影</h2><p id="69da" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">在本例中，我们将通过以下方式查找只有一个演员的电影</p><ol class=""><li id="8543" class="oo op iq kx b ky kz lb lc le oq li or lm os lq ot ou ov ow bi translated">加入<strong class="kx ir"> <em class="my">电影</em> </strong>表与<strong class="kx ir"> <em class="my">电影_演员</em> </strong>表使用<strong class="kx ir"> <em class="my">电影_id </em> </strong>。</li><li id="26b2" class="oo op iq kx b ky ox lb oy le oz li pa lm pb lq ot ou ov ow bi translated">按<strong class="kx ir"> <em class="my"> film_id </em> </strong>分组，统计演员人数(如<strong class="kx ir"> <em class="my"> actor_count </em> </strong>)。</li><li id="716a" class="oo op iq kx b ky ox lb oy le oz li pa lm pb lq ot ou ov ow bi translated">过滤<strong class="kx ir"> <em class="my"> actor_count </em> </strong>为1的记录。</li></ol><pre class="kg kh ki kj gt mo mp mq mr aw ms bi"><span id="34f5" class="mt ls iq mp b gy mu mv l mw mx"><strong class="mp ir">SELECT </strong><br/> f.film_id, <br/> f.title, <br/> <strong class="mp ir">COUNT</strong>(fa.actor_id) <strong class="mp ir">AS</strong> actor_count<br/>  <strong class="mp ir">FROM</strong> film f<br/>   <strong class="mp ir">INNER JOIN</strong> film_actor fa<br/>    <strong class="mp ir">USING</strong> (film_id)<br/>  <strong class="mp ir">GROUP BY</strong> f.film_id<br/>  <strong class="mp ir">HAVING COUNT</strong>(fa.actor_id) = 1;</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pw"><img src="../Images/499b8d6c919a12b482907013ca1df8a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:898/format:webp/1*d0YRZZISYRKLoTUX3KRFXw.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure></div><div class="ab cl no np hu nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="ij ik il im in"><h2 id="0c60" class="mt ls iq bd lt mz na dn lx nb nc dp mb le nd ne md li nf ng mf lm nh ni mh nj bi translated">10.一个演员的电影数量(按类别)</h2><p id="9828" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">在本例中，我们将通过以下方式按电影类别查找演员的电影数量</p><ol class=""><li id="4b9e" class="oo op iq kx b ky kz lb lc le oq li or lm os lq ot ou ov ow bi translated">创建一个名为<strong class="kx ir"><em class="my">actor _ cat _ CNT</em></strong>的CTE，返回每个<strong class="kx ir"> <em class="my"> actor_id </em> </strong>和<strong class="kx ir"><em class="my">category _ id</em></strong><em class="my">的电影数量。</em></li><li id="86bd" class="oo op iq kx b ky ox lb oy le oz li pa lm pb lq ot ou ov ow bi translated">将上面的CTE与<strong class="kx ir"> <em class="my">类别</em> </strong>表格用<strong class="kx ir"> <em class="my">类别_id </em> </strong>连接起来。</li><li id="4666" class="oo op iq kx b ky ox lb oy le oz li pa lm pb lq ot ou ov ow bi translated">使用<strong class="kx ir"> <em class="my"> actor_id </em> </strong>将结果表与<strong class="kx ir"> <em class="my"> actor </em> </strong>表连接。</li><li id="4bab" class="oo op iq kx b ky ox lb oy le oz li pa lm pb lq ot ou ov ow bi translated">按升序排列演员姓名(串联<strong class="kx ir"> <em class="my">名字</em> </strong>和<strong class="kx ir"> <em class="my">姓氏)</em> </strong>和<strong class="kx ir"> <em class="my">电影数量</em> </strong>)。</li></ol><pre class="kg kh ki kj gt mo mp mq mr aw ms bi"><span id="a918" class="mt ls iq mp b gy mu mv l mw mx"><strong class="mp ir">WITH </strong><br/> actor_cat_cnt <strong class="mp ir">AS</strong><br/> (<br/>  <strong class="mp ir">SELECT</strong> <br/>   fa.actor_id, <br/>   fc.category_id, <br/>   <strong class="mp ir">COUNT</strong>(f.film_id) <strong class="mp ir">AS</strong> film_count <br/>    <strong class="mp ir">FROM</strong> film_actor fa<br/>     <strong class="mp ir">INNER JOIN</strong> film f<br/>      <strong class="mp ir">USING</strong> (film_id)<br/>     <strong class="mp ir">INNER JOIN</strong> film_category fc<br/>      <strong class="mp ir">USING</strong> (film_id)<br/>    <strong class="mp ir">GROUP BY</strong> <br/>     fa.actor_id, <br/>     fc.category_id<br/> )</span><span id="1b3f" class="mt ls iq mp b gy pk mv l mw mx"><strong class="mp ir">SELECT</strong> <br/> <strong class="mp ir">CONCAT</strong>(ac.first_name, ' ', ac.last_name) <strong class="mp ir">AS</strong> actor,<br/> ca.name <strong class="mp ir">AS</strong> category,<br/> film_count<br/>  <strong class="mp ir">FROM</strong> actor_cat_cnt<br/>   <strong class="mp ir">INNER JOIN</strong> category ca<br/>    <strong class="mp ir">USING</strong> (category_id)<br/>   <strong class="mp ir">INNER JOIN</strong> actor ac<br/>    <strong class="mp ir">USING</strong> (actor_id)<br/>  <strong class="mp ir">ORDER BY</strong> <br/>   <strong class="mp ir">CONCAT</strong>(ac.first_name, ' ', ac.last_name) <strong class="mp ir">ASC</strong>,<br/>   film_count <strong class="mp ir">DESC</strong>;</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi px"><img src="../Images/de2f8194e3d403f2e8d08ef596928aa5.png" data-original-src="https://miro.medium.com/v2/resize:fit:934/format:webp/1*JBj0hz_vZNSHEdClkgm7jg.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure></div><div class="ab cl no np hu nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="ij ik il im in"><h2 id="c32c" class="mt ls iq bd lt mz na dn lx nb nc dp mb le nd ne md li nf ng mf lm nh ni mh nj bi translated">11.演员的流行类别</h2><p id="6ad4" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">在上面的例子中，我们通过电影类别找到了一个演员的电影数量。在本例中，我们将通过以下方式找到演员的热门类别(即演员拥有最多电影的类别)</p><ol class=""><li id="682d" class="oo op iq kx b ky kz lb lc le oq li or lm os lq ot ou ov ow bi translated">创建一个名为<strong class="kx ir"> <em class="my"> actor_cat_cnt </em> </strong>的CTE，返回每个<strong class="kx ir"> <em class="my"> actor_id </em> </strong>和<strong class="kx ir"> <em class="my"> category_id </em> </strong>的电影数量，并按电影数量降序排列每个演员的类别(如<strong class="kx ir"><em class="my">cat _ rank</em></strong>)<em class="my">。</em></li><li id="e5d9" class="oo op iq kx b ky ox lb oy le oz li pa lm pb lq ot ou ov ow bi translated">将上面的CTE与<strong class="kx ir"><em class="my"/></strong>的类别表用<strong class="kx ir"> <em class="my">的类别_id </em> </strong>连接起来。</li><li id="a579" class="oo op iq kx b ky ox lb oy le oz li pa lm pb lq ot ou ov ow bi translated">使用<strong class="kx ir"> <em class="my"> actor_id </em> </strong>将结果表与<em class="my"> actor </em> 表连接。</li><li id="c6c6" class="oo op iq kx b ky ox lb oy le oz li pa lm pb lq ot ou ov ow bi translated">过滤cat_rank = 1的记录。</li><li id="f509" class="oo op iq kx b ky ox lb oy le oz li pa lm pb lq ot ou ov ow bi translated">按升序排列演员姓名(串联<strong class="kx ir"> <em class="my">名</em> </strong>和<strong class="kx ir"> <em class="my">姓)</em> </strong>和<strong class="kx ir"> <em class="my">片数</em> </strong>)。</li></ol><pre class="kg kh ki kj gt mo mp mq mr aw ms bi"><span id="a69a" class="mt ls iq mp b gy mu mv l mw mx"><strong class="mp ir">WITH </strong><br/> actor_cat_cnt <strong class="mp ir">AS</strong><br/> (<br/>  <strong class="mp ir">SELECT</strong> <br/>   fa.actor_id, <br/>   fc.category_id, <br/>   <strong class="mp ir">COUNT</strong>(f.film_id) <strong class="mp ir">AS</strong> film_count,<br/>   <strong class="mp ir">RANK</strong>() <strong class="mp ir">OVER</strong> <br/>    (<strong class="mp ir">PARTITION BY</strong> fa.actor_id <br/>      <strong class="mp ir">ORDER BY COUNT</strong>(f.film_id) <strong class="mp ir">DESC</strong>) <strong class="mp ir">AS</strong> cat_rank <br/>    <strong class="mp ir">FROM</strong> film_actor fa<br/>     <strong class="mp ir">INNER JOIN</strong> film f<br/>      <strong class="mp ir">USING</strong> (film_id)<br/>     <strong class="mp ir">INNER JOIN</strong> film_category fc<br/>      <strong class="mp ir">USING</strong> (film_id)<br/>    <strong class="mp ir">GROUP BY</strong> <br/>     fa.actor_id, <br/>     fc.category_id<br/> )</span><span id="5ce5" class="mt ls iq mp b gy pk mv l mw mx"><strong class="mp ir">SELECT</strong> <br/> <strong class="mp ir">CONCAT</strong>(ac.first_name, ' ', ac.last_name) <strong class="mp ir">AS</strong> actor,<br/> ca.name <strong class="mp ir">AS</strong> category,<br/> film_count<br/>  <strong class="mp ir">FROM</strong> actor_cat_cnt<br/>   <strong class="mp ir">INNER JOIN</strong> category ca<br/>    <strong class="mp ir">USING</strong> (category_id)<br/>   <strong class="mp ir">INNER JOIN</strong> actor ac<br/>    <strong class="mp ir">USING</strong> (actor_id)<br/>  <strong class="mp ir">WHERE</strong> cat_rank = 1  <br/>  <strong class="mp ir">ORDER BY</strong> <br/>   <strong class="mp ir">CONCAT</strong>(ac.first_name, ' ', ac.last_name) <strong class="mp ir">ASC</strong>,<br/>   film_count <strong class="mp ir">DESC</strong>;</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi py"><img src="../Images/9aa8b93b8fe14b1d2e0d3d1d3fcf4cc6.png" data-original-src="https://miro.medium.com/v2/resize:fit:970/format:webp/1*ePMVyekRaWgDgCs8SeCzgQ.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="d64c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">本文到此结束。我们已经讨论了使用SQL按行或列合并表的方法，以及一些使用dvd_rental数据库的例子。这些是我们用SQL编写的几乎每个查询中使用的基本概念。我们在实践中可能不会经常使用其中的一些，但是了解它们是必要的。</p></div></div>    
</body>
</html>