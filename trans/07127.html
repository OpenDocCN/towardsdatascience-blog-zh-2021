<html>
<head>
<title>Four Unusual Python Code Smells</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">四种不同寻常的Python代码味道</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/four-unusual-python-code-smells-7bf3d93f5e6c?source=collection_archive---------19-----------------------#2021-06-28">https://towardsdatascience.com/four-unusual-python-code-smells-7bf3d93f5e6c?source=collection_archive---------19-----------------------#2021-06-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d76d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">以及如何处理它们。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/51e124de6046dc76461ac7ad3a5a845d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4BAJwkdxxRFytHZEuyYz4A.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由来自<a class="ae ky" href="https://www.pexels.com/photo/crop-man-smelling-white-flower-in-garden-7125403/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"> Pexels </a>的<a class="ae ky" href="https://www.pexels.com/@michael-burrows?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"> Michael Burrows </a>拍摄，由作者使用Python修改</p></figure><p id="38cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我想到编程和教育的时候，我畏缩了。我畏缩是因为课程涉及所有编程方面，除了一个——软件设计。可悲的是，软件设计是软件开发的关键要素。</p><blockquote class="lv"><p id="81d7" class="lw lx it bd ly lz ma mb mc md me lu dk translated">"写代码不是生产，也不总是技艺，尽管它可以是，它是设计."— <a class="ae ky" href="https://quotefancy.com/programming-quotes" rel="noopener ugc nofollow" target="_blank">乔尔·斯波尔斯基</a></p></blockquote><p id="7d5b" class="pw-post-body-paragraph kz la it lb b lc mf ju le lf mg jx lh li mh lk ll lm mi lo lp lq mj ls lt lu im bi translated">如果没有软件设计，人们会停留在20世纪90年代——那时软件通常是从零开始实现的。然而今天，最小的创业公司都会产生数千行代码，更不用说科技巨头、游戏工作室、汽车制造商等等。</p><p id="596c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些公司通常基于以前版本的代码开发新软件，这为创新和创造提供了空间。当然，如果没有一个可维护、可重用、可读和高效的代码库，这是不可能的。这些特性共同阐明了良好的代码重构实践或反代码味道的本质。</p><p id="681d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">“代码味道”这个术语是由fowler和kent在他们的书《重构:改进现有代码的设计》中提出的。但实际上，这个术语只不过是糟糕的代码设计的一个厚颜无耻的同义词。</p><p id="175e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">也就是说，在这篇文章中，我们将讨论四种不寻常的坏代码味道以及重构它们的方法。它们是“不寻常的”,因为据我所知，我们将要讨论的代码味道不是你通常在互联网上偶然发现的。所以，我希望你能像我一样从中受益。让我们开始吧:</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="bade" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">Lambda函数的误用</h1><p id="63ae" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">函数是传统函数的语法糖。它们是运行时调用的匿名构造。它们的效用源于它们的简洁。</p><p id="2a32" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，当lambda变得太长而难以阅读或太复杂而难以理解时，它就失去了魅力和有效性。更重要的是，lambda在封装不可重用代码方面崛起并大放异彩。否则，您最好使用标准函数。</p><p id="1d8a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了解决lambda不恰当使用的不同场景，我们汇编了lambda开始发臭的三个用例:</p><h2 id="556d" class="no ms it bd mt np nq dn mx nr ns dp nb li nt nu nd lm nv nw nf lq nx ny nh nz bi translated">#1.将Lambda绑定到变量</h2><p id="466c" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">考虑这个例子:</p><p id="9fac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好闻:</p><pre class="kj kk kl km gt oa ob oc od aw oe bi"><span id="bc40" class="no ms it ob b gy of og l oh oi">def f(x, y): <br/>    return x + y</span></pre><p id="a4bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">难闻的气味:</p><pre class="kj kk kl km gt oa ob oc od aw oe bi"><span id="b5d3" class="no ms it ob b gy of og l oh oi">f = lambda x, y: x + y</span></pre><p id="c3d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">乍一看，人们可以自信地说，将lambda绑定到一个变量就像显式的<em class="oj"> def </em>声明一样好。但是实际上，这种实践是一种软件反模式，因为:</p><ul class=""><li id="8e8f" class="ok ol it lb b lc ld lf lg li om lm on lq oo lu op oq or os bi translated">首先，它违背了lambda函数的定义。也就是说，你给了一个<strong class="lb iu">匿名</strong>函数一个<strong class="lb iu">名字</strong>。</li><li id="2ac4" class="ok ol it lb b lc ot lf ou li ov lm ow lq ox lu op oq or os bi translated">第二，它把lambda函数的目的抹杀了。也就是把lambda嵌入到更大的表达式中(<a class="ae ky" href="https://legacy.python.org/dev/peps/pep-0008/" rel="noopener ugc nofollow" target="_blank"> PEP 8 </a>)。</li></ul><h2 id="1e02" class="no ms it bd mt np nq dn mx nr ns dp nb li nt nu nd lm nv nw nf lq nx ny nh nz bi translated">#2.长λ</h2><p id="8204" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">到目前为止，很明显长lambda函数是糟糕代码设计的暗示。然而，问题是允许测量这种长度的启发式方法。</p><p id="9713" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">嗯，研究表明lambda表达式应该遵守以下标准:</p><ul class=""><li id="468c" class="ok ol it lb b lc ld lf lg li om lm on lq oo lu op oq or os bi translated">NOC ≤ 80</li></ul><p id="2fcc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">NOC:字符数</p><p id="2fbf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，lambda表达式不应超过80个字符。</p><h2 id="2373" class="no ms it bd mt np nq dn mx nr ns dp nb li nt nu nd lm nv nw nf lq nx ny nh nz bi translated">#3.肮脏的λ</h2><p id="573c" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">Lambda函数吸引了许多开发人员，尤其是初级开发人员。它的便利性和美学设计很可能会让人陷入肮脏的λ陷阱。</p><p id="fc92" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你看，lambda被设计成执行一个表达式。建议此表达式的字符数少于一定数量。为了避开这种约束，出现了一些卑鄙的手段和变通方法。</p><p id="e160" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">嵌套的lambda函数和内部标准函数是臭名昭著的肮脏的变通方法。让我们举一个例子来近距离观察这一点:</p><p id="4edb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">难闻的气味:</p><pre class="kj kk kl km gt oa ob oc od aw oe bi"><span id="ff1d" class="no ms it ob b gy of og l oh oi"># inner lambda function<br/>func = lambda x= 1, y= 2:lambda z: x + y + z<br/>f = func()<br/>print(f(4))</span></pre><p id="72d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好闻:</p><pre class="kj kk kl km gt oa ob oc od aw oe bi"><span id="75a2" class="no ms it ob b gy of og l oh oi">def func(x=1, y=2):<br/>    def f(z):<br/>        return x + y + z<br/>    return f<br/>f = func()<br/>print(f(4))</span></pre><p id="99a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如您所看到的，虽然lambda示例更简洁(3行对6行)，但是lambda代码更混乱，更难破译。这种做法引起的混乱的一个例子是这个<a class="ae ky" href="https://stackoverflow.com/questions/36391807/understanding-nested-lambda-function-behaviour-in-python" rel="noopener ugc nofollow" target="_blank">线程</a>。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="cc8b" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">长范围链接</h1><p id="0842" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">长范围链接是嵌套在封闭函数中的内部函数的集合。内部函数在技术上被称为<em class="oj">闭包。</em>以下示例提供了一个更清晰的画面:</p><pre class="kj kk kl km gt oa ob oc od aw oe bi"><span id="f1fd" class="no ms it ob b gy of og l oh oi">def foo(x):<br/>    def bar(y):<br/>        def baz(z):<br/>            return x + y + z<br/>        return baz(3)<br/>    return bar(10)</span><span id="e9d7" class="no ms it ob b gy oy og l oh oi">print(foo(2))  # print(10+3+2)</span></pre><p id="754b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用内部函数填充函数是一个非常有吸引力的解决方案，因为它模拟了隐私，这对于Python这样的语言来说特别有用和方便。这是因为，与C++和Java不同，Python几乎没有私有和公共类变量的区别(尽管有一些黑客攻击)。然而，这种实践开始嗅到闭包越深的味道。</p><p id="6c24" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了解决这个问题，已经为闭包设置了一个阈值试探。该指标规定最多有3个闭包。否则，代码开始看起来模糊，变得难以维护。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="6f91" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">无用的异常处理</h1><p id="42d1" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">异常处理程序是程序员用来捕捉异常的常用工具。它们在测试代码中非常有用。然而，如果异常是(1)不准确的或(2)空的，它们就变得没有用了。</p><h2 id="3161" class="no ms it bd mt np nq dn mx nr ns dp nb li nt nu nd lm nv nw nf lq nx ny nh nz bi translated">#1.不准确的例外</h2><p id="8190" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">try … except语句给了程序员管理异常的自由。这导致了非常一般和不精确的异常。看看这个:</p><pre class="kj kk kl km gt oa ob oc od aw oe bi"><span id="1780" class="no ms it ob b gy of og l oh oi">try:<br/>   pass<br/>except Exception:<br/>   raise<br/># OR<br/>try:<br/>   pass<br/>except StandardError:<br/>   raise</span></pre><p id="1e19" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个例子中，异常太过笼统，很可能预示着一系列的错误，很难发现问题的根源。这就是为什么建议对异常要精确和具体。下面的示例是一个很好的实践，它专门用于指示导入错误:</p><pre class="kj kk kl km gt oa ob oc od aw oe bi"><span id="91b0" class="no ms it ob b gy of og l oh oi">try:<br/>    import platform_specific_module<br/>except ImportError:<br/>    platform_specific_module = None</span></pre><h2 id="be47" class="no ms it bd mt np nq dn mx nr ns dp nb li nt nu nd lm nv nw nf lq nx ny nh nz bi translated">#2.空异常</h2><p id="f2d9" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">谈到错误处理程序，没有什么比纯粹的异常更糟糕的了。</p><p id="8c12" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">空<code class="fe oz pa pb ob b">except:</code>捕捉<code class="fe oz pa pb ob b">systemExit</code>和<code class="fe oz pa pb ob b">KeyboardInterrupt</code>异常，用Ctrl+C渲染程序中断更加困难。更不用说掩饰其他问题了。</p><p id="0cc0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了解决这个问题，Python风格指南<a class="ae ky" href="https://legacy.python.org/dev/peps/pep-0008/" rel="noopener ugc nofollow" target="_blank"> PEP 8 </a>建议将简单的异常限制为两种用例:</p><ul class=""><li id="d94a" class="ok ol it lb b lc ld lf lg li om lm on lq oo lu op oq or os bi translated">无论问题的性质如何，用户都希望标记错误或记录追溯。</li><li id="1a7b" class="ok ol it lb b lc ot lf ou li ov lm ow lq ox lu op oq or os bi translated">如果用户想从底部到顶部提出异常，<code class="fe oz pa pb ob b">try … finally</code>是一个很好的选择。</li></ul><h2 id="b0ff" class="no ms it bd mt np nq dn mx nr ns dp nb li nt nu nd lm nv nw nf lq nx ny nh nz bi translated">#3.补救措施？</h2><p id="53c3" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">与其他引用的代码味道不同，重构异常没有放之四海而皆准的解决方案。然而，一般的补救措施是尽可能具体和仔细地编写异常处理程序。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="85c2" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">著名系列(len(sequence))</h1><p id="7840" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">坦率地说，<code class="fe oz pa pb ob b">range(len())</code>是一个坏习惯。这曾经是我默认的循环机制。但是，我很高兴现在我不记得我最后一次使用它。</p><p id="f547" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe oz pa pb ob b">range(len())</code>吸引新的Python开发者。它甚至吸引了经验丰富的开发人员，他们的数字循环(C++之类的循环)已经在他们的大脑中形成。对于这些人来说，<code class="fe oz pa pb ob b">range(len())</code>感觉像家一样，因为它复制了与传统数值循环相同的循环机制。</p><p id="4ece" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一方面，<code class="fe oz pa pb ob b">range(len())</code>被Python战士和经验丰富的开发人员所轻视，因此被认为是迭代反模式。原因是<code class="fe oz pa pb ob b">range(len())</code>使得代码容易出现bug。这些错误很大程度上源于程序员忘记了<code class="fe oz pa pb ob b">range()</code>的第一个参数是包含性的，而第二个是排他性的。</p><p id="16b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了一劳永逸地解决这个问题，我们将列举使用<code class="fe oz pa pb ob b">range(len())</code>的常见借口及其正确的替代表达。</p><ul class=""><li id="903d" class="ok ol it lb b lc ld lf lg li om lm on lq oo lu op oq or os bi translated">您需要序列的索引:</li></ul><pre class="kj kk kl km gt oa ob oc od aw oe bi"><span id="324e" class="no ms it ob b gy of og l oh oi"><strong class="ob iu">for</strong> index, value <strong class="ob iu">in</strong> enumerate(sequence): <br/>        <strong class="ob iu">print</strong> index, value</span></pre><ul class=""><li id="7a00" class="ok ol it lb b lc ld lf lg li om lm on lq oo lu op oq or os bi translated">您希望同时迭代两个序列:</li></ul><pre class="kj kk kl km gt oa ob oc od aw oe bi"><span id="0359" class="no ms it ob b gy of og l oh oi"><strong class="ob iu">for</strong> letter, digit <strong class="ob iu">in</strong> zip(letters, digits):<br/>        <strong class="ob iu">print</strong> letter, digit</span></pre><ul class=""><li id="6a83" class="ok ol it lb b lc ld lf lg li om lm on lq oo lu op oq or os bi translated">您想要迭代序列的一个块:</li></ul><pre class="kj kk kl km gt oa ob oc od aw oe bi"><span id="eeae" class="no ms it ob b gy of og l oh oi"><strong class="ob iu">for</strong> letter <strong class="ob iu">in</strong> letters[4:]: #slicing<em class="oj"><br/></em>        <strong class="ob iu">print</strong> letter</span></pre><p id="8616" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如你所见，避免<code class="fe oz pa pb ob b">range(len())</code>是可能的。尽管如此，当序列索引的使用超出了序列本身(例如函数)时，使用<code class="fe oz pa pb ob b">range(len())</code>似乎是一个明智的选择。例如:</p><pre class="kj kk kl km gt oa ob oc od aw oe bi"><span id="0e24" class="no ms it ob b gy of og l oh oi"><strong class="ob iu">for</strong> x <strong class="ob iu">in</strong> range(len(letters)):<br/>    <strong class="ob iu">print</strong> f(x)</span></pre></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="3afd" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">外卖食品</h1><p id="8223" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">技术进步给人们编写和分析代码的方式带来了巨大的变化。变得更好。然而，反模式、代码味道、糟糕的代码设计等等，仍然是一个非常主观和开放的话题。</p><p id="57e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">软件设计原则是主观的，因为它们基于现实生活的经验和固执己见的观点。这也许就是为什么软件开发者聚会不能没有软件设计辩论的原因。</p><p id="e323" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，一些开发人员发现长lambda函数会使代码变得很臭，而其他开发人员则喜欢lambda，并认为它是pythonic式的，无害的。我个人认为，袖手旁观站在前者一边。</p><p id="e857" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">简而言之，没有一个软件能够在没有重构实践的情况下生存下来，正如俗话所说:</p><blockquote class="lv"><p id="89d7" class="lw lx it bd ly lz ma mb mc md me lu dk translated">“臭了就换。”—肯特·贝克和马丁·福勒</p></blockquote><p id="8083" class="pw-post-body-paragraph kz la it lb b lc mf ju le lf mg jx lh li mh lk ll lm mi lo lp lq mj ls lt lu im bi translated">我希望这篇文章能让你的代码看起来更好。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="338c" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">参考</h1><div class="pc pd gp gr pe pf"><a href="https://www.semanticscholar.org/paper/JSNOSE%3A-Detecting-JavaScript-Code-Smells-Fard-Mesbah/86dd17663c963772e6dd3ec8e2b1ab4a8a0e377f" rel="noopener  ugc nofollow" target="_blank"><div class="pg ab fo"><div class="ph ab pi cl cj pj"><h2 class="bd iu gy z fp pk fr fs pl fu fw is bi translated">[PDF] JSNOSE:检测JavaScript代码气味|语义学者</h2><div class="pm l"><h3 class="bd b gy z fp pk fr fs pl fu fw dk translated">JavaScript是一种强大而灵活的基于原型的脚本语言，越来越多地被开发人员用来…</h3></div><div class="pn l"><p class="bd b dl z fp pk fr fs pl fu fw dk translated">www.semanticscholar.org</p></div></div><div class="po l"><div class="pp l pq pr ps po pt ks pf"/></div></div></a></div><div class="pc pd gp gr pe pf"><a href="https://ieeexplore.ieee.org/document/7780188" rel="noopener  ugc nofollow" target="_blank"><div class="pg ab fo"><div class="ph ab pi cl cj pj"><h2 class="bd iu gy z fp pk fr fs pl fu fw is bi translated">检测Python程序中的代码味道</h2><div class="pm l"><h3 class="bd b gy z fp pk fr fs pl fu fw dk translated">Python作为一种传统的动态语言，越来越多地应用于各种软件工程任务中。然而，由于…</h3></div><div class="pn l"><p class="bd b dl z fp pk fr fs pl fu fw dk translated">ieeexplore.ieee.org</p></div></div><div class="po l"><div class="pu l pq pr ps po pt ks pf"/></div></div></a></div><div class="pc pd gp gr pe pf"><a href="https://lignos.org/py_antipatterns/" rel="noopener  ugc nofollow" target="_blank"><div class="pg ab fo"><div class="ph ab pi cl cj pj"><h2 class="bd iu gy z fp pk fr fs pl fu fw is bi translated">Python编程中的反模式</h2><div class="pm l"><h3 class="bd b gy z fp pk fr fs pl fu fw dk translated">注意(2019年9月1日):这里的建议在这一点上有些过时。有一天会有更新来改变…</h3></div><div class="pn l"><p class="bd b dl z fp pk fr fs pl fu fw dk translated">lignos.org</p></div></div></div></a></div></div></div>    
</body>
</html>