<html>
<head>
<title>Time Series Forecast in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的时间序列预测</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-predict-your-step-count-for-next-week-a16b7800b408?source=collection_archive---------8-----------------------#2021-07-03">https://towardsdatascience.com/how-to-predict-your-step-count-for-next-week-a16b7800b408?source=collection_archive---------8-----------------------#2021-07-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3c05" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">基于ARIMA模型的端到端时间序列预测</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f0e72bdef0106eb02e33b29eeb16b4c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*65jJVTsS3TAtX8I5kR8dlg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">林赛·亨伍德在<a class="ae ky" href="https://unsplash.com/s/photos/steps?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="7c18" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">自从Covid和封锁开始以来，自由行走对包括我自己在内的许多人来说都是一种奢侈。就我个人而言，我每天都试图离开我的笔记本电脑，出去呼吸一些新鲜空气。每周，我都会从手机上查看我的步数，看看我是否做了足够的锻炼。</p><blockquote class="lv"><p id="180d" class="lw lx it bd ly lz ma mb mc md me lu dk translated">如果我们能准确预测下一周的步数，那该多好啊！</p></blockquote><p id="15ed" class="pw-post-body-paragraph kz la it lb b lc mf ju le lf mg jx lh li mh lk ll lm mi lo lp lq mj ls lt lu im bi translated">在本文中，我将使用基本的时间序列分析来观察自己的步数趋势，并使用历史步数预测未来。本文的主要目的是<strong class="lb iu">展示时间序列预测</strong>的主要思想，并使用我自己的步数作为实际的编码示例。</p><h1 id="4a31" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">我们使用的数据</h1><p id="c474" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">我正在使用从我的iPhone苹果健康下载的步数数据。如果您也使用iPhone，您可以从Apple Health application个人资料页面下载健康数据，如下所示</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nh"><img src="../Images/ed4e6b1405c76372f3d86c4c1eb015c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5OUlwrUGNvYDYsuc4I1CWw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">截图来自<a class="ae ky" href="https://www.apple.com/sg/ios/health/" rel="noopener ugc nofollow" target="_blank">苹果网站</a></p></figure><p id="2d3c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下载的数据将是一个XML文件，包含Apple Health的多个部分，包括步数、心率、睡眠分析等。我利用链接中的脚本<a class="ae ky" href="https://github.com/markwk/qs_ledger/blob/master/apple_health/apple_health_extractor.ipynb" rel="noopener ugc nofollow" target="_blank">将XML文件转换成CSV格式进行分析。文件的输出将是多个CSV文件，您可以使用Python直接连接到CSV文件。<strong class="lb iu">它也是</strong> <strong class="lb iu">一个有趣的数据源，供您使用自己的健康数据探索其他数据分析或数据可视化方式</strong>。</a></p><h1 id="09e1" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">数据探索</h1><p id="3ca7" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">步数数据看起来像下面的截图，其中包含每次移动时的步数数值。它还包含开始日期、结束日期和创建日期。这里的创建日期是指该记录的创建日期和时间，因此我使用开始日期来记录时间。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ni"><img src="../Images/5b31f56f7b4b6902540478a6614f4e3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tUNyH92yNR2-vGVAhFLQgQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">步骤计数的原始数据</p></figure><p id="9ff7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于我的分析，我只需要“开始日期”和“值”两列。对我来说，第一步是将日期列转换成日期时间格式，然后将数据汇总成每周总和。这是因为许多python函数或时间序列包需要一个时间格式的列，如果我预测每天的数据，波动性会太高。</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="5629" class="no ml it nk b gy np nq l nr ns">#read data from extracted csv<br/>steps=pd.read_csv('apple_health_export/StepCount.csv')</span><span id="adba" class="no ml it nk b gy nt nq l nr ns">#convert start date into time format<br/>steps['date']=pd.to_datetime(steps['startDate'].str[:19])</span><span id="c8a6" class="no ml it nk b gy nt nq l nr ns">#Aggregate data into weekly sum<br/>sample=steps[['date','value']]<br/>weekly=sample.resample('W', on='date').sum()</span><span id="c748" class="no ml it nk b gy nt nq l nr ns">#visualize weekly data<br/>weekly.plot(figsize=(15, 6))<br/>plt.show()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nu"><img src="../Images/02a196cc03f540d6dda1a0653c71ef5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZGX_7Ng3WQ4HMCm58MuK3Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">每周步数的可视化</p></figure><p id="d04e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从上面的可视化中，我们可以看到，即使是每周的步数数据也有很高的波动性。为了消除像每周300k步数或每周少于2000步这样的极值的影响，我使用winsorization使数据更正常。</p><blockquote class="lv"><p id="5c3d" class="lw lx it bd ly lz ma mb mc md me lu dk translated">Winsorization:通过将极值限制在某个界限内来消除异常值的影响，从而对数据进行转换。</p></blockquote><p id="20cc" class="pw-post-body-paragraph kz la it lb b lc mf ju le lf mg jx lh li mh lk ll lm mi lo lp lq mj ls lt lu im bi translated">我不直接在每周级别上winsorize，而是限制在每天的步数级别上。例如，如果我一天走得太多，每天的步数将被降低到上限值，然后我将这些winsorized每天的步数再次汇总到每周的总数中。</p><p id="8f41" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我选择的边界限制是更高的2%和更低的2%(这个<strong class="lb iu">百分比值可以由我们根据数据</strong>的分布来确定)。我使用了<a class="ae ky" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.mstats.winsorize.html" rel="noopener ugc nofollow" target="_blank">‘winsorize’Python包</a>，在其中你可以直接指定百分比的上限和下限。</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="268a" class="no ml it nk b gy np nq l nr ns">#remove the first part of data with no steps<br/>sample=steps[steps['date']&gt;'2015-09-01'][['date','value']]</span><span id="e326" class="no ml it nk b gy nt nq l nr ns">#aggregate data on daily level<br/>daily=sample.resample('D',on='date').sum()</span><span id="c32c" class="no ml it nk b gy nt nq l nr ns">#Winsorize daily data<br/>daily['winsorized_value']=winsorize(daily['value'], limits=[0.02, 0.02])</span><span id="c8a4" class="no ml it nk b gy nt nq l nr ns">#Aggregate daily data into weekly data again<br/>weekly=daily.resample('W').sum()<br/>#visualize new weekly data<br/>weekly.plot(figsize=(15, 6))<br/>plt.show()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nv"><img src="../Images/c91bcc18dc7bdd4b7933af4d25bb383f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2ppr8zpCqdW_WLBpjMhZ7Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">winsorized步数的可视化</p></figure><p id="c479" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以从上面的可视化中看到，winsorized数据具有较少的极值，因此为我们提供了一个更通用的部分。然而，有一点需要注意的是<strong class="lb iu">这个平滑步骤不是强制性的</strong>，因为大多数时间序列方法会有一些其他的平滑步骤。</p><p id="4f77" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您还可以通过使用<a class="ae ky" href="https://www.statsmodels.org/stable/generated/statsmodels.tsa.seasonal.seasonal_decompose.html" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">季节性_分解</strong> </a> <strong class="lb iu">包</strong>来<strong class="lb iu">查看季节性模式和总体趋势</strong>。这里的趋势是由移动平均确定的，然后在从原始数据中去除趋势后提取季节性元素。</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="19d8" class="no ml it nk b gy np nq l nr ns">extract=train.set_index('date')<br/>from pylab import rcParams<br/>rcParams['figure.figsize'] = 18, 8<br/>decomposition = sm.tsa.seasonal_decompose(extract, model='additive')<br/>fig = decomposition.plot()<br/>plt.show()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nw"><img src="../Images/2afe837145cf8adb3e6889fe96686556.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WdCX8KUDT60oNCIPppGE6g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">季节和趋势元素</p></figure><p id="5fb5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从上图可以看出，步数中有一些轻微的季节性因素。总体趋势有一个强烈的变化，特别是从covid时期开始以来。</p><h1 id="f1b6" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">时间序列预测</h1><p id="44c3" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">研究完数据后，我们可以使用不同的时间序列预测方法开始预测。</p><blockquote class="nx ny nz"><p id="cd6f" class="kz la oa lb b lc ld ju le lf lg jx lh ob lj lk ll oc ln lo lp od lr ls lt lu im bi translated"><strong class="lb iu">问题陈述:</strong>根据历史步数数据预测下周步数有多准确？</p></blockquote><p id="2749" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">数据准备:</strong>步骤与正常的机器学习训练-测试拆分略有不同。这是因为<strong class="lb iu">训练数据和测试数据是动态的</strong>取决于您预测的周(我们使用<strong class="lb iu">该周之前的所有历史数据作为训练数据</strong>)。我们使用2021年的步数作为基准来衡量我们模型的准确性。</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="9f73" class="no ml it nk b gy np nq l nr ns">#determine training and testing group<br/>data=weekly.reset_index()<br/>test=data[data['date']&gt;'2021-01-01'][['date','value']]<br/>train=data[['date','value']]</span></pre><p id="b335" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将使用平均误差(MAE)来衡量所有模型的准确性。您也可以选择“均方误差”、“均方根误差”或“平均误差百分比”进行测量。如果想了解更多关于度量回归或预测模型的内容，可以参考这里的<a class="ae ky" rel="noopener" target="_blank" href="/what-are-the-best-metrics-to-evaluate-your-regression-model-418ca481755b"/>。</p><h2 id="ae9c" class="no ml it bd mm oe of dn mq og oh dp mu li oi oj mw lm ok ol my lq om on na oo bi translated">方法1:移动平均线</h2><p id="0d4e" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">移动平均线仅仅意味着前X个周期的平均值，X由你来决定。这是时间序列数据最常用的技术/概念之一。它可以帮助<strong class="lb iu">平滑数据</strong>趋势，从而给你一个更真实的结果近似值。</p><p id="4594" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我的例子中，我使用的是过去10个时间段的移动平均值，这意味着我认为步数主要受前10周的步数影响。您可以选择使用不同的号码。移动平均线中使用的<strong class="lb iu">常见时间段为10、20、30、50、100 </strong>，具体视场景而定。</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="0869" class="no ml it nk b gy np nq l nr ns">#get rolling moving average for previous 10 weeks<br/>data['SMA_10']=train['value'].rolling(window=10).mean().shift(1)</span><span id="7cb7" class="no ml it nk b gy nt nq l nr ns">#Measure the MAE for this measure<br/>test=data[data['date']&gt;'2020-12-31']<br/>from sklearn.metrics import mean_absolute_error<br/>print(mean_absolute_error(test['value'], test['SMA_10']))<br/>#10415.972</span></pre><h2 id="f0b3" class="no ml it bd mm oe of dn mq og oh dp mu li oi oj mw lm ok ol my lq om on na oo bi translated">方法2:指数加权移动平均</h2><p id="fc55" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">方法1移动平均线是过去10周的简单平均值。你可能想说离预测日期越近的那一周应该有更大的权重，而不是简单的平均值。这时我们可以使用指数加权移动平均线。</p><p id="32c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">指数加权移动平均给予较近的数据较大的权重，权重的分配遵循指数逻辑。让我们看看它与简单的移动平均线方法相比表现如何。</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="a56d" class="no ml it nk b gy np nq l nr ns">#Calculate ewm average value<br/>data['ewma_10']=train['value'].ewm(span=10).mean().shift(1)</span><span id="ad44" class="no ml it nk b gy nt nq l nr ns">test=data[data['date']&gt;'2020-12-31']<br/>from sklearn.metrics import mean_absolute_error<br/>print(mean_absolute_error(test['value'], test['ewma_10']))<br/>#9613.11</span></pre><p id="3d19" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与简单移动平均相比，指数加权移动平均给出了更低平均误差的更好结果。</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="8e43" class="no ml it nk b gy np nq l nr ns">test_plot_data=test.set_index('date')[['SMA_10','ewma_10']]<br/>train_plot=train[train['date']&gt;'2020-01-01'].set_index('date')<br/>plt.figure(figsize=(15,10))<br/>plt.plot(train_plot,label='Actual Step')<br/>plt.plot(test_plot_data['SMA_10'],label='sma_10')<br/>plt.plot(test_plot_data['ewma_10'],label='ewma_10')<br/>plt.legend(loc='Left corner')<br/>plt.show()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nv"><img src="../Images/f9a0ca46a1754c676fc98469c604e2d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CtcumLWJd3kA0sclcND2jg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">简单移动平均线与指数加权移动平均线</p></figure><p id="9b47" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果绘制两个预测值与实际步数的关系图，可以看到两种移动平均法的预测值都比实际步数平滑得多。与简单移动平均线(红线)相比，指数加权移动平均线(黄线)更快地捕捉到趋势，并且更接近真实步数。</p><h2 id="1b78" class="no ml it bd mm oe of dn mq og oh dp mu li oi oj mw lm ok ol my lq om on na oo bi translated">方法3: SARIMA模型—手动调谐</h2><p id="a791" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">萨里玛模型是具有季节性趋势的ARIMA模型。ARIMA模型的全称是自回归综合移动平均。在我开始介绍这个方法之前，让我们快速浏览一下ARIMA到底是什么，以及我们在建模时考虑了哪些因素。</p><blockquote class="lv"><p id="c978" class="lw lx it bd ly lz ma mb mc md me lu dk translated">快速总结:</p></blockquote><p id="bbd7" class="pw-post-body-paragraph kz la it lb b lc mf ju le lf mg jx lh li mh lk ll lm mi lo lp lq mj ls lt lu im bi translated"><strong class="lb iu">自回归/AR: </strong>输出预测依赖于先前的观测值/滞后观测值</p><p id="85e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> Integrated/I: </strong>数据不是平稳的，它需要一定阶的差分来实现平稳性</p><p id="e222" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">移动平均/移动平均:</strong>输出预测取决于之前的误差项/滞后误差</p><p id="11ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于SARIMA模型，您需要指定<strong class="lb iu"> 7个不同的参数</strong>:</p><ul class=""><li id="c25e" class="op oq it lb b lc ld lf lg li or lm os lq ot lu ou ov ow ox bi translated"><strong class="lb iu">p</strong>:AR项的滞后数</li><li id="e0b7" class="op oq it lb b lc oy lf oz li pa lm pb lq pc lu ou ov ow ox bi translated"><strong class="lb iu"> d </strong>:达到平稳所需的差分次数</li><li id="1af8" class="op oq it lb b lc oy lf oz li pa lm pb lq pc lu ou ov ow ox bi translated"><strong class="lb iu">q</strong>:MA期限的滞后数</li><li id="a203" class="op oq it lb b lc oy lf oz li pa lm pb lq pc lu ou ov ow ox bi translated">季节性周期。指同一模式再次出现的时间周期数。</li><li id="957b" class="op oq it lb b lc oy lf oz li pa lm pb lq pc lu ou ov ow ox bi translated"><strong class="lb iu"> P，D，Q </strong>:与P，D，Q相同，但为季节性参数</li></ul><p id="97e3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">网上有文章介绍我们如何根据对数据的观察来确定不同的参数。对于这个方法，我使用的是来自<a class="ae ky" href="https://www.statsmodels.org/dev/generated/statsmodels.tsa.statespace.sarimax.SARIMAX.html" rel="noopener ugc nofollow" target="_blank"> statsmodel </a>的包。</p><p id="8d25" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于您运行的每个模型，您可以有一个<strong class="lb iu">结果摘要和一个AIC值</strong>来衡量模型的样本内适合度。我对所有参数使用不同值的迭代，<strong class="lb iu">找出最低的AIC值</strong> e(样本内数据的最佳拟合模型)。我是从这里的链接<a class="ae ky" href="https://www.digitalocean.com/community/tutorials/a-guide-to-time-series-forecasting-with-arima-in-python-3" rel="noopener ugc nofollow" target="_blank">学到这个方法的。</a></p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="9903" class="no ml it nk b gy np nq l nr ns"># Define the p, d and q parameters for value between 0-2 and iterate for all the value in the range<br/>p = d = q = range(0, 2)<br/>pdq = list(itertools.product(p, d, q))</span><span id="1446" class="no ml it nk b gy nt nq l nr ns"># Generate all different combinations of seasonal p, q and q <br/>seasonal_pdq = [(x[0], x[1], x[2], 4) for x in list(itertools.product(p, d, q))]</span><span id="cabf" class="no ml it nk b gy nt nq l nr ns">params=[]<br/>seasonal=[]<br/>aic=[]<br/>for param in pdq:<br/>    for param_seasonal in seasonal_pdq:<br/>        mod = sm.tsa.statespace.SARIMAX(train_set,order=param,                                 seasonal_order=param_seasonal,                                    <br/>enforce_stationarity=False,                                          enforce_invertibility=False)</span><span id="2838" class="no ml it nk b gy nt nq l nr ns">#append all the parameters and result AIC value<br/>results = mod.fit()<br/>        params.append(param)<br/>        seasonal.append(param_seasonal)<br/>        aic.append(results.aic)<br/>parameter_options=pd.DataFrame({'params':params,'seasonal_params':seasonal,'AIC':aic})</span><span id="e6f6" class="no ml it nk b gy nt nq l nr ns">#sort the AIC value to find the best fitted model<br/>parameter_options.sort_values(by='AIC')</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pd"><img src="../Images/0e0eac53b32f10ba37b78e2abb57d074.png" data-original-src="https://miro.medium.com/v2/resize:fit:1296/format:webp/1*QQiu68TiW52xAHOMY5A9Bg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">ARIMA模型参数和分类AIC</p></figure><p id="3d83" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从上面的结果中，我们可以看到性能最好的几个参数集。但是，这并不一定等于预测的最佳参数集，因为样本外精度可能与样本内精度有很大不同。你可以参考这个列表，试着找出最合适的型号。</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="507d" class="no ml it nk b gy np nq l nr ns">data_updated=data.set_index('date')<br/>train=data[data['date']&lt;'2021-01-01']<br/>prediction=[]<br/>my_order = (0, 1, 1)<br/>my_seasonal_order = (1, 0, 1, 4)<br/>initial=len(train)</span><span id="aaa4" class="no ml it nk b gy nt nq l nr ns">initial_train=data_updated.iloc[:initial]<br/>model = sm.tsa.statespace.SARIMAX(initial_train['value'], order=my_order, seasonal_order=my_seasonal_order)<br/>results=model.fit()</span><span id="1eda" class="no ml it nk b gy nt nq l nr ns">#Iteratively update the training data and predict following week<br/>for i in range(initial,len(data)):<br/>    updated_data=data_updated.iloc[i:i+1]['value']<br/>    results=results.append(updated_data,refit=False)<br/>    prediction.append(results.forecast()[0])</span><span id="4efa" class="no ml it nk b gy nt nq l nr ns">from sklearn.metrics import mean_absolute_error<br/>print(mean_absolute_error(test['value'], prediction))</span><span id="368b" class="no ml it nk b gy nt nq l nr ns">#8469.6746</span></pre><p id="e39b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该模型的性能比两个移动平均结果好得多，平均误差值减少了15%。</p><h2 id="a7e2" class="no ml it bd mm oe of dn mq og oh dp mu li oi oj mw lm ok ol my lq om on na oo bi translated">方法4:自动ARIMA(自动调整参数)</h2><p id="f556" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">方法4使用相同的ARIMA模型，但是具有提供自动调谐功能的<strong class="lb iu">不同的封装</strong>。我使用的是pm.auto_arima包，你可以通过链接了解更多关于这个包的功能。</p><p id="0095" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">和前面的方法一样，你需要确定所有参数的取值范围。您也可以在您的步进参数中指定<strong class="lb iu">是使用步进还是网格搜索。如果没有设置stepwise=True，默认情况下它会使用网格搜索，这可能会很慢。</strong></p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="d4e7" class="no ml it nk b gy np nq l nr ns">train_index=train.set_index('date')</span><span id="4322" class="no ml it nk b gy nt nq l nr ns">#Spesify the value range for parameters<br/>model = pm.auto_arima(train_index['value'], <br/>                          start_p=0, start_q=0,d=1, max_p=5, <br/>                          max_q=5, start_P=0, D=None, start_Q=0, max_P=5, <br/>                          max_D=5, max_Q=5,stepwise=True,seasonal=True)</span><span id="6dd4" class="no ml it nk b gy nt nq l nr ns">prediction=[]</span><span id="3702" class="no ml it nk b gy nt nq l nr ns">#Recurrently predict following week and add the data into training model once we have predicted that week<br/>for i in test['value']:<br/>    predict=model.predict(n_periods=1)[0]<br/>    prediction.append(predict)<br/>    model.update(i)<br/>from sklearn.metrics import mean_absolute_error<br/>print(mean_absolute_error(test['value'], prediction))<br/>#8863.74</span></pre><p id="e0bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该模型有一个<strong class="lb iu">更新功能</strong>，允许我使用动态的历史数据循环计算下一周的数据。有趣的是，最终结果比手动调优方法的错误数略高，这可能是由于分步方法或不同软件包之间的算法略有不同。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pe"><img src="../Images/d08538a409d249acce27ee6a2290f0ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Sz5-gXxMYACJ-uZ77NSRIA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">SARIMA手动调谐与自动调谐</p></figure><p id="09bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我绘制这两种SARIMA方法的预测图时，我可以看出这两种方法比简单或指数加权移动平均方法更接近实际步数趋势。然而，SARIMA模型也不能非常准确地捕捉波动。误差率范围在20–30%之间。</p><h1 id="1018" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">结论或建议</h1><ol class=""><li id="f616" class="op oq it lb b lc nc lf nd li pf lm pg lq ph lu pi ov ow ox bi translated">在本例中，我对以下一周的值进行递归计算。但是，您很可能需要使用历史数据来预测接下来N(N&gt;1)周的值。这实际上要简单得多，因为一旦得到模型，您可以将n_periods指定为您想要预测的时间段的数量(不需要迭代地更新模型)</li><li id="e208" class="op oq it lb b lc oy lf oz li pa lm pb lq pc lu pi ov ow ox bi translated">网上有文章介绍如何确定数据是平稳的，或者我们如何使用统计方法(如“扩展的Dickey Fuller测试”)来确定AR和MA项的值。这可以更好地确定数据的分布并防止过度拟合。</li><li id="8eb4" class="op oq it lb b lc oy lf oz li pa lm pb lq pc lu pi ov ow ox bi translated">萨里玛或ARIMA方法通常比简单移动平均或指数加权移动平均方法更好，因为它考虑了误差项</li><li id="0861" class="op oq it lb b lc oy lf oz li pa lm pb lq pc lu pi ov ow ox bi translated">需要注意的一件非常重要的事情是，我们应该始终记住使用我们预测的日期之前的数据作为训练数据，这对我们来说很难使用交叉验证。</li></ol><p id="ac74" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，最后的结论是:在高精度水平上预测步数真的很难！</p><h1 id="98bc" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">参考或推荐阅读</h1><ol class=""><li id="0c6c" class="op oq it lb b lc nc lf nd li pf lm pg lq ph lu pi ov ow ox bi translated"><a class="ae ky" href="https://www.digitalocean.com/community/tutorials/a-guide-to-time-series-forecasting-with-arima-in-python-3" rel="noopener ugc nofollow" target="_blank">https://www . digital ocean . com/community/tutorials/a-guide-to-time-series-forecasting-with-arima-in-python-3</a>(如何使用最低AIC选择ARIMA参数)</li><li id="b89d" class="op oq it lb b lc oy lf oz li pa lm pb lq pc lu pi ov ow ox bi translated"><a class="ae ky" href="https://www.machinelearningplus.com/time-series/arima-model-time-series-forecasting-python/" rel="noopener ugc nofollow" target="_blank">https://www . machine learning plus . com/time-series/ARIMA-model-time-series-forecasting-python/</a>(如何统计确定参数值)</li><li id="ff2b" class="op oq it lb b lc oy lf oz li pa lm pb lq pc lu pi ov ow ox bi translated"><a class="ae ky" href="https://github.com/markwk/qs_ledger/blob/master/apple_health/apple_health_extractor.ipynb" rel="noopener ugc nofollow" target="_blank">https://github . com/markwk/QS _ ledger/blob/master/apple _ health/apple _ health _ extractor . ipynb</a>。(从Apple Health提取数据的代码)</li><li id="27b4" class="op oq it lb b lc oy lf oz li pa lm pb lq pc lu pi ov ow ox bi translated">https://towards data science . com/what-the-best-metrics-to-evaluate-your-regression-model-418 ca 481755 b(如何评估你的回归模型)</li><li id="cf08" class="op oq it lb b lc oy lf oz li pa lm pb lq pc lu pi ov ow ox bi translated"><a class="ae ky" href="https://www.statsmodels.org/dev/generated/statsmodels.tsa.statespace.sarimax.SARIMAX.html" rel="noopener ugc nofollow" target="_blank">https://www . stats models . org/dev/generated/stats models . TSA . statespace . sarimax . sarimax . html</a>(SARIMA模型包，手动调优)</li><li id="a174" class="op oq it lb b lc oy lf oz li pa lm pb lq pc lu pi ov ow ox bi translated"><a class="ae ky" href="https://alkaline-ml.com/pmdarima/modules/generated/pmdarima.arima.auto_arima.html" rel="noopener ugc nofollow" target="_blank">https://alkaline-ml . com/pmdarima/modules/generated/pmdarima . ARIMA . auto _ ARIMA . html</a>(SARIMA模型包，自动调优)</li></ol><p id="8d18" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读！如果你有任何问题或任何你想了解更多的话题，请把它们放在评论框里！</p></div></div>    
</body>
</html>