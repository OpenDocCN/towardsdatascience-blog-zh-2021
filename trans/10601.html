<html>
<head>
<title>Dockerize Your Dash App</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将你的Dash应用归档</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/dockerize-your-dash-app-1e155dd1cea3?source=collection_archive---------8-----------------------#2021-10-11">https://towardsdatascience.com/dockerize-your-dash-app-1e155dd1cea3?source=collection_archive---------8-----------------------#2021-10-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="fe3b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">让Dash为简单、现代的部署做好准备</h2></div><p id="39d5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">由<a class="ae le" href="https://www.linkedin.com/in/edkrueger/" rel="noopener ugc nofollow" target="_blank">爱德华·克鲁格</a>和<a class="ae le" href="https://www.linkedin.com/in/erin-oefelein-3105a878/" rel="noopener ugc nofollow" target="_blank">艾琳·欧菲琳</a></p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi lf"><img src="../Images/4ecf01b8fea6fcc7d726e1b8c135308e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4vpaQuV8C2uN6EY3aa1x-A.jpeg"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">照片由<a class="ae le" href="https://unsplash.com/@sebaspenalambarri?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">塞巴斯蒂安·佩纳·兰巴里</a>在<a class="ae le" href="https://unsplash.com/s/photos/whale-shark?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="d1e2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">本文将研究如何对我们已经构建的Dash应用程序进行Dockerize。理解应用程序的结构很重要，所以请在这里查看存储库<a class="ae le" href="https://github.com/edkrueger/dash-template" rel="noopener ugc nofollow" target="_blank">。如果你想了解更多的细节和解释，可以看看我们在这里详细介绍这个结构的文章:</a></p><div class="lv lw gp gr lx ly"><a rel="noopener follow" target="_blank" href="/structuring-your-dash-app-e33d8e70133e"><div class="lz ab fo"><div class="ma ab mb cl cj mc"><h2 class="bd iu gy z fp md fr fs me fu fw is bi translated">构建您的Dash应用</h2><div class="mf l"><h3 class="bd b gy z fp md fr fs me fu fw dk translated">选择正确的结构使得开发和部署Dash应用程序变得更加容易</h3></div><div class="mg l"><p class="bd b dl z fp md fr fs me fu fw dk translated">towardsdatascience.com</p></div></div><div class="mh l"><div class="mi l mj mk ml mh mm lp ly"/></div></div></a></div><p id="36fa" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在你已经根据我们的第一篇文章构建了你的Dash应用程序，你已经为你的应用程序做好了准备。</p><h2 id="a5d4" class="mn mo it bd mp mq mr dn ms mt mu dp mv kr mw mx my kv mz na nb kz nc nd ne nf bi translated">Docker是什么？你为什么要用它？</h2><p id="18d4" class="pw-post-body-paragraph ki kj it kk b kl ng ju kn ko nh jx kq kr ni kt ku kv nj kx ky kz nk lb lc ld im bi translated">Docker是一个提供容器的平台。像虚拟机(VM)一样，Docker容器是一个打包的计算环境，它将各种软件组件与系统的其余部分隔离开来。两者的主要区别在于规模和可移植性。容器比虚拟机更轻量级，容器映像以兆字节而不是吉字节来度量。</p><p id="5269" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Docker容器解决了软件几十年来的一个痛点。跨不同平台管理软件非常耗时，因为每个平台都需要应用程序依赖、解释器、二进制文件等。Docker提供了跨平台的一致性，简化了软件维护和部署。</p><p id="a742" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">难怪像Google、Azure、AWS和其他平台使用Docker来简化所有用户及其不同操作系统的应用部署。在这里，您将了解如何利用一项革命性的部署技术！</p><h2 id="0182" class="mn mo it bd mp mq mr dn ms mt mu dp mv kr mw mx my kv mz na nb kz nc nd ne nf bi translated">安装Docker</h2><p id="3d66" class="pw-post-body-paragraph ki kj it kk b kl ng ju kn ko nh jx kq kr ni kt ku kv nj kx ky kz nk lb lc ld im bi translated">要对你的应用进行Docker化，你首先需要安装Docker。安装Docker对Mac用户来说很简单，但对Windows用户来说稍微复杂一点。如果不安装Windows System for Linux (WSL2)并从该服务中运行Docker，Windows计算机将无法运行Docker。我们在这里为那些希望使用这个选项的人链接了一个指南<a class="ae le" href="https://www.hanselman.com/blog/how-to-set-up-docker-within-windows-system-for-linux-wsl2-on-windows-10" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="1575" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一旦安装完毕，你需要在你的机器上初始化Docker。除非服务在后台运行，否则Docker命令将不起作用。</p><h2 id="be0a" class="mn mo it bd mp mq mr dn ms mt mu dp mv kr mw mx my kv mz na nb kz nc nd ne nf bi translated">编写Dockerfile文件</h2><p id="ee74" class="pw-post-body-paragraph ki kj it kk b kl ng ju kn ko nh jx kq kr ni kt ku kv nj kx ky kz nk lb lc ld im bi translated">Dockerfile是一组命令，告诉Docker如何构建你的容器。它包括关于Docker容器应该扩展什么样的基本映像的信息，需要的任何额外的安装或配置步骤，以及关于运行应用程序的说明。</p><p id="269e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们在下面提供了我们的docker文件，因此您可以使用正确的规范轻松创建您的docker文件:</p><pre class="lg lh li lj gt nl nm nn no aw np bi"><span id="2f8f" class="mn mo it nm b gy nq nr l ns nt">FROM python:3.9-slim<br/>COPY requirements.txt ./requirements.txt<br/>RUN pip install -r requirements.txt<br/>COPY . ./<br/>CMD gunicorn -b 0.0.0.0:80 app.app:server</span></pre><p id="2c2c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">关于这个Dockerfile，有一点可能看起来令人困惑，那就是它分两个阶段复制文件。我们这样做是因为Docker分层构建容器，粗略地说，每一行对应一层。构建第一次运行时，它会缓存每个层。如果一个层不需要更改，我们可以使用Docker的缓存层来加快构建速度。</p><p id="6db8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们仔细看看它的行为。在第一个<code class="fe nu nv nw nm b">COPY</code>命令中，我们只将<code class="fe nu nv nw nm b">requirements.txt</code>文件复制到容器中。</p><p id="f3ef" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在为<code class="fe nu nv nw nm b">RUN</code>线。在一个构建中，如果<code class="fe nu nv nw nm b">requirements.txt</code>没有被改变，那么下一层，即安装，可以被跳过。如果缓存了，Docker就不会重新运行这个层，所以不需要重新安装Python依赖项。</p><p id="b569" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在第二个<code class="fe nu nv nw nm b">COPY</code>行中，我们将应用程序文件的剩余部分复制到容器中。自上次构建以来，一些应用程序代码可能已经更改，这意味着用于<em class="nx">之后的</em>层的缓存已经没有数据了。尽管如此，由于先前的<em class="nx">层已经被构建或从缓存中获取，这一行不会触发其他依赖项重新安装。</em></p><p id="5c57" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们一次复制所有的代码和依赖项，那么更改代码会使缓存无效，即使需求没有改变，依赖项也会被重新安装。</p><p id="6545" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要深入了解优化容器，请查看Sciforce的这篇文章。</p><div class="lv lw gp gr lx ly"><a href="https://medium.com/sciforce/strategies-of-docker-images-optimization-2ca9cc5719b6" rel="noopener follow" target="_blank"><div class="lz ab fo"><div class="ma ab mb cl cj mc"><h2 class="bd iu gy z fp md fr fs me fu fw is bi translated">码头形象优化策略</h2><div class="mf l"><h3 class="bd b gy z fp md fr fs me fu fw dk translated">我们给出了通过减少构建时间和图像大小来优化Docker图像的策略的详细回顾。</h3></div><div class="mg l"><p class="bd b dl z fp md fr fs me fu fw dk translated">medium.com</p></div></div><div class="mh l"><div class="oa l mj mk ml mh mm lp ly"/></div></div></a></div><h2 id="b1a4" class="mn mo it bd mp mq mr dn ms mt mu dp mv kr mw mx my kv mz na nb kz nc nd ne nf bi translated">构建Docker容器</h2><p id="515f" class="pw-post-body-paragraph ki kj it kk b kl ng ju kn ko nh jx kq kr ni kt ku kv nj kx ky kz nk lb lc ld im bi translated">要启动Docker容器构建，请运行:</p><pre class="lg lh li lj gt nl nm nn no aw np bi"><span id="572d" class="mn mo it nm b gy nq nr l ns nt">docker build -t tiny_home .</span></pre><p id="9cea" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">t标志“标记”我们的图像，并允许我们命名容器。标签是有帮助的，因为它允许我们用一个更容易理解的名字而不是机器语言来引用我们的容器。在这里，我们将容器命名为<em class="nx"> tiny_home </em>。</p><p id="fdfa" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个命令使用我们的Dockerfile来构建一个新的容器映像。当Docker处理我们的Docker文件时，它从包含Docker Python映像的基本Python容器开始。</p><h2 id="5ce4" class="mn mo it bd mp mq mr dn ms mt mu dp mv kr mw mx my kv mz na nb kz nc nd ne nf bi translated">Docker图像</h2><p id="eb1b" class="pw-post-body-paragraph ki kj it kk b kl ng ju kn ko nh jx kq kr ni kt ku kv nj kx ky kz nk lb lc ld im bi translated">Docker基础映像有多种类型。我们使用的是Python镜像的精简版本，当您希望安装运行Python所需的最小软件包时，这是最佳选择。后缀<code class="fe nu nv nw nm b">-slim</code>表示容器应该只装必需品。对于许多基本映像，有精简版和完整版。slim比完整版包含的少，所以图像更小，是处理空间限制的理想选择。对于大多数语言，也有一个维护的完整版本的图像。如果您不确定在应用程序中使用哪种类型，完整图像通常是最佳选择。如果你想阅读更多关于这个话题的内容，看看朱莉·紫苏·加西亚的这篇文章吧！</p><div class="lv lw gp gr lx ly"><a href="https://medium.com/swlh/alpine-slim-stretch-buster-jessie-bullseye-bookworm-what-are-the-differences-in-docker-62171ed4531d" rel="noopener follow" target="_blank"><div class="lz ab fo"><div class="ma ab mb cl cj mc"><h2 class="bd iu gy z fp md fr fs me fu fw is bi translated">阿尔卑斯，苗条，拉伸，巴斯特，杰西，牛眼，书虫Docker有什么区别…</h2><div class="mf l"><h3 class="bd b gy z fp md fr fs me fu fw dk translated">而我该选择哪一个呢？</h3></div><div class="mg l"><p class="bd b dl z fp md fr fs me fu fw dk translated">medium.com</p></div></div><div class="mh l"><div class="ob l mj mk ml mh mm lp ly"/></div></div></a></div><p id="7c1e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">图像通常包括许多层。层可能包括系统库、工具、依赖项和其他文件。在我们的例子中，Python slim映像从从DockerHub访问现有的Python slim容器开始。映像下载到本地后，就安装了Debian/Linux OS发行版和Python的最新稳定版本。最后，Docker编译所有应用程序文件并安装应用程序需求。</p><p id="b741" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我们的设置中，我们通过在预提交钩子中运行<code class="fe nu nv nw nm b">pipenv-to-requirements</code>，从我们的<code class="fe nu nv nw nm b">Pipfile</code>生成<code class="fe nu nv nw nm b">requirements.txt</code>和<code class="fe nu nv nw nm b">requirements-dev.txt</code>。由于我们只引用<code class="fe nu nv nw nm b">requirements.txt</code> Docker永远看不到发展。仅使用在我们的容器中运行应用程序所必需的依赖项可以加快构建过程，减小容器的大小，并可能提高安全性。如果你还没有这样做，请参考我们的第一篇文章，运行这些钩子。这将使这个过程变得更加容易！</p><p id="9ccb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一旦构建了Docker容器，就可以通过运行以下命令来查看它:</p><pre class="lg lh li lj gt nl nm nn no aw np bi"><span id="6f26" class="mn mo it nm b gy nq nr l ns nt">docker image ls</span></pre><p id="4b37" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后您会看到tiny_home图像填充在这里:</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/b22d68f0201caff94669795bd38f288f.png" data-original-src="https://miro.medium.com/v2/resize:fit:914/format:webp/1*TiOj5gA_k-Yp9xXmrq3rjQ.png"/></div></figure><p id="1ebd" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">由于我们已经成功构建了docker容器，该应用程序将通过端口80上的gunicorn运行。要访问我们的应用程序运行的地址，我们需要将它在Docker主机上运行的端口(端口80)映射到本地主机上的一个端口。这里，我们将把我们的应用程序映射到端口8080。要进行端口映射并同时运行我们的应用程序，请运行:</p><pre class="lg lh li lj gt nl nm nn no aw np bi"><span id="06cb" class="mn mo it nm b gy nq nr l ns nt">docker run -p 8080:80 tiny_home</span></pre><p id="138d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当您访问<a class="ae le" href="http://localhost:8080/" rel="noopener ugc nofollow" target="_blank"> http://localhost:8080/ </a>(或0.0.0.0:8080，取决于您的操作系统)时，您应该会看到您的应用程序在Docker容器中运行！对于那些不知道的，localhost是127.0.0.1的别名，而0.0.0.0引用所有本地IP地址。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi od"><img src="../Images/ac1f11e4a927fea2863f8c4bec563ec7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1294/format:webp/1*t9Q36CEu4n-EUBax9U9s1Q.png"/></div></figure><p id="a920" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您得到一个错误，指示“绑定0.0.0.0:8080失败:端口已被分配”，您可以按照这个<a class="ae le" href="https://stackoverflow.com/questions/24387451/how-can-i-kill-whatever-process-is-using-port-8080-so-that-i-can-vagrant-up/24388281" rel="noopener ugc nofollow" target="_blank">堆栈溢出</a>对话和提供的解决方案来终止任何正在使用端口8080的进程。</p><p id="44c8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您的应用程序现在已被归档！</p><p id="046f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">敬请关注我们下一篇关于将您的应用部署到GCP的云运行服务的文章！</p><p id="5833" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们希望你喜欢这篇文章！要获得更多关于数据科学、机器学习和开发的内容，请查看<a class="ae le" href="https://www.youtube.com/channel/UCmvdvjDaSjjMRIAxE5s7EZA" rel="noopener ugc nofollow" target="_blank"> Edward的YouTube频道</a>，并订阅我下面的邮件列表，成为第一个听到新文章的人！</p><div class="lv lw gp gr lx ly"><a href="https://edkruegerdata.com/subscribe" rel="noopener  ugc nofollow" target="_blank"><div class="lz ab fo"><div class="ma ab mb cl cj mc"><h2 class="bd iu gy z fp md fr fs me fu fw is bi translated">每当爱德华·克鲁格发表文章时，就收到一封电子邮件。</h2><div class="mg l"><p class="bd b dl z fp md fr fs me fu fw dk translated">edkruegerdata.com</p></div></div><div class="mh l"><div class="oe l mj mk ml mh mm lp ly"/></div></div></a></div></div></div>    
</body>
</html>