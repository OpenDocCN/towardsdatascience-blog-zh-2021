<html>
<head>
<title>Build a Data Collection App on the Cloud for Your Next Time Series Data Science Project</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为你的下一个时间序列数据科学项目在云上构建一个数据收集应用</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/build-a-data-collection-app-on-the-cloud-for-your-next-time-series-data-science-project-71e6d6291a70?source=collection_archive---------38-----------------------#2021-04-26">https://towardsdatascience.com/build-a-data-collection-app-on-the-cloud-for-your-next-time-series-data-science-project-71e6d6291a70?source=collection_archive---------38-----------------------#2021-04-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ce94" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用Python和PostgreSQL在Heroku上构建和部署数据收集应用程序的分步指南</h2></div><p id="ae18" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="le">注:本帖代码可在</em> <a class="ae lf" href="https://github.com/kevinclee26/data_collection_demo" rel="noopener ugc nofollow" target="_blank"> <em class="le">这里</em> </a>找到</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi lg"><img src="../Images/c4a575fa4f0119f3c79e9663f73582fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-aYEtg-b-W7P2ao9t0QypA.png"/></div></div><p class="ls lt gj gh gi lu lv bd b be z dk translated">计划的数据收集应用程序工作流(图片由作者提供)</p></figure><p id="09a3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">尽管近年来观察到数据激增，但我们经常发现自己被项目数据的缺乏所阻碍。在典型的一天网页浏览中，我们会遇到无数的信息(数据)，这些信息可能会产生伟大的数据科学想法，如当前天气、交通、灾难预警、股票价格、投票计数、covid计数、浏览量计数、社交媒体评论等等。我们知道数据得到维护并可供公众使用，但很少有方便的汇编。在本文中，我们将一步一步地介绍使用Python中的<strong class="kk iu"> RDMS </strong> ( <strong class="kk iu">关系数据库管理系统</strong>)开发和部署数据收集应用程序。意识到根据收集的数据不同，各个脚本可能会有很大的不同，我们采用的方法是遍历一个简单的示例，同时为每个步骤提供充分的推理:</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi lw"><img src="../Images/1fe4558f90b4525b4d9ef41808ca70f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6yymOB66jv3I65QjFwHVUQ.png"/></div></div><p class="ls lt gj gh gi lu lv bd b be z dk translated">开发步骤</p></figure><p id="fb66" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个演示应用程序将由一个收集公共可用数据快照的脚本和一个定期调用收集脚本的调度程序组成。应用程序可以选择性地部署在云上，这提供了<strong class="kk iu">可靠性</strong>和<strong class="kk iu">可用性</strong>(以及其他好处)。我们选择了<a class="ae lf" href="https://www.heroku.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu"> Heroku </strong> </a>进行部署，这是一个平台即服务(<strong class="kk iu"> PaaS </strong>)，使开发者能够完全在云端构建、运行和操作应用。</p><h2 id="efa9" class="lx ly it bd lz ma mb dn mc md me dp mf kr mg mh mi kv mj mk ml kz mm mn mo mp bi translated">定义目标和目的</h2><p id="3368" class="pw-post-body-paragraph ki kj it kk b kl mq ju kn ko mr jx kq kr ms kt ku kv mt kx ky kz mu lb lc ld im bi translated">有许多不同的方式来获取数据:API请求、web抓取以及介于两者之间的任何方式。项目的第一步是确定可靠的数据源。我们的灵感来自于<a class="ae lf" href="https://en.wikipedia.org/wiki/Open_data" rel="noopener ugc nofollow" target="_blank">开放数据</a>，这是一个想法，即<strong class="kk iu">一些</strong>数据应该免费提供给每个人，让他们随心所欲地使用。它的目标类似于其他“开放(源代码)”运动，如开源软件。有趣的是，美国联邦和地方层面的<a class="ae lf" href="https://en.wikipedia.org/wiki/Public_sector" rel="noopener ugc nofollow" target="_blank">公共部门</a>在数据透明方面取得了巨大进步。我们使用来自511.org<a class="ae lf" href="https://511.org/open-data/traffic" rel="noopener ugc nofollow" target="_blank"><strong class="kk iu"/></a>的数据进行演示。它们为<strong class="kk iu">当前交通事件</strong>提供了一个方便的API(参见<a class="ae lf" href="https://511.org/open-data/traffic" rel="noopener ugc nofollow" target="_blank">文档</a>)。<strong class="kk iu"> API密钥</strong>需要注册，请求受发行方的费率限制。一旦接收到，响应就会以JSON格式出现，我们可以用它来提取有用的数据。我们感兴趣的是捕捉仅具有以下属性的单个交通事件。通过开发一个自动化脚本，我们希望收集所有交通事件的汇编。</p><pre class="lh li lj lk gt mv mw mx my aw mz bi"><span id="3c69" class="lx ly it mw b gy na nb l nc nd">one_record={'<strong class="mw iu">id</strong>': '511.org/721616'<br/>            '<strong class="mw iu">headline</strong>': 'Caltrans Bridge work...', <br/>            '<strong class="mw iu">event_type</strong>': 'CONSTRUCTION', <br/>            '<strong class="mw iu">severity</strong>': 'Unknown', <br/>            '<strong class="mw iu">lat</strong>': -122.241176, <br/>            '<strong class="mw iu">lon</strong>': 38.483586}</span></pre><h2 id="4a36" class="lx ly it bd lz ma mb dn mc md me dp mf kr mg mh mi kv mj mk ml kz mm mn mo mp bi translated">创建GitHub存储库并设置虚拟环境</h2><p id="8b82" class="pw-post-body-paragraph ki kj it kk b kl mq ju kn ko mr jx kq kr ms kt ku kv mt kx ky kz mu lb lc ld im bi translated"><a class="ae lf" href="https://en.wikipedia.org/wiki/Git" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu"> Git </strong> </a>是一个免费开源的分布式版本控制系统。它跟踪对项目所在的<strong class="kk iu">存储库</strong>中的文件所做的所有更改。GitHub是一个Git存储库托管平台，允许开发者为开源和私有项目构建软件。包括Heroku在内的许多平台都支持与GitHub的集成，从而简化了代码部署。</p><p id="5b2e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">更多关于Git和基本用法的信息可以在<a class="ae lf" href="https://medium.com/swlh/git-with-the-program-quick-guide-to-collaboration-using-git-3039ebba1bff" rel="noopener"> <strong class="kk iu">这里</strong> </a>找到。我们将在GitHub上为这个项目创建一个远程存储库，并使用<code class="fe ne nf ng mw b">$ <strong class="kk iu">git clone "</strong><a class="ae lf" href="https://github.com/[github_user_name]/[repo_name].git" rel="noopener ugc nofollow" target="_blank"><strong class="kk iu">https://github.com/[github_name]/[repo_name].git</strong></a><strong class="kk iu">”</strong></code>将其克隆到我们的本地机器上。使用<code class="fe ne nf ng mw b">$ <strong class="kk iu">cd [repo_name]</strong></code>更改目录，以确保命令是针对作为根的新存储库执行的。</p><p id="915d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来，我们将为项目创建一个<strong class="kk iu">虚拟环境</strong>。虚拟环境的主要目的是为项目创建隔离的环境。这意味着每个项目都可以有自己的依赖项，不管其他项目有什么依赖项。同样，在开发具有特定需求的应用程序时，虚拟环境也很重要。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi nh"><img src="../Images/78e5fd75b0341d591fe38c94daa194fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pRNwaQYuaeW-bjwlHm6luA.png"/></div></div><p class="ls lt gj gh gi lu lv bd b be z dk translated">虚拟环境</p></figure><p id="0e0c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">用<code class="fe ne nf ng mw b">$ <strong class="kk iu">conda create --name env_name python=3.6</strong></code>创建一个新环境，用<code class="fe ne nf ng mw b">$ <strong class="kk iu">conda activate env_name</strong></code>激活。注意，我们用<code class="fe ne nf ng mw b"><strong class="kk iu">python=3.6</strong></code>指定了新环境，以包括<strong class="kk iu"> pip </strong>(在3.4中添加了<strong class="kk iu">Python</strong>的包安装程序)和<strong class="kk iu"> f字符串</strong>(在3.6中添加了<strong class="kk iu">格式化字符串文字</strong>)。在此项目目录/存储库中安装应用程序和运行命令时，应该激活此环境。由于这是一个新环境，所有的依赖项都需要通过<code class="fe ne nf ng mw b">$ <strong class="kk iu">pip install</strong></code>安装，然后才能导入。使用<code class="fe ne nf ng mw b">$ <strong class="kk iu">conda deactivate</strong></code>停用虚拟环境。</p><p id="3c08" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们还需要为应用程序设置<strong class="kk iu">环境变量</strong>。环境变量被认为是<a class="ae lf" href="https://devcenter.heroku.com/articles/config-vars" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu">操作系统</strong> </a>的一部分，存在于任何特定脚本之外。我们可以使用环境变量来隐藏敏感的凭证，比如511 API密钥。它们可以在我们部署时在主机上设置，但也需要在本地可用以进行开发。这些变量应该被限制在项目的范围内，所以我们真正需要的是“临时的”环境变量。幸运的是，我们可以使用<a class="ae lf" href="https://pypi.org/project/python-dotenv/" rel="noopener ugc nofollow" target="_blank"><strong class="kk iu">python-dotenv</strong></a>从<code class="fe ne nf ng mw b">.env</code>文件中读入键值对，并在运行时将它们设置为环境变量。这允许我们开发我们的脚本，就像环境变量已经设置好了一样。应该将<code class="fe ne nf ng mw b">.env</code>文件添加到<code class="fe ne nf ng mw b">.gitignore</code>中，这样它就不会包含在本地或远程的git提交中。</p><pre class="lh li lj lk gt mv mw mx my aw mz bi"><span id="0692" class="lx ly it mw b gy na nb l nc nd">$ <strong class="mw iu">echo "FIVEONEONE_TOKEN=[api_key]" &gt; .env<br/></strong>$ <strong class="mw iu">echo ".env" &gt;&gt; .gitignore</strong></span></pre><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi ni"><img src="../Images/5063b0d1a7a2e5d870fe96c99811c9ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Gq-5GH2FHl3nmueJwhMtjg.png"/></div></div><p class="ls lt gj gh gi lu lv bd b be z dk translated">环境变量比脚本更安全</p></figure><h2 id="8a30" class="lx ly it bd lz ma mb dn mc md me dp mf kr mg mh mi kv mj mk ml kz mm mn mo mp bi translated">开发数据收集脚本和数据库</h2><p id="2fe7" class="pw-post-body-paragraph ki kj it kk b kl mq ju kn ko mr jx kq kr ms kt ku kv mt kx ky kz mu lb lc ld im bi translated">在这一步中，我们将创建一个脚本来从数据源获取一次数据。在本演示中，我们使用分配的api_key向指定的端点发出请求。</p><figure class="lh li lj lk gt ll"><div class="bz fp l di"><div class="nj nk l"/></div><p class="ls lt gj gh gi lu lv bd b be z dk translated">fetch.py</p></figure><p id="d0e6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们实现了对请求成功与否的条件检查。一旦收到，响应包含<a class="ae lf" href="https://en.wikipedia.org/wiki/JSON" rel="noopener ugc nofollow" target="_blank"> JSON </a>格式的数据。具体来说，我们对JSON的<code class="fe ne nf ng mw b">events</code>键中的活动交通事件的<strong class="kk iu">列表</strong>感兴趣。在安装必要的依赖项后，我们可以用<code class="fe ne nf ng mw b">$ <strong class="kk iu">python fetch.py</strong></code>测试这个脚本:</p><pre class="lh li lj lk gt mv mw mx my aw mz bi"><span id="b351" class="lx ly it mw b gy na nb l nc nd">$ <strong class="mw iu">pip install requests</strong><br/>$ <strong class="mw iu">pip install python-dotenv</strong></span></pre><p id="d21e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来我们想把数据保存在数据库中，但是我们必须先做一点数据库工程。在这一步中，我们要充分考虑数据的大小以及如何使用数据。一般有两种类型的数据库:<strong class="kk iu"> SQL </strong>和<strong class="kk iu"> NoSQL </strong>。相比之下，SQL数据库需要更多的工作来建立，但当数据有一个定义的模式时是合适的。因为它与我们的数据相关——假设我们已经确定了想要收集的属性子集，那么使用SQL数据库是有意义的。我们将得到一个“事件”表，其中每个<strong class="kk iu">行</strong>代表一个事件，每个<strong class="kk iu">列</strong>代表一个感兴趣的属性。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi nl"><img src="../Images/7d4e9c9766150e544761198d46725506.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rxxUmXQQBybyEBQ9E6A3lg.png"/></div></div><p class="ls lt gj gh gi lu lv bd b be z dk translated">SQL数据库上的示例事件表</p></figure><p id="64d0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">换句话说，从我们收到的JSON中的交通事件列表<strong class="kk iu">开始，我们将<strong class="kk iu">遍历每个元素</strong>并解析出我们感兴趣的属性。我们可以使用<a class="ae lf" href="https://www.sqlalchemy.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu"> SQLAlchemy </strong> </a>库在Python中使用SQL。SQLAlchemy是一个<strong class="kk iu"> Python SQL toolkit </strong>和<strong class="kk iu">对象关系映射器</strong>，可以实现SQL的全部功能。</strong></p><p id="556f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在将记录存储到数据库之前，我们必须定义表模式。使用<a class="ae lf" href="https://docs.sqlalchemy.org/en/14/orm/declarative_mapping.html" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu">声明性</strong> </a>将该模式映射到一个Python类，因此每个记录将被表示为其实例。</p><figure class="lh li lj lk gt ll"><div class="bz fp l di"><div class="nj nk l"/></div><p class="ls lt gj gh gi lu lv bd b be z dk translated">models.py</p></figure><p id="f8e5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们在一个单独的脚本<code class="fe ne nf ng mw b">models.py</code>中布置数据库表的模式，稍后我们可以调用这个脚本来创建表和记录。请注意，SQLAlchemy ORM要求每个表都有一个主键。</p><p id="a76b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">将<code class="fe ne nf ng mw b">fetch.py</code>脚本修改为<code class="fe ne nf ng mw b">fetch_insert.py</code>到<strong class="kk iu"> 1) </strong>连接到数据库，<strong class="kk iu"> 2) </strong>基于<code class="fe ne nf ng mw b">models.py</code>创建表，<strong class="kk iu"> 3) </strong>遍历响应中的每个元素/解析出感兴趣的属性，并且<strong class="kk iu"> 4) </strong>创建要插入到数据库中的映射Python类的实例。</p><figure class="lh li lj lk gt ll"><div class="bz fp l di"><div class="nj nk l"/></div><p class="ls lt gj gh gi lu lv bd b be z dk translated">获取_插入. py</p></figure><p id="8adf" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们使<code class="fe ne nf ng mw b">models.py</code>成为<strong class="kk iu">依赖</strong>(如<code class="fe ne nf ng mw b">from models import *</code>)来加载模式以创建表和记录。</p><p id="0cf7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用SQLAlchemy从在<a class="ae lf" href="https://docs.sqlalchemy.org/en/14/core/engines.html#database-urls" rel="noopener ugc nofollow" target="_blank">数据库url </a>建立连接开始。当没有<code class="fe ne nf ng mw b">DATABASE_URL</code>环境变量存在时，我们编写脚本来连接到单个文件<a class="ae lf" href="https://en.wikipedia.org/wiki/SQLite" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu"> SQLite </strong> </a>数据库。我们将SQLite用于开发和备份目的，因为它是独立的、功能齐全的。像<strong class="kk iu"> Postgres </strong>这样的<strong class="kk iu"> DB服务器</strong>通常是首选，因为它支持<strong class="kk iu">可用性</strong>和<strong class="kk iu">可靠性</strong>。一旦我们将生产数据库url作为一个环境变量添加，它将优先建立数据库连接。我们应该将数据库url视为环境变量，因为它包括用户名、密码、主机名和数据库名。</p><p id="d9ec" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe ne nf ng mw b"><a class="ae lf" href="https://docs.sqlalchemy.org/en/14/core/engines.html#sqlalchemy.create_engine" rel="noopener ugc nofollow" target="_blank">sqlalchemy.create_engine()</a></code>和<code class="fe ne nf ng mw b">Base.metadata.create_all()</code>的典型用法是每个特定的数据库URL使用一次，在单个应用程序进程的生命周期内全局保存。单个<code class="fe ne nf ng mw b"><a class="ae lf" href="https://docs.sqlalchemy.org/en/14/core/connections.html#sqlalchemy.engine.Engine" rel="noopener ugc nofollow" target="_blank">Engine</a></code>代表流程管理许多单独的<a class="ae lf" href="https://docs.sqlalchemy.org/en/14/glossary.html#term-DBAPI" rel="noopener ugc nofollow" target="_blank"> DBAPI </a>连接，并且旨在以并发方式被调用。如果表已经存在，SQLAlchemy不会尝试重新创建它们。</p><p id="558a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一旦请求返回了响应，我们就遍历事件列表来收集表记录的数据。在SQLAlchemy中，记录作为映射到SQL表的Python类的实例被添加和操作。<code class="fe ne nf ng mw b">**</code>操作符允许我们获取一个键值对字典，并将其解包为<code class="fe ne nf ng mw b">Events()</code>构造函数的关键字参数。</p><p id="7874" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一旦记录被添加和提交，我们使用<code class="fe ne nf ng mw b">session.close()</code>将资源交还给引擎的连接池。这不应该与<code class="fe ne nf ng mw b">engine.dispose()</code>混淆，后者关闭连接池的所有连接。</p><p id="ac9a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">至此，我们已经构建了一个脚本来收集数据并将记录存储到SQL数据库中。我们可以使用<code class="fe ne nf ng mw b">$ <strong class="kk iu">python fetch_insert.py</strong></code> <strong class="kk iu"> </strong>(在安装完依赖项之后)测试应用程序，这将创建一个新的SQLite文件作为数据库，如果它还不存在的话。</p><pre class="lh li lj lk gt mv mw mx my aw mz bi"><span id="3248" class="lx ly it mw b gy na nb l nc nd">$ <strong class="mw iu">pip install sqlalchemy</strong><br/>$ <strong class="mw iu">pip install psycopg2</strong></span></pre><h2 id="487a" class="lx ly it bd lz ma mb dn mc md me dp mf kr mg mh mi kv mj mk ml kz mm mn mo mp bi translated">添加调度程序</h2><p id="2fcc" class="pw-post-body-paragraph ki kj it kk b kl mq ju kn ko mr jx kq kr ms kt ku kv mt kx ky kz mu lb lc ld im bi translated">我们可以安排数据获取过程按时间间隔运行，从而使我们能够持续收集数据。<a class="ae lf" href="https://apscheduler.readthedocs.io/en/stable/" rel="noopener ugc nofollow" target="_blank"><strong class="kk iu">APS Scheduler</strong></a>(<strong class="kk iu">高级Python调度器</strong>)是一个Python库，它让用户调度Python代码稍后执行，要么只执行一次，要么定期执行<strong class="kk iu"/>。它易于使用，并与其他有用的框架集成。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi nm"><img src="../Images/b106051322c512df977d96d8424efb1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_uJFk5p4HuwkAwdEn3p59A.png"/></div></div><p class="ls lt gj gh gi lu lv bd b be z dk translated">调度程序</p></figure><p id="6515" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">很方便，Heroku在他们的<a class="ae lf" href="https://devcenter.heroku.com/articles/scheduled-jobs-custom-clock-processes" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu">自定义时钟进程</strong> </a>的实现中使用了APScheduler。在他们的<a class="ae lf" href="https://apscheduler.readthedocs.io/en/stable/userguide.html" rel="noopener ugc nofollow" target="_blank">文档</a>中，他们解释说主要有四个组件来促进作业的调度。在主程序中，用户选择一个<strong class="kk iu">调度器</strong>和一个<strong class="kk iu">作业存储器</strong>。调度器负责根据<strong class="kk iu">触发器</strong>将作业添加到作业库中，而<strong class="kk iu">执行器</strong>处理作业的运行。</p><figure class="lh li lj lk gt ll"><div class="bz fp l di"><div class="nj nk l"/></div><p class="ls lt gj gh gi lu lv bd b be z dk translated">clock.py</p></figure><p id="b95c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用APScheduler调度作业很容易——我们在<code class="fe ne nf ng mw b">clock.py</code>中展示的基本实现从定义一个调度器和作业存储(默认为<code class="fe ne nf ng mw b">BlockingScheduler()</code>和<code class="fe ne nf ng mw b">MemoryJobStore()</code>)开始，它们充当运行应用程序的主要过程。接下来，使用包含调度逻辑的特定触发器添加作业。我们通过用<code class="fe ne nf ng mw b">scheduled_job()</code>和调用数据收集脚本的<code class="fe ne nf ng mw b">interval</code>触发器来装饰 函数来做到这一点。从技术上讲，该过程应该被描述为在计算的延迟之后重新执行。为了管理与数据库的连接，我们在主程序中创建引擎连接，并将其传递给收集脚本。我们必须再次将<code class="fe ne nf ng mw b">fetch.py</code>脚本重构为<code class="fe ne nf ng mw b">fetch_job.py</code>来适应这个实现。</p><figure class="lh li lj lk gt ll"><div class="bz fp l di"><div class="nj nk l"/></div><p class="ls lt gj gh gi lu lv bd b be z dk translated">fetch _作业. py</p></figure><p id="86a6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">数据收集脚本被封装在函数<code class="fe ne nf ng mw b">fetch_data</code>中，因此可以很容易地调用它，并接受数据库连接作为参数。对于每个计划的“获取”作业，在关闭之前，会与数据库建立一个会话，直到所有插入操作完成。在安装新的依赖项后，我们可以用<code class="fe ne nf ng mw b">$ <strong class="kk iu">python clock.py</strong></code>测试这个应用程序。</p><pre class="lh li lj lk gt mv mw mx my aw mz bi"><span id="c353" class="lx ly it mw b gy na nb l nc nd">$ <strong class="mw iu">pip install apscheduler</strong></span></pre><h2 id="43ec" class="lx ly it bd lz ma mb dn mc md me dp mf kr mg mh mi kv mj mk ml kz mm mn mo mp bi translated">设置Heroku应用程序并添加配置文件</h2><p id="7d2a" class="pw-post-body-paragraph ki kj it kk b kl mq ju kn ko mr jx kq kr ms kt ku kv mt kx ky kz mu lb lc ld im bi translated">此时，数据收集应用程序以固定的时间间隔“自动”执行，但仅在应用程序处于本地活动状态时执行。我们可以将应用程序部署到Heroku来消除这种依赖性。</p><p id="3bdf" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">本次演示避免使用<strong class="kk iu"> Heroku命令行界面</strong> ( <strong class="kk iu"> CLI </strong>)以保持部署简单。首先，在Heroku 上创建一个新的应用程序。登录(<strong class="kk iu"> #1 </strong>)后，转到“创建新应用”(<strong class="kk iu"> #3 </strong>)并给应用一个唯一的名称以完成创建。Heroku提供了与GitHub的便捷集成，以无缝加载代码进行部署。一旦通过验证(<strong class="kk iu"> #5 </strong>)，开发人员就可以通过名称(<strong class="kk iu"> #7 </strong>)进行搜索，并将应用程序的源代码连接到相应的存储库(<strong class="kk iu"> #8 </strong>)。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi nn"><img src="../Images/9845c364eb26ff543e17a84cd59e1a1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WR6uyBChA7Eu4ONrc-E2kA.png"/></div></div><p class="ls lt gj gh gi lu lv bd b be z dk translated">设置Heroku应用程序</p></figure><p id="a1ba" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在部署之前，我们必须更新GitHub上的源代码，但我们必须首先配置几个设置:<em class="le"> Postgres数据库</em>、<em class="le">配置变量</em>、<em class="le"> requirements.txt </em>和<em class="le"> Procfile </em>。</p><h2 id="7038" class="lx ly it bd lz ma mb dn mc md me dp mf kr mg mh mi kv mj mk ml kz mm mn mo mp bi translated">Heroku应用程序的Postgres数据库附件</h2><p id="248c" class="pw-post-body-paragraph ki kj it kk b kl mq ju kn ko mr jx kq kr ms kt ku kv mt kx ky kz mu lb lc ld im bi translated">Heroku免费提供了一个<strong class="kk iu"> Postgres插件</strong>(有限制)——一个单独的数据库比用于开发的SQLite本地数据库更好，因为它支持应用程序之外的访问。</p><p id="0499" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在Heroku上，进入应用程序主页的资源部分(<strong class="kk iu"> #1 </strong>)。在附加组件下，搜索“Heroku Postgres”(<strong class="kk iu"># 2</strong>&amp;<strong class="kk iu"># 3</strong>)。接下来选择适当的计划(Hobby Dev-Free计划提供多达10k行的数据)并进行配置。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi no"><img src="../Images/3e22368db4538e881215ad20db67f433.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Tpz_ZZiKk33i7OglEr1KBw.png"/></div></div><p class="ls lt gj gh gi lu lv bd b be z dk translated">Heroku-Postgres附加软件</p></figure><h2 id="0db8" class="lx ly it bd lz ma mb dn mc md me dp mf kr mg mh mi kv mj mk ml kz mm mn mo mp bi translated">Heroku构型</h2><p id="3a3c" class="pw-post-body-paragraph ki kj it kk b kl mq ju kn ko mr jx kq kr ms kt ku kv mt kx ky kz mu lb lc ld im bi translated">我们必须将API键和数据库URL设置为环境变量，以防止它们被暴露。从仪表板页面，导航至设置(<strong class="kk iu"> #1 </strong>)并点击“显示配置变量”(<strong class="kk iu"> #2 </strong>)。数据库的连接字符串自动添加到<code class="fe ne nf ng mw b">DATABASE_URL</code> ( <strong class="kk iu"> #3 </strong>)下。这可以用来连接到数据库(在这个项目之外)。我们必须手动添加api_key ( <strong class="kk iu"> #4 </strong>)作为环境变量(<strong class="kk iu"> #5 </strong>)。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi np"><img src="../Images/ed8dd8a9dbbbb71c8245693fc77625ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u2QUL174ttkwC-1eKSx5WQ.png"/></div></div><p class="ls lt gj gh gi lu lv bd b be z dk translated">设置配置变量</p></figure><p id="b6c4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要将应用程序部署到Heroku，还需要两个文件:1) <code class="fe ne nf ng mw b">requirements.txt</code>和2) <code class="fe ne nf ng mw b"><a class="ae lf" href="https://devcenter.heroku.com/articles/procfile" rel="noopener ugc nofollow" target="_blank">Procfile</a></code>。这将有助于Heroku配置托管应用程序的服务器。我们必须在存储库中手动创建这些文件，它们必须位于根目录下，这样Heroku才能在部署过程中找到它们。</p><ol class=""><li id="ef89" class="nq nr it kk b kl km ko kp kr ns kv nt kz nu ld nv nw nx ny bi translated"><em class="le">requirements . txt</em>—列出运行应用程序所需的所有依赖项和包。要创建<em class="le"> requirements.txt </em>文件，运行项目目录中的<code class="fe ne nf ng mw b">$ <strong class="kk iu">pip freeze &gt; requirements.txt</strong></code> <strong class="kk iu"> </strong>命令。这将把活动环境中安装的所有库的列表写入requirements.txt文件。这有助于Heroku为应用程序安装相同的依赖项。</li><li id="d365" class="nq nr it kk b kl nz ko oa kr ob kv oc kz od ld nv nw nx ny bi translated"><em class="le"> Procfile </em> —告诉Heroku如何运行应用程序，并声明启动应用程序应该执行什么命令。要创建Procfile文件，运行项目目录中的<code class="fe ne nf ng mw b">$ <strong class="kk iu">echo "clock: python clock.py" &gt; Procfile</strong></code> <strong class="kk iu"> </strong>。请注意，Procfile是一个没有文件扩展名的简单文本文件。</li></ol><p id="41e7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Procfile在单独的行上声明应用程序进程类型，每一个都具有格式<code class="fe ne nf ng mw b">&lt;process type&gt;: &lt;command&gt;</code>，其中<code class="fe ne nf ng mw b">process type</code>是原型，从该原型实例化一个<a class="ae lf" href="https://www.heroku.com/dynos" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu"> dyno </strong> </a>。Dynos是提供计算机、内存、操作系统和临时文件系统的容器，旨在根据用户指定的命令执行代码。</p><p id="c1ec" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">鉴于演示应用程序的简单性，一个时钟dyno就足够了。注意，对于我们的用例，在Procfile中，<code class="fe ne nf ng mw b">clock</code>或<code class="fe ne nf ng mw b">worker</code>流程类型声明都可以。选择使用<code class="fe ne nf ng mw b">clock</code>进程类型是为了表明<code class="fe ne nf ng mw b">clock.py</code>是一个调度应用程序，它是一个单独的进程，不应该扩展到多个进程，以防止任务重复。</p><p id="4f58" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">另外，在我们的实现中，Dyno负责调度和执行作业。根据数据收集脚本的复杂性和作业的频率，可能需要使用单独的worker dynos(不在本项目范围内)。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi oe"><img src="../Images/b1b39e239ac9f94b9310f05625639faa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vUho9KLV2X9Y7-qyGUEeMw.png"/></div></div><p class="ls lt gj gh gi lu lv bd b be z dk translated">对于简单的工作，一个时钟Dyno就足够了</p></figure><h2 id="98b4" class="lx ly it bd lz ma mb dn mc md me dp mf kr mg mh mi kv mj mk ml kz mm mn mo mp bi translated">正确的Postgres数据库URL(3月编辑)</h2><p id="3e8b" class="pw-post-body-paragraph ki kj it kk b kl mq ju kn ko mr jx kq kr ms kt ku kv mt kx ky kz mu lb lc ld im bi translated">由于SQLAlchemy在2021年3月弃用了<code class="fe ne nf ng mw b">postgres</code>方言，我们不得不手动更新Heroku的DATABASE_URL环境变量。不幸的是，它不能在Heroku操作系统级别更新，因为它是由附加组件生成的。相反，我们可以给<code class="fe ne nf ng mw b">clock.py</code>添加一个简单的<code class="fe ne nf ng mw b">String.replace()</code>语句来适应这种变化。</p><pre class="lh li lj lk gt mv mw mx my aw mz bi"><span id="94ab" class="lx ly it mw b gy na nb l nc nd">SQLALCHEMY_DATABASE_URI=SQLALCHEMY_DATABASE_URI.replace('postgres://', 'postgresql://')</span></pre><h2 id="50ac" class="lx ly it bd lz ma mb dn mc md me dp mf kr mg mh mi kv mj mk ml kz mm mn mo mp bi translated">部署到Heroku</h2><p id="5b9c" class="pw-post-body-paragraph ki kj it kk b kl mq ju kn ko mr jx kq kr ms kt ku kv mt kx ky kz mu lb lc ld im bi translated">一旦创建了两个配置文件(<em class="le"> Procfile </em>和<em class="le"> requirements.txt </em>)，将所有工作文件保存在存储库中，然后将它们添加/提交/推送至远程存储库。</p><pre class="lh li lj lk gt mv mw mx my aw mz bi"><span id="7e2b" class="lx ly it mw b gy na nb l nc nd">$ <strong class="mw iu">git add .</strong><br/>$ <strong class="mw iu">git commit -m 'ready to deploy'<br/></strong>$ <strong class="mw iu">git push</strong></span></pre><p id="d4b0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一旦代码被推送到GitHub，我们就可以在Heroku部署它。在部署页面(<strong class="kk iu"> #1 </strong>)中，选择要部署的分支(<strong class="kk iu"># 2</strong>)(<strong class="kk iu"># 3</strong>)。Heroku将开始构建应用程序。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi of"><img src="../Images/8239bb828cf188653349012abe0f80cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UTPP4cHe_vJrdqpOenhdWA.png"/></div></div><p class="ls lt gj gh gi lu lv bd b be z dk translated">部署</p></figure><p id="8b78" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们要做的最后一件事是在Heroku对dyno进行缩放。回到资源页面(<strong class="kk iu"> #1 </strong>)，现在应用程序已经部署完毕，已经识别出了<code class="fe ne nf ng mw b">clock</code> dyno。它需要扩大规模并保持扩大规模，以便保持运行并确定调度作业的合适时间(<strong class="kk iu"> #2 </strong>、<strong class="kk iu"> #3 </strong>和<strong class="kk iu"> #4 </strong>)。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi og"><img src="../Images/7c556d0ae08cf47f769e83f4ec98d6b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m6EGrg1nWjK7Lm--BdhabQ.png"/></div></div><p class="ls lt gj gh gi lu lv bd b be z dk translated">将时钟动态缩放至1</p></figure><h2 id="9b65" class="lx ly it bd lz ma mb dn mc md me dp mf kr mg mh mi kv mj mk ml kz mm mn mo mp bi translated">摘要</h2><p id="1326" class="pw-post-body-paragraph ki kj it kk b kl mq ju kn ko mr jx kq kr ms kt ku kv mt kx ky kz mu lb lc ld im bi translated">在本文中，我们逐步介绍了数据收集应用程序的创建。我们还使用Heroku将它部署到云中。我希望这对你有帮助。我的希望是激励更多的人分享他们的想法(和数据),这些想法和数据是他们努力为其他人合作策划的。</p><blockquote class="oh oi oj"><p id="f701" class="ki kj le kk b kl km ju kn ko kp jx kq ok ks kt ku ol kw kx ky om la lb lc ld im bi translated">接下来，我们将创建一个监控工具，并为我们的应用程序构建一个时序机器学习模型。如果你喜欢这篇文章，我邀请你跟我来，这样你就可以得到这个项目继续的通知。</p></blockquote></div></div>    
</body>
</html>