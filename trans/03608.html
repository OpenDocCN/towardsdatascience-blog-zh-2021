<html>
<head>
<title>REPLMaker.jl: Create Interactive Julia Packages</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">jl:创建交互式Julia包</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/replmaker-jl-create-interactive-julia-packages-67be382f3eb8?source=collection_archive---------39-----------------------#2021-03-23">https://towardsdatascience.com/replmaker-jl-create-interactive-julia-packages-67be382f3eb8?source=collection_archive---------39-----------------------#2021-03-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="8d28" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">Pkg探索</h2><div class=""/><div class=""><h2 id="e81a" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">快速浏览使用Julia的REPLMaker.jl包为最终用户创建交互式代码</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/17ddf94401e1141a727dc687a917ac27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Iin07j7XUdRe5BkAu-27EA.jpeg"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">(图片由作者提供)</p></figure><h1 id="0bb2" class="lh li it bd lj lk ll lm ln lo lp lq lr ki ls kj lt kl lu km lv ko lw kp lx ly bi translated">介绍</h1><p id="8dd2" class="pw-post-body-paragraph lz ma it mb b mc md kd me mf mg kg mh mi mj mk ml mm mn mo mp mq mr ms mt mu im bi mv translated">交互在科学和计算计算领域的程序员中并不经常被谈论。然而，不仅拥有交互式软件，而且拥有交互式软件包也有许多独特的优势。有时，当使用许多高级编程语言的包时，可能真的需要一个简单的读取求值打印循环，或REPL。虽然这可能并不总是必要的，但在包中使用它肯定是一件很酷的事情，并且可以通过潜在的更简单的命令和定制的语法使找到问题的解决方案变得更加容易和方便。</p><p id="2667" class="pw-post-body-paragraph lz ma it mb b mc ne kd me mf nf kg mh mi ng mk ml mm nh mo mp mq ni ms mt mu im bi translated">幸运的是，对于Julia用户来说，有一个非常酷的工具可以做到这一点！这个包名为REPLMaker.jl，您当然可以像使用大多数包一样使用Pkg来添加它。它已经被注册到了Julia General package registry，但是那些希望使用不同分支的人总是可以通过Git添加它。</p><pre class="ks kt ku kv gt nj nk nl nm aw nn bi"><span id="e18b" class="no li it nk b gy np nq l nr ns">using Pkg; Pkg.add("REPLMaker")</span></pre><p id="7695" class="pw-post-body-paragraph lz ma it mb b mc ne kd me mf nf kg mh mi ng mk ml mm nh mo mp mq ni ms mt mu im bi translated">说到REPLs，如果您仍然使用上面的方法来添加包，您可能需要熟悉一下Pkg REPL。它提供了我前面提到的同样的好处，缺少语法和简单的命令，但也为包提供了额外的功能，使它更容易做许多您可能想不到的不同事情。</p><h1 id="2d90" class="lh li it bd lj lk ll lm ln lo lp lq lr ki ls kj lt kl lu km lv ko lw kp lx ly bi translated">概述</h1><p id="f6cf" class="pw-post-body-paragraph lz ma it mb b mc md kd me mf mg kg mh mi mj mk ml mm mn mo mp mq mr ms mt mu im bi translated">在整个Julia生态系统的各种包中有许多使用REPLMaker.jl的例子。也就是说，我认为有一个特别的例子非常突出，那就是Genie.jl。我认为Genie.jl提供了一个非常可靠的例子，说明各种REPLs是如何非常有用的，并且这个包将这些好处带到了web开发的奇妙世界。</p><p id="9f71" class="pw-post-body-paragraph lz ma it mb b mc ne kd me mf nf kg mh mi ng mk ml mm nh mo mp mq ni ms mt mu im bi translated">使用Genie，可以为不同的交互体验提供单独的文件，为您加载环境。这对于服务器来说尤其方便，因为命令通常是在带有虚拟监管器的Unix计算机上运行的。将建立一个监督程序来运行</p><pre class="ks kt ku kv gt nj nk nl nm aw nn bi"><span id="bd97" class="no li it nk b gy np nq l nr ns">. shell_script_file.sh</span></pre><p id="57e4" class="pw-post-body-paragraph lz ma it mb b mc ne kd me mf nf kg mh mi ng mk ml mm nh mo mp mq ni ms mt mu im bi translated">以便在没有用户在场的情况下创建应用程序的实例。然后，该服务将被添加到与原始主管拥有相同权限的进程列表中。这对Genie意味着，可以用来访问Genie REPL的相同命令也可以用来加载虚拟环境和启动使用web框架的web服务器。</p><p id="6313" class="pw-post-body-paragraph lz ma it mb b mc ne kd me mf nf kg mh mi ng mk ml mm nh mo mp mq ni ms mt mu im bi translated">我认为更多的包应该应用这种方法，因为REPLs肯定是一个有用的工具。此外，我认为许多软件包可以以这种方式和其他方式利用REPLs，在Julian软件的整个范围内创造一个普遍的交互和愉快的体验。</p><h1 id="8f43" class="lh li it bd lj lk ll lm ln lo lp lq lr ki ls kj lt kl lu km lv ko lw kp lx ly bi translated">使用复制器</h1><p id="2f3c" class="pw-post-body-paragraph lz ma it mb b mc md kd me mf mg kg mh mi mj mk ml mm mn mo mp mq mr ms mt mu im bi translated">REPLMaker包中将要使用的主要方法几乎肯定是initrepl()。这个方法是导出的，所以我们将通过简单地导入包来获得它:</p><pre class="ks kt ku kv gt nj nk nl nm aw nn bi"><span id="4b67" class="no li it nk b gy np nq l nr ns">using ReplMaker</span></pre><p id="d047" class="pw-post-body-paragraph lz ma it mb b mc ne kd me mf nf kg mh mi ng mk ml mm nh mo mp mq ni ms mt mu im bi translated">initrepl()方法接受一个位置参数和大量决定repl外观的关键字参数。然而，就功能而言，我们真正需要的是一个解析器。解析器将会对我们输入到REPL中的字符串进行解码。我们可以使用Base创建一个基本的表达式解析器。Meta的解析器与我们的字符串:</p><pre class="ks kt ku kv gt nj nk nl nm aw nn bi"><span id="d62d" class="no li it nk b gy np nq l nr ns">exprparse(s) = quote Meta.parse($s) end</span></pre><p id="4f3d" class="pw-post-body-paragraph lz ma it mb b mc ne kd me mf nf kg mh mi ng mk ml mm nh mo mp mq ni ms mt mu im bi translated">您可能已经注意到这个函数使用了“quote”语句。对于那些不熟悉Julian元编程的人来说，引用表达式基本上是告诉语言，这里包含的代码将是一个一致的表达式，而不是一系列的表达式。</p><p id="0b44" class="pw-post-body-paragraph lz ma it mb b mc ne kd me mf nf kg mh mi ng mk ml mm nh mo mp mq ni ms mt mu im bi translated">现在我们可以调用initrepl()方法并提供我们的解析函数来创建一个新的repl。我们可能还想提供另一个名为“start key”的关键字参数，这将允许我们通过按键盘上的特定键来输入REPL。</p><pre class="ks kt ku kv gt nj nk nl nm aw nn bi"><span id="f930" class="no li it nk b gy np nq l nr ns">initrepl(exprparse, <br/>                prompt_text="Parse /&gt;",<br/>                prompt_color = :blue, <br/>                start_key=')', <br/>                mode_name="Expr_mode")</span></pre><p id="3315" class="pw-post-body-paragraph lz ma it mb b mc ne kd me mf nf kg mh mi ng mk ml mm nh mo mp mq ni ms mt mu im bi translated">现在，从朱莉娅·REPL，使用我们设置的开始字符，我们可以初始化我们刚刚创建的新REPL。这个新的REPL将接受并计算我们可以作为字符串传递的Julia表达式。这并不十分有用，但是这个基本概念为库和应用程序打开了一扇大门。</p></div><div class="ab cl nt nu hx nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="im in io ip iq"><h1 id="6f96" class="lh li it bd lj lk oa lm ln lo ob lq lr ki oc kj lt kl od km lv ko oe kp lx ly bi translated">结论</h1><p id="b98d" class="pw-post-body-paragraph lz ma it mb b mc md kd me mf mg kg mh mi mj mk ml mm mn mo mp mq mr ms mt mu im bi translated">REPLMaker对于朱莉娅编程语言来说是一个非常酷的工具，它使得在朱莉娅REPLs上实现令人敬畏的复制器变得又快又容易。这可以使用户通过执行命令来更容易和更快地处理包，而不需要担心语法。最重要的是，创建和使用它们相当有趣，这使得它们对教育更有价值。创建解析器相当有趣，但是创建一个有效的解析器的一个非常困难的部分是创建一个求值循环，并为解析器分配要访问的内存。也就是说，有了这两件事的照顾，我们可以非常简单地获得一些非常出色的结果！</p></div></div>    
</body>
</html>