<html>
<head>
<title>Fusing EfficientNet &amp; YoloV5 — Advanced Object Detection 2 stage pipeline tutorial</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">融合效率Net &amp; YoloV5 —高级对象检测2阶段管道教程</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/fusing-efficientnet-yolov5-advanced-object-detection-2-stage-pipeline-tutorial-da3a77b118d1?source=collection_archive---------14-----------------------#2021-04-02">https://towardsdatascience.com/fusing-efficientnet-yolov5-advanced-object-detection-2-stage-pipeline-tutorial-da3a77b118d1?source=collection_archive---------14-----------------------#2021-04-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="41ba" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">通过将YoloV5与EfficientNet集成，将对象检测性能提高约20%</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/1cfeeb40b3dd8f3e662d094e141544e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*b3JzGP8dxBbKIUL_"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@gretafarnedi?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">格蕾塔·法内迪</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">号航天飞机</a>上的照片</p></figure><p id="d72e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我将解释一个我称之为“2类过滤器”的概念。这是一种用于对象检测和分类模型的集成技术，在过去几周我一直在进行的一场Kaggle竞赛中大量使用。这项技术已经被几乎每个参加比赛的人所使用，它似乎能提高5-25%左右的成绩，这是相当有用的。</p><h2 id="1940" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">物体检测YoloV5</h2><p id="df5e" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">我们首先在数据集上训练一个YoloV5模型，同时使用加权盒融合(WBF)进行后处理/预处理，如果您想了解更多信息，我建议查看以下两篇文章:</p><div class="mt mu gp gr mv mw"><a rel="noopener follow" target="_blank" href="/advanced-yolov5-tutorial-enhancing-yolov5-with-weighted-boxes-fusion-3bead5b71688"><div class="mx ab fo"><div class="my ab mz cl cj na"><h2 class="bd iu gy z fp nb fr fs nc fu fw is bi translated">高级YoloV5教程-使用加权盒融合增强YoloV5</h2><div class="nd l"><h3 class="bd b gy z fp nb fr fs nc fu fw dk translated">关于使用YoloV5和与WBF一起提高性能的深入教程</h3></div><div class="ne l"><p class="bd b dl z fp nb fr fs nc fu fw dk translated">towardsdatascience.com</p></div></div><div class="nf l"><div class="ng l nh ni nj nf nk ks mw"/></div></div></a></div><div class="mt mu gp gr mv mw"><a rel="noopener follow" target="_blank" href="/wbf-optimizing-object-detection-fusing-filtering-predicted-boxes-7dc5c02ca6d3"><div class="mx ab fo"><div class="my ab mz cl cj na"><h2 class="bd iu gy z fp nb fr fs nc fu fw is bi translated">WBF:优化对象检测—融合和过滤预测框</h2><div class="nd l"><h3 class="bd b gy z fp nb fr fs nc fu fw dk translated">加权盒融合已经成为优化目标检测模型的新SOTA方法</h3></div><div class="ne l"><p class="bd b dl z fp nb fr fs nc fu fw dk translated">towardsdatascience.com</p></div></div><div class="nf l"><div class="nl l nh ni nj nf nk ks mw"/></div></div></a></div><p id="7020" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我不想再详述和WBF一起训练约洛娃的细节。但是，实际上您需要做的就是使用WBF消除重复的方框，然后对数据进行预处理，在上面运行YoloV5。YoloV5需要一个特定的层次结构，以便数据集能够开始培训和评估。</p><h2 id="88ee" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">分类-效率网</h2><p id="d00c" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">接下来要做的是在数据集上训练一个分类网络。但是，有趣的是，尽管在14个不同的类别(13种不同类型的疾病和1种无疾病类别)上训练了对象检测模型，但是我们将仅在2个类别(疾病和无疾病)上训练分类网络。您可以将其视为简化我们的数据科学问题的建模技巧，因为对一个网络分类2类比分类14类要容易得多，当我们融合这2个网络时，我们并不真正需要每种疾病的细节，我们只需要这2类中的一种。当然，对于您的问题来说，这可能有点不同，所以您可能需要尝试不同的设置，但是希望您可以从本文中获得一个或两个想法。</p><p id="1cdd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">目前最先进的分类网络之一是高效网。对于这个数据集，我们将使用经过Keras (TensorFlow)培训的B6效率网，以及以下增强功能:</p><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="a794" class="lv lw it nn b gy nr ns l nt nu">(<br/>    rescale=1.0 / 255,<br/>    rotation_range=40,<br/>    width_shift_range=0.2,<br/>    height_shift_range=0.2,<br/>    shear_range=0.2,<br/>    zoom_range=0.2,<br/>    horizontal_flip=True,<br/>    fill_mode="nearest",<br/>)</span></pre><p id="c338" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想看完整个教程，我建议你看看这个:</p><div class="mt mu gp gr mv mw"><a rel="noopener follow" target="_blank" href="/an-in-depth-efficientnet-tutorial-using-tensorflow-how-to-use-efficientnet-on-a-custom-dataset-1cab0997f65c"><div class="mx ab fo"><div class="my ab mz cl cj na"><h2 class="bd iu gy z fp nb fr fs nc fu fw is bi translated">使用TensorFlow的深入EfficientNet教程-如何在自定义数据集上使用EfficientNet。</h2><div class="nd l"><h3 class="bd b gy z fp nb fr fs nc fu fw dk translated">使用Tensorflow在具有挑战性的Kaggle数据集上训练效率网</h3></div><div class="ne l"><p class="bd b dl z fp nb fr fs nc fu fw dk translated">towardsdatascience.com</p></div></div><div class="nf l"><div class="nv l nh ni nj nf nk ks mw"/></div></div></a></div><h2 id="e556" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">组装</h2><p id="0912" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">这就是2类滤波器提高性能的地方，也是本文真正要讨论的内容。我不想谈论太多关于培训YoloV5和EfficientNet的内容，因为有很多关于它们的资源。</p><p id="b014" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我想强调的主要思想是，虽然Yolo的分类预测非常好，但如果你可以将它们与另一个更强大的网络的分类混合，你可以获得相当不错的性能提升。让我们看看这是如何实现的。</p><p id="d289" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里使用的想法是设置一个高阈值和一个低阈值。然后我们会检查每个分类预测。如果概率小于低阈值，我们将任何预测设置为“无疾病”。回想一下，我们最初的问题是对14种疾病中的一种或“无疾病”进行分类。这个低阈值可以是0到1之间的任何值，但是很可能是0到0.1之间的某个值。此外，如果分类预测在低阈值和高阈值之间，我们<strong class="lb iu">添加</strong>一个“无疾病”预测，该预测具有<strong class="lb iu"> EfficientNet的</strong>置信度(不是Yolo的),因为在这种情况下有更高的几率患任何疾病。最后，如果分类预测高于高阈值，我们什么也不做，因为这意味着网络高度可信。</p><p id="0c45" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这可以通过以下方式实现:</p><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="b356" class="lv lw it nn b gy nr ns l nt nu">low_thr  = 0.08<br/>high_thr = 0.95</span><span id="001e" class="lv lw it nn b gy nw ns l nt nu">def filter_2cls(row, low_thr=low_thr, high_thr=high_thr):<br/>    prob = row['target']<br/>    if prob&lt;low_thr:<br/>        <em class="nx">## Less chance of having any disease</em><br/>        row['PredictionString'] = '14 1 0 0 1 1'<br/>    elif low_thr&lt;=prob&lt;high_thr:<br/>        <em class="nx">## More chance of having any disease</em><br/>        row['PredictionString']+=f' 14 <strong class="nn iu">{</strong>prob<strong class="nn iu">}</strong> 0 0 1 1'<br/>    elif high_thr&lt;=prob:<br/>        <em class="nx">## Good chance of having any disease so believe in object detection model</em><br/>        row['PredictionString'] = row['PredictionString']<br/>    else:<br/>        raise <strong class="nn iu">ValueError</strong>('Prediction must be from [0-1]')<br/>    return row</span></pre><p id="0832" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">来源:<a class="ae ky" href="https://www.kaggle.com/awsaf49/vinbigdata-2-class-filter" rel="noopener ugc nofollow" target="_blank">卡格尔</a></p><p id="5208" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">最终想法</strong></p><p id="e6bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我在比赛期间在各种不同的场景和模型上试验了这种2级过滤器，它似乎总是能够将性能提高多达25%，这令人惊讶。我认为如果你想把它应用到你的自定义场景中，你需要考虑在什么情况下分类网络预测可以帮助你的对象检测模型。这并不完全是交换预测信心，而是以一种聪明的方式“融合”它们。</p></div></div>    
</body>
</html>