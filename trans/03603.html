<html>
<head>
<title>How to Benchmark functions in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何对Python中的函数进行基准测试</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-benchmark-functions-in-python-ed10522053a2?source=collection_archive---------34-----------------------#2021-03-23">https://towardsdatascience.com/how-to-benchmark-functions-in-python-ed10522053a2?source=collection_archive---------34-----------------------#2021-03-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7aaf" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在本文中，我们将讨论Python中基准函数的4种方法</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/67278a95e7a63fea5fd06de2b26b0da9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MI5AR2HlLRR7TZgNn72NlQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在<a class="ae ky" href="/s/photos/timer?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae ky" href="https://unsplash.com/@veri_ivanova?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Veri Ivanova </a>拍摄的照片</p></figure><p id="1659" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">前三种方法将帮助我们测量函数的执行时间，而最后一种方法将帮助我们测量内存使用情况。</p><h1 id="bcdc" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">目录</h1><ul class=""><li id="9872" class="mn mo it lb b lc mp lf mq li mr lm ms lq mt lu mu mv mw mx bi translated">使用时间库</li><li id="f795" class="mn mo it lb b lc my lf mz li na lm nb lq nc lu mu mv mw mx bi translated">使用timeit</li><li id="deeb" class="mn mo it lb b lc my lf mz li na lm nb lq nc lu mu mv mw mx bi translated">使用线条轮廓器</li><li id="7411" class="mn mo it lb b lc my lf mz li na lm nb lq nc lu mu mv mw mx bi translated">使用内存概要分析器</li><li id="0653" class="mn mo it lb b lc my lf mz li na lm nb lq nc lu mu mv mw mx bi translated">结论</li></ul><h1 id="5920" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">使用时间库</h1><p id="618f" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">这是计算函数执行时间的最简单的方法之一。我们实际上是在调用函数之前和之后获得了以秒为单位的时间。两者之差可以给我们一个函数时间的估计。我说估计，因为这是测量单次运行的时间。一个更好的基准测试应该是多次运行它并计算平均花费的时间。</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="1f56" class="nl lw it nh b gy nm nn l no np">import time</span><span id="bfd6" class="nl lw it nh b gy nq nn l no np">def func():<br/>   lst = [i for i in range(100000)]<br/>   start = time.perf_counter()</span><span id="a44b" class="nl lw it nh b gy nq nn l no np">func()<br/>print(f"Completed Execution in {time.perf_counter() - start} seconds")</span></pre><p id="28e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是输出</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="c056" class="nl lw it nh b gy nm nn l no np">Completed Execution in 0.007916 seconds</span></pre><h1 id="3846" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">使用timeit</h1><p id="e9ec" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated"><a class="ae ky" href="https://docs.python.org/3/library/timeit.html" rel="noopener ugc nofollow" target="_blank"> Timeit </a>是Python中的内置方法。它让我们指定运行函数的次数，这有助于我们计算函数运行的平均时间。这是比单次运行的执行时间更好的度量。但是，对于耗时较长的复杂函数，这种方法可能并不理想。</p><p id="b31e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一般语法如下</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="5562" class="nl lw it nh b gy nm nn l no np">timeit.Timer(funcName).timeit(number=number)</span></pre><p id="873c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> number </strong>是我们希望函数执行的次数。它返回所有单个运行时的总和。为了得到平均值，我们可以用总数除以运行次数。</p><p id="a9c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是我们如何测量函数<strong class="lb iu"> func() </strong>的平均执行时间</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="3a28" class="nl lw it nh b gy nm nn l no np">import timeit</span><span id="1114" class="nl lw it nh b gy nq nn l no np">num_runs = 10<br/>duration = timeit.Timer(func).timeit(number = num_runs)<br/>avg_duration = duration/num_runs<br/>print(f'On average it took {avg_duration} seconds')</span></pre><p id="f5a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出如下</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="5213" class="nl lw it nh b gy nm nn l no np">On average it took 0.004649160000000001 seconds</span></pre><p id="4462" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还可以使用<strong class="lb iu"> repeat() </strong>方法多次运行实验(运行函数n次)。更简单的说，如果我们把一个实验看作是运行我们的函数<strong class="lb iu"> func() </strong> 10次，我们就可以把这个实验做3次，得到每个实验的执行时间。</p><p id="fb60" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一般语法是</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="f8a3" class="nl lw it nh b gy nm nn l no np">timeit.Timer(funcName).repeat(repeat=num_repetions,number=num_runs)</span></pre><p id="2d42" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是用它来测试我们的函数<strong class="lb iu"> func() </strong></p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="003b" class="nl lw it nh b gy nm nn l no np">num_runs = 10<br/>num_repetions = 3<br/>ex_time = timeit.Timer(func).repeat(<br/>                     repeat=num_repetions,<br/>                     number=num_runs)<br/>print(f'It took {ex_time}')</span></pre><p id="0ae1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将返回以下输出</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="6de2" class="nl lw it nh b gy nm nn l no np">It took [0.0494772, 0.04936369999999998, 0.048738000000000004]</span></pre><p id="8442" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">类似于<strong class="lb iu"> timeit() </strong>方法，它返回10次运行的总时间。我们可以用<strong class="lb iu"> max() </strong>得到最差时间，<strong class="lb iu"> min() </strong>得到最佳时间，<strong class="lb iu"> sum(lst)/len(lst) </strong>得到平均执行时间。</p><h1 id="0696" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">使用线条轮廓器</h1><p id="938f" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">line_profiles是一个非常酷的库，可以对函数进行逐行分析。在使用这个库之前，我们需要安装它</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="1c20" class="nl lw it nh b gy nm nn l no np">conda install -c anaconda line_profiler</span></pre><p id="d4e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要在函数之前添加一个装饰器</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="4418" class="nl lw it nh b gy nm nn l no np">@profile<br/>def func():<br/>    lst = []<br/>    for i in range(100000):<br/>       lst.append(i)</span></pre><p id="7025" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为line-profiler提供了逐行分析，所以使用它来理解列表没有多大意义。</p><p id="d0f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Anaconda提示符下键入以下命令</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="8be2" class="nl lw it nh b gy nm nn l no np">kernprof -l main.py<br/>python -m line_profiler main.py.lprof</span></pre><p id="d7bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一个命令运行我们的python脚本，并将日志存储在一个文件中。第二个命令以易于理解的表格形式显示日志。</p><p id="9f90" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是第二个命令的输出</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nr"><img src="../Images/8ba30e37a5668dc3753f1cfc8fd3ccef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0c_xRQBcV3ZDqg0dkpfmWg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">line_profiler的屏幕截图</p></figure><ul class=""><li id="f30b" class="mn mo it lb b lc ld lf lg li ns lm nt lq nu lu mu mv mw mx bi translated"><strong class="lb iu"> Hit- </strong>该行被执行的次数。</li><li id="916b" class="mn mo it lb b lc my lf mz li na lm nb lq nc lu mu mv mw mx bi translated"><strong class="lb iu">时间- </strong>该行花费总时间</li><li id="5aa4" class="mn mo it lb b lc my lf mz li na lm nb lq nc lu mu mv mw mx bi translated"><strong class="lb iu">-</strong>每次点击生产线所用的平均时间</li><li id="3b62" class="mn mo it lb b lc my lf mz li na lm nb lq nc lu mu mv mw mx bi translated"><strong class="lb iu"> % Time- </strong>总执行时间的一部分。从上图中我们可以看到，append函数占用了大约57%的执行时间。</li></ul><p id="9ba7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果要更改line_profiler函数的执行次数，请使用以下代码</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="a71a" class="nl lw it nh b gy nm nn l no np">prof = profile(func)<br/>for i in range(10):<br/>   prof()</span></pre><p id="18e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将运行该函数10次。</p><h1 id="558c" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">使用内存概要分析器</h1><p id="3941" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">它与line_profiler非常相似，不同之处在于生成的日志告诉我们内存使用情况，而不是花费的时间。</p><p id="ee4c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们需要安装库</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="c947" class="nl lw it nh b gy nm nn l no np">conda install -c anaconda memory_profiler</span></pre><p id="2508" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将不得不像以前一样添加相同的装饰</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="67a6" class="nl lw it nh b gy nm nn l no np">@profile<br/>def func():<br/>    lst = []<br/>    for i in range(100000):<br/>       lst.append(i)</span></pre><p id="aba4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后在Anaconda提示符下键入以下命令</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="a111" class="nl lw it nh b gy nm nn l no np">python -m memory_profiler main.py</span></pre><p id="fb46" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是输出</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nv"><img src="../Images/2245e0067f2710ebe8fb189f9c400440.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Mkkhkc-5BmG8RZshD-apGA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">memory_profiler屏幕截图</p></figure><ul class=""><li id="3b87" class="mn mo it lb b lc ld lf lg li ns lm nt lq nu lu mu mv mw mx bi translated"><strong class="lb iu">内存使用量</strong> -该行的总内存使用量</li><li id="7162" class="mn mo it lb b lc my lf mz li na lm nb lq nc lu mu mv mw mx bi translated"><strong class="lb iu">递增</strong> -每次执行该行时内存使用量</li><li id="a4d4" class="mn mo it lb b lc my lf mz li na lm nb lq nc lu mu mv mw mx bi translated"><strong class="lb iu">出现次数</strong> -该行被执行的次数</li></ul><h1 id="a913" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">结论</h1><p id="4f22" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">如果您想要对一段代码或一个函数进行快速的时间性能测试，您应该尝试使用<strong class="lb iu"> time </strong>库来测量执行时间。然而，如果你想要一个更好的估计，考虑使用<strong class="lb iu"> timeit </strong>库。</p><p id="d2bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您想要更详细的逐行分析，可以考虑使用行分析器和内存分析器。</p></div><div class="ab cl nw nx hx ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="im in io ip iq"><blockquote class="od oe of"><p id="6198" class="kz la og lb b lc ld ju le lf lg jx lh oh lj lk ll oi ln lo lp oj lr ls lt lu im bi translated">在<a class="ae ky" href="https://www.linkedin.com/in/rahulbanerjee2699/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上与我联系</p><p id="572b" class="kz la og lb b lc ld ju le lf lg jx lh oh lj lk ll oi ln lo lp oj lr ls lt lu im bi translated">我最近开始了一个修改版的#100daysofcode挑战。我的目标是每天写与Python、数据科学或编程相关的内容。在<a class="ae ky" href="https://twitter.com/rahulbanerjee99" rel="noopener ugc nofollow" target="_blank"> Twitter </a>、<a class="ae ky" href="https://medium.com/daily-programming-tips" rel="noopener"> Medium </a>、<a class="ae ky" href="https://dev.to/rahulbanerjee99" rel="noopener ugc nofollow" target="_blank"> Dev.to </a>、<a class="ae ky" href="https://realpythonproject.hashnode.dev/series/daily-programming-content/" rel="noopener ugc nofollow" target="_blank"> Hashnode </a>或<a class="ae ky" href="https://www.realpythonproject.com/category/daily-programming-tips/" rel="noopener ugc nofollow" target="_blank"> my WordPress博客</a>上关注我的进展</p></blockquote></div><div class="ab cl nw nx hx ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="im in io ip iq"><p id="2e85" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="og">原载于2021年3月23日</em><a class="ae ky" href="https://www.realpythonproject.com/how-to-benchmark-functions-in-python/" rel="noopener ugc nofollow" target="_blank"><em class="og">【http://www.realpythonproject.com】</em></a><em class="og">。</em></p></div></div>    
</body>
</html>