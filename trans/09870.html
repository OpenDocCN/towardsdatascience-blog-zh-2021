<html>
<head>
<title>Plotting in parallel with matplotlib and python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用matplotlib和python并行绘图</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/plotting-in-parallel-with-matplotlib-and-python-f7efb3d944de?source=collection_archive---------10-----------------------#2021-09-16">https://towardsdatascience.com/plotting-in-parallel-with-matplotlib-and-python-f7efb3d944de?source=collection_archive---------10-----------------------#2021-09-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="9539" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/tips-and-tricks" rel="noopener" target="_blank">技巧和诀窍</a>、<a class="ae ep" href="https://towardsdatascience.com/tagged/making-sense-of-big-data" rel="noopener" target="_blank">理解大数据</a></h2><div class=""/><div class=""><h2 id="43fc" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">如何使用多重处理加速网格状绘图的创建</h2></div><p id="1d6e" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">这是另一篇关于如何加快速度的文章。我并不是在反对<code class="fe lk ll lm ln b">matplotlib</code>。事实上，它是我项目中的日常驱动力。但有时你需要额外的表演。</p><p id="f680" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">这里有一个例子。为了我的一项研究，我必须创造大量的小提琴情节。对于那些不熟悉它们的人，这里有一个非常简单的解释:基本上，这些图在某些方面类似于直方图，但你实际上可以在一个图中比较多个小提琴，这对于直方图来说很难。violin plots不是计算离散频率，而是计算每个轴的核密度估计值(KDE )(连续函数)。然后他们画出最终的多边形。绘图在计算上相当便宜，但计算KDE却不便宜。我正在处理数以亿计的数据点和多个轴。因此，性能是关键。每个轴的KDE可以独立计算，甚至可以独立绘图(在共享轴上)。但是<code class="fe lk ll lm ln b">matplotlib</code>是按顺序做的——唉！</p><p id="5a53" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">我开始尝试让<code class="fe lk ll lm ln b">matplotlib</code>使用多处理，但我不想只并行KDE计算，而是可以分成多个图的任何类型的图。Matplotlib不是真正的线程安全，所以我的大多数方法都失败了。我确信有一些漂亮的方法来实现并行，也许我没有挖掘得足够深，但是我想要一个简单问题的简单解决方案，并想出了一个便宜的技巧。</p><p id="9e41" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">我没有将<code class="fe lk ll lm ln b">matplotlib</code>的内部并行化，而是将我的数据分配给不同的进程，然后让每个进程创建自己的绘图。然后每个情节被栅格化并反馈给主进程，主进程将所有的子情节组合成一个网格状的情节。</p><p id="10fc" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">输出是一个完整的<code class="fe lk ll lm ln b">matplotlib</code>图——您甚至可以将其输入QT后端，享受GUI的所有功能。但是每个子情节都是光栅化的图像。这意味着你不能放大，改变轴等。然而，如果你只是需要一种快速的方法来创建静态图，那么这种方法应该适合你。</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi lo"><img src="../Images/3d282141663ea88e95e3873092679cc3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nm9UFPnL7sGlFf50igoikA.png"/></div></div><p class="ma mb gj gh gi mc md bd b be z dk translated">工作原理概述。图片作者。</p></figure><p id="acd5" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">我在GitHub上发布了这个附带项目，但是还没有在PyPi上发布。如果只是想用，可以在这里不看了，直接装库。请阅读GitHub自述文件了解使用信息。</p><pre class="lp lq lr ls gt me ln mf mg aw mh bi"><span id="284c" class="mi mj iq ln b gy mk ml l mm mn">pip install git+https://github.com/paulgavrikov/parallel-matplotlib-grid/</span></pre><p id="7cef" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">但是如果你好奇的话，我也会用一个稍微精简的功能来解释这个原理。让我们深入研究一下。</p><p id="9b87" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">首先，我们必须将数据分发给每个工人，然后汇集输出。我们可以通过使用池让多处理来处理这个问题。组装意味着我们只需创建支线剧情，并让每个情节通过<code class="fe lk ll lm ln b">plt.imshow</code>显示光栅化的输出。</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="8f2d" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">现在，是时候定义工人了。工人必须创建一个绘图，调用一个用户定义的函数，以任何方式将数据绘制到图形中，然后进行栅格化并返回输出。</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="9f10" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated"><code class="fe lk ll lm ln b">matplotlib</code>不太擅长在保存前计算每个图的边界。要么接受可能遗漏了一点情节的支线剧情，要么使用填充(默认完成)。</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="3d1c" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">现在你可以用你的数据和你的自定义绘图程序调用<code class="fe lk ll lm ln b">parallel_plot</code>，享受准并行绘图。</p><p id="3dc7" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">让我们创建一个5x5的小提琴网格:</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="mo mp l"/></div></figure><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi mq"><img src="../Images/0af00bcb8ba5dde52905f01196506895.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*udTql7V_5Z9Ib45DfwOvNg.png"/></div></div><p class="ma mb gj gh gi mc md bd b be z dk translated">5x5小提琴绘图网格。图片作者。</p></figure><p id="0117" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">或者一行5个散点图:</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="mo mp l"/></div></figure><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi mr"><img src="../Images/20d7e2ac3f95da5ac117963c666e9d78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6DGVxi0uzSraX7tCG93bqw.png"/></div></div><p class="ma mb gj gh gi mc md bd b be z dk translated">1x5散点图网格。图片作者。</p></figure><p id="db66" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">你可以创造任何你喜欢的情节，只要你的情节基于提供的<code class="fe lk ll lm ln b">fig</code>和<code class="fe lk ll lm ln b">axes</code>参数。只要记住<code class="fe lk ll lm ln b">multiprocessing</code>不能很好地处理超过4gb的数据。</p></div><div class="ab cl ms mt hu mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="ij ik il im in"><p id="ca05" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">一点小提示。我很清楚，当谈到真正的并行性时，多处理并不是精英中的精英。但它在大多数情况下都足够好，我的主要用途是<code class="fe lk ll lm ln b">jupyter</code>笔记本，我发现多处理是少数几个可靠工作的库之一。如果您想在<code class="fe lk ll lm ln b">jupyter</code>之外使用它，并且想与工人共享更大的数据，您可能想考虑使用<code class="fe lk ll lm ln b">ray</code>。</p><p id="b000" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated"><code class="fe lk ll lm ln b">ray</code>不使用<code class="fe lk ll lm ln b">pickle</code>来序列化数据。因此，序列化速度更快，可以序列化大于4gb的数据。访问数据也更快，因为没有昂贵的反序列化。但是我也遇到了许多占用RAM的死进程的问题，并且从来没有让它在<code class="fe lk ll lm ln b">jupyter</code>笔记本中工作过。</p></div></div>    
</body>
</html>