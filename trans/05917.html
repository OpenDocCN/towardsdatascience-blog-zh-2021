<html>
<head>
<title>Slowly Changing Dimension Type 2 in Spark</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Spark中渐变维度类型2</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/slowly-changing-dimension-type-2-in-spark-7d5865ac915b?source=collection_archive---------7-----------------------#2021-05-27">https://towardsdatascience.com/slowly-changing-dimension-type-2-in-spark-7d5865ac915b?source=collection_archive---------7-----------------------#2021-05-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/25c566e643f8c3ca07808dc4ed60ea04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UxhBnhixnU7AsKOKg52Hig.jpeg"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">资料照片由<a class="ae jd" href="https://unsplash.com/@eugenezhyvchik?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">尤金·日夫奇克</a>在<a class="ae jd" href="https://unsplash.com/s/photos/evolution?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><h2 id="4161" class="je jf jg bd b dl jh ji jj jk jl jm dk jn translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/making-sense-of-big-data" rel="noopener" target="_blank">理解大数据</a></h2><div class=""/><div class=""><h2 id="fff4" class="pw-subtitle-paragraph km jp jg bd b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dk translated">介绍什么是渐变维度类型2以及如何用Apache Spark创建它</h2></div><h1 id="662c" class="le lf jg bd lg lh li lj lk ll lm ln lo kv lp kw lq ky lr kz ls lb lt lc lu lv bi translated">介绍</h1><p id="176a" class="pw-post-body-paragraph lw lx jg ly b lz ma kq mb mc md kt me mf mg mh mi mj mk ml mm mn mo mp mq mr ij bi translated">如果这不是你第一次阅读我的帖子，你知道在我进入大数据世界之前，我是一名传统的DWH/BI开发人员。使用数据湖，我们的工作方式与我以前不同。所以过了一段时间后，我决定回到“我的根源”,写了一篇数据仓库指南的博文。现在我将再次回到这个话题，解释渐变维度(SCD ),尤其是关于Type 2，并提供一些关于如何在Apache Spark中实现它的代码，以及与关系数据库相比的一些关键差异。</p><h1 id="22e8" class="le lf jg bd lg lh li lj lk ll lm ln lo kv lp kw lq ky lr kz ls lb lt lc lu lv bi translated">什么是SCD？</h1><p id="8212" class="pw-post-body-paragraph lw lx jg ly b lz ma kq mb mc md kt me mf mg mh mi mj mk ml mm mn mo mp mq mr ij bi translated">如果您是数据仓库领域的新手，它可能听起来像某种疾病的缩写，但实际上，它是一个能够跟踪事物如何随时间变化的表。</p><p id="309a" class="pw-post-body-paragraph lw lx jg ly b lz ms kq mb mc mt kt me mf mu mh mi mj mv ml mm mn mw mp mq mr ij bi translated">SCD有多种类型。即:</p><ul class=""><li id="6999" class="mx my jg ly b lz ms mc mt mf mz mj na mn nb mr nc nd ne nf bi translated">那些只保留原始数据的—不可变的</li><li id="af96" class="mx my jg ly b lz ng mc nh mf ni mj nj mn nk mr nc nd ne nf bi translated">那些只保留当前值的</li><li id="2440" class="mx my jg ly b lz ng mc nh mf ni mj nj mn nk mr nc nd ne nf bi translated">具有当前值和先前值等。</li></ul><p id="06ca" class="pw-post-body-paragraph lw lx jg ly b lz ms kq mb mc mt kt me mf mu mh mi mj mv ml mm mn mw mp mq mr ij bi translated">如果你想了解更多，金博尔集团有一个关于不同类型SCD的很好的<a class="ae jd" href="https://www.kimballgroup.com/2013/02/design-tip-152-slowly-changing-dimension-types-0-4-5-6-7/" rel="noopener ugc nofollow" target="_blank">设计技巧</a>。尽管就我所知，这取决于你使用的是什么资源，类型可能有不同的含义:在一个上下文中，它在另一个上下文中意味着一件事——方式不同的方法。</p><h1 id="ef8b" class="le lf jg bd lg lh li lj lk ll lm ln lo kv lp kw lq ky lr kz ls lb lt lc lu lv bi translated">那么我说的2型是什么呢？</h1><p id="4767" class="pw-post-body-paragraph lw lx jg ly b lz ma kq mb mc md kt me mf mg mh mi mj mk ml mm mn mo mp mq mr ij bi translated">想象一下我们有产品维度。我通过dbdiagram.io工具创建了所有表格插图！</p><figure class="nm nn no np gt is gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/f8f97c9e1d20520ca02ab96cdc6f90ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:652/format:webp/1*TRKNWsVx7N6yDdm6-Fv-mg.png"/></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">产品维度。作者图片</p></figure><p id="5728" class="pw-post-body-paragraph lw lx jg ly b lz ms kq mb mc mt kt me mf mu mh mi mj mv ml mm mn mw mp mq mr ij bi translated">我们可能想看看产品的名称或价格如何影响我们的销售。当然，你可能会认为我在胡说八道，因为产品价格对销售有着巨大的影响，而产品名称可能与此毫无关系。但与我裸露；这只是一个展示SCD类型2如何工作的例子。</p><p id="d2dd" class="pw-post-body-paragraph lw lx jg ly b lz ms kq mb mc mt kt me mf mu mh mi mj mv ml mm mn mw mp mq mr ij bi translated">因此，想象一下，如果我们每天都在构建我们的维度，并且我们注意到一些信息发生了变化，但是因为我们只是加载快照值，所以我们看不到变化的内容和原因。因此，在这种情况下，当该行有效时，我们添加生效日期。</p><figure class="nm nn no np gt is gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/afbed73973fb78efc3dc73a32a6fac6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:658/format:webp/1*V_g88WEyh_517XS5r6V4QA.png"/></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">具有生效日期的产品维度。作者图片</p></figure><p id="0524" class="pw-post-body-paragraph lw lx jg ly b lz ms kq mb mc mt kt me mf mu mh mi mj mv ml mm mn mw mp mq mr ij bi translated">好了，现在发生的情况是，我们的表中没有主键，因为我们现在将有多个product_id。为了解决这个问题，我们可以创建一个代理键，通过join on键和事实发生的日期，我们可以轻松地将它添加到事实表中。</p><figure class="nm nn no np gt is gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/e8bda14992afcd18d87300992dcd6d22.png" data-original-src="https://miro.medium.com/v2/resize:fit:732/format:webp/1*grpth_pqPdGj_AMoQ_NpGA.png"/></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">具有代理键的产品维度。作者图片</p></figure><p id="3545" class="pw-post-body-paragraph lw lx jg ly b lz ms kq mb mc mt kt me mf mu mh mi mj mv ml mm mn mw mp mq mr ij bi translated">但是如果我们的一个产品因为某种原因被删除了会怎么样呢？是的，我们应该通过添加一个标志<strong class="ly jq"> is_deleted来确定它是否被删除。</strong></p><p id="a163" class="pw-post-body-paragraph lw lx jg ly b lz ms kq mb mc mt kt me mf mu mh mi mj mv ml mm mn mw mp mq mr ij bi translated">但是等等，现在要获得当前值以进行快速分析，我们必须在end_date扫描所有表(如果它是null或者设置为2999–12–31)？是的，这听起来也不太有效，所以让我们添加另一个标志，<strong class="ly jq">是有效的。</strong></p><p id="54c2" class="pw-post-body-paragraph lw lx jg ly b lz ms kq mb mc mt kt me mf mu mh mi mj mv ml mm mn mw mp mq mr ij bi translated">因此，我们的终端SCD类型2应该看起来像:</p><figure class="nm nn no np gt is gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/c6a6a545c71fefc341f53f5fd7069f93.png" data-original-src="https://miro.medium.com/v2/resize:fit:738/format:webp/1*pX_vtpuy25RkPG09wXl4FA.png"/></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">最终SCD。作者图片</p></figure><h1 id="86d0" class="le lf jg bd lg lh li lj lk ll lm ln lo kv lp kw lq ky lr kz ls lb lt lc lu lv bi translated">Apache Spark中的实现</h1><p id="85e5" class="pw-post-body-paragraph lw lx jg ly b lz ma kq mb mc md kt me mf mg mh mi mj mk ml mm mn mo mp mq mr ij bi translated">你可能会想，我们在RDBMS中有MERGE命令，我们可以很容易地做到这一点。是的，您可以，但是您最有可能操作的是镶木地板(或任何其他类型的文件)。或者，如果你足够幸运，你的公司有像<a class="ae jd" href="https://hudi.apache.org/" rel="noopener ugc nofollow" target="_blank"> Apache胡迪</a>/<a class="ae jd" href="https://delta.io/" rel="noopener ugc nofollow" target="_blank">Delta</a>/<a class="ae jd" href="https://iceberg.apache.org/" rel="noopener ugc nofollow" target="_blank">Apache Iceberg</a>这样的表格格式，这样你就可以在那里利用类似的特性。</p><p id="76bc" class="pw-post-body-paragraph lw lx jg ly b lz ms kq mb mc mt kt me mf mu mh mi mj mv ml mm mn mw mp mq mr ij bi translated">但是让我们假设您没有任何其他选择，只能用最简单的步骤创建SCD。</p><p id="3c48" class="pw-post-body-paragraph lw lx jg ly b lz ms kq mb mc mt kt me mf mu mh mi mj mv ml mm mn mw mp mq mr ij bi translated">声明我的代码与我之前解释的不同之处:</p><ol class=""><li id="e042" class="mx my jg ly b lz ms mc mt mf mz mj na mn nb mr nt nd ne nf bi translated">在我的代码中，我没有使用is_valid标志；我将传递end _ date = 2999–12–31，它将标识当前有效的行。</li><li id="0810" class="mx my jg ly b lz ng mc nh mf ni mj nj mn nk mr nt nd ne nf bi translated">此外，我还添加了open_reason和close_reason来标识一行被打开和关闭的原因。</li><li id="cf79" class="mx my jg ly b lz ng mc nh mf ni mj nj mn nk mr nt nd ne nf bi translated">我也不会为一个表添加一个代理键来进行PK</li></ol><h2 id="feac" class="nu lf jg bd lg nv nw dn lk nx ny dp lo mf nz oa lq mj ob oc ls mn od oe lu jm bi translated">先决条件</h2><p id="58e5" class="pw-post-body-paragraph lw lx jg ly b lz ma kq mb mc md kt me mf mg mh mi mj mk ml mm mn mo mp mq mr ij bi translated">如果一行发生了变化，我们需要的第一件事是更容易识别——get _ values _ hash方法。我更喜欢MD5，在使用MS SQL stack构建数据保险库模型时，我广泛使用了MD5，但这次我有点懒，没有找到它，而是使用了一个简单的<strong class="ly jq">散列。</strong></p><figure class="nm nn no np gt is"><div class="bz fp l di"><div class="of og l"/></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">哈希值方法</p></figure><p id="ea40" class="pw-post-body-paragraph lw lx jg ly b lz ms kq mb mc mt kt me mf mu mh mi mj mv ml mm mn mw mp mq mr ij bi translated">我们还需要确保当前快照中的列在SCD中没有相同的名称，以避免重复的列错误:</p><figure class="nm nn no np gt is"><div class="bz fp l di"><div class="of og l"/></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">列重命名方法</p></figure><p id="d14b" class="pw-post-body-paragraph lw lx jg ly b lz ms kq mb mc mt kt me mf mu mh mi mj mv ml mm mn mw mp mq mr ij bi translated">我们还需要一个分割器来识别哪些行应该被检查更改——只检查打开的行。我们根本不应该碰历史记录。</p><figure class="nm nn no np gt is"><div class="bz fp l di"><div class="of og l"/></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">从现有SCD打开和关闭行拆分器。</p></figure><h2 id="fd60" class="nu lf jg bd lg nv nw dn lk nx ny dp lo mf nz oa lq mj ob oc ls mn od oe lu jm bi translated">新行</h2><p id="fe90" class="pw-post-body-paragraph lw lx jg ly b lz ma kq mb mc md kt me mf mg mh mi mj mk ml mm mn mo mp mq mr ij bi translated">所以新行非常简单；我们添加SCD列，如is_valid、start_date、close_date、open_reason、close_reason。我还添加了一些特定的处理程序。如果某些数据到达较晚或有特定的列，我们应该使用它作为开放日期，而不是当前日期。</p><figure class="nm nn no np gt is"><div class="bz fp l di"><div class="of og l"/></div></figure><h2 id="a07a" class="nu lf jg bd lg nv nw dn lk nx ny dp lo mf nz oa lq mj ob oc ls mn od oe lu jm bi translated">删除的行</h2><p id="46ce" class="pw-post-body-paragraph lw lx jg ly b lz ma kq mb mc md kt me mf mg mh mi mj mk ml mm mn mo mp mq mr ij bi translated">我们从现有的SCD中取出打开的行，并只在删除的行上创建它们的副本。关闭SCD中已打开的文件，并向新打开的文件添加相关数据(is_deleted flag = 1，end _ date = 2999–12–31 ),并将其合并回一个数据帧。</p><figure class="nm nn no np gt is"><div class="bz fp l di"><div class="of og l"/></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">处理删除的行</p></figure><h2 id="80ee" class="nu lf jg bd lg nv nw dn lk nx ny dp lo mf nz oa lq mj ob oc ls mn od oe lu jm bi translated">已更新或未更改的行</h2><p id="1a34" class="pw-post-body-paragraph lw lx jg ly b lz ma kq mb mc md kt me mf mg mh mi mj mk ml mm mn mo mp mq mr ij bi translated">所以这个有点复杂，主要是因为这个，我们有那些先决条件的方法。</p><p id="b31e" class="pw-post-body-paragraph lw lx jg ly b lz ms kq mb mc mt kt me mf mu mh mi mj mv ml mm mn mw mp mq mr ij bi translated">首先，我们识别没有改变的记录，并把它们放在一边；他们会像以前一样。</p><p id="cd5a" class="pw-post-body-paragraph lw lx jg ly b lz ms kq mb mc mt kt me mf mu mh mi mj mv ml mm mn mw mp mq mr ij bi translated">第二，我们通过比较记录值的散列来处理更改的记录。为了避免两次读取相同的源，我使用了一个作弊方法，结果证明在较小的表中效率非常高(我还没有在较大的表上试过)=我添加了一个包含两个值(0，1)的数组列，稍后我将展开它，有条件地处理这两种情况。因此，在旧行上添加日期更改，打开包含所有相关元数据的新行，并联合所有三个数据框(无更改、来自SCD的更新更改、来自快照的新值)。</p><figure class="nm nn no np gt is"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="afd8" class="pw-post-body-paragraph lw lx jg ly b lz ms kq mb mc mt kt me mf mu mh mi mj mv ml mm mn mw mp mq mr ij bi translated">所以整个过程看起来是这样的:</p><figure class="nm nn no np gt is"><div class="bz fp l di"><div class="of og l"/></div></figure><h1 id="33f0" class="le lf jg bd lg lh li lj lk ll lm ln lo kv lp kw lq ky lr kz ls lb lt lc lu lv bi translated">摘要</h1><p id="569c" class="pw-post-body-paragraph lw lx jg ly b lz ma kq mb mc md kt me mf mg mh mi mj mk ml mm mn mo mp mq mr ij bi translated">在本文中，您已经简要介绍了SCD type 2，并且知道如果您的表存储在parquet文件中(不使用任何表格式)，如何使用Apache Spark创建它。</p><p id="63e0" class="pw-post-body-paragraph lw lx jg ly b lz ms kq mb mc mt kt me mf mu mh mi mj mv ml mm mn mw mp mq mr ij bi translated">值得一提的是，代码并非完美无瑕。</p><ul class=""><li id="9bdc" class="mx my jg ly b lz ms mc mt mf mz mj na mn nb mr nc nd ne nf bi translated">添加代理键以便在事实数据表中使用</li><li id="d4a9" class="mx my jg ly b lz ng mc nh mf ni mj nj mn nk mr nc nd ne nf bi translated">我假设删除该行后，它将不再出现，因此在这种情况下，代码将不会以正确的方式工作。</li><li id="f296" class="mx my jg ly b lz ng mc nh mf ni mj nj mn nk mr nc nd ne nf bi translated">添加is_valid标志，不处理与bool/int相比过滤效率不高的日期。</li><li id="07e1" class="mx my jg ly b lz ng mc nh mf ni mj nj mn nk mr nc nd ne nf bi translated">添加一些缓存/广播/洗牌分区选项，用一些参数提高性能。</li></ul><p id="9581" class="pw-post-body-paragraph lw lx jg ly b lz ms kq mb mc mt kt me mf mu mh mi mj mv ml mm mn mw mp mq mr ij bi translated">你可以在我的<a class="ae jd" href="https://github.com/TomasPel/BlogPosts/tree/master/slowly_changing_dimension" rel="noopener ugc nofollow" target="_blank"> GitHub </a>中找到我开发时使用的一些测试的完整代码。</p></div></div>    
</body>
</html>