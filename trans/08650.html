<html>
<head>
<title>Parsing Fixed Width Text Files with Pandas</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Pandas解析固定宽度的文本文件</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/parsing-fixed-width-text-files-with-pandas-f1db8f737276?source=collection_archive---------2-----------------------#2021-08-10">https://towardsdatascience.com/parsing-fixed-width-text-files-with-pandas-f1db8f737276?source=collection_archive---------2-----------------------#2021-08-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="f98e" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/hands-on-tutorials" rel="noopener" target="_blank">实践教程</a></h2><div class=""/><div class=""><h2 id="9344" class="pw-subtitle-paragraph ka iz iq bd b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr dk translated">如何轻松地将固定宽度的文本文件读入Pandas数据帧</h2></div><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi ks"><img src="../Images/d14359a3afc8474c3df45328bca4a283.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SA9Gmu_gXDE57LCDClO3Gw.jpeg"/></div></div><p class="le lf gj gh gi lg lh bd b be z dk translated">照片由<a class="ae li" href="https://unsplash.com/@caarl" rel="noopener ugc nofollow" target="_blank">雷诺·卡尔</a>在<a class="ae li" href="https://unsplash.com/?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure></div><div class="ab cl lj lk hu ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="ij ik il im in"><h1 id="fc9f" class="lq lr iq bd ls lt lu lv lw lx ly lz ma kj mb kk mc km md kn me kp mf kq mg mh bi translated">什么是固定宽度文本文件？</h1><p id="ab3f" class="pw-post-body-paragraph mi mj iq mk b ml mm ke mn mo mp kh mq mr ms mt mu mv mw mx my mz na nb nc nd ij bi translated">固定宽度文件类似于csv文件，但不是使用分隔符，每个字段都有固定数量的字符。这将创建所有数据整齐排列的文件，当在文本编辑器中打开时，其外观类似于电子表格。如果您在文本编辑器中查看原始数据文件，这很方便，但是当您需要以编程方式处理数据时，这就不太理想了。</p><p id="da81" class="pw-post-body-paragraph mi mj iq mk b ml ne ke mn mo nf kh mq mr ng mt mu mv nh mx my mz ni nb nc nd ij bi translated">固定宽度文件有一些常见的怪癖要记住:</p><ul class=""><li id="b3bf" class="nj nk iq mk b ml ne mo nf mr nl mv nm mz nn nd no np nq nr bi translated">当值不消耗字段的总字符数时，使用填充字符来增加该字段的总字符数。</li><li id="724f" class="nj nk iq mk b ml ns mo nt mr nu mv nv mz nw nd no np nq nr bi translated">只要在整个文件中保持一致，任何字符都可以用作填充字符。空白是一种常见的填充字符。</li><li id="76a3" class="nj nk iq mk b ml ns mo nt mr nu mv nv mz nw nd no np nq nr bi translated">字段中的值可以左对齐或右对齐，并且文件中所有字段的对齐方式必须一致。</li></ul><p id="2ee7" class="pw-post-body-paragraph mi mj iq mk b ml ne ke mn mo nf kh mq mr ng mt mu mv nh mx my mz ni nb nc nd ij bi translated">此处提供了固定宽度文件的详细描述<a class="ae li" href="https://www.softinterface.com/Convert-XLS/Features/Fixed-Width-Text-File-Definition.htm" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="2f36" class="pw-post-body-paragraph mi mj iq mk b ml ne ke mn mo nf kh mq mr ng mt mu mv nh mx my mz ni nb nc nd ij bi translated"><strong class="mk ja">注意</strong>:固定宽度文件中的所有字段<strong class="mk ja">不</strong>需要有相同的字符数。例如:在一个有三个字段的文件中，第一个字段可以是6个字符，第二个是20个字符，最后一个是9个字符。</p><h1 id="6cb1" class="lq lr iq bd ls lt nx lv lw lx ny lz ma kj nz kk mc km oa kn me kp ob kq mg mh bi translated">如何识别固定宽度的文本文件？</h1><p id="9749" class="pw-post-body-paragraph mi mj iq mk b ml mm ke mn mo mp kh mq mr ms mt mu mv mw mx my mz na nb nc nd ij bi translated">最初检查时，当空白用作填充字符时，固定宽度的文件看起来像制表符分隔的文件。如果你试图读取一个固定宽度的csv或tsv格式的文件并得到错误的结果，试着在文本编辑器中打开它。如果数据排列整齐，这可能是一个固定宽度的文件。许多文本编辑器还会给出光标位置的字符数，这使得在字符数中发现模式变得更加容易。</p><p id="fefe" class="pw-post-body-paragraph mi mj iq mk b ml ne ke mn mo nf kh mq mr ng mt mu mv nh mx my mz ni nb nc nd ij bi translated">如果您的文件太大，不容易在文本编辑器中打开，有多种方法可以在命令行上将它的一部分采样到一个单独的较小的文件中。Unix/Linux系统上的一个简单方法是<code class="fe jw jx jy jz b">head</code>命令。下面的例子使用<code class="fe jw jx jy jz b">head</code>和<code class="fe jw jx jy jz b">-n 50</code>来读取<code class="fe jw jx jy jz b">large_file.txt</code>的前50行，然后将它们复制到一个名为<code class="fe jw jx jy jz b">first_50_rows.txt</code>的新文件中。</p><pre class="kt ku kv kw gt oc jz od oe aw of bi"><span id="537b" class="og lr iq jz b gy oh oi l oj ok">head -n 50 large_file.txt &gt; first_50_rows.txt</span></pre><h1 id="e6db" class="lq lr iq bd ls lt nx lv lw lx ny lz ma kj nz kk mc km oa kn me kp ob kq mg mh bi translated">让我们使用一个真实的示例文件</h1><h2 id="fd7e" class="og lr iq bd ls ol om dn lw on oo dp ma mr op oq mc mv or os me mz ot ou mg iw bi translated">UniProtKB数据库</h2><p id="7dff" class="pw-post-body-paragraph mi mj iq mk b ml mm ke mn mo mp kh mq mr ms mt mu mv mw mx my mz na nb nc nd ij bi translated">UniProt Knowledgebase (UniProtKB)是一个可免费访问的综合性数据库，包含了CC-BY (4.0)许可下可用的蛋白质序列和注释数据。UniProtKB的Swiss-Prot分支已经人工注释和审查了各种生物体的蛋白质信息。UniProt数据的完整数据集可从ftp.uniprot.org<a class="ae li" href="http://ftp.uniprot.org/" rel="noopener ugc nofollow" target="_blank">下载。人类蛋白质的数据包含在一组<strong class="mk ja">固定宽度的文本文件中:</strong> <code class="fe jw jx jy jz b">humchr01.txt</code> - <code class="fe jw jx jy jz b">humchr22.txt</code>、<code class="fe jw jx jy jz b">humchrx.txt</code>和<code class="fe jw jx jy jz b">humchry.txt</code>。</a></p><p id="c544" class="pw-post-body-paragraph mi mj iq mk b ml ne ke mn mo nf kh mq mr ng mt mu mv nh mx my mz ni nb nc nd ij bi translated">对于这个例子，我们不需要所有的24个文件，所以这里是指向集合中第一个文件的链接:</p><p id="67d4" class="pw-post-body-paragraph mi mj iq mk b ml ne ke mn mo nf kh mq mr ng mt mu mv nh mx my mz ni nb nc nd ij bi translated"><a class="ae li" href="https://ftp.uniprot.org/pub/databases/uniprot/current_release/knowledgebase/complete/docs/humchr01.txt" rel="noopener ugc nofollow" target="_blank">https://FTP . uni prot . org/pub/databases/uni prot/current _ release/knowledge base/complete/docs/hum chr 01 . txt</a></p><h2 id="a46d" class="og lr iq bd ls ol om dn lw on oo dp ma mr op oq mc mv or os me mz ot ou mg iw bi translated">在用熊猫阅读文件之前检查它</h2><p id="d566" class="pw-post-body-paragraph mi mj iq mk b ml mm ke mn mo mp kh mq mr ms mt mu mv mw mx my mz na nb nc nd ij bi translated">在文本编辑器中快速浏览一下该文件，可以看到一个我们不需要导入6个数据字段的大标题。</p><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi ov"><img src="../Images/71d7494710d7435af44c40713c456278.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DsghtjSGwERscQUuoBauNw.jpeg"/></div></div><p class="le lf gj gh gi lg lh bd b be z dk translated"><a class="ae li" href="https://ftp.uniprot.org/pub/databases/uniprot/current_release/knowledgebase/complete/docs/humchr01.txt" rel="noopener ugc nofollow" target="_blank"> humchr01.txt </a>开头的片段</p></figure><p id="67e5" class="pw-post-body-paragraph mi mj iq mk b ml ne ke mn mo nf kh mq mr ng mt mu mv nh mx my mz ni nb nc nd ij bi translated">固定宽度文件似乎不像许多其他数据文件格式那样常见，乍看起来它们可能像制表符分隔的文件。在尝试使用Pandas阅读文件之前，在一个好的文本编辑器中对文本文件进行视觉检查可以大大减少挫折感，并有助于突出格式模式。</p><h2 id="54c4" class="og lr iq bd ls ol om dn lw on oo dp ma mr op oq mc mv or os me mz ot ou mg iw bi translated">使用pandas.read_fwf()和默认参数</h2><p id="e1af" class="pw-post-body-paragraph mi mj iq mk b ml mm ke mn mo mp kh mq mr ms mt mu mv mw mx my mz na nb nc nd ij bi translated"><strong class="mk ja">注意</strong>:这个例子的所有代码都是为Python3.6和Pandas1.2.0编写的</p><p id="55ca" class="pw-post-body-paragraph mi mj iq mk b ml ne ke mn mo nf kh mq mr ng mt mu mv nh mx my mz ni nb nc nd ij bi translated"><code class="fe jw jx jy jz b"><a class="ae li" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.read_fwf.html" rel="noopener ugc nofollow" target="_blank">pandas.read_fwf()</a></code>的文档列出了5个参数:</p><p id="aa8d" class="pw-post-body-paragraph mi mj iq mk b ml ne ke mn mo nf kh mq mr ng mt mu mv nh mx my mz ni nb nc nd ij bi translated"><code class="fe jw jx jy jz b">filepath_or_buffer</code>、<code class="fe jw jx jy jz b">colspecs</code>、<code class="fe jw jx jy jz b">widths</code>、<code class="fe jw jx jy jz b">infer_nrows</code>和<code class="fe jw jx jy jz b">**kwds</code></p><p id="a296" class="pw-post-body-paragraph mi mj iq mk b ml ne ke mn mo nf kh mq mr ng mt mu mv nh mx my mz ni nb nc nd ij bi translated">两个<code class="fe jw jx jy jz b">pandas.read_fwf()</code>参数<code class="fe jw jx jy jz b">colspecs</code>和<code class="fe jw jx jy jz b">infer_nrows</code>具有默认值，用于根据初始行的抽样推断列。</p><p id="e944" class="pw-post-body-paragraph mi mj iq mk b ml ne ke mn mo nf kh mq mr ng mt mu mv nh mx my mz ni nb nc nd ij bi translated">让我们利用<code class="fe jw jx jy jz b">pandas.read_fwf()</code>的默认设置来获得整洁的数据帧。我们将把<code class="fe jw jx jy jz b">colspecs</code>参数保留为它的默认值‘infer ’,这又利用了<code class="fe jw jx jy jz b">infer_nrows</code>参数的默认值(100)。这两个默认值试图在数据的前100行(在任何跳过的行之后)中找到一个模式，并使用该模式将数据分成列。</p><h2 id="6b90" class="og lr iq bd ls ol om dn lw on oo dp ma mr op oq mc mv or os me mz ot ou mg iw bi translated">基本文件清理</h2><p id="1c0e" class="pw-post-body-paragraph mi mj iq mk b ml mm ke mn mo mp kh mq mr ms mt mu mv mw mx my mz na nb nc nd ij bi translated">在我们的示例文件中，表格信息之前有几行文件头。我们需要在读取文件时跳过它们。</p><p id="3e25" class="pw-post-body-paragraph mi mj iq mk b ml ne ke mn mo nf kh mq mr ng mt mu mv nh mx my mz ni nb nc nd ij bi translated">没有一个参数适合在读取文件时跳过行。那么我们该怎么做呢？我们利用<code class="fe jw jx jy jz b">**kwds</code>参数。</p><p id="9853" class="pw-post-body-paragraph mi mj iq mk b ml ne ke mn mo nf kh mq mr ng mt mu mv nh mx my mz ni nb nc nd ij bi translated">便利的是，<code class="fe jw jx jy jz b">pandas.read_fwf()</code>使用与<code class="fe jw jx jy jz b"><a class="ae li" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.read_table.html" rel="noopener ugc nofollow" target="_blank">pandas.read_table()</a></code>相同的<code class="fe jw jx jy jz b">TextFileReader</code>上下文管理器。这与<code class="fe jw jx jy jz b">**kwds</code>参数相结合，允许我们将<code class="fe jw jx jy jz b">pandas.read_table()</code>的参数与<code class="fe jw jx jy jz b">pandas.read_fwf()</code>一起使用。所以我们可以使用<code class="fe jw jx jy jz b">skiprows</code>参数跳过示例文件中的前35行。类似地，我们可以使用<code class="fe jw jx jy jz b">skipfooter</code>参数跳过示例文件的最后5行，其中包含不属于表格数据的页脚。</p><pre class="kt ku kv kw gt oc jz od oe aw of bi"><span id="8368" class="og lr iq jz b gy oh oi l oj ok">pandas.read_fwf('humchr01.txt', skiprows=35, skipfooter=5)</span></pre><p id="90d2" class="pw-post-body-paragraph mi mj iq mk b ml ne ke mn mo nf kh mq mr ng mt mu mv nh mx my mz ni nb nc nd ij bi translated">上面的尝试让数据帧有点混乱😔：</p><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi ow"><img src="../Images/7032eba13c22bc21a65ac1c4830eea17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cjOGn2yW0rN_96my6O-mTw.jpeg"/></div></div></figure><p id="fb41" class="pw-post-body-paragraph mi mj iq mk b ml ne ke mn mo nf kh mq mr ng mt mu mv nh mx my mz ni nb nc nd ij bi translated"><strong class="mk ja">注意</strong>:因为我们对<code class="fe jw jx jy jz b">colspecs</code>和<code class="fe jw jx jy jz b">infer_nrows</code>使用默认值，所以我们不必声明它们。</p><p id="e0a5" class="pw-post-body-paragraph mi mj iq mk b ml ne ke mn mo nf kh mq mr ng mt mu mv nh mx my mz ni nb nc nd ij bi translated">这里的部分问题是，默认的<code class="fe jw jx jy jz b">colspecs</code>参数试图根据前100行推断列宽，但是表格数据之前的行(文件中的第36行，显示在上面的列名中)实际上并不遵循数据表中的字符计数模式，所以推断的列宽变得混乱。</p><p id="8cb6" class="pw-post-body-paragraph mi mj iq mk b ml ne ke mn mo nf kh mq mr ng mt mu mv nh mx my mz ni nb nc nd ij bi translated">如果我们将<code class="fe jw jx jy jz b">skiprows</code>设置为36而不是35，我们会将第一行数据推入列名，这也会破坏推断的列宽。如果没有额外的清理工作，就没有胜利可言。让我们用<code class="fe jw jx jy jz b">names</code>参数解决列名问题，看看是否有帮助。</p><p id="6a80" class="pw-post-body-paragraph mi mj iq mk b ml ne ke mn mo nf kh mq mr ng mt mu mv nh mx my mz ni nb nc nd ij bi translated"><strong class="mk ja">注意</strong>:使用<code class="fe jw jx jy jz b">names</code>参数意味着我们没有将文件中的一行分配给列名，因此我们作为用户必须确保考虑到这样一个事实，即<code class="fe jw jx jy jz b">skiprows</code>必须从第一个数据行开始。所以在下一个例子中<code class="fe jw jx jy jz b">skiprows</code>被设置为36，但是在之前的例子中，当我们没有使用<code class="fe jw jx jy jz b">names</code>参数时，它是35。</p><pre class="kt ku kv kw gt oc jz od oe aw of bi"><span id="ed61" class="og lr iq jz b gy oh oi l oj ok">pandas.read_fwf('humchr01.txt', skiprows=36, skipfooter=5, names=['gene_name', 'chromosomal_position', 'uniprot', 'entry_name', 'mtm_code', 'description'])</span></pre><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi ox"><img src="../Images/cf8a719da2b1adb2be23103a1afb2062.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CQ3ukpf1covkjsK0C8NG8g.jpeg"/></div></div></figure><p id="3b01" class="pw-post-body-paragraph mi mj iq mk b ml ne ke mn mo nf kh mq mr ng mt mu mv nh mx my mz ni nb nc nd ij bi translated">好多了，但还是有点乱。Pandas推断列拆分是正确的，但是将前两个字段推到了索引中。让我们通过设置<code class="fe jw jx jy jz b">index_col=False</code>来解决索引问题。</p><pre class="kt ku kv kw gt oc jz od oe aw of bi"><span id="e3b8" class="og lr iq jz b gy oh oi l oj ok">pandas.read_fwf('humchr01.txt', skiprows=36, skipfooter=5, index_col=False, names=['gene_name', 'chromosomal_position', 'uniprot', 'entry_name', 'mtm_code', 'description'])</span></pre><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi oy"><img src="../Images/234208f0a222d25e975d81475adca6a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RzltGdFa2KAOrwvcez5Ohg.jpeg"/></div></div></figure><p id="e209" class="pw-post-body-paragraph mi mj iq mk b ml ne ke mn mo nf kh mq mr ng mt mu mv nh mx my mz ni nb nc nd ij bi translated">看起来不错！列拆分正确，列名有意义，数据帧中的第一行数据与示例文件中的第一行数据相匹配。</p><p id="8060" class="pw-post-body-paragraph mi mj iq mk b ml ne ke mn mo nf kh mq mr ng mt mu mv nh mx my mz ni nb nc nd ij bi translated">我们依靠两个<code class="fe jw jx jy jz b">pandas.read_fwf()</code>特定参数的默认设置来获得整洁的数据帧。<code class="fe jw jx jy jz b">colspecs</code>参数保留其默认值“infer ”,它反过来利用<code class="fe jw jx jy jz b">infer_nrows</code>参数的默认值，并在数据的前100行(跳过的行之后)中找到一个模式，并使用该模式将数据分成列。默认参数在这个示例文件中运行良好，但是我们也可以指定<code class="fe jw jx jy jz b">colspecs</code>参数，而不是让pandas推断列。</p><h1 id="4e45" class="lq lr iq bd ls lt nx lv lw lx ny lz ma kj nz kk mc km oa kn me kp ob kq mg mh bi translated">使用colspecs手动设置字段宽度</h1><p id="1bd8" class="pw-post-body-paragraph mi mj iq mk b ml mm ke mn mo mp kh mq mr ms mt mu mv mw mx my mz na nb nc nd ij bi translated">就像上面的例子一样，我们需要从一些基本的清理开始。我们将在文件中放置页眉和页脚，并像前面一样设置列名。</p><p id="8eeb" class="pw-post-body-paragraph mi mj iq mk b ml ne ke mn mo nf kh mq mr ng mt mu mv nh mx my mz ni nb nc nd ij bi translated">下一步是用每个字段的间隔建立一个元组列表。下面的列表符合示例文件。</p><pre class="kt ku kv kw gt oc jz od oe aw of bi"><span id="b818" class="og lr iq jz b gy oh oi l oj ok">colspecs = [(0, 14), (14, 30), (30, 41), (41, 53), (53, 60), (60, -1)]</span></pre><p id="7770" class="pw-post-body-paragraph mi mj iq mk b ml ne ke mn mo nf kh mq mr ng mt mu mv nh mx my mz ni nb nc nd ij bi translated">注意最后一个元组:(60，-1)。我们可以用-1来表示最后一个索引值。或者，我们可以使用<code class="fe jw jx jy jz b">None</code>而不是-1来表示最后一个索引值。</p><p id="7fff" class="pw-post-body-paragraph mi mj iq mk b ml ne ke mn mo nf kh mq mr ng mt mu mv nh mx my mz ni nb nc nd ij bi translated"><strong class="mk ja">注意</strong>:当使用<code class="fe jw jx jy jz b">colspecs</code>时，元组不必是排除性的！如果需要，可以将最终列设置为重叠的元组。例如，如果您想要复制第一个字段:<code class="fe jw jx jy jz b">colspecs = [(0, 14), (0, 14), ...</code></p><pre class="kt ku kv kw gt oc jz od oe aw of bi"><span id="7b5e" class="og lr iq jz b gy oh oi l oj ok">pandas.read_fwf('humchr01.txt', skiprows=36, skipfooter=5, colspecs=colspecs, names=['gene_name', 'chromosomal_position', 'uniprot', 'entry_name', 'mtm_code', 'description'])</span></pre><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi oz"><img src="../Images/5ea3a08c906088fd7de2043c7bc729f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hvl_E7Tz1YrVTU2jvYqziw.jpeg"/></div></div></figure><p id="644f" class="pw-post-body-paragraph mi mj iq mk b ml ne ke mn mo nf kh mq mr ng mt mu mv nh mx my mz ni nb nc nd ij bi translated">我们又一次获得了一个整洁的数据框架。这一次，我们使用<code class="fe jw jx jy jz b">colspecs</code>参数明确声明了我们的字段开始和结束位置，而不是让pandas推断字段。</p><h1 id="3d82" class="lq lr iq bd ls lt nx lv lw lx ny lz ma kj nz kk mc km oa kn me kp ob kq mg mh bi translated">结论</h1><p id="699a" class="pw-post-body-paragraph mi mj iq mk b ml mm ke mn mo mp kh mq mr ms mt mu mv mw mx my mz na nb nc nd ij bi translated">用Pandas阅读固定宽度的文本文件既简单又容易。<code class="fe jw jx jy jz b">pandas.read_fwf()</code>的默认参数在大多数情况下都有效，定制选项有据可查。熊猫图书馆有许多功能可以让<a class="ae li" href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html" rel="noopener ugc nofollow" target="_blank">读取各种文件类型</a>，而<code class="fe jw jx jy jz b">pandas.read_fwf()</code>是一个需要记住的更有用的熊猫工具。</p></div></div>    
</body>
</html>