<html>
<head>
<title>Introduction to Apache Kafka with Wikipedia’s EventStreams service</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用维基百科的EventStreams服务介绍阿帕奇卡夫卡</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/introduction-to-apache-kafka-with-wikipedias-eventstreams-service-d06d4628e8d9?source=collection_archive---------20-----------------------#2021-04-10">https://towardsdatascience.com/introduction-to-apache-kafka-with-wikipedias-eventstreams-service-d06d4628e8d9?source=collection_archive---------20-----------------------#2021-04-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="5ccd" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">概念和实践示例</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/a8873701226dd289bdfa7c83ac375150.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*F0A4OspOmObSFFBv"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">若昂·布兰科在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><h1 id="0b86" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">介绍</h1><p id="ad63" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">在这篇文章中，我们通过基本概念，构成了阿帕奇卡夫卡。我们利用维基百科提供的名为<a class="ae kv" href="https://wikitech.wikimedia.org/wiki/Event_Platform/EventStreams" rel="noopener ugc nofollow" target="_blank">事件流</a>的真实事件流，将它们发送到一个卡夫卡主题。</p><p id="2633" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">本教程旨在让读者熟悉Apache Kafka，这是一个用于与Kafka交互的Python客户端库，也是进一步实验的平台。这种设置意味着在本地系统上运行，不考虑安全性和可伸缩性问题，使用的配置很少。</p><h1 id="2028" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">阿帕奇卡夫卡</h1><p id="a7cc" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">Apache Kafka可能是最著名的发布/订阅消息系统，它被各行各业过度采用是有充分理由的。在过去的几年里，由于对实时数据开发(分析、处理、可视化)的需求不断增长，它变得越来越流行。</p><p id="a14f" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">已经写了许多电子书和文章来解释什么是阿帕奇卡夫卡以及它是如何工作的。在本文中，我将尝试对您需要了解的最重要的几点做一个简短的概述，并为您提供一些参考信息。我已经突出了最重要的关键词。</p><h2 id="12d8" class="mp kx iq bd ky mq mr dn lc ms mt dp lg lx mu mv li mb mw mx lk mf my mz lm na bi translated">生态系统</h2><p id="3379" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">Kafka中的数据单元称为<strong class="lq ir">消息</strong>。一条消息只是一个字节数组，它还可以包含一个名为<strong class="lq ir"> key </strong>的元数据位，这也是一个字节数组。根据用例的不同，可以使用或不使用键，它们提供了一种以更可控的方式填充主题分区的方法。消息也可以被称为键值对；您可以将它们视为传统SQL数据库中的记录。</p><p id="bc6f" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在大多数情况下，消息需要有某种结构，可以很容易地从其他系统中解释出来(<strong class="lq ir">模式</strong>)。最流行的格式是JSON、XML和Avro。</p><p id="24b0" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在Kafka中，生态系统消息是以<strong class="lq ir">批</strong>的方式产生的，目的是将消息在网络内部往返的开销降至最低。</p><p id="74ce" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">消息被分类到不同的<strong class="lq ir">主题</strong>中，以便根据一些属性将它们分开。主题也可以分成<strong class="lq ir">分区</strong>，这提供了额外的可伸缩性和性能，因为它们可以被托管在不同的服务器上。您可以将主题视为一个仅附加的日志，只能从头到尾读取。在SQL世界中，主题就是我们的表。</p><p id="5f75" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">有两种类型的客户端:<strong class="lq ir">出版商</strong>和<strong class="lq ir">消费者</strong>。顾名思义，发布者向主题发送消息，消费者阅读它们。</p><p id="e374" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">一个Kafka节点被称为<strong class="lq ir">代理</strong>。代理负责从生产者那里获取消息，将它们存储在磁盘中，并响应消费者的请求。许多经纪人组成一个集群。分区只能由一个称为<strong class="lq ir"> leader的代理拥有。</strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nb"><img src="../Images/29ec09413cfb54ebec5fc452a72ca662.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MMEHSAzaBNrYS_AKlmB8Wg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">卡夫卡主要成分概述</p></figure><h2 id="8385" class="mp kx iq bd ky mq mr dn lc ms mt dp lg lx mu mv li mb mw mx lk mf my mz lm na bi translated">关键特征</h2><p id="0727" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">使Apache Kafka脱颖而出的一些关键特性:</p><ul class=""><li id="9d5c" class="nc nd iq lq b lr mk lu ml lx ne mb nf mf ng mj nh ni nj nk bi translated"><strong class="lq ir">多个制作者</strong>可以同时发布消息到相同的主题。</li><li id="832a" class="nc nd iq lq b lr nl lu nm lx nn mb no mf np mj nh ni nj nk bi translated"><strong class="lq ir">多个用户</strong>可以独立于其他用户读取数据，也可以在共享流的一组用户中读取数据，并确保每条消息在整个组中只被读取一次。</li><li id="e971" class="nc nd iq lq b lr nl lu nm lx nn mb no mf np mj nh ni nj nk bi translated"><strong class="lq ir">保留</strong>，发布到集群的数据可以按照给定的规则在磁盘上保留。</li><li id="e8de" class="nc nd iq lq b lr nl lu nm lx nn mb no mf np mj nh ni nj nk bi translated">可伸缩性，Kafka被设计为完全可伸缩的，因为它是一个分布式系统，运行在不同地理区域的多个代理集群上，支持多个发行商和消费者。</li><li id="f46e" class="nc nd iq lq b lr nl lu nm lx nn mb no mf np mj nh ni nj nk bi translated"><strong class="lq ir">性能</strong>，除了上面提到的特性之外，Kafka即使在数据负载很重的情况下也非常快，从发布一条消息到可供消费之间的延迟为亚秒级。</li></ul><p id="57ee" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在本教程中，我们将设置一个具有单个节点的Kafka集群作为概念验证。在生产环境场景中，为了充分利用Kafka的潜力，建议设置一个包含多个节点(至少三个)的集群。这将为实现跨节点的数据复制奠定基础，从而构建一个容错系统。</p><p id="8f8f" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">如果你想更深入地了解卡夫卡的生态系统，我建议你阅读<strong class="lq ir">卡夫卡权威指南</strong>以及其他电子书，你可以在<a class="ae kv" href="https://kafka.apache.org/books-and-papers" rel="noopener ugc nofollow" target="_blank">卡夫卡的官方网站</a>上免费找到。这本书将提供你理解Kafka如何工作所需要的所有低级知识，同时也提供在生产环境中部署的指南和建议。</p><h1 id="cf4a" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">卡夫卡-巨蟒</h1><p id="6fa7" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">这个项目使用kafka-python库发布事件到kafka主题，因为它使用简单。当然，也有像Confluent的官方<a class="ae kv" href="https://github.com/confluentinc/confluent-kafka-python" rel="noopener ugc nofollow" target="_blank">库</a>或<a class="ae kv" href="https://github.com/Parsely/pykafka" rel="noopener ugc nofollow" target="_blank"> pykafka </a>这样的替代品，你可以用它们来代替kafka-python。</p><p id="68d8" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">当然，您也可以从不同的编程语言中使用许多客户端库。用Java和Scala编写的客户端库可以被认为更适合生产环境，因为当需要完成更复杂的任务时，使用Kafka的母语将提供更多的选择。而且，那些库比用Python写的更成熟。</p><h1 id="16d3" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">事件流</h1><p id="1d73" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">正如简介中提到的，<a class="ae kv" href="https://wikitech.wikimedia.org/wiki/Event_Platform/EventStreams" rel="noopener ugc nofollow" target="_blank"> EventStreams </a>是一个web服务，它使用<a class="ae kv" href="https://en.wikipedia.org/wiki/Chunked_transfer_encoding" rel="noopener ugc nofollow" target="_blank">分块传输编码</a>，遵循<a class="ae kv" href="https://en.wikipedia.org/wiki/Server-sent_events" rel="noopener ugc nofollow" target="_blank">服务器发送事件</a> (SSE)协议，通过HTTP公开连续的事件流。这些事件与维基百科用户改变现有维基百科网页状态(编辑和分类)的行为有关，也与添加新网页(网页)有关。</p><p id="3d89" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在这个项目中，我们只对与现有网页编辑相关的事件感兴趣，因此我们相应地过滤来自EventsStreams服务的事件。编辑事件包含编辑日期、编辑者的用户名、标志值(取决于是机器人还是人进行了编辑/更改)、文章标题和更多元数据等信息。出于本教程的考虑，我们选择只保留其中一些变量来发布给Kafka然而，您可以根据您想要模拟的用例来创建您自己的消息模式。</p><p id="721e" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">编辑事件带有不同名称空间，用于标识不同类型的文章类别。这些名称空间在从EventStreams中使用时是整数，但是我们根据这个<a class="ae kv" href="https://en.wikipedia.org/wiki/Wikipedia:Namespace#Programming" rel="noopener ugc nofollow" target="_blank">表</a>将它们映射到它们的id名称。</p><p id="4792" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我们的消息的最终JSON模式示例如下:</p><pre class="kg kh ki kj gt nq nr ns nt aw nu bi"><span id="99e2" class="mp kx iq nr b gy nv nw l nx ny">{<br/>    "id": 1426354584, <br/>    "domain": "www.wikidata.org", <br/>    "namespace": "main namespace", <br/>    "title": "articles_title", <br/>    "timestamp": "2021-03-14T21:55:14Z", <br/>    "user_name": "a_user_name", <br/>    "user_type": "human", <br/>    "old_length": 6019, <br/>    "new_length": 8687<br/>}</span></pre><h1 id="7245" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">设置项目</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/b42026dc3f946e4e85aadcd80fa1cf0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1384/format:webp/1*N6pBizM-8QTgYoPKcABxoQ.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">项目概述</p></figure><h2 id="6130" class="mp kx iq bd ky mq mr dn lc ms mt dp lg lx mu mv li mb mw mx lk mf my mz lm na bi translated">在本地启动Kafka代理</h2><p id="b4fd" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">打开一个新的终端来启动Zookeeper集群管理器。默认情况下，端口2181将用于以下机器:</p><pre class="kg kh ki kj gt nq nr ns nt aw nu bi"><span id="aba3" class="mp kx iq nr b gy nv nw l nx ny">bin/zookeeper-server-start.sh config/zookeeper.properties</span></pre><p id="c5ba" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在第二个终端中，在本地启动一个Kafka代理。默认情况下，它将在端口9092运行。</p><pre class="kg kh ki kj gt nq nr ns nt aw nu bi"><span id="87e7" class="mp kx iq nr b gy nv nw l nx ny">bin/kafka-server-start.sh config/server.properties</span></pre><p id="61bc" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">打开第三个终端，以便与卡夫卡互动。首先列出本地主机代理中当前可用的主题。</p><pre class="kg kh ki kj gt nq nr ns nt aw nu bi"><span id="643d" class="mp kx iq nr b gy nv nw l nx ny">bin/kafka-topics.sh --list --zookeeper localhost:2181</span></pre><p id="f122" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">创建一个新的卡夫卡主题，将其命名为<strong class="lq ir"> wikipedia-events </strong>。在本主题中，我们将传播(发布)来自EventStreams服务的所有编辑事件。</p><p id="8fee" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">变量<em class="oa">复制因子</em>和<em class="oa">分区</em>是可选的。第一个选项指的是本主题应该初始化的不同节点的数量，这个选项帮助您实现前面提到的容错，并且只在具有多个代理的集群中有意义。分区还提供跨多个代理的可伸缩性；在这种情况下，1(一)以外的值实际上没有意义。</p><pre class="kg kh ki kj gt nq nr ns nt aw nu bi"><span id="a83b" class="mp kx iq nr b gy nv nw l nx ny">bin/kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic wikipedia-events</span></pre><p id="d388" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">再次列出我们的主题，wikipedia-events应该在控制台中打印出来。</p><h2 id="8f2d" class="mp kx iq bd ky mq mr dn lc ms mt dp lg lx mu mv li mb mw mx lk mf my mz lm na bi translated">设置Python环境</h2><p id="7082" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">首先将<a class="ae kv" href="https://github.com/ZisisFl/kafka-wikipedia-data-stream" rel="noopener ugc nofollow" target="_blank"> GitHub项目</a>克隆到您的本地机器上。</p><pre class="kg kh ki kj gt nq nr ns nt aw nu bi"><span id="bc94" class="mp kx iq nr b gy nv nw l nx ny">git clone <a class="ae kv" href="https://github.com/ZisisFl/kafka-wikipedia-data-stream.git" rel="noopener ugc nofollow" target="_blank">https://github.com/ZisisFl/kafka-wikipedia-data-stream.git</a></span></pre><p id="f57b" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">克隆完成后，导航到项目文件夹。</p><p id="c75b" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">首先，我们需要创建一个新的Python 3虚拟环境(这不是强制性的，但是强烈推荐)。我们将这个环境命名为kafka_env。这个项目所需的所有库都包含在<strong class="lq ir"> requirements.txt </strong>文件中。如果你想自己安装必要的库，小心使用pip install<strong class="lq ir">Kafka-python</strong>而不是pip install <strong class="lq ir"> kafka </strong>。(以下命令可能不适用于Windows操作系统。)</p><pre class="kg kh ki kj gt nq nr ns nt aw nu bi"><span id="05a5" class="mp kx iq nr b gy nv nw l nx ny">python3 -m venv kafka_venv<br/>source kafka_venv/bin/activate<br/>pip install -r requirements.txt</span></pre><p id="3574" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">使用以下命令，执行Python脚本<em class="oa">" Wikipedia _ events _ kafka _ producer . py "</em>并打开一个新的终端，以便通过终端使用来自Kafka主题的消息。选项<em class="oa"> from-beginning </em>不是必需的，使用时会提供已经发布到目标主题的消息的全部历史；否则，从执行以下命令的那一刻起，您将消耗消息。</p><pre class="kg kh ki kj gt nq nr ns nt aw nu bi"><span id="64a8" class="mp kx iq nr b gy nv nw l nx ny">bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic wikipedia-events --from-beginning</span></pre><p id="b172" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">控制台中应该打印出多个JSON对象！</p><h1 id="cd58" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">实验建议</h1><ul class=""><li id="a6d9" class="nc nd iq lq b lr ls lu lv lx ob mb oc mf od mj nh ni nj nk bi translated">创建处理不同类型事件的多个生成器，并通过不同或相同的主题发送它们。</li><li id="ab63" class="nc nd iq lq b lr nl lu nm lx nn mb no mf np mj nh ni nj nk bi translated">创建将数据成批存储到数据库或将其提供给任何其他系统的消费者。</li><li id="3873" class="nc nd iq lq b lr nl lu nm lx nn mb no mf np mj nh ni nj nk bi translated">创建一组消费者，他们将分担并行使用消息的工作，以提高性能。</li></ul></div></div>    
</body>
</html>