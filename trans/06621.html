<html>
<head>
<title>Actual, practical uses for the walrus operator in Python (+ examples)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中walrus运算符的实际应用(+示例)</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/actual-practical-uses-for-the-walrus-operator-in-python-examples-b13ea7baaa6b?source=collection_archive---------26-----------------------#2021-06-14">https://towardsdatascience.com/actual-practical-uses-for-the-walrus-operator-in-python-examples-b13ea7baaa6b?source=collection_archive---------26-----------------------#2021-06-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ae83" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">提高性能还是仅仅是语法上的好处？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/87c5f54118e6f6afe180f66be0c72c49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*k3ONGXNMCLrrUfSp"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">海象仅仅是糖做的还是有更多的成分？(图片由<a class="ae ky" href="https://www.pexels.com/@mali" rel="noopener ugc nofollow" target="_blank">马里·梅德</a>在<a class="ae ky" href="https://www.pexels.com/photo/strawberry-beside-spoon-of-sugar-141815/" rel="noopener ugc nofollow" target="_blank">像素</a>上拍摄)</p></figure><p id="26c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">快速坦白:自从在Python 3.8中引入以来，我从来没有这么频繁地使用过walrus操作符。当它第一次被介绍时，我认为它是一种句法糖，并且找不到使用它的理由。在本文中，我们将了解它是否仅仅提高了我们代码的可读性，或者是否有更多的意义。我们将通过这个模糊操作符的一些实际用例，让您的生活更轻松。在本文结束时，您将:</p><ul class=""><li id="9072" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">理解海象操作员做什么</li><li id="d72a" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">知道怎么用吗</li><li id="807c" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">识别使用walrus运算符的情况。</li></ul></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="62a4" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">0.什么是海象运营商？</h1><p id="acb6" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">让我们从头开始。海象算子长这样<code class="fe nn no np nq b">:=</code>。它允许你在同一个表达式中既赋值又返回一个变量。查看下面的代码块</p><pre class="kj kk kl km gt nr nq ns nt aw nu bi"><span id="619f" class="nv mr it nq b gy nw nx l ny nz">beerPrice = 9.99<br/>print(beerPrice)</span></pre><p id="122d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第1行，我们使用<code class="fe nn no np nq b">= </code>操作符将值9.99赋给一个名为‘beer price’的变量。然后，在第2行，我们打印变量。使用walrus运算符，我们可以一次完成这两项操作:</p><pre class="kj kk kl km gt nr nq ns nt aw nu bi"><span id="db7f" class="nv mr it nq b gy nw nx l ny nz">print(beerPrice := 9.99)</span></pre><p id="e903" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们都打印出啤酒价格，我们已经设置为9.99，此外，我们可以将变量用于其他用途。轻松点。现在让我们看看为什么我们需要这个功能，以及它对我们的代码意味着什么。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="9cb0" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">1.walrus操作员的用例</h1><p id="e286" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">在这一部分中，我们将应用运算符。我将尝试用一个尽可能类似真实应用程序的项目来说明这一点。在我看来，这比“foo”和“bar”的例子要好一些。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f807484c1e5cd5b5275af01fcc9e3b1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*eff23oPlpnsv1lp5"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">让我们让这家伙工作吧(图片由美国国家海洋和大气管理局发布)</p></figure><p id="d7c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我已经确定了一些情况，在这些情况下，walrus操作符可能是实用的。首先简单介绍一下我们的项目，然后我们将讨论每种情况。</p><h2 id="8894" class="nv mr it bd ms oa ob dn mw oc od dp na li oe of nc lm og oh ne lq oi oj ng ok bi translated">设置</h2><p id="d379" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">我们是一家出于分析目的分析书籍的公司。我们已经建立了一个很好的<a class="ae ky" rel="noopener" target="_blank" href="/build-a-real-life-professional-api-with-an-orm-part-1-8fce4d480d59"> <strong class="lb iu"> API </strong> </a>，允许用户向我们发送书籍。API将图书文件保存到磁盘，之后我们可以分析它们的内容。</p><h2 id="1492" class="nv mr it bd ms oa ob dn mw oc od dp na li oe of nc lm og oh ne lq oi oj ng ok bi translated">1.读取文件</h2><p id="b8db" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">我们的第一个目标是读取文本文件。请记住，我们不知道书籍的尺寸；人们可能会给我们发几十亿字节的百科全书！由于这个原因，我们想把这本书分成几部分来读。</p><pre class="kj kk kl km gt nr nq ns nt aw nu bi"><span id="46e9" class="nv mr it nq b gy nw nx l ny nz">""" The inferior non-walrussy way """</span><span id="8e15" class="nv mr it nq b gy ol nx l ny nz">openedBook = open('c:/bookDirectory/lotr_1.txt')<br/>longWordCount:int = 0<br/>while True:<br/>    chunk = openedBook.read(8192)<br/>    if (chunk == ''):<br/>        break<br/>    longWordCount += count_long_words(chunk=chunk)<br/>print(longWordCount)</span></pre><p id="41a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这段代码中，我们以8192字节的块读取一本书。我们将它发送给一个计算超过10个字符的单词的函数。注意，我们必须检查块是否包含数据。如果我们不这样做，那么while循环就不会终止，我们就会被卡住。让我们看看如何使用walrus改进这段代码。</p><pre class="kj kk kl km gt nr nq ns nt aw nu bi"><span id="0cc2" class="nv mr it nq b gy nw nx l ny nz">""" Walrus power! """</span><span id="e365" class="nv mr it nq b gy ol nx l ny nz">openedBook = open(os.path.join(booksFolder, book))<br/>longWordCount: int = 0<br/>while chunk := openedBook.read(8192):<br/>    longWordCount += count_long_words(chunk=chunk)<br/>print(longWordCount)</span></pre><p id="6dea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你会注意到我们的代码现在干净多了。魔术在第五行。我们将打开的书的内容分配给块，并使用它来确定我们是否应该循环。好多了！</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h2 id="b600" class="nv mr it bd ms oa ob dn mw oc od dp na li oe of nc lm og oh ne lq oi oj ng ok bi translated">2.匹配正则表达式模式</h2><p id="c5d2" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">假设我们的客户是一名图书管理员，他想给这本书增加一个难度等级。为了了解难度，我们将分析这篇课文。我们在阅读这本书时使用了以前用过的组块，现在我们将使用RegEx(正则表达式)来查找一些困难的单词，我们将这些单词定义为包含q或x的单词。</p><pre class="kj kk kl km gt nr nq ns nt aw nu bi"><span id="68d2" class="nv mr it nq b gy nw nx l ny nz"># The Old way<br/>openedBook = open(os.path.join(booksFolder, book))<br/>while chunk := openedBook.read(8192):<br/>    match = re.findall("\w*[xXqQ]\w*", chunk)<br/>    if (match == []):<br/>        continue<br/>    print(len(list(set(match))))</span></pre><p id="acf5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码中，我们找到了与第4行定义的特定正则表达式匹配的所有单词(<code class="fe nn no np nq b">\w*[xXqQ]\w*</code>的意思是:找到包含X、X、Q或Q的所有单词)。这个函数默认返回一个空列表，所以我们必须检查我们是否在第5行和第6行找到了什么。最后，我们打印出唯一匹配数的计数。</p><pre class="kj kk kl km gt nr nq ns nt aw nu bi"><span id="bfca" class="nv mr it nq b gy nw nx l ny nz"># Walrus way<br/>openedBook = open(os.path.join(booksFolder, book))<br/>while chunk := openedBook.read(8192):<br/>    if ((match := re.findall(pattern, chunk)) != []):<br/>        print(len(list(set(match))))</span></pre><p id="4798" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们使用walrus操作符时，我们可以执行regex findall并将其结果赋给match变量，如果有匹配的话！尽管性能提高了一点点(3.1毫秒)，但这样做最能提高可读性。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h2 id="8aa3" class="nv mr it bd ms oa ob dn mw oc od dp na li oe of nc lm og oh ne lq oi oj ng ok bi translated">3.列表理解中的共享子表达式</h2><p id="8e86" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">下一步:我们要分析我们在上面的正则表达式部分中发现的所有难词。我们将首先对每个单词进行词干处理，检查词干是否超过8个字符，如果是这样:保留词干。顺便说一下，词干是动词的词根:playing→ play，plays→ play，am，are，is → be等。在本文中，我们不会深入讨论这是如何工作的，只是假设我们有一个名为<code class="fe nn no np nq b">stem_word()</code>的词干函数。我们可以通过三种方式做到这一点:</p><p id="157b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">常规方式<br/> </strong>这种方式使用一个标准进行循环。最大的缺点是由于操作的数量，这是非常慢的。关于可读性:一个简单的操作需要很多行。</p><pre class="kj kk kl km gt nr nq ns nt aw nu bi"><span id="1f62" class="nv mr it nq b gy nw nx l ny nz">my_matches = []<br/>for w in matches:<br/>    s = stem_word(w)<br/>    if (len(s)) &gt;= 10:<br/>        my_matches.append(s)<br/>print('l', my_matches)</span></pre><p id="4592" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">懒惰的方式<br/> </strong>让我们对这一点更深入一点，使用列表理解。优势在于我们将之前需要的5行代码减少到了一行。我们还大大提高了性能；这种方式比传统方式大约快25%。缺点:我们必须调用两次昂贵的stem_word()函数。这是不可接受的低效。</p><pre class="kj kk kl km gt nr nq ns nt aw nu bi"><span id="d4ed" class="nv mr it nq b gy nw nx l ny nz">fmatches = [stem_word(w) for w in matches if len(stem_word(w)) &gt;= 8]</span></pre><p id="41a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了我们钟爱的操作符，我们可以将前面两者结合起来:我们不仅将所有代码放在一行中，通过列表理解来增强可读性和性能，而且我们只需调用一次昂贵的stem_word()函数。</p><pre class="kj kk kl km gt nr nq ns nt aw nu bi"><span id="d222" class="nv mr it nq b gy nw nx l ny nz">smatches = [s for w in matches if len(s := stem_word(w)) &gt;= 8]</span></pre></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h2 id="1fcc" class="nv mr it bd ms oa ob dn mw oc od dp na li oe of nc lm og oh ne lq oi oj ng ok bi translated">4.重用一个计算成本很高的值</h2><p id="063d" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">一旦一个单词被词干化，我们就想把它翻译成荷兰语、德语和西班牙语。假设我们有翻译单词的功能。这里的主要问题是，stem_word()函数非常昂贵，但是我们需要这个函数的结果来将其翻译成四种语言(英语和其他三种)。对于walrus操作符，它看起来像这样:</p><pre class="kj kk kl km gt nr nq ns nt aw nu bi"><span id="0922" class="nv mr it nq b gy nw nx l ny nz">word = 'diving'<br/>translations = [s := stem_word(word), translate_dutch(s), translate_german(s), translate_spanish(s)]</span></pre><p id="ceaf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，我们构建了一个只调用一次stem_word()函数的列表，将它存储到变量<code class="fe nn no np nq b">s</code>中，然后使用该变量调用翻译函数。我们最终得到了一个包含四种语言的翻译词干的数组！</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="fee1" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">5.从字典中检索</h1><p id="7f87" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">假设我们有一本关于当前用户的字典，如下所示。</p><pre class="kj kk kl km gt nr nq ns nt aw nu bi"><span id="ec4a" class="nv mr it nq b gy nw nx l ny nz">userdata = {<br/>    'firstname': 'mike',<br/>    'lastname': 'huls',<br/>    'beaverage': 'coffee'<br/>}</span></pre><p id="25b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们想从字典中检索一个值，所以我们需要提供一个键。我们不确定哪些键存在，这取决于用户提供的数据。最安全、最快捷、最常规的方法是:</p><pre class="kj kk kl km gt nr nq ns nt aw nu bi"><span id="5445" class="nv mr it nq b gy nw nx l ny nz">age = settings.get(key)<br/>if (age):<br/>    print(age)</span></pre><p id="419d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们使用字典对象上的<em class="om"> get </em>方法。如果键不存在，它要么返回键值，要么不返回。让我们看看如何应用walrus操作符。</p><pre class="kj kk kl km gt nr nq ns nt aw nu bi"><span id="6686" class="nv mr it nq b gy nw nx l ny nz">if (age := settings.get(key)):<br/>    print(age)</span></pre><p id="4c5c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，我们可以将设置年龄变量与检查值是否存在的表达式结合起来。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="7e3a" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">把所有的都集合起来→什么时候去海象</h1><p id="5d4a" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">看一下我们所有的例子，我们得出结论，它们可以总结为两种情况:</p><ol class=""><li id="cc32" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu on mb mc md bi translated">如果存在，则分配一个值(1、2和5)</li><li id="3d73" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu on mb mc md bi translated">在iterable (3和4)中重复使用一个计算量很大的值</li></ol><p id="1987" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一类在性能上稍有提高。多亏了walrus操作符，我们可以减少语句的数量，因为我们可以将变量赋值和检查变量是否存在结合起来。然而，主要的改进在于代码的可读性；减少线的数量。</p><p id="dc9a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第二个类提供了改进的可读性和性能。这样做的主要原因是我们使用了列表理解，并且walrus操作符只允许我们调用一次昂贵的函数。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/da9ca727a023c5b1eeb3ee68327c023a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wUe__SWZUniMHJ9l"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">这只北极熊现在知道如何控制他的海象了</p></figure><h1 id="cbaa" class="mq mr it bd ms mt oo mv mw mx op mz na jz oq ka nc kc or kd ne kf os kg ng nh bi translated">结论</h1><p id="f1c5" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">walrus操作符在性能上有一点改进，但主要是为了编写更易读、更简洁的代码。有一些特定的情况是walrus可以解决的，比如在list comprehensions中调用一个昂贵的函数两次，但是这种情况可以通过实现一个传统的循环来轻松避免。尽管如此，当“<em class="om">赋值if exists”</em>(情况1)时，我已经开始使用walrus操作符来增强我的代码的可读性。在我的日常工作中，详细描述重用昂贵的计算值的另一种情况相当少见；我通常会像之前描述的那样避免这些情况。</p><p id="7044" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望我能对这个有争议的运营商有所帮助。请让我知道您是否有任何使用案例，在这些案例中，这个操作符通过留下评论而大放异彩。编码快乐！</p><p id="fe7b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">迈克</p><p id="f7ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">又及:喜欢我正在做的事吗？<a class="ae ky" href="https://mikehuls.medium.com/" rel="noopener">跟我来</a>！</p></div></div>    
</body>
</html>