<html>
<head>
<title>Python — from A to Z (1)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python从A到Z (1)</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/python-from-a-to-z-8a37e0573773?source=collection_archive---------22-----------------------#2021-09-06">https://towardsdatascience.com/python-from-a-to-z-8a37e0573773?source=collection_archive---------22-----------------------#2021-09-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="ad35" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">你应该知道的26个概念——第一部分:从A到J</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/74fbee616180a61ceca86842eb88a4d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*U2xd2FCwYUPACGKt"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片由<a class="ae kv" href="https://unsplash.com/@agk42" rel="noopener ugc nofollow" target="_blank">亚历山大·奈特</a>在Unsplash拍摄</p></figure><p id="cf53" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Python是全球领先的编程语言之一。它被用在从数据科学、机器人、网络开发到游戏和快速原型制作的许多环境中。其简单的语法使Python程序非常容易阅读和编写，确保了快速的学习曲线。此外，Python有“电池包”——多个库(标准库和第三方库)，这将极大地方便程序员的工作。虽然与其他编程语言相比，可以更快地达到基本编程水平，但掌握Python肯定需要一些时间。在这一系列文章中，我们将<strong class="ky ir">详细解释Python的26个特性</strong>，帮助<strong class="ky ir"> </strong>您发现Python拥有的巨大能力范围。</p><h1 id="7865" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">蟒蛇</h1><p id="1f11" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">Anaconda是一个用Python管理包和环境的程序。它广泛用于数据科学领域，因为在安装Anaconda时，默认情况下会安装数据科学中最常用的包。</p><p id="d512" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果需要，Anaconda还允许您通过在anaconda提示符下键入命令<code class="fe mp mq mr ms b">conda install package_name</code>来安装任何包。安装包时，<strong class="ky ir">也可以一次安装多个包</strong>，比如命令<code class="fe mp mq mr ms b">conda install pandas numpy</code>会同时安装pandas和NumPy。Anacondas安装最新版本的软件包；但是，如果您的项目需要以前的版本，您可以通过添加版本号来指定它，如下所示:<code class="fe mp mq mr ms b">conda install pandas=0.22</code>。</p><p id="a080" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过分别使用命令<code class="fe mp mq mr ms b">conda remove package_name</code>和<code class="fe mp mq mr ms b">conda update package_name</code>，Anaconda还可以用于在您的环境中卸载和更新软件包。</p><p id="2979" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">除了包管理器之外，Anaconda还可以用来创建隔离项目的环境。虚拟环境允许在特定项目的隔离目录中本地安装包。当我们需要在不同的Python版本和安装包版本之间切换时，这种方法特别有用。</p><p id="9c7a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">用Anaconda创建虚拟环境非常简单。您只需要在Anaconda提示符下键入<code class="fe mp mq mr ms b">conda create -n environment_name [python==X.X] [list_of_packages]</code>(括号中提供的参数是可选的)。例如，您可以基于Python版轻松创建一个名为<code class="fe mp mq mr ms b">myenv</code>的虚拟环境，如下所示:<code class="fe mp mq mr ms b">conda create -n myenv python==3.6</code>。在这种特殊情况下，我们在创建环境时没有指定要安装的软件包列表。一旦环境被激活，也可以在以后安装附加的软件包。</p><p id="79e7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">创建新环境后，您需要通过键入<code class="fe mp mq mr ms b">conda activate environment_name</code>来激活它。最后，要离开当前的活动环境，在提示符下键入<code class="fe mp mq mr ms b">conda deactivate</code>命令。重要的是要记住，这只是介绍如何将Anaconda用作包和环境管理器。由于篇幅有限，还有许多操作和命令没有在本简介中详细说明。</p></div><div class="ab cl mt mu hu mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="ij ik il im in"><h1 id="6c1a" class="ls lt iq bd lu lv na lx ly lz nb mb mc jw nc jx me jz nd ka mg kc ne kd mi mj bi translated">美味的汤</h1><p id="ee67" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated"><strong class="ky ir">互联网</strong>是<strong class="ky ir">最重要的信息资源</strong>之一；然而，在大多数情况下，很难从网页中获取数据，因为信息是嵌入在HTML代码中的。这不像下载一个CSV文件那么简单。因此，<strong class="ky ir"> Python提供了各种各样的工具来简化从互联网上提取数据的过程</strong>。</p><p id="645d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">美汤</strong>是一个广泛使用的<strong class="ky ir">第三方库，用于从一个HTML文档</strong>中提取任何数据。它允许您轻松地交互和浏览HTML代码，并获得您需要的特定信息(例如页面上的所有图像)。该库提供了不同的方法和属性来从网页中识别和提取所需的信息——使用Python字符串方法将是一项非常复杂和耗时的任务(但却是可能的)。</p><p id="2635" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">创建一个漂亮的汤对象</strong>是任何漂亮的汤项目的第一步。可以用<code class="fe mp mq mr ms b">BeautifulSoup</code>构造函数创建一个漂亮的Soup对象，传递一个字符串(HTML代码)作为参数。在下面的例子中，我们使用请求库获得网页(【https://en.wikipedia.org/wiki/Madrid】)的<strong class="ky ir"> HTML代码</strong>(作为字符串)。然后，我们用<code class="fe mp mq mr ms b">BeautifulSoup</code>解析HTML代码，使其更易于获取信息。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nf ng l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nh"><img src="../Images/b16fa0cdaa9f74b966be12b691fd2351.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*olIZfQRUQvxSXzi7cTxoJw.png"/></div></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="f322" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">提取的HTML代码看起来相当混乱，但是<code class="fe mp mq mr ms b">BeautifulSoup</code>将这些代码转换成易于解析的树形结构。如上所述，<strong class="ky ir"> Beautiful Soup包含了一些从代码中提取信息</strong>的简便方法。例如，您可以通过使用<code class="fe mp mq mr ms b">find_all('a')</code>方法获得文档中的所有锚标记。此外，您还可以通过在查询中添加关键字参数<code class="fe mp mq mr ms b">id</code>或<code class="fe mp mq mr ms b">class_</code>来根据ID或类名查找HTML元素。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="ae84" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以使用更多的函数和属性从HTML文档中提取信息(在文档中有详细的解释)。</p><div class="ni nj gp gr nk nl"><a href="https://beautiful-soup-4.readthedocs.io/en/latest/" rel="noopener  ugc nofollow" target="_blank"><div class="nm ab fo"><div class="nn ab no cl cj np"><h2 class="bd ir gy z fp nq fr fs nr fu fw ip bi translated">美丽的汤文档-美丽的汤4.4.0文档</h2><div class="ns l"><h3 class="bd b gy z fp nq fr fs nr fu fw dk translated">美汤4是通过PyPi发布的，如果不能用系统打包器安装，可以安装…</h3></div><div class="nt l"><p class="bd b dl z fp nq fr fs nr fu fw dk translated">美丽的汤4.readthedocs.io</p></div></div><div class="nu l"><div class="nv l nw nx ny nu nz kp nl"/></div></div></a></div><p id="1fcc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">需要指出的是，为了从代码中提取特定的信息，您总是可以使用浏览器的开发工具<strong class="ky ir">来交互式地浏览HTML代码并找到信息所在的位置，然后您可以编写最佳的漂亮的Soup查询来检索这个特定的信息。</strong></p></div><div class="ab cl mt mu hu mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="ij ik il im in"><h1 id="c7c8" class="ls lt iq bd lu lv na lx ly lz nb mb mc jw nc jx me jz nd ka mg kc ne kd mi mj bi translated"><strong class="ak">类</strong></h1><p id="6822" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated"><strong class="ky ir">面向对象编程</strong>允许将变量和函数组合成一种数据类型，称为<strong class="ky ir">类</strong>。对于大型程序，<strong class="ky ir"> OOP给你的代码增加了组织性</strong>，把你的程序分解成更小的部分，更容易理解和调试。</p><p id="6454" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Python中的<strong class="ky ir">类是创建对象</strong>的蓝图，由方法和属性组成。要定义一个类，您将使用<code class="fe mp mq mr ms b">class</code>关键字，后跟类名(使用CapWords约定)。下面的代码定义了由两个属性和一个方法组成的<code class="fe mp mq mr ms b">Circle</code>类。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/8d6360cd620a7d655dc1f387cc1b2207.png" data-original-src="https://miro.medium.com/v2/resize:fit:1210/format:webp/1*wlmP_VyS0oOZdx47V9FMug.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">班级圈(图片由作者创作)</p></figure><p id="78c5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">属性描述了对象</strong>的特征(在本例中是颜色和半径)，并在<code class="fe mp mq mr ms b">__init__</code>函数中定义。该函数放在类的开头，在类启动时自动执行。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="457b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">方法是一个类可以采取的动作</strong>(例如计算圆的面积)。它们与函数非常相似(都使用<code class="fe mp mq mr ms b">def</code>关键字)，不同之处在于<strong class="ky ir">方法是在类</strong>内部定义的，而不是在类外部定义的。</p><p id="3f81" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">定义了类之后，您可以<strong class="ky ir">创建一个对象</strong>。创建对象的过程称为<strong class="ky ir">实例化</strong>。在这种情况下，对象将是一个特定的圆，例如，一个半径为5的红色圆。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nf ng l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/e595ea4c1eaa79a0bd9f3a41f7f29e05.png" data-original-src="https://miro.medium.com/v2/resize:fit:858/format:webp/1*8Lbu70ifCnqmHyHDHyzQPA.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">不同的圆形对象(图片由作者创建)</p></figure><p id="efaf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">随后，我们可以再次使用<code class="fe mp mq mr ms b">Circle</code>类来创建该类的更多实例。所有对象都有相同数量的属性和方法，基本上是因为它们来自同一个蓝图——<code class="fe mp mq mr ms b">Circle</code>类。</p><p id="ce2f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦<code class="fe mp mq mr ms b">red_circle</code>对象被创建，你可以使用点符号访问它的<strong class="ky ir">属性</strong>。同样使用点符号，您可以调用一个类的<strong class="ky ir">方法</strong>，但是在这种情况下，您必须在括号内指定输入参数。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nf ng l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/c0cb3ec5cd9700d52ae0d8ddd4edfba8.png" data-original-src="https://miro.medium.com/v2/resize:fit:222/format:webp/1*klm6fKJ22Y1iCVJPWm2B-Q.png"/></div></figure></div><div class="ab cl mt mu hu mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="ij ik il im in"><h1 id="c76c" class="ls lt iq bd lu lv na lx ly lz nb mb mc jw nc jx me jz nd ka mg kc ne kd mi mj bi translated"/><p id="8213" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">一个<code class="fe mp mq mr ms b">defaultdict</code>工作起来非常像一个Python <strong class="ky ir">字典</strong>，意味着两个类共享方法和操作。<code class="fe mp mq mr ms b">defaultdict</code>功能在模块<code class="fe mp mq mr ms b">collections</code>中定义。这个模块是<strong class="ky ir"> Python标准库</strong>的一部分，意味着不需要额外安装。要访问该功能，我们必须在程序的开头包含<code class="fe mp mq mr ms b">from collections import defaultdict</code>。</p><p id="f70d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<strong class="ky ir">字典</strong>中，当我们试图访问一个尚未定义的键(不存在的键)时，会引发<code class="fe mp mq mr ms b">KeyError</code>异常。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nf ng l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi od"><img src="../Images/378b8bbc1a8385308ec861b9b749b184.png" data-original-src="https://miro.medium.com/v2/resize:fit:366/format:webp/1*FbQt_6dgq1IeNExoHXIM9g.png"/></div></figure><p id="0df5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，当使用<code class="fe mp mq mr ms b">defaultdict</code>时，将创建一个新的键(使用提供给<code class="fe mp mq mr ms b">defaultdict</code>构造函数的参数),而不会引发任何异常。该参数必须是一个可调用的对象或无。</p><p id="7f50" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在下面的代码中，当试图访问一个不存在的键时，调用函数<code class="fe mp mq mr ms b">int</code>。该函数返回的值，在本例中为0，将被分配给丢失的键。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nf ng l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/9164a40144237136311284abb12e7013.png" data-original-src="https://miro.medium.com/v2/resize:fit:820/format:webp/1*WSkOgqE_Hm9BuusODwUdKw.png"/></div></figure><p id="7a68" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">提供给<code class="fe mp mq mr ms b">defautdict</code>构造函数的参数也可以是用户定义的函数(在本例中是lambda函数)，如下所示。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nf ng l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi of"><img src="../Images/6fc480bcba3ed133bd812e0b525e1487.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ECFOR6CXgmAo66tnVVai9Q.png"/></div></div></figure></div><div class="ab cl mt mu hu mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="ij ik il im in"><h1 id="14b7" class="ls lt iq bd lu lv na lx ly lz nb mb mc jw nc jx me jz nd ka mg kc ne kd mi mj bi translated">编码(字符)</h1><p id="a300" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">一个<strong class="ky ir">字符编码</strong>提供了计算机中的<strong class="ky ir">字节</strong>(原始零和一)和<strong class="ky ir">真实字符</strong>之间的映射(翻译)。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi og"><img src="../Images/0b109d48decef3ffcdb3abd1a85e4d9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CgTdGE_gcY0YEECATWjolw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">编码(图片由作者创建)</p></figure><p id="7791" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">多年来，编程语言使用<strong class="ky ir"> ASCII </strong>作为字符的内部表示。本标准包括<strong class="ky ir"> 128个字符</strong>使用7位信息。它涵盖所有英文字符(它最初是为美国的电子通信开发的)；但是，它未能涵盖出现在其他世界语言中的字符，如带有口音的字符。由于这个原因，在过去的几年中，出现了向Unicode编码的转变。该标准包含更广泛的字符和符号，根据编码类型使用8、16或32位信息，与ASCII相比自然需要更多的空间。</p><p id="8c61" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">除了ASCII和Unicode，Python还支持多种编码。Python中可用编码的完整列表可以在<code class="fe mp mq mr ms b">codecs</code>模块的Python标准文档中查阅。</p><div class="ni nj gp gr nk nl"><a href="https://docs.python.org/3/library/codecs.html#standard-encodings" rel="noopener  ugc nofollow" target="_blank"><div class="nm ab fo"><div class="nn ab no cl cj np"><h2 class="bd ir gy z fp nq fr fs nr fu fw ip bi translated">编解码器-编解码器注册表和基类- Python 3.9.7文档</h2><div class="ns l"><h3 class="bd b gy z fp nq fr fs nr fu fw dk translated">源代码:Lib/codecs.py这个模块定义了标准Python编解码器(编码器和解码器)的基类，并且…</h3></div><div class="nt l"><p class="bd b dl z fp nq fr fs nr fu fw dk translated">docs.python.org</p></div></div></div></a></div><p id="d17f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在处理文本数据时，编码是必须考虑的因素。重要的是要记住，Python用于需要编码的操作(比如读取文件)的默认编码是UTF-8。<strong class="ky ir">处理文件时，由于编码不一致而导致字符显示不正确或异常是一个常见问题。</strong>因此，在读取文件时，您需要通过在<code class="fe mp mq mr ms b">open</code>函数中包含参数<code class="fe mp mq mr ms b">encoding</code>来指定所使用的编码(当它与默认编码不匹配时)。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nf ng l"/></div></figure></div><div class="ab cl mt mu hu mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="ij ik il im in"><h1 id="0553" class="ls lt iq bd lu lv na lx ly lz nb mb mc jw nc jx me jz nd ka mg kc ne kd mi mj bi translated"><strong class="ak"> Findall (re模块)</strong></h1><p id="de88" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">使用正则表达式通常可以简化文本处理。正则表达式是用于匹配字符串中字符组合的模式。它们在测试操作中非常有用，这就是为什么Python标准库有一个专门处理正则表达式模式的模块——re模块。这个模块提供了各种各样的函数，在处理文本数据时您肯定会遇到的一个函数是<code class="fe mp mq mr ms b">findall</code>函数。</p><p id="5525" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mp mq mr ms b">re.findall(pattern, string)</code>函数从字符串(<code class="fe mp mq mr ms b">string</code>)中提取正则表达式(<code class="fe mp mq mr ms b">pattern</code>)的所有非重叠匹配。函数的第一个参数是一个正则表达式，而第二个参数是我们要搜索的字符串。该函数返回一个字符串列表，其中每个元素都是非重叠匹配的。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oh"><img src="../Images/968af9c81911ff8cfd46636d6e85ac9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ogMj6_6pvHdYIbsYsFPi1g.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Findall函数(图片由作者创建)</p></figure><p id="8ed6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面的代码从字符串中提取所有数字(包括十进制数字)。我们不打算深入讨论正则表达式如何工作的细节。为此，我们需要再写一篇文章😛。你会盲目地相信这个模式可以提取数字。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nf ng l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/ae5c642347d44a76c90dd4560d6bf17d.png" data-original-src="https://miro.medium.com/v2/resize:fit:356/format:webp/1*eW1q4l8V9aVMT74XX2I_XA.png"/></div></figure><p id="9d7a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如上所示，<code class="fe mp mq mr ms b">findall</code>函数返回一个字符串列表，包含所有不重叠的匹配。提取数据后，我们可以很容易地使用list comprehensions将列表中的每个字符串转换为float。</p><p id="a0fe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这种情况下，使用的模式非常简单；然而，正则表达式可以变得更加复杂。它们可以方便地从文档中提取网页、电子邮件、密码或电话号码，是从文本数据中获取信息的一个非常强大的工具。</p></div><div class="ab cl mt mu hu mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="ij ik il im in"><h1 id="d46b" class="ls lt iq bd lu lv na lx ly lz nb mb mc jw nc jx me jz nd ka mg kc ne kd mi mj bi translated">Get(字典法)</h1><p id="b540" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在Python 中使用字典时，<code class="fe mp mq mr ms b">KeyError</code>异常是<strong class="ky ir">常见的异常。当用户试图访问一个不在字典中的<code class="fe mp mq mr ms b">key</code>时，就会引发这个异常。</strong></p><p id="5c63" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在下面的代码示例中，当试图访问字典中不存在的<code class="fe mp mq mr ms b">key</code>时，会引发一个<code class="fe mp mq mr ms b">KeyError</code>异常。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="a5c9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了处理这个问题，除了使用<code class="fe mp mq mr ms b">try except</code>模块，一个常见的解决方案是采用<code class="fe mp mq mr ms b">get</code>方法。该方法返回在指定的<code class="fe mp mq mr ms b">key</code>找到的值(如果<code class="fe mp mq mr ms b">key</code>可用)。相反，如果<code class="fe mp mq mr ms b">key</code>在字典中不可用，<code class="fe mp mq mr ms b">get</code>方法返回<code class="fe mp mq mr ms b">None</code>或一个自定义值，从不引发异常。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nf ng l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/101672cc49e5beac4944c70033576c10.png" data-original-src="https://miro.medium.com/v2/resize:fit:302/format:webp/1*ADzrPn2C04wYRHI9vaXN6g.png"/></div></figure><p id="e697" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">永远记住，为了避免使用字典时出现<code class="fe mp mq mr ms b">KeyError</code>异常，您可以从直接访问字典的<code class="fe mp mq mr ms b">key</code>切换到使用<code class="fe mp mq mr ms b">get</code>方法。这将防止在代码执行过程中出现意外异常。</p></div><div class="ab cl mt mu hu mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="ij ik il im in"><h1 id="7c84" class="ls lt iq bd lu lv na lx ly lz nb mb mc jw nc jx me jz nd ka mg kc ne kd mi mj bi translated">帮助</h1><p id="aaa7" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在Python中工作时，记住每个函数的语法有时是一个挑战，尤其是那些你很少使用的函数。Python <code class="fe mp mq mr ms b">help</code>函数提供了对特定函数文档的访问，显示了该函数的功能及其语法。</p><p id="b0ab" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以下代码总结了<code class="fe mp mq mr ms b">hasattr</code>功能。如下所示，<code class="fe mp mq mr ms b">help</code>函数打印关于该函数如何工作及其定义的基本信息。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nf ng l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/50bde1bbc74861996700bfe682fa5016.png" data-original-src="https://miro.medium.com/v2/resize:fit:884/format:webp/1*yW6UpA0FK-OrnppLdmlwRA.png"/></div></figure><p id="b929" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">除了<code class="fe mp mq mr ms b">help</code>功能之外，Python还提供了更详细的文档，可以在线查阅。</p></div><div class="ab cl mt mu hu mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="ij ik il im in"><h1 id="f650" class="ls lt iq bd lu lv na lx ly lz nb mb mc jw nc jx me jz nd ka mg kc ne kd mi mj bi translated">索引错误</h1><p id="446c" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">Python中的有序容器(例如列表或元组)通过位置(索引)来标识它们的元素。<strong class="ky ir"> Python遵循一种称为从零开始的索引</strong>的约定，这意味着有序容器中的第一个元素位于索引0处。</p><p id="49fd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要访问列表中的元素，可以使用一个<strong class="ky ir">索引操作符</strong>，它由一对方括号(<code class="fe mp mq mr ms b">[]</code>)和一个<strong class="ky ir">索引</strong>(从0开始)组成，指定要检索的元素。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ol"><img src="../Images/9077e057f9d78c44871d1f8da22f10a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lePvk7Eh-mkbxRfsbMFADg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">访问列表元素(由作者创建的图像)</p></figure><p id="6905" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您试图访问列表中超出可用元素范围的项目，您将得到一个<code class="fe mp mq mr ms b">IndexError</code>异常，如下所示。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="88fd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">出现这种错误是很常见的，尤其是如果您刚刚开始学习Python的话。如果您来自R，错误的索引是您将面临的常见错误，因为R与Python不同，它使用基于一的索引。</p></div><div class="ab cl mt mu hu mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="ij ik il im in"><h1 id="4c2b" class="ls lt iq bd lu lv na lx ly lz nb mb mc jw nc jx me jz nd ka mg kc ne kd mi mj bi translated">Join(字符串方法)</h1><p id="abf3" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated"><code class="fe mp mq mr ms b">join</code>方法用于<strong class="ky ir">将包含在iterable中的字符串连接成一个字符串</strong>。该方法的语法如下所示，其中<code class="fe mp mq mr ms b">string</code>表示插入iterable的每个元素之间的<strong class="ky ir">分隔符</strong>，而<code class="fe mp mq mr ms b">iterable</code>是我们想要连接的字符串的<strong class="ky ir">序列(必需参数)。该序列可以是例如列表、元组、字典、集合或生成器。</strong></p><blockquote class="om"><p id="8ded" class="on oo iq bd op oq or os ot ou ov lr dk translated">string.join(iterable)</p></blockquote><p id="1dda" class="pw-post-body-paragraph kw kx iq ky b kz ow jr lb lc ox ju le lf oy lh li lj oz ll lm ln pa lp lq lr ij bi translated">下面的代码块展示了我们如何使用Python中的<code class="fe mp mq mr ms b">join</code>方法来连接字符串。正如您所看到的，<code class="fe mp mq mr ms b">join</code>方法<strong class="ky ir">返回一个字符串，该字符串由iterable </strong>中的字符串串联而成(在本例中是一个列表)。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nf ng l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pb"><img src="../Images/dc088e6ca47538acc154dab2fc17cc62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1224/format:webp/1*giRh2t26y9ImYm4ERwZ62g.png"/></div></figure><p id="6030" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">iterable的所有元素都应该是字符串类型的。如果没有，将引发一个<code class="fe mp mq mr ms b">TypeError</code>异常，如下所示。要连接一个包含数字的迭代器，我们应该先用<code class="fe mp mq mr ms b">str()</code>函数将它们转换成字符串，因为Python不做隐式字符串转换。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nf ng l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pc"><img src="../Images/87669eef6aa1c94d87cf760960639fa9.png" data-original-src="https://miro.medium.com/v2/resize:fit:504/format:webp/1*2hXBOdJRkz4p11PmGxlF-Q.png"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nf ng l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pd"><img src="../Images/292f301c9096de57c3de751d82f5c5c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:188/format:webp/1*xRDLnfQxP-n4PJG5TsWkzA.png"/></div></figure><p id="c3ac" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">重要的是要记住<code class="fe mp mq mr ms b">join</code>是一个<strong class="ky ir">字符串方法</strong>，而不是一个列表方法，因为<strong class="ky ir">我们称它为字符串</strong>而不是可迭代的(列表)。然而，字符串序列(iterable)是<code class="fe mp mq mr ms b">join</code>方法的主要参数。</p><p id="bf8c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可能知道，我们还可以使用<code class="fe mp mq mr ms b">+</code>操作符连接字符串；但是，这不是连接大量字符串的有效方式。主要是因为<code class="fe mp mq mr ms b">+</code>操作符需要在每次使用时创建一个新的对象，导致性能下降。如果您想更多地了解为什么<code class="fe mp mq mr ms b">join</code>方法优于<code class="fe mp mq mr ms b">+</code>操作符，请阅读下面的文章💚</p><div class="ni nj gp gr nk nl"><a rel="noopener follow" target="_blank" href="/do-not-use-to-join-strings-in-python-f89908307273"><div class="nm ab fo"><div class="nn ab no cl cj np"><h2 class="bd ir gy z fp nq fr fs nr fu fw ip bi translated">不要在Python中使用“+”来连接字符串</h2><div class="ns l"><h3 class="bd b gy z fp nq fr fs nr fu fw dk translated">使用“+”和join()方法在Python中连接字符串的方法比较。</h3></div><div class="nt l"><p class="bd b dl z fp nq fr fs nr fu fw dk translated">towardsdatascience.com</p></div></div><div class="nu l"><div class="pe l nw nx ny nu nz kp nl"/></div></div></a></div><p id="2015" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">字符串对象有更多的方法。要了解有关字符串方法的更多信息，可以参考官方Python文档，网址为:</p><div class="ni nj gp gr nk nl"><a href="https://docs.python.org/3/library/stdtypes.html#str.join" rel="noopener  ugc nofollow" target="_blank"><div class="nm ab fo"><div class="nn ab no cl cj np"><h2 class="bd ir gy z fp nq fr fs nr fu fw ip bi translated">内置类型- Python 3.9.6文档</h2><div class="ns l"><h3 class="bd b gy z fp nq fr fs nr fu fw dk translated">以下部分描述了解释器内置的标准类型。主要的内置类型…</h3></div><div class="nt l"><p class="bd b dl z fp nq fr fs nr fu fw dk translated">docs.python.org</p></div></div></div></a></div></div><div class="ab cl mt mu hu mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="ij ik il im in"><p id="9b8b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个简短的介绍展示了使用Python编程时可能会遇到的一些主要功能和问题。它的可读性、一致性和丰富的库使Python成为世界上最重要的编程语言之一，是任何数据科学家都应该拥有的基本资产。</p><p id="2f74" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">阿曼达·伊格莱西亚斯</p></div></div>    
</body>
</html>