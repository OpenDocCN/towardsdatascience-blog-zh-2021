<html>
<head>
<title>The “+=” May Not Do What You Expected In Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">“+=”可能不会像您在Python中期望的那样</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/the-may-not-do-what-you-expected-in-python-d46991992974?source=collection_archive---------14-----------------------#2021-07-11">https://towardsdatascience.com/the-may-not-do-what-you-expected-in-python-d46991992974?source=collection_archive---------14-----------------------#2021-07-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/761d91d38aa5b8473f50f22e9da44174.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aUaxP_F625YRZsdfXnmm3A.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">图片来自<a class="ae jg" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=2789112" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>的<a class="ae jg" href="https://pixabay.com/users/stevepb-282134/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=2789112" rel="noopener ugc nofollow" target="_blank">Steve buiss NNE</a></p></figure><div class=""/><div class=""><h2 id="0698" class="pw-subtitle-paragraph kg ji jj bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dk translated">讨论和比较3种不同的“添加”功能</h2></div><p id="26de" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你以为<code class="fe lu lv lw lx b">a = a + b</code>和Python里的<code class="fe lu lv lw lx b">a += b</code>总是一样的吗？答案是否定的。像大多数其他Python开发者一样，我以前也在想同样的事情，直到我意识到Python中有3个不同的“加法”函数。</p><ul class=""><li id="af63" class="ly lz jj la b lb lc le lf lh ma ll mb lp mc lt md me mf mg bi translated"><code class="fe lu lv lw lx b">__add__()</code></li><li id="7727" class="ly lz jj la b lb mh le mi lh mj ll mk lp ml lt md me mf mg bi translated"><code class="fe lu lv lw lx b">__radd__()</code></li><li id="d899" class="ly lz jj la b lb mh le mi lh mj ll mk lp ml lt md me mf mg bi translated"><code class="fe lu lv lw lx b">__iadd__()</code></li></ul><p id="af89" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">不认识他们？别担心。如果您知道双下划线包围的函数是“神奇”函数，您应该已经意识到这些函数应该以更直观的方式调用。确切的说，当我们有<code class="fe lu lv lw lx b">a + b</code>的时候，函数<code class="fe lu lv lw lx b">a.__add__(b)</code>在幕后被调用。</p><p id="2e22" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这篇文章中，我将介绍这三个函数以及它们之间的区别。更重要的是，我会告诉你在哪个场景中<code class="fe lu lv lw lx b">a = a + b</code>会和<code class="fe lu lv lw lx b">a += b</code>不一样，以及为什么。</p><h1 id="95d6" class="mm mn jj bd mo mp mq mr ms mt mu mv mw kp mx kq my ks mz kt na kv nb kw nc nd bi translated">1.调用__add__时。</h1><figure class="ne nf ng nh gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/145dc154f981b99f00ec07d88acb3abd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0h275zvCaFQi4l0jjFhn7w.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">图片来自<a class="ae jg" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=3456736" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>的<a class="ae jg" href="https://pixabay.com/users/ulleo-1834854/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=3456736" rel="noopener ugc nofollow" target="_blank"> Ulrike Leone </a></p></figure><p id="cfa7" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">正如简介中提到的，每当我们进行求和计算时，都会调用函数<code class="fe lu lv lw lx b">__add__()</code>。因此，我们可以说下面两个表达式总是相同的。</p><pre class="ne nf ng nh gt ni lx nj nk aw nl bi"><span id="f3c4" class="nm mn jj lx b gy nn no l np nq">a + b<br/>a.__add__(b)</span></pre><figure class="ne nf ng nh gt iv gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/1e5d69f9034c034177aa70d369a20766.png" data-original-src="https://miro.medium.com/v2/resize:fit:570/format:webp/1*UaGAXyzMA69OVs-Il_UnwA.png"/></div></figure><p id="1a72" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以通过定义一个自定义类来验证这一点。姑且称之为“X”类。然后，类“X”将接受一个数字进行初始化。同样，我们需要定义神奇的函数<code class="fe lu lv lw lx b">__add__()</code>。为了方便起见，还定义了<code class="fe lu lv lw lx b">__repr__()</code>函数，以便我们可以轻松地打印结果。</p><pre class="ne nf ng nh gt ni lx nj nk aw nl bi"><span id="16d3" class="nm mn jj lx b gy nn no l np nq">class X:<br/>    def __init__(self, num):<br/>        self.num = num</span><span id="a99a" class="nm mn jj lx b gy ns no l np nq">def __add__(self, other_X):<br/>        print('I am called!')<br/>        return X(self.num + other_X.num)</span><span id="9cc0" class="nm mn jj lx b gy ns no l np nq">def __repr__(self):<br/>        return str(self.num)</span></pre><p id="b6af" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，让我们从这个类“X”中实例化两个数字，并执行求和计算。</p><pre class="ne nf ng nh gt ni lx nj nk aw nl bi"><span id="695f" class="nm mn jj lx b gy nn no l np nq">a = X(1)<br/>b = X(2)</span><span id="e4f9" class="nm mn jj lx b gy ns no l np nq">print('a + b =', a + b)</span></pre><figure class="ne nf ng nh gt iv gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/7f6ba0a35e32b483d2c65efe7745adff.png" data-original-src="https://miro.medium.com/v2/resize:fit:828/format:webp/1*jf8oLTkk7DXiZFVTWL0ziA.png"/></div></figure><p id="6dd3" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在<code class="fe lu lv lw lx b">__add__()</code>函数中，我添加了一个打印函数来打印一些东西。然后，当我们运行<code class="fe lu lv lw lx b">a + b</code>时，它被打印出来。因此，这证明了我们已经成功地为这个定制类重写了<code class="fe lu lv lw lx b">+</code>操作符。</p><h1 id="2573" class="mm mn jj bd mo mp mq mr ms mt mu mv mw kp mx kq my ks mz kt na kv nb kw nc nd bi translated">2.__radd__和__add__有什么不同？</h1><figure class="ne nf ng nh gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/1ca2ecb1da969a5a293172e32f46259d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pjvGz09S1J8HSJwmVgnaqA.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">图片来自<a class="ae jg" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=2250932" rel="noopener ugc nofollow" target="_blank"> Pixabay </a></p></figure><p id="d632" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个功能有点特别。它将颠倒两个组件的顺序，然后将它们相加。嗯，我们都知道<code class="fe lu lv lw lx b">a + b = b + a</code>如果两者都是标量。因此，用除法比用加法来演示要容易得多。</p><p id="3db7" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">好在有两个对应的功能<code class="fe lu lv lw lx b">__truediv__()</code>和<code class="fe lu lv lw lx b">__rturediv()</code>。参见下面的例子。</p><pre class="ne nf ng nh gt ni lx nj nk aw nl bi"><span id="404c" class="nm mn jj lx b gy nn no l np nq">x = 10<br/>y = 2</span><span id="3b2d" class="nm mn jj lx b gy ns no l np nq">x.__truediv__(y)<br/>x.__rtruediv__(y)</span></pre><figure class="ne nf ng nh gt iv gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/c4dba789a28ebd6b3a68955c3a856834.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*E0Vr0fdcJgkPzjHbU3ClSg.png"/></div></figure><p id="4c31" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，</p><ul class=""><li id="df42" class="ly lz jj la b lb lc le lf lh ma ll mb lp mc lt md me mf mg bi translated"><code class="fe lu lv lw lx b">x.__truediv__(y) = x/y</code></li><li id="dec1" class="ly lz jj la b lb mh le mi lh mj ll mk lp ml lt md me mf mg bi translated"><code class="fe lu lv lw lx b">x.__rtruediv__(y) = y/x</code></li></ul><p id="807d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">同样的，</p><ul class=""><li id="766d" class="ly lz jj la b lb lc le lf lh ma ll mb lp mc lt md me mf mg bi translated"><code class="fe lu lv lw lx b">x.__add__(y) = x + y</code></li><li id="f46b" class="ly lz jj la b lb mh le mi lh mj ll mk lp ml lt md me mf mg bi translated"><code class="fe lu lv lw lx b">x.__radd__(y) = y + x</code></li></ul><p id="b4e7" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你想知道有多少其他的运算符或计算具有这些特性，这里有一个官方文档的链接。</p><div class="is it gp gr iu nv"><a href="https://docs.python.org/3.9/reference/datamodel.html?highlight=__iadd__#emulating-numeric-types" rel="noopener  ugc nofollow" target="_blank"><div class="nw ab fo"><div class="nx ab ny cl cj nz"><h2 class="bd jk gy z fp oa fr fs ob fu fw ji bi translated">3.数据模型- Python 3.9.6文档</h2><div class="oc l"><h3 class="bd b gy z fp oa fr fs ob fu fw dk translated">对象是Python对数据的抽象。Python程序中的所有数据都由对象或关系来表示…</h3></div><div class="od l"><p class="bd b dl z fp oa fr fs ob fu fw dk translated">docs.python.org</p></div></div></div></a></div><h1 id="d069" class="mm mn jj bd mo mp mq mr ms mt mu mv mw kp mx kq my ks mz kt na kv nb kw nc nd bi translated">3.调用__radd__时。</h1><figure class="ne nf ng nh gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/0744235017c0187c8f8ff73e6967b855.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V6ara3USdBW7F3wLJFAO7g.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">图片由<a class="ae jg" href="https://pixabay.com/users/techphotogal-1739491/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=1080088" rel="noopener ugc nofollow" target="_blank"> Circ OD </a>发自<a class="ae jg" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=1080088" rel="noopener ugc nofollow" target="_blank"> Pixabay </a></p></figure><p id="e44e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在我们明白了，表达式<code class="fe lu lv lw lx b">a.__radd__(b)</code>等同于<code class="fe lu lv lw lx b">b + a</code>。但是等等，当我们有表达式<code class="fe lu lv lw lx b">b + a</code>时，它肯定会运行<code class="fe lu lv lw lx b">b.__add__(a)</code>而不是前者。那么，什么时候会调用函数<code class="fe lu lv lw lx b">__radd__()</code>？</p><p id="0035" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">还记得我们已经定义了一个定制的类“X ”,我们必须实现<code class="fe lu lv lw lx b">__add__()</code>函数，以使运算符“+”能够在“X”实例之间使用吗？这意味着，有时我们可能在课堂上没有它。</p><p id="f94c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们定义另一个类“Y ”,使它与“X”相同，但不覆盖函数<code class="fe lu lv lw lx b">__add__()</code>。</p><pre class="ne nf ng nh gt ni lx nj nk aw nl bi"><span id="930d" class="nm mn jj lx b gy nn no l np nq">class Y:<br/>    def __init__(self, num):<br/>        self.num = num</span><span id="badc" class="nm mn jj lx b gy ns no l np nq">def __repr__(self):<br/>        return str(self.num)</span></pre><p id="f94a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，我们再次定义<code class="fe lu lv lw lx b">a</code>和<code class="fe lu lv lw lx b">b</code>，但是分别使用X和Y。然后，我们试着运行<code class="fe lu lv lw lx b">b + a</code>。</p><pre class="ne nf ng nh gt ni lx nj nk aw nl bi"><span id="b868" class="nm mn jj lx b gy nn no l np nq">a = X(1)<br/>b = Y(2)</span><span id="67df" class="nm mn jj lx b gy ns no l np nq">print('b + a =', b + a)</span></pre><figure class="ne nf ng nh gt iv gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/970b8f8f613e740e7a479a16e7d04613.png" data-original-src="https://miro.medium.com/v2/resize:fit:1366/format:webp/1*Na9U2N7gYwSIS2frdhQ-sA.png"/></div></figure><p id="e375" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因为<code class="fe lu lv lw lx b">b</code>是Y的一种类型，但是没有实现<code class="fe lu lv lw lx b">__add__()</code>，所以不存在<code class="fe lu lv lw lx b">b.__add__(a)</code>。</p><p id="db5e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我希望到目前为止你仍然明白。然后，让我们在类X中实现<code class="fe lu lv lw lx b">__radd__()</code>函数，然后再次运行它。</p><p id="eda4" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在类X中，添加以下函数:</p><pre class="ne nf ng nh gt ni lx nj nk aw nl bi"><span id="2423" class="nm mn jj lx b gy nn no l np nq">def __radd__(self, other_num):<br/>        print('Reversed adding!')<br/>        return X(self.num + other_num.num)</span></pre><figure class="ne nf ng nh gt iv gh gi paragraph-image"><div class="gh gi of"><img src="../Images/585881647885b4c33e93b74bb077f2d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:838/format:webp/1*XRjwRfS2TqeKlyXpM8huCA.png"/></div></figure><p id="139f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">是的，你的想法是正确的。当一个对象没有<code class="fe lu lv lw lx b">__add__()</code>但求和计算中的另一个对象实现了<code class="fe lu lv lw lx b">__radd__()</code>函数时，该函数将被调用。</p><h1 id="68d4" class="mm mn jj bd mo mp mq mr ms mt mu mv mw kp mx kq my ks mz kt na kv nb kw nc nd bi translated">4.调用__iadd__时。</h1><figure class="ne nf ng nh gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/47c3c7bea7bc7b6ec28a5a52e60ec54d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uhnwDSh-q3PRdYrGgor0UQ.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">图片来自<a class="ae jg" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=1238598" rel="noopener ugc nofollow" target="_blank"> Pixabay </a></p></figure><p id="b488" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">岸上的回答是，当我们使用<code class="fe lu lv lw lx b">+=</code>操作符时会调用<code class="fe lu lv lw lx b">__iadd__()</code>函数。然而，与<code class="fe lu lv lw lx b">__radd__()</code>函数不同的是，即使我们不实现<code class="fe lu lv lw lx b">__iadd__()</code>函数，运算符“+=”仍然可以工作。如果有功能的话，它将返回到<code class="fe lu lv lw lx b">__add__()</code>功能。</p><p id="2908" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们继续使用第1节中定义的例子。</p><pre class="ne nf ng nh gt ni lx nj nk aw nl bi"><span id="fc94" class="nm mn jj lx b gy nn no l np nq">class X:<br/>    def __init__(self, num):<br/>        self.num = num</span><span id="a72e" class="nm mn jj lx b gy ns no l np nq">def __add__(self, other_X):<br/>        print('I am called!')<br/>        return X(self.num + other_X.num)</span><span id="92c5" class="nm mn jj lx b gy ns no l np nq">def __repr__(self):<br/>        return str(self.num)</span><span id="942d" class="nm mn jj lx b gy ns no l np nq">a = X(1)<br/>b = X(2)</span><span id="c11c" class="nm mn jj lx b gy ns no l np nq">a += b<br/>print('new a =', a)</span></pre><figure class="ne nf ng nh gt iv gh gi paragraph-image"><div class="gh gi og"><img src="../Images/c1c7f42744fa080330b4c18bee7b5547.png" data-original-src="https://miro.medium.com/v2/resize:fit:866/format:webp/1*eEgYjJymm4Ye4ayZ8NUAyQ.png"/></div></figure><p id="5413" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当然，如果我们已经实现了函数<code class="fe lu lv lw lx b">__iadd__()</code>并使用了“+=”操作符，它就会被调用。</p><p id="a999" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们通过实现<code class="fe lu lv lw lx b">__iadd__()</code>函数来证明这一点。</p><pre class="ne nf ng nh gt ni lx nj nk aw nl bi"><span id="8a15" class="nm mn jj lx b gy nn no l np nq">class X:<br/>    def __init__(self, num):<br/>        self.num = num</span><span id="cf4f" class="nm mn jj lx b gy ns no l np nq">def __add__(self, other_X):<br/>        print('I am called!')<br/>        return X(self.num + other_X.num)</span><span id="9b99" class="nm mn jj lx b gy ns no l np nq">def __iadd__(self, other_X):<br/>        print('return myself')<br/>        self.num = self.num + other_X.num<br/>        return self</span><span id="efb7" class="nm mn jj lx b gy ns no l np nq">def __repr__(self):<br/>        return str(self.num)</span></pre><figure class="ne nf ng nh gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oh"><img src="../Images/a2bbd9fe8adfdf09b8e084a50899d3df.png" data-original-src="https://miro.medium.com/v2/resize:fit:812/format:webp/1*h2YzUGeWHueDtbWlG1i0vQ.png"/></div></div></figure><h1 id="659a" class="mm mn jj bd mo mp mq mr ms mt mu mv mw kp mx kq my ks mz kt na kv nb kw nc nd bi translated">5.“a=a+b”和“a+=b”的区别</h1><p id="2fad" class="pw-post-body-paragraph ky kz jj la b lb oi kk ld le oj kn lg lh ok lj lk ll ol ln lo lp om lr ls lt im bi translated">在前面的例子中，您是否注意到了我实现<code class="fe lu lv lw lx b">__iadd__()</code>函数的不同之处？是的，我让它返回<code class="fe lu lv lw lx b">self</code>，而不是像<code class="fe lu lv lw lx b">__add__()</code>那样返回一个新对象。换句话说，在这个操作中没有创建新的对象。</p><p id="cd5d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这也是官方对<code class="fe lu lv lw lx b">__iadd__()</code>的定义。</p><blockquote class="on oo op"><p id="9446" class="ky kz oq la b lb lc kk ld le lf kn lg or li lj lk os lm ln lo ot lq lr ls lt im bi translated"><code class="fe lu lv lw lx b">object.<strong class="la jk">__iadd__</strong></code> ( <em class="jj">自我</em>，<em class="jj">其他</em>)</p><p id="ee94" class="ky kz oq la b lb lc kk ld le lf kn lg or li lj lk os lm ln lo ot lq lr ls lt im bi translated">这些方法应该尝试就地执行操作<strong class="la jk"> <em class="jj">(修改自身)并返回结果。</em> </strong></p></blockquote><p id="3969" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这将在函数<code class="fe lu lv lw lx b">__add__()</code>和<code class="fe lu lv lw lx b">__iadd__()</code>之间产生差异，从而在某些情况下使运算符“+”和“+=”不同。</p><p id="6b77" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">不要忘记，我们可以在任何Python列表上使用“+”操作符，所以让我们在列表上进行实验。</p><p id="4a78" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">首先，让我们定义两个简单的列表<code class="fe lu lv lw lx b">a</code>和<code class="fe lu lv lw lx b">b</code>。</p><pre class="ne nf ng nh gt ni lx nj nk aw nl bi"><span id="af90" class="nm mn jj lx b gy nn no l np nq">a = [1, 2]<br/>b = [3, 4]</span></pre><p id="35b6" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后，让我们定义另一个变量<code class="fe lu lv lw lx b">c</code>，给它赋值<code class="fe lu lv lw lx b">a</code>。</p><pre class="ne nf ng nh gt ni lx nj nk aw nl bi"><span id="a042" class="nm mn jj lx b gy nn no l np nq">c = a</span></pre><p id="3a90" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">再简单不过了，对吧？:)</p><p id="9572" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，让我们添加<code class="fe lu lv lw lx b">a</code>和<code class="fe lu lv lw lx b">b</code>，并将其赋回<code class="fe lu lv lw lx b">a</code>。</p><pre class="ne nf ng nh gt ni lx nj nk aw nl bi"><span id="4cf2" class="nm mn jj lx b gy nn no l np nq">a = a + b<br/>print("a =", a)<br/>print("c =", c)</span></pre><figure class="ne nf ng nh gt iv gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/1fcf7037e94368a3eac58be173fdc696.png" data-original-src="https://miro.medium.com/v2/resize:fit:528/format:webp/1*kv46570wDuBUvbaz9mVPHQ.png"/></div></figure><p id="4148" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">结果显示<code class="fe lu lv lw lx b">a</code>和<code class="fe lu lv lw lx b">c</code>不同。列表<code class="fe lu lv lw lx b">c</code>仍然等于“原始”<code class="fe lu lv lw lx b">a</code>。</p><p id="6973" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，让我们试试“+=”操作符。</p><pre class="ne nf ng nh gt ni lx nj nk aw nl bi"><span id="06b0" class="nm mn jj lx b gy nn no l np nq">a = [1, 2]<br/>b = [3, 4]<br/>c = a</span><span id="94cb" class="nm mn jj lx b gy ns no l np nq">a += b<br/>print("a =", a)<br/>print("c =", c)</span></pre><figure class="ne nf ng nh gt iv gh gi paragraph-image"><div class="gh gi ov"><img src="../Images/64eb5ee8b5b097a16dfe899bf8d52999.png" data-original-src="https://miro.medium.com/v2/resize:fit:518/format:webp/1*yuVuL3FuPuD44QxuJzNZ6Q.png"/></div></figure><p id="1c47" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这一次，因为<code class="fe lu lv lw lx b">a</code>被修改，所以对象<code class="fe lu lv lw lx b">c</code>被改变！</p><p id="bd99" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这正是因为功能<code class="fe lu lv lw lx b">__iadd__()</code>的特性。它将就地修改对象，而不是新建一个对象，这将导致对象<code class="fe lu lv lw lx b">c</code>的修改。</p><p id="551d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">事实上，只有<strong class="la jk">可变</strong>对象会受到这个“特性”的影响。如果我们试图求和的对象是不可变的，那么“+”和“+=”可以认为是相同的。</p><p id="4666" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以在元组上进行实验，因为Python元组被认为是不可变的对象。</p><pre class="ne nf ng nh gt ni lx nj nk aw nl bi"><span id="17f6" class="nm mn jj lx b gy nn no l np nq">a = (1, 2)<br/>b = (3, 4)<br/>c = a</span><span id="d3c7" class="nm mn jj lx b gy ns no l np nq">a += b<br/>print("a", a)<br/>print("c", c)</span></pre><figure class="ne nf ng nh gt iv gh gi paragraph-image"><div class="gh gi ow"><img src="../Images/e56f0fd595f2b0093352f3f7bb4ec577.png" data-original-src="https://miro.medium.com/v2/resize:fit:526/format:webp/1*3HYUKCR2y31yXAVDPJeNQA.png"/></div></figure><p id="81fe" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这一次，对象<code class="fe lu lv lw lx b">c</code>没有改变。</p><p id="cd27" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">也许再举一个整数的例子，因为我们可能总是认为“+”和“+=”是相同的，这是由于我们更经常地添加数字而不是列表。例如，Python中的整数也是不可变的。</p><figure class="ne nf ng nh gt iv gh gi paragraph-image"><div class="gh gi ox"><img src="../Images/9cca8e071cd72f992105d715a3ffa0fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:444/format:webp/1*FhJcBMk-l_2RHjWskmw8Bw.png"/></div></figure><p id="b816" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，在数字上使用“+=”是足够安全的，不要担心:)</p><h1 id="9fff" class="mm mn jj bd mo mp mq mr ms mt mu mv mw kp mx kq my ks mz kt na kv nb kw nc nd bi translated">摘要</h1><figure class="ne nf ng nh gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/a5e207b704469139a4c69e769e6c563d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oLBYPlKrlHJrtWdFkpdUaA.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">图片来自<a class="ae jg" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=776681" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>的<a class="ae jg" href="https://pixabay.com/users/geralt-9301/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=776681" rel="noopener ugc nofollow" target="_blank"> Gerd Altmann </a></p></figure><p id="be72" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在本文中，我介绍了在Python中添加对象的三种方式。它们是“神奇的函数”,当我们使用操作符时就会被调用。现在你应该明白它们什么时候会被调用，它们会提供什么特性。</p><p id="42a2" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最重要的是，要知道<code class="fe lu lv lw lx b">a = a + b</code>和<code class="fe lu lv lw lx b">a += b</code>的区别。当对象是<strong class="la jk">可变的</strong>时，它们会产生不同的结果。</p><div class="is it gp gr iu nv"><a href="https://medium.com/@qiuyujx/membership" rel="noopener follow" target="_blank"><div class="nw ab fo"><div class="nx ab ny cl cj nz"><h2 class="bd jk gy z fp oa fr fs ob fu fw ji bi translated">通过我的推荐链接加入Medium克里斯托弗·陶</h2><div class="oc l"><h3 class="bd b gy z fp oa fr fs ob fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="od l"><p class="bd b dl z fp oa fr fs ob fu fw dk translated">medium.com</p></div></div><div class="oy l"><div class="oz l pa pb pc oy pd ja nv"/></div></div></a></div><p id="b6e0" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">如果你觉得我的文章有帮助，请考虑加入灵媒会员来支持我和成千上万的其他作家！(点击上面的链接)</strong></p></div></div>    
</body>
</html>