<html>
<head>
<title>Everything You Need to Know about Indexing in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关于Python中的索引，您需要知道的一切</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/everything-you-need-to-know-about-indexing-in-python-c116e8cc5e2a?source=collection_archive---------13-----------------------#2021-08-24">https://towardsdatascience.com/everything-you-need-to-know-about-indexing-in-python-c116e8cc5e2a?source=collection_archive---------13-----------------------#2021-08-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a0ad" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Python中不同数据类型和结构的索引概述。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/bb0248159ee410598432f9ba8aaa4592.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uayFqVVW8DU1zmXfg9EZ1A.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(src =<a class="ae ky" href="https://pixabay.com/images/id-1690423/" rel="noopener ugc nofollow" target="_blank">https://pixabay.com/images/id-1690423/</a></p></figure><h1 id="af69" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">介绍</h1><p id="cfe3" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi mn translated"><span class="l mo mp mq bm mr ms mt mu mv di">在</span>通用编程中，使用数据结构是很常见的。数据结构是由更小的数据类型组成的类型。数据结构的一个例子是列表或字典。数据结构允许我们方便地将几个组件作为同一个一致变量的成员进行组织和工作。正如您所想象的，这使得数据结构成为数据科学中非常重要的组成部分。假设数据结构是由更小的组件组成的，那么肯定有一种方法可以基于某些特性来访问各个组件。为此，我们使用索引。</p><p id="8df0" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">索引很重要，因为它允许我们毫不费力地调用数据结构的一部分，以便单独处理结构内部的组件。当然，对于数据科学来说，掌握这一点是非常重要的，因为数据科学家可能会经常使用数据结构。</p><blockquote class="nb"><p id="a004" class="nc nd it bd ne nf ng nh ni nj nk mm dk translated"><a class="ae ky" href="https://github.com/emmettgb/Emmetts-DS-NoteBooks/blob/master/Python3/Indexing%20in%20Python.ipynb" rel="noopener ugc nofollow" target="_blank">笔记本</a></p></blockquote></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><h1 id="361c" class="kz la it bd lb lc ns le lf lg nt li lj jz nu ka ll kc nv kd ln kf nw kg lp lq bi translated">索引类型</h1><p id="4022" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在我们开始使用索引之前，让我们看看哪些类型实际上可以被索引。在Python编程语言中，可以使用给定类中的__getitem__()方法对类型进行索引。这意味着我们可以将索引方法应用于任何类型，只需简单地添加这个方法，并返回准确的结果。为了尝试这一点，我们将首先创建一个类。考虑下面的例子:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="b722" class="oc la it ny b gy od oe l of og">class Winners:</span><span id="6657" class="oc la it ny b gy oh oe l of og">    def __init__(self, first, second, third):</span><span id="3da7" class="oc la it ny b gy oh oe l of og">         self.first, self.second = first, second</span><span id="054f" class="oc la it ny b gy oh oe l of og">         self.third = third</span></pre><p id="435b" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">现在我们可以将__getitem__()方法添加到这个新类中。这将增加使用简单索引从类中轻松获取我们的位置的能力。</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="fe97" class="oc la it ny b gy od oe l of og">def __getitem__(self, x):</span></pre><p id="95d2" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">对于这个例子，我认为最好的攻击方法是在初始化这个类的构造函数时创建一个字典。使用这种方法，我们将能够简单地调用基于数字的字典索引，以便接收这场比赛的位置。</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="03ba" class="oc la it ny b gy od oe l of og">class Winners:</span><span id="3b9b" class="oc la it ny b gy oh oe l of og">    def __init__(self, first, second, third):</span><span id="371b" class="oc la it ny b gy oh oe l of og">        self.first, self.second = first, second </span><span id="ff82" class="oc la it ny b gy oh oe l of og">        self.third = third</span><span id="4dc6" class="oc la it ny b gy oh oe l of og">        self.index = dict({1 : self.first, 2 : self.second,</span><span id="9490" class="oc la it ny b gy oh oe l of og">                           3 : self.third})</span></pre><p id="2e14" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">最后，我们将结束__getitem__()方法，只需用提供的数字调用字典键:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="8720" class="oc la it ny b gy od oe l of og">class Winners:</span><span id="d47d" class="oc la it ny b gy oh oe l of og">     def __init__(self, first, second, third):</span><span id="668c" class="oc la it ny b gy oh oe l of og">            self.first, self.second = first, second</span><span id="72db" class="oc la it ny b gy oh oe l of og">            self.third = third</span><span id="797b" class="oc la it ny b gy oh oe l of og">            self.index = dict({1 : self.first, 2 : self.second,</span><span id="ef41" class="oc la it ny b gy oh oe l of og">                             3 : self.third})</span><span id="761f" class="oc la it ny b gy oh oe l of og">    def __getitem__(self, x):</span><span id="9c72" class="oc la it ny b gy oh oe l of og">        return(self.index[x])</span></pre><p id="923f" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">虽然这当然很好，但是让我们记住，我们只是这里的日志赢家，所以任何超过4点的人都不包含在这个类中。记住，如果我们在这个类上调用索引4，我们将得到一个KeyError作为回报。每当我们创建软件时，尤其是在我们的软件用户可能永远不会看到的类中，我们会希望抛出一些错误，使错误比这更明显一些。考虑到这一点，我们将在这个方法中添加一个try和catch，以便打印出更详细的错误。最终结果看起来有点像这样:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="42de" class="oc la it ny b gy od oe l of og">class Winners:</span><span id="c743" class="oc la it ny b gy oh oe l of og">    def __init__(self, first, second, third):</span><span id="7466" class="oc la it ny b gy oh oe l of og">        self.first, self.second = first, second</span><span id="5913" class="oc la it ny b gy oh oe l of og">        self.third = third</span><span id="67fd" class="oc la it ny b gy oh oe l of og">        self.index = dict({1 : self.first, 2 : self.second,</span><span id="805a" class="oc la it ny b gy oh oe l of og">                           3 : self.third})</span><span id="fd56" class="oc la it ny b gy oh oe l of og">    def __getitem__(self, x):</span><span id="8bee" class="oc la it ny b gy oh oe l of og">        try:</span><span id="a7dd" class="oc la it ny b gy oh oe l of og">             return(self.index[x])</span><span id="9449" class="oc la it ny b gy oh oe l of og">        except KeyError:</span><span id="d5fb" class="oc la it ny b gy oh oe l of og">             print("""KeyError!\nOnly keys 1-3 are stored in this                 class!""")</span></pre><p id="b618" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">现在让我们试着索引这种类型。首先，我们当然需要初始化这个对象的一个新实例，然后我们将索引它。这是通过[]语法完成的:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="2509" class="oc la it ny b gy od oe l of og">race_winners = Winners("Nancy", "Bobby", "Reagan")</span></pre><p id="851b" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">首先让我们试着用4来表示它，看看我们得到什么样的回报！</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="a84a" class="oc la it ny b gy od oe l of og">race_winners[4]</span><span id="497d" class="oc la it ny b gy oh oe l of og">KeyError!<br/>Only keys 1-3 are stored in this class!</span></pre><p id="3c9d" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">现在我们将在该类的索引中打印1:3:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="868e" class="oc la it ny b gy od oe l of og">print(race_winners[1])</span><span id="5316" class="oc la it ny b gy oh oe l of og">print(race_winners[2])</span><span id="6942" class="oc la it ny b gy oh oe l of og">print(race_winners[3])</span><span id="2f3e" class="oc la it ny b gy oh oe l of og">Nancy<br/>Bobby<br/>Reagan</span></pre><h2 id="1570" class="oc la it bd lb oi oj dn lf ok ol dp lj ma om on ll me oo op ln mi oq or lp os bi translated">Python中的可索引类型</h2><p id="aeab" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">Python编程语言提供了几种可以立即索引的数据类型和数据结构。本文中我们首先要看是字典数据结构。</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="8cdb" class="oc la it ny b gy od oe l of og">dct = dict({"A" : [5, 10, 15], "B" : [5, 10, 15]})</span></pre><p id="d973" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">我们可以使用相应的字典键来索引字典。这将给出给定键的值对。这将方便地为我们提供下一个数据结构，列表:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="a786" class="oc la it ny b gy od oe l of og">lst = dct["A"]</span></pre><p id="f04b" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">列表可以用我们想要访问的元素的位置来索引。例如，我们新列表的第二个元素是10。我们可以用这个来称呼它</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="fadb" class="oc la it ny b gy od oe l of og">lst[1]</span></pre><p id="ca25" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">当然，这是一个，而不是两个，因为在Python中索引是从零开始的。不用说，使用列表索引肯定会派上用场。我们可以索引的另一种类型是字符串:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="3636" class="oc la it ny b gy od oe l of og">"Hello"[1]</span><span id="24f1" class="oc la it ny b gy oh oe l of og">'e'</span></pre><h1 id="56a0" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">设置索引</h1><p id="e9f8" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">与调用索引同等重要的是设置索引。设置索引不仅允许我们在列表和其他可迭代的数据结构上创建新的位置，还允许我们改变数据结构内部的现有值。此外，我们可以使用这种方法将关键字放入字典，将列添加到Pandas数据帧，等等。在Python中，索引设置调用__setitem__()方法。让我们继续为此编写一个函数:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="83aa" class="oc la it ny b gy od oe l of og">def __setitem__(self, x, y):<br/>    pass</span></pre><p id="7959" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">现在，我们将在这个新函数中编写一点逻辑，允许它将相应的字典键的值设置为新的输入值:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="cf22" class="oc la it ny b gy od oe l of og">def __setitem__(self, x, y):</span><span id="4f36" class="oc la it ny b gy oh oe l of og">self.index[x] = y</span></pre><p id="f58d" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">现在，我们可以将比赛位置的指数设置为新值:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="9cea" class="oc la it ny b gy od oe l of og">print(race_winners.index.values())</span><span id="88ea" class="oc la it ny b gy oh oe l of og">dict_values(['Nancy', 'Bobby', 'Reagan'])</span><span id="9c2d" class="oc la it ny b gy oh oe l of og">race_winners[2] = "John"</span><span id="1dc8" class="oc la it ny b gy oh oe l of og">print(race_winners.index.values())</span><span id="09fd" class="oc la it ny b gy oh oe l of og">dict_values(['Nancy', 'John', 'Reagan'])</span></pre><p id="90c2" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">当然，同样的概念也适用于Python中的所有数据结构。我们可以将此应用于列表、字典值，但不能应用于字符串，如下所示:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="f540" class="oc la it ny b gy od oe l of og">z = [5, 10]</span><span id="017f" class="oc la it ny b gy oh oe l of og">z[1] = 1</span><span id="84b4" class="oc la it ny b gy oh oe l of og">d = dict({"h" : 5, "z" : 6})</span><span id="244b" class="oc la it ny b gy oh oe l of og">d["z"] = 5</span><span id="9874" class="oc la it ny b gy oh oe l of og">assert d["z"] == d["h"]</span><span id="12ae" class="oc la it ny b gy oh oe l of og">assert z[1] &lt; z[0]</span></pre><h1 id="26a0" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">重要功能</h1><p id="045d" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">现在我们已经了解了索引的基本知识，让我们来看一下在处理数据结构时可能会用到的一些重要函数。这些函数中有许多对于处理大量数据非常有用。应该注意的是，这些函数主要用于列表和矩阵，尽管有些函数可能适用于其他结构。这将是我们要使用的这些函数的列表:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="77ad" class="oc la it ny b gy od oe l of og">lst = [5, 1, 6, 4, 5, 7, 3,</span><span id="0e34" class="oc la it ny b gy oh oe l of og">5, 4, 3, 1, 2, 3, 4,]</span></pre><h2 id="4994" class="oc la it bd lb oi oj dn lf ok ol dp lj ma om on ll me oo op ln mi oq or lp os bi translated">1.插入()</h2><p id="13f6" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">第一个有用函数是insert。Insert将允许你在一个数组中的任何索引处放置任何值。如果您希望特定数组在某个位置包含特定组件，这将非常有用。它非常容易使用，只需添加两个参数，位置，然后是你想要添加的值。</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="3a35" class="oc la it ny b gy od oe l of og">lst.insert(5, 3)</span></pre><h2 id="8941" class="oc la it bd lb oi oj dn lf ok ol dp lj ma om on ll me oo op ln mi oq or lp os bi translated">2.追加()</h2><p id="8225" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">下一个函数是append函数。这个函数经常用于生成列表，通常是在迭代中。这将为下一个可用索引添加一个值，并且只需要一个值作为参数。</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="e97f" class="oc la it ny b gy od oe l of og">lst.append(5)</span></pre><p id="e9c4" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">对于这种特殊情况，更好的方法可能是lambda with mapping，或者如果是series类型，可能是apply方法，在这种情况下，我将使用迭代循环和append函数来演示如何以这种方式使用它:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="140a" class="oc la it ny b gy od oe l of og">lst2 = []</span><span id="07e5" class="oc la it ny b gy oh oe l of og">for z in lst:</span><span id="63a1" class="oc la it ny b gy oh oe l of og">     lst2.append(z * 3 + 2)</span></pre><h2 id="af1a" class="oc la it bd lb oi oj dn lf ok ol dp lj ma om on ll me oo op ln mi oq or lp os bi translated">3.移除()</h2><p id="9648" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">Remove将从给定列表中删除一个值。注意，这需要一个值，而不是一个索引！它也只会移除给定值的一个实例。</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="fb73" class="oc la it ny b gy od oe l of og">lst.remove(1)</span></pre><h2 id="fb71" class="oc la it bd lb oi oj dn lf ok ol dp lj ma om on ll me oo op ln mi oq or lp os bi translated">4.扩展()</h2><p id="77d6" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">extend函数本质上只是append()方法，但是允许我们将一个列表追加到列表的末尾:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="7fe8" class="oc la it ny b gy od oe l of og">lst.extend([101, 503])</span></pre><h2 id="4680" class="oc la it bd lb oi oj dn lf ok ol dp lj ma om on ll me oo op ln mi oq or lp os bi translated">5.计数()</h2><p id="f686" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">Count将返回一个整数，它是给定列表中某个元素的所有实例的计数。</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="4d2d" class="oc la it ny b gy od oe l of og">lst.count(5)</span><span id="00fa" class="oc la it ny b gy oh oe l of og">4</span></pre><p id="e173" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">这个函数的一个很好的用例是计算模式。观察我如何使用count和字典在迭代循环中获得模式:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="77d4" class="oc la it ny b gy od oe l of og">digit_n = {}</span><span id="14c7" class="oc la it ny b gy oh oe l of og">for x in set(lst):</span><span id="d061" class="oc la it ny b gy oh oe l of og">    cnt = lst.count(x)</span><span id="dc36" class="oc la it ny b gy oh oe l of og">    digit_n[cnt] = x</span><span id="d5e8" class="oc la it ny b gy oh oe l of og">     mode = digit_n[max(digit_n.keys())]</span><span id="0245" class="oc la it ny b gy oh oe l of og">print(mode)</span><span id="d387" class="oc la it ny b gy oh oe l of og">5</span></pre><h2 id="0d41" class="oc la it bd lb oi oj dn lf ok ol dp lj ma om on ll me oo op ln mi oq or lp os bi translated">6.排序()</h2><p id="f584" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我想讨论的最后一个重要列表函数是sort()函数。该函数不带参数，将对列表进行逻辑排序，或者按照关键字参数的指定进行排序。在下面的例子中，我使用sort来查找列表的中值:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="41ce" class="oc la it ny b gy od oe l of og">lst.sort()<br/>medianindex = int(len(lst) / 2)</span><span id="565c" class="oc la it ny b gy oh oe l of og">print(medianindex)</span><span id="9b9c" class="oc la it ny b gy oh oe l of og">print(lst[medianindex])</span></pre></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><h1 id="65ac" class="kz la it bd lb lc ns le lf lg nt li lj jz nu ka ll kc nv kd ln kf nw kg lp lq bi translated">结论</h1><p id="a145" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">不用说，在编写任何涉及数据的代码时，索引是一件非常重要的事情。list类的标准函数对于操纵、创建和从数据中获得洞察力也非常有用。我认为这是所有人都想知道的关于Python中索引的内容。非常感谢你的阅读，我希望你有一个美好的白天或夜晚休息！</p></div></div>    
</body>
</html>