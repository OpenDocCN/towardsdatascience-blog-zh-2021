<html>
<head>
<title>Advanced multi-tasking in Python: Applying and benchmarking thread pools and process pools in 6 lines of code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的高级多任务处理:用6行代码应用线程池和进程池并进行基准测试</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/advanced-multi-tasking-in-python-applying-and-benchmarking-threadpools-and-processpools-90452e0f7d40?source=collection_archive---------9-----------------------#2021-11-18">https://towardsdatascience.com/advanced-multi-tasking-in-python-applying-and-benchmarking-threadpools-and-processpools-90452e0f7d40?source=collection_archive---------9-----------------------#2021-11-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f83a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">安全轻松地对您的代码应用多任务处理</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/062a14d3a4a54f4d0f3223c770bc35fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*i7j5dKwWcQ0wGIl-"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">我们的一名工作人员正在执行一项重要任务(图片由<a class="ae ky" href="https://unsplash.com/photos/c3RWaj8L3M8" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae ky" href="https://unsplash.com/@epan5" rel="noopener ugc nofollow" target="_blank"> Krysztof Niewolny </a>拍摄)</p></figure><p id="0269" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当你的机器可以执行多任务时，为什么要按顺序执行呢？使用进程的线程，你可以通过同时运行来大大提高代码的速度。本文将向您展示用Python实现这一奇妙技术的安全而简单的方法。在本文结束时，您将:</p><ul class=""><li id="0ab7" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">了解哪些任务适合多任务处理</li><li id="cb2a" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">知道何时应用线程池或进程池</li><li id="672f" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">能够向同事和朋友吹嘘只用几行简单的代码就可以将执行速度提高10倍</li></ul><p id="ea68" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们开始之前，我强烈建议先看一看<a class="ae ky" href="https://mikehuls.medium.com/why-is-python-so-slow-and-how-to-speed-it-up-485b5a84154e" rel="noopener"> <strong class="lb iu">这篇文章</strong> </a>来理解Python是如何工作的。为什么Python一开始就不是多线程的？它向您展示了我们在本文中试图解决的问题。我还推荐阅读这篇解释线程和进程区别的文章。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="2d2c" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">为什么要用泳池？</h1><p id="8cc9" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">池是希望保护员工数量的应用程序的理想选择。假设您在一个API中运行一个函数，该函数创建5个workers来处理提供的数据。如果您的API在一秒钟内突然收到500个请求，该怎么办？创建2500个都执行繁重任务的工人可能会杀死你的计算机。</p><p id="2416" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">池通过限制可以创建的工作线程的数量来防止您的计算机像这样被终止。在API示例中，您可能希望创建一个最多包含50个工作线程的池。当500个请求进来时会发生什么？只有50个工人被创造出来。还记得每个请求需要5个工人吗？这意味着只有前10个请求得到处理。一旦工人完成并返回到池中，它可以再次被发送出去。</p><p id="f1f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">总之:池确保在任何给定的时间都不会有超过一定数量的工作线程处于活动状态。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="910c" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">创建池</h1><p id="8e0e" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">使用并发库，我们可以轻松地为线程和进程创建池。在下面的部分，我们将进入代码。最后，我们会有一个例子:</p><ul class=""><li id="c913" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">如何创建池</li><li id="0fd9" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">限制池的最大工作线程数</li><li id="e137" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">将目标函数映射到池中，以便工作人员可以执行它</li><li id="3220" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">收集函数的结果</li><li id="931d" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">等待所有工人完成后再继续</li></ul><h2 id="409e" class="nn mr it bd ms no np dn mw nq nr dp na li ns nt nc lm nu nv ne lq nw nx ng ny bi translated">设置</h2><p id="8cf3" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">正如您在<a class="ae ky" href="https://mikehuls.medium.com/multi-tasking-in-python-speed-up-your-program-10x-by-executing-things-simultaneously-4b4fc7ee71e" rel="noopener"> <strong class="lb iu">这篇文章</strong> </a> <strong class="lb iu"> </strong>中看到的，线程更适合IO类型的任务(并发等待)，而进程最适合CPU密集型任务(使用更多CPU)。为了正确测试我们的代码，我们将定义两种类型的函数:一种是IO密集型的，另一种是CPU密集型的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="ae19" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些是我们的目标函数；承担重任的职能。注意，两者都有一个打印输出参数。这不是特别有用的<br/>，但是我们需要它来证明我们可以传递额外的(关键字)参数。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5bf0431d11de2022023ba38a2a53fa2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*b3Wq3GddjF55kVO5"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">每个蜂巢都有一个固定数量的工蜂池(图片由<a class="ae ky" href="https://unsplash.com/@kel_foto" rel="noopener ugc nofollow" target="_blank">汉斯约格·凯勒</a>在<a class="ae ky" href="https://unsplash.com/photos/OJHxRwXWXBs" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄)</p></figure><h2 id="4bcf" class="nn mr it bd ms no np dn mw nq nr dp na li ns nt nc lm nu nv ne lq nw nx ng ny bi translated">线程池IO繁重任务</h2><p id="76ec" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">我们将从I/O-heavy函数开始。我们有一个100个数字的列表，我们想传递给这个函数。按顺序，代码如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="b874" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们执行上面的代码，大约需要<strong class="lb iu"> 100秒</strong>来执行(100个调用，每2秒一次)。让我们使用线程池来运行相同的代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="0acf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如你所见，我们使用了concurrent . futures . threadpoolexecutor。我们定义最多10个工人，然后在我们的范围内循环，为每个数字创建一个线程。每个线程一完成，我们就将结果添加到_sum变量中，并最终返回它。执行这段代码大约需要10秒钟。这并不奇怪，因为我们有10个工人，所以我们应该比顺序运行代码快10倍。</p><p id="54a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面你会发现同样的代码只是格式不同。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="4ebc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将把对函数的调用定义为部分函数，这样我们就可以把它映射到执行器。第三行对范围(10)中的每个值执行部分函数。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h2 id="687a" class="nn mr it bd ms no np dn mw nq nr dp na li ns nt nc lm nu nv ne lq nw nx ng ny bi translated">CPU繁重的任务</h2><p id="17e7" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">当谈到将CPU繁重功能映射到进程池的代码时，我们可以简单地说:代码非常相似。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="01b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">只需将第3行中的函数换成(cpu_heavy_task)并将ThreadPoolExecutor切换成ProcessPoolExecutor。就是这样！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/74cf51933d209cfa143268be559ab94d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*6gNkmkB9cd9UbEJc"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">让我们来看看顺序、线程和进程之间的区别(图片由<a class="ae ky" href="https://unsplash.com/@glen_rushton" rel="noopener ugc nofollow" target="_blank"> Glen Rushton </a>在<a class="ae ky" href="https://unsplash.com/photos/Uwl7TRuTZqE" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上提供)</p></figure><h1 id="8a5a" class="mq mr it bd ms mt ob mv mw mx oc mz na jz od ka nc kc oe kd ne kf of kg ng nh bi translated">标杆管理</h1><p id="fff9" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">让我们来测试一下这些功能吧！我们将顺序执行IO密集型和CPU密集型函数，线程化和多处理。<br/>以下是结果:</p><pre class="kj kk kl km gt og oh oi oj aw ok bi"><span id="f3fd" class="nn mr it oh b gy ol om l on oo">IO heavy function<br/>sequential:      took 100.44 seconds<br/>threaded:        took 10.04  seconds (max pool size = 10)<br/>processed:       took 10.20  seconds (max pool size = 10)<br/> <br/>CPU heavy function <br/>sequential:      took 27.89  seconds<br/>threaded:        took 26.65  seconds (max pool size = 10)<br/>processed:       took 6.58   seconds (max pool size = 10)</span></pre><p id="6a35" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如<strong class="lb iu"> </strong> <a class="ae ky" href="https://mikehuls.medium.com/multi-tasking-in-python-speed-up-your-program-10x-by-executing-things-simultaneously-4b4fc7ee71e" rel="noopener"> <strong class="lb iu">这篇</strong> </a> <strong class="lb iu"> </strong>中所解释的，这些结果都是意料之中的。顺序执行当然是最慢的，一个接一个地执行所有的函数。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c90d29f9d8a2fe22d20005c7b50ecae1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*yKnaq_10mjTYcp_0"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">不仅仅是一辆车，还有游泳池，我们有整个车队可以使用(图片由乔治·贝尔在Unsplash上拍摄)</p></figure><p id="070a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="op">线程</em>IO繁重功能的速度快了10倍，因为我们的工作人员是它的10倍。<em class="op">处理</em>IO密集型函数大约与10个线程一样快。它会慢一点，因为设置这些流程的成本更高。注意，虽然两者速度一样快，但是线程是更好的选择，因为它们提供了共享资源的能力。</p><p id="dd5c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们对CPU密集型函数进行基准测试时，我们看到线程化与顺序方法一样快。这是由于GIL在本文  <strong class="lb iu">中解释了<a class="ae ky" href="https://mikehuls.medium.com/multi-tasking-in-python-speed-up-your-program-10x-by-executing-things-simultaneously-4b4fc7ee71e" rel="noopener"> <strong class="lb iu">。</strong>进程在处理CPU密集型任务时效率更高，速度提高了约4.3倍。</a></strong></p><p id="cdf6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另外，请注意，在这些情况下，我们的池大小相当小，并且可以调整(取决于您的目标函数)以创建更快的程序！</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="6841" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">结论</h1><p id="adc6" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">正如您在本文中读到的，使用池非常容易。此外，我希望已经阐明了为什么以及如何使用它们。有时候多任务处理是不够的。查看<a class="ae ky" href="https://mikehuls.medium.com/getting-started-with-cython-how-to-perform-1-7-billion-calculations-per-second-in-python-b83374cfcf77" rel="noopener"> <strong class="lb iu">这篇</strong> </a>或<a class="ae ky" href="https://mikehuls.medium.com/write-your-own-c-extension-to-speed-up-python-x100-626bb9d166e7" rel="noopener"> <strong class="lb iu">这篇</strong> </a>的文章，这篇文章向您展示了如何编译一小部分代码以获得100倍的速度提升(也可以是多任务的)。</p><p id="0b95" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你有建议/澄清，请评论，以便我可以改进这篇文章。与此同时，请查看我的<a class="ae ky" href="https://mikehuls.medium.com/" rel="noopener">关于各种编程相关主题的其他文章</a>，例如:</p><ul class=""><li id="0b1e" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><a class="ae ky" href="https://mikehuls.medium.com/multi-tasking-in-python-speed-up-your-program-10x-by-executing-things-simultaneously-4b4fc7ee71e" rel="noopener">Python中的多任务处理:通过同时执行，将程序速度提高10倍</a></li><li id="c650" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://mikehuls.medium.com/create-a-fast-auto-documented-maintainable-and-easy-to-use-python-api-in-5-lines-of-code-with-4e574c00f70e" rel="noopener">用FastAPI用5行代码创建一个快速自动记录、可维护且易于使用的Python API</a></li><li id="4328" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://mikehuls.medium.com/python-to-sql-upsert-safely-easily-and-fast-17a854d4ec5a" rel="noopener">从Python到SQL——安全、轻松、快速地升级</a></li><li id="67e3" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://mikehuls.medium.com/create-and-publish-your-own-python-package-ea45bee41cdc" rel="noopener">创建并发布你自己的Python包</a></li><li id="bfc7" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://mikehuls.medium.com/create-your-custom-python-package-that-you-can-pip-install-from-your-git-repository-f90465867893" rel="noopener">创建您的定制私有Python包，您可以从您的Git库PIP安装该包</a></li><li id="4ae7" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://mikehuls.medium.com/virtual-environments-for-absolute-beginners-what-is-it-and-how-to-create-one-examples-a48da8982d4b" rel="noopener">面向绝对初学者的虚拟环境——什么是虚拟环境以及如何创建虚拟环境(+示例)</a></li><li id="31f2" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://mikehuls.medium.com/dramatically-improve-your-database-inserts-with-a-simple-upgrade-6dfa672f1424" rel="noopener">通过简单升级，显著提高数据库插入速度</a></li></ul><p id="cbce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">编码快乐！</p><p id="147a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">—迈克</p><p id="74d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">页（page的缩写）学生:比如我正在做的事情？<a class="ae ky" href="https://mikehuls.medium.com/membership" rel="noopener">跟着我！</a></p><div class="oq or gp gr os ot"><a href="https://mikehuls.medium.com/membership" rel="noopener follow" target="_blank"><div class="ou ab fo"><div class="ov ab ow cl cj ox"><h2 class="bd iu gy z fp oy fr fs oz fu fw is bi translated">通过我的推荐链接加入媒体-迈克·赫斯</h2><div class="pa l"><h3 class="bd b gy z fp oy fr fs oz fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="pb l"><p class="bd b dl z fp oy fr fs oz fu fw dk translated">mikehuls.medium.com</p></div></div><div class="pc l"><div class="pd l pe pf pg pc ph ks ot"/></div></div></a></div></div></div>    
</body>
</html>