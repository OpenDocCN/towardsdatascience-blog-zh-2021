<html>
<head>
<title>Optimising your input pipeline performance with tf.data (part 2)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用tf.data优化输入管道性能(第2部分)</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/optimising-your-input-pipeline-performance-with-tf-data-part-2-9ee406451f93?source=collection_archive---------16-----------------------#2021-05-29">https://towardsdatascience.com/optimising-your-input-pipeline-performance-with-tf-data-part-2-9ee406451f93?source=collection_archive---------16-----------------------#2021-05-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="dae8" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">提高您的输入管道效率和GPU利用率</h2></div></div><div class="ab cl kf kg hu kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="ij ik il im in"><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/2e2d29dc9261b8aaef0211495d3814d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7Q-P_NrtrfVU9Ge73YFX2Q.png"/></div></div><p class="ky kz gj gh gi la lb bd b be z dk translated">来源:ka ggle<a class="ae lc" href="https://www.kaggle.com/jalammar/intro-to-data-input-pipelines-with-tf-data" rel="noopener ugc nofollow" target="_blank">https://www . ka ggle . com/jalammar/intro-to-data-input-pipelines-with-TF-data</a></p></figure><p id="551b" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">在第1部分中，我重点介绍了aim中的不同概念<code class="fe lz ma mb mc b">tf.data</code>，以优化您的输入管道性能。我们希望确保输入管道上不存在瓶颈，以便充分利用我们的GPU使用。</p><p id="6c75" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">现在，在第2部分中，我将展示一个在输入管道中使用<code class="fe lz ma mb mc b">tf.data</code>和keras <code class="fe lz ma mb mc b">ImageDataGenerator</code>的实际例子，测量两者之间的性能。</p><div class="md me gp gr mf mg"><a rel="noopener follow" target="_blank" href="/optimising-your-input-pipeline-performance-with-tf-data-part-1-32e52a30cac4"><div class="mh ab fo"><div class="mi ab mj cl cj mk"><h2 class="bd ir gy z fp ml fr fs mm fu fw ip bi translated">使用tf.data优化输入管道性能(第1部分)</h2><div class="mn l"><h3 class="bd b gy z fp ml fr fs mm fu fw dk translated">tf.data API使您能够从简单的、可重用的部分构建复杂的输入管道。</h3></div><div class="mo l"><p class="bd b dl z fp ml fr fs mm fu fw dk translated">towardsdatascience.com</p></div></div><div class="mp l"><div class="mq l mr ms mt mp mu kw mg"/></div></div></a></div><p id="1742" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated"><strong class="lf ir">使用Keras </strong> <code class="fe lz ma mb mc b"><strong class="lf ir">ImageDataGenerator</strong></code> <strong class="lf ir"> : </strong></p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mv mw l"/></div><p class="ky kz gj gh gi la lb bd b be z dk translated">使用Keras ImageDataGenerator加载数据</p></figure><p id="8785" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated"><strong class="lf ir">利用</strong> <code class="fe lz ma mb mc b"><strong class="lf ir">tf.data</strong></code> <strong class="lf ir"> : </strong></p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mv mw l"/></div><p class="ky kz gj gh gi la lb bd b be z dk translated">使用tf.data加载数据</p></figure><p id="caac" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated"><strong class="lf ir">测量</strong> <code class="fe lz ma mb mc b"><strong class="lf ir">tf.data</strong></code> <strong class="lf ir">和</strong> <code class="fe lz ma mb mc b"><strong class="lf ir">ImageDataGenerator</strong></code> <strong class="lf ir"> : </strong>的时间性能</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mv mw l"/></div><p class="ky kz gj gh gi la lb bd b be z dk translated">测量时间性能</p></figure><p id="646c" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">请注意，在这两个示例中，输入数据是从本地机器而不是远程云存储中读取的，并且没有做任何预处理工作。目录结构应该如下所示:</p><p id="471c" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated"><code class="fe lz ma mb mc b">dir_path</code>应该是pictures文件夹的路径，而<code class="fe lz ma mb mc b">folders</code>是由pictures文件夹中的文件夹名组成的数组——在我的例子中，它是我的train和validation文件夹。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/472b94c243f7ce67d0de6e6d17a2d55e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1018/format:webp/1*Lx4xyloVgHDHiNAlbvv55g.png"/></div><p class="ky kz gj gh gi la lb bd b be z dk translated">目录结构。来源:来自本地机器的截图</p></figure><p id="39eb" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">结果对<code class="fe lz ma mb mc b">tf.data</code>更有利，比Keras <code class="fe lz ma mb mc b">ImageDataGenerator</code>快两倍多。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi my"><img src="../Images/b61fbbe06fbfcf4a4af8631e2bca4b93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d8KZ9TC6kQts2abSiRrUAQ.png"/></div></div></figure><p id="7fcc" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">注意，对于我们的<code class="fe lz ma mb mc b">tf.data</code>生成器，它返回一个类型&lt; float，string &gt;，因为我们已经在函数中定义了标签。如果你想让生成器返回&lt; float，改为float &gt;，你必须将函数中的标签解析成相应的float——为了训练你的模型。</p><p id="196d" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">此外，在这个<code class="fe lz ma mb mc b">tf.data</code>示例中，由于我使用的数据集很大，我将缓存存储在本地存储中，而不是内存中。如果数据集足够小，可以放入内存中，那么将缓存存储在内存中会使性能稍微好一点。</p></div><div class="ab cl kf kg hu kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="ij ik il im in"><h1 id="61db" class="mz na iq bd nb nc nd ne nf ng nh ni nj jw nk jx nl jz nm ka nn kc no kd np nq bi translated">结论</h1><p id="22dc" class="pw-post-body-paragraph ld le iq lf b lg nr jr li lj ns ju ll lm nt lo lp lq nu ls lt lu nv lw lx ly ij bi translated">与Keras <code class="fe lz ma mb mc b">ImageDataGenerator</code>相比，<code class="fe lz ma mb mc b">tf.data</code>提供了更高效的输入管道。有了一个更有效的输入管道，你就可以更好地利用GPU来训练你的模型，因为瓶颈不再在输入管道上了！希望你喜欢这些文章。谢谢大家！</p><h1 id="befa" class="mz na iq bd nb nc nw ne nf ng nx ni nj jw ny jx nl jz nz ka nn kc oa kd np nq bi translated">来源</h1><p id="1e16" class="pw-post-body-paragraph ld le iq lf b lg nr jr li lj ns ju ll lm nt lo lp lq nu ls lt lu nv lw lx ly ij bi translated"><a class="ae lc" href="https://medium.com/swlh/dump-keras-imagedatagenerator-start-using-tensorflow-tf-data-part-1-a30330bdbca9" rel="noopener">https://medium . com/swlh/dump-keras-imagedata generator-start-using-tensor flow-TF-data-part-1-a 30330 BDB ca 9</a></p></div></div>    
</body>
</html>