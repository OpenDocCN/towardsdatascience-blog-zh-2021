<html>
<head>
<title>Performing Groupings on Multi-Index Pandas DataFrames</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在多索引Pandas数据帧上执行分组</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/performing-groupings-on-multi-index-pandas-dataframes-1e22ed435a29?source=collection_archive---------9-----------------------#2021-09-04">https://towardsdatascience.com/performing-groupings-on-multi-index-pandas-dataframes-1e22ed435a29?source=collection_archive---------9-----------------------#2021-09-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1560" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">探索set_index()和groupby()函数</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/1229404261136e076b8f90bca1a52b73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*IMvZFRzglBwemTao"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Maksym Kaharlytskyi 在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="f022" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我的上一篇文章——“<strong class="lb iu">使用多索引Pandas DataFrames </strong>”中，我谈到了如何将单索引数据帧转换成多索引数据帧，以及使用它的各种技术。</p><div class="lv lw gp gr lx ly"><a rel="noopener follow" target="_blank" href="/working-with-multi-index-pandas-dataframes-f64d2e2c3e02"><div class="lz ab fo"><div class="ma ab mb cl cj mc"><h2 class="bd iu gy z fp md fr fs me fu fw is bi translated">使用多索引熊猫数据框架</h2><div class="mf l"><h3 class="bd b gy z fp md fr fs me fu fw dk translated">了解如何轻松使用多索引数据框架</h3></div><div class="mg l"><p class="bd b dl z fp md fr fs me fu fw dk translated">towardsdatascience.com</p></div></div><div class="mh l"><div class="mi l mj mk ml mh mm ks ly"/></div></div></a></div><p id="a2a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我将继续讨论多索引数据帧，但这一次我将更多地关注于使用<strong class="lb iu"> set_index() </strong>和<strong class="lb iu"> groupby() </strong>函数，并探索它们的相似之处和不同之处。</p><h1 id="58f9" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">加载数据帧</h1><p id="1531" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">在这篇文章中，我将使用两个CSV文件。第一个是<strong class="lb iu"> temperature.csv </strong>，包含以下内容:</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="7399" class="np mo it nl b gy nq nr l ns nt">Country,City,1/1/2020,1/2/2020,1/3/2020,1/4/2020,1/5/2020<br/>Singapore,Singapore,28,29,28,31,33<br/>England,London,3,4,1,4,7<br/>England,Birmingham,5,7,12,3,6<br/>Japan,Tokyo,6,8,14,6,4<br/>Japan,Tahara,3,4,7,9,5</span></pre><p id="a7ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第二个是<strong class="lb iu">湿度. csv </strong>，内容如下:</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="6792" class="np mo it nl b gy nq nr l ns nt">Country,City,1/1/2020,1/2/2020,1/3/2020,1/4/2020,1/5/2020<br/>Singapore,Singapore,0.71,0.69,0.80,0.72,0.73<br/>England,London,0.81,0.79,0.68,0.82,0.83<br/>England,Birmingham,0.88,0.9,0.92,0.79,0.79<br/>Japan,Tokyo,0.93,0.9,0.91,0.89,0.9<br/>Japan,Tahara,1,0.92,0.99,0.93,0.95</span></pre><p id="e17f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们加载两个CSV文件并检查它们的结构:</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="7b8c" class="np mo it nl b gy nq nr l ns nt">import pandas as pd<br/>df_temp = pd.read_csv("temperature.csv")<br/>df_temp</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/46ebd8480b416512eb9f96df3418eda6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1110/format:webp/1*qSS7Ri_hxtI9zQ1oPh_YFQ.png"/></div></figure><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="b648" class="np mo it nl b gy nq nr l ns nt">df_humd = pd.read_csv("humidity.csv")<br/>df_humd</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nv"><img src="../Images/7c86fcffbe28d9a4d5e3313aab9d8afb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1116/format:webp/1*dKoXrPKHuLX0u3gQ_wIfTw.png"/></div></div></figure><p id="0983" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，这两个文件包含了三个国家不同城市的一系列温度和湿度数据。日期以列的形式排列，这使得操作起来并不容易。因此，更好的办法是使用<strong class="lb iu"> melt() </strong>函数来取消它们的透视:</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="224a" class="np mo it nl b gy nq nr l ns nt">df_temp_melted = \<br/>    <strong class="nl iu">df_temp.melt</strong>(id_vars=['Country','City'], # columns to keep              <br/>                 var_name='Date',   # name of column to add<br/>                 value_name='Temp') # name of new column to <br/>                                    # store the temp for each date</span><span id="63f9" class="np mo it nl b gy nw nr l ns nt">df_humd_melted = <strong class="nl iu">df_humd.melt</strong>(id_vars=['Country','City'],           <br/>                              var_name='Date', <br/>                              value_name='Humidity')</span></pre><p id="bacc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">取消透视的<strong class="lb iu"> df_temp_melted </strong>数据帧现在看起来像这样:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/040c98a25a49f9945b8fd256d13e0662.png" data-original-src="https://miro.medium.com/v2/resize:fit:666/format:webp/1*V1wMRVapHVAGsmwa21OYtQ.png"/></div></figure><p id="66c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">取消透视的<strong class="lb iu"> df_humd_melted </strong>数据帧现在看起来像这样:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/b9bcf6ed682e7c4215c79681c706d4e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:704/format:webp/1*BM8chE2-J4RnmXzlzT_ygg.png"/></div></figure><p id="f29d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为除了温度和湿度列之外，这两个数据帧是相同的，所以使用concat()函数将它们合并成一个数据帧是有意义的:</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="0f3c" class="np mo it nl b gy nq nr l ns nt">df_melted = pd.concat(<br/>    [df_temp_melted, df_humd_melted['Humidity']],axis=1)<br/>df_melted</span></pre><p id="0454" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，您有一个包含温度和湿度值的单指数数据框架:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/2f3f819475f6e978317104920cc3c620.png" data-original-src="https://miro.medium.com/v2/resize:fit:814/format:webp/1*Q4J_u4hpauS28HtCCsCIHA.png"/></div></figure><h1 id="29ec" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">使用set_index()函数转换为多索引数据帧</h1><p id="e214" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">让我们尝试使用<strong class="lb iu"> set_index() </strong>函数，使用<strong class="lb iu"> Country </strong>列为<strong class="lb iu"> df_melted </strong>设置一个新的索引:</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="1cf5" class="np mo it nl b gy nq nr l ns nt">df_melted.set_index(<strong class="nl iu">['Country']</strong>)</span></pre><p id="b89c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您将看到以下结果。这是一个单索引数据帧:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/1686c43be4abb26b1240ea6b76ef66ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:760/format:webp/1*P0HXbOT8e9Ds_DPlFSA-TA.png"/></div></figure><p id="fac4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用<strong class="lb iu">国家</strong>和<strong class="lb iu">城市</strong>列作为索引怎么样？当然，您只需要将两列作为一个列表传入:</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="813b" class="np mo it nl b gy nq nr l ns nt">df_melted.set_index(<strong class="nl iu">['Country','City']</strong>)</span></pre><p id="05a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，现在您有了一个多索引数据框架，以<strong class="lb iu">国家</strong>和<strong class="lb iu">城市</strong>作为索引:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/26f0e07570c471e0f349e3be94df178c.png" data-original-src="https://miro.medium.com/v2/resize:fit:762/format:webp/1*GLlqxv6m0pqzxFzuvpyElg.png"/></div></figure><p id="136f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然我们也可以有三列作为索引:</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="947c" class="np mo it nl b gy nq nr l ns nt">df_melted.set_index(<strong class="nl iu">['Country','City','Date']</strong>)</span></pre><p id="fe85" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/325ef9fcf510cf97e99f67d9c73e8bfb.png" data-original-src="https://miro.medium.com/v2/resize:fit:770/format:webp/1*7PFsbiu7lZkLjGxdyOptxg.png"/></div></div></figure><p id="3413" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你看上面的输出，你可能会对输出有点失望。您可能希望输出如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi od"><img src="../Images/acd6d0228d80f1021c293724e6abbea2.png" data-original-src="https://miro.medium.com/v2/resize:fit:764/format:webp/1*XaMkh1cMO7rxNFAbe97bog.png"/></div></figure><p id="9265" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不幸的是，<strong class="lb iu"> set_index() </strong>函数的输出会因数据在数据帧中的排序方式而异。为了获得上面想要的输出，在使用<strong class="lb iu"> set_index() </strong>函数设置索引之前，您需要首先对数据帧进行排序:</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="2606" class="np mo it nl b gy nq nr l ns nt"><strong class="nl iu"># sort the dataframe first ...<br/>df_melted = df_melted.sort_values(by=['Country','City','Date'])</strong></span><span id="98f7" class="np mo it nl b gy nw nr l ns nt"><strong class="nl iu"># ... then set the three columns as index</strong><br/>df_melted.set_index(['Country','City','Date'])</span></pre><p id="73d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您现在应该会看到如上所示的输出。</p><h1 id="8692" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">使用groupby()获取多索引数据帧</h1><p id="a288" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">获得上一节结果的一个更简单的方法是使用<strong class="lb iu"> groupby() </strong>函数。默认情况下，<strong class="lb iu"> groupby() </strong>函数根据分组所依据的列对数据帧进行排序。使用groupby()，您的代码将如下所示:</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="ff91" class="np mo it nl b gy nq nr l ns nt">df_melted.<strong class="nl iu">groupby(['Country','City','Date'], <br/>                  as_index=True).agg(lambda x:x)</strong></span></pre><p id="ef21" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的声明中:</p><ul class=""><li id="9745" class="oe of it lb b lc ld lf lg li og lm oh lq oi lu oj ok ol om bi translated">首先根据<strong class="lb iu">国家</strong>、<strong class="lb iu">城市</strong>和<strong class="lb iu">日期</strong>对行进行排序</li><li id="47a7" class="oe of it lb b lc on lf oo li op lm oq lq or lu oj ok ol om bi translated">然后将指定的列用作索引(通过将<strong class="lb iu"> as_index </strong>参数设置为<strong class="lb iu"> True </strong>(默认值))</li><li id="94a5" class="oe of it lb b lc on lf oo li op lm oq lq or lu oj ok ol om bi translated">然后对<strong class="lb iu"> groupby() </strong>函数的结果调用<strong class="lb iu"> agg() </strong>函数；然后，数字列的每个值(<strong class="lb iu">温度</strong>和<strong class="lb iu">湿度</strong>)作为一个序列传递给lambda函数</li></ul><blockquote class="os ot ou"><p id="6dc3" class="kz la ov lb b lc ld ju le lf lg jx lh ow lj lk ll ox ln lo lp oy lr ls lt lu im bi translated">如果<strong class="lb iu"> as_index </strong>参数设置为<strong class="lb iu"> False </strong>，结果将是单索引数据帧。</p></blockquote><p id="d93c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以通过检查传递给aggregate ( <strong class="lb iu"> agg() </strong>)函数的值来验证最后一点:</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="1598" class="np mo it nl b gy nq nr l ns nt"><strong class="nl iu">def check(x):<br/>    print(x)<br/>    return x</strong></span><span id="60d2" class="np mo it nl b gy nw nr l ns nt">df_melted.groupby(['Country','City','Date'], <br/>                  as_index=True).agg(<strong class="nl iu">check</strong>)</span></pre><p id="f1bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的代码片段将打印出以下输出。<strong class="lb iu">温度</strong>列中的每个值作为一个序列传入，后面是<strong class="lb iu">湿度</strong>列中的每个值:</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="f1d6" class="np mo it nl b gy nq nr l ns nt">2    5<br/>Name: Temp, dtype: int64<br/>7    7<br/>Name: Temp, dtype: int64<br/>12    12<br/>Name: Temp, dtype: int64<br/>17    3<br/>Name: Temp, dtype: int64<br/>22    6<br/>Name: Temp, dtype: int64<br/>...</span><span id="3add" class="np mo it nl b gy nw nr l ns nt">0    0.71<br/>Name: Humidity, dtype: float64<br/>5    0.69<br/>Name: Humidity, dtype: float64<br/>10    0.8<br/>Name: Humidity, dtype: float64<br/>15    0.72<br/>Name: Humidity, dtype: float64<br/>20    0.73<br/>Name: Humidity, dtype: float64</span></pre><p id="b708" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为我们的dataframe对于每个<em class="ov">国家、城市和日期</em>都有一个惟一的值，所以传递给lambda函数(<strong class="lb iu"> x </strong>)的每个值都是一个包含一个元素的Series对象。因此，我们可以简单地返回lambda函数中的序列:</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="ad64" class="np mo it nl b gy nq nr l ns nt">df_melted.groupby(['Country','City','Date'], <br/>                  as_index=True).agg(<strong class="nl iu">lambda x:x</strong>)</span></pre><p id="5232" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">多索引数据帧现在如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oz"><img src="../Images/fa8fa76a9053a94861852b57cbf5cf1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:768/format:webp/1*jbn7W4tPqtLE0SdmgxSH4A.png"/></div></figure><blockquote class="os ot ou"><p id="27df" class="kz la ov lb b lc ld ju le lf lg jx lh ow lj lk ll ox ln lo lp oy lr ls lt lu im bi translated">如果在<strong class="lb iu"> groupby() </strong>函数中设置<strong class="lb iu"> sort=False </strong>，会得到不同的结果。试试看，你就会明白我的意思。</p><p id="6f64" class="kz la ov lb b lc ld ju le lf lg jx lh ow lj lk ll ox ln lo lp oy lr ls lt lu im bi translated">提示:结果将类似于前面使用<strong class="lb iu"> set_index() </strong>函数得到的结果。</p></blockquote><p id="41fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们尝试只使用两列来分组— <strong class="lb iu">国家</strong>和<strong class="lb iu">城市</strong>:</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="029e" class="np mo it nl b gy nq nr l ns nt">df_melted.groupby(<strong class="nl iu">['Country','City']</strong>, as_index=True).agg(<br/>                  <strong class="nl iu">lambda x:x</strong>)</span></pre><p id="e858" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以上语句在运行时会产生一个错误:</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="d2ed" class="np mo it nl b gy nq nr l ns nt"><em class="ov">ValueError: Must produce aggregated value</em></span></pre><p id="869a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是因为现在传递给lambda函数(<strong class="lb iu"> x </strong>)的序列有不止一行(每个唯一的<em class="ov">国家和城市</em>行有不止一行日期、温度和湿度)。并且聚合函数期望您返回一个值(或一个具有一个值的序列)，而不是一个具有多个值的序列。要解决这个问题，您需要提供一个函数，比如对序列调用<strong class="lb iu"> mean() </strong>:</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="4598" class="np mo it nl b gy nq nr l ns nt">df_melted.groupby(['Country','City'], as_index=True).agg(<br/>                  <strong class="nl iu">lambda x:x.mean()</strong>)</span></pre><p id="db9e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上述语句现在将产生以下输出:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pa"><img src="../Images/331d90fe1f9e617d7d5fe7195cd33ec7.png" data-original-src="https://miro.medium.com/v2/resize:fit:626/format:webp/1*C29DddA4eOY5S02S6noBjA.png"/></div></figure><p id="d21f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您还可以向<strong class="lb iu"> agg() </strong>函数传递一个字典，指示应用于每一列的特定函数:</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="d1b8" class="np mo it nl b gy nq nr l ns nt">df_melted.groupby(['Country','City'], as_index=True).agg(<strong class="nl iu"><br/>    {<br/>        'Temp':['mean','min','max'],<br/>        'Humidity':['mean','min','max'],<br/>    }</strong><br/>)</span></pre><p id="eb25" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上述语句生成以下输出:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pb"><img src="../Images/c382a3da4c928ad93e9f4d3135646413.png" data-original-src="https://miro.medium.com/v2/resize:fit:906/format:webp/1*IOP0l1DZ8wwjU8Mql7djaw.png"/></div></figure><h1 id="32af" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">对多索引数据帧执行groupby</h1><p id="80fe" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">在多索引数据帧上调用<strong class="lb iu"> groupby() </strong>函数时，也可以指定索引来执行groupby。让我们基于您之前看到的<strong class="lb iu"> df_melted </strong>数据帧生成一个新的数据帧<strong class="lb iu"> df2 </strong>:</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="e6e5" class="np mo it nl b gy nq nr l ns nt">df2 = df_melted.groupby(['Country','City','Date'], <br/>                  as_index=True).agg(lambda x:x)<br/>df2</span></pre><p id="b98e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是<strong class="lb iu"> df2 </strong>的样子:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oz"><img src="../Images/cfa777556b4c331bb662815c98b350b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:768/format:webp/1*bwl-tfmRFPkRiGv6j67IGA.png"/></div></figure><p id="5295" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设您想要每个国家的平均温度和湿度。为此，您可以在dataframe上执行一个<strong class="lb iu"> groupby() </strong>并指定索引<em class="ov">级别</em>:</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="140a" class="np mo it nl b gy nq nr l ns nt">df2.groupby(level=0).mean()</span></pre><p id="a68a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，<strong class="lb iu">级别=0 </strong>表示<strong class="lb iu">国家</strong>指数。或者，您也可以直接指定索引的名称:</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="24f4" class="np mo it nl b gy nq nr l ns nt">df2.groupby(level='<strong class="nl iu">Country</strong>').mean()</span></pre><p id="4bc2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">两个语句都会产生以下结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pc"><img src="../Images/0d998f6a83961a3d4efdfffecd9990db.png" data-original-src="https://miro.medium.com/v2/resize:fit:440/format:webp/1*BRZUNWhdiZtBtyWsG2izcg.png"/></div></figure><p id="56ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每个城市的平均温度和湿度怎么样？简单，只需指定<strong class="lb iu">城市</strong>为关卡:</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="8705" class="np mo it nl b gy nq nr l ns nt">df2.groupby(level='<strong class="nl iu">City</strong>').mean()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pd"><img src="../Images/8c73eea00381d6bda256e55b75d4f8f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:462/format:webp/1*1MYn5xue0qFTIQMSMDWV7g.png"/></div></figure><p id="b561" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，每个<strong class="lb iu">国家</strong>和<strong class="lb iu">城市</strong>的平均温度和湿度如何？供应列表中的<strong class="lb iu">国家</strong>和<strong class="lb iu">城市</strong>:</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="b2ce" class="np mo it nl b gy nq nr l ns nt">df2.groupby(level=[<strong class="nl iu">'Country','City'</strong>]).mean()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pe"><img src="../Images/e300fc38a387fd8f03b7393ca21fabe1.png" data-original-src="https://miro.medium.com/v2/resize:fit:634/format:webp/1*_aFRnDzskoKJDduY8F9C2A.png"/></div></figure><blockquote class="os ot ou"><p id="87b2" class="kz la ov lb b lc ld ju le lf lg jx lh ow lj lk ll ox ln lo lp oy lr ls lt lu im bi translated">当然你也可以使用<strong class="lb iu"> agg() </strong>函数来指定应用于每一列的特定函数</p></blockquote><h1 id="4b5b" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">结论</h1><p id="7488" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">在本文中，我们看到了<strong class="lb iu"> set_index() </strong>和<strong class="lb iu"> groupby() </strong>函数，它们都允许您创建多索引数据帧。虽然表面上看起来很相似，但是由<strong class="lb iu"> set_index() </strong>创建的输出依赖于数据帧中行的顺序，并要求您对行执行一些预先排序/重新排列。另一方面，<strong class="lb iu"> groupby() </strong>函数根据默认指定的列对行进行排序，并允许您使用一个或多个索引对多索引数据帧执行“groupby”</p><blockquote class="os ot ou"><p id="6841" class="kz la ov lb b lc ld ju le lf lg jx lh ow lj lk ll ox ln lo lp oy lr ls lt lu im bi translated"><strong class="lb iu"> set_index() </strong>函数仅适用于单索引数据帧，而<strong class="lb iu"> groupby() </strong>既适用于单索引数据帧，也适用于多索引数据帧。</p></blockquote><div class="lv lw gp gr lx ly"><a href="https://weimenglee.medium.com/membership" rel="noopener follow" target="_blank"><div class="lz ab fo"><div class="ma ab mb cl cj mc"><h2 class="bd iu gy z fp md fr fs me fu fw is bi translated">加入媒介与我的介绍链接-李伟孟</h2><div class="mf l"><h3 class="bd b gy z fp md fr fs me fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="mg l"><p class="bd b dl z fp md fr fs me fu fw dk translated">weimenglee.medium.com</p></div></div><div class="mh l"><div class="pf l mj mk ml mh mm ks ly"/></div></div></a></div></div></div>    
</body>
</html>