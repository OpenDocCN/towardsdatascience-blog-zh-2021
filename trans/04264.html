<html>
<head>
<title>Python Lists Are Sometimes Much Faster Than NumPy. Here’s Proof.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python列表有时比NumPy快得多。这是证据。</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/python-lists-are-sometimes-much-faster-than-numpy-heres-a-proof-4b3dad4653ad?source=collection_archive---------4-----------------------#2021-04-11">https://towardsdatascience.com/python-lists-are-sometimes-much-faster-than-numpy-heres-a-proof-4b3dad4653ad?source=collection_archive---------4-----------------------#2021-04-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="bdbe" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">小心使用什么。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/2241cc280fda661fc5058992c8d2f489.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Kw1vNHg3SGqKs0A9"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">布拉登·科拉姆在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><p id="a912" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我最近在做一个数字图像处理项目。超参数调整花了相当长的时间，我才得到想要的精度。都是因为过度拟合的寄生虫和我没用的低端硬件。</p><p id="44b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于每次执行，我的机器花费大约15-20分钟。20分钟处理20 000个条目。我想象如果我一直在处理一个100万的记录数据集，我将不得不在训练结束之前等待地球完成一次完整的旋转。</p><p id="f71e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我对模型的准确性感到满意。然而，在提交我的代码之前，我想尝试许多其他的卷积神经网络(CNN)架构。因此，我决定在我的代码中寻找优化空间。</p><p id="cbad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为我使用的是PyPi中预先构建的机器学习算法——Scikit-Learn和tensor flow——只剩下很少的子例程需要优化。一个选择是在数据结构方面提升我的代码。我将数据存储在列表中，由于NumPy非常快，我认为使用它可能是一个可行的选择。</p><p id="3f98" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">猜猜我的列表代码转换成NumPy数组代码后发生了什么？</p><p id="47fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">令我惊讶的是，执行时间没有缩短。相反，它飙升。</p><p id="9390" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">也就是说，在这篇文章中，我将带您了解列表最终比NumPy数组表现更好的确切情况。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="83b1" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">数字和列表</h1><p id="079c" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">首先，让我们讨论NumPy数组和列表之间的区别。</p><p id="9e52" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://numpy.org/" rel="noopener ugc nofollow" target="_blank"> NumPy </a>是用于N维数组操作和计算的事实上的Python库。它是开源的，易于使用，内存友好，速度快如闪电。</p><p id="7777" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">NumPy最初被称为“Numeric”，它为许多数据科学库(如SciPy、Scikit-Learn、Panda等)设置了框架。</p><p id="be9e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Python列表存储有序的、可变的数据对象的集合，而NumPy数组只存储单一类型的对象。因此，我们可以说NumPy数组生活在列表的保护伞下。因此，没有NumPy数组做不到的事情。</p><p id="b854" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，说到NumPy整体。Numpy不仅包括数组操作，还包括许多其他例程，如二元运算、线性代数、数学函数等等。我相信它涵盖了超过一个人可能需要的。</p><p id="eb01" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来要考虑的是为什么我们通常使用NumPy数组而不是列表。</p><p id="9d30" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">简而言之，我相信每个阅读这篇文章的人都知道:它更快。</p><p id="af82" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">NumPy确实快得离谱，尽管Python速度慢是众所周知的。这是因为NumPy是C和Fortran的包装器。而且不用说这两个有多快。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="96db" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">NumPy数组比列表快</h1><p id="6643" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在我们讨论NumPy数组变得像蜗牛一样慢的情况之前，有必要验证NumPy数组通常比列表更快的假设。</p><p id="f0dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为此，我们将使用NumPy和lists来计算一百万个元素数组的平均值。该数组是随机生成的。</p><p id="36bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下代码是一个示例:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="6b59" class="ne md it na b gy nf ng l nh ni">"""General comparison between NumPy and lists"""</span><span id="9a5d" class="ne md it na b gy nj ng l nh ni">import numpy as np<br/>from time import time</span><span id="e567" class="ne md it na b gy nj ng l nh ni">#Random numpy array<br/>numpy_array = np.random.rand(1000000)<br/>list_conv = list(numpy_array)</span><span id="957e" class="ne md it na b gy nj ng l nh ni">#Start timing NumPy compuation<br/>start1 = time()<br/>#Compute the mean using NumPy<br/>numpy_mean = np.mean(numpy_array)<br/>print(f"Computing the mean using NumPy: {numpy_mean}")<br/>#End timing<br/>end1 = time()<br/>#Time taken<br/>time1 = end1 - start1<br/>print(f"Computation time: {time1}")</span><span id="0ff5" class="ne md it na b gy nj ng l nh ni">#Start timing list computation<br/>start2 = time()<br/>#Compute the mean using lists<br/>list_mean = np.mean(list_conv)<br/>print(f"Computing the mean using lists: {list_mean}")<br/>#End timing<br/>end2 = time()<br/>#Time taken<br/>time2 = end2 - start2<br/>print(f"Computation time: {time2}")</span><span id="25f7" class="ne md it na b gy nj ng l nh ni">#Check results are equal<br/>assert abs(numpy_mean - list_mean) &lt;= 10e-6, "Alert, means are not equal"</span></pre><p id="6e45" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我的机器输出如下:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="420c" class="ne md it na b gy nf ng l nh ni">Computing the mean using NumPy: 0.4996098756973947<br/>Computation time: 0.01397562026977539<br/>Computing the mean using lists: 0.4996098756973947<br/>Computation time: 0.17974257469177246</span></pre><p id="8294" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如预测的那样，我们可以看到NumPy数组明显比列表快。相当大的速度差异是显而易见的。</p><p id="9746" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">也就是说，我们能概括地说NumPy数组总是比列表快吗？</p><p id="2b89" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事实证明NumPy数组并不总是超过列表。列表也有锦囊妙计，这就把我们带到了下一个环节。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="c8da" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">NumPy数组并不总是比列表快</h1><p id="cde6" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">如果列表与NumPy数组相比毫无用处，它们可能已经被Python社区抛弃了。</p><p id="1360" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与NumPy数组相比，列表更出色的一个例子是<code class="fe nk nl nm na b">append()</code>函数。"<code class="fe nk nl nm na b">append()</code>"将值添加到列表和NumPy数组的末尾。这是一个常见且经常使用的功能。</p><p id="ae05" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面的脚本演示了列表的<code class="fe nk nl nm na b">append()</code>和NumPy的<code class="fe nk nl nm na b">append()</code>之间的比较。这段代码只是将从0到99 999的数字添加到一个列表和一个NumPy数组的末尾。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="5efe" class="ne md it na b gy nf ng l nh ni">"""numpy.append() vs list.append()"""<br/>import numpy as np<br/>from time import time</span><span id="c092" class="ne md it na b gy nj ng l nh ni">def numpy_append():<br/>    arr = np.empty((1, 0), int)<br/>    for i in range(100000):<br/>        arr = np.append(arr, np.array(i))<br/>    return arr</span><span id="10fe" class="ne md it na b gy nj ng l nh ni">def list_append():<br/>    list_1 = []<br/>    for i in range(100000):<br/>        list_1.append(i)<br/>    return list_1</span><span id="b54e" class="ne md it na b gy nj ng l nh ni">def main ():<br/>    #Start timing numpy array<br/>    start1 = time()<br/>    new_np_arr = numpy_append()<br/>    #End timing<br/>    end1 = time()<br/>    #Time taken<br/>    print(f"Computation time of the numpy array : {end1 - start1}")</span><span id="5383" class="ne md it na b gy nj ng l nh ni">    #Start timing numpy array<br/>    start2 = time()<br/>    new_list = list_append()<br/>    #End timing<br/>    end2 = time()<br/>    #Time taken<br/>    print(f"Computation time of the list: {end2 - start2}")</span><span id="e68e" class="ne md it na b gy nj ng l nh ni">    #Testing<br/>    assert list(new_np_arr) == new_list, "Arrays tested are not the same"</span><span id="915d" class="ne md it na b gy nj ng l nh ni">if __name__ == "__main__":<br/>    main()</span></pre><p id="6569" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我的机器产生以下输出:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="7572" class="ne md it na b gy nf ng l nh ni">Computation time of the numpy array : 2.779465675354004<br/>Computation time of the list: 0.010703325271606445</span></pre><p id="0224" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们所看到的，在这个例子中，列表比NumPy数组表现得更好。Numpy表现差到被超过2000 %的地步。</p><p id="fd09" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个案例表明，无论何时涉及到速度，NumPy都不应该被认为是“总是去”的选项。相反，需要仔细考虑。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="3001" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">Numpy.append有什么问题？</h1><p id="e1c7" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">为了解开这个谜，我们将访问NumPy的源代码。<code class="fe nk nl nm na b">append()</code>函数的<a class="ae ky" href="https://github.com/numpy/numpy/blob/v1.20.0/numpy/lib/function_base.py#L4690-L4745" rel="noopener ugc nofollow" target="_blank"> docstring </a>告知如下内容:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="6913" class="ne md it na b gy nf ng l nh ni">"Append values to the end of an array.</span><span id="15a6" class="ne md it na b gy nj ng l nh ni">    Parameters<br/>    ----------<br/>    arr : array_like<br/>        Values are appended to a copy of this array.<br/>    values : array_like<br/>        These values are appended to a copy of `arr`.  It must be of <br/>        the correct shape (the same shape as `arr`, excluding<br/>        `axis`). If `axis` is not specified, `values` can be any <br/>        shape and will be flattened before use.<br/>    axis : int, optional<br/>        The axis along which `values` are appended.  If `axis` is <br/>        not given, both `arr` and `values` are flattened before use.</span><span id="886d" class="ne md it na b gy nj ng l nh ni">    Returns<br/>    -------<br/>    append : ndarray<br/>        A copy of `arr` with `values` appended to `axis`.  Note that<br/>        `append` does not occur in-place: a new array is allocated<br/>        and filled.  If `axis` is None, `out` is a flattened array."</span></pre><p id="c829" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在彻底阅读了docstring之后，我们可以看到关于函数返回内容的“注释”。它声明追加过程不发生在同一个数组中。而是创建并填充一个新数组。</p><p id="3c03" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，在列表中，事情是非常不同的。列表填充过程停留在列表本身中，不会生成新的列表。</p><p id="5673" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">总之，我们可以看到<code class="fe nk nl nm na b">numpy.append()</code>的复制-填充过程使它成为一个开销。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="bc89" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">外卖食品</h1><p id="f5e9" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">编程没有万金油。</p><p id="0b03" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的发现证明了NumPy阵列并不能解决所有性能问题。在考虑所有选择之前，不应该盲目地采取行动。这样做也最大化了产生设计更好的代码的机会。</p><p id="1670" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，通过实验探索多种途径可以确保人们最终不会后悔做出了不同的选择。更重要的是，实验会发现错误信息。</p><p id="fdf9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，作为对我坚持这一观点的奖励，这里有一段A. Einstein深刻的引用，总结了这篇文章的观点。</p><blockquote class="nn"><p id="4b96" class="no np it bd nq nr ns nt nu nv nw lu dk translated">“再多的实验也无法证明我是对的；一个简单的实验就能证明我是错的。”——阿尔伯特·爱因斯坦。</p></blockquote></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="f6c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你觉得这很有见地，可以考虑成为 <a class="ae ky" href="https://ayarmohammed96.medium.com/membership" rel="noopener"> <em class="nx">高级</em> </a> <em class="nx">会员，每月5美元。如果用这个</em> <a class="ae ky" href="https://ayarmohammed96.medium.com/membership" rel="noopener"> <em class="nx">链接</em> </a> <em class="nx">，我会得到一个小切。</em></p><div class="ny nz gp gr oa ob"><a href="https://ayarmohammed96.medium.com/membership" rel="noopener follow" target="_blank"><div class="oc ab fo"><div class="od ab oe cl cj of"><h2 class="bd iu gy z fp og fr fs oh fu fw is bi translated">通过我的推荐链接加入媒体-穆罕默德·阿亚尔</h2><div class="oi l"><h3 class="bd b gy z fp og fr fs oh fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="oj l"><p class="bd b dl z fp og fr fs oh fu fw dk translated">ayarmohammed96.medium.com</p></div></div><div class="ok l"><div class="ol l om on oo ok op ks ob"/></div></div></a></div><p id="0dbe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nx">享受您的编程日！</em></p></div></div>    
</body>
</html>