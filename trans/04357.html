<html>
<head>
<title>Introspecting Databases with Airflow and SQLAlchemy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Airflow和SQLAlchemy反思数据库</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/introspecting-databases-with-airflow-and-sqlalchemy-6ef18d85acce?source=collection_archive---------16-----------------------#2021-04-13">https://towardsdatascience.com/introspecting-databases-with-airflow-and-sqlalchemy-6ef18d85acce?source=collection_archive---------16-----------------------#2021-04-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="beb6" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">迭代自动自省数据库对象的教程</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/0516dc8068d65057513ef1fe9fd0d6ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*cqbGp5JbC_mfBg8G"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@bukowski?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">pawebukowski</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><p id="10d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在最近一个利用了<a class="ae ky" href="https://airflow.apache.org/" rel="noopener ugc nofollow" target="_blank">气流</a>的数据迁移项目中，我需要连接到一个数据库并自动自省它的模式和表。一个需要内省的数据库有<em class="lv">数百</em>个模式。每个模式都有几十个不同的表，其中大多数都有不同的列和列约束。</p><p id="683c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">换句话说，我们的数据库元数据由成千上万的对象组成，没有人会手动将这些对象输入到配置文件或硬编码的Python列表中。知道了Airflow使用<a class="ae ky" href="https://www.sqlalchemy.org/" rel="noopener ugc nofollow" target="_blank"> SQLAlchemy </a>模块尽可能地用方言和引擎与数据库通信，我有一种预感，我可以利用Airflow与数据库的SQLAlchemy连接来生成模式、表、列或我需要访问的任何数据库对象的列表。</p><p id="e15b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我的预感是对的！SQLAlchemy和<a class="ae ky" href="https://airflow.apache.org/docs/apache-airflow/stable/_api/airflow/hooks/dbapi/index.html" rel="noopener ugc nofollow" target="_blank"> Airflow的DB API钩子</a>使得<a class="ae ky" href="https://airflow.apache.org/docs/apache-airflow/stable/_api/airflow/hooks/dbapi/index.html#airflow.hooks.dbapi.DbApiHook.get_sqlalchemy_engine" rel="noopener ugc nofollow" target="_blank">获得任何连接数据库的SQLAlchemy引擎</a>变得容易。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="3618" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">预赛</h1><p id="0216" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">这个演示需要遵循几个初步步骤。我们将使用PostgreSQL，但几乎任何常见的数据库都可以。</p><h2 id="5c88" class="na me it bd mf nb nc dn mj nd ne dp mn li nf ng mp lm nh ni mr lq nj nk mt nl bi translated">安装气流</h2><p id="7d7c" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">从这里的开始<a class="ae ky" href="https://airflow.apache.org/docs/apache-airflow/stable/start/index.html" rel="noopener ugc nofollow" target="_blank">。用</a><a class="ae ky" href="https://airflow.apache.org/docs/apache-airflow/stable/start/docker.html" rel="noopener ugc nofollow" target="_blank">对接器安装</a>很容易。</p><h2 id="73f6" class="na me it bd mf nb nc dn mj nd ne dp mn li nf ng mp lm nh ni mr lq nj nk mt nl bi translated">创建PostgreSQL数据库</h2><p id="6d5c" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">AWS提供了一个关于如何做的快速指南。如果您愿意，可以用表填充<code class="fe nm nn no np b">public</code>模式(或其他模式),并插入一些数据。(如果已经有了一个填充了可以连接的模式和表的Postgres数据库，可以跳过这一步。)</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="b57c" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">气流设置</h1><p id="b9f8" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">以下步骤可以通过Airflow CLI完成，但web UI简单而漂亮。</p><h2 id="fa43" class="na me it bd mf nb nc dn mj nd ne dp mn li nf ng mp lm nh ni mr lq nj nk mt nl bi translated">运行气流</h2><p id="c38d" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">运行气流调度程序和web服务器。如何运行气流包含在<a class="ae ky" href="https://airflow.apache.org/docs/apache-airflow/stable/start/index.html" rel="noopener ugc nofollow" target="_blank">气流入门教程</a>中。一旦气流开始，将你的浏览器指向网络用户界面。如果您通过Docker或本地安装了Airflow，URL很可能是<code class="fe nm nn no np b">http://localhost:8080/</code>。</p><h2 id="acd2" class="na me it bd mf nb nc dn mj nd ne dp mn li nf ng mp lm nh ni mr lq nj nk mt nl bi translated">创建到Postgres数据库的连接</h2><p id="fccb" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">从web UI的导航栏中，单击<strong class="lb iu">管理</strong> &gt; <strong class="lb iu">连接</strong>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/36bf837093d3d662c083bddf0b41d5d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1156/format:webp/1*UBKacws7FbWOB2WbO52ILQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">通过Airflow web UI创建Postgres数据库连接</p></figure><p id="c302" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">点击蓝色的<strong class="lb iu"> + </strong>按钮添加一个新的连接。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/a7da28cdfe999cc77614c00afc0f39a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1156/format:webp/1*tEr1k0e0eEgKBa9OxCKhjA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">通过Airflow web用户界面添加新连接</p></figure><p id="b6ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输入您的数据库主机连接详情，并点击<strong class="lb iu">保存</strong>按钮。注意:“模式”字段实际上是您想要连接的数据库。我正在使用我的<code class="fe nm nn no np b">dvdrental</code>数据库中现成的<a class="ae ky" href="https://www.postgresqltutorial.com/postgresql-sample-database/" rel="noopener ugc nofollow" target="_blank"> DVD租赁数据</a>。记下您的<strong class="lb iu">连接Id </strong>，因为我们在下一步中需要它。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nr"><img src="../Images/d79a446357f47dd795610fb00a067791.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ne9yiqV8CD67_Igbh5U6zA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">通过Airflow web UI定义您的Postgres数据库连接</p></figure><h1 id="d908" class="md me it bd mf mg ns mi mj mk nt mm mn jz nu ka mp kc nv kd mr kf nw kg mt mu bi translated">创建DAG</h1><p id="2e4a" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">在气流安装过程中创建的<code class="fe nm nn no np b">dags</code>文件夹中，添加一个名为<code class="fe nm nn no np b">introspect_db.py</code>的Python文件。将此DAG代码复制并粘贴到文件中。如果你有<strong class="lb iu"> Conn Id </strong> <code class="fe nm nn no np b">postgres_conn</code>，保持代码不变。否则，更改<code class="fe nm nn no np b">pg_hook</code>分配行以反映您的<strong class="lb iu">连接Id </strong>。</p><pre class="kj kk kl km gt nx np ny nz aw oa bi"><span id="7569" class="na me it np b gy ob oc l od oe">import logging<br/>import re<br/>from typing import List<br/><br/>from airflow import DAG<br/>from airflow.operators.dummy import DummyOperator<br/>from airflow.operators.python import PythonOperator<br/>from airflow.providers.postgres.hooks.postgres import PostgresHook<br/>from airflow.utils.dates import days_ago<br/>from airflow.utils.task_group import TaskGroup<br/><br/>from sqlalchemy.inspection import inspect<br/>from sqlalchemy.engine.reflection import Inspector<br/>from sqlalchemy.engine import Engine<br/><br/><br/>def log_info(info, *args, **kwargs):<br/>    logging.info(f"info={info}")<br/>    logging.info(f"args={args}")<br/>    logging.info(f"kwargs={kwargs}")<br/><br/><br/>default_args = {<br/>    "owner": "airflow",<br/>}<br/><br/>with DAG(<br/>        dag_id="introspect_db",<br/>        default_args=default_args,<br/>        schedule_interval="@once",<br/>        start_date=days_ago(2),<br/>) as dag:</span><span id="3b70" class="na me it np b gy of oc l od oe">    pg_hook = PostgresHook(postgres_conn_id="postgres_conn")<br/>    pg_engine: Engine = pg_hook.get_sqlalchemy_engine()<br/>    pg_inspector: Inspector = inspect(pg_engine)<br/><br/>    schema_names: List[str] = pg_inspector.get_schema_names()<br/><br/>    schema_task_groups: List[TaskGroup] = [<br/>        TaskGroup(group_id=f"{s}") for s in schema_names<br/>    ]<br/><br/>    for schema_tg in schema_task_groups:<br/>        # Ex. of schema_tg.group_id: "public"<br/>        schema_name: str = schema_tg.group_id<br/><br/>        table_names: List[str] = \<br/>            pg_inspector.get_table_names(schema=schema_name)<br/><br/>        table_task_groups: List[TaskGroup] = [<br/>            TaskGroup(group_id=f"{t}", parent_group=schema_tg)<br/>            for t in table_names<br/>        ]<br/><br/>        for table_tg in table_task_groups:<br/>            # Ex. of table_tg.group_id: "public.actor"<br/>            table_name_p = re.compile(r"^\w+\.(\w+)$")<br/>            table_name: str = re.match(<br/>                table_name_p,<br/>                table_tg.group_id<br/>            ).group(1)<br/><br/>            start_table = PythonOperator(<br/>                task_id=f"start_{table_name}",<br/>                task_group=table_tg,<br/>                python_callable=log_info,<br/>                op_kwargs={<br/>                    "info": [<br/>                        f"table_tg.group_id={table_tg.group_id}",<br/>                        f"table_name={table_name}",<br/>                    ]<br/>                }<br/>            )</span><span id="d19c" class="na me it np b gy of oc l od oe">            end_table = DummyOperator(<br/>                task_id=f"end_{table_name}",<br/>                task_group=table_tg<br/>            )</span><span id="5990" class="na me it np b gy of oc l od oe">            start_table &gt;&gt; end_table</span><span id="6378" class="na me it np b gy of oc l od oe">        start_schema = PythonOperator(<br/>            task_id=f"start_{schema_name}",<br/>            task_group=schema_tg,<br/>            python_callable=log_info,<br/>            op_kwargs={<br/>                "info": [<br/>                    f"schema_tg.group_id={schema_tg.group_id}",<br/>                    f"schema_name={schema_name}",<br/>                ]<br/>            }<br/>        )</span><span id="f41e" class="na me it np b gy of oc l od oe">        end_schema = DummyOperator(<br/>            task_id=f"end_{schema_name}",<br/>            task_group=schema_tg<br/>        )<br/><br/>        start_schema &gt;&gt; table_task_groups &gt;&gt; end_schema<br/><br/>    start = DummyOperator(task_id="start")<br/>    end = DummyOperator(task_id="end")<br/><br/>    start &gt;&gt; schema_task_groups &gt;&gt; end</span></pre><p id="4ca2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">DAG代码中有几个片段值得一提。</p><p id="f531" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">片段1。第一个代码片段(如下)说明了如何获取数据库的模式名。首先，使用Postgres连接(如上定义)获得一个Postgres挂钩。这个钩子用于获取SQLAlchemy引擎。反过来，该引擎用于检查连接的数据库中所有模式名称的列表。</p><pre class="kj kk kl km gt nx np ny nz aw oa bi"><span id="7782" class="na me it np b gy ob oc l od oe"># Snippet 1</span><span id="5728" class="na me it np b gy of oc l od oe">pg_hook = PostgresHook(postgres_conn_id="postgres_conn")<br/>pg_engine: Engine = pg_hook.get_sqlalchemy_engine()<br/>pg_inspector: Inspector = inspect(pg_engine)</span><span id="e9a7" class="na me it np b gy of oc l od oe">schema_names: List[str] = pg_inspector.get_schema_names()</span></pre><p id="fef4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">片段2。下一个代码片段演示了如何为每个自省模式创建一个TaskGroup对象列表。我们迭代每个模式TaskGroup对象，从模式TaskGroup的组ID中获取每个模式名称作为字符串，然后在模式中执行某种工作。</p><pre class="kj kk kl km gt nx np ny nz aw oa bi"><span id="4ef8" class="na me it np b gy ob oc l od oe"># Snippet 2</span><span id="81f9" class="na me it np b gy of oc l od oe">schema_task_groups: List[TaskGroup] = [<br/>    TaskGroup(group_id=f"{s}") for s in schema_names<br/>]</span><span id="1ce6" class="na me it np b gy of oc l od oe">for schema_tg in schema_task_groups:<br/>    # Ex. of schema_tg.group_id: "public"<br/>    schema_name: str = schema_tg.group_id</span><span id="767a" class="na me it np b gy of oc l od oe">    ...</span></pre><p id="3d1a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">片段3。在这种情况下，我们在每个模式中所做的“工作”是自省模式的所有表。为了做到这一点，我们采用了与模式相似的方法。然而，这一次我们需要做两件不同的事情。首先，为了创建每个表TaskGroup对象，我们需要将<code class="fe nm nn no np b">schema_tg</code> TaskGroup对象传递给<code class="fe nm nn no np b">parent_group</code>参数。其次，我们需要从表TaskGroup对象的<code class="fe nm nn no np b">group_id</code>中解析出表名。任务组ID的格式是<code class="fe nm nn no np b">&lt;schema&gt;.&lt;table&gt;</code>，所以我使用了<code class="fe nm nn no np b">re</code> regex模块来解析出表名。例如，对于一个表任务组ID为<code class="fe nm nn no np b">public.actor</code>，正则表达式模式<code class="fe nm nn no np b">^\w+\.(\w+)$</code>将允许我们提取任务组ID的<code class="fe nm nn no np b">actor</code>部分。</p><pre class="kj kk kl km gt nx np ny nz aw oa bi"><span id="9311" class="na me it np b gy ob oc l od oe"># Snippet 3</span><span id="6a7e" class="na me it np b gy of oc l od oe">    table_names: List[str] = \<br/>        pg_inspector.get_table_names(schema=schema_name)<br/><br/>    table_task_groups: List[TaskGroup] = [<br/>        TaskGroup(group_id=f"{t}", parent_group=schema_tg)<br/>        for t in table_names<br/>    ]<br/><br/>    for table_tg in table_task_groups:<br/>        # Ex. of table_tg.group_id: "public.actor"<br/>        table_name_p = re.compile(r"^\w+\.(\w+)$")<br/>        table_name: str = re.match(<br/>            table_name_p,<br/>            table_tg.group_id<br/>        ).group(1)</span><span id="bf6f" class="na me it np b gy of oc l od oe">        ...</span></pre><p id="cb17" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">片段4。最后，注意任务依赖是如何定义的。任务对<code class="fe nm nn no np b">start</code>和<code class="fe nm nn no np b">end</code>以及<code class="fe nm nn no np b">start_schema</code>和<code class="fe nm nn no np b">end_schema</code>是单个任务。在每个任务对之间是一个变量，代表一组TaskGroup对象。这类似于用类似于<code class="fe nm nn no np b">task_1 &gt;&gt; [task_2, task_3] &gt;&gt; task_4</code>的列表定义任务依赖关系，因为<code class="fe nm nn no np b">schema_task_groups</code>和<code class="fe nm nn no np b">table_task_groups</code>是TaskGroup对象的<em class="lv">列表</em>。</p><pre class="kj kk kl km gt nx np ny nz aw oa bi"><span id="4cdf" class="na me it np b gy ob oc l od oe"># Snippet 4</span><span id="16e9" class="na me it np b gy of oc l od oe">    start_schema &gt;&gt; table_task_groups &gt;&gt; end_schema</span><span id="4a30" class="na me it np b gy of oc l od oe">    ...</span><span id="db2a" class="na me it np b gy of oc l od oe">start &gt;&gt; schema_task_groups &gt;&gt; end</span></pre><p id="610b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">代码准备好了。现在，我们可以与web用户界面进行交互。</p><h1 id="83fc" class="md me it bd mf mg ns mi mj mk nt mm mn jz nu ka mp kc nv kd mr kf nw kg mt mu bi translated">查看DAG的结构</h1><p id="8fec" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">在<code class="fe nm nn no np b">http://localhost:8080/</code>返回web UI，点击<strong class="lb iu"> introspect_db </strong> DAG链接，然后点击<strong class="lb iu">图形视图</strong>按钮。您应该在web UI中看到模式任务组。</p><p id="5919" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我的看起来像这样。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi og"><img src="../Images/dbc37473e25363875f2e4db49c103bce.png" data-original-src="https://miro.medium.com/v2/resize:fit:908/format:webp/1*YLSLnqLwdNiIYFluF1vv5Q.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图表视图中的方案任务组</p></figure><p id="6951" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">单击其中一个模式任务组将其展开。您应该可以在所选的模式任务组中看到表任务组。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/53c52d6b073724149778dcd4c886449e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1264/format:webp/1*Yv8KV4XC0v_Qe721My_ozA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图表视图中的表任务组</p></figure><p id="eb6a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，单击其中一个表任务组将其展开，您将显示表组中的任务。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/196c3622fa04878dde6f999f8aa374be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PZp2CxSC79L7giGhbydpCg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图表视图中表任务组中的任务</p></figure></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="925f" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">结论</h1><p id="db67" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">在本教程中，我们使用了Airflow中包含的工具来自省数据库的对象，将这些对象反映为嵌套的任务组，并遍历这些对象。您在任何级别上对对象做什么工作都由您决定。我希望这个指南对解决你的类似问题有所帮助。感谢阅读！</p></div></div>    
</body>
</html>