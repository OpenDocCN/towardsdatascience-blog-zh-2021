<html>
<head>
<title>Unmarshalling ERDDAP data into Akka/Scala with Spray</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Spray将ERDDAP数据解组到Akka/Scala中</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/unmarshalling-erddap-data-into-akka-scala-with-spray-bd094bc81a5b?source=collection_archive---------34-----------------------#2021-05-21">https://towardsdatascience.com/unmarshalling-erddap-data-into-akka-scala-with-spray-bd094bc81a5b?source=collection_archive---------34-----------------------#2021-05-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="bb5e" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/hands-on-tutorials" rel="noopener" target="_blank">实践教程</a></h2><div class=""/><div class=""><h2 id="d257" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">科学数据唾手可得。有一种方法可以将它吸收到你的Akka/Scala项目中。</h2></div><p id="ec5e" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated"><a class="ae lk" href="https://coastwatch.pfeg.noaa.gov/erddap/index.html" rel="noopener ugc nofollow" target="_blank"> ERDDAP </a>是NOAA开发的工具，以可扩展的格式提供科学数据集，供公众广泛使用。如果您以前曾经处理过科学数据，您就会知道处理这些数据极具挑战性，因为这些数据格式是为非常特定的科学用途而构建的，具有复杂的要求，例如在多维数组中工作，并且通常是使用Fortran之类的计算机编程语言构建的，这些语言在科学世界之外很少使用。由于像美国宇航局或欧洲核子研究中心这样的长期组织不太可能在一夜之间改变他们的做法，所以ERDDAP是对公众的一种令人惊叹的服务，即使它在美学方面有一点缺乏。它吸收各种常见科学数据格式的数据，并以各种有用的格式提供易于访问的API，以便于使用。许多组织使用ERDDAP来处理和分发他们的数据，以实现开放访问(和其他)的目的。</p><p id="ae5f" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">基于ERDDAP的数据服务中的大多数链接都指向ERDDAP表单，这本身就有点吓人。</p><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="gh gi ll"><img src="../Images/74065701ccc15fe928c89528df47f6b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DT9zGpZi9yfkeNTRt5eStg.png"/></div></div><p class="lx ly gj gh gi lz ma bd b be z dk translated">ERDAP表单——有点难看，但是考虑到您可以从ERDAP服务器提取的数据量，这种难看是可以原谅的。</p></figure><p id="b0f5" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">默认的提交屏幕将为您提供一个html表格。我认为您可以尝试解析它，但是使用原始的JSON数据更有意义。您还可以使用许多其他格式，包括MATLAB二进制文件和netcdfs。要访问json数据，只需更改文件类型。</p><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="gh gi mb"><img src="../Images/8c141dd0ba311fec2ffa02961dc9ca9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s5JXKGf2Oy3vF55ZpyJSUA.png"/></div></div><p class="lx ly gj gh gi lz ma bd b be z dk translated">获取一些好的旧json数据！</p></figure><p id="fb64" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">我们现在将使用普通的JSON，但是我们也将查看。jsonlKVP(键值对流)。如果运行submit，ERDDAP会将json下载到您的计算机上——但是如果您想从服务器或以编程方式访问数据呢？为此，您可以使用“只生成URL”服务。或者，您可以学习<a class="ae lk" href="https://coastwatch.pfeg.noaa.gov/erddap/rest.html#requests" rel="noopener ugc nofollow" target="_blank">erd DAP如何生成URL并完全跳过表单过程。</a></p><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="gh gi mc"><img src="../Images/01402e88e7d0bb1a48b74e7c76ba4563.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aQQtImGWhCAqK9_qbXKzJQ.png"/></div></div><p class="lx ly gj gh gi lz ma bd b be z dk translated">也许根本没有必要使用这个表单。</p></figure><p id="0ba6" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">为了这项工作，我决定从加拿大渔业和海洋部收集数据——这是一个位于加拿大新斯科舍省普尔湾的水温和压力计。的。json输出如下所示:</p><pre class="lm ln lo lp gt md me mf mg aw mh bi"><span id="6449" class="mi mj iq me b gy mk ml l mm mn">{<br/>"table": {<br/>  "columnNames": ["station_name", "time", "water_pressure", "water_temperature", "battery_voltage", "latitude", "longitude"],<br/>  "columnTypes": ["String", "String", "float", "float", "float", "double", "double"],<br/>  "columnUnits": [null, "UTC", "mbar", "degree_C", "V", "degrees_north", "degrees_east"],<br/>  "rows": [<br/>    ["POOLC_20200929", "2020-09-29T15:18:51Z", null, null, 0, 47.679933, -55.43001667],<br/>    ["POOLC_20200929", "2020-09-29T15:18:51Z", null, null, 0, 47.679933, -55.43001667],<br/>    ["POOLC_20200929", "2020-09-29T15:18:51Z", null, null, 0, 47.679933, -55.43001667],</span><span id="68cd" class="mi mj iq me b gy mo ml l mm mn">  [...]</span><span id="163f" class="mi mj iq me b gy mo ml l mm mn">    ["POOLC_20200929", "2020-09-29T16:08:51Z", 83.5167, 14.4, 12.73, 47.679933, -55.42001667]</span><span id="9297" class="mi mj iq me b gy mo ml l mm mn">  [...]<br/>}</span></pre><p id="9273" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">如果你了解Scala，你可能已经心脏病发作了。你看，与更流行的Python不同，Scala非常关心进出程序的数据类型。作为一种强类型语言，它希望确切地知道正在使用什么数据类型。作为一种面向对象的语言，它希望使用类将数据放入对象中。最后，作为一种相当新的基于Java的语言，它会希望尽可能避免空值。</p><p id="dfdb" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">好消息是<a class="ae lk" href="https://github.com/spray/spray-json" rel="noopener ugc nofollow" target="_blank"> Spray </a>被设计成将所有这些数据类型放入漂亮、干净的类java对象中。Spray的另一个优点是它得到了<a class="ae lk" href="https://akka.io/" rel="noopener ugc nofollow" target="_blank"> Akka框架</a>的支持。虽然我不会在这里过多地讨论Akka的内部工作方式，但主要的要点是，使用Akka，您可以构建并发操作的流管道，而不会阻塞分布式系统。因此，如果你想获得所有这些可爱的ERDDAP数据，并通过一个巨大的消防水管快速可靠地发射出去，Akka是一个很好的工作方式。Akka也有一个名为<a class="ae lk" href="https://doc.akka.io/docs/alpakka/current/index.html" rel="noopener ugc nofollow" target="_blank"> Alpakka </a>的姐妹库，它将允许你将这些流与其他服务挂钩，例如与<a class="ae lk" href="https://kafka.apache.org/" rel="noopener ugc nofollow" target="_blank"> Apache Kafka </a>或<a class="ae lk" href="https://aws.amazon.com/kinesis/" rel="noopener ugc nofollow" target="_blank"> Amazon Kinesis流</a>挂钩，与<a class="ae lk" href="https://cassandra.apache.org/" rel="noopener ugc nofollow" target="_blank"> Cassandra </a>或<a class="ae lk" href="https://www.mongodb.com/" rel="noopener ugc nofollow" target="_blank"> MongoDB </a>挂钩，通过像<a class="ae lk" href="https://aws.amazon.com/lambda/" rel="noopener ugc nofollow" target="_blank"> Lambda </a>这样的无服务器应用程序，与像<a class="ae lk" href="https://databricks.com/glossary/what-is-parquet" rel="noopener ugc nofollow" target="_blank"> Parquet </a>这样最新最棒的大数据格式挂钩(这是额尔达普人可能会做的事情)</p><p id="beef" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">但是足够证明Akka，让我们进入编码的过程。我们首先需要一个对象来存储我们所有的类。这需要一些导入。</p><pre class="lm ln lo lp gt md me mf mg aw mh bi"><span id="6414" class="mi mj iq me b gy mk ml l mm mn">import akka.http.scaladsl.marshallers.sprayjson.SprayJsonSupport<br/>import spray.json._<br/>import DefaultJsonProtocol._</span></pre><p id="d526" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">第一次导入允许我们在Akka代码中使用Spray。二是喷json库本身。最后，spray中的<em class="mp"> DefaultJsonProtocol </em>库包含了Json中可以出现的所有基本数据类型如字符串、数组、对象、整型、浮点型等等。</p><p id="a098" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">接下来，我们构建对象并创建一些case类来存储数据。</p><pre class="lm ln lo lp gt md me mf mg aw mh bi"><span id="ee0a" class="mi mj iq me b gy mk ml l mm mn">object erddapConstants extends SprayJsonSupport {<br/>  <br/>  //(implicit val will go here eventually)<br/>  final case class Root(table: Table) // the root class<br/>  final case class Table(<br/>    columnNames: List[String],<br/>    columnTypes: List[String],<br/>    columnUnits: List[Option[String]],<br/>    rows: ???)</span><span id="82f4" class="mi mj iq me b gy mo ml l mm mn">  abstract class ErddapDataFormat {}</span><span id="ce9b" class="mi mj iq me b gy mo ml l mm mn">  final case class<strong class="me ja"> P</strong>oolCoveSensorRow(<br/>    station_name: String,<br/>    time: String,<br/>    water_pressure: Option[Float],<br/>    water_temperature: Option[Float],<br/>    battery_voltage: Float,<br/>    latitude: Double,<br/>    longitude: Double) extends<strong class="me ja"> </strong>ErddapDataFormat</span><span id="41df" class="mi mj iq me b gy mo ml l mm mn">}</span></pre><p id="2d4a" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">该对象扩展了“SprayJsonSupport ”,以确保我们可以将所有可爱的json工具翻译成基于Akka的命令。我们有一个承载所有数据的根类，然后有一个对应于其余可用数据的表类。幸运的是，我们不必创建对象来处理列表特性，因为Spray的DefaultJsonProtocol已经为我们做了这些。我们还通过要求Spray在遇到空数据时创建一个<code class="fe mq mr ms me b">Option[T]</code>来解决我们的<code class="fe mq mr ms me b">null</code>问题。再一次，<code class="fe mq mr ms me b">DefaultJsonProtocol</code>为我们做了繁重的工作。最后，有一个PoolCoveSensorRow case类来处理行数据本身。</p><p id="3a7f" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">然而，我们在弄清楚如何管理这些行时遇到了一个大问题。Spray不支持构建一个值为<code class="fe mq mr ms me b">Any</code>类型的<code class="fe mq mr ms me b">List</code>。此外，spray将无法将列表直接封送到PoolCoveSensorRow类中，因为没有可供Spray用来将行值与case类匹配的键值对。我们将在后面讨论这个问题。</p><p id="1dca" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">首先，我们必须看看spray如何自动获取json，并根据我们的需要将其放入我们的case类中。答案是通过包含隐式值来处理数据。同样，Spray为我们提供了一些jsonFormat函数，帮助我们将json与case类相互转换。我们只需要知道我们的case类有多少个参数。</p><pre class="lm ln lo lp gt md me mf mg aw mh bi"><span id="80c6" class="mi mj iq me b gy mk ml l mm mn">implicit val poolcSensorRowJsonFormat: JsonFormat[<strong class="me ja">P</strong>oolCoveSensorRow] = jsonFormat7(PoolCoveSensorRow)<br/>implicit val rootFormat: RootJsonFormat[Root] = jsonFormat1(Root)<br/>implicit val tableFormat: JsonFormat[Table] = jsonFormat4(Table)</span></pre><p id="92b6" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">现在是最后一部分。我们如何处理这些行？我的第一次尝试尝试使用Spray的自定义格式化代码。为此，您用一个<code class="fe mq mr ms me b">write</code>和一个<code class="fe mq mr ms me b">read</code>方法构建一个隐式对象。大概是这样的:</p><pre class="lm ln lo lp gt md me mf mg aw mh bi"><span id="74d7" class="mi mj iq me b gy mk ml l mm mn">implicit object PoolCoveSensorRowFormat extends RootJsonFormat[PoolCoveSensorRow] {<br/>  // writing is not so important here as you can simply <br/>  // create a JsObject out of the case class.<br/>  // How you want to handle it is up to you.</span><span id="7651" class="mi mj iq me b gy mo ml l mm mn">  def write(item: PoolCoveSensorRow) = {} // do nothing</span><span id="f851" class="mi mj iq me b gy mo ml l mm mn">  def read(json: JsValue) = {<br/>    val jsObject = json.asJsObject<br/>    jsObject.getFields("rows") match {<br/>      case List[List[<strong class="me ja"><em class="mp">???</em></strong>] if (some test) =&gt; <strong class="me ja"><em class="mp">(put List items into           PoolCoveSensorRow object)</em></strong><br/>      case _ =&gt; <strong class="me ja"><em class="mp">(handle error)</em></strong></span><span id="7d8f" class="mi mj iq me b gy mo ml l mm mn">}</span></pre><p id="afb6" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">在尝试了许多可能的格式选项后，我决定采用更简单的方法。我们可以将数据整理成spray的JsValue类型，然后根据需要进行修改，而不是搞乱数据格式。这涉及到更改表case类。</p><pre class="lm ln lo lp gt md me mf mg aw mh bi"><span id="30ef" class="mi mj iq me b gy mk ml l mm mn">final case class Table (columnNames: List[String],<br/>  columnTypes: List[String],<br/>  columnUnits: List[Option[String]]<br/>  rows: List[List[JsValue]) {</span><span id="4f69" class="mi mj iq me b gy mo ml l mm mn">  def poolCoveSensorTest: Boolean = rows(0).length == 7 &amp;&amp; rows(0)(0).convertTo[String] == "POOLC_20200929"</span><span id="1a6d" class="mi mj iq me b gy mo ml l mm mn">  def convertedRows[T &lt;: ErddapDataFormat]: List[T] = rows match {<br/>    case x if poolCoveSensorTest =&gt; rows.map({row: List[JsValue] =&gt;<br/>      PoolCoveSensorRow(<br/>        row(0).convertTo[String],<br/>        row(1).convertTo[String],<br/>        row(2).convertTo[Float],<br/>        (etc)<br/>      )<br/>    case _ =&gt; throw new Exception("Rows did not match any known ErrdapDataSet")})<br/>    }<br/>  }<br/>}</span></pre><p id="1a2d" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">这种方法的一个好处是，您也可以为其他类型的数据创建测试，然后将测试用例包含在convertedRows定义中以进行数据处理。</p><p id="8cde" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">最后，您只需将这个对象导入到另一个类中进行数据摄取。</p><pre class="lm ln lo lp gt md me mf mg aw mh bi"><span id="5b31" class="mi mj iq me b gy mk ml l mm mn"><strong class="me ja">import </strong>akka.NotUsed<br/><strong class="me ja">import </strong>akka.actor.ActorSystem<br/><strong class="me ja">import </strong>akka.http.scaladsl.Http<br/><strong class="me ja">import </strong>akka.stream.scaladsl.{Sink, Source}<br/><strong class="me ja">import </strong>akka.http.scaladsl.model.{DateTime, HttpRequest, HttpResponse}<br/><strong class="me ja">import </strong>java.util.concurrent.ExecutorService<br/><strong class="me ja">import </strong>scala.concurrent.{ExecutionContext, ExecutionContextExecutorService}</span><span id="7f93" class="mi mj iq me b gy mo ml l mm mn">class ProcessErddapData () {<br/>  implicit val system: ActorSystem = ActorSystem()<br/>  val execution: ExecutorService = java.util.concurrent.Executors.newSingleThreadExecutor()<br/>  implicit val ec: ExecutionContextExecutorService = ExecutionContext.fromExecutorService(execution)</span><span id="9121" class="mi mj iq me b gy mo ml l mm mn">  import erddapConstants._</span><span id="3158" class="mi mj iq me b gy mo ml l mm mn">  // Get source from url<br/>  val poolCoveUrl: String = // the url</span><span id="cb94" class="mi mj iq me b gy mo ml l mm mn">  def jsonDataSource(url: String): Future[HttpResponse] = { <br/>    val http = Http(system)<br/>    http.singleRequest(HttpRequest(uri = url)<br/>  }</span><span id="3216" class="mi mj iq me b gy mo ml l mm mn">  val poolCoveData: Source[PoolCoveSensorRow, NotUsed] = {<br/>    val data = jsonDataSource(poolCoveUrl)<br/>      .flatMap(resp =&gt; Unmarshal(resp.entity).to[Root])<br/>      .map(_.table.convertedRows[PoolCoveSensorRow])<br/>    Source.future(data).flatMapConcat(iter =&gt; Source(iter))</span><span id="aee9" class="mi mj iq me b gy mo ml l mm mn">  }</span><span id="11be" class="mi mj iq me b gy mo ml l mm mn">}</span></pre><p id="338a" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">现在，您可以使用<code class="fe mq mr ms me b">poolCoveData</code>值作为流源，以泵入Kafka producer，映射，与其他数据源合并，过滤，并最终运行Akka streams接收器进行输出。</p><p id="1274" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">现在有另一种方法可以用来构建流媒体源。除了在Erddap中使用json格式，还可以使用Jsonl格式，它只是一组由换行符分隔的键值对。看起来是这样的:</p><pre class="lm ln lo lp gt md me mf mg aw mh bi"><span id="2078" class="mi mj iq me b gy mk ml l mm mn">{"station_name":"POOLC_20200929", "time":"2020-09-29T15:18:51Z", "water_pressure":null, "water_temperature":null, "battery_voltage":0, "latitude":47.679933, "longitude":-55.43001667}</span><span id="c277" class="mi mj iq me b gy mo ml l mm mn">{"station_name":"POOLC_20200929", "time":"2020-09-29T15:38:51Z", "water_pressure":null, "water_temperature":null, "battery_voltage":0, "latitude":47.679933, "longitude":-55.43001667}</span><span id="0f2c" class="mi mj iq me b gy mo ml l mm mn">{"station_name":"POOLC_20200929", "time":"2020-09-29T16:18:51Z", "water_pressure":83.5167, "water_temperature":null, "battery_voltage":12.73, "latitude":47.679933, "longitude":-55.43001667}</span><span id="c95b" class="mi mj iq me b gy mo ml l mm mn">[...] and so on...</span></pre><p id="d7af" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">为什么我一直不用这个？活到老学到老！</p><p id="0ff0" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">不用说，使用Akka和spray收集jsonl数据要简单得多，几乎不值得运行教程。当然，缺点是您无权访问列数据类型和单位，并且必须自己决定转换。主要的挑战是，您需要告诉Akka数据是如何构造的——<code class="fe mq mr ms me b">\n</code>定界的(如本例所示)或类似json list的其他东西。</p><pre class="lm ln lo lp gt md me mf mg aw mh bi"><span id="d518" class="mi mj iq me b gy mk ml l mm mn">class ProcessErddapStreamData () {<br/>  // This part is the same as before. Set up your actor system,<br/>  // and the context for your concurrent operations (single thread<br/>  // in this case).</span><span id="dac7" class="mi mj iq me b gy mo ml l mm mn">  implicit val system: ActorSystem = ActorSystem()<br/>  val execution: ExecutorService = java.util.concurrent.Executors.newSingleThreadExecutor()<br/>  implicit val ec: ExecutionContextExecutorService = ExecutionContext.fromExecutorService(execution)</span><span id="0471" class="mi mj iq me b gy mo ml l mm mn">  import erddapConstants._</span><span id="8999" class="mi mj iq me b gy mo ml l mm mn">// Add a Flow to handle the framing of your Json with max size<br/>  val jsonStream: Flow[ByteString, ByteString, NotUsed] = JsonFraming.objectScanner(1000)</span><span id="c292" class="mi mj iq me b gy mo ml l mm mn">  val poolCoveUrl = // the url ending with '.jsonlKVP'</span><span id="5b19" class="mi mj iq me b gy mo ml l mm mn">  def jsonDataSource(url: String) = {<br/>    // You need to fully run the Http request before <br/>    // processing the streams. If you do not, Akka will throw an<br/>    // error to avoid having an http request open too long.</span><span id="022b" class="mi mj iq me b gy mo ml l mm mn">    Http()<br/>      .singleRequest(HttpRequest(uri=url)<br/>      .flatMap(resp =&gt; resp.entity.dataBytes.runReduce(_++_))}</span><span id="944a" class="mi mj iq me b gy mo ml l mm mn">  val poolCoveData = Source.future(jsonDataSource(poolCoveUrl))<br/>      .via(jsonStream)<br/>      .map(_.utf8String.parseJson.convertTo[PoolCoveSensorRow])</span><span id="cbc6" class="mi mj iq me b gy mo ml l mm mn">}</span></pre><p id="7ceb" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">使用JsonFraming类objectScanner方法，既可以标识要使用的分隔值，又可以为数据流设置最大值。因为这里的数据是新行分隔的，并且默认情况下在JsonFraming类中处理，所以除了简单地创建一个流来处理流之外，没有太多事情要做。接下来，您可以使用Spray的<code class="fe mq mr ms me b">.convertTo[Class]</code>方法，轻松地将json对象转换成适当的<code class="fe mq mr ms me b">PoolCoveSensorRow</code>类。</p><p id="825f" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">清理数据从来都不容易，处理不熟悉的数据会带来许多挑战。和往常一样，随着您越来越了解数据源内部的情况以及您的用户希望如何与数据源进行交互，找到一个可行的解决方案并随着时间的推移对其进行改进是没有坏处的。</p><p id="5e4b" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">为学习更多关于数据的知识并找到使用数据的新方法干杯！</p></div></div>    
</body>
</html>