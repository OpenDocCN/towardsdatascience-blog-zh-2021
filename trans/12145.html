<html>
<head>
<title>Raft Algorithm, Explained</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Raft算法，已解释</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/raft-algorithm-explained-a7c856529f40?source=collection_archive---------6-----------------------#2021-12-08">https://towardsdatascience.com/raft-algorithm-explained-a7c856529f40?source=collection_archive---------6-----------------------#2021-12-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="c5b3" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">第1部分—领导人选举</h2></div><h2 id="f1d8" class="kf kg iq bd kh ki kj dn kk kl km dp kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">介绍</h2><p id="924b" class="pw-post-body-paragraph lb lc iq ld b le lf jr lg lh li ju lj ko lk ll lm ks ln lo lp kw lq lr ls lt ij bi translated">Raft是一种共识算法，用于以分布式方式编排副本。Raft的设计考虑到了可理解性，它只有几个可移动的部分，很容易实现。在本文中，我们将探讨Raft的基本组件以及它的领导者选举机制。</p><h2 id="a811" class="kf kg iq bd kh ki kj dn kk kl km dp kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">基本原则</h2><p id="1d3a" class="pw-post-body-paragraph lb lc iq ld b le lf jr lg lh li ju lj ko lk ll lm ks ln lo lp kw lq lr ls lt ij bi translated"><strong class="ld ir">数据流</strong></p><p id="0537" class="pw-post-body-paragraph lb lc iq ld b le lu jr lg lh lv ju lj ko lw ll lm ks lx lo lp kw ly lr ls lt ij bi translated">在最高级别上，Raft基于具有半异步复制策略的单领导架构。要了解更多关于单领导复制的信息，您可以查看<a class="ae lz" rel="noopener" target="_blank" href="/database-replication-explained-5c76a200d8f3">这篇文章</a>。顾名思义，所有的写/读请求都要经过一个领导者，这个领导者再将请求传播给追随者。它等待多数并向客户机返回ACK(图1)</p><figure class="mb mc md me gt mf gh gi paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="gh gi ma"><img src="../Images/d04a559e002b7f04f7187fc45fbcdf82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C5jw9AgxNtot5VzgbrAFCg.png"/></div></div><p class="mm mn gj gh gi mo mp bd b be z dk translated">图一。木筏数据流，作者图</p></figure><p id="c59b" class="pw-post-body-paragraph lb lc iq ld b le lu jr lg lh lv ju lj ko lw ll lm ks lx lo lp kw ly lr ls lt ij bi translated">附带说明一下，Raft是可线性化的(强一致性),因为它由同一个leader处理所有读/写操作。</p><p id="12e3" class="pw-post-body-paragraph lb lc iq ld b le lu jr lg lh lv ju lj ko lw ll lm ks lx lo lp kw ly lr ls lt ij bi translated"><strong class="ld ir">故障转移</strong></p><p id="3a43" class="pw-post-body-paragraph lb lc iq ld b le lu jr lg lh lv ju lj ko lw ll lm ks lx lo lp kw ly lr ls lt ij bi translated">领导者显然是系统中的单点故障，必须实施节点故障转移以确保可用性。在Raft中，这种故障转移被称为领导者选举，我们将在后面详细讨论。总的想法是，当领导者活着且可联系时，它每隔100毫秒(可配置)向所有追随者发送心跳消息。当领导者不可达时(死亡或网络中断)，一些追随者将向同伴发出消息并呼吁选举。</p><figure class="mb mc md me gt mf gh gi paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="gh gi mq"><img src="../Images/23ce92bdc6825d36d19393e38e8ed075.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vl_yaJo-adBVgqhQPvA4Aw.png"/></div></div><p class="mm mn gj gh gi mo mp bd b be z dk translated">图二。领导人选举，按作者分列</p></figure><p id="322c" class="pw-post-body-paragraph lb lc iq ld b le lu jr lg lh lv ju lj ko lw ll lm ks lx lo lp kw ly lr ls lt ij bi translated"><strong class="ld ir"> RPC定义</strong></p><p id="bcb8" class="pw-post-body-paragraph lb lc iq ld b le lu jr lg lh lv ju lj ko lw ll lm ks lx lo lp kw ly lr ls lt ij bi translated">根据上面的描述，Raft服务器之间似乎有许多类型的消息——广播命令、心跳、运行选举、提交日志等。然而，Raft被精心设计，它只使用了<strong class="ld ir">两个</strong>RPC:</p><p id="7b0d" class="pw-post-body-paragraph lb lc iq ld b le lu jr lg lh lv ju lj ko lw ll lm ks lx lo lp kw ly lr ls lt ij bi translated"><strong class="ld ir"> AppendEntry </strong>:这个RPC由领导者发起，携带最新接收到的命令。它也用作心跳消息。当一个追随者收到这个消息，选举计时器被重置。<strong class="ld ir"> AppendEntry </strong>消息是这样的结构(我在这里使用Golang)</p><figure class="mb mc md me gt mf"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="c4b2" class="pw-post-body-paragraph lb lc iq ld b le lu jr lg lh lv ju lj ko lw ll lm ks lx lo lp kw ly lr ls lt ij bi translated"><strong class="ld ir"> RequestVote </strong>:当一个跟随者的选举定时器到时(长时间没有收到AppendEntry，~300ms)，它成为候选人，并调用其他所有节点为自己投票。其他人可以同意或拒绝投票。一旦大多数人同意，候选人就成为领导者。其他候选人回归追随者。</p><figure class="mb mc md me gt mf"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="fc1e" class="pw-post-body-paragraph lb lc iq ld b le lu jr lg lh lv ju lj ko lw ll lm ks lx lo lp kw ly lr ls lt ij bi translated">如果你现在看不到每个字段的用途，那也没关系，但是请记住，对于一个正在工作的Raft服务器来说，这是你所需要的。这篇文章聚焦于领导人选举，这意味着我们将更详细地研究的请求。</p><p id="e979" class="pw-post-body-paragraph lb lc iq ld b le lu jr lg lh lv ju lj ko lw ll lm ks lx lo lp kw ly lr ls lt ij bi translated"><strong class="ld ir">日志</strong></p><p id="96d6" class="pw-post-body-paragraph lb lc iq ld b le lu jr lg lh lv ju lj ko lw ll lm ks lx lo lp kw ly lr ls lt ij bi translated">Raft将来自客户端的命令存储在一个只附加的日志中(保存在磁盘上)。每当接收到一个新命令时(例如，set key = val)，就会将它和当前的术语编号一起添加到日志中(稍后解释)。</p><figure class="mb mc md me gt mf gh gi paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="gh gi mt"><img src="../Images/37babb35fc22ad5e0444342b2b0d5568.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Xw7DCLDx49q1k14duZmxEQ.png"/></div></div><p class="mm mn gj gh gi mo mp bd b be z dk translated">图五。木筏日志，作者图</p></figure><p id="740c" class="pw-post-body-paragraph lb lc iq ld b le lu jr lg lh lv ju lj ko lw ll lm ks lx lo lp kw ly lr ls lt ij bi translated">领导者日志是集群中的唯一权威。如果一个跟随者的日志和领导者的日志有冲突，矛盾会被领导者覆盖。</p><h2 id="584d" class="kf kg iq bd kh ki kj dn kk kl km dp kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">选举详情</h2><p id="10a9" class="pw-post-body-paragraph lb lc iq ld b le lf jr lg lh li ju lj ko lk ll lm ks ln lo lp kw lq lr ls lt ij bi translated">在分布式环境中，有许多可能的场景，其中领导者与其他节点失去联系。可能服务器死了；也许它的信息丢失了。与其分析Raft在每种情况下是如何工作的，不如让我们把自己放到一个追随者节点的角度。</p><p id="03dd" class="pw-post-body-paragraph lb lc iq ld b le lu jr lg lh lv ju lj ko lw ll lm ks lx lo lp kw ly lr ls lt ij bi translated"><strong class="ld ir">选举伪代码</strong></p><p id="efb3" class="pw-post-body-paragraph lb lc iq ld b le lu jr lg lh lv ju lj ko lw ll lm ks lx lo lp kw ly lr ls lt ij bi translated">作为跟随者，节点保持一个选举计时器。如果在给定的时间内rf.hearbeatEvent通道中没有可用的消息，节点转换为候选节点并广播<strong class="ld ir"> RequestVote。</strong><a class="ae lz" href="https://gobyexample.com/select" rel="noopener ugc nofollow" target="_blank">select case</a>文法是一个Golang特性，它阻塞线程，直到通道中有新消息可用。</p><figure class="mb mc md me gt mf"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="8374" class="pw-post-body-paragraph lb lc iq ld b le lu jr lg lh lv ju lj ko lw ll lm ks lx lo lp kw ly lr ls lt ij bi translated"><strong class="ld ir">问题1 —多重选举</strong></p><p id="7150" class="pw-post-body-paragraph lb lc iq ld b le lu jr lg lh lv ju lj ko lw ll lm ks lx lo lp kw ly lr ls lt ij bi translated">在没有任何选举协调的情况下，没有什么可以阻止Raft节点运行多个选举。由于每个节点都为自己投票(通过设计)，因此可能没有一个选举能够获得多数票。在没有任何共识的情况下，节点陷入了一次又一次没有领袖的选举循环中。</p><p id="ddf7" class="pw-post-body-paragraph lb lc iq ld b le lu jr lg lh lv ju lj ko lw ll lm ks lx lo lp kw ly lr ls lt ij bi translated">为了避免并发选举，Raft尝试了一个简单的解决方案——随机化超时，如图6所示。有人可能会说随机化不能解决问题，我同意。这里的关键思想是随机化降低了选举冲突的概率。如果发生分裂投票，我们可以简单地重试，很有可能在下一轮完成。</p><figure class="mb mc md me gt mf"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="d3e0" class="pw-post-body-paragraph lb lc iq ld b le lu jr lg lh lv ju lj ko lw ll lm ks lx lo lp kw ly lr ls lt ij bi translated"><strong class="ld ir">问题2 —多个领导</strong></p><p id="e132" class="pw-post-body-paragraph lb lc iq ld b le lu jr lg lh lv ju lj ko lw ll lm ks lx lo lp kw ly lr ls lt ij bi translated">多个领导者甚至可以存在于一个严格多数票的Raft集群中吗？答案既是肯定的，也是否定的。如果一个领导者(L1)与所有其他节点断开，追随者将进行新的选举，最终选出一个新的领导者(L2)。对L1来说，由于它没有办法探测到L2的存在，它仍然充当着领导者的角色。所以，是的，Raft中可以有多个领导者。</p><p id="fa76" class="pw-post-body-paragraph lb lc iq ld b le lu jr lg lh lv ju lj ko lw ll lm ks lx lo lp kw ly lr ls lt ij bi translated">但是，如果您还记得复制策略—当大多数副本回复<strong class="ld ir"> AppendEntry </strong>调用时的半异步和ACK。如果L1无法达到多数，它将无法处理任何写请求。所以，从当事人的角度来看，L1就像死了一样。所以不，只有一个领导人(L2)可以在服务。</p><p id="147d" class="pw-post-body-paragraph lb lc iq ld b le lu jr lg lh lv ju lj ko lw ll lm ks lx lo lp kw ly lr ls lt ij bi translated"><strong class="ld ir">问题3 —老领导重新加入集群</strong></p><p id="9f75" class="pw-post-body-paragraph lb lc iq ld b le lu jr lg lh lv ju lj ko lw ll lm ks lx lo lp kw ly lr ls lt ij bi translated">现在，如果网络是固定的，而L1突然可以到达所有节点，那会怎么样呢？它对L2政府会有什么反应？这就是<strong class="ld ir"> AppendEntry </strong>和<strong class="ld ir"> RequestVote </strong>中的<strong class="ld ir"> Term </strong>字段发挥作用的地方。</p><p id="40bf" class="pw-post-body-paragraph lb lc iq ld b le lu jr lg lh lv ju lj ko lw ll lm ks lx lo lp kw ly lr ls lt ij bi translated">每个节点都有一个<strong class="ld ir">术语</strong>号，并用它标记所有发出的消息。每当接收到消息时，节点将发送方的<strong class="ld ir">术语</strong>号与其自身的进行比较。如果滞后，接收方自动更新其<strong class="ld ir">术语</strong>。</p><p id="ec10" class="pw-post-body-paragraph lb lc iq ld b le lu jr lg lh lv ju lj ko lw ll lm ks lx lo lp kw ly lr ls lt ij bi translated">当进行新的选举时，候选人将<strong class="ld ir">任期</strong>数增加1。更新的术语将被传播到投票给L2的所有节点，这些节点保证是大多数。现在，如果L1重新加入这个组织，它会发现自己的任期更短了——是时候下台了。</p><figure class="mb mc md me gt mf gh gi paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="gh gi mu"><img src="../Images/4e10cdc5ed90cd3a58776b15ef00540f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-YtqCevFwWqXc3dlUbxMww.png"/></div></div><p class="mm mn gj gh gi mo mp bd b be z dk translated">图8。状态转换，从原来的<a class="ae lz" href="https://raft.github.io/" rel="noopener ugc nofollow" target="_blank">筏纸</a>、</p></figure><p id="2cbd" class="pw-post-body-paragraph lb lc iq ld b le lu jr lg lh lv ju lj ko lw ll lm ks lx lo lp kw ly lr ls lt ij bi translated"><strong class="ld ir">问题4 —落后的候选人</strong></p><p id="6c7d" class="pw-post-body-paragraph lb lc iq ld b le lu jr lg lh lv ju lj ko lw ll lm ks lx lo lp kw ly lr ls lt ij bi translated">到目前为止，我已经忽略了选举的一个关键部分——日志健全性检查。在Raft中，投票是以先到先得的方式进行的。但是，这个简单的逻辑并不能阻止日志过期的节点成为领导者。考虑图9中的场景，其中过时的追随者2成为第一个要求选举的人。</p><figure class="mb mc md me gt mf gh gi paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="gh gi mv"><img src="../Images/c384af3c1a48f7dfe5c8116f23ff9d52.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ej-s67rVVt1NyB04AmBsHA.png"/></div></div><p class="mm mn gj gh gi mo mp bd b be z dk translated">图九。当前投票逻辑的问题，按作者分类</p></figure><p id="b812" class="pw-post-body-paragraph lb lc iq ld b le lu jr lg lh lv ju lj ko lw ll lm ks lx lo lp kw ly lr ls lt ij bi translated">如果投票是先到先得，那么跟随者1将投票给跟随者2。记得领队日志是Raft的唯一权威吗？如果跟随者2成为领导者，最后一个条目(z-=1)将被丢弃！</p><p id="0c65" class="pw-post-body-paragraph lb lc iq ld b le lu jr lg lh lv ju lj ko lw ll lm ks lx lo lp kw ly lr ls lt ij bi translated">为了解决这个问题，Raft实施了额外的选举限制，以确保只有更新日志的候选人才能参加选举。</p><ol class=""><li id="50db" class="mw mx iq ld b le lu lh lv ko my ks mz kw na lt nb nc nd ne bi translated">如果候选人的任期数较低，则拒绝投票(它肯定错过了一些选举)</li><li id="c698" class="mw mx iq ld b le nf lh ng ko nh ks ni kw nj lt nb nc nd ne bi translated">如果候选人的日志没有更新，拒绝投票，如下所示。</li></ol><figure class="mb mc md me gt mf"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="20a2" class="pw-post-body-paragraph lb lc iq ld b le lu jr lg lh lv ju lj ko lw ll lm ks lx lo lp kw ly lr ls lt ij bi translated">由于选举限制，图9中的跟随者2将不会获得跟随者1的投票，因为其日志虽然具有相同的LastTerm，但比跟随者1的日志短。第一次选举后发生的情况是没有领导者被选举，跟随者1将最终超时并赢得选举(跟随者1将投票给它，因为所有标准都满足)。</p><h2 id="14a4" class="kf kg iq bd kh ki kj dn kk kl km dp kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">摘要</h2><p id="85fa" class="pw-post-body-paragraph lb lc iq ld b le lf jr lg lh li ju lj ko lk ll lm ks ln lo lp kw lq lr ls lt ij bi translated">在本文中，我们从一个普通的选举逻辑(先来先服务)开始，并通过考虑各种极端情况，将其发展为成熟的版本。领导者选举中最重要的RPC是<strong class="ld ir"> RequestVote </strong> RPC，它使用一个具有四个字段的结构:</p><ul class=""><li id="507f" class="mw mx iq ld b le lu lh lv ko my ks mz kw na lt nk nc nd ne bi translated"><strong class="ld ir"> Term </strong>:对陈旧领导检测非常重要。没有它，老领导就无法优雅地下台。</li><li id="063a" class="mw mx iq ld b le nf lh ng ko nh ks ni kw nj lt nk nc nd ne bi translated"><strong class="ld ir"> CandidateId </strong>:显示候选人的身份。</li><li id="7047" class="mw mx iq ld b le nf lh ng ko nh ks ni kw nj lt nk nc nd ne bi translated"><strong class="ld ir"> LastLogIndex </strong>:候选人日志的长度，用于实施选举限制。如果候选人的日志很短，就不会赢得选举。</li><li id="abcc" class="mw mx iq ld b le nf lh ng ko nh ks ni kw nj lt nk nc nd ne bi translated"><strong class="ld ir"> LastLogTerm </strong>:最后一个日志条目的期限，用于选举限制。如果任期低，就不会赢得选举。</li></ul><p id="bf2a" class="pw-post-body-paragraph lb lc iq ld b le lu jr lg lh lv ju lj ko lw ll lm ks lx lo lp kw ly lr ls lt ij bi translated">在<a class="ae lz" rel="noopener" target="_blank" href="/raft-algorithm-explained-2-30db4790cdef">的下一篇文章</a>中，我们将探讨Raft如何在领导层变动时保持复制日志的完整和同步。</p></div></div>    
</body>
</html>