<html>
<head>
<title>10 quick Numpy tricks that will make life easier for a data scientist</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让数据科学家的生活更轻松的10个快速数字技巧</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/10-quick-numpy-tricks-that-will-make-life-easier-for-a-data-scientist-35a0253c7479?source=collection_archive---------3-----------------------#2021-06-22">https://towardsdatascience.com/10-quick-numpy-tricks-that-will-make-life-easier-for-a-data-scientist-35a0253c7479?source=collection_archive---------3-----------------------#2021-06-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5984" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解数据科学的基本数字函数</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f61c6c74f76ca53fc7ee34d14cfec26a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3YxyoJVSysFSirtG"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae ky" href="https://unsplash.com/@adityaries?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Aditya Saxena </a>拍摄</p></figure><p id="eca6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Numpy是唯一让我这个铁杆C++程序员首先转向python的东西。请注意，这是在我的数据科学学习曲线出现之前，没有python，任何人都无法生存！(请不要冒犯，只是陈述我的观点，所有的R爱好者，我都一样尊重你们)。但是如果一个库可以改变我对编程语言的忠诚，那么它一定是一个地狱般的库。</p><p id="b97f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我曾经实习过的机器人实验室里，我们曾经就奇怪的Numpy命令互相测验，那时我才真正看到了这个图书馆的美丽。所以，如果你通过了下面的测试，无论如何，你不需要这个博客:p。但除此之外，继续阅读！！</p><p id="f970" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">测试:预测以下内容的输出</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="0972" class="ma mb it lw b gy mc md l me mf">import numpy as np</span><span id="be05" class="ma mb it lw b gy mg md l me mf">arr = np.arange(5)<br/>arr = arr[-1::-1]<br/>print(arr)</span></pre><p id="2624" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你已经知道了这一点，你可能已经知道了我将在这篇博客中讲述的大部分内容，但除此之外，请继续阅读。</p><p id="32d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="mh">输出为[4，3，2，1，0] </em></p><p id="48f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们深入研究Numpy的函数，这些函数是我们的救命稻草，尤其是对我来说，因为我讨厌编写double for循环来访问2D数组。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mi mj l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://gph.is/g/E3lq5qO" rel="noopener ugc nofollow" target="_blank">吉菲</a></p></figure><p id="39ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="mh">注意:在所有未来的例子中，我假设作为np的import numpy已经被调用</em></p><h1 id="aa9b" class="mk mb it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">1.numpy.arange(开始、停止、步进)</h1><p id="1bb8" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">此函数返回一个numpy数组，其中包含从start开始到stop结束并以步长差递增的数字。所以这些数字位于[开始，停止]区间。</p><p id="59dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">举个例子，</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="6078" class="ma mb it lw b gy mc md l me mf"><strong class="lw iu">&gt;&gt;&gt; np.arange(3,7,2)<br/>array([3, 5])</strong></span><span id="bb96" class="ma mb it lw b gy mg md l me mf"><strong class="lw iu">&gt;&gt;&gt; np.arange(5)<br/>array([0,1,2,3,4])</strong></span></pre><p id="1d5a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">类似函数</strong> : <a class="ae ky" href="https://numpy.org/doc/stable/reference/generated/numpy.linspace.html" rel="noopener ugc nofollow" target="_blank"> numpy.linspace </a>，<a class="ae ky" href="https://numpy.org/doc/stable/reference/generated/numpy.repeat.html" rel="noopener ugc nofollow" target="_blank"> numpy.repeat </a>，<a class="ae ky" href="https://numpy.org/doc/stable/reference/generated/numpy.tile.html#numpy.tile" rel="noopener ugc nofollow" target="_blank"> numpy.tile </a>，<a class="ae ky" href="https://numpy.org/devdocs/reference/generated/numpy.eye.html" rel="noopener ugc nofollow" target="_blank"> numpy.eye </a>(是不同的用例，但在处理矩阵时很有帮助)。</p><p id="c5c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想看看定义和初始化数组的其他方法，我在之前的博客<a class="ae ky" rel="noopener" target="_blank" href="/linear-algebra-essentials-for-data-scientist-along-with-implementation-5cfbece6d7ca">这里</a>提到过。</p><h1 id="f69b" class="mk mb it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">2.numpy.random</h1><p id="acda" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">numpy.random是numpy中的一个模块，包含用于生成随机数的函数。它有多种用途，尤其是在处理基于概率的函数时。让我们看看本模块中不同功能的几个示例。当您使用相同的命令时，下面显示的输出会发生变化，因为它们是随机生成的。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="08a7" class="ma mb it lw b gy mc md l me mf"><strong class="lw iu">#Create an array of random numbers, size of array is (3,2)</strong></span><span id="71de" class="ma mb it lw b gy mg md l me mf"><strong class="lw iu">&gt;&gt;&gt; np.random.rand(3,2)<br/>array([[ 0.14022471,  0.96360618],  #random<br/>       [ 0.37601032,  0.25528411],  #random<br/>       [ 0.49313049,  0.94909878]]) #random</strong></span></pre><p id="19c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">点击查看更多示例<a class="ae ky" href="https://numpy.org/doc/stable/reference/random/generated/numpy.random.rand.html" rel="noopener ugc nofollow" target="_blank">。</a></p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="4c74" class="ma mb it lw b gy mc md l me mf"><strong class="lw iu">#Return random integers from <em class="mh">low</em> (inclusive) to <em class="mh">high</em> (exclusive) or 0 (inclusive) to low(exclusive), </strong><strong class="lw iu">random.randint</strong><strong class="lw iu">(<em class="mh">low</em>, <em class="mh">high=None</em>, <em class="mh">size=None</em>, <em class="mh">dtype=int</em>)</strong></span><span id="6a21" class="ma mb it lw b gy mg md l me mf"><strong class="lw iu">&gt;&gt;&gt; np.random.randint(2, size=10)<br/>array([1, 0, 0, 0, 1, 1, 0, 0, 1, 0]) # random<br/>&gt;&gt;&gt; np.random.randint(5)<br/>1</strong></span></pre><p id="659b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">点击查看更多<a class="ae ky" href="https://numpy.org/doc/stable/reference/random/generated/numpy.random.randint.html" rel="noopener ugc nofollow" target="_blank">的例子。</a></p><p id="db4c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">类似功能</strong> : <a class="ae ky" href="https://numpy.org/doc/stable/reference/random/generated/numpy.random.randn.html" rel="noopener ugc nofollow" target="_blank"> numpy.random.randn </a>，<a class="ae ky" href="https://numpy.org/doc/stable/reference/random/generated/numpy.random.random_sample.html" rel="noopener ugc nofollow" target="_blank">numpy . random . sample</a>，<a class="ae ky" href="https://numpy.org/doc/stable/reference/random/generated/numpy.random.choice.html" rel="noopener ugc nofollow" target="_blank"> numpy.random.choice </a>。</p><h1 id="f844" class="mk mb it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">3.numpy.argmax(arr，axis = None)</h1><p id="a738" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">我们的许多用例，尤其是在执行优化时，要求我们知道具有最大值或最小值的变量。为了去掉跟踪这些信息的额外代码行，我们可以简单地使用argmax和argmin的numpy函数。让我们看一个同样的例子。以下示例包含术语轴。数组的轴是我们希望执行计算的方向。如果我们没有指定一个轴，那么默认情况下计算是在整个数组上完成的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/85884f3b5e0e6ef6b16e91c5fb72f54f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1304/format:webp/0*v4ISG1guMG6rz8wb.jpg"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://i.stack.imgur.com/gj5ue.jpg" rel="noopener ugc nofollow" target="_blank">图像参考</a></p></figure><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="bc7f" class="ma mb it lw b gy mc md l me mf"><strong class="lw iu">&gt;&gt;&gt; a = np.array([[10, 12, 11],[13, 14, 10]])<br/>&gt;&gt;&gt; np.argmax(a)<br/>4 #since if the array is flattened, 14 is at the 4th index<br/>&gt;&gt;&gt; np.argmax(a, axis=0)<br/>array([1, 1, 0]) # index of max in each column<br/>&gt;&gt;&gt; np.argmax(a, axis=1)<br/>array([1, 1]) # index of max in each row</strong></span></pre><p id="57a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">类似功能</strong> : <a class="ae ky" href="https://numpy.org/doc/stable/reference/generated/numpy.argmin.html#numpy.argmin" rel="noopener ugc nofollow" target="_blank"> numpy.argmin </a>，<a class="ae ky" href="https://numpy.org/doc/stable/reference/generated/numpy.amax.html#numpy.amax" rel="noopener ugc nofollow" target="_blank"> numpy.amax </a></p><h2 id="8789" class="ma mb it bd ml nh ni dn mp nj nk dp mt li nl nm mv lm nn no mx lq np nq mz nr bi translated">4.切片和索引</h2><p id="6705" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">这在改变NumPy数组的内容时起着至关重要的作用。它用于同时访问数组中的多个元素。举个例子会让你更容易理解它是如何工作的。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="84b8" class="ma mb it lw b gy mc md l me mf"><strong class="lw iu">&gt;&gt;&gt; a = np.arange(5)<br/>&gt;&gt;&gt; print(a[4])<br/>4 # number at index</strong></span><span id="2f4c" class="ma mb it lw b gy mg md l me mf"><strong class="lw iu">&gt;&gt;&gt; print(a[1:])<br/>array([1, 2, 3, 4]) #it will print all element from index 1 to last (including number at index 1)</strong></span><span id="af7c" class="ma mb it lw b gy mg md l me mf"><strong class="lw iu">&gt;&gt;&gt; print(a[:2])<br/>array([0, 1]) #it will print all element from index 0 to index 2(excluding number at index 2)</strong></span><span id="e52e" class="ma mb it lw b gy mg md l me mf"><strong class="lw iu">&gt;&gt;&gt; print(a[1:3])<br/>array([1, 2]) #it will print all element from index 1 (including) to index 3 (excluding)</strong></span><span id="c84b" class="ma mb it lw b gy mg md l me mf"><strong class="lw iu">&gt;&gt;&gt; print(a[0:4:2])<br/>array([0,2]) # [0:4:2] represents start index, stop index, and step respectively. It will start from index 0 (inclusive) go to index 4 (exclusive) in step of 2 which will result in [0, 2] and a[0,2] will be the output.</strong></span></pre><p id="8447" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">切片用于灵活地访问numpy数组的多个索引处的元素。如果使用得当，它可以大大减少代码的长度。</p><p id="5bd2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">回到我在博客开头给出的测试，那里的魔法使用了切片。当我们写arr[-1::-1]时，它实际上从arr的最后一个元素开始，然后第二个-1确保它以步长1的相反顺序进行。因此我们得到了相反的数组。</p><h2 id="ad71" class="ma mb it bd ml nh ni dn mp nj nk dp mt li nl nm mv lm nn no mx lq np nq mz nr bi translated">5.numpy.setdiff1d <strong class="ak"> ( <em class="ns"> ar1 </em>，<em class="ns"> ar2 </em> ) </strong></h2><p id="4e11" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">当我们需要将数组视为集合并寻找它们的差、交或并时，numpy通过这些内置函数使这项工作变得简单。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="af07" class="ma mb it lw b gy mc md l me mf"><strong class="lw iu">#Set difference</strong><br/><strong class="lw iu">&gt;&gt;&gt; a = np.array([1, 2, 3, 2, 4, 1])<br/>&gt;&gt;&gt; b = np.array([3, 4, 5, 6])<br/>&gt;&gt;&gt; np.setdiff1d(a, b)<br/>array([1, 2])</strong></span><span id="d4cf" class="ma mb it lw b gy mg md l me mf"><strong class="lw iu">#Set intersection<br/>&gt;&gt;&gt; np.intersect1d([1, 3, 4, 3], [3, 1, 2, 1])<br/>array([1, 3])</strong></span><span id="e200" class="ma mb it lw b gy mg md l me mf"><strong class="lw iu">#Set Union<br/>&gt;&gt;&gt; np.union1d([-1, 0, 1], [-2, 0, 2])<br/>array([-2, -1,  0,  1,  2])</strong></span></pre><p id="d2ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">类似功能:</strong> <a class="ae ky" href="https://numpy.org/doc/stable/reference/generated/numpy.setxor1d.html" rel="noopener ugc nofollow" target="_blank"> numpy.setxor1d </a>，<a class="ae ky" href="https://numpy.org/doc/stable/reference/generated/numpy.isin.html" rel="noopener ugc nofollow" target="_blank"> numpy.isin </a>。</p><h2 id="7502" class="ma mb it bd ml nh ni dn mp nj nk dp mt li nl nm mv lm nn no mx lq np nq mz nr bi translated">6.numpy . shape<strong class="ak">(<em class="ns">a</em>，<em class="ns"> newshape </em>，<em class="ns"> order='C' </em> ) </strong></h2><p id="6431" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">在处理矩阵时，我们需要适当的维数来进行乘法等运算。或者甚至在处理复杂数据时，我不得不无数次地改变数组的形状。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="9718" class="ma mb it lw b gy mc md l me mf"><strong class="lw iu">&gt;&gt;&gt; a = np.arange(6).reshape((3, 2))<br/>&gt;&gt;&gt; a<br/>array([[0, 1],<br/>       [2, 3],<br/>       [4, 5]])<br/>&gt;&gt;&gt; np.reshape(a, (2, 3)) <em class="mh"># C-like index ordering</em><br/>array([[0, 1, 2],<br/>       [3, 4, 5]])<br/>&gt;&gt;&gt; np.reshape(a, (2, 3), order='F') <em class="mh"># Fortran-like index ordering</em><br/>array([[0, 4, 3],<br/>       [2, 1, 5]])</strong></span></pre><p id="87e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">点击查看更多例子。(我强烈建议阅读所有示例)</p><p id="305d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">类似功能:</strong> <a class="ae ky" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.flatten.html" rel="noopener ugc nofollow" target="_blank"> ndarray.flatten </a>，<a class="ae ky" href="https://numpy.org/doc/stable/reference/generated/numpy.ravel.html" rel="noopener ugc nofollow" target="_blank"> numpy.ravel </a>。这两种方法都可以将任意数组转换成1D数组，但是两者之间有细微的差别。此外，像<a class="ae ky" href="https://numpy.org/doc/stable/reference/generated/numpy.squeeze.html" rel="noopener ugc nofollow" target="_blank"> numpy.squeeze </a>和numpy.unsqueeze这样的函数用于在数组中删除或添加一个维度。</p><h2 id="f691" class="ma mb it bd ml nh ni dn mp nj nk dp mt li nl nm mv lm nn no mx lq np nq mz nr bi translated">7.numpy.where( <strong class="ak"> <em class="ns">条件</em> [，<em class="ns"> x </em>，<em class="ns"> y </em> ] </strong>)</h2><p id="2f7d" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">帮助我们根据输入到函数中的一些条件提取子数组。这里如果条件满足，则选择<em class="mh"> x </em>，否则选择<em class="mh"> y </em>。让我们看一些例子来了解更多</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="ff5d" class="ma mb it lw b gy mc md l me mf"><strong class="lw iu">&gt;&gt;&gt; np.where([[True, False], [True, True]],<br/>...          [[1, 2], [3, 4]], #x<br/>...          [[9, 8], [7, 6]]) #y<br/>#Here since the second element in first row was false the output contained the element from the second array at that index. </strong></span><span id="e794" class="ma mb it lw b gy mg md l me mf"><strong class="lw iu">&gt;&gt;&gt; a = np.arange(10)<br/>&gt;&gt;&gt; a<br/>array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])<br/>&gt;&gt;&gt; np.where(a &lt; 5, a, 10*a)<br/>array([ 0,  1,  2,  3,  4, 50, 60, 70, 80, 90])</strong></span></pre><p id="399e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">类似功能</strong> : <a class="ae ky" href="https://numpy.org/doc/stable/reference/generated/numpy.choose.html#numpy.choose" rel="noopener ugc nofollow" target="_blank"> np.choose </a>，<a class="ae ky" href="https://numpy.org/doc/stable/reference/generated/numpy.nonzero.html#numpy.nonzero" rel="noopener ugc nofollow" target="_blank"> np .非零</a></p><h2 id="7360" class="ma mb it bd ml nh ni dn mp nj nk dp mt li nl nm mv lm nn no mx lq np nq mz nr bi translated">8.numpy . concatenate(<strong class="ak"><em class="ns">(a1</em>、<em class="ns"> a2 </em>、<em class="ns">……)</em>、<em class="ns"> axis=0 </em> </strong>)</h2><p id="66ba" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">该函数有助于沿现有轴连接数组。当我们预处理数据并需要多次追加或组合数据时，这是有益的。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="6981" class="ma mb it lw b gy mc md l me mf"><strong class="lw iu">&gt;&gt;&gt; a = np.array([[1, 2], [3, 4]])<br/>&gt;&gt;&gt; b = np.array([[5, 6]])<br/>&gt;&gt;&gt; np.concatenate((a, b), axis=0)<br/>array([[1, 2],<br/>       [3, 4],<br/>       [5, 6]])<br/>&gt;&gt;&gt; np.concatenate((a, b.T), axis=1)<br/>array([[1, 2, 5],<br/>       [3, 4, 6]])<br/>&gt;&gt;&gt; np.concatenate((a, b), axis=None)<br/>array([1, 2, 3, 4, 5, 6])</strong></span></pre><p id="b9e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">类似功能:</strong> <a class="ae ky" href="https://numpy.org/doc/stable/reference/generated/numpy.array_split.html#numpy.array_split" rel="noopener ugc nofollow" target="_blank"> numpy.array_split </a>，<a class="ae ky" href="https://numpy.org/doc/stable/reference/generated/numpy.ma.concatenate.html#numpy.ma.concatenate" rel="noopener ugc nofollow" target="_blank"> numpy.ma.concatenate </a>，<a class="ae ky" href="https://numpy.org/doc/stable/reference/generated/numpy.split.html#numpy.split" rel="noopener ugc nofollow" target="_blank"> numpy.split </a>，numpy.hsplit，numpy.vsplit，numpy.dsplit，<a class="ae ky" href="https://numpy.org/doc/stable/reference/generated/numpy.hstack.html" rel="noopener ugc nofollow" target="_blank"> numpy.hstack </a></p><h2 id="3938" class="ma mb it bd ml nh ni dn mp nj nk dp mt li nl nm mv lm nn no mx lq np nq mz nr bi translated">9.numpy.power( <strong class="ak"> <em class="ns"> x1 </em>，<em class="ns"> x2) </em> </strong></h2><p id="fda3" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">我无法告诉你这个功能给我的生活带来了多大的便利。它帮助我取代了所有用来写一个数组的平方或立方的循环。该函数输出一个数组，该数组包含第一个数组的元素的自乘幂，从第二个数组开始，按元素排序。让我给你举个例子来说明一下。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="0adb" class="ma mb it lw b gy mc md l me mf"><strong class="lw iu">&gt;&gt;&gt; x1 = np.arange(6)<br/>&gt;&gt;&gt; x1<br/>[0, 1, 2, 3, 4, 5]<br/>&gt;&gt;&gt; np.power(x1, 3)<br/>array([  0,   1,   8,  27,  64, 125])<br/>&gt;&gt;&gt; x2 = [1.0, 2.0, 3.0, 3.0, 2.0, 1.0]<br/>&gt;&gt;&gt; np.power(x1, x2)<br/>array([  0.,   1.,   8.,  27.,  16.,   5.])<br/>&gt;&gt;&gt; x2 = np.array([[1, 2, 3, 3, 2, 1], [1, 2, 3, 3, 2, 1]])<br/>&gt;&gt;&gt; x2<br/>array([[1, 2, 3, 3, 2, 1],<br/>       [1, 2, 3, 3, 2, 1]])<br/>&gt;&gt;&gt; np.power(x1, x2)<br/>array([[ 0,  1,  8, 27, 16,  5],<br/>       [ 0,  1,  8, 27, 16,  5]])</strong></span></pre><p id="1dde" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在ndarrays上，<code class="fe nt nu nv lw b">**</code>操作符可以用作<code class="fe nt nu nv lw b">np.power</code>的简写。</p><p id="4765" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">相似函数:</strong>所有的基本数学运算符。你可以在这里查看它们。</p><h2 id="4ac3" class="ma mb it bd ml nh ni dn mp nj nk dp mt li nl nm mv lm nn no mx lq np nq mz nr bi translated">10.numpy.allclose(a，b，rtol=1e-5，atol=1e-8)</h2><p id="5377" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">allclose用于确定两个数组在某个容差范围内的元素是否相等。公差值是正数，并且是一个小数字。计算为(<em class="mh"> rtol </em> * abs( <em class="mh"> b </em>))和<em class="mh"> atol之和。</em>a和b之间的元素绝对差值应小于计算的公差<em class="mh">。</em></p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="7724" class="ma mb it lw b gy mc md l me mf"><strong class="lw iu">&gt;&gt;&gt; np.allclose([1e10,1e-7], [1.00001e10,1e-8])<br/>False<br/>&gt;&gt;&gt; np.allclose([1e10,1e-8], [1.00001e10,1e-9])<br/>True</strong></span></pre><p id="deb1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事实证明，在比较包含来自两个不同模型的预测值的两个数组时，这非常有用。</p><p id="7803" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">类似功能:</strong> <a class="ae ky" href="https://numpy.org/doc/stable/reference/generated/numpy.isclose.html#numpy.isclose" rel="noopener ugc nofollow" target="_blank"> numpy.isclose </a>，<a class="ae ky" href="https://numpy.org/doc/stable/reference/generated/numpy.all.html#numpy.all" rel="noopener ugc nofollow" target="_blank"> numpy.all </a>，<a class="ae ky" href="https://numpy.org/doc/stable/reference/generated/numpy.any.html#numpy.any" rel="noopener ugc nofollow" target="_blank"> numpy.any </a>，<a class="ae ky" href="https://numpy.org/doc/stable/reference/generated/numpy.equal.html#numpy.equal" rel="noopener ugc nofollow" target="_blank"> numpy.equal </a></p></div><div class="ab cl nw nx hx ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="im in io ip iq"><p id="83d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我很高兴现在证明你是Numpy的主人！！</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od mj l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://gph.is/g/EGRVvKJ" rel="noopener ugc nofollow" target="_blank">吉菲</a></p></figure><p id="b51e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尝试这些，你很快就会成为一名数据科学家大师！万事如意。</p><p id="2fde" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">更多此类内容，请关注我们的<a class="ae ky" href="https://medium.com/@AnveeNaik" rel="noopener">媒体</a>。请在评论中告诉我们你想了解更多的话题，我们会尝试就这些话题写博客。</p><p id="75a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="mh">成为</em> <a class="ae ky" href="https://medium.com/@AnveeNaik/membership" rel="noopener"> <em class="mh">介质会员</em> </a> <em class="mh">解锁并阅读介质上的许多其他故事。</em></p></div></div>    
</body>
</html>