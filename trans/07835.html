<html>
<head>
<title>Do Not Use Python Lists For All Purposes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">不要将Python列表用于任何目的</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/do-not-use-python-lists-for-all-purposes-8d52f7df5ab2?source=collection_archive---------13-----------------------#2021-07-18">https://towardsdatascience.com/do-not-use-python-lists-for-all-purposes-8d52f7df5ab2?source=collection_archive---------13-----------------------#2021-07-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/ca0ff7e6aa3b6f7d9fd4064a28fdaea9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IcJEeRw1dtZChNvfVmgTgw.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">图片来自<a class="ae jg" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=4567915" rel="noopener ugc nofollow" target="_blank"> Pixabay </a></p></figure><div class=""/><div class=""><h2 id="33a3" class="pw-subtitle-paragraph kg ji jj bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dk translated">用itertools实现iterables的5个Python技巧</h2></div><p id="2a34" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">列表类型无疑是Python中最流行的容器对象类型。在某种程度上，它甚至可以被认为是Python的“灵魂”,因为它有许多Python的标志性语法，比如切片和列表理解。</p><p id="93b2" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是，它太方便了，很多开发者都习惯了。通常，除了List，Python中还有许多类型的iterables和容器类型。</p><p id="f068" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在本文中，我将介绍Python内置的“Itertools”模块中的5个技巧。它使我们能够以5种奇特的方式操纵任何Python可迭代对象。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><p id="c69c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">本文中的所有函数都来自itertools模块。因此，所有示例代码都假设函数已经从模块中导入，如下所示。</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="a2fe" class="mk ml jj mg b gy mm mn l mo mp">from itertools import *</span></pre><h1 id="7f1a" class="mq ml jj bd mr ms mt mu mv mw mx my mz kp na kq nb ks nc kt nd kv ne kw nf ng bi translated">1.链-组合任何容器</h1><figure class="mb mc md me gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/2c28f61b08ebc7ce0ed026edf9e84eac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E1ioMvhxv605YxHpN1agnQ.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">来自<a class="ae jg" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=3481377" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>的<a class="ae jg" href="https://pixabay.com/users/analogicus-8164369/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=3481377" rel="noopener ugc nofollow" target="_blank">模拟图像</a></p></figure><p id="0ad8" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">假设你有两个列表，你想一个接一个的循环。最直观的解决方案可能是将它们组合成一个列表，并将该列表放入一个for循环中。</p><p id="edae" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里有两个带有名称的示例列表。假设我们想打印这些列表中的所有名字。</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="9260" class="mk ml jj mg b gy mm mn l mo mp">my_list_1 = ['Alice', 'Bob', 'Chris']<br/>my_list_2 = ['David', 'Emily','Frank']</span><span id="58d5" class="mk ml jj mg b gy nh mn l mo mp">for name in my_list_1 + my_list_2:<br/>    print('Name: ', name)</span></pre><figure class="mb mc md me gt iv gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/9c917c8a07994aceb4fafc97fc531693.png" data-original-src="https://miro.medium.com/v2/resize:fit:786/format:webp/1*A2q1YnQyNWnESGsZcvgvdQ.png"/></div></figure><p id="e9ac" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当然，这样做是没有问题的。它又快又简单。更重要的是，可读性很强。但是，如果我们在不同类型的容器中有这些名称，那该怎么办呢？Python中典型的可重复项可能包括</p><ul class=""><li id="5d5c" class="nj nk jj la b lb lc le lf lh nl ll nm lp nn lt no np nq nr bi translated"><strong class="la jk">列表</strong></li></ul><p id="6237" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe ns nt nu mg b">my_list = [‘Alice’, ‘Bob’]</code></p><ul class=""><li id="4147" class="nj nk jj la b lb lc le lf lh nl ll nm lp nn lt no np nq nr bi translated"><strong class="la jk">元组</strong></li></ul><p id="f05b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe ns nt nu mg b">my_tuple = (‘Chris’, ‘David’)</code></p><ul class=""><li id="e0d8" class="nj nk jj la b lb lc le lf lh nl ll nm lp nn lt no np nq nr bi translated"><strong class="la jk">字典</strong></li></ul><p id="60d6" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe ns nt nu mg b">my_dictionary = {‘name’: ‘Emily’}</code></p><ul class=""><li id="bfce" class="nj nk jj la b lb lc le lf lh nl ll nm lp nn lt no np nq nr bi translated"><strong class="la jk">设定</strong></li></ul><p id="3310" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe ns nt nu mg b">my_set = {‘Frank’, ‘Grace’}</code></p><ul class=""><li id="bb37" class="nj nk jj la b lb lc le lf lh nl ll nm lp nn lt no np nq nr bi translated"><strong class="la jk">发电机</strong></li></ul><p id="ea41" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe ns nt nu mg b">my_generator = (name for name in [‘Helen’, ‘Isaac’])</code></p><p id="6ee1" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">是不是应该把所有的“非列表”对象都转换成列表，然后再组合起来？答案当然是没有，没有必要。我们可以简单地使用itertools模块中的<code class="fe ns nt nu mg b">chain()</code>函数。</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="a86f" class="mk ml jj mg b gy mm mn l mo mp">my_chain = chain(<br/>    my_list, <br/>    my_tuple, <br/>    my_dictionary.values(), <br/>    my_set, <br/>    my_generator<br/>)</span><span id="343b" class="mk ml jj mg b gy nh mn l mo mp">for name in my_chain:<br/>    print('Name: ', name)</span></pre><figure class="mb mc md me gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nv"><img src="../Images/930695b308e7acc80e157dd4666af0f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:986/format:webp/1*G-RJ1GB8UxF70ulMjtpoPA.png"/></div></div></figure><h1 id="98e2" class="mq ml jj bd mr ms mt mu mv mw mx my mz kp na kq nb ks nc kt nd kv ne kw nf ng bi translated">2.星图——对每个元素应用函数</h1><figure class="mb mc md me gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/1b7bc2670a1a0ed16e17dccecb9d551c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XTxOvv2vflHhOC_s1kxPpw.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">图片来自<a class="ae jg" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=828656" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>的<a class="ae jg" href="https://pixabay.com/photos/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=828656" rel="noopener ugc nofollow" target="_blank">免费照片</a></p></figure><p id="d53d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你有没有想过将一个函数应用到一个容器中的所有对象，并在一个容器中得到结果？<code class="fe ns nt nu mg b">starmap()</code>函数可以帮助我们实现这一点。</p><p id="f300" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了简化演示，让我们使用一个现有的函数<code class="fe ns nt nu mg b">pow</code>，它只是计算一个数的幂。我们将函数名作为第一个参数，将iterable作为第二个参数。</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="55fa" class="mk ml jj mg b gy mm mn l mo mp">result = starmap(pow, [(2,2), (3,2), (4,2), (5,2)])</span></pre><figure class="mb mc md me gt iv gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/64d5e08351c35ad486b6f7fbadce90ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:974/format:webp/1*K_8ET4VbN5X3G-boALkS8w.png"/></div></figure><p id="204e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我们想使用定制功能呢？只需定义它并将函数名作为第一个参数传递。如果函数足够简单，您还可以定义一个匿名函数，如下所示。</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="bea2" class="mk ml jj mg b gy mm mn l mo mp">result = starmap(<br/>    lambda x, y: pow(x, y), <br/>    [(2,2), (3,2), (4,2), (5,2)]<br/>)</span></pre><figure class="mb mc md me gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nx"><img src="../Images/d724c469e902b82bdf71fc8f88b6b6f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:658/format:webp/1*e_ciw9kGY7XXij4SPTh7OQ.png"/></div></div></figure><h1 id="c16c" class="mq ml jj bd mr ms mt mu mv mw mx my mz kp na kq nb ks nc kt nd kv ne kw nf ng bi translated">3.压缩—使用遮罩过滤可重复项</h1><figure class="mb mc md me gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/840def52517a10ce9f4526439fba0549.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z7HNlusb2Gyc4NqZW5NEOA.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">图片由<a class="ae jg" href="https://pixabay.com/users/yamsri-785809/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=2422421" rel="noopener ugc nofollow" target="_blank"> Klittika Suwanjaruen </a>从<a class="ae jg" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=2422421" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>拍摄</p></figure><p id="d536" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您曾经使用Pandas来转换一些数据帧，您一定知道我们可以传递一个具有真或假值的“系列”作为“掩码”来过滤另一个系列或数据帧。</p><p id="a7e8" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">事实上，我们可以使用<code class="fe ns nt nu mg b">compress()</code>函数在任何iterables上复制这个特性。请参见下面的示例。</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="b56d" class="mk ml jj mg b gy mm mn l mo mp">compress(<br/>    ['Alice', 'Bob', 'Chris', 'David'], <br/>    [True, False, True, False]<br/>)</span></pre><figure class="mb mc md me gt iv gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/9ac92825ddb51a710135650c85e5987a.png" data-original-src="https://miro.medium.com/v2/resize:fit:774/format:webp/1*MUC4Rhu_M7--8ne7TihCeg.png"/></div></figure><p id="b5c6" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">第一个列表包含4个名称，第二个列表包含4个布尔值。第二个列表将用于过滤第一个列表，以便只保留具有“真”值的位置。</p><p id="dd9d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以一起使用多个itertools函数来实现一些更好的东西。假设我们有一些名字和句子。</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="b8b1" class="mk ml jj mg b gy mm mn l mo mp">names = ['Alice', 'Chris']<br/>sentences = ['I am Chris', 'Alice and Chris', 'I am Alice']</span></pre><p id="b1f7" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，我们要找出句子包含名字的所有“名字，句子”对。</p><p id="2d41" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以首先使用<code class="fe ns nt nu mg b">product()</code>函数来生成所有的可能性。</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="e17b" class="mk ml jj mg b gy mm mn l mo mp">product(names, sentences)</span></pre><figure class="mb mc md me gt iv gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/0ac1b13bb7be831a4c6f356fd1d24aa7.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/format:webp/1*Uf8dN_Eg5ZtNgOPD57-xdA.png"/></div></figure><p id="2476" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后，我们可以为<code class="fe ns nt nu mg b">compress()</code>函数生成“掩码”。我们想定义一个函数来测试每一对。所以，我们可以在这里使用<code class="fe ns nt nu mg b">starmap()</code>函数。</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="26bd" class="mk ml jj mg b gy mm mn l mo mp">matched_mask = starmap(<br/>    lambda name, sentence: (name in sentence),<br/>    product(names, sentences)<br/>)</span></pre><figure class="mb mc md me gt iv gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/cbdacf4c07e334182af4182e8456317e.png" data-original-src="https://miro.medium.com/v2/resize:fit:888/format:webp/1*yITu0jiTgJ83Tp1zzKG8jg.png"/></div></figure><p id="81b3" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后，我们可以使用<code class="fe ns nt nu mg b">compress()</code>函数来过滤由<code class="fe ns nt nu mg b">product()</code>函数生成的列表。</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="b3e1" class="mk ml jj mg b gy mm mn l mo mp">compress(product(names, sentences), matched_mask)</span></pre><figure class="mb mc md me gt iv gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/04193d7d3e3f57d3a2d8f563e10f693b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1112/format:webp/1*WN0AnPMccf78GHc6x3azOw.png"/></div></figure><h1 id="1f31" class="mq ml jj bd mr ms mt mu mv mw mx my mz kp na kq nb ks nc kt nd kv ne kw nf ng bi translated">4.Dropwhile、Takewhile和Filterfalse —过滤具有特定行为的可重复项</h1><figure class="mb mc md me gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/1eb78a403597151d91ea068ddd27d26f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pKM6s9vVtjJ1orBOFmbicg.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">图片来自<a class="ae jg" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=471166" rel="noopener ugc nofollow" target="_blank"> Pixabay </a></p></figure><p id="d353" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">基于某些条件进行筛选相对容易。但是，有时候条件并不是全部因素。例如，还需要考虑iterable中元素的位置和顺序。</p><p id="4d8f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">假设我每天每3个小时检查一次自己的当前状态。</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="c8bc" class="mk ml jj mg b gy mm mn l mo mp">checkpoints = {<br/>    '00:00': 'sleeping',<br/>    '03:00': 'sleeping',<br/>    '06:00': 'wake up',<br/>    '09:00': 'working',<br/>    '12:00': 'sleeping',<br/>    '15:00': 'working',<br/>    '18:00': 'eating',<br/>    '21:00': 'entertaining',<br/>    '23:00': 'sleeping'<br/>}</span></pre><p id="3005" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，我想在这一天生成一个日历。包括我醒来之前的状态没有意义。所以，排除睡眠状态会更好。然而，我在午餐时间睡了一会儿，我不想排除它。</p><p id="1949" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">通常，要实现这一点需要多个条件。但是使用<code class="fe ns nt nu mg b">dropwhile()</code>函数，我们可以简单地做以下事情。</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="5e61" class="mk ml jj mg b gy mm mn l mo mp">my_calendar = dropwhile(<br/>    lambda item: item[1] == 'sleeping',<br/>    checkpoints.items()<br/>)</span></pre><figure class="mb mc md me gt iv gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/4fbfbe9057175e0af3d7f7460de69fa9.png" data-original-src="https://miro.medium.com/v2/resize:fit:776/format:webp/1*W3zqKSdxkaCcvHIWKy1wIw.png"/></div></figure><p id="59c0" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们只需要一个条件，即测试状态是否为“睡眠”。如果是，就“放弃”它。函数<code class="fe ns nt nu mg b">dropwhile()</code>的特点是，一旦它遇到第一个不满足条件的元素，它将停止在iterable中丢弃任何东西。换句话说，即使更多的元素满足条件，它们也不会被丢弃。</p><p id="9bb6" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我们想放弃所有的“睡眠”状态呢？我们可以使用<code class="fe ns nt nu mg b">filterfalse()</code>功能。</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="18c9" class="mk ml jj mg b gy mm mn l mo mp">my_calendar = filterfalse(<br/>    lambda item: item[1] == 'sleeping',<br/>    checkpoints.items()<br/>)</span></pre><figure class="mb mc md me gt iv gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/a36ed4c1be78c65f3cee6db25a2f23dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:786/format:webp/1*n7niY3A6EfOMjO_Y4vl_OQ.png"/></div></figure><p id="cae1" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">与<code class="fe ns nt nu mg b">dropwhile()</code>函数相反，<code class="fe ns nt nu mg b">takewhile()</code>函数将保留满足谓词的任何元素。然而，由于第一个元素不满足谓词，所有其余的都将被删除。</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="7fe1" class="mk ml jj mg b gy mm mn l mo mp">my_calendar = takewhile(<br/>    lambda item: item[1] == 'sleeping',<br/>    checkpoints.items()<br/>)</span></pre><figure class="mb mc md me gt iv gh gi paragraph-image"><div class="gh gi od"><img src="../Images/c74e73be79484ba4acc05ad251dea09e.png" data-original-src="https://miro.medium.com/v2/resize:fit:884/format:webp/1*FV47Akxe6EoaEAKLtbwxyQ.png"/></div></figure><p id="6e23" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe ns nt nu mg b">takewhile()</code>功能可视为<code class="fe ns nt nu mg b">dropwhile()</code>功能的反义词。</p><h1 id="dc74" class="mq ml jj bd mr ms mt mu mv mw mx my mz kp na kq nb ks nc kt nd kv ne kw nf ng bi translated">5.is lice——用步骤对可重复项切片</h1><figure class="mb mc md me gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/126e37c8040def48448cb7761e843a6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-t9SzRBbH1SK7PpFRu5q4A.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">来自<a class="ae jg" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=636562" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>的<a class="ae jg" href="https://pixabay.com/users/security-535773/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=636562" rel="noopener ugc nofollow" target="_blank">安全</a>图片</p></figure><p id="77f6" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Python列表可以很容易地切片。这是最Pythonic化的语法之一。假设我们有一个如下的列表。</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="17bd" class="mk ml jj mg b gy mm mn l mo mp">my_list = ['a', 'b', 'c', 'd', 'e', 'f']</span></pre><p id="0a75" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我们可以得到从第三个开始并在第五个停止的元素，我们可以做以下事情。</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="b340" class="mk ml jj mg b gy mm mn l mo mp">my_list[2:5]</span></pre><figure class="mb mc md me gt iv gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/527988e6e4a2ae36c670263a3ca5399e.png" data-original-src="https://miro.medium.com/v2/resize:fit:404/format:webp/1*coPzR4Ir6ClP6bRfHF8QiA.png"/></div></figure><p id="35da" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用Itertools中的<code class="fe ns nt nu mg b">islice()</code>函数，我们可以再实现一个特性，这就是步骤。</p><p id="24ff" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe ns nt nu mg b">islice()</code>函数有4个参数。第一个是iterable，其余的是开始索引、停止索引和步骤。</p><p id="5ab6" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我们想得到前两个元素:</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="0d24" class="mk ml jj mg b gy mm mn l mo mp">islice(my_list, 2)  # equivalent to my_list[0:2]</span></pre><figure class="mb mc md me gt iv gh gi paragraph-image"><div class="gh gi of"><img src="../Images/0a79b2da064ceac2f371b63c36629314.png" data-original-src="https://miro.medium.com/v2/resize:fit:842/format:webp/1*LW-pFFsVr6FFhytsc9cx3g.png"/></div></figure><p id="c5b0" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我们想得到2号到5号的商品:</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="8085" class="mk ml jj mg b gy mm mn l mo mp">islice(my_list, 2, 5)  # equivalent to my_list[2:5]</span></pre><figure class="mb mc md me gt iv gh gi paragraph-image"><div class="gh gi og"><img src="../Images/ca26fae872f7700b8fd558a68c83bed4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1188/format:webp/1*YLxx00TaXeY0upcN4wgkgQ.png"/></div></figure><p id="b5aa" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">到目前为止，没有意外。但是，<code class="fe ns nt nu mg b">islice()</code>功能也支持“步骤”。</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="7fb2" class="mk ml jj mg b gy mm mn l mo mp">islice(my_list, 0, None, 2)</span></pre><figure class="mb mc md me gt iv gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/18079c07974e322b6e848911260dc5ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1334/format:webp/1*0pcQsOuQ7eLUp1-ZlJuVXw.png"/></div></figure><p id="8a19" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">从头到尾每第二个项目得到<strong class="la jk">。</strong></p><h1 id="101b" class="mq ml jj bd mr ms mt mu mv mw mx my mz kp na kq nb ks nc kt nd kv ne kw nf ng bi translated">摘要</h1><figure class="mb mc md me gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/d5a4d4b980dbd2f4a03945c8bd7f0cde.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2r8E6lIx2G5gN9LSu_gaBQ.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk">Image by <a class="ae jg" href="https://pixabay.com/users/uniquedesign52-816436/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=656969" rel="noopener ugc nofollow" target="_blank">二 盧</a> from <a class="ae jg" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=656969" rel="noopener ugc nofollow" target="_blank">Pixabay</a></p></figure><p id="4f76" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在本文中，我介绍了Python中Itertools模块的5个技巧。事实上，所有的iterables都非常方便，并且有它们有趣的行为。我们可能不需要一直使用List。</p><p id="c801" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">itertools帮助我们以许多奇特的方式操纵Python可迭代对象。本文不能包含Itertools模块的所有函数。</p><div class="is it gp gr iu oi"><a href="https://medium.com/@qiuyujx/membership" rel="noopener follow" target="_blank"><div class="oj ab fo"><div class="ok ab ol cl cj om"><h2 class="bd jk gy z fp on fr fs oo fu fw ji bi translated">通过我的推荐链接加入灵媒-陶</h2><div class="op l"><h3 class="bd b gy z fp on fr fs oo fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="oq l"><p class="bd b dl z fp on fr fs oo fu fw dk translated">medium.com</p></div></div><div class="or l"><div class="os l ot ou ov or ow ja oi"/></div></div></a></div><p id="c91b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">如果你觉得我的文章有帮助，请考虑加入灵媒会员来支持我和成千上万的其他作家！(点击上面的链接)</strong></p></div></div>    
</body>
</html>