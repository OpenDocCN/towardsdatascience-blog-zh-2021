<html>
<head>
<title>The Basics Of Writing Assembly</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">编写程序集的基础</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/the-basics-of-writing-assembly-cf5f9e7989bc?source=collection_archive---------5-----------------------#2021-08-22">https://towardsdatascience.com/the-basics-of-writing-assembly-cf5f9e7989bc?source=collection_archive---------5-----------------------#2021-08-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e30f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">想学汇编？从这里开始！</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ff39d4cfc6539e14ba7ccc3bd3b44ee1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b5bFxhPzYxQp0unW0MUG0g.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(src =<a class="ae ky" href="https://pixabay.com/images/id-424812/" rel="noopener ugc nofollow" target="_blank">https://pixabay.com/images/id-424812/</a></p></figure><h1 id="a78d" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">介绍</h1><p id="9f5b" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi mn translated">计算机是技术革新，在仅仅半个世纪的时间里，它彻底改变了整个世界和我们做任何事情的方式。计算技术对现代社会至关重要，由于国际互联网和计算机的普及，我们甚至将我们生活的时间称为“信息时代”。不用说，计算机理论是一门非常重要的学科，尤其是在数据科学的背景下。计算机理论的核心是硬件的一个非常重要的组成部分，中央处理器，或称CPU。</p><h2 id="1ada" class="mw la it bd lb mx my dn lf mz na dp lj ma nb nc ll me nd ne ln mi nf ng lp nh bi translated">中央处理器</h2><p id="a54e" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">CPU通常可以比喻为人脑，因为就计算机而言，它本质上是操作的大脑。我认为更准确的比喻可能是大脑皮层本身，因为处理器不一定做大脑做的所有事情，例如存储记忆，但我跑题了，这个比喻仍然完成了工作。处理器主要是一个I/O设备，它可以在寄存器中临时存储要计算的位。CPU内部唯一的其他组件是控制单元，它控制数据进出寄存器，最后是组合逻辑核心。组合逻辑内核用于非常快速地处理带有数据的命令，甚至可以用于存储在存储器中的位，而不仅仅是寄存器。换句话说，如果堆栈中有8位，处理器寄存器中有8位都是整数，我们想将这些数字相加，我们可以使用add命令。您现在可能会忽略它，它的程序集如下所示:</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="7ccd" class="mw la it nj b gy nn no l np nq">mov rsi, example_data1<br/>add rsi, example_data2</span></pre><p id="501d" class="pw-post-body-paragraph lr ls it lt b lu nr ju lw lx ns jx lz ma nt mc md me nu mg mh mi nv mk ml mm im bi translated">当然，这是假设这两个部分都是堆栈的别名部分，是预先保留或分配的。当然，对于这种复杂的硬件组件，总是需要某种方式让软件与之接口，这就是汇编或机器码发挥作用的地方。</p><h2 id="df80" class="mw la it bd lb mx my dn lf mz na dp lj ma nb nc ll me nd ne ln mi nf ng lp nh bi translated">什么是组装？</h2><p id="5c91" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">汇编是一个由寄存器标号、段和命令组成的系统，处理器可以输入这些信息以便在硬件端执行某些操作。如果说CPU是计算机的大脑，那么汇编就是脊髓。汇编允许CPU在内存和内核之间传递信息，以使计算机真正做人类想让它做的事情。</p><h2 id="5771" class="mw la it bd lb mx my dn lf mz na dp lj ma nb nc ll me nd ne ln mi nf ng lp nh bi translated">为什么要学汇编？</h2><p id="1bc3" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">汇编语言无疑已经失去了很多用户，因为C语言更容易使用，功能也差不多，但速度稍慢。然而，我认为至少追求最低限度的汇编语言教育的一个重要原因是，与编写Python或C++，甚至C语言相比，它确实可以帮助您学习更多的计算机知识。即使您是初学者，我认为对汇编语言的基本理解也确实可以帮助您从非常低的水平掌握输入和输出的概念。</p><p id="eb0c" class="pw-post-body-paragraph lr ls it lt b lu nr ju lw lx ns jx lz ma nt mc md me nu mg mh mi nv mk ml mm im bi translated">此外，有很多薪水很高的汇编编程工作，所以我认为它甚至对赚钱也很有用。不用说，如果你没有足够好地掌握其他语言来编写你想要的代码，汇编语言总是一个备用点。然而，我认为我想写一篇关于汇编编程的文章的主要原因是为了教育的利益，因为这可能是本文要完成的大部分内容。数据科学家确实有相当大一部分工作分配给了计算机编程，因此理解计算机对于编写更好的代码至关重要。</p></div><div class="ab cl nw nx hx ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="im in io ip iq"><h1 id="2203" class="kz la it bd lb lc od le lf lg oe li lj jz of ka ll kc og kd ln kf oh kg lp lq bi translated">书写组件</h1><p id="548b" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">现在我们对汇编有了一个基本的了解，实际上我们可以开始用这种语言编写我们的第一个程序了！当然，为了实际编写一些汇编，你需要编译一个汇编器。你可能有时会听到程序员把汇编语言称为汇编程序，这在技术上是不恰当的，因为汇编程序更类似于编译器，而不是语言本身。比如Python语言和Python编译器是不一样的。这是一件奇怪的事情，让我很恼火，所以我想我很乐意解释这两个词之间的区别。</p><h2 id="7ce2" class="mw la it bd lb mx my dn lf mz na dp lj ma nb nc ll me nd ne ln mi nf ng lp nh bi translated">设置装配</h2><p id="a452" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">马上，我们将需要查看我们的系统，以便了解我们将需要什么样的汇编程序。您通常可以针对其他内核和处理器品牌进行汇编，但是如果没有针对您的操作系统和处理器的合适汇编程序，您将无法有效地进行调试。由于我在Linux上，目前流行！操作系统，Ubuntu的衍生物，并有一个英特尔处理器，我将使用全网汇编，或NASM。对于Windows Intel系统，你会希望获得微软宏汇编程序，或MASM。如果你有其他系统，你可以谷歌一下</p><blockquote class="oi oj ok"><p id="4be2" class="lr ls ol lt b lu nr ju lw lx ns jx lz om nt mc md on nu mg mh oo nv mk ml mm im bi translated">(OS) (CPU制造商)汇编程序</p></blockquote><p id="db67" class="pw-post-body-paragraph lr ls it lt b lu nr ju lw lx ns jx lz ma nt mc md me nu mg mh mi nv mk ml mm im bi translated">还应该注意的是，一些系统调用可能与汇编程序之间的例子有所不同。在本文的例子中，不同的内核之间有巨大的差异，所以我不能完全解释所有的差异。考虑到这一点，即使您不理解，这篇文章可能仍然是一篇好文章，因为这里的主要目的是学习更多关于计算机的知识。然而，不管你用的是什么系统，我至少可以给你指出正确的搜索方向，以及你到底需要安装什么:</p><ul class=""><li id="3b42" class="op oq it lt b lu nr lx ns ma or me os mi ot mm ou ov ow ox bi translated"><strong class="lt iu"> Windows </strong> —点击Windows开始按钮，然后点击设置(齿轮图标)。在设置菜单中，点击系统。向下滚动并点击关于。</li><li id="3ad9" class="op oq it lt b lu oy lx oz ma pa me pb mi pc mm ou ov ow ox bi translated"><strong class="lt iu"> OSX </strong> —点击苹果菜单&gt;关于这台Mac。</li><li id="8f6f" class="op oq it lt b lu oy lx oz ma pa me pb mi pc mm ou ov ow ox bi translated">如果你不知道如何做到这一点，我将假设你在Gnome上。在大多数DEs上，这仍然有效。按下您的“活动”按钮(或Windows按钮)，然后键入about并按enter键。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pd"><img src="../Images/018c324eb992dcbbb31e3d470fed0499.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dxWXECrcokZSmILGbO7MNQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="79b8" class="pw-post-body-paragraph lr ls it lt b lu nr ju lw lx ns jx lz ma nt mc md me nu mg mh mi nv mk ml mm im bi translated">在Linux上，您可以通过您的软件包管理器直接安装NASM。例如，Apt:</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="0e32" class="mw la it nj b gy nn no l np nq">sudo apt-get install nasm</span></pre><p id="f589" class="pw-post-body-paragraph lr ls it lt b lu nr ju lw lx ns jx lz ma nt mc md me nu mg mh mi nv mk ml mm im bi translated">在Windows上，我相信你可以通过标准的安装向导安装MASM。在MacOS上，我必须承认我完全不知道如何安装汇编程序。我认为它可能会通过Brew来完成。</p><h2 id="5d0f" class="mw la it bd lb mx my dn lf mz na dp lj ma nb nc ll me nd ne ln mi nf ng lp nh bi translated">我们的准则</h2><p id="a2b7" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">对于我们今天的项目，我们将编写一个简单的Hello " Name "程序。这本质上是Hello World！这个应用程序还将展示如何为输入和诸如此类的事情保留字节。而我通常认为你好世界！对于第一个项目来说有点太简单了，因为在大多数高级语言中，它只是类似于<code class="fe pe pf pg nj b">print(“Hello world!”)</code>的东西，在汇编的例子中，我认为这是一个很好的学习例子！此外，这段代码将在Github上提供，因此您可以随意下载、汇编或在这里查看:</p><div class="ph pi gp gr pj pk"><a href="https://github.com/emmettgb/Assembly-Intro" rel="noopener  ugc nofollow" target="_blank"><div class="pl ab fo"><div class="pm ab pn cl cj po"><h2 class="bd iu gy z fp pp fr fs pq fu fw is bi translated">GitHub-emmettgb/Assembly-Intro:NASM汇编中的一些介绍性示例</h2><div class="pr l"><h3 class="bd b gy z fp pp fr fs pq fu fw dk translated">NASM装配中的一些介绍性例子。通过创建帐户，为emmettgb/Assembly-Intro开发做出贡献…</h3></div><div class="ps l"><p class="bd b dl z fp pp fr fs pq fu fw dk translated">github.com</p></div></div><div class="pt l"><div class="pu l pv pw px pt py ks pk"/></div></div></a></div><h2 id="94d0" class="mw la it bd lb mx my dn lf mz na dp lj ma nb nc ll me nd ne ln mi nf ng lp nh bi translated">部分</h2><p id="52f6" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">对于这个项目，我们需要讨论和理解的第一件事是节的概念。段用于定义处理器需要分配的数据，或在堆栈中保留的数据，或通过文本给处理器重要的指令。有几个部分，但现在我们将重点放在。数据部分。为了定义一个部分，您只需编写section，后跟我们想要创建的部分。例如，在。数据部分:</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="c883" class="mw la it nj b gy nn no l np nq">section .data</span></pre><p id="919c" class="pw-post-body-paragraph lr ls it lt b lu nr ju lw lx ns jx lz ma nt mc md me nu mg mh mi nv mk ml mm im bi translated">此外，对于节，我们不需要像函数那样使用冒号。无论如何，我们还将在它下面定义另一个称为。bss部分，然后是。文本部分。之后，我们的部分应该看起来像这样:</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="e685" class="mw la it nj b gy nn no l np nq">section .data</span><span id="ffd3" class="mw la it nj b gy pz no l np nq">section .bss</span><span id="b95f" class="mw la it nj b gy pz no l np nq">section .text</span></pre><h2 id="ef29" class="mw la it bd lb mx my dn lf mz na dp lj ma nb nc ll me nd ne ln mi nf ng lp nh bi translated">别名堆栈</h2><p id="5e1b" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">首先。数据段用于定义静态数据。这意味着我们将把这些数据直接放入堆栈中，并使用一个别名来调用它。这个命令叫做定义字节，简称db。在db之前，我们需要提供这部分堆栈的别名。假设我们的堆栈从0开始，每当我们写这个别名时，它将只为我们保存字节的起点，0，在这个例子中我们将写hello _____。这将是6个字节，一个用于hello中的每个字符，一个用于结尾的空格。我还将为结尾预留更多的内存，包括解释点和返回。虽然我们已经习惯了内核中带有内核的可爱而奇特的正则表达式，但是处理器没有这些，所以我们将使用数字10来代替\n。这只是一个数字，本质上类似于添加新行的正则表达式。</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="0dcc" class="mw la it nj b gy nn no l np nq">section .data<br/>  hello: db "Hello "<br/>  ending: db "!", 10<br/>section .bss</span><span id="3891" class="mw la it nj b gy pz no l np nq">section .text</span></pre><p id="b2c6" class="pw-post-body-paragraph lr ls it lt b lu nr ju lw lx ns jx lz ma nt mc md me nu mg mh mi nv mk ml mm im bi translated">所以现在，如果我们的堆栈从0开始，我们将有别名hello，从0开始，到6结束，然后堆叠在它上面的是别名end，从7开始，到9结束(为10保留了一个字节)。现在让我们转到。bss部分，通常用于为应用程序内部将要使用的内容保留数据。当然，我们将为我们的用户输入保留字节，所以我们将我们的新别名命名为。长度超过16个字节的名字不多，我就分配这么多。我们用resb命令保留字节。我们按照我们希望保留的字节数:</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="e1aa" class="mw la it nj b gy nn no l np nq">section .bss<br/>  input: resb 16</span></pre><h2 id="81c7" class="mw la it bd lb mx my dn lf mz na dp lj ma nb nc ll me nd ne ln mi nf ng lp nh bi translated">。文本</h2><p id="9795" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我们今天要学习的最后一个部分是。文本部分。该部分用于为处理器提供重要信息，并保存我们汇编软件的所有代码。在这种情况下，_start将成为处理器应该访问的汇编文件内部的入口点。当然，它也有其他的用途，但是在这个例子中，我们只需要使用那一部分。我们所需要做的就是用全局命令调用我们的启动函数(我们还没有写):</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="1442" class="mw la it nj b gy nn no l np nq">section .text<br/>global _start</span></pre><p id="69f9" class="pw-post-body-paragraph lr ls it lt b lu nr ju lw lx ns jx lz ma nt mc md me nu mg mh mi nv mk ml mm im bi translated">现在，我们代码的section部分将如下所示:</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="70b3" class="mw la it nj b gy nn no l np nq">; Sections:<br/>section .data<br/>  hello: db "Hello "<br/>  ending: db "!", 10</span><span id="7e5b" class="mw la it nj b gy pz no l np nq">section .bss<br/>  input: resb 16</span><span id="ed00" class="mw la it nj b gy pz no l np nq">section .text<br/>  global _start</span><span id="caf7" class="mw la it nj b gy pz no l np nq">; Functions:</span></pre><blockquote class="oi oj ok"><p id="8fa4" class="lr ls ol lt b lu nr ju lw lx ns jx lz om nt mc md on nu mg mh oo nv mk ml mm im bi translated">您还可以用注释代码；比如Lisp。</p></blockquote><h2 id="cae1" class="mw la it bd lb mx my dn lf mz na dp lj ma nb nc ll me nd ne ln mi nf ng lp nh bi translated">功能</h2><p id="9258" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">为了编写一个函数，我们只需键入一个函数别名，后跟一个冒号，例如我们的start函数:</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="661d" class="mw la it nj b gy nn no l np nq">_start:</span></pre><p id="9cf3" class="pw-post-body-paragraph lr ls it lt b lu nr ju lw lx ns jx lz ma nt mc md me nu mg mh mi nv mk ml mm im bi translated">函数在汇编中工作就像在其他语言中一样。考虑到这一点，我们现在需要将命令添加到我们的函数中，在这之前会有很多解释，所以准备好吧。</p><h2 id="ec66" class="mw la it bd lb mx my dn lf mz na dp lj ma nb nc ll me nd ne ln mi nf ng lp nh bi translated">寄存器和系统调用</h2><p id="b9bf" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在许多方面，汇编编程将是处理器和内核之间的通信。我们通过将数据移入寄存器来完成大部分通信，然后使用syscalls来完成内核端的操作，以向使用计算机的实际人员提供某种回报。系统调用总是以这样的方式工作，首先将数据移动到寄存器中的特定位置，然后进行系统调用，内核执行放入寄存器中的操作。我们可以把寄存器看作是处理器内部的临时数据存储器，它是不可思议地可变的。这些寄存器以位置命名，例如1、2、3 …</p><p id="efb4" class="pw-post-body-paragraph lr ls it lt b lu nr ju lw lx ns jx lz ma nt mc md me nu mg mh mi nv mk ml mm im bi translated">这是每种架构的所有寄存器的映射。请注意，我找不到一个具有知识共享署名的表格，所以我承担了为您创建自己的表格的艰巨任务。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi qa"><img src="../Images/bd9cca13a0851748a9b11c3ea7bbc0e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:350/format:webp/1*2ae5XzqLKU915xn3HUA_Vw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)(对了，知识共享(CREATIVE COMMONS)，你可以保存这个图片并分享。)</p></figure><p id="0063" class="pw-post-body-paragraph lr ls it lt b lu nr ju lw lx ns jx lz ma nt mc md me nu mg mh mi nv mk ml mm im bi translated">大多数情况下，我们将使用这些寄存器处理系统调用或处理器命令。我们都可以从寄存器和内存中做到这一点。例如，我们想添加rax和rbx寄存器:</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="087c" class="mw la it nj b gy nn no l np nq">add rax, rbx</span></pre><p id="90f2" class="pw-post-body-paragraph lr ls it lt b lu nr ju lw lx ns jx lz ma nt mc md me nu mg mh mi nv mk ml mm im bi translated">现在让我们来谈谈系统调用。为了对我们的内核进行系统调用，我们需要将数据放入我们的寄存器。通常，在位置1，rax寄存器中，我们会放入一个命令，让内核与其他寄存器一起执行。当然，您可以为您的特定内核查找一个完整的系统调用列表。</p><h2 id="6ae8" class="mw la it bd lb mx my dn lf mz na dp lj ma nb nc ll me nd ne ln mi nf ng lp nh bi translated">进行系统调用</h2><p id="d85b" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">当然，对我来说，与您一起检查每个系统调用的工作量将是非常大的，例如，在Linux中有313个系统调用，所以我将只展示我今天要处理的系统调用。您可以在这里查看Linux系统调用的完整列表:</p><div class="ph pi gp gr pj pk"><a href="https://blog.rchapman.org/posts/Linux_System_Call_Table_for_x86_64/" rel="noopener  ugc nofollow" target="_blank"><div class="pl ab fo"><div class="pm ab pn cl cj po"><h2 class="bd iu gy z fp pp fr fs pq fu fw is bi translated">x86 64的Linux系统调用表</h2><div class="pr l"><h3 class="bd b gy z fp pp fr fs pq fu fw dk translated">Linux 4.7(2016年7月20日从github.com/torvalds/linux拉)，x86_64注:64位x86使用syscall而不是…</h3></div><div class="ps l"><p class="bd b dl z fp pp fr fs pq fu fw dk translated">blog.rchapman.org</p></div></div></div></a></div><p id="af37" class="pw-post-body-paragraph lr ls it lt b lu nr ju lw lx ns jx lz ma nt mc md me nu mg mh mi nv mk ml mm im bi translated">无论如何，我们今天要看的3个调用是sys_exit、sys_read和sys_write。我们的程序被设计为先读后写，因为它从来没有真正要求我们的名字(你能看出来，因为我们没有为此保留字节)，所以我们需要调用的第一件事是sys_write。我将在这里为sys_read和sys_write提供一个小表:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qb"><img src="../Images/e8c80bd76316ce03d926fef9dcca51cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tK69CfmXRkRbOU9CZCv0Pg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="26aa" class="pw-post-body-paragraph lr ls it lt b lu nr ju lw lx ns jx lz ma nt mc md me nu mg mh mi nv mk ml mm im bi translated">这些表格将为您提供几乎所有您需要了解的关于这些系统调用的信息。我们可以把系统调用看作是以寄存器作为参数的方法。我们将使用MOV命令将数据移入寄存器。</p><h1 id="7a26" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">写Hello World！</h1><p id="556a" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">为了开始系统调用的演示，我觉得使用最简单的系统调用可能会有用，这当然是退出系统调用。这也有助于我们更好地理解如何只使用to寄存器进行系统调用。</p><h2 id="7a8f" class="mw la it bd lb mx my dn lf mz na dp lj ma nb nc ll me nd ne ln mi nf ng lp nh bi translated">出口</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qc"><img src="../Images/24e9e7fc14f82e462d4a125e02b07f42.png" data-original-src="https://miro.medium.com/v2/resize:fit:1356/format:webp/1*kfP2y_Ro3HyetR48BOpk5g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="be6f" class="pw-post-body-paragraph lr ls it lt b lu nr ju lw lx ns jx lz ma nt mc md me nu mg mh mi nv mk ml mm im bi translated">正如我们在表中看到的，这个系统调用的数字标签将是60。当我们进行系统调用时，它几乎总是进入位置1寄存器，即rax寄存器。现在让我们从在rax上使用带无符号整数的MOV命令开始。这个无符号整数是一个退出代码，在这种情况下，我们希望它是0。在编程的世界里，代码0意味着我们的程序没有出错。我们首先将0移入rax寄存器的3中:</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="0c69" class="mw la it nj b gy nn no l np nq">_start:<br/>  mov rax, 60</span></pre><p id="92f7" class="pw-post-body-paragraph lr ls it lt b lu nr ju lw lx ns jx lz ma nt mc md me nu mg mh mi nv mk ml mm im bi translated">请注意的语法</p><blockquote class="oi oj ok"><p id="fda9" class="lr ls ol lt b lu nr ju lw lx ns jx lz om nt mc md on nu mg mh oo nv mk ml mm im bi translated">[命令](寄存器)，(寄存器或数据)</p></blockquote><p id="14de" class="pw-post-body-paragraph lr ls it lt b lu nr ju lw lx ns jx lz ma nt mc md me nu mg mh mi nv mk ml mm im bi translated">按照相同的语法，让我们将0移入第二个寄存器位置rdi:</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="17f5" class="mw la it nj b gy nn no l np nq">_start:<br/>  mov rax, 60<br/>  mov rdi, 0</span></pre><p id="e1c4" class="pw-post-body-paragraph lr ls it lt b lu nr ju lw lx ns jx lz ma nt mc md me nu mg mh mi nv mk ml mm im bi translated">最后，我们将简单地在末尾添加syscall来进行syscall:我们现在的最终结果应该是这样的:</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="8640" class="mw la it nj b gy nn no l np nq">; Sections:<br/>section .data<br/>  hello: db "Hello "<br/>  ending: db "!", 10</span><span id="1a2a" class="mw la it nj b gy pz no l np nq">section .bss<br/>  input: resb 16</span><span id="4df3" class="mw la it nj b gy pz no l np nq">section .text<br/>  global _start</span><span id="c08f" class="mw la it nj b gy pz no l np nq">; Functions:</span><span id="cc33" class="mw la it nj b gy pz no l np nq">_start:<br/>  mov rax, 60<br/>  mov rdi, 0<br/>  syscall</span></pre><h2 id="4387" class="mw la it bd lb mx my dn lf mz na dp lj ma nb nc ll me nd ne ln mi nf ng lp nh bi translated">正在组装！</h2><p id="3e6b" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">现在我们将组装我们的新应用程序。当然，这个应用程序除了打开和关闭之外什么也不做，但是它仍然很容易判断出是否有问题，因为我们将收到一个分段错误消息。现在，我们需要将终端带到包含汇编文件的目录，并使用nasm来汇编它:</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="e93f" class="mw la it nj b gy nn no l np nq">nasm -f elf64 hello_world.asm</span></pre><p id="b46a" class="pw-post-body-paragraph lr ls it lt b lu nr ju lw lx ns jx lz ma nt mc md me nu mg mh mi nv mk ml mm im bi translated">这将为我们提供一个. o文件，我们现在可以将它转换成一个可执行的二进制文件:</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="2d88" class="mw la it nj b gy nn no l np nq">ld hello_world.o -o hello</span></pre><p id="ecaf" class="pw-post-body-paragraph lr ls it lt b lu nr ju lw lx ns jx lz ma nt mc md me nu mg mh mi nv mk ml mm im bi translated">然后我们可以用。/:</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="2ed4" class="mw la it nj b gy nn no l np nq">./hello</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qd"><img src="../Images/f688d76a9474e68ea34f5d68b2b3288f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gfrEQ0Xd_MtDVqLa9TVUXw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><blockquote class="qe"><p id="0096" class="qf qg it bd qh qi qj qk ql qm qn mm dk translated">恭喜你！</p></blockquote><p id="4989" class="pw-post-body-paragraph lr ls it lt b lu qo ju lw lx qp jx lz ma qq mc md me qr mg mh mi qs mk ml mm im bi translated">你的第一个汇编程序已经正式完成了！如果您最终得到“分段错误(核心转储)”，这基本上意味着您的代码中的某个地方有问题。找到这些bug可能相当棘手，因为核心转储实际上并没有描述太多关于异常发生位置的信息。</p><h2 id="8b89" class="mw la it bd lb mx my dn lf mz na dp lj ma nb nc ll me nd ne ln mi nf ng lp nh bi translated">读取字节</h2><p id="b3d5" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">接下来我们需要做的是处理一些简单的标准输入，并输出该输入以及我们的hello消息。让我们回头参考syscall表，该表包含我们为此所需的信息:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qb"><img src="../Images/e8c80bd76316ce03d926fef9dcca51cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tK69CfmXRkRbOU9CZCv0Pg.png"/></div></div></figure><p id="f866" class="pw-post-body-paragraph lr ls it lt b lu nr ju lw lx ns jx lz ma nt mc md me nu mg mh mi nv mk ml mm im bi translated">我们看到sys_read是第一个调用，它为零。记住这一点，我们将把它移到rax寄存器中:</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="165c" class="mw la it nj b gy nn no l np nq">mov rax, 0</span></pre><p id="64f5" class="pw-post-body-paragraph lr ls it lt b lu nr ju lw lx ns jx lz ma nt mc md me nu mg mh mi nv mk ml mm im bi translated">接下来，我们将把0移入rdi寄存器。该寄存器用于描述我们正在使用的缓冲器。当然，对于这个例子，我们需要STDIN，标准输入是0，标准输出是1。</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="fbb5" class="mw la it nj b gy nn no l np nq">mov rdi, 0</span></pre><p id="7485" class="pw-post-body-paragraph lr ls it lt b lu nr ju lw lx ns jx lz ma nt mc md me nu mg mh mi nv mk ml mm im bi translated">接下来，我们将把我们的保留字节放入rsi寄存器的位置3:</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="3c46" class="mw la it nj b gy nn no l np nq">mov rsi, input</span></pre><p id="2bf9" class="pw-post-body-paragraph lr ls it lt b lu nr ju lw lx ns jx lz ma nt mc md me nu mg mh mi nv mk ml mm im bi translated">当我们这样做时，我们基本上是在说</p><blockquote class="qe"><p id="3192" class="qf qg it bd qh qi qt qu qv qw qx mm dk translated">"在这里存储输入！"</p></blockquote><p id="3ac3" class="pw-post-body-paragraph lr ls it lt b lu qo ju lw lx qp jx lz ma qq mc md me qr mg mh mi qs mk ml mm im bi translated">这意味着我们指向堆栈中的一个位置，该位置被保留并作为输入别名。最后，我们需要这个缓冲区允许占用的字节数，16:</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="da1e" class="mw la it nj b gy nn no l np nq">mov rax, 0<br/>  mov rdi, 0<br/>  mov rsi, input<br/>  mov rdx, 16<br/>  syscall</span></pre><h2 id="0fc1" class="mw la it bd lb mx my dn lf mz na dp lj ma nb nc ll me nd ne ln mi nf ng lp nh bi translated">输出</h2><p id="2e16" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">最后，现在让我们把这个打印出来，和我们的其他信息一起显示在屏幕上。我们将从信息的“你好”部分开始。首先，查看上面的图表，我们将1移入rax寄存器。</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="9163" class="mw la it nj b gy nn no l np nq">mov rax, 1</span></pre><p id="60fb" class="pw-post-body-paragraph lr ls it lt b lu nr ju lw lx ns jx lz ma nt mc md me nu mg mh mi nv mk ml mm im bi translated">因为这是标准输出，所以我们也需要将1移动到rdi中的描述符。</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="b1f3" class="mw la it nj b gy nn no l np nq">mov rdi, 1</span></pre><p id="f0ea" class="pw-post-body-paragraph lr ls it lt b lu nr ju lw lx ns jx lz ma nt mc md me nu mg mh mi nv mk ml mm im bi translated">现在我们需要将内存的别名移入rsi，hello，然后将它需要输出的字节数移入rdx。为了演示stack的工作原理，我将把这个数字改为7，然后组装它，这样我们就可以看到发生了什么:</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="163b" class="mw la it nj b gy nn no l np nq">mov rdx, 7</span></pre><p id="20f5" class="pw-post-body-paragraph lr ls it lt b lu nr ju lw lx ns jx lz ma nt mc md me nu mg mh mi nv mk ml mm im bi translated">现在我们的最终结果看起来有点像这样。</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="6f07" class="mw la it nj b gy nn no l np nq">mov rax, 1<br/>  mov rdi, 1<br/>  mov rsi, hello<br/>  mov rdx, 7<br/>  syscall</span></pre><p id="e382" class="pw-post-body-paragraph lr ls it lt b lu nr ju lw lx ns jx lz ma nt mc md me nu mg mh mi nv mk ml mm im bi translated">让我们看看在rdx中多编译一个字节会发生什么:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi qy"><img src="../Images/94e9be005f7f97bbe3deb6e0c8ac65a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1116/format:webp/1*5QayvfLOB66mcNnyr6Sm6A.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="bfd0" class="pw-post-body-paragraph lr ls it lt b lu nr ju lw lx ns jx lz ma nt mc md me nu mg mh mi nv mk ml mm im bi translated">忽略f，那是我的输入，但是注意我们的。数据段没有用解释点定义我们的hello消息？</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="a2f3" class="mw la it nj b gy nn no l np nq">section .data<br/>  hello: db "Hello "<br/>  ending: db "!", 10</span></pre><p id="947c" class="pw-post-body-paragraph lr ls it lt b lu nr ju lw lx ns jx lz ma nt mc md me nu mg mh mi nv mk ml mm im bi translated">栈之所以叫栈是有原因的。它是内存中一系列相互堆叠的字节。每当我们分配这些内存部分时，我们都将“ending”放在“hello”的上面。hello的长度是未知的，这就是为什么每当我们进行这个syscall时，我们必须将它移动到rdx寄存器中。无论如何，我现在将把它改回6，我们将继续重复这段代码，但不是打印hello，而是打印输入。之后，我们将打印结局。我还强烈推荐使用适当的格式和分离您的系统调用，因为这肯定会使所有的操作混为一谈。这是我们的最终产品:</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="6006" class="mw la it nj b gy nn no l np nq">; Sections:<br/>section .data<br/>  hello: db "Hello "<br/>  ending: db "!", 10</span><span id="ee52" class="mw la it nj b gy pz no l np nq">section .bss<br/>  input resb 16</span><span id="a70b" class="mw la it nj b gy pz no l np nq">section .text<br/>  global _start<br/>_start:<br/>  mov rax, 0<br/>  mov rdi, 0<br/>  mov rsi, input<br/>  mov rdx, 16<br/>  syscall</span><span id="0f0f" class="mw la it nj b gy pz no l np nq">mov rax, 1<br/>  mov rdi, 1<br/>  mov rsi, hello<br/>  mov rdx, 6<br/>  syscall</span><span id="9d1f" class="mw la it nj b gy pz no l np nq">mov rax, 1<br/>  mov rdi, 1<br/>  mov rsi, input<br/>  mov rdx, 16<br/>  syscall</span><span id="eeef" class="mw la it nj b gy pz no l np nq">mov rax, 1<br/>  mov rdi, 1<br/>  mov rsi, ending<br/>  mov rdx, 2<br/>  syscall<br/>  <br/>  mov rax, 60<br/>  mov rdi, 0<br/>  syscall<br/>; Functions:</span></pre><p id="9c3d" class="pw-post-body-paragraph lr ls it lt b lu nr ju lw lx ns jx lz ma nt mc md me nu mg mh mi nv mk ml mm im bi translated">现在让我们组装并运行它！</p></div><div class="ab cl nw nx hx ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="im in io ip iq"><h1 id="accb" class="kz la it bd lb lc od le lf lg oe li lj jz of ka ll kc og kd ln kf oh kg lp lq bi translated">结论</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qz"><img src="../Images/738eedd3cf9e4b07b90f458b871d909d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eIWiYZkd0F14lQNP1y6smA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="69f4" class="pw-post-body-paragraph lr ls it lt b lu nr ju lw lx ns jx lz ma nt mc md me nu mg mh mi nv mk ml mm im bi translated">我们的感叹号出现在底部可能有点奇怪。发生这种情况的原因是因为我们为STDOUT保留了16个字节。换句话说，我们还不知道这个名字的长度。这当然可以很容易地通过比较、跳转和标记来解决，但这是我希望这篇文章所能达到的深度。</p><p id="7c98" class="pw-post-body-paragraph lr ls it lt b lu nr ju lw lx ns jx lz ma nt mc md me nu mg mh mi nv mk ml mm im bi translated">我觉得这种语言的技巧绝对可以应用到更高级的编程中！事实上，这几乎是我最初学习汇编语言的全部原因。除此之外，写起来很有趣，因为通常比写标准的高级语言更有挑战性。这真的让你不得不更多地考虑硬件。如果有一件事是我个人最喜欢的，那就是从软件的角度与硬件交互。这基本上是我们在不接触裸机的情况下最接近硬件的了(另一篇文章的想法？)，我觉得很有意思。非常感谢大家的阅读，我将考虑做另一部分，我们将在这篇文章中投入更多的组装乐趣。到那时，快乐的发现，快乐的编程！</p></div></div>    
</body>
</html>