<html>
<head>
<title>Which Encoder Is The Best For Random Forest Accuracy? Float Or Ordinal?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">哪种编码器最适合随机森林精度？浮点数还是序数？</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/which-encoder-is-the-best-for-random-forest-accuracy-float-or-ordinal-ea7ba7ee697d?source=collection_archive---------19-----------------------#2021-04-03">https://towardsdatascience.com/which-encoder-is-the-best-for-random-forest-accuracy-float-or-ordinal-ea7ba7ee697d?source=collection_archive---------19-----------------------#2021-04-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d9fe" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">基尼指数随机森林分类器上分类编码器的比较。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/58dc8f4781ff09e0aa7b61e5cc047d81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wSPtI78F2rH5H1S3wv1sLA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(src =<a class="ae ky" href="https://unsplash.com/photos/50bzI1F6urA" rel="noopener ugc nofollow" target="_blank">https://unsplash.com/photos/50bzI1F6urA</a></p></figure><h1 id="e3fa" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">介绍</h1><p id="103a" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi mn translated"><span class="l mo mp mq bm mr ms mt mu mv di"> O </span>处理分类数据和问题的最常见模型类型之一是随机森林分类器。这是有充分理由的，因为它相对容易使用，不需要太多努力就可以产生一些非常惊人的结果。随机森林分类器使用一种称为基尼指数的统计指标来种植节点，以分析数据和结果之间的某些一致性。</p><p id="5e39" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">处理这类数据时，需要处理连续的要素是很常见的，但在不是这种情况的情况下，我们需要将分类值转换成某种数字形式，以便计算机可以实际分析它。为此，通常使用编码器。编码器获取典型的文本或分类数据，并将其转换成一种新的形式，有时具有惊人的准确性性能，这取决于用什么模型对什么数据处理什么类别。也就是说，我真的想尝试一下，了解一下哪些不同类型的编码器可以更好地处理基尼指数，以便在我们的随机森林分类模型中获得最高的准确性。</p><blockquote class="nb"><p id="7daf" class="nc nd it bd ne nf ng nh ni nj nk mm dk translated"><a class="ae ky" href="https://github.com/emmettgb/Lathe-Books/blob/main/models/Gini%20Encoder%20Comparison%20(0.1.7).ipynb" rel="noopener ugc nofollow" target="_blank">笔记本</a></p></blockquote><p id="cfaf" class="pw-post-body-paragraph lr ls it lt b lu nl ju lw lx nm jx lz ma nn mc md me no mg mh mi np mk ml mm im bi translated">我的预测是，顺序编码器的性能将超过浮点和标签编码器。我之所以估计这个案例，部分是因为我在这个课题上的经验。以我的经验来看，顺序编码对于基于基尼指数的预测非常有效，而在许多其他分类模型中，一种热编码可能是最合适的解决方案。我估计这是因为一个热点将创建更多的特征来作为我们节点的基础，这将把我们的胡萝卜放入几个基于布尔的篮子中，而不是只保留一个集合编码的特征。另一方面，float编码器只是简单地将字符转换成数字，所以本质上它要做的事情和ordinal编码器一样，对每个类别应用唯一的值。我认为序数编码器在这方面仍将领先的原因是，序数编码器不会有可能具有高方差且本质上是任意的高数字，它不会浪费任何连续的空间，使我们的评估者更容易跟踪我们总体中的数字。如果你想了解更多关于这三种编码器的信息，你可以在这里查阅我写的这篇关于这三种编码器的文章，甚至是如何用Julia编写它们:</p><div class="nq nr gp gr ns nt"><a rel="noopener follow" target="_blank" href="/encoders-how-to-write-them-how-to-use-them-d8dd70f45e39"><div class="nu ab fo"><div class="nv ab nw cl cj nx"><h2 class="bd iu gy z fp ny fr fs nz fu fw is bi translated">编码器——如何编写，如何使用</h2><div class="oa l"><h3 class="bd b gy z fp ny fr fs nz fu fw dk translated">通过这个“从头开始”的演练，探索编码器在机器学习中的多种用途！</h3></div><div class="ob l"><p class="bd b dl z fp ny fr fs nz fu fw dk translated">towardsdatascience.com</p></div></div><div class="oc l"><div class="od l oe of og oc oh ks nt"/></div></div></a></div><h1 id="569c" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">依赖性和数据</h1><p id="d0e2" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">对于这个项目，我们将使用模型和编码器的Lathe.jl实现。这将有助于降低依赖性，并为我们将要使用的每个工具提供一致的方法。此外，我们将使用DataFrames.jl和CSV.jl来读入我们要处理的数据。</p><p id="595f" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">这个过程的第一步是读入我们的数据。为此，我们将使用sink参数和CSV.read()方法。如果你想了解更多关于水槽的论点，我也有一篇关于它的文章，你可以在这里找到:</p><div class="nq nr gp gr ns nt"><a rel="noopener follow" target="_blank" href="/what-is-a-sink-argument-caf77dab6ac5"><div class="nu ab fo"><div class="nv ab nw cl cj nx"><h2 class="bd iu gy z fp ny fr fs nz fu fw is bi translated">什么是“下沉”论点？</h2><div class="oa l"><h3 class="bd b gy z fp ny fr fs nz fu fw dk translated">关于在Julia编程语言中使用接收器参数的介绍。</h3></div><div class="ob l"><p class="bd b dl z fp ny fr fs nz fu fw dk translated">towardsdatascience.com</p></div></div><div class="oc l"><div class="oi l oe of og oc oh ks nt"/></div></div></a></div><p id="17f7" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">我为这个项目选择的数据是2008年发生在亚特兰大的犯罪数据集。让我们继续往下读:</p><pre class="kj kk kl km gt oj ok ol om aw on bi"><span id="0c4e" class="oo la it ok b gy op oq l or os">using CSV<br/>using DataFrames; df = CSV.read("atlcrime.csv", DataFrame)</span></pre><p id="02c2" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">现在我们已经有了数据，我删除了缺失的值，然后继续使用我为此项目选择的两个要素创建了一个新的数据框:</p><pre class="kj kk kl km gt oj ok ol om aw on bi"><span id="ea65" class="oo la it ok b gy op oq l or os">df = dropmissing(df)<br/>df = DataFrame(:crime =&gt; df[!, :crime], :neighborhood =&gt; df[!, :neighborhood])</span></pre><p id="740e" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">现在，为了了解我们将在这里处理多少个类别，我将集合类型转换为数组。然后，我打印了这些内容的长度，给出了一些类别，因为我们可能不希望我们的目标有比我们的功能更多的类别:</p><pre class="kj kk kl km gt oj ok ol om aw on bi"><span id="243b" class="oo la it ok b gy op oq l or os">println(length(Set(df[!, :crime])))</span></pre><p id="e85e" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">犯罪特写最终有11个不同的类别。</p><pre class="kj kk kl km gt oj ok ol om aw on bi"><span id="e32a" class="oo la it ok b gy op oq l or os">println(length(Set(df[!, :neighborhood])))</span></pre><p id="68e3" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">邻域要素最终有243个不同的类别，因此对于我的目标，我最终选择了犯罪要素。现在，我们可以使用Lathe.preprocess中的TrainTestSplit()方法将我们的特征分成两个不同的集合，以便使用以下内容进行训练和测试:</p><pre class="kj kk kl km gt oj ok ol om aw on bi"><span id="b1bc" class="oo la it ok b gy op oq l or os">using Lathe.preprocess: TrainTestSplit<br/>train, test = TrainTestSplit(df)</span></pre><p id="3845" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">现在，我要让我们的火车和测试x和y的数据框架，并进入一维数组:</p><pre class="kj kk kl km gt oj ok ol om aw on bi"><span id="51c1" class="oo la it ok b gy op oq l or os">target = :neighborhood<br/>feature = :crime<br/>trainX = train[!, feature]<br/>trainy = train[!, target]<br/>testX = test[!, feature]<br/>testy = test[!, target]</span></pre><p id="533a" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">请注意，在DataFrames.jl的新版本中，这些调用将返回PooledDataArray类型。Lathe专门处理Julian数组类型，而不是抽象数组类型，所以这意味着我们肯定需要改变这一点。当然，我们可以通过简单地将数组类型转换成它们来实现:</p><pre class="kj kk kl km gt oj ok ol om aw on bi"><span id="660b" class="oo la it ok b gy op oq l or os">trainX = Array(trainX)</span></pre><h1 id="c188" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">浮点/标签编码器</h1><p id="8827" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">现在我们将使用Lathe.preprocess的FloatEncoder对这个新数组中的标签进行编码。</p><pre class="kj kk kl km gt oj ok ol om aw on bi"><span id="86d9" class="oo la it ok b gy op oq l or os">using Lathe.preprocess: FloatEncoder</span></pre><p id="3554" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">FloatEncoder是车床内部的一种类型，是编码器类型的子类型。更进一步，我们也可以说这是一个车床预处理器。这意味着我们可以期望从这个调用中返回一个类型，而不是结果编码数组。为了获得数组，我们需要从类型内部调用predict()函数:</p><pre class="kj kk kl km gt oj ok ol om aw on bi"><span id="7a13" class="oo la it ok b gy op oq l or os">fetX = FloatEncoder().predict(trainX)</span></pre><p id="5a17" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">现在我们有了我们的特性，我们还需要将数组类型转换到我们的目标上:</p><pre class="kj kk kl km gt oj ok ol om aw on bi"><span id="8203" class="oo la it ok b gy op oq l or os">trainy = Array(trainy)</span></pre><p id="1ac7" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">最后，我们将使用来自Lathe.models的RandomForestClassifier类型。与编码器一样，我们将使用新类型调用predict方法。当然，我们也想对我们的测试X进行编码:</p><pre class="kj kk kl km gt oj ok ol om aw on bi"><span id="08ca" class="oo la it ok b gy op oq l or os">using Lathe.models: RandomForestClassifier<br/>model = RandomForestClassifier(fetX, trainy)</span><span id="4d6c" class="oo la it ok b gy ot oq l or os">feteX = FloatEncoder().predict(Array(testX))<br/>y_hat = model.predict(feteX)</span></pre><p id="1884" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">现在，我们可以使用Lathe.stats中的catacc方法以基于百分比的精度验证该模型:</p><pre class="kj kk kl km gt oj ok ol om aw on bi"><span id="dc35" class="oo la it ok b gy op oq l or os">using Lathe.stats: catacc<br/>catacc(y_hat, testy)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/2b4c81d1240b639f0b0f104f593a73ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:500/format:webp/1*J3cnYMYvU10IMbi_fOm6mw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">低得可笑(图片由作者提供)</p></figure><h1 id="9d20" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">顺序编码器</h1><p id="e0de" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">与float编码器一样，这个过程的第一步是初始化编码器，并在我们的数组上调用predict()函数。唯一的区别是，这一次我们需要提供数组作为参数来创建类型。这将创建查找字典，稍后用于对结果进行编号。</p><pre class="kj kk kl km gt oj ok ol om aw on bi"><span id="5302" class="oo la it ok b gy op oq l or os">using Lathe.preprocess: OrdinalEncoder<br/>ordenc = OrdinalEncoder(trainX)<br/>oetX = ordenc.predict(trainX)</span></pre><p id="b2dc" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">和以前一样，我们将使用这些数据来拟合RandomForestClassifier:</p><pre class="kj kk kl km gt oj ok ol om aw on bi"><span id="d938" class="oo la it ok b gy op oq l or os">model = RandomForestClassifier(oetX, trainy)</span></pre><p id="e19b" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">然后在使用相同的序号编码器对特征进行编码后调用预测函数:</p><pre class="kj kk kl km gt oj ok ol om aw on bi"><span id="dc38" class="oo la it ok b gy op oq l or os">oeteX = ordenc.predict(testX)<br/>y_hat = model.predict(oeteX)</span></pre><p id="65c7" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">现在我们将像以前一样使用Lathe.stats.catacc验证结果:</p><pre class="kj kk kl km gt oj ok ol om aw on bi"><span id="b7b7" class="oo la it ok b gy op oq l or os">catacc(testy, y_hat)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ov"><img src="../Images/a5c3c9fb79b23df801214d1335bb12f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:416/format:webp/1*BBdsJ_LQzEJRMcTENlgS8Q.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><h1 id="c412" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">结论</h1><p id="5774" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">虽然我们用顺序编码器得到了基本的精度提升，但这还在误差范围内。也就是说，这不应该是一个巨大的惊喜。这两种编码器做的事情基本相同，但方式不同。我最初的意图是将这些预测与来自一键编码器的结果进行比较，但是在这方面仍然有一些问题需要解决。谢谢你看我的文章！</p></div></div>    
</body>
</html>