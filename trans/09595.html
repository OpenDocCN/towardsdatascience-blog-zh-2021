<html>
<head>
<title>Timelines</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">时间表</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/timelines-4f3216c0a1d0?source=collection_archive---------30-----------------------#2021-09-06">https://towardsdatascience.com/timelines-4f3216c0a1d0?source=collection_archive---------30-----------------------#2021-09-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="de4e" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/notes-from-industry" rel="noopener" target="_blank">行业笔记</a></h2><div class=""/><div class=""><h2 id="1d15" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">一个通用的时间轴视图帮助我们理解用户与系统的各种交互。</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/311e235bdbb681389131e3e798361877.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*VqTfVe8UydTz2DYw"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">由<a class="ae lh" href="https://unsplash.com/@peter_s?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">彼得·斯顿夫</a>在<a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="537a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这是我的书《Azure上的数据工程》的摘录。本文中的代码示例使用Azure Data Explorer。如果你想运行它们，创建一个<a class="ae lh" href="https://azure.microsoft.com/en-us/services/data-explorer/" rel="noopener ugc nofollow" target="_blank"> Azure Data Explorer集群和数据库</a>。一旦设置完成，您就可以使用<a class="ae lh" href="https://dataexplorer.azure.com/" rel="noopener ugc nofollow" target="_blank"> Data Explorer web UI </a>连接到您的集群和数据库并运行代码示例。Azure Data Explorer使用KQL，Kusto查询语言。如果不熟悉，可以查看<a class="ae lh" href="https://docs.microsoft.com/en-us/azure/data-explorer/kql-quick-reference" rel="noopener ugc nofollow" target="_blank">快速参考</a>。这本书更深入地介绍了Azure Data Explorer，但是这篇文章是独立的。</p><h1 id="f262" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">时间表</h1><p id="e0b8" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">在我的上一篇文章<a class="ae lh" rel="noopener" target="_blank" href="/identity-keyrings-201d17295954">身份密匙环</a>中，我们看到了身份密匙环如何帮助我们连接整个企业的数据集。另一个有用的视图是显示我们系统中发生的所有事件的视图——时间线。</p><p id="a425" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">一个通用的时间轴视图帮助我们理解用户与系统的各种交互。比方说，我们正试图了解客户支持问题与用户保持率之间的关系。为此，我们需要查看支持票证何时打开和关闭，以及用户何时取消订阅。这些数据点同样来自不同的团队:客户成功团队处理支持票据，支付团队知道用户何时取消订阅。图1显示了如何在时间线上绘制。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nb"><img src="../Images/7ee54036b8781062fc24e58a2bdafafa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1248/format:webp/1*WJP4_sa0iAwcKozvHHtilg.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">图1:多个事件的时间线视图:支持票证何时打开和关闭以及订阅何时取消。</p></figure><h1 id="c29a" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">构建时间线视图</h1><p id="ee3c" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">我们可以为这些事件定义一个公共模式，用一个<code class="fe nc nd ne nf b">Timestamp</code>列来捕获事件发生的时间，用<code class="fe nc nd ne nf b">KeyType</code>和<code class="fe nc nd ne nf b">KeyValue</code>列来捕获与事件相关联的身份的类型和值，用一个<code class="fe nc nd ne nf b">EventType</code>列和一个动态<code class="fe nc nd ne nf b">EventProperties</code>列来捕获特定于事件的属性。我们将利用半结构化数据来封装不同类型的属性，因为各种事件类型都有自己的关联属性。下一个清单创建了这个表。</p><pre class="ks kt ku kv gt ng nf nh ni aw nj bi"><span id="7aa6" class="nk mf it nf b gy nl nm l nn no">.create table Timeline (Timestamp: datetime,<br/>  KeyType: string, KeyValue: string, <br/>  EventType: string, EvenProperties: dynamic)</span></pre><p id="849f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在让我们假设我们想要从客户成功团队获取一个<code class="fe nc nd ne nf b">SupportTickets</code>表，从我们的支付团队获取一个<code class="fe nc nd ne nf b">SubscriptionOrders</code>表，用于捕获新的和取消的订阅。下面的清单用一些示例数据填充了这些表:</p><pre class="ks kt ku kv gt ng nf nh ni aw nj bi"><span id="f78a" class="nk mf it nf b gy nl nm l nn no">.set SupportTickets &lt;|<br/>datatable (Timestamp: datetime, SupportCustomerId: int,<br/>  TicketId: int, Status: string, Message: string) [<br/>    datetime(2020–07–01), 21, 5001, 'Opened', '...',<br/>    datetime(2020–07–03), 21, 5002, 'Opened', '...',<br/>    datetime(2020–07–04), 21, 5001, 'Updated', '...',<br/>    datetime(2020–07–05), 21, 5001, 'Closed', '...',<br/>    datetime(2020–07–19), 21, 5002, 'Closed', '...',<br/>]</span><span id="f9dd" class="nk mf it nf b gy np nm l nn no">.set SubscriptionOrders &lt;|<br/>datatable (Timestamp: datetime, CustomerId: int,<br/>  SubscriptionId: guid, Order: string) [<br/>    datetime(2020–06–01), 1001,<br/>      'fd10b613–8378–4d37-b8e7-bb665999d122', 'Create',<br/>    datetime(2020–07–19), 1001,<br/>      'fd10b613–8378–4d37-b8e7-bb665999d122', 'Cancel'<br/>]</span></pre><p id="e7b8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">下面的清单显示了我们如何将这些表格纳入我们的时间表:</p><pre class="ks kt ku kv gt ng nf nh ni aw nj bi"><span id="753f" class="nk mf it nf b gy nl nm l nn no">.append Timeline &lt;| SupportTickets<br/>| where Status == 'Opened'<br/>| project Timestamp, KeyType='SupportCustomerId',<br/>    KeyValue=tostring(SupportCustomerId),<br/>    EventType='SupportTicketOpened',<br/>    EventProperties=pack("Message", Message)</span><span id="d62d" class="nk mf it nf b gy np nm l nn no">.append Timeline &lt;| SupportTickets<br/>| where Status == 'Closed'<br/>| project Timestamp, KeyType='SupportCustomerId',<br/>    KeyValue=tostring(SupportCustomerId),<br/>    EventType='SupportTicketClosed',<br/>    EventProperties=pack("Message", Message)</span><span id="5009" class="nk mf it nf b gy np nm l nn no">.append Timeline &lt;| SubscriptionOrders<br/>| where Order == 'Create'<br/>| project Timestamp, KeyType='CustomerId',<br/>    KeyValue=tostring(CustomerId),<br/>    EventType='SubscriptionCreate',<br/>    EventProperties=pack("SubscriptionId", SubscriptionId)</span><span id="e175" class="nk mf it nf b gy np nm l nn no">.append Timeline &lt;| SubscriptionOrders<br/>| where Order == 'Cancel'<br/>| project Timestamp, KeyType='CustomerId',<br/>    KeyValue=tostring(CustomerId),<br/>    EventType='SubscriptionClose',<br/>    EventProperties=pack("SubscriptionId", SubscriptionId)</span></pre><p id="0a0e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe nc nd ne nf b">pack()</code>从一组属性名和值中创建一个动态值，这使我们能够在<code class="fe nc nd ne nf b">EventProperties </code>列中存储不同形式的数据。</p><h1 id="eea3" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">使用时间线</h1><p id="dd27" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">如果我们查询时间表，我们会得到如下结果:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nq nr l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">时间表</p></figure><p id="5886" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们有时间线上的各种事件，它们的特定属性在<code class="fe nc nd ne nf b">EventProperties</code>列中捕获。将这一点与钥匙圈结合起来，我们就可以更好地了解我们的系统是如何被使用的。</p><p id="8d90" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">对于下一个查询，您将需要在<a class="ae lh" rel="noopener" target="_blank" href="/identity-keyrings-201d17295954">上一篇文章</a>中构建的密匙环表:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nq nr l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">钥匙圈表</p></figure><p id="0530" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">让我们回到我们的示例，我们希望将支持票证与订阅取消相关联。以下清单中的查询检索订阅被取消后30天内打开的所有支持票证。</p><pre class="ks kt ku kv gt ng nf nh ni aw nj bi"><span id="9ff0" class="nk mf it nf b gy nl nm l nn no">Timeline<br/>| where EventType == 'SubscriptionClose' // #1<br/>| join kind=inner (Keyring<br/>    | where KeyType == 'CustomerId') on KeyValue  // #2<br/>| join kind=inner (Keyring<br/>    | where KeyType == 'SupportCustomerId') on GroupId  // #3<br/>| join kind=inner (Timeline<br/>    | where EventType == 'SupportTicketOpened') on<br/>      $left.KeyValue2 == $right.KeyValue  // #4<br/>| project Delta=(Timestamp — Timestamp1), CustomerId=KeyValue,<br/>  SupportCustomerId=KeyValue2    // #5<br/>| where Delta &lt; timespan(30d)    // #6</span></pre><p id="ce13" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们首先获取所有的<code class="fe nc nd ne nf b">SubscriptionClose</code>事件(#1)。然后我们用<code class="fe nc nd ne nf b">CustomerId</code>上的钥匙圈表连接得到<code class="fe nc nd ne nf b">GroupId</code> (#2)。然后，我们再次连接<code class="fe nc nd ne nf b">GroupId</code>上的密匙环表，以获得关联的<code class="fe nc nd ne nf b">SupportCustomerId</code> (#3)。最后，我们再次加入<code class="fe nc nd ne nf b">SupportCustomerId</code> ( <code class="fe nc nd ne nf b">KeyValue</code>)上的时间表，寻找<code class="fe nc nd ne nf b">SupportTicketOpened</code>事件(#4)。</p><p id="79c1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们现在已经有了所有需要的数据——我们将<code class="fe nc nd ne nf b">SubscriptionClose</code>和<code class="fe nc nd ne nf b">SupportTicketOpened</code>之间的时间差计算为<code class="fe nc nd ne nf b">Delta</code>。我们有<code class="fe nc nd ne nf b">CustomerId</code>和<code class="fe nc nd ne nf b">SupportCustomerId</code> (#5)。最后，我们通过小于30天的时间差进行筛选(#6)。</p><p id="bdbf" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这里的关键要点是，这些数据点(打开/关闭的支持票证、取消的订阅)来自我们企业的不同系统，并使用不同的id进行标识。使用身份密匙环和时间线，我们将它们聚合到一个公共模式中，从这个模式中我们可以生成我们的业务报告。</p><p id="781e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">概括地说，钥匙圈和时间线都是通用的数据模型，我们可以在系统中可用的原始数据的基础上构建。这些有助于将这些点连接起来，并将原本分散的数据集整合到一个统一的视图中，以了解用户如何与我们的系统进行交互。建立和维护这样的模型是数据工程师的责任。</p></div></div>    
</body>
</html>