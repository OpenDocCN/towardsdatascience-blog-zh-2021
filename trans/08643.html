<html>
<head>
<title>Going Beyond value_counts(): Creating Visually Engaging Frequency Tables With Only 3 Lines Of Code (Using OkCupid Data)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">超越value_counts():只用3行代码创建视觉上引人入胜的频率表(使用OkCupid数据)</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/going-beyond-value-counts-creating-visually-engaging-frequency-tables-with-only-3-lines-of-code-3021c7756991?source=collection_archive---------41-----------------------#2021-08-09">https://towardsdatascience.com/going-beyond-value-counts-creating-visually-engaging-frequency-tables-with-only-3-lines-of-code-3021c7756991?source=collection_archive---------41-----------------------#2021-08-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7d79" class="pw-subtitle-paragraph ju is it bd b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl dk translated">一些你可能不知道的简单而有用的生活窍门</h2></div><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/76db0bf53350d5bd63e050f036f0564d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7TH4zJhuQp9x7EgGiFNOWQ.png"/></div></div><p class="ky kz gj gh gi la lb bd b be z dk translated">图片由作者创作，灵感来自<a class="ae lc" href="http://loveascii.com/hearts.html" rel="noopener ugc nofollow" target="_blank"> Loveascii </a></p></figure><p id="819e" class="pw-post-body-paragraph ld le it lf b lg lh jy li lj lk kb ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">虽然在Python pandas库中为一个系列对象创建频率表最简单的方法是应用<code class="fe jq jr js jt b">value_counts()</code>方法，但是这个操作的结果看起来相当简单。我们可以通过调整方法的布尔参数<code class="fe jq jr js jt b">normalize</code>、<code class="fe jq jr js jt b">sort</code>、<code class="fe jq jr js jt b">ascending</code>和<code class="fe jq jr js jt b">dropna</code>，或者将值(如果它们是数字的话)分组到bin中，来使它提供更多的信息。然而，这里的选项非常有限，所以为了在视觉上增强结果频率表，我们可以考虑一些简单而有用的技巧，比如方法链接、文本定制、为每个频率值添加<code class="fe jq jr js jt b">%</code>符号，以及使用漂亮打印的功能。</p><p id="73b6" class="pw-post-body-paragraph ld le it lf b lg lh jy li lj lk kb ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">在本文中，我们将使用包含年龄、性别、位置、教育等信息的<a class="ae lc" href="https://www.kaggle.com/andrewmvd/okcupid-profiles" rel="noopener ugc nofollow" target="_blank"> Kaggle数据集</a>进行实验。，针对<em class="lz"> OkCupid交友app </em>的6万用户💞。然而，出于我们的目的，我们将只使用用户状态的数据。</p><h1 id="54f7" class="ma mb it bd mc md me mf mg mh mi mj mk kd ml ke mm kg mn kh mo kj mp kk mq mr bi translated">1.方法链接</h1><p id="c74f" class="pw-post-body-paragraph ld le it lf b lg ms jy li lj mt kb ll lm mu lo lp lq mv ls lt lu mw lw lx ly im bi translated">首先，让我们为用户状态创建一个基本频率表:</p><pre class="kn ko kp kq gt mx jt my mz aw na bi"><span id="8755" class="nb mb it jt b gy nc nd l ne nf">import pandas as pd<br/>profiles = pd.read_csv("okcupid_profiles.csv", na_values="unknown")<br/>s = profiles["status"]<br/>s.value_counts()</span><span id="4c40" class="nb mb it jt b gy ng nd l ne nf"><strong class="jt iu">Output:</strong></span><span id="fa95" class="nb mb it jt b gy ng nd l ne nf">single            55697<br/>seeing someone     2064<br/>available          1865<br/>married             310<br/>Name: status, dtype: int64</span></pre><p id="b281" class="pw-post-body-paragraph ld le it lf b lg lh jy li lj lk kb ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">尽管此表清楚地显示了总体趋势，但以相对频率查看此信息会更方便。让我们将<code class="fe jq jr js jt b">True</code>分配给<code class="fe jq jr js jt b">normalize</code>参数，并将结果频率表(它本身是一个序列)分配给一个名为<code class="fe jq jr js jt b">s_norm</code>的变量。</p><p id="55d3" class="pw-post-body-paragraph ld le it lf b lg lh jy li lj lk kb ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">(<em class="lz">旁注:</em>在下文中，我们将默认保留<code class="fe jq jr js jt b">value_counts()</code>方法的所有其他参数，这意味着我们将只考虑按降序排序的频率表，并排除缺失值。对于我们的目的，使用或不使用这些参数并不重要。)</p><pre class="kn ko kp kq gt mx jt my mz aw na bi"><span id="44b1" class="nb mb it jt b gy nc nd l ne nf">s_norm = s.value_counts(normalize=True)<br/>s_norm</span><span id="2e07" class="nb mb it jt b gy ng nd l ne nf"><strong class="jt iu">Output:</strong></span><span id="d458" class="nb mb it jt b gy ng nd l ne nf">single            0.929275<br/>seeing someone    0.034437<br/>available         0.031117<br/>married           0.005172<br/>Name: status, dtype: float64</span></pre><p id="1785" class="pw-post-body-paragraph ld le it lf b lg lh jy li lj lk kb ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">现在所有的频率都被转换成分数，但是我们更喜欢看到百分比，所以让我们把这个系列乘以100:</p><pre class="kn ko kp kq gt mx jt my mz aw na bi"><span id="3d07" class="nb mb it jt b gy nc nd l ne nf">s_pct = s_norm.mul(100)<br/>s_pct</span><span id="42c2" class="nb mb it jt b gy ng nd l ne nf"><strong class="jt iu">Output:</strong></span><span id="d6cc" class="nb mb it jt b gy ng nd l ne nf">single            92.927456<br/>seeing someone     3.443673<br/>available          3.111652<br/>married            0.517218<br/>Name: status, dtype: float64</span></pre><p id="87a1" class="pw-post-body-paragraph ld le it lf b lg lh jy li lj lk kb ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">我们真的不需要如此精确的百分比。此外，让我们想象一下，我们根本不需要小数点:</p><pre class="kn ko kp kq gt mx jt my mz aw na bi"><span id="0861" class="nb mb it jt b gy nc nd l ne nf">s_pct_rounded = s_pct.round()<br/>s_pct_rounded</span><span id="927a" class="nb mb it jt b gy ng nd l ne nf"><strong class="jt iu">Output:</strong></span><span id="8a3e" class="nb mb it jt b gy ng nd l ne nf">single            93.0<br/>seeing someone     3.0<br/>available          3.0<br/>married            1.0<br/>Name: status, dtype: float64</span></pre><p id="c0d8" class="pw-post-body-paragraph ld le it lf b lg lh jy li lj lk kb ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">不幸的是，舍入到整个部分给我们留下了所谓的<a class="ae lc" href="https://pandas.pydata.org/pandas-docs/stable/user_guide/integer_na.html" rel="noopener ugc nofollow" target="_blank">可空整数</a>(即小数部分等于0的浮点数)。要修复它，我们可以使用<code class="fe jq jr js jt b">convert_dtypes()</code>或<code class="fe jq jr js jt b">astype(int)</code>:</p><pre class="kn ko kp kq gt mx jt my mz aw na bi"><span id="dd1c" class="nb mb it jt b gy nc nd l ne nf">s_pct_int = s_pct_rounded.convert_dtypes()<br/>s_pct_int</span><span id="4eda" class="nb mb it jt b gy ng nd l ne nf"><strong class="jt iu">Output:</strong></span><span id="a252" class="nb mb it jt b gy ng nd l ne nf">single            93<br/>seeing someone     3<br/>available          3<br/>married            1<br/>Name: status, dtype: Int64</span></pre><p id="e93e" class="pw-post-body-paragraph ld le it lf b lg lh jy li lj lk kb ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">现在让我们展开<code class="fe jq jr js jt b">s_pct_int</code>的整个表达式，显示我们链接的所有方法:</p><pre class="kn ko kp kq gt mx jt my mz aw na bi"><span id="c2d6" class="nb mb it jt b gy nc nd l ne nf">s_pct_int = profiles['status'].value_counts(normalize=True).mul(100).round().convert_dtypes()</span></pre><h1 id="74df" class="ma mb it bd mc md me mf mg mh mi mj mk kd ml ke mm kg mn kh mo kj mp kk mq mr bi translated">2.添加表格标题</h1><p id="527e" class="pw-post-body-paragraph ld le it lf b lg ms jy li lj mt kb ll lm mu lo lp lq mv ls lt lu mw lw lx ly im bi translated">在不了解上下文的情况下，从上表中无法清楚地看出这些数字代表的是百分比而不是绝对频率。让我们使用f字符串格式为表格添加一个标题:</p><pre class="kn ko kp kq gt mx jt my mz aw na bi"><span id="ab7a" class="nb mb it jt b gy nc nd l ne nf">print(f"OkCupid user statuses, %\n{s_pct_int}")</span><span id="d3aa" class="nb mb it jt b gy ng nd l ne nf"><strong class="jt iu">Output:</strong></span><span id="bb2f" class="nb mb it jt b gy ng nd l ne nf">OkCupid user statuses, %<br/>single            93<br/>seeing someone     3<br/>available          3<br/>married            1<br/>Name: status, dtype: Int64</span></pre><p id="c9f8" class="pw-post-body-paragraph ld le it lf b lg lh jy li lj lk kb ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">一个好主意是，特别是如果我们一次打印出几个频率表，从视觉上突出表的其余部分的标题，例如使其加粗。为此，我们可以使用<a class="ae lc" href="https://en.wikipedia.org/wiki/ANSI_escape_code" rel="noopener ugc nofollow" target="_blank"> ANSI转义码</a>序列。特别是，要在Python中以粗体显示一个字符串，我们应该在该字符串之前添加序列<code class="fe jq jr js jt b">\033[1m</code>,在它之后添加<code class="fe jq jr js jt b">\033[0m</code> —:</p><pre class="kn ko kp kq gt mx jt my mz aw na bi"><span id="65bf" class="nb mb it jt b gy nc nd l ne nf">print(f"\033[1mOkCupid user statuses, %\033[0m\n{s_pct_int}")</span><span id="ce0d" class="nb mb it jt b gy ng nd l ne nf"><strong class="jt iu">Output:</strong></span><span id="8637" class="nb mb it jt b gy ng nd l ne nf"><strong class="jt iu">OkCupid user statuses, %</strong> <br/>single            93 <br/>seeing someone     3 <br/>available          3 <br/>married            1 <br/>Name: status, dtype: Int64</span></pre><h1 id="cfdb" class="ma mb it bd mc md me mf mg mh mi mj mk kd ml ke mm kg mn kh mo kj mp kk mq mr bi translated">3.将<code class="fe jq jr js jt b">%</code>符号加到每个频率值上</h1><p id="4aca" class="pw-post-body-paragraph ld le it lf b lg ms jy li lj mt kb ll lm mu lo lp lq mv ls lt lu mw lw lx ly im bi translated">在上面的例子中，我们给表格标题添加了<code class="fe jq jr js jt b">%</code>符号。如果我们想把它加到每个频率值上呢？这里的一个解决方法是制作一个频率值列表，在每个列表中添加<code class="fe jq jr js jt b">%</code>符号，然后从这个列表中创建一个序列。为了制作列表，我们可以使用下面的For循环:</p><pre class="kn ko kp kq gt mx jt my mz aw na bi"><span id="e9aa" class="nb mb it jt b gy nc nd l ne nf">lst_with_pct_symb = []<br/>for value in s_pct_int.values:<br/>    lst_with_pct_symb.append(f"{value}%")<br/>lst_with_pct_symb</span><span id="94ad" class="nb mb it jt b gy ng nd l ne nf"><strong class="jt iu">Output:</strong></span><span id="24aa" class="nb mb it jt b gy ng nd l ne nf">['93%', '3%', '3%', '1%']</span></pre><p id="772a" class="pw-post-body-paragraph ld le it lf b lg lh jy li lj lk kb ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">或者更简洁地说，一个列表理解:</p><pre class="kn ko kp kq gt mx jt my mz aw na bi"><span id="540a" class="nb mb it jt b gy nc nd l ne nf">lst_with_pct_symb = [f"{value}%" for value in s_pct_int.values]</span></pre><p id="dc92" class="pw-post-body-paragraph ld le it lf b lg lh jy li lj lk kb ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">现在，让我们创建并打印一个更新的频率表。这一次，我们将从标题中删除<code class="fe jq jr js jt b">%</code>符号:</p><pre class="kn ko kp kq gt mx jt my mz aw na bi"><span id="a82d" class="nb mb it jt b gy nc nd l ne nf">s_with_pct_symb = pd.Series(lst_with_pct_symb, index=s_pct_int.index)<br/>print(f"\033[1mOkCupid user statuses\033[0m\n{s_with_pct_symb}")</span><span id="fe7a" class="nb mb it jt b gy ng nd l ne nf"><strong class="jt iu">Output:</strong></span><span id="1542" class="nb mb it jt b gy ng nd l ne nf"><strong class="jt iu">OkCupid user statuses</strong><br/>single            93%<br/>seeing someone     3%<br/>available          3%<br/>married            1%<br/>dtype: object</span></pre><h1 id="ca30" class="ma mb it bd mc md me mf mg mh mi mj mk kd ml ke mm kg mn kh mo kj mp kk mq mr bi translated">4.漂亮的印刷桌子</h1><p id="137b" class="pw-post-body-paragraph ld le it lf b lg ms jy li lj mt kb ll lm mu lo lp lq mv ls lt lu mw lw lx ly im bi translated">最后，我们可以把频率表打印出来。为此，我们将使用<code class="fe jq jr js jt b">to_markdown()</code> pandas方法，该方法需要安装(不一定是导入)<a class="ae lc" href="https://pypi.org/project/tabulate/" rel="noopener ugc nofollow" target="_blank">制表</a>模块(<code class="fe jq jr js jt b">pip install tabulate</code>)。</p><p id="2640" class="pw-post-body-paragraph ld le it lf b lg lh jy li lj lk kb ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated"><strong class="lf iu">重要提示:</strong>为了正确显示结果，只能在<code class="fe jq jr js jt b">print()</code>命令中使用<code class="fe jq jr js jt b">to_markdown()</code>方法。</p><p id="a92e" class="pw-post-body-paragraph ld le it lf b lg lh jy li lj lk kb ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">让我们再次展示名为<code class="fe jq jr js jt b">s_with_pct_symb</code>的用户状态频率表，这次是一个真实的表，使用的是<code class="fe jq jr js jt b">to_markdown()</code>的基本语法。如前所述，我们将添加一个粗体标题并应用f字符串格式。为了一致性，在下文中，我们将要显示的频率表分配给一个名为<code class="fe jq jr js jt b">S</code>的变量:</p><pre class="kn ko kp kq gt mx jt my mz aw na bi"><span id="6c5b" class="nb mb it jt b gy nc nd l ne nf">S = s_with_pct_symb<br/>print(f"\033[1mOkCupid user statuses\033[0m\n{S.to_markdown()}")</span><span id="83bf" class="nb mb it jt b gy ng nd l ne nf"><strong class="jt iu">Output:</strong></span><span id="b4c5" class="nb mb it jt b gy ng nd l ne nf"><strong class="jt iu">OkCupid user statuses</strong><br/>|                | 0   |<br/>|:---------------|:----|<br/>| single         | 93% |<br/>| seeing someone | 3%  |<br/>| available      | 3%  |<br/>| married        | 1%  |</span></pre><p id="098f" class="pw-post-body-paragraph ld le it lf b lg lh jy li lj lk kb ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">我们可能要做的第一件事是删除一个自动创建的表头(在我们的例子中是多余的)。为此，我们必须为一个名为<code class="fe jq jr js jt b">headers</code>的可选参数分配一个空列表或字符串:</p><pre class="kn ko kp kq gt mx jt my mz aw na bi"><span id="0d13" class="nb mb it jt b gy nc nd l ne nf">print(f"\033[1mOkCupid user statuses\033[0m\n{S.to_markdown(headers=[])}")</span><span id="640d" class="nb mb it jt b gy ng nd l ne nf"><strong class="jt iu">Output:</strong></span><span id="d7c8" class="nb mb it jt b gy ng nd l ne nf"><strong class="jt iu">OkCupid user statuses</strong><br/>|:---------------|:----|<br/>| single         | 93% |<br/>| seeing someone | 3%  |<br/>| available      | 3%  |<br/>| married        | 1%  |</span></pre><p id="411e" class="pw-post-body-paragraph ld le it lf b lg lh jy li lj lk kb ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">在<a class="ae lc" href="https://pypi.org/project/tabulate/" rel="noopener ugc nofollow" target="_blank">表格文档</a>中，我们可以找到一些其他参数进行调整。但是，它们大多与DataFrame对象相关。在我们的例子中，假设我们有一个序列，并且记住在添加了<code class="fe jq jr js jt b">%</code>符号之后，频率值实际上变成了字符串，我们有一个小得多的选择。</p><p id="77d3" class="pw-post-body-paragraph ld le it lf b lg lh jy li lj lk kb ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">我们来玩一下参数<code class="fe jq jr js jt b">tablefmt</code>和<code class="fe jq jr js jt b">stralign</code>。它们中的第一个定义了表格格式，可以有下列值之一:<code class="fe jq jr js jt b">plain</code>、<code class="fe jq jr js jt b">simple</code>、<code class="fe jq jr js jt b">github</code>、<code class="fe jq jr js jt b">grid</code>、<code class="fe jq jr js jt b">fancy_grid</code>、<code class="fe jq jr js jt b">pipe</code>、<code class="fe jq jr js jt b">orgtbl</code>、<code class="fe jq jr js jt b">jira</code>、<code class="fe jq jr js jt b">presto</code>、<code class="fe jq jr js jt b">pretty</code>、<code class="fe jq jr js jt b">psql</code>、<code class="fe jq jr js jt b">rst</code>等。例如，我们之前看到的表格格式叫做<code class="fe jq jr js jt b">pipe</code>，这是<code class="fe jq jr js jt b">to_markdown()</code> pandas方法的默认格式。奇怪的是，对于制表软件包本身，默认的表格格式是<code class="fe jq jr js jt b">simple</code>。至于第二个参数<code class="fe jq jr js jt b">stralign</code>，它用于覆盖默认的字符串数据对齐方式(即<code class="fe jq jr js jt b">left</code>)。这里可能的选项是<code class="fe jq jr js jt b">right</code>和<code class="fe jq jr js jt b">center</code>。</p><pre class="kn ko kp kq gt mx jt my mz aw na bi"><span id="ba56" class="nb mb it jt b gy nc nd l ne nf">print(f"\033[1mOkCupid user statuses\033[0m\n"<br/>      f"{S.to_markdown(headers=[], tablefmt='fancy_grid', stralign='right')}")</span><span id="f1de" class="nb mb it jt b gy ng nd l ne nf"><strong class="jt iu">Output:</strong></span><span id="2c0c" class="nb mb it jt b gy ng nd l ne nf"><strong class="jt iu">OkCupid user statuses</strong><br/>╒════════════════╤═════╕<br/>│         single │ 93% │<br/>├────────────────┼─────┤<br/>│ seeing someone │  3% │<br/>├────────────────┼─────┤<br/>│      available │  3% │<br/>├────────────────┼─────┤<br/>│        married │  1% │<br/>╘════════════════╧═════╛</span></pre><p id="3ec6" class="pw-post-body-paragraph ld le it lf b lg lh jy li lj lk kb ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">现在让我们把注意力转向我们之前创建的名为<code class="fe jq jr js jt b">s_pct_int</code>的频率表。提醒其语法和外观:</p><pre class="kn ko kp kq gt mx jt my mz aw na bi"><span id="5422" class="nb mb it jt b gy nc nd l ne nf">s_pct_int = profiles['status'].value_counts(normalize=True).mul(100).round().convert_dtypes()<br/>s_pct_int</span><span id="3b8d" class="nb mb it jt b gy ng nd l ne nf"><strong class="jt iu">Output:</strong></span><span id="0e46" class="nb mb it jt b gy ng nd l ne nf">single            93<br/>seeing someone     3<br/>available          3<br/>married            1<br/>Name: status, dtype: Int64</span></pre><p id="881d" class="pw-post-body-paragraph ld le it lf b lg lh jy li lj lk kb ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">要为<code class="fe jq jr js jt b">s_pct_int</code>创建降价表，添加相应的表头是有意义的。同样，让我们为<code class="fe jq jr js jt b">tablefmt</code>参数尝试一个新值:</p><pre class="kn ko kp kq gt mx jt my mz aw na bi"><span id="acc5" class="nb mb it jt b gy nc nd l ne nf">S = s_pct_int<br/>print(f"\033[1mOkCupid user statuses\033[0m\n"<br/>      f"{S.to_markdown(headers=['STATUS', '%'], tablefmt='github')}")</span><span id="49d4" class="nb mb it jt b gy ng nd l ne nf"><strong class="jt iu">Output:</strong></span><span id="9482" class="nb mb it jt b gy ng nd l ne nf"><strong class="jt iu">OkCupid user statuses</strong><br/>| STATUS         |   % |<br/>|----------------|-----|<br/>| single         |  93 |<br/>| seeing someone |   3 |<br/>| available      |   3 |<br/>| married        |   1 |</span></pre><p id="5563" class="pw-post-body-paragraph ld le it lf b lg lh jy li lj lk kb ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">然而，这里我们有一个好消息:对于数字频率值，我们可以使用<code class="fe jq jr js jt b">floatfmt</code>参数来定制浮点数的格式。这意味着上面方法链中的最后两个方法(<code class="fe jq jr js jt b">round()</code>和<code class="fe jq jr js jt b">convert_dtypes()</code>)是多余的，可以删除。它留给我们之前创建的频率表<code class="fe jq jr js jt b">s_pct</code>:</p><pre class="kn ko kp kq gt mx jt my mz aw na bi"><span id="0538" class="nb mb it jt b gy nc nd l ne nf">s_pct = profiles['status'].value_counts(normalize=True).mul(100)<br/>s_pct</span><span id="dab9" class="nb mb it jt b gy ng nd l ne nf"><strong class="jt iu">Output:</strong></span><span id="1b4f" class="nb mb it jt b gy ng nd l ne nf">single            92.927456<br/>seeing someone     3.443673<br/>available          3.111652<br/>married            0.517218<br/>Name: status, dtype: float64</span></pre><p id="b864" class="pw-post-body-paragraph ld le it lf b lg lh jy li lj lk kb ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">让我们展示一下它的降价表示:</p><pre class="kn ko kp kq gt mx jt my mz aw na bi"><span id="9d2f" class="nb mb it jt b gy nc nd l ne nf">S = s_pct<br/>print(f"\033[1mOkCupid user statuses\033[0m\n"<br/>      f"{S.to_markdown(headers=['STATUS', '%'], tablefmt='github', floatfmt='.0f')}")</span><span id="2f99" class="nb mb it jt b gy ng nd l ne nf"><strong class="jt iu">Output:</strong></span><span id="a3b9" class="nb mb it jt b gy ng nd l ne nf"><strong class="jt iu">OkCupid user statuses</strong><br/>| STATUS         |   % |<br/>|----------------|-----|<br/>| single         |  93 |<br/>| seeing someone |   3 |<br/>| available      |   3 |<br/>| married        |   1 |</span></pre><p id="4470" class="pw-post-body-paragraph ld le it lf b lg lh jy li lj lk kb ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">由于正确的数字格式，我们获得了与前一个相同的表。</p><p id="5e07" class="pw-post-body-paragraph ld le it lf b lg lh jy li lj lk kb ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated"><strong class="lf iu">注意:</strong><code class="fe jq jr js jt b">floatfmt</code>参数不配合表格格式<code class="fe jq jr js jt b">pretty</code>使用。</p><h1 id="71e5" class="ma mb it bd mc md me mf mg mh mi mj mk kd ml ke mm kg mn kh mo kj mp kk mq mr bi translated">实用的外卖</h1><p id="dce6" class="pw-post-body-paragraph ld le it lf b lg ms jy li lj mt kb ll lm mu lo lp lq mv ls lt lu mw lw lx ly im bi translated">尽管上面的整个演练花费了大量的迭代和描述，下面我们将找到4个不同版本的<code class="fe jq jr js jt b">profiles['status']</code>频率表的最终代码解决方案，全部以%表示:</p><ul class=""><li id="fc97" class="nh ni it lf b lg lh lj lk lm nj lq nk lu nl ly nm nn no np bi translated">2个带有/不带有<code class="fe jq jr js jt b">%</code>符号的简单表格，</li><li id="c5f0" class="nh ni it lf b lg nq lj nr lm ns lq nt lu nu ly nm nn no np bi translated">2个印刷精美的表格，带/不带<code class="fe jq jr js jt b">%</code>符号，带/不带表头。</li></ul><p id="9304" class="pw-post-body-paragraph ld le it lf b lg lh jy li lj lk kb ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">每个解决方案最多只需3行简单代码，就能生成感兴趣的频率表的直观有效的表示。</p><pre class="kn ko kp kq gt mx jt my mz aw na bi"><span id="691f" class="nb mb it jt b gy nc nd l ne nf">S = profiles['status'].value_counts(normalize=True).mul(100).round().convert_dtypes()<br/>print(f"\033[1mOkCupid user statuses, %\033[0m\n{S}")</span><span id="1c5d" class="nb mb it jt b gy ng nd l ne nf"><strong class="jt iu">Output:</strong></span><span id="d9b7" class="nb mb it jt b gy ng nd l ne nf"><strong class="jt iu">OkCupid user statuses, %</strong><br/>single            93<br/>seeing someone     3<br/>available          3<br/>married            1<br/>Name: status, dtype: Int64</span></pre></div><div class="ab cl nv nw hx nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="im in io ip iq"><pre class="mx jt my mz aw na bi"><span id="8aff" class="nb mb it jt b gy oc od oe of og nd l ne nf">s_pct_int = profiles['status'].value_counts(normalize=True).mul(100).round().convert_dtypes()<br/>S = pd.Series([f"{value}%" for value in s_pct_int.values], index=s_pct_int.index)<br/>print(f"\033[1mOkCupid user statuses\033[0m\n{S}")</span><span id="e130" class="nb mb it jt b gy ng nd l ne nf"><strong class="jt iu">Output:</strong></span><span id="ebfe" class="nb mb it jt b gy ng nd l ne nf"><strong class="jt iu">OkCupid user statuses</strong><br/>single            93%<br/>seeing someone     3%<br/>available          3%<br/>married            1%<br/>dtype: object</span></pre></div><div class="ab cl nv nw hx nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="im in io ip iq"><pre class="mx jt my mz aw na bi"><span id="294c" class="nb mb it jt b gy oc od oe of og nd l ne nf">S = profiles['status'].value_counts(normalize=True).mul(100)<br/>print(f"\033[1mOkCupid user statuses\033[0m\n"<br/>      f"{S.to_markdown(headers=['STATUS', '%'], tablefmt='github', floatfmt='.0f')}")</span><span id="8804" class="nb mb it jt b gy ng nd l ne nf"><strong class="jt iu">Output:</strong></span><span id="a4eb" class="nb mb it jt b gy ng nd l ne nf"><strong class="jt iu">OkCupid user statuses</strong><br/>| STATUS         |   % |<br/>|----------------|-----|<br/>| single         |  93 |<br/>| seeing someone |   3 |<br/>| available      |   3 |<br/>| married        |   1 |</span></pre></div><div class="ab cl nv nw hx nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="im in io ip iq"><pre class="mx jt my mz aw na bi"><span id="b7a4" class="nb mb it jt b gy oc od oe of og nd l ne nf">s_pct_int = profiles['status'].value_counts(normalize=True).mul(100).round().convert_dtypes()<br/>S = pd.Series([f"{value}%" for value in s_pct_int.values], index=s_pct_int.index)<br/>print(f"\033[1mOkCupid user statuses\033[0m\n{S.to_markdown(headers=[], tablefmt='fancy_grid')}")</span><span id="86a0" class="nb mb it jt b gy ng nd l ne nf"><strong class="jt iu">Output:</strong></span><span id="20c0" class="nb mb it jt b gy ng nd l ne nf"><strong class="jt iu">OkCupid user statuses</strong><br/>╒════════════════╤═════╕<br/>│ single         │ 93% │<br/>├────────────────┼─────┤<br/>│ seeing someone │ 3%  │<br/>├────────────────┼─────┤<br/>│ available      │ 3%  │<br/>├────────────────┼─────┤<br/>│ married        │ 1%  │<br/>╘════════════════╧═════╛</span></pre><h1 id="b06c" class="ma mb it bd mc md me mf mg mh mi mj mk kd ml ke mm kg mn kh mo kj mp kk mq mr bi translated">结论</h1><p id="d8bf" class="pw-post-body-paragraph ld le it lf b lg ms jy li lj mt kb ll lm mu lo lp lq mv ls lt lu mw lw lx ly im bi translated">在本文中，我们讨论了一些简单而强大的方法来改进频率表的布局和整体可读性。他们都有<code class="fe jq jr js jt b">value_counts()</code>熊猫方法作为核心部分，但都超越了它，产生了更有影响力的表现。更重要的是，每个建议的解决方案，在其最终形式下，最多需要3行代码。</p><p id="2d7f" class="pw-post-body-paragraph ld le it lf b lg lh jy li lj lk kb ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">我希望你喜欢阅读我的文章，并发现它很有帮助。感谢大家的阅读，祝使用OkCupid交友app的人好运😉💘</p></div><div class="ab cl nv nw hx nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="im in io ip iq"><p id="9869" class="pw-post-body-paragraph ld le it lf b lg lh jy li lj lk kb ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated"><strong class="lf iu">你会发现这些文章也很有趣:</strong></p><div class="oh oi gp gr oj ok"><a rel="noopener follow" target="_blank" href="/5-pandas-methods-youve-never-used-and-you-didn-t-lose-anything-37277fae7c55"><div class="ol ab fo"><div class="om ab on cl cj oo"><h2 class="bd iu gy z fp op fr fs oq fu fw is bi translated">你从未用过的5种熊猫方法…而且你没有失去任何东西！</h2><div class="or l"><h3 class="bd b gy z fp op fr fs oq fu fw dk translated">你知道他们到底什么时候能帮上忙吗？</h3></div><div class="os l"><p class="bd b dl z fp op fr fs oq fu fw dk translated">towardsdatascience.com</p></div></div><div class="ot l"><div class="ou l ov ow ox ot oy kw ok"/></div></div></a></div><div class="oh oi gp gr oj ok"><a rel="noopener follow" target="_blank" href="/an-unconventional-yet-convenient-matplotlib-broken-barh-function-and-when-it-is-particularly-88887b76c127"><div class="ol ab fo"><div class="om ab on cl cj oo"><h2 class="bd iu gy z fp op fr fs oq fu fw is bi translated">一个非常规但方便的Matplotlib Broken_Barh函数，当它特别…</h2><div class="or l"><h3 class="bd b gy z fp op fr fs oq fu fw dk translated">它是什么，如何使用和定制，何时使用</h3></div><div class="os l"><p class="bd b dl z fp op fr fs oq fu fw dk translated">towardsdatascience.com</p></div></div><div class="ot l"><div class="oz l ov ow ox ot oy kw ok"/></div></div></a></div><div class="oh oi gp gr oj ok"><a rel="noopener follow" target="_blank" href="/2-efficient-ways-of-creating-fancy-pictogram-charts-in-python-8b77d361d500"><div class="ol ab fo"><div class="om ab on cl cj oo"><h2 class="bd iu gy z fp op fr fs oq fu fw is bi translated">用Python创建精美象形图的两种有效方法</h2><div class="or l"><h3 class="bd b gy z fp op fr fs oq fu fw dk translated">什么是象形图，何时使用，以及如何在Plotly和PyWaffle库中创建它们</h3></div><div class="os l"><p class="bd b dl z fp op fr fs oq fu fw dk translated">towardsdatascience.com</p></div></div><div class="ot l"><div class="pa l ov ow ox ot oy kw ok"/></div></div></a></div></div></div>    
</body>
</html>