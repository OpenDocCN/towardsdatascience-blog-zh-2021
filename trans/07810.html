<html>
<head>
<title>Create “Weather-Proof” Validations for your Time Series Forecasting Model</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为您的时间序列预测模型创建“不受天气影响”的验证</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/create-weather-proof-validations-for-your-time-series-forecasting-model-d456a1037c4f?source=collection_archive---------20-----------------------#2021-07-17">https://towardsdatascience.com/create-weather-proof-validations-for-your-time-series-forecasting-model-d456a1037c4f?source=collection_archive---------20-----------------------#2021-07-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5827" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用Python构建最终时间预测的指南</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/1109017fb716cf47d855f633bba8bf0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*tJw40Eby4gss-OEA"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">马尔科·布里托在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="abb9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">时间旅行！！—是时候让我们的探索更上一层楼，致力于预测依赖于时间的结果了。时间序列是以时间间隔出现的一系列数据。这些时间间隔可以是每小时、每天、每周或任何可量化的重复持续时间。在一定时间间隔内进行的一系列观察称为时间序列。</p><blockquote class="lv"><p id="e5f9" class="lw lx it bd ly lz ma mb mc md me lu dk translated">预测时间序列处理的是预测下一个周期或在未来参考时间框架内发生的事件观察。</p></blockquote><p id="f73e" class="pw-post-body-paragraph kz la it lb b lc mf ju le lf mg jx lh li mh lk ll lm mi lo lp lq mj ls lt lu im bi translated">在整个故事中，我们的目标是建立一个对所有问题都理想的时间序列预测。这里的想法是不要为一个问题建立最佳解决方案，而是为大多数问题建立一个可以接近的解决方案。</p><p id="2832" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">成功的时间序列所需的重要结构和测试</strong></p><ol class=""><li id="d069" class="mk ml it lb b lc ld lf lg li mm lm mn lq mo lu mp mq mr ms bi translated">重采样</li><li id="05e1" class="mk ml it lb b lc mt lf mu li mv lm mw lq mx lu mp mq mr ms bi translated">时间序列的平稳性</li><li id="be43" class="mk ml it lb b lc mt lf mu li mv lm mw lq mx lu mp mq mr ms bi translated">ARIMA和皮拉明德·ARIMA造型</li><li id="99db" class="mk ml it lb b lc mt lf mu li mv lm mw lq mx lu mp mq mr ms bi translated">季节性和缺失值插补</li><li id="146d" class="mk ml it lb b lc mt lf mu li mv lm mw lq mx lu mp mq mr ms bi translated">Ad-Fuller (ADF)测试</li><li id="8e67" class="mk ml it lb b lc mt lf mu li mv lm mw lq mx lu mp mq mr ms bi translated">自相关和偏相关</li><li id="7871" class="mk ml it lb b lc mt lf mu li mv lm mw lq mx lu mp mq mr ms bi translated">格兰杰因果检验</li></ol><p id="a4b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">了解时间序列预测的流程</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi my"><img src="../Images/ba51303045c10808856cfa0c353f8a3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fycSKI_z91K5mJjssrEuDw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">时序预测和分析的逐步流程|作者图片</p></figure><p id="ad6a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> Panel Data: </strong> Panel是一个基于时间的数据集，除了序列数据之外，还包含一个或多个在某些时间段量化的关联变量。这些因变量有助于为预测“Y”的值提供有价值的见解。</p><p id="7f42" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">时间序列中的滞后:</strong> Lag，作为一个通用的英文术语，指的是较慢的响应时间，通常称为潜伏期。在时间序列预测或分析中，1到8范围内的滞后被认为适用于季度定时数据。对于以月为间隔的时间序列，6、12或24的滞后被认为是合适的。为了更好地理解滞后，让我们看一下这个场景。对于属于时间序列的一组离散值，对于滞后1，此时间序列将与当前时间序列之前的同一时间序列进行比较。换句话说，时间序列被移动到过去的一个时间段。</p><blockquote class="mz na nb"><p id="542c" class="kz la nc lb b lc ld ju le lf lg jx lh nd lj lk ll ne ln lo lp nf lr ls lt lu im bi translated">了解数据集是时间序列还是面板的一种方法是了解时间列是否是影响预测结果的唯一数据部分。</p></blockquote><p id="02eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从下一节开始，我们开始动手(我们编码！！)而且为了简单起见，我在这个故事里只加伪代码。但是，为了能够遍历整个代码，我链接了下面的代码库。这只是一个Python笔记本，我建议您跟随这个故事。</p><div class="ng nh gp gr ni nj"><a href="https://github.com/rjrahul24/ai-with-python-series/tree/main/05.%20Build%20Concrete%20Time%20Series%20Forecasts" rel="noopener  ugc nofollow" target="_blank"><div class="nk ab fo"><div class="nl ab nm cl cj nn"><h2 class="bd iu gy z fp no fr fs np fu fw is bi translated">rjrahul 24/时间序列预测</h2><div class="nq l"><h3 class="bd b gy z fp no fr fs np fu fw dk translated">Python系列教程，旨在学习人工智能概念。</h3></div><div class="nr l"><p class="bd b dl z fp no fr fs np fu fw dk translated">github.com</p></div></div><div class="ns l"><div class="nt l nu nv nw ns nx ks nj"/></div></div></a></div><h1 id="2fca" class="ny nz it bd oa ob oc od oe of og oh oi jz oj ka ok kc ol kd om kf on kg oo op bi translated">1.对时间序列进行重采样</h1><p id="fc59" class="pw-post-body-paragraph kz la it lb b lc oq ju le lf or jx lh li os lk ll lm ot lo lp lq ou ls lt lu im bi translated">重采样是一种用于改变时间序列观测频率的技术。在pandas的数据帧中，重采样方法使这种频率转换变得很方便。所需的先决条件是，对象必须具有DateTime数据类型格式(DateTime、DateTimeIndex、PeriodIndex、TimeDeltaIndex等。).如下所述，存在两种重采样类型。<strong class="lb iu"> <em class="nc">虽然，在这两种情况下，都必须发明数据。</em>T3】</strong></p><ol class=""><li id="d783" class="mk ml it lb b lc ld lf lg li mm lm mn lq mo lu mp mq mr ms bi translated"><strong class="lb iu">上采样</strong>:增加采样数据的频率。例如，将基于分钟的频率更改为秒。</li><li id="9c02" class="mk ml it lb b lc mt lf mu li mv lm mw lq mx lu mp mq mr ms bi translated"><strong class="lb iu">下采样</strong>:上采样的反过程。例如，将基于天的频率更改为月。</li></ol><p id="8017" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当数据可用的频率与您进行分析的频率不同时，需要进行重采样。</p><blockquote class="mz na nb"><p id="d65e" class="kz la nc lb b lc ld ju le lf lg jx lh nd lj lk ll ne ln lo lp nf lr ls lt lu im bi translated">但在最常见的情况下，重采样用于为监督学习算法提供某种程度的附加结构和对机器学习问题的洞察。</p></blockquote><pre class="kj kk kl km gt ov ow ox oy aw oz bi"><span id="9d74" class="pa nz it ow b gy pb pc l pd pe"># The series module from Pandas will help in creating a time series<br/>from pandas import Series,DataFrame<br/>import seaborn as sns</span><span id="af57" class="pa nz it ow b gy pf pc l pd pe"># Before resampling<br/>timeseries_mm = time_series['wind_speed']<br/>timeseries_mm.plot(style='g--')<br/>plt.show()</span><span id="83d7" class="pa nz it ow b gy pf pc l pd pe"># Resampling the dataset using the Mean() resample method<br/>timeseries_mm = time_series['wind_speed'].resample("A").mean()<br/>timeseries_mm.plot(style='g--')<br/>plt.show()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pg"><img src="../Images/4e5ebf9f23d811a06fd5f45790634af5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Uqm-KyB2EbllCu-lEoBs4Q@2x.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">时间序列重采样前后记录的风速变化|作者提供的图像</p></figure><h1 id="d2aa" class="ny nz it bd oa ob oc od oe of og oh oi jz oj ka ok kc ol kd om kf on kg oo op bi translated">2.平稳和非平稳时间序列</h1><p id="8c3b" class="pw-post-body-paragraph kz la it lb b lc oq ju le lf or jx lh li os lk ll lm ot lo lp lq ou ls lt lu im bi translated">平稳性被认为是每个时间序列的一个特征。在平稳序列的情况下，时间序列的值不是时间的函数。</p><blockquote class="mz na nb"><p id="07e0" class="kz la nc lb b lc ld ju le lf lg jx lh nd lj lk ll ne ln lo lp nf lr ls lt lu im bi translated">这意味着当前值与过去值的均值、方差和自相关等测量值都是恒定的。平稳的时间序列也不受季节变化的影响。</p></blockquote><p id="0109" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">几乎每一个时间序列都可以通过适当的变换变得平稳。</p><h2 id="3f0d" class="pa nz it bd oa ph pi dn oe pj pk dp oi li pl pm ok lm pn po om lq pp pq oo pr bi translated"><strong class="ak">使时间序列平稳</strong></h2><p id="6233" class="pw-post-body-paragraph kz la it lb b lc oq ju le lf or jx lh li os lk ll lm ot lo lp lq ou ls lt lu im bi translated">使用以下提到的任何一种方法都可以使时间序列数据变得平稳:</p><ol class=""><li id="7a73" class="mk ml it lb b lc ld lf lg li mm lm mn lq mo lu mp mq mr ms bi translated">对序列进行一次或多次差分:差分的概念是用当前时间中的序列值减去前一时间单位中同一序列的值，将使其保持不变。也就是说，用当前值减去下一个值叫做差分。<br/> — <strong class="lb iu"> <em class="nc">比如考虑以下数列:[1，5，2，12，20]。一阶差分给出:[5–1，2–5，12–2，20–12]=[4，-3，10，8]。第二次求差得到:[-3–4，-10–3，8–10]=[-7，-13，-2] </em> </strong></li><li id="99cd" class="mk ml it lb b lc mt lf mu li mv lm mw lq mx lu mp mq mr ms bi translated">获取现有时间序列的日志</li><li id="78de" class="mk ml it lb b lc mt lf mu li mv lm mw lq mx lu mp mq mr ms bi translated">取当前数列的第n个根。</li><li id="2def" class="mk ml it lb b lc mt lf mu li mv lm mw lq mx lu mp mq mr ms bi translated">结合一种或多种上述技术。</li></ol><h2 id="3794" class="pa nz it bd oa ph pi dn oe pj pk dp oi li pl pm ok lm pn po om lq pp pq oo pr bi translated"><strong class="ak">为什么平稳时间序列很重要？</strong></h2><p id="4094" class="pw-post-body-paragraph kz la it lb b lc oq ju le lf or jx lh li os lk ll lm ot lo lp lq ou ls lt lu im bi translated">平稳的时间序列比较容易预测，也比较可靠。</p><blockquote class="mz na nb"><p id="2142" class="kz la nc lb b lc ld ju le lf lg jx lh nd lj lk ll ne ln lo lp nf lr ls lt lu im bi translated">原因是，预测模型基本上是线性回归算法，利用这些系列数据的滞后来形成预测值。</p></blockquote><p id="5880" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还知道，线性回归算法在预测值(X)彼此不相关的情况下效果最好。使时间序列平稳可消除预测值之间的所有和任何持续的自相关，从而使序列更适合回归分析。一旦序列的滞后或预测因子是独立的，预测就有望给出可靠的预测。</p><p id="6430" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">* *下节中的Ad-Fuller测试将测试系列的稳定性。</strong></p><h1 id="23c9" class="ny nz it bd oa ob oc od oe of og oh oi jz oj ka ok kc ol kd om kf on kg oo op bi translated">3.ARIMA和皮拉明德·ARIMA造型</h1><p id="e447" class="pw-post-body-paragraph kz la it lb b lc oq ju le lf or jx lh li os lk ll lm ot lo lp lq ou ls lt lu im bi translated">统计学和经济学领域的通用术语，<strong class="lb iu">【自回归综合移动平均线(ARIMA)】</strong>用于描述移动平均线构造。他们对建立时间序列预测模型产生了浓厚的兴趣。</p><blockquote class="lv"><p id="3f5a" class="lw lx it bd ly lz ma mb mc md me lu dk translated">ARIMA模型适用于输入数据在均值意义上显示非平稳性的证据，但没有观察到显著差异的情况。</p></blockquote><p id="d74b" class="pw-post-body-paragraph kz la it lb b lc mf ju le lf mg jx lh li mh lk ll lm mi lo lp lq mj ls lt lu im bi translated">我们可以将ARIMA的定义分解如下，ARIMA的AR部分代表一个进化变量，它根据自身滞后(旧值)进行回归。MA部分显示回归误差，它是过去不同时间出现的误差项的线性组合。剩下的“I”(积分)表示数据被当前值和先前值之间的差异所取代。这些单独的过程可能需要执行多次。每个功能的目的都是使模型尽可能符合数据。</p><blockquote class="mz na nb"><p id="7822" class="kz la nc lb b lc ld ju le lf lg jx lh nd lj lk ll ne ln lo lp nf lr ls lt lu im bi translated"><a class="ae ky" href="https://pypi.org/project/pyramid-arima/" rel="noopener ugc nofollow" target="_blank">来自Python文档</a> — Pyramid是一个严肃的统计Python库，只有一个目标:将R的auto.arima功能引入Python。金字塔的运作方式是将<strong class="lb iu"> statsmodels.tsa.ARIMA </strong>和<strong class="lb iu">stats models . TSA . statespace . sarimax</strong>包装到一个估算器类中，并为熟悉scikit-learn的程序员创建一个更加用户友好的估算器界面。</p></blockquote><p id="d2df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">pmdarima最初被称为pyramid-arima，是一个统计库，有助于填补Python时间序列中的数据空白。它包含一组用于检查平稳性和季节性的统计测试。还包括时间序列差分和逆差分等功能。</p><pre class="kj kk kl km gt ov ow ox oy aw oz bi"><span id="1055" class="pa nz it ow b gy pb pc l pd pe"># Predicting Wind Speeds using "pmdarima" package in Python</span><span id="c68d" class="pa nz it ow b gy pf pc l pd pe">from pmdarima.arima import auto_arima<br/>from pmdarima.arima import ADFTest</span><span id="0324" class="pa nz it ow b gy pf pc l pd pe">train=df[:1300]<br/>test=df[-250:]<br/>plt.figure(figsize=(15,10))</span><span id="8f80" class="pa nz it ow b gy pf pc l pd pe">adf_test=ADFTest(alpha=0.05)<br/>adf_test.should_diff(time_series_train["wind_speed"])<br/>df = time_series_train["wind_speed"]</span><span id="b933" class="pa nz it ow b gy pf pc l pd pe">model = auto_arima(train,start_p=0,d=1,start_q=0,max_p=5,max_d=5,max_q=5, start_P=0,D=1, start_Q=0, max_P=5,max_D=5,max_Q=5, m=12,seasonal=True,error_action='warn',trace=True,supress_warnings=True,stepwise=True,random_state=20,n_fits=50)</span><span id="cac2" class="pa nz it ow b gy pf pc l pd pe">plt.plot(train)<br/>plt.plot(test)<br/>plt.autoscale()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ps"><img src="../Images/d50e3be56ad93aa8c64f9c37bde98095.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-uaVajK9ukWJJr-ObSTJLg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用pmdarima风速模型预测的数据部分(橙色)|图片由作者提供</p></figure><h1 id="c38c" class="ny nz it bd oa ob oc od oe of og oh oi jz oj ka ok kc ol kd om kf on kg oo op bi translated">4.季节性和缺失值插补</h1><p id="e66f" class="pw-post-body-paragraph kz la it lb b lc oq ju le lf or jx lh li os lk ll lm ot lo lp lq ou ls lt lu im bi translated">时间序列数据的季节性是指在小于一年的特定时间间隔内出现的变化。这些时间间隔可以是每小时、每月、每周或每季度。天气或气候变化等各种因素会导致季节性。</p><blockquote class="lv"><p id="7ef7" class="lw lx it bd ly lz ma mb mc md me lu dk translated">造成季节性的模式总是循环的，并以周期性模式出现。</p></blockquote><p id="6bd8" class="pw-post-body-paragraph kz la it lb b lc mf ju le lf mg jx lh li mh lk ll lm mi lo lp lq mj ls lt lu im bi translated">对于工作依赖于这些变化的企业来说，如股票市场、劳工组织等，理解季节性是很重要的。季节性变化有几个研究的理由和意义:</p><ul class=""><li id="b629" class="mk ml it lb b lc ld lf lg li mm lm mn lq mo lu pt mq mr ms bi translated">对数据集季节性影响的解释提供了对季节性变化对数据影响的详细理解。</li><li id="c9c0" class="mk ml it lb b lc mt lf mu li mv lm mw lq mx lu pt mq mr ms bi translated">一旦一个季节模式被建立，重要的方法可以被用来从时间序列中消除它。这将有助于研究数据集其他不规则成分的影响。去季节性是消除季节性的概念。</li><li id="a4fb" class="mk ml it lb b lc mt lf mu li mv lm mw lq mx lu pt mq mr ms bi translated">季节性和规律性变化的历史模式有助于预测类似数据的未来趋势。例如，气候模式的预测。</li></ul><h2 id="3ef2" class="pa nz it bd oa ph pi dn oe pj pk dp oi li pl pm ok lm pn po om lq pp pq oo pr bi translated"><strong class="ak">处理时间序列内的缺失值</strong></h2><p id="7e00" class="pw-post-body-paragraph kz la it lb b lc oq ju le lf or jx lh li os lk ll lm ot lo lp lq ou ls lt lu im bi translated">在任何数据集中观察到缺失数据是很常见的。类似地，对于表示时间序列的数据，可以观察到缺少日期或时间的序列。数据总是有可能被捕获并且为零。在这种情况下，需要忽略假阴性。</p><blockquote class="mz na nb"><p id="de9d" class="kz la nc lb b lc ld ju le lf lg jx lh nd lj lk ll ne ln lo lp nf lr ls lt lu im bi translated">此外，需要注意的重要一点是，对于时间序列数据，均值或中值插补不是一个好的做法。特别是，如果时间序列没有表现出平稳性。更好、更明智的方法是用该时间段的历史值填充远期数据。</p></blockquote><p id="ed55" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，基于对数据的研究和序列的前景，可以尝试多种方法来估算缺失值。以下是一些值得注意的输入缺失时间序列值的常用技术:</p><ul class=""><li id="e1a7" class="mk ml it lb b lc ld lf lg li mm lm mn lq mo lu pt mq mr ms bi translated">反向填充</li><li id="3298" class="mk ml it lb b lc mt lf mu li mv lm mw lq mx lu pt mq mr ms bi translated">线性内插法</li><li id="7f83" class="mk ml it lb b lc mt lf mu li mv lm mw lq mx lu pt mq mr ms bi translated">二次插值法</li><li id="ebb5" class="mk ml it lb b lc mt lf mu li mv lm mw lq mx lu pt mq mr ms bi translated">最近邻居的平均值</li><li id="c775" class="mk ml it lb b lc mt lf mu li mv lm mw lq mx lu pt mq mr ms bi translated">季节性对应平均值</li></ul><p id="7200" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将新值引入数据集后，测量时间序列的性能也很重要。</p><blockquote class="mz na nb"><p id="58fa" class="kz la nc lb b lc ld ju le lf lg jx lh nd lj lk ll ne ln lo lp nf lr ls lt lu im bi translated">使用两种或多种方法输入值，然后使用均方根(RMSE)等方法计算模型的精度，这被认为是一种良好的做法。这有助于决定哪种插补技术最适合数据。</p></blockquote><h1 id="3985" class="ny nz it bd oa ob oc od oe of og oh oi jz oj ka ok kc ol kd om kf on kg oo op bi translated">5.Ad-Fuller (ADF)测试</h1><p id="50d9" class="pw-post-body-paragraph kz la it lb b lc oq ju le lf or jx lh li os lk ll lm ot lo lp lq ou ls lt lu im bi translated">扩展的Dickey-Fuller检验(ADF)，也称为Ad-Fuller检验，是时间序列分析的一种重要检验机制。它测试一个基本的零假设，即给定的输入单位根存在于整个时间序列样本中。另一个假设通常是序列的平稳性或趋势平稳性。</p><blockquote class="mz na nb"><p id="185c" class="kz la nc lb b lc ld ju le lf lg jx lh nd lj lk ll ne ln lo lp nf lr ls lt lu im bi translated">在这个测试中主要使用的增强的Dickey-Fuller(ADF)统计是一个负数。越是否定，对某个置信水平下存在单位根的假设的否定越强。</p></blockquote><p id="cfbc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Ad-Fuller测试背后的启示是，如果时间序列以单位根过程为特征，那么在这种情况下，序列(y-1)的滞后水平将不会产生任何预测(y)未来变化的相关信息，除了在(y-1)的delta中观察到的那些变化。<em class="nc">在这种情况下，零假设不被拒绝。</em>另一方面，如果现有过程没有单位根，则表明它是稳定的，因此显示出向均值的回归。这里，滞后水平将提供预测未来变化的相关信息。</p><pre class="kj kk kl km gt ov ow ox oy aw oz bi"><span id="6fdf" class="pa nz it ow b gy pb pc l pd pe"># Statsmodel and Adfuller will help in testing the stationarity of the time series<br/>import statsmodels<br/>from statsmodels.tsa.stattools import adfuller</span><span id="083c" class="pa nz it ow b gy pf pc l pd pe"># Decomposing the time series with Statsmodels Decompose Method<br/>from statsmodels.tsa.seasonal import seasonal_decompose<br/>sd_1 = seasonal_decompose(time_series_train["meantemp"])<br/>sd_2 = seasonal_decompose(time_series_train["humidity"])<br/>sd_3 = seasonal_decompose(time_series_train["wind_speed"])<br/>sd_4 = seasonal_decompose(time_series_train["meanpressure"])<br/>sd_1.plot()<br/>sd_2.plot()<br/>sd_3.plot()<br/>sd_4.plot()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pu"><img src="../Images/f54b281a783f9b13f4ace798e8c4cb08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*48pJBrcFTL5glqKECp-t6w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">所有列的季节性分解|按作者分类的图像</p></figure><pre class="kj kk kl km gt ov ow ox oy aw oz bi"><span id="4c0b" class="pa nz it ow b gy pb pc l pd pe"># From the above graph’s observations, it looks like everything other than meanpressure is already stationary<br/># To re-confirm stationarity, we will run all columns through the ad-fuller test</span><span id="0f45" class="pa nz it ow b gy pf pc l pd pe">adfuller(time_series_train["meantemp"])<br/>adfuller(time_series_train["humidity"])<br/>adfuller(time_series_train["wind_speed"])<br/>adfuller(time_series_train["meanpressure"])</span><span id="fd85" class="pa nz it ow b gy pf pc l pd pe"># Consolidate the ad-fuller tests to test from static data<br/>temp_var = time_series_train.columns<br/>print('significance level : 0.05')<br/>for var in temp_var:<br/>  ad_full = adfuller(time_series_train[var])<br/>  print(f'For {var}')<br/>  print(f'Test static {ad_full[1]}',end='\n \n')</span><span id="4621" class="pa nz it ow b gy pf pc l pd pe"><strong class="ow iu"><em class="nc">&gt;&gt;&gt; significance level : 0.05 <br/>&gt;&gt;&gt; For meantemp Test static 0.2774121372301611   <br/>&gt;&gt;&gt; For humidity Test static 0.004470100478130758   <br/>&gt;&gt;&gt; For wind_speed Test static 0.0025407221531464   <br/>&gt;&gt;&gt; For meanpressure Test static 0.0</em></strong></span></pre><p id="3e29" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过ad-fuller检验，我们现在可以得出结论，所有数据都是静态的，因为静态检验低于显著性水平。这也否定了平均压力不是静态的假设。</p><h1 id="2f8a" class="ny nz it bd oa ob oc od oe of og oh oi jz oj ka ok kc ol kd om kf on kg oo op bi translated">6.自相关和偏相关</h1><p id="548a" class="pw-post-body-paragraph kz la it lb b lc oq ju le lf or jx lh li os lk ll lm ot lo lp lq ou ls lt lu im bi translated"><strong class="lb iu">自相关</strong>:序列与其滞后时间的相关性称为自相关。就像相关性测量两个变量之间线性关系的大小一样，自相关在时间序列的滞后值之间也是如此。如果时间序列有很大的自相关性，这意味着滞后对时间序列预测的影响很大。更一般地说，相关因子1(滞后= 1)表示彼此相隔一个周期的值之间的相关性。同样，滞后“k”自相关显示了彼此独立的“k”个时间段的值之间的关联。</p><p id="bd06" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">偏相关:</strong>偏相关的目的也类似于自相关，因为它传达了关于变量及其滞后之间关系的信息。但是部分自相关仅提供滞后之间的纯关联的细节，而忽略了中间滞后产生的相关性。</p><pre class="kj kk kl km gt ov ow ox oy aw oz bi"><span id="b878" class="pa nz it ow b gy pb pc l pd pe"># Plotting the test data with auto correlation<br/>from statsmodels.graphics.tsaplots import plot_acf</span><span id="53e4" class="pa nz it ow b gy pf pc l pd pe"># The next 6 periods of mean temperature (graph 1) and wind_speed (graph 2)<br/>plot_acf(df_forecast["meantemp"])<br/>plot_acf(df_forecast["wind_speed"])</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pv"><img src="../Images/9e2e78df444766f52a52851f61c4b44a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ukFvuxUgElsnaT1c2d9OHQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">平均温度和风速的自相关|图片作者</p></figure><h1 id="e23c" class="ny nz it bd oa ob oc od oe of og oh oi jz oj ka ok kc ol kd om kf on kg oo op bi translated">7.格兰杰因果检验</h1><p id="1607" class="pw-post-body-paragraph kz la it lb b lc oq ju le lf or jx lh li os lk ll lm ot lo lp lq ou ls lt lu im bi translated">格兰杰因果关系检验有助于通过分析相似的时间序列来理解时间序列的行为。</p><blockquote class="mz na nb"><p id="a1e3" class="kz la nc lb b lc ld ju le lf lg jx lh nd lj lk ll ne ln lo lp nf lr ls lt lu im bi translated">该测试假设，如果一个事件X导致另一个事件Y的发生，那么基于前面的Y和X的组合值的Y的未来预测应该超过单独基于Y的Y的预测。</p></blockquote><blockquote class="lv"><p id="42e2" class="lw lx it bd ly lz pw px py pz qa lu dk translated">因此，这里需要注意的是，格兰杰因果关系不应该在事件Y的滞后导致Y的情况下使用。</p></blockquote><p id="65d5" class="pw-post-body-paragraph kz la it lb b lc mf ju le lf mg jx lh li mh lk ll lm mi lo lp lq mj ls lt lu im bi translated">带有PyPi的statsmodel包实现了格兰杰因果关系检验。该方法接受一个有两列的二维数组作为其主参数。第一列包含值，第二列包含预测值(X)。这里的零假设是，属于第二列的序列不会导致属于第一列的序列出现。<strong class="lb iu"> <em class="nc">如果P值小于预定义的显著性水平0.05，则拒绝零假设。这也得出结论，X的滞后是有用的。</em> </strong>第二个参数<em class="nc">“maxlag”</em>允许您输入Y需要包含在测试中的最大滞后数。</p><pre class="kj kk kl km gt ov ow ox oy aw oz bi"><span id="1a8f" class="pa nz it ow b gy pb pc l pd pe"># Import Granger Causality module from the statsmodels package and use the Chi-Squared test metric<br/>from statsmodels.tsa.stattools import grangercausalitytests<br/>test_var = time_series.columns<br/>lag_max = 12<br/>test_type = 'ssr_chi2test'</span><span id="65d1" class="pa nz it ow b gy pf pc l pd pe">causal_val = DataFrame(np.zeros((len(test_var),len(test_var))),columns=test_var,index=test_var)<br/>for a in test_var:<br/>  for b in test_var:<br/>    c = grangercausalitytests ( time_series [ [b,a] ], maxlag = lag_max, verbose = False)<br/>    pred_val = [round ( c [ i +1 ] [0] [test_type] [1], 5 ) for i in range (lag_max) ]<br/>    min_value = np.min (pred_val)<br/>    causal_val.loc[b,a] = min_value<br/>causal_val</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi qb"><img src="../Images/d6a6aeef97a35101fd5fc93f45bf6ac1.png" data-original-src="https://miro.medium.com/v2/resize:fit:926/format:webp/1*U6BiBqdQA3ULFPhZ6dgEag.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="eaee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nc">格兰杰因果关系的结果证明了这些特征之间的密切相关性。</em></p><h1 id="6256" class="ny nz it bd oa ob oc od oe of og oh oi jz oj ka ok kc ol kd om kf on kg oo op bi translated">结论</h1><p id="4499" class="pw-post-body-paragraph kz la it lb b lc oq ju le lf or jx lh li os lk ll lm ot lo lp lq ou ls lt lu im bi translated">时间序列是一个巨大的主题，包括本章没有讨论的各种其他奇点，这应该被认为是这一领域研究的开始。分析从研究时间序列数据开始，了解平稳性，测试季节性，建立预测模型，最后进行时间预测。这个故事的目的是强调可以建立一个可持续的和健壮的时间序列预测模型的关键结构。如果需要的话，请随意浏览下面的参考资料部分，以获得各个主题的详细解释。另外提醒一下，我建议您在阅读本文的同时阅读上面链接的代码库。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qc"><img src="../Images/f6feec439fb8e20378426d8af1c6f45e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*OM2wRDSCcm8KoGeS"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@waldemarbrandt67w?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">瓦尔德马尔·布兰德</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure></div><div class="ab cl qd qe hx qf" role="separator"><span class="qg bw bk qh qi qj"/><span class="qg bw bk qh qi qj"/><span class="qg bw bk qh qi"/></div><div class="im in io ip iq"><h2 id="ad16" class="pa nz it bd oa ph pi dn oe pj pk dp oi li pl pm ok lm pn po om lq pp pq oo pr bi translated">通读几个比较有趣的机器学习教程</h2><div class="ng nh gp gr ni nj"><a rel="noopener follow" target="_blank" href="/implementing-an-end-to-end-machine-learning-workflow-with-azure-data-factory-f16cbeeffd94"><div class="nk ab fo"><div class="nl ab nm cl cj nn"><h2 class="bd iu gy z fp no fr fs np fu fw is bi translated">使用Azure Data Factory实现端到端的机器学习工作流</h2><div class="nq l"><h3 class="bd b gy z fp no fr fs np fu fw dk translated">使用微软的Azure数据工厂(ADF)在一个屏幕上构建完整的MLOps生命周期</h3></div><div class="nr l"><p class="bd b dl z fp no fr fs np fu fw dk translated">towardsdatascience.com</p></div></div><div class="ns l"><div class="qk l nu nv nw ns nx ks nj"/></div></div></a></div><div class="ng nh gp gr ni nj"><a rel="noopener follow" target="_blank" href="/a-guide-to-genetic-learning-algorithms-for-optimization-e1067cdc77e7"><div class="nk ab fo"><div class="nl ab nm cl cj nn"><h2 class="bd iu gy z fp no fr fs np fu fw is bi translated">最优化遗传“学习”算法指南</h2><div class="nq l"><h3 class="bd b gy z fp no fr fs np fu fw dk translated">利用强化学习和遗传算法重建图像</h3></div><div class="nr l"><p class="bd b dl z fp no fr fs np fu fw dk translated">towardsdatascience.com</p></div></div><div class="ns l"><div class="ql l nu nv nw ns nx ks nj"/></div></div></a></div><div class="ng nh gp gr ni nj"><a rel="noopener follow" target="_blank" href="/clean-architecture-of-analyzing-data-7e689da7dd4a"><div class="nk ab fo"><div class="nl ab nm cl cj nn"><h2 class="bd iu gy z fp no fr fs np fu fw is bi translated">分析数据的清晰架构</h2><div class="nq l"><h3 class="bd b gy z fp no fr fs np fu fw dk translated">数据分析是一个复杂的过程吗？让我们一步一步来理解它</h3></div><div class="nr l"><p class="bd b dl z fp no fr fs np fu fw dk translated">towardsdatascience.com</p></div></div><div class="ns l"><div class="qm l nu nv nw ns nx ks nj"/></div></div></a></div></div><div class="ab cl qd qe hx qf" role="separator"><span class="qg bw bk qh qi qj"/><span class="qg bw bk qh qi qj"/><span class="qg bw bk qh qi"/></div><div class="im in io ip iq"><h2 id="359f" class="pa nz it bd oa ph pi dn oe pj pk dp oi li pl pm ok lm pn po om lq pp pq oo pr bi translated">关于我</h2><p id="1d2a" class="pw-post-body-paragraph kz la it lb b lc oq ju le lf or jx lh li os lk ll lm ot lo lp lq ou ls lt lu im bi translated">我是Rahul，目前在研究人工智能，在Xbox游戏上实现大数据分析。我在微软工作。除了专业工作之外，我还试图制定一个程序，来理解如何通过使用人工智能来改善世界上发展中国家的经济状况。</p><p id="4ff5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我现在在纽约的哥伦比亚大学，你可以通过<a class="ae ky" href="https://www.linkedin.com/in/rjrahul24/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>和<a class="ae ky" href="https://twitter.com/rjrahul24" rel="noopener ugc nofollow" target="_blank"> Twitter </a>与我联系。</p><h2 id="120a" class="pa nz it bd oa ph pi dn oe pj pk dp oi li pl pm ok lm pn po om lq pp pq oo pr bi translated">[参考文献]</h2><ol class=""><li id="3f27" class="mk ml it lb b lc oq lf or li qn lm qo lq qp lu mp mq mr ms bi translated"><a class="ae ky" href="https://www.statisticssolutions.com/free-resources/directory-of-statistical-analyses/time-series-analysis/" rel="noopener ugc nofollow" target="_blank">https://www . statistics solutions . com/free-resources/directory-of-statistical-analyses/time-series-analysis/</a></li><li id="8092" class="mk ml it lb b lc mt lf mu li mv lm mw lq mx lu mp mq mr ms bi translated"><a class="ae ky" rel="noopener" target="_blank" href="/the-complete-guide-to-time-series-analysis-and-forecasting-70d476bfe775">https://towards data science . com/the-complete-guide-to-time-series-analysis-and-forecasting-70d 476 bfe 775</a></li><li id="aa30" class="mk ml it lb b lc mt lf mu li mv lm mw lq mx lu mp mq mr ms bi translated"><a class="ae ky" href="https://en.wikipedia.org/wiki/Autoregressive_integrated_moving_average" rel="noopener ugc nofollow" target="_blank">https://en . Wikipedia . org/wiki/auto regressive _ integrated _ moving _ average</a></li><li id="b46d" class="mk ml it lb b lc mt lf mu li mv lm mw lq mx lu mp mq mr ms bi translated"><a class="ae ky" href="https://machinelearningmastery.com/arima-for-time-series-forecasting-with-python/" rel="noopener ugc nofollow" target="_blank">https://machine learning mastery . com/ARIMA-for-time-series-forecasting-with-python/</a></li><li id="86f9" class="mk ml it lb b lc mt lf mu li mv lm mw lq mx lu mp mq mr ms bi translated"><a class="ae ky" href="https://otexts.com/fpp2/arima.html" rel="noopener ugc nofollow" target="_blank">https://otexts.com/fpp2/arima.html</a></li><li id="c1a2" class="mk ml it lb b lc mt lf mu li mv lm mw lq mx lu mp mq mr ms bi translated"><a class="ae ky" rel="noopener" target="_blank" href="/taking-seasonality-into-consideration-for-time-series-analysis-4e1f4fbb768f">https://towards data science . com/taking-consideration-for-time-series-analysis-4 E1 F4 fbb 768 f</a></li><li id="670b" class="mk ml it lb b lc mt lf mu li mv lm mw lq mx lu mp mq mr ms bi translated"><a class="ae ky" href="https://www.firstintuition.co.uk/fihub/time-series-analysis/" rel="noopener ugc nofollow" target="_blank">https://www . first intuition . co . uk/fihub/time-series-analysis/</a></li></ol></div></div>    
</body>
</html>