<html>
<head>
<title>Learn Git Branches with your ML Project</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用您的ML项目学习Git分支</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/learn-git-branches-with-your-ml-project-7f58bdf1ae80?source=collection_archive---------14-----------------------#2021-08-24">https://towardsdatascience.com/learn-git-branches-with-your-ml-project-7f58bdf1ae80?source=collection_archive---------14-----------------------#2021-08-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="6345" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我提出一个假设来开始这篇文章。你知道git的基础知识。你做<strong class="jp ir"> git init，git clone </strong>，<strong class="jp ir"> git add </strong>，<strong class="jp ir"> git commit </strong>，<strong class="jp ir"> git push，git fetch，git pull </strong>。但是让我来测试你。下面这句话是什么意思？</p><pre class="kl km kn ko gt kp kq kr ks aw kt bi"><span id="bab3" class="ku kv iq kq b gy kw kx l ky kz">$ <!-- -->git switch -c development</span></pre><p id="327e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我跟你说实话，在我一个月前开始我的机器学习项目之前，我不知道这一行是做什么的。但是我在学习<strong class="jp ir">分支</strong>的过程中偶然发现了这个命令，以使我在Git版本控制方面的技能更加完整。这篇文章总结了我的学习，也是我想要的，这样我就可以尽可能快速有效地学习分支。如果你和我来自相似的地方，我鼓励你通过阅读这篇文章来适应分支。</p><p id="2a58" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了使这种学习有效，我们首先<em class="la">看看Git的内部，真正理解分支。这将包括<strong class="jp ir">指针、blobs、提交对象</strong>。<em class="la">其次</em>，我定期向您展示我写的代码行，这样您就可以在Git库的不同分支中拥有多个版本的项目。</em></p><figure class="kl km kn ko gt lc gh gi paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="gh gi lb"><img src="../Images/7aeacacec6f1bd50cada75f548c7b53b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*UeWf1SpSoGoRsmjv"/></div></div><p class="lj lk gj gh gi ll lm bd b be z dk translated">照片由<a class="ae ln" href="https://unsplash.com/@keilahoetzel?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">凯拉·霍泽尔</a>在<a class="ae ln" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><h1 id="80d0" class="lo kv iq bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated"><strong class="ak">分支是如何在引擎盖下工作的？</strong></h1><p id="f857" class="pw-post-body-paragraph jn jo iq jp b jq ml js jt ju mm jw jx jy mn ka kb kc mo ke kf kg mp ki kj kk ij bi translated">如果输入<code class="fe mq mr ms kq b">git commit -m “update"</code>会怎么样？它创建了一个提交对象。它包含作者的姓名和电子邮件地址、您为此提交键入的消息(“更新”)、指向之前提交的指针以及指向您暂存的文件的指针。好吧，有点快了。我们从舞台开始。</p><p id="284e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们假设您创建了两个文件</p><ul class=""><li id="8b4a" class="mt mu iq jp b jq jr ju jv jy mv kc mw kg mx kk my mz na nb bi translated">自述文件</li><li id="4a6a" class="mt mu iq jp b jq nc ju nd jy ne kc nf kg ng kk my mz na nb bi translated">HelloWorld.py</li></ul><p id="16b7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">并用<code class="fe mq mr ms kq b">git add README HelloWorld.py</code>将它们登台</p><p id="6c8c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Staging导致对每个文件进行校验和检查，并将该版本存储在Git存储库中。在Git中，这个校验和单个文件的结果被称为blob。每个blob代表文件的内容。当我们提交时，每个子目录(包含已转移的文件)也依次进行校验和检查。这一步的结果是一个树对象。树对象保存指向单个blobs的指针，存储单个文件的名称和SHA-1散列。不要忘记我前面提到的提交文件。这指向以前的提交，也指向根文件，以便能够在需要时重新创建版本。我们现在有4个Git文件:</p><figure class="kl km kn ko gt lc gh gi paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="gh gi nh"><img src="../Images/aaebae28da14b1a2f2dcb48288ca0898.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XLSk0_0QmJgysUrTylSePw.jpeg"/></div></div><p class="lj lk gj gh gi ll lm bd b be z dk translated">作者绘图，Git文件示意图</p></figure><p id="d155" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我注意到一个提交文件指向前一个提交文件，也称为父文件。让我们也想象一下。</p><figure class="kl km kn ko gt lc gh gi paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="gh gi ni"><img src="../Images/161ad75ebe14193fb736b8df7aa03550.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L5r-tvHuIyY0mkfJIIg4Pg.jpeg"/></div></div><p class="lj lk gj gh gi ll lm bd b be z dk translated">提交指向其树对象的对象</p></figure></div><div class="ab cl nj nk hu nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="ij ik il im in"><h1 id="5134" class="lo kv iq bd lp lq nq ls lt lu nr lw lx ly ns ma mb mc nt me mf mg nu mi mj mk bi translated">现在，您已经准备好听听分支到底是什么了！</h1><blockquote class="nv"><p id="02cc" class="nw nx iq bd ny nz oa ob oc od oe kk dk translated">分支基本上是指向一个提交对象的可移动指针。</p></blockquote><p id="f069" class="pw-post-body-paragraph jn jo iq jp b jq of js jt ju og jw jx jy oh ka kb kc oi ke kf kg oj ki kj kk ij bi translated">因此创建一个分支就是创建一个指针。这是一个非常轻量级的解决方案。分支是一个40个字符的SHA-1散列，它是对提交对象进行校验和检查的结果。创建一个分支就像创建41个字节并将它们写入一个文件一样简单(41是因为1个换行符)。</p><h2 id="6c2f" class="ku kv iq bd lp ok ol dn lt om on dp lx jy oo op mb kc oq or mf kg os ot mj ou bi translated">分支在实践中是如何工作的</h2><p id="611b" class="pw-post-body-paragraph jn jo iq jp b jq ml js jt ju mm jw jx jy mn ka kb kc mo ke kf kg mp ki kj kk ij bi translated">创建名为“testing”的分支的命令如下所示:</p><pre class="kl km kn ko gt kp kq kr ks aw kt bi"><span id="3810" class="ku kv iq kq b gy kw kx l ky kz">$ git branch testing</span></pre><p id="80d1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是你可能想知道这个分支在哪里分叉？为了理解这一点，我们必须引入另一个Git要素。<strong class="jp ir">头部指针</strong>。</p><h2 id="6f36" class="ku kv iq bd lp ok ol dn lt om on dp lx jy oo op mb kc oq or mf kg os ot mj ou bi translated">头部指针</h2><p id="d181" class="pw-post-body-paragraph jn jo iq jp b jq ml js jt ju mm jw jx jy mn ka kb kc mo ke kf kg mp ki kj kk ij bi translated">Git通过维护一个HEAD指针知道你在树状结构上的位置。HEAD指向您当前所在的分支。所以如果你输入<code class="fe mq mr ms kq b">git branch testing</code>，现在分支<code class="fe mq mr ms kq b">testing</code>指向相同的提交，就像头指针之前指向的另一个分支。但是<code class="fe mq mr ms kq b">git branch</code>并没有改变头部指针指向的位置，所以它仍然在master上。</p><p id="4082" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我画了一张图让你更清楚。一个名为master的分支在我们创建一个名为testing的新分支之前就存在了，因为<code class="fe mq mr ms kq b">git branch</code>没有改变HEAD的位置，所以在创建<code class="fe mq mr ms kq b">testing</code>之后它仍然指向master。</p><figure class="kl km kn ko gt lc gh gi paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="gh gi ov"><img src="../Images/7b1a0bb1b284abac51aa2970d0a187d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lrqXLNkFEHZMXYGQsrGXqg.jpeg"/></div></div><p class="lj lk gj gh gi ll lm bd b be z dk translated">一个简单的提交历史，有两个分支和头指针</p></figure><p id="f3d0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这意味着如果你想对分支的位置有更多的控制，你必须首先改变头指针指向的位置。这是用单词<code class="fe mq mr ms kq b">checkout</code>完成的，但是它只能检出已经存在的分支。请注意，如果您<code class="fe mq mr ms kq b">checkout</code>其他分支，您的工作目录中的文件会更改为保存在其他分支中的版本，如果您签出这些其他分支的话。</p><p id="dc8b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">还记得<code class="fe mq mr ms kq b">git switch -c testing</code>吗？它结合了<code class="fe mq mr ms kq b">git branch testing</code>和<code class="fe mq mr ms kq b">git checkout testing</code>，让你一次完成。你创建一个分支/指针，让HEAD指向这个新的分支。</p><blockquote class="nv"><p id="cdbb" class="nw nx iq bd ny nz oa ob oc od oe kk dk translated">EAD决定向哪个分支添加新的提交。</p></blockquote><p id="7706" class="pw-post-body-paragraph jn jo iq jp b jq of js jt ju og jw jx jy oh ka kb kc oi ke kf kg oj ki kj kk ij bi translated">如果我们编写了<code class="fe mq mr ms kq b">git checkout testing</code>，然后向我们的库<code class="fe mq mr ms kq b">git commit -m "another commit"</code>提交一些东西，我们的情况看起来是这样的:</p><figure class="kl km kn ko gt lc gh gi paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="gh gi ow"><img src="../Images/a8b7c4ef53abc53ff455c83b473d5bf2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mO-snMtFrFEUNRlTkqR7gw.jpeg"/></div></div><p class="lj lk gj gh gi ll lm bd b be z dk translated">测试分支提前一个提交</p></figure><p id="0d5c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这种情况下，它看起来不像我们从自然界中所知道的实际分支。但是如果我们回到分支主节点<code class="fe mq mr ms kq b">git checkout master</code>，然后在主分支上回到<code class="fe mq mr ms kq b">commit</code>，我们会得到这两个分支的共同祖先或节点。这种情况看起来更像实际的分支。但是你明白了。</p><figure class="kl km kn ko gt lc gh gi paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="gh gi ox"><img src="../Images/7aac23db509831b15863449ebf3947e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Mm4QwXB5rvbSUoEVYDDeBQ.jpeg"/></div></div><p class="lj lk gj gh gi ll lm bd b be z dk translated">测试分支仍然提前1次提交，但现在也落后1次提交</p></figure><h1 id="da57" class="lo kv iq bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">我们必须谈论合并</h1><p id="2227" class="pw-post-body-paragraph jn jo iq jp b jq ml js jt ju mm jw jx jy mn ka kb kc mo ke kf kg mp ki kj kk ij bi translated">有分支有什么用？你有两条或多条开发路径，你可能想两全其美，例如，从一个分支获得新的功能，并将其与主开发合并。</p><p id="9b90" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了理解合并，让我们考虑两种可能的合并机制。</p><h2 id="0d75" class="ku kv iq bd lp ok ol dn lt om on dp lx jy oo op mb kc oq or mf kg os ot mj ou bi translated">快进合并</h2><p id="d323" class="pw-post-body-paragraph jn jo iq jp b jq ml js jt ju mm jw jx jy mn ka kb kc mo ke kf kg mp ki kj kk ij bi translated">使用快速向前合并，您基本上将落后的分支(主)向前移动到领先的分支(测试)。我再次展示了之前的情况。如果在后面的分支(主分支)没有在前面的分支(测试分支)中丢失的提交，这个<strong class="jp ir">快速前进合并</strong>起作用。</p><p id="48af" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">之前:</strong></p><figure class="kl km kn ko gt lc gh gi paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="gh gi ow"><img src="../Images/a8b7c4ef53abc53ff455c83b473d5bf2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mO-snMtFrFEUNRlTkqR7gw.jpeg"/></div></div><p class="lj lk gj gh gi ll lm bd b be z dk translated">这种情况是为快速向前合并而设计的</p></figure><p id="f572" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">之后:</p><figure class="kl km kn ko gt lc gh gi paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="gh gi oy"><img src="../Images/93870d6aef449c21ad50af12788c908c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JZfeHxjU7GV1cINEeS45OQ.jpeg"/></div></div><p class="lj lk gj gh gi ll lm bd b be z dk translated">快进合并的结果</p></figure><p id="61b8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为此，首先将头部指针移动到<code class="fe mq mr ms kq b">master</code>，然后移动到<code class="fe mq mr ms kq b">merge</code>:</p><pre class="kl km kn ko gt kp kq kr ks aw kt bi"><span id="d900" class="ku kv iq kq b gy kw kx l ky kz">$ git checkout master<br/>$ git merge testing</span></pre><p id="676c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你不再需要测试指针，你可以通过写来删除它</p><pre class="kl km kn ko gt kp kq kr ks aw kt bi"><span id="0192" class="ku kv iq kq b gy kw kx l ky kz">$ git branch -d testing</span></pre><h2 id="1587" class="ku kv iq bd lp ok ol dn lt om on dp lx jy oo op mb kc oq or mf kg os ot mj ou bi translated">基本合并</h2><p id="a313" class="pw-post-body-paragraph jn jo iq jp b jq ml js jt ju mm jw jx jy mn ka kb kc mo ke kf kg mp ki kj kk ij bi translated">另一种合并方式发生在两条路径都存在的情况下，如下图所示</p><figure class="kl km kn ko gt lc gh gi paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="gh gi oz"><img src="../Images/8cbaafba5de96ee0598e89679e5a2cea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nMINkYjOokqFnrORkXbAtg.jpeg"/></div></div><p class="lj lk gj gh gi ll lm bd b be z dk translated">一个稍微困难一点的合并工作，测试是提前2次提交和滞后1次提交</p></figure><p id="a143" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这种情况下，Git必须执行三个版本的合并。Git不是向前移动分支指针，而是创建文件的快照，并创建指向它的新提交。这个提交有一个特殊的名称。它被称为合并提交，因为它有多个父级。</p><figure class="kl km kn ko gt lc gh gi paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="gh gi pa"><img src="../Images/ce8c525fd1397f77d26e16b63e8653cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GLOzQT-XGHG9fPdzpqvz6w.jpeg"/></div></div><p class="lj lk gj gh gi ll lm bd b be z dk translated">创建了一个名为合并提交的提交对象，以从两个分支获取关于共同祖先f30ab的更改</p></figure><h1 id="ffb4" class="lo kv iq bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">创建远程分支</h1><p id="8be0" class="pw-post-body-paragraph jn jo iq jp b jq ml js jt ju mm jw jx jy mn ka kb kc mo ke kf kg mp ki kj kk ij bi translated">如果您想与他人共享您的分支，以便多个编码人员可以处理您的项目，或者在GitHub上向他人展示您的项目，您需要将分支推送到远程存储库并创建远程分支。</p><p id="92f1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">语法如下所示:</p><pre class="kl km kn ko gt kp kq kr ks aw kt bi"><span id="2d97" class="ku kv iq kq b gy kw kx l ky kz">$ git push &lt;remote&gt; &lt;branch&gt; </span><span id="4b3c" class="ku kv iq kq b gy pb kx l ky kz">#for example<br/>$ git push origin master</span></pre><p id="4e77" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个命令创建了两件重要的事情。</p><ol class=""><li id="4cb7" class="mt mu iq jp b jq jr ju jv jy mv kc mw kg mx kk pc mz na nb bi translated">它创建了一个远程分支，其他人可以使用并进一步构建</li><li id="6908" class="mt mu iq jp b jq nc ju nd jy ne kc nf kg ng kk pc mz na nb bi translated">它在您的本地存储库中创建一个<strong class="jp ir">远程跟踪分支</strong></li></ol><p id="52db" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">将远程跟踪分支视为对远程分支状态的引用。他们有下面的名字结构<code class="fe mq mr ms kq b">remotes/&lt;remoteName&gt;/&lt;branchName&gt;</code>。您仍然拥有分支的本地版本<code class="fe mq mr ms kq b">master</code>，这意味着您的本地Git存储库拥有以下分支:</p><pre class="kl km kn ko gt kp kq kr ks aw kt bi"><span id="4578" class="ku kv iq kq b gy kw kx l ky kz">master<br/>remotes/origin/master</span></pre><p id="8ba3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意，带有语法<code class="fe mq mr ms kq b">remotes/&lt;remoteName&gt;/&lt;branchName&gt;</code>的远程跟踪分支是本地引用，不能用<code class="fe mq mr ms kq b">git merge</code>移动它们。相反，如果您在<code class="fe mq mr ms kq b">master</code>上做了更改，您可以将它们推送到服务器并获得一个更新的远程跟踪分支<code class="fe mq mr ms kq b">remotes/origin/master</code>。因此，只要您不与远程储存库联系，远程跟踪分支<strong class="jp ir">就不会移动。如果您的一位同事想要进行更改，并且他们已经克隆了他们使用的存储库:</strong></p><pre class="kl km kn ko gt kp kq kr ks aw kt bi"><span id="a5c8" class="ku kv iq kq b gy kw kx l ky kz">git fetch origin </span></pre><p id="f4ad" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">远程跟踪分支将被置于在那些分支上完成的最新提交。但是请注意，如果您获取和接收新的远程跟踪分支，您将不会自动拥有可以编辑的本地副本。如果<code class="fe mq mr ms kq b">issue</code>是一个新的分支，它会是这样的:</p><pre class="kl km kn ko gt kp kq kr ks aw kt bi"><span id="1a48" class="ku kv iq kq b gy kw kx l ky kz">master<br/>testing<br/>remotes/origin/master<br/>remotes/origin/testing<br/>remotes/origin/issue</span></pre><p id="67e8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您将只有一个无法修改的指针<code class="fe mq mr ms kq b">remotes/origin/issue</code>。这意味着您需要使用以下命令来创建本地可编辑副本:</p><pre class="kl km kn ko gt kp kq kr ks aw kt bi"><span id="1078" class="ku kv iq kq b gy kw kx l ky kz">$ git checkout -b issue origin/issue</span></pre></div><div class="ab cl nj nk hu nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="ij ik il im in"><h2 id="4e1a" class="ku kv iq bd lp ok ol dn lt om on dp lx jy oo op mb kc oq or mf kg os ot mj ou bi translated">git拉</h2><p id="dee7" class="pw-post-body-paragraph jn jo iq jp b jq ml js jt ju mm jw jx jy mn ka kb kc mo ke kf kg mp ki kj kk ij bi translated">也可以通过编写一步完成<code class="fe mq mr ms kq b">fetch</code>和<code class="fe mq mr ms kq b">merge</code></p><pre class="kl km kn ko gt kp kq kr ks aw kt bi"><span id="7cec" class="ku kv iq kq b gy kw kx l ky kz">git pull &lt;remote&gt;</span></pre><h1 id="374f" class="lo kv iq bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">知道你的团队在做什么</h1><p id="8b55" class="pw-post-body-paragraph jn jo iq jp b jq ml js jt ju mm jw jx jy mn ka kb kc mo ke kf kg mp ki kj kk ij bi translated">你正在失去概观？别担心。我将用一个命令结束这篇文章，这个命令让您了解您的分支超前或落后了多少个版本。但是要确保，首先输入<code class="fe mq mr ms kq b">git fetch</code>，这样您的本地repo就会得到更新，并从您的同事那里了解最新的提交。</p><pre class="kl km kn ko gt kp kq kr ks aw kt bi"><span id="c1de" class="ku kv iq kq b gy kw kx l ky kz">$ git branch -vv</span></pre><p id="9a60" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">结果可能如下所示</p><pre class="kl km kn ko gt kp kq kr ks aw kt bi"><span id="1189" class="ku kv iq kq b gy kw kx l ky kz">testing     7e424c3 [origin/testing: ahead 2, behind 1] change abc  master      1ae2a45 [origin/master] Deploy index fix<br/>* issue     f8674d9 [origin/issue: behind 1] should do it          cart        5ea463a Try something new</span></pre><p id="c9d0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我想从这个例子中指出几点:</p><ul class=""><li id="8296" class="mt mu iq jp b jq jr ju jv jy mv kc mw kg mx kk my mz na nb bi translated">在左边你可以看到分支的名称，星号表示头部指针的位置</li><li id="5fc7" class="mt mu iq jp b jq nc ju nd jy ne kc nf kg ng kk my mz na nb bi translated">右边是代表每个分支上最后一次提交的SHA-1散列</li><li id="47a3" class="mt mu iq jp b jq nc ju nd jy ne kc nf kg ng kk my mz na nb bi translated">远程分支在版本差异旁边的方括号中表示，例如，前面的2表示我向本地分支<code class="fe mq mr ms kq b">testing</code>提交了两次，而这个工作还没有推送到远程。此外，我们的本地分支机构还没有完全更新。团队中有人推到了偏远地区，我们还没有将这项工作合并到我们当地的分支机构。</li><li id="064d" class="mt mu iq jp b jq nc ju nd jy ne kc nf kg ng kk my mz na nb bi translated">右边是提交消息</li></ul><h1 id="7e02" class="lo kv iq bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated"><strong class="ak">删除(远程)分行</strong></h1><p id="e058" class="pw-post-body-paragraph jn jo iq jp b jq ml js jt ju mm jw jx jy mn ka kb kc mo ke kf kg mp ki kj kk ij bi translated">最后，如果你不再需要树枝..</p><p id="8e30" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">远程，</strong></p><pre class="kl km kn ko gt kp kq kr ks aw kt bi"><span id="1260" class="ku kv iq kq b gy kw kx l ky kz">$ git push &lt;remoteName&gt; --delete &lt;branchName&gt;</span></pre><p id="7731" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">本地，</strong></p><pre class="kl km kn ko gt kp kq kr ks aw kt bi"><span id="ec13" class="ku kv iq kq b gy kw kx l ky kz">$ git branch -d &lt;branchName&gt;</span></pre><p id="f34a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">开始时，记住在两个地方都删除可能会很烦人，但是我向您展示了如何删除，并且您可能会在对其中一个命令感到不确定时返回到本文。</p></div><div class="ab cl nj nk hu nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="ij ik il im in"><h1 id="d8df" class="lo kv iq bd lp lq nq ls lt lu nr lw lx ly ns ma mb mc nt me mf mg nu mi mj mk bi translated">摘要</h1><p id="6bb6" class="pw-post-body-paragraph jn jo iq jp b jq ml js jt ju mm jw jx jy mn ka kb kc mo ke kf kg mp ki kj kk ij bi translated">您了解了提交、树和blob对象。您知道分支实际上只是指向提交对象的指针。此外，记住HEAD指针的存在是至关重要的，因为这个指针将决定你的新分支将在你的<code class="fe mq mr ms kq b">git branch</code>命令上创建的位置。您现在熟悉的一个概念是合并分支，并在不使用它们之后删除它们。请务必记住快速向前合并和基本合并之间的区别。</p><p id="b8ba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你喜欢这篇文章，你可能会喜欢我在medium上写的其他一些文章。</p><div class="pd pe gp gr pf pg"><a rel="noopener follow" target="_blank" href="/working-with-json-data-in-python-45e25ff958ce"><div class="ph ab fo"><div class="pi ab pj cl cj pk"><h2 class="bd ir gy z fp pl fr fs pm fu fw ip bi translated">在python中使用JSON数据</h2><div class="pn l"><h3 class="bd b gy z fp pl fr fs pm fu fw dk translated">写入json文件，从json文件读取用python解释并举例说明。</h3></div><div class="po l"><p class="bd b dl z fp pl fr fs pm fu fw dk translated">towardsdatascience.com</p></div></div><div class="pp l"><div class="pq l pr ps pt pp pu lh pg"/></div></div></a></div><div class="pd pe gp gr pf pg"><a rel="noopener follow" target="_blank" href="/skip-gram-neural-network-for-graphs-83b8f308bf87"><div class="ph ab fo"><div class="pi ab pj cl cj pk"><h2 class="bd ir gy z fp pl fr fs pm fu fw ip bi translated">图的跳格神经网络</h2><div class="pn l"><h3 class="bd b gy z fp pl fr fs pm fu fw dk translated">本文将深入探讨节点嵌入的更多细节。如果你缺乏直觉和对节点嵌入的理解…</h3></div><div class="po l"><p class="bd b dl z fp pl fr fs pm fu fw dk translated">towardsdatascience.com</p></div></div><div class="pp l"><div class="pv l pr ps pt pp pu lh pg"/></div></div></a></div><div class="pd pe gp gr pf pg"><a rel="noopener follow" target="_blank" href="/graph-coloring-with-networkx-88c45f09b8f4"><div class="ph ab fo"><div class="pi ab pj cl cj pk"><h2 class="bd ir gy z fp pl fr fs pm fu fw ip bi translated">网络图着色</h2><div class="pn l"><h3 class="bd b gy z fp pl fr fs pm fu fw dk translated">图着色问题的解决方案在概念上很简单，但在应用上却很强大。本教程展示了…</h3></div><div class="po l"><p class="bd b dl z fp pl fr fs pm fu fw dk translated">towardsdatascience.com</p></div></div><div class="pp l"><div class="pw l pr ps pt pp pu lh pg"/></div></div></a></div></div></div>    
</body>
</html>