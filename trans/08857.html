<html>
<head>
<title>Logarithms and Exponents in Complexity Analysis</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">复杂性分析中的对数和指数</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/logarithms-exponents-in-complexity-analysis-b8071979e847?source=collection_archive---------1-----------------------#2021-08-16">https://towardsdatascience.com/logarithms-exponents-in-complexity-analysis-b8071979e847?source=collection_archive---------1-----------------------#2021-08-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="807f" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">自学成才的软件工程师✨在复杂性分析中掌握对数</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/6da899d846b47fc4b0fddb75d9b5ead5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gZn1cs_qkR06V55gXHre1g.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">来源:<a class="ae kv" href="https://unsplash.com/@lorenzoherrera" rel="noopener ugc nofollow" target="_blank">@洛伦佐·埃雷拉</a></p></figure></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="6654" class="ld le iq bd lf lg lh li lj lk ll lm ln jw lo jx lp jz lq ka lr kc ls kd lt lu bi translated">目录</h1><ol class=""><li id="488c" class="lv lw iq lx b ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated"><a class="ae kv" href="https://medium.com/@humamaboalraja/logarithms-exponents-in-complexity-analysis-b8071979e847#5ad2" rel="noopener">对数101 </a> 🧮</li><li id="03be" class="lv lw iq lx b ly mn ma mo mc mp me mq mg mr mi mj mk ml mm bi translated"><a class="ae kv" href="#dbb3" rel="noopener ugc nofollow">我们需要了解的先决条件</a>📚</li><li id="4315" class="lv lw iq lx b ly mn ma mo mc mp me mq mg mr mi mj mk ml mm bi translated"><a class="ae kv" href="#26d2" rel="noopener ugc nofollow">计算机科学和二进制对数</a>💻</li><li id="7629" class="lv lw iq lx b ly mn ma mo mc mp me mq mg mr mi mj mk ml mm bi translated"><a class="ae kv" href="#9600" rel="noopener ugc nofollow">为什么计算机科学中的对数大多是二进制对数</a>？</li><li id="14b1" class="lv lw iq lx b ly mn ma mo mc mp me mq mg mr mi mj mk ml mm bi translated"><a class="ae kv" href="#e39a" rel="noopener ugc nofollow">该关系及其在复杂性分析方面的意义</a>⏱</li><li id="07b8" class="lv lw iq lx b ly mn ma mo mc mp me mq mg mr mi mj mk ml mm bi translated"><a class="ae kv" href="#9063" rel="noopener ugc nofollow">比较渐近线图上的对数函数和线性函数</a>📈</li><li id="28b2" class="lv lw iq lx b ly mn ma mo mc mp me mq mg mr mi mj mk ml mm bi translated"><a class="ae kv" href="#237c" rel="noopener ugc nofollow">最后的金例:✨二分搜索法</a></li><li id="064d" class="lv lw iq lx b ly mn ma mo mc mp me mq mg mr mi mj mk ml mm bi translated"><a class="ae kv" href="#559a" rel="noopener ugc nofollow">结论</a></li><li id="2953" class="lv lw iq lx b ly mn ma mo mc mp me mq mg mr mi mj mk ml mm bi translated"><a class="ae kv" href="#b53a" rel="noopener ugc nofollow">参考文献</a></li></ol></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><p id="62f5" class="pw-post-body-paragraph ms mt iq lx b ly mu jr mv ma mw ju mx mc my mz na me nb nc nd mg ne nf ng mi ij bi translated">我为那些对数学及其与计算机科学、复杂性分析、竞争性编程、编码面试等的关系感到不知所措的人写了这篇文章…我试图解释你在复杂性分析方面理解对数所需要的每一个细节，它特别针对自学的软件工程师/开发人员和任何没有扎实数学背景的人！这将是我的第一篇媒体文章，它将是一系列其他即将到来的文章，所以请原谅我，希望你喜欢它💜</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="5ad2" class="ld le iq bd lf lg lh li lj lk ll lm ln jw lo jx lp jz lq ka lr kc ls kd lt lu bi translated">1 -对数101 🧮</h1><p id="584a" class="pw-post-body-paragraph ms mt iq lx b ly lz jr mv ma mb ju mx mc nh mz na me ni nc nd mg nj nf ng mi ij bi translated"><strong class="lx ir">对数或对数:</strong>一个在计算机科学中经常使用的数学概念/表达式，它是指数的逆(翻转)，它们被用来回答这样一个问题:一个“基数”数必须乘以多少次才能得到另一个特定的数<strong class="lx ir">或</strong>(你必须提高到什么幂，才能得到另一个数)<strong class="lx ir">或</strong>我们也可以把它定义为<strong class="lx ir">的幂</strong>(或指数)</p><p id="c0bc" class="pw-post-body-paragraph ms mt iq lx b ly mu jr mv ma mw ju mx mc my mz na me nb nc nd mg ne nf ng mi ij bi translated"><strong class="lx ir">举例</strong>:20的基数要乘以多少次才能得到<strong class="lx ir">8000</strong>？答案是<strong class="lx ir">3</strong>(<strong class="lx ir">8000<em class="nk">= 20×20×20</em></strong>)。所以<strong class="lx ir">8000</strong>的对数底数20就是<strong class="lx ir"> 3 </strong>。它是用基数右下角的下标(小数字)来表示的。所以语句应该是<strong class="lx ir"> log20(8，000) = 3 </strong>。</p><ul class=""><li id="1975" class="lv lw iq lx b ly mu ma mw mc nl me nm mg nn mi no mk ml mm bi translated"><strong class="lx ir"> log20(400) </strong>就像问“我们乘以多少个<strong class="lx ir">20</strong>才能得到<strong class="lx ir"> 400 </strong>？也就是2(20 * 20)。所以<strong class="lx ir"> log20(400) = 2 </strong></li></ul><p id="d883" class="pw-post-body-paragraph ms mt iq lx b ly mu jr mv ma mw ju mx mc my mz na me nb nc nd mg ne nf ng mi ij bi translated">对数使用以下公式定义:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi np"><img src="../Images/c7529f615bfac168f04002dbebe15b52.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PkNfkgMn_yKflT3KIBKpVA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">b =底数| y =指数| n =幂(b乘以y的幂得到的结果)</p></figure></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="dbb3" class="ld le iq bd lf lg lh li lj lk ll lm ln jw lo jx lp jz lq ka lr kc ls kd lt lu bi translated">2 -我们需要了解的先决条件📚</h1><ul class=""><li id="77d0" class="lv lw iq lx b ly lz ma mb mc md me mf mg mh mi no mk ml mm bi translated"><strong class="lx ir">指数:</strong>一个数字，标识该基数或表达式必须乘以自身的次数，它显示为一个上标(某个其他“基数”或数学表达式右上角的微小数字)。</li><li id="d615" class="lv lw iq lx b ly mn ma mo mc mp me mq mg mr mi no mk ml mm bi translated"><strong class="lx ir">基数</strong>:在对数语句中，一个基数是一个要被自身相乘的数学对象，它被表示为该基数右下方的一个下标，或者被一个指数所要求的次数，该指数被写为该基数右上方的一个上标</li><li id="f187" class="lv lw iq lx b ly mn ma mo mc mp me mq mg mr mi no mk ml mm bi translated">常用对数:以10为基数的对数。它用于测量声音、电和光等。</li><li id="69fc" class="lv lw iq lx b ly mn ma mo mc mp me mq mg mr mi no mk ml mm bi translated"><strong class="lx ir"> log: </strong>(数学中)对数的缩写。</li><li id="1675" class="lv lw iq lx b ly mn ma mo mc mp me mq mg mr mi no mk ml mm bi translated"><strong class="lx ir">二进制对数:</strong>底数为2的对数。二进制对数是二进制数字系统的基础，它允许我们只用零和一的数字来计数，它们非常重要&amp;在计算机科学中非常普遍。</li></ul></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="26d2" class="ld le iq bd lf lg lh li lj lk ll lm ln jw lo jx lp jz lq ka lr kc ls kd lt lu bi translated">3 -计算机科学和二进制对数💻</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nq"><img src="../Images/de1649cd28d72396d00b7fc39d474fc0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dzaZNBlASEcWx8AQD6kbHQ.png"/></div></div></figure><p id="2162" class="pw-post-body-paragraph ms mt iq lx b ly mu jr mv ma mw ju mx mc my mz na me nb nc nd mg ne nf ng mi ij bi translated">最初，我们必须理解一些可能不明显的东西，如果你以前见过表达式<strong class="lx ir"><em class="nk">O</em>(<em class="nk">log n</em>)</strong>关于复杂性分析，当我们谈论对数时，我们必须指定一个底数。</p><p id="5c09" class="pw-post-body-paragraph ms mt iq lx b ly mu jr mv ma mw ju mx mc my mz na me nb nc nd mg ne nf ng mi ij bi translated">所以这里的底数是“<strong class="lx ir"><em class="nk">”b</em></strong><em class="nk">”</em>它就像一个小小的“<strong class="lx ir"><em class="nk">”b</em></strong><em class="nk">”</em>就在圆木的正下方，这一点非常重要。</p><ul class=""><li id="3a4d" class="lv lw iq lx b ly mu ma mw mc nl me nm mg nn mi no mk ml mm bi translated">因为举例来说，如果我们写10的以5为底的对数，然后我们写10的以10为底的对数，我们会得到非常不同的结果，因为等式会不同。这里的“<strong class="lx ir"><em class="nk">b</em></strong><em class="nk">”</em>不是5就是10。</li></ul><p id="64d3" class="pw-post-body-paragraph ms mt iq lx b ly mu jr mv ma mw ju mx mc my mz na me nb nc nd mg ne nf ng mi ij bi translated">这就是我们必须理解/认识到的地方，在计算机科学和编码面试中，当我们说log n of时，我们总是假设底数是2，假设我们处理的是所谓的<strong class="lx ir">二进制对数</strong>，它是底数为2的对数(正如我们在先决条件中提到的)，除非它被指定为其他底数。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="9600" class="ld le iq bd lf lg lh li lj lk ll lm ln jw lo jx lp jz lq ka lr kc ls kd lt lu bi translated">4 -为什么计算机科学中的对数大多是二进制对数？</h1><p id="6553" class="pw-post-body-paragraph ms mt iq lx b ly lz jr mv ma mb ju mx mc nh mz na me ni nc nd mg nj nf ng mi ij bi translated">因为在计算机科学中，对数大多是通过将一些<strong class="lx ir">数据输入</strong>(如列表、数组等)<strong class="lx ir"> </strong>重复分成两半来实现的，这通常发生在如下算法中:</p><ul class=""><li id="141a" class="lv lw iq lx b ly mu ma mw mc nl me nm mg nn mi no mk ml mm bi translated">像二分搜索法、快速排序、最近点对、合并排序等分治算法…</li></ul><p id="8718" class="pw-post-body-paragraph ms mt iq lx b ly mu jr mv ma mw ju mx mc my mz na me nb nc nd mg ne nf ng mi ij bi translated">在这些情况下，在使用单元素数组之前，将长度为<strong class="lx ir"> n </strong>的<strong class="lx ir">数据输入</strong>(如列表、数组等)分成两半的次数是log₂ n</p><p id="2ff6" class="pw-post-body-paragraph ms mt iq lx b ly mu jr mv ma mw ju mx mc my mz na me nb nc nd mg ne nf ng mi ij bi translated">在计算机科学中，指数增长通常是我们提到的分而治之这样的离散过程的结果。因此，我们通常使用log2 n作为对数函数，因为它出现得如此频繁。</p><p id="b3e0" class="pw-post-body-paragraph ms mt iq lx b ly mu jr mv ma mw ju mx mc my mz na me nb nc nd mg ne nf ng mi ij bi translated">但是澄清一下，不要混淆任何人，我们大多数时候使用二进制对数的事实并不意味着我们在计算机科学中总是只使用以2为底的对数。只是处理二进制数或将输入数据分成两半的情况很常见，这就是为什么以2为底的对数在很多情况下最终会成为默认对数，而且一般来说，<strong class="lx ir">你选择哪个底真的无关紧要</strong>。因为例如:</p><ul class=""><li id="b1a5" class="lv lw iq lx b ly mu ma mw mc nl me nm mg nn mi no mk ml mm bi translated">在Big-O符号(上限增长)中，所有对数都是渐近等价的(唯一的区别是有乘法常数因子)；</li></ul><p id="55a6" class="pw-post-body-paragraph ms mt iq lx b ly mu jr mv ma mw ju mx mc my mz na me nb nc nd mg ne nf ng mi ij bi translated">所以我们通常在写O(log n)这样的东西时甚至不指定底数，因为我们总是假设对数是二进制对数，意思是以2为对数底数的对数，所以这里甚至不写底数2。</p><blockquote class="nr ns nt"><p id="a190" class="ms mt nk lx b ly mu jr mv ma mw ju mx nu my mz na nv nb nc nd nw ne nf ng mi ij bi translated">P <!-- -->。对于那些有数学背景的人来说，当你说N的对数时，你可能习惯于使用基数<strong class="lx ir"> 10 </strong>，这是数学中常用的。</p><p id="bafc" class="ms mt nk lx b ly mu jr mv ma mw ju mx nu my mz na nv nb nc nd nw ne nf ng mi ij bi translated">如果你已经习惯了这一点，请记住，对于计算机科学和编码面试来说，除非另有说明，否则你通常会处理以2为底的对数。</p></blockquote></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="e39a" class="ld le iq bd lf lg lh li lj lk ll lm ln jw lo jx lp jz lq ka lr kc ls kd lt lu bi translated">5 -关系及其在复杂性分析方面的意义</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/baab9876bb8c76fe9062c0f84a97a0b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:956/format:webp/1*nVJUKzENNXFq2nPXycx65w.png"/></div></figure><p id="236a" class="pw-post-body-paragraph ms mt iq lx b ly mu jr mv ma mw ju mx mc my mz na me nb nc nd mg ne nf ng mi ij bi translated">正如我们之前提到的，它基本上意味着log(n)是你需要将2乘以的幂，从而得到"<strong class="lx ir"><em class="nk">" n "</em></strong>。</p><blockquote class="nr ns nt"><p id="2188" class="ms mt nk lx b ly mu jr mv ma mw ju mx nu my mz na nv nb nc nd nw ne nf ng mi ij bi translated"><strong class="lx ir">因此，当且仅当数字2的y次方等于n时，n的以2为底的对数等于y。</strong></p></blockquote><ul class=""><li id="b151" class="lv lw iq lx b ly mu ma mw mc nl me nm mg nn mi no mk ml mm bi translated">例如，这意味着1等于我们需要用2来得到1的幂。这个幂是0。<strong class="lx ir"><em class="nk">log</em>(<em class="nk">1</em>)<em class="nk">= 0</em></strong>因为2的0次方等于1: <strong class="lx ir"> log(1) = 0，2⁰ = 1 </strong>，其他例子:</li><li id="8889" class="lv lw iq lx b ly mn ma mo mc mp me mq mg mr mi no mk ml mm bi translated">8的log将是:<strong class="lx ir"><em class="nk">log</em>(<em class="nk">8</em>)<em class="nk">= 3，2 = 8 </em> </strong></li><li id="224b" class="lv lw iq lx b ly mn ma mo mc mp me mq mg mr mi no mk ml mm bi translated">16的日志将是:<strong class="lx ir"> <em class="nk">日志</em> ( <em class="nk"> 16 </em> ) <em class="nk"> = 4，2⁴ = 16 </em> </strong></li></ul><p id="c945" class="pw-post-body-paragraph ms mt iq lx b ly mu jr mv ma mw ju mx mc my mz na me nb nc nd mg ne nf ng mi ij bi translated">因此，要找到对数或二进制对数，我们必须问自己，2的幂等于多少？如果我们解决了这个问题，那么我们会找到<strong class="lx ir"> <em class="nk">日志</em> </strong> <strong class="lx ir"> <em class="nk"> n </em> </strong>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi np"><img src="../Images/2897cc45164a61dc65f26ea7ec7a4155.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0JXuNMYSwSDcxqeIj0suCA.png"/></div></div></figure><p id="3275" class="pw-post-body-paragraph ms mt iq lx b ly mu jr mv ma mw ju mx mc my mz na me nb nc nd mg ne nf ng mi ij bi translated">那么这意味着什么呢？🙄</p><p id="0faf" class="pw-post-body-paragraph ms mt iq lx b ly mu jr mv ma mw ju mx mc my mz na me nb nc nd mg ne nf ng mi ij bi translated">让我们来看看2的幂，当我们增加2的幂时，我们实际上是在把之前的数翻倍，对吗？！</p><p id="5d49" class="pw-post-body-paragraph ms mt iq lx b ly mu jr mv ma mw ju mx mc my mz na me nb nc nd mg ne nf ng mi ij bi translated">如果我们有数字<strong class="lx ir"> <em class="nk"> 2 </em> </strong>的<strong class="lx ir"> <em class="nk"> x </em> </strong>的次方，我们有<strong class="lx ir"> 2 </strong>的<strong class="lx ir"> (x+1) </strong>的次方，我们就是把那个数字乘以2或者加倍，对吗？</p><ul class=""><li id="ae51" class="lv lw iq lx b ly mu ma mw mc nl me nm mg nn mi no mk ml mm bi translated"><strong class="lx ir">举例</strong>:<strong class="lx ir"><em class="nk">2⁷=2⁶</em></strong><strong class="lx ir"><em class="nk">2</em></strong>2的6次方是64。64乘以二是128，也就是<strong class="lx ir"> 2 </strong>的<strong class="lx ir"> 7 </strong>次方。所以，每当我们把2的指数增加到1的幂，我们就把这个数字翻倍了。那真的很重要。</li></ul><p id="4108" class="pw-post-body-paragraph ms mt iq lx b ly mu jr mv ma mw ju mx mc my mz na me nb nc nd mg ne nf ng mi ij bi translated">换句话说，当我们把数字<strong class="lx ir"> <em class="nk"> N </em> </strong>翻倍的时候，我们只是把这个问号增加了一个。太简单了，对吧！🤞🎸</p><ul class=""><li id="4e8d" class="lv lw iq lx b ly mu ma mw mc nl me nm mg nn mi no mk ml mm bi translated"><strong class="lx ir">例#2: </strong>假设我们有<strong class="lx ir"> 2⁴ = 16 </strong>，现在你把16翻倍，也就是上图中这里的数字n，我们把16翻倍到32，我们要做的就是把指数加1<strong class="lx ir">2⁵= 32</strong></li></ul><p id="10db" class="pw-post-body-paragraph ms mt iq lx b ly mu jr mv ma mw ju mx mc my mz na me nb nc nd mg ne nf ng mi ij bi translated"><strong class="lx ir">重述</strong>:所以在这张关系图中我们可以看到，问号的2次方等于<strong class="lx ir"> <em class="nk"> N </em> </strong>。随着<strong class="lx ir"> <em class="nk"> N </em> </strong>翻倍问号只增加一个。甚至当<strong class="lx ir"> <em class="nk"> N </em> </strong>很大的时候。如果我们试着把指数再提高一点，我们会看得更清楚。例如，如果我们写出2的20次方。例如</p><ul class=""><li id="84d2" class="lv lw iq lx b ly mu ma mw mc nl me nm mg nn mi no mk ml mm bi translated">2 ⁰ =1，073，741，824  | <strong class="lx ir"> 2⁴⁰ = 1，099，511，627，776 </strong>我们只增加了10个指数。</li></ul><p id="99ed" class="pw-post-body-paragraph ms mt iq lx b ly mu jr mv ma mw ju mx mc my mz na me nb nc nd mg ne nf ng mi ij bi translated">所以展示所有这些例子的目的是，N增加得越多，图中的指数或问号就会增加一点点，因为这个关系，<strong class="lx ir"> 2 </strong>的<strong class="lx ir">次方？</strong>等于<strong class="lx ir"> <em class="nk"> N </em> </strong>，相当于<strong class="lx ir"><em class="nk">log(N)</em></strong><strong class="lx ir">=</strong><strong class="lx ir">？</strong>，这就告诉我们<em class="nk"> log(n) </em>到底代表了什么！😀❤️</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi np"><img src="../Images/700f3763a8fccb11c29b96b20f53ae99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CU7NJVSOiRzjn32Sr6q8xQ.png"/></div></div></figure><p id="1ec9" class="pw-post-body-paragraph ms mt iq lx b ly mu jr mv ma mw ju mx mc my mz na me nb nc nd mg ne nf ng mi ij bi translated"><strong class="lx ir"> <em class="nk"> log(n) </em> </strong>只随着<strong class="lx ir"> N </strong>的增加而少量增加。当<strong class="lx ir"> N </strong>翻倍时，<strong class="lx ir"> <em class="nk"> log(n) </em> </strong>只增加1。这就是为什么，当我们有一个时间复杂度为<em class="nk"> log(n) </em>的算法时，如果我们将其与复杂度分析联系起来，这是非常好的，因为这意味着随着输入的增加/加倍，我们在算法中执行的基本运算的数量只增加一个。</p><blockquote class="nr ns nt"><p id="340f" class="ms mt nk lx b ly mu jr mv ma mw ju mx nu my mz na nv nb nc nd nw ne nf ng mi ij bi translated"><strong class="lx ir">对数时间复杂度</strong> <strong class="lx ir"> <em class="iq"> log(n) </em> </strong>:用大O符号表示为<strong class="lx ir"> O(log n) </strong>，当一个算法的运行时间为O(log n)时，表示随着输入大小的增长，运算次数增长非常缓慢。<strong class="lx ir">例子:</strong>二分搜索法。</p></blockquote><p id="e81c" class="pw-post-body-paragraph ms mt iq lx b ly mu jr mv ma mw ju mx mc my mz na me nb nc nd mg ne nf ng mi ij bi translated">所以我想现在你很清楚了，一个<strong class="lx ir"> <em class="nk">【对数(n) </em> </strong>复杂度比一个<strong class="lx ir">线性复杂度O(n) </strong>要好得多。即使<strong class="lx ir"> O(n) </strong>，线性时间对于一个算法来说已经很不错了。<strong class="lx ir"><em class="nk">【log(n)</em></strong>随着输入量的增加，时间会变得更好。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="9063" class="ld le iq bd lf lg lh li lj lk ll lm ln jw lo jx lp jz lq ka lr kc ls kd lt lu bi translated">6 -在渐近线图上比较对数函数和线性函数📈</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ny"><img src="../Images/411beb95b310235798a8d8dd0fcbe5f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K_HE3cnMwxBKT9G-moS3nQ.png"/></div></div></figure><p id="84b3" class="pw-post-body-paragraph ms mt iq lx b ly mu jr mv ma mw ju mx mc my mz na me nb nc nd mg ne nf ng mi ij bi translated">如果你熟悉Big-O复杂度图，你可以看到这里的x轴代表数字<strong class="lx ir"> N </strong>。</p><p id="f218" class="pw-post-body-paragraph ms mt iq lx b ly mu jr mv ma mw ju mx mc my mz na me nb nc nd mg ne nf ng mi ij bi translated">线性函数的复杂度看起来类似于<strong class="lx ir"> <em class="nk"> O(n) </em> </strong>，其中复杂度随着<strong class="lx ir"> N </strong>线性增加。</p><ul class=""><li id="2af8" class="lv lw iq lx b ly mu ma mw mc nl me nm mg nn mi no mk ml mm bi translated">所以当<strong class="lx ir"> N </strong>等于比方说十亿。这条线会有10亿。</li><li id="d5cd" class="lv lw iq lx b ly mn ma mo mc mp me mq mg mr mi no mk ml mm bi translated">而O(log n)函数，正如你在渐近图中看到的，它在最开始时上升，正如我们前面提到的，<strong class="lx ir">log(1)= 0—</strong><strong class="lx ir">log(4)= 2—</strong><strong class="lx ir">log(8)= 3</strong>。</li><li id="2a18" class="lv lw iq lx b ly mn ma mo mc mp me mq mg mr mi no mk ml mm bi translated">因此，一开始它会适度增加，但这里输入越大，(N增加越多)，log(n)函数变化越小。就像我们上面说的，当N是一百万时，log(n)只有20。</li><li id="9473" class="lv lw iq lx b ly mn ma mo mc mp me mq mg mr mi no mk ml mm bi translated">即使N是10亿，log(n)仍然只有30。只会增加20英镑。</li></ul><p id="b116" class="pw-post-body-paragraph ms mt iq lx b ly mu jr mv ma mw ju mx mc my mz na me nb nc nd mg ne nf ng mi ij bi translated">这就是log(n)如此强大的原因，因为log(n)的复杂性实际上代表了一种不会随着输入大小的增加而快速增加的复杂性。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="237c" class="ld le iq bd lf lg lh li lj lk ll lm ln jw lo jx lp jz lq ka lr kc ls kd lt lu bi translated"><strong class="ak"> 7 -最后的金例:✨二分搜索法</strong></h1><blockquote class="nr ns nt"><p id="f7ea" class="ms mt nk lx b ly mu jr mv ma mw ju mx nu my mz na nv nb nc nd nw ne nf ng mi ij bi translated">二分搜索法只能处理排序后的数据(列表、数组等)</p></blockquote><p id="c6c8" class="pw-post-body-paragraph ms mt iq lx b ly mu jr mv ma mw ju mx mc my mz na me nb nc nd mg ne nf ng mi ij bi translated"><strong class="lx ir">二分搜索法</strong>是一种高效的区间搜索算法，可以在有序列表中搜索想要的目标。</p><p id="a1f1" class="pw-post-body-paragraph ms mt iq lx b ly mu jr mv ma mw ju mx mc my mz na me nb nc nd mg ne nf ng mi ij bi translated">示例:</p><ul class=""><li id="a3da" class="lv lw iq lx b ly mu ma mw mc nl me nm mg nn mi no mk ml mm bi translated">让我们假设我们有一个<strong class="lx ir">1024</strong>元素的列表，我心里有一个数字，你必须尽可能少地猜出来</li><li id="51a8" class="lv lw iq lx b ly mn ma mo mc mp me mq mg mr mi no mk ml mm bi translated">每猜一次，你就会知道，你的猜测是过高、过低还是正确。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nz"><img src="../Images/e3f67de0aa9d2994ca8a6acc2325470d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zJzr6l3SXwPmjiq_o8fDLw.png"/></div></div></figure><ul class=""><li id="35fd" class="lv lw iq lx b ly mu ma mw mc nl me nm mg nn mi no mk ml mm bi translated">您可以使用的一种方法是以线性方式开始猜测，比如说:它是0吗，如果太低，您会说1，如果太低，您会说2，以此类推，这种方法被称为线性方法，基于我们目前所知的线性时间和对数时间之间的差异，我们可以做得更好，对吗？！</li></ul><p id="5197" class="pw-post-body-paragraph ms mt iq lx b ly mu jr mv ma mw ju mx mc my mz na me nb nc nd mg ne nf ng mi ij bi translated">另一种(更好的)方法是，我们从中间元素开始，而不是从第一个元素开始，如果它太低，那么我们可以去掉一半的输入，对吗？！😀</p><ul class=""><li id="45b7" class="lv lw iq lx b ly mu ma mw mc nl me nm mg nn mi no mk ml mm bi translated">现在，在我们的猜测低于干燥的数字之后，因为我们知道0到512都低于我们想要猜测的数字，我们的下一个猜测将遵循相同的方法，我们将搜索空间剩下的一半，在这种情况下，我们的第二个猜测将是<strong class="lx ir"> 768 </strong></li><li id="21fb" class="lv lw iq lx b ly mn ma mo mc mp me mq mg mr mi no mk ml mm bi translated">768 太高了，但再次发生的是，我们从搜索空间的数字中削减了一半</li></ul><p id="fbc0" class="pw-post-body-paragraph ms mt iq lx b ly mu jr mv ma mw ju mx mc my mz na me nb nc nd mg ne nf ng mi ij bi translated">这就是二分搜索法的工作方式，它开始在输入(数组、列表等)的中间搜索想要的元素..)，然后向右或向左移动，这取决于您要查找的值是更大还是更小，正如我们看到的，它在每次迭代中减少搜索空间中剩余数字的一半。</p><ul class=""><li id="1469" class="lv lw iq lx b ly mu ma mw mc nl me nm mg nn mi no mk ml mm bi translated">所以现在在这种情况下，我们的下一个猜测是在<strong class="lx ir"> 512 </strong>和<strong class="lx ir"> 768 </strong>之间</li><li id="f8e0" class="lv lw iq lx b ly mn ma mo mc mp me mq mg mr mi no mk ml mm bi translated">因此，现在我们看到，在线性搜索的情况下，使用具有对数时间复杂度的二分搜索法，最多需要<strong class="lx ir"> 10 </strong>步来获得我们想要的期望值，而不是<strong class="lx ir"> 1，024 </strong>线性运算</li><li id="5e4d" class="lv lw iq lx b ly mn ma mo mc mp me mq mg mr mi no mk ml mm bi translated">另一个例子:假设我们在一个<strong class="lx ir"> 1，073，741，824个</strong>项目列表中寻找想要的值，如果我们想要寻找我们想要的值，并且它在列表的末尾，如果我们想要使用线性方法，那么我们必须迭代<strong class="lx ir"> 1，073，741，824次</strong>才能得到想要的值。另一方面，如果我们想以一种<strong class="lx ir">对数</strong>的方式使用二分搜索法来做这件事，那么我们最多需要<strong class="lx ir"> log₂n </strong> <strong class="lx ir"> 30 </strong> <strong class="lx ir">的猜测，</strong>令人吃惊吧！🤯 🎉</li></ul><p id="3a5a" class="pw-post-body-paragraph ms mt iq lx b ly mu jr mv ma mw ju mx mc my mz na me nb nc nd mg ne nf ng mi ij bi translated">现在我们已经知道了二分搜索法是如何工作的，让我们看一个代码示例，来巩固我们对算法的理解:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="38b2" class="pw-post-body-paragraph ms mt iq lx b ly mu jr mv ma mw ju mx mc my mz na me nb nc nd mg ne nf ng mi ij bi translated">最后，因为二分搜索法在每次迭代中把输入分成两半，所以它运行在对数运行时:O(log n)。</p><p id="1491" class="pw-post-body-paragraph ms mt iq lx b ly mu jr mv ma mw ju mx mc my mz na me nb nc nd mg ne nf ng mi ij bi translated">一般来说，当我们有一个在每次调用时将数据分成两半的算法时，我们最有可能处理的是对数运行时:O(log n)。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="559a" class="ld le iq bd lf lg lh li lj lk ll lm ln jw lo jx lp jz lq ka lr kc ls kd lt lu bi translated">结论</h1><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oc ob l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://giphy.com/gifs/filmeditor--the-hangover-movie-3owzW5c1tPq63MPmWk" rel="noopener ugc nofollow" target="_blank">https://giphy.com/gifs/filmeditor-宿醉电影-3 owzw 5 C1 tpq 63 pmwk</a></p></figure><p id="b28a" class="pw-post-body-paragraph ms mt iq lx b ly mu jr mv ma mw ju mx mc my mz na me nb nc nd mg ne nf ng mi ij bi translated">好了，各位，希望这篇文章很有见地，你们读得很开心，并且没有让你们不知所措，这篇文章将是我很快会写的一系列关于计算机科学主题的文章，比如(复杂性分析、软件工程、分布式系统等等..)，如果您有任何意见、反馈或您只是喜欢它，一般来说，您的反馈是值得赞赏的。祝您好运💫</p><h1 id="b53a" class="ld le iq bd lf lg od li lj lk oe lm ln jw of jx lp jz og ka lr kc oh kd lt lu bi translated">参考资料:</h1><div class="oi oj gp gr ok ol"><a href="https://stackoverflow.com/questions/42568658/why-are-logarithms-in-computer-science-presumed-to-be-base-2-logarithms" rel="noopener  ugc nofollow" target="_blank"><div class="om ab fo"><div class="on ab oo cl cj op"><h2 class="bd ir gy z fp oq fr fs or fu fw ip bi translated">为什么计算机科学中的对数被假定为以2为底的对数？</h2><div class="os l"><h3 class="bd b gy z fp oq fr fs or fu fw dk translated">在计算机科学中，对数产生的最常见的方式之一是通过重复地将一些数组分成两半…</h3></div><div class="ot l"><p class="bd b dl z fp oq fr fs or fu fw dk translated">stackoverflow.com</p></div></div><div class="ou l"><div class="ov l ow ox oy ou oz kp ol"/></div></div></a></div><div class="oi oj gp gr ok ol"><a href="https://www.sciencenewsforstudents.org/article/explainer-what-are-logarithms-exponents" rel="noopener  ugc nofollow" target="_blank"><div class="om ab fo"><div class="on ab oo cl cj op"><h2 class="bd ir gy z fp oq fr fs or fu fw ip bi translated">解释者:什么是对数和指数？</h2><div class="os l"><h3 class="bd b gy z fp oq fr fs or fu fw dk translated">酸性:对含酸物质的形容词。这些材料通常能够侵蚀一些矿物质…</h3></div><div class="ot l"><p class="bd b dl z fp oq fr fs or fu fw dk translated">www.sciencenewsforstudents.org</p></div></div><div class="ou l"><div class="pa l ow ox oy ou oz kp ol"/></div></div></a></div></div></div>    
</body>
</html>