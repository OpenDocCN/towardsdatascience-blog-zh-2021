<html>
<head>
<title>A Complete Data Analysis Workflow in Python PyCaret</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python PyCaret中的完整数据分析工作流</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/a-complete-data-analysis-workflow-in-python-pycaret-9a13c0fa51d4?source=collection_archive---------19-----------------------#2021-06-10">https://towardsdatascience.com/a-complete-data-analysis-workflow-in-python-pycaret-9a13c0fa51d4?source=collection_archive---------19-----------------------#2021-06-10</a></blockquote><div><div class="fc ik il im in io"/><div class="ip iq ir is it"><h2 id="4af3" class="iu iv iw bd b dl ix iy iz ja jb jc dk jd translated" aria-label="kicker paragraph">数据分析</h2><div class=""/><div class=""><h2 id="a6da" class="pw-subtitle-paragraph kc jf iw bd b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt dk translated">这是一个现成的教程，利用了我用过的最好的机器学习库。</h2></div><figure class="kv kw kx ky gu kz gi gj paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="gi gj ku"><img src="../Images/d6d0ea6bd4e7e3fbe3c2cb4b4f086cb6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S83D2f3dDqSMELl3Byo7fw.jpeg"/></div></div><p class="lg lh gk gi gj li lj bd b be z dk translated">图片由<a class="ae lk" href="https://pixabay.com/users/xresch-7410129/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=5090539" rel="noopener ugc nofollow" target="_blank"> xresch </a>从<a class="ae lk" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=5090539" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>获得</p></figure><p id="9b4d" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated">在这个简短的教程中，我展示了一个利用<code class="fe mh mi mj mk b">pycaret</code> Python库的完整数据分析过程。这个库的文档可以在<a class="ae lk" href="https://pycaret.org/" rel="noopener ugc nofollow" target="_blank">这个链接</a>找到。该过程包括:</p><ul class=""><li id="6d42" class="ml mm iw ln b lo lp lr ls lu mn ly mo mc mp mg mq mr ms mt bi translated">预处理，包括标准化和平衡化</li><li id="fd37" class="ml mm iw ln b lo mu lr mv lu mw ly mx mc my mg mq mr ms mt bi translated">带参数调整的模型选择</li><li id="f8c5" class="ml mm iw ln b lo mu lr mv lu mw ly mx mc my mg mq mr ms mt bi translated">模型评估</li><li id="cd5f" class="ml mm iw ln b lo mu lr mv lu mw ly mx mc my mg mq mr ms mt bi translated">在看不见的数据上部署。</li></ul><p id="a1fe" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated">本教程的完整代码可以从<a class="ae lk" href="https://github.com/alod83/data-science/blob/master/DataAnalysis/Data%20Analysis%20with%20pycaret.ipynb" rel="noopener ugc nofollow" target="_blank">我的Github库</a>下载。</p><h1 id="cffb" class="mz na iw bd nb nc nd ne nf ng nh ni nj kl nk km nl ko nm kp nn kr no ks np nq bi translated">加载数据集</h1><p id="da4d" class="pw-post-body-paragraph ll lm iw ln b lo nr kg lq lr ns kj lt lu nt lw lx ly nu ma mb mc nv me mf mg ip bi translated">首先，我通过Python <code class="fe mh mi mj mk b">pandas</code>库加载数据集。我利用了由<a class="ae lk" href="https://www.kaggle.com/rashikrahmanpritom/heart-attack-analysis-prediction-dataset" rel="noopener ugc nofollow" target="_blank"> Kaggle库</a>提供的<code class="fe mh mi mj mk b">heart.csv</code>数据集。该数据集可用于执行二元分类。数据集包含303条记录和13个输入要素。</p><pre class="kv kw kx ky gu nw mk nx ny aw nz bi"><span id="6e69" class="oa na iw mk b gz ob oc l od oe">import pandas as pd</span><span id="325a" class="oa na iw mk b gz of oc l od oe">df = pd.read_csv('source/heart.csv')<br/>df.head()</span></pre><figure class="kv kw kx ky gu kz gi gj paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="gi gj og"><img src="../Images/2661398eb8d1621f84d22bbb90024afb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9q70ZkSNIiDrFdQHcSfh6A.png"/></div></div><p class="lg lh gk gi gj li lj bd b be z dk translated">作者图片</p></figure><h1 id="c4bf" class="mz na iw bd nb nc nd ne nf ng nh ni nj kl nk km nl ko nm kp nn kr no ks np nq bi translated">分割数据</h1><p id="32cd" class="pw-post-body-paragraph ll lm iw ln b lo nr kg lq lr ns kj lt lu nt lw lx ly nu ma mb mc nv me mf mg ip bi translated">现在，我可以将数据分为用于建模的数据和用于预测的不可见数据。用于建模的数据将被分割成训练集和测试集，但是我将在本教程的后面执行这个操作。</p><p id="917d" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated">通过<code class="fe mh mi mj mk b">dataframe</code>函数<code class="fe mh mi mj mk b">sample()</code>使用建模/不可见分割，该函数返回随机项目的一部分，并接收要返回的项目的一部分作为输入(<code class="fe mh mi mj mk b">frac</code>)。在我的例子中，我保留95%的数据用于建模，5%用于隐藏。</p><pre class="kv kw kx ky gu nw mk nx ny aw nz bi"><span id="4c63" class="oa na iw mk b gz ob oc l od oe">data = df.sample(frac=0.95, random_state=42)</span></pre><p id="81d9" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated">当先前提取的数据被丢弃时，我将<code class="fe mh mi mj mk b">data_unseen</code>计算为剩余的数据帧。</p><pre class="kv kw kx ky gu nw mk nx ny aw nz bi"><span id="9071" class="oa na iw mk b gz ob oc l od oe">data_unseen = df.drop(data.index)</span></pre><p id="4acd" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated">我重置了<code class="fe mh mi mj mk b">data</code>和<code class="fe mh mi mj mk b">data_unseen</code>的索引。</p><pre class="kv kw kx ky gu nw mk nx ny aw nz bi"><span id="dea9" class="oa na iw mk b gz ob oc l od oe">data.reset_index(inplace=True, drop=True)<br/>data_unseen.reset_index(inplace=True, drop=True)</span></pre><p id="4ba2" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated">最后，我打印两个数据集的大小。</p><pre class="kv kw kx ky gu nw mk nx ny aw nz bi"><span id="06f9" class="oa na iw mk b gz ob oc l od oe">print('Data for Modeling: ' + str(data.shape))<br/>print('Unseen Data For Predictions: ' + str(data_unseen.shape))</span></pre><p id="c91e" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated">它给出了以下输出:</p><pre class="kv kw kx ky gu nw mk nx ny aw nz bi"><span id="2f4e" class="oa na iw mk b gz ob oc l od oe">Data for Modeling: (288, 14)<br/>Unseen Data For Predictions: (15, 14)</span></pre><h1 id="83d8" class="mz na iw bd nb nc nd ne nf ng nh ni nj kl nk km nl ko nm kp nn kr no ks np nq bi translated">数据预处理</h1><p id="8e05" class="pw-post-body-paragraph ll lm iw ln b lo nr kg lq lr ns kj lt lu nt lw lx ly nu ma mb mc nv me mf mg ip bi translated">数据预处理通过<code class="fe mh mi mj mk b">setup()</code>函数在<code class="fe mh mi mj mk b">pycaret</code>中完成，该函数可以接收数量惊人的参数作为输入。在本教程中，我利用了三种预处理技术:</p><ul class=""><li id="d2ce" class="ml mm iw ln b lo lp lr ls lu mn ly mo mc mp mg mq mr ms mt bi translated"><strong class="ln jg">标准化</strong>，在同一区间内缩放所有特征。我利用了<code class="fe mh mi mj mk b">minmax</code>函数。我在我的<a class="ae lk" rel="noopener" target="_blank" href="/data-preprocessing-with-python-pandas-part-3-normalisation-5b5392d27673">上一篇文章</a>中讨论了数据标准化。</li><li id="6a98" class="ml mm iw ln b lo mu lr mv lu mw ly mx mc my mg mq mr ms mt bi translated"><strong class="ln jg">训练测试分割</strong>，将数据集分割成两部分:训练和测试集。训练集大小是整个数据集的80%。</li><li id="1be7" class="ml mm iw ln b lo mu lr mv lu mw ly mx mc my mg mq mr ms mt bi translated"><strong class="ln jg">平衡</strong>，试图平衡阶级。我试图对少数民族阶层进行过度采样。<code class="fe mh mi mj mk b">pycaret</code>库利用<code class="fe mh mi mj mk b">imblearn</code>库来执行平衡。关于不平衡学习库的更多细节可以在这里找到<a class="ae lk" href="https://imbalanced-learn.org/stable/" rel="noopener ugc nofollow" target="_blank">。</a></li></ul><p id="b5aa" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated">在执行平衡之前，我会检查数据集是否平衡，即训练集中的输出类是否被均等地表示。我可以使用<code class="fe mh mi mj mk b">value_counts()</code>函数来计算每个输出类中的记录数。输出类是不平衡的，因此我可以平衡它们。在本教程中，我通过<code class="fe mh mi mj mk b">RandomOverSampler()</code>执行过采样。</p><pre class="kv kw kx ky gu nw mk nx ny aw nz bi"><span id="ce9f" class="oa na iw mk b gz ob oc l od oe">data['output'].value_counts()</span></pre><p id="a74e" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated">它给出了以下输出:</p><pre class="kv kw kx ky gu nw mk nx ny aw nz bi"><span id="352b" class="oa na iw mk b gz ob oc l od oe">1    155<br/>0    133</span></pre><p id="c5f4" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated"><code class="fe mh mi mj mk b">setup()</code>功能接收以下输入:</p><ul class=""><li id="d16e" class="ml mm iw ln b lo lp lr ls lu mn ly mo mc mp mg mq mr ms mt bi translated"><code class="fe mh mi mj mk b">normalize = True</code>和<code class="fe mh mi mj mk b">normalize_method='minmax'</code>，指定如何执行标准化</li><li id="7653" class="ml mm iw ln b lo mu lr mv lu mw ly mx mc my mg mq mr ms mt bi translated"><code class="fe mh mi mj mk b">train_size = 0.8</code>执行训练/测试分割</li><li id="3b4a" class="ml mm iw ln b lo mu lr mv lu mw ly mx mc my mg mq mr ms mt bi translated"><code class="fe mh mi mj mk b">fix_imbalance = True</code>和<code class="fe mh mi mj mk b">fix_imbalance_method=RandomOverSampler()</code>指定如何执行平衡</li></ul><p id="feb0" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated">其他参数包括:</p><ul class=""><li id="26ce" class="ml mm iw ln b lo lp lr ls lu mn ly mo mc mp mg mq mr ms mt bi translated"><code class="fe mh mi mj mk b">session_id=123</code>，用于实验的再现性。值<code class="fe mh mi mj mk b">123</code>可以是随机数</li><li id="eaa2" class="ml mm iw ln b lo mu lr mv lu mw ly mx mc my mg mq mr ms mt bi translated"><code class="fe mh mi mj mk b">data = data</code>，指定型号数据</li><li id="0e79" class="ml mm iw ln b lo mu lr mv lu mw ly mx mc my mg mq mr ms mt bi translated"><code class="fe mh mi mj mk b">target = 'output'</code>，指定目标类。</li></ul><p id="518f" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated">在运行设置之前，该功能要求确认参数的自动识别。</p><pre class="kv kw kx ky gu nw mk nx ny aw nz bi"><span id="eb2e" class="oa na iw mk b gz ob oc l od oe">from pycaret.classification import *<br/>from imblearn.over_sampling import RandomOverSampler</span><span id="7839" class="oa na iw mk b gz of oc l od oe">model = setup(data = data, target = 'output', normalize = True, normalize_method='minmax', train_size = 0.8,fix_imbalance = True, fix_imbalance_method=RandomOverSampler(), session_id=123)</span></pre><h1 id="aedd" class="mz na iw bd nb nc nd ne nf ng nh ni nj kl nk km nl ko nm kp nn kr no ks np nq bi translated">模型选择和调整</h1><p id="96e5" class="pw-post-body-paragraph ll lm iw ln b lo nr kg lq lr ns kj lt lu nt lw lx ly nu ma mb mc nv me mf mg ip bi translated">型号选择有两种方式:</p><ul class=""><li id="8702" class="ml mm iw ln b lo lp lr ls lu mn ly mo mc mp mg mq mr ms mt bi translated">选择一个特定的模型，然后调整它</li><li id="b84d" class="ml mm iw ln b lo mu lr mv lu mw ly mx mc my mg mq mr ms mt bi translated">AutoML:让库选择最好的模型，然后调整它。</li></ul><h2 id="b745" class="oa na iw bd nb oh oi dn nf oj ok dp nj lu ol om nl ly on oo nn mc op oq np jc bi translated">选择具体型号</h2><p id="5a03" class="pw-post-body-paragraph ll lm iw ln b lo nr kg lq lr ns kj lt lu nt lw lx ly nu ma mb mc nv me mf mg ip bi translated">在这种情况下，我选择K-Neighbors分类器。首先，我通过<code class="fe mh mi mj mk b">create_model()</code>函数创建模型，然后通过<code class="fe mh mi mj mk b">tune_model()</code>函数调整它。有趣的是，该模型不将数据作为输入，因为它们已经通过<code class="fe mh mi mj mk b">setup()</code>函数包含在<code class="fe mh mi mj mk b">pycaret</code>中。作为默认选项，<code class="fe mh mi mj mk b">tune_model()</code>执行10重验证。</p><p id="441c" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated">作为输出，<code class="fe mh mi mj mk b">tune_model()</code>函数打印每个折叠的以下指标，以及平均值和标准偏差:准确性、AUC、召回率、精确度、F1、Kappa、MCC。</p><pre class="kv kw kx ky gu nw mk nx ny aw nz bi"><span id="a43e" class="oa na iw mk b gz ob oc l od oe">knn = create_model('knn')<br/>tuned_knn = tune_model(knn)</span></pre><figure class="kv kw kx ky gu kz gi gj paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="gi gj or"><img src="../Images/34c33cea2096ebf4c860223e4d63e5e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PeJ-MkQlw_WDHNORNbqr3g.png"/></div></div><p class="lg lh gk gi gj li lj bd b be z dk translated">作者图片</p></figure><p id="ffee" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated"><code class="fe mh mi mj mk b">pycaret</code>库还提供了<code class="fe mh mi mj mk b">plot_model()</code>函数，允许绘制一些度量标准，如<code class="fe mh mi mj mk b">auc</code> (ROC曲线)和<code class="fe mh mi mj mk b">pr</code>(精确召回曲线)。</p><pre class="kv kw kx ky gu nw mk nx ny aw nz bi"><span id="e698" class="oa na iw mk b gz ob oc l od oe">plot_model(tuned_knn, plot = 'auc')</span></pre><figure class="kv kw kx ky gu kz gi gj paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="gi gj os"><img src="../Images/8b83e326883b8a8ca7fe74766c4e633b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mK8TP-b0rqoleBXtTVV_gg.png"/></div></div><p class="lg lh gk gi gj li lj bd b be z dk translated">作者图片</p></figure><pre class="kv kw kx ky gu nw mk nx ny aw nz bi"><span id="51a6" class="oa na iw mk b gz ob oc l od oe">plot_model(tuned_knn, plot = 'pr')</span></pre><figure class="kv kw kx ky gu kz gi gj paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="gi gj os"><img src="../Images/320b779b33435e93163dcfefc93fe326.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_ByqQjvmm8GXDFIGRMhEmw.png"/></div></div><p class="lg lh gk gi gj li lj bd b be z dk translated">作者图片</p></figure><p id="f800" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated">现在，我可以利用调整后的模型对用于建模的所有数据集中的项目进行分类(包括训练集和测试集)。这可以通过<code class="fe mh mi mj mk b">predict_model()</code>函数来完成，该函数返回计算出的指标。此外，对于数据集中的每一项，它返回原始输入、输出、预测标签(列<code class="fe mh mi mj mk b">Label</code>)和分数(列<code class="fe mh mi mj mk b">Score</code>)。</p><pre class="kv kw kx ky gu nw mk nx ny aw nz bi"><span id="2a91" class="oa na iw mk b gz ob oc l od oe">predict_model(tuned_knn)</span></pre><figure class="kv kw kx ky gu kz gi gj paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="gi gj ot"><img src="../Images/e36d826ac758e49975649968b371084d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5MrI61ZnIjmFD0xo6_JQ5g.png"/></div></div><p class="lg lh gk gi gj li lj bd b be z dk translated">作者图片</p></figure><h2 id="2710" class="oa na iw bd nb oh oi dn nf oj ok dp nj lu ol om nl ly on oo nn mc op oq np jc bi translated">AutoML</h2><p id="5c7f" class="pw-post-body-paragraph ll lm iw ln b lo nr kg lq lr ns kj lt lu nt lw lx ly nu ma mb mc nv me mf mg ip bi translated">AutoML可通过<code class="fe mh mi mj mk b">compare_models()</code>功能完成，该功能分析所有可用模型，返回最佳模型，并打印每个测试模型的测量指标。</p><pre class="kv kw kx ky gu nw mk nx ny aw nz bi"><span id="c41b" class="oa na iw mk b gz ob oc l od oe">best = compare_models()</span></pre><figure class="kv kw kx ky gu kz gi gj paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="gi gj ou"><img src="../Images/3401455340428c51fb5a3a6077603fc8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xb9-UKwaLPDCANNwOm1anw.png"/></div></div><p class="lg lh gk gi gj li lj bd b be z dk translated">作者图片</p></figure><p id="a7cb" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated">最佳模式是:</p><pre class="kv kw kx ky gu nw mk nx ny aw nz bi"><span id="8e6e" class="oa na iw mk b gz ob oc l od oe">LinearDiscriminantAnalysis(n_components=None, priors=None, shrinkage=None, solver='svd', store_covariance=False, tol=0.0001)</span></pre><p id="e70c" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated">现在，我可以通过<code class="fe mh mi mj mk b">tune_model()</code>功能调整最佳型号。该过程类似于单个模型所遵循的过程。因此，在模型调优之后，我可以绘制一些度量标准，比如精度-召回曲线。</p><pre class="kv kw kx ky gu nw mk nx ny aw nz bi"><span id="2650" class="oa na iw mk b gz ob oc l od oe">tuned_best = tune_model(best)</span></pre><figure class="kv kw kx ky gu kz gi gj paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="gi gj ov"><img src="../Images/316696aed5092e14d31b9f186030e47f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vMBGIcBTsGRwTmOgTHOrDQ.png"/></div></div><p class="lg lh gk gi gj li lj bd b be z dk translated">作者图片</p></figure><pre class="kv kw kx ky gu nw mk nx ny aw nz bi"><span id="6b14" class="oa na iw mk b gz ob oc l od oe">plot_model(tuned, plot = 'pr')</span></pre><figure class="kv kw kx ky gu kz gi gj paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="gi gj ow"><img src="../Images/66de0df3ce66f2f00a1a7cceff8ad1d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vpQRcOzZNltgSZ0N3ZwXmA.png"/></div></div><p class="lg lh gk gi gj li lj bd b be z dk translated">作者图片</p></figure><h1 id="6b6c" class="mz na iw bd nb nc nd ne nf ng nh ni nj kl nk km nl ko nm kp nn kr no ks np nq bi translated">最终确定模型</h1><p id="30e0" class="pw-post-body-paragraph ll lm iw ln b lo nr kg lq lr ns kj lt lu nt lw lx ly nu ma mb mc nv me mf mg ip bi translated">一旦模型被调优，它就可以被最终确定，即通过包含测试集来重新调优。</p><pre class="kv kw kx ky gu nw mk nx ny aw nz bi"><span id="c674" class="oa na iw mk b gz ob oc l od oe">final_best = finalize_model(tuned_best)</span></pre><p id="5ef3" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated">首先，通过再次调用<code class="fe mh mi mj mk b">predict_model()</code>功能，可以检查最终模型的性能。</p><pre class="kv kw kx ky gu nw mk nx ny aw nz bi"><span id="e8ec" class="oa na iw mk b gz ob oc l od oe">predict_model(final_best)</span></pre><figure class="kv kw kx ky gu kz gi gj paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="gi gj ox"><img src="../Images/f255ed3ed0b23917be92441bbb7c1ba5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1mHVeU3pRWPSnk1qUxCIyg.png"/></div></div><p class="lg lh gk gi gj li lj bd b be z dk translated">作者图片</p></figure><p id="f5da" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated">最后，可以在看不见的数据上测试模型的性能。</p><pre class="kv kw kx ky gu nw mk nx ny aw nz bi"><span id="a812" class="oa na iw mk b gz ob oc l od oe">predict_model(final_best, data = data_unseen)</span></pre><figure class="kv kw kx ky gu kz gi gj paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="gi gj oy"><img src="../Images/820cbbc8b0f5dbaa7a7fe25e37801501.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vxn3kGUZn2G7klcy_EjfaA.png"/></div></div><p class="lg lh gk gi gj li lj bd b be z dk translated">作者图片</p></figure><h1 id="5342" class="mz na iw bd nb nc nd ne nf ng nh ni nj kl nk km nl ko nm kp nn kr no ks np nq bi translated">摘要</h1><p id="c182" class="pw-post-body-paragraph ll lm iw ln b lo nr kg lq lr ns kj lt lu nt lw lx ly nu ma mb mc nv me mf mg ip bi translated">在本教程中，我展示了如何利用Python <code class="fe mh mi mj mk b">pycaret</code>库执行完整的数据分析工作流。该工作流程包括以下步骤:</p><ul class=""><li id="4d57" class="ml mm iw ln b lo lp lr ls lu mn ly mo mc mp mg mq mr ms mt bi translated">数据预处理</li><li id="a22d" class="ml mm iw ln b lo mu lr mv lu mw ly mx mc my mg mq mr ms mt bi translated">模型选择和调整</li><li id="67a0" class="ml mm iw ln b lo mu lr mv lu mw ly mx mc my mg mq mr ms mt bi translated">模型最终确定。</li></ul><p id="25ec" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated">如果你想了解我的研究和其他活动的最新情况，你可以在<a class="ae lk" href="https://twitter.com/alod83" rel="noopener ugc nofollow" target="_blank"> Twitter </a>、<a class="ae lk" href="https://www.youtube.com/channel/UC4O8-FtQqGIsgDW_ytXIWOg?view_as=subscriber" rel="noopener ugc nofollow" target="_blank"> Youtube </a>和<a class="ae lk" href="https://github.com/alod83" rel="noopener ugc nofollow" target="_blank"> Github </a>上关注我。</p><h1 id="1ba4" class="mz na iw bd nb nc nd ne nf ng nh ni nj kl nk km nl ko nm kp nn kr no ks np nq bi translated">相关文章</h1><div class="oz pa gq gs pb pc"><a rel="noopener follow" target="_blank" href="/a-complete-data-analysis-workflow-in-python-and-scikit-learn-9a77f7c283d3"><div class="pd ab fp"><div class="pe ab pf cl cj pg"><h2 class="bd jg gz z fq ph fs ft pi fv fx jf bi translated">Python和scikit中的完整数据分析工作流程-学习</h2><div class="pj l"><p class="bd b dl z fq ph fs ft pi fv fx dk translated">towardsdatascience.com</p></div></div><div class="pk l"><div class="pl l pm pn po pk pp le pc"/></div></div></a></div><div class="oz pa gq gs pb pc"><a rel="noopener follow" target="_blank" href="/how-to-detect-outliers-with-python-pyod-aa7147359e4b"><div class="pd ab fp"><div class="pe ab pf cl cj pg"><h2 class="bd jg gz z fq ph fs ft pi fv fx jf bi translated">如何用Python pyod检测异常值</h2><div class="pq l"><h3 class="bd b gz z fq ph fs ft pi fv fx dk translated">关于pyod库使用的快速教程。</h3></div><div class="pj l"><p class="bd b dl z fq ph fs ft pi fv fx dk translated">towardsdatascience.com</p></div></div><div class="pk l"><div class="pr l pm pn po pk pp le pc"/></div></div></a></div><div class="oz pa gq gs pb pc"><a rel="noopener follow" target="_blank" href="/automl-in-python-a-comparison-between-hyperopt-sklearn-and-tpot-8c12aaf7e829"><div class="pd ab fp"><div class="pe ab pf cl cj pg"><h2 class="bd jg gz z fq ph fs ft pi fv fx jf bi translated">Python中的AutoML:Hyperopt sk learn和TPOT的比较</h2><div class="pq l"><h3 class="bd b gz z fq ph fs ft pi fv fx dk translated">两种流行的Python AutoML库的优缺点</h3></div><div class="pj l"><p class="bd b dl z fq ph fs ft pi fv fx dk translated">towardsdatascience.com</p></div></div><div class="pk l"><div class="ps l pm pn po pk pp le pc"/></div></div></a></div><h1 id="529f" class="mz na iw bd nb nc nd ne nf ng nh ni nj kl nk km nl ko nm kp nn kr no ks np nq bi translated">新到中？您可以每月订阅几美元，并解锁无限的文章— <a class="ae lk" href="https://alod83.medium.com/membership" rel="noopener">单击此处</a>。</h1></div></div>    
</body>
</html>