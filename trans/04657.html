<html>
<head>
<title>Monads Explained</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">单子解释道</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/monads-from-the-lens-of-imperative-programmer-af1ab8c8790c?source=collection_archive---------4-----------------------#2021-04-22">https://towardsdatascience.com/monads-from-the-lens-of-imperative-programmer-af1ab8c8790c?source=collection_archive---------4-----------------------#2021-04-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/ea194fd755d8f74f769aba1ff589e4c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Fz3VuUPixyb2vbpn"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated"><a class="ae kc" href="https://unsplash.com/@sigmund?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">西格蒙德</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</p></figure><p id="cfd7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以，我费了很大的劲才明白“单子”到底是什么！到处都有人用公式或长篇大论来解释它，以至于人们几乎不可能理解它。在这里，我将用简单的语言解释复杂的逻辑。另外，如果你有兴趣看这个主题的视频，请看看下面的视频。</p><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="lf lg l"/></div></figure><p id="47e1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，为了便于理解，我将用Python编码，这样Haskell的语法就不会把你吓跑。</p></div><div class="ab cl lh li hu lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ij ik il im in"><p id="53b6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在开始之前，让我首先向您介绍Haskell的主要特性，因为它首先需要单子——函数式编程。函数式编程是一种思维模式，在这种模式下，所有的设计都是根据纯函数来考虑的。</p><ul class=""><li id="df33" class="lo lp iq kf b kg kh kk kl ko lq ks lr kw ls la lt lu lv lw bi translated">职能是一等公民。所以，所有简单的逻辑都是一个函数，所有复杂的逻辑都是通过函数间的运算来处理的。</li><li id="dfbb" class="lo lp iq kf b kg lx kk ly ko lz ks ma kw mb la lt lu lv lw bi translated">函数必须是纯的。这意味着无论你给什么输入，输出都应该保持不变。与纯函数交互的唯一方式是只通过输入和输出。它不能访问全局状态，也不能打印任何东西，甚至不能抛出异常，除非在函数定义中进行了定义。</li></ul></div><div class="ab cl lh li hu lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ij ik il im in"><p id="429c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi mc translated">Monad是一个通用的概念，它有助于在纯函数之间进行操作，以处理副作用。就是这样。让我用一个例子来解释一下，一会儿就明白了。</p></div><div class="ab cl lh li hu lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ij ik il im in"><h1 id="3c92" class="ml mm iq bd mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni bi translated">问题陈述</h1><p id="487c" class="pw-post-body-paragraph kd ke iq kf b kg nj ki kj kk nk km kn ko nl kq kr ks nm ku kv kw nn ky kz la ij bi translated">对一个数做多次平方运算。</p><pre class="lb lc ld le gt no np nq nr aw ns bi"><span id="47ed" class="nt mm iq np b gy nu nv l nw nx">def square(num: int) -&gt; int:<br/>    return num * num;</span><span id="8317" class="nt mm iq np b gy ny nv l nw nx">print(square(square(2)));</span><span id="155b" class="nt mm iq np b gy ny nv l nw nx"><strong class="np ir">--------------------------------------------------------------------<br/>Output</strong><br/>16</span></pre><h1 id="d0df" class="ml mm iq bd mn mo nz mq mr ms oa mu mv mw ob my mz na oc nc nd ne od ng nh ni bi translated">引入副作用</h1><p id="7237" class="pw-post-body-paragraph kd ke iq kf b kg nj ki kj kk nk km kn ko nl kq kr ks nm ku kv kw nn ky kz la ij bi translated">现在，让我们通过打印输入的当前值来给函数添加一个副作用。</p><pre class="lb lc ld le gt no np nq nr aw ns bi"><span id="b8ed" class="nt mm iq np b gy nu nv l nw nx">def sqaure_with_print(num: int) -&gt; int:<br/>    print("Currrent num: ", num);<br/>    return num * num;</span><span id="59a1" class="nt mm iq np b gy ny nv l nw nx">print(sqaure_with_print(sqaure_with_print(2)));</span><span id="0e27" class="nt mm iq np b gy ny nv l nw nx"><strong class="np ir">--------------------------------------------------------------------<br/>Output<br/></strong>Currrent num:  2<br/>Currrent num:  4<br/>16</span></pre><h1 id="f135" class="ml mm iq bd mn mo nz mq mr ms oa mu mv mw ob my mz na oc nc nd ne od ng nh ni bi translated">有副作用的纯函数</h1><p id="1873" class="pw-post-body-paragraph kd ke iq kf b kg nj ki kj kk nk km kn ko nl kq kr ks nm ku kv kw nn ky kz la ij bi translated">由于print语句的引入，上述函数不再是一个纯函数。现在该怎么办？如何处理纯函数中的副作用？记住，与纯函数交互的唯一方式是通过输入和输出。我们需要在输出本身中获取日志。</p><pre class="lb lc ld le gt no np nq nr aw ns bi"><span id="f9fd" class="nt mm iq np b gy nu nv l nw nx">def sqaure_with_print_return(num: int) -&gt; (int, str):<br/>    logs = "Currrent num " + str(num);<br/>    return (num * num, logs);</span><span id="5146" class="nt mm iq np b gy ny nv l nw nx">print(sqaure_with_print_return(sqaure_with_print_return(2)));</span><span id="d155" class="nt mm iq np b gy ny nv l nw nx"><strong class="np ir">--------------------------------------------------------------------<br/>Output<br/></strong>Traceback (most recent call last):<br/>File "hello.py", line 21, in &lt;module&gt;<br/>print(sqaure_with_print_return(sqaure_with_print_return(2)));<br/>File "hello.py", line 17, in sqaure_with_print_return<br/>return (num * num, logs);<br/>TypeError: can't multiply sequence by non-int of type 'tuple'</span></pre><h1 id="fd7a" class="ml mm iq bd mn mo nz mq mr ms oa mu mv mw ob my mz na oc nc nd ne od ng nh ni bi translated">自定义排版</h1><p id="0f1b" class="pw-post-body-paragraph kd ke iq kf b kg nj ki kj kk nk km kn ko nl kq kr ks nm ku kv kw nn ky kz la ij bi translated">哎呀！虽然我们能够把它变成一个纯粹的函数，但是为了把函数链接起来，同时输出副作用，破坏了程序。但是为什么会这样呢？该函数需要<code class="fe oe of og np b">int</code>，而我们通过了<code class="fe oe of og np b">(int, str)</code>。看起来只是期望不匹配。看起来需要做一些特殊处理。</p><p id="fc4b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可能需要修改<code class="fe oe of og np b">square_with_print_return,</code>，以便它可以接受<code class="fe oe of og np b">(int, str)</code>而不是<code class="fe oe of og np b">int</code>。我们是否应该改变一个函数的输入签名，以便它们可以组合？这是可扩展的吗？</p><p id="e5b8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">相反，让我们添加一个定制的compose函数，它知道如何处理上述参数不匹配的情况。</p><pre class="lb lc ld le gt no np nq nr aw ns bi"><span id="8fb1" class="nt mm iq np b gy nu nv l nw nx">def sqaure_with_print_return(num: int) -&gt; (int, str):<br/>    logs = "Currrent num " + str(num);<br/>    return (num * num, logs);</span><span id="6edc" class="nt mm iq np b gy ny nv l nw nx">def compose(func2, func1, num: int):<br/>    res1 = func1(num)<br/>    res2 = func2(res1[0])<br/>    return (res2[0], res1[1] + res2[1]);</span><span id="aab8" class="nt mm iq np b gy ny nv l nw nx">print(compose(sqaure_with_print_return, sqaure_with_print_return, 2));</span><span id="7b45" class="nt mm iq np b gy ny nv l nw nx"><strong class="np ir">--------------------------------------------------------------------<br/>Output<br/></strong>(16, 'Currrent num 2 Currrent num 4')</span></pre><p id="8135" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">耶！成功了！现在，假设我们想要链接3个函数，必须重写这个组合函数，对吗？我们需要找到一种可伸缩的方式来编写这个函数，以便它可以处理任意数量的函数。</p><h1 id="9b47" class="ml mm iq bd mn mo nz mq mr ms oa mu mv mw ob my mz na oc nc nd ne od ng nh ni bi translated">包装纯函数</h1><p id="5b2f" class="pw-post-body-paragraph kd ke iq kf b kg nj ki kj kk nk km kn ko nl kq kr ks nm ku kv kw nn ky kz la ij bi translated">更好的解决方案是使用其他包装函数，这有助于以所需的格式处理输入和输出参数。这个函数将知道如何在不改变纯函数参数的情况下处理副作用。</p><pre class="lb lc ld le gt no np nq nr aw ns bi"><span id="a991" class="nt mm iq np b gy nu nv l nw nx">from typing import Tuple</span><span id="7acf" class="nt mm iq np b gy ny nv l nw nx">def sqaure_with_print_return(num: int) -&gt; (int, str):<br/>    logs = "Currrent num " + str(num);<br/>    return (num * num, logs);</span><span id="d03b" class="nt mm iq np b gy ny nv l nw nx">def bind(func, tuple: Tuple[int, str]):<br/>   res = func(tuple[0])<br/>   return (res[0], tuple[1] + res[1])</span><span id="de10" class="nt mm iq np b gy ny nv l nw nx">def unit(number: int):<br/>   return (number, "");</span><span id="7f9e" class="nt mm iq np b gy ny nv l nw nx">print(bind(sqaure_with_print_return, (bind(sqaure_with_print_return, unit(2)))))</span><span id="dde2" class="nt mm iq np b gy ny nv l nw nx"><strong class="np ir">--------------------------------------------------------------------<br/>Output<br/></strong>(16, 'Currrent num 2 Currrent num 4')</span></pre><ul class=""><li id="3412" class="lo lp iq kf b kg kh kk kl ko lq ks lr kw ls la lt lu lv lw bi translated"><strong class="kf ir">绑定函数:</strong>这只是<code class="fe oe of og np b">square_with_print_return </code>上的一个包装函数，它接受一个元组，而不仅仅是int。所以，所有这样的函数都可以用绑定函数来包装。因此，现在您的纯函数可以处理任何类型的输入参数</li><li id="59fd" class="lo lp iq kf b kg lx kk ly ko lz ks ma kw mb la lt lu lv lw bi translated"><strong class="kf ir">单元函数:</strong>但是我们的第一个参数是一个整数。有人应该把它转换成一个元组。这就是单位函数的作用。</li></ul><p id="c55a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是我的朋友，叫莫纳德！</p></div><div class="ab cl lh li hu lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ij ik il im in"><p id="01c4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，我们可以说，单子只是处理纯函数中副作用的一种漂亮而通用的方式，并提供了一种通过使用绑定和单元概念来组合纯函数的可伸缩方法。</p></div></div>    
</body>
</html>