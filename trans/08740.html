<html>
<head>
<title>Masking Geo-Spatial Level 3 Satellite Images Using Shapefiles: A Grid-Based Approach</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Shapefiles掩蔽地理空间3级卫星图像:基于网格的方法</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/masking-geo-spatial-level-3-satellite-images-using-shapefiles-a-grid-based-approach-c88d7a108f4a?source=collection_archive---------19-----------------------#2021-08-12">https://towardsdatascience.com/masking-geo-spatial-level-3-satellite-images-using-shapefiles-a-grid-based-approach-c88d7a108f4a?source=collection_archive---------19-----------------------#2021-08-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="072f" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何使用相应区域的shapefile处理和屏蔽特定区域所需的大气三级数据</h2></div></div><div class="ab cl kf kg hu kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="ij ik il im in"><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/52358e3564a0006e9850a983b6a20dca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Mj251aybXu2VURTk"/></div></div><p class="ky kz gj gh gi la lb bd b be z dk translated">美国宇航局在<a class="ae lc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><h1 id="46ae" class="ld le iq bd lf lg lh li lj lk ll lm ln jw lo jx lp jz lq ka lr kc ls kd lt lu bi translated">介绍</h1><p id="22da" class="pw-post-body-paragraph lv lw iq lx b ly lz jr ma mb mc ju md me mf mg mh mi mj mk ml mm mn mo mp mq ij bi translated">让我们先从<strong class="lx ir">遥感的概念说起。</strong>这是一项通过传感器(如卫星)收集数据的自然研究。这些传感器可以监测和收集地球不同方面的数据。其中一些包括植被数据、大气数据、海洋数据等。他们以热图或图像的形式提供数据。图像处理和屏蔽是从传感器收集的数据中提取信息所需的基本工具。本文重点介绍如何使用相应区域的shapefile处理和屏蔽特定区域所需的<strong class="lx ir">大气NO2 </strong>数据。这里使用的数据是由臭氧监测仪器(OMI)收集的。数据是从Earthdata网站下载的，你可以从下面的链接下载数据。</p><p id="5787" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated"><a class="ae lc" href="https://search.earthdata.nasa.gov/search/granules?p=C1266136111-GES_DISC&amp;pg[0][v]=f&amp;pg[0][gsk]=-start_date&amp;q=omi%20no2&amp;tl=1628603996.133!3" rel="noopener ugc nofollow" target="_blank">https://search.earthdata.nasa.gov/search/granules?p = c 1266136111-GES _ DISC&amp;pg[0][v]= f&amp;pg[0][GSK]=-start _ date&amp;q = OMI % 20no 2&amp;TL = 1628603996.133！3 </a>！！</p><h1 id="ccb0" class="ld le iq bd lf lg lh li lj lk ll lm ln jw lo jx lp jz lq ka lr kc ls kd lt lu bi translated">数据描述</h1><p id="e55f" class="pw-post-body-paragraph lv lw iq lx b ly lz jr ma mb mc ju md me mf mg mh mi mj mk ml mm mn mo mp mq ij bi translated">这里使用的数据是OMI卫星记录的3级二维网格卫星数据。数据的分辨率为(0.25 x 0.25)度网格。数据由对流层柱状<strong class="lx ir">二氧化氮</strong>气体组成。数据集的详细结构可以提取如下:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi mw"><img src="../Images/d0ebfd4ed28e0c34bb9c3c27abcea899.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1ga64bkrCrpHyo3rR0aBtA.png"/></div></div></figure><p id="8a18" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated"><em class="mx">*在文件名中使用您自己的文件路径* </em></p><p id="bfd3" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">主数据字段位于数据集的数据字段子树下。有四个数据变量，如下所述:</p><blockquote class="my mz na"><p id="337c" class="lv lw mx lx b ly mr jr ma mb ms ju md nb mt mg mh nc mu mk ml nd mv mo mp mq ij bi translated"><strong class="lx ir"> ColumnAmountNo2: </strong>总的No2柱密度。</p><p id="dd06" class="lv lw mx lx b ly mr jr ma mb ms ju md nb mt mg mh nc mu mk ml nd mv mo mp mq ij bi translated"><strong class="lx ir">columnaumntno 2 cloudscreened:</strong>滤除云噪声后的总NO2柱密度。</p><p id="1ab6" class="lv lw mx lx b ly mr jr ma mb ms ju md nb mt mg mh nc mu mk ml nd mv mo mp mq ij bi translated"><strong class="lx ir">columnaumntno 2 drop:</strong>对流层区域NO2的柱密度。</p><p id="e8b7" class="lv lw mx lx b ly mr jr ma mb ms ju md nb mt mg mh nc mu mk ml nd mv mo mp mq ij bi translated"><strong class="lx ir">columnaumntno 2 ropcloudscreened:</strong>无云噪声的对流层区域NO2的柱密度。</p></blockquote><p id="f0de" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">在本文中，我们将使用数据变量<strong class="lx ir">columnamountno 2 ropcloudscreened</strong>。</p><h1 id="464f" class="ld le iq bd lf lg lh li lj lk ll lm ln jw lo jx lp jz lq ka lr kc ls kd lt lu bi translated">工具和技术</h1><p id="c1d2" class="pw-post-body-paragraph lv lw iq lx b ly lz jr ma mb mc ju md me mf mg mh mi mj mk ml mm mn mo mp mq ij bi translated">Python 3.7被用作提取和处理数据集的主要语言。这个版本很重要，因为另一个名为<em class="mx"> geopandas </em>的包不能在python的更高版本上工作。Jupyter笔记本用于执行脚本。数据集采用. he5文件格式。为了从数据文件中读取和提取数据，需要一个名为<em class="mx"> h5py </em>的专门包。所有这些都可以在conda环境中获得，您可以使用Anaconda通过给定的链接进行安装。</p><div class="ne nf gp gr ng nh"><a href="https://www.anaconda.com/products/individual" rel="noopener  ugc nofollow" target="_blank"><div class="ni ab fo"><div class="nj ab nk cl cj nl"><h2 class="bd ir gy z fp nm fr fs nn fu fw ip bi translated">Anaconda |个人版</h2><div class="no l"><h3 class="bd b gy z fp nm fr fs nn fu fw dk translated">Anaconda的开源个人版是在一个应用程序上执行Python/R数据科学和机器学习的最简单的方法</h3></div><div class="np l"><p class="bd b dl z fp nm fr fs nn fu fw dk translated">www.anaconda.com</p></div></div><div class="nq l"><div class="nr l ns nt nu nq nv kw nh"/></div></div></a></div><p id="4bc7" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">执行代码所需的包有:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi mw"><img src="../Images/7dce83a21d28e1786322cf93018dc7b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Lt3gyLLtIVQUovi2ymcgtg.png"/></div></div></figure><h1 id="5ebf" class="ld le iq bd lf lg lh li lj lk ll lm ln jw lo jx lp jz lq ka lr kc ls kd lt lu bi translated">导入数据</h1><p id="6344" class="pw-post-body-paragraph lv lw iq lx b ly lz jr ma mb mc ju md me mf mg mh mi mj mk ml mm mn mo mp mq ij bi translated">为了导入数据，需要名为<em class="mx"> os </em>的包，这是python中的一个内置包。它遍历给定的路径，并将文件夹中包含的所有文件名读入python中的一个列表。使用如下所示的路径成功检索数据集名称后，需要使用<em class="mx"> h5py </em>包提取数据。</p><p id="a616" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">在提取数据时，数据需要被清理，即所有小于零的像素值需要被过滤并用NaN值替换。数据提取和清理一次完成，节省了一些计算开销，也减少了代码的大小。清除数据后，沿轴=0取所有数据的平均值，得到平均数据。</p><p id="42af" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">#注:<em class="mx">根据需要取平均值。如果每天都要进行一些分析，可以跳过均值步骤，单独运行每个数据的屏蔽。</em></p><p id="3cb3" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">整个过程需要分两步完成:</p><ul class=""><li id="8eea" class="nw nx iq lx b ly mr mb ms me ny mi nz mm oa mq ob oc od oe bi translated">收集所有数据文件名。</li><li id="f0a4" class="nw nx iq lx b ly of mb og me oh mi oi mm oj mq ob oc od oe bi translated">使用h5py提取数据。</li></ul><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi mw"><img src="../Images/cb93010a87b346ff1c14af0732cc539a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nrlN2pZFAtyvj8wj3BWL_g.png"/></div></div><p class="ky kz gj gh gi la lb bd b be z dk translated">正在收集相关路径中的所有文件</p></figure><pre class="kn ko kp kq gt ok ol om on aw oo bi"><span id="14f8" class="op le iq ol b gy oq or l os ot">def extractData(filenames):<br/>    data = []<br/>    for fname in filenames:<br/>        fHandle = hdf.File(fname,'r')<br/>        #Data extraction<br/>        #Use any one of the data variable from data description<br/>        dataNo2 = fHandle['HDFEOS/GRIDS/ColumnAmountNO2/Data Fields/ColumnAmountNO2TropCloudScreened'][:]<br/>        dataNo2[dataNo2 &lt; 0] = np.nan #cleaning <br/>        data.append(dataNo2)<br/>    dataArray = np.array(data)<br/>    mean = np.nanmean(dataArray, axis=0)<br/>    return mean</span></pre><p id="6a72" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">这里，<strong class="lx ir"> <em class="mx"> fHandle </em> </strong>内的路径是取自数据描述的路径。</p><h1 id="d09e" class="ld le iq bd lf lg lh li lj lk ll lm ln jw lo jx lp jz lq ka lr kc ls kd lt lu bi translated">读取形状文件</h1><p id="02f9" class="pw-post-body-paragraph lv lw iq lx b ly lz jr ma mb mc ju md me mf mg mh mi mj mk ml mm mn mo mp mq ij bi translated">出于测试目的，使用了印度国家边界shapefile。读取和处理形状文件<em class="mx">需要geopandas </em>。Geopandas是python中的一个包，广泛用于地理数据处理。出于可视化的目的，使用matplotlib。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi ou"><img src="../Images/12a4d9737b552263a917d3aeec2efcf0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3anh3eXWdXDrQq1Q0OWb2Q.png"/></div></div></figure><h1 id="b008" class="ld le iq bd lf lg lh li lj lk ll lm ln jw lo jx lp jz lq ka lr kc ls kd lt lu bi translated">创建纬度和经度列表</h1><p id="6a11" class="pw-post-body-paragraph lv lw iq lx b ly lz jr ma mb mc ju md me mf mg mh mi mj mk ml mm mn mo mp mq ij bi translated">为了将图像数据转换成网格地理数据集，每个数据点的确切位置必须与全球坐标系统上的相应位置(纬度和经度)相关联。为了关联数据，使用数据的分辨率生成纬度和经度向量。由于NO2数据是世界数据，纬度的界限被设置为<strong class="lx ir"> [-90，90] </strong>，经度的界限被设置为<strong class="lx ir"> [-180，180】。</strong>由于数据的分辨率为0.25度，我们创建一个间隔为0.25的等间距数组，并保持纬度和经度的界限。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi mw"><img src="../Images/2b01511246763fa4c590119efea38d7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fpqEeHJDldJSlkLMmVFiwg.png"/></div></div></figure><h1 id="0962" class="ld le iq bd lf lg lh li lj lk ll lm ln jw lo jx lp jz lq ka lr kc ls kd lt lu bi translated">从shapefile获取边界</h1><p id="7f26" class="pw-post-body-paragraph lv lw iq lx b ly lz jr ma mb mc ju md me mf mg mh mi mj mk ml mm mn mo mp mq ij bi translated">为了将全局数据裁剪为shapefile的坐标，需要从我们正在使用的各个shapefile中提取纬度和经度边界。这将进一步用于在屏蔽后重新研磨数据，并将数据裁剪到所需的坐标。这可以通过用shapefile的边界生成另一组纬度和经度列表来完成。</p><p id="9857" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">一个shapefile可能由多个多边形组成，它需要从所有多边形中获取纬度和经度坐标。取其中的最大值和最小值将提供总shapefile的边界，如下所示。</p><pre class="kn ko kp kq gt ok ol om on aw oo bi"><span id="b40f" class="op le iq ol b gy oq or l os ot">def getBounds(shape):<br/>    x1 = []<br/>    y1 = []<br/>    for i in range(len(shape)):<br/>        if(isinstance(shape.iloc[i].geometry, shapely.geometry.polygon.Polygon)):  <br/>            x = shape.exterior.iloc[i].coords.xy[0]<br/>            y = shape.exterior.iloc[i].coords.xy[1]<br/>            x1.append(min(x))<br/>            x1.append(max(x))<br/>            y1.append(min(y))<br/>            y1.append(max(y))<br/>        else:<br/>            for poly in shape.iloc[i].geometry:<br/>                x = poly.exterior.coords.xy[0]<br/>                y = poly.exterior.coords.xy[1]<br/>                x1.append(min(x))<br/>                x1.append(max(x))<br/>                y1.append(min(y))<br/>                y1.append(max(y))</span><span id="91ab" class="op le iq ol b gy ov or l os ot">return x1,y1</span><span id="2dd8" class="op le iq ol b gy ov or l os ot">def getBoundary(shape,res):<br/>    x,y = getBounds(shape)<br/>    my_lats = np.arange(np.min(y)-res/2, np.max(y)+res/2, res)<br/>    my_lons = np.arange(np.min(x)-res/2, np.max(x)+res/2, res)<br/>    return(my_lats,my_lons)</span></pre><h1 id="a0d2" class="ld le iq bd lf lg lh li lj lk ll lm ln jw lo jx lp jz lq ka lr kc ls kd lt lu bi translated">创建和裁剪地理数据框</h1><p id="615e" class="pw-post-body-paragraph lv lw iq lx b ly lz jr ma mb mc ju md me mf mg mh mi mj mk ml mm mn mo mp mq ij bi translated">到目前为止，我们一直使用文件中的原始数据。但是为了以后屏蔽数据，需要将这些数据转换成由地理点组成的地理数据框架。这可以使用<em class="mx"> geopandas </em>库轻松完成。</p><p id="4550" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">创建数据框时，可使用shapefiles的纬度和经度边界裁剪数据。剪辑的概念可以用如下图所示的摄像机的概念来解释。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi ow"><img src="../Images/950850f5318d818b6a8327cfdf74f899.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PU8DSWfNvQs0qrHCvT06NQ.jpeg"/></div></div><p class="ky kz gj gh gi la lb bd b be z dk translated">世界和视口框图</p></figure><p id="7ac9" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">在我们的例子中，世界是经度从-180到+180，纬度从-90到+90的实际数据。视区的坐标由shapefile的边界决定。</p><pre class="kn ko kp kq gt ok ol om on aw oo bi"><span id="774a" class="op le iq ol b gy oq or l os ot">def createGeoData(lt,ln,mean_No,shape):<br/>    lat = []<br/>    lon = []<br/>    data = []<br/>    for i in range(len(lt)):<br/>        for j in range(len(ln)):<br/>            lat.append(lt[i])<br/>            lon.append(ln[j])<br/>            data.append(mean_No[i][j])<br/>            <br/>    Geo_Dataset = pd.DataFrame({'latitude':lat, 'longitude': lon, 'NO2':data})<br/>    #clip data with shape file boundaries<br/>    x1, y1 = getBoundary(shape,0.25)<br/>    temp = Geo_Dataset[Geo_Dataset['latitude']&gt;int(min(x1))]<br/>    temp = temp[temp['latitude']&lt;int(max(x1))]<br/>    temp = temp[temp['longitude']&gt;int(min(y1))]<br/>    temp = temp[temp['longitude']&lt;int(max(y1))]<br/>    crc = {'init':'epsg:4326'}<br/>    geometry = [Point(xy) for xy in zip(temp['longitude'], temp['latitude'])]<br/>    geo_df = gpd.GeoDataFrame(temp,crs=crc,geometry=geometry)<br/>    geo_df.reset_index(drop=True, inplace=True)<br/>    return geo_df</span></pre><h1 id="cd51" class="ld le iq bd lf lg lh li lj lk ll lm ln jw lo jx lp jz lq ka lr kc ls kd lt lu bi translated">屏蔽数据</h1><p id="d1bf" class="pw-post-body-paragraph lv lw iq lx b ly lz jr ma mb mc ju md me mf mg mh mi mj mk ml mm mn mo mp mq ij bi translated">由于数据被转换为由几何(点)组成的地理数据框，因此这些点可直接用于检查数据是否包含在shapefile的任何面中。这里使用了检查多边形内部点的概念。这是通过使用shapely库中的点和面包来执行的。shapefile的任何一个多边形内的点保持不变，其余的点被赋予一个NaN值。</p><pre class="kn ko kp kq gt ok ol om on aw oo bi"><span id="05c9" class="op le iq ol b gy oq or l os ot">def mask(map1, geo_df):<br/>    pol = map1.geometry<br/>    pts = geo_df.geometry<br/>    test = geo_df<br/>    l,t,df = [],[],[]<br/>    for k in range(len(pts)):<br/>        flag = True<br/>        for i in range(len(pol)):<br/>            if(pol[i].contains(pts[k])):<br/>                l.append(geo_df.latitude[k])<br/>                t.append(geo_df.longitude[k])<br/>                df.append(geo_df.NO2[k])<br/>                flag = False<br/>                break<br/>            #end if<br/>        #end for<br/>        if(flag):<br/>            l.append(np.nan)<br/>            t.append(np.nan)<br/>            df.append(np.nan)<br/>        #end if<br/>    #end for<br/>    newdf = pd.DataFrame({'latitude':l, 'longitude': t, 'NO2':df})<br/>    return newdf</span></pre><h1 id="13a8" class="ld le iq bd lf lg lh li lj lk ll lm ln jw lo jx lp jz lq ka lr kc ls kd lt lu bi translated">重新划分数据</h1><p id="e677" class="pw-post-body-paragraph lv lw iq lx b ly lz jr ma mb mc ju md me mf mg mh mi mj mk ml mm mn mo mp mq ij bi translated">将数据转换为地理数据框时，数据被展平以便于裁剪。因此，在屏蔽数据之后，数据需要重新网格化以便可视化。</p><p id="21c3" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">由于数据已经被裁剪，数据的形状应该等于边界纬度数组的长度乘以从shapefile获得的边界经度数组的长度。</p><p id="f5f0" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated"># <em class="mx">注意:如果数据的形状与给定的条件不匹配，检查边界是否被正确检索，剪裁是否正确完成。</em></p><p id="a414" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">可以通过以下方式创建网格并用数据填充</p><pre class="kn ko kp kq gt ok ol om on aw oo bi"><span id="735c" class="op le iq ol b gy oq or l os ot">def createGrid(my_lats, my_lons,mask):<br/>    grd = np.zeros((len(my_lats),len(my_lons)))<br/>    print(grd.shape, mask.NO2.shape)<br/>    k = 0<br/>    for i in range(len(my_lats)):<br/>        for j in range(len(my_lons)):<br/>            grd[i][j] = mask.NO2[k]<br/>            k = k+1<br/>        #end for<br/>    #end for<br/>    return grd</span></pre><h1 id="e285" class="ld le iq bd lf lg lh li lj lk ll lm ln jw lo jx lp jz lq ka lr kc ls kd lt lu bi translated"><strong class="ak">可视化</strong></h1><p id="29e0" class="pw-post-body-paragraph lv lw iq lx b ly lz jr ma mb mc ju md me mf mg mh mi mj mk ml mm mn mo mp mq ij bi translated">为了可视化数据，使用了<em class="mx"> Matplotlib </em>。关于可视化没有太多要解释的😆。只需根据您的需要修改颜色栏参数。</p><pre class="kn ko kp kq gt ok ol om on aw oo bi"><span id="7033" class="op le iq ol b gy oq or l os ot">def plot(grd, map1, x1,y1):<br/>    plt.rcParams["font.weight"] = "bold"<br/>    fig,ax = plt.subplots(figsize=(15,15))<br/>    map1.plot(ax=ax, alpha=0.7, color='none')<br/>    ax.set_title("No2 Distribution", fontweight='bold', size=20)<br/>    ax.set_xlabel('Longitude (E)', fontsize = 20)<br/>    ax.set_ylabel('Latitude (N)', fontsize = 20)<br/>    bounds = [int(min(x1)),int(max(x1)),int(min(y1)),int(max(y1))]<br/>    img = ax.imshow(grd,aspect='auto',interpolation='none', origin='lower', extent=bounds)<br/>    cb = fig.colorbar(img)<br/>    cb.ax.tick_params(labelsize=18)<br/>    cb.set_label('mol cm^-2', labelpad=-57, size=14)<br/>    ax.tick_params(labelsize = 20, width = 2.0)<br/>    img.set_clim(0.1*1e16, 0.5*1e16)<br/>    plt.show()</span></pre><h1 id="0eb0" class="ld le iq bd lf lg lh li lj lk ll lm ln jw lo jx lp jz lq ka lr kc ls kd lt lu bi translated">执行</h1><p id="29fe" class="pw-post-body-paragraph lv lw iq lx b ly lz jr ma mb mc ju md me mf mg mh mi mj mk ml mm mn mo mp mq ij bi translated">现在让我们看看上述这些函数是如何工作的。有一个调用上述函数的序列。它在这里</p><pre class="kn ko kp kq gt ok ol om on aw oo bi"><span id="e55a" class="op le iq ol b gy oq or l os ot">filenames = []<br/>for path, subdirs, files in os.walk(r'path to your own data'):<br/>    for filename in files:<br/>        f = path +'/'+filename<br/>        filenames.append(str(f))</span><span id="e3f0" class="op le iq ol b gy ov or l os ot">mean_data = extractData(filenames)<br/>latitude = np.arange(-90,90,0.25)<br/>longitude = np.arange(-180,180,0.25)<br/>m = readSHape(shpFile)<br/>geo_df = createGeoData(latitude,longitude,mean_data,m)<br/>msk = mask(m, geo_df)<br/>my_lat,my_lon = getBoundary(m,0.25)<br/>data = createGrid(my_lat,my_lon,msk)<br/>plot(data,m, my_lon, my_lat)</span></pre><h1 id="7d9d" class="ld le iq bd lf lg lh li lj lk ll lm ln jw lo jx lp jz lq ka lr kc ls kd lt lu bi translated">结果</h1><p id="41ef" class="pw-post-body-paragraph lv lw iq lx b ly lz jr ma mb mc ju md me mf mg mh mi mj mk ml mm mn mo mp mq ij bi translated">让我们来看看所有编码的输出😃</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi ox"><img src="../Images/1c257f0f2b401af259afed24910bf942.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NaUDtkeVtMZQ0LzIOyb3xg.png"/></div></div></figure><h1 id="57f4" class="ld le iq bd lf lg lh li lj lk ll lm ln jw lo jx lp jz lq ka lr kc ls kd lt lu bi translated">结论</h1><p id="1975" class="pw-post-body-paragraph lv lw iq lx b ly lz jr ma mb mc ju md me mf mg mh mi mj mk ml mm mn mo mp mq ij bi translated">如您所见，全局数据被隐藏在shapefile中。这些方法适用于所有地理区域或边界shapefile。这是一个非常方便的地理空间分析工具。</p></div></div>    
</body>
</html>