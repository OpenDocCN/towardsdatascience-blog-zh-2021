<html>
<head>
<title>Performing Deduplication with Record Linkage and Supervised Learning</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过记录链接和监督学习执行重复数据删除</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/performing-deduplication-with-record-linkage-and-supervised-learning-b01a66cc6882?source=collection_archive---------0-----------------------#2021-10-01">https://towardsdatascience.com/performing-deduplication-with-record-linkage-and-supervised-learning-b01a66cc6882?source=collection_archive---------0-----------------------#2021-10-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="d323" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/hands-on-tutorials" rel="noopener" target="_blank">实践教程</a></h2><div class=""/><div class=""><h2 id="96a9" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">用机器学习方法识别重复记录</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/ca7c3a17e6232d07ace07890c58af49e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*EST6TEC2cm2aLnwE"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">由<a class="ae lh" href="https://unsplash.com/@iampatrickpilz?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Valentino Funghi </a>在<a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h2 id="8c3c" class="li lj it bd lk ll lm dn ln lo lp dp lq lr ls lt lu lv lw lx ly lz ma mb mc iz bi translated">介绍</h2><p id="02f1" class="pw-post-body-paragraph md me it mf b mg mh kd mi mj mk kg ml lr mm mn mo lv mp mq mr lz ms mt mu mv im bi translated">大多数数据都是由人工记录的，而且通常没有经过审核，没有同步，仅仅是因为出现了诸如打字错误之类的错误。请想一想，您是否曾经填写过两次相同的表格，但地址略有不同？例如，您提交了如下图所示的表单:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi mw"><img src="../Images/2fdf7c3ed5f1694531141926de78831e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NWj3HQ9wcsjr93IME-Tz4g.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">填写样本名称和地址详细信息(图片由作者提供)</p></figure><p id="8d37" class="pw-post-body-paragraph md me it mf b mg mx kd mi mj my kg ml lr mz mn mo lv na mq mr lz nb mt mu mv im bi translated">请注意，这些细节实际上是指具有相同“地址”的同一个人“简”。许多组织都在处理这样的数据，它们清楚地显示是重复的，并且表示相同的实体，但是单词并不完全相等。因此，python函数“drop_duplicates”将无法将这些记录识别为重复记录，因为单词并不完全匹配。所以解决这些乱七八糟的数据的办法就是执行<strong class="mf jd">带记录链接的重复数据删除。</strong>记录链接通过比较不同来源的记录来确定记录是否匹配并代表同一个实体<em class="nc">(个人/公司/企业)</em>。</p><p id="c75e" class="pw-post-body-paragraph md me it mf b mg mx kd mi mj my kg ml lr mz mn mo lv na mq mr lz nb mt mu mv im bi translated">在本文中，我们将探索使用记录链接和结合监督学习来分类重复和非重复记录。以下是我们将在本文中涉及的主题:</p><pre class="ks kt ku kv gt nd ne nf ng aw nh bi"><span id="894b" class="li lj it ne b gy ni nj l nk nl"><a class="ae lh" href="http://xx" rel="noopener ugc nofollow" target="_blank"><strong class="ne jd">Table of Contents: </strong></a><strong class="ne jd"><br/>- What is Record Linkage? <br/>- Understand our Data Set<br/>- Applying Record Linkage Process<br/>(a) Preprocessing<br/>(b) Indexing<br/>(c) Comparison &amp; Similarity<br/>(d) Supervised Learning (Classification) <br/>- Conclusion</strong></span></pre><h2 id="6b9f" class="li lj it bd lk ll lm dn ln lo lp dp lq lr ls lt lu lv lw lx ly lz ma mb mc iz bi translated">什么是记录联动？</h2><p id="4728" class="pw-post-body-paragraph md me it mf b mg mh kd mi mj mk kg ml lr mm mn mo lv mp mq mr lz ms mt mu mv im bi translated">记录链接是指识别和链接与同一实体(人员、业务、产品等)相关的记录的方法。)在一个或多个数据源中。它搜索可能的重复记录并将它们链接在一起作为单个记录处理，这也使得避免数据冗余成为可能。</p><p id="4f86" class="pw-post-body-paragraph md me it mf b mg mx kd mi mj my kg ml lr mz mn mo lv na mq mr lz nb mt mu mv im bi translated">当唯一标识符变量存在于数据集中时，例如(标识号、散列码等)，链接相同实体的过程将是简单的。但是，在有些情况下，数据集中不存在唯一的标识符，因此我们需要识别出被复制的变量的良好候选对象，并将它们配对(例如:州、姓氏、出生日期、电话号码)——在执行步骤:索引时，我们会对此有更多的了解。</p><p id="f8dd" class="pw-post-body-paragraph md me it mf b mg mx kd mi mj my kg ml lr mz mn mo lv na mq mr lz nb mt mu mv im bi translated">我们将使用<a class="ae lh" href="https://recordlinkage.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank"> Python记录链接工具包</a>库，它提供了执行记录链接和重复数据删除所需的工具和函数。记录链接工具包的安装和导入如下:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nm nn l"/></div></figure><h2 id="d549" class="li lj it bd lk ll lm dn ln lo lp dp lq lr ls lt lu lv lw lx ly lz ma mb mc iz bi translated">了解我们的数据集</h2><p id="2a1c" class="pw-post-body-paragraph md me it mf b mg mh kd mi mj mk kg ml lr mm mn mo lv mp mq mr lz ms mt mu mv im bi translated">对于本教程，我们将使用由Febrl项目(来源:<a class="ae lh" href="https://recordlinkage.readthedocs.io/en/latest/ref-datasets.html" rel="noopener ugc nofollow" target="_blank">可自由扩展的生物医学记录链接</a>)生成的Python记录链接工具包下可用的<a class="ae lh" href="https://recordlinkage.readthedocs.io/en/latest/ref-datasets.html" rel="noopener ugc nofollow" target="_blank">公共数据集。有四组数据可用，但我们将使用第二组数据——feb rl 2。让我们从子模块<em class="nc"> recordlinkage.datasets. </em>导入数据集</a></p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nm nn l"/></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi no"><img src="../Images/c74ac3905c68e64c1624d781dfd94a7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-VHg7QVW7oNfPOdNKgR4EA.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">加载数据集— FEBRL 2(图片由作者提供)</p></figure><p id="1bfd" class="pw-post-body-paragraph md me it mf b mg mx kd mi mj my kg ml lr mz mn mo lv na mq mr lz nb mt mu mv im bi translated">数据集以“数据帧”的格式返回，我们可以看到这个数据集总共有5000条记录。根据Febrl的数据集来源，该表中有4000条原始记录和1000条重复记录。</p><p id="1bd9" class="pw-post-body-paragraph md me it mf b mg mx kd mi mj my kg ml lr mz mn mo lv na mq mr lz nb mt mu mv im bi translated">让我们使用以下内容来更好地理解表中的数据类型:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi np"><img src="../Images/e8e5c1e7980ef0cb5698f92451be1274.png" data-original-src="https://miro.medium.com/v2/resize:fit:888/format:webp/1*vC_HEnoSRy9ARdeu0VgXWA.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">数据类型信息(作者图片)</p></figure><p id="0d1a" class="pw-post-body-paragraph md me it mf b mg mx kd mi mj my kg ml lr mz mn mo lv na mq mr lz nb mt mu mv im bi translated">根据上面的结果，我们的数据集中的列值具有相同的数据类型——“object”(也称为“String”)，并且都具有非空条件。</p><p id="ea05" class="pw-post-body-paragraph md me it mf b mg mx kd mi mj my kg ml lr mz mn mo lv na mq mr lz nb mt mu mv im bi translated">接下来，我们还应该使用以下函数对数据集的统计汇总进行基本检查:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nq"><img src="../Images/18615dd09f39361363c1d2202adcdc4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P511IDwEEVR1K8l2mcJSbQ.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">统计摘要(图片由作者提供)</p></figure><p id="47f9" class="pw-post-body-paragraph md me it mf b mg mx kd mi mj my kg ml lr mz mn mo lv na mq mr lz nb mt mu mv im bi translated">从统计汇总结果中，我们可以很快看到姓氏given_name的唯一计数不是5000，这表明同一个人在数据集中可能有多个记录，这些记录具有不同的地址/街道号/州等。</p><p id="d6e6" class="pw-post-body-paragraph md me it mf b mg mx kd mi mj my kg ml lr mz mn mo lv na mq mr lz nb mt mu mv im bi translated">我们数据集中的重复记录示例如下所示:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nr"><img src="../Images/15c98b79d2ccd5c01e29aed681541a1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CuxTNBpNff1NuKdgWvZzdA.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">数据集的样本重复记录(作者图片)</p></figure><p id="5e17" class="pw-post-body-paragraph md me it mf b mg mx kd mi mj my kg ml lr mz mn mo lv na mq mr lz nb mt mu mv im bi translated">请注意，从这一对被称为重复记录的样本记录来看，差异在于“姓氏”、“地址_2”和“郊区”，只有几个字符的差异。我们的目标是识别并突出显示像这个样本这样的重复记录。</p><p id="78b6" class="pw-post-body-paragraph md me it mf b mg mx kd mi mj my kg ml lr mz mn mo lv na mq mr lz nb mt mu mv im bi translated">现在，我们已经对数据集有了基本的了解，让我们了解并应用记录链接过程来对数据集进行重复数据删除并正确分类。</p><h2 id="cb07" class="li lj it bd lk ll lm dn ln lo lp dp lq lr ls lt lu lv lw lx ly lz ma mb mc iz bi translated">应用记录链接流程</h2><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ns"><img src="../Images/39c29f55e8985536c7b4ce4d222956b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fKgZTitH_hXdRTSvx9roVA.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">记录链接过程(图片由作者提供)</p></figure><h2 id="9380" class="li lj it bd lk ll lm dn ln lo lp dp lq lr ls lt lu lv lw lx ly lz ma mb mc iz bi translated"><strong class="ak"> (a)预处理</strong></h2><p id="746b" class="pw-post-body-paragraph md me it mf b mg mh kd mi mj mk kg ml lr mm mn mo lv mp mq mr lz ms mt mu mv im bi translated">这一步很重要，因为将数据标准化为相同的格式将增加识别重复项的机会。根据数据中的值，预处理步骤可能包括:</p><ul class=""><li id="cdb1" class="nt nu it mf b mg mx mj my lr nv lv nw lz nx mv ny nz oa ob bi translated">小写/大写</li></ul><p id="17ff" class="pw-post-body-paragraph md me it mf b mg mx kd mi mj my kg ml lr mz mn mo lv na mq mr lz nb mt mu mv im bi translated">这是文本预处理最简单也是最重要的一步，就是将你的文本数据集标准化为全部“小写”或“大写”。在下面的例子中，我们将数据集中的文本转换为大写。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nm nn l"/></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oc"><img src="../Images/f7db23a0ee6a24e210b5562f1b5f3f02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pLkxuU6sCAmNt-YyNZcilg.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">预处理:大写(图片由作者提供)</p></figure><ul class=""><li id="2562" class="nt nu it mf b mg mx mj my lr nv lv nw lz nx mv ny nz oa ob bi translated">停用词移除</li></ul><p id="fb47" class="pw-post-body-paragraph md me it mf b mg mx kd mi mj my kg ml lr mz mn mo lv na mq mr lz nb mt mu mv im bi translated">停用词是常见的词，被删除是为了给文本中更重要的信息提供更大的重要性。例如在一个完整的句子中，停用词有<strong class="mf jd">、【the】、【a】、</strong>等。对于公司名称，停用词可以是<strong class="mf jd">、【公司】、【公司】、【有限公司】、</strong>等。对于人名，停用词可以是<strong class="mf jd">、【先生】、【夫人】、【女士】、【先生】等。对于地址，停用词可以是<strong class="mf jd">、【街】、【地点】、【路】、</strong>等。</strong></p><p id="7fc6" class="pw-post-body-paragraph md me it mf b mg mx kd mi mj my kg ml lr mz mn mo lv na mq mr lz nb mt mu mv im bi translated">对于我们的数据集，没有要从名称中删除的停用词，但是我们可以从地址字段“address_1”中删除停用词。在下面的例子中，我们删除了数据集中常见的停用词。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nm nn l"/></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi od"><img src="../Images/3aef3ecf188089f2165fcd9933b0ec54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jHkmtQGiDNRhoe8HZDFkQg.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">预处理:停用词移除(图片由作者提供)</p></figure><ul class=""><li id="2bd9" class="nt nu it mf b mg mx mj my lr nv lv nw lz nx mv ny nz oa ob bi translated">邮政编码清理</li></ul><p id="3184" class="pw-post-body-paragraph md me it mf b mg mx kd mi mj my kg ml lr mz mn mo lv na mq mr lz nb mt mu mv im bi translated">邮政编码清理是通过删除可能包含的符号来完成的，如“-”、“+”或空格。<em class="nc">(通常，这种清理是在电话号码上完成的，但由于我们的数据集中没有电话号码，我们将对邮政编码应用类似的逻辑)</em></p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/87e512aebecf1fdc5becfe952088d606.png" data-original-src="https://miro.medium.com/v2/resize:fit:916/format:webp/1*lVBx4wP7j1zyLhs3Chz9Ow.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">邮政编码清理示例(图片由作者提供)</p></figure><p id="9946" class="pw-post-body-paragraph md me it mf b mg mx kd mi mj my kg ml lr mz mn mo lv na mq mr lz nb mt mu mv im bi translated">下面的例子显示了对“邮政编码”的清理，其中只保留数字值。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nm nn l"/></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi of"><img src="../Images/46bbacd7b325d4a6a3416efc49cea3dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*87NX22lP_5pGdKt7xnCtZA.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">预处理:邮政编码清理(图片由作者提供)</p></figure><ul class=""><li id="b10c" class="nt nu it mf b mg mx mj my lr nv lv nw lz nx mv ny nz oa ob bi translated">删除无关符号</li></ul><p id="1ec9" class="pw-post-body-paragraph md me it mf b mg mx kd mi mj my kg ml lr mz mn mo lv na mq mr lz nb mt mu mv im bi translated">特殊符号无助于识别文本中的相似之处，应该清除。以下示例显示了为删除地址字段中不相关的符号而进行的清理。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nm nn l"/></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi od"><img src="../Images/036ad2129af1aa998784258acbff4857.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4x6cXKo-ncY4RMoIwUVtEg.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">预处理:去除无关符号(图片由作者提供)</p></figure><h2 id="5e00" class="li lj it bd lk ll lm dn ln lo lp dp lq lr ls lt lu lv lw lx ly lz ma mb mc iz bi translated"><strong class="ak"> (b)步进</strong></h2><p id="23f0" class="pw-post-body-paragraph md me it mf b mg mh kd mi mj mk kg ml lr mm mn mo lv mp mq mr lz ms mt mu mv im bi translated">既然我们的数据集已经过预处理并被认为是干净的数据集，我们将需要创建记录对(也称为候选链接)。创建记录对并计算相似性，以确定记录对是否被认为是匹配/重复的。<a class="ae lh" href="https://recordlinkage.readthedocs.io/en/latest/ref-index.html" rel="noopener ugc nofollow" target="_blank"> Python记录链接工具包</a>提供了索引模块来创建记录配对，从而简化了流程。</p><p id="740e" class="pw-post-body-paragraph md me it mf b mg mx kd mi mj my kg ml lr mz mn mo lv na mq mr lz nb mt mu mv im bi translated">有几种索引技术可用于记录链接，例如:</p><ul class=""><li id="3f07" class="nt nu it mf b mg mx mj my lr nv lv nw lz nx mv ny nz oa ob bi translated">完整索引</li></ul><p id="cc02" class="pw-post-body-paragraph md me it mf b mg mx kd mi mj my kg ml lr mz mn mo lv na mq mr lz nb mt mu mv im bi translated">基于数据集中记录对的所有可能组合创建完整索引。使用完全索引在数据量上有风险，因为记录的数量会以二次方的方式增加。例如，基于我们的5000条记录的数据集，使用完整索引总共创建了12497500对。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nm nn l"/></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi og"><img src="../Images/997ce4b6a741a6493526e7d335eedc93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4mc0y_ca9EjnwmPs4HQ__g.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">索引方法:完整(图片由作者提供)</p></figure><ul class=""><li id="cef8" class="nt nu it mf b mg mx mj my lr nv lv nw lz nx mv ny nz oa ob bi translated">阻塞</li></ul><p id="9fc4" class="pw-post-body-paragraph md me it mf b mg mx kd mi mj my kg ml lr mz mn mo lv na mq mr lz nb mt mu mv im bi translated">分块索引是完整索引的一个很好的替代方案，因为记录对是基于同一个块(具有公共值)生成的。通过基于特定列进行分块，可以大大减少记录对的数量。例如，通过阻塞“State”列，只有来自同一州的记录对相互链接，总共创建了2768103对记录，这也是与完整索引相比较少的记录。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nm nn l"/></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oh"><img src="../Images/49884aba7c3dcd93db5b11076a7af41f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zjz5R5tzWxQ904X8mmvaCA.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">索引方法:块(图片由作者提供)</p></figure><p id="8fdb" class="pw-post-body-paragraph md me it mf b mg mx kd mi mj my kg ml lr mz mn mo lv na mq mr lz nb mt mu mv im bi translated">但是，请注意，拥有较少的记录对并不总是最好的方法，因为如果存在重复的记录，但“State”的值存在拼写错误，则可能会错过实际的匹配。</p><ul class=""><li id="68d1" class="nt nu it mf b mg mx mj my lr nv lv nw lz nx mv ny nz oa ob bi translated">排序邻域</li></ul><p id="5314" class="pw-post-body-paragraph md me it mf b mg mx kd mi mj my kg ml lr mz mn mo lv na mq mr lz nb mt mu mv im bi translated">按排序邻域的索引是另一种产生具有邻近值的对的替代方法，例如，以下记录被配对在一起，因为在“姓氏”列中有相似性— <em class="nc"> Laundon和Lanyon </em>。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oi"><img src="../Images/cab4f302c0f95ef6d373c9fad9b4e2e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:898/format:webp/1*7g9jNP305oSyYBulK6qRRg.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">索引方法:排序邻域样本对(图片由作者提供)</p></figure><p id="104f" class="pw-post-body-paragraph md me it mf b mg mx kd mi mj my kg ml lr mz mn mo lv na mq mr lz nb mt mu mv im bi translated">使用排序邻域索引总共创建了75034对，与完整索引和块索引相比，这也是较少的记录。<em class="nc">(这也取决于所选列的值内容)</em></p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nm nn l"/></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oj"><img src="../Images/e1f0de9110a2abffb22528b6f861e833.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SwS_Rp1Xa38b-Zumy_2stQ.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">索引方法:排序邻域(图片由作者提供)</p></figure><p id="e25e" class="pw-post-body-paragraph md me it mf b mg mx kd mi mj my kg ml lr mz mn mo lv na mq mr lz nb mt mu mv im bi translated">在本教程中，我们将结合两种方法对数据集进行索引，即“分块”索引和“排序邻域”索引。</p><p id="b583" class="pw-post-body-paragraph md me it mf b mg mx kd mi mj my kg ml lr mz mn mo lv na mq mr lz nb mt mu mv im bi translated"><strong class="mf jd">为什么我选择使用多种指数方法？</strong></p><ul class=""><li id="3cc2" class="nt nu it mf b mg mx mj my lr nv lv nw lz nx mv ny nz oa ob bi translated">使用“全索引”将为我们提供所有可能匹配的记录对，但将导致记录总数的巨大增长。</li><li id="ebf6" class="nt nu it mf b mg ok mj ol lr om lv on lz oo mv ny nz oa ob bi translated">因此，通过“分块”或“排序邻域”使用索引能够解决记录总数大幅增长的问题。</li><li id="3ae9" class="nt nu it mf b mg ok mj ol lr om lv on lz oo mv ny nz oa ob bi translated">然而，仅仅通过使用“分块”或“排序邻域”方法的索引，就有可能错过实际的匹配。那么，为什么不通过结合这两种方法来减少遗漏实际匹配记录的可能性，并且仍然拥有比全索引更少的记录呢！</li></ul><p id="7c4e" class="pw-post-body-paragraph md me it mf b mg mx kd mi mj my kg ml lr mz mn mo lv na mq mr lz nb mt mu mv im bi translated">下面的命令是追加由“分块”和“排序邻域”创建的记录对。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nm nn l"/></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi op"><img src="../Images/cb6d5c9addb296b8d5350c7d7a121d36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y_3vacJu4d_2cqY2VTQOXA.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">附加两种索引方法(图片由作者提供)</p></figure><h2 id="9404" class="li lj it bd lk ll lm dn ln lo lp dp lq lr ls lt lu lv lw lx ly lz ma mb mc iz bi translated">比较和相似性</h2><p id="d71c" class="pw-post-body-paragraph md me it mf b mg mh kd mi mj mk kg ml lr mm mn mo lv mp mq mr lz ms mt mu mv im bi translated">现在，我们已经生成了记录对，我们希望对记录对执行比较，以创建一个比较向量来计算两个记录对之间的相似性得分。下图显示了根据“给定姓名”列上的索引对计算和比较的相似性得分。例如，“rec-712-dup-0”和“rec-2778-org”的记录对在给定名称上具有0.46667的低相似性得分。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/ede86fc49f5d974ee8c24125ce7d9931.png" data-original-src="https://miro.medium.com/v2/resize:fit:1268/format:webp/1*x3MnkNPn1BN2RamZyBNs8w.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">样本比较向量(图片由作者提供)</p></figure><p id="d8a4" class="pw-post-body-paragraph md me it mf b mg mx kd mi mj my kg ml lr mz mn mo lv na mq mr lz nb mt mu mv im bi translated">可以用许多不同的方法进行比较，以计算字符串、数值或日期中的相似性值。在我们计算字符串值的相似性得分的场景中，我们可以使用以下算法:</p><ul class=""><li id="e6ea" class="nt nu it mf b mg mx mj my lr nv lv nw lz nx mv ny nz oa ob bi translated">贾罗温克勒</li><li id="7440" class="nt nu it mf b mg ok mj ol lr om lv on lz oo mv ny nz oa ob bi translated">莱文斯坦</li><li id="94a4" class="nt nu it mf b mg ok mj ol lr om lv on lz oo mv ny nz oa ob bi translated">最长公共子串(LCS)</li><li id="be7e" class="nt nu it mf b mg ok mj ol lr om lv on lz oo mv ny nz oa ob bi translated">雅克卡德</li></ul><p id="032f" class="pw-post-body-paragraph md me it mf b mg mx kd mi mj my kg ml lr mz mn mo lv na mq mr lz nb mt mu mv im bi translated">让我们继续计算数据集中不同列的相似性得分。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nm nn l"/></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi or"><img src="../Images/4b3c1848e70764524b385405faf141d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R5M4Qjc-Wwq1Y8YM9b-OGg.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">比较矢量输出(图片由作者提供)</p></figure><p id="5c3e" class="pw-post-body-paragraph md me it mf b mg mx kd mi mj my kg ml lr mz mn mo lv na mq mr lz nb mt mu mv im bi translated">请注意，本例中使用的相似性函数是“Jarowinkler”或“Levenshtein”。Jarowinler相似性得分是通过给予字符串的开头更多的重要性来计算的，因此该算法用于计算诸如姓名、地址、州等特征的相似性得分。Levenshtein相似性得分是根据字符的顺序计算的，并提供更高的重要性，因此该算法用于计算街道号、邮政编码等特征的相似性得分。<em class="nc">(还有很多其他不同的相似度函数也可以探索，比如“余弦”、“dameray_levenshtein”等)。</em>现在我们已经创建了相似性特征，我们可以进入下一步，即构建监督学习模型。</p><h2 id="b7a4" class="li lj it bd lk ll lm dn ln lo lp dp lq lr ls lt lu lv lw lx ly lz ma mb mc iz bi translated">监督学习(分类)</h2><p id="27a0" class="pw-post-body-paragraph md me it mf b mg mh kd mi mj mk kg ml lr mm mn mo lv mp mq mr lz ms mt mu mv im bi translated">在本节中，我们将训练一个模型，根据提供的数据集对重复项和非重复项进行分类。但是在我们可以训练模型之前，我们需要在我们的数据集中有一个“标签”列(<em class="nc">目标变量</em>)，以便模型知道哪些是重复的，哪些不是。</p><p id="d41b" class="pw-post-body-paragraph md me it mf b mg mx kd mi mj my kg ml lr mz mn mo lv na mq mr lz nb mt mu mv im bi translated">加载数据时，指定“return_links = True”将返回已知的重复记录对。</p><pre class="ks kt ku kv gt nd ne nf ng aw nh bi"><span id="2b59" class="li lj it ne b gy ni nj l nk nl">df, links = load_febrl2(return_links=True)</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi os"><img src="../Images/5837a0b80734895ac3f445d4d22696d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1102/format:webp/1*4hvIGg8QsCtt-Oj9lU99jg.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">返回“真实重复”记录对(按作者排序的图像)</p></figure><p id="4176" class="pw-post-body-paragraph md me it mf b mg mx kd mi mj my kg ml lr mz mn mo lv na mq mr lz nb mt mu mv im bi translated">我们还可以为真正的重复对计算和创建比较向量，以全面了解它们的相似性得分有多高，并将这组配对转换为下一步的数据帧格式。</p><pre class="ks kt ku kv gt nd ne nf ng aw nh bi"><span id="59fe" class="li lj it ne b gy ni nj l nk nl">duplicate_pairs_vectors = compare.compute(links,df)</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ot"><img src="../Images/acd14e240098ac8709d400a61b236fd3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*So_Ei0Kr0US52aPYD6EyCw.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">“真实重复”记录对的比较矢量输出(图片由作者提供)</p></figure><p id="3619" class="pw-post-body-paragraph md me it mf b mg mx kd mi mj my kg ml lr mz mn mo lv na mq mr lz nb mt mu mv im bi translated">从矢量输出中，我们可以通过观察和注意到，对于大多数特征来说，重复对往往具有高相似性得分，从而给出粗略的估计。</p><p id="b80e" class="pw-post-body-paragraph md me it mf b mg mx kd mi mj my kg ml lr mz mn mo lv na mq mr lz nb mt mu mv im bi translated">下面的步骤是在我们的数据集上创建列“Label”的一些ETL过程，由此如果在数据集“duplicate_pairs”中找到配对，则标签为“1”否则为“0”(Duplicate = 1，Not Duplicate = 0)</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nm nn l"/></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/bb3d4f482487b3d8d5173fba24200255.png" data-original-src="https://miro.medium.com/v2/resize:fit:1116/format:webp/1*D5TKQksT5CXxukg7-yU3Lw.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">添加了“标签”列的数据集</p></figure><p id="a64c" class="pw-post-body-paragraph md me it mf b mg mx kd mi mj my kg ml lr mz mn mo lv na mq mr lz nb mt mu mv im bi translated">在标记数据集之后，注意有1901对重复项和2824073对重复项，这也表明许多配对被索引但却是唯一的。</p><p id="3f73" class="pw-post-body-paragraph md me it mf b mg mx kd mi mj my kg ml lr mz mn mo lv na mq mr lz nb mt mu mv im bi translated">有了一组标记的数据，我们可以开始训练一个监督学习模型，将记录分类为“重复”或“不重复”。在这个例子中，我将训练一个XGBoost模型来执行分类。下面是用于导入模型库和将数据集拆分为训练集和测试集的命令。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nm nn l"/></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ov"><img src="../Images/46149829812bf1a68d0f2209c1c1cc87.png" data-original-src="https://miro.medium.com/v2/resize:fit:870/format:webp/1*eylY_Y7QcCXnpLTSb-vcsw.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">测试集分组(图片由作者提供)</p></figure><p id="e1d1" class="pw-post-body-paragraph md me it mf b mg mx kd mi mj my kg ml lr mz mn mo lv na mq mr lz nb mt mu mv im bi translated">通过查看测试集分布，我们有760对模型副本来测试和预测。接下来，我们可以训练XGBoost模型，并将训练好的模型应用于测试集，以将记录分类为“重复”或“不重复”</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="67cb" class="pw-post-body-paragraph md me it mf b mg mx kd mi mj my kg ml lr mz mn mo lv na mq mr lz nb mt mu mv im bi translated">让我们来查看模型归类为“重复项”(predict = 1)的配对记录的输出</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ow"><img src="../Images/28916e5ca737ca6c0b29237ed3a9711e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uOevQ0BIynjam6T6E4VySg.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">模型将记录分类为“重复”(按作者分类)</p></figure><p id="bcdd" class="pw-post-body-paragraph md me it mf b mg mx kd mi mj my kg ml lr mz mn mo lv na mq mr lz nb mt mu mv im bi translated">接下来，我们将仔细挑选前两对，并查看实际记录，以确定有什么不同。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ox"><img src="../Images/f08a171f056a62154b51979b9acd855a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vi5rbZPCCxQli6T6uqpv5w.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">样本记录—归类为“重复”(按作者分类的图像)</p></figure><p id="5d8c" class="pw-post-body-paragraph md me it mf b mg mx kd mi mj my kg ml lr mz mn mo lv na mq mr lz nb mt mu mv im bi translated">从示例记录中，请注意，对于第一次配对，可以在两个地址字段上看到差异。第二次配对的其他地方—可以在街道号码和地址字段中看到差异。看起来模型能够对数据集中不同值的记录进行分类。</p><p id="ea96" class="pw-post-body-paragraph md me it mf b mg mx kd mi mj my kg ml lr mz mn mo lv na mq mr lz nb mt mu mv im bi translated">恭喜你。我们已经建立了一个模型来识别数据集中的重复项。</p><h2 id="28f4" class="li lj it bd lk ll lm dn ln lo lp dp lq lr ls lt lu lv lw lx ly lz ma mb mc iz bi translated">结论</h2><p id="758f" class="pw-post-body-paragraph md me it mf b mg mh kd mi mj mk kg ml lr mm mn mo lv mp mq mr lz ms mt mu mv im bi translated">在本文中，我们学习了如何结合使用记录链接和监督学习来执行重复数据删除。由此，在能够执行比较以计算相似性得分和用于模型训练之前，记录需要被索引成对。但是，请注意，这是为了理解执行重复数据消除的过程而进行的练习，数据集值很简单。真实世界的数据通常比我们的例子更加混乱和复杂。</p></div><div class="ab cl oy oz hx pa" role="separator"><span class="pb bw bk pc pd pe"/><span class="pb bw bk pc pd pe"/><span class="pb bw bk pc pd"/></div><div class="im in io ip iq"><p id="80f3" class="pw-post-body-paragraph md me it mf b mg mx kd mi mj my kg ml lr mz mn mo lv na mq mr lz nb mt mu mv im bi translated"><em class="nc">感谢您阅读我的文章，如果您喜欢并愿意支持我:</em></p><ul class=""><li id="38b7" class="nt nu it mf b mg mx mj my lr nv lv nw lz nx mv ny nz oa ob bi translated"><em class="nc">跟我上</em> <a class="ae lh" href="https://iam-suelynn.medium.com/" rel="noopener"> <em class="nc">中</em> </a> <em class="nc"> </em>🙆🏻</li><li id="4339" class="nt nu it mf b mg ok mj ol lr om lv on lz oo mv ny nz oa ob bi translated">通过我的<a class="ae lh" href="https://iam-suelynn.medium.com/membership" rel="noopener">推荐链接</a>成为Medium会员🙋</li></ul><h2 id="f900" class="li lj it bd lk ll lm dn ln lo lp dp lq lr ls lt lu lv lw lx ly lz ma mb mc iz bi translated">参考和链接:</h2><p id="39a2" class="pw-post-body-paragraph md me it mf b mg mh kd mi mj mk kg ml lr mm mn mo lv mp mq mr lz ms mt mu mv im bi translated">[1]<a class="ae lh" href="https://github.com/dedupeio/dedupe-examples.git" rel="noopener ugc nofollow" target="_blank">https://github.com/dedupeio/dedupe-examples.git</a></p><p id="ef3f" class="pw-post-body-paragraph md me it mf b mg mx kd mi mj my kg ml lr mz mn mo lv na mq mr lz nb mt mu mv im bi translated">[2]<a class="ae lh" href="https://github.com/vintasoftware/deduplication-slides/blob/master/slides.ipynb" rel="noopener ugc nofollow" target="_blank">https://github . com/vinta software/de duplication-slides/blob/master/slides . ipynb</a></p><p id="6fd9" class="pw-post-body-paragraph md me it mf b mg mx kd mi mj my kg ml lr mz mn mo lv na mq mr lz nb mt mu mv im bi translated">[3]<a class="ae lh" href="https://recordlinkage.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank">https://recordlinkage.readthedocs.io/en/latest/</a></p></div></div>    
</body>
</html>