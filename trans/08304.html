<html>
<head>
<title>10 Best Practices to Write Readable and Maintainable SQL Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">编写可读和可维护的SQL代码的10个最佳实践</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/10-best-practices-to-write-readable-and-maintainable-sql-code-427f6bb98208?source=collection_archive---------0-----------------------#2021-07-31">https://towardsdatascience.com/10-best-practices-to-write-readable-and-maintainable-sql-code-427f6bb98208?source=collection_archive---------0-----------------------#2021-07-31</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7a69" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何编写你的团队可以轻松阅读和维护的SQL查询？</h2></div><p id="d100" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">没有适当的指导方针，很容易弄乱SQL。由于团队中的每个人可能都有自己编写SQL的习惯，您很快就会得到一个没有人理解的令人困惑的代码。</p><p id="b1a3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可能已经意识到遵循一系列良好实践的重要性。<br/>愿这篇文章能给你带来你正在寻找的指导！</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi le"><img src="../Images/aca34ac61f204596d8551abf92697d10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NGniUKoit2YaJY08brT01g.png"/></div></div><p class="lq lr gj gh gi ls lt bd b be z dk translated"><a class="ae lu" href="https://unsplash.com/@liane" rel="noopener ugc nofollow" target="_blank"> @liane </a>在<a class="ae lu" href="https://unsplash.com/" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><h2 id="b1e6" class="lv lw it bd lx ly lz dn ma mb mc dp md kr me mf mg kv mh mi mj kz mk ml mm mn bi translated">1.使用大写字母作为关键字</h2><p id="cd2e" class="pw-post-body-paragraph ki kj it kk b kl mo ju kn ko mp jx kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">让我们从一个基本的开始:对SQL关键字<a class="ae lu" href="https://www.w3schools.com/sql/sql_ref_keywords.asp" rel="noopener ugc nofollow" target="_blank">使用大写字母</a>，对表和列使用小写字母。在SQL函数(FIRST_VALUE()、DATE_TRUNC()等)中使用大写字母也是一个很好的实践，尽管这更有争议。</p><blockquote class="mt mu mv"><p id="b6d7" class="ki kj mw kk b kl km ju kn ko kp jx kq mx ks kt ku my kw kx ky mz la lb lc ld im bi translated"><strong class="kk iu">避免</strong></p></blockquote><pre class="lf lg lh li gt na nb nc nd aw ne bi"><span id="1a06" class="lv lw it nb b gy nf ng l nh ni">select id, name from company.customers</span></pre><blockquote class="mt mu mv"><p id="9dbb" class="ki kj mw kk b kl km ju kn ko kp jx kq mx ks kt ku my kw kx ky mz la lb lc ld im bi translated"><strong class="kk iu">偏好</strong></p></blockquote><pre class="lf lg lh li gt na nb nc nd aw ne bi"><span id="3b66" class="lv lw it nb b gy nf ng l nh ni"><strong class="nb iu">SELECT</strong> id, name <strong class="nb iu">FROM</strong> company.customers</span></pre><h2 id="819a" class="lv lw it bd lx ly lz dn ma mb mc dp md kr me mf mg kv mh mi mj kz mk ml mm mn bi translated">2.对模式、表、列使用Snake Case</h2><p id="ffdb" class="pw-post-body-paragraph ki kj it kk b kl mo ju kn ko mp jx kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">编程语言在案例类型方面有自己的最佳实践:camelCase、PascalCase、kebab-case和snake_case是最常见的。</p><p id="a369" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">谈到SQL，Snake Case(有时也称为下划线Case)是使用最广泛的约定。</p><blockquote class="mt mu mv"><p id="e187" class="ki kj mw kk b kl km ju kn ko kp jx kq mx ks kt ku my kw kx ky mz la lb lc ld im bi translated"><strong class="kk iu">避免</strong></p></blockquote><pre class="lf lg lh li gt na nb nc nd aw ne bi"><span id="a626" class="lv lw it nb b gy nf ng l nh ni"><strong class="nb iu">SELECT</strong> Customers.id, <br/>       Customers.name, <br/>       COUNT(WebVisit.id) as nbVisit<br/><strong class="nb iu">FROM</strong> COMPANY.Customers<br/><strong class="nb iu">JOIN</strong> COMPANY.WebVisit <strong class="nb iu">ON</strong> Customers.id = WebVisit.customerId</span><span id="fcbf" class="lv lw it nb b gy nj ng l nh ni"><strong class="nb iu">WHERE</strong> Customers.age &lt;= 30<br/><strong class="nb iu">GROUP BY</strong> Customers.id, Customers.name</span></pre><blockquote class="mt mu mv"><p id="2aef" class="ki kj mw kk b kl km ju kn ko kp jx kq mx ks kt ku my kw kx ky mz la lb lc ld im bi translated"><strong class="kk iu">更喜欢</strong></p></blockquote><pre class="lf lg lh li gt na nb nc nd aw ne bi"><span id="8dff" class="lv lw it nb b gy nf ng l nh ni"><strong class="nb iu">SELECT</strong> customers.id, <br/>       customers.name, <br/>       COUNT(web_visit.id) as nb_visit<br/><strong class="nb iu">FROM</strong> company.customers<br/><strong class="nb iu">JOIN</strong> company.web_visit <strong class="nb iu">ON</strong> customers.id = web_visit.customer_id</span><span id="63c0" class="lv lw it nb b gy nj ng l nh ni"><strong class="nb iu">WHERE</strong> customers.age &lt;= 30<br/><strong class="nb iu">GROUP BY</strong> customers.id, customers.name</span></pre><p id="e5d2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">尽管有些人喜欢使用变体来区分模式、表和列，但我建议坚持使用snake case。</p><h2 id="23b4" class="lv lw it bd lx ly lz dn ma mb mc dp md kr me mf mg kv mh mi mj kz mk ml mm mn bi translated">3.使用别名可以提高可读性</h2><p id="df6f" class="pw-post-body-paragraph ki kj it kk b kl mo ju kn ko mp jx kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">众所周知，别名是重命名没有意义的表或列的一种便捷方式。当表和列的名称没有意义时，不要犹豫给它们起别名，也不要犹豫给聚合起别名。</p><blockquote class="mt mu mv"><p id="ce3d" class="ki kj mw kk b kl km ju kn ko kp jx kq mx ks kt ku my kw kx ky mz la lb lc ld im bi translated"><strong class="kk iu">避免</strong></p></blockquote><pre class="lf lg lh li gt na nb nc nd aw ne bi"><span id="4f17" class="lv lw it nb b gy nf ng l nh ni"><strong class="nb iu">SELECT</strong> customers.id, <br/>       customers.name, <br/>       customers.context_col1,<br/>       nested.f0_<br/><strong class="nb iu">FROM</strong> company.customers<strong class="nb iu"><br/>JOIN</strong> (<br/>          <strong class="nb iu">SELECT</strong> customer_id,<br/>                 MIN(date)<br/>          <strong class="nb iu">FROM</strong> company.purchases<br/>          <strong class="nb iu">GROUP BY</strong> customer_id<br/>      ) <strong class="nb iu">ON</strong> customer_id = customers.id</span></pre><blockquote class="mt mu mv"><p id="8548" class="ki kj mw kk b kl km ju kn ko kp jx kq mx ks kt ku my kw kx ky mz la lb lc ld im bi translated"><strong class="kk iu">更喜欢</strong></p></blockquote><pre class="lf lg lh li gt na nb nc nd aw ne bi"><span id="d002" class="lv lw it nb b gy nf ng l nh ni"><strong class="nb iu">SELECT</strong> customers.id, <br/>       customers.name, <br/>       customers.context_col1 <strong class="nb iu">as ip_address</strong>,<br/>       first_purchase.date    <strong class="nb iu">as first_purchase_date</strong><br/><strong class="nb iu">FROM</strong> company.customers<strong class="nb iu"><br/>JOIN</strong> (<br/>          <strong class="nb iu">SELECT</strong> customer_id,<br/>                 MIN(date) <strong class="nb iu">as date</strong><br/>          <strong class="nb iu">FROM</strong> company.purchases<br/>          <strong class="nb iu">GROUP BY</strong> customer_id<br/>      ) <strong class="nb iu">AS first_purchase </strong><br/>        <strong class="nb iu">ON</strong> first_purchase.customer_id = customers.id</span></pre><p id="09b1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我通常用小写字母<code class="fe nk nl nm nb b">as</code>作为列的别名，用大写字母<code class="fe nk nl nm nb b">AS</code>作为表的别名。</p><h2 id="9db4" class="lv lw it bd lx ly lz dn ma mb mc dp md kr me mf mg kv mh mi mj kz mk ml mm mn bi translated">4.格式:小心使用缩进和空格</h2><p id="fdaf" class="pw-post-body-paragraph ki kj it kk b kl mo ju kn ko mp jx kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">尽管这是一个基本原则，但它能让你的代码更具可读性。就像使用python一样，您应该标识您的SQL代码。</p><p id="3e8e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当使用子查询或派生表时，在关键字后使用Ident。</p><blockquote class="mt mu mv"><p id="b79a" class="ki kj mw kk b kl km ju kn ko kp jx kq mx ks kt ku my kw kx ky mz la lb lc ld im bi translated"><strong class="kk iu">避免</strong></p></blockquote><pre class="lf lg lh li gt na nb nc nd aw ne bi"><span id="fc92" class="lv lw it nb b gy nf ng l nh ni">SELECT customers.id, customers.name, customers.age, customers.gender, customers.salary, first_purchase.date<br/>FROM company.customers<br/>LEFT JOIN ( SELECT customer_id, MIN(date) as date FROM company.purchases GROUP BY customer_id ) AS first_purchase <br/>ON first_purchase.customer_id = customers.id <br/>WHERE customers.age&lt;=30</span></pre><blockquote class="mt mu mv"><p id="63b4" class="ki kj mw kk b kl km ju kn ko kp jx kq mx ks kt ku my kw kx ky mz la lb lc ld im bi translated"><strong class="kk iu">更喜欢</strong></p></blockquote><pre class="lf lg lh li gt na nb nc nd aw ne bi"><span id="d256" class="lv lw it nb b gy nf ng l nh ni"><strong class="nb iu">SELECT</strong> customers.id, <br/>       customers.name, <br/>       customers.age, <br/>       customers.gender, <br/>       customers.salary,<br/>       first_purchase.date<br/><strong class="nb iu">FROM</strong> company.customers<br/><strong class="nb iu">LEFT JOIN</strong> (<br/>              <strong class="nb iu">SELECT</strong> customer_id,<br/>                     MIN(date) as date <br/>              <strong class="nb iu">FROM</strong> company.purchases<br/>              <strong class="nb iu">GROUP BY</strong> customer_id<br/>          ) <strong class="nb iu">AS</strong> first_purchase <br/>            <strong class="nb iu">ON</strong> first_purchase.customer_id = customers.id<br/><strong class="nb iu">WHERE</strong> customers.age &lt;= 30</span></pre><p id="a4fe" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">另外，请注意我们如何在where子句中使用空格。</p><blockquote class="mt mu mv"><p id="50d0" class="ki kj mw kk b kl km ju kn ko kp jx kq mx ks kt ku my kw kx ky mz la lb lc ld im bi translated"><strong class="kk iu">避免</strong></p></blockquote><pre class="lf lg lh li gt na nb nc nd aw ne bi"><span id="79cc" class="lv lw it nb b gy nf ng l nh ni">SELECT id WHERE customers.age&lt;=30</span></pre><blockquote class="mt mu mv"><p id="9a15" class="ki kj mw kk b kl km ju kn ko kp jx kq mx ks kt ku my kw kx ky mz la lb lc ld im bi translated"><strong class="kk iu">偏爱</strong></p></blockquote><pre class="lf lg lh li gt na nb nc nd aw ne bi"><span id="6726" class="lv lw it nb b gy nf ng l nh ni">SELECT id WHERE customers.age &lt;= 30</span></pre><h2 id="7d18" class="lv lw it bd lx ly lz dn ma mb mc dp md kr me mf mg kv mh mi mj kz mk ml mm mn bi translated">5.避免选择*</h2><p id="33e8" class="pw-post-body-paragraph ki kj it kk b kl mo ju kn ko mp jx kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">不值得提醒这种好的做法。你应该明确你想要选择什么，因此避免使用<code class="fe nk nl nm nb b">Select *</code>。</p><p id="f351" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让你的请求不清楚，因为它隐藏了询问背后的意图。另外，请记住，您的表可能会发生变化并影响<code class="fe nk nl nm nb b">Select *</code>。这就是为什么我不是一个大风扇的<code class="fe nk nl nm nb b">EXCEPT()</code>指令。</p><blockquote class="mt mu mv"><p id="5523" class="ki kj mw kk b kl km ju kn ko kp jx kq mx ks kt ku my kw kx ky mz la lb lc ld im bi translated"><strong class="kk iu">避开</strong></p></blockquote><pre class="lf lg lh li gt na nb nc nd aw ne bi"><span id="9537" class="lv lw it nb b gy nf ng l nh ni">SELECT * EXCEPT(id) FROM company.customers</span></pre><blockquote class="mt mu mv"><p id="a329" class="ki kj mw kk b kl km ju kn ko kp jx kq mx ks kt ku my kw kx ky mz la lb lc ld im bi translated"><strong class="kk iu">更喜欢</strong></p></blockquote><pre class="lf lg lh li gt na nb nc nd aw ne bi"><span id="0d0a" class="lv lw it nb b gy nf ng l nh ni"><strong class="nb iu">SELECT</strong> name,<br/>       age,<br/>       salary<br/><strong class="nb iu">FROM</strong> company.customers</span></pre><h2 id="1d5f" class="lv lw it bd lx ly lz dn ma mb mc dp md kr me mf mg kv mh mi mj kz mk ml mm mn bi translated">6.使用ANSI-92连接语法</h2><p id="f137" class="pw-post-body-paragraph ki kj it kk b kl mo ju kn ko mp jx kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">…而不是用于连接表的SQL WHERE子句。<br/>尽管您可以使用WHERE子句和JOIN子句来连接表，但是最好使用JOIN / ANSI-92语法。</p><p id="6a76" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">虽然在性能方面没有区别，但是JOIN子句将关系逻辑与过滤器分开，提高了可读性。</p><blockquote class="mt mu mv"><p id="272f" class="ki kj mw kk b kl km ju kn ko kp jx kq mx ks kt ku my kw kx ky mz la lb lc ld im bi translated"><strong class="kk iu">避免</strong></p></blockquote><pre class="lf lg lh li gt na nb nc nd aw ne bi"><span id="78fb" class="lv lw it nb b gy nf ng l nh ni"><strong class="nb iu">SELECT</strong> customers.id, <br/>       customers.name, <br/>       COUNT(transactions.id) as nb_transaction<br/><strong class="nb iu">FROM</strong> company.customers, company.transactions<br/><strong class="nb iu">WHERE</strong> customers.id = transactions.customer_id<br/>      <strong class="nb iu">AND</strong> customers.age &lt;= 30<br/><strong class="nb iu">GROUP BY</strong> customers.id, customers.name</span></pre><blockquote class="mt mu mv"><p id="59e0" class="ki kj mw kk b kl km ju kn ko kp jx kq mx ks kt ku my kw kx ky mz la lb lc ld im bi translated"><strong class="kk iu">偏好</strong></p></blockquote><pre class="lf lg lh li gt na nb nc nd aw ne bi"><span id="d32d" class="lv lw it nb b gy nf ng l nh ni"><strong class="nb iu">SELECT</strong> customers.id, <br/>       customers.name, <br/>       COUNT(transactions.id) as nb_transaction<br/><strong class="nb iu">FROM</strong> company.customers<br/><strong class="nb iu">JOIN</strong> company.transactions <strong class="nb iu">ON</strong> customers.id = transactions.customer_id</span><span id="3a74" class="lv lw it nb b gy nj ng l nh ni"><strong class="nb iu">WHERE</strong> customers.age &lt;= 30<br/><strong class="nb iu">GROUP BY</strong> customers.id, customers.name</span></pre><p id="f0ef" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">“基于Where子句”的语法—也称为ANSI-89 —比新的ANSI-92要老，这就是为什么它仍然非常普遍。如今，大多数开发人员和数据分析师都使用JOIN语法。</p><h2 id="8c7e" class="lv lw it bd lx ly lz dn ma mb mc dp md kr me mf mg kv mh mi mj kz mk ml mm mn bi translated">7.使用公用表表达式(CTE)</h2><p id="d7bc" class="pw-post-body-paragraph ki kj it kk b kl mo ju kn ko mp jx kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">CTE允许您定义和执行查询，其结果是临时存在的，可以在更大的查询中使用。cte可以在大多数现代数据库中找到。</p><p id="7f6a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它像派生表一样工作，有两个优点:</p><ul class=""><li id="a633" class="nn no it kk b kl km ko kp kr np kv nq kz nr ld ns nt nu nv bi translated">使用CTE可以提高查询的可读性</li><li id="0d79" class="nn no it kk b kl nw ko nx kr ny kv nz kz oa ld ns nt nu nv bi translated">CTE被定义一次，然后可以被多次引用</li></ul><p id="f3cb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你用指令<strong class="kk iu">用…声明一个CTE为</strong>:</p><pre class="lf lg lh li gt na nb nc nd aw ne bi"><span id="22a8" class="lv lw it nb b gy nf ng l nh ni"><strong class="nb iu">WITH</strong> my_cte <strong class="nb iu">AS</strong><br/>(<br/>  SELECT col1, col2 FROM table<br/>)<br/>SELECT * FROM my_cte</span></pre><blockquote class="mt mu mv"><p id="4bbf" class="ki kj mw kk b kl km ju kn ko kp jx kq mx ks kt ku my kw kx ky mz la lb lc ld im bi translated"><strong class="kk iu">避免</strong></p></blockquote><pre class="lf lg lh li gt na nb nc nd aw ne bi"><span id="f3cc" class="lv lw it nb b gy nf ng l nh ni"><strong class="nb iu">SELECT</strong> customers.id, <br/>       customers.name, <br/>       customers.age, <br/>       customers.gender, <br/>       customers.salary,<br/>       persona_salary.avg_salary as persona_avg_salary,<br/>       first_purchase.date<br/><strong class="nb iu">FROM</strong> company.customers<strong class="nb iu"><br/>JOIN</strong> (<br/>          <strong class="nb iu">SELECT</strong> customer_id,<br/>                 MIN(date) as date <br/>          <strong class="nb iu">FROM</strong> company.purchases<br/>          <strong class="nb iu">GROUP BY</strong> customer_id<br/>      ) <strong class="nb iu">AS</strong> first_purchase <br/>        <strong class="nb iu">ON</strong> first_purchase.customer_id = customers.id<br/><strong class="nb iu">JOIN</strong> (<br/>          <strong class="nb iu">SELECT</strong> age,<br/>             gender,<br/>             AVG(salary) as avg_salary<br/>         <strong class="nb iu">FROM</strong> company.customers<br/>         <strong class="nb iu">GROUP BY</strong> age, gender<br/>      ) <strong class="nb iu">AS</strong> persona_salary <br/>        <strong class="nb iu">ON</strong> persona_salary.age = customers.age<br/>           <strong class="nb iu">AND</strong> persona_salary.gender = customers.gender<br/><strong class="nb iu">WHERE</strong> customers.age &lt;= 30</span></pre><blockquote class="mt mu mv"><p id="0cae" class="ki kj mw kk b kl km ju kn ko kp jx kq mx ks kt ku my kw kx ky mz la lb lc ld im bi translated"><strong class="kk iu">更喜欢</strong></p></blockquote><pre class="lf lg lh li gt na nb nc nd aw ne bi"><span id="00a5" class="lv lw it nb b gy nf ng l nh ni"><strong class="nb iu">WITH</strong> first_purchase <strong class="nb iu">AS</strong><br/>(<br/>   <strong class="nb iu">SELECT</strong> customer_id,<br/>          MIN(date) as date <br/>   <strong class="nb iu">FROM</strong> company.purchases<br/>   <strong class="nb iu">GROUP BY</strong> customer_id<br/>),</span><span id="5c3c" class="lv lw it nb b gy nj ng l nh ni">persona_salary <strong class="nb iu">AS</strong><br/>(<br/>   <strong class="nb iu">SELECT</strong> age,<br/>          gender,<br/>          AVG(salary) as avg_salary<br/>   <strong class="nb iu">FROM</strong> company.customers<br/>   <strong class="nb iu">GROUP BY</strong> age, gender<br/>)</span><span id="b80c" class="lv lw it nb b gy nj ng l nh ni"><strong class="nb iu">SELECT</strong> customers.id, <br/>       customers.name, <br/>       customers.age, <br/>       customers.gender, <br/>       customers.salary,<br/>       persona_salary.avg_salary as persona_avg_salary,<br/>       first_purchase.date<br/><strong class="nb iu">FROM</strong> company.customers<strong class="nb iu"><br/>JOIN</strong> first_purchase <strong class="nb iu">ON</strong> first_purchase.customer_id = customers.id<br/><strong class="nb iu">JOIN</strong> persona_salary <strong class="nb iu">ON</strong> persona_salary.age = customers.age<br/>                       <strong class="nb iu">AND</strong> persona_salary.gender = customers.gender<br/><strong class="nb iu">WHERE</strong> customers.age &lt;= 30</span></pre><h2 id="a175" class="lv lw it bd lx ly lz dn ma mb mc dp md kr me mf mg kv mh mi mj kz mk ml mm mn bi translated">8.有时，将查询分成多个可能是值得的</h2><p id="c2b5" class="pw-post-body-paragraph ki kj it kk b kl mo ju kn ko mp jx kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">小心这个。让我们给出一些背景:</p><p id="443f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我经常使用AirFlow在Bigquery上执行SQL查询，转换数据，并准备数据可视化。我们有一个工作流程编排器(Airflow ),它按照定义的顺序执行请求。在某些情况下，我们选择将复杂的查询分成多个较小的查询。</p><blockquote class="mt mu mv"><p id="0f21" class="ki kj mw kk b kl km ju kn ko kp jx kq mx ks kt ku my kw kx ky mz la lb lc ld im bi translated"><strong class="kk iu">而不是</strong></p></blockquote><pre class="lf lg lh li gt na nb nc nd aw ne bi"><span id="b55c" class="lv lw it nb b gy nf ng l nh ni">CREATE TABLE customers_infos AS<br/>SELECT customers.id,<br/>       customers.salary,<br/>       traffic_info.weeks_since_last_visit,<br/>       category_info.most_visited_category_id,<br/>       purchase_info.highest_purchase_value</span><span id="de6d" class="lv lw it nb b gy nj ng l nh ni">FROM company.customers<br/>LEFT JOIN ([..]) AS traffic_info<br/>LEFT JOIN ([..]) AS category_info<br/>LEFT JOIN ([..]) AS purchase_info</span></pre><blockquote class="mt mu mv"><p id="3376" class="ki kj mw kk b kl km ju kn ko kp jx kq mx ks kt ku my kw kx ky mz la lb lc ld im bi translated">你可以用</p></blockquote><pre class="lf lg lh li gt na nb nc nd aw ne bi"><span id="5589" class="lv lw it nb b gy nf ng l nh ni"><strong class="nb iu">## STEP1: Create initial table<br/></strong>CREATE TABLE public.customers_infos AS<br/>SELECT customers.id,<br/>       customers.salary,<br/>       0 as weeks_since_last_visit,<br/>       0 as most_visited_category_id,<br/>       0 as highest_purchase_value<br/>FROM company.customers</span><span id="0230" class="lv lw it nb b gy nj ng l nh ni"><strong class="nb iu">## STEP2: Update traffic infos<br/></strong>UPDATE public.customers_infos<br/>SET weeks_since_last_visit = DATE_DIFF(<em class="mw">CURRENT_DATE</em>,<br/>                                       last_visit.date, WEEK)<br/>FROM (<br/>         SELECT customer_id, max(visit_date) as date<br/>         FROM web.traffic_info<br/>         GROUP BY customer_id<br/>     ) AS last_visit<br/>WHERE last_visit.customer_id = customers_infos.id</span><span id="4e0d" class="lv lw it nb b gy nj ng l nh ni"><strong class="nb iu">## STEP3: Update category infos<br/></strong>UPDATE public.customers_infos<br/>SET most_visited_category_id = [...]<br/>WHERE [...]</span><span id="3a54" class="lv lw it nb b gy nj ng l nh ni"><strong class="nb iu">## STEP4: Update purchase infos<br/></strong>UPDATE public.customers_infos<br/>SET highest_purchase_value = [...]<br/>WHERE [...]</span></pre><p id="b245" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">警告:</strong>尽管这种方法在简化复杂查询时非常有用，但它可能会带来可读性/性能的损失。</p><p id="1d0c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您使用OLAP(或任何面向列的)数据库，尤其如此，该数据库针对聚合和分析查询(选择、AVG、最小、最大等)进行了优化，但在事务处理(更新)方面性能较差。</p><p id="6bbb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">虽然在某些情况下，它也可能提高你的表现。即使是现代的面向列的数据库，太多的连接也会导致内存或性能问题。在这些情况下，拆分请求通常有助于提高性能和内存。</p><p id="0268" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，值得一提的是，您需要某种程序或编排器来按照定义的顺序执行查询。</p><h2 id="fd7d" class="lv lw it bd lx ly lz dn ma mb mc dp md kr me mf mg kv mh mi mj kz mk ml mm mn bi translated">9.基于您自己的约定的有意义的名称</h2><p id="c99d" class="pw-post-body-paragraph ki kj it kk b kl mo ju kn ko mp jx kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">正确命名模式和表是很困难的。使用哪种命名约定是有争议的，但是选择一种并坚持使用它是没有争议的。你应该定义<strong class="kk iu">你自己的</strong>惯例，并让你的团队采纳。</p><blockquote class="mt mu mv"><p id="3d9a" class="ki kj mw kk b kl km ju kn ko kp jx kq mx ks kt ku my kw kx ky mz la lb lc ld im bi translated">计算机科学只有两个硬东西:缓存失效和事物命名。—菲尔·卡尔顿</p></blockquote><p id="63cf" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以下是我使用的惯例示例:</p><h2 id="3b97" class="lv lw it bd lx ly lz dn ma mb mc dp md kr me mf mg kv mh mi mj kz mk ml mm mn bi translated"><strong class="ak">模式</strong></h2><p id="abd1" class="pw-post-body-paragraph ki kj it kk b kl mo ju kn ko mp jx kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">如果您使用的分析数据库有多种用途，那么以有意义的模式组织您的表是一个很好的做法。</p><p id="d136" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我们的Bigquery数据库中，每个数据源都有一个模式。更重要的是，我们根据目的以不同的模式输出结果。</p><ul class=""><li id="fe67" class="nn no it kk b kl km ko kp kr np kv nq kz nr ld ns nt nu nv bi translated">第三方工具可以访问的任何表都位于<strong class="kk iu"> <em class="mw">公共</em> </strong>模式中。Dataviz工具如DataStudio或Tableau从这里获取数据。</li><li id="9973" class="nn no it kk b kl nw ko nx kr ny kv nz kz oa ld ns nt nu nv bi translated">由于我们将机器学习与<a class="ae lu" rel="noopener" target="_blank" href="/super-fast-machine-learning-to-production-with-bigquery-ml-53c43b3825a3"> BQML </a>一起使用，我们得到了一个专用的<strong class="kk iu"> <em class="mw">机器学习</em> </strong>模式。</li></ul><h2 id="0568" class="lv lw it bd lx ly lz dn ma mb mc dp md kr me mf mg kv mh mi mj kz mk ml mm mn bi translated">桌子</h2><p id="56b2" class="pw-post-body-paragraph ki kj it kk b kl mo ju kn ko mp jx kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">根据惯例，表本身应该是名称。<br/>在Agorapulse，我们有几个用于数据可视化的仪表板，每个仪表板都有自己的用途:营销仪表板、产品仪表板、管理仪表板等等。</p><p id="f304" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们的公共模式中的每个表都以仪表板的名称为前缀。一些例子可能包括:</p><pre class="lf lg lh li gt na nb nc nd aw ne bi"><span id="916d" class="lv lw it nb b gy nf ng l nh ni">product_inbox_usage<br/>product_addon_competitor_stats<br/>marketing_acquisition_agencies<br/>executive_funnel_overview</span></pre><p id="a370" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当与团队合作时，花时间定义你的惯例是值得的。当涉及到命名一个新表时，千万不要用一个你以后会“改变”的又快又脏的名字:你可能不会。</p><p id="a64a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">请随意使用这些例子来定义您的约定。</p><h2 id="4502" class="lv lw it bd lx ly lz dn ma mb mc dp md kr me mf mg kv mh mi mj kz mk ml mm mn bi translated">10.最后，写一些有用的评论…但不要太多</h2><p id="ee57" class="pw-post-body-paragraph ki kj it kk b kl mo ju kn ko mp jx kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">我同意这样的观点，一个写得很好并且正确命名的代码不需要注释。阅读您的代码的人应该在代码本身之前就理解其逻辑和意图。</p><p id="19f1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">尽管如此，注释在某些情况下还是有用的。但是你一定要避免过多评论的陷阱。</p><blockquote class="mt mu mv"><p id="e50d" class="ki kj mw kk b kl km ju kn ko kp jx kq mx ks kt ku my kw kx ky mz la lb lc ld im bi translated"><strong class="kk iu">避免</strong></p></blockquote><pre class="lf lg lh li gt na nb nc nd aw ne bi"><span id="975f" class="lv lw it nb b gy nf ng l nh ni"><strong class="nb iu">WITH</strong> fp <strong class="nb iu">AS</strong><br/>(<br/>   <strong class="nb iu">SELECT</strong> c_id,               # customer id<br/>          MIN(date) as dt     # date of first purchase<br/>   <strong class="nb iu">FROM</strong> company.purchases<br/>   <strong class="nb iu">GROUP BY</strong> c_id<br/>),</span><span id="a466" class="lv lw it nb b gy nj ng l nh ni">ps <strong class="nb iu">AS</strong><br/>(<br/>   <strong class="nb iu">SELECT</strong> age,<br/>          gender,<br/>          AVG(salary) as avg<br/>   <strong class="nb iu">FROM</strong> company.customers<br/>   <strong class="nb iu">GROUP BY</strong> age, gender<br/>)</span><span id="e4b1" class="lv lw it nb b gy nj ng l nh ni"><strong class="nb iu">SELECT</strong> customers.id, <br/>       ct.name, <br/>       ct.c_age,            # customer age<br/>       ct.gender,<br/>       ct.salary,<br/>       ps.avg,              # average salary of a similar persona<br/>       fp.dt                # date of first purchase for this client<br/><strong class="nb iu">FROM</strong> company.customers ct</span><span id="2fd5" class="lv lw it nb b gy nj ng l nh ni"># join the first purchase on client id<br/><strong class="nb iu">JOIN</strong> fp <strong class="nb iu">ON</strong> c_id = ct.id</span><span id="8054" class="lv lw it nb b gy nj ng l nh ni"># match persona based on same age and genre<br/><strong class="nb iu">JOIN</strong> ps <strong class="nb iu">ON</strong> ps.age = c_age<br/>           <strong class="nb iu">AND</strong> ps.gender = ct.gender<br/><strong class="nb iu">WHERE</strong> c_age &lt;= 30</span></pre><blockquote class="mt mu mv"><p id="2956" class="ki kj mw kk b kl km ju kn ko kp jx kq mx ks kt ku my kw kx ky mz la lb lc ld im bi translated"><strong class="kk iu">更喜欢</strong></p></blockquote><pre class="lf lg lh li gt na nb nc nd aw ne bi"><span id="dafb" class="lv lw it nb b gy nf ng l nh ni"><strong class="nb iu">WITH</strong> first_purchase <strong class="nb iu">AS</strong><br/>(<br/>   <strong class="nb iu">SELECT</strong> customer_id,<br/>          MIN(date) as date <br/>   <strong class="nb iu">FROM</strong> company.purchases<br/>   <strong class="nb iu">GROUP BY</strong> customer_id<br/>),</span><span id="fa05" class="lv lw it nb b gy nj ng l nh ni">persona_salary <strong class="nb iu">AS</strong><br/>(<br/>   <strong class="nb iu">SELECT</strong> age,<br/>          gender,<br/>          AVG(salary) as avg_salary<br/>   <strong class="nb iu">FROM</strong> company.customers<br/>   <strong class="nb iu">GROUP BY</strong> age, gender<br/>)</span><span id="c9d0" class="lv lw it nb b gy nj ng l nh ni"><strong class="nb iu">SELECT</strong> customers.id, <br/>       customers.name, <br/>       customers.age, <br/>       customers.gender, <br/>       customers.salary,<br/>       persona_salary.avg_salary <strong class="nb iu">as</strong> persona_avg_salary,<br/>       first_purchase.date<br/><strong class="nb iu">FROM</strong> company.customers<strong class="nb iu"><br/>JOIN</strong> first_purchase <strong class="nb iu">ON</strong> first_purchase.customer_id = customers.id<br/><strong class="nb iu">JOIN</strong> persona_salary <strong class="nb iu">ON</strong> persona_salary.age = customers.age<br/>                       <strong class="nb iu">AND</strong> persona_salary.gender = customers.gender<br/><strong class="nb iu">WHERE</strong> customers.age &lt;= 30</span></pre><h1 id="92aa" class="ob lw it bd lx oc od oe ma of og oh md jz oi ka mg kc oj kd mj kf ok kg mm ol bi translated">结论</h1><p id="5b80" class="pw-post-body-paragraph ki kj it kk b kl mo ju kn ko mp jx kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">SQL很棒。它是数据分析、数据科学、数据工程甚至软件开发的基础之一:它不会等待。它的灵活性是一种优势，但也可能是一个陷阱。</p><p id="0f1f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一开始你可能没有意识到这一点，尤其是如果你是唯一负责自己代码的人。但是在某些时候，当与团队一起工作时，或者如果有人必须继续您的工作，没有一组最佳实践的SQL代码将成为负担。</p><p id="8bc9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我总结了编写SQL的最常见的最佳实践。当然，有些是有争议的或基于个人观点的:你可能想从这里获得灵感，并与你的团队定义一些不同的东西。</p><p id="20b4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我希望它能帮助您将SQL质量提升到一个新的水平！</p></div></div>    
</body>
</html>