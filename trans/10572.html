<html>
<head>
<title>Aggregations on time-series data with Pandas</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">熊猫时间序列数据的聚合</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/aggregations-on-time-series-data-with-pandas-5c79cc24a449?source=collection_archive---------9-----------------------#2021-10-09">https://towardsdatascience.com/aggregations-on-time-series-data-with-pandas-5c79cc24a449?source=collection_archive---------9-----------------------#2021-10-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d47d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Python熊猫和SQL时间聚合和语法解释。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/2aeeae92263577ec50f66fd8efa526f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pFPGtp2WU3zQ3Og7C3mBGQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">等待一个好时机，波兰2021。作者照片。</p></figure><h1 id="2ef0" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">介绍</h1><p id="62c9" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">处理时间序列数据本身通常就是一项挑战。它是一种特殊的数据，数据点在时间上相互依赖。在分析它的时候，你获得洞察力的效率在很大程度上取决于你处理时间维度的能力。</p><p id="197d" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">通常，时间序列数据是在很长一段时间内收集的，特别是当它们来自硬件设备或代表金融交易等序列时。此外，即使数据集中没有字段为“空”，如果时间戳没有规则地间隔、移位、丢失或以任何方式不一致，数据仍然可能有问题。</p><p id="abe8" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">有助于从依赖于时间的数据中获取有用信息的关键技能之一是高效地执行聚合。它不仅允许大大减少数据总量，而且有助于更快地发现有趣的事实。</p><p id="bc7a" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">在本文中，我将介绍几种方法来帮助您进行分析的最流行的Python库<a class="ae mr" href="https://pandas.pydata.org" rel="noopener ugc nofollow" target="_blank"> Pandas </a>如何帮助您执行这些聚合，以及当您处理时间时有什么特别之处。除此之外，我还将在SQL中放一个等效的语法以供参考。</p><h1 id="5566" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">数据</h1><p id="a014" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">为了演示，我使用来自Kaggle的<a class="ae mr" href="https://www.kaggle.com/ealtman2019/credit-card-transactions?select=credit_card_transactions-ibm_v2.csv" rel="noopener ugc nofollow" target="_blank">信用卡交易</a>数据集。然而，为了简单起见，我将重点放在<code class="fe ms mt mu mv b">"Amount"</code>列上，并按单个用户对其进行过滤，尽管聚合总是可以扩展以包含更多的标准。关于时间的信息分布在<code class="fe ms mt mu mv b">"Year", "Month", "Day"</code>和<code class="fe ms mt mu mv b">"Time"</code>列中，所以用一个单独的列来表示它是有意义的。</p><p id="1fe0" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">因为整个数据集重约2.35 GB，所以让我们使用较小的批次来动态转换数据。</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="ae97" class="na kz it mv b gy nb nc l nd ne">import pandas as pd<br/>import numpy as np<br/>from tqdm import tqdm<br/>from pathlib import Path<br/><br/><br/>SRC = Path("data/credit_card_transactions-ibm_v2.csv")<br/>DST = Path("data/transactions.csv")<br/>USER = 0<br/><br/><br/>def load(filepath=SRC):<br/>    data = pd.read_csv(<br/>        filepath,<br/>        iterator=True,<br/>        chunksize=10000,<br/>        usecols=["Year", "Month", "Day", "Time", "Amount"],<br/>    )<br/>    <br/>    for df in tqdm(data):<br/>        yield df<br/><br/><br/>def process(df):<br/>    _df = df.query("User == @USER") <br/>    ts = _df.apply(<br/>        lambda x: f"{x['Year']}{x['Month']:02d}{x['Day']:02d} {x['Time']}",<br/>        axis=1,<br/>    )<br/><br/>    _df["timestmap"] = pd.to_datetime(ts)<br/>    _df["amount"] = df["Amount"].str.strip("$").astype(float)<br/>    <br/>    return _df.get(["timestamp", "amount"])<br/><br/><br/>def main():<br/>    for i, df in enumerate(load()):<br/>        df = process(df)<br/>        df.to_csv(<br/>            DST,<br/>            mode="a" if i else "w",<br/>            header=not(bool(i)),<br/>            index=False,<br/>        )<br/><br/><br/>if __name__ == "__main__":<br/>    main()</span></pre><p id="60b3" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">…提供:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="4caf" class="na kz it mv b gy nb nc l nd ne">| timestamp           |   amount |<br/>|:--------------------|---------:|<br/>| 2002-09-01 06:21:00 |   134.09 |<br/>| 2002-09-01 06:42:00 |    38.48 |<br/>| 2002-09-02 06:22:00 |   120.34 |<br/>| 2002-09-02 17:45:00 |   128.95 |<br/>| 2002-09-03 06:23:00 |   104.71 |</span></pre><p id="0999" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">这个框架的“头”给了我们上表。对于单个用户(这里是<code class="fe ms mt mu mv b">USER = 0</code>)，我们有将近20k个时间戳，以一分钟的分辨率标记2002年到2020年之间的事务。</p><p id="1c9f" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">感谢第31行中的<code class="fe ms mt mu mv b">pd.to_datetime</code>,我们转换了从四列串联的数据，并将其存储为以统一数据类型描述时间的<code class="fe ms mt mu mv b">np.datetime64</code>变量。</p><h2 id="0378" class="na kz it bd la nf ng dn le nh ni dp li lz nj nk lk md nl nm lm mh nn no lo np bi translated">什么是np.datetime64？</h2><p id="52cb" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated"><code class="fe ms mt mu mv b">np.datetime64</code> ( <a class="ae mr" href="https://numpy.org/doc/stable/reference/arrays.datetime.html" rel="noopener ugc nofollow" target="_blank"> doc </a>)类型是pythonic】对象的数字版本。它是矢量化的，因此可以快速对整个数组执行操作。同时，该对象识别典型的<code class="fe ms mt mu mv b">datetime</code>方法(<a class="ae mr" href="https://docs.python.org/3/library/datetime.html" rel="noopener ugc nofollow" target="_blank"> doc </a>)，这些方法有助于自然地操作这些值。</p><p id="3dc4" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">在熊猫这边，相关的对象是<code class="fe ms mt mu mv b">Timestamp</code>、<code class="fe ms mt mu mv b">Timedelta</code>和<code class="fe ms mt mu mv b">Period</code>(对应<code class="fe ms mt mu mv b">DatetimeIndex</code>、<code class="fe ms mt mu mv b">TimedeltaIndex</code>和<code class="fe ms mt mu mv b">PeriodIndex</code>)，分别描述时间中的瞬间、时移和时间跨度。然而，在本质上，仍然有<code class="fe ms mt mu mv b">np.datetime64</code>和类似的<code class="fe ms mt mu mv b">np.timedelta64</code>拥有便利的属性。</p><p id="8d1b" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">将与时间相关的值转换成这些对象是任何时间序列分析的最佳起点。它既方便又快捷。</p><h1 id="7a44" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">基本重采样</h1><p id="9c82" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">时序聚合的最简单形式是使用聚合函数将值输入到间隔均匀的容器中。它有助于调整分辨率和数据量。</p><p id="e562" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">以下代码片段显示了使用两个函数对天数进行重采样的示例:sum和count:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="c37c" class="na kz it mv b gy nb nc l nd ne">SELECT<br/>    sum(amount),<br/>    count(amount),<br/>    DATE(timestamp) AS dt<br/>FROM transactions<br/>GROUP BY dt;</span></pre><p id="72c6" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">熊猫为我们提供了至少两种方法来达到同样的结果:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="b972" class="na kz it mv b gy nb nc l nd ne"># option 1<br/>df["amount"].resample("D").agg(["sum", "count"])</span><span id="fef9" class="na kz it mv b gy nq nc l nd ne"># option 2<br/>df["amount"].groupby(pd.Grouper(level=0, freq="D")) \<br/>    .agg(["sum", "count"])</span></pre><p id="07a1" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">这两种选择是等效的。第一种更简单，它依赖于这样一个事实，即<code class="fe ms mt mu mv b">timestamp</code>列已经被设置为dataframe的索引，尽管也可以使用可选参数<code class="fe ms mt mu mv b">on</code>指向特定的列。第二种方法结合使用了更通用的聚合对象<code class="fe ms mt mu mv b">pd.Grouper</code>和<code class="fe ms mt mu mv b">.groupby</code>方法。它是高度可定制的，有许多可选参数。这里，我使用的是<code class="fe ms mt mu mv b">level</code>而不是<code class="fe ms mt mu mv b">key</code>，因为<code class="fe ms mt mu mv b">timestamp</code>是一个索引。另外，<code class="fe ms mt mu mv b">freq="D"</code>代表<em class="nr">天</em>。还有其他的<a class="ae mr" href="https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#dateoffset-objects" rel="noopener ugc nofollow" target="_blank">代码</a>，尽管一个类似的SQL语句可能更复杂。</p><h1 id="a41e" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">几个时间跨度的聚合</h1><p id="c1f5" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">假设您想要聚合时间戳的多个部分的数据，比如<code class="fe ms mt mu mv b">(year, week)</code>或<code class="fe ms mt mu mv b">(month, day-of-week, hour)</code>。由于<code class="fe ms mt mu mv b">timestamp</code>属于<code class="fe ms mt mu mv b">np.datetime64</code>类型，所以可以使用所谓的<code class="fe ms mt mu mv b">.dt</code>访问器来引用它的方法，并将它们用于聚合指令。</p><p id="8460" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">在SQL中，您应该:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="e28a" class="na kz it mv b gy nb nc l nd ne">SELECT<br/>    AVG(amount),<br/>    STRFTIME('%Y %W', timestamp) AS yearweek<br/>FROM transactions<br/>GROUP BY yearweek</span></pre><p id="004d" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">在熊猫身上有两种方法:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="360a" class="na kz it mv b gy nb nc l nd ne">df = df.reset_index()  # if we want `timestamp` to be a column<br/>df["amount"].groupby(by=[<br/>    df["timestamp"].dt.year, <br/>    df["timestamp"].dt.isocalendar().week<br/>]).mean()<br/><br/>df = df.set_index("timestamp")  # if we want `timestamp` to be index<br/>df["amount"].groupby(by=[<br/>    df.index.year,<br/>    df.index.isocalendar().week,<br/>]).mean()</span></pre><p id="ef14" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">他们做同样的事情。</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="ba61" class="na kz it mv b gy nb nc l nd ne">|            |   amount |<br/>|:-----------|---------:|<br/>| (2002, 1)  |  40.7375 |<br/>| (2002, 35) |  86.285  |<br/>| (2002, 36) |  82.3733 |<br/>| (2002, 37) |  72.2048 |<br/>| (2002, 38) |  91.8647 |</span></pre><p id="445c" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">另外值得一提的是，<code class="fe ms mt mu mv b">.groupby</code>方法并不强制使用聚合函数。它所做的只是将帧分割成一系列帧。您可能也想使用单独的“子帧”,并直接对它们执行一些变换。如果是这种情况，只需重复:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="fd40" class="na kz it mv b gy nb nc l nd ne">for key, group in df.groupby(by=[<br/>        df.index.year,<br/>        df.index.isocalendar().week<br/>    ]):<br/>    pass</span></pre><p id="4ddf" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">这里的<code class="fe ms mt mu mv b">key</code>将是一个<code class="fe ms mt mu mv b">(year, week)</code>的元组，而<code class="fe ms mt mu mv b">group</code>将是一个子帧。</p><h2 id="bc07" class="na kz it bd la nf ng dn le nh ni dp li lz nj nk lk md nl nm lm mh nn no lo np bi translated">注意</h2><p id="7e9e" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">值得一提的是，在不同风格的SQL和Pandas中，时间窗口的边界可能会有不同的定义。当使用SQLite进行比较时，两者给出的结果略有不同。</p><p id="475d" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">SQL:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="3721" class="na kz it mv b gy nb nc l nd ne">SELECT<br/>    STRFTIME('%Y %W %w', timestamp),<br/>    timestamp<br/>FROM TRANSACTIONS<br/>LIMIT 5;</span><span id="ba03" class="na kz it mv b gy nq nc l nd ne">--gives:<br/>| timestamp           | year | week | day |<br/>|:--------------------|-----:|-----:|----:| <br/>| 2002-09-01 06:21:00 | 2002 | 34   |  0  |                    <br/>| 2002-09-01 06:42:00 | 2002 | 34   |  0  |                    <br/>| 2002-09-02 06:22:00 | 2002 | 35   |  1  |                    <br/>| 2002-09-02 17:45:00 | 2002 | 35   |  1  |                    <br/>| 2002-09-03 06:23:00 | 2002 | 35   |  2  |</span></pre><p id="aee4" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">熊猫:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="0084" class="na kz it mv b gy nb nc l nd ne">df.index.isocalendar().head()</span><span id="3928" class="na kz it mv b gy nq nc l nd ne"># gives:<br/>| timestamp           |   year |   week |   day |<br/>|:--------------------|-------:|-------:|------:|<br/>| 2002-09-01 06:21:00 |   2002 |     35 |     7 |<br/>| 2002-09-01 06:42:00 |   2002 |     35 |     7 |<br/>| 2002-09-02 06:22:00 |   2002 |     36 |     1 |<br/>| 2002-09-02 17:45:00 |   2002 |     36 |     1 |<br/>| 2002-09-03 06:23:00 |   2002 |     36 |     2 |</span></pre><p id="85df" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">概念是一样的，只是参照物不一样。</p><h1 id="b770" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">窗口功能</h1><p id="f9ac" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">最后一种通常用于时间数据的聚合类型是使用滚动窗口。与按某些特定列的值按行分组相反，这种方法定义了一个行的间隔来选择一个子表，移动窗口，并再次这样做。</p><p id="eb7e" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">让我们来看一个计算连续五行(当前加上过去的四行)的移动平均值的例子。在SQL中，语法如下:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="20b3" class="na kz it mv b gy nb nc l nd ne">SELECT<br/>    timestamp,<br/>    AVG(amount) OVER (<br/>        ORDER BY timestamp<br/>        ROWS BETWEEN 4 PRECEDING AND CURRENT ROW<br/>    ) rolling_avg<br/>FROM transactions;</span></pre><p id="8108" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">Pandas声明了一个简单得多的语法:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="6adc" class="na kz it mv b gy nb nc l nd ne"># applying mean immediatiely<br/>df["amount"].rolling(5).mean()<br/><br/># accessing the chunks directly<br/>for chunk in df["amount"].rolling(5):<br/>    pass</span></pre><p id="9fc7" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">同样，在Pandas中，可以使用可选参数进行不同的调整。窗口的大小由<code class="fe ms mt mu mv b">window</code>属性决定，这在SQL中是通过一系列语句实现的(第5行)。此外，我们可能希望将窗口居中，使用不同的窗口，例如加权平均，或者执行可选的数据清理。然而，<code class="fe ms mt mu mv b">.rolling</code>方法返回的<code class="fe ms mt mu mv b">pd.Rolling</code>对象的用法在某种意义上类似于<code class="fe ms mt mu mv b">pd.DataFrameGroupBy</code>对象。</p><h1 id="7a1b" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">结论</h1><p id="3b49" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">在这里，我展示了我在处理时序数据时经常使用的三种类型的聚合。虽然并不是所有包含时间信息的数据都是时间序列，但是对于时间序列来说，将时间信息转换成<code class="fe ms mt mu mv b">pd.Timestamp</code>或其他实现numpy的<code class="fe ms mt mu mv b">np.datetime64</code>对象的类似对象几乎总是有益的。如图所示，它使得跨不同时间属性的聚合变得非常方便、直观和有趣。</p></div><div class="ab cl ns nt hx nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="im in io ip iq"><p id="eddd" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated"><em class="nr">最初发表于</em><a class="ae mr" href="https://zerowithdot.com/time-series-aggregations-pandas/" rel="noopener ugc nofollow" target="_blank"><em class="nr">【https://zerowithdot.com】</em></a><em class="nr">。</em></p></div></div>    
</body>
</html>