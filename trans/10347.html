<html>
<head>
<title>How Not to Use Python Lists</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何不使用Python列表</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-not-to-use-python-lists-d06cbe8e593?source=collection_archive---------4-----------------------#2021-10-02">https://towardsdatascience.com/how-not-to-use-python-lists-d06cbe8e593?source=collection_archive---------4-----------------------#2021-10-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="92db" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">理解Python中的可变对象。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c2c6dcc82b8090da60722e735879f179.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8xZkF6mq2knNGxbaAHt2sw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@rojekilian?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Sarah Kilian </a>在<a class="ae ky" href="https://unsplash.com/s/photos/oops?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="7ae5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我记得几年前当我从使用R转换到使用Python时，我必须习惯的一件事是可变对象——这在R中并不算什么。</p><p id="ff4a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可变对象是创建后<strong class="lb iu">可以修改</strong>的对象。Python中可变对象的一些例子是列表、字典和集合。在下面的例子中，我们在创建之后扩展了<code class="fe lv lw lx ly b">y</code>。</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="68a8" class="md me it ly b gy mf mg l mh mi">y = [1, 2, 3]<br/>id(y)<br/>Out[7]: 4831904704</span><span id="bad5" class="md me it ly b gy mj mg l mh mi">y.extend([4, 5, 6])<br/>y<br/>Out[10]: [1, 2, 3, 4, 5, 6]<br/>id(y)<br/>Out[11]: 4831904704</span></pre><p id="f673" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以看到它保持了其唯一的标识号(由<code class="fe lv lw lx ly b">id</code>函数给出)——这意味着我们仍然在使用同一个对象。</p><p id="63bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一方面，不可变对象<strong class="lb iu">不能被修改</strong>。一些例子是元组、字符串、整数、布尔等。正如你在下面的例子中看到的，一旦我们改变了<code class="fe lv lw lx ly b">x</code>的值，它的身份就改变了——我们已经将<code class="fe lv lw lx ly b">x</code>重新分配给了<code class="fe lv lw lx ly b">2</code>。</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="5b7e" class="md me it ly b gy mf mg l mh mi">x = 1<br/>id(x)<br/>Out[3]: 4564694112</span><span id="6642" class="md me it ly b gy mj mg l mh mi">x = 2<br/>id(x)<br/>Out[5]: 4564694144</span></pre></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><p id="faf9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您不习惯可变对象，那么编写具有…的代码是相当容易的。意想不到的后果。</p><p id="9f3c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来看几个例子(在大多数情况下，不要做什么)。</p><h1 id="59f8" class="mr me it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">列表作为默认参数？</h1><p id="d663" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">假设您正在编写一个类来帮助跟踪每个人的朋友。所以你要做以下事情。</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="fcf1" class="md me it ly b gy mf mg l mh mi"><em class="nn">class </em>FriendBook:<br/>    <em class="nn">def __init__</em>(self, <em class="nn">name</em>, <em class="nn">friends</em>=[]):<br/>        self.name = <em class="nn">name<br/>        </em>self.friends = <em class="nn">friends<br/><br/>    def </em>add_new_friend(self, <em class="nn">friend</em>):<br/>        <em class="nn">if friend not in </em>self.friends:<br/>            self.friends.append(<em class="nn">friend</em>)</span></pre><p id="1ddb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后你开始为不同的人创建友谊书。</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="9b6a" class="md me it ly b gy mf mg l mh mi">person_a_friendbook = FriendBook(name='Person A')<br/>person_b_friendbook = FriendBook(name='Person B')</span><span id="fbf9" class="md me it ly b gy mj mg l mh mi">person_c_friendbook = FriendBook(<br/>  name='Person C', <br/>  friends=['Person E'],<br/>)</span><span id="cc01" class="md me it ly b gy mj mg l mh mi">person_a_friendbook.add_new_friend('Person D')</span></pre><p id="3f39" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们希望B在这一点上没有朋友。但是，事实并非如此。</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="aef7" class="md me it ly b gy mf mg l mh mi">person_a_friendbook.friends<br/>Out[3]: ['Person D']</span><span id="916c" class="md me it ly b gy mj mg l mh mi">person_b_friendbook.friends<br/>Out[5]: ['Person D']</span><span id="df17" class="md me it ly b gy mj mg l mh mi">person_c_friendbook.friends<br/>Out[7]: ['Person E']</span></pre><p id="7b85" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是因为我们的默认参数<code class="fe lv lw lx ly b">friends=[]</code>只被创建一次，在我们创建类的时候。我们可以通过使用比较它们的身份的<code class="fe lv lw lx ly b">is</code>操作符来验证这一点。</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="9da5" class="md me it ly b gy mf mg l mh mi">person_a_friendbook.friends is person_b_friendbook.friends<br/>Out[8]: True</span></pre><p id="7cb9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以看到<code class="fe lv lw lx ly b">person_a_friendbook.friends</code>和<code class="fe lv lw lx ly b">person_b_friendbook.friends</code>的身份是一样的。任何时候你回过头来使用<code class="fe lv lw lx ly b">friends</code>的缺省值，你都将使用同一个列表——这意味着这个列表将被所有使用缺省参数实例化的对象共享。这很少(很可能永远不会)是我们想要的。大多数ide会警告你。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/2d831d62311cbe0d017ab3412feb71e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_w91AYV8T4Gy363EUMG68g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">PyCharm试图将我们从可变的默认参数中拯救出来。图片由作者提供。</p></figure><p id="5a9e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">解决办法很简单。</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="0a25" class="md me it ly b gy mf mg l mh mi"><em class="nn">class </em>FriendBook:<br/>    <em class="nn">def __init__</em>(self, <em class="nn">name</em>, <strong class="ly iu"><em class="nn">friends</em>=None</strong>):<br/>        self.name = <em class="nn">name<br/>        </em><strong class="ly iu">self.friends = friends or []</strong><em class="nn"><br/><br/>    def </em>add_new_friend(self, <em class="nn">friend</em>):<br/>        <em class="nn">if friend not in </em>self.friends:<br/>            self.friends.append(<em class="nn">friend</em>)</span></pre><p id="adff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样，我们为每个对象都获得了一个新的空列表。</p><h1 id="2e45" class="mr me it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">但我只是修改了函数内部的列表？</h1><p id="4e38" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">继续下一个我们可能会搞砸的方式。</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="c36f" class="md me it ly b gy mf mg l mh mi">x = [1, 2, <em class="nn">None</em>, 4, 5, <em class="nn">None</em>]<br/><br/><em class="nn">def </em>fill_none(<em class="nn">data</em>, <em class="nn">fill_value</em>):<br/>    n = len(<em class="nn">data</em>)<br/>    <em class="nn">for </em>i <em class="nn">in </em>range(n):<br/>        <em class="nn">if data</em>[i] <em class="nn">is None</em>:<br/>            <em class="nn">data</em>[i] = <em class="nn">fill_value<br/><br/>    return data<br/><br/><br/></em>y = fill_none(data=x, fill_value=100)</span></pre><p id="fb3c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的函数越过<code class="fe lv lw lx ly b">data</code>并用<code class="fe lv lw lx ly b">fill_value</code>替换<code class="fe lv lw lx ly b">None</code>值。</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="f0e0" class="md me it ly b gy mf mg l mh mi">y<br/>Out[1]: [1, 2, 100, 4, 5, 100]</span></pre><p id="3904" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">y</code>的值是我们所期望的。你能猜出<code class="fe lv lw lx ly b">x</code>现在是什么吗？如果你认为它和<code class="fe lv lw lx ly b">y</code>一样，那么你是正确的。</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="a3c2" class="md me it ly b gy mf mg l mh mi">x<br/>Out[2]: [1, 2, 100, 4, 5, 100]</span></pre><p id="39a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们将一个可变对象作为参数传递给一个函数时，我们给了这个函数修改它的权力。现在，我们可以用两种方法来解决这个问题。第一个是清楚地表明，如果我们真的想这样的话，函数会修改列表。在我看来，我们可以通过删除<code class="fe lv lw lx ly b">return</code>语句并添加一个docstring来实现。</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="07f5" class="md me it ly b gy mf mg l mh mi">x = [1, 2, <em class="nn">None</em>, 4, 5, <em class="nn">None</em>]<br/><br/><em class="nn">def </em>fill_none(<em class="nn">data</em>, <em class="nn">fill_value</em>):<br/>    '''<br/>    Replace None values with the fill_value. Modifies data in-place.<br/>    '''<br/>    n = len(<em class="nn">data</em>)<br/>    <em class="nn">for </em>i <em class="nn">in </em>range(n):<br/>        <em class="nn">if data</em>[i] <em class="nn">is None</em>:<br/>            <em class="nn">data</em>[i] = <em class="nn">fill_value<br/><br/></em>fill_none(data=x, fill_value=100)</span></pre><p id="45af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第二种选择是在函数中使用列表的副本。</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="70b4" class="md me it ly b gy mf mg l mh mi">x = [1, 2, <em class="nn">None</em>, 4, 5, <em class="nn">None</em>]<br/><br/><em class="nn">def </em>fill_none(<em class="nn">data</em>, <em class="nn">fill_value</em>):<br/>    data = data[:]  # make a copy of data<br/>    n = len(<em class="nn">data</em>)<br/>    <em class="nn">for </em>i <em class="nn">in </em>range(n):<br/>        <em class="nn">if data</em>[i] <em class="nn">is None</em>:<br/>            <em class="nn">data</em>[i] = <em class="nn">fill_value</em></span><span id="1807" class="md me it ly b gy mj mg l mh mi"><em class="nn">    return data</em></span><span id="270f" class="md me it ly b gy mj mg l mh mi">y = fill_none(data=x, fill_value=100)</span></pre><p id="1082" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在<code class="fe lv lw lx ly b">x</code>和<code class="fe lv lw lx ly b">y</code>不一样了。</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="b93e" class="md me it ly b gy mf mg l mh mi">y<br/>Out[13]: [1, 2, 100, 4, 5, 100]<br/>x<br/>Out[14]: [1, 2, None, 4, 5, None]</span></pre><h1 id="e088" class="mr me it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">你确定元组是不可变的吗？</h1><p id="18fa" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">如果你记得，在这篇文章的开始，我们说过元组是不可变的，它们是不可变的，它们没有允许我们改变它们的方法。你可能想知道的一件事是“我能在里面放一个列表吗？”然后“我能改变元组内部的列表吗？”。答案是“是”和“是”。</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="3499" class="md me it ly b gy mf mg l mh mi">my_list = [1, 2, 3]<br/>my_tuple = ('a', 'b', my_list)</span><span id="124b" class="md me it ly b gy mj mg l mh mi">my_tuple<br/>Out[1]: ('a', 'b', [1, 2, 3])</span><span id="5268" class="md me it ly b gy mj mg l mh mi">my_list.append('surprise')</span><span id="5ca1" class="md me it ly b gy mj mg l mh mi">my_tuple<br/>Out[2]: ('a', 'b', [1, 2, 3, 'surprise'])</span></pre><p id="b3e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为什么会这样？嗯，tuple是不可变的意味着我们在创建它之后不能改变它包含的对象(但是如果它们是可变的，我们可以修改其中的对象)。事实上，即使在我们修改了列表之后，<code class="fe lv lw lx ly b">my_tuple</code>仍然包含相同的三个元素，它们在我们创建它的时候都有相同的身份。这不一定是“搞砸了”或你想做的事情，但如果你没有意识到这一点，可能会令人困惑。</p><h1 id="26e9" class="mr me it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">结论</h1><p id="1735" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">在这篇文章中，我们讨论了Python中的可变和不可变对象。我们关注了可变对象，更具体地说是列表，如果不知道它们是如何工作的，会导致意想不到的后果。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><ul class=""><li id="01b8" class="np nq it lb b lc ld lf lg li nr lm ns lq nt lu nu nv nw nx bi translated"><strong class="lb iu">订阅</strong> <a class="ae ky" href="https://eminik355.medium.com/subscribe" rel="noopener"> <strong class="lb iu">邮件更新</strong> </a> <strong class="lb iu">。</strong></li><li id="5ab5" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated"><a class="ae ky" href="https://eminik355.medium.com/membership" rel="noopener"> <strong class="lb iu">成为</strong> </a> <strong class="lb iu">媒体的会员，获得所有故事的全部访问权限。你的会员费直接支持你读的作家。</strong></li></ul></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><p id="3dae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">更多来自同一作者。</strong></p><div class="od oe gp gr of og"><a rel="noopener follow" target="_blank" href="/multi-armed-bandits-thompson-sampling-algorithm-fea205cf31df"><div class="oh ab fo"><div class="oi ab oj cl cj ok"><h2 class="bd iu gy z fp ol fr fs om fu fw is bi translated">多武装匪徒:汤普森采样算法</h2><div class="on l"><h3 class="bd b gy z fp ol fr fs om fu fw dk translated">了解带Python代码的Thompson采样(贝叶斯)bandit算法。</h3></div><div class="oo l"><p class="bd b dl z fp ol fr fs om fu fw dk translated">towardsdatascience.com</p></div></div><div class="op l"><div class="oq l or os ot op ou ks og"/></div></div></a></div><div class="od oe gp gr of og"><a rel="noopener follow" target="_blank" href="/going-bayesian-testing-rate-metrics-82e872b79175"><div class="oh ab fo"><div class="oi ab oj cl cj ok"><h2 class="bd iu gy z fp ol fr fs om fu fw is bi translated">走向贝叶斯:测试速率度量</h2><div class="on l"><h3 class="bd b gy z fp ol fr fs om fu fw dk translated">如何在没有p值和置信区间的情况下运行速率度量的A/B测试？</h3></div><div class="oo l"><p class="bd b dl z fp ol fr fs om fu fw dk translated">towardsdatascience.com</p></div></div><div class="op l"><div class="ov l or os ot op ou ks og"/></div></div></a></div><div class="od oe gp gr of og"><a href="https://medium.com/analytics-vidhya/calculating-using-monte-carlo-simulations-337cff638ac5" rel="noopener follow" target="_blank"><div class="oh ab fo"><div class="oi ab oj cl cj ok"><h2 class="bd iu gy z fp ol fr fs om fu fw is bi translated">使用蒙特卡罗模拟计算𝛑</h2><div class="on l"><h3 class="bd b gy z fp ol fr fs om fu fw dk translated">用Python代码介绍蒙特卡罗模拟。</h3></div><div class="oo l"><p class="bd b dl z fp ol fr fs om fu fw dk translated">medium.com</p></div></div><div class="op l"><div class="ow l or os ot op ou ks og"/></div></div></a></div></div></div>    
</body>
</html>