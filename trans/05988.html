<html>
<head>
<title>Clustering on numerical and categorical features.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于数字和类别特征的聚类。</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/clustering-on-numerical-and-categorical-features-6e0ebcf1cbad?source=collection_archive---------0-----------------------#2021-05-29">https://towardsdatascience.com/clustering-on-numerical-and-categorical-features-6e0ebcf1cbad?source=collection_archive---------0-----------------------#2021-05-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="a4cd" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/hands-on-tutorials" rel="noopener" target="_blank">实践教程</a></h2><div class=""/><div class=""><h2 id="03d8" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">在Python中使用高尔距离。</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/d80935857747206e435ee8b5c0f0f9a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*UfpKb3xWcOApcRTD"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">由<a class="ae lh" href="https://unsplash.com/@universaleye?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">蒙罗工作室</a>在<a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><h1 id="7120" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">介绍</h1><p id="30b6" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">去年，我一直在从事与客户体验(CX)相关的项目。在这些项目中，对客户数据进行机器学习(ML)和数据分析技术，以提高公司对客户的了解。最近，我集中精力寻找具有某些共同特征的不同客户群体，以便能够对他们采取特定的行动。</p><p id="c267" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">您可能已经猜到了，这个项目是通过执行<strong class="mc jd">集群实现的。</strong>对于那些不熟悉这一概念的人来说，聚类是根据一组对象或观察结果(例如，客户)的特征或属性(例如，性别、年龄、购买趋势)将它们分成不同的组(称为聚类)的任务。这种划分应该以这样的方式进行，即在同一个集群中的观测值应该尽可能地相似。此外，每个集群应该尽可能远离其他集群。[1]</p><p id="99af" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">一个主要的挑战是找到一种方法对既有分类变量又有数值变量的数据执行聚类算法。在现实世界中(尤其是在CX)，许多信息都存储在分类变量中。尽管web上有大量关于数字变量聚类的信息，但是很难找到关于混合数据类型的信息。</p><p id="477c" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">这是一项复杂的任务，对于将这种数据类型的混合与聚类算法结合使用是否合适存在很多争议。然而，我决定放手一搏，尽我所能。在这篇博客的剩余部分，我将分享我的个人经历和我所学到的东西。</p><p id="61b7" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">在接下来的章节中，我们将会看到高尔距离是什么，使用哪种聚类算法比较方便，以及它在Python中的使用示例。</p><p id="3935" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated"><strong class="mc jd">免责声明</strong>:我认为自己是一个数据科学新手，所以这篇帖子并不是要创造一个每个人都应该使用的单一而神奇的指南，而是分享我所获得的知识。我现在的主要兴趣是不断学习，所以我乐于接受批评和指正。欢迎在评论区分享你的想法！</p><h1 id="d5de" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">高尔距离</h1><p id="8ac5" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">既然我们理解了集群的含义，我想强调一下上面提到的下面这句话。</p><p id="fa9a" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated"><em class="nb">划分的方式应该是观测值</em> <strong class="mc jd"> <em class="nb">尽可能的相似</em> </strong> <em class="nb">在同一个集群</em>。</p><p id="40a5" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">如何定义不同客户之间的<strong class="mc jd">相似度</strong>？在只有数字特征的情况下，解决方案看起来很直观，因为我们都知道55岁的客户更像45岁的人，而不是25岁的人。有许多方法可以测量这些距离，尽管这些信息超出了本文的范围。</p><p id="d7e7" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">但是，如果我们不仅知道他们的年龄，还知道他们的<em class="nb">婚姻状况</em>(例如，单身、已婚、离婚……)呢？这种分类特征可以通过使用诸如插补、标签编码、一键编码等技术转换成数字特征……然而，这些转换可能导致聚类算法误解这些特征并产生无意义的聚类。例如，如果我们在<em class="nb">婚姻状况</em>特征上使用标签编码技术，我们将获得以下编码特征:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/12577c6cad2a54d0102f09cfefb4055c.png" data-original-src="https://miro.medium.com/v2/resize:fit:994/format:webp/1*NkQGBcuabLReEtw6m5Ph_Q.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">应用于婚姻状况特征的标签编码技术</p></figure><p id="5be5" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">这种转换的问题是，聚类算法可能会认为一个<em class="nb">单身</em>值更类似于<em class="nb">已婚</em> ( <em class="nb">已婚</em>[2】–<em class="nb">单身</em> [1]=1)，而不是<em class="nb">离异</em> ( <em class="nb">离异</em>[3】–<em class="nb">单身</em> [1]=2)。如图所示，转换特征可能不是最佳方法。</p><p id="2073" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">这就是高尔距离(衡量相似性或不相似性)发挥作用的地方。<strong class="mc jd">高尔相似性(GS) </strong>最早是由J. C .高尔在1971年定义的[2]。为了计算观察结果<em class="nb"> i </em>和<em class="nb"> j </em>(例如，两个客户)之间的相似性，将<em class="nb"> GS </em>计算为观察结果的<em class="nb"> m </em>特征之间的部分相似性的平均值(<em class="nb"> ps </em>)。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/d7dde9764a4f186856196c5d1637b913.png" data-original-src="https://miro.medium.com/v2/resize:fit:510/format:webp/1*52oB5M2_nl2_nSHkOTFNag.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">观察值I和j之间的相似性。每个观察值都有m个不同的特征，或者是数字的，或者是分类的，或者是混合的。</p></figure><p id="4af3" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">部分相似性的计算取决于被比较的特征的类型。</p><ul class=""><li id="d648" class="ne nf it mc b md mw mg mx mj ng mn nh mr ni mv nj nk nl nm bi translated">对于一个<strong class="mc jd">数字特征</strong>、<strong class="mc jd">、</strong>来说，两个个体<em class="nb"> i </em>和<em class="nb"> j </em>之间的部分相似性是一减去他们在特定特征中的值(绝对值)之间的差除以该特征的总范围。</li></ul><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/1d674481f606ca79829409a969153b26.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/format:webp/1*2O1dq9Paf0o0cT3JF4zH_w.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">当f是数值时，特征f中观察值I和j之间的相似性。</p></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi no"><img src="../Images/2da07ff6fa7dd952b80f5de96730c8c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:502/format:webp/1*S6VbmTrUeQRKdkYkBoozvw.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">特征f的范围</p></figure><ul class=""><li id="e893" class="ne nf it mc b md mw mg mx mj ng mn nh mr ni mv nj nk nl nm bi translated">对于一个<strong class="mc jd">分类</strong>特征，两个个体之间的部分相似性只有在两个观察值完全相同时才为1。否则为零。</li></ul><p id="5194" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">部分相似度的范围总是从0到1。因此，当我们计算部分相似性的平均值来计算GS时，我们总是得到一个从0到1不等的结果。零表示观测值尽可能不同，一表示完全相等。</p><p id="5ccd" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">由于这些发现，当存在分类变量和数字变量的混合时，我们可以测量两个观察值之间的相似程度。然而，在进入细节之前，我们必须小心谨慎，并考虑到某些方面，这些方面可能会影响该距离与聚类算法的结合使用。</p><h2 id="c74b" class="np lj it bd lk nq nr dn lo ns nt dp ls mj nu nv lu mn nw nx lw mr ny nz ly iz bi translated">高尔距离的数学性质</h2><p id="848a" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">关于交叉验证，我强烈推荐阅读两个问题:</p><ul class=""><li id="c5ab" class="ne nf it mc b md mw mg mx mj ng mn nh mr ni mv nj nk nl nm bi translated"><a class="ae lh" href="https://stats.stackexchange.com/questions/22212/gowers-dissimilarity-index" rel="noopener ugc nofollow" target="_blank">高尔的相异指数</a></li><li id="7743" class="ne nf it mc b md oa mg ob mj oc mn od mr oe mv nj nk nl nm bi translated"><a class="ae lh" href="https://stats.stackexchange.com/questions/15287/hierarchical-clustering-with-mixed-type-data-what-distance-similarity-to-use" rel="noopener ugc nofollow" target="_blank">混合类型数据的层次聚类——使用什么距离/相似度？</a></li></ul><p id="81d9" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">两者都将<strong class="mc jd">高尔相似度</strong> (GS) <strong class="mc jd">定义为非欧几里得和非公制的</strong>。<strong class="mc jd">高尔相异度</strong> (GD = 1 — GS)与GS有相同的局限性，所以它<strong class="mc jd">也是非欧非度</strong>。然而，定义为√GD的高尔相异度实际上是一个欧几里德距离(因此是自动度量的)，当没有使用特殊处理的序数变量时(如果你对此感兴趣，你应该看看<a class="ae lh" href="https://www.researchgate.net/publication/271789313_Extending_Gower's_General_Coefficient_of_Similarity_to_Ordinal_Characters" rel="noopener ugc nofollow" target="_blank"> Podani如何将高尔扩展到序数字符</a></p><p id="bce1" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">这很重要，因为如果我们使用GS或GD，我们使用的距离不符合欧几里德几何。因此，不得使用基于欧几里德距离的方法，因为一些聚类方法:</p><ul class=""><li id="8aba" class="ne nf it mc b md mw mg mx mj ng mn nh mr ni mv nj nk nl nm bi translated">k均值</li><li id="d429" class="ne nf it mc b md oa mg ob mj oc mn od mr oe mv nj nk nl nm bi translated">层次聚类的沃德法、形心法、中位数法</li><li id="bd5f" class="ne nf it mc b md oa mg ob mj oc mn od mr oe mv nj nk nl nm bi">…</li></ul><h1 id="a9d0" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">编程语言中的高尔距离</h1><h2 id="2b02" class="np lj it bd lk nq nr dn lo ns nt dp ls mj nu nv lu mn nw nx lw mr ny nz ly iz bi translated">R或Python中的相关工作</h2><p id="0cf5" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">现在，我们可以在R或Python中使用这个度量来执行聚类吗？关于R，我发现了一系列非常有用的帖子，通过一个叫做<a class="ae lh" href="https://www.rdocumentation.org/packages/cluster/versions/2.1.2/topics/daisy" rel="noopener ugc nofollow" target="_blank"> <em class="nb">雏菊</em> </a> <em class="nb"> : </em>的函数，教你如何使用这个距离度量</p><ul class=""><li id="60c6" class="ne nf it mc b md mw mg mx mj ng mn nh mr ni mv nj nk nl nm bi translated">混合类型数据的聚类:一种使用R 的建议方法。</li><li id="01ee" class="ne nf it mc b md oa mg ob mj oc mn od mr oe mv nj nk nl nm bi translated"><a class="ae lh" href="https://medium.com/@rumman1988/clustering-categorical-and-numerical-datatype-using-gower-distance-ab89b3aa90d9" rel="noopener">使用高尔距离</a>聚类分类和数值数据类型。</li><li id="1e19" class="ne nf it mc b md oa mg ob mj oc mn od mr oe mv nj nk nl nm bi translated"><a class="ae lh" rel="noopener" target="_blank" href="/hierarchical-clustering-on-categorical-data-in-r-a27e578f2995">R</a>中分类数据的层次聚类(仅具有分类特征)。</li></ul><p id="5e2c" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">但是，我还没有找到用Python实现它的具体指南。这就是为什么我决定写这个博客，并试图给社区带来一些新的东西。原谅我，如果目前有一个具体的博客，我错过了。</p><h2 id="952e" class="np lj it bd lk nq nr dn lo ns nt dp ls mj nu nv lu mn nw nx lw mr ny nz ly iz bi translated">Python中的高尔距离</h2><p id="39c4" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">首先，很重要的一点是，目前我们还不能在scikit-learn提供的聚类算法中包含这个距离度量。这是自2015年以来scikit-learn的GitHub上的一个<a class="ae lh" href="https://github.com/scikit-learn/scikit-learn/issues/5884" rel="noopener ugc nofollow" target="_blank">开放问题</a>。然而，自2017年以来，由<a class="ae lh" href="https://github.com/marcelobeckmann" rel="noopener ugc nofollow" target="_blank"> Marcelo Beckmann </a>领导的一组社区成员一直致力于高尔距离的实施。希望它能很快在图书馆内使用。</p><p id="392b" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">在这个过程中，另一位名叫Michael Yan的开发人员显然使用了Marcelo Beckmann的代码创建了一个名为<a class="ae lh" href="https://pypi.org/project/gower/" rel="noopener ugc nofollow" target="_blank"><strong class="mc jd"><em class="nb">gower</em></strong></a><em class="nb"/>的非scikit-learn包，该包已经可以使用，而无需等待scikit-learn社区昂贵且必要的验证过程。<strong class="mc jd">注意，这个实现使用了高尔相异度(GD)。</strong></p><h1 id="af68" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">动手实施</h1><h2 id="bd30" class="np lj it bd lk nq nr dn lo ns nt dp ls mj nu nv lu mn nw nx lw mr ny nz ly iz bi translated">数据</h2><p id="fea3" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">当我学习新的算法或方法时，我真的喜欢在非常小的数据集中看到结果，这样我就可以专注于细节。因此，对于实现，我们将使用一个小的合成数据集，其中包含关于杂货店客户的虚构信息。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="of og l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">创建熊猫数据帧的Python代码</p></figure><p id="a8c3" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">创建的数据有10个客户和6个特征:</p><ul class=""><li id="9b8a" class="ne nf it mc b md mw mg mx mj ng mn nh mr ni mv nj nk nl nm bi translated"><strong class="mc jd">年龄</strong>:数字</li><li id="9400" class="ne nf it mc b md oa mg ob mj oc mn od mr oe mv nj nk nl nm bi translated">性别:分类</li><li id="8f2e" class="ne nf it mc b md oa mg ob mj oc mn od mr oe mv nj nk nl nm bi translated"><strong class="mc jd">公民身份</strong>:绝对身份</li><li id="d8fd" class="ne nf it mc b md oa mg ob mj oc mn od mr oe mv nj nk nl nm bi translated"><strong class="mc jd">薪资</strong>:数字</li><li id="62c7" class="ne nf it mc b md oa mg ob mj oc mn od mr oe mv nj nk nl nm bi translated">客户有孩子吗？:二进制</li><li id="6252" class="ne nf it mc b md oa mg ob mj oc mn od mr oe mv nj nk nl nm bi translated"><strong class="mc jd">购买者类型</strong>:分类</li></ul><p id="35d7" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">所有信息如下所示:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oh"><img src="../Images/8d2313407d73b9138db973264a2fb0d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*npOGZI3pES1feAqFFHJ8oA.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">客户综合数据</p></figure><h2 id="d85b" class="np lj it bd lk nq nr dn lo ns nt dp ls mj nu nv lu mn nw nx lw mr ny nz ly iz bi translated">高尔距离</h2><p id="1cd5" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">现在，是时候使用之前提到的<a class="ae lh" href="https://pypi.org/project/gower/" rel="noopener ugc nofollow" target="_blank"> <em class="nb">高尔包</em> </a>来计算不同客户之间的所有距离了。让我们手动做第一个，并且<strong class="mc jd">记住这个包正在计算高尔相异度(DS) </strong>。所以计算的方式有点变化。</p><ul class=""><li id="a021" class="ne nf it mc b md mw mg mx mj ng mn nh mr ni mv nj nk nl nm bi translated">对于一个<strong class="mc jd">数字</strong>特征，<strong class="mc jd"> </strong>两个客户<em class="nb"> i </em>和<em class="nb"> j </em>之间的部分相异度是它们在特定特征中的值(绝对值)的差除以该特征的总范围。<em class="nb">工资</em>的范围是52000(70000–18000)，而<em class="nb">年龄</em>的范围是68(90–22)。注意<strong class="mc jd">在这些特性中没有异常值</strong>的重要性。一个非常大或非常小的错误值将直接影响范围，因此该特征的差异将变得不那么重要。</li><li id="b06a" class="ne nf it mc b md oa mg ob mj oc mn od mr oe mv nj nk nl nm bi translated">对于一个<strong class="mc jd">分类</strong>特征，当两个客户对此特征具有不同的值时，两个客户之间的部分不相似性为1。否则为零。</li></ul><p id="ebfa" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">按照这个过程，我们计算前两个客户的所有部分差异。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oi"><img src="../Images/bd19cbf5e030b7652243473f11961155.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WHBLW14NuzNdvT3k8z9ezA.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">计算前两个客户的部分差异</p></figure><p id="bd98" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">两个客户之间的高尔相异度是沿着不同特征的部分相异度的平均值:(0.044118+0+0+0.096154+0+0)/6 = 0.023379。由于值接近于零，我们可以说这两个客户非常相似。</p><p id="6b85" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">让我们使用<a class="ae lh" href="https://pypi.org/project/gower/" rel="noopener ugc nofollow" target="_blank"> <em class="nb">高尔包</em> </a>来计算客户之间的所有差异。然后，将结果存储在一个矩阵中:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="of og l"/></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oj"><img src="../Images/c499b8a7c8b9599d550443dbd9b398bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FFMH3SCKmpF3COLu6ZSA0w.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">距离矩阵</p></figure><p id="186b" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">我们可以这样解释这个矩阵。在第一列中，我们看到了第一个客户与所有其他客户的不同之处。由于GD较低，该客户与第二、第三和第六位客户相似。</p><h2 id="f696" class="np lj it bd lk nq nr dn lo ns nt dp ls mj nu nv lu mn nw nx lw mr ny nz ly iz bi translated">对距离矩阵执行聚类</h2><p id="cbef" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">我们刚刚看到的矩阵可以用于几乎任何scikit-learn聚类算法。然而，我们必须记住高尔距离的局限性，因为它既不是欧几里得距离，也不是公制距离。</p><p id="71ab" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">要在scikit-learn聚类算法中使用Gower，我们必须在所选方法的文档中查找直接传递距离矩阵的选项。虽然参数的名称可以根据算法的不同而改变，但我们几乎总是应该将值<em class="nb">预先计算好</em>，所以我建议去算法的文档中查找这个单词。</p><p id="aa83" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">在本文中，我们将使用<strong class="mc jd"> DBSCAN </strong>(带噪声应用的基于密度的空间聚类)算法。理解算法超出了本文的范围，因此我们不会深入讨论细节。我在这里留下了<a class="ae lh" href="https://scikit-learn.org/stable/modules/clustering.html#dbscan" rel="noopener ugc nofollow" target="_blank">算法</a>背后理论的链接，以及一个直观解释其基本功能的gif。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ok og l"/></div></figure><p id="cdd0" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">这里我们有代码，在这里我们定义了集群算法，并对其进行配置，以使要使用的指标为“<em class="nb">预计算</em>”。拟合算法时，我们将引入已计算的距离矩阵，而不是将数据集与数据一起引入。此外，我们将集群的结果添加到原始数据中，以便能够解释结果。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="b98b" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">最终结果如下:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ol"><img src="../Images/407b7a341ba9fd78b0ba2f5725a53d6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Uqu6nhccWwxdD8P77vJeiA.png"/></div></div></figure><p id="8b8b" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">如果我们分析不同的集群，我们会发现:</p><ul class=""><li id="16e1" class="ne nf it mc b md mw mg mx mj ng mn nh mr ni mv nj nk nl nm bi translated"><strong class="mc jd">集群0(绿色):</strong>工资在18，000至27，000英镑之间，没有孩子并且很少购买的客户。</li><li id="46cd" class="ne nf it mc b md oa mg ob mj oc mn od mr oe mv nj nk nl nm bi translated"><strong class="mc jd">第1组(蓝色):</strong>收入约3.3万英镑、经常购物的40多岁母亲。</li><li id="bdc8" class="ne nf it mc b md oa mg ob mj oc mn od mr oe mv nj nk nl nm bi translated"><strong class="mc jd">第2组(红色):</strong>60多岁的男性，中等购买量，无子女</li><li id="7f65" class="ne nf it mc b md oa mg ob mj oc mn od mr oe mv nj nk nl nm bi translated"><strong class="mc jd"> Cluster -1: </strong>这不是集群本身，而是被算法识别为异常值的客户。它无法在任何集群中识别。</li></ul><p id="7b03" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">通过这些结果，我们可以了解客户所划分的不同群体。因此，我们可以对它们执行特定的动作，例如个性化的广告活动、针对特定群体的要约……的确，这个示例非常小，并且被设置为具有成功的集群，实际的项目要复杂得多并且花费时间来实现显著的结果。</p><h1 id="053b" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">结论</h1><p id="7d57" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">本文提出了一种在Python中使用Gower距离执行聚类的方法。它还暴露了距离度量本身的局限性，因此可以正确使用。最后，这个小例子证实了以这种方式开发的集群是有意义的，并且可以为我们提供大量信息。</p><p id="a727" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">我希望你能发现这种方法很有用，并且你会发现这篇文章很容易阅读。最重要的是，我很高兴收到任何形式的反馈。所以，请随意分享你的想法！</p><h1 id="ef94" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">参考</h1><p id="7567" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">[1]维基百科投稿人，聚类分析(2021)，<a class="ae lh" href="https://en.wikipedia.org/wiki/Cluster_analysis" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Cluster_analysis</a></p><p id="5a9a" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">[2] J. C. Gower，<a class="ae lh" href="https://www.jstor.org/stable/2528823?origin=crossref" rel="noopener ugc nofollow" target="_blank">广义相似系数及其若干性质</a> (1971)，生物统计学</p></div></div>    
</body>
</html>