<html>
<head>
<title>Introduction to Memory Mapped IO</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">内存映射IO简介</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/introduction-to-memory-mapped-io-3540454770f7?source=collection_archive---------11-----------------------#2021-05-30">https://towardsdatascience.com/introduction-to-memory-mapped-io-3540454770f7?source=collection_archive---------11-----------------------#2021-05-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="a961" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">利用内存映射IO实现超高速并行文件写入</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/e679db099bc8756ac95e0a6e09269885.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kPhrodAAPnTBhjVyURsb4g.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/@possessedphotography?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">附身摄影</a>在<a class="ae kv" href="https://unsplash.com/s/photos/ram?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</p></figure><h1 id="8349" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">什么是内存映射文件？</h1><p id="5269" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated"><a class="ae kv" href="https://en.wikipedia.org/wiki/Memory-mapped_file" rel="noopener ugc nofollow" target="_blank">内存映射文件</a>是<strong class="lq ir">虚拟内存</strong>中的一段。虚拟内存是物理内存的抽象，由<strong class="lq ir"> <em class="mk">操作系统</em> </strong> (OS)提供给<strong class="lq ir"> <em class="mk">进程</em> </strong>。如果操作系统耗尽内存或看到某个进程长时间空闲，这些虚拟内存段将被“<strong class="lq ir">分页</strong>”到物理磁盘位置上(“<strong class="lq ir">交换</strong>”)。所以“<strong class="lq ir">交换</strong>本质上是磁盘上的那部分虚拟内存。</p><p id="bef1" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated"><strong class="lq ir">更准确地说，内存映射文件是完全由操作系统管理的虚拟内存上的部分(或全部)文件的镜像</strong>。</p><p id="3af5" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">换句话说，每当一个文件被内存映射时，操作系统会立即将文件内存映射到虚拟内存上的一个区域。你可以认为这是一些内存空间。每当操作系统将文件内容转储到磁盘(以容纳另一个任务)时，就会发生<a class="ae kv" href="https://en.wikipedia.org/wiki/Page_fault" rel="noopener ugc nofollow" target="_blank">页面错误</a>。这时操作系统会返回并将内容重新加载到RAM中。但是我们的程序将永远看不到这种变化，而是在<strong class="lq ir"> <em class="mk">内存映射IO </em> </strong>中面临偶尔的延迟。</p><blockquote class="mq"><p id="85d2" class="mr ms iq bd mt mu mv mw mx my mz mj dk translated">在本文中，我将只讨论内存映射写。下次再读！我将以一个生物信息学相关的任务作为运行实例。请随意将它转换到您自己的领域并进行尝试。</p></blockquote><h1 id="55c1" class="kw kx iq bd ky kz la lb lc ld le lf lg jw na jx li jz nb ka lk kc nc kd lm ln bi translated">内存映射文件写入的额外好处</h1><p id="526e" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">使用或不使用内存映射文件有很多理由。我只谈优点！</p><p id="5c49" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated"><strong class="lq ir">并行性:</strong>内存映射区可以认为是一个巨大的字节数组。所以你可以从尽可能多的线程中写/读。或者甚至在进程之间共享。只要不出现竞态条件。</p><p id="b756" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated"><strong class="lq ir">性能:</strong>内存映射写入通常很快，因为不使用流/文件缓冲区。操作系统执行实际的文件写入，通常一次写入几千字节的数据块。</p><blockquote class="nd ne nf"><p id="8330" class="lo lp mk lq b lr ml jr lt lu mm ju lw ng mn lz ma nh mo md me ni mp mh mi mj ij bi translated">不利的一面是，除非你按顺序写，否则可能会有页面错误减缓你的程序。</p></blockquote><h1 id="7e02" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">开始编码吧！</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nj"><img src="../Images/22db01d78781dd7d507dabac5c4eb7ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*odXy8TQi3XXeF6KA5GFuwQ.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@ricaros?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">丹尼尔·伊德里</a>在<a class="ae kv" href="https://unsplash.com/s/photos/programming?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="47b4" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">在这个例子中，我们的任务如下:</p><p id="b9b9" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated"><em class="mk">给定100万个DNA序列，将其矢量化，并以文本形式写入，用于未来的机器学习任务。注意，每个向量具有136维的固定大小，并且使用函数</em> <code class="fe nk nl nm nn b"><em class="mk">vectorize(sequence)</em></code> <em class="mk">来获得，因为它是如何完成的并不相关。为了使它更有趣，让我们从单线程的常规文件写入开始，逐步改进我们的程序。</em></p><h2 id="496a" class="no kx iq bd ky np nq dn lc nr ns dp lg lx nt nu li mb nv nw lk mf nx ny lm nz bi translated">单线程操作</h2><p id="95c6" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">我们将简单地读取序列并进行矢量化。得到的向量将被转换成一个字符串，并写到输出缓冲区。概要C++代码可在<a class="ae kv" href="https://gist.github.com/anuradhawick/b80513dfb7f555f68d73698151acfe4e" rel="noopener ugc nofollow" target="_blank">这里</a>获得。</p><pre class="kg kh ki kj gt oa nn ob oc aw od bi"><span id="9fc3" class="no kx iq nn b gy oe of l og oh">while (seq := has_sequence(input_file))<br/>    vector := vectorize(seq)<br/>    output &lt;&lt; to_string(vector)</span></pre><h2 id="a836" class="no kx iq bd ky np nq dn lc nr ns dp lg lx nt nu li mb nv nw lk mf nx ny lm nz bi translated">多线程操作</h2><p id="42fc" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">在多线程操作中，我们需要确保输出和输入的顺序相同。否则，我们可能会忘记哪个数据点是哪个数据点。因此，我将使用一个数据队列进行读取，并使用一个消费者进行批处理和并行处理。这两个过程是异步发生，因此队列总是满的。</p><pre class="kg kh ki kj gt oa nn ob oc aw od bi"><span id="8bd0" class="no kx iq nn b gy oe of l og oh">Queue = {}</span><span id="e4d2" class="no kx iq nn b gy oi of l og oh">thread_1<br/>while (seq := has_sequence(input_file) and Queue.size() &lt; 20000)<br/>    Queue := Queue + seq</span><span id="be88" class="no kx iq nn b gy oi of l og oh">thread_2<br/>while Queue.size() != 0<br/>    batch := dequeue(Queue, 10000 items)<br/>    batch_vectors := vectorize_batch(batch)<br/>    output &lt;&lt; to_string(batch_vectors)</span></pre><p id="e616" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">注意，为了清楚起见，我省略了互斥和其他细粒度的同步技巧。概要C++代码可在<a class="ae kv" href="https://gist.github.com/anuradhawick/222c1024972d9a10ea32deeb09847a91" rel="noopener ugc nofollow" target="_blank">这里</a>获得。我使用了条件变量来访问队列和终止线程。</p><h2 id="ec36" class="no kx iq bd ky np nq dn lc nr ns dp lg lx nt nu li mb nv nw lk mf nx ny lm nz bi translated">存储器映射操作</h2><p id="807f" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">关于内存映射操作，有一些事情需要记住。当创建一个新的内存映射文件时，我们必须指定一个大小。这是因为我们不能动态地增加操作系统分配给我们的区域(我们可以通过复制来增加大小，比如调整数组大小。这可能非常慢)。因此，我们需要对总产出规模有一个概念。这对我们来说很容易，因为我们知道向量的大小。我们还可以通过在数据集上快速迭代一次来获得数据项的总数。所以我们的代码如下:</p><pre class="kg kh ki kj gt oa nn ob oc aw od bi"><span id="d1f0" class="no kx iq nn b gy oe of l og oh">num_sequences := iterate_once_get_seqs()<br/>vector_size := 136<br/>float_size := 8 <br/>size_of_line := vector_size * (float_size + 1)<br/>size_of_file := size_of_line * num_sequences<br/>mmap_file := mmap.open(output, size_of_file, write_mode)</span></pre><p id="ab92" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">请注意，此时我们已经创建了一个内存映射文件。我们固定了浮点值的长度(要么填充零，要么截断十进制精度)。让我们在以固定宽度方式书写时变得容易。</p><pre class="kg kh ki kj gt oa nn ob oc aw od bi"><span id="a272" class="no kx iq nn b gy oe of l og oh">vectorize_function:<br/>   lock(mutex)<br/>   seq := has_sequence(input_file)<br/>   unlock(mutex)<br/>   if (seq):<br/>       vec := vectorize(seq)<br/>       mmapfile.write(<strong class="nn ir">offset</strong>, to_string(vec))</span><span id="0382" class="no kx iq nn b gy oi of l og oh">thread_pool(many threads)</span><span id="d967" class="no kx iq nn b gy oi of l og oh">for _ in range(num workers)<br/>    thread_pool.add_worker(vectorize_function, mmapfile)</span></pre><p id="d16f" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">注意，我们有一个<strong class="lq ir">偏移</strong>参数。这可以通过下面的等式获得:</p><pre class="kg kh ki kj gt oa nn ob oc aw od bi"><span id="5411" class="no kx iq nn b gy oe of l og oh">offset := size_of_line * sequence_id</span></pre><p id="0576" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">序列id是数据集中从零开始的序列的索引。我们将把内存映射文件指针从开始增加到偏移量，并在该偏移量处复制字符串向量。操作系统会处理剩下的事情。</p><blockquote class="nd ne nf"><p id="9016" class="lo lp mk lq b lr ml jr lt lu mm ju lw ng mn lz ma nh mo md me ni mp mh mi mj ij bi translated">注意，我们在文件读取时只有一个互斥体！不再有阻塞的调用或序列的批处理。</p></blockquote><h1 id="4962" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">每种方法的性能</h1><p id="32af" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">我使用了<code class="fe nk nl nm nn b">/usr/bin/time -v program.o</code>命令来获得每种方法使用的CPU和Wall时间。结果如下。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oj"><img src="../Images/c9ee929847ab2fc52e07a84e7ec46dd2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6RMezbwLN6yy0u5YrdqVGw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="2592" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">请注意，CPU使用率从80%增加到了420%。它几乎是批处理多线程方法的两倍。CPU时间几乎保持不变，因为我们要做的计算量大致相同。墙壁时间减少到四分之一。然而，由于操作系统将内存映射文件保存在RAM中，RAM的使用从2MB增加到了近1GB。因为我有足够的内存，操作系统似乎一直在内存中维护文件。使用linux <code class="fe nk nl nm nn b">diff</code>命令验证了结果。</p><p id="9078" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">我们几乎用光了我电脑的全部4个内核！这是一个胜利！也节省了很多时间。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ok"><img src="../Images/728b7411cfe0c6f22b3789d95b2989c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k3ucbwWRlCQzg4T6DkACZw.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">由<a class="ae kv" href="https://unsplash.com/@goumbik?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">卢卡斯·布拉塞克</a>在<a class="ae kv" href="https://unsplash.com/s/photos/time?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><h1 id="a69e" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">结束语</h1><p id="798d" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">我们可以通过使用各种其他技巧(比如使用内存映射来读取文件)来进一步优化这个程序。然而，收益是以额外的工作和编码为代价的。在这个例子中，我使用了C++ Boost库(<code class="fe nk nl nm nn b">#include &lt;boost/iostreams/device/mapped_file.hpp&gt;</code>)。Boost有一个可移植的内存映射扩展，它可以帮助你忘记你运行的平台。</p><p id="1526" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">Python也有类似的实现(参考<a class="ae kv" href="https://docs.python.org/3/library/mmap.html" rel="noopener ugc nofollow" target="_blank">文档</a>)。因此，即使对于python程序员来说，这也应该相当简单。</p><p id="21fc" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">我希望你喜欢阅读这篇文章，并相信这些知识将有助于编写更好更快的程序。在下面找到完整的项目(面向生物信息学家)；</p><div class="ol om gp gr on oo"><a href="https://github.com/anuradhawick/seq2vec" rel="noopener  ugc nofollow" target="_blank"><div class="op ab fo"><div class="oq ab or cl cj os"><h2 class="bd ir gy z fp ot fr fs ou fu fw ip bi translated">anuradhawick/seq2vec</h2><div class="ov l"><h3 class="bd b gy z fp ot fr fs ou fu fw dk translated">该工具旨在用于生物信息学机器学习相关任务中的数据生成。你可以用…</h3></div><div class="ow l"><p class="bd b dl z fp ot fr fs ou fu fw dk translated">github.com</p></div></div><div class="ox l"><div class="oy l oz pa pb ox pc kp oo"/></div></div></a></div><p id="17b1" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">祝您愉快！😃</p></div></div>    
</body>
</html>