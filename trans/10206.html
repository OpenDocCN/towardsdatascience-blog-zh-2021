<html>
<head>
<title>Graph Neural Networks: A learning journey since 2008 — Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">图形神经网络:2008年以来的学习之旅——第二部分</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/graph-neural-networks-a-learning-journey-since-2008-part-2-22dbf7a3b0d?source=collection_archive---------34-----------------------#2021-09-27">https://towardsdatascience.com/graph-neural-networks-a-learning-journey-since-2008-part-2-22dbf7a3b0d?source=collection_archive---------34-----------------------#2021-09-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="531b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">关于斯卡塞利图形神经网络的第二个故事。今天，让我们来实现我们所学的:Python中的GNN</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/b6868d69524fb205460b24bf9074a398.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yXbSt1AQh2OgRSz3E2_UjQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">布雷迪·贝里尼在<a class="ae ky" href="https://unsplash.com/photos/WEQbe2jBg40" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><div class="kz la gp gr lb lc"><a href="https://medium.com/@stefanobosisio1/membership" rel="noopener follow" target="_blank"><div class="ld ab fo"><div class="le ab lf cl cj lg"><h2 class="bd iu gy z fp lh fr fs li fu fw is bi translated">通过我的推荐链接加入Medium-Stefano Bosisio</h2><div class="lj l"><h3 class="bd b gy z fp lh fr fs li fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="lk l"><p class="bd b dl z fp lh fr fs li fu fw dk translated">medium.com</p></div></div><div class="ll l"><div class="lm l ln lo lp ll lq ks lc"/></div></div></a></div><p id="482f" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我们在本系列的第一部分<a class="ae ky" rel="noopener" target="_blank" href="/graph-neural-networks-a-learning-journey-since-2008-part-1-7df897834df9">中学习了斯卡塞利图形神经网络的理论背景。特别是，我们了解到:</a></p><ul class=""><li id="f0ee" class="mn mo it lt b lu lv lx ly ma mp me mq mi mr mm ms mt mu mv bi translated">GNN既适合基于节点的预测，也适合基于图的预测。在前一种情况下，我们希望预测图中的每个节点，在后一种情况下，我们希望预测整个图</li><li id="8dd4" class="mn mo it lt b lu mw lx mx ma my me mz mi na mm ms mt mu mv bi translated">每个节点可以用一个转移函数<em class="nb"> f𝓌 </em>和一个输出函数<em class="nb"> g𝓌 </em>来表示。</li><li id="2005" class="mn mo it lt b lu mw lx mx ma my me mz mi na mm ms mt mu mv bi translated">为了收敛到一个解，转移函数和输出函数都必须满足Banach的不动点解</li><li id="d1ae" class="mn mo it lt b lu mw lx mx ma my me mz mi na mm ms mt mu mv bi translated">多层感知器(MLP)确实满足巴拿赫的要求，因此<em class="nb"> f𝓌 </em>和<em class="nb"> g𝓌 </em>可以实现为简单的神经网络层</li></ul><p id="9905" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">记住这几点，让我们一步一步地看看如何用Python实现这个框架，并把它应用到一个简单的问题上，这个问题叫做“空手道俱乐部”。</p><h1 id="fe28" class="nc nd it bd ne nf ng nh ni nj nk nl nm jz nn ka no kc np kd nq kf nr kg ns nt bi translated">空手道俱乐部</h1><p id="0500" class="pw-post-body-paragraph lr ls it lt b lu nu ju lw lx nv jx lz ma nw mc md me nx mg mh mi ny mk ml mm im bi translated">我们以扎卡里的空手道俱乐部问题为例。这个问题可以追溯到Zachary的论文“小群体中冲突和裂变的信息流模型”[29]，其中对一个空手道俱乐部网络进行了三年(1970–1972)的研究。该网络由34名成员组成，包括空手道俱乐部管理员“约翰A”和教练“嗨先生”，以及在俱乐部外互动的成对成员之间的联系(他们聚在一起喝啤酒，散步……)。在管理者和指导者之间的一场争论之后，俱乐部分裂成两半，因此两个新的组被创建。扎卡里用福特-富尔克森算法正确预测了成员如何重新安排他们的社交网络/每个成员的决定。这个问题引起了图形爱好者社区的注意，它被广泛用于测试GraphNN。斯卡塞利2009年的论文应用图形神经网络正确预测了空手道俱乐部成员在分裂后的决策。</p><h2 id="ce95" class="nz nd it bd ne oa ob dn ni oc od dp nm ma oe of no me og oh nq mi oi oj ns ok bi translated">Github回购和安装</h2><p id="9119" class="pw-post-body-paragraph lr ls it lt b lu nu ju lw lx nv jx lz ma nw mc md me nx mg mh mi ny mk ml mm im bi translated">主要脚本存储在此存储库中:</p><div class="kz la gp gr lb lc"><a href="https://github.com/Steboss/learn_graph_ml/tree/master/Scarselli_GNN" rel="noopener  ugc nofollow" target="_blank"><div class="ld ab fo"><div class="le ab lf cl cj lg"><h2 class="bd iu gy z fp lh fr fs li fu fw is bi translated">大师ste boss/learn _ graph _ ml/斯卡塞利_GNN</h2><div class="lj l"><h3 class="bd b gy z fp lh fr fs li fu fw dk translated">从2009年到现在的一次长途旅行，在ste boss/learn _ graph _ ml/Scarselli _ GNN大师课上学习图表</h3></div><div class="lk l"><p class="bd b dl z fp lh fr fs li fu fw dk translated">github.com</p></div></div><div class="ll l"><div class="ol l ln lo lp ll lq ks lc"/></div></div></a></div><p id="2661" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在继续之前，我建议您在一个工作目录中创建一个虚拟环境(只需输入您的终端<code class="fe om on oo op b">python -m venv venv</code>，就会创建一个<code class="fe om on oo op b">venv</code>文件夹)。然后，您可以安装这些软件包:</p><ul class=""><li id="cf89" class="mn mo it lt b lu lv lx ly ma mp me mq mi mr mm ms mt mu mv bi translated"><code class="fe om on oo op b">dgl</code>是Deep Graph Library，一个专门从事图形计算的库。在培训步骤中，我们将使用它来可视化我们的图表。要安装<code class="fe om on oo op b">dgl</code>，请在此页面插入您的硬件信息:<a class="ae ky" href="https://www.dgl.ai/pages/start.html" rel="noopener ugc nofollow" target="_blank">https://www.dgl.ai/pages/start.html</a>(例如<code class="fe om on oo op b">None</code> CUDA、<code class="fe om on oo op b">Pip(stable)</code>包、<code class="fe om on oo op b">Mac</code> Os和<code class="fe om on oo op b">Python 3.8</code>版本，这样我就可以用下面的命令<code class="fe om on oo op b">pip install dgl -f https://data.dgl.ai/wheels/repo.html)</code>安装<code class="fe om on oo op b">dgl</code>。如果您在使用<code class="fe om on oo op b">pip</code>时遇到问题，只需使用<code class="fe om on oo op b">pip install --upgrade pip</code>进行升级，一切都会正常工作。</li><li id="a667" class="mn mo it lt b lu mw lx mx ma my me mz mi na mm ms mt mu mv bi translated"><code class="fe om on oo op b">pip install torch</code></li><li id="ac75" class="mn mo it lt b lu mw lx mx ma my me mz mi na mm ms mt mu mv bi translated"><code class="fe om on oo op b">pip install tensorflow</code></li><li id="7a06" class="mn mo it lt b lu mw lx mx ma my me mz mi na mm ms mt mu mv bi translated"><code class="fe om on oo op b">pip install matplotlib</code></li><li id="d5dc" class="mn mo it lt b lu mw lx mx ma my me mz mi na mm ms mt mu mv bi translated"><code class="fe om on oo op b">pip install seaborn</code></li></ul><h2 id="ec77" class="nz nd it bd ne oa ob dn ni oc od dp nm ma oe of no me og oh nq mi oi oj ns ok bi translated">脚本和图形介绍</h2><p id="e46d" class="pw-post-body-paragraph lr ls it lt b lu nu ju lw lx nv jx lz ma nw mc md me nx mg mh mi ny mk ml mm im bi translated">正如你在Github repo中看到的，有几个脚本。以下是对它们的简单描述:</p><ul class=""><li id="b14d" class="mn mo it lt b lu lv lx ly ma mp me mq mi mr mm ms mt mu mv bi translated"><code class="fe om on oo op b">create_and_visualize.py</code>允许创建初始图形并在训练期间绘制图形</li><li id="38d4" class="mn mo it lt b lu mw lx mx ma my me mz mi na mm ms mt mu mv bi translated"><code class="fe om on oo op b">prepare_edge_nodes_mat.py</code>提供了边、标签和节点的特征。创建两个矩阵:<code class="fe om on oo op b">E</code>边矩阵和图形id，<code class="fe om on oo op b">N</code>节点特征矩阵和图形id</li><li id="0ed0" class="mn mo it lt b lu mw lx mx ma my me mz mi na mm ms mt mu mv bi translated"><code class="fe om on oo op b">prepare_GNN.py</code>变换<code class="fe om on oo op b">E</code>和<code class="fe om on oo op b">N</code>矩阵作为图形神经网络的输入。输出是一个<code class="fe om on oo op b">inp</code>矩阵，其形式为<code class="fe om on oo op b">[source_node, destination_node, features of the source node, features of the destination node]</code>和<code class="fe om on oo op b">arcnode</code>矩阵，一个稀疏矩阵，节点之间有边连接，例如<code class="fe om on oo op b">[source_node, destination_node, 1 at source index position 0 otherwise]</code></li><li id="7fdf" class="mn mo it lt b lu mw lx mx ma my me mz mi na mm ms mt mu mv bi translated"><code class="fe om on oo op b">input_and_output_funcitons.py</code>定义了<em class="nb"> f𝓌 </em>和<em class="nb"> g𝓌 </em>神经网络，以及验证指标和损失</li><li id="dd4f" class="mn mo it lt b lu mw lx mx ma my me mz mi na mm ms mt mu mv bi translated"><code class="fe om on oo op b">GNN.py</code>主图形神经网络类，其中定义了训练条件，以及收敛性检查。最终输出是训练损失、节点预测、节点在训练期间的位置以及收敛的迭代次数。</li><li id="cf5a" class="mn mo it lt b lu mw lx mx ma my me mz mi na mm ms mt mu mv bi translated"><code class="fe om on oo op b">karate.py</code>是主脚本，创建空手道数据集并训练GNN。</li></ul><p id="ca52" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">作为第一步，我们可以运行<code class="fe om on oo op b">create_and_visualize.py</code>来可视化空手道俱乐部图。您可以在一个<code class="fe om on oo op b">ipyhton</code> shell中运行这个脚本:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图1:在Python shell中，只需输入上面的命令就可以显示输入的空手道俱乐部图</p></figure><p id="9305" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">该图是通过<code class="fe om on oo op b">build_karate_club_graph()</code>函数中的<code class="fe om on oo op b">dgl.DGLGraph()</code>创建的。<code class="fe om on oo op b">visualize_karate_club()</code>通过转换输入图<code class="fe om on oo op b">to_networkx()</code>产生输出(图2)</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi os"><img src="../Images/ec6d89e57e5f9411c11b7dc98b6cf04b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pY_uf0p6oc-XZbDU1Igw2g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图2:作为图表的空手道俱乐部。该俱乐部由34个人组成，在分裂后，他们决定根据自己的特点分成两组。</p></figure><h2 id="1218" class="nz nd it bd ne oa ob dn ni oc od dp nm ma oe of no me og oh nq mi oi oj ns ok bi translated">图解说明</h2><p id="f537" class="pw-post-body-paragraph lr ls it lt b lu nu ju lw lx nv jx lz ma nw mc md me nx mg mh mi ny mk ml mm im bi translated">图3示出了计算步骤的图形研究。从初始图创建两个矩阵:节点特征N矩阵和边矩阵e。然后这两个矩阵被转换为图神经网络的输入。特别地，矩阵e和来自矩阵n的特征被用作转移函数<em class="nb"> f𝓌 </em>的输入。这个神经网络输出与arcnode one-hot编码矩阵相乘，以更新节点的状态。最终输出用作函数<em class="nb"> g𝓌 </em>的输入，以产生最终预测</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ot"><img src="../Images/2c59db193170bbdc320d8091321d043e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ij_cj0HqGsgKzDlr6ZQ4Ug.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图3:计算方法的图示。输入图被细分为矩阵N和e。从那里，GraphNN的输入矩阵被创建。矩阵inp是边矩阵和特征的组合，而arcnode将边连接定义为一个一键编码矩阵。然后，inp矩阵被用作NN fw的输入。节点状态由matmul用arcnode矩阵更新。通过输出函数gw产生最终输出</p></figure><h2 id="059f" class="nz nd it bd ne oa ob dn ni oc od dp nm ma oe of no me og oh nq mi oi oj ns ok bi translated">1.输入预处理:边、标签和要素</h2><div class="kz la gp gr lb lc"><a href="https://github.com/Steboss/learn_graph_ml/blob/master/Scarselli_GNN/prepare_edge_nodes_mat.py" rel="noopener  ugc nofollow" target="_blank"><div class="ld ab fo"><div class="le ab lf cl cj lg"><h2 class="bd iu gy z fp lh fr fs li fu fw is bi translated">主Steboss上的learn _ graph _ ml/prepare _ edge _ nodes _ mat . py/learn _ graph _ ml</h2><div class="lj l"><h3 class="bd b gy z fp lh fr fs li fu fw dk translated">从2009年到现在的一次长途旅行，带着graphs-learn _ graph _ ml/prepare _ edge _ nodes _ mat . py在主…</h3></div><div class="lk l"><p class="bd b dl z fp lh fr fs li fu fw dk translated">github.com</p></div></div><div class="ll l"><div class="ou l ln lo lp ll lq ks lc"/></div></div></a></div><p id="125a" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated"><code class="fe om on oo op b">prepare_edge_nodes_mat.py</code>允许创建两个矩阵:边矩阵<code class="fe om on oo op b">E</code>和节点特征矩阵<code class="fe om on oo op b">N</code>。</p><p id="b5ec" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">为了创建边，我在<code class="fe om on oo op b">data/edges.txt</code>中提供了一个输入文件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图edges.txt文件的前8行，节点1的边</p></figure><p id="9f96" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">边的矩阵<code class="fe om on oo op b">E</code>是从边输入加上定义了<code class="fe om on oo op b">graph_id</code>的最后一列创建的，在这种情况下<code class="fe om on oo op b">graph_id</code>是0，因为我们想要节点聚焦的预测。如果您正在执行基于图形的预测，您将添加一个<code class="fe om on oo op b">graph_id</code>。</p><p id="4894" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">矩阵<code class="fe om on oo op b">E</code>的最终内容是<code class="fe om on oo op b">[source_node, destination_node, graph_id]</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图5:从输入边创建E矩阵并与图id值连接</p></figure><p id="ed20" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">使用<code class="fe om on oo op b">sp.eye(np.max(edges+1), dtype=np.float32).tocsr()</code>将节点的特征创建为一个热编码矩阵:</p><ul class=""><li id="df0b" class="mn mo it lt b lu lv lx ly ma mp me mq mi mr mm ms mt mu mv bi translated"><code class="fe om on oo op b">sp.eye</code>是<code class="fe om on oo op b">scipy.sparse</code>矩阵，</li><li id="f30b" class="mn mo it lt b lu mw lx mx ma my me mz mi na mm ms mt mu mv bi translated"><code class="fe om on oo op b">np.max(edges+1)</code>定义了我们想要的索引的值为1、</li><li id="caa1" class="mn mo it lt b lu mw lx mx ma my me mz mi na mm ms mt mu mv bi translated"><code class="fe om on oo op b">tocsr()</code>是压缩稀疏行格式</li></ul><p id="f350" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">将特征与<code class="fe om on oo op b">graph_id</code>连接，以创建最终节点的特征矩阵<code class="fe om on oo op b">N</code>，其内容为<code class="fe om on oo op b">[ node's features, graph_id]</code>，维度为<code class="fe om on oo op b">[number_of_nodes, number_of_nodes+1]</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图6:前3个节点的矩阵N内容</p></figure><p id="48b5" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在这种情况下，标签(0或1)被分配为:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图7:为每个节点分配标签的代码</p></figure><p id="438a" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">最后，脚本随机选取4个节点作为监督训练的标记节点。</p><h2 id="6a93" class="nz nd it bd ne oa ob dn ni oc od dp nm ma oe of no me og oh nq mi oi oj ns ok bi translated">2.从矩阵到GNN输入</h2><div class="kz la gp gr lb lc"><a href="https://github.com/Steboss/learn_graph_ml/blob/master/Scarselli_GNN/prepare_GNN.py" rel="noopener  ugc nofollow" target="_blank"><div class="ld ab fo"><div class="le ab lf cl cj lg"><h2 class="bd iu gy z fp lh fr fs li fu fw is bi translated">主ste boss/learn_graph_ml/prepare _ gnn . py上的learn _ graph _ ml</h2><div class="lj l"><h3 class="bd b gy z fp lh fr fs li fu fw dk translated">从2009年到现在的一次长途旅行，带着图表- learn_graph_ml/prepare_GNN.py在Steboss大师/learn_graph_ml</h3></div><div class="lk l"><p class="bd b dl z fp lh fr fs li fu fw dk translated">github.com</p></div></div><div class="ll l"><div class="ov l ln lo lp ll lq ks lc"/></div></div></a></div><p id="1702" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated"><code class="fe om on oo op b">prepare_GNN.py</code>帮助从<code class="fe om on oo op b">E</code>和<code class="fe om on oo op b">N</code>矩阵创建神经网络的输入。</p><p id="9c52" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">第一个输出是<code class="fe om on oo op b">inp</code>矩阵。<a class="ae ky" href="https://github.com/Steboss/learn_graph_ml/blob/9f4868264d41f44495f0acf7e8a8d6d890d4e2c4/Scarselli_GNN/prepare_GNN.py#L22" rel="noopener ugc nofollow" target="_blank">第22–36行显示了如何创建输入</a>矩阵，它是边矩阵<code class="fe om on oo op b">E</code>和节点特征<code class="fe om on oo op b">N.</code>的串联，最终内容是<code class="fe om on oo op b">[source_node, destination_node, source_features, destination_features]</code>。例如，对于第一条边，在节点0和1之间，<code class="fe om on oo op b">inp</code>的内容是:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图8:节点0和1的GNN的输入矩阵。前两个数字指的是节点0和1，接着是节点0的功能[1，0，0，…]和节点1的功能[0，1，0，…]</p></figure><p id="45aa" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated"><a class="ae ky" href="https://github.com/Steboss/learn_graph_ml/blob/9f4868264d41f44495f0acf7e8a8d6d890d4e2c4/Scarselli_GNN/prepare_GNN.py#L46" rel="noopener ugc nofollow" target="_blank">第二个输出是</a> <code class="fe om on oo op b"><a class="ae ky" href="https://github.com/Steboss/learn_graph_ml/blob/9f4868264d41f44495f0acf7e8a8d6d890d4e2c4/Scarselli_GNN/prepare_GNN.py#L46" rel="noopener ugc nofollow" target="_blank">arcnode</a></code>，以<code class="fe om on oo op b">SparseMatrix</code>格式对边缘信息进行编码，其尺寸为<code class="fe om on oo op b">[number_of_nodes, number_of_edges]</code>(本例中为34x78)。稀疏格式允许节省内存，并且只标识值为1的行列索引对，否则为0。</p><h2 id="92bf" class="nz nd it bd ne oa ob dn ni oc od dp nm ma oe of no me og oh nq mi oi oj ns ok bi translated">3.定义输入和输出函数</h2><div class="kz la gp gr lb lc"><a href="https://github.com/Steboss/learn_graph_ml/blob/master/Scarselli_GNN/input_and_output_functions.py" rel="noopener  ugc nofollow" target="_blank"><div class="ld ab fo"><div class="le ab lf cl cj lg"><h2 class="bd iu gy z fp lh fr fs li fu fw is bi translated">主ste boss/learn _ graph _ ml/input _ and _ output _ functions . py</h2><div class="lj l"><h3 class="bd b gy z fp lh fr fs li fu fw dk translated">从2009年到现在的一个漫长的旅程，有图-learn _ graph _ ml/input _ and _ output _ functions . py在主…</h3></div><div class="lk l"><p class="bd b dl z fp lh fr fs li fu fw dk translated">github.com</p></div></div><div class="ll l"><div class="ow l ln lo lp ll lq ks lc"/></div></div></a></div><p id="d219" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated"><code class="fe om on oo op b">input_and_output_functions.py</code>将底层转换和输出函数定义为MLP。<code class="fe om on oo op b">class Net</code>的核心函数是<code class="fe om on oo op b">netSt</code>和<code class="fe om on oo op b">netOut</code>，分别为<em class="nb"> f𝓌 </em>和<em class="nb"> g𝓌 </em>创建神经网络，定义了一个2层神经网络。<code class="fe om on oo op b">netSt</code>接收维数为70的节点特征，并使用<code class="fe om on oo op b">tanh</code>激活函数，用3个隐藏节点重新映射这些特征。<code class="fe om on oo op b">netOut</code>具有类似的架构，它接收2维输入，通过3个节点重新映射，并在<code class="fe om on oo op b">softmax</code>应用后返回最终预测输出:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图9:图形NN的转换和输出函数。</p></figure><h2 id="2559" class="nz nd it bd ne oa ob dn ni oc od dp nm ma oe of no me og oh nq mi oi oj ns ok bi translated">4.几乎准备好了:主GNN</h2><div class="kz la gp gr lb lc"><a href="https://github.com/Steboss/learn_graph_ml/blob/master/Scarselli_GNN/GNN.py" rel="noopener  ugc nofollow" target="_blank"><div class="ld ab fo"><div class="le ab lf cl cj lg"><h2 class="bd iu gy z fp lh fr fs li fu fw is bi translated">主ste boss/learn_graph_ml/gnn . py上的learn _ graph _ ml</h2><div class="lj l"><h3 class="bd b gy z fp lh fr fs li fu fw dk translated">从2009年到现在的漫长旅程，在Steboss大师/learn _ graph _ ml/gnn . py</h3></div><div class="lk l"><p class="bd b dl z fp lh fr fs li fu fw dk translated">github.com</p></div></div><div class="ll l"><div class="ox l ln lo lp ll lq ks lc"/></div></div></a></div><p id="86fb" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">最后一步是<code class="fe om on oo op b">GNN.py</code>，我们将定义神经网络架构应该如何工作。功能<code class="fe om on oo op b">convergence</code>、<code class="fe om on oo op b">condition</code>和<code class="fe om on oo op b">Loop</code>是整个架构的核心部分，在这里更新节点的状态</p><p id="8324" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">训练环节从<a class="ae ky" href="https://github.com/Steboss/learn_graph_ml/blob/9f4868264d41f44495f0acf7e8a8d6d890d4e2c4/Scarselli_GNN/GNN.py#L293" rel="noopener ugc nofollow" target="_blank">行293 </a>开始，<code class="fe om on oo op b">Loop</code>功能封装在<code class="fe om on oo op b">self.loss_op</code>中。在【T23、<a class="ae ky" href="https://github.com/Steboss/learn_graph_ml/blob/9f4868264d41f44495f0acf7e8a8d6d890d4e2c4/Scarselli_GNN/GNN.py#L221" rel="noopener ugc nofollow" target="_blank">线221 </a>，被称为运行<code class="fe om on oo op b">condition</code>和<code class="fe om on oo op b">convergence</code>。最后一个函数更新当前节点的状态:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图10:更新节点状态的函数收敛</p></figure><p id="5162" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">图10中的<code class="fe om on oo op b">a[:,1]</code>是输入矩阵<code class="fe om on oo op b">inp[:,1]</code>，即所有的<code class="fe om on oo op b">destination_node</code>索引。<code class="fe om on oo op b">tf.gather</code>返回每个目的节点的所有<code class="fe om on oo op b">old_state</code>值，得到一个78x2的矩阵，其值在第一次迭代时为零——因为<code class="fe om on oo op b">old_state</code>最初被初始化为一个零矩阵，<code class="fe om on oo op b">np.zeros((ArcNode.dense_shape[0], self.state_dim))</code> ( <a class="ae ky" href="http://self.state: np.zeros((ArcNode.dense_shape[0], self.state_dim))," rel="noopener ugc nofollow" target="_blank">行261 </a>)。</p><p id="aa25" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated"><code class="fe om on oo op b">sl = a[:, 2:]</code>返回所有的<code class="fe om on oo op b">source_node</code>和<code class="fe om on oo op b">destination_node</code>特征(尺寸78x68)，然后连接为<code class="fe om on oo op b">inp</code>用于转换神经网络功能。通过矩阵乘法<code class="fe om on oo op b">sparse_tensor_dense_matmul</code>用边缘连接更新来自<em class="nb"> f𝓌 </em>的输出状态。新状态被传回<code class="fe om on oo op b">Loop</code>功能(<a class="ae ky" href="https://github.com/Steboss/learn_graph_ml/blob/9f4868264d41f44495f0acf7e8a8d6d890d4e2c4/Scarselli_GNN/GNN.py#L237" rel="noopener ugc nofollow" target="_blank">行237 </a>)，然后被用作<em class="nb"> g𝓌 </em>输出功能的输入:<code class="fe om on oo op b">out=self.net.netOut(stf)</code></p><h1 id="da4d" class="nc nd it bd ne nf ng nh ni nj nk nl nm jz nn ka no kc np kd nq kf nr kg ns nt bi translated">空手道俱乐部在行动</h1><p id="7f73" class="pw-post-body-paragraph lr ls it lt b lu nu ju lw lx nv jx lz ma nw mc md me nx mg mh mi ny mk ml mm im bi translated">您现在可以运行<code class="fe om on oo op b">karate.py</code>了！！！</p><div class="kz la gp gr lb lc"><a href="https://github.com/Steboss/learn_graph_ml/blob/master/Scarselli_GNN/karate.py" rel="noopener  ugc nofollow" target="_blank"><div class="ld ab fo"><div class="le ab lf cl cj lg"><h2 class="bd iu gy z fp lh fr fs li fu fw is bi translated">师父ste boss/learn _ graph _ ml/空手道. py</h2><div class="lj l"><h3 class="bd b gy z fp lh fr fs li fu fw dk translated">从2009年到现在的一次长途旅行，有图表-learn _ graph _ ml/空手道. py在Steboss大师/learn_graph_ml</h3></div><div class="lk l"><p class="bd b dl z fp lh fr fs li fu fw dk translated">github.com</p></div></div><div class="ll l"><div class="oy l ln lo lp ll lq ks lc"/></div></div></a></div><p id="eef3" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">最终的输出没有什么意义，但它是一个显著的例子，可以看到图形神经网络的力量以及图形如何被用作我们预测的输入。</p><p id="2b57" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated"><code class="fe om on oo op b">karate.py</code>脚本的主要部分在<a class="ae ky" href="https://github.com/Steboss/learn_graph_ml/blob/9f4868264d41f44495f0acf7e8a8d6d890d4e2c4/Scarselli_GNN/karate.py#L61" rel="noopener ugc nofollow" target="_blank">第61行</a>，在此执行训练步骤。如果您想将最终结果保存为<code class="fe om on oo op b">gif</code>，如果您想在<code class="fe om on oo op b">tensorboard</code>中可视化神经网络结果，这是打开<code class="fe om on oo op b">tensorboard</code>的命令，带有最终输出:</p><pre class="kj kk kl km gt oz op pa pb aw pc bi"><span id="0b38" class="nz nd it op b gy pd pe l pf pg">venv/bin/tensorboard --logdir tmp/path/to/folder_with_out.tfevents</span></pre><p id="acdf" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">将您的浏览器连接到<code class="fe om on oo op b">http://localhost:PORT</code>，这里端口被定义为终端中的输出，以充分工作<code class="fe om on oo op b">tensorboard</code></p><p id="eb98" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">主输出形式<code class="fe om on oo op b">g.Train</code>是<code class="fe om on oo op b">loop_val</code>。此变量报告:</p><ul class=""><li id="df5a" class="mn mo it lt b lu lv lx ly ma mp me mq mi mr mm ms mt mu mv bi translated"><code class="fe om on oo op b">loop_val[0]</code>节点的预测值</li><li id="a789" class="mn mo it lt b lu mw lx mx ma my me mz mi na mm ms mt mu mv bi translated"><code class="fe om on oo op b">loop_val[1]</code>为更新状态而执行的迭代次数</li><li id="2506" class="mn mo it lt b lu mw lx mx ma my me mz mi na mm ms mt mu mv bi translated"><code class="fe om on oo op b">loop_val[2]</code>当前节点的位置</li><li id="4a7e" class="mn mo it lt b lu mw lx mx ma my me mz mi na mm ms mt mu mv bi translated"><code class="fe om on oo op b">loop_val[3]</code>节点的特性</li></ul><p id="ec44" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">图11将训练运行动画化，从没有节点预测的初始猜测，直到节点之间有线性间隔的结束。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ph"><img src="../Images/9b504b57ce152ad7ed84909542754de1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*mlRmrbUsjca5m0jB9NlYtg.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图11:基于来自GraphNN的预测，通过时期的节点细分</p></figure><p id="66fb" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">今天就到这里吧！请继续关注关于图形和ML的新帖子！！！！</p></div><div class="ab cl pi pj hx pk" role="separator"><span class="pl bw bk pm pn po"/><span class="pl bw bk pm pn po"/><span class="pl bw bk pm pn"/></div><div class="im in io ip iq"><p id="fa6f" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated"><em class="nb">如果有任何问题或意见，请随时发送电子邮件至:stefanobosisio1@gmail.com或直接发送至Medium。</em></p></div></div>    
</body>
</html>