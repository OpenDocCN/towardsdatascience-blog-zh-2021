<html>
<head>
<title>Logistic Regression in real-life: building a daily productivity classification model</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">现实生活中的逻辑回归:构建日常生产力分类模型</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/logistic-regression-in-real-life-building-a-daily-productivity-classification-model-a0fc2c70584e?source=collection_archive---------7-----------------------#2021-03-23">https://towardsdatascience.com/logistic-regression-in-real-life-building-a-daily-productivity-classification-model-a0fc2c70584e?source=collection_archive---------7-----------------------#2021-03-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/7d5d5c7bb6eb82afddfc968114d327f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SFzuNg8yaL1qUZYm6o4PpA.png"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">图片作者。</p></figure><p id="5f73" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">Logistic回归是一个机器学习分类模型，名字相当混乱！</p><p id="4d73" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这个名字让你想到<a class="ae la" rel="noopener" target="_blank" href="/linear-regression-in-real-life-4a78d7159f16">线性回归</a>，但它不是用来预测一个无限的、连续的结果。相反，它是一个统计分类模型，它给你一个观察属于一个特定类别的可能性。</p><p id="8440" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">逻辑回归被用于许多科学领域。在<a class="ae la" href="https://en.wikipedia.org/wiki/Natural_language_processing" rel="noopener ugc nofollow" target="_blank">自然语言处理(NLP) </a>中，它被用来确定电影评论的情绪，而在医学中，它可以用来确定病人患特定疾病的概率。</p><h1 id="92d7" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">对你的日常生产力进行分类</h1><p id="3e64" class="pw-post-body-paragraph kc kd iq ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz ij bi translated">最近你对衡量自己的生产力感兴趣。不一定要量化到最小的细节，但只是为了更好地了解你的一天是否真的富有成效。</p><p id="7944" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">每天结束时，你都在问自己，这一天是否真的富有成效。但这只是一个潜在的有偏见的定性数据点。你想找到一个更科学的方法来做这件事。</p><p id="08cf" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">你已经观察了一天中的自然涨落，并意识到对它影响最大的是:</p><ul class=""><li id="34dc" class="me mf iq ke b kf kg kj kk kn mg kr mh kv mi kz mj mk ml mm bi translated"><strong class="ke ir">睡眠</strong>你知道睡眠，或者睡眠不足，对你的一天有很大的影响。</li><li id="0bb3" class="me mf iq ke b kf mn kj mo kn mp kr mq kv mr kz mj mk ml mm bi translated"><strong class="ke ir">咖啡</strong>不是喝完咖啡一天就开始了吗？</li><li id="999d" class="me mf iq ke b kf mn kj mo kn mp kr mq kv mr kz mj mk ml mm bi translated">专注时间<strong class="ke ir">这并不总是可能的，但是你可以试着花3-4小时专注于项目。</strong></li><li id="5ea1" class="me mf iq ke b kf mn kj mo kn mp kr mq kv mr kz mj mk ml mm bi translated">你已经注意到，当你有时间吃一顿正式的午餐，而不仅仅是小吃时，一天会过得很顺利。</li><li id="896a" class="me mf iq ke b kf mn kj mo kn mp kr mq kv mr kz mj mk ml mm bi translated"><strong class="ke ir">散步</strong>你一直在进行短途散步，以便进入状态，放松一下，思考一下你的项目。</li></ul><figure class="mt mu mv mw gt jr gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/812e80fdbbe85c1851bab50a85a166cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1100/format:webp/1*uqa1x1oL873BI59xAoPT0w.png"/></div><p class="jy jz gj gh gi ka kb bd b be z dk translated"><em class="mx">什么影响了你的工作效率。</em></p></figure><p id="b856" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">你听说过机器学习分类模型，因为有许多不同的模型，具有不同的复杂程度和定制程度，所以你想从一个简单的模型开始。</p><p id="3e8f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">当你在考虑使用哪种模式时，你意识到这些活动与你的整体生产力有线性关系。</p><p id="a6ff" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">那么你的第一个问题是，<em class="my"/><a class="ae la" rel="noopener" target="_blank" href="/linear-regression-in-real-life-4a78d7159f16"><em class="my">线性回归</em> </a> <em class="my">可能是这项工作最简单、最好的工具吗？</em></p><h1 id="f994" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">如果是线性模型，为什么不用线性回归呢？</h1><p id="6c0c" class="pw-post-body-paragraph kc kd iq ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz ij bi translated">最后，您希望创建一个模型来描述一组特征、影响您工作效率的因素以及目标变量(有效率或无效率的一天)之间的线性关系。</p><p id="916c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">那么，为什么不保持简单，使用线性回归模型呢？</p><p id="b278" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">要用线性回归模型将你的一天划分为有效率还是没有效率，第一步是选择一个任意的阈值<em class="my"> x </em>，并根据一个简单的标准将观察值分配给每个类别:</p><ul class=""><li id="c55a" class="me mf iq ke b kf kg kj kk kn mg kr mh kv mi kz mj mk ml mm bi translated"><em class="my">类非生产性</em>，所有小于等于<em class="my"> x </em>的结果。</li><li id="0e0c" class="me mf iq ke b kf mn kj mo kn mp kr mq kv mr kz mj mk ml mm bi translated"><em class="my">类生产性</em>否则，即所有结果大于<em class="my"> x </em>。</li></ul><figure class="mt mu mv mw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mz"><img src="../Images/b148053fabc7257cd5af09feb47ea7f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:704/format:webp/1*DJhuZM_6vVk-e610RNK30w.png"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated"><em class="mx">使用任意阈值x来确定数据属于哪一类。</em></p></figure><p id="1c3a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这很简单！</p><p id="16c9" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">您获取数据并在训练集和测试集之间进行分割，确保将所有分类值编码为数字值。</p><blockquote class="na"><p id="ff38" class="nb nc iq bd nd ne nf ng nh ni nj kz dk translated">线性回归模型不知道如何处理分类值，所以需要对它们进行编码。</p></blockquote><p id="dfdb" class="pw-post-body-paragraph kc kd iq ke b kf nk kh ki kj nl kl km kn nm kp kq kr nn kt ku kv no kx ky kz ij bi translated">你可以用你喜欢的方式，只要是整数。在这种情况下<em class="my">否</em>变为0，而<em class="my">是</em>变为1。</p><figure class="mt mu mv mw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi np"><img src="../Images/d336a5b0f5b2e5de4658f097e7baee6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*60dJtgxJO765UP5jNItMog.png"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated"><em class="mx">你一直在收集的用来模拟日常工作效率的数据。</em></p></figure><p id="1fee" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">至于任意阈值，您已经决定:</p><ul class=""><li id="4320" class="me mf iq ke b kf kg kj kk kn mg kr mh kv mi kz mj mk ml mm bi translated">小于或等于零的结果被分配到0级，即非生产日。</li><li id="d953" class="me mf iq ke b kf mn kj mo kn mp kr mq kv mr kz mj mk ml mm bi translated">积极的结果被分配到第1类，即富有成效的一天。</li></ul><p id="f4e8" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">您使用Python的<a class="ae la" href="https://scikit-learn.org/stable/modules/generated/sklearn.linear_model.LinearRegression.html" rel="noopener ugc nofollow" target="_blank"> SckitLearn </a>通过线性回归模型运行数据，并绘制结果及其各自的类。</p><pre class="mt mu mv mw gt nq nr ns nt aw nu bi"><span id="81ae" class="nv lc iq nr b gy nw nx l ny nz">import numpy as np<br/>import matplotlib.pyplot as plt<br/>from sklearn import linear_model<br/>from matplotlib.lines import Line2D<br/>from sklearn.model_selection import train_test_split</span><span id="f569" class="nv lc iq nr b gy oa nx l ny nz">def plot_results(train_targets, predictions):<br/>    fig, ax = plt.subplots(figsize=(15, 10))<br/>    # removing all borders except bottom<br/>    ax.spines['top'].set_visible(False)<br/>    ax.spines['right'].set_visible(False)<br/>    ax.spines['left'].set_visible(False)</span><span id="ab5e" class="nv lc iq nr b gy oa nx l ny nz">    # adding major gridlines<br/>    ax.grid(color='grey', linestyle='-', linewidth=0.25, alpha=0.5)</span><span id="aabd" class="nv lc iq nr b gy oa nx l ny nz">    training_colors = ['#4786D1' if target &lt;= 0 else '#F28627' for target in train_targets]<br/>    prediction_colors = ['#4786D1' if target &lt;= 0 else '#F28627' for target in predictions]</span><span id="22f4" class="nv lc iq nr b gy oa nx l ny nz">    train_set_len = len(train_targets)<br/>    predictions_len = len(predictions)</span><span id="97a9" class="nv lc iq nr b gy oa nx l ny nz">    plt.scatter(np.arange(0, train_set_len), train_targets, color=training_colors, marker='o', s=[12 * train_set_len])<br/>    plt.scatter(np.arange(0, predictions_len), predictions, color=prediction_colors, marker='^', s=[40 * predictions_len])</span><span id="8739" class="nv lc iq nr b gy oa nx l ny nz">    ax.set_xlabel('Observation')<br/>    ax.set_ylabel('Target value')</span><span id="ef51" class="nv lc iq nr b gy oa nx l ny nz">    # Customizing symbols in the legend<br/>    legend_items = [Line2D([0], [0], color='#4786D1', markersize=15), <br/>        Line2D([0], [0], color='#F28627', markersize=15),<br/>        Line2D([0], [0], color='w', marker='o', markerfacecolor='#979797', markeredgecolor='#979797', markersize=15),<br/>        Line2D([0], [0], color='w', marker='^', markerfacecolor='#979797', markeredgecolor='#979797', markersize=15)]</span><span id="4c82" class="nv lc iq nr b gy oa nx l ny nz">    # Adding some spacing between each legend row and padding<br/>    ax.legend(handles=legend_items,<br/>    labels=['Class 0: Non Productive', 'Class 1: Productive', 'Training set', 'Predictions'],labelspacing=1.5, borderpad=1)<br/>    <br/>    plt.show()</span><span id="ce8c" class="nv lc iq nr b gy oa nx l ny nz">def fit_linear_regression(features, targets):<br/>    train_features, test_features, train_targets, test_targets = train_test_split(features, targets, test_size=0.25, random_state=123)</span><span id="ab7f" class="nv lc iq nr b gy oa nx l ny nz">    model = linear_model.LinearRegression()<br/>    fitted_model = model.fit(train_features, train_targets)<br/>    predictions = fitted_model.predict(test_features)<br/>    <br/>    print('---Linear Regression')<br/>    print('Coefficients: ' + str(fitted_model.coef_))<br/>    print('Intercept: ' + str(fitted_model.intercept_))<br/>    print('R-squared: ' + str(fitted_model.score(train_features, np.array(train_targets).reshape(-1, 1))))<br/>    <br/>    plot_results(train_targets, predictions)</span><span id="c1b0" class="nv lc iq nr b gy oa nx l ny nz">productivity_features = [[8.0, 2, 4.5, 1, 0],<br/>                         [7.5, 1, 5.0, 1, 0],<br/>                         [9.0, 2, 3.0, 0, 0],<br/>                         [6.0, 3, 2.5, 1, 0],<br/>                         [8.5, 2, 3.5, 0, 1],<br/>                         [10.0, 1, 2.0, 1, 1],<br/>                         [7.5, 3, 2.5, 1, 0],<br/>                         [8.5, 2, 3.5, 0, 1],<br/>                         [6.0, 2, 1.5, 1, 1],<br/>                         [7.0, 1.0, 3.0, 1, 0]]</span><span id="8f44" class="nv lc iq nr b gy oa nx l ny nz">productivity_targets = [1, 1, 0, 0, 1, 0, 1, 0, 0, 1]</span><span id="b91a" class="nv lc iq nr b gy oa nx l ny nz">fit_linear_regression(productivity_features, productivity_targets)</span></pre><h1 id="772a" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">线性回归:不是这项工作的最佳工具</h1><p id="11ab" class="pw-post-body-paragraph kc kd iq ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz ij bi translated">绘制训练集的目标或结果以及模型预测，您可以看到一些点被错误地分类。</p><p id="d659" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在某些情况下，该模型在预测正确的类别方面做得并不好。</p><p id="cff8" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">例如，在只有蓝色数据点的绘图区域中有一个橙色数据点，而在主要为橙色的区域中有一个蓝色数据点。</p><figure class="mt mu mv mw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ob"><img src="../Images/767f85b7865270749c3331a9fc6b7e8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PenEb9t2gXGFVwyJuyIIpg.png"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated"><em class="mx">训练目标值散点图(圆形)和线性回归模型预测值散点图(三角形)。根据等级进行颜色编码:蓝色代表0级，橙色代表1级。</em></p></figure><p id="903a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">因此，为了更好地了解模型的性能，您可以检查它的<a class="ae la" href="https://en.wikipedia.org/wiki/Coefficient_of_determination" rel="noopener ugc nofollow" target="_blank"> R平方</a>，这是一个衡量这些特征如何帮助确定结果的指标。</p><figure class="mt mu mv mw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oc"><img src="../Images/09b8b97a34944229484eefbec266468e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hR277v2TpsSM8--dhWqvhQ.png"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">线性回归模型的输出。</p></figure><p id="deb8" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">0.7还不错。当然，这种模式有改进的空间，但它不是一个彻底的失败！</p><p id="f172" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">但是，即使有看似令人鼓舞的结果，线性回归模型在分类任务方面也有一些限制:</p><ol class=""><li id="a35b" class="me mf iq ke b kf kg kj kk kn mg kr mh kv mi kz od mk ml mm bi translated">意味着结果值有特定的顺序。</li><li id="ffd8" class="me mf iq ke b kf mn kj mo kn mp kr mq kv mr kz od mk ml mm bi translated">产生连续的、无限的结果。</li><li id="9290" class="me mf iq ke b kf mn kj mo kn mp kr mq kv mr kz od mk ml mm bi translated">仅解释单个特征如何影响目标。</li></ol><h2 id="3bb5" class="nv lc iq bd ld oe of dn lh og oh dp ll kn oi oj lp kr ok ol lt kv om on lx oo bi translated"><strong class="ak"> 1。意味着结果值有特定的顺序</strong></h2><p id="80ad" class="pw-post-body-paragraph kc kd iq ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz ij bi translated">如果你只使用一个阈值来分配类，你是在假设结果有一个隐含的顺序。</p><p id="5f59" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">例如，您决定所有小于或等于<em class="my"> 0 </em>的结果属于<em class="my">类0、</em>，而所有其他结果<em class="my"> </em>属于<em class="my">类1 </em>。</p><p id="3f57" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">因此，使用这种方法，您隐含地假设所有来自<em class="my">类0 </em>的观察值必须在所有来自<em class="my">类1 </em>的观察值之前。</p><p id="38f5" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">你可以控制这个阈值，所以你可以选择任何你想要的数字。但是，在实际中，当数据可能不遵循该特定顺序时，该模型将盲目地使用给定的阈值。</p><p id="c98a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">因此，该模型往往具有较低的准确性。</p><h2 id="d513" class="nv lc iq bd ld oe of dn lh og oh dp ll kn oi oj lp kr ok ol lt kv om on lx oo bi translated"><strong class="ak"> 2。产生连续的、无限的结果</strong></h2><p id="b9b9" class="pw-post-body-paragraph kc kd iq ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz ij bi translated">在分类问题中，结果变量是<em class="my">分类</em>，在这种情况下，是一个生产或非生产日。</p><p id="55a9" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">但是你正在将数据拟合到一个只能产生连续结果的回归模型中。</p><p id="7ec0" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">结果是连续的这一事实不是问题。最大的限制是这些结果不限于0到1之间的值。</p><p id="e02c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">你刚刚看到了它的作用。尽管可能的目标是0和1，但有些预测完全是0，有些预测是肯定的，但不完全是1。有些预测甚至是负面的！</p><h2 id="5d33" class="nv lc iq bd ld oe of dn lh og oh dp ll kn oi oj lp kr ok ol lt kv om on lx oo bi translated"><strong class="ak"> 3。仅解释单个特征如何影响目标</strong></h2><p id="0927" class="pw-post-body-paragraph kc kd iq ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz ij bi translated">线性回归是表示目标变量和一组特征之间的线性关系的一个很好的模型，但是模型系数只能告诉您一个特定的特征(独立于其他特征)如何影响目标。</p><blockquote class="na"><p id="799b" class="nb nc iq bd nd ne nf ng nh ni nj kz dk translated">线性回归映射目标和特定特征之间的关系，假设所有其他特征都是固定的。</p></blockquote><p id="6338" class="pw-post-body-paragraph kc kd iq ke b kf nk kh ki kj nl kl km kn nm kp kq kr nn kt ku kv no kx ky kz ij bi translated">但是在分类任务中，你想要测量整个特征集如何影响结果，因为所有特征<em class="my">同时存在</em>，而不是孤立存在【1】。</p><h1 id="d697" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">逻辑回归拯救世界！</h1><p id="8572" class="pw-post-body-paragraph kc kd iq ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz ij bi translated">知道了这些限制，很明显线性回归不是分类任务的最佳工具。</p><p id="b7c4" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">一个可行的选择是使用<strong class="ke ir">逻辑回归</strong>。它解决了线性回归的局限性，同时分享了它的许多特征。例如，逻辑回归和线性回归都是<a class="ae la" href="https://en.wikipedia.org/wiki/Generalized_linear_model" rel="noopener ugc nofollow" target="_blank">广义线性模型</a>，描述目标和独立变量集之间的线性关系。</p><p id="4122" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">但是逻辑回归更适合于二元分类任务，因为它:</p><ul class=""><li id="1055" class="me mf iq ke b kf kg kj kk kn mg kr mh kv mi kz mj mk ml mm bi translated">预测发生<a class="ae la" href="https://en.wikipedia.org/wiki/Bernoulli_distribution" rel="noopener ugc nofollow" target="_blank">伯努利事件</a>的可能性，其结果只能是<em class="my">是/否</em>或<em class="my">肯定/否定</em>。</li><li id="a818" class="me mf iq ke b kf mn kj mo kn mp kr mq kv mr kz mj mk ml mm bi translated">找到一个函数<em class="my"> g，</em>，也称为<em class="my">链接函数</em>，该函数获取某个观察值属于某个类别的可能性，并将其结果建模为预测值的线性组合。</li><li id="8dd4" class="me mf iq ke b kf mn kj mo kn mp kr mq kv mr kz mj mk ml mm bi translated">假设模型的结果不会随着特征的变化而线性变化。函数<em class="my"> g </em>随着特征的变化而线性变化。</li></ul><p id="e9ec" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">对于只有一个特征或预测器的模型，<strong class="ke ir">链接函数</strong> <em class="my"> g </em>可描述为:</p><figure class="mt mu mv mw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi op"><img src="../Images/945498633969df1a5cfdce8d868e4d62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G3roqnBRlkwDe2CTimex8w.png"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">逻辑回归模型连接函数的定义。</p></figure><p id="6c42" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">逻辑回归使用<em class="my">链接函数</em>，但是它的结果是一个概率，这意味着它只能预测0到1之间的值。</p><p id="86b2" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">所以问题变成了，<em class="my">逻辑回归如何把线性组合的无界连续值变成概率？</em></p><h1 id="feab" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">logit函数</h1><p id="3a5e" class="pw-post-body-paragraph kc kd iq ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz ij bi translated">为了完成这一数学壮举并将其结果限制在0和1之间，逻辑回归使用<a class="ae la" href="https://en.wikipedia.org/wiki/Logit" rel="noopener ugc nofollow" target="_blank"> <strong class="ke ir"> logit函数</strong> </a>作为其链接函数来表示概率<em class="my"> p </em>的<strong class="ke ir">对数优势比的对数</strong>。</p><p id="2649" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在这种情况下，多产日的对数概率是多产日的概率(<em class="my"> p </em>)与非多产日的概率(1- <em class="my"> p </em>)之比。</p><p id="12cd" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这就是为什么logit函数也被称为log-odds <em class="my"> </em>函数。</p><figure class="mt mu mv mw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oq"><img src="../Images/9a4bc866e768af99b528758ca0b77ae6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m82lfy4TCQ7AIz3tVQVoNw.png"/></div></div></figure><p id="87ec" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">但是为什么是logit而不是其他函数呢？</p><p id="9363" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><em class="my"> logit </em>功能是一个<a class="ae la" href="https://en.wikipedia.org/wiki/Sigmoid_function" rel="noopener ugc nofollow" target="_blank"> sigmoid功能</a>。它在0和1处渐近，因此，随着模型结果越来越接近<em class="my">-无穷大</em>,<em class="my">logit</em>的结果越来越接近0。另一方面，随着结果越来越接近<em class="my">+无穷大</em>，<em class="my"> logit </em>的结果越来越接近1。</p><figure class="mt mu mv mw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi or"><img src="../Images/f02b2d50e303aed13eb66b4b08a663f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-XV4U7rmoSLBdGi5OTlnyA.png"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">一个逻辑函数的锅。</p></figure><p id="f11a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">logit函数很棒，因为它将值保持在0和1之间，但是您对<em class="my">对数几率不感兴趣。</em></p><p id="2a59" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在二元类任务中，您需要实际的概率。</p><h1 id="4beb" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">物流功能</h1><p id="2455" class="pw-post-body-paragraph kc kd iq ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz ij bi translated">实际上，你希望<em class="my">从对数概率中提取</em>概率。</p><p id="a1a2" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">听起来像是一个困难的任务，但是，好消息是，它只需要几个数学变换！</p><p id="5b4a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">下面是你如何从对数概率中<em class="my">得出</em>成功的概率<em class="my"/>(p)。</p><p id="7f4b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">首先你<em class="my">去掉</em>的对数，然后，经过一些代数运算，你能够<em class="my">分离出</em> <em class="my"> p </em>。</p><figure class="mt mu mv mw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi os"><img src="../Images/5a8a16a0cfc15666e54441d2acd92088.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QlYer7FTOIqmgpMlL5vWdw.png"/></div></div></figure><p id="4ac1" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在这个过程结束时，概率<em class="my"> p </em>、成功概率<em class="my"/>、<em class="my"> </em>是一个线性组合的函数。</p><p id="bdfb" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">从数学上来说，你实现的是logit函数的逆函数，这个函数叫做<a class="ae la" href="https://en.wikipedia.org/wiki/Logistic_function" rel="noopener ugc nofollow" target="_blank"> <strong class="ke ir">逻辑函数</strong> </a> <em class="my">。</em></p><figure class="mt mu mv mw gt jr gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/eec86d9b3ede89eaae4c9e6da27f7bfe.png" data-original-src="https://miro.medium.com/v2/resize:fit:680/format:webp/1*fs7cSzb6I0FEaPinVyxidg.png"/></div><p class="jy jz gj gh gi ka kb bd b be z dk translated"><em class="mx">逻辑函数的定义。</em></p></figure><p id="2e54" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">简单形式的线性组合<em class="my"> z </em>的函数。</p><p id="5888" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果你对<em class="my">失败</em>的概率感兴趣，你可以做一个等价的操作并隔离(1- <em class="my"> p </em>而不是<em class="my"> p. </em></p></div><div class="ab cl ou ov hu ow" role="separator"><span class="ox bw bk oy oz pa"/><span class="ox bw bk oy oz pa"/><span class="ox bw bk oy oz"/></div><div class="ij ik il im in"><p id="e916" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">将所有这些放在一起，现在我们知道逻辑回归使用逻辑函数来预测观察值属于<em class="my">正</em>类的可能性。概率也是线性组合的函数，如线性回归中使用的概率。</p><p id="3c69" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">逻辑回归这个名字更有意义！</p><p id="03a7" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这个模型只需要考虑一个细节，然后就可以把你的一天划分为有效率的或者没有效率的。</p><h1 id="795f" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">定义决策边界</h1><p id="34a9" class="pw-post-body-paragraph kc kd iq ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz ij bi translated">对于每个观察值，逻辑回归模型计算该观察值属于<em class="my">正</em>类的概率，在本例中，是多产的<em class="my"> </em>日。它看起来像这样:</p><figure class="mt mu mv mw gt jr gh gi paragraph-image"><div class="gh gi pb"><img src="../Images/5be0dd9e6cd283766b28f1c103213bed.png" data-original-src="https://miro.medium.com/v2/resize:fit:826/format:webp/1*2FdnfVvGyhmD_VM3bc31gA.png"/></div></figure><p id="6711" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">但是您在分类任务中使用这个模型，所以它仍然需要决定将哪个类分配给每个观察。</p><p id="0cb2" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">该模型需要一些标准来区分对应于生产日的观察和对应于非生产日的观察。它需要一个<strong class="ke ir">决策边界</strong>。</p><blockquote class="na"><p id="2f13" class="nb nc iq bd nd ne nf ng nh ni nj kz dk translated">决策边界是将来自<em class="mx">正</em>类的观察值与来自<em class="mx">负</em>类的观察值分开的<em class="mx">假想边界</em>。</p></blockquote><p id="312a" class="pw-post-body-paragraph kc kd iq ke b kf nk kh ki kj nl kl km kn nm kp kq kr nn kt ku kv no kx ky kz ij bi translated">根据手头的问题，您可以将决策边界设置为您喜欢的任何概率。但是典型地，判定边界被设置为0.5。</p><p id="58af" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">所以，如果模型预测观察有一个概率:</p><ul class=""><li id="8d1b" class="me mf iq ke b kf kg kj kk kn mg kr mh kv mi kz mj mk ml mm bi translated"><strong class="ke ir">低于或等于0.5 </strong>，观察值被分配到负类，例如，非生产日。</li><li id="facc" class="me mf iq ke b kf mn kj mo kn mp kr mq kv mr kz mj mk ml mm bi translated"><strong class="ke ir">大于0.5 </strong>，观察值被分配到积极等级，例如，多产日。</li></ul><h1 id="e561" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">你的一天(真的)有成效吗？</h1><p id="64b8" class="pw-post-body-paragraph kc kd iq ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz ij bi translated">要回答这个问题，您可以在已经完成的线性回归的基础上，再次使用ScikitLearn来拟合一个<a class="ae la" href="https://scikit-learn.org/stable/modules/generated/sklearn.linear_model.LogisticRegression.html#sklearn.linear_model.LogisticRegression" rel="noopener ugc nofollow" target="_blank">逻辑回归模型</a>。</p><pre class="mt mu mv mw gt nq nr ns nt aw nu bi"><span id="5640" class="nv lc iq nr b gy nw nx l ny nz">from sklearn.linear_model import LogisticRegression</span><span id="715b" class="nv lc iq nr b gy oa nx l ny nz">def fit_logistic_regression(features, targets):<br/>    train_features, test_features, train_targets, test_targets = train_test_split(features, targets, test_size=0.25, random_state=123)</span><span id="f14a" class="nv lc iq nr b gy oa nx l ny nz">    model = LogisticRegression(random_state=0)<br/>    fitted_model = model.fit(train_features, train_targets)<br/>    predictions = fitted_model.predict(test_features)</span><span id="0a8a" class="nv lc iq nr b gy oa nx l ny nz">    print('---Logistic Regression')<br/>    print('Coefficients: ' + str(fitted_model.coef_))<br/>    print('Intercept: ' + str(fitted_model.intercept_))<br/>    print('Mean accuracy: ' + str(fitted_model.score(train_features, np.array(train_targets).reshape(-1, 1))))<br/>    <br/>    plot_results(train_targets, predictions)<br/></span><span id="3e4c" class="nv lc iq nr b gy oa nx l ny nz">fit_logistic_regression(productivity_features, productivity_targets)</span></pre><p id="e5fa" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">然而，仅仅通过观察模型结果的曲线，很难判断模型是否做得很好。</p><figure class="mt mu mv mw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi pc"><img src="../Images/6a1c7b6f3216d352085686acb0f6c0c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qS8f1rHtIJnmX_cztRwaqA.png"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated"><em class="mx">训练目标值(圆形)和逻辑回归模型预测值(三角形)的散点图。根据等级进行颜色编码:蓝色代表0级，橙色代表1级。</em></p></figure><p id="6750" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">要衡量性能，你需要看模型的<strong class="ke ir"/><a class="ae la" href="https://en.wikipedia.org/wiki/Accuracy_and_precision" rel="noopener ugc nofollow" target="_blank"><strong class="ke ir"/></a>。</p><figure class="mt mu mv mw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi pd"><img src="../Images/2198035f2f3eb11cf8525bc67430ee74.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GNJAZRdSdc4-FWVYJskp0Q.png"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">逻辑回归模型的输出。</p></figure><p id="d359" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">85%的准确度意味着您的模型正确预测了85%的测试观察值。</p></div><div class="ab cl ou ov hu ow" role="separator"><span class="ox bw bk oy oz pa"/><span class="ox bw bk oy oz pa"/><span class="ox bw bk oy oz"/></div><div class="ij ik il im in"><p id="c916" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在你不必仅仅依靠定性的自我评价来判断你的一天是否富有成效！</p><p id="3634" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">你已经通过一种定量的、可重复的方式对你一天的工作效率进行了分类。</p><p id="ceac" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在这个过程中，您也更好地理解了为什么线性回归不是分类任务的最佳模型，即使特征和目标之间的关系是线性的。</p><p id="ffb0" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">希望你喜欢学习逻辑回归。</p><p id="7b1d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><em class="my">感谢阅读！</em></p><h1 id="503f" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">参考</h1><p id="59b0" class="pw-post-body-paragraph kc kd iq ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz ij bi translated">[1] Stoltzfus JC。<a class="ae la" href="https://pubmed.ncbi.nlm.nih.gov/21996075/" rel="noopener ugc nofollow" target="_blank">逻辑回归:简明入门</a>。Acad急救医学。2011年10月；18(10):1099–104.</p><p id="3ba1" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><em class="my">图片由作者提供，除非另有说明。</em></p></div></div>    
</body>
</html>