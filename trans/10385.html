<html>
<head>
<title>Grouping Dates in Pandas and SQL</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Pandas和SQL中的日期分组</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/grouping-dates-in-pandas-and-sql-5d067ab52b99?source=collection_archive---------21-----------------------#2021-10-03">https://towardsdatascience.com/grouping-dates-in-pandas-and-sql-5d067ab52b99?source=collection_archive---------21-----------------------#2021-10-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8bd5" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何使用Python和SQL对数据进行分组</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f3c6e77eda2ea5ba1057df8b86b071f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*scJZ9sLxZpFHhqa28j5Wag.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来源:图片由<a class="ae ky" href="https://pixabay.com/users/tigerlily713-194784/" rel="noopener ugc nofollow" target="_blank">tiger ly 713</a>发自<a class="ae ky" href="https://pixabay.com/photos/calendar-date-time-month-week-660670/" rel="noopener ugc nofollow" target="_blank"> Pixabay </a></p></figure><p id="120f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用数据集时，经常会出现数据格式不适合进行适当分析的情况。</p><p id="c366" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如果我们希望进行时间序列预测，但在同一时间段内存在许多数据点，该怎么办？</p><p id="8b05" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本例中，我们将使用Antonio、Almeida和Nunes的<a class="ae ky" href="https://www.sciencedirect.com/science/article/pii/S2352340918315191" rel="noopener ugc nofollow" target="_blank">酒店预订需求数据集</a> (2019)来探索如何使用Python的pandas和PostgreSQL将各个数据点分组到一个时间序列中。</p><h1 id="2ef5" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">熊猫</h1><p id="9f5f" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在这个特定的数据集中，每个预订酒店的客户都有单独的条目，提供了到达的年份和星期:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ms"><img src="../Images/c9c6ef2be1b459b2e6f9afc756050f58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WebyUVlmjFuiJNnZuVwclQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来源:Jupyter笔记本输出</p></figure><p id="4889" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，当滚动到数据集的右侧时，我们会看到平均日费率(ADR)或客户每天支付的平均费率也显示出来:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mt"><img src="../Images/8df20c6c80a0c2669b742f2ff93eb577.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x1C3wwwsBBAgyThXTnToeg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来源:Jupyter笔记本输出</p></figure><p id="7dad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">考虑一下这个场景。假设我们希望获得所有客户每周的平均ADR。我们将如何在熊猫身上实现这一目标？</p><p id="46df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们要做的第一件事是<a class="ae ky" href="https://datatofish.com/concatenate-values-python/" rel="noopener ugc nofollow" target="_blank">连接</a>到达的年份和星期的值。</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="65c5" class="mz lw it mv b gy na nb l nc nd">&gt;&gt;&gt; df1 = df['ArrivalDateYear'].map(str) + df['ArrivalDateWeekNumber'].map(str)</span><span id="40ad" class="mz lw it mv b gy ne nb l nc nd">&gt;&gt;&gt; print (df1)</span><span id="ce77" class="mz lw it mv b gy ne nb l nc nd">&gt;&gt;&gt; df1=pd.DataFrame(df1)</span><span id="1124" class="mz lw it mv b gy ne nb l nc nd">0        201527<br/>1        201527<br/>2        201527<br/>3        201527<br/>4        201527<br/>          ...  <br/>40055    201735<br/>40056    201735<br/>40057    201735<br/>40058    201735<br/>40059    201735<br/>Length: 40060, dtype: object</span></pre><p id="41cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">ADR值数组存储在单独的数据帧中:</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="1f56" class="mz lw it mv b gy na nb l nc nd">df2 = DataFrame(c, columns= ['ADR']) <br/>df2</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/9c5e2f0e71244f265900cbc199bffc41.png" data-original-src="https://miro.medium.com/v2/resize:fit:486/format:webp/1*x_6acHyvIxq0anfB0byjgQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来源:Jupyter笔记本输出</p></figure><p id="2890" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这两个数据帧又可以连接成一个新的数据帧:</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="6261" class="mz lw it mv b gy na nb l nc nd">df3=pd.concat([df1, df2], axis = 1)<br/>df3<br/>df3.columns = ['FullDate', 'ADR']<br/>df3.sort_values(['FullDate','ADR'], ascending=True)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/78de7457ee92615959a606c2045fbda5.png" data-original-src="https://miro.medium.com/v2/resize:fit:628/format:webp/1*PQnXvQ2utrF0K6ZxgnIXWg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来源:Jupyter笔记本输出</p></figure><p id="8bcf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，<strong class="lb iu"> groupby </strong>可用于计算FullDate变量的所有相同条目的平均值；即具有相同年数和周数的那些。</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="cb6c" class="mz lw it mv b gy na nb l nc nd">df4 = df3.groupby('FullDate').agg("mean")<br/>df4<br/>df4.sort_values(['FullDate'], ascending=True)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/27f12999780af76907c5bf555c23e75f.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*gvBmOPSLjvIc8mFjPuGEdA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来源:Jupyter笔记本输出</p></figure><p id="e4f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在有了一个可以用于预测目的的每周时间序列！</p><h1 id="55f6" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">一种数据库系统</h1><p id="21af" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">现在，假设我们想使用PostgreSQL完成同样的事情。我们将如何着手实现这一目标？</p><p id="13bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为此，我们将首先在PostgreSQL中创建一个表，然后从CSV文件中导入相关变量(只有相关变量保存在CSV文件中)。</p><p id="db84" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，在下面的代码中，ADR最初被指定为一个<strong class="lb iu"> decimal(4，2) </strong>数据类型。但是，发现某些值需要比decimal(4，2)更大的存储空间。</p><p id="04b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，使用如下ALTER TABLE将数据类型修改为<strong class="lb iu"> decimal(6，2) </strong>。</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="dbc9" class="mz lw it mv b gy na nb l nc nd">hotel=# create table h1 (<br/>hotel(# IsCanceled int,<br/>hotel(# ArrivalDateYear int,<br/>hotel(# ArrivalDateMonth varchar(10),<br/>hotel(# ArrivalDateWeekNumber int,<br/>hotel(# ADR decimal(4,2));<br/>CREATE TABLE</span><span id="495c" class="mz lw it mv b gy ne nb l nc nd">hotel=# alter table h1 alter column ADR type decimal(6,2);<br/>ALTER TABLE<br/>hotel=# copy h1 (IsCanceled, ArrivalDateYear, ArrivalDateMonth, ArrivalDateWeekNumber, ADR)<br/>hotel-# from 'H1.csv'<br/>hotel-# DELIMITER ','<br/>hotel-# CSV HEADER;<br/>COPY 40060</span></pre><p id="0a0e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与Python不同，不需要将年份和周数连接起来。相反，我们可以简单地按年份分组并按周数排序，如下所示:</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="7eec" class="mz lw it mv b gy na nb l nc nd">select arrivaldateweeknumber, avg(adr) from h1 where arrivaldateyear='2015' group by arrivaldateweeknumber order by arrivaldateweeknumber limit 5;</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/7b29fa18ea5c053ec85a4026c0008d43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1206/format:webp/1*-Bhv7I-7mD1QbKHKzv5mXA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来源:PostgreSQL输出</p></figure><p id="9944" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们现在希望按2016年的所有周分组。我们可以这样做:</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="1fd4" class="mz lw it mv b gy na nb l nc nd">select arrivaldateweeknumber, avg(adr) from h1 where arrivaldateyear='2016' group by arrivaldateweeknumber order by arrivaldateweeknumber limit 5;</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/9eacdf12c24f55a5cf284ce32828708e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1184/format:webp/1*dINtpdqAKNnF38AuC7RQgQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来源:PostgreSQL输出</p></figure><p id="7f84" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们已经用和在pandas中一样的方式在SQL中形成了时间序列。在现实世界中，人们可以选择使用熊猫来操纵数据。但是，如果从SQL数据库导入，这将需要从表中提取过多的数据。</p><p id="7e51" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，可以使用SQL简单地执行原始数据格式化，然后使用SQLAlchemy之类的库进行导入，以便在Python中进行进一步的分析。</p><h1 id="1021" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">结论</h1><p id="1c9d" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在本文中，您已经看到:</p><ul class=""><li id="ac3c" class="nk nl it lb b lc ld lf lg li nm lm nn lq no lu np nq nr ns bi translated">如何使用熊猫连接</li><li id="29cd" class="nk nl it lb b lc nt lf nu li nv lm nw lq nx lu np nq nr ns bi translated">如何将CSV数据集导入PostgreSQL</li><li id="a294" class="nk nl it lb b lc nt lf nu li nv lm nw lq nx lu np nq nr ns bi translated">在PostgreSQL中使用GROUP BY和ORDER BY来形成时间序列</li></ul><p id="d7a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">非常感谢您的宝贵时间，非常感谢您的任何问题或反馈。</p><p id="db30" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="ny">免责声明:本文是在“原样”的基础上编写的，没有任何担保。它旨在提供数据科学概念的概述，不应被解释为专业建议。本文中的发现和解释是作者的发现和解释，不被本文中提到的任何第三方认可或隶属于任何第三方。作者与本文提及的任何第三方无任何关系。</em></p></div></div>    
</body>
</html>