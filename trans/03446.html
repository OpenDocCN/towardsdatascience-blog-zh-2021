<html>
<head>
<title>7 Tips for Great CMake Scripts</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">制作优秀CMake脚本的7个技巧</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/7-tips-for-clean-cmake-scripts-c8d276587389?source=collection_archive---------6-----------------------#2021-03-19">https://towardsdatascience.com/7-tips-for-clean-cmake-scripts-c8d276587389?source=collection_archive---------6-----------------------#2021-03-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4fa8" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何让你的DevOps生活更轻松</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/56828e01ddb7d3e796b01f2311d00566.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*L2ikdGnZtakKIGxN"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk">Photo by <a class="ae ky" href="https://unsplash.com/@danist07?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">贝莉儿 DANIST</a> on <a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></p></figure><p id="dac0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">CMake已经成为c++构建自动化、测试和打包的事实上的标准工具。它广泛用于多平台开发，并支持为大多数C++编译器生成构建文件。自从21年前推出以来，它走过了漫长的道路，增加了对许多优秀特性的支持，在C++开发人员中广受欢迎。</p><p id="2932" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，我想向你介绍一些可能帮助你编写更好的CMake脚本的技巧。虽然您可能已经熟悉其中一些，但我相信您也会发现一些有用的。</p><h1 id="e93b" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">1.始终使用target_*()命令</h1><p id="bcaa" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">由于向后兼容，像<em class="ms"> add_definitions </em>、<em class="ms">include _ directory</em>、<em class="ms"> link_libraries、</em>等函数在现代CMake中仍然存在。但是，只要有可能，您应该更喜欢使用它们的对应项<em class="ms">target _ compile _ definitions</em>、<em class="ms">target _ include _ directory</em>、<em class="ms"> target_sources、</em>或<em class="ms"> target_link_libraries </em>来代替。</p><p id="99c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于不带<em class="ms"> target_ </em>的函数没有指定作用域，它们将泄漏到目录中指定的所有目标。例如，如果您想要构建一个可执行目标，它还依赖于子目录中定义的库，您可以这样指定它:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="461d" class="my lw it mu b gy mz na l nb nc">project(main_project)<br/>add_executable(main_project main.cpp)<br/>add_subdirectory(dependency_lib)<br/>include_directories(include_files)</span></pre><p id="15b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不幸的是，由于include _ directories中指定的目录被附加到当前<em class="ms"> CMakeLists.txt </em>文件中所有目标的列表中，它们也将被附加到<em class="ms"> dependency_lib </em>。因此，我们最终可能会在dependency_lib中使用错误的包含文件。这同样适用于其他命令。尤其是使用<em class="ms"> add_definitions </em>或者<em class="ms"> add_compile_options </em>这样的命令，这可能会导致一些难以发现的编译错误。</p><p id="f3c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一方面，使用<em class="ms">target _ include _ directory</em>或<em class="ms"> target_link_libraries </em>，我们显式地指定了我们想要使用的目标，避免了任何泄漏问题。此外，这些命令让我们可以有选择地指定实现所需继承行为的范围(见下一篇技巧)。</p><h1 id="4222" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">2.使用目标传递来指定依赖关系层次结构</h1><p id="3bc3" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在现代CMake中，目标命令让您使用<em class="ms">接口</em>、<em class="ms">私有</em>和<em class="ms">公共</em>关键字来指定命令范围。如果您想要将依赖从子目标延续到父目标，这是很有用的。</p><p id="e601" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，让我们考虑下面的代码:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="1641" class="my lw it mu b gy mz na l nb nc">project(main_project)<br/>add_executable(main_project main.cpp)<br/>add_subdirectory(dependency_lib)<br/>target_link_libraries(main_project PRIVATE dependency_lib)</span></pre><p id="078b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在子目录dependency_lib中，我们有以下CMakeLists.txt:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="8e8e" class="my lw it mu b gy mz na l nb nc">project(dependency_lib)<br/>add_library(dependency_lib SHARED library.cpp)<br/>add_subdirectory(sub_dependency_lib)<br/>target_link_libraries(dependency_lib PRIVATE sub_dependency_lib)</span></pre><p id="f01c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">显然，我们有一个依赖关系的层次结构。<em class="ms"> main_project </em>依赖于<em class="ms"> dependency_lib </em>，后者又依赖于<em class="ms"> sub_dependency_lib </em>。这样写，<em class="ms"> sub_dependency_lib </em>对<em class="ms"> main_project </em>是不可见的。这意味着<em class="ms"> main_project </em>将不能直接使用<em class="ms"> sub_dependency_lib </em>的任何函数。如果你将关键字PRIVATE替换为PUBLIC，你也可以在<em class="ms"> main_project </em>中使用<em class="ms"> sub_dependency_lib </em>。如果<em class="ms"> dependency_lib </em>没有完全隐藏依赖关系，这是很有用的，这是经常发生的情况。INTERFACE关键字使用频率较低，它指定一个在“上游”目标中使用的依赖项，而不在声明它的目标中使用(在本例中，<em class="ms"> sub_dependency_lib </em>对<em class="ms"> main_project </em>可见，但不会在<em class="ms"> dependency_lib </em>本身中使用)。</p><h1 id="8be7" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">3.防止源代码内生成</h1><p id="ff6d" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在配置任何CMake构建之前，您应该执行的默认步骤是创建一个构建子目录，然后运行CMake。但是，有时您可能会忘记创建附加目录并在根目录下运行CMake。这种“源代码内构建”污染了您的项目，并在git中产生了许多变化。</p><p id="65a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您想要禁用源代码内编译，请将下面几行放到您的根文件<em class="ms"> CMakeLists.txt </em>中:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="cc4f" class="my lw it mu b gy mz na l nb nc">if(${CMAKE_SOURCE_DIR} STREQUAL ${CMAKE_BINARY_DIR})<br/>message(FATAL_ERROR “In-source build detected!”)<br/>endif()</span></pre><p id="0e7a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个简单的脚本比较了源目录和构建目录，如果它们相等，就会抛出一个错误。</p><h1 id="33dc" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">4.指定跨平台C++一致性的语言标准</h1><p id="e4d1" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">建议使用以下定义为每个CMake项目指定C++标准:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="9446" class="my lw it mu b gy mz na l nb nc">project(main_project LANGUAGES CXX)<br/>set(CMAKE_CXX_STANDARD 17)<br/>set(CMAKE_CXX_STANDARD_REQUIRED ON)<br/>set(CMAKE_CXX_EXTENSIONS OFF)</span></pre><p id="b870" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这确保了在给定编译器支持的情况下，标准将被强制执行，并关闭非标准C++特性。避免通过添加编译标志来设置C++标准。这不是跨平台兼容的，因为每个编译器使用不同的标志。</p><p id="bd4b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果需要更好的控制，可以指定编译器支持的具体C++特性:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="7eb0" class="my lw it mu b gy mz na l nb nc">target_compile_features(<!-- -->dependency_lib<br/>    PUBLIC<br/>        cxx_nullptr<br/>    PRIVATE<br/>        cxx_variadic_templates<br/>        cxx_lambdas<br/>)</span></pre><p id="0fc8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，我们要求<em class="ms"> dependency_lib </em>编译时支持变量模板、nullptr和lambdas，而上游目标也应该编译时支持nullptr。</p><h1 id="218c" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">5.如果您的项目包含CUDA代码，请将CUDA添加为一种语言</h1><p id="330a" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">有了modern CMake，您就不仅仅局限于C或C++。CMake还支持其他语言，如Objective-C或Fortran。C++世界中使用频率较高的语言之一是CUDA，NVIDIA的GPGPU编程语言。设置CUDA传统上是相当困难的。使用CMake，您可以将CUDA作为编程语言添加到CMake项目中，如下所示:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="a2fc" class="my lw it mu b gy mz na l nb nc">cmake_minimum_required(VERSION 3.8 FATAL_ERROR)<br/>project(cmake_and_cuda LANGUAGES CXX CUDA)</span></pre><p id="b1fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，您可以像添加C++源文件一样轻松地添加新的CUDA内核:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="8ce4" class="my lw it mu b gy mz na l nb nc">add_executable(cmake_and_cuda kernel.cu kernel.h)</span></pre><p id="04a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要选择特定的CUDA架构，您可以将以下内容添加到cmake命令中:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="a85f" class="my lw it mu b gy mz na l nb nc">cmake -DCMAKE_CUDA_FLAGS=”-arch=sm_75” .</span></pre><h1 id="3f1a" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">6.将重复的CMake代码放在宏或函数中</h1><p id="03d0" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">与任何其他编程语言一样，CMake也提倡不重复自己(DRY)原则。将需要两次以上的代码放在单独的函数或宏中总是好的。CMake中的宏定义如下:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="4720" class="my lw it mu b gy mz na l nb nc">macro(foo arg)<br/>  &lt;commands&gt;<br/>endmacro()</span></pre><p id="598e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一方面，函数被定义为:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="16ce" class="my lw it mu b gy mz na l nb nc">function(foo arg)<br/>  &lt;commands&gt;<br/>endfunction()</span></pre><p id="9191" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管这两个概念非常相似，但它们在作用域上有所不同:一个函数定义了它自己的作用域，而一个宏的行为就像你在使用它的地方粘贴了代码一样。例如，宏中的return()语句不是从宏返回控制，而是返回封闭范围的控制。</p><h1 id="c84c" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">7.使用ExternalProject添加自定义目标</h1><p id="2ede" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">如果您的项目依赖于自定义目标，例如外部存储库，您可以使用ExternalProject模块。<em class="ms"> ExternalProject_Add </em>命令允许您下载并使用git repo，如下所示:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="8d02" class="my lw it mu b gy mz na l nb nc">ExternalProject_Add(<br/>  Eigen<br/>  GIT_REPOSITORY "https://gitlab.com/libeigen/eigen.git"<br/>  GIT_TAG "${EXPECTED_EIGEN_VERSION}"<br/>  SOURCE_DIR eigen<br/>  BINARY_DIR eigen-build<br/>  CMAKE_ARGS<br/>    -DBUILD_TESTING:BOOL=OFF<br/>    -DBUILD_SHARED_LIBS:BOOL=ON<br/>)</span></pre><p id="3dff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个例子中，我们使用了流行的Eigen3矩阵向量库，方法是指定存储库URL、要检查的特定git标记、源目录和普通CMake项目中的二进制目录，以及CMake参数。除了git，该命令还支持Subversion、CVS、Mercurial和普通下载。默认情况下，添加的项目被假定为CMake项目(尽管并不需要如此)。您也可以指定单独的CMake生成器和单独的构建命令。</p><p id="35c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">指定外部项目后，它可以用作另一个CMake目标，即您的目标可以依赖于它，外部项目本身也可以依赖于其他目标。你可以在<a class="ae ky" href="https://cmake.org/cmake/help/latest/module/ExternalProject.html" rel="noopener ugc nofollow" target="_blank"> CMake文档</a>中找到更多关于ExternalProject模块的信息。</p><h1 id="697c" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">结论</h1><p id="dd7b" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">现代CMake是一个用于定义整个软件构建的广泛且可扩展的系统。它支持许多不同的平台和语言，并允许您建立一个相互依赖的目标层次结构。最后一个技巧:将CMake代码视为代码库的一部分，并好好维护它。这将使构建过程对项目的所有开发人员透明。</p><h1 id="90c8" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">资源</h1><ul class=""><li id="ce1c" class="nd ne it lb b lc mn lf mo li nf lm ng lq nh lu ni nj nk nl bi translated">CMake文档:【https://cmake.org/cmake/help/v3.20/ T4】</li><li id="6439" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">CMake目标说明:<a class="ae ky" href="https://leimao.github.io/blog/CMake-Public-Private-Interface/" rel="noopener ugc nofollow" target="_blank">https://lei Mao . github . io/blog/CMake-Public-Private-Interface/</a></li><li id="0ec2" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">目标及物性解释:<a class="ae ky" href="https://pspdfkit.com/blog/2018/modern-cmake-tips/" rel="noopener ugc nofollow" target="_blank">https://pspdfkit.com/blog/2018/modern-cmake-tips/</a></li></ul></div></div>    
</body>
</html>