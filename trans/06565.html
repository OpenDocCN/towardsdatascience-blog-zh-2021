<html>
<head>
<title>DBSCAN Clustering Algorithm — How to Build Powerful Density-Based Models</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">DBSCAN聚类算法——如何构建强大的基于密度的模型</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/dbscan-clustering-algorithm-how-to-build-powerful-density-based-models-21d9961c4cec?source=collection_archive---------7-----------------------#2021-06-13">https://towardsdatascience.com/dbscan-clustering-algorithm-how-to-build-powerful-density-based-models-21d9961c4cec?source=collection_archive---------7-----------------------#2021-06-13</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><h2 id="5c37" class="is it iu bd b dl iv iw ix iy iz ja dk jb translated" aria-label="kicker paragraph">机器学习</h2><div class=""/><div class=""><h2 id="fb28" class="pw-subtitle-paragraph ka jd iu bd b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr dk translated">对有噪声的应用程序使用基于密度的空间聚类的详细指南</h2></div><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj ks"><img src="../Images/28370909f282dbe58c311151bcd796cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LxykIdWPtgZ4cMswB2X4Kg.png"/></div></div><p class="le lf gk gi gj lg lh bd b be z dk translated">DBSCAN聚类算法。图片由<a class="ae li" href="https://solclover.com/" rel="noopener ugc nofollow" target="_blank">作者</a>提供。</p></figure><h1 id="3b65" class="lj lk iu bd ll lm ln lo lp lq lr ls lt kj lu kk lv km lw kn lx kp ly kq lz ma bi translated">介绍</h1><p id="8eb3" class="pw-post-body-paragraph mb mc iu md b me mf ke mg mh mi kh mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">如果你想成为一名成功的数据科学家，你需要了解不同机器学习算法的细微差别。</p><p id="8959" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">这个故事是我深入研究这种算法如何工作的系列文章的一部分。这包括可视化和现实生活中的数据示例，以及完整的Python代码，供您在自己的数据科学项目中使用。</p><h1 id="7768" class="lj lk iu bd ll lm ln lo lp lq lr ls lt kj lu kk lv km lw kn lx kp ly kq lz ma bi translated">内容</h1><ul class=""><li id="7e7c" class="nc nd iu md b me mf mh mi mk ne mo nf ms ng mw nh ni nj nk bi translated">DBSCAN属于哪一类算法？</li><li id="c4b2" class="nc nd iu md b me nl mh nm mk nn mo no ms np mw nh ni nj nk bi translated">有哪些不同类型的聚类算法？</li><li id="e9c1" class="nc nd iu md b me nl mh nm mk nn mo no ms np mw nh ni nj nk bi translated">DBSCAN算法是如何工作的？</li><li id="cd8d" class="nc nd iu md b me nl mh nm mk nn mo no ms np mw nh ni nj nk bi translated">对真实数据使用DBSCAN的Python示例。</li></ul><h1 id="7adf" class="lj lk iu bd ll lm ln lo lp lq lr ls lt kj lu kk lv km lw kn lx kp ly kq lz ma bi translated">DBSCAN属于哪一类算法？</h1><p id="998c" class="pw-post-body-paragraph mb mc iu md b me mf ke mg mh mi kh mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">随着时间的推移，机器学习算法的总数不断增长，创造了许多分析数据的方法。我尝试收集数据科学社区最常用的算法并进行分类。请务必浏览下面的<strong class="md je">互动</strong>旭日图👇通过点击不同类别的<strong class="md je">显示更多</strong>。</p><blockquote class="nq nr ns"><p id="67b3" class="mb mc nt md b me mx ke mg mh my kh mj nu mz mm mn nv na mq mr nw nb mu mv mw in bi translated">请注意，在许多情况下，相同的算法可以用于解决多种类型的问题。例如，可以使用神经网络进行分类、回归或作为强化学习的一部分。</p></blockquote><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="nx ny l"/></div><p class="le lf gk gi gj lg lh bd b be z dk translated">机器学习算法分类。由<a class="ae li" href="https://solclover.com/" rel="noopener ugc nofollow" target="_blank">作者</a>创建的交互式图表。</p></figure><p id="457b" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated"><strong class="md je"> <em class="nt">如果你喜欢数据科学和机器学习</em> </strong> <em class="nt">，请</em> <a class="ae li" href="https://solclover.com/subscribe" rel="noopener ugc nofollow" target="_blank"> <em class="nt">订阅</em> </a> <em class="nt">每当我发布一个新的故事，你都会收到一封电子邮件。</em></p><p id="4a0f" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">如上图所示，顾名思义(带噪声的应用基于密度的空间聚类)，DBSCAN是一种聚类算法，属于机器学习的<strong class="md je">无监督</strong>分支。</p><p id="5e12" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">通常，人们会根据所选特征的相似性，使用聚类来识别不同的客户、对象或其他类型的数据组(也称为聚类)。</p><h1 id="bfcf" class="lj lk iu bd ll lm ln lo lp lq lr ls lt kj lu kk lv km lw kn lx kp ly kq lz ma bi translated">聚类算法的类型</h1><p id="509a" class="pw-post-body-paragraph mb mc iu md b me mf ke mg mh mi kh mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">并非所有的聚类算法都是一样的。不同的聚类算法对如何最好地对数据进行聚类有不同的想法。有4个主要类别:</p><ul class=""><li id="a5b2" class="nc nd iu md b me mx mh my mk nz mo oa ms ob mw nh ni nj nk bi translated"><strong class="md je">基于质心的</strong> —使用欧几里德距离将每个点分配到最近的聚类中心。例:<a class="ae li" rel="noopener" target="_blank" href="/k-means-clustering-a-comprehensive-guide-to-its-successful-use-in-python-c3893957667d">K-表示</a></li><li id="ab81" class="nc nd iu md b me nl mh nm mk nn mo no ms np mw nh ni nj nk bi translated"><strong class="md je">基于连通性的</strong> —假设附近的对象(数据点)比远处的对象更相关。例如:<a class="ae li" rel="noopener" target="_blank" href="/hac-hierarchical-agglomerative-clustering-is-it-better-than-k-means-4ff6f459e390">层次凝聚聚类(HAC) </a>。</li><li id="a8e9" class="nc nd iu md b me nl mh nm mk nn mo no ms np mw nh ni nj nk bi translated"><strong class="md je">基于密度的</strong> —将集群定义为由低密度区域分隔的密集空间区域。示例:带噪声的应用程序的基于密度的空间聚类(DBSCAN)。</li><li id="f4b5" class="nc nd iu md b me nl mh nm mk nn mo no ms np mw nh ni nj nk bi translated"><strong class="md je">基于分布的</strong> —假设数据中存在指定数量的分布。每个分布都有自己的均值(μ)和方差(σ ) /协方差(Cov)。例子:<a class="ae li" rel="noopener" target="_blank" href="/gmm-gaussian-mixture-models-how-to-successfully-use-it-to-cluster-your-data-891dc8ac058f">高斯混合模型(GMM) </a>。</li></ul><h1 id="8f70" class="lj lk iu bd ll lm ln lo lp lq lr ls lt kj lu kk lv km lw kn lx kp ly kq lz ma bi translated">DBSCAN算法是如何工作的？</h1><h2 id="8f39" class="oc lk iu bd ll od oe dn lp of og dp lt mk oh oi lv mo oj ok lx ms ol om lz ja bi translated">定义参数</h2><p id="ac6c" class="pw-post-body-paragraph mb mc iu md b me mf ke mg mh mi kh mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">如上所述，基于密度的算法通过识别由不太密集的区域分隔的空间中的密集区域(即，填充有许多数据点)来工作。为了使算法能够找到这些密集区域，我们首先需要建立我们认为足够密集的区域。我们通过指定两个超参数来做到这一点:</p><ul class=""><li id="2733" class="nc nd iu md b me mx mh my mk nz mo oa ms ob mw nh ni nj nk bi translated"><strong class="md je">ε</strong>(ϵ，sk learn:EPS)——定义该点与任何其他点之间的最大距离的点周围区域的半径，其中一个点被视为另一个点的邻域。简单来说，就是你在下面的gif图中看到的圆的半径。</li><li id="ae56" class="nc nd iu md b me nl mh nm mk nn mo no ms np mw nh ni nj nk bi translated"><strong class="md je">最小点数</strong> (MinPts，sk learn:Min _ samples)-邻域中形成聚类所需的最小点数。</li></ul><h2 id="a140" class="oc lk iu bd ll od oe dn lp of og dp lt mk oh oi lv mo oj ok lx ms ol om lz ja bi translated">例子</h2><p id="9c3c" class="pw-post-body-paragraph mb mc iu md b me mf ke mg mh mi kh mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">让我们看看下面的例子，其中eps=2.5单位，MinPts=4。注意，这里的迭代是指一个算法迭代通过每个点，并将其分配到一个类别(噪声、核心点、边界点)。</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj on"><img src="../Images/9ed0aea1b2a2a75851280ce8d851cb62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*Wlb4XzugO5k2SuUc3BDZGg.gif"/></div></div><p class="le lf gk gi gj lg lh bd b be z dk translated">DBSCAN过程。图片由<a class="ae li" href="https://solclover.com/" rel="noopener ugc nofollow" target="_blank">作者</a>提供。</p></figure><ul class=""><li id="fc5b" class="nc nd iu md b me mx mh my mk nz mo oa ms ob mw nh ni nj nk bi translated"><strong class="md je">迭代0 </strong> —尚未访问任何点。接下来，该算法将随机选择一个起点，将我们带到迭代1。</li><li id="fa32" class="nc nd iu md b me nl mh nm mk nn mo no ms np mw nh ni nj nk bi translated"><strong class="md je">迭代1 </strong> —点A只有一个邻居。由于2个点(A+1个邻居)小于4(形成聚类所需的最小值，如上所述)，A被标记为噪声。</li><li id="5e37" class="nc nd iu md b me nl mh nm mk nn mo no ms np mw nh ni nj nk bi translated"><strong class="md je">迭代2 </strong> —点B在其邻域内有5个其他点。因为6个点(B + 5个邻居)大于4，所以识别第一个聚类的开始，其中<strong class="md je"> B </strong>成为<strong class="md je">核心点</strong>。同时，先前被认为是噪声的点<strong class="md je"> A被重新标记为边界点</strong>，因为它位于核心点b的邻域内</li><li id="c40d" class="nc nd iu md b me nl mh nm mk nn mo no ms np mw nh ni nj nk bi translated"><strong class="md je">迭代3到6 </strong> —点C、D、E、F被标记为核心点，并被分配给聚类1。</li><li id="9db1" class="nc nd iu md b me nl mh nm mk nn mo no ms np mw nh ni nj nk bi translated"><strong class="md je">迭代7 </strong> —点G被标记为边界点，因为它在核心点E和F的邻域内，但没有达到被标记为核心点的最小数量4个点。</li><li id="5c5f" class="nc nd iu md b me nl mh nm mk nn mo no ms np mw nh ni nj nk bi translated"><strong class="md je">迭代8 </strong> —点H被标记为噪声(异常值)，因为在其邻域内没有其他点。</li><li id="333a" class="nc nd iu md b me nl mh nm mk nn mo no ms np mw nh ni nj nk bi translated"><strong class="md je">迭代9到12 </strong> —识别并标记新的聚类，包含4个核心点(I，J，K，L)。</li></ul><h2 id="a9f7" class="oc lk iu bd ll od oe dn lp of og dp lt mk oh oi lv mo oj ok lx ms ol om lz ja bi translated">与其他聚类方法相比，DBSCAN的优缺点</h2><ul class=""><li id="bd9b" class="nc nd iu md b me mf mh mi mk ne mo nf ms ng mw nh ni nj nk bi translated"><strong class="md je">优点:</strong> 1)很好地识别任意形状的簇；2)可以识别异常值，这可能是练习的主要目标。</li><li id="93c6" class="nc nd iu md b me nl mh nm mk nn mo no ms np mw nh ni nj nk bi translated"><strong class="md je">缺点</strong>:由于Epsilon和MinPts是固定的，所以当数据中存在变化的密度时，它不能很好地工作。</li></ul><div class="kt ku kv kw gu ab cb"><figure class="oo kx op oq or os ot paragraph-image"><a href="https://solclover.com/membership"><img src="../Images/63320331b74bd98eea6402472b4209ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*qkXay39OnVc2IosW6rkxtw.png"/></a></figure><figure class="oo kx op oq or os ot paragraph-image"><a href="https://www.linkedin.com/in/saulius-dobilas/"><img src="../Images/60fb21d1cb2701bfb6b71f61c99403e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*vabxOXtQ4T034N_mscHSmQ.png"/></a></figure></div><h1 id="bedc" class="lj lk iu bd ll lm ln lo lp lq lr ls lt kj lu kk lv km lw kn lx kp ly kq lz ma bi translated">DBSCAN集群的Python示例</h1><p id="bfbc" class="pw-post-body-paragraph mb mc iu md b me mf ke mg mh mi kh mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">现在我们已经了解了DBSCAN算法，让我们用Python创建一个集群模型。</p><h2 id="6bdc" class="oc lk iu bd ll od oe dn lp of og dp lt mk oh oi lv mo oj ok lx ms ol om lz ja bi translated">设置</h2><p id="5d4e" class="pw-post-body-paragraph mb mc iu md b me mf ke mg mh mi kh mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">我们将使用以下数据和库:</p><ul class=""><li id="38ca" class="nc nd iu md b me mx mh my mk nz mo oa ms ob mw nh ni nj nk bi translated">【Kaggle的房价数据</li><li id="4be9" class="nc nd iu md b me nl mh nm mk nn mo no ms np mw nh ni nj nk bi translated"><a class="ae li" href="https://scikit-learn.org/stable/index.html" rel="noopener ugc nofollow" target="_blank">sci kit-学习库</a>用于<br/> 1)特征缩放(<a class="ae li" href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.MinMaxScaler.html#sklearn.preprocessing.MinMaxScaler" rel="noopener ugc nofollow" target="_blank">最小最大缩放器</a>)；<br/> 2)识别最佳超参数(<a class="ae li" href="https://scikit-learn.org/stable/modules/generated/sklearn.metrics.silhouette_score.html?highlight=silhouette#sklearn.metrics.silhouette_score" rel="noopener ugc nofollow" target="_blank">轮廓得分</a>)；<br/> 3)执行<a class="ae li" href="https://scikit-learn.org/stable/modules/generated/sklearn.cluster.DBSCAN.html" rel="noopener ugc nofollow" target="_blank"> DBSCAN聚类</a></li><li id="d90b" class="nc nd iu md b me nl mh nm mk nn mo no ms np mw nh ni nj nk bi translated">用于数据可视化的<a class="ae li" href="https://plotly.com/python/" rel="noopener ugc nofollow" target="_blank"> Plotly </a>和<a class="ae li" href="https://matplotlib.org/" rel="noopener ugc nofollow" target="_blank"> Matplotlib </a></li><li id="c1df" class="nc nd iu md b me nl mh nm mk nn mo no ms np mw nh ni nj nk bi translated"><a class="ae li" href="https://pandas.pydata.org/docs/" rel="noopener ugc nofollow" target="_blank">熊猫</a>进行数据操作</li></ul><p id="c228" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">让我们导入所有的库:</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="ou ny l"/></div></figure><p id="c42c" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">接下来，我们下载并读入将用于构建DBSCAN集群模型的数据。<br/> <em class="nt">(来源:</em><a class="ae li" href="https://www.kaggle.com/quantbruce/real-estate-price-prediction?select=Real+estate.csv" rel="noopener ugc nofollow" target="_blank"><em class="nt">https://www . ka ggle . com/quant Bruce/real-estate-price-prediction？select = Real+estate . CSV</em></a><em class="nt">)</em></p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="ou ny l"/></div></figure><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj ov"><img src="../Images/a855813f7eaaea57a80c2a8ff2a15d54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nWD-MIniAPRGJsEK49S61A.png"/></div></div><p class="le lf gk gi gj lg lh bd b be z dk translated">来自<a class="ae li" href="https://www.kaggle.com/quantbruce/real-estate-price-prediction?select=Real+estate.csv" rel="noopener ugc nofollow" target="_blank"> Kaggle </a>的房价数据。图片由<a class="ae li" href="https://solclover.com/" rel="noopener ugc nofollow" target="_blank">作者</a>提供。</p></figure><p id="6026" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">我们将使用以下3个特征对观察结果进行聚类:</p><ul class=""><li id="9cc3" class="nc nd iu md b me mx mh my mk nz mo oa ms ob mw nh ni nj nk bi translated">“X3距离最近的捷运站”</li><li id="f0f6" class="nc nd iu md b me nl mh nm mk nn mo no ms np mw nh ni nj nk bi translated">《X2房子时代》</li><li id="3018" class="nc nd iu md b me nl mh nm mk nn mo no ms np mw nh ni nj nk bi translated">单位面积的房价。</li></ul><p id="373f" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">请注意，此数据旨在用于根据可用功能预测房价。这就是为什么字段名以X和Y开头，表示什么应该是特征，什么应该是目标。然而，由于我们将它用于不同的目的(例如，集群)，我们可以忽略命名约定。</p><p id="b563" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">让我们在三维图上绘制观察结果。</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="ou ny l"/></div></figure><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="nx ny l"/></div><p class="le lf gk gi gj lg lh bd b be z dk translated">住房数据的3D散点图。图表作者<a class="ae li" href="https://solclover.com/" rel="noopener ugc nofollow" target="_blank">作者</a>。</p></figure><h2 id="bc2d" class="oc lk iu bd ll od oe dn lp of og dp lt mk oh oi lv mo oj ok lx ms ol om lz ja bi translated">数据准备—特征缩放</h2><p id="0fc1" class="pw-post-body-paragraph mb mc iu md b me mf ke mg mh mi kh mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">对于聚类，尤其是基于密度的方法，在将数据放入模型之前准备数据是至关重要的。虽然您可能希望执行多个变换，但最常见的是缩放。</p><p id="b086" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">当您的要素分布具有非常不同的范围时，就会进行缩放。例如，在这个例子中，离最近的MRT站的距离在0和6，488之间，而房屋年龄在0到44之间。因此需要对它们进行缩放，以使它们符合相同的范围。否则，为epsilon选择一个值就不容易了，并且一个特征可能最终单独负责聚类的结果。</p><p id="b3ad" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">让我们画出这三个特征的分布图。</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="ou ny l"/></div></figure><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj ow"><img src="../Images/25182280a45f8d358a290970245d3433.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gyi3AN1g5-oes3vTHtJFzw.png"/></div></div><p class="le lf gk gi gj lg lh bd b be z dk translated">三个特征的分布。图片由<a class="ae li" href="https://solclover.com/" rel="noopener ugc nofollow" target="_blank">作者</a>提供。</p></figure><p id="0147" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">现在让我们应用最小-最大缩放，并再次绘制它。</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="ou ny l"/></div></figure><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj ox"><img src="../Images/3bd076ef99b0f0d2fcc1298f085b1ec7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kc-uW1vunTEcLNpmxoIPvA.png"/></div></div><p class="le lf gk gi gj lg lh bd b be z dk translated">最小-最大缩放后三个特征的分布。图片由<a class="ae li" href="https://solclover.com/" rel="noopener ugc nofollow" target="_blank">作者</a>提供。</p></figure><p id="895e" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">如您所见，最小-最大缩放并没有影响要素的基本分布。相反，它缩小了范围，所以它们现在都在0到1之间。</p><p id="b91a" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">在某些情况下，您可能还想对分布应用转换。例如，到最近的MRT的距离看起来类似于对数分布，这意味着大多数房屋都位于车站附近，很少有房屋离车站较远。</p><p id="aae2" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">因此，如果您对区分靠近MRT的所有房屋更感兴趣，而对较远的房屋不太感兴趣，那么您可以应用对数变换来展开它们。</p><h2 id="d9b1" class="oc lk iu bd ll od oe dn lp of og dp lt mk oh oi lv mo oj ok lx ms ol om lz ja bi translated">DBSCAN聚类-选择超参数值</h2><p id="004c" class="pw-post-body-paragraph mb mc iu md b me mf ke mg mh mi kh mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">现在我们已经准备好了我们的特性，让我们决定epsilon和MinPts的值。为此，我们将使用sklearn库中可用的剪影乐谱。以下是从其<a class="ae li" href="https://scikit-learn.org/stable/modules/clustering.html#silhouette-coefficient" rel="noopener ugc nofollow" target="_blank">文档</a>中直接引用的一段话:</p><blockquote class="nq nr ns"><p id="dd73" class="mb mc nt md b me mx ke mg mh my kh mj nu mz mm mn nv na mq mr nw nb mu mv mw in bi translated">轮廓系数是为每个样本定义的，由两个分数组成:<br/> <strong class="md je"> a: </strong>一个样本与同一类中所有其他点之间的平均距离。<br/> <strong class="md je"> b: </strong>样本与下一个最近的聚类中所有其他点之间的平均距离。</p><p id="1dba" class="mb mc nt md b me mx ke mg mh my kh mj nu mz mm mn nv na mq mr nw nb mu mv mw in bi translated">单个样品的轮廓系数<strong class="md je"> s </strong>为:</p></blockquote><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div class="gi gj oy"><img src="../Images/1c0f2b4f8b18efb77da835d3a1673bf3.png" data-original-src="https://miro.medium.com/v2/resize:fit:654/format:webp/0*mUfFqisz78mhtVes.png"/></div></figure><blockquote class="nq nr ns"><p id="a7e5" class="mb mc nt md b me mx ke mg mh my kh mj nu mz mm mn nv na mq mr nw nb mu mv mw in bi translated">一组样本的轮廓系数是每个样本的轮廓系数的平均值。</p></blockquote><p id="8e0e" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">让我们使用epsilon和MinPts的不同组合创建多个DBSCAN模型，并绘制轮廓分数。</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="ou ny l"/></div></figure><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj ox"><img src="../Images/2c1047a5207c771f4dd8ced4fc9fad61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WENmE9wZeKN1ihoRrTRhMg.png"/></div></div><p class="le lf gk gi gj lg lh bd b be z dk translated">不同ε和MinPts的剪影分数。图片由<a class="ae li" href="https://solclover.com/" rel="noopener ugc nofollow" target="_blank">作者</a>提供。</p></figure><p id="385c" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">看上面，我们可以看到eps=0.08产生最高的分数。一些组合最终具有非常相似的分数，这表明这些组合的聚类输出也是相似的。</p><p id="e1d1" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">我们将选择两种不同的组合来说明超参数选择的结果如何不同。我们将对第一个模型使用eps=0.08和MinPts=3，对第二个模型使用eps=0.06和MinPts=6。</p><h2 id="7983" class="oc lk iu bd ll od oe dn lp of og dp lt mk oh oi lv mo oj ok lx ms ol om lz ja bi translated">DBSCAN聚类-运行算法</h2><p id="e5ec" class="pw-post-body-paragraph mb mc iu md b me mf ke mg mh mi kh mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">让我们构建模型并打印分类标签:</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="ou ny l"/></div></figure><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj oz"><img src="../Images/e931ddb2f6853bdd21c6c3b6ab33f9a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VanOgO5y-vEkhwlJE0uSwA.png"/></div></div><p class="le lf gk gi gj lg lh bd b be z dk translated">DBSCAN模型集群标签。图片由<a class="ae li" href="https://solclover.com/" rel="noopener ugc nofollow" target="_blank">作者</a>提供。</p></figure><blockquote class="nq nr ns"><p id="92ff" class="mb mc nt md b me mx ke mg mh my kh mj nu mz mm mn nv na mq mr nw nb mu mv mw in bi translated">注意，-1表示模型将该点定义为异常值(噪声)。</p></blockquote><p id="f982" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">您可以立即看到，第一个模型(eps=0.08，MinPts=3)的聚类较少，聚类0和1比其他模型大得多。同时，第二个模型(eps=0.06，MinPts=6)产生了更多的簇，这是选择更小的ε的直接结果。</p><p id="660b" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">为了使结果更加直观，让我们使用不同的颜色创建相同的3D散点图。</p><p id="99ff" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">首先，让我们将聚类标签合并回数据框。</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="ou ny l"/></div></figure><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj pa"><img src="../Images/cb7e1d3fb2d97f297ec7a65c3724dc74.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T3RgkQK2EVpCk-f6pcdQ6A.png"/></div></div><p class="le lf gk gi gj lg lh bd b be z dk translated">用DBSCAN簇标签存放数据。图片由<a class="ae li" href="https://solclover.com/" rel="noopener ugc nofollow" target="_blank">作者</a>提供。</p></figure><p id="47b7" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">为第一个模型绘制3D图表(eps=0.08，MinPts=3)。</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="ou ny l"/></div></figure><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="nx ny l"/></div><p class="le lf gk gi gj lg lh bd b be z dk translated">第一个DBSCAN模型的3D散点图。图表作者<a class="ae li" href="https://solclover.com/" rel="noopener ugc nofollow" target="_blank">作者</a>。</p></figure><p id="0a05" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">然后我们运行相同的代码，但是用['DBSCAN Clusters 66']替换['DBSCAN Clusters 83']。</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="nx ny l"/></div><p class="le lf gk gi gj lg lh bd b be z dk translated">第二个DBSCAN模型的3D散点图。图表作者<a class="ae li" href="https://solclover.com/" rel="noopener ugc nofollow" target="_blank">作者</a>。</p></figure><p id="f0be" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">如您所见，第二个模型进一步将两个大集群分成了几个小集群。</p><p id="5bc4" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">第一个模型中两个大集群的形成是由位于MRT站附近的大多数房屋驱动的(见分布图)。虽然我们提到可以使用对数变换来展开这些观察结果，但我们在第二个模型中采用了不同的方法，而是降低了ε值。</p><h1 id="52c1" class="lj lk iu bd ll lm ln lo lp lq lr ls lt kj lu kk lv km lw kn lx kp ly kq lz ma bi translated">结论</h1><p id="3f87" class="pw-post-body-paragraph mb mc iu md b me mf ke mg mh mi kh mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">当您具有任意形状的聚类或者您对查找数据中的异常值感兴趣时，基于密度的聚类是您应该考虑的方法。</p><p id="a447" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">尽管如此，本文的主要观点应该是集群没有唯一正确的答案。因此，在生成最终的聚类模型之前，考虑数据的多种预处理方法并测试一系列不同的超参数值非常重要。</p><p id="0d6e" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">我希望我的Python代码和详细的算法演练已经让您对DBSCAN有了很好的理解。此外，如果您希望继续了解这个主题，我还列出了一些可选聚类算法的链接。</p><p id="3a99" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">干杯！👏<br/>T3【索尔·多比拉斯】T4</p></div><div class="ab cl pb pc hy pd" role="separator"><span class="pe bw bk pf pg ph"/><span class="pe bw bk pf pg ph"/><span class="pe bw bk pf pg"/></div><div class="in io ip iq ir"><p id="2a21" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated"><strong class="md je"> <em class="nt">如果你已经花光了这个月的学习预算，下次请记得我。</em> </strong> <em class="nt">我的个性化链接加入媒介是:</em></p><div class="pi pj gq gs pk pl"><a href="https://solclover.com/membership" rel="noopener  ugc nofollow" target="_blank"><div class="pm ab fp"><div class="pn ab po cl cj pp"><h2 class="bd je gz z fq pq fs ft pr fv fx jd bi translated">通过我的推荐链接加入Medium索尔·多比拉斯</h2><div class="ps l"><h3 class="bd b gz z fq pq fs ft pr fv fx dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="pt l"><p class="bd b dl z fq pq fs ft pr fv fx dk translated">solclover.com</p></div></div><div class="pu l"><div class="pv l pw px py pu pz lc pl"/></div></div></a></div></div><div class="ab cl pb pc hy pd" role="separator"><span class="pe bw bk pf pg ph"/><span class="pe bw bk pf pg ph"/><span class="pe bw bk pf pg"/></div><div class="in io ip iq ir"><div class="kt ku kv kw gu pl"><a rel="noopener follow" target="_blank" href="/gmm-gaussian-mixture-models-how-to-successfully-use-it-to-cluster-your-data-891dc8ac058f"><div class="pm ab fp"><div class="pn ab po cl cj pp"><h2 class="bd je gz z fq pq fs ft pr fv fx jd bi translated">GMM:高斯混合模型——如何成功地使用它对你的数据进行聚类？</h2><div class="ps l"><h3 class="bd b gz z fq pq fs ft pr fv fx dk translated">GMM的直观解释和有用的Python示例</h3></div><div class="pt l"><p class="bd b dl z fq pq fs ft pr fv fx dk translated">towardsdatascience.com</p></div></div><div class="pu l"><div class="qa l pw px py pu pz lc pl"/></div></div></a></div><div class="pi pj gq gs pk pl"><a rel="noopener follow" target="_blank" href="/hac-hierarchical-agglomerative-clustering-is-it-better-than-k-means-4ff6f459e390"><div class="pm ab fp"><div class="pn ab po cl cj pp"><h2 class="bd je gz z fq pq fs ft pr fv fx jd bi translated">HAC:层次凝聚聚类。比K-Means好吗？</h2><div class="ps l"><h3 class="bd b gz z fq pq fs ft pr fv fx dk translated">HAC算法的详细介绍，以及Python代码和几个有用的图表</h3></div><div class="pt l"><p class="bd b dl z fq pq fs ft pr fv fx dk translated">towardsdatascience.com</p></div></div><div class="pu l"><div class="qb l pw px py pu pz lc pl"/></div></div></a></div><div class="pi pj gq gs pk pl"><a rel="noopener follow" target="_blank" href="/k-means-clustering-a-comprehensive-guide-to-its-successful-use-in-python-c3893957667d"><div class="pm ab fp"><div class="pn ab po cl cj pp"><h2 class="bd je gz z fq pq fs ft pr fv fx jd bi translated">K-Means聚类——在Python中成功使用的综合指南</h2><div class="ps l"><h3 class="bd b gz z fq pq fs ft pr fv fx dk translated">用真实数据的Python演示解释K-Means算法</h3></div><div class="pt l"><p class="bd b dl z fq pq fs ft pr fv fx dk translated">towardsdatascience.com</p></div></div><div class="pu l"><div class="qc l pw px py pu pz lc pl"/></div></div></a></div></div></div>    
</body>
</html>