<html>
<head>
<title>Playfair Cipher Encryption</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">公平密码加密</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/playfair-cipher-encryption-fa8ed7df8ea5?source=collection_archive---------12-----------------------#2021-05-27">https://towardsdatascience.com/playfair-cipher-encryption-fa8ed7df8ea5?source=collection_archive---------12-----------------------#2021-05-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="6759" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用Playfair密码加密字符串的c代码</h2></div><h2 id="ca6a" class="kf kg iq bd kh ki kj dn kk kl km dp kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">内容</h2><ol class=""><li id="42eb" class="lb lc iq ld b le lf lg lh ko li ks lj kw lk ll lm ln lo lp bi translated"><a class="ae lq" href="#f665" rel="noopener ugc nofollow">简介</a></li><li id="9517" class="lb lc iq ld b le lr lg ls ko lt ks lu kw lv ll lm ln lo lp bi translated"><a class="ae lq" href="#de39" rel="noopener ugc nofollow">公平竞赛密码</a></li><li id="80f2" class="lb lc iq ld b le lr lg ls ko lt ks lu kw lv ll lm ln lo lp bi translated"><a class="ae lq" href="#7722" rel="noopener ugc nofollow">加密规则</a></li><li id="060c" class="lb lc iq ld b le lr lg ls ko lt ks lu kw lv ll lm ln lo lp bi translated"><a class="ae lq" href="#e358" rel="noopener ugc nofollow"> C实现</a></li><li id="5464" class="lb lc iq ld b le lr lg ls ko lt ks lu kw lv ll lm ln lo lp bi translated"><a class="ae lq" href="#d2ea" rel="noopener ugc nofollow">一些纯文本的输出</a></li><li id="3e2e" class="lb lc iq ld b le lr lg ls ko lt ks lu kw lv ll lm ln lo lp bi translated"><a class="ae lq" href="#70bc" rel="noopener ugc nofollow">延伸阅读</a></li></ol><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div class="gh gi lw"><img src="../Images/a6ae39caf4093d98c0262812a633917e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1334/format:webp/1*npghPg3IE1hhCBMfApFFOg.jpeg"/></div><p class="me mf gj gh gi mg mh bd b be z dk translated">法比奥于<a class="ae lq" href="https://unsplash.com/photos/oyXis2kALVg" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>发表</p></figure><h2 id="f665" class="kf kg iq bd kh ki kj dn kk kl km dp kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">介绍</h2><p id="e2e1" class="pw-post-body-paragraph mi mj iq ld b le lf jr mk lg lh ju ml ko mm mn mo ks mp mq mr kw ms mt mu ll ij bi translated">密码学是秘密写作的科学或艺术。加密技术的基本目标是让两个人能够在不安全的信道上进行通信，使对方无法理解对方在说什么。目前使用的加密技术主要有两种</p><ol class=""><li id="6343" class="lb lc iq ld b le mv lg mw ko mx ks my kw mz ll lm ln lo lp bi translated"><strong class="ld ir">对称密钥加密</strong>-加密和解密使用相同的密钥</li><li id="b7d7" class="lb lc iq ld b le lr lg ls ko lt ks lu kw lv ll lm ln lo lp bi translated"><strong class="ld ir">非对称密钥加密</strong>-一个密钥用于加密，另一个用于解密</li></ol><p id="8db1" class="pw-post-body-paragraph mi mj iq ld b le mv jr mk lg mw ju ml ko na mn mo ks nb mq mr kw nc mt mu ll ij bi translated">还有许多其他类型的密码，如单表和多表、流和分组等。这篇文章着眼于Playfair密码及其使用C函数的应用。</p><h2 id="de39" class="kf kg iq bd kh ki kj dn kk kl km dp kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">公平密码</h2><p id="6738" class="pw-post-body-paragraph mi mj iq ld b le lf jr mk lg lh ju ml ko mm mn mo ks mp mq mr kw ms mt mu ll ij bi translated">由查尔斯·惠斯通发明的公平密码(Playfair cipher)是一种多字母替代密码，这意味着一个字母可以在其加密中由不同的字母表示，这取决于给双方使用的关键字。例如，让我们假设关键字是'<em class="nd">查尔斯'</em>。绘制一个5x5的矩阵，在每个单元格中填充字母，从关键字开始，后面是字母表中的字母。I/J填充在同一个单元格中。所有重复的字母都被去掉了，给了我们这个矩阵-</p><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/69f50ac4493c4de05aba87a2ce37c5b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:540/format:webp/1*Y_0-lb5XnHYqi1XMEtNuKQ.png"/></div><p class="me mf gj gh gi mg mh bd b be z dk translated">作者图片-关键字'<em class="nf">查尔斯</em>'的公平矩阵</p></figure><p id="28bb" class="pw-post-body-paragraph mi mj iq ld b le mv jr mk lg mw ju ml ko na mn mo ks nb mq mr kw nc mt mu ll ij bi translated">给定一个明文句子，它被分割成两个字母组，去掉所有空格，并在字母数为奇数的情况下用字母x填充。重复的纯文本字母用填充字母(如x)分隔。给定句子“<em class="nd">在桥上见我</em>”,两个数字将是-</p><blockquote class="ng"><p id="91ff" class="nh ni iq bd nj nk nl nm nn no np ll dk translated">在eb ri dg ex见我</p></blockquote><h2 id="7722" class="kf kg iq bd kh ki nq dn kk kl nr dp kn ko ns kq kr ks nt ku kv kw nu ky kz la bi translated"><strong class="ak">加密规则</strong></h2><ol class=""><li id="db81" class="lb lc iq ld b le lf lg lh ko li ks lj kw lk ll lm ln lo lp bi translated">矩阵同一行中的两个明文字母分别被右边的字母替换，该行的第一个元素循环跟随最后一个元素。</li></ol><blockquote class="ng"><p id="5a4f" class="nh ni iq bd nj nk nv nw nx ny nz ll dk translated">eb将由sd代替</p><p id="d579" class="nh ni iq bd nj nk nl nm nn no np ll dk translated">ng将由gi/gj代替</p></blockquote><p id="9ba8" class="pw-post-body-paragraph mi mj iq ld b le oa jr mk lg ob ju ml ko oc mn mo ks od mq mr kw oe mt mu ll ij bi translated">2.落在矩阵的同一列中的两个明文字母被下面的字母替换，该列的顶部元素循环跟随底部元素。</p><blockquote class="ng"><p id="fc71" class="nh ni iq bd nj nk nl nm nn no np ll dk translated">dt将被我的</p><p id="aadb" class="nh ni iq bd nj nk nl nm nn no np ll dk translated">ty将由yr代替</p></blockquote><p id="e950" class="pw-post-body-paragraph mi mj iq ld b le oa jr mk lg ob ju ml ko oc mn mo ks od mq mr kw oe mt mu ll ij bi translated">3.否则，一对中的每个明文字母都将被位于其自己的行中的字母和被另一个明文字母占据的列所替换。</p><blockquote class="ng"><p id="00f1" class="nh ni iq bd nj nk nl nm nn no np ll dk translated">我会被gd取代</p><p id="8968" class="nh ni iq bd nj nk nl nm nn no np ll dk translated">et将被do取代</p></blockquote><p id="ff68" class="pw-post-body-paragraph mi mj iq ld b le oa jr mk lg ob ju ml ko oc mn mo ks od mq mr kw oe mt mu ll ij bi translated">遵循这些规则，密文变成<em class="nd"> 'gd do gd rq pr sd hm em bv' </em>。</p><p id="7ef3" class="pw-post-body-paragraph mi mj iq ld b le mv jr mk lg mw ju ml ko na mn mo ks nb mq mr kw nc mt mu ll ij bi translated">这种密码比简单的替换更安全，但是通过对字母对进行统计频率计数，仍然容易受到纯密文攻击，因为每对字母总是以相同的方式加密。此外，短关键字使得Playfair密码更容易破解。</p><h2 id="e358" class="kf kg iq bd kh ki kj dn kk kl km dp kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">实施情况</h2><p id="cf80" class="pw-post-body-paragraph mi mj iq ld b le lf jr mk lg lh ju ml ko mm mn mo ks mp mq mr kw ms mt mu ll ij bi translated">首先，我们导入所需的库，并为要加密的字符串分配定义一个足够大的大小。</p><pre class="lx ly lz ma gt of og oh oi aw oj bi"><span id="6883" class="kf kg iq og b gy ok ol l om on">#include &lt;stdio.h&gt;<br/>#include &lt;stdlib.h&gt;<br/>#include &lt;string.h&gt; <br/>#define SIZE 100</span></pre><p id="d37f" class="pw-post-body-paragraph mi mj iq ld b le mv jr mk lg mw ju ml ko na mn mo ks nb mq mr kw nc mt mu ll ij bi translated">现在我们编写一个函数来使用Playfair密码加密明文。字符串被转换为大写，所有空格都被删除。明文被填充为偶数长度，字母对变得不相同。生成5x5的关键正方形。为此，首先使用一个26字符的hashmap来存储密钥字符串中每个字母的计数。使用这种方法，矩阵中的每个单元格首先用关键字字符串字母填充，并且通过减少hashmap中的计数只填充一次。然后填充剩余的字母表。</p><p id="afeb" class="pw-post-body-paragraph mi mj iq ld b le mv jr mk lg mw ju ml ko na mn mo ks nb mq mr kw nc mt mu ll ij bi translated">然后在有向图中搜索明文中的每个字符，并找到它的位置。根据字符对中字符的相对位置，遵循上述详细规则，执行加密，并返回加密的字符对。</p><pre class="lx ly lz ma gt of og oh oi aw oj bi"><span id="4658" class="kf kg iq og b gy ok ol l om on">// Function to encrypt using the Playfair Cipher<br/>void PlayfairCrypt(char str[], char keystr[])<br/>{<br/>    char keyT[5][5], ks, ps;<br/><br/>    // Key<br/>    ks = strlen(keystr);<br/>    // Plaintext<br/>    ps = strlen(str);<br/><br/>    // Function to convert the string to uppercase<br/>    // Can also use the library function toUpper here, but a function was written for better understanding of ascii values.<br/>    void toUpperCase(char encrypt[], int ps)<br/>    {<br/>        int i;<br/>        for (i = 0; i &lt; ps; i++) {<br/>            if (encrypt[i] &gt; 96 &amp;&amp; encrypt[i] &lt; 123)<br/>                encrypt[i] -= 32;<br/>        }<br/>    }<br/><br/>    // Function to remove all spaces in a string<br/>    int removeSpaces(char* plain, int ps)<br/>    {<br/>        int i, count = 0;<br/>        for (i = 0; i &lt; ps; i++)<br/>            if (plain[i] != ' ')<br/>                plain[count++] = plain[i];<br/>        plain[count] = '\0';<br/>        return count;<br/>    }<br/><br/>    // Function to generate the 5x5 key square<br/>    void generateKeyTable(char keystr[], int ks, char keyT[5][5])<br/>    {<br/>        int i, j, k, flag = 0, *dicty;<br/><br/>        // a 26 character hashmap to store count of the alphabet<br/>        dicty = (int*)calloc(26, sizeof(int));<br/>        for (i = 0; i &lt; ks; i++) {<br/>            if (keystr[i] != 'j')<br/>                dicty[keystr[i] - 97] = 2;<br/>        }<br/><br/>        dicty['j' - 97] = 1;<br/><br/>        i = 0;<br/>        j = 0;<br/><br/>        for (k = 0; k &lt; ks; k++) {<br/>            if (dicty[keystr[k] - 97] == 2) {<br/>                dicty[keystr[k] - 97] -= 1;<br/>                keyT[i][j] = keystr[k];<br/>                j++;<br/>                if (j == 5) {<br/>                    i++;<br/>                    j = 0;<br/>                }<br/>            }<br/>        }<br/><br/>        for (k = 0; k &lt; 26; k++) {<br/>            if (dicty[k] == 0) {<br/>                keyT[i][j] = (char)(k + 97);<br/>                j++;<br/>                if (j == 5) {<br/>                    i++;<br/>                    j = 0;<br/>                }<br/>            }<br/>        }<br/>    }<br/><br/>    // Function to search for the characters of a digraph in the key square and return their position<br/>    void search(char keyT[5][5], char a, char b, int arr[])<br/>    {<br/>        int i, j;<br/><br/>        if (a == 'j')<br/>            a = 'i';<br/>        else if (b == 'j')<br/>            b = 'i';<br/><br/>        for (i = 0; i &lt; 5; i++) {<br/><br/>            for (j = 0; j &lt; 5; j++) {<br/><br/>                if (keyT[i][j] == a) {<br/>                    arr[0] = i;<br/>                    arr[1] = j;<br/>                }<br/>                else if (keyT[i][j] == b) {<br/>                    arr[2] = i;<br/>                    arr[3] = j;<br/>                }<br/>            }<br/>        }<br/>    }<br/><br/>    // Function to make the plain text length even, and make pairs unidentical.<br/>    int prepare(char str[], int ptrs)<br/>    {<br/>        int i, j, subs_s = ptrs;<br/>        for (i = 0; i &lt; subs_s; i += 2) {<br/>            if(str[i]==str[i+1]){<br/>                for(j=subs_s; j&gt;i+1; j--){<br/>                   str[j]=str[j-1];<br/>                }<br/>                str[i+1]='x';<br/>                subs_s+=1;<br/>            }<br/>        }<br/>        str[subs_s]='\0';<br/><br/>        if (subs_s % 2 != 0) {<br/>            str[subs_s++] = 'z';<br/>            str[subs_s] = '\0';<br/>        }<br/>        return subs_s;<br/>    }<br/><br/>    // Function for performing the encryption<br/>    void encrypt(char str[], char keyT[5][5], int ps)<br/>    {<br/>        int i, a[4];<br/><br/>        for(i=0; i&lt;ps; i+=2){<br/><br/>            search(keyT, str[i], str[i + 1], a);<br/><br/>            if (a[0] == a[2]) {<br/>                str[i] = keyT[a[0]][(a[1] + 1)%5];<br/>                str[i + 1] = keyT[a[0]][(a[3] + 1)%5];<br/>            }<br/>            else if (a[1] == a[3]) {<br/>                str[i] = keyT[(a[0] + 1)%5][a[1]];<br/>                str[i + 1] = keyT[(a[2] + 1)%5][a[1]];<br/>            }<br/>            else {<br/>                str[i] = keyT[a[0]][a[3]];<br/>                str[i + 1] = keyT[a[2]][a[1]];<br/>            }<br/>        }<br/>    }<br/><br/>    ks = removeSpaces(keystr, ks);<br/>    ps = removeSpaces(str, ps);<br/>    ps = prepare(str, ps);<br/>    generateKeyTable(keystr, ks, keyT);<br/>    encrypt(str, keyT, ps);<br/>    toUpperCase(str, ps);<br/>    //cipher text - printed in upper case letters<br/>    printf("Cipher text: %s\n", str);<br/>}</span></pre><p id="f96e" class="pw-post-body-paragraph mi mj iq ld b le mv jr mk lg mw ju ml ko na mn mo ks nb mq mr kw nc mt mu ll ij bi translated">驱动程序代码只接受输入密钥字符串和输入明文，并调用输出加密字符串的PlayfairCrypt函数。</p><pre class="lx ly lz ma gt of og oh oi aw oj bi"><span id="bf38" class="kf kg iq og b gy ok ol l om on">// Driver code<br/>int main()<br/>{<br/>    char str[SIZE], keystr[SIZE];<br/><br/>    //Key used - to be entered in lower case letters<br/>    printf("Enter the key: ");<br/>    scanf("%[^\n]s", &amp;keystr);<br/>    printf("Key text: %s\n", keystr);<br/><br/>    // Plaintext to be encrypted - entered in lower case letters<br/>    printf("Enter the plaintext: ");<br/>    scanf("\n");<br/>    scanf("%[^\n]s", &amp;str);<br/>    printf("Plain text: %s\n", str);<br/><br/>    //Calling the PlayfairCrypt function<br/>    PlayfairCrypt(str, keystr);<br/><br/>    return 0;<br/>}</span></pre><h2 id="d2ea" class="kf kg iq bd kh ki kj dn kk kl km dp kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">一些纯文本的输出</h2><p id="a6f0" class="pw-post-body-paragraph mi mj iq ld b le lf jr mk lg lh ju ml ko mm mn mo ks mp mq mr kw ms mt mu ll ij bi translated">使用关键字字符串'<em class="nd"> diskjockey </em>'对上述代码进行编译、运行和测试。</p><ol class=""><li id="1863" class="lb lc iq ld b le mv lg mw ko mx ks my kw mz ll lm ln lo lp bi translated">这批货将于中午到达</li><li id="78fd" class="lb lc iq ld b le lr lg ls ko lt ks lu kw lv ll lm ln lo lp bi translated">周五之前保持低调</li><li id="024c" class="lb lc iq ld b le lr lg ls ko lt ks lu kw lv ll lm ln lo lp bi translated">永远走后门</li><li id="b734" class="lb lc iq ld b le lr lg ls ko lt ks lu kw lv ll lm ln lo lp bi translated">电话被窃听了</li></ol><div class="lx ly lz ma gt ab cb"><figure class="oo mb op oq or os ot paragraph-image"><div role="button" tabindex="0" class="ou ov di ow bf ox"><img src="../Images/1c690c04f4361a8a43af1c0262ac8a55.png" data-original-src="https://miro.medium.com/v2/resize:fit:1060/format:webp/1*ocxFoSTx5ndkMDgVUgjKwg.png"/></div></figure><figure class="oo mb oy oq or os ot paragraph-image"><div role="button" tabindex="0" class="ou ov di ow bf ox"><img src="../Images/22e6b895a8fdb1c656072a62a1018dc3.png" data-original-src="https://miro.medium.com/v2/resize:fit:942/format:webp/1*scMN8BUBfGyRkarnGOUrEQ.png"/></div></figure></div><div class="ab cb"><figure class="oo mb oz oq or os ot paragraph-image"><img src="../Images/870f5a3d4edf33dc2649067506eecd0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:988/format:webp/1*AM3tmOG-jlL8bfnnm8rNhQ.png"/></figure><figure class="oo mb pa oq or os ot paragraph-image"><div role="button" tabindex="0" class="ou ov di ow bf ox"><img src="../Images/00baad366847a9665f66243829210157.png" data-original-src="https://miro.medium.com/v2/resize:fit:932/format:webp/1*O3bm7ar9jAUxu_cHcEITQw.png"/></div><p class="me mf gj gh gi mg mh bd b be z dk pb di pc pd translated">作者的图片——使用Playfair加密的C代码输出一些纯文本</p></figure></div><p id="2de6" class="pw-post-body-paragraph mi mj iq ld b le mv jr mk lg mw ju ml ko na mn mo ks nb mq mr kw nc mt mu ll ij bi translated">本文中使用和解释的全部代码可以在<a class="ae lq" href="https://github.com/ruthussanketh/cryptography/blob/main/playfair-cipher/codes/playfair_encrypt.c" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><h2 id="70bc" class="kf kg iq bd kh ki kj dn kk kl km dp kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">进一步阅读</h2><ol class=""><li id="6c43" class="lb lc iq ld b le lf lg lh ko li ks lj kw lk ll lm ln lo lp bi translated"><a class="ae lq" href="http://homepages.math.uic.edu/~lenz/f15.m260/project1.html" rel="noopener ugc nofollow" target="_blank">项目-实现Playfair密码的编码和解码</a></li><li id="20bd" class="lb lc iq ld b le lr lg ls ko lt ks lu kw lv ll lm ln lo lp bi translated">艾琳·鲍德温<a class="ae lq" href="https://derekbruff.org/blogs/fywscrypto/files/2010/11/Baldwin-Essay-2.pdf" rel="noopener ugc nofollow" target="_blank">——一篇关于公平游戏密码的论文</a></li><li id="35fc" class="lb lc iq ld b le lr lg ls ko lt ks lu kw lv ll lm ln lo lp bi translated">帕尔，拉马尼，艾扬格，苏尼塔。<a class="ae lq" href="https://people.cis.fiu.edu/gubbisadashiva/wp-content/uploads/sites/9/2019/11/A-Variation-in-the-Working-of-Playfair-Cipher.pdf" rel="noopener ugc nofollow" target="_blank">公平游戏密码工作方式的变化</a></li><li id="0e94" class="lb lc iq ld b le lr lg ls ko lt ks lu kw lv ll lm ln lo lp bi translated"><a class="ae lq" href="https://ruthussanketh.medium.com/playfair-cipher-decryption-c43b698b45bd" rel="noopener"> Playfair密码解密</a></li></ol></div></div>    
</body>
</html>