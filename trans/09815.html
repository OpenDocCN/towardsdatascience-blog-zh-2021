<html>
<head>
<title>Intro: GraphQL in Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">简介:Go中的GraphQL</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/intro-graphql-in-go-9fed8e2a3e18?source=collection_archive---------19-----------------------#2021-09-14">https://towardsdatascience.com/intro-graphql-in-go-9fed8e2a3e18?source=collection_archive---------19-----------------------#2021-09-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="25d3" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">什么是GraphQL，为什么使用它，以及如何在Golang中使用它</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/4e8a7cd463b2d400c9983563c4d624a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rGnghC78cZ5WBtvbRJ5akg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">GraphQL作为Go——Gopher中的架构解决方案由<a class="ae ky" href="https://twitter.com/tenntenn" rel="noopener ugc nofollow" target="_blank">上田拓也</a>绘制，灵感来自勒内·弗伦奇(CC BY 3.0)的作品</p></figure><p id="e48a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将使用Go内置的GraphQL服务器为地鼠构建一个雇佣代理API。与其他介绍不同，我不会用一个简短的声明列出所有组件的名称。相反，我们将一步一步地构建一个应用程序，并解释每个步骤中发生的事情。希望这种方法能让你更容易避免信息泛滥。我不仅会介绍GraphQL，还会介绍我在使用<code class="fe lv lw lx ly b"><a class="ae ky" href="https://github.com/graphql-go/graphql" rel="noopener ugc nofollow" target="_blank">graphql-go</a></code>时如何构建架构</p><p id="927f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要澄清的第一件事是一个非常普遍的误解。</p><blockquote class="lz"><p id="c17e" class="ma mb it bd mc md me mf mg mh mi lu dk translated">GraphQL不是数据库！— <a class="ae ky" href="https://graphql.org/faq/#is-graphql-a-database-language-like-sql" rel="noopener ugc nofollow" target="_blank">图表QL </a></p></blockquote><p id="e264" class="pw-post-body-paragraph kz la it lb b lc mj ju le lf mk jx lh li ml lk ll lm mm lo lp lq mn ls lt lu im bi translated">我觉得这个误解来源于名字，开发者习惯于听到所有的数据库名字<code class="fe lv lw lx ly b">MySQL</code>、<code class="fe lv lw lx ly b">PostgreSQL</code>等。重要的是最后两个字母，QL。如果你已经有一段时间了，你可能知道这是<code class="fe lv lw lx ly b">Query Language</code>的简称，但是我遇到的很多人只是把它和数据库联系起来。</p><p id="7bdf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，GraphQL是一种查询语言，旨在使服务器和客户端之间的通信更加容易和可靠。我们需要马上解决的另一件事是，GraphQL是数据库不可知的。这意味着它不关心正在使用的底层数据库。</p><blockquote class="mo mp mq"><p id="6596" class="kz la mr lb b lc ld ju le lf lg jx lh ms lj lk ll mt ln lo lp mu lr ls lt lu im bi translated">本文中的所有图片均由珀西·博尔梅勒绘制，地鼠由<a class="ae ky" href="https://twitter.com/tenntenn" rel="noopener ugc nofollow" target="_blank">拓也·上田</a>绘制，灵感来自蕾妮·弗伦奇的作品。图像中的地鼠已被修改。</p></blockquote><p id="d59e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你问这怎么可能？那么，您应该将GraphQL视为数据库和客户端之间的中间件。您有一个GraphQL服务器，它接收查询格式的请求，查询精确地指定您想要返回什么数据，服务器返回请求中定义的数据。</p><p id="7e41" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里定义并记录了查询语言<a class="ae ky" href="https://graphql.org/learn/schema/" rel="noopener ugc nofollow" target="_blank">。</a></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">这是搜索地鼠时查询的样子</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">这是示例查询的响应，请注意，只显示了需要的字段</p></figure><p id="a7e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你有任何关于GraphQL的问题，他们有一个非常好的FAQ<a class="ae ky" href="https://graphql.org/faq/" rel="noopener ugc nofollow" target="_blank">FAQ</a>。</p><p id="efa1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，我们将涵盖基础知识，我们将建立一个应用程序来搜索和寻找地鼠雇用。我们不会涵盖GraphQL的所有方面，那会太长。</p><h2 id="4b29" class="mx my it bd mz na nb dn nc nd ne dp nf li ng nh ni lm nj nk nl lq nm nn no np bi translated">为什么以及何时应该使用GraphQL</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/903fd32f485a8847a039986ed5c5b178.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SuV7q_dPNK_zMlUpoZbfvg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">GraphQL —使用多个数据源，但只有一个响应和一个请求</p></figure><p id="5084" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我承认，当我第一次听说GraphQL时，我持怀疑态度。我知道很多人也是如此。听起来好像只是在API和调用者之间增加一层会使事情变得更复杂。</p><p id="12bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但事实并非如此，我希望能让你相信这一点。</p><p id="4cfd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我发现使用GraphQL的一个最好的原因是能够组合数据源。我是<code class="fe lv lw lx ly b">RepositoryPattern</code>的忠实用户，你可以在我的领域驱动设计文章中找到讨论。</p><div class="nq nr gp gr ns nt"><a href="https://programmingpercy.tech/blog/how-to-domain-driven-design-ddd-golang/" rel="noopener  ugc nofollow" target="_blank"><div class="nu ab fo"><div class="nv ab nw cl cj nx"><h2 class="bd iu gy z fp ny fr fs nz fu fw is bi translated">如何在Golang中实现领域驱动设计(DDD)</h2><div class="oa l"><h3 class="bd b gy z fp ny fr fs nz fu fw dk translated">近年来，微服务已经成为一种非常流行的构建软件的方法。微服务用于构建…</h3></div><div class="ob l"><p class="bd b dl z fp ny fr fs nz fu fw dk translated">编程percy.tech</p></div></div><div class="oc l"><div class="od l oe of og oc oh ks nt"/></div></div></a></div><p id="7e73" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">简而言之，每个数据源都有一个存储库。对于我们正在构建的代理，我们将有存储地鼠的<code class="fe lv lw lx ly b">GopherRepository</code>和存储工作的<code class="fe lv lw lx ly b">JobRepository</code>。GraphQL可以轻松地将这两种结构组合成一个输出，而无需耦合后端的数据源。在我们将要构建的服务器中，它看起来像是<code class="fe lv lw lx ly b">Gopher</code>结构有<code class="fe lv lw lx ly b">Jobs</code>与之相关，但它实际上将是两个不同的存储解决方案。</p><p id="e059" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我喜欢GraphQL的第二个原因是，它允许用户精确地指定请求什么字段，从而避免了<a class="ae ky" href="https://www.howtographql.com/basics/1-graphql-is-the-better-rest/" rel="noopener ugc nofollow" target="_blank">过度提取</a>。您只发送一个请求，并且只获得您所请求的信息，没有未使用的额外字段。</p><p id="0a55" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">GraphQL的一个原则是开发过程应该从模式定义开始。这被称为<code class="fe lv lw lx ly b">Schema Driven Development</code>，我不会在这里讨论它，但是基本上，我们从模式而不是业务逻辑开始。</p><blockquote class="lz"><p id="419e" class="ma mb it bd mc md me mf mg mh mi lu dk translated">在GraphQL中，你的API从定义所有类型、查询和变化的模式开始，它帮助其他人理解你的API。这就像是服务器和客户端之间的契约。— GraphQL网站</p></blockquote><h2 id="7ba8" class="mx my it bd mz na oi dn nc nd oj dp nf li ok nh ni lm ol nk nl lq om nn no np bi translated">如何在Go中使用GraphQL</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/4dd7c44d72f9bee0c4e83a8b6f05122b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nYj58DDUF9Rd7x37tqFB7A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">下载所需的包并创建go模块</p></figure><p id="190c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先要做的是决定使用什么样的Go包。GraphQL网站维护着所有可用包的列表<a class="ae ky" href="https://graphql.org/code/#go" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="ccec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将使用<a class="ae ky" href="https://github.com/graphql-go/graphql" rel="noopener ugc nofollow" target="_blank"> graphql-go/graphql </a>，这是一个在官方<a class="ae ky" href="https://github.com/graphql/graphql-js" rel="noopener ugc nofollow" target="_blank"> graphql-js </a>参考之后构建的包。这个包不读取graphql模式文件，而是在go代码中定义模式。定义模式的方式与javascript端使用的方式相同，这很好。</p><p id="12b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将从创建一个包并获得所需的库开始。我们将获取用于构建和定义模式的<code class="fe lv lw lx ly b">graphql-go/graphql</code>,以及用于托管graphql服务器的<code class="fe lv lw lx ly b">graphql-go/handler</code>。</p><pre class="kj kk kl km gt on ly oo op aw oq bi"><span id="5da9" class="mx my it ly b gy or os l ot ou">go mod init github.com/programmingpercy/gopheragency<br/>go get github.com/graphql-go/graphql<br/>go get github.com/graphql-go/handler<br/>touch main.go</span></pre><h2 id="f386" class="mx my it bd mz na nb dn nc nd ne dp nf li ng nh ni lm nj nk nl lq nm nn no np bi translated">查询和解析器—提取数据</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/a83c18a2e84a57b871d53ba33a96c785.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f_Q4RvWRijIhqIjANGxZ3g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">查询是对数据的请求，解析器处理业务逻辑来查找数据</p></figure><p id="8ee1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">查询是从服务器获取数据的操作。通过根据<a class="ae ky" href="https://graphql.org/learn/schema/" rel="noopener ugc nofollow" target="_blank">模式</a>声明发送请求来执行查询。您在本文前面看到了一个示例查询，我们将以此为起点。响应中将只返回在<code class="fe lv lw lx ly b">query</code>中使用的<code class="fe lv lw lx ly b">fields</code>。</p><p id="d1e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在继续之前，我们需要了解两个关键词。</p><ul class=""><li id="0ade" class="ov ow it lb b lc ld lf lg li ox lm oy lq oz lu pa pb pc pd bi translated"><a class="ae ky" href="https://graphql.org/graphql-js/basic-types/" rel="noopener ugc nofollow" target="_blank">字段</a> —某一数据类型的值，<code class="fe lv lw lx ly b">String</code>，<code class="fe lv lw lx ly b">Int</code>，<code class="fe lv lw lx ly b">Float</code>，<code class="fe lv lw lx ly b">Boolean</code>，<code class="fe lv lw lx ly b">ID</code></li><li id="522f" class="ov ow it lb b lc pe lf pf li pg lm ph lq pi lu pa pb pc pd bi translated"><a class="ae ky" href="https://graphql.org/graphql-js/object-types/" rel="noopener ugc nofollow" target="_blank">对象</a> —一个带<code class="fe lv lw lx ly b">fields</code>的对象，把它想象成一个struct。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">我们展示查询中每个事物是什么的例子</p></figure><p id="f362" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要开始实现它，我们需要开始构建模式，记得<code class="fe lv lw lx ly b">Schema Driven Development</code>吗？</p><p id="f2e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将从创建可以查询的<code class="fe lv lw lx ly b">Gopher</code>对象开始。创建一个<code class="fe lv lw lx ly b">schema</code>文件夹，并在其中创建一个<code class="fe lv lw lx ly b">gopher.go</code>。</p><p id="87d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将从创建<code class="fe lv lw lx ly b">GopherType</code>开始，它是一个可以使用GraphQL发送的<code class="fe lv lw lx ly b">object</code>的声明。为了在<code class="fe lv lw lx ly b">graphql-go/graphql</code>中创建一个新的<code class="fe lv lw lx ly b">object</code>，我们使用了<code class="fe lv lw lx ly b">graphql.NewObject</code>函数，<code class="fe lv lw lx ly b">NewObject</code>的输入是一个<code class="fe lv lw lx ly b">ObjectConfig.</code></p><p id="c1aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个<code class="fe lv lw lx ly b">ObjectConfig </code>是一个用于配置如何定义<code class="fe lv lw lx ly b">object</code>的结构。config保存了一个<code class="fe lv lw lx ly b">graphql.Fields</code>对象，它是<code class="fe lv lw lx ly b">map[string]*graphql.Fields</code>的别名，记住<code class="fe lv lw lx ly b">Objects</code>是一组<code class="fe lv lw lx ly b">Fields</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">schemas/Gopher . go-Gopher对象类型的声明</p></figure><p id="9dbb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们已经定义了<code class="fe lv lw lx ly b">GopherType</code>,我们必须设置并托管一个能够响应查询的GraphQL服务器。</p><p id="6b1f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了拥有一个GraphQL服务器，我们需要一个<code class="fe lv lw lx ly b"><a class="ae ky" href="https://graphql.org/learn/execution/#root-fields-resolvers" rel="noopener ugc nofollow" target="_blank">RootQuery</a></code>，它是每个查询的基础。根查询将在顶层保存所有可用的查询。</p><p id="ab66" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当请求到达服务器时，必须获取数据。获取数据由<code class="fe lv lw lx ly b">Resolvers</code>完成，它是一个接受查询和所有<code class="fe lv lw lx ly b">arguments</code>的函数。我们将创建一个简单的服务器，在添加<code class="fe lv lw lx ly b">GopherType</code>之前先用一个简单的<code class="fe lv lw lx ly b">Hello</code>进行响应。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">main.go —一个简单的graphQL服务器，在端口8080上公开</p></figure><p id="5ab5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">更新main.go之后，在端口<code class="fe lv lw lx ly b">8080</code>上托管服务器，然后访问<a class="ae ky" href="http://localhost:8080/graphql" rel="noopener ugc nofollow" target="_blank"> localhost:8080/graphql </a>，您将看到一个UI，我们可以在其中测试当前的实现。</p><p id="9b3d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在左边你可以写下你的<code class="fe lv lw lx ly b">Query</code>，在中间你可以看到来自<code class="fe lv lw lx ly b">Resolver</code>的响应，在右边你可以看到一个可点击的树形结构，你可以用它来查看所有可用的查询。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pj"><img src="../Images/e89ff3732c957008bee71dc167d3dc61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7Zz424Iknb78F4ZJZWogaw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">GraphiQL——一个测试和实验查询的网站</p></figure><p id="0647" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尝试一下，看看你是否得到了正确的反应，以确保一切正常。</p><p id="46a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在是时候实现一个真正的解析器了，我们将创建一个名为<code class="fe lv lw lx ly b">gopher</code>的新文件夹，其中包含一个用于获取地鼠的<code class="fe lv lw lx ly b">Resolver</code>。创建<code class="fe lv lw lx ly b">resolver.go</code>文件，该文件将定义我们期望从地鼠数据存储中得到的所有<code class="fe lv lw lx ly b">Resolver</code>函数。</p><p id="93c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">记住，任何看起来像<code class="fe lv lw lx ly b">funcName(p graphql.ResolveParams) (interface{},error)</code>的函数都可以用作解析器。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">gopher/resolver.go —定义我们的gopher解析器的解析器接口</p></figure><p id="cdb1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">既然我们已经定义了一个解析器接口，我们需要实现它。让我们使用包含几个地鼠的内存数据存储。Gopher结构必须有<code class="fe lv lw lx ly b">JSON</code>标签来匹配定义的<code class="fe lv lw lx ly b">GopherType</code>。如果标签不匹配，则不会返回响应。</p><p id="d77f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建一个<code class="fe lv lw lx ly b">gopher.go</code>并填充该结构。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">gopher/gopher . go-与GopherType对象匹配的gopher结构</p></figure><p id="c00b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们创建一个<code class="fe lv lw lx ly b">Repository</code>来定义充当Gopher存储所需的函数。创建<code class="fe lv lw lx ly b">repository.go</code>并插入以下要点。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">gopher/repository.go —定义gopher存储的存储库接口</p></figure><p id="3e51" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们实现一个简单的内存数据存储库。我们将创建一个<code class="fe lv lw lx ly b">memory.go</code>并填充超级简单的存储解决方案，为我们生成两个地鼠。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">memory . go——内存地鼠的简单存储解决方案</p></figure><p id="11a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">很好，我们现在可以开始实现用于处理查询的<code class="fe lv lw lx ly b">Resolvers</code>。让我们从简单开始，用所有可用的地鼠实现响应。我们将有一个实现<code class="fe lv lw lx ly b">Resolver</code>接口的结构。我们采用这种结构的原因将在后面变得更加清楚，但是一个<code class="fe lv lw lx ly b">Resolver</code>可以容纳许多<code class="fe lv lw lx ly b">Repositories</code>来组合数据。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">resolver.go添加了一个ResolveGophers函数，可用作服务器根查询中的解析器</p></figure><p id="2b7b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要开始使用来自<code class="fe lv lw lx ly b">GopherService</code>的<code class="fe lv lw lx ly b">ResolveGophers</code>，我们需要在<code class="fe lv lw lx ly b">main.go</code>中创建一个服务，并让<code class="fe lv lw lx ly b">RootQuery</code>返回一个<code class="fe lv lw lx ly b">GopherType</code>的<code class="fe lv lw lx ly b">List</code>。记住<code class="fe lv lw lx ly b">GopherType</code>是我们之前创建的自定义<code class="fe lv lw lx ly b">Object</code>，而<code class="fe lv lw lx ly b">List</code>是GraphQL中的一个数组。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">main.go —更新了GraphQL根查询，以返回一个地鼠列表，并使用我们的InMemoryRepository解析它们</p></figure><p id="911b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在重启程序<code class="fe lv lw lx ly b">go run main.go</code>并访问<a class="ae ky" href="http://localhost:8080/graphql" rel="noopener ugc nofollow" target="_blank"> localhost:8080/graphql </a>，看看graphql是如何让我们避免过度获取和不足获取的。</p><p id="14ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请记住，在GraphQL中，我们定义了在查询中返回哪些字段，因此只有您查询的字段会被返回。请看下面的两张图片，在我只获取地鼠名称中，第二张图片显示了如何获取所有可用的数据。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pk"><img src="../Images/989f6e320349e50a00aa4625ade9883f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hzrX5sRv_jOtjtK3KswL4g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">GraphiQL —只获取所有地鼠的名称的查询</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pl"><img src="../Images/3942fda478dc1f3bc8d927c016d0b8ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0Lr_G4Q1orzmdnA2z0WRDg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">GraphiQL —查询以获取对地鼠可用的所有值</p></figure><h2 id="7320" class="mx my it bd mz na nb dn nc nd ne dp nf li ng nh ni lm nj nk nl lq nm nn no np bi translated"><strong class="ak">在不耦合数据源的情况下组合查询中的数据</strong></h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/a5885d9a989146104ff6dd2df0e52419.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F8sIlD5QJ6dPqm633DRDRw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">组合对象而不耦合它们</p></figure><p id="ff41" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们继续之前，是时候展示如何使用多个存储库从许多来源获取数据了。这是GraphQL的另一个伟大特性。</p><p id="8b56" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每个<code class="fe lv lw lx ly b">graphql.Field</code>都有一个<code class="fe lv lw lx ly b">Resolve</code>字段，所以你可以给每个<code class="fe lv lw lx ly b">graphql.Field</code>输入一个解析函数。通常，我们需要访问解析器中的存储库，最简单的方法是使用<code class="fe lv lw lx ly b">Service</code>生成<code class="fe lv lw lx ly b">Schema</code>，因为它拥有所有需要的访问权限。</p><p id="9755" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看何时实现一个用于处理作业的<code class="fe lv lw lx ly b">JobRepository</code>。我们将在<code class="fe lv lw lx ly b">GopherService</code>中存储<code class="fe lv lw lx ly b">JobRepository</code>和<code class="fe lv lw lx ly b">GopherRepository</code>，并在<code class="fe lv lw lx ly b">schema</code>包中创建一个<code class="fe lv lw lx ly b">GenerateSchema</code>函数，该函数接受服务作为输入，并创建我们可以用于GraphQL的模式。这种方法允许我们构建可以访问所有数据源的解析器，这样我们就可以组合它们。</p><p id="1ba9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先创建一个<code class="fe lv lw lx ly b">job</code>文件夹，并创建我们将在内部使用的<code class="fe lv lw lx ly b">job</code>结构。我们还将为该作业创建一个<code class="fe lv lw lx ly b">Repository</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">job/job.go —后端域中使用的作业结构</p></figure><p id="a0d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们需要一个作为存储库一部分的结构，这次也是一个内存解决方案。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">job/memory.go —一个用于作业存储库的内存解决方案</p></figure><p id="16ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们开始修复解析器之前，要做的最后一件事是升级<code class="fe lv lw lx ly b">Service</code>，这样它就可以访问<code class="fe lv lw lx ly b">JobRepository</code></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">gopher/resolver . go-gopher服务现在接受作业存储库</p></figure><p id="25c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在是时候关注这里发生的事情了。我们将添加一个<code class="fe lv lw lx ly b">ResolveJobs</code>函数，在这个函数中我们将访问一个<code class="fe lv lw lx ly b">Source</code>字段，这个字段是对象的<code class="fe lv lw lx ly b">Parent</code>。当我们想要使用来自查询本身的数据时，这非常有用，就像在这种情况下，当我们搜索一个<code class="fe lv lw lx ly b">Job</code>时，我们需要地鼠的<code class="fe lv lw lx ly b">ID</code>。</p><p id="8129" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">Source</code>将是一个<code class="fe lv lw lx ly b">Gopher</code>对象，所以我们需要对它进行类型转换。然后使用那个地鼠的ID到<code class="fe lv lw lx ly b">jobRepository</code></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">gopher/resolver . go-resolve jobs希望父对象是gopher</p></figure><p id="4089" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">是时候开始构建模式了，这是我们可以组合来自<code class="fe lv lw lx ly b">GopherService</code>的数据的地方。</p><p id="2643" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建GraphQL对象来表示<code class="fe lv lw lx ly b">schemas/factory.go</code>中的<code class="fe lv lw lx ly b">JobType</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">schemas/factory . go-表示作业的GraphQL对象</p></figure><p id="8a09" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们从固定<code class="fe lv lw lx ly b">Jobs</code>数组的<code class="fe lv lw lx ly b">Field</code>开始。请注意我们是如何将服务作为参数传递的，这样我们就可以到达所需的<code class="fe lv lw lx ly b">Resolver</code>函数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">factory.go构建作业字段，该字段是作业类型的列表</p></figure><p id="b9b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">既然我们已经完成了<code class="fe lv lw lx ly b">Job</code>字段，我们希望将其设置为<code class="fe lv lw lx ly b">Gopher</code>类型的可用数据字段。我们将删除<code class="fe lv lw lx ly b">gopher.go</code>文件并将内容移动到它的生成器函数中，因为我们再次需要<code class="fe lv lw lx ly b">GopherService</code>的存在。记住<code class="fe lv lw lx ly b">Jobs</code>字段将是<code class="fe lv lw lx ly b">Gopher</code>的子字段，这使得<code class="fe lv lw lx ly b">Source</code>是正确的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">factory.go —生成包含作业字段的GopherType。</p></figure><p id="7e28" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">是时候完成RootQuery和导出到其他包的<code class="fe lv lw lx ly b">GenerateSchema</code>中的模式了。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">factory . go——generate schema将所有部分链接成一个根查询</p></figure><p id="0bd2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要实现这个功能，删除<code class="fe lv lw lx ly b">main.go</code>中旧的<code class="fe lv lw lx ly b">main</code>函数，使用新创建的存储库和模式生成器。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">main . go——更简单的版本，不需要主函数的领域知识</p></figure><p id="653d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">重新启动应用程序并尝试查询作业。您应该看到，在每个Gopher下，都有一个JSON响应中呈现的作业列表。很神奇吧？</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pm"><img src="../Images/c09ac841191a4279d9fdc9b495e403a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-Rz9xISp4xvozjoUAuSb9g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">对Gophers查询的JSON响应</p></figure><p id="3f2e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您想知道我们创建的<code class="fe lv lw lx ly b">job</code>解析器和<code class="fe lv lw lx ly b">gopher</code>解析器，那么我们为什么还没有实现它们是有原因的。我们不想每次都获取所有项目，但是我们希望能够只查询某些Gophers。输入参数。</p><h2 id="5ba4" class="mx my it bd mz na nb dn nc nd ne dp nf li ng nh ni lm nj nk nl lq nm nn no np bi translated">参数—指定搜索值的能力</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f886dcfc78f624b382dabf196a2582f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*INIA1de4d3ftGvE1e96tlA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用参数指定要查询的特定数据</p></figure><p id="6adb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有一种搜索特定数据的方法是有意义的。这种方式是通过在查询中使用<code class="fe lv lw lx ly b">Arguments</code>来实现的。参数是包含在查询中的命名值。</p><p id="5e20" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个GraphQL字段可以有零个或多个可用参数。</p><p id="1b42" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可能实现它来学习更容易，所以让我们添加查询特定地鼠和作业的能力。</p><p id="150c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe lv lw lx ly b">graphql.ResolveParams</code>中，我们有一个<code class="fe lv lw lx ly b">Args</code>字段，它将包含查询中发送的所有参数。</p><p id="73a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以使用Args字段来搜索我们添加的任何参数。让我们先给<code class="fe lv lw lx ly b">Jobs</code>解析器添加一个参数，其中我们要求一个公司参数。</p><p id="4208" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">更新<code class="fe lv lw lx ly b">JobRepository</code>以接受另一个参数<code class="fe lv lw lx ly b">companyName</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">job/memory . go-更新GetJobs以获取公司名称</p></figure><p id="8938" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还修正了<code class="fe lv lw lx ly b">Repository</code>来关联新的变化。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">job/job . go-存储库更改</p></figure><p id="635c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们修复<code class="fe lv lw lx ly b">ResolveJobs</code>来检查参数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">gopher/Resolver . go-解析器现在接受参数Company</p></figure><p id="3190" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要做的最后一件事是让<code class="fe lv lw lx ly b">graphql.Field</code>也接受参数。每个<code class="fe lv lw lx ly b">graphql.Field</code>都有一个<code class="fe lv lw lx ly b">Args</code>可以用来定义可能的参数，Args是一个<code class="fe lv lw lx ly b">map[string]*ArgumentConfig</code>，我们必须在其中设置名称和数据类型。让我们把它加到<code class="fe lv lw lx ly b">schemas/factory</code></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">模式/工厂-作业字段现在有一个参数</p></figure><p id="5acb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，您可以通过在查询中使用参数来请求某些公司。通过在字段后使用以下语法添加参数。</p><pre class="kj kk kl km gt on ly oo op aw oq bi"><span id="0085" class="mx my it ly b gy or os l ot ou">jobs(company: "value"){</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pn"><img src="../Images/6a6a41338a52e2aa8099f4741e55f99d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VQaUbmXiD1fVnsWoGj-r8Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">该图显示了我们如何通过使用和参数来筛选某些作业</p></figure><h2 id="988a" class="mx my it bd mz na nb dn nc nd ne dp nf li ng nh ni lm nj nk nl lq nm nn no np bi translated">突变-修改数据</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/499b4cbc73103ea73e6175f8f04d58eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qMahNZ0AaHB7YjayYFoYcQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">GraphQL中的突变允许对数据进行更改</p></figure><p id="1b4f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">太好了，我们可以从服务器上查询数据。当我们想修改数据的时候呢？</p><p id="ea90" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是我们在GraphQL中拥有<code class="fe lv lw lx ly b">mutations</code>的时候。突变是由一个<code class="fe lv lw lx ly b">RootMutation</code>定义的，就像我们有一个RootQuery一样。因此，我们需要为所有可用的突变、它们的参数和可用的字段建立一个模式。</p><p id="d56d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">GraphQL中的一个<code class="fe lv lw lx ly b">Mutation</code>看起来非常像一个查询，事实上，它也将返回结果。因此，变异可以用于应用新值，也可以在应用新值后获取新值。就像查询一样，您定义了要返回什么值。</p><p id="3e97" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们允许<code class="fe lv lw lx ly b">JobRepository</code>通过一个ID到<code class="fe lv lw lx ly b">GetJob</code>并到<code class="fe lv lw lx ly b">Update</code>该作业，这样我们可以稍后创建一个变异来修改作业的开始和结束日期。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">job/job.go —用两个新函数更新存储库</p></figure><p id="a3ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后打开<code class="fe lv lw lx ly b">memory.go</code>并更新存储解决方案来处理这些新功能。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">job/memory.go —用于处理作业更新的内存解决方案</p></figure><p id="5461" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们需要给<code class="fe lv lw lx ly b">GopherService</code>添加一个<code class="fe lv lw lx ly b">Resolver</code>函数，我注意到graphql-go的一个特点是开销很大，因为我们要处理大量的<code class="fe lv lw lx ly b">interface{}</code>。您可以通过创建助手函数来处理类型断言来避免很多开销，在下面的代码片段中，您可以看到一个用于提取字符串形式的GraphQL参数的<code class="fe lv lw lx ly b">grabStringArgument</code>。变异解析器就像查询解析器一样，所以这里没有什么新东西。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">gopher/resolver . go-添加了更新作业的突变解析器。</p></figure><p id="4032" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们需要更新模式以进行突变。正如您可能已经注意到的，创建所有的<code class="fe lv lw lx ly b">graphql.Fields</code>可能会变成相当多的代码，所以我通常会创建一个生成器函数来减少代码重复。</p><p id="fb5d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了创建一个字段，我们需要一个<code class="fe lv lw lx ly b">Type</code>，它是实现输出接口的任何东西，类似于下面的代码片段</p><pre class="kj kk kl km gt on ly oo op aw oq bi"><span id="7c3d" class="mx my it ly b gy or os l ot ou">type Output interface {<br/>    Name() string<br/>    Description() string<br/>    String() string<br/>    Error() error<br/>}</span></pre><p id="ecc0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第二个参数是解析器，它是别名<code class="fe lv lw lx ly b">FieldResolveFn func(p ResolveParams) (interface{},error)</code>，第三个是字符串描述，第四个是允许的参数映射。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">schemas/factory . go-graph QL字段的通用工厂</p></figure><p id="96c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">构建变异查询时，在<code class="fe lv lw lx ly b">schemas</code>包中创建一个<code class="fe lv lw lx ly b">mutation.go</code>文件。我们首先创建请求中可用的参数。我们希望突变请求有<code class="fe lv lw lx ly b">require</code>两个参数，所以我们使用<code class="fe lv lw lx ly b">graphql.NewNonNull</code>函数创建它们。使用<code class="fe lv lw lx ly b">NewNonNull</code>将使GraphQL服务器在发送空值请求时触发一个错误。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">schemas/mutation . go-可用于Mutatejob请求的参数。</p></figure><p id="d761" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要创建包含新变异的<code class="fe lv lw lx ly b">RootMutation</code>，就像创建查询一样。我们现在将使用<code class="fe lv lw lx ly b">generateGraphQLField</code>来缩短代码。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">schemas/mutation.go —构建根变异</p></figure><p id="6d06" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们尝试变异之前要做的最后一件事是将RootMutation应用到<code class="fe lv lw lx ly b">factory.go</code>中的模式</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">schemas/factory . go-将根变异添加到模式配置中。</p></figure><p id="d6d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">打开GraphiQL试用一下。我们发送<code class="fe lv lw lx ly b">Mutation</code>的方式与发送<code class="fe lv lw lx ly b">Query</code>相同，只需替换关键字。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi po"><img src="../Images/19f737056558d2e1de9256b2d8eba340.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AXQmUE-p6GVHvgEdiiSicg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">GraphiQL —发送变更请求以更改开始日期</p></figure><h2 id="9b48" class="mx my it bd mz na nb dn nc nd ne dp nf li ng nh ni lm nj nk nl lq nm nn no np bi translated">结论</h2><p id="ac4b" class="pw-post-body-paragraph kz la it lb b lc pp ju le lf pq jx lh li pr lk ll lm ps lo lp lq pt ls lt lu im bi translated">我们已经讨论了GraphQL的核心。在本文中，您了解了如何查询数据、对数据进行变异以及GraphQL的基本工作原理。您已经看到了我们如何将数据源组合成一个单一的输出，以及如何构建项目。</p><p id="b0f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">GraphQL已经成长了很多，并且提供了更多。这里有一些你应该自己调查的主题，以增加你的知识。</p><ul class=""><li id="c3e8" class="ov ow it lb b lc ld lf lg li ox lm oy lq oz lu pa pb pc pd bi translated">列举</li><li id="7ecb" class="ov ow it lb b lc pe lf pf li pg lm ph lq pi lu pa pb pc pd bi translated">接口、片段和内联片段</li><li id="7b07" class="ov ow it lb b lc pe lf pf li pg lm ph lq pi lu pa pb pc pd bi translated">捐款</li></ul><p id="cf89" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想了解更多，我可以推荐Robin Wieruch的<a class="ae ky" href="https://amzn.to/3BIZNaP" rel="noopener ugc nofollow" target="_blank">通往GraphQL之路</a>。这本书并不关注Go，而是从前端的角度关注GraphQL。这本书将介绍如何使用GraphQL与节点后端进行交互。</p><blockquote class="mo mp mq"><p id="df16" class="kz la mr lb b lc ld ju le lf lg jx lh ms lj lk ll mt ln lo lp mu lr ls lt lu im bi translated">完全披露——这本书的链接是一个附属链接，这意味着我有权获得一些销售收入。</p></blockquote><p id="1bc6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你是否会使用GraphQL？</p><p id="3245" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以在<a class="ae ky" href="https://github.com/percybolmer/graphql-in-go" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到完整代码。</p><p id="e278" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢您的阅读，并随时以任何可能的方式联系我，在T <a class="ae ky" href="https://twitter.com/percybolmer" rel="noopener ugc nofollow" target="_blank"> witter </a>、<a class="ae ky" href="https://www.instagram.com/programmingpercy/" rel="noopener ugc nofollow" target="_blank"> Instagram </a>、<a class="ae ky" href="https://www.linkedin.com/in/percy-bolmer-bb223b122/" rel="noopener ugc nofollow" target="_blank"> Linkedin </a>上发表评论。</p></div></div>    
</body>
</html>