<html>
<head>
<title>Still Using the OS Module in Python? This Alternative is Remarkably Better</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">还在用Python里的OS模块？这个选择明显更好</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/still-using-the-os-module-in-python-this-alternative-is-remarkably-better-7d728ce22fb7?source=collection_archive---------7-----------------------#2021-09-11">https://towardsdatascience.com/still-using-the-os-module-in-python-this-alternative-is-remarkably-better-7d728ce22fb7?source=collection_archive---------7-----------------------#2021-09-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6a21" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Python的OS模块是管理文件和文件夹的噩梦。你应该试试Pathlib。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/54fdc867c9ef092825e510357d5ee324.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1zRkf6fHcpQ-ylt9cEVB1g.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@wellgraf?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Pontus Wellgraf </a>在<a class="ae ky" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="b1de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用Python的<code class="fe lv lw lx ly b">os</code>模块管理文件和文件夹简直是一场噩梦。然而，它是每个数据科学工作流程的重要组成部分。保存报告、读取配置文件，凡是你能想到的，都不在话下。</p><p id="3174" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">想象一下——你花了几周的时间围绕你的模型构建一个API，它完美地工作，至少在你的机器上。一旦部署，这是一个完全不同的故事。您的API会在意想不到的地方失败，甚至无法运行，因为您硬编码的绝对路径根本不存在。</p><p id="74b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有一个简单的解决方案。Python 3.4及更高版本默认提供了<code class="fe lv lw lx ly b">pathlib</code>库。这是目前为止在你的应用程序中处理文件、文件夹及其连接最人性化的方式。最棒的是——今天你将了解这一切。我并不是说<code class="fe lv lw lx ly b">os</code>模块毫无用处，只是说<code class="fe lv lw lx ly b">pathlib</code>在文件和文件夹管理方面更胜一筹。</p><p id="86a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，创建一个新的Python文件并导入<code class="fe lv lw lx ly b">pathlib</code>库:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="afa8" class="md me it ly b gy mf mg l mh mi">import pathlib</span></pre><p id="45b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你需要在一个<code class="fe lv lw lx ly b">.py</code>文件中才能使用一些功能。例如，您将无法访问Jupyter笔记本中的<code class="fe lv lw lx ly b">__file__</code>属性。其他一切都应该运行良好。</p><p id="b0ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是你今天将学到的内容:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="5bde" class="md me it ly b gy mf mg l mh mi"><strong class="ly iu">· </strong><a class="ae ky" href="#bfc5" rel="noopener ugc nofollow"><strong class="ly iu">Get a path to the current Python file</strong></a><strong class="ly iu"><br/>· </strong><a class="ae ky" href="#c12b" rel="noopener ugc nofollow"><strong class="ly iu">Get a path to the current working directory</strong></a><strong class="ly iu"><br/>· </strong><a class="ae ky" href="#73ec" rel="noopener ugc nofollow"><strong class="ly iu">Get a first parent folder path</strong></a><strong class="ly iu"><br/>· </strong><a class="ae ky" href="#fa39" rel="noopener ugc nofollow"><strong class="ly iu">Get an Nth parent folder path</strong></a><strong class="ly iu"><br/>· </strong><a class="ae ky" href="#a452" rel="noopener ugc nofollow"><strong class="ly iu">Join paths</strong></a><strong class="ly iu"><br/>· </strong><a class="ae ky" href="#a315" rel="noopener ugc nofollow"><strong class="ly iu">Create a directory if it doesn’t exist</strong></a><strong class="ly iu"><br/>· </strong><a class="ae ky" href="#bcba" rel="noopener ugc nofollow"><strong class="ly iu">Create files</strong></a><strong class="ly iu"><br/>· </strong><a class="ae ky" href="#cf03" rel="noopener ugc nofollow"><strong class="ly iu">Check if the path is a folder</strong></a><strong class="ly iu"><br/>· </strong><a class="ae ky" href="#b03e" rel="noopener ugc nofollow"><strong class="ly iu">Check if the path is a file</strong></a><strong class="ly iu"><br/>· </strong><a class="ae ky" href="#70e5" rel="noopener ugc nofollow"><strong class="ly iu">Get the name of the file</strong></a><strong class="ly iu"><br/>· </strong><a class="ae ky" href="#2501" rel="noopener ugc nofollow"><strong class="ly iu">Get the file extension</strong></a><strong class="ly iu"><br/>· </strong><a class="ae ky" href="#26f8" rel="noopener ugc nofollow"><strong class="ly iu">Iterate over files in a folder</strong></a></span></pre></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="bfc5" class="mq me it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">获取当前Python文件的路径</h1><p id="8230" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">有时，您需要包含Python文件名的工作目录的绝对路径。用<code class="fe lv lw lx ly b">pathlib</code>可以快速获得。记住，这个命令<strong class="lb iu">不会</strong>在Jupyter笔记本中工作，因为你不能访问那里的<code class="fe lv lw lx ly b">__file__</code>属性。如果您是笔记本用户，请跳过这一部分。</p><p id="924d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">总之，下面是如何获得Python脚本的绝对路径+文件名:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="ef22" class="md me it ly b gy mf mg l mh mi">curr_file = pathlib.Path(__file__)<br/>print(curr_file)</span></pre><p id="b59a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是它在我的机器上的样子:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="46cc" class="md me it ly b gy mf mg l mh mi">&gt;&gt;&gt; /Users/dradecic/Desktop/pathlib_guide/python_pathlib.py</span></pre><p id="c058" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nm">简单，对吧？</em>对。</p><p id="9383" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果不需要文件名，有一个更简单的解决方案。</p><h1 id="c12b" class="mq me it bd mr ms nn mu mv mw no my mz jz np ka nb kc nq kd nd kf nr kg nf ng bi translated">获取当前工作目录的路径</h1><p id="adcf" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">这相当于在Unix shell中执行<code class="fe lv lw lx ly b">pwd</code>。它将返回您当前所在目录的路径，或者正在运行的脚本所在的位置。</p><p id="5869" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是它的使用方法:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="6de4" class="md me it ly b gy mf mg l mh mi">cwd = pathlib.Path.cwd()<br/>print(cwd)</span></pre><p id="6f50" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是它在我的机器上打印的内容:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="4d43" class="md me it ly b gy mf mg l mh mi">&gt;&gt;&gt; /Users/dradecic/Desktop/pathlib_guide</span></pre><p id="b291" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如你所见，没有文件名。</p><p id="2ba1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是如果你需要访问父文件夹中的文件呢？对我来说，那就是。让我们接下来讨论这个问题。</p><h1 id="73ec" class="mq me it bd mr ms nn mu mv mw no my mz jz np ka nb kc nq kd nd kf nr kg nf ng bi translated">获取第一父文件夹路径</h1><p id="3eb1" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">这个很简单。你只需要访问当前工作目录的<code class="fe lv lw lx ly b">parent</code>属性。这是如何做到的:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="9b10" class="md me it ly b gy mf mg l mh mi">one_above = pathlib.Path.cwd().parent <br/>print(one_above)</span></pre><p id="31ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是它在我的机器上打印的内容:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="0917" class="md me it ly b gy mf mg l mh mi">&gt;&gt;&gt; /Users/dradecic/Desktop</span></pre><p id="254e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">太好了！但是如果一个父文件夹不够呢？让我们看看你有什么选择。</p><h1 id="fa39" class="mq me it bd mr ms nn mu mv mw no my mz jz np ka nb kc nq kd nd kf nr kg nf ng bi translated">获取第n个父文件夹路径</h1><p id="2052" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">你有选择。第一个是像疯子一样多次呼叫进入<code class="fe lv lw lx ly b">parent</code>房产。这里有一个例子:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="5d06" class="md me it ly b gy mf mg l mh mi">mul_above = pathlib.Path.cwd().parent.parent.parent</span></pre><p id="b6aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">更简单的方法是访问<code class="fe lv lw lx ly b">parents</code>属性数组并对其进行索引。例如，下面是获取第二个父文件夹路径的方法:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="2de9" class="md me it ly b gy mf mg l mh mi">mul_above = pathlib.Path.cwd().parents[1]<br/>print(mul_above)</span></pre><p id="eca6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">结果如下:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="e6d7" class="md me it ly b gy mf mg l mh mi">&gt;&gt;&gt; /Users/dradecic</span></pre><p id="f458" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">数组索引从0开始，所以访问<code class="fe lv lw lx ly b">parents[1]</code>会进入第二个父文件夹。</p><p id="8937" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你现在有足够的知识开始加入路径。接下来看看如何。</p><h1 id="a452" class="mq me it bd mr ms nn mu mv mw no my mz jz np ka nb kc nq kd nd kf nr kg nf ng bi translated">加入路径</h1><p id="5674" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">假设一个包含销售报告的文件夹位于您当前位置的两个目录之上，该报告称为<code class="fe lv lw lx ly b">summer-sales.csv</code>。有办法用绝对路径访问吗？</p><p id="25d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然有。</p><p id="49d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您已经知道如何访问第n个父文件夹路径。您将通过调用<code class="fe lv lw lx ly b">joinpath()</code>并提供报告名称作为参数来扩展该功能:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="09d7" class="md me it ly b gy mf mg l mh mi">tgt_path = pathlib.Path.cwd().parents[1]<br/>tgt_fname = 'summer-sales.csv'<br/>print(tgt_path.joinpath(tgt_fname))</span></pre><p id="5afc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是它在我的机器上打印的内容:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="6a02" class="md me it ly b gy mf mg l mh mi">&gt;&gt;&gt; /Users/dradecic/summer-sales.csv</span></pre><p id="0103" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">joinpath()</code>函数可能是我用的最多的一个。超级有用。</p><h1 id="a315" class="mq me it bd mr ms nn mu mv mw no my mz jz np ka nb kc nq kd nd kf nr kg nf ng bi translated">如果目录不存在，则创建一个目录</h1><p id="782e" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">如果每次因为我忘记创建目录而导致生产失败时，我都会得到一美元…这是一个非常常见的错误，而<code class="fe lv lw lx ly b">pathlib</code>可以让你没有太多麻烦地解决它。</p><p id="8e02" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设您想要将销售报告存储在当前工作目录下的<code class="fe lv lw lx ly b">reports</code>文件夹中。您必须先创建该文件夹，然后才能在其中存储文件。只有当它不存在时，您才应该创建它。</p><p id="b5e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">简而言之——使用<code class="fe lv lw lx ly b">mkdir()</code>创建一个文件夹，使用<code class="fe lv lw lx ly b">exists()</code>检查文件夹是否已经存在。</p><p id="fa46" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是完整的代码片段:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="88cd" class="md me it ly b gy mf mg l mh mi">tgt_path = pathlib.Path.cwd().joinpath('reports')<br/><br/>if not tgt_path.exists():<br/>    tgt_path.mkdir()</span></pre><p id="6998" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">执行上述代码将会创建一个<code class="fe lv lw lx ly b">reports</code>文件夹，您已经猜到了:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl ns"><img src="../Images/7e96cb90d7afd90bb9f3f522800b71a7.png" data-original-src="https://miro.medium.com/v2/format:webp/1*dDhEbWxKx5bu3QHExE8bQA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图1 —使用Pathlib创建文件夹(作者图片)</p></figure><p id="8d76" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">干净利落。接下来让我们看看如何在该文件夹中创建文件。</p><h1 id="bcba" class="mq me it bd mr ms nn mu mv mw no my mz jz np ka nb kc nq kd nd kf nr kg nf ng bi translated">创建文件</h1><p id="3cb0" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">您通常会通过一些第三方库保存报告。然而，您也可以使用<code class="fe lv lw lx ly b">pathlib</code>创建任何类型的空文件。</p><p id="da8c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是如何在<code class="fe lv lw lx ly b">reports</code>文件夹中创建CSV和TXT文件:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="52e3" class="md me it ly b gy mf mg l mh mi">tgt_path = pathlib.Path.cwd().joinpath('reports')<br/><br/>tgt_path.joinpath('summer-sales.csv').touch(exist_ok=True)<br/>tgt_path.joinpath('winter-sales.txt').touch(exist_ok=True)</span></pre><p id="daa9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">exist_ok=True</code>参数告诉Python覆盖一个已经存在的文件。</p><p id="efdc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看文件是否已创建:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl ns"><img src="../Images/5a5e77a2c873825824bfc95f75a503eb.png" data-original-src="https://miro.medium.com/v2/format:webp/1*IzFKx2y6aRrI2DOB8TZ_8Q.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图2 —使用Pathlib创建文件(作者图片)</p></figure><p id="a460" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">很管用。</p><h1 id="cf03" class="mq me it bd mr ms nn mu mv mw no my mz jz np ka nb kc nq kd nd kf nr kg nf ng bi translated">检查路径是否是文件夹</h1><p id="819f" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">如果你想检查一个给定的路径是否是一个文件夹，只需看看<code class="fe lv lw lx ly b">is_dir()</code>函数。它返回一个布尔值。</p><p id="6200" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下示例对文件夹和文件都使用了上述函数:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="8156" class="md me it ly b gy mf mg l mh mi">tgt_path = pathlib.Path.cwd().joinpath('reports')<br/><br/>print(tgt_path.is_dir())<br/>print(tgt_path.joinpath('summer-sales.csv').is_dir())</span></pre><p id="9140" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是您应该看到的打印内容:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="92dc" class="md me it ly b gy mf mg l mh mi">&gt;&gt;&gt; True<br/>&gt;&gt;&gt; False</span></pre><p id="b67c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是全部了！</p><h1 id="b03e" class="mq me it bd mr ms nn mu mv mw no my mz jz np ka nb kc nq kd nd kf nr kg nf ng bi translated">检查路径是否是文件</h1><p id="8461" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">与前面的例子类似，您可以使用<code class="fe lv lw lx ly b">is_file()</code>函数来检查给定的路径是否会产生一个文件。</p><p id="6487" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面的示例在文件夹和文件中都使用了它:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="6425" class="md me it ly b gy mf mg l mh mi">tgt_path = pathlib.Path.cwd().joinpath('reports')<br/><br/>print(tgt_path.is_dir())<br/>print(tgt_path.joinpath('summer-sales.csv').is_dir())</span></pre><p id="9075" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如你所想象的，这次你会得到完全相反的结果:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="1a67" class="md me it ly b gy mf mg l mh mi">&gt;&gt;&gt; False<br/>&gt;&gt;&gt; True</span></pre><p id="b2ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在今天结束之前，让我们探索几个更有用的功能。</p><h1 id="70e5" class="mq me it bd mr ms nn mu mv mw no my mz jz np ka nb kc nq kd nd kf nr kg nf ng bi translated">获取文件的名称</h1><p id="100e" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">如果需要从绝对路径中提取文件名，可以访问<code class="fe lv lw lx ly b">name</code>属性。</p><p id="d573" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里有一个简单但不太有用的例子。它打印我们的<code class="fe lv lw lx ly b">summer-sales.csv</code>文件的文件名:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="ea6d" class="md me it ly b gy mf mg l mh mi">tgt_path = pathlib.Path.cwd().joinpath('reports/summer-sales.csv')<br/>print(tgt_path.name)</span></pre><p id="7840" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是您应该在控制台中看到的内容:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="8f5c" class="md me it ly b gy mf mg l mh mi">&gt;&gt;&gt; summer-sales.csv</span></pre><p id="d046" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">没什么。</p><h1 id="2501" class="mq me it bd mr ms nn mu mv mw no my mz jz np ka nb kc nq kd nd kf nr kg nf ng bi translated">获取文件扩展名</h1><p id="6e49" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">有时候你需要的只是一个文件扩展名。可能你想对不同的文件类型做不同的处理，对文件名不太在意。<code class="fe lv lw lx ly b">suffix</code>物业有你罩着。</p><p id="dea5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是如何从同一个<code class="fe lv lw lx ly b">summer-sales.csv</code>文件中获取文件扩展名的方法:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="bd83" class="md me it ly b gy mf mg l mh mi">tgt_path = pathlib.Path.cwd().joinpath('reports/summer-sales.csv')<br/>print(tgt_path.suffix)</span></pre><p id="7ef0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是您应该看到打印出来的内容:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="3a12" class="md me it ly b gy mf mg l mh mi">&gt;&gt;&gt; .csv</span></pre><p id="cded" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，让我们来看看迭代。</p><h1 id="26f8" class="mq me it bd mr ms nn mu mv mw no my mz jz np ka nb kc nq kd nd kf nr kg nf ng bi translated">遍历文件夹中的文件</h1><p id="77c5" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">假设您在单个目录中有一堆CSV报告，并且想要逐个处理它们。你只需要<code class="fe lv lw lx ly b">iterdir()</code>功能。</p><p id="55bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">整个过程再简单不过了:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="77fc" class="md me it ly b gy mf mg l mh mi">tgt_path = pathlib.Path.cwd().joinpath('reports')<br/><br/>for file in tgt_path.iterdir():<br/>    print(file)</span></pre><p id="a188" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是它在我的机器上打印的内容:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="e9d6" class="md me it ly b gy mf mg l mh mi">&gt;&gt;&gt; /Users/dradecic/Desktop/pathlib_guide/reports/summer-sales.csv<br/>    /Users/dradecic/Desktop/pathlib_guide/reports/winter-sales.txt</span></pre><p id="179f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">今天到此为止。你现在已经拥有了一切，再也不会犯愚蠢的生产错误了。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><p id="f6bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nm">你对</em> <code class="fe lv lw lx ly b"><em class="nm">pathlib</em></code> <em class="nm">有什么想法？它是你最喜欢的文件和文件夹管理库，还是你对其他东西感兴趣？请在下面的评论区告诉我。</em></p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><p id="0049" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nm">喜欢这篇文章吗？成为</em> <a class="ae ky" href="https://medium.com/@radecicdario/membership" rel="noopener"> <em class="nm">中等会员</em> </a> <em class="nm">继续无限制学习。如果你使用下面的链接，我会收到你的一部分会员费，不需要你额外付费。</em></p><div class="nt nu gp gr nv nw"><a href="https://medium.com/@radecicdario/membership" rel="noopener follow" target="_blank"><div class="nx ab fo"><div class="ny ab nz cl cj oa"><h2 class="bd iu gy z fp ob fr fs oc fu fw is bi translated">通过我的推荐链接加入Medium-Dario rade ci</h2><div class="od l"><h3 class="bd b gy z fp ob fr fs oc fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="oe l"><p class="bd b dl z fp ob fr fs oc fu fw dk translated">medium.com</p></div></div><div class="of l"><div class="og l oh oi oj of ok ks nw"/></div></div></a></div></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="aeee" class="mq me it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">保持联系</h1><ul class=""><li id="1f10" class="ol om it lb b lc nh lf ni li on lm oo lq op lu oq or os ot bi translated">在<a class="ae ky" href="https://medium.com/@radecicdario" rel="noopener"> Medium </a>上关注我，了解更多类似的故事</li><li id="42c3" class="ol om it lb b lc ou lf ov li ow lm ox lq oy lu oq or os ot bi translated">注册我的<a class="ae ky" href="https://mailchi.mp/46a3d2989d9b/bdssubscribe" rel="noopener ugc nofollow" target="_blank">简讯</a></li><li id="88f1" class="ol om it lb b lc ou lf ov li ow lm ox lq oy lu oq or os ot bi translated">在<a class="ae ky" href="https://www.linkedin.com/in/darioradecic/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上连接</li></ul></div></div>    
</body>
</html>