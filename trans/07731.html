<html>
<head>
<title>Merging too many small files into fewer large files in Datalake using Apache Spark</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Apache Spark将Datalake中过多的小文件合并到较少的大文件中</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/merging-too-many-small-files-into-fewer-large-files-using-apache-spark-in-datalake-ff9a32807056?source=collection_archive---------7-----------------------#2021-07-15">https://towardsdatascience.com/merging-too-many-small-files-into-fewer-large-files-using-apache-spark-in-datalake-ff9a32807056?source=collection_archive---------7-----------------------#2021-07-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="307a" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated"><em class="kf">提高对大型数据集的读取查询性能</em></h2></div><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi kg"><img src="../Images/d275247b302b166cbe3cac72dc6a9542.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m_-uhXCQ3pOx5KdLauS6Pw.png"/></div></div><p class="ks kt gj gh gi ku kv bd b be z dk translated">作者图片</p></figure><p id="227e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi ls translated"><span class="l lt lu lv bm lw lx ly lz ma di"> T </span>在数据平台中存储大量数据的现代方法是将每个数据集分布在集群中的几个节点上。如果使用云，整个数据集将被分成多个对象。这可能会导致“太多的小文件”，这是大数据领域的一个众所周知的问题。创建小文件的原因有几个，比如一条消息一条消息地保存传入的流数据，按具有数据倾斜的键进行分区，等等。当通过Namenode、MapReduce或Spark作业维护或读取该数据集时，驱动程序必须跟踪所有文件的元数据，以便规划分布式数据处理。当它们太多时，保存元数据会有内存开销，而且列出它们会花费更多的网络I/O时间。</p><p id="6c04" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在数据湖中工作时，您可能已经注意到，Spark作业花费太多时间读取s3/HDFS上的数据集，甚至需要一段时间才能看到执行器启动。或者您的Hive查询需要一两分钟来启动任务。最有可能的是，这是由于驱动程序花费了大部分时间首先在s3中检查数据集的文件/对象的所有元数据，尤其是当有太多小文件时。这是因为驱动程序执行数据集中的文件列表，估计大小/分区，然后将实际处理分配给执行器。因此，拥有太多的小文件可能会导致性能瓶颈，在最坏的情况下，驱动程序可能会因内存不足异常而失败。</p><p id="8fd7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是一个简单的Spark作业，它可以接收数据集和估计的单个输出文件大小，并将输入数据集合并到更大的文件中，最终减少文件的数量。同时，拥有一个非常大的文件也不好。一般来说，1gb或512MiB的文件是标准的。</p><p id="8172" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae mb" href="https://github.com/justhackit/spark-utils/blob/main/src/main/scala/com/sparkutils/io/FileMerger.scala" rel="noopener ugc nofollow" target="_blank"> <em class="mc">这里有完整的剧本</em> </a>。让我给你介绍一下剧本…</p></div><div class="ab cl md me hu mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="ij ik il im in"><h2 id="9154" class="mk ml iq bd mm mn mo dn mp mq mr dp ms lf mt mu mv lj mw mx my ln mz na nb nc bi translated">司机:</h2><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="9718" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是接受三个参数的主要方法..1)小文件所在的源s3路径2)作业将合并文件写入的目标s3路径，以及3)单个合并文件的最大目标文件大小。</p><p id="f02e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个脚本假设输入目录(第5行)再次包含子目录，这些子目录实际上包含最终文件。通常，分区数据集就是这种情况。但是，如果我们只有一个存放所有文件的目录，那么您可以调整第5行，将单个元素传递给列表。</p><p id="935d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，第9行到第11行很有趣，它使用Scala的并行集合来并行提交多个spark作业。是的，你没看错。当从每个线程提交时，我们可以运行并行的Spark操作。如您所见，所有的多线程都通过使用并行集合被抽象掉了。第9行设置并行度，即并行处理多少个目录。在这里，我只是将它设置为子目录的数量。如果超过一百个，我建议成批运行它们，因为集群可能会过载(当然，这取决于集群的大小)。</p><p id="8b59" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从第12行开始，处理开始于遍历每个输入目录并并行处理它们。每个目录的整个过程可以分为三个步骤:</p><h2 id="83f3" class="mk ml iq bd mm mn mo dn mp mq mr dp ms lf mt mu mv lj mw mx my ln mz na nb nc bi translated">步骤1:找到文件大小</h2><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="ef34" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这很简单。我只是使用“com . Amazon AWS:AWS-Java-SDK”<strong class="ky ir"/>库列出目录中的文件。在列表过程中，我还发现了每个对象的大小，并将Map &lt; file-prefix，size &gt;返回给调用者。</p><h2 id="cc10" class="mk ml iq bd mm mn mo dn mp mq mr dp ms lf mt mu mv lj mw mx my ln mz na nb nc bi translated">步骤2:确定要合并的文件组</h2><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="3116" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这里，我们可以找到可以合并的一组较小的文件。如您所见，该方法采用了映射<file>和目标文件大小。在按文件大小对映射进行排序后，它将多个文件分组到一个批处理中，以便该批处理的总大小小于或等于目标文件大小。当然，这可能不是最好的群集，因为我们可能最终得到小于目标文件大小的文件，但不能与其他此类文件进行批处理，因为总批处理大小可能会超过目标文件大小。幸运的是，由于我们是按照文件大小升序对地图进行排序的，所以最小大小的文件会被组合在一起，只有那些已经接近目标大小的文件会保留下来。该函数最后返回一个List[List[file]]，其中包含要合并为单个文件的一批文件的列表。</file></p><h2 id="2624" class="mk ml iq bd mm mn mo dn mp mq mr dp ms lf mt mu mv lj mw mx my ln mz na nb nc bi translated">第三步:合并文件并写出它们</h2><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="06bf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在到了最后一步，即将前一步中的分组文件合并成一个文件。你可以猜到，这是一个简单的任务。只需使用spark.read()函数读取文件(在上面的代码中，我读取的是Parquet文件，但可以是任何文件格式),方法是传递该组中的文件列表，然后使用coalesce(1)将它们合并成一个文件。这是另一个有趣的作品。我们再次使用并行集合来执行合并，因此合并同一目录中的每个组是并行进行的。因此，如果每个目录中有<em class="mc"> m个</em>目录和<em class="mc"> n个</em>组，那么就会有<em class="mc"> m x n个</em>并行作业在运行。</p><p id="57ad" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当写出合并的文件时，写模式是“追加”，因为，正如我前面提到的，多个目录被并行处理，并且所有目录的目标目录都是相同的，“覆盖”模式将失败，表示“目录已经存在”。因此，您需要确保目标目录是一个新目录。</p></div><div class="ab cl md me hu mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="ij ik il im in"><p id="64f3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">仅此而已。现在，即使是KiB的文件也会被合并成100兆或100兆字节.当要扫描的文件数量较少时，您可以很容易地看到读取查询的性能提升。</p><p id="9b63" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下一步是什么？ <br/> 1。对这个脚本的一个可能的即兴创作是，在进行磁盘IO之前，最好通过写作业合并数据集，而不是合并已经存在的文件。我将分享另一个可以做到这一点的帖子。同时，该脚本可用于合并历史数据集。<br/> 2。正如我已经提到的，第2步，即确定要合并的文件组，并不是最好的。如果你知道一个聚类算法，可以以一种最佳的方式对文件进行分组，这样我们在合并后就有最少的文件，我欢迎PR的:-)</p></div></div>    
</body>
</html>