<html>
<head>
<title>How To Fill Plots With Patterns In Matplotlib</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Matplotlib中用模式填充绘图</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-fill-plots-with-patterns-in-matplotlib-58ad41ea8cf8?source=collection_archive---------5-----------------------#2021-07-14">https://towardsdatascience.com/how-to-fill-plots-with-patterns-in-matplotlib-58ad41ea8cf8?source=collection_archive---------5-----------------------#2021-07-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="fec3" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">向条形图、直方图、箱线图和饼图添加图案的方法</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/cfda11c0a0d3973f7af337b1f02110a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DVDC-pU3QQm3l7K1bAstyA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="96ff" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">创建地块时使用填充图案是使用颜色的一种很好的替代方法。在下列情况下，它尤其有用:</p><ul class=""><li id="476a" class="lu lv it la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated">这个情节将会刊登在一份黑白出版物上，</li><li id="1239" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">如果我们想要减少每个绘图使用的颜色数量(例如对于饼图)，</li><li id="c6b5" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">如果我们想要强调图中的一些元素(例如条形图中的一些条)。</li></ul><p id="c124" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">不幸的是，目前matplotlib在这方面的功能相当有限。此外，对于不同类型的地块没有独特的方法。</p><p id="4a29" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在本文中，我们将探讨如何向条形图、直方图、盒图和饼图添加模式。为了最大化数据-墨水比率，我们将通过在各处添加<code class="fe mi mj mk ml b">fill=False</code>来创建仅黑白的图。</p><h1 id="2b85" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">条形图</h1><p id="61e5" class="pw-post-body-paragraph ky kz it la b lb ne ju ld le nf jx lg lh ng lj lk ll nh ln lo lp ni lr ls lt im bi translated">要用图形填充条形图，我们只需将以下值之一作为字符串赋给可选参数<code class="fe mi mj mk ml b">hatch</code>:<code class="fe mi mj mk ml b">/</code>、<code class="fe mi mj mk ml b">\\</code>、<code class="fe mi mj mk ml b">|</code>、<code class="fe mi mj mk ml b">-</code>、<code class="fe mi mj mk ml b">+</code>、<code class="fe mi mj mk ml b">x</code>、<code class="fe mi mj mk ml b">o</code>、<code class="fe mi mj mk ml b">O</code>、<code class="fe mi mj mk ml b">.</code>、<code class="fe mi mj mk ml b">*</code>:</p><pre class="kj kk kl km gt nj ml nk nl aw nm bi"><span id="ad70" class="nn mn it ml b gy no np l nq nr">import matplotlib.pyplot as plt<br/>import numpy as np<br/>x = range(1,5)<br/>y = range(1,5)<br/>plt.bar(x, y, fill=False, hatch='/')<br/>plt.show()</span></pre><p id="c31e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">输出:</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/541e54b22eb379447d189c53bcd391c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:744/format:webp/1*w-j2D8irFiJzmCq6YTix0Q.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="854c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了获得更密集的填充，我们应该在字符串中添加更多的同类符号。所以，让我们用<code class="fe mi mj mk ml b">'///'</code>代替<code class="fe mi mj mk ml b">'/'</code>:</p><pre class="kj kk kl km gt nj ml nk nl aw nm bi"><span id="ca18" class="nn mn it ml b gy no np l nq nr">plt.bar(x, y, fill=False, hatch='///')<br/>plt.show()</span></pre><p id="aee6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">输出:</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/7412d3deeffca40a66eec42a7c37c463.png" data-original-src="https://miro.medium.com/v2/resize:fit:744/format:webp/1*GEGuFtrIecvI3kqTnK_xaA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="cf74" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">注意:</strong>由于反斜杠(<code class="fe mi mj mk ml b">\</code>)是Python中的一个特殊字符，如果我们想用这个模式填充我们的条形图，我们就必须使用一个<strong class="la iu">双反斜杠</strong> ( <code class="fe mi mj mk ml b">'\\'</code>)。在这种情况下，为了获得更密集的模式，有必要将偶数个反斜杠分配给<code class="fe mi mj mk ml b">hatch</code>参数(<code class="fe mi mj mk ml b">'\\\\'</code>、<code class="fe mi mj mk ml b">'\\\\\\'</code>等)。).</p><p id="9973" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">也可以在相同的条上组合两种或多种模式，将相应的字符添加到字符串中:</p><pre class="kj kk kl km gt nj ml nk nl aw nm bi"><span id="78aa" class="nn mn it ml b gy no np l nq nr">plt.bar(x, y, fill=False, hatch='.O')<br/>plt.show()</span></pre><p id="399a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">输出:</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/6d6a3070f397700ad87815d73f16fadb.png" data-original-src="https://miro.medium.com/v2/resize:fit:744/format:webp/1*Ae3dOZbKpSHTAwjCVNS5qw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="6fd5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">绘制堆积或分组条形图时，填充变得更加有用:</p><pre class="kj kk kl km gt nj ml nk nl aw nm bi"><span id="a2f0" class="nn mn it ml b gy no np l nq nr">y1 = range(1,5)<br/>y2 = range(5,9)<br/>plt.bar(x, y1, fill=False, hatch='xx')<br/>plt.bar(x, y2, fill=False, hatch='..', bottom=y1)<br/>plt.show()</span></pre><p id="640a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">输出:</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/dea09a1ef0b43a6418429be6193b14da.png" data-original-src="https://miro.medium.com/v2/resize:fit:738/format:webp/1*SeFZD1zyFYviY6M6ZWDFJQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="ab55" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">此外，与颜色一样，我们可以使用填充来强调最重要的线条。这里的算法如下。<code class="fe mi mj mk ml b">plt.bar()</code>方法返回一个包含n个条形的容器，可以将这些条形赋给一个变量:</p><pre class="kj kk kl km gt nj ml nk nl aw nm bi"><span id="29c2" class="nn mn it ml b gy no np l nq nr">bars = plt.bar(x, y)<br/>print(bars)</span><span id="02eb" class="nn mn it ml b gy nu np l nq nr"><strong class="ml iu">Output:<br/></strong>&lt;BarContainer object of 4 artists&gt;</span></pre><p id="359c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在我们的例子中，容器中有4个条。让我们为条形图案设置一个条件。例如，我们只想强调<code class="fe mi mj mk ml b">1 &lt; y &lt; 3</code>所在的小节。我们可以遍历y值列表，对于满足上述条件的值，分配星号(<code class="fe mi mj mk ml b">'*'</code>)，否则不分配任何值(空字符串)。因此，我们将拥有一个与每个<em class="nv"> y </em>值相对应的<code class="fe mi mj mk ml b">hatch</code>参数值列表:</p><pre class="kj kk kl km gt nj ml nk nl aw nm bi"><span id="35b7" class="nn mn it ml b gy no np l nq nr">hatches = ['*' if y&gt;1 and y&lt;3 else '' for y in y]<br/>print(hatches)</span><span id="f520" class="nn mn it ml b gy nu np l nq nr"><strong class="ml iu">Output:<br/></strong>['', '*', '', '']</span></pre><p id="8fe9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，我们可以遍历容器的各个条，并为每个条设置相应的<code class="fe mi mj mk ml b">hatch</code>值:</p><pre class="kj kk kl km gt nj ml nk nl aw nm bi"><span id="08f3" class="nn mn it ml b gy no np l nq nr">bars = plt.bar(x, y)<br/>for i in range(len(bars)):<br/>    bars[i].set(hatch = hatches[i], fill=False)<br/>plt.show()</span></pre><p id="5bbd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">输出:</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/e86ba7175b96e16115d943872e99cc74.png" data-original-src="https://miro.medium.com/v2/resize:fit:744/format:webp/1*hhRa_azJNUbaRnT8QoMJQw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><h1 id="eb14" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">柱状图</h1><p id="cb46" class="pw-post-body-paragraph ky kz it la b lb ne ju ld le nf jx lg lh ng lj lk ll nh ln lo lp ni lr ls lt im bi translated">为了填充直方图，我们使用了与条形图相同的可选参数<code class="fe mi mj mk ml b">hatch</code>,以及相同的可选值:</p><pre class="kj kk kl km gt nj ml nk nl aw nm bi"><span id="8563" class="nn mn it ml b gy no np l nq nr">data = np.random.normal(loc=10, scale=10, size=500)<br/>plt.hist(data, histtype='step', edgecolor='black', fill=False, hatch='.')<br/>plt.show()</span></pre><p id="c7b5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">输出:</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/ea2968507ebb4fd0dbf124b833ae0b12.png" data-original-src="https://miro.medium.com/v2/resize:fit:750/format:webp/1*lcjsGUgGnnzbRPr31NL_Kg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="5a3c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当绘制多个堆叠或重叠的直方图时，它变得更加有用:</p><pre class="kj kk kl km gt nj ml nk nl aw nm bi"><span id="8e95" class="nn mn it ml b gy no np l nq nr">data1 = np.random.normal(30, 20, 5000)<br/>data2 = np.random.normal(80, 15, 5000)<br/>plt.hist(data1, bins=30, histtype='step', edgecolor='black', fill=False, hatch='.')<br/>plt.hist(data2, bins=30, histtype='step', edgecolor='black', fill=False, hatch='o')<br/>plt.show()</span></pre><p id="759c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">输出:</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/ef274dc95b0f79461a5de9f8ba91d53c.png" data-original-src="https://miro.medium.com/v2/resize:fit:750/format:webp/1*OGqZl0B_kH69Q5sg1YOcTg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><h1 id="ee6d" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">箱形图</h1><p id="7b44" class="pw-post-body-paragraph ky kz it la b lb ne ju ld le nf jx lg lh ng lj lk ll nh ln lo lp ni lr ls lt im bi translated">然而，对于箱线图，这种方法不太直接，因为<code class="fe mi mj mk ml b">plt.boxplot()</code>方法没有<code class="fe mi mj mk ml b">hatch</code>参数。因此，我们必须使用一个变通办法。这里的算法如下。<code class="fe mi mj mk ml b">plt.boxplot()</code>方法返回一个字典，以盒图的不同元素作为键:胡须、盒子、中线、传单等。该字典可以分配给一个变量:</p><pre class="kj kk kl km gt nj ml nk nl aw nm bi"><span id="7252" class="nn mn it ml b gy no np l nq nr">data = np.random.rand(100)<br/>boxplots = plt.boxplot(data, patch_artist=True)<br/>boxplots</span><span id="43b8" class="nn mn it ml b gy nu np l nq nr"><strong class="ml iu">Output:<br/></strong>{'whiskers': [&lt;matplotlib.lines.Line2D at 0x195176862e0&gt;,<br/>  &lt;matplotlib.lines.Line2D at 0x19517686640&gt;],<br/> 'caps': [&lt;matplotlib.lines.Line2D at 0x195176869a0&gt;,<br/>  &lt;matplotlib.lines.Line2D at 0x19517686d00&gt;],<br/> 'boxes': [&lt;matplotlib.patches.PathPatch at 0x19517667f10&gt;],<br/> 'medians': [&lt;matplotlib.lines.Line2D at 0x195176900a0&gt;],<br/> 'fliers': [&lt;matplotlib.lines.Line2D at 0x195176903a0&gt;],<br/> 'means': []}</span></pre><p id="9caf" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">注意:</strong>为了以后能够使用<code class="fe mi mj mk ml b">hatch</code>属性，需要在调用<code class="fe mi mj mk ml b">plt.boxplot()</code>时设置<code class="fe mi mj mk ml b">patch_artist=True</code>。</p><p id="64f6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们从上面的字典中需要的是<code class="fe mi mj mk ml b">'boxes'</code>键。我们必须遍历所有的方框(即使在我们的例子中，我们只有一个方框图，因此只有一个方框),并为每个方框设置相应的<code class="fe mi mj mk ml b">hatch</code>值，就像我们在条形图中只强调一个条形一样:</p><pre class="kj kk kl km gt nj ml nk nl aw nm bi"><span id="7c4e" class="nn mn it ml b gy no np l nq nr">boxplots = plt.boxplot(data, patch_artist=True)<br/>for box in boxplots['boxes']:<br/>    box.set(hatch = 'x', fill=False)    <br/>plt.show()</span></pre><p id="72c4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">输出:</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/9cf8a0c35937a5b93ef85c6758343cf7.png" data-original-src="https://miro.medium.com/v2/resize:fit:744/format:webp/1*18Wewaa9JeEj4jAoScf3ww.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="9723" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当创建两个或多个盒状图时，这种技术变得更加有用:只强调其中的一部分，或者只为每个盒状图分配不同的模式。在这种情况下，我们必须创建一个<code class="fe mi mj mk ml b">hatch</code>属性的值列表(根据条件，如果必要，或者只是随机的),并遍历它:</p><pre class="kj kk kl km gt nj ml nk nl aw nm bi"><span id="332c" class="nn mn it ml b gy no np l nq nr">data1 = np.random.rand(10)<br/>data2 = np.random.rand(20)<br/>data3 = np.random.rand(500)<br/>hatches = ['o', '++', 'x']<br/>boxplots = plt.boxplot([data1, data2, data3], patch_artist=True)<br/>for i in range(len(boxplots['boxes'])):<br/>    boxplots['boxes'][i].set(hatch = hatches[i], fill=False)<br/>plt.show()</span></pre><p id="65ac" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">输出:</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/c447d14a41bdae8dd3a09f9249f5bdac.png" data-original-src="https://miro.medium.com/v2/resize:fit:744/format:webp/1*MsBswceGsAJdNGYTWe6_3w.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><h1 id="5b7a" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">圆形分格统计图表</h1><p id="fbd4" class="pw-post-body-paragraph ky kz it la b lb ne ju ld le nf jx lg lh ng lj lk ll nh ln lo lp ni lr ls lt im bi translated">和盒子图一样，<code class="fe mi mj mk ml b">plt.pie()</code>方法没有<code class="fe mi mj mk ml b">hatch</code>参数，所以用模式填充饼图也不简单。这一次，<code class="fe mi mj mk ml b">plt.pie()</code>方法返回一个元组:</p><pre class="kj kk kl km gt nj ml nk nl aw nm bi"><span id="b580" class="nn mn it ml b gy no np l nq nr">data = np.random.rand(5)<br/>patches = plt.pie(data)<br/>patches</span><span id="928e" class="nn mn it ml b gy nu np l nq nr"><strong class="ml iu">Output:<br/></strong>([&lt;matplotlib.patches.Wedge at 0x195177aa4c0&gt;,<br/>  &lt;matplotlib.patches.Wedge at 0x195177aa970&gt;,<br/>  &lt;matplotlib.patches.Wedge at 0x195177aadf0&gt;,<br/>  &lt;matplotlib.patches.Wedge at 0x195177b72b0&gt;,<br/>  &lt;matplotlib.patches.Wedge at 0x195177b7730&gt;],<br/> [Text(1.046742554077009, 0.3381272326866619, ''),<br/>  Text(-0.00440567017664189, 1.0999911772692974, ''),<br/>  Text(-1.0992106691773433, -0.0416641904601184, ''),<br/>  Text(-0.5217111246565277, -0.9684097802116732, ''),<br/>  Text(0.7338182292945598, -0.8194576293836047, '')])</span></pre><p id="5e39" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个元组的第一个元素(<code class="fe mi mj mk ml b">patches[0]</code>)包含了我们饼图的所有楔形。在这种情况下，有5个楔子。我们可以根据特定的条件或随机地给每个人分配一个特定的模式。让我们强调最小和最大的楔子，其他的不填。为此，我们必须遍历数据，对于满足上述条件的值(即最小值和最大值)，将<code class="fe mi mj mk ml b">'o'</code>和<code class="fe mi mj mk ml b">'O'</code>符号分配给相应的<code class="fe mi mj mk ml b">hatch</code>值，否则不分配任何值(空字符串):</p><pre class="kj kk kl km gt nj ml nk nl aw nm bi"><span id="6a7b" class="nn mn it ml b gy no np l nq nr">hatches = ['o' if value==min(data) else 'O' if value==max(data) else '' for value in data]</span></pre><p id="8228" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，让我们遍历楔形区和<code class="fe mi mj mk ml b">hatch</code>值，并用选择的模式填充最小和最大的楔形区:</p><pre class="kj kk kl km gt nj ml nk nl aw nm bi"><span id="b6d4" class="nn mn it ml b gy no np l nq nr">patches = plt.pie(data)<br/>for i in range(len(patches[0])):<br/>    patches[0][i].set(hatch = hatches[i], fill=False)<br/>plt.show()</span></pre><p id="cdc8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">输出:</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/35c1ff9f8405013a1a42bdad0ca9374e.png" data-original-src="https://miro.medium.com/v2/resize:fit:462/format:webp/1*T-i42N_hPPGsvMoRnCdEAA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><h1 id="35c6" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">结论</h1><p id="e053" class="pw-post-body-paragraph ky kz it la b lb ne ju ld le nf jx lg lh ng lj lk ll nh ln lo lp ni lr ls lt im bi translated">在本文中，我们探索了在matplolib中用不同的模式填充等高线图的方法，如条形图、直方图、箱线图和饼图，并考虑了这种方法特别有用的情况。</p><p id="65dd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我希望你喜欢阅读，并发现这些信息对你未来的项目有用。</p></div><div class="ab cl ny nz hx oa" role="separator"><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od"/></div><div class="im in io ip iq"><p id="f278" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">你可能也会对这些文章感兴趣:</strong></p><div class="of og gp gr oh oi"><a href="https://levelup.gitconnected.com/python-can-be-lots-of-fun-999552d69d21" rel="noopener  ugc nofollow" target="_blank"><div class="oj ab fo"><div class="ok ab ol cl cj om"><h2 class="bd iu gy z fp on fr fs oo fu fw is bi translated">Python可以带来很多乐趣</h2><div class="op l"><h3 class="bd b gy z fp on fr fs oo fu fw dk translated">Cowsay和Dinosay库，用于在Python中以ASCII艺术形式创建“会说话”的动物</h3></div><div class="oq l"><p class="bd b dl z fp on fr fs oo fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="or l"><div class="os l ot ou ov or ow ks oi"/></div></div></a></div><div class="of og gp gr oh oi"><a href="https://levelup.gitconnected.com/when-a-python-gotcha-leads-to-wrong-results-2447f379fdfe" rel="noopener  ugc nofollow" target="_blank"><div class="oj ab fo"><div class="ok ab ol cl cj om"><h2 class="bd iu gy z fp on fr fs oo fu fw is bi translated">当Python陷阱导致错误结果时</h2><div class="op l"><h3 class="bd b gy z fp on fr fs oo fu fw dk translated">一个奇怪的难以调试的带有舍入数字的Python故障</h3></div><div class="oq l"><p class="bd b dl z fp on fr fs oo fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="or l"><div class="ox l ot ou ov or ow ks oi"/></div></div></a></div><div class="of og gp gr oh oi"><a href="https://medium.com/geekculture/creating-toyplots-in-python-49de0bb27ec1" rel="noopener follow" target="_blank"><div class="oj ab fo"><div class="ok ab ol cl cj om"><h2 class="bd iu gy z fp on fr fs oo fu fw is bi translated">在Python 🧸中创建玩具图</h2><div class="op l"><h3 class="bd b gy z fp on fr fs oo fu fw dk translated">高质量的极简交互式可视化，非常适合电子出版</h3></div><div class="oq l"><p class="bd b dl z fp on fr fs oo fu fw dk translated">medium.com</p></div></div><div class="or l"><div class="oy l ot ou ov or ow ks oi"/></div></div></a></div></div></div>    
</body>
</html>