<html>
<head>
<title>Want to Implement MLOps at Home? Refactor Your Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">想在家里实现MLOps？重构您的代码</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/mlops-at-home-part2-3c4282df7714?source=collection_archive---------20-----------------------#2021-07-20">https://towardsdatascience.com/mlops-at-home-part2-3c4282df7714?source=collection_archive---------20-----------------------#2021-07-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3cbf" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">首先让您的代码可重用，然后看看工具</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/3bddfe1481aa7474eeebe5e221879441.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*TmhAiSsV-UTxEer0"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">凯利·西克玛在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><h1 id="c951" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">介绍</h1><p id="7684" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">MLOps是目前机器学习和数据科学中最受<strong class="lt iu">欢迎的</strong>流行语之一，但也是在线课程、YouTube视频和训练营最少涉及的领域之一。</p><p id="7210" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><strong class="lt iu">你可以在这里阅读我是如何定义MLOps的:</strong></p><div class="ms mt gp gr mu mv"><a rel="noopener follow" target="_blank" href="/mlops-at-home-part1-4c60db29d4a2"><div class="mw ab fo"><div class="mx ab my cl cj mz"><h2 class="bd iu gy z fp na fr fs nb fu fw is bi translated">在家创建一个现代的、开源的MLOps堆栈</h2><div class="nc l"><p class="bd b dl z fp na fr fs nb fu fw dk translated">towardsdatascience.com</p></div></div><div class="nd l"><div class="ne l nf ng nh nd ni ks mv"/></div></div></a></div><p id="4d8a" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">自从写了上面的文章，我一直带着以下问题研究MLOps</p><blockquote class="nj"><p id="3e94" class="nk nl it bd nm nn no np nq nr ns mm dk translated">我如何在家里开发和学习MLOps，而不用昂贵的软件，以一种转移到现实世界问题的方式？</p></blockquote><p id="9dbf" class="pw-post-body-paragraph lr ls it lt b lu nt ju lw lx nu jx lz ma nv mc md me nw mg mh mi nx mk ml mm im bi translated">我的解决方案是开发<strong class="lt iu">笔记本MLOPs </strong>的思路；从Jupyter笔记本电脑无缝过渡到可重复、有效的MLOps渠道。</p><p id="d648" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><strong class="lt iu">第一步是重构或改变你的代码。</strong></p><blockquote class="nj"><p id="af59" class="nk nl it bd nm nn no np nq nr ns mm dk translated">为了开发MLOps实践，您的代码应该是干净的和可重用的；使用有限硬编码的函数。</p></blockquote><p id="0c91" class="pw-post-body-paragraph lr ls it lt b lu nt ju lw lx nu jx lz ma nv mc md me nw mg mh mi nx mk ml mm im bi translated"><strong class="lt iu">那么我们要怎么做呢？下面的流程图总结了这些步骤；第一步是重构您的代码，这将是本文的重点，以后的文章将依次处理每个阶段。我们正准备将代码加载到<a class="ae ky" href="https://kedro.readthedocs.io/en/stable/index.html" rel="noopener ugc nofollow" target="_blank"> Kedro </a>上，我已经测试了它，发现它是进入MLOps的一个很好的网关工具。</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/657e98edfdc4d6b7911a9752c9b1ebf5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1164/format:webp/1*7DkDTZvtnq1TfbogXvS-Ew.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">MLOps家居流程图之旅。图片作者。</p></figure><h1 id="40bf" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">目录</h1><ul class=""><li id="b318" class="nz oa it lt b lu lv lx ly ma ob me oc mi od mm oe of og oh bi translated"><a class="ae ky" href="#2b55" rel="noopener ugc nofollow">动机</a></li><li id="046f" class="nz oa it lt b lu oi lx oj ma ok me ol mi om mm oe of og oh bi translated"><a class="ae ky" href="#6f4e" rel="noopener ugc nofollow">第一步:数据</a></li><li id="bb38" class="nz oa it lt b lu oi lx oj ma ok me ol mi om mm oe of og oh bi translated"><a class="ae ky" href="#297a" rel="noopener ugc nofollow">第二步:清理</a></li><li id="bf0b" class="nz oa it lt b lu oi lx oj ma ok me ol mi om mm oe of og oh bi translated"><a class="ae ky" href="#9a99" rel="noopener ugc nofollow">步骤3:参数字典</a></li><li id="0756" class="nz oa it lt b lu oi lx oj ma ok me ol mi om mm oe of og oh bi translated"><a class="ae ky" href="#96d3" rel="noopener ugc nofollow">不变代码</a></li><li id="5f47" class="nz oa it lt b lu oi lx oj ma ok me ol mi om mm oe of og oh bi translated"><a class="ae ky" href="#d13c" rel="noopener ugc nofollow">第四步:函数脚本</a></li><li id="9cfd" class="nz oa it lt b lu oi lx oj ma ok me ol mi om mm oe of og oh bi translated"><a class="ae ky" href="#d3d8" rel="noopener ugc nofollow">运行代码</a></li><li id="73d4" class="nz oa it lt b lu oi lx oj ma ok me ol mi om mm oe of og oh bi translated"><a class="ae ky" href="#4a99" rel="noopener ugc nofollow">第五步:建模</a></li><li id="7e08" class="nz oa it lt b lu oi lx oj ma ok me ol mi om mm oe of og oh bi translated"><a class="ae ky" href="#1843" rel="noopener ugc nofollow">结论</a></li></ul><h1 id="2b55" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">为什么我们需要重构我们的代码？</h1><p id="161e" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">MLOps的一个关键优势是<strong class="lt iu">可重复性</strong>和<strong class="lt iu">自动化</strong>，然而我们在机器学习的实验阶段编写的大多数代码都是不可重复的。我们通常在Jupyter笔记本的单元格中编写代码，一个接一个地运行，每次按下<em class="on"> shift + enter </em>。</p><p id="d56e" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">为了开发一个管道，我们需要使我们的代码更加可重复，这意味着<strong class="lt iu">将我们的预处理和建模阶段重写为Python函数。</strong></p><h1 id="6f4e" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">第一步:从一个“普通”的笔记本开始</h1><p id="a2db" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我用的是Kaggle 的<a class="ae ky" href="https://www.kaggle.com/serigne/stacked-regressions-top-4-on-leaderboard" rel="noopener ugc nofollow" target="_blank">这个笔记本，它用的是</a><a class="ae ky" href="https://www.kaggle.com/c/house-prices-advanced-regression-techniques" rel="noopener ugc nofollow" target="_blank">这个房价数据集</a>。这是Kaggle上最受欢迎的笔记本之一，理由很充分。它使用了一些非常有趣的整体建模技术，如果你以前没看过，绝对值得一读。</p><p id="8b99" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><a class="ae ky" href="https://github.com/AdamShafi92/mlops-at-home/tree/main/1-refactoring_code" rel="noopener ugc nofollow" target="_blank">我也上传了这篇文章到我的Github repo。</a></p><p id="3d18" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">从MLOps的角度来看，这是不合适的。一些清理与EDA混合在一起，可重用的功能非常少。当然，这是有意义的，因为这样做的目的是为了在Kaggle竞争中取得好成绩，而不是为了持续更新的生产部署。</p><p id="7528" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">然而，因为我们有一些真正可靠的代码，所以复制和粘贴代码以获得更清晰的东西是很简单的。</p><h1 id="297a" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">步骤2:清理</h1><p id="f2d0" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我已经创建了这个笔记本的简化版，它被清晰地分成了几个部分，减少了ed a并简化了一些代码。在最初的Kaggle笔记本中，清洁阶段分布在整个笔记本中，有时中间还有图表。因为我们是从别人那里拿笔记本，所以对我们来说很好地理解它在做什么是很重要的，给它一个结构有助于做到这一点。</p><p id="497b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><strong class="lt iu">您可以在这里查看笔记本:</strong></p><div class="ms mt gp gr mu mv"><a href="https://github.com/AdamShafi92/mlops-at-home/blob/main/1-refactoring_code/2%20Simplified.ipynb" rel="noopener  ugc nofollow" target="_blank"><div class="mw ab fo"><div class="mx ab my cl cj mz"><h2 class="bd iu gy z fp na fr fs nb fu fw is bi translated">adamshafi 92/m lops-在家</h2><div class="oo l"><h3 class="bd b gy z fp na fr fs nb fu fw dk translated">在GitHub上创建一个帐户，为adamshafi 92/mlops-home开发做出贡献。</h3></div><div class="nc l"><p class="bd b dl z fp na fr fs nb fu fw dk translated">github.com</p></div></div><div class="nd l"><div class="op l nf ng nh nd ni ks mv"/></div></div></a></div><p id="2b91" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这款笔记本的核心元素是:</p><ol class=""><li id="0dfd" class="nz oa it lt b lu mn lx mo ma oq me or mi os mm ot of og oh bi translated"><strong class="lt iu">加载数据</strong></li><li id="f8bc" class="nz oa it lt b lu oi lx oj ma ok me ol mi om mm ot of og oh bi translated"><strong class="lt iu">测试</strong>:通过检查前几行并查看一些统计和分布来检查数据</li><li id="a10d" class="nz oa it lt b lu oi lx oj ma ok me ol mi om mm ot of og oh bi translated"><strong class="lt iu"> EDA: </strong>了解数据的统计属性，并查看要清理的区域</li><li id="bbb0" class="nz oa it lt b lu oi lx oj ma ok me ol mi om mm ot of og oh bi translated"><strong class="lt iu">预处理</strong>:去除异常值、修正偏差、填充缺失值和编码分类变量</li><li id="2e94" class="nz oa it lt b lu oi lx oj ma ok me ol mi om mm ot of og oh bi translated"><strong class="lt iu">测试</strong>:确保预处理工作正常。</li><li id="184c" class="nz oa it lt b lu oi lx oj ma ok me ol mi om mm ot of og oh bi translated"><strong class="lt iu">建模</strong>:训练几个模型，查看度量标准，挑选最佳模型</li></ol><h1 id="9a99" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">步骤3:创建参数字典</h1><p id="dda9" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">MLOps的另一个关键领域是<strong class="lt iu">跟踪</strong>。很容易训练一个模型并调整超参数，然后忘记哪个版本的模型表现最好。<strong class="lt iu">我们可以(也愿意)实现工具来帮助这个</strong>，但是在这个早期阶段，从字典中调用来访问我们的参数是一个很好的想法。参数字典还有助于我们减少硬编码，因为我们可以调用字典而不是硬编码一个值。</p><p id="efbd" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">它应该包含(几乎)<strong class="lt iu">我们做出的每一个会影响模型</strong>的选择，所以如果我们移除任何异常值，它应该包含我们选择的值。删除列也是如此。它不需要不必要的选项。如果您已经缩放了数据，它不需要包括每个不同的缩放器选项。</p><p id="b91c" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">您可以使用以下代码定义字典</p><pre class="kj kk kl km gt ou ov ow ox aw oy bi"><span id="940b" class="oz la it ov b gy pa pb l pc pd">parameters = {'outliers' : 4000}</span></pre><p id="b5e2" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">然后，您可以通过调用字典来访问该值:</p><pre class="kj kk kl km gt ou ov ow ox aw oy bi"><span id="d67c" class="oz la it ov b gy pa pb l pc pd">parameters['outliers']</span><span id="f7f9" class="oz la it ov b gy pe pb l pc pd">&gt;&gt;&gt; 4000</span></pre><p id="1290" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">你也可以嵌套字典</p><pre class="kj kk kl km gt ou ov ow ox aw oy bi"><span id="097d" class="oz la it ov b gy pa pb l pc pd">parameters = {'outliers' : {'feat1' : 4000<br/>                            'feat2' : 50 }}</span></pre><p id="d7eb" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><strong class="lt iu">要提升一个等级</strong>，请尝试使用<em class="on">。yml </em>文件，可以作为字典加载到Python中。一旦我们开始使用MLOps工具，我们将不得不这样做。</p></div><div class="ab cl pf pg hx ph" role="separator"><span class="pi bw bk pj pk pl"/><span class="pi bw bk pj pk pl"/><span class="pi bw bk pj pk"/></div><div class="im in io ip iq"><h1 id="96d3" class="kz la it bd lb lc pm le lf lg pn li lj jz po ka ll kc pp kd ln kf pq kg lp lq bi translated">旁注:代码我们保持不变</h1><p id="8155" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">因为这不是我第一次这样做，我将把一些区域留在原来的笔记本中，这是因为有非常好的工具和解决方案，我将在以后的帖子中实现它们。</p><ol class=""><li id="6182" class="nz oa it lt b lu mn lx mo ma oq me or mi os mm ot of og oh bi translated"><strong class="lt iu"> EDA </strong>:探索性数据分析可以根据你正在做的事情而有很大的变化，也有一些软件包可以自动完成这个任务，比如<a class="ae ky" href="https://github.com/pandas-profiling/pandas-profiling" rel="noopener ugc nofollow" target="_blank"> pandas profiling </a>。</li><li id="7db2" class="nz oa it lt b lu oi lx oj ma ok me ol mi om mm ot of og oh bi translated"><strong class="lt iu">测试</strong>:我们将使用<a class="ae ky" href="https://greatexpectations.io/" rel="noopener ugc nofollow" target="_blank">远大前程</a>来自动化测试。</li><li id="0421" class="nz oa it lt b lu oi lx oj ma ok me ol mi om mm ot of og oh bi translated"><strong class="lt iu">建模</strong>:有很多工具，比如<a class="ae ky" href="https://www.mlflow.org/docs/latest/index.html" rel="noopener ugc nofollow" target="_blank"> MLFlow </a>，我们需要将它们集成到我们的管道中。</li></ol></div><div class="ab cl pf pg hx ph" role="separator"><span class="pi bw bk pj pk pl"/><span class="pi bw bk pj pk pl"/><span class="pi bw bk pj pk"/></div><div class="im in io ip iq"><h1 id="d13c" class="kz la it bd lb lc pm le lf lg pn li lj jz po ka ll kc pp kd ln kf pq kg lp lq bi translated">步骤4:将脚本转换成函数</h1><p id="bdb0" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">如果你曾经尝试过Kaggle数据集，那么拥有一个看起来像上面这样的笔记本是很常见的。为了实现良好的MLOps实践，我们需要使用一个<strong class="lt iu">可重用的</strong>管道<strong class="lt iu">来清理我们的数据。要做到这一点，我们需要将代码转换成函数。</strong></p><p id="354d" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">每个功能应该相当小，我们将使用<a class="ae ky" href="https://en.wikipedia.org/wiki/Single-responsibility_principle" rel="noopener ugc nofollow" target="_blank">单一责任原则</a>，因此每个功能只有一项工作。</p><blockquote class="nj"><p id="5e6e" class="nk nl it bd nm nn no np nq nr ns mm dk translated">单一责任原则是一项计算机编程原则，它规定计算机程序中的每个模块、类或函数都应对该程序功能的单一部分负责，并应封装该部分</p><p id="33a0" class="nk nl it bd nm nn no np nq nr ns mm dk translated">—维基百科</p></blockquote><p id="c87b" class="pw-post-body-paragraph lr ls it lt b lu nt ju lw lx nu jx lz ma nv mc md me nw mg mh mi nx mk ml mm im bi translated">这个笔记本在这里:</p><div class="ms mt gp gr mu mv"><a href="https://github.com/AdamShafi92/mlops-at-home/blob/main/1-refactoring_code/3%20Refactored.ipynb" rel="noopener  ugc nofollow" target="_blank"><div class="mw ab fo"><div class="mx ab my cl cj mz"><h2 class="bd iu gy z fp na fr fs nb fu fw is bi translated">adamshafi 92/m lops-在家</h2><div class="oo l"><h3 class="bd b gy z fp na fr fs nb fu fw dk translated">在GitHub上创建一个帐户，为adamshafi 92/mlops-home开发做出贡献。</h3></div><div class="nc l"><p class="bd b dl z fp na fr fs nb fu fw dk translated">github.com</p></div></div><div class="nd l"><div class="pr l nf ng nh nd ni ks mv"/></div></div></a></div><p id="75d4" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">对于这个MLOps实现，我建议在函数中包含任何可能影响模型的关键字参数，这样我们就可以很容易地更改它们。我们还将使用一个参数字典来提供这些关键字参数。我在下面举了一个例子。</p><p id="3d4e" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><strong class="lt iu">原码</strong></p><pre class="kj kk kl km gt ou ov ow ox aw oy bi"><span id="40f3" class="oz la it ov b gy pa pb l pc pd">train = train.drop(train[(train['GrLivArea']&gt;4000) &amp; <br/>                         (train['SalePrice']&lt;300000)]<br/>                   .index)</span></pre><p id="a2cc" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><strong class="lt iu">功能+参数字典</strong></p><pre class="kj kk kl km gt ou ov ow ox aw oy bi"><span id="8731" class="oz la it ov b gy pa pb l pc pd">parameters = {'outliers' : {'GrLivArea' : 4000,<br/>                            'SalePrice' : 300000}}<br/></span><span id="a23e" class="oz la it ov b gy pe pb l pc pd">def remove_outliers(train, parameters):<br/>    train = train.copy()<br/>    train = train.drop(<br/>        train[<br/>        (train['GrLivArea']&gt;parameters['outliers']['GrLivArea']) &amp; <br/>        (train['SalePrice']&lt;parameters['outliers']['SalePrice'])]<br/>        .index)<br/>    return train</span></pre><p id="bd00" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这实际上并不是一个重大的改变，因为列名仍然是硬编码的，所以我们并没有在这里做很大的改进。然而，这个函数现在可以很容易地重用，更重要的是，以后可以在管道中使用。我们将参数字典作为一个参数包含在函数中，以方便以后的工作。</p><p id="7ea9" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">总之，我已经创建了8个新的预处理函数。比较repo中的笔记本2和笔记本3，比较代码是如何变化的。</p><div class="ms mt gp gr mu mv"><a href="https://github.com/AdamShafi92/mlops-at-home/tree/main/1-refactoring_code" rel="noopener  ugc nofollow" target="_blank"><div class="mw ab fo"><div class="mx ab my cl cj mz"><h2 class="bd iu gy z fp na fr fs nb fu fw is bi translated">adamshafi 92/m lops-在家</h2><div class="oo l"><h3 class="bd b gy z fp na fr fs nb fu fw dk translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="nc l"><p class="bd b dl z fp na fr fs nb fu fw dk translated">github.com</p></div></div><div class="nd l"><div class="ps l nf ng nh nd ni ks mv"/></div></div></a></div></div><div class="ab cl pf pg hx ph" role="separator"><span class="pi bw bk pj pk pl"/><span class="pi bw bk pj pk pl"/><span class="pi bw bk pj pk"/></div><div class="im in io ip iq"><h1 id="d3d8" class="kz la it bd lb lc pm le lf lg pn li lj jz po ka ll kc pp kd ln kf pq kg lp lq bi translated">运行代码</h1><p id="900a" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">为了实际运行我们的函数，我们需要运行一些代码。一旦我们转移到MLOps，这些将被我们的工具定义为<em class="on">管道</em>和<em class="on">编排</em>，但现在我们将在笔记本上运行它们以确保一切正常。要运行代码，我们只需逐个调用每个函数。</p><p id="a395" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">要查看每个功能的细节，请查看Github 上的笔记本2。</p><pre class="kj kk kl km gt ou ov ow ox aw oy bi"><span id="dcdc" class="oz la it ov b gy pa pb l pc pd">train2 = train.copy()<br/>train2 = remove_outliers(train, parameters)</span><span id="cd10" class="oz la it ov b gy pe pb l pc pd">y_train = create_target(train2)</span><span id="a7e4" class="oz la it ov b gy pe pb l pc pd">train2 = drop_cols(train2, parameters)<br/>train2 = fill_na(train2, parameters)<br/>train2 = total_sf(train2)<br/>train2 = to_str(train2, parameters)<br/>train2 = fix_skew(train2, skewness)<br/>train2 = one_hot(train2)<br/>train2 = train2.astype(float)</span></pre></div><div class="ab cl pf pg hx ph" role="separator"><span class="pi bw bk pj pk pl"/><span class="pi bw bk pj pk pl"/><span class="pi bw bk pj pk"/></div><div class="im in io ip iq"><h1 id="4a99" class="kz la it bd lb lc pm le lf lg pn li lj jz po ka ll kc pp kd ln kf pq kg lp lq bi translated">第五步:建模</h1><p id="1226" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我们没有对这个笔记本的建模部分做太多的改动，因为稍后它会被<strong class="lt iu"> MLFlow </strong>所取代。一个好的临时选择是在这里也使用参数字典。</p><p id="8d9c" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这里我刚刚添加了一个功能，这个功能是<strong class="lt iu">训练</strong>和<strong class="lt iu"> pickles </strong>模型，并输出一些<strong class="lt iu">图表</strong>；残差的直方图、训练数据和预测的散点图以及QQ图。</p><p id="69cc" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">由于这是一个Kaggle数据集，我们没有带标签的测试数据。尽管我们使用交叉验证来挑选最佳模型，但为了简单起见，我们使用训练数据来绘制这些图。</p><pre class="kj kk kl km gt ou ov ow ox aw oy bi"><span id="7aa2" class="oz la it ov b gy pa pb l pc pd">def fit_model(model, X_train, y_train, filepath, n_folds=5):<br/>    score = rmsle_cv(model, X_train, y_train, n_folds)</span><span id="9e30" class="oz la it ov b gy pe pb l pc pd">    model = model.fit(X_train,y_train)<br/>    pickle.dump(model, open(filepath, 'wb'))<br/>    <br/>    print("\nmodel score: {:.4f} ({:.4f})\n".format(<br/>    score.mean(), score.std()))<br/>    <br/>    y_pred = model.predict(X_train)<br/>    <br/>    fig,ax = plt.subplots(ncols=3,figsize=(20,4))<br/>    ax[0].hist(x=y_pred-y_train,bins=20)<br/>    ax[1].scatter(x=y_train,y=y_pred)<br/>    ax[1].axline([0, 0], [1, 1])<br/>    sm.qqplot(y_pred, ax=ax[2], fit=True,line="45")<br/>    plt.show()<br/>    return model</span><span id="2b0c" class="oz la it ov b gy pe pb l pc pd">lasso = make_pipeline(<br/>RobustScaler(), Lasso(alpha=0.0005, random_state=1))</span><span id="968a" class="oz la it ov b gy pe pb l pc pd">lasso_fit = fit_model(lasso,train2,y_train,'lasso.pkl')</span></pre><blockquote class="pt pu pv"><p id="c284" class="lr ls on lt b lu mn ju lw lx mo jx lz pw mp mc md px mq mg mh py mr mk ml mm im bi translated">注意:我们必须缩放线性模型的数据，目前最简单的方法是使用sklearn的<strong class="lt iu">make _ pipeline</strong><em class="it"/>函数，并在这一点上包括缩放器，而不是事先缩放所有数据。</p></blockquote><p id="96d2" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">就是这样！假设您已经理解了核心概念，那么您现在应该能够将一台以实验为重点的立式笔记本电脑转变为可用于所有重要开发部署阶段的产品。</p></div><div class="ab cl pf pg hx ph" role="separator"><span class="pi bw bk pj pk pl"/><span class="pi bw bk pj pk pl"/><span class="pi bw bk pj pk"/></div><div class="im in io ip iq"><h1 id="1843" class="kz la it bd lb lc pm le lf lg pn li lj jz po ka ll kc pp kd ln kf pq kg lp lq bi translated">结论</h1><p id="5628" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我们已经学习了如何准备在MLOps管道中使用的代码。关键是编写<strong class="lt iu">可重用的</strong>函数，而不是一次性使用的、根据命令运行的代码。另一个关键的收获是<strong class="lt iu">参数字典</strong>，这是一个跟踪参数和运行实验的好方法，即使你不打算将你的笔记本开发成MLOps流水线。</p><p id="b44b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在本系列的下一篇文章中，我们将创建一个<a class="ae ky" href="https://kedro.readthedocs.io/en/stable/index.html" rel="noopener ugc nofollow" target="_blank"> Kedro </a>项目，并将我们的笔记本变成节点和管道，Kedro可以根据命令运行。</p><h2 id="bca8" class="oz la it bd lb pz qa dn lf qb qc dp lj ma qd qe ll me qf qg ln mi qh qi lp qj bi translated">了解更多信息</h2><div class="ms mt gp gr mu mv"><a rel="noopener follow" target="_blank" href="/explainable-ai-9a9af94931ff"><div class="mw ab fo"><div class="mx ab my cl cj mz"><h2 class="bd iu gy z fp na fr fs nb fu fw is bi translated">你应该了解的5个可解释的机器学习模型</h2><div class="oo l"><h3 class="bd b gy z fp na fr fs nb fu fw dk translated">当简单的方法奏效时，为什么要使用复杂的模型？</h3></div><div class="nc l"><p class="bd b dl z fp na fr fs nb fu fw dk translated">towardsdatascience.com</p></div></div><div class="nd l"><div class="qk l nf ng nh nd ni ks mv"/></div></div></a></div><h2 id="8d9b" class="oz la it bd lb pz qa dn lf qb qc dp lj ma qd qe ll me qf qg ln mi qh qi lp qj bi translated">将我的内容直接发送到您的收件箱！</h2><div class="ms mt gp gr mu mv"><a href="https://adamsh.substack.com/p/coming-soon" rel="noopener  ugc nofollow" target="_blank"><div class="mw ab fo"><div class="mx ab my cl cj mz"><h2 class="bd iu gy z fp na fr fs nb fu fw is bi translated">Data Siens:机器学习技巧、诀窍和教程的资源。</h2><div class="oo l"><h3 class="bd b gy z fp na fr fs nb fu fw dk translated">欢迎来到亚当的数据西恩斯。我是一名数据科学家，有5年的分析经验。我喜欢谈论任何事情…</h3></div><div class="nc l"><p class="bd b dl z fp na fr fs nb fu fw dk translated">adamsh.substack.com</p></div></div><div class="nd l"><div class="ql l nf ng nh nd ni ks mv"/></div></div></a></div></div></div>    
</body>
</html>