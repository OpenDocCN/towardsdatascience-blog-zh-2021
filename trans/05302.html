<html>
<head>
<title>Twitchverse: Constructing a Twitch Knowledge Graph in Neo4j</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Twitchverse:在Neo4j中构建Twitch知识图</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/twitchverse-constructing-a-twitch-knowledge-graph-in-neo4j-78f03276c1f7?source=collection_archive---------21-----------------------#2021-05-10">https://towardsdatascience.com/twitchverse-constructing-a-twitch-knowledge-graph-in-neo4j-78f03276c1f7?source=collection_archive---------21-----------------------#2021-05-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="e0d6" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">了解如何在Neo4j中设计和构建描述Twitch宇宙的知识图</h2></div><p id="f2cc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我从Twitch   <strong class="kh ir"> </strong>帖子上的可视化公共数据中获得了<a class="ae lb" rel="noopener" target="_blank" href="/insights-from-visualizing-public-data-on-twitch-a73304a1b3eb"> <strong class="kh ir">见解的灵感。作者使用<a class="ae lb" href="https://gephi.org/" rel="noopener ugc nofollow" target="_blank"> Gephi </a>对Twitch网络进行图形分析，并将结果可视化。Twitch是一个在线平台，允许用户通过直播分享他们的内容。Twitch streamers通过与粉丝共享他们的屏幕来广播他们的游戏或活动，粉丝可以听到和观看他们的直播。我想知道如果我们使用图形数据库而不是Gephi来存储网络信息，我们可以进行什么样的分析。这篇博文将向你展示如何在<a class="ae lb" href="https://neo4j.com/" rel="noopener ugc nofollow" target="_blank"> Neo4j </a>中设计和构建知识图。数据将通过官方的<a class="ae lb" href="https://dev.twitch.tv/docs/api/" rel="noopener ugc nofollow" target="_blank"> Twitch API </a>获取。</strong></a></p><h2 id="72c2" class="lc ld iq bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated">环境设置</h2><p id="5b09" class="pw-post-body-paragraph kf kg iq kh b ki lv jr kk kl lw ju kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">你需要Twitch API的证书来关注这篇博文。如果你已经在Twitch上创建了一个用户，你可以在<a class="ae lb" href="https://twitchtokengenerator.com/" rel="noopener ugc nofollow" target="_blank"> Twitch令牌生成器站点</a>上获得访问令牌和客户端id，这是获得凭证最简单的方法。一旦你完成了这个步骤，你应该准备好<strong class="kh ir">客户端id </strong>和<strong class="kh ir">访问令牌</strong>(记住，访问令牌不是客户端秘密)。</p><p id="cec3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，您需要访问Neo4j数据库实例。最直接的解决方案是使用Neo4j沙箱，Neo4j数据库的免费云实例。如果选择此路线，请选择使用空白沙盒项目。如果你愿意，你也可以在本地安装<a class="ae lb" href="https://neo4j.com/download/" rel="noopener ugc nofollow" target="_blank"> Neo4j桌面</a>。</p><h2 id="b19a" class="lc ld iq bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated">导入关于当前热门观看的流的信息</h2><p id="4642" class="pw-post-body-paragraph kf kg iq kh b ki lv jr kk kl lw ju kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">首先，我们将从Twitch API导入关于当前直播流的信息。API文档可从<a class="ae lb" href="https://dev.twitch.tv/docs/api/reference#get-streams" rel="noopener ugc nofollow" target="_blank">这里</a>获得。我们可以获取当前直播的1000个观看次数最多的流的数据。API响应包含以下信息:</p><ul class=""><li id="00f7" class="ma mb iq kh b ki kj kl km ko mc ks md kw me la mf mg mh mi bi translated">流媒体工具名称和id</li><li id="03ca" class="ma mb iq kh b ki mj kl mk ko ml ks mm kw mn la mf mg mh mi bi translated">他们正在玩的游戏</li><li id="7e53" class="ma mb iq kh b ki mj kl mk ko ml ks mm kw mn la mf mg mh mi bi translated">溪流的语言</li></ul><p id="5724" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">想想我们应该如何将这些信息存储为图表。我们用哪些信息作为节点，哪些作为关系？回答你的一些问题，随着时间的推移，用户可以玩很多游戏，使用很多语言。此外，流可以表现得像普通用户一样，订阅其他流，在他们的聊天中交谈等。通常情况下，需要不止一次的图建模过程迭代才能得到正确的结果。下面的图模型是我的第二次迭代。</p><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi mo"><img src="../Images/2b6b4b4e204f14f78aa754b09d41bf78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aUEK4ZO59LsI-3x0zWH0AA.png"/></div></div><p class="na nb gj gh gi nc nd bd b be z dk translated">图形模型来存储有关streamers的信息。图片由作者提供。</p></figure><p id="2ec6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我已经使用<a class="ae lb" href="https://arrows.app/" rel="noopener ugc nofollow" target="_blank"> arrows应用程序</a>绘制了这篇博文中的所有图表。</p><p id="cfaf" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如你所见，streamer只是一个Twitch用户，他也广播他们的内容。我已经决定为Twitch网络中的所有用户使用一个<em class="ne">用户</em>标签，并为也进行流传输的用户添加一个二级<em class="ne">流</em>标签。我们知道一个流有多少追随者，在哪里可以找到这个流，以及用户是什么时候被创建的。我们将这些附加信息存储为节点属性。</p><p id="86c5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">语言和游戏信息以<a class="ae lb" href="https://medium.com/neo4j/graph-data-modeling-categorical-variables-dd8a2845d5e0" rel="noopener">分类节点</a>的形式存储。分类节点用于存储关于值数量有限的变量的信息。在我们的例子中，所玩的游戏和语言具有有限的价值。用户可以与游戏节点有一个或多个关系。也许在周五，他们更喜欢玩Valorant，周日他们喜欢玩扑克。我们的图模型忽略了这个信息的时间成分。我们也不存储流玩家玩游戏的次数作为关系权重。我们忽略这两个数据点，因为我们必须优化数据收集过程来提取这些信息。</p><p id="c434" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在继续之前，请确保在Neo4j中定义惟一的约束，以优化导入查询的性能。</p><pre class="mp mq mr ms gt nf ng nh ni aw nj bi"><span id="4de6" class="lc ld iq ng b gy nk nl l nm nn">CREATE CONSTRAINT ON (s:Stream) ASSERT s.name IS UNIQUE;<br/>CREATE CONSTRAINT ON (u:User) ASSERT u.name IS UNIQUE;<br/>CREATE CONSTRAINT ON (g:Game) ASSERT g.name IS UNIQUE;<br/>CREATE CONSTRAINT ON (l:Language) ASSERT l.name IS UNIQUE;<br/>CREATE CONSTRAINT ON (t:Team) ASSERT t.id IS UNIQUE;</span></pre><p id="0284" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我从事Neo4j数据库工作已经有五年了。大约一两个月后，我了解到<a class="ae lb" href="https://neo4j.com/labs/apoc/" rel="noopener ugc nofollow" target="_blank"> APOC库</a>是一个必须与Neo4j数据库结合使用的插件。它具有许多实用功能，可以帮助您立即解决您的问题。我最喜欢的APOC手术从一开始就是，现在仍然是<code class="fe no np nq ng b">apoc.load.json</code>手术。它允许打开JSON文件，更重要的是，从任何返回JSON的API端点获取数据。仅使用Cypher，您可以抓取各种API端点，并在没有任何外部工具的情况下构建知识图。多牛逼啊！它还支持请求中的自定义头和有效负载。在<a class="ae lb" href="https://neo4j.com/labs/apoc/4.1/import/load-json/" rel="noopener ugc nofollow" target="_blank">文档</a>中了解更多关于<code class="fe no np nq ng b">apoc.load.json</code>程序的信息。</p><p id="99f6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了导入关于streamers的信息，您需要附近有Twitch API <strong class="kh ir"> client_id </strong>。streams端点支持分页，并允许导出多达1000个活动流，每个请求最多100个流。端点有一个可用于分页的<em class="ne">偏移量</em>参数。为了用递增的偏移量参数执行十个请求，我们使用</p><pre class="mp mq mr ms gt nf ng nh ni aw nj bi"><span id="340b" class="lc ld iq ng b gy nk nl l nm nn">UNWIND range(0, 900, 100) as offset</span></pre><p id="f6dc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该语句将对偏移量的每个值执行请求。range子句与Python中的range函数非常相似。我们告诉它，我们想要创建一个从0开始到900结束的列表，步长为100。</p><p id="4443" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们将分页、请求和存储响应放在一个Cypher语句中，我们将得到下面的查询:</p><pre class="mp mq mr ms gt nf ng nh ni aw nj bi"><span id="4f98" class="lc ld iq ng b gy nk nl l nm nn">WITH $client_id as client_id<br/>//prepare pagination<br/>UNWIND range(0,900,100) as offset<br/>//Make an API request<br/>WITH "https://api.twitch.tv/kraken/streams/?limit=100&amp;offset=" + toString(offset) AS url, client_id<br/>CALL apoc.load.jsonParams(url,{Accept: "application/vnd.twitchtv.v5+json", `Client-ID`:client_id},null) YIELD value<br/>//Iterate over results in the response<br/>UNWIND value.streams as stream<br/>//Store streamer information<br/>MERGE (s:User{name:stream.channel.name})<br/>SET s.followers = stream.channel.followers,<br/>    s.url = stream.channel.url,<br/>    s.createdAt = datetime(stream.channel.createdAt),<br/>    s:Stream,<br/>    s.id = stream.channel.`_id`<br/>//Store game information<br/>MERGE (g:Game{name:stream.game})<br/>MERGE (s)-[:PLAYS]-&gt;(g)<br/>//Store language information<br/>MERGE (l:Language{name:stream.channel.language})<br/>MERGE (s)-[:HAS_LANGUAGE]-&gt;(l);</span></pre><p id="a640" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，您的Neo4j数据库中应该有关于1000条streamers的信息。为了检查该图，我们可以看一下数据库中的单个流。运行以下cypher查询来获取单个流的游戏和语言信息:</p><pre class="mp mq mr ms gt nf ng nh ni aw nj bi"><span id="e8c7" class="lc ld iq ng b gy nk nl l nm nn">MATCH (s:Stream)<br/>WITH s LIMIT 1<br/>MATCH p=()&lt;-[:HAS_LANGUAGE]-(s)-[:PLAYS]-&gt;()<br/>RETURN p</span></pre><p id="1d3f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可以在Neo4j浏览器中可视化结果。您应该会看到类似下图的内容。</p><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/fa1473f2f8e9baa4e5797cd85c634ae1.png" data-original-src="https://miro.medium.com/v2/resize:fit:854/format:webp/1*MRDoU6LrA6OtdTXL4cymOw.png"/></div><p class="na nb gj gh gi nc nd bd b be z dk translated">单个流、其语言和他们玩的游戏的网络可视化。图片由作者提供。</p></figure><h2 id="ac48" class="lc ld iq bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated">导入关于聊天者的信息</h2><p id="09e7" class="pw-post-body-paragraph kf kg iq kh b ki lv jr kk kl lw ju kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">在Twitch上，用户可以通过在聊天中输入评论来与streamers互动。幸运的是，Twitch有一个API端点，允许我们检索关于特定流的聊天者的信息。这个API端点不需要任何授权。如果你想知道谁是<em class="ne"> botezlive </em>流中的聊天者，你可以通过打开下面的链接获得这些信息:</p><pre class="mp mq mr ms gt nf ng nh ni aw nj bi"><span id="b33f" class="lc ld iq ng b gy nk nl l nm nn">http://tmi.twitch.tv/group/user/botezlive/chatters</span></pre><p id="7942" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">关于chatter的信息存储在三个独立的数组中，指示chatter是流的VIP、流的版主还是普通用户。还有global_mod，和admin数组返回，但是据我所见都是空的，我们就忽略了。</p><p id="490c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在导入关于chatters的信息之前，让我们考虑一下应该如何定义图模型。从API端点响应中，我们了解到我们可以区分chatter是版主、VIP还是普通用户。我们希望在我们的知识图中存储用户、版主和VIP之间的这种差异。我用不同的关系类型来表示这种区别。</p><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi ns"><img src="../Images/e8ac76d945ac15ff5da69c4e962cfe19.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iaQ3Y04LDwvsJN454xYVVg.png"/></div></div><p class="na nb gj gh gi nc nd bd b be z dk translated">颤振信息的图形模型。图片由作者提供。</p></figure><p id="603a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我第二喜欢的APOC手术是<code class="fe no np nq ng b">apoc.periodic.iterate</code>手术。它允许我们批量处理交易。这在处理大型数据结构时非常有用。在我们的例子中，单个拖缆可以有数千个抖动，如果我们检索1000个拖缆的抖动信息，我们可以处理大量数据。<code class="fe no np nq ng b">apoc.periodic.iterate</code>过程接受两个带有可选配置图的Cypher语句。第一个Cypher语句返回我们想要迭代的数据列表。第二条语句从第一条Cypher语句中获取信息，通常将信息存储到Neo4j中。在配置图中，我们可以定义批量大小。批量大小表示单个事务中应该添加多少次迭代。在<a class="ae lb" href="https://neo4j.com/labs/apoc/4.1/graph-updates/periodic-execution/" rel="noopener ugc nofollow" target="_blank">文档</a>中了解更多关于APOC配料的信息。</p><p id="f658" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们把它们放在一起，我们可以返回<code class="fe no np nq ng b">apoc.periodic.iterate</code>过程的第一个Cypher语句中的所有streamers。在第二条语句中，我们创建了一个对Twitch API端点的请求，并存储了结果。我使用了值为1的<em class="ne"> batchSize </em>参数来批处理每个请求，并在单独的事务中存储响应。</p><pre class="mp mq mr ms gt nf ng nh ni aw nj bi"><span id="0073" class="lc ld iq ng b gy nk nl l nm nn">// Import mods/vip/chatters for each stream<br/>CALL apoc.periodic.iterate(<br/>   // Return all stream nodes<br/>  'MATCH (s:Stream) RETURN s',<br/>  'WITH s, "http://tmi.twitch.tv/group/user/" + s.name + "/chatters" as url     <br/>  //Fetch chatter information  <br/>  CALL apoc.load.json(url) YIELD value     <br/>  WITH s, value.chatters as chatters     <br/>  // Store information about vips<br/>  FOREACH (vip in chatters.vips | <br/>          MERGE (u:User{name:vip}) <br/>          MERGE (u)-[:VIP]-&gt;(s))<br/>  //Store information about moderators<br/>  FOREACH (mod in chatters.moderators | <br/>          MERGE (u:User{name:mod}) <br/>          MERGE (u)-[:MODERATOR]-&gt;(s))<br/>  //Store information about regular users<br/>  FOREACH (chatter in chatters.viewers | <br/>          MERGE (u:User{name:chatter}) <br/>          MERGE (u)-[:CHATTER]-&gt;(s))',<br/>{batchSize:1})</span></pre><p id="0dd5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可以结合获取前1000个活动流来重复此查询，以收集关于Twitch chatter网络的更多信息。要检查信息存储是否正确，可以执行以下Cypher查询:</p><pre class="mp mq mr ms gt nf ng nh ni aw nj bi"><span id="9a8f" class="lc ld iq ng b gy nk nl l nm nn">MATCH (s:Stream)<br/>WITH s LIMIT 1<br/>MATCH p=(s)&lt;-[:MODERATOR|VIP|CHATTER]-()<br/>RETURN p LIMIT 25</span></pre><p id="9a5e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您在Neo4j浏览器中可视化该查询的结果，您应该会看到类似于下面的可视化内容:</p><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi nt"><img src="../Images/ae485df2ed14e7ab47c5f602280af090.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vEZ_4yFUB7UCsITIgJlM7g.png"/></div></div><p class="na nb gj gh gi nc nd bd b be z dk translated">导入chatter网络的结果。图片由作者提供。</p></figure><h2 id="5d54" class="lc ld iq bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated">导入有关streamers的详细信息</h2><p id="0143" class="pw-post-body-paragraph kf kg iq kh b ki lv jr kk kl lw ju kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">有一个单独的Twitch API端点，我们可以使用它来获取关于每个流的更多详细信息，比如总视图计数生存期。API端点参考可在<a class="ae lb" href="https://dev.twitch.tv/docs/api/reference#get-users" rel="noopener ugc nofollow" target="_blank">此链接</a>上获得。我们已经学习了如何结合<code class="fe no np nq ng b">apoc.load.json</code>和<code class="fe no np nq ng b">apoc.periodic.iterate</code>过程从API端点获取信息。</p><p id="4694" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们应该如何存储附加描述和总历史视图计数信息？它们不是分类变量，每个流只有一个值。我认为将它们存储为节点属性是最有意义的。</p><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/6e0e376919fa5883c8efd31b3b8311ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1274/format:webp/1*dLkYeetmGXw93ApI4OZlew.png"/></div><p class="na nb gj gh gi nc nd bd b be z dk translated">将总视图计数和描述存储为节点属性。图片由作者提供。</p></figure><p id="fca4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如上所述，我们结合了<code class="fe no np nq ng b">apoc.periodic.iterate</code>和<code class="fe no np nq ng b">apoc.load.json</code>过程来从Twitch API端点获取这些信息。</p><pre class="mp mq mr ms gt nf ng nh ni aw nj bi"><span id="f395" class="lc ld iq ng b gy nk nl l nm nn">CALL apoc.periodic.iterate(<br/>  'MATCH (s:Stream) RETURN s',<br/>  'WITH s, <br/>        "https://api.twitch.tv/helix/users?login=" + s.name as url, <br/>        "Bearer &lt;access token&gt;" as auth, $client_id as client_id<br/>   CALL apoc.load.jsonParams(url,<br/>       {Authorization: auth, `Client-ID`:client_id},null)<br/>   YIELD value<br/>   SET s.id = value.data[0].id, <br/>       s.total_view_count = value.data[0].view_count,<br/>       s.createdAt = datetime(value.data[0].created_at),<br/>       s.description = value.data[0].description',<br/>{batchSize:1})</span></pre><h2 id="904f" class="lc ld iq bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated">导入streamer团队信息</h2><p id="48c6" class="pw-post-body-paragraph kf kg iq kh b ki lv jr kk kl lw ju kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">每个streamer可以属于Twitch上的零个、一个或多个团队。这是我们将在这篇博文中导入的最后一个信息。我将让您稍微思考一下我们应该如何存储一个streamer属于哪个团队的信息。我可以给你一个提示，它属于分类变量范畴。每个流可以属于零个、一个或多个团队。Twitch上的团队数量有限。</p><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi nv"><img src="../Images/93c78f3a5552958ee8047f6a2a2a3de0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dxjBmGy4K28ecXmhnAPD8g.png"/></div></div><p class="na nb gj gh gi nc nd bd b be z dk translated">Twitch团队信息的图模型。图片由作者提供。</p></figure><p id="f57a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可以在图形建模过程中看到重复的模式。需要注意的一点是，您应该尽可能使用不同的关系类型，这一点没有明确提到。您希望避免像<em class="ne"> HAS、</em>这样的通用关系类型，尤其是当它在许多不同的场景中使用时。</p><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi nw"><img src="../Images/1ea212b2e10e4f4437aff0249ac96889.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AoqBTJHntgMb1JVaPbKrFA.png"/></div></div><p class="na nb gj gh gi nc nd bd b be z dk translated">图片由作者提供。</p></figure><p id="1fc3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，你应该已经熟悉了<code class="fe no np nq ng b">apoc.periodic.iterate</code>和<code class="fe no np nq ng b">apoc.load.json</code>程序。同样，我们将使用与之前相同的cypher查询结构从Twitch API端点检索数据。这里，只有端点URL和我们存储响应的方式发生了变化。将<code class="fe no np nq ng b">apoc.periodic.iterate</code>与值为1的<strong class="kh ir"> batchSize </strong>参数一起使用的另一个好处是，即使任何API请求失败，它也不会终止Cypher查询。Neo4j是一个ACID数据库，它会等到整个事务成功后再提交数据。由于我们将每个API请求分解到一个单独的事务中，所以我们不会遇到这样的问题:如果一千个请求中只有一个失败，我们就不会将任何信息存储到数据库中。例如，对于大约1–2%的请求，此端点会返回一个错误。当我们使用参数为1的<em class="ne"> batchSize </em>时，我们会忽略这些错误。</p><pre class="mp mq mr ms gt nf ng nh ni aw nj bi"><span id="2b8b" class="lc ld iq ng b gy nk nl l nm nn">CALL apoc.periodic.iterate(<br/>  'MATCH (s:Stream) <br/>   WHERE exists (s.id) and NOT (s)-[:HAS_TEAM]-&gt;()<br/>   RETURN s',<br/>   'WITH $client_id as client_id,<br/>         "Bearer &lt;access token&gt;" as auth, s<br/>    WITH s, <br/>         "https://api.twitch.tv/helix/teams/channel?broadcaster_id=" + toString(s.id) as url, <br/>         client_id, <br/>         auth<br/>    CALL apoc.load.jsonParams(url,<br/>         {Authorization: auth, `Client-ID`:client_id},null)<br/>    YIELD value<br/>    WITH s, value.data as data<br/>    WHERE data IS NOT NULL<br/>    UNWIND data as team<br/>    MERGE (t:Team{id:team.id})<br/>    ON CREATE SET t.name = team.team_display_name,<br/>                  t.createdAt = datetime(replace(trim(split(team.created_at,"+")[0]), " ", "T"))        <br/>    MERGE (s)-[:HAS_TEAM]-&gt;(t)',<br/>{batchSize:1})</span></pre><h2 id="fb33" class="lc ld iq bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated">摘要</h2><p id="6e8e" class="pw-post-body-paragraph kf kg iq kh b ki lv jr kk kl lw ju kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">希望你已经学会了如何借助APOC程序在Neo4j中有效地刮API端点。一步一步地，我们将额外的信息导入到我们的图表中，最终得到了一个描述Twitch宇宙的知识图表。</p><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi nx"><img src="../Images/3d74673b90e6fb9f3c034e4e90346791.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*el3TPeLEhwpWk0YSMSfJpg.png"/></div></div><p class="na nb gj gh gi nc nd bd b be z dk translated">抽动知识图图式。图片由作者提供。</p></figure><p id="9b7c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我的下一篇博客文章中，我将演示如何使用Cypher查询语言和图算法来分析这个图。敬请期待！</p><p id="97d4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="ne"> p.s .如果你想玩Twitch图而不用自己导入数据，我准备了一个</em> <a class="ae lb" href="https://drive.google.com/file/d/1ZR_SBEyEmOmxd6v-02kOARlnbq-VVpl_/view?usp=sharing" rel="noopener ugc nofollow" target="_blank"> <em class="ne"> Neo4j数据库转储</em> </a> <em class="ne">包含1000万个节点和2000万个关系。数据是在2021年5月7日到9日之间收集的。</em></p></div></div>    
</body>
</html>