<html>
<head>
<title>Write and train your own custom machine learning models using PyCaret</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用PyCaret编写和训练您自己的自定义机器学习模型</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/write-and-train-your-own-custom-machine-learning-models-using-pycaret-8fa76237374e?source=collection_archive---------8-----------------------#2021-04-27">https://towardsdatascience.com/write-and-train-your-own-custom-machine-learning-models-using-pycaret-8fa76237374e?source=collection_archive---------8-----------------------#2021-04-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="e49b" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">一步一步的，初学者友好的教程，关于如何用PyCaret编写和训练定制的机器学习模型</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/d0de640ad256b578c92df0752fc5f5b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*dERI0tdhD_Yay4OU"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">罗布·兰伯特在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h1 id="6ee7" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">PyCaret</h1><p id="1ca1" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">PyCaret是一个开源的低代码机器学习库和端到端的模型管理工具，内置于Python中，用于自动化机器学习工作流。它因其易用性、简单性以及快速高效地构建和部署端到端ML原型的能力而广受欢迎。</p><p id="2281" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">PyCaret是一个替代的低代码库，可以用几行代码代替数百行代码。这使得实验周期成倍地快速和有效。</p><p id="2f8f" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">py caret<strong class="lq ir">简单</strong> <strong class="lq ir">好用</strong>。PyCaret中执行的所有操作都顺序存储在一个<strong class="lq ir">管道</strong>中，该管道对于<strong class="lq ir">部署是完全自动化的。</strong>无论是输入缺失值、一键编码、转换分类数据、特征工程，甚至是超参数调整，PyCaret都能实现自动化。</p><p id="ac63" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">本教程假设您对PyCaret有一定的了解和经验。如果您以前没有使用过，没关系，您可以通过这些教程快速入门:</p><ul class=""><li id="779c" class="mp mq iq lq b lr mk lu ml lx mr mb ms mf mt mj mu mv mw mx bi translated"><a class="ae kv" rel="noopener" target="_blank" href="/pycaret-2-2-is-here-whats-new-ad7612ca63b"> PyCaret 2.2已经发布——新功能</a></li><li id="8ca6" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated"><a class="ae kv" rel="noopener" target="_blank" href="/announcing-pycaret-2-0-39c11014540e">宣布PyCaret 2.0 </a></li><li id="f767" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated">关于PyCaret你不知道的五件事</li></ul><h1 id="2acc" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">正在安装PyCaret</h1><p id="ae0f" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">安装PyCaret非常容易，只需要几分钟。我们强烈建议使用虚拟环境来避免与其他库的潜在冲突。</p><p id="fb99" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">PyCaret的默认安装是pycaret的精简版本，只安装这里列出的硬依赖项<a class="ae kv" href="https://github.com/pycaret/pycaret/blob/master/requirements.txt" rel="noopener ugc nofollow" target="_blank"/>。</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="4f81" class="ni kx iq ne b gy nj nk l nl nm"><strong class="ne ir"># install slim version (default)<br/></strong>pip install pycaret</span><span id="f10a" class="ni kx iq ne b gy nn nk l nl nm"><strong class="ne ir"># install the full version</strong><br/>pip install pycaret[full]</span></pre><p id="58ab" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">当你安装pycaret的完整版本时，这里列出的所有可选依赖项<a class="ae kv" href="https://github.com/pycaret/pycaret/blob/master/requirements-optional.txt" rel="noopener ugc nofollow" target="_blank"/>也会被安装。</p><h1 id="adc3" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">👉我们开始吧</h1><p id="5b5e" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">在我们开始讨论定制模型训练之前，让我们来看一个PyCaret如何处理开箱即用模型的快速演示。我将使用<a class="ae kv" href="https://github.com/pycaret/pycaret/tree/master/datasets" rel="noopener ugc nofollow" target="_blank"> PyCaret的存储库</a>上的“保险”数据集。该数据集的目标是基于一些属性预测患者费用。</p><h1 id="1f51" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">👉<strong class="ak">数据集</strong></h1><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="b1fe" class="ni kx iq ne b gy nj nk l nl nm"><strong class="ne ir"># read data from pycaret repo<br/></strong>from pycaret.datasets import get_data<br/>data = get_data('insurance')</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi no"><img src="../Images/c90057791b0d551e91fb3d556163dcb7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1268/format:webp/1*h4UQIEtUUmsP2ybJlsFKPA.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">保险数据集中的样本行</p></figure><h1 id="2f94" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">👉<strong class="ak">数据准备</strong></h1><p id="3159" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">对于PyCaret中的所有模块来说，<code class="fe np nq nr ne b">setup</code>是在PyCaret中执行的任何机器学习实验中的第一个也是唯一一个强制步骤。该函数负责训练模型之前所需的所有数据准备。除了执行一些基本的默认处理任务，PyCaret还提供了一系列预处理功能。要了解PyCaret中所有预处理功能的更多信息，您可以查看这个<a class="ae kv" href="https://pycaret.org/preprocessing/" rel="noopener ugc nofollow" target="_blank">链接</a>。</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="bc35" class="ni kx iq ne b gy nj nk l nl nm"><strong class="ne ir"># initialize setup<br/></strong>from pycaret.regression import *<br/>s = setup(data, target = 'charges')</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ns"><img src="../Images/8705f544421a28b0848c2c5db6b00365.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s5bhY1IN1jOM11JDuwFaZw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">pycaret.regression模块中的设置函数</p></figure><p id="0a90" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">每当在PyCaret中初始化<code class="fe np nq nr ne b">setup</code>函数时，它都会分析数据集并推断所有输入要素的数据类型。如果所有数据类型都推断正确，您可以按enter键继续。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/625f719a527ccf0a4efeed50d56ecb00.png" data-original-src="https://miro.medium.com/v2/resize:fit:956/format:webp/1*Y9kIg0BfRfzG1WdZm6MnbQ.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">设置的输出—为显示而截断</p></figure><h1 id="5a08" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">👉可用型号</h1><p id="ab99" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">要查看所有可用于训练的模型列表，您可以使用名为<code class="fe np nq nr ne b">models</code>的功能。它显示一个表格，其中包含模型ID、名称和实际评估者的参考。</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="ea7c" class="ni kx iq ne b gy nj nk l nl nm"><strong class="ne ir"># check all the available models<br/></strong>models()</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nu"><img src="../Images/e686bae891cd4c00df4a19cfe45979d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JVVVA2aUyVBJ9SyQjEC13A.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">models的输出()-出于显示目的，输出被截断</p></figure><h1 id="10ae" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">👉模型训练和选择</h1><p id="e64a" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">PyCaret中训练任何模型使用最多的函数是<code class="fe np nq nr ne b">create_model</code>。它需要一个你想要训练的估计器的ID。</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="011f" class="ni kx iq ne b gy nj nk l nl nm"><strong class="ne ir"># train decision tree<br/></strong>dt = create_model('dt')</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/3976e536c69a10ae241e777c72e8a0ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1184/format:webp/1*-txdluhP3Jl27ZUvoMzdow.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">create_model的输出(' dt ')</p></figure><p id="c100" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">输出显示了带有平均值和标准差的10倍交叉验证指标。这个函数的输出是一个经过训练的模型对象，它本质上是一个<code class="fe np nq nr ne b">scikit-learn</code>对象。</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="5303" class="ni kx iq ne b gy nj nk l nl nm">print(dt)</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nw"><img src="../Images/5472fdf6d0817ffbcc0321c25524f018.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7z-sMZdcNVamc1U-PFzVXg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">打印输出(dt)</p></figure><p id="2cdc" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">要在一个循环中训练多个模型，您可以编写一个简单的列表理解:</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="8136" class="ni kx iq ne b gy nj nk l nl nm"><strong class="ne ir"># train multiple models</strong><br/>multiple_models = [create_model(i) for i in ['dt', 'lr', 'xgboost']]</span><span id="6750" class="ni kx iq ne b gy nn nk l nl nm"><strong class="ne ir"># check multiple_models<br/></strong>type(multiple_models), len(multiple_models)<br/>&gt;&gt;&gt; (list, 3)</span><span id="4a46" class="ni kx iq ne b gy nn nk l nl nm">print(multiple_models)</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nx"><img src="../Images/020d61327a68262cacff96c75f26e7c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OO_I-wbH7h4PseoHOQ36Vg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">打印输出(多种型号)</p></figure><p id="7d96" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">如果您想训练库中所有可用的模型，而不是选定的几个，您可以使用PyCaret的<code class="fe np nq nr ne b">compare_models</code>函数，而不是编写自己的循环(<em class="ny">结果将是相同的，尽管</em>)。</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="b80d" class="ni kx iq ne b gy nj nk l nl nm"><strong class="ne ir"># compare all models</strong><br/>best_model = compare_models()</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nz"><img src="../Images/dbcc35dcf9a8739f16844d26bd76ed42.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9XtwGLvLDmJ5ro2fq67HLQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">compare_models函数的输出</p></figure><p id="e649" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><code class="fe np nq nr ne b">compare_models</code>返回显示所有模型的交叉验证指标的输出。根据这个输出，梯度推进回归器是最好的模型，在训练集上使用10重交叉验证，平均绝对误差<strong class="lq ir"/>【MAE】<strong class="lq ir"/>为2702美元。</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="f0b0" class="ni kx iq ne b gy nj nk l nl nm"><strong class="ne ir"># check the best model</strong><br/>print(best_model)</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oa"><img src="../Images/0d7aef38cc5df2ba685ce1b7858c41c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pQSXoclIKREi-2U2uG3jhQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">打印输出(最佳模式)</p></figure><p id="6b57" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">上面表格中显示的指标是交叉验证分数，用于检查保留集上的<code class="fe np nq nr ne b">best_model</code>的分数:</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="59cf" class="ni kx iq ne b gy nj nk l nl nm"><strong class="ne ir"># predict on hold-out<br/></strong>pred_holdout = predict_model(best_model)</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ob"><img src="../Images/7845663d1a2c8647fb7b9c2b50ae652c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G1l1bG1f_Tzoeo7X_ieixw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">预测模型(最佳模型)函数的输出</p></figure><p id="7860" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">要在看不见的数据集上生成预测，您可以使用相同的<code class="fe np nq nr ne b">predict_model</code>函数，但只需传递一个额外的参数<code class="fe np nq nr ne b">data</code>:</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="39b7" class="ni kx iq ne b gy nj nk l nl nm"><strong class="ne ir"># create copy of data drop target column</strong><br/>data2 = data.copy()<br/>data2.drop('charges', axis=1, inplace=True)</span><span id="234c" class="ni kx iq ne b gy nn nk l nl nm"><strong class="ne ir"># generate predictions<br/></strong>predictions = predict_model(best_model, data = data2)</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/013a304d8f852f5b1ab1a5c21ec52286.png" data-original-src="https://miro.medium.com/v2/resize:fit:1216/format:webp/1*jch_dJNscn_i2vNfgWpV5g.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">预测模型的输出(最佳模型，数据=数据2)</p></figure><h1 id="b378" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">👉编写和培训自定义模型</h1><p id="bb20" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">到目前为止，我们看到的是PyCaret中所有可用模型的训练和模型选择。然而，PyCaret为定制模型工作的方式是完全相同的。只要您的估算器与<code class="fe np nq nr ne b">sklearn</code> API风格兼容，它就会以同样的方式工作。我们来看几个例子。</p><p id="f614" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在向您展示如何编写自己的定制类之前，我将首先演示如何使用定制的非sklearn模型(sklearn或pycaret的基库中没有的模型)。</p><h2 id="f1bd" class="ni kx iq bd ky od oe dn lc of og dp lg lx oh oi li mb oj ok lk mf ol om lm on bi translated">👉<strong class="ak"> GPLearn车型</strong></h2><p id="2d17" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">虽然遗传编程(GP)可以用来执行<a class="ae kv" href="http://www.genetic-programming.org/combined.php" rel="noopener ugc nofollow" target="_blank">非常多种多样的任务</a>，<code class="fe np nq nr ne b">gplearn</code>被有目的地限制于解决符号回归问题。</p><p id="1a7c" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">符号回归是一种机器学习技术，旨在识别最佳描述关系的基础数学表达式。它首先构建一组简单的随机公式来表示已知自变量与其因变量目标之间的关系，以预测新数据。每一代程序都是通过从种群中选择最适合的个体进行遗传操作而从上一代进化而来的。</p><p id="a047" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">要使用<code class="fe np nq nr ne b">gplearn</code>的型号，您必须先安装它:</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="a30b" class="ni kx iq ne b gy nj nk l nl nm"><strong class="ne ir"># install gplearn<br/></strong>pip install gplearn</span></pre><p id="251a" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">现在您可以简单地导入未训练的模型，并在<code class="fe np nq nr ne b">create_model</code>函数中传递它:</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="7f37" class="ni kx iq ne b gy nj nk l nl nm"><strong class="ne ir"># import untrained estimator</strong><br/>from gplearn.genetic import SymbolicRegressor<br/>sc = SymbolicRegressor()</span><span id="f010" class="ni kx iq ne b gy nn nk l nl nm"><strong class="ne ir"># train using create_model<br/></strong>sc_trained = create_model(sc)</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/8f48bc50cddca176bdcdbd40a43d70ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1236/format:webp/1*WjHjXcM_Q4w7zuM_nfzVng.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">create_model的输出(sc_trained)</p></figure><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="db31" class="ni kx iq ne b gy nj nk l nl nm">print(sc_trained)</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi op"><img src="../Images/58f4e8a1df1520c5b8ba9d77e85a70d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1glIGPLohn6bxElYSmgtuQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">打印输出(sc_trained)</p></figure><p id="ea0e" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">您还可以检查这方面的坚持分数:</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="3254" class="ni kx iq ne b gy nj nk l nl nm"><strong class="ne ir"># check hold-out score<br/></strong>pred_holdout_sc = predict_model(sc_trained)</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oq"><img src="../Images/dea0c49f1ef7f85211df3cb1103195b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EoTHf4G1wm8Zh0xqScS_Gg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">预测模型(sc_trained)的输出</p></figure><h2 id="0d1f" class="ni kx iq bd ky od oe dn lc of og dp lg lx oh oi li mb oj ok lk mf ol om lm on bi translated">👉NGBoost型号</h2><p id="eae3" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">ngboost是一个实现自然梯度提升的Python库，如<a class="ae kv" href="https://stanfordmlgroup.github.io/projects/ngboost/" rel="noopener ugc nofollow" target="_blank">“NGBoost:概率预测的自然梯度提升”</a>所述。它建立在<a class="ae kv" href="https://scikit-learn.org/stable/" rel="noopener ugc nofollow" target="_blank"> Scikit-Learn </a>的基础上，在选择适当的评分规则、分布和基础学习者方面设计为可扩展和模块化的。本<a class="ae kv" href="https://drive.google.com/file/d/183BWFAdFms81MKy6hSku8qI97OwS_JH_/view?usp=sharing" rel="noopener ugc nofollow" target="_blank">幻灯片</a>提供了NGBoost基础方法的教学介绍。</p><p id="173d" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">要使用ngboost中的模型，您必须首先安装ngboost:</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="80a0" class="ni kx iq ne b gy nj nk l nl nm"><strong class="ne ir"># install ngboost</strong><br/>pip install ngboost</span></pre><p id="a414" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">安装后，您可以从ngboost库中导入未经训练的评估器，并使用<code class="fe np nq nr ne b">create_model</code>来训练和评估模型:</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="58c3" class="ni kx iq ne b gy nj nk l nl nm"><strong class="ne ir"># import untrained estimator</strong><br/>from ngboost import NGBRegressor<br/>ng = NGBRegressor()</span><span id="4e0e" class="ni kx iq ne b gy nn nk l nl nm"><strong class="ne ir"># train using create_model<br/></strong>ng_trained = create_model(ng)</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi or"><img src="../Images/22f2cd2165d417001d0700ca65b7e420.png" data-original-src="https://miro.medium.com/v2/resize:fit:1206/format:webp/1*6GjuFIPOBN4f19Qj7YPMlw.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">create_model的输出(ng)</p></figure><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="f159" class="ni kx iq ne b gy nj nk l nl nm">print(ng_trained)</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi os"><img src="../Images/ad33e4bc4f3d4377f6456f4cf7cb1d8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SSZoHUK4NnLE2Ri_Uy985Q.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">打印输出(ng_trained)</p></figure><h2 id="fc98" class="ni kx iq bd ky od oe dn lc of og dp lg lx oh oi li mb oj ok lk mf ol om lm on bi translated">👉编写自定义类</h2><p id="cd25" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">上面的两个例子<code class="fe np nq nr ne b">gplearn</code>和<code class="fe np nq nr ne b">ngboost</code>是pycaret的定制模型，因为它们在默认库中不可用，但是您可以像使用任何其他现成模型一样使用它们。然而，可能有一个用例涉及编写你自己的算法(即算法背后的数学)，在这种情况下，你可以从<code class="fe np nq nr ne b">sklearn</code>继承基类并编写你自己的数学。</p><p id="e2e2" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">让我们创建一个简单的估计器，它在<code class="fe np nq nr ne b">fit</code>阶段学习<code class="fe np nq nr ne b">target</code>变量的平均值，并预测所有新数据点的相同平均值，而不考虑X输入(<em class="ny">可能在现实生活中没有用，只是为了演示功能</em>)。</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="002b" class="ni kx iq ne b gy nj nk l nl nm"><strong class="ne ir"># create custom estimator</strong><br/>import numpy as np<strong class="ne ir"><br/></strong>from sklearn.base import BaseEstimator</span><span id="505e" class="ni kx iq ne b gy nn nk l nl nm">class MyOwnModel(BaseEstimator):<br/>    <br/>    def __init__(self):<br/>        self.mean = 0<br/>        <br/>    def fit(self, X, y):<br/>        self.mean = y.mean()<br/>        return self<br/>    <br/>    def predict(self, X):<br/>        return np.array(X.shape[0]*[self.mean])</span></pre><p id="97d8" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">现在让我们使用这个估计器进行训练:</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="016b" class="ni kx iq ne b gy nj nk l nl nm"><strong class="ne ir"># import MyOwnModel class</strong><br/>mom = MyOwnModel()</span><span id="ff5d" class="ni kx iq ne b gy nn nk l nl nm"><strong class="ne ir"># train using create_model<br/></strong>mom_trained = create_model(mom)</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ot"><img src="../Images/e6ce7aaa0ff96a0ef196a227126127d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1256/format:webp/1*ElBm8PRRTYgkCQ7J6tsf_g.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">create_model(mom)的输出</p></figure><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="2636" class="ni kx iq ne b gy nj nk l nl nm"><strong class="ne ir"># generate predictions on data</strong><br/>predictions = predict_model(mom_trained, data=data)</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ou"><img src="../Images/d2de3729f69a6d2a0911d93067bc8c74.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SE8aSw-Rhj41PYzRQxHWQw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">predict_model的输出(mom，data=data)</p></figure><p id="46c9" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">请注意，<code class="fe np nq nr ne b">Label</code>列实际上是所有行的预测，是相同的数字$13，225，这是因为我们以这样的方式创建了该算法，它从训练集的平均值中学习并预测相同的值(只是为了保持简单)。</p><p id="b070" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我希望您会喜欢PyCaret的易用性和简单性。只需几行代码，您就可以执行端到端的机器学习实验，并编写自己的算法，而无需调整任何本机代码。</p><h1 id="7013" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">即将推出！</h1><p id="1ee0" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">下周我将写一篇教程来推进这篇教程。我们将编写一个更复杂的算法，而不仅仅是一个均值预测。我将在下一个教程中介绍一些复杂的概念。请在<a class="ae kv" href="https://medium.com/@moez-62905" rel="noopener"> Medium </a>、<a class="ae kv" href="https://www.linkedin.com/in/profile-moez/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>、<a class="ae kv" href="https://twitter.com/moezpycaretorg1" rel="noopener ugc nofollow" target="_blank"> Twitter </a>关注我，获取更多更新。</p></div><div class="ab cl ov ow hu ox" role="separator"><span class="oy bw bk oz pa pb"/><span class="oy bw bk oz pa pb"/><span class="oy bw bk oz pa"/></div><div class="ij ik il im in"><p id="702a" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">使用Python中的这个轻量级工作流自动化库，您可以实现的目标是无限的。如果你觉得这很有用，请不要忘记给我们GitHub库上的⭐️。</p><p id="661d" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">要了解更多关于PyCaret的信息，请关注我们的LinkedIn和Youtube。</p><p id="1e70" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">加入我们的休闲频道。此处邀请链接<a class="ae kv" href="https://join.slack.com/t/pycaret/shared_invite/zt-p7aaexnl-EqdTfZ9U~mF0CwNcltffHg" rel="noopener ugc nofollow" target="_blank">。</a></p><h1 id="8de9" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">您可能还对以下内容感兴趣:</h1><p id="bc3f" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated"><a class="ae kv" rel="noopener" target="_blank" href="/build-your-own-automl-in-power-bi-using-pycaret-8291b64181d">使用PyCaret 2.0 </a> <br/> <a class="ae kv" rel="noopener" target="_blank" href="/deploy-machine-learning-pipeline-on-cloud-using-docker-container-bec64458dc01">在Power BI中构建您自己的AutoML使用Docker在Azure上部署机器学习管道</a> <br/> <a class="ae kv" rel="noopener" target="_blank" href="/deploy-machine-learning-model-on-google-kubernetes-engine-94daac85108b">在Google Kubernetes引擎上部署机器学习管道</a> <br/> <a class="ae kv" rel="noopener" target="_blank" href="/deploy-machine-learning-pipeline-on-aws-fargate-eb6e1c50507">在AWS Fargate上部署机器学习管道</a> <br/> <a class="ae kv" rel="noopener" target="_blank" href="/build-and-deploy-your-first-machine-learning-web-app-e020db344a99">构建并部署您的第一个机器学习web应用</a> <br/> <a class="ae kv" rel="noopener" target="_blank" href="/deploy-pycaret-and-streamlit-app-using-aws-fargate-serverless-infrastructure-8b7d7c0584c2">使用AWS Fargate serverless </a> <br/>部署PyCaret和Streamlit应用</p><h1 id="e5e7" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">重要链接</h1><p id="7309" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated"><a class="ae kv" href="https://pycaret.readthedocs.io/en/latest/installation.html" rel="noopener ugc nofollow" target="_blank">文档</a> <br/> <a class="ae kv" href="https://medium.com/@moez_62905" rel="noopener">博客</a><br/><a class="ae kv" href="http://www.github.com/pycaret/pycaret" rel="noopener ugc nofollow" target="_blank">GitHub</a><br/><a class="ae kv" href="https://stackoverflow.com/questions/tagged/pycaret" rel="noopener ugc nofollow" target="_blank">stack overflow</a><br/><a class="ae kv" href="https://pycaret.readthedocs.io/en/latest/installation.html" rel="noopener ugc nofollow" target="_blank">安装PyCaret <br/> </a> <a class="ae kv" href="https://pycaret.readthedocs.io/en/latest/tutorials.html" rel="noopener ugc nofollow" target="_blank">笔记本教程<br/> </a> <a class="ae kv" href="https://pycaret.readthedocs.io/en/latest/contribute.html" rel="noopener ugc nofollow" target="_blank">贡献于PyCaret </a></p><h1 id="93ec" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">想了解某个特定模块？</h1><p id="7708" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">单击下面的链接查看文档和工作示例。</p><p id="705a" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><a class="ae kv" href="https://pycaret.readthedocs.io/en/latest/api/classification.html" rel="noopener ugc nofollow" target="_blank">分类<br/> </a> <a class="ae kv" href="https://pycaret.readthedocs.io/en/latest/api/regression.html" rel="noopener ugc nofollow" target="_blank">回归</a> <br/> <a class="ae kv" href="https://pycaret.readthedocs.io/en/latest/api/clustering.html" rel="noopener ugc nofollow" target="_blank">聚类</a><br/>T29】异常检测 <br/> <a class="ae kv" href="https://pycaret.readthedocs.io/en/latest/api/nlp.html" rel="noopener ugc nofollow" target="_blank">自然语言处理<br/> </a> <a class="ae kv" href="https://pycaret.readthedocs.io/en/latest/api/arules.html" rel="noopener ugc nofollow" target="_blank">关联规则挖掘</a></p></div></div>    
</body>
</html>