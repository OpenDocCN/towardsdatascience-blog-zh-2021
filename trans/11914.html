<html>
<head>
<title>Refactoring a Jupyter notebook into a maintainable pipeline: A step-by-step guide (Part II)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将 Jupyter 笔记本重构为可维护的管道:分步指南(第二部分)</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/refactoring-a-jupyter-notebook-into-a-maintainable-pipeline-a-step-by-step-guide-part-ii-138a8c395764?source=collection_archive---------25-----------------------#2021-11-29">https://towardsdatascience.com/refactoring-a-jupyter-notebook-into-a-maintainable-pipeline-a-step-by-step-guide-part-ii-138a8c395764?source=collection_archive---------25-----------------------#2021-11-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="732b" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph">从 Jupyter 开发可维护的项目</h2><div class=""/><div class=""><h2 id="cf91" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">将 Jupyter 笔记本转换成模块化可维护项目的详细指南。</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/38f298bd51514f3c043cbfee06c2b053.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Fvcu3S3WpdWn2v7ZvX72Bg.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">图片作者。</p></figure><blockquote class="le lf lg"><p id="4209" class="lh li lj lk b ll lm ka ln lo lp kd lq lr ls lt lu lv lw lx ly lz ma mb mc md ij bi translated"><strong class="lk ja"> <em class="iq">更新:我们发布了</em> </strong> <code class="fe me mf mg mh b"><a class="ae mi" href="https://github.com/ploomber/soorgeon" rel="noopener ugc nofollow" target="_blank"><strong class="lk ja"><em class="iq">soorgeon</em></strong></a></code> <strong class="lk ja"> <em class="iq">，一款自动重构遗留笔记本的工具！</em>T11】</strong></p></blockquote><p id="136f" class="pw-post-body-paragraph lh li iq lk b ll lm ka ln lo lp kd lq mj ls lt lu mk lw lx ly ml ma mb mc md ij bi translated">在本系列的第一部分<a class="ae mi" href="https://ploomber.io/blog/refactor-nb-i/" rel="noopener ugc nofollow" target="_blank">中，我们描述了如何从传统笔记本过渡到我们可以用<code class="fe me mf mg mh b">ploomber build</code>执行的单任务流水线。在第二部分，我们将打破单一的笔记本，将我们的工作模块化为更小的任务。</a></p><h1 id="4f4d" class="mm mn iq bd mo mp mq mr ms mt mu mv mw kf mx kg my ki mz kj na kl nb km nc nd bi translated">步骤 5:确定任务</h1><p id="5e48" class="pw-post-body-paragraph lh li iq lk b ll ne ka ln lo nf kd lq mj ng lt lu mk nh lx ly ml ni mb mc md ij bi translated">存在于单个文件中的项目很难调试，因为变量可能会意外交互。因此，我们想要一个有清晰边界的结构化项目，一个“任务”的输出成为下一个任务的输入；我们称之为<em class="lj">数据管道</em>。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nj"><img src="../Images/b6e4496a4e99484f85e386c7bc4bdcf7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QXOC0TDhsK2DNkNuMaNK9A.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">图片作者。</p></figure><p id="f8a2" class="pw-post-body-paragraph lh li iq lk b ll lm ka ln lo lp kd lq mj ls lt lu mk lw lx ly ml ma mb mc md ij bi translated">在这一步，我们检查代码以确定应该在哪里拆分笔记本。例如，假设您的笔记本看起来像这样:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="d159" class="pw-post-body-paragraph lh li iq lk b ll lm ka ln lo lp kd lq mj ls lt lu mk lw lx ly ml ma mb mc md ij bi translated">你的代码可能会比这个例子更加广泛和混乱，但是目标是在代码段之间定义<em class="lj">分割</em>。例如，在这个例子中，我们对数据做了三件事:加载、清理和绘图；因此，我们可以把它分成三个部分。我们通过添加 Markdown 标题来做到这一点，这样我们可以快速识别每个部分的开始和结束位置(要了解如何在 Jupyter 中插入 Markdown 单元格，<a class="ae mi" href="https://jupyter-notebook.readthedocs.io/en/stable/examples/Notebook/Working%20With%20Markdown%20Cells.html" rel="noopener ugc nofollow" target="_blank">单击此处</a>)。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="c31f" class="pw-post-body-paragraph lh li iq lk b ll lm ka ln lo lp kd lq mj ls lt lu mk lw lx ly ml ma mb mc md ij bi translated"><em class="lj">注意:</em> Markdown 有多种类型的标题；一个 H1 头球看起来像这样<code class="fe me mf mg mh b"># I'm an H1 heading</code>，而一个 H2 头球看起来像这样:<code class="fe me mf mg mh b">## I'm an H2 heading</code>。</p><p id="3bfa" class="pw-post-body-paragraph lh li iq lk b ll lm ka ln lo lp kd lq mj ls lt lu mk lw lx ly ml ma mb mc md ij bi translated">大多数笔记本都比这本书混乱得多，所以在定义节之前，您可能需要稍微重新组织一下代码单元。如果要加载多个数据集，请确保每个部分一次只处理一个数据集:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="7657" class="pw-post-body-paragraph lh li iq lk b ll lm ka ln lo lp kd lq mj ls lt lu mk lw lx ly ml ma mb mc md ij bi translated">定义好笔记本的分区后，请转到下一步。</p><h1 id="373c" class="mm mn iq bd mo mp mq mr ms mt mu mv mw kf mx kg my ki mz kj na kl nb km nc nd bi translated">第六步:打破整块石头！</h1><p id="cea6" class="pw-post-body-paragraph lh li iq lk b ll ne ka ln lo nf kd lq mj ng lt lu mk nh lx ly ml ni mb mc md ij bi translated">这一步是我们最终打破整体，并开始组装一个多级管道。通过在任务之间提供明确的界限，我们为每个任务建立了更精确的目的，并且可以快速测试我们的输出。</p><p id="faf0" class="pw-post-body-paragraph lh li iq lk b ll lm ka ln lo lp kd lq mj ls lt lu mk lw lx ly ml ma mb mc md ij bi translated">定义任务边界有些武断，但这里有一些经验法则:</p><ol class=""><li id="aaeb" class="nm nn iq lk b ll lm lo lp mj no mk np ml nq md nr ns nt nu bi translated">在单独的分支中转换每个数据集(例如，如果使用两个数据集，您的管道应该有两个分支)；当两个数据集需要连接时，合并分支。</li><li id="199c" class="nm nn iq lk b ll nv lo nw mj nx mk ny ml nz md nr ns nt nu bi translated">对于每个数据集:一个任务是下载数据，另一个任务是清理数据(如果在 ML 管道上工作，还有一个任务是生成要素)。</li><li id="da9f" class="nm nn iq lk b ll nv lo nw mj nx mk ny ml nz md nr ns nt nu bi translated">如果处理 ML 管道:一个任务用于连接所有特征和标签，一个用于训练模型，另一个用于评估。</li></ol><p id="c092" class="pw-post-body-paragraph lh li iq lk b ll lm ka ln lo lp kd lq mj ls lt lu mk lw lx ly ml ma mb mc md ij bi translated">例如，假设我们有两个数据集需要加载、清理和绘制，我们希望我们的管道看起来像这样:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nj"><img src="../Images/7f286c111429e8bd057cb2516cdb812c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9Ndb5CdQNHZKWKAJ4pCpzQ.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">图片作者。</p></figure><p id="d393" class="pw-post-body-paragraph lh li iq lk b ll lm ka ln lo lp kd lq mj ls lt lu mk lw lx ly ml ma mb mc md ij bi translated">所以现在是时候把我们的项目分成两个文件了。按照我们的例子，我们向后应用切割，我们制作的第一个切割在我们的笔记本的末尾:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="2f70" class="pw-post-body-paragraph lh li iq lk b ll lm ka ln lo lp kd lq mj ls lt lu mk lw lx ly ml ma mb mc md ij bi translated">我们将绘制数据的代码移到一个新的脚本中，并编辑我们的<code class="fe me mf mg mh b">pipeline.yaml</code>文件:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="9080" class="pw-post-body-paragraph lh li iq lk b ll lm ka ln lo lp kd lq mj ls lt lu mk lw lx ly ml ma mb mc md ij bi translated">编辑完<code class="fe me mf mg mh b">pipeline.yaml</code>文件后，执行以下命令来生成<code class="fe me mf mg mh b">plot.py</code>文件:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="5d31" class="pw-post-body-paragraph lh li iq lk b ll lm ka ln lo lp kd lq mj ls lt lu mk lw lx ly ml ma mb mc md ij bi translated">我们在这里做了一些改变。首先，我们修改第一个任务的第一个产品，因为它现在生成两个输出:笔记本和数据集 B 的干净版本。然后，我们添加了一个新任务，它执行<code class="fe me mf mg mh b">plot.py</code>(将绘制数据集 B 的代码复制到这里)并生成另一个笔记本。</p><p id="d178" class="pw-post-body-paragraph lh li iq lk b ll lm ka ln lo lp kd lq mj ls lt lu mk lw lx ly ml ma mb mc md ij bi translated">我们希望实现以下目标:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oa"><img src="../Images/231fd359be6b0bc8b2ffe339a49b474f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dn0Zc7tEilFw_UPdVqylRQ.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">图片作者。</p></figure><p id="0441" class="pw-post-body-paragraph lh li iq lk b ll lm ka ln lo lp kd lq mj ls lt lu mk lw lx ly ml ma mb mc md ij bi translated">如何实现这一点需要解释如何在 Ploomber 中构建管道。很简单，只需要做一些代码修改，把标绘代码移到<code class="fe me mf mg mh b">plot-b.py</code>；查看我们在<a class="ae mi" href="https://ploomber.readthedocs.io/en/latest/get-started/spec-api-python.html" rel="noopener ugc nofollow" target="_blank">文档中的完整示例。</a></p><p id="da6e" class="pw-post-body-paragraph lh li iq lk b ll lm ka ln lo lp kd lq mj ls lt lu mk lw lx ly ml ma mb mc md ij bi translated">一旦你学会了 Ploomber 的基础，重复同样的过程，直到你有一个包含许多小脚本的管道。确保使用<code class="fe me mf mg mh b">ploomber build</code>运行管道，并检查输出是否仍然匹配。</p><h1 id="eb52" class="mm mn iq bd mo mp mq mr ms mt mu mv mw kf mx kg my ki mz kj na kl nb km nc nd bi translated">步骤 7:添加集成测试</h1><p id="ab8c" class="pw-post-body-paragraph lh li iq lk b ll ne ka ln lo nf kd lq mj ng lt lu mk nh lx ly ml ni mb mc md ij bi translated">到目前为止，我们已经手动检查了每个管道任务的已执行笔记本输出，以确保在进行更改后结果仍然匹配。不幸的是，从长远来看这是不实际的，所以让我们自动化它。</p><p id="7762" class="pw-post-body-paragraph lh li iq lk b ll lm ka ln lo lp kd lq mj ls lt lu mk lw lx ly ml ma mb mc md ij bi translated">构建我们的管道允许我们嵌入验证每个输出完整性的集成测试。例如，让我们假设我们已经将我们的分析分解为两个步骤(如上一节中的图像所示)；我们可以在执行下一个任务之前测试每个任务的输出:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oa"><img src="../Images/84c71dc99570783cc36e9d39edde3e57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YRjc8ZdrA5DNs1NLL15j9g.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">图片作者。</p></figure><p id="d474" class="pw-post-body-paragraph lh li iq lk b ll lm ka ln lo lp kd lq mj ls lt lu mk lw lx ly ml ma mb mc md ij bi translated">为了测试我们的管道任务，我们可以在每个阶段定义一些期望的属性；例如，我们可以声明数据集 B 的干净版本必须具有以下属性:</p><ul class=""><li id="aeb8" class="nm nn iq lk b ll lm lo lp mj no mk np ml nq md ob ns nt nu bi translated">列<code class="fe me mf mg mh b">age</code>中没有 NAs</li><li id="bd68" class="nm nn iq lk b ll nv lo nw mj nx mk ny ml nz md ob ns nt nu bi translated">正数小于 100 的列<code class="fe me mf mg mh b">age</code></li><li id="bae7" class="nm nn iq lk b ll nv lo nw mj nx mk ny ml nz md ob ns nt nu bi translated">列<code class="fe me mf mg mh b">category</code>必须有值<code class="fe me mf mg mh b">a</code>、<code class="fe me mf mg mh b">b</code>或<code class="fe me mf mg mh b">c</code></li></ul><p id="1854" class="pw-post-body-paragraph lh li iq lk b ll lm ka ln lo lp kd lq mj ls lt lu mk lw lx ly ml ma mb mc md ij bi translated">我们可以将这样的数据期望转换成集成测试，以便在每次运行管道时验证它们。最简单的方法是在每个任务的末尾添加一些<code class="fe me mf mg mh b">assert</code>语句:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="679b" class="pw-post-body-paragraph lh li iq lk b ll lm ka ln lo lp kd lq mj ls lt lu mk lw lx ly ml ma mb mc md ij bi translated">或者，我们可以使用 Ploomber <code class="fe me mf mg mh b">on_finish</code>钩子在任务正确执行后运行任意函数。要获得完整的示例，请查看我们的<a class="ae mi" href="https://ploomber.readthedocs.io/en/latest/user-guide/testing.html" rel="noopener ugc nofollow" target="_blank">管道测试教程</a>。</p><p id="48f5" class="pw-post-body-paragraph lh li iq lk b ll lm ka ln lo lp kd lq mj ls lt lu mk lw lx ly ml ma mb mc md ij bi translated">测试数据管道很棘手；请查看我在 2020 年 PyData 全球大会上的演讲，我会详细介绍这一点。</p><h1 id="7645" class="mm mn iq bd mo mp mq mr ms mt mu mv mw kf mx kg my ki mz kj na kl nb km nc nd bi translated">步骤 8:在每个<code class="fe me mf mg mh b">git push</code>上运行您的管道</h1><p id="f3ff" class="pw-post-body-paragraph lh li iq lk b ll ne ka ln lo nf kd lq mj ng lt lu mk nh lx ly ml ni mb mc md ij bi translated">到目前为止，我们已经通过执行<code class="fe me mf mg mh b">ploomber build</code>在本地测试了我们的管道。然而，最好在每个<code class="fe me mf mg mh b">git push</code>上自动执行管道；启用自动化测试就是创建一个小脚本来安装依赖项并运行我们的管道:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="955d" class="pw-post-body-paragraph lh li iq lk b ll lm ka ln lo lp kd lq mj ls lt lu mk lw lx ly ml ma mb mc md ij bi translated">如何在每个<code class="fe me mf mg mh b">git push</code>上运行一些脚本取决于我们使用的 git 服务。例如，如果使用 GitHub，我们可以使用<a class="ae mi" href="https://docs.github.com/en/actions" rel="noopener ugc nofollow" target="_blank"> GitHub Actions </a>，所有托管 git 库的服务都提供类似的东西；查看 git 服务的文档以了解更多信息。</p><h1 id="4a97" class="mm mn iq bd mo mp mq mr ms mt mu mv mw kf mx kg my ki mz kj na kl nb km nc nd bi translated">结语:保持你的管道正常运行</h1><p id="bc28" class="pw-post-body-paragraph lh li iq lk b ll ne ka ln lo nf kd lq mj ng lt lu mk nh lx ly ml ni mb mc md ij bi translated">恭喜你！您现在有了一个健壮的、可维护的管道，它允许您更快、更有信心地引入变更。但是记住永远保持这种方式；如果不小心处理，很容易将管道退化为类似于我们已经开始的东西。因此，这里有一些应对你可能遇到的情况的技巧。</p><h2 id="81a8" class="oc mn iq bd mo od oe dn ms of og dp mw mj oh oi my mk oj ok na ml ol om nc iw bi translated">修改任务</h2><p id="cb05" class="pw-post-body-paragraph lh li iq lk b ll ne ka ln lo nf kd lq mj ng lt lu mk nh lx ly ml ni mb mc md ij bi translated">无论何时你必须修改一个任务，都要一小步一小步地去做，并且运行你的管道来确保在每一个小的修改之后一切都正常工作。</p><h2 id="e917" class="oc mn iq bd mo od oe dn ms of og dp mw mj oh oi my mk oj ok na ml ol om nc iw bi translated">添加新数据集</h2><p id="0a89" class="pw-post-body-paragraph lh li iq lk b ll ne ka ln lo nf kd lq mj ng lt lu mk nh lx ly ml ni mb mc md ij bi translated">如果需要向分析中添加新的数据集，请创建一个新的笔记本。然后，探索这些数据，直到您对其有了基本的了解，并决定是否将其纳入您的管道。</p><p id="0234" class="pw-post-body-paragraph lh li iq lk b ll lm ka ln lo lp kd lq mj ls lt lu mk lw lx ly ml ma mb mc md ij bi translated">如果您决定将数据集合并到管道中，通过将您的探索性代码作为新任务合并到管道中来添加一个新分支(记住将您的<code class="fe me mf mg mh b">.ipynb</code>转换为<code class="fe me mf mg mh b">.py</code>文件):</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nj"><img src="../Images/ab94632ce7de3d79a30d2ac0995ae12e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ffOBEEkuf0MX7dvKc7S70g.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">图片作者。</p></figure><p id="e7b4" class="pw-post-body-paragraph lh li iq lk b ll lm ka ln lo lp kd lq mj ls lt lu mk lw lx ly ml ma mb mc md ij bi translated">随着你对数据了解的越来越多，你可能会开始添加代码来清理它，如果你正在开发一个机器学习管道，你可能会开始创建功能；所以把逻辑分解成更小的部分；典型的结构如下:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nj"><img src="../Images/d3cb20e708699ee525253a539ea9089a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8Ke-2na7XRZfkUybwMOPag.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">图片作者。</p></figure><p id="d775" class="pw-post-body-paragraph lh li iq lk b ll lm ka ln lo lp kd lq mj ls lt lu mk lw lx ly ml ma mb mc md ij bi translated">记得添加集成测试。此外，确保加载 take 的任务可以使用一个<code class="fe me mf mg mh b">sample</code>参数来运行带有数据样本的代码，以便进行快速测试。</p><p id="8860" class="pw-post-body-paragraph lh li iq lk b ll lm ka ln lo lp kd lq mj ls lt lu mk lw lx ly ml ma mb mc md ij bi translated">添加新的数据集是项目中的一个里程碑，因此请确保记录下来。我强烈建议您创建一个<code class="fe me mf mg mh b">CHANGELOG.md</code>文件来记录项目中这些类型的重大变更:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nk nl l"/></div></figure><h2 id="7451" class="oc mn iq bd mo od oe dn ms of og dp mw mj oh oi my mk oj ok na ml ol om nc iw bi translated">删除数据集</h2><p id="fa33" class="pw-post-body-paragraph lh li iq lk b ll ne ka ln lo nf kd lq mj ng lt lu mk nh lx ly ml ni mb mc md ij bi translated">如果不再需要某个数据集，请删除处理该数据集的整个分支。保留死代码没有任何意义。确保你在你的<code class="fe me mf mg mh b">CHANGELOG.md</code>档案中记录了这一点。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nk nl l"/></div></figure><h2 id="e5f2" class="oc mn iq bd mo od oe dn ms of og dp mw mj oh oi my mk oj ok na ml ol om nc iw bi translated">代码质量</h2><p id="5d11" class="pw-post-body-paragraph lh li iq lk b ll ne ka ln lo nf kd lq mj ng lt lu mk nh lx ly ml ni mb mc md ij bi translated">为了保持项目的可维护性，保持代码的可读性是必不可少的。像<a class="ae mi" href="https://github.com/PyCQA/flake8" rel="noopener ugc nofollow" target="_blank"> flake8 </a>和<a class="ae mi" href="https://github.com/psf/black" rel="noopener ugc nofollow" target="_blank"> black </a>这样的包是对你的代码进行 lint 和自动格式化的好选择。要了解更多关于林挺的知识并获得保持代码整洁的技巧，请查看我们的指南<a class="ae mi" href="https://ploomber.io/posts/clean-nbs/" rel="noopener ugc nofollow" target="_blank">写整洁的笔记本</a>。</p><h1 id="b503" class="mm mn iq bd mo mp mq mr ms mt mu mv mw kf mx kg my ki mz kj na kl nb km nc nd bi translated">最后的想法</h1><p id="4800" class="pw-post-body-paragraph lh li iq lk b ll ne ka ln lo nf kd lq mj ng lt lu mk nh lx ly ml ni mb mc md ij bi translated">转换传统的基于笔记本电脑的管道需要花费很多精力，但这是值得的。根据我的经验，许多数据项目失败是因为它们建立在薄弱的基础上，阻碍了它们取得稳定的进展。通过构建和测试您的管道，您已经走在了游戏的前面，您将能够自信地对您的工作进行更改，并确保您可以随时重现您的结果。</p><p id="bc84" class="pw-post-body-paragraph lh li iq lk b ll lm ka ln lo lp kd lq mj ls lt lu mk lw lx ly ml ma mb mc md ij bi translated">发现错误？<a class="ae mi" href="https://github.com/ploomber/posts/issues/new?title=Issue%20in%20post%3A%20%22Refactoring%20a%20Jupyter%20notebook%20into%20a%20maintainable%20pipeline%3A%20A%20step-by-step%20guide%20%28Part%20II%29%22" rel="noopener ugc nofollow" target="_blank">点击这里让我们知道</a>。</p></div><div class="ab cl on oo hu op" role="separator"><span class="oq bw bk or os ot"/><span class="oq bw bk or os ot"/><span class="oq bw bk or os"/></div><div class="ij ik il im in"><p id="8f77" class="pw-post-body-paragraph lh li iq lk b ll lm ka ln lo lp kd lq mj ls lt lu mk lw lx ly ml ma mb mc md ij bi translated"><em class="lj">最初发布于</em><a class="ae mi" href="https://ploomber.io/posts/refactor-nb-ii" rel="noopener ugc nofollow" target="_blank"><em class="lj">ploomber . io</em></a></p></div></div>    
</body>
</html>