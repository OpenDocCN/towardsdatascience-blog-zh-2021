<html>
<head>
<title>5 Development Rules to Improve Your Data Science Projects</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">提高数据科学项目的5个开发规则</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/5-development-rules-to-improve-your-data-science-projects-f3392b8243cd?source=collection_archive---------14-----------------------#2021-09-20">https://towardsdatascience.com/5-development-rules-to-improve-your-data-science-projects-f3392b8243cd?source=collection_archive---------14-----------------------#2021-09-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/794383eae16ad62145843f1891a65854.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*IQaaPVT4CoSi7uvz"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">卡尔·帕夫洛维奇在<a class="ae jg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>的照片</p></figure><div class=""/><div class=""><h2 id="eaef" class="pw-subtitle-paragraph kg ji jj bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dk translated">指导您的数据科学工作流程的简单技巧</h2></div><p id="436c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在从事数据科学项目时，我喜欢为如何为项目编写代码制定一些基本规则。有了一些简单的原则，我总是确信我将要写的代码能够经受住最低的质量门槛。</p><p id="c466" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk"> <em class="lu">在这篇文章中，我将向你展示5个简单的开发规则来指导你的数据科学工作流程。</em> </strong></p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="b5b4" class="mc md jj bd me mf mg mh mi mj mk ml mm kp mn kq mo ks mp kt mq kv mr kw ms mt bi translated">规则</h1><p id="e4f9" class="pw-post-body-paragraph ky kz jj la b lb mu kk ld le mv kn lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">简而言之，规则是:</p><ol class=""><li id="215f" class="mz na jj la b lb lc le lf lh nb ll nc lp nd lt ne nf ng nh bi translated"><strong class="la jk">将脚本抽象成函数和类</strong></li><li id="62e8" class="mz na jj la b lb ni le nj lh nk ll nl lp nm lt ne nf ng nh bi translated"><strong class="la jk">确保函数是原子的</strong></li><li id="78b6" class="mz na jj la b lb ni le nj lh nk ll nl lp nm lt ne nf ng nh bi translated"><strong class="la jk">编写单元测试</strong></li><li id="95dd" class="mz na jj la b lb ni le nj lh nk ll nl lp nm lt ne nf ng nh bi translated"><strong class="la jk">结合Jupyter笔记本使用您最喜欢的文本编辑器</strong></li><li id="558f" class="mz na jj la b lb ni le nj lh nk ll nl lp nm lt ne nf ng nh bi translated"><strong class="la jk">进行小规模频繁提交</strong></li></ol><p id="27f9" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，让我们一个一个地看一遍。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="2806" class="nn md jj bd me no np dn mi nq nr dp mm lh ns nt mo ll nu nv mq lp nw nx ms ny bi translated">1.将脚本抽象成函数和类</h2><p id="8062" class="pw-post-body-paragraph ky kz jj la b lb mu kk ld le mv kn lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">假设你正在用Jupyter笔记本计算如何最好地可视化一些数据。一旦代码工作了，并且您认为它不需要更多的调试，就该对它进行抽象了！让我们看一个例子，</p><pre class="nz oa ob oc gt od oe of og aw oh bi"><span id="4dcf" class="nn md jj oe b gy oi oj l ok ol">import matplotlib.pyplot as plt<br/>import seaborn as sns<br/>sns.set()<br/>import numpy as np<br/>import pandas as pd<br/><br/><br/>synthetic_data = np.random.normal(0,1,1000)<br/><br/>plt.plot(synthetic_data, color="green")<br/>plt.title("Plotting Synthetic Data")<br/>plt.xlabel("x axis")<br/>plt.ylabel("y axis")<br/>plt.show()</span></pre><figure class="nz oa ob oc gt iv gh gi paragraph-image"><div class="ab gu cl om"><img src="../Images/57663d0ec223fa7c16effb8e110d488b.png" data-original-src="https://miro.medium.com/v2/format:webp/1*X7LilJ-9i_aU8Zv0cBzIpg.png"/></div></figure><p id="09c8" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这里，我们绘制了一些合成数据。假设我们对我们的绘图满意，我们现在要做的是将它抽象成一个函数，并将其添加到我们项目的代码库中:</p><pre class="nz oa ob oc gt od oe of og aw oh bi"><span id="2be0" class="nn md jj oe b gy oi oj l ok ol">def plotSyntheticDataTimeSeries(data):<br/>    plt.plot(data, color="green")<br/>    plt.title("Plotting Synthetic Data")<br/>    plt.xlabel("x axis")<br/>    plt.ylabel("y axis")<br/>    plt.show()</span></pre><p id="c94a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">太好了！现在，我们可以将它放在我们的代码库中，并在每次需要使用这个绘图函数时调用它，如下所示:</p><pre class="nz oa ob oc gt od oe of og aw oh bi"><span id="7aef" class="nn md jj oe b gy oi oj l ok ol">plotSyntheticDataTimeSeries(synthetic_data)</span></pre><figure class="nz oa ob oc gt iv gh gi paragraph-image"><div class="ab gu cl om"><img src="../Images/57663d0ec223fa7c16effb8e110d488b.png" data-original-src="https://miro.medium.com/v2/format:webp/1*X7LilJ-9i_aU8Zv0cBzIpg.png"/></div></figure><p id="c7be" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">简单，也是很好的练习。</p><p id="6ecb" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果出于某种原因，我们希望加载数据并对其执行一些简单的转换，我们可能希望有一个类来为我们处理这些。</p><p id="0696" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们看一个使用<a class="ae jg" href="https://www.kaggle.com/brijbhushannanda1979/bigmart-sales-data" rel="noopener ugc nofollow" target="_blank">大商场销售数据集</a>的简单例子:</p><pre class="nz oa ob oc gt od oe of og aw oh bi"><span id="c00b" class="nn md jj oe b gy oi oj l ok ol">import matplotlib.pyplot as plt<br/>import seaborn as sns<br/>sns.set()<br/>import numpy as np<br/>import pandas as pd<br/><br/><br/>class DataPrep:<br/>    def __init__(self,data_path,cols_to_remove=["Item_Fat_Content", "Item_Type", "Outlet_Size"]):<br/>        self.data = pd.read_csv(data_path)<br/>        self.cols_to_remove = cols_to_remove<br/>        self.removeNans()<br/>        self.removeCols()<br/>        <br/>    def removeNans(self):<br/>        self.data = self.data.dropna()<br/>    <br/>    def removeCols(self):<br/>        self.data = self.data.drop(self.cols_to_remove, axis=1)<br/>        self.data = self.data.reset_index(drop=True)<br/>    <br/>    <br/>        <br/>    <br/>data_path = "./BigMartSales.csv"<br/>dp = DataPrep(data_path)<br/>dp.data</span></pre><figure class="nz oa ob oc gt iv gh gi paragraph-image"><div class="ab gu cl om"><img src="../Images/22bbd0e23b9f8eea25d4a3f6347263ae.png" data-original-src="https://miro.medium.com/v2/format:webp/1*3P1XVHOKS2_mV11Hft8AsQ.png"/></div></figure><p id="4fd4" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在我们有了它，DataPrep类可以被系统地用来执行我们想要的转换。这显然是一个玩具示例，并没有涵盖清理和预处理数据集的整个过程。</p><p id="876e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这里，我们只是举例说明如何将代码抽象成函数和类，这些函数和类以后可以发展并集成到我们的生产流水线中。 </p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="7096" class="nn md jj bd me no np dn mi nq nr dp mm lh ns nt mo ll nu nv mq lp nw nx ms ny bi translated">2.<strong class="ak">确保函数是原子的</strong></h2><p id="8053" class="pw-post-body-paragraph ky kz jj la b lb mu kk ld le mv kn lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">结合将你的管道抽象成函数和类的想法，我们也应该总是寻找原子性，也就是说，每个函数应该做一件事。这条规则源于面向对象编程的良好实践，是避免不必要的复杂性的良好指南，这种复杂性可能会在将来耗费大量时间。</p><p id="3bda" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，如果我们有一个情况，我们加载数据集，转换它，然后绘制它，我们应该为这个过程的每个原子写一个函数。</p><p id="a4eb" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们将一个绘图函数添加到上一个示例的代码库中，看看它会是什么样子:</p><pre class="nz oa ob oc gt od oe of og aw oh bi"><span id="a700" class="nn md jj oe b gy oi oj l ok ol">import matplotlib.pyplot as plt<br/>import seaborn as sns<br/>sns.set()<br/>import numpy as np<br/>import pandas as pd<br/><br/><br/><br/>def badExampleofNonAtomicFunction():<br/>    data_path = "./BigMartSales.csv"<br/>    cols_to_remove = ["Item_Fat_Content", "Item_Type", "Outlet_Size"]<br/>    data = pd.read_csv(data_path)<br/>    data = data.dropna()<br/>    data = data.drop(cols_to_remove, axis=1)<br/>    data = data.reset_index(drop=True)<br/>    data[data["Outlet_Identifier"]=="OUT049"]["Item_Outlet_Sales"].plot()<br/>    plt.title("Sales for Outlet: OUT049")<br/>    plt.show()<br/>    <br/>badExampleofNonAtomicFunction()</span></pre><figure class="nz oa ob oc gt iv gh gi paragraph-image"><div class="ab gu cl om"><img src="../Images/1534105e8245cd67994d9bfa6d189f13.png" data-original-src="https://miro.medium.com/v2/format:webp/1*GgH2MGgNxWY5_Wf7NuAAiA.png"/></div></figure><p id="9619" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">尽管如此，这里我们并没有构建一个合理的跟踪记录来记录我们对数据集应用了什么，所以调试这个将是一场噩梦。</p><p id="8961" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在让我们看一个例子，看看如何使这段代码更容易调试。我们可以从使用之前构建的类开始，在该类之外编写一个简单的绘图函数:</p><pre class="nz oa ob oc gt od oe of og aw oh bi"><span id="63e0" class="nn md jj oe b gy oi oj l ok ol">import matplotlib.pyplot as plt<br/>import seaborn as sns<br/>sns.set()<br/>import numpy as np<br/>import pandas as pd<br/><br/><br/>class DataPrep:<br/>    def __init__(self,data_path,cols_to_remove=["Item_Fat_Content", "Item_Type", "Outlet_Size"]):<br/>        self.data = pd.read_csv(data_path)<br/>        self.cols_to_remove = cols_to_remove<br/>        self.removeNans()<br/>        self.removeCols()<br/>        <br/>    def removeNans(self):<br/>        self.data = self.data.dropna()<br/>    <br/>    def removeCols(self):<br/>        self.data = self.data.drop(self.cols_to_remove, axis=1)<br/>        self.data = self.data.reset_index(drop=True)<br/>    <br/><br/>def plotOutletSales(data, outlet_id):<br/>    data[data["Outlet_Identifier"]==outlet_id]["Item_Outlet_Sales"].plot()<br/>    plt.title(f"Sales for Outlet: {outlet_id}")<br/>    plt.show()<br/>        <br/>    <br/>data_path = "./BigMartSales.csv"<br/>dp = DataPrep(data_path)<br/>plotOutletSales(dp.data, outlet_id="OUT049")</span></pre><figure class="nz oa ob oc gt iv gh gi paragraph-image"><div class="ab gu cl om"><img src="../Images/1534105e8245cd67994d9bfa6d189f13.png" data-original-src="https://miro.medium.com/v2/format:webp/1*GgH2MGgNxWY5_Wf7NuAAiA.png"/></div></figure><p id="7512" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，我们有了稍微好一点的东西，因为我们让每一步都成为一个构建模块，为我们的管道添加单独的功能。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="a7cc" class="nn md jj bd me no np dn mi nq nr dp mm lh ns nt mo ll nu nv mq lp nw nx ms ny bi translated">3.编写单元测试</h2><p id="93c2" class="pw-post-body-paragraph ky kz jj la b lb mu kk ld le mv kn lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">编写单元测试肯定是一个有点烦人的步骤，但对于生产代码来说，确保我们的代码对于真实环境足够健壮，以及在部署管道时帮助防止不必要的错误和问题是非常重要的。</p><p id="29a5" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们编写一些代码来测试我们为<code class="fe on oo op oe b">DataPrep</code>类编写的各个方法:</p><pre class="nz oa ob oc gt od oe of og aw oh bi"><span id="8020" class="nn md jj oe b gy oi oj l ok ol">import unittest<br/>import pandas as pd<br/>import numpy as np<br/><br/><br/>def removeNans(data):<br/>    data = data.dropna()<br/>    return data<br/>    <br/>def removeCols():<br/>    data = data.drop(cols_to_remove, axis=1)<br/>    data = data.reset_index(drop=True)<br/><br/><br/>class TestDataPrep:<br/>    def __init__(self):<br/>        data_path = "./BigMartSales.csv"<br/>        self.data = pd.read_csv(data_path)<br/>        super().__init__(unittest.TestCase)<br/>    <br/>    def test_removeNans(self):<br/>        data = removeNans(self.data)<br/>        result = []<br/>        <br/>        for col in data.columns:<br/>            result.append(data[col].isnull().sum())<br/>        <br/>        result = np.sum(result)<br/>        print(result)<br/>        self.assertEqual(result,0)<br/>    <br/>    def test_removeCols():<br/>        data = removeCols(self.data)<br/>        cols_to_check = ["Item_Fat_Content", "Item_Type", "Outlet_Size"]<br/>        self.assertEqual(any(element in cols_to_check <br/>                        for element in data.columns)==False)<br/><br/><br/>data_path = "./BigMartSales.csv"<br/>data = pd.read_csv(data_path)<br/><br/>if __name__ == "__main__":<br/>    unittest.main()</span><span id="0893" class="nn md jj oe b gy oq oj l ok ol"># Output<br/>Ran 0 tests in 0.000s</span><span id="f790" class="nn md jj oe b gy oq oj l ok ol">OK</span></pre><p id="cb89" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">在这个例子中，我们通过编写一个名为</strong> <code class="fe on oo op oe b"><strong class="la jk">TestDataPrep</strong></code> <strong class="la jk">的类来测试这两个函数，这个类对它们的预期结果进行检查。</strong></p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="e13e" class="nn md jj bd me no np dn mi nq nr dp mm lh ns nt mo ll nu nv mq lp nw nx ms ny bi translated">4.将您最喜爱的文本编辑器与Jupyter笔记本结合使用</h2><p id="6334" class="pw-post-body-paragraph ky kz jj la b lb mu kk ld le mv kn lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">我是杰瑞米·霍华德的超级粉丝，我强烈推荐他的视频:</p><figure class="nz oa ob oc gt iv"><div class="bz fp l di"><div class="or os l"/></div></figure><p id="b80f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">浅谈使用Jupyter笔记本进行软件开发。</p><p id="1d04" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我们将我们最喜欢的文本编辑器与jupyter笔记本结合使用，通过以下简单的笔记本命令让它们自动同步，那么数据科学项目的开发可以得到极大的改进:</p><pre class="nz oa ob oc gt od oe of og aw oh bi"><span id="6141" class="nn md jj oe b gy oi oj l ok ol">%load_ext autoreload<br/>%autoloread 2</span></pre><p id="d484" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，每次我们在我们选择的文本编辑器上编辑内容时，我们都会在jupyter笔记本中自动更新该函数或类。</p><p id="db32" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">通过这样做，人们可以利用jupyter笔记本令人惊叹的交互功能，以及我们最喜欢的文本编辑器 (我使用Visual Studio代码，但这只是一种偏好)的强大文本编辑功能。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="d0d3" class="nn md jj bd me no np dn mi nq nr dp mm lh ns nt mo ll nu nv mq lp nw nx ms ny bi translated">5.小而频繁地提交</h2><p id="8908" class="pw-post-body-paragraph ky kz jj la b lb mu kk ld le mv kn lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">就像一般的功能和开发一样，我们的目标是构建一个易于调试的管道。</p><p id="4f69" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为此，还应该使用小而频繁的提交，而不是大的提交，因为大的提交会使得在出错时更难返回并进行调查。</p><p id="352d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我的建议是为提交设置一个规则，一旦达到这个阈值，我们就提交并继续开发。T13】</p><p id="a6b0" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了有助于此，我们可以提前计划我们的项目，并预见我们需要执行来完成它的步骤，试图找到进度的清晰定义，当达到该定义时，将触发提交。</p><p id="b95e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">通过这样做，我们得到了一种在数据科学项目中计算和正确跟踪进度的方法。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="fe5c" class="mc md jj bd me mf mg mh mi mj mk ml mm kp mn kq mo ks mp kt mq kv mr kw ms mt bi translated">良好做法的重要性</h1><p id="eede" class="pw-post-body-paragraph ky kz jj la b lb mu kk ld le mv kn lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">所有从事严肃的数据科学项目的人都需要一种随着时间推移而改进的方法。</p><p id="1214" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">根据项目的类型和个人的目标，可以添加或更改许多关于个人良好实践的流程，但如果我想留给您一件事，那就是，<strong class="la jk"> <em class="lu">定义您的一套良好实践，遵循它，并随着时间的推移改进它！</em>T3】</strong></p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="b992" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您对数据科学感兴趣，并且正在寻找一个起点，请查看udemy课程:</p><ul class=""><li id="2502" class="mz na jj la b lb lc le lf lh nb ll nc lp nd lt ot nf ng nh bi translated"><a class="ae jg" href="http://seekoapp.io/614807cde82c850008014aec" rel="noopener ugc nofollow" target="_blank">数据科学课程2021:完整的数据科学训练营</a></li></ul><blockquote class="ou ov ow"><p id="a380" class="ky kz lu la b lb lc kk ld le lf kn lg ox li lj lk oy lm ln lo oz lq lr ls lt im bi translated"><em class="jj">这是一个附属链接，如果你使用这个课程我会得到一点佣金，干杯！:)</em></p></blockquote></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="76f9" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你喜欢这篇文章，在<a class="ae jg" href="https://lucas-soares.medium.com/" rel="noopener">媒体</a>、<a class="ae jg" href="https://lucas-soares.medium.com/subscribe" rel="noopener">上关注我，订阅我的简讯</a>，在<a class="ae jg" href="https://twitter.com/LucasEnkrateia" rel="noopener ugc nofollow" target="_blank">推特</a>、<a class="ae jg" href="https://www.linkedin.com/in/lucas-soares-969044167/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>、<a class="ae jg" href="https://www.instagram.com/theaugmentedself/" rel="noopener ugc nofollow" target="_blank"> Instagram </a>和<a class="ae jg" href="https://lucas-soares.medium.com/membership" rel="noopener">加入媒体</a>与我联系！谢谢，下次再见！:)</p></div></div>    
</body>
</html>