<html>
<head>
<title>How to Improve Deep Learning Forecasts for Time Series — Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何改进时间序列的深度学习预测—第 2 部分</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-improve-deep-learning-forecasts-for-time-series-part-2-c11efc8dfee2?source=collection_archive---------24-----------------------#2021-10-26">https://towardsdatascience.com/how-to-improve-deep-learning-forecasts-for-time-series-part-2-c11efc8dfee2?source=collection_archive---------24-----------------------#2021-10-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="0f71" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">时序数据聚类背后的代码。</h2></div><p id="55b4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<a class="ae lb" rel="noopener" target="_blank" href="/how-to-improve-deep-learning-forecasts-for-time-series-1799e3975d7c">之前的文章</a>中，我们解释了时间序列数据的聚类是如何工作的。在本帖中，我们将深入探究代码本身。</p><p id="51e4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所有的东西都会用 python 写，但是大多数库都有 R 版本。我们将努力保持相对较高的水平，但如果你想了解更多，代码会有一些有用的资源。</p><p id="8773" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">事不宜迟，我们开始吧。</p><h1 id="b092" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">0 —数据创建</h1><p id="ec3b" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">为了有助于解释，让我们利用一个理论上的例子:<strong class="kh ir">我们试图通过使用来自世界各地本地市场的信息来预测黄金价格。</strong></p><p id="3af1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，我们开发一个 1000 x 10 的数据帧。每行对应一个独特的时间点，在我们的例子中是一天，每列对应一个不同的黄金市场。我们数据框中的所有值都是价格。</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="cdb8" class="mi ld iq me b gy mj mk l ml mm"># create data<br/>rng = pd.date_range('2000-01-01', freq='d', periods=n_rows)<br/>df = pd.DataFrame(np.random.rand(n_rows, n_cols), index=rng)</span></pre><p id="1ced" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面的代码极大地简化了我们的例子。一个概念性的问题是，价格总是取 0 到 1 之间的值，然而代码的教训仍然适用。</p><p id="7fcd" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">创建了一个合成数据框，让我们把它变脏。</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="b702" class="mi ld iq me b gy mj mk l ml mm"># "unclean" data<br/>df = df.apply(lambda x: make_outliers_on_col(x), axis='index')<br/>df = df.apply(lambda x: make_nan_on_col(x), axis='index')</span></pre><p id="cd02" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面的函数在我们的数据框中随机输入了 10 个异常值和 10 个空值。我们生成的数据框看起来像这样…</p><figure class="lz ma mb mc gt mo gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi mn"><img src="../Images/6d88f1378c036f4d9627d4121b5ae249.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-QUomosmFvm9iJj6XkTIoA.png"/></div></div><p class="mv mw gj gh gi mx my bd b be z dk translated">图 1:合成数据会丢失值和异常值。作者图片</p></figure><h2 id="b058" class="mi ld iq bd le mz na dn li nb nc dp lm ko nd ne lo ks nf ng lq kw nh ni ls nj bi translated">1 —数据清理</h2><p id="a575" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">有两个主要的数据清理步骤:缺失数据插补和异常值剔除。幸运的是，熊猫有一些简单的内置方法可以帮助我们。</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="b5ea" class="mi ld iq me b gy mj mk l ml mm"># interpolate missing values<br/>df = df.interpolate(method='spline', order=1, limit=10, limit_direction='both')</span><span id="4822" class="mi ld iq me b gy nk mk l ml mm"># interpolate outliers<br/>df = df.apply(lambda x: nullify_outliers(x), axis='index')<br/>df = df.interpolate(method='spline', order=1, limit=10, limit_direction='both')</span></pre><p id="7815" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们的策略很简单。我们首先使用样条插值法估算所有缺失的数据。然后，我们用空值替换所有异常值，并再次使用样条插值。</p><p id="6443" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">论文提出了多种缺失值插补方法，其中一些包括<a class="ae lb" href="https://en.wikipedia.org/wiki/Linear_interpolation" rel="noopener ugc nofollow" target="_blank">插值</a>(如上所示)<a class="ae lb" href="https://arxiv.org/abs/1804.11087" rel="noopener ugc nofollow" target="_blank">奇异值分解(SVD)插补</a>和<a class="ae lb" href="https://machinelearningmastery.com/knn-imputation-for-missing-values-in-machine-learning/" rel="noopener ugc nofollow" target="_blank"> K 近邻(KNN)插补</a>。</p><p id="f8d9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">如果你在乎速度，SVD 或者插值是你最好的选择。KNN 可能会提供更好的结果，但它的计算量更大。</strong></p><p id="f4ff" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这一步结束时，我们将得到如图 2 所示的数据框:</p><figure class="lz ma mb mc gt mo gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi nl"><img src="../Images/5ec0e3a77046a26004cbcff4bb7d5f55.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DhxdmGwqsZPa70U8ZLaQ7Q.png"/></div></div><p class="mv mw gj gh gi mx my bd b be z dk translated">图 2:合成清理数据将缺失值和离群值进行估算。作者图片</p></figure><h2 id="e152" class="mi ld iq bd le mz na dn li nb nc dp lm ko nd ne lo ks nf ng lq kw nh ni ls nj bi translated">2 —聚类</h2><p id="b160" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">有了清晰的数据集，我们现在将寻找具有相似特征的黄金市场。我们的假设是，相似的市场将更容易被模型拟合，从而导致更准确的预测。</p><p id="9a90" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">论文中引用的最有效的分类类型包括利用每个时间序列的特征。我们会看两种类型:<strong class="kh ir">时间序列和信号处理特征</strong>。</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="6116" class="mi ld iq me b gy mj mk l ml mm"># TS-specific features<br/>autocorrelation = df.apply(lambda x: acf(x, nlags=3), axis='index')<br/>partial_autocorrelation = df.apply(lambda x: pacf(x, nlags=3), axis='index')</span><span id="52a6" class="mi ld iq me b gy nk mk l ml mm"># Signal-processing-specific features<br/>fast_fourier_transform = df.apply(lambda x: np.fft.fft(x), axis='index')<br/>variance = df.apply(lambda x: np.var(x), axis='index')</span></pre><p id="e75a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从这里，我们可以对每对特征集执行 k-means 聚类。为了简单起见，我们只限于两个特性，但是本文列举了两个组的四个潜在特性。</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="d7ce" class="mi ld iq me b gy mj mk l ml mm">import numpy as np<br/>from scipy.cluster.vq import kmeans2</span><span id="3230" class="mi ld iq me b gy nk mk l ml mm"># setup ts and signal features for clustering<br/>features = [np.array([autocorrelation, partial_autocorrelation]),<br/>            np.array([fast_fourier_transform, variance])]</span><span id="37aa" class="mi ld iq me b gy nk mk l ml mm">for f in features:<br/>    # cluster<br/>    out = kmeans2(f, 2)<br/>    cluster_centers, labels = out</span><span id="90b5" class="mi ld iq me b gy nk mk l ml mm">    # ...</span></pre><p id="fe23" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面的代码将我们的 10 个黄金市场分成两个不同的组，如图 3 所示。</p><figure class="lz ma mb mc gt mo gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi nm"><img src="../Images/ff07c913b00ce0270cd822752aea5952.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H82WHHmYR4o14pC4x2s0sQ.png"/></div></div><p class="mv mw gj gh gi mx my bd b be z dk translated">图 3:我们的时间序列数据的聚类。左图使用时间序列特征，右图使用信号处理特征。图片作者。</p></figure><p id="5433" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">既然我们已经将数据分组到“相似的”时间序列中，我们就可以为每个组建模了。</p><h2 id="e7c6" class="mi ld iq bd le mz na dn li nb nc dp lm ko nd ne lo ks nf ng lq kw nh ni ls nj bi translated">3 —预测模型</h2><p id="4127" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">该论文认为双向 LSTM 具有最好的精确度。尽管名字很吓人，双向 LSTM 只是两个 LSTM。第一种是用常规输入进行前向后向训练。第二种是用反向输入向量从后向前训练的。</p><p id="bdde" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">通过在一个时期内创建两个学习结构，模型通常会更快地收敛，并更完整地学习数据中的结构。</strong></p><p id="7b82" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，为了简单起见，我们将使用基本的 LSTM，但是这些概念可以很容易地应用于更复杂的模型结构。</p><p id="ad5e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这样做之前，重要的是要注意我们在每个聚类中对时间序列值进行了平均。有些模型，如<a class="ae lb" rel="noopener" target="_blank" href="/deep-learning-for-time-series-data-ed410da30798"> DeepAR </a>，适合多个时间序列，并输出单一预测。然而，普通 LSTMs 需要单变量数据。</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="5dab" class="mi ld iq me b gy mj mk l ml mm">from keras.models import Sequential<br/>from keras.layers import Dense<br/>from keras.layers import LSTM</span><span id="18fe" class="mi ld iq me b gy nk mk l ml mm"># fit basic LSTM<br/>model = Sequential()<br/>model.add(LSTM(4, input_shape=(1, look_back)))<br/>model.add(Dense(1))<br/>model.compile(loss='mean_squared_error', optimizer='adam')<br/>model.fit(trainX, trainY, epochs=n_epoch, batch_size=1, verbose=2)</span></pre><p id="f059" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面的代码在所有 4 个数据集上迭代运行，它们的精度如图 4 所示。</p><figure class="lz ma mb mc gt mo gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi nn"><img src="../Images/e038182eb112ac815ed0ae6e586a5fd1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gi3YdQhFnzkiTRsye57qBA.png"/></div></div><p class="mv mw gj gh gi mx my bd b be z dk translated">图 4:我们每个集群的时间序列预测。蓝色是原始数据，橙色是训练 preds，绿色是我们的预测。图片作者。</p></figure><p id="b85d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">仅通过视觉判断，我们的预测似乎没有太大差异，所以让我们看看每个模型的均方根误差(RMSE)。</p><figure class="lz ma mb mc gt mo gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi no"><img src="../Images/3ab459f51764f3011960142c1b217dc1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KDGKK2DRZG3Levgxl4zUrA.png"/></div></div><p class="mv mw gj gh gi mx my bd b be z dk translated">图 5:我们四个模型的 RMSE。图片作者。</p></figure><p id="48a8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">图 5 为我们的评估增加了更多的粒度。我们可以看到，TS 功能在群集 1 上的表现优于信号功能，但在群集 2 上表现较差。总的来说，每组的聚类 1 和聚类 2 之间的平均 RMSE 是相似的。</p><p id="f917" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在你可能想知道为什么不同组的表现如此相似。如果你还记得，我们的数据生成机制对所有时间序列都是一样的。</p><p id="7158" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">聚类的目的是提取时间序列模型中的系统差异。然后我们可以为每一个开发一个专门的模型。</strong></p><p id="5f98" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果数据具有相同的底层数据生成机制，聚类将无助于预测性能。</p><h2 id="3eb8" class="mi ld iq bd le mz na dn li nb nc dp lm ko nd ne lo ks nf ng lq kw nh ni ls nj bi translated">4 —后续步骤</h2><p id="e153" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">以上演练的完整代码可以在<a class="ae lb" href="https://github.com/mberk06/DS_academic_papers/blob/master/22_time_series_cleaning_and_clustering.py" rel="noopener ugc nofollow" target="_blank">这里</a>看到。然而，对于具有真实世界数据的建模项目，建议进行更多的尝试。</p><p id="390b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，利用主题知识来了解时间序列应该如何分组也是非常有益的。黄金数据的一个例子是在相似的地理位置对时间序列进行聚类。如果你没有主题知识，这里有更多的想法:</p><ul class=""><li id="4470" class="np nq iq kh b ki kj kl km ko nr ks ns kw nt la nu nv nw nx bi translated">聚集更多功能</li><li id="25e6" class="np nq iq kh b ki ny kl nz ko oa ks ob kw oc la nu nv nw nx bi translated">同时在 TS 和基于信号的功能上集群</li><li id="7ae4" class="np nq iq kh b ki ny kl nz ko oa ks ob kw oc la nu nv nw nx bi translated">使用更复杂的深度学习结构</li><li id="8c42" class="np nq iq kh b ki ny kl nz ko oa ks ob kw oc la nu nv nw nx bi translated">介绍静态特性(<a class="ae lb" href="https://arxiv.org/pdf/2001.09547.pdf" rel="noopener ugc nofollow" target="_blank">文章</a>讨论了这方面的架构)</li></ul></div><div class="ab cl od oe hu of" role="separator"><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi"/></div><div class="ij ik il im in"><p id="d4e7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="ok">感谢阅读！我会再写 30 篇文章，把学术研究带到 DS 行业。查看我的评论，链接到这篇文章的主要来源和一些有用的资源。</em></p></div></div>    
</body>
</html>