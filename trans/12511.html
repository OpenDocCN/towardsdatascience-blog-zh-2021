<html>
<head>
<title>Forecasting the Future Power Consumption of Germany using LSTM(RNN) and DNN</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">利用 LSTM(RNN)和 DNN 预测德国未来的电力消费</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/forecasting-the-future-power-consumption-of-germany-using-lstm-rnn-and-dnn-d8e05e7fdc0a?source=collection_archive---------2-----------------------#2021-12-22">https://towardsdatascience.com/forecasting-the-future-power-consumption-of-germany-using-lstm-rnn-and-dnn-d8e05e7fdc0a?source=collection_archive---------2-----------------------#2021-12-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2e35" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">利用 LSTM(RNN)和 DNN 对过去 5 年的电力消耗进行探索性数据分析，并预测未来的电力消耗</h2></div><p id="050d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">人类生活在时间轴上，并据此设计自己的日常生活。他们通常在晚上睡觉，其他活动通常在特定的时间进行(例如早餐——在早上)。当我们考虑语言时，众所周知，所说或所写的保持并遵循某种意义的完整性。当我们谈论机器学习时，这种序列数据集中的模型训练是通过使用统计方法(如 ARIMA、SARIMAX)以及使用神经网络来进行的。基本思想是时间 t 的数据是几个先前数据点的结果。本文解释了 RNN-LSTM 的理论部分，并包括一个关于时间序列数据集的快速探索性数据分析和使用 LSTM 和 DNN 预测德国未来功耗的教程。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="ab57" class="ln lo it lj b gy lp lq l lr ls"><strong class="lj iu"><em class="lt">Table of Contents<br/></em>1. Theory<br/>1.1. Recurrent Neural Networks<br/>1.1.1. Under the Hood<br/>1.1.2. Vanishing Gradient Descent<br/>1.2. Long-Short Term Memory<br/>2. Tutorial<br/>3. Conclusion<br/>4. References</strong></span></pre><figure class="le lf lg lh gt lv gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi lu"><img src="../Images/325fdb30b6fc56234dff1122dcab3e1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*13sJTaHotO840I9A"/></div></div><p class="mc md gj gh gi me mf bd b be z dk translated">丹尼·米勒在<a class="ae mg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><h1 id="3251" class="mh lo it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">递归神经网络</h1><p id="e12e" class="pw-post-body-paragraph ki kj it kk b kl my ju kn ko mz jx kq kr na kt ku kv nb kx ky kz nc lb lc ld im bi translated">在按顺序流动的数据集中，时间 t 的每个数据都与历史数据相关。比如我们考虑 NLP，一个段落的延续是按照它前面的关键词来塑造的，也就是按照意思的完整性来塑造的。阅读小说时，平均每秒钟可以看到 3-4 个单词，并且可以流畅地继续阅读。虽然在 1 个小时的阅读结束时，已经看到并阅读了几千个单词，但很难背下来。然而，阅读的部分可以很容易理解和解释。在机器学习中，递归神经网络可以用来从这样的序列数据集中提取基本含义和模式。让我们继续不同的例子；电影由画面组成，根据电影的主题和内容，这些画面具有一定的完整性。我们在理解了电影之后，可以很容易地预测电影中的下一个瞬间或者下一帧。递归神经网络可用于通过检测序列数据中的流动模式来预测未来。在另一个例子中，它提供时间序列，即在随时间变化的图形<em class="lt">(股票市场，冠状病毒随时间的传播)</em>中，来检测流量并进行预测。那么，如何用数字从数学上解释是什么提供了这些可能性呢？</p><h2 id="395d" class="ln lo it bd mi nd ne dn mm nf ng dp mq kr nh ni ms kv nj nk mu kz nl nm mw nn bi translated">在后台</h2><p id="ad89" class="pw-post-body-paragraph ki kj it kk b kl my ju kn ko mz jx kq kr na kt ku kv nb kx ky kz nc lb lc ld im bi translated">下图显示了递归神经网络过程如何在 4 秒钟内处理 4 个数据的顺序数据集中工作。其基本工作原理类似于前馈神经网络。整个系统可以简要概括如下:</p><p id="9b35" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">分配给输入的权重值在图层后变成输出，并与实际输出进行比较，以确定损失值，即与应有位置的距离。根据该损失值，更新权重值，并重复相同的过程。更新权重的目的是最小化损失值并确定最佳权重值。</p><p id="a6b9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">另一方面，RNN 是顺序设计的，即，在反向连接中检测时间<code class="fe no np nq lj b">t</code>与<code class="fe no np nq lj b">(t-1)</code>的数据连接。当然，除了仅仅<code class="fe no np nq lj b">t</code>和<code class="fe no np nq lj b">(t-1)</code>，也许它在时间 t 的值是根据最后 10 个值计算的，这要归功于它的后向连接结构。现在让我们详细研究一下图 1。</p><figure class="le lf lg lh gt lv gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi nr"><img src="../Images/dc76017b11c2357afd875c50035d65c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pOXQHeLnqsrVdYLe7437eg.png"/></div></div><p class="mc md gj gh gi me mf bd b be z dk translated">图一。递归神经网络，作者图片</p></figure><p id="28b7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们考虑 4 个数据点(x1、x2、x3 和 x4)。黄色结构代表层。每个输出的等式如上所述。正如所看到的，每一层的输出被顺序地呈现为下一层的附加输入。最终输出结果基于选定的激活函数。然后，计算所得结果的偏差，根据损失输出导出权重，并通过反向传播过程进行更新。RNN 的结构基本上遵循这种模式。如果我们看看这个 RNN 结构的缺点，消失梯度的问题就迎刃而解了。</p><h2 id="f9c0" class="ln lo it bd mi nd ne dn mm nf ng dp mq kr nh ni ms kv nj nk mu kz nl nm mw nn bi translated">消失梯度下降</h2><p id="83c3" class="pw-post-body-paragraph ki kj it kk b kl my ju kn ko mz jx kq kr na kt ku kv nb kx ky kz nc lb lc ld im bi translated">当很难收敛到全局极小点时，这种情况称为消失梯度下降。</p><p id="1dbe" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在 RNN，当有太多层并且权重用<strong class="kk iu"> Sigmoid 函数</strong>更新时，这个过程发生。用<strong class="kk iu"> Sigmoid 函数</strong>获得的值应该在 0 和 1 之间。然而，在反向传播过程中，第一输入<em class="lt">(NLP 的前几个字，时间序列的前几次)</em>在连续序列的学习中对系统的影响被最小化，因为权重更新处于如此低的水平，以至于当到达第一层时。这会导致这些输入及其权重被忽略，从而将顺序学习集中在最后的输入上。</p><p id="6864" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果用另一个激活函数代替 Sigmoid 函数，比如<strong class="kk iu"> ReLu </strong>，由于<strong class="kk iu"> ReLu </strong>的结构，会出现与消失梯度下降相反的情况，即权重变化太大以至于无法安全到达全局极小点。</p><h1 id="4c59" class="mh lo it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">长短期记忆</h1><p id="2b37" class="pw-post-body-paragraph ki kj it kk b kl my ju kn ko mz jx kq kr na kt ku kv nb kx ky kz nc lb lc ld im bi translated">LSTM 设计用于防止在更新权重期间忽略顺序序列中第一个输入的影响。图 2 显示了 LSTM 模型如何避免在权重调整中不考虑不重要的先前数据(先前数据的权重)的问题。</p><figure class="le lf lg lh gt lv gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi ns"><img src="../Images/5304623e5c4fa389722ff18f3079be94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8b3pmgemmE7MSrfY9nZO0g.png"/></div></div><p class="mc md gj gh gi me mf bd b be z dk translated">图二。长短期记忆(LSTM)，<a class="ae mg" href="http://A. Géron, Hands-on Machine Learning with Scikit-Learn, Keras, and TensorFlow (2019, O’reilly). O’Reilly Media, 2017." rel="noopener ugc nofollow" target="_blank">来源</a></p></figure><p id="3746" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">逻辑(Sigmoid)激活功能</strong>输出 0-1 之间的数据。这样，数据的显著性水平被评估为 0-1。0 变得不重要，并在乘法运算中反映为 0。1 表示它很重要。</p><p id="f30b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">双曲正切激活函数</strong>通过输出(-1)和(+1)之间的值来承担调节任务。</p><h2 id="6c7b" class="ln lo it bd mi nd ne dn mm nf ng dp mq kr nh ni ms kv nj nk mu kz nl nm mw nn bi translated">步伐</h2><ol class=""><li id="4bae" class="nt nu it kk b kl my ko mz kr nv kv nw kz nx ld ny nz oa ob bi translated">先前单元输出<code class="fe no np nq lj b">(h(t-1))</code>和当前输入<code class="fe no np nq lj b">(x(t))</code>通过<strong class="kk iu">逻辑(sigmoid)函数</strong>传递。长期状态<code class="fe no np nq lj b">(c(t-1))</code>乘以结果值<code class="fe no np nq lj b">(f(t))</code>。在这个阶段(忘记门)，从长期状态中数学推断出哪些数据是重要的，重要到什么程度。</li><li id="55f1" class="nt nu it kk b kl oc ko od kr oe kv of kz og ld ny nz oa ob bi translated">在第一步中获得的 sigmoid 值也在这里用相同的输入(先前单元输出<code class="fe no np nq lj b">(h(t-1))</code>和当前输入<code class="fe no np nq lj b">(x(t))</code>)获得<code class="fe no np nq lj b">(i(t))</code>。此外，这些输入也通过<strong class="kk iu">tanh</strong>T24】激活功能并与 sigmoid 输出<code class="fe no np nq lj b">(g(t))</code>相乘。在这个阶段，(输入门)<code class="fe no np nq lj b">i(t)</code>从数学上表达了 g(t)值有多重要。</li><li id="96ee" class="nt nu it kk b kl oc ko od kr oe kv of kz og ld ny nz oa ob bi translated">将前两种情况下获得的数学表达式(遗忘门和输入门)相加，形成新的单元状态<code class="fe no np nq lj b">(c(t))</code>。此外，该结果通过传递<strong class="kk iu"> tanh </strong>并乘以前两个阶段的两个输入(前一个单元输出<code class="fe no np nq lj b">(h(t-1))</code>和当前输入<code class="fe no np nq lj b">(x(t))</code>)的<strong class="kk iu">逻辑(sigmoid)函数</strong>结果<code class="fe no np nq lj b">(o(t))</code>而被规则化。返回短期状态<code class="fe no np nq lj b">(h(t))</code>。在这个阶段(输出门)，长期状态的重要性转移到系统。</li></ol><blockquote class="oh"><p id="82be" class="oi oj it bd ok ol om on oo op oq ld dk translated">LSTM 及其配置版本适用于许多基于时间的数据集，尤其是股票市场价格预测。</p></blockquote><h1 id="e17b" class="mh lo it bd mi mj mk ml mm mn mo mp mq jz or ka ms kc os kd mu kf ot kg mw mx bi translated">辅导的</h1><p id="2039" class="pw-post-body-paragraph ki kj it kk b kl my ju kn ko mz jx kq kr na kt ku kv nb kx ky kz nc lb lc ld im bi translated">在本教程中，使用 2015 年 1 月 1 日至 2020 年 9 月 1 日之间德国数据集的每小时能耗，对 LSTM 和 DNN 的模型进行了训练。数据集可以从<a class="ae mg" href="https://www.kaggle.com/francoisraucent/western-europe-power-consumption" rel="noopener ugc nofollow" target="_blank">链接</a>下载。</p><p id="0cd6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">数据集的许可:CC0:公共域</p><figure class="le lf lg lh gt lv"><div class="bz fp l di"><div class="ou ov l"/></div></figure><h2 id="b035" class="ln lo it bd mi nd ne dn mm nf ng dp mq kr nh ni ms kv nj nk mu kz nl nm mw nn bi">[1]</h2><p id="5745" class="pw-post-body-paragraph ki kj it kk b kl my ju kn ko mz jx kq kr na kt ku kv nb kx ky kz nc lb lc ld im bi translated">首先，导入必要的库，由于时间 t 的数据与之前的数据相关，因此从 2015 年 1 月 1 日到 2019 年 5 月 31 日保留为训练集，2019 年 5 月 31 日–2020 年 9 月 1 日保留为测试集。数据集由每 15 分钟的功耗值组成。通过将 4 个值(0-15 分钟、15 分钟-30 分钟、30 分钟-45 分钟、45 分钟-60 分钟)相加，数据集被转换为基于小时的值。然后如图 3 所示。</p><figure class="le lf lg lh gt lv gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi ow"><img src="../Images/f9b9bbff1b1ca6e0bafe019d99fd07d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*foTqctD4VVOCnU6dN5CNFw.png"/></div></div><p class="mc md gj gh gi me mf bd b be z dk translated">图 3。德国 2005 年 1 月 1 日至 2020 年 9 月 1 日的电力消耗，图片由作者提供</p></figure><h2 id="f04d" class="ln lo it bd mi nd ne dn mm nf ng dp mq kr nh ni ms kv nj nk mu kz nl nm mw nn bi">[2]</h2><p id="e51b" class="pw-post-body-paragraph ki kj it kk b kl my ju kn ko mz jx kq kr na kt ku kv nb kx ky kz nc lb lc ld im bi translated">添加年份和月份列后，根据年份和月份的盒状图分别如图 4 和图 5 所示。</p><figure class="le lf lg lh gt lv gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi ow"><img src="../Images/66bc7203463b03186141d87b50e14ef2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p3XtVaE9V6-fpAPSaynlFg.png"/></div></div><p class="mc md gj gh gi me mf bd b be z dk translated">图 4。按年份排列的方框图，按作者排列的图像</p></figure><figure class="le lf lg lh gt lv gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi ow"><img src="../Images/1ebbbab6004953bdbfda10b24cd3a449.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CYqgk57R3JZHKQAfsHRcSg.png"/></div></div><p class="mc md gj gh gi me mf bd b be z dk translated">图 5。按月份排列的方框图，按作者排列的图像</p></figure><h2 id="dcc5" class="ln lo it bd mi nd ne dn mm nf ng dp mq kr nh ni ms kv nj nk mu kz nl nm mw nn bi">[3]</h2><p id="73c6" class="pw-post-body-paragraph ki kj it kk b kl my ju kn ko mz jx kq kr na kt ku kv nb kx ky kz nc lb lc ld im bi translated">在本节中，使用以下策略根据神经网络模型对数据集进行重新调整和重新设计:</p><p id="de6d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">将 24 个数据(1 天= 24 小时)按顺序用<code class="fe no np nq lj b">last_n = 24</code>设计为输入，25。数据被输出。例如，在索引的基础上，输入 0–24，而输入 24。数据输出；25.输入 1–25 时的数据输出；26.输入 2–26 时的数据输出，等等。</p><p id="bc36" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当设计 LSTM 模型时，<code class="fe no np nq lj b">return sequence=True</code>被设置直到最后一个 LSTM 层，并且模型被训练。在训练结束时，模型分别预测更新的权重以及训练和测试数据集。</p><p id="1e28" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">图 6 显示了在创建输入-输出时，通过重新排列由所选数字引起的移位，测试数据集的随机部分的可视化结果。</p><figure class="le lf lg lh gt lv gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi ow"><img src="../Images/0f9c0bab7c7493c3c1425e89624bbe2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MfVecfJ6v13FGp6SO3GmhQ.png"/></div></div><p class="mc md gj gh gi me mf bd b be z dk translated">图 6。LSTM 预测与真实值的比较，作者图片</p></figure><h2 id="238b" class="ln lo it bd mi nd ne dn mm nf ng dp mq kr nh ni ms kv nj nk mu kz nl nm mw nn bi">[4]</h2><p id="954d" class="pw-post-body-paragraph ki kj it kk b kl my ju kn ko mz jx kq kr na kt ku kv nb kx ky kz nc lb lc ld im bi translated">在这一部分中，使用密集层来构建模型，以使用深度神经网络来训练模型。在数据集中使用相同的缩放器方法，并在制作适合模型的形状后对其进行训练。LSTM 使用的流程经过配置，适合 DNN 模型，测试数据集随机部分的预测如图 7 所示。</p><figure class="le lf lg lh gt lv gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi ow"><img src="../Images/aa3444dc973a7df5547ad6f83f3efa49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tKvSHzuFfptI3bt2VXA2qw.png"/></div></div><p class="mc md gj gh gi me mf bd b be z dk translated">图 7。DNN 预测与真实值的比较，作者图片</p></figure><h1 id="b487" class="mh lo it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">结论</h1><p id="8d33" class="pw-post-body-paragraph ki kj it kk b kl my ju kn ko mz jx kq kr na kt ku kv nb kx ky kz nc lb lc ld im bi translated">顾名思义，长短期记忆(LSTM)是基于通过更新权重来训练模型，同时考虑到长期历史数据的重要性。使用上述密集层创建的 DNN 模型是在神经网络的基础上根据输入和输出之间的激活函数来更新权重。当我们粗略对比上面的结果(图 6 和图 7)时，可以说两种结果都接近现实。然而，当仔细观察时，可以看出 LSTM 在较低和较高的峰值处，尤其是在较低的峰值点处绘制了更成功的图形。尽管 DNN 结果中几乎所有较低的峰值都低于它们应有的水平，但 LSTM 绘制了一个更成功、更恰当的图表，尽管存在小幅的上下偏差。</p><p id="094d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">由于 LSTM 的设计考虑了先前数据的重要性，因此它可以更有效地执行学习过程。因此，当模型被训练时，DNN 可以使错误模式成为学习过程的一部分，而 LSTM 在这一点上更灵活地呈现模型。由于这个数据集结构大致遵循一定的顺序(见图 3)，只有仔细研究才能看出这两个模型之间的区别。然而，对于具有较高随机性(难以检测模式)的数据集和时变数据集，可以更清楚地看到 LSTM 的差异。</p><h1 id="7456" class="mh lo it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">参考</h1><p id="d6d1" class="pw-post-body-paragraph ki kj it kk b kl my ju kn ko mz jx kq kr na kt ku kv nb kx ky kz nc lb lc ld im bi translated"><a class="ae mg" href="http://colah.github.io/posts/2015-08-Understanding-LSTMs/" rel="noopener ugc nofollow" target="_blank">http://colah.github.io/posts/2015-08-Understanding-LSTMs/</a></p></div><div class="ab cl ox oy hx oz" role="separator"><span class="pa bw bk pb pc pd"/><span class="pa bw bk pb pc pd"/><span class="pa bw bk pb pc"/></div><div class="im in io ip iq"><div class="le lf lg lh gt pe"><a href="https://ibrahimkovan.medium.com/machine-learning-guideline-959da5c6f73d" rel="noopener follow" target="_blank"><div class="pf ab fo"><div class="pg ab ph cl cj pi"><h2 class="bd iu gy z fp pj fr fs pk fu fw is bi translated">机器学习指南</h2><div class="pl l"><h3 class="bd b gy z fp pj fr fs pk fu fw dk translated">所有与机器学习相关的文章</h3></div><div class="pm l"><p class="bd b dl z fp pj fr fs pk fu fw dk translated">ibrahimkovan.medium.com</p></div></div><div class="pn l"><div class="po l pp pq pr pn ps ma pe"/></div></div></a></div></div></div>    
</body>
</html>