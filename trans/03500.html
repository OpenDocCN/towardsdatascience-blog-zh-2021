<html>
<head>
<title>5 Principles to write SOLID Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">编写可靠代码的5个原则</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/5-principles-to-write-solid-code-examples-in-python-9062272e6bdc?source=collection_archive---------0-----------------------#2021-03-21">https://towardsdatascience.com/5-principles-to-write-solid-code-examples-in-python-9062272e6bdc?source=collection_archive---------0-----------------------#2021-03-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="d82d" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/tips-and-tricks" rel="noopener" target="_blank"> <em class="jb">小窍门</em> </a></h2><div class=""/><div class=""><h2 id="d144" class="pw-subtitle-paragraph ka jd it bd b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr dk translated">借助于坚实的设计原则编写更好的代码的简短指南，用Python例子来说明。</h2></div><p id="b18a" class="pw-post-body-paragraph ks kt it ku b kv kw ke kx ky kz kh la lb lc ld le lf lg lh li lj lk ll lm ln im bi translated">作为一名刚刚开始工作的软件工程师，没有正式的计算机科学背景，我一直在努力提出合理的底层设计并以正确的方式构建代码。最初，它帮助我想出了一个需要遵循的5条原则的清单，我将在这篇文章中与你分享。</p><h1 id="34ef" class="lo lp it bd lq lr ls lt lu lv lw lx ly kj lz kk ma km mb kn mc kp md kq me mf bi translated">坚实的设计原则</h1><p id="4465" class="pw-post-body-paragraph ks kt it ku b kv mg ke kx ky mh kh la lb mi ld le lf mj lh li lj mk ll lm ln im bi translated">SOLID是5个面向对象设计原则集合的首字母缩写，大约20年前由Robert C. Martin首次提出概念，它们塑造了我们今天编写软件的方式。</p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi ml"><img src="../Images/d4246c039b5c2109517fed74fd420b8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yCuXkBbkJxSkw6iI8ohrhw.jpeg"/></div></div><p class="mx my gj gh gi mz na bd b be z dk translated">照片由<a class="ae nb" href="https://unsplash.com/@thisisengineering?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">在<a class="ae nb" href="/s/photos/coding?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上绘制</a></p></figure><p id="2af7" class="pw-post-body-paragraph ks kt it ku b kv kw ke kx ky kz kh la lb lc ld le lf lg lh li lj lk ll lm ln im bi translated">它们旨在帮助创建更简单、更容易理解、可维护和可扩展的代码。当一大群人在不断增长和发展的代码库上工作时，这变得非常重要，这些代码库通常由成千上万(如果不是数百万)行代码组成。这些原则是保持良好实践和编写更高质量代码的路标。</p><p id="dbbc" class="pw-post-body-paragraph ks kt it ku b kv kw ke kx ky kz kh la lb lc ld le lf lg lh li lj lk ll lm ln im bi translated">这些字母代表:</p><ol class=""><li id="a090" class="nc nd it ku b kv kw ky kz lb ne lf nf lj ng ln nh ni nj nk bi translated">单一责任原则</li><li id="b455" class="nc nd it ku b kv nl ky nm lb nn lf no lj np ln nh ni nj nk bi translated">开/关原则</li><li id="c457" class="nc nd it ku b kv nl ky nm lb nn lf no lj np ln nh ni nj nk bi translated">利斯科夫替代原理</li><li id="88b5" class="nc nd it ku b kv nl ky nm lb nn lf no lj np ln nh ni nj nk bi translated">界面分离原理</li><li id="7c0c" class="nc nd it ku b kv nl ky nm lb nn lf no lj np ln nh ni nj nk bi translated">从属倒置原则</li></ol><p id="2e44" class="pw-post-body-paragraph ks kt it ku b kv kw ke kx ky kz kh la lb lc ld le lf lg lh li lj lk ll lm ln im bi translated">它们都是简单的概念，很容易掌握，但是在编写行业标准代码时非常有价值。</p><h1 id="6668" class="lo lp it bd lq lr ls lt lu lv lw lx ly kj lz kk ma km mb kn mc kp md kq me mf bi translated">1.单一责任原则</h1><blockquote class="nq nr ns"><p id="8338" class="ks kt nt ku b kv kw ke kx ky kz kh la nu lc ld le nv lg lh li nw lk ll lm ln im bi translated">一个类应该有且只有一个改变的理由。</p></blockquote><p id="7b35" class="pw-post-body-paragraph ks kt it ku b kv kw ke kx ky kz kh la lb lc ld le lf lg lh li lj lk ll lm ln im bi translated">这大概是最直观的原理，对于软件组件或者微服务也是如此。“只有一个改变的理由”可以被重新表述为“只有一个责任”。这使得代码更加健壮和灵活，对于其他人来说更容易理解，并且在更改现有代码时，您将避免一些意想不到的副作用。您还需要做更少的更改:一个类需要更改的独立原因越多，它需要更改的次数就越多。如果您有许多相互依赖的类，那么您需要做出的更改数量可能会呈指数级增长。你的类越复杂，就越难在不产生意外后果的情况下改变它们。</p><pre class="mm mn mo mp gt nx ny nz oa aw ob bi"><span id="28f9" class="oc lp it ny b gy od oe l of og">class Album:<br/>    def __init__(self, name, artist, songs) -&gt; None:<br/>        self.name = name<br/>        self.artist = artist<br/>        self.songs = songs</span><span id="5a17" class="oc lp it ny b gy oh oe l of og">    def add_song(self, song):<br/>        self.songs.append(song)</span><span id="7805" class="oc lp it ny b gy oh oe l of og">    def remove_song(self, song):<br/>        self.songs.remove(song) </span><span id="a167" class="oc lp it ny b gy oh oe l of og">    def __str__(self) -&gt; str:<br/>        return f"Album {self.name} by {self.artist}\nTracklist:\n{self.songs}"</span><span id="fac3" class="oc lp it ny b gy oh oe l of og">    # breaks the SRP<br/>    def search_album_by_artist(self):<br/>        """ Searching the database for other albums by same artist """<br/>        pass</span></pre><p id="f414" class="pw-post-body-paragraph ks kt it ku b kv kw ke kx ky kz kh la lb lc ld le lf lg lh li lj lk ll lm ln im bi translated">在上面的例子中，我创建了一个类<code class="fe oi oj ok ny b">Album</code>。它存储专辑名称、艺术家和曲目列表，并可以操作专辑的内容，例如添加歌曲或删除。现在，如果我添加一个功能来搜索同一位艺术家的专辑，我就违反了单一责任原则。如果我决定以不同的方式存储专辑(例如，通过添加唱片标签或将曲目列表存储为曲目名称和长度的字典)，我的类将必须更改，如果我更改存储这些专辑的数据库(例如，我从Excel表移动到在线数据库)，我的类也需要更改。显然，这是两种不同的责任。相反，我应该创建一个与相册数据库交互的类。这可以通过按首字母、曲目数量等搜索专辑来扩展。(参见下一个原则)</p><pre class="mm mn mo mp gt nx ny nz oa aw ob bi"><span id="a44f" class="oc lp it ny b gy od oe l of og"># instead:<br/>class AlbumBrowser:<br/>    """ Class for browsing the Albums database"""<br/>    def search_album_by_artist(self, albums, artist):<br/>        pass<br/>    <br/>    def search_album_starting_with_letter(self, albums, letter):<br/>        pass</span></pre><p id="c869" class="pw-post-body-paragraph ks kt it ku b kv kw ke kx ky kz kh la lb lc ld le lf lg lh li lj lk ll lm ln im bi translated">一个警告:使类过于简单会使代码变得难以阅读，因为人们不得不遵循一长串相互传递的对象，并可能导致单方法类的代码库支离破碎。这个原则并不意味着每个类都应该像在一个方法中一样做<em class="nt">一件单一的事情</em>，而是<em class="nt">一个概念</em>。</p><h1 id="3b8a" class="lo lp it bd lq lr ls lt lu lv lw lx ly kj lz kk ma km mb kn mc kp md kq me mf bi translated">2.开闭原理</h1><blockquote class="nq nr ns"><p id="755d" class="ks kt nt ku b kv kw ke kx ky kz kh la nu lc ld le nv lg lh li nw lk ll lm ln im bi translated"><em class="it">软件实体(类、模块、功能等。)应该对扩展开放，但对修改关闭。</em></p></blockquote><p id="7630" class="pw-post-body-paragraph ks kt it ku b kv kw ke kx ky kz kh la lb lc ld le lf lg lh li lj lk ll lm ln im bi translated">这意味着我应该能够在不改变现有代码结构的情况下添加新功能，而是添加新代码。目标是尽可能少地更改现有的、经过测试的代码，以防止出现bug，并且不得不重新测试所有东西。如果不遵循这个原则，结果可能是依赖类的一长串变化，现有特性的退化，以及不必要的测试时间。</p><p id="d185" class="pw-post-body-paragraph ks kt it ku b kv kw ke kx ky kz kh la lb lc ld le lf lg lh li lj lk ll lm ln im bi translated">下面的例子说明了这一点:</p><pre class="mm mn mo mp gt nx ny nz oa aw ob bi"><span id="9ab9" class="oc lp it ny b gy od oe l of og">class Album:<br/>    def __init__(self, name, artist, songs, genre):<br/>        self.name = name<br/>        self.artist = artist<br/>        self.songs = songs<br/>        self.genre = genre</span><span id="5299" class="oc lp it ny b gy oh oe l of og">#before<br/>class AlbumBrowser:<br/>    def search_album_by_artist(self, albums, artist):<br/>        return [album for album in albums if album.artist == artist]</span><span id="bcc3" class="oc lp it ny b gy oh oe l of og">    def search_album_by_genre(self, albums, genre):<br/>        return [album for album in albums if album.genre == genre]</span></pre><p id="c8f1" class="pw-post-body-paragraph ks kt it ku b kv kw ke kx ky kz kh la lb lc ld le lf lg lh li lj lk ll lm ln im bi translated">现在，如果我想按艺术家和流派搜索<em class="nt">，会发生什么？如果我加上<em class="nt">发布年份</em>会怎么样？我将不得不每次都编写新的函数(总共(准确地说是2^n)-1)，而且数量呈指数增长。</em></p><p id="64b5" class="pw-post-body-paragraph ks kt it ku b kv kw ke kx ky kz kh la lb lc ld le lf lg lh li lj lk ll lm ln im bi translated">相反，我应该为我的规范定义一个具有公共接口的基类，然后为从基类继承该接口的每种类型的规范定义子类:</p><pre class="mm mn mo mp gt nx ny nz oa aw ob bi"><span id="288c" class="oc lp it ny b gy od oe l of og">#after<br/>class SearchBy:<br/>    def is_matched(self, album):<br/>        pass<br/>      <br/>class SearchByGenre(SearchBy):<br/>    def __init__(self, genre):<br/>        self.genre = genre</span><span id="3ceb" class="oc lp it ny b gy oh oe l of og">    def is_matched(self, album):<br/>        return album.genre == self.genre<br/>    <br/>class SearchByArtist(SearchBy):<br/>    def __init__(self, artist):<br/>        self.artist = artist</span><span id="d15a" class="oc lp it ny b gy oh oe l of og">    def is_matched(self, album):<br/>        return album.artist == self.artist<br/>    <br/>class AlbumBrowser:<br/>    def browse(self, albums, searchby):<br/>        return [album for album in albums if searchby.is_matched(album)]</span></pre><p id="18b5" class="pw-post-body-paragraph ks kt it ku b kv kw ke kx ky kz kh la lb lc ld le lf lg lh li lj lk ll lm ln im bi translated">这允许我们在需要的时候用另一个类来扩展搜索(例如通过发布日期)。任何新的搜索类都需要满足Searchby定义的接口，所以当我们与现有代码交互时不会有意外。为了按条件浏览，我们现在需要首先创建一个SearchBy对象，并将其传递给AlbumBrowser。</p><p id="4fa0" class="pw-post-body-paragraph ks kt it ku b kv kw ke kx ky kz kh la lb lc ld le lf lg lh li lj lk ll lm ln im bi translated">但是多重标准呢？我非常喜欢我在这个<a class="ae nb" href="https://www.udemy.com/course/design-patterns-python/" rel="noopener ugc nofollow" target="_blank">设计模式Udemy课程</a>中看到的这个解决方案。这允许用户通过<code class="fe oi oj ok ny b">&amp;</code>将浏览标准连接在一起:</p><pre class="mm mn mo mp gt nx ny nz oa aw ob bi"><span id="2f04" class="oc lp it ny b gy od oe l of og">#add __and__:<br/>class SearchBy:<br/>    def is_matched(self, album):<br/>        pass<br/>    <br/>    def __and__(self, other):<br/>        return AndSearchBy(self, other)</span><span id="bb23" class="oc lp it ny b gy oh oe l of og">class AndSearchBy(SearchBy):<br/>    def __init__(self, searchby1, searchby2):<br/>        self.searchby1 = searchby1<br/>        self.searchby2 = searchby2</span><span id="6dca" class="oc lp it ny b gy oh oe l of og">    def is_matched(self, album):<br/>        return self.searchby1.is_matched(album) and self.searchby2.is_matched(album)</span></pre><p id="9766" class="pw-post-body-paragraph ks kt it ku b kv kw ke kx ky kz kh la lb lc ld le lf lg lh li lj lk ll lm ln im bi translated">这个<code class="fe oi oj ok ny b">&amp;</code>方法可能有点混乱，所以下面的例子演示了它的用法:</p><pre class="mm mn mo mp gt nx ny nz oa aw ob bi"><span id="7323" class="oc lp it ny b gy od oe l of og">LAWoman = Album(<br/>    name="L.A. Woman",<br/>    artist="The Doors",<br/>    songs=["Riders on the Storm"],<br/>    genre="Rock",<br/>)</span><span id="1eff" class="oc lp it ny b gy oh oe l of og">Trash = Album(<br/>    name="Trash",<br/>    artist="Alice Cooper",<br/>    songs=["Poison"],<br/>    genre="Rock",<br/>)<br/>albums = [LAWoman, Trash]</span><span id="a27b" class="oc lp it ny b gy oh oe l of og"># this creates the AndSearchBy object<br/>my_search_criteria = SearchByGenre(genre="Rock") &amp; SearchByArtist(<br/>    artist="The Doors"<br/>)</span><span id="285c" class="oc lp it ny b gy oh oe l of og">browser = AlbumBrowser()<br/>assert browser.browse(albums=albums, searchby=my_search_criteria) == [LAWoman]<br/># yay we found our album</span></pre><h1 id="86df" class="lo lp it bd lq lr ls lt lu lv lw lx ly kj lz kk ma km mb kn mc kp md kq me mf bi translated">3.利斯科夫替代原理</h1><p id="d0e8" class="pw-post-body-paragraph ks kt it ku b kv mg ke kx ky mh kh la lb mi ld le lf mj lh li lj mk ll lm ln im bi translated">这个原则是由Barbara Liskov提出的，她非常正式地阐述了她的原则:</p><blockquote class="nq nr ns"><p id="ed35" class="ks kt nt ku b kv kw ke kx ky kz kh la nu lc ld le nv lg lh li nw lk ll lm ln im bi translated"><em class="it">“设φ(x)是关于t类型的对象x的一个可证明的性质。那么φ(y)对于S类型的对象y应该是真的，其中S是t的子类型。”</em></p></blockquote><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi ol"><img src="../Images/e997d8cf0902ead7800cad0e5b3615fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-C__7qiMvRuVB-SCQahSBQ.jpeg"/></div></div><p class="mx my gj gh gi mz na bd b be z dk translated">如果它看起来像鸭子，叫起来像鸭子，但它需要电池，你可能有错误的抽象。— 📸拉维·辛格</p></figure><p id="f632" class="pw-post-body-paragraph ks kt it ku b kv kw ke kx ky kz kh la lb lc ld le lf lg lh li lj lk ll lm ln im bi translated">这意味着，如果我们有一个基类T和子类S，您应该能够用子类S替换主类T，而不会破坏代码。子类的接口应该和基类的接口一样，子类的行为应该和基类一样。</p><p id="f85e" class="pw-post-body-paragraph ks kt it ku b kv kw ke kx ky kz kh la lb lc ld le lf lg lh li lj lk ll lm ln im bi translated">如果T中有一个方法在S中被覆盖，那么这两个方法应该接受相同的输入，并返回相同类型的输出。子类只能返回基类返回值的子集，但是它应该接受基类的所有输入。</p><p id="5c56" class="pw-post-body-paragraph ks kt it ku b kv kw ke kx ky kz kh la lb lc ld le lf lg lh li lj lk ll lm ln im bi translated">在矩形和正方形的经典例子中，我们创建了一个Rectangle类，带有宽度和高度设置器。如果您有一个正方形，宽度设置器也需要调整高度，反之亦然，以保持正方形属性。这迫使我们做出选择:要么我们保留Rectangle类的实现，但是当您对它使用setter时Square不再是正方形，要么您更改setter以使正方形的高度和宽度相同。这可能会导致一些意想不到的行为，如果你有一个函数，调整你的形状的高度。</p><pre class="mm mn mo mp gt nx ny nz oa aw ob bi"><span id="de9b" class="oc lp it ny b gy od oe l of og">class Rectangle:<br/>    def __init__(self, height, width):<br/>        self._height = height<br/>        self._width = width</span><span id="12e3" class="oc lp it ny b gy oh oe l of og">    @property<br/>    def width(self):<br/>        return self._width</span><span id="4c1e" class="oc lp it ny b gy oh oe l of og">    @width.setter<br/>    def width(self, value):<br/>        self._width = value</span><span id="9941" class="oc lp it ny b gy oh oe l of og">    @property<br/>    def height(self):<br/>        return self._height</span><span id="c992" class="oc lp it ny b gy oh oe l of og">    @height.setter<br/>    def height(self, value):<br/>        self._height = value</span><span id="2899" class="oc lp it ny b gy oh oe l of og">    def get_area(self):<br/>        return self._width * self._height<br/></span><span id="9f4e" class="oc lp it ny b gy oh oe l of og">class Square(Rectangle):<br/>    def __init__(self, size):<br/>        Rectangle.__init__(self, size, size)</span><span id="94ed" class="oc lp it ny b gy oh oe l of og">    @Rectangle.width.setter<br/>    def width(self, value):<br/>        self._width = value<br/>        self._height = value</span><span id="0ae9" class="oc lp it ny b gy oh oe l of og">    @Rectangle.height.setter<br/>    def height(self, value):<br/>        self._width = value<br/>        self._height = value<br/></span><span id="f231" class="oc lp it ny b gy oh oe l of og">def get_squashed_height_area(Rectangle):<br/>    Rectangle.height = 1<br/>    area = Rectangle.get_area()<br/>    return area<br/></span><span id="a65c" class="oc lp it ny b gy oh oe l of og">rectangle = Rectangle(5, 5)<br/>square = Square(5)</span><span id="3586" class="oc lp it ny b gy oh oe l of og">assert get_squashed_height_area(rectangle) == 5  # expected 5<br/>assert get_squashed_height_area(square) == 1  # expected 5</span></pre><p id="30bb" class="pw-post-body-paragraph ks kt it ku b kv kw ke kx ky kz kh la lb lc ld le lf lg lh li lj lk ll lm ln im bi translated">虽然这看起来没什么大不了的(当然你可以记住sqaure也改变宽度？！)，当函数更复杂时，或者当您使用其他代码时，这就成了一个更大的问题，只要假设子类的行为是相同的。</p><p id="e0dd" class="pw-post-body-paragraph ks kt it ku b kv kw ke kx ky kz kh la lb lc ld le lf lg lh li lj lk ll lm ln im bi translated">一个我非常喜欢的简短但直观的例子来自<a class="ae nb" href="https://en.wikipedia.org/wiki/Circle%E2%80%93ellipse_problem#Description" rel="noopener ugc nofollow" target="_blank">圆-椭圆问题维基文章</a>:</p><pre class="mm mn mo mp gt nx ny nz oa aw ob bi"><span id="f4df" class="oc lp it ny b gy od oe l of og">class Person():<br/>    def walkNorth(meters):<br/>        pass<br/>    def walkSouth(meters):<br/>        pass</span><span id="42a7" class="oc lp it ny b gy oh oe l of og">class Prisoner(Person):<br/>    def walkNorth(meters):<br/>        pass <br/>    def walkSouth(meters):<br/>        pass</span></pre><p id="a39e" class="pw-post-body-paragraph ks kt it ku b kv kw ke kx ky kz kh la lb lc ld le lf lg lh li lj lk ll lm ln im bi translated">显然，我们不能对囚犯实施步行方法，因为他们不能自由地向任意方向行走任意距离。我们不应该被允许在类上调用walk方法，接口是错误的。这就引出了我们的下一个原则…</p><h1 id="e261" class="lo lp it bd lq lr ls lt lu lv lw lx ly kj lz kk ma km mb kn mc kp md kq me mf bi translated">4.界面分离原理</h1><blockquote class="nq nr ns"><p id="40dd" class="ks kt nt ku b kv kw ke kx ky kz kh la nu lc ld le nv lg lh li nw lk ll lm ln im bi translated">“客户不应该被迫依赖他们不使用的接口。”</p></blockquote><p id="2ca7" class="pw-post-body-paragraph ks kt it ku b kv kw ke kx ky kz kh la lb lc ld le lf lg lh li lj lk ll lm ln im bi translated">如果你有一个包含许多方法的基类，可能不是所有的子类都需要它们，可能只是少数。但是由于继承，您将能够在所有子类上调用这些方法，甚至在那些不需要它的子类上。这意味着大量未使用的、不需要的接口，当它们被意外调用时会导致错误。</p><p id="f7d7" class="pw-post-body-paragraph ks kt it ku b kv kw ke kx ky kz kh la lb lc ld le lf lg lh li lj lk ll lm ln im bi translated">这一原则旨在防止这种情况发生。我们应该把接口做得尽可能小，这样就不需要实现我们不需要的功能。我们应该把它们分成多个基类，而不是一个大的基类。它们应该只有对每个都有意义的方法，然后让我们的子类继承它们。</p><p id="bb70" class="pw-post-body-paragraph ks kt it ku b kv kw ke kx ky kz kh la lb lc ld le lf lg lh li lj lk ll lm ln im bi translated">在下一个例子中，我们将使用抽象方法。抽象方法在基类中创建一个接口，该接口没有实现，但在从基类继承的每个子类中被强制实现。抽象方法本质上是加强一个接口。</p><pre class="mm mn mo mp gt nx ny nz oa aw ob bi"><span id="e0ed" class="oc lp it ny b gy od oe l of og">class PlaySongs:<br/>    def __init__(self, title):<br/>        self.title = title</span><span id="38fe" class="oc lp it ny b gy oh oe l of og">    def play_drums(self):<br/>        print("Ba-dum ts")</span><span id="f684" class="oc lp it ny b gy oh oe l of og">    def play_guitar(self):<br/>        print("*Soul-moving guitar solo*")</span><span id="c0be" class="oc lp it ny b gy oh oe l of og">    def sing_lyrics(self):<br/>        print("NaNaNaNa")</span><span id="887e" class="oc lp it ny b gy oh oe l of og"># This class is fine, just changing the guitar and lyrics<br/>class PlayRockSongs(PlaySongs): <br/>    def play_guitar(self):<br/>        print("*Very metal guitar solo*")</span><span id="c98e" class="oc lp it ny b gy oh oe l of og">    def sing_lyrics(self):<br/>        print("I wanna rock and roll all night")</span><span id="bc37" class="oc lp it ny b gy oh oe l of og"># This breaks the ISP, we don't have lyrics <br/>class PlayInstrumentalSongs(PlaySongs):<br/>    def sing_lyrics(self):<br/>        raise Exception("No lyrics for instrumental songs")</span></pre><p id="d39f" class="pw-post-body-paragraph ks kt it ku b kv kw ke kx ky kz kh la lb lc ld le lf lg lh li lj lk ll lm ln im bi translated">相反，我们可以为歌唱和音乐分别开设一门课(假设在我们的例子中吉他和鼓总是一起出现，否则我们需要将它们分开更多，也许通过乐器。)这样，我们只有我们需要的接口，我们不能在器乐歌曲上调用sing歌词。</p><pre class="mm mn mo mp gt nx ny nz oa aw ob bi"><span id="4c3d" class="oc lp it ny b gy od oe l of og">from abc import ABCMeta<br/></span><span id="9851" class="oc lp it ny b gy oh oe l of og">class PlaySongsLyrics:<br/>    @abstractmethod<br/>    def sing_lyrics(self, title):<br/>        pass<br/></span><span id="bd25" class="oc lp it ny b gy oh oe l of og">class PlaySongsMusic:<br/>    @abstractmethod<br/>    def play_guitar(self, title):<br/>        pass</span><span id="68ef" class="oc lp it ny b gy oh oe l of og">    @abstractmethod<br/>    def play_drums(self, title):<br/>        pass<br/></span><span id="8149" class="oc lp it ny b gy oh oe l of og">class PlayInstrumentalSong(PlaySongsMusic):<br/>    def play_drums(self, title):<br/>        print("Ba-dum ts")</span><span id="e0f1" class="oc lp it ny b gy oh oe l of og">    def play_guitar(self, title):<br/>        print("*Soul-moving guitar solo*")<br/></span><span id="b6f4" class="oc lp it ny b gy oh oe l of og">class PlayRockSong(PlaySongsMusic, PlaySongsLyrics):<br/>    def play_guitar(self):<br/>        print("*Very metal guitar solo*")</span><span id="e3a5" class="oc lp it ny b gy oh oe l of og">    def sing_lyrics(self):<br/>        print("I wanna rock and roll all night")</span><span id="9989" class="oc lp it ny b gy oh oe l of og">    def play_drums(self, title):<br/>        print("Ba-dum ts")</span></pre><h1 id="0224" class="lo lp it bd lq lr ls lt lu lv lw lx ly kj lz kk ma km mb kn mc kp md kq me mf bi translated">5.从属倒置原则</h1><p id="8748" class="pw-post-body-paragraph ks kt it ku b kv mg ke kx ky mh kh la lb mi ld le lf mj lh li lj mk ll lm ln im bi translated">最后一个原则是</p><blockquote class="nq nr ns"><p id="0536" class="ks kt nt ku b kv kw ke kx ky kz kh la nu lc ld le nv lg lh li nw lk ll lm ln im bi translated">高层模块不应该依赖低层模块。两者都应该依赖于抽象(例如接口)。</p><p id="5e99" class="ks kt nt ku b kv kw ke kx ky kz kh la nu lc ld le nv lg lh li nw lk ll lm ln im bi translated">抽象不应该依赖于细节。细节(具体实现)应该依赖于抽象</p></blockquote><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi om"><img src="../Images/1da154a14970d19c6a82979bfcf5a3e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EPbbEw7dhF6CnzD2p6BhQQ.jpeg"/></div></div><p class="mx my gj gh gi mz na bd b be z dk translated">你会把灯直接焊在墙上的电线上吗？— 📸<a class="ae nb" href="https://unsplash.com/@yash44_?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">亚什·帕特尔</a></p></figure><p id="38b8" class="pw-post-body-paragraph ks kt it ku b kv kw ke kx ky kz kh la lb lc ld le lf lg lh li lj lk ll lm ln im bi translated">如果你的代码有定义良好的抽象接口，改变一个类的内部实现不会破坏你的代码。它与之交互的一个类不应该知道另一个类的内部工作方式，只要接口相同，它就不会受到影响。例如，更改您使用的数据库类型(SQL或NoSQL)或更改存储数据的数据结构(字典或列表)。</p><p id="55ee" class="pw-post-body-paragraph ks kt it ku b kv kw ke kx ky kz kh la lb lc ld le lf lg lh li lj lk ll lm ln im bi translated">下面的例子说明了这一点，其中ViewRockAlbums明确地依赖于这样一个事实，即相册以一定的顺序存储在AlbumStore中的一个元组中。它应该不知道Albumstore的内部结构。现在，如果我们改变相册中元组的顺序，我们的代码就会中断。</p><pre class="mm mn mo mp gt nx ny nz oa aw ob bi"><span id="1051" class="oc lp it ny b gy od oe l of og">class AlbumStore:<br/>    albums = []</span><span id="e2f5" class="oc lp it ny b gy oh oe l of og">    def add_album(self, name, artist, genre):<br/>        self.albums.append((name, artist, genre))<br/></span><span id="30bd" class="oc lp it ny b gy oh oe l of og">class ViewRockAlbums:<br/>    def __init__(self, album_store):<br/>        for album in album_store.albums:<br/>            if album[2] == "Rock":<br/>                print(f"We have {album[0]} in store.")</span></pre><p id="7fee" class="pw-post-body-paragraph ks kt it ku b kv kw ke kx ky kz kh la lb lc ld le lf lg lh li lj lk ll lm ln im bi translated">相反，我们需要向AlbumStore添加一个抽象接口来隐藏细节，其他类可以调用这个接口。这应该像开闭原则中的例子那样完成，但是假设我们不关心通过任何其他方式过滤，我将只添加一个filter_by_genre方法。现在，如果我们有另一种类型的AlbumStore，它决定以不同的方式存储相册，它需要为filter_by_genre实现相同的接口，以使ViewRockAlbums工作。</p><pre class="mm mn mo mp gt nx ny nz oa aw ob bi"><span id="644c" class="oc lp it ny b gy od oe l of og">class GeneralAlbumStore:<br/>    @abstractmethod<br/>    def filter_by_genre(self, genre):<br/>        pass</span><span id="2359" class="oc lp it ny b gy oh oe l of og">class MyAlbumStore(GeneralAlbumStore):<br/>    albums = []</span><span id="4ed8" class="oc lp it ny b gy oh oe l of og">    def add_album(self, name, artist, genre):<br/>        self.albums.append((name, artist, genre))</span><span id="c652" class="oc lp it ny b gy oh oe l of og">    def filter_by_genre(self, genre):<br/>        if album[2] == genre:<br/>            yield album[0]</span><span id="86ec" class="oc lp it ny b gy oh oe l of og">class ViewRockAlbums:<br/>    def __init__(self, album_store):<br/>        for album_name in album_store.filter_by_genre("Rock"):<br/>            print(f"We have {album_name} in store.")</span></pre><h1 id="a991" class="lo lp it bd lq lr ls lt lu lv lw lx ly kj lz kk ma km mb kn mc kp md kq me mf bi translated">结论</h1><p id="d8a2" class="pw-post-body-paragraph ks kt it ku b kv mg ke kx ky mh kh la lb mi ld le lf mj lh li lj mk ll lm ln im bi translated">坚实的设计原则是编写可维护的、可扩展的和易于理解的代码的指南。下一次当你想到一个设计的时候，为了写出可靠的代码，把它们记在心里是值得的。在你的脑海中浏览这些字母，回忆每个字母的意思:</p><ol class=""><li id="2f17" class="nc nd it ku b kv kw ky kz lb ne lf nf lj ng ln nh ni nj nk bi translated">单一责任原则</li><li id="fbe3" class="nc nd it ku b kv nl ky nm lb nn lf no lj np ln nh ni nj nk bi translated">开/关原则</li><li id="3831" class="nc nd it ku b kv nl ky nm lb nn lf no lj np ln nh ni nj nk bi translated">利斯科夫替代原理</li><li id="934e" class="nc nd it ku b kv nl ky nm lb nn lf no lj np ln nh ni nj nk bi translated">界面分离原理</li><li id="eda2" class="nc nd it ku b kv nl ky nm lb nn lf no lj np ln nh ni nj nk bi translated">从属倒置原则</li></ol><p id="a7d8" class="pw-post-body-paragraph ks kt it ku b kv kw ke kx ky kz kh la lb lc ld le lf lg lh li lj lk ll lm ln im bi translated">现在去一个接一个地让世界变得更美好吧！</p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi on"><img src="../Images/24ab74f01ba00e92792ed57b75bd7b54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZkV2evZT885DbdOi4ulasA.jpeg"/></div></div><p class="mx my gj gh gi mz na bd b be z dk translated">马丁·w·柯斯特在<a class="ae nb" href="/s/photos/happy-code?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure></div><div class="ab cl oo op hx oq" role="separator"><span class="or bw bk os ot ou"/><span class="or bw bk os ot ou"/><span class="or bw bk os ot"/></div><div class="im in io ip iq"><p id="03cc" class="pw-post-body-paragraph ks kt it ku b kv kw ke kx ky kz kh la lb lc ld le lf lg lh li lj lk ll lm ln im bi translated"><strong class="ku je">参考文献:</strong></p><p id="5f6d" class="pw-post-body-paragraph ks kt it ku b kv kw ke kx ky kz kh la lb lc ld le lf lg lh li lj lk ll lm ln im bi translated">[1]坚实的发展原则-在动机图片中—<a class="ae nb" href="https://lostechies.com/derickbailey/2009/02/11/solid-development-principles-in-motivational-pictures/" rel="noopener ugc nofollow" target="_blank">https://los techies . com/derick Bailey/2009/02/11/SOLID-Development-Principles-In-motivative-Pictures/</a></p><p id="4208" class="pw-post-body-paragraph ks kt it ku b kv kw ke kx ky kz kh la lb lc ld le lf lg lh li lj lk ll lm ln im bi translated">[2] Udemy设计模式课程—<a class="ae nb" href="https://www.udemy.com/course/design-patterns-python/" rel="noopener ugc nofollow" target="_blank">https://www.udemy.com/course/design-patterns-python/</a></p><p id="0ddb" class="pw-post-body-paragraph ks kt it ku b kv kw ke kx ky kz kh la lb lc ld le lf lg lh li lj lk ll lm ln im bi translated">[3]坚实的设计原则—<a class="ae nb" href="https://adevait.com/software/solid-design-principles-the-guide-to-becoming-better-developers" rel="noopener ugc nofollow" target="_blank">https://ade vait . com/software/SOLID-Design-Principles-the-guide to-being-better-developers</a></p></div></div>    
</body>
</html>