<html>
<head>
<title>Fuzzywuzzy: Merging Datasets on Diversely Transcribed Names</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Fuzzywuzzy:合并不同转录名称的数据集</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/fuzzywuzzy-basica-and-merging-datasets-on-names-with-different-transcriptions-e2bb6e179fbf?source=collection_archive---------13-----------------------#2021-06-16">https://towardsdatascience.com/fuzzywuzzy-basica-and-merging-datasets-on-names-with-different-transcriptions-e2bb6e179fbf?source=collection_archive---------13-----------------------#2021-06-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="1242" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用词向量距离比较字符串相似度的模糊匹配</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/2dc61d22f00ceb573b636fdf3158dad3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZQ231tJtho60PZfsNmatVg.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">安娜斯塔西娅·切平斯卡在Unsplash上拍摄的照片</p></figure><p id="90fb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我最近做了一个项目，涉及到合并同一个人的姓名的数据集，这些姓名的转录略有不同。一些名字拼写错误，包括昵称、中间名或后缀，它们在数据集之间不匹配。在本例中，我使用了一个字符串匹配包<a class="ae kv" href="https://pypi.org/project/fuzzywuzzy/" rel="noopener ugc nofollow" target="_blank"> Fuzzywuzzy </a>来合并正确的名称。</p><p id="a2d1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了省去你很多我在合并前做的额外工作，我想解释一下你可以使用的<a class="ae kv" href="https://pypi.org/project/fuzzywuzzy/" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> Fuzzywuzzy </strong> </a>的模块、方法和用途。</p><h1 id="5a72" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">模糊的距离计算</h1><p id="4c8b" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">Fuzzywuzzy使用Levenshtein distance来计算距离，简单来说，它决定了需要对字符串中的每个字符进行多少次更改才能找到另一个单词。</p><p id="90c0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，“dog”和“dogs”需要一个变化:添加“s”。而“dog”和“dig”也需要一个变化:替换一个字母。而将“start”改为“tarp”将会有两处改动:删除“s”并用“t”代替“p”。</p><p id="8749" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在实现one names的计算时需要注意的一点是，在词根发生变化的情况下，将名字与昵称进行比较时会有困难。例如,“Bobby”和“Robert”需要大量的更改，可能会导致其他不相关的名称出现为更好的匹配。</p><h1 id="7ff0" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated"><strong class="ak">模糊不清的模块和方法</strong></h1><p id="105f" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">Fuzzywuzzy有两个模块:<code class="fe mp mq mr ms b">process</code>和<code class="fe mp mq mr ms b">fuzz</code>。</p><h2 id="399f" class="mt lt iq bd lu mu mv dn ly mw mx dp mc lf my mz me lj na nb mg ln nc nd mi ne bi translated">绒毛</h2><p id="1154" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">返回字符串的相似率，在0-100之间，最基本、最精确的方法是<code class="fe mp mq mr ms b">fuzz.ratio()</code>。</p><ol class=""><li id="a273" class="nf ng iq ky b kz la lc ld lf nh lj ni ln nj lr nk nl nm nn bi translated"><code class="fe mp mq mr ms b">fuzz.partial_ratio()</code>将一个字符串与较长字符串中长度相等的子字符串进行比较。例如:<code class="fe mp mq mr ms b"><strong class="ky ir">fuzz.partial_ratio(‘Dogs’, ‘Dog’)</strong></code>会有一个<strong class="ky ir"> 100的部分_比率</strong>，但只会有一个<strong class="ky ir"> 86 </strong>与<strong class="ky ir"> </strong> <code class="fe mp mq mr ms b"><strong class="ky ir">fuzz.ratio()</strong></code>。</li></ol><p id="43c1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">2.<code class="fe mp mq mr ms b">fuzz.token_sort_ratio()</code>不考虑顺序测量字符串，您可以从包含单词<strong class="ky ir"> sort </strong>中猜到这一点。这在比较不同顺序的姓名时很有用，例如，比较<strong class="ky ir">姓</strong>、<strong class="ky ir">名</strong>与<strong class="ky ir">名</strong>、T18】姓。</p><p id="16ad" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">3.<code class="fe mp mq mr ms b">token_set_ratio()</code>，你可以从<code class="fe mp mq mr ms b">.token_sort_ratio</code>中猜到，把每一个令牌做一套来比较。重复的话不会影响比例。如果我们在歌名列表中查找歌曲，其中一首歌曲名为<strong class="ky ir">谁放出了狗</strong>，而我们想要匹配的歌曲名为<strong class="ky ir">谁放出了狗，谁，谁，谁</strong>，我们将获得<strong class="ky ir"> 100的比率分数。</strong></p><h2 id="19d5" class="mt lt iq bd lu mu mv dn ly mw mx dp mc lf my mz me lj na nb mg ln nc nd mi ne bi translated">过程</h2><p id="141b" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">基于比率抓取最相似的单词。</p><ol class=""><li id="1e17" class="nf ng iq ky b kz la lc ld lf nh lj ni ln nj lr nk nl nm nn bi translated"><code class="fe mp mq mr ms b">process.extract()</code>和<code class="fe mp mq mr ms b">process.extractOne()</code>将从字符串列表中取出最相似的(extractOne)或n个最相似的(extract(limit = n))单词与你给定的字符串进行比较。</li></ol><h1 id="d2b1" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">与Fuzzywuzzy的过程融合</h1><p id="5daa" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在我的合并过程中的这一点上，我已经将我的一个数据集中的名称重新排序为与我的第二个数据集相同的顺序，所以我在我的过程中没有使用<code class="fe mp mq mr ms b">fuzz</code>。现在我们知道，在未来的尝试中，我们不必这样做。</p><p id="dc44" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，安装您正在使用的软件包和模块。</p><pre class="kg kh ki kj gt no ms np nq aw nr bi"><span id="6f23" class="mt lt iq ms b gy ns nt l nu nv"><em class="nw"># pip install fuzzywuzzy<br/></em>from fuzzywuzzy import process</span></pre><p id="141c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了合并名称，我在要合并的数据帧中创建了一组名称，称为<code class="fe mp mq mr ms b">names</code>，并在第二个数据帧中创建了一组要比较的名称:<code class="fe mp mq mr ms b">member_names</code>。然后我做了一个字典，里面有与<code class="fe mp mq mr ms b">names</code>最接近的两个匹配项，这样我就可以手动检查分数，看名字匹配是否正确。</p><pre class="kg kh ki kj gt no ms np nq aw nr bi"><span id="2f40" class="mt lt iq ms b gy ns nt l nu nv"># <em class="nw">make a dictionary of closest matches to names</em> </span><span id="17e7" class="mt lt iq ms b gy nx nt l nu nv">keys = {}</span><span id="80b0" class="mt lt iq ms b gy nx nt l nu nv"><strong class="ms ir">for</strong> name <strong class="ms ir">in</strong> names: <em class="nw">#names in smaller dataset to compare and match</em></span><span id="96ae" class="mt lt iq ms b gy nx nt l nu nv"><em class="nw">#get closest match of `name` compared to larger data `member_names`</em></span><span id="a5f1" class="mt lt iq ms b gy nx nt l nu nv"><em class="nw">    </em>keys[name] = ((process.extract(name, member_names, limit=2)))</span><span id="b3be" class="mt lt iq ms b gy nx nt l nu nv">#<em class="nw">you can limit to 1 with extractOne to take less time but I wanted to check if names were returning as correct.</em></span></pre><p id="1ce7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是<code class="fe mp mq mr ms b">keys</code>返回的前5行。</p><pre class="kg kh ki kj gt no ms np nq aw nr bi"><span id="345b" class="mt lt iq ms b gy ns nt l nu nv">Robert J. Wittman [('J Cox', 86), ('Rob Wittman', 86)]<br/>James R. Langevin [('James Risch', 86), ('James Comer', 86)]<br/>Gerald E. Connolly [('Gerry Connolly', 75), ('J Cox', 54)]<br/>Kathy Manning [('Kay Granger', 58), ('Kathy Castor', 56)]<br/>Michael K. Simpson [('Mike Simpson', 86), ('Michael Waltz', 66)]</span></pre><p id="1137" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如您所看到的，最匹配的名字并不完美，所以从这一点上，我过滤并检查了不匹配的名字。我查了比率低于或等于86%的名字。</p><pre class="kg kh ki kj gt no ms np nq aw nr bi"><span id="bc9b" class="mt lt iq ms b gy ns nt l nu nv"><em class="nw">#checking names that might not match correctly</em></span><span id="ac00" class="mt lt iq ms b gy nx nt l nu nv"><strong class="ms ir">for</strong> name <strong class="ms ir">in</strong> keys:<br/>    <strong class="ms ir">if</strong> keys[name][0][1] &lt;= 86: <em class="nw"> #this gives the second value in the first tuple, which is the score of the first name</em><br/>        <br/>    print(name, keys[name])</span></pre><p id="b681" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此时，您可以将您的限制扩展到2个以上，因为我的一些匹配项的比率较低。找到正确的参数后，您可以为没有匹配项的名称创建一个列表，在不同的索引处有匹配项，并迭代字典值以创建一个合并关键字过滤列表中的名称，如果需要的话:</p><pre class="kg kh ki kj gt no ms np nq aw nr bi"><span id="ad6d" class="mt lt iq ms b gy ns nt l nu nv">no_match = ['Michael Enzi', 'Kathy Manning', 'John Hickenlooper', 'William Hagerty', 'cott Franklin', 'Victoria Spartz',<br/>           'Marjorie Taylor Greene', 'Marie Newman', 'eter Meijer', 'David Cheston Rouzer', 'Robert "Bobby" Scott']<br/><br/>second_match = ['Mitchell Mcconnell, Jr.', 'Harold Dallas Rogers', 'Neal Patrick Dunn MD, FACS']</span></pre><p id="a6a4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面，我提供了匹配代码的简化版本来生成merge_keys:</p><pre class="kg kh ki kj gt no ms np nq aw nr bi"><span id="0bb8" class="mt lt iq ms b gy ns nt l nu nv">#<em class="nw"> getting list of the matches from the bigger dataset to the smaller one as keys to merge on</em></span><span id="49e1" class="mt lt iq ms b gy nx nt l nu nv">merge_key = [keys[name][1][0] <strong class="ms ir">if</strong><br/>                      name <strong class="ms ir">in</strong> second_match \<br/>                      <strong class="ms ir">else</strong> <strong class="ms ir">None</strong> <strong class="ms ir">if</strong> name <strong class="ms ir">in</strong> no_match <strong class="ms ir">else</strong><br/>                      keys[name][0][0] <strong class="ms ir">for</strong> name <strong class="ms ir">in \<br/>                      </strong>df['name']]</span><span id="d151" class="mt lt iq ms b gy nx nt l nu nv">df[‘merge_key’] = merge_key</span><span id="5aa4" class="mt lt iq ms b gy nx nt l nu nv">df.merge(second_df, how = ‘left’, left_on = ‘merge_key’, right_on=’member_names’)</span></pre><p id="fa74" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在你知道了！如果愿意，您可以覆盖任一数据集中的原始列，但是我希望保留原始数据集中的原始名称，以及我希望用于合并第二个数据集中的名称。</p><p id="ebe3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢阅读，我希望它是有帮助的！</p><p id="f974" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可以阅读更多关于fuzzywuzzy的内容，或者在这里下载。</p></div></div>    
</body>
</html>