<html>
<head>
<title>AUK — a simple alternative to AUC</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">AUK——AUC 的简单替代品</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/auk-a-simple-alternative-to-auc-800e61945be5?source=collection_archive---------35-----------------------#2021-11-08">https://towardsdatascience.com/auk-a-simple-alternative-to-auc-800e61945be5?source=collection_archive---------35-----------------------#2021-11-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="fa43" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated"><em class="kf">对于不平衡数据，比 AUC 更好的性能指标</em></h2></div><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi kg"><img src="../Images/2e3d7103822aa61e281371567a18fe2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*9vNBTqMAtjRlNnjp"/></div></div><p class="ks kt gj gh gi ku kv bd b be z dk translated">由<a class="ae kw" href="https://unsplash.com/@quesada179?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Javier Quesada </a>在<a class="ae kw" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="a582" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><strong class="kz ir">二进制分类和评价指标</strong></p><p id="f3f4" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">分类问题在数据科学中普遍存在。通过分类，模型被训练来标注来自固定标签集的输入数据。当这个固定集合的长度为二时，那么这个问题就叫做<em class="lt">二元分类</em>。</p><p id="2fca" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">通常，经过训练的二元分类模型为每个输入返回一个实数值<em class="lt"> r </em>。如果实数值高于设定的阈值<em class="lt"> t </em>，则为输入分配一个正标签，否则，将为输入分配一个负标签。</p><p id="76ca" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">为二元分类问题计算的评估指标通常基于<a class="ae kw" rel="noopener" target="_blank" href="/understanding-confusion-matrix-a9ad42dcfd62">混淆矩阵</a>。</p><p id="3177" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">为了评估分类模型的性能或对不同的模型进行排序，可以选择选取一个阈值<em class="lt"> t </em>并基于它计算<em class="lt">精度、召回率、F(1)分数</em>和<em class="lt">精度</em>。此外，可以通过关注所有阈值(测试集中唯一的<em class="lt"> r </em>分数的数量)来评估模型的性能，而不是选择一个阈值。基于后一种方法的一个常用图表是<a class="ae kw" rel="noopener" target="_blank" href="/understanding-auc-roc-curve-68b2303cc9c5"> ROC 曲线</a>，它描绘了真实正比率(TP / TP + FN)与真实负比率(TN / TN + FP)的关系。然后，该曲线下的面积(AUC，0 到 1 之间的值)用于评估模型的质量，并将其与其他模型进行比较。</p><p id="b354" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><strong class="kz ir">联合自卫军的缺点</strong></p><p id="ed4d" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">AUC 是用于对模型性能进行排名的最常用的标量之一。然而，AUC 的缺点鲜为人知；Hand (2009)已经表明 AUC 对不同的分类器使用不同的分类成本分布(在这种情况下；对于不同的阈值<em class="lt"> t </em>)，并且它不考虑数据中的类偏度。然而，误分类损失应该取决于属于每个类别的对象的相对比例；AUC 不考虑这些前科。这相当于说，使用一个分类器，错误分类类别 1 是错误分类类别 0 的<em class="lt">倍。但是，使用另一个分类器，误分类类 1 是<em class="lt"> P </em>倍严重，其中<em class="lt">P</em>≦<em class="lt">P</em>。这是无意义的，因为单个点的不同种类的错误分类的相对严重性是问题的属性，而不是碰巧被选择的分类器。</em></p><p id="9bbe" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><strong class="kz ir">海雀</strong></p><p id="1fd3" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">为了克服这些缺点，Kaymak、Ben-David 和 Potharst (2012)提出了一个相关但不同的指标；Kappa 曲线下的面积(AUK)，这是基于被称为<a class="ae kw" rel="noopener" target="_blank" href="/cohens-kappa-9786ceceab58"> Cohen 的 Kappa </a>的公认指标。它测量绘制 Kappa 对假阳性率的图形下的面积。就像 AUC 可以被视为整体性能的指标一样，海雀也可以。然而，Kappa 由于偶然性而导致正确的分类。因此，它固有地解释了类偏度。</p><p id="5797" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">在本文中，作者展示了海雀的一些特征和优点:</p><ul class=""><li id="a66a" class="lu lv iq kz b la lb ld le lg lw lk lx lo ly ls lz ma mb mc bi translated">Kappa 是真阳性率和假阳性率之差的非线性变换。</li><li id="3fe7" class="lu lv iq kz b la md ld me lg mf lk mg lo mh ls lz ma mb mc bi translated">凸 Kappa 曲线具有唯一的最大值，可用于选择最佳模型。</li></ul><p id="8c3f" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">此外，如果数据集是平衡的:</p><ul class=""><li id="b9b9" class="lu lv iq kz b la lb ld le lg lw lk lx lo ly ls lz ma mb mc bi translated">科恩的 Kappa 提供了与 ROC 曲线完全相同的信息。</li><li id="82e7" class="lu lv iq kz b la md ld me lg mf lk mg lo mh ls lz ma mb mc bi translated">AUK = AUC — 0.5 (AUK 和 AUC 仅相差一个常数)。</li><li id="1d69" class="lu lv iq kz b la md ld me lg mf lk mg lo mh ls lz ma mb mc bi translated">AUK = 0.5 基尼(当数据集中没有偏斜时，AUK 等于基尼系数的一半)</li><li id="2754" class="lu lv iq kz b la md ld me lg mf lk mg lo mh ls lz ma mb mc bi translated">当 ROC 曲线的梯度等于 1 时，Kappa 值最大。因此，通过 Kappa 找到最优模型没有任何附加价值。</li></ul><p id="fb0c" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><strong class="kz ir">结论</strong></p><p id="f82e" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">也就是说，如果数据集是平衡的。然而，AUC 和 AUK 可能对不平衡数据集有不同的模型排名(请阅读论文中的示例)，这在投入生产时会产生巨大的影响。由于 AUK 解释了类偏度，而 AUC 没有，AUK 似乎是更好的选择，应该成为任何数据科学家工具箱的一部分。</p><p id="e361" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><strong class="kz ir">代码</strong></p><p id="3bbc" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">假设您有:</p><ul class=""><li id="0b96" class="lu lv iq kz b la lb ld le lg lw lk lx lo ly ls lz ma mb mc bi translated"><em class="lt">概率:</em>你的分类模型的输出；一个长度为 k 的实数列表。</li><li id="5c21" class="lu lv iq kz b la md ld me lg mf lk mg lo mh ls lz ma mb mc bi translated"><em class="lt">标签:</em>分类模型的实际标签；一个由 0 和 1 组成的<em class="lt"> k </em>长度列表。</li></ul><p id="c7f4" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">然后，可以调用下面的类来计算 AUK 和/或得到 Kappa 曲线。</p><pre class="kh ki kj kk gt mi mj mk ml aw mm bi"><span id="af9f" class="mn mo iq mj b gy mp mq l mr ms">class AUK:<br/>    def __init__(self, probabilities, labels, integral='trapezoid'):<br/>        self.probabilities = probabilities<br/>        self.labels = labels<br/>        self.integral = integral<br/>        if integral not in ['trapezoid','max','min']:<br/>            raise ValueError('"'+str(integral)+'"'+ ' is not a valid integral value. Choose between "trapezoid", "min" or "max"')<br/>        self.probabilities_set = sorted(list(set(probabilities)))<br/>    <br/>    #make predictions based on the threshold value and self.probabilities<br/>    def _make_predictions(self, threshold):<br/>        predictions = []<br/>        for prob in self.probabilities:<br/>            if prob &gt;= threshold:<br/>                predictions.append(1)<br/>            else: <br/>                predictions.append(0)<br/>        return predictions<br/>    <br/>    #make list with kappa scores for each threshold<br/>    def kappa_curve(self):<br/>        kappa_list = []<br/>        <br/>        for thres in self.probabilities_set:<br/>            preds = self._make_predictions(thres)<br/>            tp, tn, fp, fn = self.confusion_matrix(preds)<br/>            k = self.calculate_kappa(tp, tn, fp, fn)<br/>            kappa_list.append(k)<br/>        return self._add_zero_to_curve(kappa_list)<br/>    <br/>    #make list with fpr scores for each threshold<br/>    def fpr_curve(self):<br/>        fpr_list = []<br/>        <br/>        for thres in self.probabilities_set:<br/>            preds = self._make_predictions(thres)<br/>            tp, tn, fp, fn = self.confusion_matrix(preds)<br/>            fpr = self.calculate_fpr(fp, tn)<br/>            fpr_list.append(fpr)<br/>        return self._add_zero_to_curve(fpr_list)<br/>    <br/>   <br/>    #calculate confusion matrix<br/>    def confusion_matrix(self, predictions):<br/>        tp = 0<br/>        tn = 0<br/>        fp = 0<br/>        fn = 0<br/>        for i, pred in enumerate(predictions):<br/>            if pred == self.labels[i]:<br/>                if pred == 1:<br/>                    tp += 1<br/>                else: <br/>                    tn += 1<br/>            elif pred == 1:<br/>                fp += 1<br/>            else: fn += 1<br/>            tot = tp + tn + fp + fn<br/>        return tp/tot, tn/tot, fp/tot, fn/tot<br/>        <br/>    #Calculate AUK<br/>    def calculate_auk(self):        <br/>        auk=0<br/>        fpr_list = self.fpr_curve()<br/>            <br/>        for i, prob in enumerate(self.probabilities_set[:-1]):<br/>            x_dist = abs(fpr_list[i+1] - fpr_list[i])<br/>                <br/>            preds = self._make_predictions(prob) <br/>            tp, tn, fp, fn = self.confusion_matrix(preds)<br/>            kapp1 = self.calculate_kappa(tp, tn, fp, fn)<br/>                <br/>            preds = self._make_predictions(self.probabilities_set[i+1]) <br/>            tp, tn, fp, fn = self.confusion_matrix(preds)<br/>            kapp2 = self.calculate_kappa(tp, tn, fp, fn)<br/>                <br/>            y_dist = abs(kapp2-kapp1)<br/>            bottom = min(kapp1, kapp2)*x_dist<br/>            auk += bottom<br/>            if self.integral == 'trapezoid':<br/>                top = (y_dist * x_dist)/2<br/>                auk += top<br/>            elif self.integral == 'max':<br/>                top = (y_dist * x_dist)<br/>                auk += top<br/>            else:<br/>                continue<br/>        return auk<br/>    <br/>    #Calculate the false-positive rate<br/>    def calculate_fpr(self, fp, tn):<br/>        return fp/(fp+tn)<br/>    <br/>    #Calculate kappa score<br/>    def calculate_kappa(self, tp, tn, fp, fn):<br/>        acc = tp + tn<br/>        p = tp + fn<br/>        p_hat = tp + fp<br/>        n = fp + tn<br/>        n_hat = fn + tn<br/>        p_c = p * p_hat + n * n_hat<br/>        return (acc - p_c) / (1 - p_c)<br/>    <br/>    #Add zero to appropriate position in list<br/>    def _add_zero_to_curve(self, curve):<br/>        min_index = curve.index(min(curve)) <br/>        if min_index&gt; 0:<br/>            curve.append(0)<br/>        else: curve.insert(0,0)<br/>        return curve</span><span id="bfc8" class="mn mo iq mj b gy mt mq l mr ms">    #Add zero to appropriate position in list<br/>    def _add_zero_to_curve(self, curve):<br/>        min_index = curve.index(min(curve)) <br/>        if min_index&gt; 0:<br/>            curve.append(0)<br/>        else: curve.insert(0,0)<br/>        return curve</span></pre><p id="feac" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">要计算 AUK，请使用以下步骤:</p><pre class="kh ki kj kk gt mi mj mk ml aw mm bi"><span id="0d32" class="mn mo iq mj b gy mp mq l mr ms">auk_class = AUK(probabilities, labels)</span><span id="b432" class="mn mo iq mj b gy mt mq l mr ms">auk_score = auk_class.calculate_auk()</span><span id="80f8" class="mn mo iq mj b gy mt mq l mr ms">kappa_curve = auk_class.kappa_curve()</span></pre><p id="da17" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">最后，我强烈建议只在计算积分时使用<em class="lt">梯形</em>，因为这也是<a class="ae kw" href="https://scikit-learn.org/stable/modules/generated/sklearn.metrics.auc.html" rel="noopener ugc nofollow" target="_blank"> sklearn 计算 AUC </a>积分的方式。</p><h1 id="a261" class="mu mo iq bd mv mw mx my mz na nb nc nd jw ne jx nf jz ng ka nh kc ni kd nj nk bi translated">参考</h1><p id="32f1" class="pw-post-body-paragraph kx ky iq kz b la nl jr lc ld nm ju lf lg nn li lj lk no lm ln lo np lq lr ls ij bi translated">Hand，D. J. (2009)。测量分类器性能:ROC 曲线下面积的一致替代方法。<em class="lt">机器学习</em>，<em class="lt"> 77 </em> (1)，103–123。</p><p id="7a95" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">凯马克，u .，本大卫，a .，，波塔斯特，R. (2012)。海雀:AUC 的简单替代。<em class="lt">人工智能的工程应用</em>，<em class="lt"> 25 </em> (5)，1082–1089。</p></div></div>    
</body>
</html>