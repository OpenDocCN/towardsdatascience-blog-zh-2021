<html>
<head>
<title>How to Train a Classification Model with TensorFlow in 10 Minutes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用TensorFlow在10分钟内训练一个分类模型</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-train-a-classification-model-with-tensorflow-in-10-minutes-fd2b7cfba86?source=collection_archive---------3-----------------------#2021-10-14">https://towardsdatascience.com/how-to-train-a-classification-model-with-tensorflow-in-10-minutes-fd2b7cfba86?source=collection_archive---------3-----------------------#2021-10-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="07c6" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">从数据收集和准备到模型训练和评估—包括源代码</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/29355f71aa25ba2fd6eaeb7d087c4bbc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i2HCYqP5Mgn6uTbW7NqF0g.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@burst?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">爆裂</a>于<a class="ae ky" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">未爆裂</a></p></figure><p id="e94f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">深度学习无处不在。从销售预测到在图像数据上分割皮肤病，只要有高质量的数据，深度学习算法没有做不到的事情。</p><p id="d32b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果深度学习和TensorFlow对你来说很陌生，那你来对地方了。本文将向您展示在表格数据上构建分类模型的整个过程。您将在一次会议中完成从数据收集和准备到训练和评估神经网络模型的过程。我们开始吧。</p><p id="027a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您将需要安装TensorFlow 2+、Numpy、Pandas、Matplotlib和Scikit-Learn来跟进。</p><p id="efe8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不想看书？请观看我的视频:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="af50" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">跳到一个部分:</p><pre class="kj kk kl km gt lx ly lz ma aw mb bi"><span id="498b" class="mc md it ly b gy me mf l mg mh"><strong class="ly iu">· </strong><a class="ae ky" href="#efa5" rel="noopener ugc nofollow"><strong class="ly iu">DATASET USED</strong></a><br/><strong class="ly iu">· </strong><a class="ae ky" href="#ccbc" rel="noopener ugc nofollow"><strong class="ly iu">DATA PREPARATION AND EXPLORATION</strong></a><br/>  ∘ <a class="ae ky" href="#3c5e" rel="noopener ugc nofollow">Basic preparation</a><br/>  ∘ <a class="ae ky" href="#6d40" rel="noopener ugc nofollow">Converting to a binary classification problem</a><br/>  ∘ <a class="ae ky" href="#541e" rel="noopener ugc nofollow">Train/test split</a><br/>  ∘ <a class="ae ky" href="#0d9d" rel="noopener ugc nofollow">Data scaling</a><br/><strong class="ly iu">· </strong><a class="ae ky" href="#3a77" rel="noopener ugc nofollow"><strong class="ly iu">TRAINING A CLASSIFICATION MODEL WITH TENSORFLOW</strong></a><br/>  ∘ <a class="ae ky" href="#1597" rel="noopener ugc nofollow">Defining a neural network architecture</a><br/>  ∘ <a class="ae ky" href="#c871" rel="noopener ugc nofollow">Visualizing model performance</a><br/>  ∘ <a class="ae ky" href="#11c8" rel="noopener ugc nofollow">Making predictions</a><br/>  ∘ <a class="ae ky" href="#1656" rel="noopener ugc nofollow">Model evaluation on test data</a></span></pre><p id="e3f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以在<a class="ae ky" href="https://github.com/better-data-science/TensorFlow" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上下载源代码。</p></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="efa5" class="mp md it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">使用的数据集</h1><p id="dde1" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">让我们避免不必要的麻烦，坚持简单的数据集。来自Kaggle的<a class="ae ky" href="https://www.kaggle.com/shelvigarg/wine-quality-dataset" rel="noopener ugc nofollow" target="_blank">葡萄酒质量数据集</a>对今天来说已经足够好了:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nl"><img src="../Images/22e312d8d26f36ca55853f206f206d63.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T0AUc1nOEi-cOsLhRfKSjg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片1——来自Kaggle的葡萄酒质量数据集(图片由作者提供)</p></figure><p id="cbf8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">数据集基本上是干净的，但默认情况下不是为二元分类(好酒/劣酒)而设计的。取而代之的是，葡萄酒是按等级来评定的。我们稍后会解决这个问题。</p><p id="ef34" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下载并解压CSV文件到你的机器上，然后打开JupyterLab。您可以自由使用任何其他IDE，但下面所有的截图都将来自Jupyter。</p></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="ccbc" class="mp md it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">数据准备和探索</h1><p id="6b8c" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">第一步是导入Numpy和Pandas，然后导入数据集。下面的代码片段实现了这一点，并打印了一个5行的随机样本:</p><pre class="kj kk kl km gt lx ly lz ma aw mb bi"><span id="151d" class="mc md it ly b gy me mf l mg mh">import numpy as np<br/>import pandas as pd <br/><br/>df = pd.read_csv('data/winequalityN.csv')<br/>df.sample(5)</span></pre><p id="ea95" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是数据集的外观:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nm"><img src="../Images/feed837a5b8f9a02954e1367cd5078bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nPiseuNzkEXHQ_jy_YM_iA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片2 —葡萄酒质量数据集(图片由作者提供)</p></figure><p id="6495" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它基本上是干净的，但仍有一些工作要做。</p><h2 id="3c5e" class="mc md it bd mq nn no dn mu np nq dp my li nr ns na lm nt nu nc lq nv nw ne nx bi translated">基本准备</h2><p id="8e32" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">数据集有一些缺失值，但数量并不多，因为总共有6497行:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/3c114cef112adea797e52ef92563a78a.png" data-original-src="https://miro.medium.com/v2/resize:fit:856/format:webp/1*WfruHhbuKbJ8aw4RTgT4iA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图3-缺失值计数(作者图片)</p></figure><p id="1f95" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运行以下代码来消除它们:</p><pre class="kj kk kl km gt lx ly lz ma aw mb bi"><span id="15c5" class="mc md it ly b gy me mf l mg mh">df = df.dropna()</span></pre><p id="03d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">唯一的非数字特征是<code class="fe nz oa ob ly b">type</code>。可以是<em class="oc">白色</em> (4870行)或<em class="oc">红色</em> (1593行)。下面的代码片段将这个特性转换成一个名为<code class="fe nz oa ob ly b">is_white_wine</code>的二进制特性，其中如果<code class="fe nz oa ob ly b">type</code>是白色的<em class="oc">则值为1，否则为0:</em></p><pre class="kj kk kl km gt lx ly lz ma aw mb bi"><span id="1d21" class="mc md it ly b gy me mf l mg mh">df['is_white_wine'] = [<br/>    1 if typ == 'white' else 0 for typ in df['type']<br/>]<br/>df.drop('type', axis=1, inplace=True)</span></pre><p id="350c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在所有的特性都是数值型的，只剩下一件事要做——将目标变量(<code class="fe nz oa ob ly b">quality</code>)二进制化。</p><h2 id="6d40" class="mc md it bd mq nn no dn mu np nq dp my li nr ns na lm nt nu nc lq nv nw ne nx bi translated">转化为二进制分类问题</h2><p id="9688" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">葡萄酒的等级从3到9，假设越高越好。以下是价值计数:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi od"><img src="../Images/f672e9d7c65c663aa56aded57031f147.png" data-original-src="https://miro.medium.com/v2/resize:fit:924/format:webp/1*yI8v29JGVB13cQGYq2Yhhg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图4 —目标变量值计数(作者图片)</p></figure><p id="d4af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了简单起见，我们将把它转换成一个二进制变量。我们会将任何6级及以上的葡萄酒归类为<em class="oc">好</em> (1)，其他所有葡萄酒归类为<em class="oc">差</em> (0)。代码如下:</p><pre class="kj kk kl km gt lx ly lz ma aw mb bi"><span id="282a" class="mc md it ly b gy me mf l mg mh">df['is_good_wine'] = [<br/>    1 if quality &gt;= 6 else 0 for quality in df['quality']<br/>]<br/>df.drop('quality', axis=1, inplace=True)<br/><br/>df.head()</span></pre><p id="c155" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是数据集现在的样子:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/77f0c453463237dffa27e37b5fd78172.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7UrOdp3_qUEj2e2q0h8rgQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图5-准备后的数据集(作者提供的图片)</p></figure><p id="00b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你现在有4091种好酒和2372种劣酒。班级不平衡，但我们可以解决这个问题。接下来，让我们将数据集分成训练集和测试集。</p><h2 id="541e" class="mc md it bd mq nn no dn mu np nq dp my li nr ns na lm nt nu nc lq nv nw ne nx bi translated">训练/测试分割</h2><p id="0b7f" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">我们会坚持标准的80:20分成。代码如下:</p><pre class="kj kk kl km gt lx ly lz ma aw mb bi"><span id="bd68" class="mc md it ly b gy me mf l mg mh">from sklearn.model_selection import train_test_split<br/><br/>X = df.drop('is_good_wine', axis=1)<br/>y = df['is_good_wine']<br/><br/>X_train, X_test, y_train, y_test = train_test_split(<br/>    X, y, <br/>    test_size=0.2, random_state=42<br/>)</span></pre><p id="7ae3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，定型集中有5170行，测试集中有1293行。训练一个稍微像样的神经网络模型应该就够了。在开始培训之前，让我们先对数据进行缩放。</p><h2 id="0d9d" class="mc md it bd mq nn no dn mu np nq dp my li nr ns na lm nt nu nc lq nv nw ne nx bi translated">数据缩放</h2><p id="22de" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">像<code class="fe nz oa ob ly b">sulphates</code>和<code class="fe nz oa ob ly b">citric acid</code>这样的特征的值接近于零，而<code class="fe nz oa ob ly b">total sulfur dioxide</code>是以百为单位。如果你让它们保持原样，你会混淆神经网络，因为它会认为更高规模的特征更重要。</p><p id="b936" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是伸缩性发挥作用的地方。我们将使用来自Scikit-Learn的<code class="fe nz oa ob ly b">StandardScaler</code>来拟合和转换训练数据，并将转换应用于测试数据:</p><pre class="kj kk kl km gt lx ly lz ma aw mb bi"><span id="9ecb" class="mc md it ly b gy me mf l mg mh">from sklearn.preprocessing import StandardScaler<br/><br/>scaler = StandardScaler()<br/>X_train_scaled = scaler.fit_transform(X_train)<br/>X_test_scaled = scaler.transform(X_test)</span></pre><p id="a70a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是前三个缩放行的样子:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/68760079ce91bda759c500e3d61d2a32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iEd4_mVs21efehOFdEpLYA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片6 —缩放的训练集(图片由作者提供)</p></figure><p id="49d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在取值范围更窄了，所以神经网络应该能做得更好。让我们训练模型，看看我们是否能得到一些像样的东西。</p></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="3a77" class="mp md it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">用TensorFlow训练分类模型</h1><p id="c1b1" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">在训练二元分类模型时，您需要记住几件事情:</p><ul class=""><li id="e05b" class="og oh it lb b lc ld lf lg li oi lm oj lq ok lu ol om on oo bi translated"><strong class="lb iu">输出层结构</strong> —您可能想要用sigmoid函数激活一个神经元。这将输出一个概率，然后你可以分配给好酒(P &gt; 0.5)或坏酒(P &lt; = 0.5)。</li><li id="c916" class="og oh it lb b lc op lf oq li or lm os lq ot lu ol om on oo bi translated"><strong class="lb iu">损失函数</strong> —二进制交叉熵是最合适的。不要误认为是分类交叉熵。</li><li id="041a" class="og oh it lb b lc op lf oq li or lm os lq ot lu ol om on oo bi translated"><strong class="lb iu">类平衡</strong> —目标变量中的类平衡吗？换句话说，你有大致相同数量的好酒和坏酒吗？否则，<em class="oc">准确性</em>可能不是最佳评估指标。我们还将使用<em class="oc">精度</em>和<em class="oc">召回</em>。</li></ul><p id="60e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">考虑到以上三点，接下来让我们定义一个神经网络架构。</p><h2 id="1597" class="mc md it bd mq nn no dn mu np nq dp my li nr ns na lm nt nu nc lq nv nw ne nx bi translated">定义神经网络架构</h2><p id="c3f1" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">我完全是随机选择这个架构的，所以可以随意调整。该模型从12个输入特征到128个神经元的第一隐藏层，接着是256个神经元的两个附加隐藏层。最后有一个单神经元输出层。隐藏层使用ReLU作为激活函数，输出层使用Sigmoid。</p><p id="566b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">代码如下:</p><pre class="kj kk kl km gt lx ly lz ma aw mb bi"><span id="8856" class="mc md it ly b gy me mf l mg mh">import tensorflow as tf<br/>tf.random.set_seed(42)<br/><br/><br/>model = tf.keras.Sequential([<br/>    tf.keras.layers.Dense(128, activation='relu'),<br/>    tf.keras.layers.Dense(256, activation='relu'),<br/>    tf.keras.layers.Dense(256, activation='relu'),<br/>    tf.keras.layers.Dense(1, activation='sigmoid')<br/>])<br/><br/>model.compile(<br/>    loss=tf.keras.losses.binary_crossentropy,<br/>    optimizer=tf.keras.optimizers.Adam(lr=0.03),<br/>    metrics=[<br/>        tf.keras.metrics.BinaryAccuracy(name='accuracy'),<br/>        tf.keras.metrics.Precision(name='precision'),<br/>        tf.keras.metrics.Recall(name='recall')<br/>    ]<br/>)<br/><br/>history = model.fit(X_train_scaled, y_train, epochs=100)</span></pre><p id="7d2a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将启动培训过程。在我的机器上，一个纪元大约需要1秒钟(M1·MBP):</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ou"><img src="../Images/7866a55508e91b1090e4019cf6a600ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aK9vv6yhxpdicPq3I__DCg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图7-模型训练(图片由作者提供)</p></figure><p id="f7a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们在训练过程中跟踪丢失、准确度、精确度和召回，并将其保存到<code class="fe nz oa ob ly b">history</code>。我们现在可以可视化这些指标，以了解模型的运行情况。</p><h2 id="c871" class="mc md it bd mq nn no dn mu np nq dp my li nr ns na lm nt nu nc lq nv nw ne nx bi translated">可视化模型性能</h2><p id="bbb8" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">让我们从导入Matplotlib并稍微调整一下默认样式开始。以下代码片段将使绘图变大，并删除顶部和右侧的脊线:</p><pre class="kj kk kl km gt lx ly lz ma aw mb bi"><span id="2278" class="mc md it ly b gy me mf l mg mh">import matplotlib.pyplot as plt<br/>from matplotlib import rcParams<br/><br/>rcParams['figure.figsize'] = (18, 8)<br/>rcParams['axes.spines.top'] = False<br/>rcParams['axes.spines.right'] = False</span></pre><p id="49bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该图将有多条线——损失线、准确度线、精确度线和回忆线。它们都共用X轴，代表纪元编号(<code class="fe nz oa ob ly b">np.arange(1, 101)</code>)。我们应该看到损失在减少，其他指标在增加:</p><pre class="kj kk kl km gt lx ly lz ma aw mb bi"><span id="2abb" class="mc md it ly b gy me mf l mg mh">plt.plot(<br/>    np.arange(1, 101), <br/>    history.history['loss'], label='Loss'<br/>)<br/>plt.plot(<br/>    np.arange(1, 101), <br/>    history.history['accuracy'], label='Accuracy'<br/>)<br/>plt.plot(<br/>    np.arange(1, 101), <br/>    history.history['precision'], label='Precision'<br/>)<br/>plt.plot(<br/>    np.arange(1, 101), <br/>    history.history['recall'], label='Recall'<br/>)<br/>plt.title('Evaluation metrics', size=20)<br/>plt.xlabel('Epoch', size=14)<br/>plt.legend();</span></pre><p id="98a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来看看:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ov"><img src="../Images/90e1e7c0e93c7eea0bbc4e29cd6180a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-P1hN1m2-ivN8-rVWYk4Rw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图8 —培训期间的模特表现(图片由作者提供)</p></figure><p id="0996" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们训练模型时，准确度、精确度和召回率稍微增加，而损失减少。所有都有偶尔的峰值，如果你训练模型更长时间，这些峰值有望消失。</p><p id="edad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据图表，你可以为更多的时期训练模型，因为没有稳定期的迹象。</p><p id="d3e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是我们是否过度适应了呢？接下来我们来回答这个问题。</p><h2 id="11c8" class="mc md it bd mq nn no dn mu np nq dp my li nr ns na lm nt nu nc lq nv nw ne nx bi translated">做预测</h2><p id="276b" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">您现在可以使用<code class="fe nz oa ob ly b">predict()</code>函数来获得缩放测试数据的预测概率:</p><pre class="kj kk kl km gt lx ly lz ma aw mb bi"><span id="2c26" class="mc md it ly b gy me mf l mg mh">predictions = model.predict(X_test_scaled)</span></pre><p id="6b25" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是它们的样子:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ow"><img src="../Images/88deac2aa5a42041286d1764ea108c84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1180/format:webp/1*2nntqPVstVUvZkHHxHcOQg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片9 —预测概率(图片由作者提供)</p></figure><p id="48ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你必须在评估之前将它们转换成类。逻辑很简单——如果概率大于0.5，我们指定1(好酒)，否则指定0(坏酒):</p><pre class="kj kk kl km gt lx ly lz ma aw mb bi"><span id="3a19" class="mc md it ly b gy me mf l mg mh">prediction_classes = [<br/>    1 if prob &gt; 0.5 else 0 for prob in np.ravel(predictions)<br/>]</span></pre><p id="a680" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是前20个的样子:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ox"><img src="../Images/dbe9d860e22203f2d89e084a80a530cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uZ05QoC7K927TNl0YaJQTw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片10-预测类(作者图片)</p></figure><p id="0d54" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是我们所需要的—接下来让我们评估这个模型。</p><h2 id="1656" class="mc md it bd mq nn no dn mu np nq dp my li nr ns na lm nt nu nc lq nv nw ne nx bi translated">测试数据的模型评估</h2><p id="af07" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">让我们从混淆矩阵开始:</p><pre class="kj kk kl km gt lx ly lz ma aw mb bi"><span id="008b" class="mc md it ly b gy me mf l mg mh">from sklearn.metrics import confusion_matrix<br/><br/>print(confusion_matrix(y_test, prediction_classes))</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oy"><img src="../Images/d7507a0ff054e8b92164b684036b9c75.png" data-original-src="https://miro.medium.com/v2/resize:fit:408/format:webp/1*dVFtHriW63C_TgTUW7CwXQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图11 —混淆矩阵(图片由作者提供)</p></figure><p id="876b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假阴性(214)比假阳性(99)多，所以测试集上的召回值将低于精度。</p><p id="6819" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面的代码片段显示了测试集的准确度、精确度和召回率:</p><pre class="kj kk kl km gt lx ly lz ma aw mb bi"><span id="71e6" class="mc md it ly b gy me mf l mg mh">from sklearn.metrics import accuracy_score, precision_score, recall_score<br/><br/>print(f'Accuracy: {accuracy_score(y_test, prediction_classes):.2f}')<br/>print(f'Precision: {precision_score(y_test, prediction_classes):.2f}')<br/>print(f'Recall: {recall_score(y_test, prediction_classes):.2f}')</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oz"><img src="../Images/59193e220d27274c42ff12b96b351411.png" data-original-src="https://miro.medium.com/v2/resize:fit:536/format:webp/1*BhldaOB2wyr6Zt6REJ1Kyg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图12 —测试集的准确度、精确度和召回率(图片由作者提供)</p></figure><p id="9d72" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与列车组评估相比，所有值都略低:</p><ul class=""><li id="c8b8" class="og oh it lb b lc ld lf lg li oi lm oj lq ok lu ol om on oo bi translated"><strong class="lb iu">精度</strong> : 0.82</li><li id="5f2f" class="og oh it lb b lc op lf oq li or lm os lq ot lu ol om on oo bi translated"><strong class="lb iu">精度</strong> : 0.88</li><li id="102c" class="og oh it lb b lc op lf oq li or lm os lq ot lu ol om on oo bi translated"><strong class="lb iu">回忆</strong> : 0.83</li></ul><p id="443f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个模型有点过度拟合了，但在几分钟内仍然是不错的工作。我们将在下一篇文章中讨论优化。</p></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="a47f" class="mp md it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">离别赠言</h1><p id="9ba2" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">这就做到了——你现在知道如何训练一个简单的神经网络进行二进制分类。我们今天使用的数据集相对干净，几乎不需要任何准备工作。不要习惯那种感觉。</p><p id="dc01" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还有很多可以改进的地方。例如，您可以向网络添加额外的层，增加神经元的数量，选择不同的激活函数，选择不同的优化器，添加删除层，等等。可能性几乎是无穷无尽的，所以一切都归结于实验。</p><p id="59cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下一篇文章将涉及优化—您将学习如何自动找到最佳学习速率和神经网络架构，如果您想了解更多，请继续关注。</p><p id="fb41" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读。</p></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><p id="2a56" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">喜欢这篇文章吗？成为 <a class="ae ky" href="https://medium.com/@radecicdario/membership" rel="noopener"> <em class="oc">中等会员</em> </a> <em class="oc">继续无限制学习。如果你使用下面的链接，我会收到你的一部分会员费，不需要你额外付费。</em></p><div class="pa pb gp gr pc pd"><a href="https://medium.com/@radecicdario/membership" rel="noopener follow" target="_blank"><div class="pe ab fo"><div class="pf ab pg cl cj ph"><h2 class="bd iu gy z fp pi fr fs pj fu fw is bi translated">通过我的推荐链接加入Medium-Dario rade ci</h2><div class="pk l"><h3 class="bd b gy z fp pi fr fs pj fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="pl l"><p class="bd b dl z fp pi fr fs pj fu fw dk translated">medium.com</p></div></div><div class="pm l"><div class="pn l po pp pq pm pr ks pd"/></div></div></a></div></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="8143" class="mp md it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">保持联系</h1><ul class=""><li id="c885" class="og oh it lb b lc ng lf nh li ps lm pt lq pu lu ol om on oo bi translated">注册我的<a class="ae ky" href="https://mailchi.mp/46a3d2989d9b/bdssubscribe" rel="noopener ugc nofollow" target="_blank">简讯</a></li><li id="693d" class="og oh it lb b lc op lf oq li or lm os lq ot lu ol om on oo bi translated">在YouTube<a class="ae ky" href="https://www.youtube.com/c/BetterDataScience" rel="noopener ugc nofollow" target="_blank">上订阅</a></li><li id="4d9a" class="og oh it lb b lc op lf oq li or lm os lq ot lu ol om on oo bi translated">在<a class="ae ky" href="https://www.linkedin.com/in/darioradecic/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上连接</li></ul></div></div>    
</body>
</html>