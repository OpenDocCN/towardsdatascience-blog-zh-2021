<html>
<head>
<title>TensorFlow.js Blueprint App</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TensorFlow.js蓝图App</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/tensorflow-js-blueprint-app-e39654b2b44a?source=collection_archive---------26-----------------------#2021-03-19">https://towardsdatascience.com/tensorflow-js-blueprint-app-e39654b2b44a?source=collection_archive---------26-----------------------#2021-03-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b4a7" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">数据分类任务的TensorFlow.js代码流的端到端示例。这个应用程序是用React构建的，但是相同的代码可以在任何JS工具包/框架中重用。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/701e14e2adc3a517ea47b6ce7b1cb104.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*euKIYUhV6jLTSy2L45RloA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者:安德烈·巴拉诺夫斯基</p></figure><p id="2a3f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我认为用结构良好的TensorFlow.js代码逻辑创建一个简单的React应用程序来进行数据分类会有所帮助。主要的想法是，想用TensorFlow.js编写逻辑代码和构建模型的人应该能够轻松地从我的示例应用程序中复制粘贴。出于这个原因，我使用了一个简单的数据集，但是代码结构也包含了处理复杂数据集的所有逻辑。</p><p id="fff0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我使用的数据在下面的图片中是可视化的。有3组数据点——红色、蓝色和绿色。数据是二维的。该模型应该从这些数据中学习，如何划分组，以及新的点何时到来，它应该能够对其进行分类并将其分配到正确的组。即使只有非常少的数据点可用于训练，模型仍然能够学习正确的表示。这是这个例子的要点——保持简单和可重复。</p><p id="c5ad" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">示例应用程序可在<a class="ae lu" href="https://github.com/katanaml/sample-apps/tree/master/08" rel="noopener ugc nofollow" target="_blank"> GitHub </a> repo上获得。要在您的计算机上运行它，请按照下列步骤操作:</p><ol class=""><li id="96c6" class="lv lw it la b lb lc le lf lh lx ll ly lp lz lt ma mb mc md bi translated">纱线安装</li><li id="23f0" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">纱线起点</li></ol><p id="eaa2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">主要逻辑在src/App.js文件中实现。让我们从那里开始。在React中，您在同一个JS文件中编写UI和JS逻辑，这很方便。</p><h1 id="508f" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">培养</h1><p id="8029" class="pw-post-body-paragraph ky kz it la b lb nb ju ld le nc jx lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">App.js中有一个函数，叫做<em class="ng"> handleRunTraining </em>。该功能从“运行训练”按钮调用，该按钮在React JSX的同一文件中定义。这个函数做几件事:</p><ul class=""><li id="c908" class="lv lw it la b lb lc le lf lh lx ll ly lp lz lt nh mb mc md bi translated">准备培训和验证数据</li><li id="798b" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt nh mb mc md bi translated">打印准备好的培训数据</li><li id="0ab5" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt nh mb mc md bi translated">运行模型训练</li></ul><h2 id="3c72" class="ni mk it bd ml nj nk dn mp nl nm dp mt lh nn no mv ll np nq mx lp nr ns mz nt bi translated">数据准备</h2><p id="c09c" class="pw-post-body-paragraph ky kz it la b lb nb ju ld le nc jx lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">为了准备训练和验证数据，我们调用<em class="ng"> prepareData </em>函数。该功能在<em class="ng"> dataHelper </em>组件中定义。</p><p id="f58b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">大多数具有TensorFlow.js功能的示例将从CSV文件中获取数据。我想我应该把数据放到一个普通的JS数组中。当数据来自API调用时，它也很可能在数组结构中。这是一个更现实的场景，它将帮助我的示例代码更加通用和可重用。我定义了3组点——红色、绿色和蓝色:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/de677b4f8ccc6d9a67f5ff91c01212b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BLTPkgRf0FrEz1-LRyHLIA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">训练数据，作者:Andrej Baranovskij</p></figure><p id="7751" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这些点用<em class="ng"> (x，y) </em>坐标定义。为了使ML模型训练有效，我们需要归一化成对的<em class="ng"> (x，y) </em>坐标。默认情况下，值分布在150到950之间，这使得很难获得有效的训练结果。当数据被标准化时(值被带到相似的范围)，模型训练是更优的。在我们的例子中，<em class="ng"> (x，y) </em>轴的值从0到1000。这意味着我们可以通过以下等式来归一化所有数据点:</p><pre class="kj kk kl km gt nu nv nw nx aw ny bi"><span id="de1b" class="ni mk it nv b gy nz oa l ob oc">data.forEach(function (item, index) {<br/>    item.xs[0] = (item.xs[0] / (1000 / 2)) - 1;<br/>    item.xs[1] = (item.xs[1] / (1000 / 2)) - 1;<br/>})</span></pre><p id="5c19" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">第一个点的标准化数据如下所示(值将介于-1和1之间):</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi od"><img src="../Images/c1f334b139d7b2c0c2396b973e1d750d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1388/format:webp/1*KtJJK0YxmMoKOVQCFZOPdw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">标准化数据，作者:Andrej Baranovskij</p></figure><p id="2719" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们将使用TensorFlow.js <em class="ng"> fitDataset </em>方法进行模型训练。此方法不接受JS数组，数据必须是TensorFlow.js数据集的形式。有一个效用函数，将JS数组转换成TensorFlow.js数据集— <em class="ng"> tf.data.array() </em>。这个函数接受JS数组作为参数，数组应该带有<em class="ng"> xs </em>和<em class="ng"> ys </em>属性。</p><p id="b65a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您应该在发送数据进行训练之前对其进行混洗，这将增加精确模型训练的机会。可以从与将JS数组转换为数据集相同的函数中应用混排:</p><pre class="kj kk kl km gt nu nv nw nx aw ny bi"><span id="6530" class="ni mk it nv b gy nz oa l ob oc">const dataShuffled = tf.data.array(data).shuffle(3);</span></pre><p id="77d8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们的样本数据集很小，但我们仍然会抽取其中的20%进行验证。在训练过程中，通过<em class="ng"> fitDataset </em>方法进行验证。验证的想法——它应该在每次训练迭代后对训练期间看不到的数据检查模型的准确性。这有助于理解在训练期间是否没有过度拟合，如果模型对验证数据也表现良好，这意味着模型训练运行良好。您还应该有一个测试数据集，用于在训练完成后评估模型。这是将数据集分为训练和验证的方法:</p><pre class="kj kk kl km gt nu nv nw nx aw ny bi"><span id="5c0d" class="ni mk it nv b gy nz oa l ob oc">const dataTraining = dataShuffled.take(training_size);<br/>const dataValidation = dataShuffled.skip(training_size);</span></pre><p id="e856" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">目标属性包含分类值(<em class="ng">红色、绿色、蓝色</em>)。例如，我们应该将这些值编码成<em class="ng"> 0，1，0 </em>的形式。这种编码可以通过映射函数来完成。在同一个调用中，我们可以指定一个批处理值，以指示一次将有多少行被提供给训练循环:</p><pre class="kj kk kl km gt nu nv nw nx aw ny bi"><span id="ebb6" class="ni mk it nv b gy nz oa l ob oc">const convertedDataTraining =<br/>    dataTraining.map(({ xs, ys }) =&gt; {<br/>        const labels = [<br/>            ys == "Red" ? 1 : 0,<br/>            ys == "Green" ? 1 : 0,<br/>            ys == "Blue" ? 1 : 0<br/>        ]<br/>        return { xs: Object.values(xs), ys: Object.values(labels) };<br/>    }).batch(1);</span></pre><p id="0165" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">相同的映射应该应用于验证数据集。</p><h2 id="f392" class="ni mk it bd ml nj nk dn mp nl nm dp mt lh nn no mv ll np nq mx lp nr ns mz nt bi translated">模特培训</h2><p id="7899" class="pw-post-body-paragraph ky kz it la b lb nb ju ld le nc jx lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">训练在<em class="ng"> runTraining </em>功能中执行，该功能在<em class="ng"> modelTraining </em>组件中定义。</p><p id="4d87" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">首先要做的是建立一个模型。通过构建模型，我的意思是用顺序API组装一组TensorFlow.js层，并用优化器、损失和指标编译模型。模型层架构取决于您想要解决的任务和数据，以及损失的优化器的选择。</p><p id="b5ee" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们有3个目标值，这意味着最后一层应该有一个<em class="ng"> softmax </em>激活，并带有3个单位/神经元:</p><pre class="kj kk kl km gt nu nv nw nx aw ny bi"><span id="8080" class="ni mk it nv b gy nz oa l ob oc">function buildModel(numOfFeatures) {<br/>    const model = tf.sequential();</span><span id="031b" class="ni mk it nv b gy oe oa l ob oc">    model.add(tf.layers.dense({<br/>        inputShape: [numOfFeatures],<br/>        units: 12,<br/>        activation: 'relu'<br/>    }));<br/>    model.add(tf.layers.dense({<br/>        units: 3,<br/>        activation: 'softmax'<br/>    }));</span><span id="e8b1" class="ni mk it nv b gy oe oa l ob oc">    model.compile({ optimizer: tf.train.adam(0.01), <br/>        loss: 'categoricalCrossentropy', <br/>        metrics: 'accuracy' });</span><span id="8ded" class="ni mk it nv b gy oe oa l ob oc">    return model;<br/>}</span></pre><p id="cb83" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一旦模型建立起来，我们就可以训练它。我正在使用<em class="ng"> fitDataset </em>方法，还有一个<em class="ng"> fit </em>方法。我更喜欢使用<em class="ng"> fitDataset </em>，因为它适用于TensorFlow.js数据集，这是一种更通用的将数据输入训练过程的方法。方法<em class="ng"> fitDataset </em>在使用WebGL后端训练时也提供了更好的性能，这要感谢更好的内存管理。不需要设置批量值，因为在准备数据时已经设置好了。执行培训:</p><pre class="kj kk kl km gt nu nv nw nx aw ny bi"><span id="7aff" class="ni mk it nv b gy nz oa l ob oc">const history = await model.fitDataset(<br/>   convertedDataTraining,<br/>   {<br/>       epochs: 100,<br/>       validationData: convertedDataValidation,<br/>       callbacks: {onEpochEnd: (epoch, logs) =&gt; {<br/>           console.log("Epoch: " + epoch + <br/>              " Loss: " + logs.loss + <br/>              " Accuracy: " + logs.acc + <br/>              " Validation loss: " + logs.val_loss + <br/>              " Validation accuracy: " + logs.val_acc);<br/>       }<br/>   }});</span></pre><p id="b35f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">模型训练完成后，我们可以将其保存在浏览器索引数据库中:</p><pre class="kj kk kl km gt nu nv nw nx aw ny bi"><span id="cf62" class="ni mk it nv b gy nz oa l ob oc">await model.save('indexeddb://basic-model');</span></pre><h1 id="64f2" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">推理</h1><p id="f2bf" class="pw-post-body-paragraph ky kz it la b lb nb ju ld le nc jx lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">推断调用是在App.js的<em class="ng"> handleRunInference </em>方法中完成的。该方法做的第一件事是加载保存的模型:</p><pre class="kj kk kl km gt nu nv nw nx aw ny bi"><span id="443f" class="ni mk it nv b gy nz oa l ob oc">const model = await tf.loadLayersModel('indexeddb://basic-model');</span></pre><p id="9113" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">接下来，我们定义一个新的数据点，我们将把它发送给<em class="ng">预测</em>方法进行分类，并分配给三个组(<em class="ng">红色、绿色、蓝色</em>)中的一个。我们以与训练/验证数据相同的方式标准化数据点值:</p><pre class="kj kk kl km gt nu nv nw nx aw ny bi"><span id="e887" class="ni mk it nv b gy nz oa l ob oc">let data = [500, 850];<br/>data[0] = (data[0] / (1000 / 2)) - 1;<br/>data[1] = (data[1] / (1000 / 2)) - 1;</span></pre><p id="3ad2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">TensorFlow.js函数<em class="ng">预测</em>用张量运算。我们从数据点中创建一个张量，并调用函数来对该点所属的组进行分类:</p><pre class="kj kk kl km gt nu nv nw nx aw ny bi"><span id="b965" class="ni mk it nv b gy nz oa l ob oc">const input = tf.tensor2d(data, [1, data.length]);<br/>const prediction = model.predict(input);</span></pre><p id="4d0c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后一位—我们读取预测结果，找出概率最高的一组，得到它的名字:</p><pre class="kj kk kl km gt nu nv nw nx aw ny bi"><span id="ab90" class="ni mk it nv b gy nz oa l ob oc">const pIndex = tf.argMax(prediction, 1).dataSync();<br/>const classNames = ["Red", "Green", "Blue"];<br/>const probability = prediction.dataSync()[pIndex];<br/>const result = classNames[pIndex];</span></pre><p id="ea52" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在我们的测试中，数据点以99%的概率属于一个<em class="ng">蓝色</em>组。</p><p id="b24c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后一位—调用dispose函数来清理为预测结果分配的内存:</p><pre class="kj kk kl km gt nu nv nw nx aw ny bi"><span id="9536" class="ni mk it nv b gy nz oa l ob oc">prediction.dispose();</span></pre><h1 id="e0e2" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">结论</h1><p id="423f" class="pw-post-body-paragraph ky kz it la b lb nb ju ld le nc jx lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">在这篇文章中，我描述了如何将来自API的数据准备到TensorFlow.js <em class="ng"> Dataset </em>结构中，如何对数据进行混洗、规范化、一次性编码和批处理。接下来，我继续进行模型训练，并解释了为什么在TensorFlow.js中推荐使用<em class="ng"> fitDataset </em>来训练神经网络。最后，您看到了如何进行推理并获得结果。这个应用程序是用React构建的，但是相同的代码可以在任何JS工具包/框架中重用。</p><h2 id="a4bf" class="ni mk it bd ml nj nk dn mp nl nm dp mt lh nn no mv ll np nq mx lp nr ns mz nt bi translated">源代码</h2><ul class=""><li id="c98c" class="lv lw it la b lb nb le nc lh of ll og lp oh lt nh mb mc md bi translated">GitHub 回购</li></ul><h1 id="68c6" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">油管（国外视频网站）</h1><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在Youtube上查看我的解释</p></figure></div></div>    
</body>
</html>