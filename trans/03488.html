<html>
<head>
<title>The root of all software design challenge: Independent or Dependent</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">所有软件设计挑战的根源:独立还是依赖</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/the-root-of-all-software-design-challenge-independent-or-dependent-31252051bf0e?source=collection_archive---------18-----------------------#2021-03-20">https://towardsdatascience.com/the-root-of-all-software-design-challenge-independent-or-dependent-31252051bf0e?source=collection_archive---------18-----------------------#2021-03-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="d348" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">程序员世界</h2><div class=""/><div class=""><h2 id="e3a8" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">独立依赖设计:许多软件设计方案的蓝图</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/e7c9ce2615b23d3b0a3cd2f7b74946ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*POrDoxVGBpvwt7dD.jpg"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">图片由<a class="ae lh" href="https://pixabay.com/de/users/chrisreadingfoto-2723427/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=1928848" rel="noopener ugc nofollow" target="_blank">克里斯在<a class="ae lh" href="https://pixabay.com/de/photos/team-haufen-gemeinsamkeit-1928848/" rel="noopener ugc nofollow" target="_blank">皮克斯贝</a>阅读</a></p></figure><p id="33ad" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi me translated">我们先学习编码，然后学习软件设计和架构。然后我们被介绍了许多解决问题的方法。Vijini Mallawaarachchi撰写的关于10种常见软件架构模式的文章为其中的许多模式提供了很好的说明。</p><p id="2613" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然而，很多时候，在解决了问题之后，我们会发现新的问题又出现了。这让我思考，我们到底在解决什么？</p><p id="c372" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果我们“抽象”软件设计的所有问题，它们都面向一个单一的问题，即。我们如何将它们分开，又将它们联系在一起。换句话说:</p><ol class=""><li id="51f1" class="mp mq it lk b ll lm lo lp lr mr lv ms lz mt md mu mv mw mx bi translated">应该独立到什么程度？和</li><li id="ff2e" class="mp mq it lk b ll my lo mz lr na lv nb lz nc md mu mv mw mx bi translated">他们应该如何依赖？</li></ol><p id="83af" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">当我们能够清楚地理解这个问题时，它将帮助我们制定一个更可持续的解决方案。我将在下面提供一些例子。</p><p id="8752" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">但是首先，让我更清楚地说明这个问题</p><h1 id="f54f" class="nd ne it bd nf ng nh ni nj nk nl nm nn ki no kj np kl nq km nr ko ns kp nt nu bi translated">独立还是依赖？</h1><p id="40b6" class="pw-post-body-paragraph li lj it lk b ll nv kd ln lo nw kg lq lr nx lt lu lv ny lx ly lz nz mb mc md im bi translated">当我们第一次想要构建软件(或者编码一个解决方案)时，我们把它看作一个单一的实体。所有组件都在内。没有界限。实体本身是相对独立的，因为它不依赖于任何其他实体。</p><p id="a1a7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然而，这并不理想，当没有边界时，连接可能会变得混乱，并变得纠缠不清。这就是代码中禁止使用<code class="fe oa ob oc od b">goto</code>命令的原因。</p><p id="e3fd" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">因此，软件设计概念出现了，我们将单个实体分成两个或更多的实体，其中一个依赖于另一个，并且理想的是只有一个方向(避免循环依赖)。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/826972a792e7235376a8e0063acf82e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1362/format:webp/1*_WadWMmm91OGKhJxhN_-hQ.png"/></div></figure><p id="4c59" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在上图中，我们可以看到最初的单一实体设计。然后，我们将其转换为依赖于实体2设计的实体1。这种设计比单一实体更简洁。我们也可以分配不同开发人员拥有每个实体，因此每个人都有更清晰的职责。</p><p id="6a4c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然而，新的挑战出现了…如果实体1中的D需要G中的新东西，我们该如何处理呢？</p><ul class=""><li id="042f" class="mp mq it lk b ll lm lo lp lr mr lv ms lz mt md of mv mw mx bi translated">只需修改实体2中的G？(实体2的所有者将会不高兴，因为每次D想要G改变时，实体2将需要改变)</li><li id="3014" class="mp mq it lk b ll my lo mz lr na lv nb lz nc md of mv mw mx bi translated">在实体1中复制G，让D可以随心所欲的对G做任何改动，不依赖实体2？(但之后我们可能会有两组可能相似的G)。</li><li id="41f5" class="mp mq it lk b ll my lo mz lr na lv nb lz nc md of mv mw mx bi translated">将G移到实体1，因为A也需要G？(但问题是我也需要G，把G移到实体1会在实体1和实体2之间产生循环依赖)。</li></ul><p id="7943" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">也许最好的解决方案是将G和I移到实体1，使实体1更加独立于实体2。但我们知道，这将回到原点问题，它将导致更混乱的实体1。</p><p id="16d8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这就是软件设计的永恒之战。应该独立还是依赖？上面的场景是对它的一个非常简化的解释。我们可以在不同层次的软件设计中看到这种挑战，例如</p><ul class=""><li id="bf5d" class="mp mq it lk b ll lm lo lp lr mr lv ms lz mt md of mv mw mx bi translated">将代码划分成功能，例如，我们应该重构或复制多少？</li><li id="018d" class="mp mq it lk b ll my lo mz lr na lv nb lz nc md of mv mw mx bi translated">类对象之间的责任划分</li><li id="76bc" class="mp mq it lk b ll my lo mz lr na lv nb lz nc md of mv mw mx bi translated">抽象级别的划分，例如，什么应该在基础中，什么应该在子中</li><li id="22cd" class="mp mq it lk b ll my lo mz lr na lv nb lz nc md of mv mw mx bi translated">客户机与服务器、主服务器与从服务器等之间的责任划分…</li></ul><p id="6fb7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">定义分区边界是困难的。没有完美解决方案，它会不断发展。</p><p id="a3cf" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然而，如果我们将这种划分视为独立和依赖的范围划分，我们可能会发现一些双赢的情况。这可以通过我所谓的“<strong class="lk jd">独立依赖</strong>解决方案”来实现。</p><p id="9503" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这听起来可能很新鲜，但是这种方法已经在软件设计中以多种方式应用，而我们却没有意识到。让我与你分享一些例子</p><h1 id="3952" class="nd ne it bd nf ng nh ni nj nk nl nm nn ki no kj np kl nq km nr ko ns kp nt nu bi translated">独立依赖于解决方案</h1><p id="0672" class="pw-post-body-paragraph li lj it lk b ll nv kd ln lo nw kg lq lr nx lt lu lv ny lx ly lz nz mb mc md im bi translated">一个<strong class="lk jd">独立依赖</strong>另一个实体的实体是指，虽然它依赖于另一个实体，但它本身也可以影响依赖的实体，更加自力更生。</p><p id="5f73" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们今天在抽象层次上使用的许多流行的软件设计方法是一种使一些东西独立的方法。</p><p id="c45b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">下面的一些例子将有助于使这一点更清楚…</p><h2 id="46a7" class="og ne it bd nf oh oi dn nj oj ok dp nn lr ol om np lv on oo nr lz op oq nt iz bi translated">1.依赖注入</h2><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi or"><img src="../Images/5bea25b7c192252d0bab26db166d7515.png" data-original-src="https://miro.medium.com/v2/resize:fit:702/format:webp/1*wEcRhNAEsfYnHqaFii9aNQ.png"/></div></figure><p id="9dc5" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">假设我们有一个函数，我们想执行网络获取，我们有这个简单的函数如下</p><pre class="ks kt ku kv gt os od ot ou aw ov bi"><span id="900b" class="og ne it od b gy ow ox l oy oz">fun performNetworkFetch(input: String): String {<br/>    if (validateInput(input)) {<br/>        return <strong class="od jd">NetworkRepository()</strong>.fetch(input)<br/>    } else {<br/>        return "Sorry, invalid input"<br/>    }<br/>}</span></pre><p id="e417" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这里我们可以看到<code class="fe oa ob oc od b">performNetworkFetch</code>依赖于<code class="fe oa ob oc od b">NetworkRepository</code>实例上的<strong class="lk jd">来执行获取。</strong></p><p id="ba5a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这是可行的，但是对于测试来说是不是很糟糕，因为没有办法去模仿<code class="fe oa ob oc od b">NetworkResponsitory</code>。</p><p id="0e67" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">所以解决的办法就是通过在函数内实例化，让<code class="fe oa ob oc od b">performNetworkFetch</code>不直接依赖<code class="fe oa ob oc od b">networkRepository</code>，而是通过参数注入。这种方法被称为<em class="pa">依赖注入</em>。</p><pre class="ks kt ku kv gt os od ot ou aw ov bi"><span id="9fcf" class="og ne it od b gy ow ox l oy oz">fun performNetworkFetch(input: String, <br/>    <strong class="od jd">networkRepostoriy: NetworkRespositor</strong>y): String {</span><span id="9217" class="og ne it od b gy pb ox l oy oz">    if (validateInput(input)) {<br/>        return <strong class="od jd">networkRepostoriy</strong>.fetch(input)<br/>    } else {<br/>        return "Sorry, invalid input"<br/>    }<br/>}</span></pre><p id="e705" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">有了这些，现在我们可以通过模仿<code class="fe oa ob oc od b">networkResponsitory</code>来测试这个函数。</p><p id="9172" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">通过使<code class="fe oa ob oc od b">performNetworkFetch</code>不直接依赖于<code class="fe oa ob oc od b">networkRepository</code>，我们可以看到<em class="pa">依赖注入</em>使得函数<strong class="lk jd">独立依赖于对象</strong>。</p><h2 id="d8b7" class="og ne it bd nf oh oi dn nj oj ok dp nn lr ol om np lv on oo nr lz op oq nt iz bi translated">2.依赖性倒置</h2><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pc"><img src="../Images/e8d2458166756d1bef8efefd07f530dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*luXWEN5ukDPv336PdJd3kw.png"/></div></div></figure><p id="d3ae" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">当对象A引用另一个包中的另一个对象B时，它<strong class="lk jd">依赖于它</strong>。</p><pre class="ks kt ku kv gt os od ot ou aw ov bi"><span id="b0c1" class="og ne it od b gy ow ox l oy oz">class Aclass(val B: Bclass)</span><span id="6c1a" class="og ne it od b gy pb ox l oy oz">val a1 = Aclass(Bclass())</span></pre><p id="763d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这将发布对象A无法动态地将对象B的内容更改为另一个的问题。</p><p id="5a71" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然而，如果我们使用<em class="pa">依赖倒置</em>，通过让对象引用接口B来代替</p><pre class="ks kt ku kv gt os od ot ou aw ov bi"><span id="a252" class="og ne it od b gy ow ox l oy oz">class <!-- -->Aclass<!-- -->(val B: interface)</span><span id="b03c" class="og ne it od b gy pb ox l oy oz">val a1 = Aclass(Bclass()) // B inherits from interface B<br/>val a2 = Aclass(Cclass()) // C is also inherits from interface B</span></pre><p id="f138" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在，A虽然有点依赖B，但也更加独立了。它也可以得到C(它是B接口的继承)。</p><p id="3b9b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这样，我们就使对象A <strong class="lk jd">独立于对象b</strong>。</p><h2 id="d9d9" class="og ne it bd nf oh oi dn nj oj ok dp nn lr ol om np lv on oo nr lz op oq nt iz bi translated">3.多态性</h2><p id="fd49" class="pw-post-body-paragraph li lj it lk b ll nv kd ln lo nw kg lq lr nx lt lu lv ny lx ly lz nz mb mc md im bi translated">面向对象编程(OOP)的三个基本概念是封装、继承和多态。</p><p id="0c18" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">封装和继承都是定义边界和创建依赖关系的方法。使OOP更加灵活的核心是多态性。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pd"><img src="../Images/5a61259ea5c6f9fd2be2a2b08bf0193b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1142/format:webp/1*GiXFj5UMWqQgahNObBYwFQ.png"/></div></figure><p id="fdd4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在典型的子类中，类继承自父类，子类的函数定义依赖于父类。例如，根据上图，在一个数学类中，减类和加类都是从Math的计算函数继承的。</p><p id="5392" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这不好，因为如果我们运行下面的函数，减和加应该有不同的计算行为</p><pre class="ks kt ku kv gt os od ot ou aw ov bi"><span id="8cf1" class="og ne it od b gy ow ox l oy oz">fun (math: Math): Int {<br/>   return math.compute(1, 2)<br/>}</span></pre><p id="1658" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">因此，OOP的多态性部分开始发挥作用。数学类将只定义一个虚拟(或抽象)函数，并允许子类(即加法和减法)相应地重新定义计算函数。</p><p id="851f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这使得加和减，<strong class="lk jd">独立依赖于</strong>数学课。</p><h2 id="c2cd" class="og ne it bd nf oh oi dn nj oj ok dp nn lr ol om np lv on oo nr lz op oq nt iz bi translated">4.函数式编程</h2><p id="48c7" class="pw-post-body-paragraph li lj it lk b ll nv kd ln lo nw kg lq lr nx lt lu lv ny lx ly lz nz mb mc md im bi translated">最近，函数式编程成为了流行的编程范例。这与它改变一个人所依赖的核心的能力有很大关系。下面的文章将详细介绍。</p><div class="pe pf gp gr pg ph"><a href="https://levelup.gitconnected.com/why-code-evolve-from-procedural-to-object-oriented-to-functional-programming-13a88292307e" rel="noopener  ugc nofollow" target="_blank"><div class="pi ab fo"><div class="pj ab pk cl cj pl"><h2 class="bd jd gy z fp pm fr fs pn fu fw jc bi translated">为什么代码从过程化到面向对象再到函数式编程</h2><div class="po l"><h3 class="bd b gy z fp pm fr fs pn fu fw dk translated">通过实际的代码示例学习不同风格的编程范式</h3></div><div class="pp l"><p class="bd b dl z fp pm fr fs pn fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="pq l"><div class="pr l ps pt pu pq pv lb ph"/></div></div></a></div><p id="198b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">简而言之，函数式编程通过提供一种将函数作为另一个函数或对象的参数的方式，增强了开发人员的体验。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pw"><img src="../Images/6f3641f3fba90c57b7f9bfca75a53e2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:874/format:webp/1*Ai8Hw04UDMDY0WX9l4SbsA.png"/></div></div></figure><p id="f722" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">没有注入函数的能力，执行函数完全依赖于依赖对象</p><pre class="ks kt ku kv gt os od ot ou aw ov bi"><span id="85f1" class="og ne it od b gy ow ox l oy oz">fun executionFunction() {<br/>    dependentObject.doSomething()<br/>}</span><span id="da94" class="og ne it od b gy pb ox l oy oz">class DependentObject {<br/>    func doSomething() { <br/>        x() // calling x within<br/>    }<br/><strong class="od jd">    fun x() { /* Do something */ }</strong><br/>}</span></pre><p id="8202" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">使用函数式编程，我们可以如下所示定义和注入函数。</p><pre class="ks kt ku kv gt os od ot ou aw ov bi"><span id="d025" class="og ne it od b gy ow ox l oy oz">fun executionFunction() {<br/><strong class="od jd">    fun x() { /* Do something */ }</strong><br/>    dependentObject.doSomething(::x)<br/>}</span><span id="335b" class="og ne it od b gy pb ox l oy oz">class DependentObject {<br/>    func doSomething(x: () -&gt; Unit) { <br/>        x() // calling x from executionFunction<br/>    }<br/>}</span></pre><p id="faf9" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如你所见，我们通过将函数注入其中，使执行函数<strong class="lk jd">独立依赖于依赖对象</strong>。</p><h2 id="56c6" class="og ne it bd nf oh oi dn nj oj ok dp nn lr ol om np lv on oo nr lz op oq nt iz bi translated">5.适配器设计模式</h2><p id="37ce" class="pw-post-body-paragraph li lj it lk b ll nv kd ln lo nw kg lq lr nx lt lu lv ny lx ly lz nz mb mc md im bi translated">这是四人帮的模式之一。它最初的目的是允许不兼容的接口一起工作。</p><p id="200c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">同时，adaptor模式也可以用来允许一个类的备用接口，使得一个类虽然依赖于，但也独立于被依赖者。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi px"><img src="../Images/424e5e09afbfd3bdc304672459f089e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:882/format:webp/1*DyGVoz_njrbETeRJ_G99_A.png"/></div></figure><p id="039a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果没有适配器，这个类将完全<strong class="lk jd">依赖于直接依赖的数据类型。这使得类和依赖者之间产生了强耦合。</strong></p><p id="1bab" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果接口的依赖方有任何变化，我们将需要直接修改类，这可能会涉及很多变化。</p><p id="d929" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">为了更好地保护类免受依赖项的修改，我们可以在类和依赖项之间设置一个适配器。这将保护类免受依赖者发生的任何变化。发生这种情况时，只需要更换适配器。</p><p id="21b6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">因此，从这里我们可以看到，<em class="pa">适配器设计模式</em>使得类<strong class="lk jd">独立于依赖者</strong>。</p><h2 id="9ff5" class="og ne it bd nf oh oi dn nj oj ok dp nn lr ol om np lv on oo nr lz op oq nt iz bi translated">6.后端对前端</h2><p id="77a2" class="pw-post-body-paragraph li lj it lk b ll nv kd ln lo nw kg lq lr nx lt lu lv ny lx ly lz nz mb mc md im bi translated">如今，在任何应用程序开发中，都有<strong class="lk jd">依赖</strong>来自服务器的服务。该服务为多个客户端提供服务。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi py"><img src="../Images/d5570105f6b96bad18e0f18fa8a6dbba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1134/format:webp/1*gIsivN-e-4UZckL9vWcbrw.png"/></div></figure><p id="e1b2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果服务器发生变化，两者都会发生变化。客户也必须改变。如果客户端是不能立即更改的移动应用程序，这就变得棘手了。</p><p id="2188" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">为了防止这个问题，目前一种常见的做法是在应用程序客户端和服务器之间实现后端对前端(BFF)。BFF就像一个迷你服务，作为应用程序客户端的代理。</p><p id="e898" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">服务器上的任何更改都被屏蔽在应用程序之外。人们只需要相应地修改BFF，而App客户端没有影响。</p><p id="4c88" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这使得应用客户端<strong class="lk jd">独立依赖于服务器</strong>。</p><h2 id="c0ce" class="og ne it bd nf oh oi dn nj oj ok dp nn lr ol om np lv on oo nr lz op oq nt iz bi translated">7.偏执的编码&amp;优雅的退出</h2><p id="e18d" class="pw-post-body-paragraph li lj it lk b ll nv kd ln lo nw kg lq lr nx lt lu lv ny lx ly lz nz mb mc md im bi translated">如果一个应用客户端依赖于一个服务(BFF或者直接依赖于服务器)，通常在定义接口之间有一个契约API，即什么是可空的，什么不是。</p><p id="f865" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然而，正如罗纳德·里根所说，“信任但要核实”。不能保证服务器会一直履行合同。如果有一天没有，应用程序可能会崩溃。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pz"><img src="../Images/fd70426bdb99887af6bee13b8a80fb55.png" data-original-src="https://miro.medium.com/v2/resize:fit:762/format:webp/1*h_C6xNipgxnPShHSBTEnZQ.png"/></div></figure><p id="d2f5" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">因此，有一种被称为偏执编码的编程方法，它将检查所有输入，即使已经有一个输入肯定会以某种方式运行的契约。一旦检查失败，它将优雅地退出应用程序。</p><p id="8d80" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">同样，在这里我们可以看到偏执编码如何使应用程序客户端更加独立于服务器，同时依赖于服务器，在应用程序端提供更安全的结果。另一种<strong class="lk jd">独立依赖</strong>的软件处理方式。</p></div><div class="ab cl qa qb hx qc" role="separator"><span class="qd bw bk qe qf qg"/><span class="qd bw bk qe qf qg"/><span class="qd bw bk qe qf"/></div><div class="im in io ip iq"><h1 id="5e60" class="nd ne it bd nf ng qh ni nj nk qi nm nn ki qj kj np kl qk km nr ko ql kp nt nu bi translated">最后</h1><p id="6b3b" class="pw-post-body-paragraph li lj it lk b ll nv kd ln lo nw kg lq lr nx lt lu lv ny lx ly lz nz mb mc md im bi translated">软件本质上比其他领域变化更快，因此简单的基于分区的解决方案通常不足以使软件更加通用。</p><p id="f9bf" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">由此，正如我们从上面看到的，许多软件设计正在应用基于<strong class="lk jd">独立依赖</strong>的解决方案来迎合软件既灵活又可靠的需求。</p><p id="ae75" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">以后当你卡在解决一个软件设计问题的时候，想想怎么才能独立依赖。你可能会找到一个有用的。</p></div></div>    
</body>
</html>