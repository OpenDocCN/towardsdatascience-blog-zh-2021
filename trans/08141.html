<html>
<head>
<title>3 Tips on Pandas Groupby Aggregation (vs SQL)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关于Pandas Groupby Aggregation (vs SQL)的3个提示</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/3-tips-on-pandas-groupby-vs-sql-e6f85b07d6f0?source=collection_archive---------31-----------------------#2021-07-26">https://towardsdatascience.com/3-tips-on-pandas-groupby-vs-sql-e6f85b07d6f0?source=collection_archive---------31-----------------------#2021-07-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="dd00" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何在Pandas groupby和aggregation中生成与SQL相同的输出</h2></div><p id="7e68" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">目录</strong></p><ul class=""><li id="8a65" class="lb lc iq kh b ki kj kl km ko ld ks le kw lf la lg lh li lj bi translated"><a class="ae lk" href="#5510" rel="noopener ugc nofollow">按每列汇总</a></li><li id="4e86" class="lb lc iq kh b ki ll kl lm ko ln ks lo kw lp la lg lh li lj bi translated"><a class="ae lk" href="#7d8b" rel="noopener ugc nofollow">按DataFrame.agg </a>聚合<strong class="kh ir">(推荐)</strong></li><li id="8592" class="lb lc iq kh b ki ll kl lm ko ln ks lo kw lp la lg lh li lj bi translated"><a class="ae lk" href="#1551" rel="noopener ugc nofollow">按字典和DataFrame.agg </a> <strong class="kh ir">(推荐)</strong></li></ul><h1 id="1afa" class="lq lr iq bd ls lt lu lv lw lx ly lz ma jw mb jx mc jz md ka me kc mf kd mg mh bi translated">1.介绍</h1><p id="f8a6" class="pw-post-body-paragraph kf kg iq kh b ki mi jr kk kl mj ju kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated"><strong class="kh ir">“创世纪做了任天堂做不到的事情”</strong>是20世纪90年代早期视频游戏市场上最经典但也是最有力的广告词之一。同样，<strong class="kh ir">“SQL做了熊猫做不到的事情”</strong>每当我面对熊猫的任何数据争论问题时，这一直困扰着我，而这些问题可以通过简单的SQL轻松解决。</p><p id="7046" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">作为一名仍在学习SQL和Python ML包的数据分析师新手，我一直在寻找一些方法来从一种语言到另一种语言产生相同的输出。我希望这篇文章可以至少在聚合函数方面证明上述断言是错误的，表明<strong class="kh ir">“Pandas做SQL所做的事情(在某些时候)”。</strong></p><p id="9a34" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这篇文章的目标是<strong class="kh ir">通过只使用Pandas </strong>来获得相同的SQL输出结果。我们将使用一个名为<code class="fe mn mo mp mq b">garments_simple</code>的简化数据集。原始数据集可以在UCI机器学习资源库(<a class="ae lk" href="https://archive-beta.ics.uci.edu/ml/datasets/597" rel="noopener ugc nofollow" target="_blank"> <strong class="kh ir">链接</strong> </a>)找到。</p><pre class="mr ms mt mu gt mv mq mw mx aw my bi"><span id="6ca1" class="mz lr iq mq b gy na nb l nc nd"><strong class="mq ir">SELECT</strong> team, sum(over_time) AS sum_over_time, max(over_time) AS max_over_time, mean(incentive) AS avg_incentive, max(incentive) AS max_incentive<br/><strong class="mq ir">FROM</strong> garments_simple<br/><strong class="mq ir">GROUPBY</strong> team</span></pre><p id="19fc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">输出包含<code class="fe mn mo mp mq b">over_time</code>的<code class="fe mn mo mp mq b">sum </code>和<code class="fe mn mo mp mq b">max </code>以及每个<code class="fe mn mo mp mq b">quarter</code>分组的<code class="fe mn mo mp mq b">incentive</code>的<code class="fe mn mo mp mq b">mean </code>和<code class="fe mn mo mp mq b">max </code>。</p><figure class="mr ms mt mu gt nf gh gi paragraph-image"><div role="button" tabindex="0" class="ng nh di ni bf nj"><div class="gh gi ne"><img src="../Images/98fa1f63cb8f5d4f958c48960cf8289e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QGupaqr3KftPVc3lw8NbMg.png"/></div></div><p class="nm nn gj gh gi no np bd b be z dk translated">Raw 'garment_simple '(左)-&gt; Output 'garment_agg '(右)</p></figure></div><div class="ab cl nq nr hu ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="ij ik il im in"><h1 id="5510" class="lq lr iq bd ls lt nx lv lw lx ny lz ma jw nz jx mc jz oa ka me kc ob kd mg mh bi translated">2.每列合计</h1><p id="a078" class="pw-post-body-paragraph kf kg iq kh b ki mi jr kk kl mj ju kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">这是聚合列的最简单和最容易的方法。</p><ul class=""><li id="5c25" class="lb lc iq kh b ki kj kl km ko ld ks le kw lf la lg lh li lj bi translated">优点:容易、简单、易读</li><li id="026a" class="lb lc iq kh b ki ll kl lm ko ln ks lo kw lp la lg lh li lj bi translated">缺点:可能会很冗长</li></ul><pre class="mr ms mt mu gt mv mq mw mx aw my bi"><span id="c5b6" class="mz lr iq mq b gy na nb l nc nd"><strong class="mq ir"># Make empty dataframe and groupby by quarter</strong><br/>garment_agg = pd.DataFrame()<br/>garment_group = garments_simple.groupby('quarter')</span><span id="bcfa" class="mz lr iq mq b gy oc nb l nc nd"><strong class="mq ir"># Aggregate per column</strong><br/>garment_agg['sum_over_time'] = garment_group['over_time'].sum()<br/>garment_agg['max_over_time'] = garment_group['over_time'].max()<br/>garment_agg['avg_incentive'] = garment_group['incentive'].mean()<br/>garment_agg['max_incentive'] = garment_group['incentive'].max()</span><span id="9a3e" class="mz lr iq mq b gy oc nb l nc nd"><strong class="mq ir"># Reset Index</strong><br/>garment_agg = garment_agg.reset_index()<br/>garment_agg</span></pre></div><div class="ab cl nq nr hu ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="ij ik il im in"><h1 id="7d8b" class="lq lr iq bd ls lt nx lv lw lx ny lz ma jw nz jx mc jz oa ka me kc ob kd mg mh bi translated">3.通过DataFrame.agg方法聚合</h1><p id="65f0" class="pw-post-body-paragraph kf kg iq kh b ki mi jr kk kl mj ju kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">第二种方法可能更适合聚合，因为它通过对象列包装聚合。</p><ul class=""><li id="fc92" class="lb lc iq kh b ki kj kl km ko ld ks le kw lf la lg lh li lj bi translated">优点:比第一种方法更简洁</li><li id="56f1" class="lb lc iq kh b ki ll kl lm ko ln ks lo kw lp la lg lh li lj bi translated"><strong class="kh ir">缺点:</strong>如果列太多，可能会很冗长</li></ul><pre class="mr ms mt mu gt mv mq mw mx aw my bi"><span id="ad9f" class="mz lr iq mq b gy na nb l nc nd"><strong class="mq ir"># Make empty dataframe and groupby by quarter</strong><br/>garment_agg = pd.DataFrame()<br/>garment_group = garments_simple.groupby('quarter')</span><span id="4e2d" class="mz lr iq mq b gy oc nb l nc nd"><strong class="mq ir"># Add new columns by using .agg method</strong><br/>garment_agg[['sum_over_time', 'max_over_time']] = garment_group['over_time'].agg(['sum','max'])</span><span id="9f7a" class="mz lr iq mq b gy oc nb l nc nd">garment_agg[['avg_incentive','max_incentive']] = garment_group['incentive'].agg(['mean','max'])</span><span id="df45" class="mz lr iq mq b gy oc nb l nc nd"><strong class="mq ir"># Reset Index</strong><br/>garment_agg = garment_agg.reset_index()<br/>garment_agg</span></pre></div><div class="ab cl nq nr hu ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="ij ik il im in"><h1 id="1551" class="lq lr iq bd ls lt nx lv lw lx ny lz ma jw nz jx mc jz oa ka me kc ob kd mg mh bi translated">4.按字典和DataFrame.agg聚合</h1><p id="67da" class="pw-post-body-paragraph kf kg iq kh b ki mi jr kk kl mj ju kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">最后一个方法是创建包含所有聚合对象列和函数的<code class="fe mn mo mp mq b">agg_dict</code>。您将能够根据<code class="fe mn mo mp mq b">agg_dict</code>立即执行聚合。</p><ul class=""><li id="2a46" class="lb lc iq kh b ki kj kl km ko ld ks le kw lf la lg lh li lj bi translated"><strong class="kh ir">优点:</strong>简洁，可读性强</li><li id="27d9" class="lb lc iq kh b ki ll kl lm ko ln ks lo kw lp la lg lh li lj bi translated"><strong class="kh ir">缺点:</strong>需要额外的一行来替换多索引列名</li></ul><pre class="mr ms mt mu gt mv mq mw mx aw my bi"><span id="50fe" class="mz lr iq mq b gy na nb l nc nd"><strong class="mq ir"># Make empty dataframe and groupby by quarter</strong><br/>garment_agg = pd.DataFrame()<br/>garment_group = garments_simple.groupby('quarter')</span><span id="ad69" class="mz lr iq mq b gy oc nb l nc nd"># Using dictionary to represent all the aggregation<br/>agg_dict = {<br/>    'over_time':['sum','max'],<br/>    'incentive':['mean','max']<br/>}</span><span id="f108" class="mz lr iq mq b gy oc nb l nc nd"><strong class="mq ir"># Aggregate all at once</strong><br/>garment_agg = garment_group.agg(agg_dict)<br/>garment_agg</span><span id="01ee" class="mz lr iq mq b gy oc nb l nc nd"><strong class="mq ir"># Replace multi-index to singular index</strong><br/>garment_agg.columns = [('_').join(column) for column in garment_agg.columns]<br/>garment_agg = garment_agg.reset_index()<br/>garment_agg</span></pre><h1 id="8359" class="lq lr iq bd ls lt lu lv lw lx ly lz ma jw mb jx mc jz md ka me kc mf kd mg mh bi translated">5.结论</h1><p id="ce5c" class="pw-post-body-paragraph kf kg iq kh b ki mi jr kk kl mj ju kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">熊猫<code class="fe mn mo mp mq b">groupby</code>和集合函数在特征工程中经常使用。考虑到其简单性，推荐使用最后两种<code class="fe mn mo mp mq b">DataFrame.agg</code>方法。希望这篇文章能帮助那些正在学习熊猫的人。</p><p id="1559" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">**完整的源代码可以在 这里找到<a class="ae lk" href="https://github.com/brandon-park/medium_article/tree/main/pandas_groupby_vs_sql" rel="noopener ugc nofollow" target="_blank"> <strong class="kh ir">。</strong></a></p></div></div>    
</body>
</html>