<html>
<head>
<title>Beginner Guide to Variational Autoencoders (VAE) with PyTorch Lightning (Part 3)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用PyTorch Lightning的可变自动编码器(VAE)初学者指南(第3部分)</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/beginner-guide-to-variational-autoencoders-vae-with-pytorch-lightning-part-3-9d686d0d85d9?source=collection_archive---------22-----------------------#2021-06-10">https://towardsdatascience.com/beginner-guide-to-variational-autoencoders-vae-with-pytorch-lightning-part-3-9d686d0d85d9?source=collection_archive---------22-----------------------#2021-06-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="080b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用最少的额外代码构建新模型</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/58bcef9e5a4d6e0094dee59a330b6c83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qZfv-O-jz2z6r4TG"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@agk42?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">亚历山大·奈特</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</p></figure><p id="6fc7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这篇博客文章是一个迷你系列的一部分，该系列讨论了使用可变自动编码器构建PyTorch深度学习项目的不同方面。</p><blockquote class="lv lw lx"><p id="2f73" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated"><a class="ae ky" rel="noopener" target="_blank" href="/beginner-guide-to-variational-autoencoders-vae-with-pytorch-lightning-13dbc559ba4b">第1部分</a>:数学基础与实现<br/> <a class="ae ky" rel="noopener" target="_blank" href="/beginner-guide-to-variational-autoencoders-vae-with-pytorch-lightning-part-2-6b79ad697c79">第2部分</a>:用PyTorch Lightning <br/> <a class="ae ky" rel="noopener" target="_blank" href="/beginner-guide-to-variational-autoencoders-vae-with-pytorch-lightning-part-3-9d686d0d85d9#1921-b4c73b02c87">增压第3部分</a>:卷积VAE、继承与单元测试<br/> <a class="ae ky" rel="noopener" target="_blank" href="/building-a-vae-playground-with-streamlit-aa88a3394c04">第4部分</a> : Streamlit Web App与部署</p></blockquote><p id="6558" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这一节中，我们将看看如何使用上一节中编写的代码来构建卷积VAE。这种VAE能更好地识别图像中的重要特征，从而生成更好的图像。</p><p id="f52a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最好的部分是，由于PyTorch模块和类继承，这个新模型可以用最少的额外代码来构建。</p><h1 id="76f5" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated"><strong class="ak">什么是卷积VAE？</strong></h1><p id="d572" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">卷积是图像处理中常用的一种操作，用于提取特定图像的特征。图像通常充满了不必要的信息，放大任何像素，周围的像素很可能有非常相似的颜色。在卷积神经网络(CNN)中，许多卷积滤波器被自动学习以获得在分类和识别图像时有用的特征。我们简单地借用这些原理来使用卷积层来构建VAE。</p><p id="944a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过构建卷积VAE，我们旨在获得更好的特征提取过程。即使我们不执行任何分类/回归任务，我们也希望潜在的表示尽可能地丰富信息。通过更强大的特征提取，解码器可以生成更有说服力的数据点。</p><p id="07fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">即使这个新模型使用了新的架构，我们也希望高效地编写代码。好的高效的代码使用<strong class="lb iu">干</strong>(不要重复自己)原则。为了避免不必要的重复代码，我们将使用继承这一强大的概念来构建我们的模型。</p><h1 id="cc0e" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated"><strong class="ak">什么是继承？</strong></h1><p id="8dad" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">继承是面向对象编程(OOP)语言中一个非常强大的概念。它允许用户定义对象，然后构建新对象，同时保留原始对象的一些功能。继承是一个非常广泛的话题，有些事情，比如多重继承，我就不详细介绍了。有关Python和继承中OOP编程的更多信息，请查看本文。</p><div class="mz na gp gr nb nc"><a href="https://realpython.com/inheritance-composition-python/" rel="noopener  ugc nofollow" target="_blank"><div class="nd ab fo"><div class="ne ab nf cl cj ng"><h2 class="bd iu gy z fp nh fr fs ni fu fw is bi translated">继承和组合:Python OOP指南-真正的Python</h2><div class="nj l"><h3 class="bd b gy z fp nh fr fs ni fu fw dk translated">继承和组合是面向对象编程中的两个主要概念，它们模拟了…</h3></div><div class="nk l"><p class="bd b dl z fp nh fr fs ni fu fw dk translated">realpython.com</p></div></div><div class="nl l"><div class="nm l nn no np nl nq ks nc"/></div></div></a></div><p id="289e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">实际上，继承是如此普遍，以至于我们已经在<a class="ae ky" rel="noopener" target="_blank" href="/beginner-guide-to-variational-autoencoders-vae-with-pytorch-lightning-13dbc559ba4b">第1部分</a>中使用了继承。甚至在不知道的情况下，继承在PyTorch中被广泛使用，其中每个神经网络都从基类<code class="fe nr ns nt nu b">nn.Module</code>继承。</p><p id="21b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我们只需要定义<code class="fe nr ns nt nu b">__init__ </code>和<code class="fe nr ns nt nu b">forward</code>方法，剩下的工作由基类来完成。我们将要构建的模型将进一步推进这一步，并建立在上一节构建的VAE的基础上。</p><p id="1910" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">继承允许我们在不同的阶段建立复杂的模型。我们之前建立的VAE模型充当了骨架。它执行重新参数化并实现KL-散度损失。</p><p id="fdb8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们可以继承这个类，创建一个更好的模型，使用一个更适合这个任务的架构。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nv"><img src="../Images/316cb300723bb94405d7044582724378.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WyO9rJlS5efVmn6Zahbqiw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">conv·VAE继承了VAE的所有方法，然后改写了编码器和解码器。作者图片</p></figure><p id="e6dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后可以通过改变编码器和解码器来修改该模型。编码器简单地进行表示学习，解码器进行生成。这些子网可以是简单的线性层，也可以是复杂的网络。</p><p id="036f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的卷积VAE中，我们希望改变这些组件，同时保持所有其他组件不变。使用继承可以很容易做到这一点</p><p id="56b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这允许我们避免重复大量的代码。像<code class="fe nr ns nt nu b">forward</code>、<code class="fe nr ns nt nu b">training_step</code>、<code class="fe nr ns nt nu b">train_loader </code>这样的类方法将保持完全相同，继承允许我们自动复制它们。</p><h1 id="2459" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated"><strong class="ak">代码重构</strong></h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nw"><img src="../Images/561ef81a8e3cd1255010a6851bc596d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*GG63GCqOBxl7Mlb0"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@garett3?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Garett Mizunaka </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="e1c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你仔细观察，在之前的模型中。向前的步骤包括在将向量送入编码器之前将其展平。对于卷积VAE，我们不想做这种展平，因为它会阻止我们2D卷积。</p><p id="1f3b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">似乎要使继承工作，我们需要做一些代码重构！</p><p id="b566" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从本质上讲，代码重构是在保持外部功能不变的情况下对代码进行一些修改。这意味着代码在输入和输出方面仍然具有相同的行为。重构可以使代码运行得更快，或者在我们的例子中，简化代码，以便我们可以在其他地方重用它。</p><p id="b1e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以重构我们的代码，而不是重写整个前进步骤，这样输入张量的展平和将其整形回28 x 28发生在<code class="fe nr ns nt nu b">self.encoder</code>和<code class="fe nr ns nt nu b">self.decoder</code>内，而不是在前进函数内。</p><p id="b927" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这使得该模型更加通用，因为它可以适应不同的编码器，例如卷积，其中我们不想平坦化输入向量。</p><h1 id="b6df" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated"><strong class="ak">单元测试</strong></h1><p id="402f" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">但是坚持住！我们先不要做重构。您希望发生的最糟糕的事情是，当您更改代码时，您的模型会崩溃。我们希望确保VAE模型在重构后仍然做完全相同的事情。</p><p id="7d21" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">确保您的项目在更改后仍然可用的一个好方法是编写单元测试。</p><p id="331b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">单元测试是简单的脚本，您可以运行它来确保您的代码正常工作。在我们的模型中，这是为了确保我们建立的模型仍然能够训练，梯度仍然能够很好地反向传播。</p><p id="035b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为此，我们将使用pytest，这是一个用于编写单元测试的强大库，它还包含有用的调试工具来找出测试失败的原因。</p><p id="3d86" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们在目录中创建一个名为<code class="fe nr ns nt nu b">tests</code>的文件夹。在这个文件夹中，我们创建了一个名为<code class="fe nr ns nt nu b">test_model.py</code>的文件。这将存储所有需要的单元测试。</p><p id="41a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们定义一个简单的测试:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="da73" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">pytest的另一个很酷的特性是它会自动搜索包中的测试函数。只要函数名以<code class="fe nr ns nt nu b">test</code>开头，pytest就会相应地运行测试。</p><p id="74c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过在命令行中运行<code class="fe nr ns nt nu b">pytest</code>，我们可以确认测试通过。</p><h1 id="3774" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated"><strong class="ak"> Pytorch模块化</strong></h1><p id="e884" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">现在有了合适的测试系统，我们可以开始修改代码了。</p><p id="a735" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关于PyTorch模块，需要理解的一件重要事情是，它们基本上是函数。当一个输入被传递给任何PyTorch模块时，它只是运行一些操作，然后将渐变反向传播。</p><p id="70b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这意味着即使简单的整形操作也可以初始化为PyTorch对象。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">展平模块</p></figure><p id="48ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们简单地将旧的forward函数的第一行作为一个模块添加进去。通过这种方式，将<code class="fe nr ns nt nu b">Flatten()</code>作为一个模块放在编码器中可以实现同样的目的。</p><p id="4549" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们为堆栈模块编写代码。对于MNIST数据集，该模块将张量整形回其原始形状(1，28，28)</p><p id="0c26" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的例子中，因为图像是黑白的，所以只有一个通道，但是让我们构建一个堆栈模块，它也可以处理彩色图像。</p><p id="4d0e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为此，我们必须将关于数据集的信息存储到模型本身中。这是通过将数据的原始形状作为参数传递给模块来实现的。这些参数是通道、高度和宽度。前进操作将是一个类似于展平模块的<code class="fe nr ns nt nu b">view</code>操作。</p><p id="338a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了存储这些参数，我们需要使用<strong class="lb iu"> __init__ </strong>函数。这允许我们将这些参数存储为类变量。为此，我们首先将其初始化为PyTorch模块，这是通过调用<code class="fe nr ns nt nu b">__init__</code>函数中的<code class="fe nr ns nt nu b">super(self,Stack).__init__() </code>来完成的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">堆栈模块</p></figure><p id="cc6e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">既然我们已经将这些整形函数抽象成它们自己的对象，我们可以使用<code class="fe nr ns nt nu b">nn.Sequential</code>将这些操作定义为编码器和解码器模块的一部分。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">新VAE法典</p></figure><p id="7e67" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就像整形操作是<code class="fe nr ns nt nu b">self.encoder</code>和<code class="fe nr ns nt nu b">self.decoder</code>的一部分一样</p><p id="f539" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们运行单元测试来检查代码是否有效。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/28f3dbfd2a43f26a3312f90c2f633869.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wybDJSYTh_6EdJVrxATaqQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="4551" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不错！测试通过，代码按预期运行。</p><div class="mz na gp gr nb nc"><a href="https://docs.pytest.org/en/6.2.x/" rel="noopener  ugc nofollow" target="_blank"><div class="nd ab fo"><div class="ne ab nf cl cj ng"><h2 class="bd iu gy z fp nh fr fs ni fu fw is bi translated">帮助你编写更好的程序</h2><div class="nj l"><h3 class="bd b gy z fp nh fr fs ni fu fw dk translated">pytest和数以千计的其他软件包的维护者正在与Tidelift合作，以提供商业支持和…</h3></div><div class="nk l"><p class="bd b dl z fp nh fr fs ni fu fw dk translated">docs.pytest.org</p></div></div><div class="nl l"><div class="oa l nn no np nl nq ks nc"/></div></div></a></div></div><div class="ab cl ob oc hx od" role="separator"><span class="oe bw bk of og oh"/><span class="oe bw bk of og oh"/><span class="oe bw bk of og"/></div><div class="im in io ip iq"><p id="4d9a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">构建卷积编码器</strong></p><p id="0f9c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了这些改动，我们就可以开始建造VAE conv了。让我们从编码器开始。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">conv·VAE的编码器和__init__函数</p></figure><p id="d225" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">编码器的第一部分是<code class="fe nr ns nt nu b">Conv2d</code>层的连续步骤以及<code class="fe nr ns nt nu b">ReLU</code>激活和<code class="fe nr ns nt nu b">BatchNorm2d</code>以帮助加速训练。该步骤在降低维度的同时执行特征提取。</p><p id="7d73" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下一步是展平步骤，将矢量转换回一维。VAE中的潜在代表是一个单一的向量，我们需要得到相同形状的输入。这可以使用我们之前定义的<code class="fe nr ns nt nu b">Flatten()</code>模块来完成。只要从VAE文件中导入它，我们就可以在编码器中使用它。</p><p id="4a9f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">继续看解码器</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">conv·VAE的解码器网络</p></figure><p id="c7de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">解码器的架构非常相似。基本上是一样的，只是方向相反。</p><p id="1db0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">1.前馈层<code class="fe nr ns nt nu b">(nn.Linear)</code></p><p id="52c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">2.<code class="fe nr ns nt nu b">Stack</code>将线性层转换为带通道的2d形状的模块</p><p id="c80f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">3.<code class="fe nr ns nt nu b">ConvTranspose2d</code>对图像进行增采样并生成具有更大高度和宽度的图像的图层。(与Conv2d相反)</p><p id="45f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">4.<code class="fe nr ns nt nu b">Conv2d</code>层清理最终输出</p><p id="7da1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最终层应该输出与原始形状具有相同尺寸的东西，并且MSE损失可以很容易地应用。</p><p id="a262" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">信不信由你，我们结束了！默认情况下，Python类将继承所有的方法，因此除了<code class="fe nr ns nt nu b">__init__ </code>之外的所有其他函数都不必重新定义。这意味着从培训、验证甚至<code class="fe nr ns nt nu b">save_images</code>的一切都将自动呈现在新的Conv VAE中使用。</p><h1 id="952b" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结果！</h1><div class="kj kk kl km gt ab cb"><figure class="oi kn oj ok ol om on paragraph-image"><img src="../Images/1624b8eb9a33e676686049067e00d3f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:484/format:webp/1*0yLwZQEs6b8Ni40SqfQqzA.png"/></figure><figure class="oi kn oj ok ol om on paragraph-image"><img src="../Images/509b6142a73e9047c38342ca8d02a89c.png" data-original-src="https://miro.medium.com/v2/resize:fit:484/format:webp/1*IehFZMwkdjP3-vnSRL3spA.png"/><p class="ku kv gj gh gi kw kx bd b be z dk oo di op oq translated">图片来自香草VAE(左)和卷积VAE(右)。作者图片</p></figure></div><p id="f1a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">卷积VAE产生的图像似乎更清晰，图像中有更多的可变性。尽管使用相同的潜在空间维度，新模型能够捕捉和重建显示更多变化的图像。这显示了改进的编码器-解码器网络的能力，并且当应用于彩色图像时，这种差异将更加显著。</p><p id="e917" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下一节(也是最后一节),我将着眼于将模型完全部署到Heroku上所需的步骤，并创建一个与它们交互的平台！</p></div></div>    
</body>
</html>