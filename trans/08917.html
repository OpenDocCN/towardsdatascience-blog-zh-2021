<html>
<head>
<title>Give wings to Python — Simple tricks towards faster Python Programs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">给Python插上翅膀——实现更快Python程序的简单技巧</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/give-wings-to-python-make-it-fly-6eb4d4859b89?source=collection_archive---------16-----------------------#2021-08-17">https://towardsdatascience.com/give-wings-to-python-make-it-fly-6eb4d4859b89?source=collection_archive---------16-----------------------#2021-08-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="627f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">编写优化且更快的Python程序的策略汇编</h2></div><p id="5580" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Python不是特别快，但它是最受欢迎的编码语言之一，尤其是在数据分析方面。有趣的是，使它天生缓慢的原因也使它成为最受欢迎的语言。</p><ol class=""><li id="89a9" class="le lf it kk b kl km ko kp kr lg kv lh kz li ld lj lk ll lm bi translated"><strong class="kk iu">动态类型化</strong> —用户不必提供变量的数据类型。这让用户的生活更轻松，但给解释者带来了麻烦。</li><li id="ce61" class="le lf it kk b kl ln ko lo kr lp kv lq kz lr ld lj lk ll lm bi translated"><strong class="kk iu">已解释，未编译</strong> — Python被解释为未编译，这意味着它不能提前对程序进行内存和速度的高级优化。</li><li id="43a1" class="le lf it kk b kl ln ko lo kr lp kv lq kz lr ld lj lk ll lm bi translated"><strong class="kk iu">内存问题</strong>——由于Python的灵活性，每个元素都有自己的内存，而不是一个连续的内存块。它会在提取操作过程中造成时间延迟</li></ol><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="gh gi ls"><img src="../Images/b9b823b3636401093c3e38dd13befe8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ebXf-Y0UdcFjNYdNBwgkYg.jpeg"/></div></div><p class="me mf gj gh gi mg mh bd b be z dk translated">资料来源:联合国人类住区规划署</p></figure><p id="b629" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">尽管有这些问题，我相信大多数缓慢进入系统可以归因于程序员编写简洁、优化程序的能力。这些年来，我在处理数据、构建模型、将<em class="mi">不那么优化的</em>代码投入生产的时候犯了很多错误。但是所有这些经历为我提供了一些工具，我一直用这些工具来使我的代码更干净、更快、更pythonic化(不管那意味着什么)。</p><p id="d89a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们看看那是什么。</p><h1 id="d515" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">创可贴解决方案</h1><p id="ea78" class="pw-post-body-paragraph ki kj it kk b kl nb ju kn ko nc jx kq kr nd kt ku kv ne kx ky kz nf lb lc ld im bi translated">如果你有很多时间，那么你可以把你的Python代码转换成C/C++，然后在上面写一个Python包装器。它将为您提供C++的速度，并保持Python的易用性。</p><p id="49e1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是，我们不希望这样，因为有更简单的解决方案。</p><p id="de78" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Numba走进房间。</p><p id="89f7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">好吧，我告诉你Numba从2012年就开始出现了，但对许多程序员来说仍然是难以捉摸的。</p><p id="5342" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它本质上是把你的Python代码转换成机器码，速度和C代码差不多。</p><p id="3f27" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们用一个简单的例子来验证一下。一个简单的功能，没什么重的。</p><figure class="lt lu lv lw gt lx"><div class="bz fp l di"><div class="ng nh l"/></div></figure><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="gh gi ni"><img src="../Images/d4a666a8459d2664c469740b23acdbca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hNDPNOu9Yqx3ckzsEG8KlA.png"/></div></div></figure><p id="6770" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在具有6个内核的i7机器上，每循环1.43秒。看起来很慢，但肯定可以改进。</p><p id="501e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用pip在您的机器上安装numba</p><pre class="lt lu lv lw gt nj nk nl nm aw nn bi"><span id="b3aa" class="no mk it nk b gy np nq l nr ns">pip install numba</span></pre><figure class="lt lu lv lw gt lx"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="6fe7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们所做的只是添加了两行代码，import和@jit(nopython=True)</p><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="gh gi nt"><img src="../Images/9033f5d32d989146c47bca1431e2f028.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QWMxqHVue7-myxE61YQvgA.png"/></div></div></figure><p id="3d23" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">每循环14.5毫秒。</p><p id="3a62" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">那就是1430/14.5 ~ 98X的速度增益。</p><p id="86b0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">收益当然取决于你的机器和你到底想做什么，但如果你想快速解决问题而又不想过多地陷入代码的罪恶中，这是一个很好的起点。</p><ul class=""><li id="b039" class="le lf it kk b kl km ko kp kr lg kv lh kz li ld nu lk ll lm bi translated">它通常在你不得不处理令人烦恼的循环时起作用</li></ul><p id="0a90" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">或者，</p><ul class=""><li id="5cd5" class="le lf it kk b kl km ko kp kr lg kv lh kz li ld nu lk ll lm bi translated">其中需要对大集合执行相同的操作。</li></ul><h1 id="c9b8" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">侧写师</h1><p id="d20b" class="pw-post-body-paragraph ki kj it kk b kl nb ju kn ko nc jx kq kr nd kt ku kv ne kx ky kz nf lb lc ld im bi translated">您需要找出代码的哪一部分使它变慢了。在大多数情况下，这将是一些错误形成的循环或函数，这将是麻烦制造者。</p><h2 id="0ca0" class="no mk it bd ml nv nw dn mp nx ny dp mt kr nz oa mv kv ob oc mx kz od oe mz of bi translated">Unix计时器</h2><p id="535a" class="pw-post-body-paragraph ki kj it kk b kl nb ju kn ko nc jx kq kr nd kt ku kv ne kx ky kz nf lb lc ld im bi translated">在shell上，在调用python和您的代码之前，您需要使用Unix的time命令。</p><figure class="lt lu lv lw gt lx"><div class="bz fp l di"><div class="ng nh l"/></div></figure><h2 id="b8dd" class="no mk it bd ml nv nw dn mp nx ny dp mt kr nz oa mv kv ob oc mx kz od oe mz of bi translated">cProfiler</h2><p id="a3bd" class="pw-post-body-paragraph ki kj it kk b kl nb ju kn ko nc jx kq kr nd kt ku kv ne kx ky kz nf lb lc ld im bi translated">您可以从shell中运行cProfiler，方法是调用</p><pre class="lt lu lv lw gt nj nk nl nm aw nn bi"><span id="b044" class="no mk it nk b gy np nq l nr ns">python -m cProfile -s time name_of_your_file.py</span></pre><p id="39fb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它会让你淹没在大量的信息中，所以你需要做些别的事情。</p><p id="4056" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可以在代码中导入cProfile，并在您怀疑会使您陷入困境的函数上运行它。</p><pre class="lt lu lv lw gt nj nk nl nm aw nn bi"><span id="e27e" class="no mk it nk b gy np nq l nr ns">import cProfile<br/>cProfile.run('complicated_func()') #<em class="mi">Here I am running it on a complicated_function that has time overheads.</em></span></pre><p id="c853" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">输出可以放在文件中，也可以在shell上看到。</p><pre class="lt lu lv lw gt nj nk nl nm aw nn bi"><span id="0376" class="no mk it nk b gy np nq l nr ns">cProfile.run('complicated_func()', 'output.txt')</span></pre><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="gh gi og"><img src="../Images/2a726fd3dc55932d68f1446c5e04b38a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I9rE2mmm6__-fMwCRw9jtA.png"/></div></div></figure><h1 id="185e" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">舒马赫速度</h1><p id="05b5" class="pw-post-body-paragraph ki kj it kk b kl nb ju kn ko nc jx kq kr nd kt ku kv ne kx ky kz nf lb lc ld im bi translated">到目前为止，它是关于创可贴解决方案以及如何对您的代码进行时间配置，让我们来看看某些策略，它们不仅是最佳实践，而且还能为您加快速度。</p><h2 id="34ed" class="no mk it bd ml nv nw dn mp nx ny dp mt kr nz oa mv kv ob oc mx kz od oe mz of bi translated">发电机节省内存，提高速度</h2><p id="1b29" class="pw-post-body-paragraph ki kj it kk b kl nb ju kn ko nc jx kq kr nd kt ku kv ne kx ky kz nf lb lc ld im bi translated">列表是很好的，但是如果你正在处理一些需要延迟生成的列，那么生成器会更好。</p><figure class="lt lu lv lw gt lx"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="f63e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用生成器带来的性能提升是延迟(按需)值生成的结果，这意味着更低的内存使用率。此外，我们不需要等到所有的元素都生成之后才开始使用它们。</p><p id="6656" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面的代码片段为列表使用了87，616字节的内存，而生成器只使用了112字节的内存<strong class="kk iu">。</strong></p><p id="bde6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="mi">节省下来的内存可以让你的代码运行得更快，因为CPU正在处理的所有数据都应该在缓存中；如果使用列表，那么数据溢出到L1缓存的可能性更大。</em></p><h2 id="6600" class="no mk it bd ml nv nw dn mp nx ny dp mt kr nz oa mv kv ob oc mx kz od oe mz of bi translated"><strong class="ak">范围内的枚举</strong></h2><p id="9f80" class="pw-post-body-paragraph ki kj it kk b kl nb ju kn ko nc jx kq kr nd kt ku kv ne kx ky kz nf lb lc ld im bi translated">这更多的是一个<strong class="kk iu"> <em class="mi">干净代码</em> </strong>的原则，而不是与速度有关。如果您不仅需要处理数据的索引，还需要处理数据本身，那么在Python 3.8上，enumerate是一个更干净、更好、也更快的选择。</p><figure class="lt lu lv lw gt lx"><div class="bz fp l di"><div class="ng nh l"/></div></figure><h2 id="89c8" class="no mk it bd ml nv nw dn mp nx ny dp mt kr nz oa mv kv ob oc mx kz od oe mz of bi translated">进口</h2><p id="7eb9" class="pw-post-body-paragraph ki kj it kk b kl nb ju kn ko nc jx kq kr nd kt ku kv ne kx ky kz nf lb lc ld im bi translated">如果你打算只使用一个函数，不要导入整个库和包。</p><pre class="lt lu lv lw gt nj nk nl nm aw nn bi"><span id="9a63" class="no mk it nk b gy np nq l nr ns">import math<br/>value = math.sqrt(50)</span><span id="28c0" class="no mk it nk b gy oh nq l nr ns">vs</span><span id="280d" class="no mk it nk b gy oh nq l nr ns">from math import sqrt<br/>value = sqrt(50)</span></pre><p id="8a97" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当编写生产级代码时，如此小的开销累积起来会达到惊人的比例。</p><h2 id="36bc" class="no mk it bd ml nv nw dn mp nx ny dp mt kr nz oa mv kv ob oc mx kz od oe mz of bi translated">明智地使用Itertools</h2><p id="9d2a" class="pw-post-body-paragraph ki kj it kk b kl nb ju kn ko nc jx kq kr nd kt ku kv ne kx ky kz nf lb lc ld im bi translated">尽可能使用itertools，它们可以节省大量时间，尤其是在避免for循环方面。</p><pre class="lt lu lv lw gt nj nk nl nm aw nn bi"><span id="d3c5" class="no mk it nk b gy np nq l nr ns">from itertools import product</span><span id="3304" class="no mk it nk b gy oh nq l nr ns">def cartesian_prod (arr1, arr2):<br/>    return list(product(arr1, arr2))</span><span id="6830" class="no mk it nk b gy oh nq l nr ns">arr1 = [1,2,3]<br/>arr2 = [4,5,6]<br/>cartesian_prod(arr1, arr2)<br/></span><span id="60ce" class="no mk it nk b gy oh nq l nr ns"># Output is<br/>[(1, 4), (1, 5), (1, 6), (2, 4), (2, 5), (2, 6), (3, 4), (3, 5), (3, 6)]</span></pre><p id="afac" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您正在处理一个问题陈述，比如推荐系统，并且想要用户项的组合，那么通过itertools计算笛卡尔积是一个明智而安全的选择。</p><p id="fb2d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">人们还可以使用itertools的排列组合功能来减轻生活中的一些痛苦。</p><h2 id="ce40" class="no mk it bd ml nv nw dn mp nx ny dp mt kr nz oa mv kv ob oc mx kz od oe mz of bi translated">只用f弦系住你的琴弦</h2><p id="283a" class="pw-post-body-paragraph ki kj it kk b kl nb ju kn ko nc jx kq kr nd kt ku kv ne kx ky kz nf lb lc ld im bi translated">不要对字符串使用任何旧的方法，比如%s或format()，f字符串非常快，而且更容易使用</p><figure class="lt lu lv lw gt lx"><div class="bz fp l di"><div class="ng nh l"/></div></figure><h2 id="8653" class="no mk it bd ml nv nw dn mp nx ny dp mt kr nz oa mv kv ob oc mx kz od oe mz of bi translated">传统for循环的列表理解</h2><p id="f1d5" class="pw-post-body-paragraph ki kj it kk b kl nb ju kn ko nc jx kq kr nd kt ku kv ne kx ky kz nf lb lc ld im bi translated">一般来说，for循环(至少比while循环好)很慢，如果你开始使用两个嵌套循环，那么复杂度将会是n。</p><figure class="lt lu lv lw gt lx"><div class="bz fp l di"><div class="ng nh l"/></div></figure><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="gh gi oi"><img src="../Images/aedc1c5ab870755e11db287175a51cf6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mvQNjBdedQKNFk2EASEjcw.png"/></div></div></figure><p id="05e9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于传统的For循环，时间是136毫秒</p><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="gh gi oj"><img src="../Images/c771c5cee7db10201ca4107e3ce96d9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*onu81i6assHLs6zhjBq-9Q.png"/></div></div></figure><p id="8b5a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于列表理解，它是118毫秒</p><blockquote class="ok"><p id="0077" class="ol om it bd on oo op oq or os ot ld dk translated">这不是一个很大的改进，但是代码看起来更干净，并且只用一行代码就完成了。</p></blockquote><p id="f468" class="pw-post-body-paragraph ki kj it kk b kl ou ju kn ko ov jx kq kr ow kt ku kv ox kx ky kz oy lb lc ld im bi translated">类似地，使用<a class="ae oz" href="https://www.learnpython.org/en/Map,_Filter,_Reduce" rel="noopener ugc nofollow" target="_blank"> <em class="mi"> map、filter和reduce </em> </a>函数可以减轻代码的时间和空间复杂度。</p><figure class="lt lu lv lw gt lx"><div class="bz fp l di"><div class="pa nh l"/></div><p class="me mf gj gh gi mg mh bd b be z dk translated">资料来源:Giphy</p></figure><h2 id="f4bb" class="no mk it bd ml nv nw dn mp nx ny dp mt kr nz oa mv kv ob oc mx kz od oe mz of bi translated">你的硬件是什么？</h2><p id="08b3" class="pw-post-body-paragraph ki kj it kk b kl nb ju kn ko nc jx kq kr nd kt ku kv ne kx ky kz nf lb lc ld im bi translated">十有八九，你可能在SSD(固态硬盘)上运行你的代码。如果你已经达到专业水平的python编程，那么你检查SFrames，可伸缩框架的缩写。它们在固态硬盘上的大型数据集上工作得非常好，比熊猫好得多。</p><p id="5152" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">人们可以使用turicreate(graph lab的免费版本)在代码中使用SFrame。</p><h1 id="f408" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">结论</h1><p id="e79b" class="pw-post-body-paragraph ki kj it kk b kl nb ju kn ko nc jx kq kr nd kt ku kv ne kx ky kz nf lb lc ld im bi translated">有许多方法可以优化代码的性能。所有上述策略都经过了尝试和测试，但它们不是快速解决问题或万无一失的解决方案，因为它们在某种程度上取决于您运行它的数据和您使用的硬件。</p><blockquote class="ok"><p id="b8ef" class="ol om it bd on oo op oq or os ot ld dk translated">还有许多其他方法，如使用局部变量、并发和多线程，也有助于实现更快的速度。</p></blockquote><p id="362f" class="pw-post-body-paragraph ki kj it kk b kl ou ju kn ko ov jx kq kr ow kt ku kv ox kx ky kz oy lb lc ld im bi translated">编码时，遵循最佳实践，而不是抄近路，因为生产环境非常敏感，您不希望花费无数时间回顾您在亿万年前编写的东西。</p><p id="a519" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">通常在代码库的可读性和优化之间有一个折衷。孰先孰后的决定取决于你。</p></div></div>    
</body>
</html>