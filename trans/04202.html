<html>
<head>
<title>Query folding in Power BI — tricks, lies &amp; ultimate performance test</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Power BI中的查询折叠—技巧、谎言和最终性能测试</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/query-folding-in-power-bi-tricks-lies-ultimate-performance-test-879cafcf6cf8?source=collection_archive---------15-----------------------#2021-04-09">https://towardsdatascience.com/query-folding-in-power-bi-tricks-lies-ultimate-performance-test-879cafcf6cf8?source=collection_archive---------15-----------------------#2021-04-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="08aa" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在查询折叠系列的最后一部分，学习更多技巧，找出视图本地查询所在的时间，最后找出(不)折叠的查询之间的差异，由实数支持</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/fed80a9e673c2ea599b8f57347e5866f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BtJEHNuylUt1OnGpvJvvjg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://www.pexels.com/photo/ace-bet-blackjack-business-534181/" rel="noopener ugc nofollow" target="_blank">https://www . pexels . com/photo/ace-bet-black jack-business-534181/</a></p></figure><blockquote class="kz la lb"><p id="970a" class="lc ld le lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">"这会破坏查询折叠吗？"“您的查询会折叠吗？”…也许有人问过你这些问题，但你会说:“问…什么？!"</p><p id="190b" class="lc ld le lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">或者，您可能听说过Power BI中的查询折叠，但不知道如何在现实生活中利用它。</p><p id="0949" class="lc ld le lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">如果你认识到自己处于(至少)上述两种情况中的一种，那么请继续阅读这篇简短的系列博文！</p></blockquote><ul class=""><li id="fabe" class="lz ma it lf b lg lh lj lk mb mc md me mf mg ly mh mi mj mk bi translated"><a class="ae ky" rel="noopener" target="_blank" href="/what-is-a-query-folding-in-power-bi-and-why-should-i-care-5b89f42f38d7">第1部分——什么是Power BI中的查询折叠，我为什么要关心？</a></li><li id="46ae" class="lz ma it lf b lg ml lj mm mb mn md mo mf mp ly mh mi mj mk bi translated"><a class="ae ky" rel="noopener" target="_blank" href="/query-folding-in-power-bi-devil-is-in-the-detail-d564ab0cb32">第2部分—查询折叠—细节决定成败！</a></li></ul><p id="0e81" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll mb ln lo lp md lr ls lt mf lv lw lx ly im bi translated">我假设您现在已经熟悉了Power BI中查询折叠的概念，尤其是它对于数据刷新和增量刷新过程的重要性。我们也已经开始研究Power Query转换的一些有趣的行为，在这个系列的最后一部分，我将向您展示一些更有趣的发现。</p><p id="f3e2" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll mb ln lo lp md lr ls lt mf lv lw lx ly im bi translated">最后，我们将用最终的性能测试来结束它——我将向您展示两个相同查询背后的确切数字——一个折叠，另一个不折叠！</p><h2 id="3c79" class="mq mr it bd ms mt mu dn mv mw mx dp my mb mz na nb md nc nd ne mf nf ng nh ni bi translated">更改数据类型</h2><p id="34bb" class="pw-post-body-paragraph lc ld it lf b lg nj ju li lj nk jx ll mb nl lo lp md nm ls lt mf nn lw lx ly im bi translated">Power Query中最常见的转换之一是更改数据类型。在您的数据模型中使用适当的数据类型是一个众所周知的<a class="ae ky" rel="noopener" target="_blank" href="/how-to-reduce-your-power-bi-model-size-by-90-76d7c4377f2d">最佳实践——例如，如果您的报告中不需要小时、分钟和秒级别的粒度，您应该更好地摆脱它们，并将该列的数据类型从日期/时间更改为仅日期。</a></p><p id="5068" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll mb ln lo lp md lr ls lt mf lv lw lx ly im bi translated">然而，通往地狱的道路是由良好的意图铺成的:)…因此，让我向您展示一个细微的差异，它会导致您的查询变得非常慢，即使您坚持使用正确的数据类型的建议！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/ca114cc74afb14975377eefae4a02cbd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XyO0v_1GfUVo-eDQw6ixgQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="a557" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll mb ln lo lp md lr ls lt mf lv lw lx ly im bi translated">如上图所示，我的OrderDate列属于日期/时间数据类型。我想把它切换到日期。有(至少)两个可能的选项可以做到这一点—第一个是右键单击该列，展开“更改类型”选项的下拉列表(就像我在插图中所做的那样)，然后选择“日期类型”(就在日期/时间下方):</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/7d5b05c4cfca8c3bac12403c9e633316.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8B2Q3i5xMAjAFszxL6t3dw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="dd71" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll mb ln lo lp md lr ls lt mf lv lw lx ly im bi translated">这里发生了一些重要的事情，让我来解释一下:</p><ol class=""><li id="9777" class="lz ma it lf b lg lh lj lk mb mc md me mf mg ly np mi mj mk bi translated">在Applied Steps窗格中，您可以注意到我们的转换步骤已经被记录下来</li><li id="de21" class="lz ma it lf b lg ml lj mm mb mn md mo mf mp ly np mi mj mk bi translated">在该列中，您可以看到时间部分消失了</li><li id="af67" class="lz ma it lf b lg ml lj mm mb mn md mo mf mp ly np mi mj mk bi translated">当我打开View Native Query对话框时，您可以看到Mashup引擎很好地将我们的转换转换成了T-SQL <em class="le"> CONVERT() </em>函数</li><li id="124b" class="lz ma it lf b lg ml lj mm mb mn md mo mf mp ly np mi mj mk bi translated">应用于这个转换步骤的M公式是:<em class="le">表。TransformColumnTypes() </em></li></ol><p id="acda" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll mb ln lo lp md lr ls lt mf lv lw lx ly im bi translated">现在让我们检查更改列的数据类型的另一个选项:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/c1293eb9d7a5f5175762c95338360c32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FNKntbp-TnklBDLM-tYNeQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="242d" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll mb ln lo lp md lr ls lt mf lv lw lx ly im bi translated">就在我们之前的变更类型选项下面，有一个转换选项。展开下拉列表后，您可以看到“仅日期”转换。让我们点击它，看看会发生什么:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/31ec15970c626662860cabbe87f67080.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7tkHzCAv95fICAFnNMFUyg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="8ab7" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll mb ln lo lp md lr ls lt mf lv lw lx ly im bi translated">看起来很相似，是吗？但是，让我们再次回顾一下现在发生的所有事情:</p><ol class=""><li id="872a" class="lz ma it lf b lg lh lj lk mb mc md me mf mg ly np mi mj mk bi translated">我们现在有一个称为提取日期的步骤，而不是更改类型的步骤</li><li id="b388" class="lz ma it lf b lg ml lj mm mb mn md mo mf mp ly np mi mj mk bi translated">该列本身看起来与上一个示例完全相同，没有时间部分</li><li id="a59a" class="lz ma it lf b lg ml lj mm mb mn md mo mf mp ly np mi mj mk bi translated">不对不对，查询不再折叠了！正如您所看到的，查看本地查询选项是灰色的！</li><li id="e073" class="lz ma it lf b lg ml lj mm mb mn md mo mf mp ly np mi mj mk bi translated">这个时候，M公式适用的是:<em class="le">表。TransformColumns() </em></li></ol><p id="62c4" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll mb ln lo lp md lr ls lt mf lv lw lx ly im bi translated">所以，M公式(<em class="le">表中的一个不同的单词。TransformColumnTypes </em> vs <em class="le">表。TransformColumns </em>)严重影响了我们的查询，以至于无法将其转换为SQL！</p><p id="2a8e" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll mb ln lo lp md lr ls lt mf lv lw lx ly im bi translated">从这个故事中吸取教训:当你选择改变数据类型的选项时，要小心谨慎！</p><h2 id="ca14" class="mq mr it bd ms mt mu dn mv mw mx dp my mb mz na nb md nc nd ne mf nf ng nh ni bi translated">编写本机SQL查询以获取数据</h2><p id="59b5" class="pw-post-body-paragraph lc ld it lf b lg nj ju li lj nk jx ll mb nl lo lp md nm ls lt mf nn lw lx ly im bi translated">将数据导入Power BI时，您需要做出的最早决定之一是:您是否希望从SQL数据库“按原样”导入数据，然后在Power Query编辑器中应用必要的转换…或者，您是否希望手动编写SQL查询来检索数据…</p><p id="9d92" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll mb ln lo lp md lr ls lt mf lv lw lx ly im bi translated">如果您选择后一个选项，您应该意识到手写的SQL查询不能再折叠了！所以，在这个场景中，是<strong class="lf iu"> <em class="le">全有或者全无</em> </strong>！一旦您决定使用自定义SQL语句导入数据，在Power Query编辑器中应用的所有后续转换步骤都不会折叠，即使您正在应用一些基本的转换，如过滤或重命名列，这些步骤在“正常”情况下会折叠。</p><p id="8f2c" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll mb ln lo lp md lr ls lt mf lv lw lx ly im bi translated">让我给你看一个例子:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/026c131e0394c830ada295c466032242.png" data-original-src="https://miro.medium.com/v2/resize:fit:1398/format:webp/1*A26EiPVHZ-RkLvHUmWM_Ng.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="a79d" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll mb ln lo lp md lr ls lt mf lv lw lx ly im bi translated">因此，我想从DimDate表中导入所有行和列。现在，假设我只想保留2007年1月1日之后的行:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/9dab496429b07817f09d8bfed8e9b509.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g0T_kQAfJIWCRFf3m_fjzg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="8603" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll mb ln lo lp md lr ls lt mf lv lw lx ly im bi translated">在正常情况下，当您“按原样”导入DimDate表时，可以使用SQL中的WHERE子句(WHERE FullDateAlternateKey &gt; ' 2007–01–01 ')轻松转换该转换，并将其推送到SQL数据库源。</p><p id="6019" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll mb ln lo lp md lr ls lt mf lv lw lx ly im bi translated">现在，如果我在这一步运行查询诊断工具，我可以看到这里没有发生查询折叠！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/41991dc1d03faf8567e4a836576ce484.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hLaRxxXYRatz3LqOLO525Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="d0c5" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll mb ln lo lp md lr ls lt mf lv lw lx ly im bi translated">如您所见，只有我们的初始查询是在SQL数据库端执行的。所以，这里发生的事情是，Mashup引擎从DimDate表中提取了所有行<strong class="lf iu"><em class="le"/></strong>，然后应用了我们请求的转换步骤！无需强调这对性能的影响，无论是在CPU还是内存消耗方面…</p><p id="0551" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll mb ln lo lp md lr ls lt mf lv lw lx ly im bi translated">如果您决定采用这种方式并手工编写SQL代码，有两种可能的解决方案:</p><ul class=""><li id="2d02" class="lz ma it lf b lg lh lj lk mb mc md me mf mg ly mh mi mj mk bi translated"><strong class="lf iu"> <em class="le">创建一个数据库视图</em></strong>——这是最理想的场景！如果您能够在底层数据库中创建视图，那么您可以将整个转换逻辑封装在视图中，然后“按原样”导入视图，所有应用的转换都已经就绪！由于数据库视图在Power BI中被视为与数据库表完全相同，因此您仍然可以在视图上实现查询折叠！</li><li id="0787" class="lz ma it lf b lg ml lj mm mb mn md mo mf mp ly mh mi mj mk bi translated"><strong class="lf iu"> <em class="le">在单个SQL语句中应用所有必要的转换</em> </strong> —如果您没有足够的权限创建数据库对象，另一个选项是在您编写的单个SQL语句中包含所有必要的转换步骤。大概是这样的:</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/66dfc49d385690316677726fec447ff5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1398/format:webp/1*MwBf0DkU_HwJYTf0LwdDTg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="0078" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll mb ln lo lp md lr ls lt mf lv lw lx ly im bi translated">最近，在编写原生SQL查询时，对查询折叠进行了一些改进。克里斯·韦伯写了一篇关于使用<em class="le">价值的<a class="ae ky" href="https://blog.crossjoin.co.uk/2021/02/21/query-folding-on-sql-queries-in-power-query-using-value-nativequery-and-enablefoldingtrue/" rel="noopener ugc nofollow" target="_blank">优秀博文</a>。NativeQuery() </em>函数，并为EnableFolding参数提供显式值<em class="le"> TRUE </em>。</p><p id="5fa7" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll mb ln lo lp md lr ls lt mf lv lw lx ly im bi translated">然而，在撰写本文的时候，这个选项只适用于PostgreSQL连接器，这里的<a class="ae ky" href="https://docs.microsoft.com/en-us/power-query/connectors/postgresql#native-query-folding" rel="noopener ugc nofollow" target="_blank">中记录了这个连接器。它也可以在SQL Server中工作，但不是以最直观的方式，因为您需要在高级编辑器中手动替换M代码。</a></p><p id="5b6b" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll mb ln lo lp md lr ls lt mf lv lw lx ly im bi translated">因此，这更像是一种变通解决方案(确实很有帮助)，但是让我们希望在不久的将来，我们能够“开箱即用”地明确指示Power BI，我们希望在编写定制SQL时启用查询折叠…</p><h2 id="7b4a" class="mq mr it bd ms mt mu dn mv mw mx dp my mb mz na nb md nc nd ne mf nf ng nh ni bi translated">骗子，骗子…</h2><p id="5dd3" class="pw-post-body-paragraph lc ld it lf b lg nj ju li lj nk jx ll mb nl lo lp md nm ls lt mf nn lw lx ly im bi translated">我在本系列的前一部分已经承诺，我将向您展示另一个例子，当<em class="le">查看本机查询</em>选项可以欺骗您认为查询折叠被破坏时，即使实际上它不是真的…</p><p id="ccea" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll mb ln lo lp md lr ls lt mf lv lw lx ly im bi translated">假设我们只想保留表中的前X行。在我的例子中，我希望保留事实表中的前2000行:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/5bef33b0580c78a5281aa6b43d20fa56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yphZBznbW6UyUB0bl2CHfw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="6526" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll mb ln lo lp md lr ls lt mf lv lw lx ly im bi translated">一旦我应用了这个步骤并检查了View Native查询，我就可以意识到我的查询折叠了，因为我的转换被转换成了SQL中的TOP子句:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/04347dee0f2e3a7b2aa0828908cb732c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1398/format:webp/1*S-IWd-vMU0s7t4_IEahVsA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="413c" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll mb ln lo lp md lr ls lt mf lv lw lx ly im bi translated">现在，假设我想对我的销售额列应用绝对值转换。通常，这种转换很容易折叠，因为T-SQL中有一个ABS函数:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/dde9a49ec26222c15845cf334579d18b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qepaigq_1DQYm0MBTSKjqw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="8e8c" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll mb ln lo lp md lr ls lt mf lv lw lx ly im bi translated">但是，如果我右键单击这一步，我会看到查看本地查询选项是灰色的，所以我会假设这一步破坏了我的查询折叠！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/edb230ab6ff551230d8e6e71f0edb170.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8nnJF-gaGDvr7EinJoEoYA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="71ab" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll mb ln lo lp md lr ls lt mf lv lw lx ly im bi translated">让我们在查询诊断工具中对此进行检查:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/e4e9764b2ea957056acca543c3921119.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*decKtEKxzQi-7Sz9MHsfzQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="c79d" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll mb ln lo lp md lr ls lt mf lv lw lx ly im bi translated">哦，我的天啊！这一步确实折了！所以，我们又被查看原生查询选项骗了！</p><p id="617b" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll mb ln lo lp md lr ls lt mf lv lw lx ly im bi translated">这里的关键接管是:每当您假设特定的转换步骤可以折叠时(就像在这个例子中，当我们知道SQL有ABS函数来支持我们的转换时)，请仔细检查实际发生了什么！</p><h2 id="7175" class="mq mr it bd ms mt mu dn mv mw mx dp my mb mz na nb md nc nd ne mf nf ng nh ni bi translated">终极性能测试</h2><p id="1296" class="pw-post-body-paragraph lc ld it lf b lg nj ju li lj nk jx ll mb nl lo lp md nm ls lt mf nn lw lx ly im bi translated">好吧，如果到目前为止我还没有说服您为什么应该努力实现查询折叠，现在让我拿出我最后的王牌吧！</p><p id="5e59" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll mb ln lo lp md lr ls lt mf lv lw lx ly im bi translated">我想向您展示返回完全相同结果的查询之间的数据刷新性能差异——其中一个折叠，另一个不折叠！</p><p id="f1ce" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll mb ln lo lp md lr ls lt mf lv lw lx ly im bi translated"><strong class="lf iu"> <em class="le">测试#1查询折上</em> </strong></p><p id="62f7" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll mb ln lo lp md lr ls lt mf lv lw lx ly im bi translated">对于这个测试，我将使用Contoso示例数据库中的FactOnlineSales表。这个表大约有1260万行，很好地展示了查询折叠概念的重要性。</p><p id="e571" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll mb ln lo lp md lr ls lt mf lv lw lx ly im bi translated">在第一个示例中，我应用了9个不同的变换步骤，它们都是可折叠的，如下图所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/cb46384cdd00a2cd3368cbb3c7b0a263.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LE8snxxbDebxiZJFxSh_Sg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="4f91" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll mb ln lo lp md lr ls lt mf lv lw lx ly im bi translated">不要关注Mashup引擎生成的SQL代码:如果你是一名SQL专业人员，当然，你可以编写更优化的SQL代码——但是，请记住，使用Mashup引擎自动生成的脚本，<strong class="lf iu"> <em class="le">你不会得到最优的SQL——你只是得到正确的SQL </em> </strong>！</p><p id="7b6b" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll mb ln lo lp md lr ls lt mf lv lw lx ly im bi translated">我将点击Close &amp; Apply并打开秒表来测量我的数据刷新持续的时间。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/b530d9bc67874598d6feed3d4a7a03e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kPvzrjiU8PO7ZRcozNSm0g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="f849" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll mb ln lo lp md lr ls lt mf lv lw lx ly im bi translated">这个查询花了32秒在我的Power BI报告中加载了280万条记录。数据是以100.000–150.000条记录为一批加载的，这很好地表明查询折叠已经就绪。</p><p id="ccd3" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll mb ln lo lp md lr ls lt mf lv lw lx ly im bi translated"><strong class="lf iu"> <em class="le">测试#2查询折掉</em> </strong></p><p id="24e2" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll mb ln lo lp md lr ls lt mf lv lw lx ly im bi translated">现在，我将返回到Power Query Editor，并在第三步中故意中断查询折叠(记住上面将日期/时间类型更改为Date的示例)，使用我知道不可折叠的转换:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/9623798b51c754bf88c9e9e9f7083ff2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sV7m9qD9EsUDk-Cll-FAvg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="3f39" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll mb ln lo lp md lr ls lt mf lv lw lx ly im bi translated">说实话，我将在这里实现部分折叠，因为前两步将折叠，但提取日期转换后的所有后续步骤将不会折叠！</p><p id="c75e" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll mb ln lo lp md lr ls lt mf lv lw lx ly im bi translated">让我们再次打开秒表，看看会发生什么:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/32c772d9f8df0d6cb7fca61be5e8c2d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FZoUkgNxJwtCZf9h3V4t4g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="3a7f" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll mb ln lo lp md lr ls lt mf lv lw lx ly im bi translated">首先要注意的是:这个查询花了4分41秒加载到我们的Power BI报告中，这大约比我们之前的查询折叠时的<strong class="lf iu"><em class="le"/></strong>多10倍。这一次，加载的数据批次在10.000到20.000条记录之间。</p><p id="6eff" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll mb ln lo lp md lr ls lt mf lv lw lx ly im bi translated">但是，更值得关注的是—您可以看到加载的记录总数几乎达到了1100万条！！！而不是上例中的280万！为什么会这样？在之前的文章中，我解释了当Mashup引擎不能将M语言翻译成SQL时，它需要将所有数据(从查询折叠被破坏的那一刻起)拉进<strong class="lf iu">所有数据，然后<strong class="lf iu">然后</strong>对整个导入数据块应用转换！</strong></p><p id="790b" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll mb ln lo lp md lr ls lt mf lv lw lx ly im bi translated">最终结果是完全相同的——我们的Power BI报告中有2.830.017条记录——但是，在查询折叠就绪后，所有必要的转换都在SQL数据库端执行，Mashup引擎得到了已经准备好的数据集。而在第二个场景中，在我们中断了查询折叠之后，Mashup引擎将所有剩余的行(大约。1100万)，只有在这之后，它才能应用其他转换步骤。</p><p id="68e0" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll mb ln lo lp md lr ls lt mf lv lw lx ly im bi translated">而且，这只是一个基本的例子，只有一个表，数据量没有那么大！想象一下包含多个表的大型数据集的影响有多大。</p><h2 id="5ae1" class="mq mr it bd ms mt mu dn mv mw mx dp my mb mz na nb md nc nd ne mf nf ng nh ni bi translated">结论</h2><p id="8a05" class="pw-post-body-paragraph lc ld it lf b lg nj ju li lj nk jx ll mb nl lo lp md nm ls lt mf nn lw lx ly im bi translated">嗯，我们在这个博客系列中讨论了很多。我们学习了数据整形概念，我们介绍了超级查询基础知识，我们还学习了什么是查询折叠以及为什么我们应该尽最大努力来实现它。</p><p id="383b" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll mb ln lo lp md lr ls lt mf lv lw lx ly im bi translated">我还与您分享了一些基本的例子和在一些常见用例中如何实现查询折叠的巧妙技巧。</p><p id="63f5" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll mb ln lo lp md lr ls lt mf lv lw lx ly im bi translated">最后，请注意，查询折叠是一项正在进行的工作，Power BI团队的人员正在不断改进这一特性。因此，我在这里向您展示的一些查询折叠问题可能会同时得到解决。因此，请确保了解最新的改进。</p><p id="1840" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll mb ln lo lp md lr ls lt mf lv lw lx ly im bi translated">感谢来自微软的Alex Powers收集了关于查询折叠的不同资源，以及Christopher Majka分享了链接，Github 上有一个<a class="ae ky" href="https://github.com/itsnotaboutthecell/powerquerym/blob/master/QueryFolding.md" rel="noopener ugc nofollow" target="_blank"> repo，在这里您可以跟踪查询折叠功能的所有最新变化。</a></p><p id="6558" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll mb ln lo lp md lr ls lt mf lv lw lx ly im bi translated">感谢阅读！</p><p id="b907" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll mb ln lo lp md lr ls lt mf lv lw lx ly im bi translated"><a class="ae ky" href="https://datamozart.medium.com/membership" rel="noopener">成为会员，阅读Medium上的每一个故事！</a></p><p id="5e23" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll mb ln lo lp md lr ls lt mf lv lw lx ly im bi translated">订阅<a class="ae ky" href="http://eepurl.com/gOH8iP" rel="noopener ugc nofollow" target="_blank">此处</a>获取更多有见地的数据文章！</p></div></div>    
</body>
</html>