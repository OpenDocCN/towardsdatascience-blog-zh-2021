<html>
<head>
<title>Baseline Walkthrough for the Machine Translation Task of the Shifts Challenge at NeurIPS 2021</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">NeurIPS 2021轮班挑战赛机器翻译任务的基线演练</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/baseline-walkthrough-for-the-machine-translation-task-of-the-shifts-challenge-at-neurips-2021-e432c92882de?source=collection_archive---------11-----------------------#2021-10-09">https://towardsdatascience.com/baseline-walkthrough-for-the-machine-translation-task-of-the-shifts-challenge-at-neurips-2021-e432c92882de?source=collection_archive---------11-----------------------#2021-10-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="6ebe" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">让你自己站起来跑起来！</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/36b6a41c9c9bb13c322a9324274a37b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*mf1Bl7VYaIOfnSgnJ3jaIA.gif"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片由Yandex提供</p></figure><p id="74f0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">分布式转移(训练和部署数据之间的不匹配)在现实世界的任务中普遍存在，并对人工智能系统的安全和可靠使用提出了重大挑战。今年在NeurlPS上，我们组织了<a class="ae lr" href="https://research.yandex.com/shifts" rel="noopener ugc nofollow" target="_blank"> <strong class="kx ir"> <em class="ls">转变挑战</em> </strong> </a>，在那里我们调查了在真实的工业规模应用中对分布转变和不确定性的鲁棒性。本博客仅针对此次挑战的机器翻译任务，是对<a class="ae lr" href="https://github.com/yandex-research/shifts/tree/main/translation" rel="noopener ugc nofollow" target="_blank">官方Github页面</a>上的说明的补充，带有关于数据集、培训和评估流程的<em class="ls">附加说明</em>。本教程是对黄的《换挡挑战赛车辆运动预测任务教程<a class="ae lr" href="https://medium.com/@andrehuang0/baseline-walkthrough-of-the-vehicle-motion-prediction-task-in-shifts-challenge-at-neurlps-2021-22f5d51d854b#7570" rel="noopener">的后续。</a></p><p id="7d70" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">本教程的结构如下:</p><ol class=""><li id="2be4" class="lt lu iq kx b ky kz lb lc le lv li lw lm lx lq ly lz ma mb bi translated">任务概述</li><li id="7ab9" class="lt lu iq kx b ky mc lb md le me li mf lm mg lq ly lz ma mb bi translated">设置环境和存储库</li><li id="ea84" class="lt lu iq kx b ky mc lb md le me li mf lm mg lq ly lz ma mb bi translated">下载数据和基线</li><li id="8a38" class="lt lu iq kx b ky mc lb md le me li mf lm mg lq ly lz ma mb bi translated">将数据预处理成Fairseq格式</li><li id="3c13" class="lt lu iq kx b ky mc lb md le me li mf lm mg lq ly lz ma mb bi translated">模特培训</li><li id="b426" class="lt lu iq kx b ky mc lb md le me li mf lm mg lq ly lz ma mb bi translated">获得预测和不确定性估计</li><li id="e281" class="lt lu iq kx b ky mc lb md le me li mf lm mg lq ly lz ma mb bi translated">模型评估和提交</li><li id="b5ff" class="lt lu iq kx b ky mc lb md le me li mf lm mg lq ly lz ma mb bi translated">改进方向</li></ol><h1 id="1fd9" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">1.任务概述</h1><p id="e495" class="pw-post-body-paragraph kv kw iq kx b ky mz jr la lb na ju ld le nb lg lh li nc lk ll lm nd lo lp lq ij bi translated">作为轮班数据集的一部分，我们检查机器翻译的任务。翻译服务，如Google Translate或Yandex Translate，在其翻译查询中经常遇到非典型和不寻常的语言使用。这通常包括俚语、脏话、糟糕的语法、拼写和标点符号，以及表情符号。这对现代翻译系统提出了挑战，现代翻译系统通常是在语言使用更“标准”的语料库上训练的。因此，对于模型来说，重要的是既要对非典型语言的使用具有鲁棒性，以提供高质量的翻译，又要能够指出它们何时不能提供高质量的翻译。这在机器翻译系统用于翻译敏感的法律或外交文件时尤其重要，在这种情况下，意义不“在翻译中丢失”是至关重要的。因此，我们希望模型能够在一系列场景中表现良好，并在它们不能表现良好时进行指示。这分别对应于<strong class="kx ir"> <em class="ls">鲁棒性</em> </strong>和<strong class="kx ir"> <em class="ls">不确定性</em> </strong>的预测。在<em class="ls">转变</em> <em class="ls">挑战</em>中，我们评估了分布转变下的预测稳健性和不确定性<em class="ls">。</em></p><p id="5da1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在大多数先前的工作中，不确定性估计和对分布变化的稳健性是分开评估的。鲁棒性通常通过对特定任务的预测性能的度量来评估，例如分类错误率。同时，不确定性估计的质量通常通过区分与训练数据匹配的“域内”数据集和基于不确定性测量的移位或“域外”(OOD)数据集的能力来评估。然而，我们认为这两个问题是一个共同整体的两个部分，因此必须一起评估<strong class="kx ir"><em class="ls"/></strong>。此外，它们必须在包含大量匹配或“域内”数据和大量移位数据的数据集上进行联合评估[1]。我们将在评估部分描述更多细节。</p><p id="a5a8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">翻译本质上是一个<strong class="kx ir"> <em class="ls">结构化预测</em> </strong>任务，因为输出序列中的标记之间存在依赖关系。通常我们必须对这些依赖的形式做出假设；例如，大多数现代翻译系统是从左到右自回归的。然而，我们可以考虑条件独立预测或其他因子分解顺序。这些假设的性质使得获得理论上合理的不确定性度量具有挑战性。直到最近，人们才开始开发结构化预测的原则性不确定性测量方法[2，3，4，5，6]。然而，这仍然是一个未解决的任务和一个富有成果的研究领域。本教程研究了如何在自回归结构化预测【2】中基于<a class="ae lr" href="https://openreview.net/pdf?id=jN5y-zb5Q7m" rel="noopener ugc nofollow" target="_blank">不确定性估计建立和运行基线系统。</a></p><h1 id="d4ad" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">2.设置环境和存储库</h1><p id="87d5" class="pw-post-body-paragraph kv kw iq kx b ky mz jr la lb na ju ld le nb lg lh li nc lk ll lm nd lo lp lq ij bi translated">要开始这项任务，您必须首先设置所有必需的包和适当的环境。请注意代码有点过时，使用的是<strong class="kx ir"> Fairseq 0.9 </strong>和<strong class="kx ir"> PyTorch 1.6.0。</strong>我们计划很快创建一个更干净的最新实现。因此，你将需要<strong class="kx ir"> python 3.7 </strong>和<strong class="kx ir"> CUDA 10.2。</strong></p><p id="bbac" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">首先，启动您的shell，克隆并安装轮班质询存储库:</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="2bdc" class="nj mi iq nf b gy nk nl l nm nn">git clone <a class="ae lr" href="https://github.com/yandex-research/shifts.git" rel="noopener ugc nofollow" target="_blank">https://github.com/yandex-research/shifts.git</a></span></pre><p id="fdc0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在目录中，您会发现一个“requirements . txt”——继续安装所有这些包:</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="68dd" class="nj mi iq nf b gy nk nl l nm nn">pip install matplotlib numpy torch==1.6.0 sacrebleu==1.4.3 nltk==3.4.5</span></pre><p id="cbfb" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这也将安装与Fairseq 0.9兼容的所有必需软件包的版本。最后，克隆一个自回归结构化预测【2】中<a class="ae lr" href="https://openreview.net/pdf?id=jN5y-zb5Q7m" rel="noopener ugc nofollow" target="_blank">不确定性估计的实现。</a></p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="5441" class="nj mi iq nf b gy nk nl l nm nn">git clone <a class="ae lr" href="https://github.com/KaosEngineer/structured-uncertainty.git" rel="noopener ugc nofollow" target="_blank">https://github.com/KaosEngineer/structured-uncertainty.git</a><br/>cd structured-uncertainty <br/>python3 -m pip install — user — no-deps — editable .</span></pre><p id="bf3c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在，您已经设置了环境、班次库和结构化不确定性库，应该为下一步做好准备了。</p><h1 id="57c4" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">3.下载数据和基线</h1><p id="f752" class="pw-post-body-paragraph kv kw iq kx b ky mz jr la lb na ju ld le nb lg lh li nc lk ll lm nd lo lp lq ij bi translated">现在您已经设置了您的存储库，您可以下载培训和开发数据以及基线模型。注意，<strong class="kx ir">下载数据的脚本也做一些初始预处理。</strong></p><p id="180c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">要下载培训和发展数据，请运行预处理脚本:</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="9d4c" class="nj mi iq nf b gy nk nl l nm nn">chmod +x ./shifts/translation/data/prepare_data.sh </span><span id="3187" class="nj mi iq nf b gy no nl l nm nn">./shifts/translation/data/prepare_data.sh</span></pre><p id="9545" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这将对数据进行预处理，将所有训练数据合并为一个数据，并从训练数据中移除重复和复制的示例。接下来，下载基线模型:</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="1c03" class="nj mi iq nf b gy nk nl l nm nn">wget <a class="ae lr" href="https://storage.yandexcloud.net/yandex-research/shifts/translation/baseline-models.tar" rel="noopener ugc nofollow" target="_blank">https://storage.yandexcloud.net/yandex-research/shifts/translation/baseline-models.tar</a></span><span id="b3d8" class="nj mi iq nf b gy no nl l nm nn">tar -xf baseline-models.tar</span></pre><p id="8b35" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这将产生以下顶级目录结构:</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="4958" class="nj mi iq nf b gy nk nl l nm nn">./<br/>├── baseline-models<br/>├── mosesdecoder<br/>├── orig<br/>├── shifts<br/>├── structured-uncertainty<br/>├── subword-nmt<br/>└── wmt20_en_ru</span></pre><p id="1233" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir"> orig </strong>、<strong class="kx ir"> wmt20_en_ru </strong>和<strong class="kx ir"> baseline-models </strong>目录应包含以下内容:</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="073e" class="nj mi iq nf b gy nk nl l nm nn">orig<br/>├── dev-data<br/>│ ├── LICENSE.md<br/>│ ├── newstest2019-enru-ref.ru.sgm<br/>│ ├── newstest2019-enru-src.en.sgm<br/>│ ├── reddit_dev.en<br/>│ ├── reddit_dev.meta<br/>│ └── reddit_dev.ru<br/>└── train-data<br/> ├── 1mcorpus<br/> │ ├── corpus.en_ru.1m.en<br/> │ └── corpus.en_ru.1m.ru<br/> ├── WikiMatrix.v1.en-ru.langid.en<br/> ├── WikiMatrix.v1.en-ru.langid.ru<br/> ├── WikiMatrix.v1.en-ru.langid.tsv<br/> ├── commoncrawl.ru-en.en<br/> ├── commoncrawl.ru-en.ru<br/> ├── en-ru<br/> │ ├── DISCLAIMER<br/> │ ├── README<br/> │ ├── UNv1.0.en-ru.en<br/> │ ├── UNv1.0.en-ru.ids<br/> │ ├── UNv1.0.en-ru.ru<br/> │ └── UNv1.0.pdf<br/> ├── extra<br/> ├── news-commentary-v15.en-ru.en<br/> ├── news-commentary-v15.en-ru.ru<br/> ├── news-commentary-v15.en-ru.tsv<br/> ├── news.en<br/> ├── news.en.translatedto.ru<br/> ├── news.ru<br/> ├── news.ru.translatedto.en<br/> ├── paracrawl-release1.en-ru.zipporah0-dedup-clean.en<br/> ├── paracrawl-release1.en-ru.zipporah0-dedup-clean.ru<br/> ├── readme.txt<br/> ├── wikititles-v2.ru-en.en<br/> ├── wikititles-v2.ru-en.ru<br/> └── wikititles-v2.ru-en.tsv<br/>wmt20_en_ru<br/>├── code<br/>├── reddit_dev.en<br/>├── reddit_dev.ru<br/>├── test19.en<br/>├── test19.ru<br/>├── tmp<br/>│ ├── bpe.reddit_dev.en<br/>│ ├── bpe.reddit_dev.ru<br/>│ ├── bpe.test19.en<br/>│ ├── bpe.test19.ru<br/>│ ├── bpe.train.en<br/>│ ├── bpe.train.ru<br/>│ ├── bpe.valid.en<br/>│ ├── bpe.valid.ru<br/>│ ├── reddit_dev.en<br/>│ ├── reddit_dev.ru<br/>│ ├── test19.en<br/>│ ├── test19.ru<br/>│ ├── train.en<br/>│ ├── train.en-ru<br/>│ ├── train.ru<br/>│ ├── train.tags.en-ru.clean.tok.en<br/>│ ├── train.tags.en-ru.clean.tok.ru<br/>│ ├── train.tags.en-ru.tok.en<br/>│ ├── train.tags.en-ru.tok.ru<br/>│ ├── valid.en<br/>│ └── valid.ru<br/>├── train.en<br/>├── train.ru<br/>├── valid.en<br/>└── valid.ru<br/>baseline-models/<br/>├── dict.en.txt<br/>├── dict.ru.txt<br/>├── model1.pt<br/>├── model2.pt<br/>├── model3.pt<br/>├── model4.pt<br/>└── model5.pt</span></pre><h1 id="b423" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated"><strong class="ak"> 4。将数据预处理成Fairseq格式</strong></h1><p id="d5e2" class="pw-post-body-paragraph kv kw iq kx b ky mz jr la lb na ju ld le nb lg lh li nc lk ll lm nd lo lp lq ij bi translated">既然您已经下载了数据，清理并预处理了它，现在必须将它转换成一个Fairseq特定的格式。这可以使用以下命令来完成:</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="a20f" class="nj mi iq nf b gy nk nl l nm nn">python3 structured-uncertainty/preprocess.py — source-lang en — target-lang ru — trainpref wmt20_en_ru/train — validpref wmt20_en_ru/valid — testpref wmt20_en_ru/test19,wmt20_en_ru/reddit_dev — destdir data-bin/wmt20_en_ru — thresholdtgt 0 — thresholdsrc 0 — workers 24</span></pre><p id="a0b6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果您使用提供的基线模型，请使用以下命令进行预处理:</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="fcdb" class="nj mi iq nf b gy nk nl l nm nn">python3 structured-uncertainty/preprocess.py — srcdict baseline-models/dict.en.txt — tgtdict baseline-models/dict.ru.txt — source-lang en — target-lang ru — trainpref wmt20_en_ru/train — validpref wmt20_en_ru/valid — testpref wmt20_en_ru/test19,wmt20_en_ru/reddit_dev — destdir data-bin/wmt20_en_ru — thresholdtgt 0 — thresholdsrc 0 — workers 24</span></pre><p id="a447" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">上面的命令使用基线模型附带的字典，这些字典与您通过运行前面几节中的脚本得到的字典略有不同。以上两个命令应该创建一个新目录'<strong class="kx ir"> <em class="ls"> data-bin </em> </strong>'，其结构如下:</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="ee93" class="nj mi iq nf b gy nk nl l nm nn">data-bin/<br/>└── wmt20_en_ru<br/> ├── dict.en.txt<br/> ├── dict.ru.txt<br/> ├── test.en-ru.en.bin<br/> ├── test.en-ru.en.idx<br/> ├── test.en-ru.ru.bin<br/> ├── test.en-ru.ru.idx<br/> ├── test1.en-ru.en.bin<br/> ├── test1.en-ru.en.idx<br/> ├── test1.en-ru.ru.bin<br/> ├── test1.en-ru.ru.idx<br/> ├── train.en-ru.en.bin<br/> ├── train.en-ru.en.idx<br/> ├── train.en-ru.ru.bin<br/> ├── train.en-ru.ru.idx<br/> ├── valid.en-ru.en.bin<br/> ├── valid.en-ru.en.idx<br/> ├── valid.en-ru.ru.bin<br/> └── valid.en-ru.ru.idx</span></pre><p id="4da7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">其中<strong class="kx ir"> <em class="ls">测试</em> </strong>为域内开发数据集— <strong class="kx ir"> <em class="ls">新闻测试19</em></strong><strong class="kx ir"><em class="ls">测试1 </em> </strong>为转移后的开发数据— <strong class="kx ir"> <em class="ls"> reddit_dev </em> </strong>。</p><h1 id="6a9a" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">5.模特培训</h1><p id="4266" class="pw-post-body-paragraph kv kw iq kx b ky mz jr la lb na ju ld le nb lg lh li nc lk ll lm nd lo lp lq ij bi translated">现在，如果您想要重新创建基线，可以运行以下命令:</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="444d" class="nj mi iq nf b gy nk nl l nm nn">python3 structured-uncertainty/train.py data-bin/wmt20_en_ru — arch transformer_wmt_en_de_big — share-decoder-input-output-embed — fp16 — memory-efficient-fp16 — num-workers 16 — optimizer adam — adam-betas ‘(0.9, 0.98)’ — clip-norm 0.0 — lr 5e-4 — lr-scheduler inverse_sqrt — warmup-updates 4000 — dropout 0.1 — weight-decay 0.0001 — criterion label_smoothed_cross_entropy — label-smoothing 0.1 — max-tokens 5120 — save-dir MODEL_DIR — max-update 50000 — update-freq 16 — keep-last-epochs 10 — seed 0</span></pre><p id="1bc0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这用于产生基线，只有种子不同。如果你正在训练的GPU不是V100或A100，那么很可能你不应该使用FP16，因为这种模式在数值上可能不稳定。请注意，您可能希望使用不同的设置、不同的历元数或使用不同的体系结构来训练您的模型，因此该命令的详细信息可能会有所不同。</p><h1 id="fd2c" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">6.获得预测和不确定性估计</h1><p id="6452" class="pw-post-body-paragraph kv kw iq kx b ky mz jr la lb na ju ld le nb lg lh li nc lk ll lm nd lo lp lq ij bi translated">现在，您已经有了一个基线模型或您自己的模型的集合，您可以对单个模型或集合运行推理，如下所示。要运行单一模型基线:</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="57da" class="nj mi iq nf b gy nk nl l nm nn">mkdir single <br/>for i in test test1; do <br/>   python3 structured-uncertainty//generate.py wmt20_en_ru/ — path      baseline-models/model1.pt — max-tokens 4096 — remove-bpe — nbest 5 — gen-subset ${i} &gt;&amp; single/results-${i}.txt<br/>done</span></pre><p id="50c6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">要运行集合基线:</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="bde2" class="nj mi iq nf b gy nk nl l nm nn">mkdir ensemble<br/>for i in test test1; do <br/> python3 structured-uncertainty/generate.py wmt20_en_ru/ — path baseline-models/model1.pt:baseline-models/model2.pt:baseline-models/model3.pt — max-tokens 1024 — remove-bpe — nbest 5 — gen-subset ${i} — compute-uncertainty &gt;&amp; ensemble/results-${i}.txt<br/>done</span></pre><p id="c760" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">注意，如果您正在使用<strong class="kx ir"> <em class="ls">集合</em> </strong>，您应该只使用“<strong class="kx ir"> <em class="ls"> —计算不确定性</em> </strong>”标志。这产生了翻译的原始输出和相关的不确定性分数，然后需要进一步处理。所有文件都保存在目录“single”和“ensemble”中，结构如下:</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="5537" class="nj mi iq nf b gy nk nl l nm nn">ensemble<br/>├── results-test.txt<br/>└── results-test1.txt</span></pre><h1 id="7357" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">7.模型评估和提交</h1><p id="f13c" class="pw-post-body-paragraph kv kw iq kx b ky mz jr la lb na ju ld le nb lg lh li nc lk ll lm nd lo lp lq ij bi translated">既然您已经成功地用您的模型运行了推理，我们现在需要评估模型的输出并创建一个提交文件。请记住，test是您的newstest19，即非转移开发数据，而test1是reddit_dev，即转移开发数据。我们将对这两个模型进行评估。</p><p id="6219" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这可以通过运行以下脚本轻松完成:</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="6da3" class="nj mi iq nf b gy nk nl l nm nn">chmod +x ./shifts/translation/assessment/eval_single.sh<br/>chmod +x ./shifts/translation/assessment/eval_ensemble.sh</span><span id="2f5f" class="nj mi iq nf b gy no nl l nm nn">./shifts/translation/assessment/eval_single.sh<br/>./shifts/translation/assessment/eval_ensemble.sh</span></pre><p id="785f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">该脚本现在将修改单个目录和集合目录，如下所示:</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="a95a" class="nj mi iq nf b gy nk nl l nm nn">ensemble<br/>├── results-test.txt<br/>├── results-test1.txt<br/>├── test<br/>│ ├── aep_du.txt<br/>│ ├── aep_tu.txt<br/>│ ├── entropy_expected.txt<br/>│ ├── ep_entropy_expected.txt<br/>│ ├── ep_epkl.txt<br/>│ ├── ep_mkl.txt<br/>│ ├── ep_mutual_information.txt<br/>│ ├── epkl.txt<br/>│ ├── expected_entropy.txt<br/>│ ├── hypo_ids.txt<br/>│ ├── hypo_likelihoods.txt<br/>│ ├── hypos.txt<br/>│ ├── log_probs.txt<br/>│ ├── logcombo.txt<br/>│ ├── logvar.txt<br/>│ ├── mkl.txt<br/>│ ├── mutual_information.txt<br/>│ ├── npmi.txt<br/>│ ├── ref_ids.txt<br/>│ ├── refs.txt<br/>│ ├── score.txt<br/>│ ├── score_npmi.txt<br/>│ ├── tmp<br/>│ ├── var.txt<br/>│ └── varcombo.txt<br/>└── test1<br/> ├── aep_du.txt<br/> ├── aep_tu.txt<br/> ├── entropy_expected.txt<br/> ├── ep_entropy_expected.txt<br/> ├── ep_epkl.txt<br/> ├── ep_mkl.txt<br/> ├── ep_mutual_information.txt<br/> ├── epkl.txt<br/> ├── expected_entropy.txt<br/> ├── hypo_ids.txt<br/> ├── hypo_likelihoods.txt<br/> ├── hypos.txt<br/> ├── log_probs.txt<br/> ├── logcombo.txt<br/> ├── logvar.txt<br/> ├── mkl.txt<br/> ├── mutual_information.txt<br/> ├── npmi.txt<br/> ├── ref_ids.txt<br/> ├── refs.txt<br/> ├── score.txt<br/> ├── score_npmi.txt<br/> ├── tmp<br/> ├── var.txt<br/> └── varcombo.txt</span></pre><p id="b91f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">除了假设id(<strong class="kx ir"><em class="ls">hypo _ ids . txt</em></strong>)、引用(<strong class="kx ir"> <em class="ls"> refs.txt </em> </strong>)假设(<strong class="kx ir"><em class="ls">hypo . txt</em></strong>)和假设可能性(<strong class="kx ir"><em class="ls">hypo _ likelihoods . txt</em></strong>)之外，大多数输出都是代码产生的不同的不确定性度量。假设文件应该比参考文件长射束尺寸的倍数。例如，如果光束宽度为5，那么假设文件应该比参考文件长5倍。</p><p id="667b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">一旦我们获得了假设和(许多不同的)不确定性分数，我们就可以评估相对于参考文献的预测，然后创建提交文件。首先，让我们讨论如何评估模型。</p><p id="7ad0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">使用BLEU和GLEU指标评估模型的性能。然而，BLEU仅在<em class="ls">语料库级别</em>是鲁棒的，而GLEU在<em class="ls">句子级别</em>是鲁棒的。由于我们对评估每个翻译句子的<em class="ls">质量感兴趣，我们的鲁棒性和不确定性质量的<strong class="kx ir"> <em class="ls">联合评估</em> </strong>使用GLEU。我们计算模型相对于适当的参考转录产生的每个假设的GLEU。回想一下，该模型可以为每个输入产生多个平移假设(例如:如果波束宽度为5，则每个输入5个)。我们分别通过取最大值或所有假设的加权平均值来计算最大(最佳)GLEU和预期GLEU。每个假设的权重可以用不同的方式计算。一种方法是对每个假设的长度归一化似然性进行指数化和归一化。这将产生一组总计为1的5个正权重。最后，我们在<strong class="kx ir">联合域内和移位数据集(<em class="ls">测试+测试1 </em>)上取平均maxGLEU或expectedGLEU。</strong></em></p><p id="04cb" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在，我们已经评估了我们的模型在联合域内和移位集上的预测质量，我们可以通过构建误差保留曲线来评估不确定性估计的质量。为此，我们首先通过从100中减去(这样越低越好)，将我们的GLEU度量转换为“<em class="ls"> GLEU误差</em>”。接下来，按照不确定性递减的顺序，用从神谕中获得的基本事实转录替换模型的预测，从而构建误差保留曲线，从而减少误差。理想情况下，模型的不确定性与其误差相关，因此误差最大的预测将首先被替换，随着更多预测被替换，这将产生平均误差的最大减少。这代表了一种混合的人类-人工智能场景，其中模型可以在困难的情况下向先知(人类)寻求帮助，并从先知那里获得关于这些例子的完美预测。</p><p id="5fc5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">随着原始预测的保留部分减少，GLEU误差也减少。最后，我们测量误差保留曲线下的面积(R-AUC)。保留曲线下面积(R-AUC)是一个用于联合评估对分布变化的稳健性和不确定性估计质量的指标。R-AUC可以通过改进模型的预测来降低，使得它在任何给定的保留率下具有更低的总误差，或者通过提供与误差更好相关的不确定性的估计，使得最不正确的预测首先被拒绝。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi np"><img src="../Images/85ad59fa7a7ee2f52a6dc7c0fa66cdf6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y-8OKcmxgeX2wyCDvRxqjg.png"/></div></div></figure><p id="b3f1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在上面的保留曲线中，除了基于不确定性的排名，我们还包括了代表“随机”排名和“最佳”排名的曲线，前者不确定性估计值完全没有信息，后者不确定性估计值与误差完全相关。这些代表作为不确定性质量函数的R-AUC性能的下限和上限。根据评估数据(10月17日相关数据)获得最低R-AUC的提交材料将胜出。</p></div><div class="ab cl nq nr hu ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="ij ik il im in"><p id="f096" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在我们已经讨论了评估，让我们讨论如何创建提交文件。如果您已经运行了上面描述的所有内容，那么您的顶级目录中应该已经有一个“submission.json”文件了。该文件是通过运行以下命令创建的:</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="c9cb" class="nj mi iq nf b gy nk nl l nm nn">python shifts/translation/assessment/create_submission.py ensemble/test ensemble/test1 — save_path ./submission-ensemble.json — beam_width 5 — nbest 5 — ensemble — uncertainty_metric SCR-PE</span></pre><p id="009c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这个脚本接受域内数据(<strong class="kx ir"> <em class="ls">测试</em> </strong>)，然后是移位数据(<strong class="kx ir"> <em class="ls">测试1 </em> </strong>)，保存路径，解码期间的波束宽度是多少(<strong class="kx ir"> <em class="ls"> beam_width </em> </strong>)，要使用的假设有多少(<strong class="kx ir"> <em class="ls"> n_best </em> </strong>)，是否使用了<strong class="kx ir"> <em class="ls">集合</em> </strong>输出，以及要包含哪些不确定性度量(<strong class="kx ir">)然后，该脚本将输出处理成一个json-list文件，其结构如下:</strong></p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="5851" class="nj mi iq nf b gy nk nl l nm nn">jsn_list = [jsn0, jsn1, ..., jsonN]</span><span id="a1e0" class="nj mi iq nf b gy no nl l nm nn">jsn0 =  {‘id’: ‘001’,<br/>	‘hypos’: [hypo1, hypo2, hypo3],<br/>	‘uncertainty’: 9000}<br/><br/>hypo1 = {‘text’: “Кошка сидела на столе”,<br/>	 ‘confidence’: 0.3}</span></pre><p id="e3c7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然后可以在<em class="ls">班次</em>网站上提交该文件。注意，如果您使用自定义的不确定性度量，那么您必须修改这个脚本。</p><h1 id="a571" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">8.改进方向</h1><p id="ec96" class="pw-post-body-paragraph kv kw iq kx b ky mz jr la lb na ju ld le nb lg lh li nc lk ll lm nd lo lp lq ij bi translated">这篇博客只涉及轮班挑战中机器翻译任务的基线方法。有几个方向可以带来有趣的发现和改进:</p><ul class=""><li id="2598" class="lt lu iq kx b ky kz lb lc le lv li lw lm lx lq nx lz ma mb bi translated">增强集合中模型的多样性。这可以通过使用测试时数据扩充来实现，例如BPE丢失或在测试时在每个系综成员中启用“正常”丢失。</li><li id="ee2d" class="lt lu iq kx b ky mc lb md le me li mf lm mg lq nx lz ma mb bi translated">考虑组合对数据做出不同假设的模型集合，如从左到右、从右到左自回归模型、非自回归模型和允许考虑任意分解顺序的模型，如XL-Net [7]。</li><li id="c961" class="lt lu iq kx b ky mc lb md le me li mf lm mg lq nx lz ma mb bi translated">考虑调整和评估不需要使用模型集合的确定性方法[9]。</li></ul><p id="6cd0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">但是，你可以自由地找到自己的问题解决方案，只要他们遵守<a class="ae lr" href="https://research.yandex.com/shifts/terms" rel="noopener ugc nofollow" target="_blank">这里描述的<em class="ls">和</em></a>的规则和计算限制。</p></div><div class="ab cl nq nr hu ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="ij ik il im in"><h1 id="6464" class="mh mi iq bd mj mk ny mm mn mo nz mq mr jw oa jx mt jz ob ka mv kc oc kd mx my bi translated">参考</h1><p id="0db8" class="pw-post-body-paragraph kv kw iq kx b ky mz jr la lb na ju ld le nb lg lh li nc lk ll lm nd lo lp lq ij bi translated">[1] A. Malinin、N. Band、Ganshin、Alexander、G. Chesnokov、Y. Gal、M. J. F. Gales、A. Noskov、A. Ploskonosov、L. Prokhorenkova、I. Provilkov、v .刘冰、v .刘冰、Roginskiy、Denis、M. Shmatova、P. Tigas和B. Yangel，“转变:跨多个大规模任务的真实分布转变数据集”，2021年。</p><p id="7650" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">[2] Andrey Malinin和Mark Gales，“自回归结构化预测中的不确定性估计”，ICLR 2021。</p><p id="a5fe" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">[3]萧，蒂姆·Z和戈麦斯，艾丹·丹和加尔·亚林，“Wat heb je gezegd？用变分变压器检测非分布翻译”，贝叶斯深度学习研讨会，NeurIPS 2019</p><p id="92d5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">[4]王，刘硕，杨，王，晁，栾，黄波，孙，茅松，“基于不确定性的置信度估计改进回译”。2019</p><p id="8a33" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">[5] Fomicheva，Marina和Sun，Shuo和Yankovskaya，Lisa和Blain，Frederic和Guzman，Francisco和Fishel，Mark和Aletras，Nikolaos和Chaudhary，Vishrav和Specia，Lucia，《神经机器翻译的无监督质量估计》，2020年</p><p id="ec04" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">[6]诺廷、帕斯卡尔和埃尔南德斯-洛巴托、何塞·米格尔和加尔、亚林。<br/>“高维数据的原则性不确定性估计”，深度学习研讨会中的不确定性&amp;鲁棒性，ICML，2020年</p><p id="eebb" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">[7]杨，，戴，子航，杨，，卡波内尔，海梅，萨拉赫丁诺夫，鲁斯和勒，郭五，“XL-Net:语言理解的广义自回归预训练”，NeurIP，S2019</p><p id="397a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">[8] Joost van Amersfoort，Lewis Smith，Yee Whye Teh，Yarin Gal，“使用单一深度确定性神经网络进行不确定性估计”，ICML，2020年</p></div></div>    
</body>
</html>