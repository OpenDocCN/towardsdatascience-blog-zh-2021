<html>
<head>
<title>Dealing with features that have high cardinality</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">处理具有高基数的要素</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/dealing-with-features-that-have-high-cardinality-1c9212d7ff1b?source=collection_archive---------2-----------------------#2021-08-04">https://towardsdatascience.com/dealing-with-features-that-have-high-cardinality-1c9212d7ff1b?source=collection_archive---------2-----------------------#2021-08-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="7145" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/tips-and-tricks" rel="noopener" target="_blank">提示和技巧</a></h2><div class=""/><div class=""><h2 id="d797" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">一个简单的实用程序，我用来处理具有许多唯一值的分类特征</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/01c3b94c1123caa4fb9c14b5541cfce8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*UffX4jFW-uxTxeRz"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">照片由<a class="ae le" href="https://unsplash.com/@gpthree?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">乔治·帕甘三世</a>在<a class="ae le" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><h1 id="d332" class="lf lg iq bd lh li lj lk ll lm ln lo lp kf lq kg lr ki ls kj lt kl lu km lv lw bi translated">什么是高基数？</h1><p id="349e" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">几乎所有的数据集现在都有分类变量。每个分类变量由唯一的值组成。当有太多这样的唯一值时，分类特征被认为具有高基数。在这种情况下，一键编码成为一个大问题，因为我们在分类变量中为每个唯一值(指示其存在或不存在)设置了一个单独的列。这就导致了两个问题，一个是明显的空间消耗，但是这个问题没有第二个问题<strong class="lz ja">维数灾难那么大。</strong>我将更详细地讨论维数灾难，但首先，让我们来看看一键编码前后的数据。</p></div><div class="ab cl mu mv hu mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="ij ik il im in"><h1 id="ee70" class="lf lg iq bd lh li nb lk ll lm nc lo lp kf nd kg lr ki ne kj lt kl nf km lv lw bi translated">一键编码前后我们的分类特征</h1><p id="7234" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">我们将关注资格特征。因为这些数据是从许多人填写的表格中收集的，所以该列包含许多不同的资格。下面是该列的外观以及它所具有的所有唯一值。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ng nh l"/></div></figure><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="2805" class="pw-post-body-paragraph lx ly iq lz b ma ni ka mc md nj kd mf mg nk mi mj mk nl mm mn mo nm mq mr ms ij bi translated"><strong class="lz ja">我们可以看到该特性中有15个唯一值，它占用了316KB的空间。</strong>让我们用pandas one _ hot编码这个特性。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ng nh l"/></div></figure><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="1469" class="pw-post-body-paragraph lx ly iq lz b ma ni ka mc md nj kd mf mg nk mi mj mk nl mm mn mo nm mq mr ms ij bi translated">我们现在可以看到我们的原始特性已经变得有多大，存储它所需的空间自然也增加到了<strong class="lz ja"> 592KB。</strong>这只是一个特征，如果在训练过程中我们拥有数百个分类变量，我们将最终拥有数百个特征，这在某些情况下不利于模型训练。简单的模型无法处理如此多的变量。但是现在让我们看看另一个主要问题，维数灾难。</p></div><div class="ab cl mu mv hu mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="ij ik il im in"><h1 id="0878" class="lf lg iq bd lh li nb lk ll lm nc lo lp kf nd kg lr ki ne kj lt kl nf km lv lw bi translated">维度的诅咒</h1><p id="ea5e" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">下面是一个简单的总结:</p><blockquote class="nn"><p id="13da" class="no np iq bd nq nr ns nt nu nv nw ms dk translated">随着特征数量的增长，我们需要准确区分这些特征(以便给我们一个预测)并概括我们的模型(学习函数)的数据量呈指数增长<strong class="ak"/>。</p></blockquote><p id="b6f0" class="pw-post-body-paragraph lx ly iq lz b ma nx ka mc md ny kd mf mg nz mi mj mk oa mm mn mo ob mq mr ms ij bi translated">如果你不想阅读下面的技术细节，请随意跳到下一节。 </p><p id="5cab" class="pw-post-body-paragraph lx ly iq lz b ma ni ka mc md nj kd mf mg nk mi mj mk nl mm mn mo nm mq mr ms ij bi translated">我想用<strong class="lz ja"> Yoshua Bengio的(是的传说中的Yoshua Bengio！)quora回答</strong>更详细的解释一下这个。我强烈建议在这里阅读整个答案<a class="ae le" href="https://www.quora.com/What-is-the-curse-of-dimensionality" rel="noopener ugc nofollow" target="_blank">。根据答案，增加一个特征中不同值的数量只是增加了使用输入行(<strong class="lz ja">包含n个这样的特征</strong>)可以得到的可能组合的总数。<strong class="lz ja">假设我们有两个特性，每个特性有两个不同的值，这给了我们总共4种可能的方法来组合这两个特性。现在，如果其中一个有三个不同的值，我们将有3X2 =6种可能的方式来组合它们。</strong></a></p><p id="0c12" class="pw-post-body-paragraph lx ly iq lz b ma ni ka mc md nj kd mf mg nk mi mj mk nl mm mn mo nm mq mr ms ij bi translated">在经典的非参数学习算法(例如最近邻、高斯核SVM、高斯核高斯过程等)中。)模型需要看到这些组合中的每一个的至少一个例子(或者至少尽可能多的覆盖感兴趣的配置的所有变化)，以便产生正确的答案，该答案不同于其他附近配置所需的目标值。</p><p id="daa1" class="pw-post-body-paragraph lx ly iq lz b ma ni ka mc md nj kd mf mg nk mi mj mk nl mm mn mo nm mq mr ms ij bi translated">对此有一个解决方法，即即使在缺乏大量训练数据的情况下，该模型也可以辨别未来预测的配置(不在训练集中),只要这些组合中存在某种结构(模式)。<strong class="lz ja">在大多数情况下，高基数使模型难以识别此类模式，因此模型不能很好地推广到训练集之外的示例。</strong></p></div><div class="ab cl mu mv hu mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="ij ik il im in"><h1 id="3cd5" class="lf lg iq bd lh li nb lk ll lm nc lo lp kf nd kg lr ki ne kj lt kl nf km lv lw bi translated">通过使用简单的聚合函数降低基数</h1><p id="b55c" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">下面是一个简单的函数，我用它来减少一个特性的基数。想法很简单。让属于高频率值的实例保持原样，并用一个新的类别替换其他实例，我们称之为<strong class="lz ja"> <em class="mt"> other。</em>T13】</strong></p><ol class=""><li id="8793" class="oc od iq lz b ma ni md nj mg oe mk of mo og ms oh oi oj ok bi translated">选择一个阈值</li><li id="9121" class="oc od iq lz b ma ol md om mg on mk oo mo op ms oh oi oj ok bi translated">按频率对列中的唯一值进行降序排序</li><li id="360d" class="oc od iq lz b ma ol md om mg on mk oo mo op ms oh oi oj ok bi translated">不断增加这些排序(降序)的唯一值的频率，直到达到阈值。</li><li id="b0e7" class="oc od iq lz b ma ol md om mg on mk oo mo op ms oh oi oj ok bi translated">这些是我们将保留的唯一类别，所有其他类别的实例将替换为<strong class="lz ja">“其他”。</strong></li></ol><p id="9aa5" class="pw-post-body-paragraph lx ly iq lz b ma ni ka mc md nj kd mf mg nk mi mj mk nl mm mn mo nm mq mr ms ij bi translated">在浏览代码之前，让我们快速浏览一个例子。假设我们的列颜色有<strong class="lz ja"> 100 </strong>个值，我们的阈值是90%(即<strong class="lz ja"> 90 </strong>)。我们有5种不同的颜色:红色(50)、蓝色(40)、黄色(5)、绿色(3)和橙色(2)。括号中的数字表示该列中有多少个该类别的实例。</p><p id="4802" class="pw-post-body-paragraph lx ly iq lz b ma ni ka mc md nj kd mf mg nk mi mj mk nl mm mn mo nm mq mr ms ij bi translated">我们看到红色(50)+蓝色(40)达到我们的阈值90。在这种情况下，我们只保留2个类别(红色、蓝色)，并将其他颜色的所有其他实例标记为“<strong class="lz ja"> Other </strong>”。</p><p id="4d48" class="pw-post-body-paragraph lx ly iq lz b ma ni ka mc md nj kd mf mg nk mi mj mk nl mm mn mo nm mq mr ms ij bi translated">因此，我们将基数从<strong class="lz ja"> 5减少到3(红色、蓝色、其他)</strong></p><p id="0541" class="pw-post-body-paragraph lx ly iq lz b ma ni ka mc md nj kd mf mg nk mi mj mk nl mm mn mo nm mq mr ms ij bi translated">这是我写的一个实用函数来帮助实现这一点。这是很好的评论，并完全遵循我上面描述的，所以你不会有问题。我们可以设置一个<strong class="lz ja">自定义阈值</strong>，并且<strong class="lz ja"> return_categories </strong>选项可选地让我们在减少基数后看到所有唯一值的列表。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ng nh l"/></div></figure><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="ea41" class="pw-post-body-paragraph lx ly iq lz b ma ni ka mc md nj kd mf mg nk mi mj mk nl mm mn mo nm mq mr ms ij bi translated"><strong class="lz ja">正如您所看到的，使用这个函数，我们将资格列的基数从15减少到了6！</strong></p></div><div class="ab cl mu mv hu mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="ij ik il im in"><h1 id="bba0" class="lf lg iq bd lh li nb lk ll lm nc lo lp kf nd kg lr ki ne kj lt kl nf km lv lw bi translated"><strong class="ak">结论</strong></h1><p id="51a4" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">我们看到了如何通过使用一个简单的函数来减少基数，更重要的是为什么这是必要的(维数灾难)。但是请记住，我们很幸运，我们的列中的值的分布允许我们使用这种方法。如果所有15个类别平均分布，我们将无法使用这种方法，在这种情况下，可能需要将PCA与数据集的其他特征结合使用，但在其他时间会更多地使用。</p><p id="eddc" class="pw-post-body-paragraph lx ly iq lz b ma ni ka mc md nj kd mf mg nk mi mj mk nl mm mn mo nm mq mr ms ij bi translated">如果你喜欢这篇文章，这里有更多！</p><div class="oq or gp gr os ot"><a rel="noopener follow" target="_blank" href="/scatter-plots-on-maps-using-plotly-79f16aee17d0"><div class="ou ab fo"><div class="ov ab ow cl cj ox"><h2 class="bd ja gy z fp oy fr fs oz fu fw iz bi translated">使用Plotly在地图上散布图</h2><div class="pa l"><h3 class="bd b gy z fp oy fr fs oz fu fw dk translated">了解如何用很少的代码创建交互式散点图来表示数据中的多个要素</h3></div><div class="pb l"><p class="bd b dl z fp oy fr fs oz fu fw dk translated">towardsdatascience.com</p></div></div><div class="pc l"><div class="pd l pe pf pg pc ph ky ot"/></div></div></a></div><div class="oq or gp gr os ot"><a rel="noopener follow" target="_blank" href="/regex-essential-for-nlp-ee0336ef988d"><div class="ou ab fo"><div class="ov ab ow cl cj ox"><h2 class="bd ja gy z fp oy fr fs oz fu fw iz bi translated">正则表达式对NLP至关重要</h2><div class="pa l"><h3 class="bd b gy z fp oy fr fs oz fu fw dk translated">理解各种正则表达式，并将其应用于自然语言中经常遇到的情况…</h3></div><div class="pb l"><p class="bd b dl z fp oy fr fs oz fu fw dk translated">towardsdatascience.com</p></div></div><div class="pc l"><div class="pi l pe pf pg pc ph ky ot"/></div></div></a></div><div class="oq or gp gr os ot"><a rel="noopener follow" target="_blank" href="/powerful-text-augmentation-using-nlpaug-5851099b4e97"><div class="ou ab fo"><div class="ov ab ow cl cj ox"><h2 class="bd ja gy z fp oy fr fs oz fu fw iz bi translated">使用NLPAUG的强大文本增强！</h2><div class="pa l"><h3 class="bd b gy z fp oy fr fs oz fu fw dk translated">通过文本增强技术处理NLP分类问题中的类别不平衡</h3></div><div class="pb l"><p class="bd b dl z fp oy fr fs oz fu fw dk translated">towardsdatascience.com</p></div></div><div class="pc l"><div class="pj l pe pf pg pc ph ky ot"/></div></div></a></div><div class="oq or gp gr os ot"><a rel="noopener follow" target="_blank" href="/effortless-exploratory-data-analysis-eda-201c99324857"><div class="ou ab fo"><div class="ov ab ow cl cj ox"><h2 class="bd ja gy z fp oy fr fs oz fu fw iz bi translated">轻松的探索性数据分析(EDA)</h2><div class="pb l"><p class="bd b dl z fp oy fr fs oz fu fw dk translated">towardsdatascience.com</p></div></div><div class="pc l"><div class="pk l pe pf pg pc ph ky ot"/></div></div></a></div><p id="548e" class="pw-post-body-paragraph lx ly iq lz b ma ni ka mc md nj kd mf mg nk mi mj mk nl mm mn mo nm mq mr ms ij bi translated">查看我的<a class="ae le" href="https://github.com/rajlm10" rel="noopener ugc nofollow" target="_blank"> <strong class="lz ja"> GitHub </strong> </a>其他一些项目。可以联系我<a class="ae le" href="https://rajsangani.me/" rel="noopener ugc nofollow" target="_blank"> <strong class="lz ja"> <em class="mt">这里</em> </strong> </a> <strong class="lz ja"> <em class="mt">。</em> </strong>感谢您的配合！</p></div></div>    
</body>
</html>