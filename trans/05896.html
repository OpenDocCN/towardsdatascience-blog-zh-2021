<html>
<head>
<title>Python’s Most Confusing Operator</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python最令人困惑的操作符</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/pythons-most-confusing-operator-96c67d6e661a?source=collection_archive---------14-----------------------#2021-05-26">https://towardsdatascience.com/pythons-most-confusing-operator-96c67d6e661a?source=collection_archive---------14-----------------------#2021-05-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8360" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">有趣地看看Python的加等于运算符的怪癖和特性</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/58f0e71ecb2e1cbd2dd1c2df96f3330d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oFpS80A25TD7pgdSM3ml4g.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(src =<a class="ae ky" href="https://pixabay.com/images/id-534103/" rel="noopener ugc nofollow" target="_blank">https://pixabay.com/images/id-534103/</a></p></figure><h1 id="4ca5" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">介绍</h1><p id="688f" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">运算符是现代编程中绝对重要的组成部分。它们通常用于数学运算，但也可用于变异不同类型的泥沼并比较这些类型。Python编程语言有一系列不同的操作符，新的操作符也在不断增加，最新的是Python 3.8中添加的walrus操作符。实际上，我写了一篇关于该操作符的文章，这篇文章还包括了一些其他有趣改进的亮点，对于感兴趣的人来说可能值得一读:</p><div class="mn mo gp gr mp mq"><a rel="noopener follow" target="_blank" href="/my-favorite-new-features-in-python-3-8-a95d7a0a31c9"><div class="mr ab fo"><div class="ms ab mt cl cj mu"><h2 class="bd iu gy z fp mv fr fs mw fu fw is bi translated">Python 3.8中我最喜欢的新特性</h2><div class="mx l"><h3 class="bd b gy z fp mv fr fs mw fu fw dk translated">Python 3.8在几周前发布了，与其匆忙谈论新特性，我决定…</h3></div><div class="my l"><p class="bd b dl z fp mv fr fs mw fu fw dk translated">towardsdatascience.com</p></div></div><div class="mz l"><div class="na l nb nc nd mz ne ks mq"/></div></div></a></div><p id="2c13" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">一个具有一些有趣功能和怪癖的操作符是加号-equals操作符。乍一看，这似乎只是加法和断言操作符的基本组合。虽然可能是这种情况，但是有一些真正有趣的特性使这个操作符与众不同。今天，我将展示这个操作符的一些有趣的特性，并演示是什么让它如此有趣。如果您想看看这些古怪的行为，您也可以从这里获得我用来演示这些代码的笔记本的副本:</p><div class="mn mo gp gr mp mq"><a href="https://github.com/emmettgb/Emmetts-DS-NoteBooks/blob/master/Python3/interesting%20plus-equals.ipynb" rel="noopener  ugc nofollow" target="_blank"><div class="mr ab fo"><div class="ms ab mt cl cj mu"><h2 class="bd iu gy z fp mv fr fs mw fu fw is bi translated">emmett GB/Emmetts-DS-笔记本电脑</h2><div class="mx l"><h3 class="bd b gy z fp mv fr fs mw fu fw dk translated">各种项目的随机笔记本。通过创建帐户，为emmettgb/Emmetts-DS笔记本电脑的开发做出贡献…</h3></div><div class="my l"><p class="bd b dl z fp mv fr fs mw fu fw dk translated">github.com</p></div></div><div class="mz l"><div class="nk l nb nc nd mz ne ks mq"/></div></div></a></div></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><h1 id="e951" class="kz la it bd lb lc ns le lf lg nt li lj jz nu ka ll kc nv kd ln kf nw kg lp lq bi translated">加号-等号概述</h1><p id="310e" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在我们深入这个操作符的古怪之处之前，我们可能应该熟悉一下这个操作符在语言中通常是如何使用的。在这种意义上，加号-等号可以被认为是加法和断言的捷径。而不是做一些像</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="776a" class="oc la it ny b gy od oe l of og">x = 5<br/>x = x + 5<br/>print(x)</span><span id="5066" class="oc la it ny b gy oh oe l of og">10</span></pre><p id="79db" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">我们可以做些类似的事情</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="8354" class="oc la it ny b gy od oe l of og">x = 5<br/>x += 5<br/>print(x)</span></pre><p id="2d59" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">当然，这个运算符的这种使用方式归结为个人喜好。一些用户可能更喜欢后一种添加数字的方法，但是在我的主观意见中，我总是发现加号-等号运算符可以使这样的表达式更加简洁。</p><h1 id="9b2c" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">加号-等于和变异元组</h1><p id="a438" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">您可能熟悉Python中的元组和列表数据结构。这是Python中两种不同类型的可迭代一维数组，它们之间有一个关键区别。元组是不可变的结构，这意味着一旦被定义，元组就不能被改变。列表当然是可变的等价物，包含append()之类的方法。</p><p id="700c" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">虽然元组不是可变的对象，但是有一个关键的区别是许多程序员忽略了的。虽然元组本身可能不是可变的，但其中的类型仍然是可变的。元组仍然是一种数据结构，并且该元组中的数据仍然属于其各自的类型。然而，Python仍然拥有人们可能期望的来自尝试改变不可变类型的抛出。考虑到这个功能，我们可以预期下面的代码会抛出一个错误，指出元组是不可变的。</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="dc5e" class="oc la it ny b gy od oe l of og">z = (5, 10, 15)<br/>z[4] = 15</span></pre><p id="175e" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">然而，为了证明我的观点，即元组中包含的数据仍然是可变的，如果我们要从元组中取出一些数据，我们可以对其进行变异:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="01b8" class="oc la it ny b gy od oe l of og">newnum = z[3]</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/dd27c9d416ed52a92b5875e72df7ae2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:814/format:webp/1*m9cKyWE6vqesoibKGfV1Jw.png"/></div></figure><blockquote class="oj"><p id="5e4b" class="ok ol it bd om on oo op oq or os mm dk translated">愚蠢的Julia程序员，在Python中索引从零开始。</p></blockquote><pre class="ot ou ov ow ox nx ny nz oa aw ob bi"><span id="cc63" class="oc la it ny b gy od oe l of og">newnum = z[2]<br/>newnum += 5<br/>print(newnum)</span><span id="a669" class="oc la it ny b gy oh oe l of og">20</span></pre><p id="3bd5" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">考虑下面的列表元组:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="04d1" class="oc la it ny b gy od oe l of og">letters = (["S", "T"],<br/>                 ["A", "D"])</span></pre><p id="1fc1" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">元组本身是不可变的类型。然而，其中的列表，一个是字母表中L后面的字母，另一个是前面的字母，仍然是可变的。如果我们现在尝试在列表中添加一个新字母，你认为会发生什么？</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="aac4" class="oc la it ny b gy od oe l of og">letters[0] += "Q"</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oy"><img src="../Images/a4938698aac3546cca10a1867e1b5d47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1284/format:webp/1*vi61yu8g9IUW4UCKiSzyPw.png"/></div></figure><p id="a76a" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">不出所料，我们得到了另一个类型错误，因为元组一旦创建就不能变异。然而，只有在数据结构上调用我们的操作符之后，才会抛出这种类型错误。换句话说，我们可能遇到了一个异常，但是如果我们现在从元组中打印出我们的列表，我们将看到该元素实际上已经被追加到我们的列表中:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="cadc" class="oc la it ny b gy od oe l of og">print(letters[0])</span><span id="4c4c" class="oc la it ny b gy oh oe l of og">['S', 'T', 'Q']</span></pre><p id="dd9a" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">关于这一点需要注意的一点是，它不能直接处理数据类型。关于Python有趣的事情是，基本上在库内的数据类型和我们可能在库外使用的数据类型之间没有关键的区别。这意味着我们可以用纯Python重写这些类型。这与大多数语言不同，大多数语言通常包含基本的数据类型，而这些数据类型不是语言本身结构化的。</p><p id="9d01" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">信不信由你，这种类型错误和元组可变性是Python的一个特性，而不是bug。乍一看，这里似乎犯了某种错误，但是考虑到Python的方法论，这在某种程度上确实是有意义的。这都与Python如何处理数据有关，更重要的是，plus-equals如何处理不同的数据类型。这也是加号-equals如此棒的部分原因！</p><h1 id="98f4" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">看看加号等于</h1><p id="59cc" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">既然我们知道了加等于运算符有多奇怪，那么让我们来看看运算符实际上是如何工作的，以便更好地理解其用法中的奇怪现象是如何产生的。当然，这将是Python在这个操作符上实现相同功能的一个更粗糙的版本。代码看起来就像我们期望的那样:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="f818" class="oc la it ny b gy od oe l of og">def plusequals(num1, num2):<br/>    total = num1.__iadd__(num2)<br/>    num1 = total</span></pre><p id="8e34" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">然而，每当我们处理更大的表达式，而不是简单的数据类型时，我们可以认为代码看起来更像这样:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="338a" class="oc la it ny b gy od oe l of og">def plusequals(x[0], element):</span><span id="9489" class="oc la it ny b gy oh oe l of og">    total = x[0].__iadd__(element)<br/>   x[0] = total</span></pre><p id="f335" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">当然，正如我们前面提到的，对于从元组中提取的元素，加法是完全可能的。然而，每当我们将x的第一个(第零个)索引赋给新的总数时，就会遇到元组的类型错误。</p></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><h1 id="2ae3" class="kz la it bd lb lc ns le lf lg nt li lj jz nu ka ll kc nv kd ln kf nw kg lp lq bi translated">结论</h1><p id="356c" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">加号-等号运算符肯定比第一次看到的要多。简单的代码允许它做一些非常有趣和古怪的事情，它甚至可以用来提供对Python编程的更坚实的理解。之所以认为这是一个特性，而不是一个错误，是因为事实上这正是操作符的工作方式。简单数据类型(如整数)的基本操作实际上完全依赖于这一点，因此它不是必须改变的东西是有意义的。也就是说，虽然它有点古怪和令人困惑，但它确实很酷！感谢您的阅读！</p></div></div>    
</body>
</html>