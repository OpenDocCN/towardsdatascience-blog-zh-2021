<html>
<head>
<title>SVM Talking algos: Using Interior Point Methods for SVM Training</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SVM说话算法:使用内点方法进行SVM训练</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/svm-talking-algos-using-interior-point-methods-for-svm-training-d705cdf78c94?source=collection_archive---------21-----------------------#2021-10-18">https://towardsdatascience.com/svm-talking-algos-using-interior-point-methods-for-svm-training-d705cdf78c94?source=collection_archive---------21-----------------------#2021-10-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="6e35" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/hands-on-tutorials" rel="noopener" target="_blank">实践教程</a></h2><div class=""/><div class=""><h2 id="be5b" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">使用优化方法从头开始训练支持向量分类器</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ko"><img src="../Images/0be8e2b3a6a289bf0bc2102d89686c77.png" data-original-src="https://miro.medium.com/v2/resize:fit:1080/format:webp/1*WRt7jEmSZr7i5vM2copzLg.png"/></div></figure><p id="569b" class="pw-post-body-paragraph kw kx iq ky b kz la ka lb lc ld kd le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">好了，伙计们！我们已经讨论了约束优化的<a class="ae ls" href="https://medium.com/@marialavrovskaya/svm-talking-maths-quadratic-programming-and-cholesky-factorisation-968a493db10b" rel="noopener">预备知识</a>和<a class="ae ls" rel="noopener" target="_blank" href="/svm-talking-maths-formulating-support-vector-machine-as-a-quadratic-programming-problem-ab5d30a8d73e">将支持向量机分类问题公式化为二次规划</a> (QP)。今天我们学习如何数字训练支持向量分类器<strong class="ky ja">。</strong></p><p id="e533" class="pw-post-body-paragraph kw kx iq ky b kz la ka lb lc ld kd le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这篇文章可以分为两部分:理论和实践！如果你以前遇到过内点方法，你可以跳过理论部分，向下滚动到我们的实际例子！</p><p id="b9ca" class="pw-post-body-paragraph kw kx iq ky b kz la ka lb lc ld kd le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，我们试图从障碍方法出发，给内点方法提供一些直观。第二，我们制定原始对偶方法，直接来自修改KKT条件。这可能现在没有意义，但是当你读的时候会明白的！最后，我们从头开始编写我们的分类器——这是之前学习的所有构建模块汇集的地方。</p><h1 id="c4da" class="lt lu iq bd lv lw lx ly lz ma mb mc md kf me kg mf ki mg kj mh kl mi km mj mk bi translated">理论！支持向量分类器如QP</h1><p id="cdef" class="pw-post-body-paragraph kw kx iq ky b kz ml ka lb lc mm kd le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">我们从<a class="ae ls" rel="noopener" target="_blank" href="/svm-talking-maths-formulating-support-vector-machine-as-a-quadratic-programming-problem-ab5d30a8d73e">开始，回忆</a>支持向量分类器可以通过它的对偶表示为二次规划</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/620cadc3d266023974f7a31d48ef3d6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:740/0*qoJEuXv0bIlPem2b"/></div><p class="mr ms gj gh gi mt mu bd b be z dk translated">SVM扮演QP</p></figure><p id="16cd" class="pw-post-body-paragraph kw kx iq ky b kz la ka lb lc ld kd le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在哪里</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/ddcf32bff9887cdc547f957f775baee3.png" data-original-src="https://miro.medium.com/v2/resize:fit:908/0*IaZ_zYEo2lywTkag"/></div></figure><p id="b467" class="pw-post-body-paragraph kw kx iq ky b kz la ka lb lc ld kd le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是我们的优化问题！现在让我们学习如何用数字来解决它。</p><h1 id="eb8b" class="lt lu iq bd lv lw lx ly lz ma mb mc md kf me kg mf ki mg kj mh kl mi km mj mk bi translated">建立你的直觉:内点方法</h1><p id="9863" class="pw-post-body-paragraph kw kx iq ky b kz ml ka lb lc mm kd le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">内点法背后的重要思想是，它们试图通过将牛顿法应用于一系列的<strong class="ky ja">等式</strong>约束问题或一系列的<strong class="ky ja">修改的</strong>版本的KKT条件，来解决问题(上文所述)或KKT条件(为上文问题制定的)。两个自然的问题是:不平等约束在哪里消失，什么是KKT条件的修改版本？</p><p id="8ebe" class="pw-post-body-paragraph kw kx iq ky b kz la ka lb lc ld kd le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">前者可以很容易地通过屏障方法观察，帮助后者建立直觉。让我们直入主题吧🚀</p><h2 id="451e" class="mw lu iq bd lv mx my dn lz mz na dp md lf nb nc mf lj nd ne mh ln nf ng mj iw bi translated">不等式约束在哪里消失？</h2><p id="348f" class="pw-post-body-paragraph kw kx iq ky b kz ml ka lb lc mm kd le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">我们试图将不等式约束问题(如上所述)近似公式化为等式约束问题，牛顿的方法可以应用于该等式约束问题。我们的第一步是通过使不等式约束隐含在目标中来重写问题(让我们采用这里讨论的一般形式<a class="ae ls" href="https://medium.com/@marialavrovskaya/svm-talking-maths-quadratic-programming-and-cholesky-factorisation-968a493db10b" rel="noopener"/>)。这是通过引入指示器函数来实现的。因此我们有</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/09abc4b6b81d1315f456f993727044dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:580/0*b5MWDkSrHUvfDira"/></div></figure><p id="cfda" class="pw-post-body-paragraph kw kx iq ky b kz la ka lb lc ld kd le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">到目前为止一切顺利。这里唯一的问题是，这个目标不能是两次可微的，这意味着我们的假设被违反，我们不能对它应用牛顿的方法。那么我们能做什么呢？</p><p id="7056" class="pw-post-body-paragraph kw kx iq ky b kz la ka lb lc ld kd le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们再近似一次！现在我们想用可微的东西来近似指标函数。可能我们有一个！我们用另一个函数来近似指示函数</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/57938a18e018dcebfa256078380d883a.png" data-original-src="https://miro.medium.com/v2/resize:fit:494/0*_-kL71vi0zA_GyeZ"/></div></figure><p id="a0b2" class="pw-post-body-paragraph kw kx iq ky b kz la ka lb lc ld kd le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">其中<em class="nj"> t </em> &gt; 0是设置近似精度的参数。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="nl nm di nn bf no"><div class="gh gi nk"><img src="../Images/68744a42850bbb347e232aceb97fe596.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aA-ofHQ0OxbM97MGViVJ9A.png"/></div></div><p class="mr ms gj gh gi mt mu bd b be z dk translated">作者创建的图像。灵感来源于[1]</p></figure><p id="e158" class="pw-post-body-paragraph kw kx iq ky b kz la ka lb lc ld kd le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该图显示了不同的<em class="nj"> t=0.5，2，4，5的近似精度。</em>蓝线(<em class="nj"> t=5 </em>)表明随着<em class="nj"> t </em>参数的增加，我们有了更好的近似值。</p><p id="f7fc" class="pw-post-body-paragraph kw kx iq ky b kz la ka lb lc ld kd le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这给了我们一个新的优化问题。通过将目标乘以<em class="nj"> t，</em>我们得到具有相同最小化器的等价最小化问题</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi np"><img src="../Images/50ee270714dda1fe066a381311f9a930.png" data-original-src="https://miro.medium.com/v2/resize:fit:692/0*Es-4DPh1NKqfjWSt"/></div></figure><p id="7229" class="pw-post-body-paragraph kw kx iq ky b kz la ka lb lc ld kd le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">新函数<em class="nj"> phi </em>被称为对数障碍，它说明了不等式约束<em class="nj">。</em></p><h2 id="6e32" class="mw lu iq bd lv mx my dn lz mz na dp md lf nb nc mf lj nd ne mh ln nf ng mj iw bi translated">什么是修正的KKT条件？</h2><p id="3fcd" class="pw-post-body-paragraph kw kx iq ky b kz ml ka lb lc mm kd le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">我们现在考虑上面写的问题。对于每一个<em class="nj"> t &gt; 0 </em>我们<em class="nj"> </em>定义<em class="nj"> x*(t) </em>为解。当我们应用<a class="ae ls" href="https://en.wikipedia.org/wiki/Newton%27s_method_in_optimization" rel="noopener ugc nofollow" target="_blank">牛顿法</a>时，我们有中心点，它们是<em class="nj"> x*(t)。</em>该<strong class="ky ja">中心路径是</strong>严格可行的，这意味着这些中心点也满足等式条件。我们记得在梯度为零的地方发现了最小值。我们写出了拉格朗日函数</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/54847220921cebee840f2c5faebbf9d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1032/0*rcVO-E448iCjaZ7L"/></div></figure><p id="ca1a" class="pw-post-body-paragraph kw kx iq ky b kz la ka lb lc ld kd le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">想知道nu是哪里来的？如前所述，我们将最小化问题<em class="nj">全部写成拉格朗日形式的一个表达式</em>(这意味着用拉格朗日乘数为等式约束增加目标函数)。然后我们求导，让它等于零，我们记得这是最小的地方。我们陈述存在最优的<em class="nj"> nu </em>，使得表达式书面打击成立。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/6c5573b04963a944d98cfc9387b11f4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1118/0*Rlc0OA6Bgh-QjUv_"/></div></figure><p id="424f" class="pw-post-body-paragraph kw kx iq ky b kz la ka lb lc ld kd le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从上面的表达式中，我们可以推导出中心路径的一个重要性质:每个中心点<em class="nj"> x*(t) </em>产生一个对偶可行点，因此是最优解的下界<em class="nj"> p* </em>。回忆阅读此处<a class="ae ls" href="https://medium.com/@marialavrovskaya/svm-talking-maths-quadratic-programming-and-cholesky-factorisation-968a493db10b" rel="noopener"/>？</p><p id="113b" class="pw-post-body-paragraph kw kx iq ky b kz la ka lb lc ld kd le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们将λ定义如下</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/650c843bbaf211e519e8a6350d9be021.png" data-original-src="https://miro.medium.com/v2/resize:fit:384/0*3AO9osA6YPPhDrz-"/></div></figure><p id="8590" class="pw-post-body-paragraph kw kx iq ky b kz la ka lb lc ld kd le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这给了我们一个双重功能，通过插入我们的lambda，我们有</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="nl nm di nn bf no"><div class="gh gi nt"><img src="../Images/f244b299ebd05a656f6c0e7c03237b45.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*E3dWhYn6ale6QX9W"/></div></div></figure><p id="2b0e" class="pw-post-body-paragraph kw kx iq ky b kz la ka lb lc ld kd le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而在我们说二元性差距实际上为零之前，实际上我们表明它不完全是那样的。我们的二元差距等于<em class="nj"> -m/t. </em></p><p id="1665" class="pw-post-body-paragraph kw kx iq ky b kz la ka lb lc ld kd le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就改变了我们所说的KKT条件的形式。新的<strong class="ky ja">KKT条件简称为<strong class="ky ja">修正的</strong> KKT条件。因此，我们的最后一个条件被我们讨论过的二元差距所取代！</strong></p><p id="75cb" class="pw-post-body-paragraph kw kx iq ky b kz la ka lb lc ld kd le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，新的修改KKT条件，又名中心性条件，是</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/dcc83b3e58d69cc73ffb22e714f3ae2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1060/0*CEcrSp8_PrxAeP0Z"/></div><p class="mr ms gj gh gi mt mu bd b be z dk translated">修正的KKT条件</p></figure></div><div class="ab cl nv nw hu nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="ij ik il im in"><p id="f1dc" class="pw-post-body-paragraph kw kx iq ky b kz la ka lb lc ld kd le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">到目前为止一切顺利！我们提供了修改的KKT条件从何而来的直觉，这有望帮助你更好地理解内点算法背后的思想。从这一刻起，你应该记住的是修正的KKT条件，我们正试图用牛顿法解决这个系统！:)</p><h1 id="b620" class="lt lu iq bd lv lw lx ly lz ma mb mc md kf me kg mf ki mg kj mh kl mi km mj mk bi translated">数值求解:原始对偶方法</h1><p id="50b1" class="pw-post-body-paragraph kw kx iq ky b kz ml ka lb lc mm kd le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">本质上，我们将修改后的条件表示为</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/262fe51b5a813075252d331f3cea89f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:300/0*bJxr-bJOt3h2QToZ"/></div><p class="mr ms gj gh gi mt mu bd b be z dk translated">非线性方程rt</p></figure><p id="869e" class="pw-post-body-paragraph kw kx iq ky b kz la ka lb lc ld kd le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们定义的地方</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi od"><img src="../Images/f0e4db49c1ce29dd2acfd069ff324107.png" data-original-src="https://miro.medium.com/v2/resize:fit:914/0*MEhQMRHKQel_8qNm"/></div></figure><p id="1d6b" class="pw-post-body-paragraph kw kx iq ky b kz la ka lb lc ld kd le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">并且<em class="nj"> f(x) </em>是不等式约束的向量，而<em class="nj"> Df </em>是它的导数。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/bdacd4fd9264ed8544a0b1c03f0115e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:360/0*ThC0lnlU_urSQitf"/></div></figure><p id="9491" class="pw-post-body-paragraph kw kx iq ky b kz la ka lb lc ld kd le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦我们找到满足第一个方程的x，λ，nu ，这意味着我们找到了最小化器！你知道这些方程矩阵是从哪里来的吗？这确实是我们修改后的KKT条件，所有条款都在左边！</p><p id="94ef" class="pw-post-body-paragraph kw kx iq ky b kz la ka lb lc ld kd le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在应该怎么解决呢？我们考虑对于固定的<em class="nj"> t </em>求解非线性方程<em class="nj"> r_t </em>的牛顿步骤。我们将当前点和牛顿步表示为</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi of"><img src="../Images/7caaee6a5501cf169d2c4e0832e84f9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:726/0*uKEOEYd_7fpn2UX1"/></div></figure><p id="ce85" class="pw-post-body-paragraph kw kx iq ky b kz la ka lb lc ld kd le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">分别是。牛顿步骤的特征在于非线性方程</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi og"><img src="../Images/318e4aa71842128c266be27eb79047eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:786/0*G6HujJ4T_e-x19NU"/></div></figure><p id="6ade" class="pw-post-body-paragraph kw kx iq ky b kz la ka lb lc ld kd le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以根据x，λ和nu，我们有</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="nl nm di nn bf no"><div class="gh gi oh"><img src="../Images/74d27c81f14b0fb31a9147616341e81a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*sajg4CRKKpygMIx7"/></div></div><p class="mr ms gj gh gi mt mu bd b be z dk translated">最终系统</p></figure></div><div class="ab cl nv nw hu nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="ij ik il im in"><h1 id="077f" class="lt lu iq bd lv lw oi ly lz ma oj mc md kf ok kg mf ki ol kj mh kl om km mj mk bi translated">练习！翻译成代码</h1><p id="6d4d" class="pw-post-body-paragraph kw kx iq ky b kz ml ka lb lc mm kd le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">终于，我们到了！我们有最终的非线性方程，我们想用牛顿法数值求解。我们如何编码？在本教程中，我们使用Matlab</p><h2 id="fc6b" class="mw lu iq bd lv mx my dn lz mz na dp md lf nb nc mf lj nd ne mh ln nf ng mj iw bi translated">关于我们数据的注释</h2><p id="ae9a" class="pw-post-body-paragraph kw kx iq ky b kz ml ka lb lc mm kd le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">我们使用合成生成的数据集，该数据集包含两个类，并且不容易被直线分开。这个数据集是使用Python代码生成的，可以在这里访问<a class="ae ls" href="https://github.com/MariaLavrovskaya/Nowearetalking/tree/main/svm/data" rel="noopener ugc nofollow" target="_blank">。</a></p><h2 id="3d10" class="mw lu iq bd lv mx my dn lz mz na dp md lf nb nc mf lj nd ne mh ln nf ng mj iw bi translated">第一步。从CSV文件中读取数据</h2><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="on oo l"/></div></figure><h2 id="4467" class="mw lu iq bd lv mx my dn lz mz na dp md lf nb nc mf lj nd ne mh ln nf ng mj iw bi translated">第二步。将问题翻译成代码</h2><p id="0c33" class="pw-post-body-paragraph kw kx iq ky b kz ml ka lb lc mm kd le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">还记得吗，在本文的开始，我们讨论了支持向量机的QP？将它翻译成代码非常简单，因为我们1)知道目标，2)知道我们的不平等和平等约束。让我们把它放在一起。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="f784" class="pw-post-body-paragraph kw kx iq ky b kz la ka lb lc ld kd le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们首先需要创建我们的三维矩阵。回想一下，它包含x和y的乘积，因此我们写for loop来找到它。一旦找到D，我们就写出它的一阶和二阶导数。然后我们把不平等和平等约束以及它们的派生物放在一起。</p><p id="0fb7" class="pw-post-body-paragraph kw kx iq ky b kz la ka lb lc ld kd le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第33–38行显示了问题设置。回想一下，我们正试图优化<em class="nj"> x，λ和nu </em>，所以我们应该从某个地方开始！我们如何选择一个起点？你真的可以从什么开始，唯一的要求:选择应该是可行的，这意味着在这一点上问题的约束没有被违反！</p><h2 id="7a91" class="mw lu iq bd lv mx my dn lz mz na dp md lf nb nc mf lj nd ne mh ln nf ng mj iw bi translated">第三步。选择默认参数</h2><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="4abb" class="pw-post-body-paragraph kw kx iq ky b kz la ka lb lc ld kd le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">之前，我们只讨论了参数<em class="nj"> t，</em>，然而，我们也可以默认选择其他参数。原始对偶算法假设在每次迭代中<em class="nj"> t </em>都在变大，所以我们引入了<em class="nj"> m </em>常数，我们在每次迭代中用它乘以<em class="nj"> t </em>(我们将在代码中进一步看到)。<em class="nj"> tol和maxIter </em>是作为停止标准的两个参数。</p><p id="4445" class="pw-post-body-paragraph kw kx iq ky b kz la ka lb lc ld kd le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="nj"> tol </em>控制代理二元差距，所以我们只在代理二元差距非常非常小时停止。代理对偶间隙的引入是由于原始对偶方法不一定在每次迭代中都产生一定可行的点，这意味着在每次迭代中我们不一定计算对偶间隙并在它非常非常小时停止—因此，我们引入了代理对偶间隙。</p><p id="7fad" class="pw-post-body-paragraph kw kx iq ky b kz la ka lb lc ld kd le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">maxIter只是确保我们进行一定数量的迭代，这样我们就不会永远都在求解。</p><p id="50dd" class="pw-post-body-paragraph kw kx iq ky b kz la ka lb lc ld kd le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">回溯选项允许确定步长。我们将看到它是如何在算法中使用的。</p><h2 id="16ba" class="mw lu iq bd lv mx my dn lz mz na dp md lf nb nc mf lj nd ne mh ln nf ng mj iw bi translated">第四步。编写算法代码</h2><p id="779e" class="pw-post-body-paragraph kw kx iq ky b kz ml ka lb lc mm kd le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">首先，我非常感谢Marta Betcke博士，当我在UCL学习的时候，他给我介绍了数值优化。本节介绍的算法是受伦敦大学学院数值优化讲师Marta Betcke博士的启发。</p><p id="721b" class="pw-post-body-paragraph kw kx iq ky b kz la ka lb lc ld kd le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们创建一个单独的函数，它将上面定义的所有参数作为输入。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="8e8d" class="pw-post-body-paragraph kw kx iq ky b kz la ka lb lc ld kd le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们通过将<em class="nj"> r_t </em>转换为<em class="nj">deltaY</em>【1】找到了我们的<em class="nj"> deltaY </em></p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi op"><img src="../Images/7ea8821065e919071eb57b65178c57c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:478/0*DzKP1LH9yxQDDMDA"/></div></figure><h2 id="7117" class="mw lu iq bd lv mx my dn lz mz na dp md lf nb nc mf lj nd ne mh ln nf ng mj iw bi translated">第五步。确定步长</h2><p id="4c83" class="pw-post-body-paragraph kw kx iq ky b kz ml ka lb lc mm kd le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">我们找到了我们需要走的方向，但我们还没有朝这个方向迈出一步。我们应该如何确定我们的步长？我们使用<a class="ae ls" href="https://en.wikipedia.org/wiki/Line_search" rel="noopener ugc nofollow" target="_blank">线搜索</a>,但是对其进行调整以适用于原始对偶算法。</p><p id="e59c" class="pw-post-body-paragraph kw kx iq ky b kz la ka lb lc ld kd le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">基本线搜索应该通过考虑残差的范数和通过确保两个约束成立来修改。第一个约束是</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/4f97ec460eadba2fef89befbd0fedb30.png" data-original-src="https://miro.medium.com/v2/resize:fit:120/0*BwXGNI2EZO3Wn5lZ"/></div><p class="mr ms gj gh gi mt mu bd b be z dk translated">回溯的第一个约束</p></figure><p id="aab8" class="pw-post-body-paragraph kw kx iq ky b kz la ka lb lc ld kd le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了简单起见，这里我们假设第一个约束永远不会被违反。因此我们设置<em class="nj"> s_max=1。</em></p><p id="e7ff" class="pw-post-body-paragraph kw kx iq ky b kz la ka lb lc ld kd le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第二个约束确保</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="nl nm di nn bf no"><div class="gh gi or"><img src="../Images/995331ba1e085d2048068be5d8dcc4b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*0jr54lbLcUxiy0TN"/></div></div><p class="mr ms gj gh gi mt mu bd b be z dk translated">回溯的第二个约束</p></figure><p id="8658" class="pw-post-body-paragraph kw kx iq ky b kz la ka lb lc ld kd le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了确保第二个约束，我们需要开始回溯减少s，直到满足约束。这就是我们之前介绍的<em class="nj"> optsBT </em>选项发挥作用的地方！因为我们不希望在不满足约束的情况下永远回溯，所以我们希望确保在满足一定数量的迭代时停止。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="80b6" class="pw-post-body-paragraph kw kx iq ky b kz la ka lb lc ld kd le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们一直做这个练习，直到我们的代理对偶间隙小于容许水平，或者达到最大迭代次数！最终三重奏<em class="nj"> x_k，lambda_k和nu_k </em>将是我们的解！</p><h2 id="7ee5" class="mw lu iq bd lv mx my dn lz mz na dp md lf nb nc mf lj nd ne mh ln nf ng mj iw bi translated">第六步。行动呼吁</h2><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="7bb1" class="pw-post-body-paragraph kw kx iq ky b kz la ka lb lc ld kd le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们调用我们命名为PrimalDual的创建函数来工作！</p><h2 id="e634" class="mw lu iq bd lv mx my dn lz mz na dp md lf nb nc mf lj nd ne mh ln nf ng mj iw bi translated">第七步。绘制决策边界</h2><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="cef7" class="pw-post-body-paragraph kw kx iq ky b kz la ka lb lc ld kd le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们到了！由于我们已经记录了迭代，我们现在可以找到大于某个阈值(我们使用0.001)的支持向量！</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="nl nm di nn bf no"><div class="gh gi os"><img src="../Images/cf3a9094c0ca989202faae954312356a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qHMrVZzDQfobV-_7Z5Kmvw.png"/></div></div><p class="mr ms gj gh gi mt mu bd b be z dk translated">作者图片</p></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="nl nm di nn bf no"><div class="gh gi os"><img src="../Images/9d750b1b77e4d9b6f5732d4bf716121d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qiTvEtoP0x4cTUQGHyMZEQ.png"/></div></div><p class="mr ms gj gh gi mt mu bd b be z dk translated">作者图片</p></figure><p id="c489" class="pw-post-body-paragraph kw kx iq ky b kz la ka lb lc ld kd le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">回想一下，我们的<em class="nj"> infoPD </em>结构还包含了每次迭代中代理对偶间隙的信息。通过将它绘制成迭代次数的函数，我们可以看到它在快速下降。它不会精确地归零，但它比我们一开始设置的<em class="nj"> tol=1e-12 </em>要小。</p><p id="3efc" class="pw-post-body-paragraph kw kx iq ky b kz la ka lb lc ld kd le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ja">参考文献:</strong></p><p id="8fed" class="pw-post-body-paragraph kw kx iq ky b kz la ka lb lc ld kd le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">[1] V. L. Boyd Stephen，<em class="nj">凸优化</em>。2004.</p></div></div>    
</body>
</html>