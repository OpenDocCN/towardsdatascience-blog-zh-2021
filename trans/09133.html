<html>
<head>
<title>The Danger of Random Seeds</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">随机种子的危险</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/the-danger-of-random-seeds-fa1c728c1121?source=collection_archive---------31-----------------------#2021-08-23">https://towardsdatascience.com/the-danger-of-random-seeds-fa1c728c1121?source=collection_archive---------31-----------------------#2021-08-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1df6" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">R中的一个案例研究，讲述了迂腐地使用随机种子会导致不想要的结果。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/349db47210f82e465b4e76d77cc0dfe2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*myYVXd_PpnZntQK_royQtg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">凯文·杰瑞特在<a class="ae ky" href="https://unsplash.com/s/photos/danger?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="5f9a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">手动设置<a class="ae ky" href="https://en.wikipedia.org/wiki/Random_number_generation" rel="noopener ugc nofollow" target="_blank">(伪)随机发生器</a>的种子是一把双刃剑:</p><ul class=""><li id="b25b" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">这确实意味着运行相同的脚本将总是产生相同的结果，从而使<strong class="lb iu">实验可重复</strong>；</li><li id="bd42" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">但是它也可能从随机性中带走比你想要的更多的东西，从而使<strong class="lb iu">实验潜在地变得无用</strong>。</li></ul><p id="79cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是前阵子发生在我一个…咳咳…朋友身上的事。回想起来，这是一个非常明显的错误，但是我并没有经常看到这种情况，所以我很确定其他人也会遇到这种问题。</p><p id="e525" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看我的朋友做错了什么，让他的例子成为所有人的警告标志！</p><h1 id="efb3" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">这个计划</h1><p id="ea55" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">我的朋友想要实现的是:</p><ul class=""><li id="20b6" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">生成10k个随机数，在0和10之间均匀分布，我们称此列为<code class="fe ng nh ni nj b">x</code>；</li><li id="4553" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">做一些其他的事情；</li><li id="7191" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">生成另一组10k随机数，这次是从一个<a class="ae ky" href="https://en.wikipedia.org/wiki/Poisson_distribution" rel="noopener ugc nofollow" target="_blank">泊松分布</a>，λ=<code class="fe ng nh ni nj b">x</code>，让我们称这个列为<code class="fe ng nh ni nj b">y</code>。</li></ul><p id="7b29" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">他还希望能够引用结果并使它们可重复，所以他设置了一个随机种子。他用R语言编程的方式:</p><pre class="kj kk kl km gt nk nj nl nm aw nn bi"><span id="9e2b" class="no mk it nj b gy np nq l nr ns">library(data.table)</span><span id="d214" class="no mk it nj b gy nt nq l nr ns">my_random_seed &lt;- 123</span><span id="c595" class="no mk it nj b gy nt nq l nr ns">set.seed(my_random_seed)<br/>tbl &lt;- data.table(x = runif(10000) * 10)</span><span id="f803" class="no mk it nj b gy nt nq l nr ns"># ... other stuff ...</span><span id="4635" class="no mk it nj b gy nt nq l nr ns">set.seed(my_random_seed)<br/>tbl[, y := rpois(10000, x)]</span></pre><blockquote class="nu"><p id="2722" class="nv nw it bd nx ny nz oa ob oc od lu dk translated">你能看出他做错了什么吗？</p></blockquote><p id="3c7b" class="pw-post-body-paragraph kz la it lb b lc oe ju le lf of jx lh li og lk ll lm oh lo lp lq oi ls lt lu im bi translated">(如果可以的话，你几乎可以停止阅读，因为这将是全部。)</p><h1 id="f1ee" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">有什么不对劲的迹象</h1><p id="a602" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">在找到朋友犯的错误之前，先来看看结果吧！</p><p id="18e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ng nh ni nj b">tbl</code>本身看起来是这样的:</p><pre class="kj kk kl km gt nk nj nl nm aw nn bi"><span id="c2d1" class="no mk it nj b gy np nq l nr ns">              x  y<br/>    1: 2.875775  2<br/>    2: 7.883051 10<br/>    3: 4.089769  3<br/>    4: 8.830174 12<br/>    5: 9.404673 14<br/>   ---            <br/> 9996: 4.663523  4<br/> 9997: 8.989519 13<br/> 9998: 1.135348  0<br/> 9999: 5.712259  6<br/>10000: 9.005851 13</span></pre><p id="074a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">到目前为止没有什么可疑的，泊松分布的期望值是它的λ参数，所以我们期望<code class="fe ng nh ni nj b">x</code>和<code class="fe ng nh ni nj b">y</code>接近。</p><p id="43a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，如果我们按<code class="fe ng nh ni nj b">x</code>分组调查结果，就会出现一个不太理想的画面:</p><pre class="kj kk kl km gt nk nj nl nm aw nn bi"><span id="1699" class="no mk it nj b gy np nq l nr ns">tbl[,.(y_mean = mean(y), count = .N), <br/>    keyby = .(x_rounded = round(x, 1))]</span></pre><p id="2e73" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">退货:</p><pre class="kj kk kl km gt nk nj nl nm aw nn bi"><span id="b046" class="no mk it nj b gy np nq l nr ns">     x_rounded   y_mean count<br/>  1:       0.0  0.00000    52<br/>  2:       0.1  0.00000   102<br/>  3:       0.2  0.00000   107<br/>  4:       0.3  0.00000   103<br/>  5:       0.4  0.00000   102<br/> ---                         <br/> 97:       9.6 15.16495    97<br/> 98:       9.7 16.00000    90<br/> 99:       9.8 16.74118    85<br/>100:       9.9 17.96078   102<br/>101:      10.0 20.36957    46</span></pre><p id="329a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这可不好。例如，假设泊松分布的102个随机数的λ值约为9.9，其平均值为17.96。</p><p id="5bde" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">总数也不匹配。每个泊松都有其各自λ的期望值，正如我们所知，对于独立变量，期望值相加，因此我们会期望<code class="fe ng nh ni nj b">x</code>和<code class="fe ng nh ni nj b">y</code>的和接近，但它们大约是50k和57k。</p><p id="ec4c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好吧，再多一点来说明问题，策划<code class="fe ng nh ni nj b">x</code>对<code class="fe ng nh ni nj b">y</code>的攻击也表明有些事情显然是错误的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/fe26f1dc89833672b057976c4cb14728.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ySqaOnJRPNr2LKhs5e5zMg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">拙劣的泊松生成(作者图片)</p></figure><h1 id="0109" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">揭秘</h1><p id="10d7" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">而杀手是……(击鼓)……用同一个数字两次作为随机种子。</p><p id="f364" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在引擎盖下，当我们要求<code class="fe ng nh ni nj b">rpois</code>从一个特定的泊松分布中产生一个随机数时，它会从一个随机的均匀数开始，并使用反演技术找到相应的值。(至少对于小lambda来说是这样。否则，它似乎是使用一个正常的近似值，但我很肯定，这也归结为一个随机的统一数字。详情请看<a class="ae ky" href="https://github.com/SurajGupta/r-source/blob/master/src/nmath/rpois.c" rel="noopener ugc nofollow" target="_blank">源代码</a>。)</p><p id="5d92" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以我们有一个随机的统一号，姑且称之为<code class="fe ng nh ni nj b">w</code>。泊松生成然后将使用累积分布函数(CDF)找到整数<code class="fe ng nh ni nj b">u</code>，其中<code class="fe ng nh ni nj b">CDF(u-1) &lt; w ≤ CDF(u)</code>，然后生成的数字将是<code class="fe ng nh ni nj b">u</code>。(这里不要引用我的话，只是大概的想法。)</p><blockquote class="nu"><p id="1772" class="nv nw it bd nx ny ok ol om on oo lu dk translated">问题是，在我们的例子中，这个随机的均匀数将总是来自与泊松分布的λ相同的随机种子。</p></blockquote><p id="3f79" class="pw-post-body-paragraph kz la it lb b lc oe ju le lf of jx lh li og lk ll lm oh lo lp lq oi ls lt lu im bi translated">具体来说，λ将与随机统一数乘以10相同。(这就是我们最初生成数据的方式，得到一个U(0，10)分布。)</p><h1 id="de9e" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">重现问题</h1><p id="49f4" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">我们可以很容易地重现正在发生的事情。首先，生成CDF值(是的，有一个内置函数，但我认为从头开始做会很有趣):</p><pre class="kj kk kl km gt nk nj nl nm aw nn bi"><span id="eda0" class="no mk it nj b gy np nq l nr ns">tbl[,cdf0 := x^0 * exp(-x) / factorial(0)]<br/>tbl[,cdf1 := cdf0 + x^1 * exp(-x) / factorial(1)]<br/>tbl[,cdf2 := cdf1 + x^2 * exp(-x) / factorial(2)]<br/>tbl[,cdf3 := cdf2 + x^3 * exp(-x) / factorial(3)]<br/>...</span></pre><p id="97e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们使用这些来“生成”我们自己的“泊松”(观察我们如何使用<code class="fe ng nh ni nj b">x/10</code>作为“随机”均匀数):</p><pre class="kj kk kl km gt nk nj nl nm aw nn bi"><span id="96c0" class="no mk it nj b gy np nq l nr ns">tbl[y2 := NULL]<br/>tbl[x/10 &lt;= cdf0, y2:=0]<br/>tbl[x/10 &gt; cdf0 &amp; x/10 &lt;= cdf1, y2:=1]<br/>tbl[x/10 &gt; cdf1 &amp; x/10 &lt;= cdf2, y2:=2]<br/>tbl[x/10 &gt; cdf2 &amp; x/10 &lt;= cdf3, y2:=3]<br/>...</span></pre><p id="91d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，如果我们检查<code class="fe ng nh ni nj b">tbl</code>，我们将看到列<code class="fe ng nh ni nj b">y</code>(最初的泊松生成)和<code class="fe ng nh ni nj b">y2</code>(我们的重新计算)将匹配。</p><h1 id="213b" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">如何避免这种情况</h1><p id="25d2" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">我觉得意识到这种对随机种子的潜在滥用是成功的一半。然后，您可以在每个环境中只设置一次随机种子，使用不同的种子，或者干脆不使用它们。</p><p id="b1d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个话题的另一个有趣的角度来自<a class="ae ky" href="https://www.johndcook.com/blog/2016/01/29/random-number-generator-seed-mistakes/" rel="noopener ugc nofollow" target="_blank">johndcook.com</a>，作者警告在一个序列中使用太多的随机数作为种子，因为你会比你预期的更快地遇到重复的数字。这篇文章使用16位整数进行计算，而<a class="ae ky" href="https://stat.ethz.ch/R-manual/R-devel/library/base/html/Random.html" rel="noopener ugc nofollow" target="_blank"> R的随机数生成器</a>使用32位整数作为默认值(至少这是我的理解)，但我认为这个建议仍然有效。</p><p id="bb04" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">stats.statexchange.com<a class="ae ky" href="https://stats.stackexchange.com/questions/205961/if-so-many-people-use-set-seed123-doesnt-that-affect-randomness-of-worlds-re" rel="noopener ugc nofollow" target="_blank">上有一些值得思考的东西，如果太多人使用相同的随机种子会发生什么(就像我朋友用123)，如果人们一直选择相同的4-5个数字，会不会导致任何问题。可悲的是，讨论没有结论。我猜正确的解决方案是生成一个足够大范围的随机整数，并使用它作为种子，而不是通常的123、1234、100、42等。</a></p></div></div>    
</body>
</html>