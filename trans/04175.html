<html>
<head>
<title>Political Polling Data from Wikipedia with Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Python处理维基百科上的政治投票数据</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/political-polling-data-from-wikipedia-with-python-b71a9b291d7c?source=collection_archive---------27-----------------------#2021-04-08">https://towardsdatascience.com/political-polling-data-from-wikipedia-with-python-b71a9b291d7c?source=collection_archive---------27-----------------------#2021-04-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="3e93" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用Python中的Requests、pandas和正则表达式从Wikipedia中获取和清理爱尔兰政治投票数据，以便为分析做好准备。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/adacf4bec5ccaa6a419288de0bf44dd3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zWO9XExjgJ5E5l7p"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">阿诺·杰格斯在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><h1 id="aa75" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated"><strong class="ak">简介</strong></h1><p id="023a" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">在2011年的爱尔兰大选中，即将离任的政府中的政党(共和党和绿党)在投票中一败涂地。在2007年的大选中赢得了77个席位的共和党最终只获得了20个席位。绿党失去了他们在2007年赢得的所有六个席位。</p><p id="4263" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我想获得民意调查数据，以了解在那个时期爱尔兰政党的公众支持率是如何逐渐下降或上升的。当事人高峰在哪里？支持率的变化是否与当时的特定事件——失业率、新政党领导人等——相一致。？</p><p id="c7e1" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><strong class="lq ir">要求</strong></p><p id="12e4" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在本文中，我主要关注收集和清理轮询数据。</p><p id="549d" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我们将使用请求库连接到维基百科来获取数据。然后，我们将使用pandas库本身将其加载到pandas数据帧中。数据不会是完美的，所以我们需要在使用它之前对其进行清理。</p><p id="4825" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">模块是Python标准库的一部分。但是如果您需要安装pandas或requests，请查看它们文档中的安装部分:</p><div class="mq mr gp gr ms mt"><a href="https://docs.python-requests.org/en/master/user/install/" rel="noopener  ugc nofollow" target="_blank"><div class="mu ab fo"><div class="mv ab mw cl cj mx"><h2 class="bd ir gy z fp my fr fs mz fu fw ip bi translated">安装请求-请求2.25.1文档</h2><div class="na l"><h3 class="bd b gy z fp my fr fs mz fu fw dk translated">文档的这一部分涵盖了请求的安装。使用任何软件包的第一步是…</h3></div><div class="nb l"><p class="bd b dl z fp my fr fs mz fu fw dk translated">docs.python-requests.org</p></div></div></div></a></div><div class="mq mr gp gr ms mt"><a href="https://pandas.pydata.org/pandas-docs/stable/getting_started/install.html" rel="noopener  ugc nofollow" target="_blank"><div class="mu ab fo"><div class="mv ab mw cl cj mx"><h2 class="bd ir gy z fp my fr fs mz fu fw ip bi translated">安装- pandas 1.2.3文档</h2><div class="na l"><h3 class="bd b gy z fp my fr fs mz fu fw dk translated">安装pandas最简单的方法是将其安装为Anaconda发行版的一部分，这是一个跨平台发行版…</h3></div><div class="nb l"><p class="bd b dl z fp my fr fs mz fu fw dk translated">pandas.pydata.org</p></div></div></div></a></div><p id="8041" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我在示例中使用Jupyter笔记本(作为Anaconda Navigator的一部分)来展示结果。有关如何安装的信息，请参见此处的文档<a class="ae kv" href="https://docs.anaconda.com/anaconda/navigator/install/" rel="noopener ugc nofollow" target="_blank"/>。</p><h1 id="e088" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">寻找数据</h1><p id="e958" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">获取数据的第一步是找到可以处理数据的地方。维基百科有大量关于选举和政治的数据。爱尔兰许多大选的文章都有自上次大选以来的投票数据。<a class="ae kv" href="https://en.wikipedia.org/wiki/2011_Irish_general_election" rel="noopener ugc nofollow" target="_blank">这里的</a>是我曾经处理过的文章。</p><h1 id="61b0" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">步骤1 —发出HTTP请求</h1><p id="b24e" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">首先，我们导入我们需要的库和模块。</p><pre class="kg kh ki kj gt nc nd ne nf aw ng bi"><span id="629a" class="nh kx iq nd b gy ni nj l nk nl">import pandas as pd<br/>import requests<br/>import re</span></pre><p id="2aad" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">接下来，我们将添加我们的数据所在的URL，以便我们可以轻松地将它传递给访问它的请求。</p><pre class="kg kh ki kj gt nc nd ne nf aw ng bi"><span id="4a21" class="nh kx iq nd b gy ni nj l nk nl">url = "<a class="ae kv" href="https://en.wikipedia.org/wiki/2011_Irish_general_election" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/2011_Irish_general_election</a>"</span></pre><p id="eb60" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">现在，我们发出请求，并将响应设置为一个名为<em class="mp"> data </em>的变量</p><pre class="kg kh ki kj gt nc nd ne nf aw ng bi"><span id="4337" class="nh kx iq nd b gy ni nj l nk nl">data = requests.get(url)</span></pre><p id="7c3c" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在<em class="mp">数据</em>中，我们现在应该在我们的URL上有HTML数据，以及关于请求的许多其他信息。例如，我们可以检查响应代码以确保请求成功:</p><pre class="kg kh ki kj gt nc nd ne nf aw ng bi"><span id="419e" class="nh kx iq nd b gy ni nj l nk nl">data.status_code<br/>&gt;&gt;200</span></pre><p id="1da6" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在本例中是这样的，我们感兴趣的响应部分是HTML内容:</p><pre class="kg kh ki kj gt nc nd ne nf aw ng bi"><span id="65c3" class="nh kx iq nd b gy ni nj l nk nl">data.content</span></pre><h1 id="c502" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">步骤2-将数据放入熊猫数据框架</h1><p id="fefd" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">熊猫可以使用它的<em class="mp"> read_html() </em>方法读取HTML表格。该方法将返回您传入的内容中的所有表格，将每个表格转换为dataframe，并将其存储在一个列表中。</p><p id="1c03" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我们可以通过传入<em class="mp"> data.content </em>来获取页面上的所有表格，但是我们可以使用match参数更具体地获取。</p><p id="624a" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">正如熊猫医生所说，使用这个:</p><blockquote class="nm nn no"><p id="1a6c" class="lo lp mp lq b lr mk jr lt lu ml ju lw np mm lz ma nq mn md me nr mo mh mi mj ij bi translated">将返回包含与该正则表达式或字符串匹配的文本的表集。</p></blockquote><p id="4d65" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在维基百科页面上，我们可以看到这几乎是唯一一个关于投票数据的表格。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/61789f08e76fb06da99096ec31142ec1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1322/format:webp/1*nCNiXXlPjroCMT6SAiZsfA.png"/></div></figure><p id="d964" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我们将添加“投票代理”作为匹配参数。</p><pre class="kg kh ki kj gt nc nd ne nf aw ng bi"><span id="be01" class="nh kx iq nd b gy ni nj l nk nl">tables = pd.read_html(data.content, flavor='bs4', match = "Polling Agency")</span></pre><p id="4c00" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">现在，在表中我们应该有一个数据帧列表(希望只有一个)。如果我们对它运行<em class="mp"> len() </em>，我们可以看到情况是这样的:</p><pre class="kg kh ki kj gt nc nd ne nf aw ng bi"><span id="b112" class="nh kx iq nd b gy ni nj l nk nl">len(tables)<br/>&gt;&gt;1</span></pre><p id="5586" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">因此，它将是列表中第一个也是唯一一个数据帧。我们将它保存在下面的变量中:</p><pre class="kg kh ki kj gt nc nd ne nf aw ng bi"><span id="1c0d" class="nh kx iq nd b gy ni nj l nk nl">polling_data_2011 = tables[0]</span></pre><p id="397a" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">让我们看看前20行:</p><pre class="kg kh ki kj gt nc nd ne nf aw ng bi"><span id="76da" class="nh kx iq nd b gy ni nj l nk nl">polling_data_2011[0:20]</span></pre><p id="27e3" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我们可以看到它做得相当不错。看起来没有太多丢失的数据，但是我们需要做一些更新。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nt"><img src="../Images/b94e3386d5db177bee17fba4a4791c75.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_pTdD-SY-3iJUHAD-nadDA.png"/></div></div></figure><h1 id="f948" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">步骤3 —清理数据</h1><p id="53af" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">我们有数据，但正如我们所看到的，有一些问题。</p><ol class=""><li id="cc60" class="nu nv iq lq b lr mk lu ml lx nw mb nx mf ny mj nz oa ob oc bi translated">最好也将日期存储在三个单独的列中:日/月/年。那么就更容易看到年复一年的变化。</li><li id="80da" class="nu nv iq lq b lr od lu oe lx of mb og mf oh mj nz oa ob oc bi translated">在<em class="mp">来源</em>栏中，我们有维基百科的参考号。我们希望去掉它们，因为它们实际上不是源名称的一部分。</li><li id="3971" class="nu nv iq lq b lr od lu oe lx of mb og mf oh mj nz oa ob oc bi translated">我们想删除<em class="mp"> %s </em>，这样我们就可以处理数字数据了。</li><li id="4f6c" class="nu nv iq lq b lr od lu oe lx of mb og mf oh mj nz oa ob oc bi translated">最后，您会注意到在<em class="mp">轮询代理</em>列中有一些<em class="mp"> NaN </em>值。在这种情况下，这是因为这些争吵根本不是民意调查，而是实际的选举结果——我们有通用电气的结果，以及一些欧洲和地方选举结果。我们要做的是创建另一列，将该行分类为选举数据或民意测验数据。这样，如果我们愿意，我们将能够轻松地处理民意调查数据。</li></ol><h2 id="80d6" class="nh kx iq bd ky oi oj dn lc ok ol dp lg lx om on li mb oo op lk mf oq or lm os bi translated">将日期解析为三列</h2><p id="0b1f" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">我们创建了三个想要匹配的正则表达式。一个用于日，一个用于月，一个用于年。然后，我们遍历date列中的每个字段，获取其索引和值，并根据值检查正则表达式。然后，我们将找到的值插入到它自己的新列中——我们对所有三个列都这样做。</p><pre class="kg kh ki kj gt nc nd ne nf aw ng bi"><span id="f68a" class="nh kx iq nd b gy ni nj l nk nl">day_re = "[0-9]+"<br/>month_re = "[A-Z][a-z]+"<br/>year_re = "[0-9]{4}"</span><span id="932b" class="nh kx iq nd b gy ot nj l nk nl">for index, value in polling_data_2011["Date"].items():<br/>    #day<br/>    match = re.search(day_re, value)<br/>    if match:<br/>        polling_data_2011.loc[index,"Poll_day"] = match.group()<br/>      <br/>    #month<br/>    match = re.search(month_re, value)<br/>    if match:<br/>        polling_data_2011.loc[index, "Poll_month"] = match.group()<br/>    <br/>    #year<br/>    match = re.search(year_re, value)<br/>    if match:<br/>        polling_data_2011.loc[index, "Poll_year"] = match.group()</span></pre><p id="6a51" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我们现在有三个新列:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ou"><img src="../Images/23b55a1defc744b0f3f1a8571f96860e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zABneEiKLpTZq8cIz7zuMQ.png"/></div></div></figure><h2 id="298e" class="nh kx iq bd ky oi oj dn lc ok ol dp lg lx om on li mb oo op lk mf oq or lm os bi translated">清洁源柱</h2><p id="9124" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">在<em class="mp">信号源</em>栏中，在每个实际信号源名称后，参考编号以<strong class="lq ir">开头。</strong></p><p id="6657" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">因此，我们遍历<em class="mp">源</em>列中的字段，类似于我们对日期所做的。然而，这一次，我们将匹配这个正则表达式，并将new_name设置为每个字段中直到这个值的所有值。</p><p id="3d46" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">注意，在<em class="mp"> regex_to_match </em>中，我们需要对我们正在搜索的字符进行转义，因为这个字符在regex中有特殊的含义。</p><pre class="kg kh ki kj gt nc nd ne nf aw ng bi"><span id="03da" class="nh kx iq nd b gy ni nj l nk nl">regex_for_reference = "\["</span><span id="f861" class="nh kx iq nd b gy ot nj l nk nl">for index, value in polling_data_2011["Source"].items():<br/>    ref_match = re.search(regex_for_reference, value)<br/>    if ref_match:<br/>        location = ref_match.span()[0]<br/>        new_name = (value[0:location])<br/>        polling_data_2011.loc[index,"Source"] = new_name<br/>    else:<br/>        polling_data_2011.loc[index,"Source"] = value</span></pre><p id="6a5b" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">看起来更整洁:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ov"><img src="../Images/edfac128b1ed51ea5bb04b62ae12b078.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rLYBgkI6ebQTaQcuuIPJtA.png"/></div></div></figure><p id="d153" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我想检查一下没有其他明显的错误。维基百科是一个有许多贡献者的来源。也许不同的贡献者输入的名字不同。</p><p id="908c" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">让我们看看<em class="mp">源列中的所有唯一值:</em></p><pre class="kg kh ki kj gt nc nd ne nf aw ng bi"><span id="3e87" class="nh kx iq nd b gy ni nj l nk nl">polling_data_2011["Source"].unique()</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ow"><img src="../Images/0a7702b3441154be8fdcb4c49eef3793.png" data-original-src="https://miro.medium.com/v2/resize:fit:1104/format:webp/1*flwEDO02rCMOwmCZK9jhwg.png"/></div></figure><p id="a773" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我们看到其中一个来源至少在一行中有不同的表达方式——我们需要用句点(<em class="mp"> The Sunday Business Post)更新这个来源。)</em>与其他的一样(<em class="mp">《星期日商业邮报》</em>)。</p><p id="8c2c" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">让我们改变之前使用的正则表达式，并删除任何存在句点的地方:</p><pre class="kg kh ki kj gt nc nd ne nf aw ng bi"><span id="6906" class="nh kx iq nd b gy ni nj l nk nl">regex_for_period = "\."</span><span id="205b" class="nh kx iq nd b gy ot nj l nk nl">for index, value in polling_data_2011["Source"].items():<br/>    period_match = re.search(regex_for_period, value)<br/>    <br/>    if period_match:<br/>        location = period_match.span()[0]<br/>        new_name = (value[0:location])<br/>        polling_data_2011.loc[index,"Source"] = new_name</span><span id="7239" class="nh kx iq nd b gy ot nj l nk nl">    else:<br/>        polling_data_2011.loc[index,"Source"] = value</span></pre><p id="13db" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我也在<em class="mp">民调机构</em>一栏做了同样的检查。没有问题。</p><h2 id="38ba" class="nh kx iq bd ky oi oj dn lc ok ol dp lg lx om on li mb oo op lk mf oq or lm os bi translated">将带有%的列转换成我们可以处理的数字数据</h2><p id="56ee" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">这里，我们将从每个包含%的字段中删除它。让我们对每个政党都这样做。我们遍历列，然后遍历每列中的字段。在找到%之前，我们只保留所有内容。</p><p id="0076" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">注意:我们可以在这里使用<em class="mp"> find() </em>(以及在其他一些情况下)来代替<em class="mp"> re </em>，但是我们将坚持使用<em class="mp"> re </em>来保持一致。</p><pre class="kg kh ki kj gt nc nd ne nf aw ng bi"><span id="e9de" class="nh kx iq nd b gy ni nj l nk nl">regex_to_find_percent = "%"<br/>columns = ["Fianna Fáil", "Fine Gael", "Labour Party", "Green Party", "Sinn Féin", "Ind./Others"]</span><span id="1f13" class="nh kx iq nd b gy ot nj l nk nl">for column in columns:<br/>    for index, value in polling_data_2011[column].items():<br/>        match = re.search(regex_to_find_percent, value)<br/>        if match:<br/>            match_index = match.span()[0]<br/>            new_value = (value[0:match_index])<br/>            polling_data_2011.loc[index, column] = new_value</span></pre><p id="56a5" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">看起来不错:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ox"><img src="../Images/ec1b92a2752ae6698fc6bf5625ce1db2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H8g6zh6ezcgXz4PPtKxAEw.png"/></div></div></figure><p id="008a" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我们现在需要将这些列转换为float类型，这样我们就可以对它们使用pandas describe方法()等方法来查看最小值、最大值和平均值等信息。</p><pre class="kg kh ki kj gt nc nd ne nf aw ng bi"><span id="975b" class="nh kx iq nd b gy ni nj l nk nl">for column in columns:<br/>    polling_data_2011[column] = polling_data_2011[column].astype(float)</span></pre><p id="b9e3" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">现在describe()方法为我们提供了一些关于数据的描述性统计数据。</p><pre class="kg kh ki kj gt nc nd ne nf aw ng bi"><span id="0367" class="nh kx iq nd b gy ni nj l nk nl">polling_data_2011.describe()</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oy"><img src="../Images/d0e1075ec0e5e0e6f6f9f17e2d333472.png" data-original-src="https://miro.medium.com/v2/resize:fit:1028/format:webp/1*yW6QkubMczDOgS57UiALQw.png"/></div></figure><h2 id="dc86" class="nh kx iq bd ky oi oj dn lc ok ol dp lg lx om on li mb oo op lk mf oq or lm os bi translated">从选举数据中分离民意测验数据</h2><p id="c6c4" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">在上表中，我们知道有几行不是民意测验数据。让我们对每一列进行分类，这样我们就知道我们在做什么了。然后，如果我们愿意，我们将能够只处理民意调查数据。</p><p id="5356" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">实际上，我将把它分为三类:选举结果、民意调查和出口民调。我之所以这么做，是因为后两者虽然是民调，但略有不同。出口民调是基于投票后对人们的采访，而标准的民意调查是关于一个人打算如何投票。</p><p id="77ce" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我们将在source列的每个字段中检查“<em class="mp">选举</em>”和<em class="mp">“投票后调查”</em>的实例。我们还将说明它何时会以大写字母出现在句子的开头。如果我们匹配选举，我们在名为<em class="mp"> Poll_type的新列中放一个E。</em>如果我们匹配出口投票，我们将EP放入<em class="mp"> Poll_type </em>列。如果我们两个都不符合，我们假设这是一个民意调查——op。</p><pre class="kg kh ki kj gt nc nd ne nf aw ng bi"><span id="0219" class="nh kx iq nd b gy ni nj l nk nl">election_regex = "[Ee]lection"<br/>exit_poll_regex = "[Ee]xit poll"<br/>for index, value in polling_data_2011["Source"].items():<br/>    election_match = re.search(election_regex, value)<br/>    exit_poll_match = re.search(exit_poll_regex, value)<br/>    if election_match: <br/>        polling_data_2011.loc[index, "Poll_type"] = "E"<br/>    if exit_poll_match:<br/>        polling_data_2011.loc[index, "Poll_type"] = "EP"<br/>    if not election_match and not exit_poll_match:<br/>        polling_data_2011.loc[index, "Poll_type"] = "OP"</span></pre><h1 id="2a98" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">步骤4 —检查我们的数据</h1><p id="0488" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">现在我们有了最终的表格，让我们做一些检查以确保数据是正确的。</p><p id="8e5c" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">从维基百科页面的快速浏览中，我们可以看到在此期间有一次投票后调查，以及2007年和2011年的一次大选。让我们按Poll_year和Poll_type创建一个数据透视表，以确保我们与原始表相匹配。</p><pre class="kg kh ki kj gt nc nd ne nf aw ng bi"><span id="587a" class="nh kx iq nd b gy ni nj l nk nl">polling_data_2011.pivot_table(index=["Poll_year","Poll_type"])</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oz"><img src="../Images/29da1693264cb9abfdb6bc038cab14dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1246/format:webp/1*up-AojldfkqUrRlReCKsGw.png"/></div></figure><p id="3213" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在上表中，我们可以看到每年的选举结果都与维基百科页面上报道的相符。例如，2011年:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pa"><img src="../Images/69b26d0c06c552806cee448490d53ceb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fEsCNFPnc9vWGB4tj_vv7g.png"/></div></div></figure><p id="7079" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">根据原始数据，我们可以预测未来几年的选举和出口民调。数据现在看起来很好，随时可以使用。</p></div><div class="ab cl pb pc hu pd" role="separator"><span class="pe bw bk pf pg ph"/><span class="pe bw bk pf pg ph"/><span class="pe bw bk pf pg"/></div><div class="ij ik il im in"><p id="d22e" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">获取这些数据的过程非常简单。获得我想要的特定表并进行必要的数据清理非常容易。</p><p id="f8e8" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在未来，我想看看管理日期列的其他选项，并探索使用我已经完成的工作来获得额外的数据有多容易。</p></div><div class="ab cl pb pc hu pd" role="separator"><span class="pe bw bk pf pg ph"/><span class="pe bw bk pf pg ph"/><span class="pe bw bk pf pg"/></div><div class="ij ik il im in"><p id="60db" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">所有代码和表格的图片都是作者拍摄的。本文的Jupyter笔记本可以在这里找到:</p><div class="mq mr gp gr ms mt"><a href="https://github.com/LiamConnors/Medium-articles" rel="noopener  ugc nofollow" target="_blank"><div class="mu ab fo"><div class="mv ab mw cl cj mx"><h2 class="bd ir gy z fp my fr fs mz fu fw ip bi translated">Liam Connors/Medium-文章</h2><div class="na l"><h3 class="bd b gy z fp my fr fs mz fu fw dk translated">我在媒体上发表的文章的代码。为LiamConnors/Medium-articles开发创建一个…</h3></div><div class="nb l"><p class="bd b dl z fp my fr fs mz fu fw dk translated">github.com</p></div></div><div class="pi l"><div class="pj l pk pl pm pi pn kp mt"/></div></div></a></div></div></div>    
</body>
</html>