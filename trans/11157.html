<html>
<head>
<title>Keeping Kubernetes Clusters Clean and Tidy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">保持Kubernetes集群干净整洁</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/keeping-kubernetes-clusters-clean-and-tidy-fad52a37f910?source=collection_archive---------14-----------------------#2021-11-01">https://towardsdatascience.com/keeping-kubernetes-clusters-clean-and-tidy-fad52a37f910?source=collection_archive---------14-----------------------#2021-11-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="fa46" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">清除所有未使用的资源，这些资源会使您的Kubernetes集群变得杂乱并浪费其计算资源</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/25a55504ab0414586acee876890c915a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b9HFWz0pgUKmwjjAOG3tTw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@neal_johnson?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">尼尔·约翰逊</a>在<a class="ae ky" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="7ebb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">随着集群的增长，资源、卷或其他API对象的数量也会增加，迟早会达到极限。无论是<code class="fe lv lw lx ly b">etcd</code>，卷，内存还是CPU。当您可以设置简单而复杂的规则、自动化和监控来保持集群整洁时，为什么要让自己遭受不必要的痛苦和麻烦呢？这些规则、自动化和监控可以让您的集群保持整洁，而不会让流氓工作负载吃掉您的资源或到处都是陈旧的对象。</p><h1 id="b125" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">何必呢？</h1><p id="16b6" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated"><em class="mw">一些被遗忘的豆荚，未使用的持久卷，</em> <code class="fe lv lw lx ly b"><em class="mw">Completed</em></code> <em class="mw">乔布斯或者也许旧的ConfigMap/Secret无所谓，或者呢？它就放在那里，我可能在某个时候需要它！</em></p><p id="9f8e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">嗯，它现在不会造成任何损害，但是当事情随着时间的推移而积累时，它们就会开始影响集群的性能和稳定性。因此，让我们来看看这些被遗忘的资源可能导致的一些常见/基本问题:</p><p id="0fab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每个Kubernetes集群都有一些基本限制。首先是每个节点的pod数量，根据Kubernetes文档，应该最多为110个。也就是说，如果您有非常大的节点，有大量的内存/CPU，您肯定可以更高—甚至可能每个节点500个，正如这里用OpenShift 测试的<a class="ae ky" href="https://www.openshift.com/blog/500_pods_per_node" rel="noopener ugc nofollow" target="_blank">，但是如果您突破了极限，当事情开始出问题时，不要感到惊讶，不仅仅是因为内存或CPU不足。</a></p><p id="e44a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可能遇到的另一个问题是临时存储不足。节点上所有正在运行的pod都至少使用一点临时存储空间来存储日志、缓存、暂存空间或<code class="fe lv lw lx ly b">emptyDir</code>卷。您可能会很快达到极限，这可能会导致pod被逐出或新的pod无法在节点上启动。在节点上运行太多pod也会导致这个问题，因为临时存储用于容器映像和容器的可写层。如果节点的临时存储空间不足，它就会被感染，您可能会很快发现这一点。如果您想检查节点上存储的当前状态，您可以在节点上运行<code class="fe lv lw lx ly b">df -h /var/lib</code>。</p><p id="66b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与短暂存储类似，持久卷也可能成为问题的来源，尤其是如果您在一些云中运行Kubernetes，因此需要为您提供的每个PVC付费。因此，很明显，清理所有未使用的PVC以节省资金是很重要的。此外，保持使用过的PVC干净也很重要，这样可以避免应用程序空间不足，尤其是在集群中运行数据库时。</p><p id="05fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">过多的物品也会产生问题，因为它们都存放在<code class="fe lv lw lx ly b">etcd</code>储物件中。随着<code class="fe lv lw lx ly b">etcd</code>数据库的增长，它的性能会开始下降，考虑到<code class="fe lv lw lx ly b">etcd</code>是Kubernetes集群的大脑，你应该尽力避免这种情况。也就是说，你将需要非常大的集群来达到<code class="fe lv lw lx ly b">etcd</code>的极限，正如OpenAI 的这篇<a class="ae ky" href="https://openai.com/blog/scaling-kubernetes-to-2500-nodes/" rel="noopener ugc nofollow" target="_blank">帖子所示。然而，没有一个单一的指标可以用来衡量<code class="fe lv lw lx ly b">etcd</code>的性能，因为它取决于对象的数量、大小或它们变化的频率，所以你最好保持它的干净，否则你可能会得到一些令人讨厌的惊喜。</a></p><p id="3253" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，杂乱的集群也会导致安全问题。当不需要/不使用角色绑定或服务帐户时，就把它们留在那里是一种邀请，有人会抓住它们并滥用它们。</p><h1 id="b2c3" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">基础</h1><p id="4d5b" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">你不需要做任何复杂的事情来解决上面提到的大部分问题。解决这些问题的最好方法是完全预防它们。实现这一点的一种方法是使用对象配额，您(作为集群管理员)可以在单个名称空间上强制实施该配额。</p><p id="2aef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以通过配额解决的第一个问题是PVC的数量和大小:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="1245" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码片段中，我们有两个对象——第一个是<em class="mw"> LimitRange </em>,它规定了名称空间中单个PVC的最小和最大大小。这有助于阻止用户请求大量数据。这里的第二个对象(<em class="mw"> ResourceQuota </em>)额外对PVC的数量及其累积大小进行了硬性限制。</p><p id="f29a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，为了防止人们创建一堆对象，然后在不需要时将它们丢弃，您可以使用<em class="mw">对象计数</em>配额，该配额对给定名称空间中特定类型资源的实例数量进行硬性限制:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="42f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以使用几个内置字段来指定对象计数配额，例如上面显示的<code class="fe lv lw lx ly b">configmaps</code>、<code class="fe lv lw lx ly b">secrets</code>或<code class="fe lv lw lx ly b">services</code>。对于所有其他资源，你可以使用<code class="fe lv lw lx ly b">count/&lt;resource&gt;.&lt;group&gt;</code>格式，如<code class="fe lv lw lx ly b">count/jobs.batch</code>所示，这有助于防止错误配置的<em class="mw"> CronJob </em>产生大量的作业。</p><p id="61e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可能都知道可以设置内存和CPU配额，但是您可能不知道还可以为暂时存储设置配额。对本地临时存储的配额支持是作为1.18版中的一项alpha功能添加的，它允许您以与内存和CPU相同的方式设置临时存储限制:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="9d6e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，要小心这些，因为当它们超过极限时会被驱逐，这可能是由例如集装箱原木的尺寸引起的。</p><p id="e917" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了为资源设置配额和限制之外，还可以为部署设置修订历史限制，以减少保留在集群中的<em class="mw">副本集</em>的数量。这是使用<code class="fe lv lw lx ly b">.spec.revisionHistoryLimit</code>完成的，默认为10。</p><p id="f7d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，还可以设置TTL(生存时间)来清理集群中存在时间过长的对象。这使用TTL控制器，该控制器从1.21版开始处于测试阶段，目前仅适用于使用<code class="fe lv lw lx ly b">.spec.ttlSecondsAfterFinished</code>字段的作业，但将来可能会扩展到其他资源(例如pod)。</p><h1 id="9da9" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">手动清理</h1><p id="8fc0" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">如果预防还不够，并且您已经有一堆孤立的、未使用的或以其他方式废弃的资源，那么您可以进行一次性清除。这可以只用<code class="fe lv lw lx ly b">kubectl get</code>和<code class="fe lv lw lx ly b">kubectl delete</code>来完成。您可以做的一些基本示例如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="6668" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一个命令使用资源标签执行基本的删除操作，这显然要求您首先使用某个<code class="fe lv lw lx ly b">key=value</code>对来标记所有相关的资源。第二个示例展示了如何基于某个字段(通常是某个状态字段)删除一种类型的资源——在本例中是所有的completed/succeeded窗格。这一点也可以应用于其他资源，例如已完成的作业。</p><p id="70eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了这两个命令之外，很难找到能够批量删除内容的模式，因此您必须寻找未使用的单独资源。然而，有一个工具可能会有所帮助——它叫做<code class="fe lv lw lx ly b"><a class="ae ky" href="https://github.com/yogeshkk/k8spurger" rel="noopener ugc nofollow" target="_blank">k8spurger</a></code>。该工具查找未使用的<em class="mw">角色绑定</em>、<em class="mw">服务账户</em>、<em class="mw">配置映射</em>等。并生成适合删除的资源列表，这有助于缩小搜索范围。</p><h1 id="2126" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">kube-看门人</h1><p id="9e2e" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">前几节探索了一些简单的、特别的清理方法，但是消除任何混乱的最终解决方案是使用<code class="fe lv lw lx ly b"><a class="ae ky" href="https://codeberg.org/hjacobs/kube-janitor" rel="noopener ugc nofollow" target="_blank">kube-janitor</a></code>。<code class="fe lv lw lx ly b">kube-janitor</code>是一个在集群中运行的工具，可以作为任何其他工作负载，并使用JSON查询来查找资源，然后可以根据指定的TTL或到期日期删除这些资源。</p><p id="17d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要将该工具部署到您的集群中，您可以运行以下命令:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="32c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这会将<code class="fe lv lw lx ly b">kube-janitor</code>部署到<code class="fe lv lw lx ly b">default</code>名称空间，并使用示例规则文件和<em class="mw">模拟运行</em>模式运行它(使用<code class="fe lv lw lx ly b">kube-janitor</code> <em class="mw">部署</em>中的<code class="fe lv lw lx ly b">--dry-run</code>标志)。</p><p id="99e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在关闭<em class="mw">空转</em>模式之前，我们应该设置自己的规则。这些位于<code class="fe lv lw lx ly b">kube-janitor</code>配置图中，看起来像这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="7237" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们显然对需要填充的<code class="fe lv lw lx ly b">rules:</code>部分感兴趣。因此，这里有一些有用的示例，您可以在集群清理中使用:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="7d1d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此示例显示了清理临时、陈旧或未使用资源的一些基本用例。除了这种规则，您还可以为特定对象设置绝对到期日期/时间。这可以使用注释来完成，例如:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="655a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当你设置好你的规则和注释后，你可能应该让这个工具在<em class="mw">模拟运行</em>模式下运行一段时间，并打开调试日志，看看正确的对象是否会被删除，并避免删除你不想删除的内容(换句话说，如果你因为错误的配置和缺乏测试而删除了生产卷，不要怪我)。</p><p id="a480" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，使用<code class="fe lv lw lx ly b">kube-janitor</code>时要考虑的一件事是，如果集群中有很多对象，它可能需要比默认的<code class="fe lv lw lx ly b">100Mi</code>更多的内存。所以，为了避免它的pod卡在<em class="mw"> CrashLoopBackOff </em>中，我更喜欢给它<code class="fe lv lw lx ly b">1Gi</code>作为内存限制。</p><h1 id="bcb0" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">监控集群限制</h1><p id="ad31" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">并非所有问题都可以通过手动甚至自动清理来解决，在某些情况下，监控是确保您不会触及集群中任何限制的最佳方式，无论是pod数量、可用的临时存储还是<code class="fe lv lw lx ly b">etcd</code>对象数量。</p><p id="40b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，监控是一个很大的话题，需要一篇(或两篇)文章来阐述，所以为了本文的目的，我将列出来自<em class="mw"> Prometheus </em>的几个指标，当您保持集群整洁时，这些指标可能会对您有用:</p><ul class=""><li id="1099" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated"><code class="fe lv lw lx ly b">etcd_db_total_size_in_bytes</code>-<code class="fe lv lw lx ly b">etcd</code>数据库的大小</li><li id="2ef2" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated"><code class="fe lv lw lx ly b">etcd_object_counts</code> - <code class="fe lv lw lx ly b">etcd</code>对象计数</li><li id="51d7" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated"><code class="fe lv lw lx ly b">pod:container_cpu_usage:sum</code> -集群中每个pod的CPU使用率</li><li id="748e" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated"><code class="fe lv lw lx ly b">pod:container_fs_usage_bytes:sum</code> -集群中每个pod的文件系统使用情况</li><li id="cb69" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated"><code class="fe lv lw lx ly b">pod:container_memory_usage_bytes:sum</code> -集群中每个pod的内存使用情况</li><li id="9e31" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated"><code class="fe lv lw lx ly b">node_memory_MemFree_bytes</code> -每个节点的空闲内存</li><li id="435d" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated"><code class="fe lv lw lx ly b">namespace:container_memory_usage_bytes:sum</code> -每个名称空间的内存使用量</li><li id="e601" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated"><code class="fe lv lw lx ly b">namespace:container_cpu_usage:sum</code> -每个名称空间的CPU使用率</li><li id="0421" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated"><code class="fe lv lw lx ly b">kubelet_volume_stats_used_bytes</code> -每个卷的已用空间</li><li id="28cd" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated"><code class="fe lv lw lx ly b">kubelet_running_pods</code> -节点中正在运行的pod数量</li><li id="c09c" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated"><code class="fe lv lw lx ly b">kubelet_container_log_filesystem_used_bytes</code> -每个集装箱/箱的原木尺寸</li><li id="b708" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated"><code class="fe lv lw lx ly b">kube_node_status_capacity_pods</code> -每个节点的推荐最大箱数</li><li id="2d39" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated"><code class="fe lv lw lx ly b">kube_node_status_capacity</code> -所有指标的最大值(CPU、pod、短期存储、内存、大页面)</li></ul><p id="dbcd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些只是您可以使用的众多指标中的一部分。可用的度量也取决于您的监控工具，这意味着您可能能够获得一些由您运行的服务公开的额外的定制度量。</p><h1 id="9071" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">结束语</h1><p id="dd4a" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">在本文中，我们探讨了清理Kubernetes集群的许多选项——有些非常简单，有些更复杂。不管你选择哪种解决方案，试着保持在这个<em class="mw">“清理任务”</em>的顶端，并在你进行的过程中清理东西。它可以让你省去一个大麻烦，如果没有别的，它可以清除你的集群中一些不必要的混乱，这与清理你的桌子的目的相同。还要记住，如果你把东西放在那里一段时间，你会忘记它们为什么在那里，它们是否被需要，这使得把东西恢复到干净状态变得更加困难。</p><p id="4f8d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了这里介绍的方法，您可能还想使用一些<em class="mw"> GitOps </em>解决方案，如<em class="mw"> ArgoCD </em>或<em class="mw"> Flux </em>来创建和管理资源，这可以大大减少孤立资源的数量，并且也使清理更容易，因为它通常只需要您删除一个自定义资源的单个实例，这将触发从属资源的级联删除。</p></div><div class="ab cl nn no hx np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="im in io ip iq"><p id="141c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="mw">本文最初发布于</em><a class="ae ky" href="https://martinheinz.dev/blog/60?utm_source=medium&amp;utm_medium=referral&amp;utm_campaign=blog_post_60" rel="noopener ugc nofollow" target="_blank"><em class="mw">martinheinz . dev</em></a></p><div class="nu nv gp gr nw nx"><a rel="noopener follow" target="_blank" href="/the-easiest-way-to-debug-kubernetes-workloads-ff2ff5e3cc75"><div class="ny ab fo"><div class="nz ab oa cl cj ob"><h2 class="bd iu gy z fp oc fr fs od fu fw is bi translated">调试Kubernetes工作负载的最简单方法</h2><div class="oe l"><h3 class="bd b gy z fp oc fr fs od fu fw dk translated">对Kubernetes上运行的任何应用程序进行调试和故障排除的最快最简单的方法…</h3></div><div class="of l"><p class="bd b dl z fp oc fr fs od fu fw dk translated">towardsdatascience.com</p></div></div><div class="og l"><div class="oh l oi oj ok og ol ks nx"/></div></div></a></div><div class="nu nv gp gr nw nx"><a rel="noopener follow" target="_blank" href="/yq-mastering-yaml-processing-in-command-line-e1ff5ebc0823"><div class="ny ab fo"><div class="nz ab oa cl cj ob"><h2 class="bd iu gy z fp oc fr fs od fu fw is bi translated">yq:在命令行中掌握YAML处理</h2><div class="oe l"><h3 class="bd b gy z fp oc fr fs od fu fw dk translated">学习使用yq命令行实用程序和这个简单的备忘单更有效地解析和操作YAML文件</h3></div><div class="of l"><p class="bd b dl z fp oc fr fs od fu fw dk translated">towardsdatascience.com</p></div></div><div class="og l"><div class="om l oi oj ok og ol ks nx"/></div></div></a></div><div class="nu nv gp gr nw nx"><a href="https://itnext.io/hardening-docker-and-kubernetes-with-seccomp-a88b1b4e2111" rel="noopener  ugc nofollow" target="_blank"><div class="ny ab fo"><div class="nz ab oa cl cj ob"><h2 class="bd iu gy z fp oc fr fs od fu fw is bi translated">用seccomp强化Docker和Kubernetes</h2><div class="oe l"><h3 class="bd b gy z fp oc fr fs od fu fw dk translated">您的容器可能不像您想象的那样安全，但是seccomp配置文件可以帮助您解决这个问题…</h3></div><div class="of l"><p class="bd b dl z fp oc fr fs od fu fw dk translated">itnext.io</p></div></div><div class="og l"><div class="on l oi oj ok og ol ks nx"/></div></div></a></div></div></div>    
</body>
</html>