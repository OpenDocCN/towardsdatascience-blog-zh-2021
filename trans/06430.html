<html>
<head>
<title>How to use LightGBM and boosted decision trees to forecast sales</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用LightGBM和boosted决策树预测销售</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-use-lightgbm-and-boosted-decision-trees-forecast-sales-cf65ce8ab645?source=collection_archive---------13-----------------------#2021-06-09">https://towardsdatascience.com/how-to-use-lightgbm-and-boosted-decision-trees-forecast-sales-cf65ce8ab645?source=collection_archive---------13-----------------------#2021-06-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f8ed" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用机器学习构建数据以预测未来销售的广泛指南。它介绍了如何使用python创建滞后变量、滚动方法和基于时间的功能。它涵盖了如何执行目标编码，训练测试分裂的时间相关模型，并建立一个梯度推进树模型预测下个月的零售商的销售。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/961b15a05b2834e00350af82b4066cad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*79T-FMEDM_f_kF_D72HSUg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk">Photo by <a class="ae ky" href="https://unsplash.com/@encourline?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">褚 天成</a> on <a class="ae ky" href="https://unsplash.com/s/photos/shopping-electornics?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></p></figure><h1 id="64b9" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">问题陈述</h1><p id="fb8c" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">大多数公司对了解他们未来的业绩感兴趣。上市公司必须向投资者提供指导，说明他们认为下一季度或下一年的财务表现会如何。</p><p id="347c" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">为了能够回答公司在未来时期的表现，许多公司雇佣分析师来构建预测业务表现的分析解决方案。这种分析往往侧重于平均历史表现，并将其外推至未来结果。移动平均线和滚动窗口是一种常见的做法，也是长期以来的标准做法。</p><p id="90ec" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">随着数据科学的最新发展，这些模型可以使用更复杂的技术(如梯度推进三)得到显著改善。</p><p id="2a72" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在本指南中，我们将使用ML为一家俄罗斯零售商预测下个月的销售额。我们将预测每个商店售出的每件商品的销售量。</p><p id="01d0" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">通过将数据组织为月度预测，我们可以利用我们拥有的关于商店和产品的非常精细的数据。我们将使用在t-n时刻获取的历史销售数据来预测t+n时刻的未来销售。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ms"><img src="../Images/9dc3688e46b108004b4f083b0baad98a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TKm89v6lR6xSm7rEwgJCHA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><h1 id="3966" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">数据</h1><p id="8c4a" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">该数据集来源于kaggle的预测未来销售竞赛，包括几个数据文件，我们必须将它们结合在一起。对于那些了解数据库建模的人来说，sales_train文件或训练集可以被认为是星型模式中的事实表，其中items、item_ categories和shops是我们可以用主键连接的维度表。</p><p id="9c40" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">测试文件是具有类似关系的另一个事实。sales_train文件和测试文件的关键区别在于，销售文件是<strong class="lt iu">每日</strong>，测试文件是<strong class="lt iu">每月</strong>。通常在实践中，我们可能希望预测月销售额，以便最终消费者更容易理解。这意味着我们还必须将每日数据汇总到每月数据，以便将其输入到我们的模型中。</p><p id="701e" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">数据集包含以下文件:</p><ul class=""><li id="7c38" class="mt mu it lt b lu mn lx mo ma mv me mw mi mx mm my mz na nb bi translated"><strong class="lt iu"> sales_train.csv </strong> —培训集。2013年1月至2015年10月的每日历史数据。</li><li id="592d" class="mt mu it lt b lu nc lx nd ma ne me nf mi ng mm my mz na nb bi translated"><strong class="lt iu"> test.csv </strong> —测试集。你需要预测这些商店和产品在2015年11月的销售额。</li><li id="3b42" class="mt mu it lt b lu nc lx nd ma ne me nf mi ng mm my mz na nb bi translated"><strong class="lt iu"> sample_submission.csv </strong> —格式正确的示例提交文件。</li><li id="4638" class="mt mu it lt b lu nc lx nd ma ne me nf mi ng mm my mz na nb bi translated"><strong class="lt iu"> items.csv </strong> —物品/产品的补充信息。</li><li id="eaed" class="mt mu it lt b lu nc lx nd ma ne me nf mi ng mm my mz na nb bi translated"><strong class="lt iu"> item_categories.csv </strong> —关于物品类别的补充信息。</li><li id="c6a2" class="mt mu it lt b lu nc lx nd ma ne me nf mi ng mm my mz na nb bi translated"><strong class="lt iu">shop . CSV</strong>-店铺补充信息。</li></ul><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="73e8" class="nm la it ni b gy nn no l np nq">## Import lots of libraries to use<br/>import pandas as pd<br/>import numpy as np<br/>from google_trans_new import google_translator<br/>import seaborn as sns<br/>import matplotlib.pyplot as plt<br/>from sklearn.metrics import mean_squared_error<br/>%matplotlib inline<br/>from itertools import product<br/>import time<br/>from sklearn.model_selection import KFold<br/>from sklearn import base<br/>import lightgbm as lgb<br/>from lightgbm import LGBMRegressor<br/>from sklearn.preprocessing import LabelEncoder, OneHotEncoder, RobustScaler<br/>from sklearn.model_selection import GridSearchCV, cross_val_score, StratifiedKFold, learning_curve, KFold, train_test_split<br/>import calendar<br/>from datetime import datetime</span></pre><p id="959c" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">让我们读入数据。</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="36f6" class="nm la it ni b gy nn no l np nq">## allows us to pick up the european formatting of the dates in the trainset<br/>dateparse = lambda x: pd.datetime.strptime(x, ‘%d.%m.%Y’) </span><span id="341f" class="nm la it ni b gy nr no l np nq"># importing the trainset with dates correctly formatted<br/>sales = pd.read_csv(‘sales_train.csv’, parse_dates = [‘date’], date_parser = dateparse)</span><span id="6f3d" class="nm la it ni b gy nr no l np nq">#import the rest of the files<br/>test = pd.read_csv(‘test.csv’)<br/>items = pd.read_csv(‘items.csv’)<br/>item_categories = pd.read_csv(‘item_categories.csv’)<br/>shops = pd.read_csv(‘shops.csv’)</span></pre><p id="3188" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">现在我们已经读入了所有的文件，我们开始一个一个地分析文件。从项目类别开始。</p><h2 id="df96" class="nm la it bd lb ns nt dn lf nu nv dp lj ma nw nx ll me ny nz ln mi oa ob lp oc bi translated">项目类别文件</h2><p id="5e19" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">不幸的是，文件是俄文的。为了更好地理解数据，我们可以将单个类别转换成对非俄语使用者有意义的数据点。为此，我们可以使用googletrans将类别名称翻译成英语。我们将把翻译后的值存储在一个名为<strong class="lt iu"> Category_type的列中。</strong></p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="0fbb" class="nm la it ni b gy nn no l np nq">item_categories.head()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi od"><img src="../Images/a2eb91816682cc9d1cd741040794e2d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:614/format:webp/1*IyG3Qx_rxWuDF_WXjjKjCA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="5a3b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">不会说俄语可能是一个劣势，但我们可以看到，似乎我们有一个模式，其中有一个单词后面跟着PS2、PS3、PS4和PSP。这看起来很像它与各种索尼playstation平台有关。也许第一个可以帮助我们将这些物品归类在一起。我们来翻译一下单词，看看。</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="3bd3" class="nm la it ni b gy nn no l np nq"># Starting with translating the column item_category name from Russian to English. We will then append that to the original dataframe.<br/>translator = google_translator()  <br/>list_a = []<br/>for word in item_categories['item_category_name']:<br/>    try:<br/>        a = translator.translate(word)<br/>        list_a.append(a)<br/>    except:<br/>        list_a.append(word)<br/>item_categories['English_Name'] = list(list_a)<br/>print(list_a)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/c6077bc8b7585f4e9c19110dff752239.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DqfhdlBC82IRzE4AivBseA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="7c96" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这个翻译并不完美，因为它漏掉了一些术语。我们可以手动搜索单词，并用我们资助的最佳翻译替换它们，以便我们的类别更容易使用。</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="a610" class="nm la it ni b gy nn no l np nq">## Программы means Programs<br/>item_categories[‘English_Name’]= item_categories[‘English_Name’].str.replace(“Программы”, “Programs”)</span><span id="300f" class="nm la it ni b gy nr no l np nq">## Книги means Books<br/>item_categories[‘English_Name’]= item_categories[‘English_Name’].str.replace(“Книги”, “Books”)</span><span id="3bc6" class="nm la it ni b gy nr no l np nq">item_categories.head()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi of"><img src="../Images/6bfe27df7696a2e4e71f810789210497.png" data-original-src="https://miro.medium.com/v2/resize:fit:938/format:webp/1*H3IpXZb3SLxDRp7naOsNpQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="8034" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">啊哈！看起来每个项目类别的第一部分都有类别类型。在我们的例子中，类别类型是附件。让我们把它提取出来，存储在一个名为Category_type的新特性中。</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="ef6f" class="nm la it ni b gy nn no l np nq">## Create a feature called Variable type by splitting the English_Name strings where they either have a paranthesis or a dash.<br/>list_a = []<br/>for row in item_categories['English_Name']:<br/>        a = row.replace('(','-').split(' -')[0] ## replacing the opening parantheses with dash so we can use str.split function to split on it.<br/>        list_a.append(a)<br/>item_categories['Category_type'] = list(list_a)<br/>## Lets check out the categories we have<br/>pd.DataFrame((item_categories['Category_type'].unique()))</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi og"><img src="../Images/6ca637b68b91a6981847590c5ef97723.png" data-original-src="https://miro.medium.com/v2/resize:fit:1246/format:webp/1*A8Sabio5_XtFv3EeGKGWqw.png"/></div></figure><p id="ad20" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">看起来几个类别有相似的名称和含义。比如<strong class="lt iu">游戏</strong> <strong class="lt iu">主机</strong>和<strong class="lt iu">游戏主机</strong>实际上是同一类型的品类。让我们清理一下，让这个新特性更加统一。</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="2336" class="nm la it ni b gy nn no l np nq">## Let's clean up some of this output in the categories:</span><span id="19f7" class="nm la it ni b gy nr no l np nq">## Game Consoles are really the same thing as Gaming Consoles<br/>item_categories['Category_type']= item_categories['Category_type'].str.replace("Gaming Consoles", "Game Consoles")</span><span id="eafa" class="nm la it ni b gy nr no l np nq">## Payment cards with a lowercase c is the same as Payment Cards with upper case C<br/>item_categories['Category_type']= item_categories['Category_type'].str.replace("Payment cards", "Payment Cards")</span><span id="e864" class="nm la it ni b gy nr no l np nq">## Cinema and movie tends to be synomomous. Let's change "The Movie" category type to Cinema<br/>item_categories['Category_type']= item_categories['Category_type'].str.replace("The Movie", "Cinema")</span><span id="2269" class="nm la it ni b gy nr no l np nq">## Pure and Clean Media Seem Similar. Let's combine into Pure/Clean Media<br/>item_categories['Category_type']= item_categories['Category_type'].str.replace("Clean media", "Pure/Clean Media")<br/>item_categories['Category_type']= item_categories['Category_type'].str.replace("Pure Media", "Pure/Clean Media")</span></pre><p id="f38d" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">因为这个数据集比较大(对于笔记本电脑来说，无论如何都要处理)，所以让我们删除不打算使用的列。这将允许我们在笔记本电脑上使用更少的内存。我们去掉英文名称categories_name，只留下类别类型。</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="f3c0" class="nm la it ni b gy nn no l np nq">item_categories = item_categories.drop([‘item_category_name’,’English_Name’],axis =1)</span></pre><p id="97ec" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><strong class="lt iu">商店</strong></p><p id="fa05" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这个文件包含了商店的名称。它可以用作获取销售文件中商店Id名称的关键字。因为这个文件也是俄语的，我们将再次把单词翻译成英语。一旦我们有了英文名称，我们将提取这些商店所在的城市，并将其作为一个特征。</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="2700" class="nm la it ni b gy nn no l np nq">shops.head()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/fdc6aa4972b6b3e3851badf5946fe25d.png" data-original-src="https://miro.medium.com/v2/resize:fit:636/format:webp/1*UxCYOoUaJsCJsnSHVMUDbQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="7b2f" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">尽管我学习了如何用俄语拼写配饰，但我担心我的俄语还不够好，看不清商店的名字。让我们把它们翻译成英语，看看这些单词是什么意思。</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="2e34" class="nm la it ni b gy nn no l np nq">## Let’s translate this into English<br/>translator = google_translator() <br/>list_a = []<br/>for word in shops[‘shop_name’]:<br/> a = translator.translate(word)<br/> list_a.append(a)<br/>shops[‘English_Shop_Name’] = list_a<br/>shops</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/e0fa455373fc6d5142d658ad525eb675.png" data-original-src="https://miro.medium.com/v2/resize:fit:1096/format:webp/1*Cl1H02yTe3autQCTW2lrmg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="66fe" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">貌似城市是第一个词，后面是购物中心，TC或者，SEC之类的。让我们试着从这里提取城市。一些谷歌化的词让我觉得所有我检查过的地方，不管是TC还是SEC都是在购物中心。因此，我们没有创建一个突出的店铺名称的一部分。</p><p id="ce96" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们将创建一个仅包含城市名称(第一个单词)的<strong class="lt iu">城市</strong>变量，并通过按空格分割English _ Shops _ Name字符串来创建一个名为<strong class="lt iu">城市类型</strong>的特性。</p><p id="d829" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">因为像圣彼得堡这样的城市名称中有一个空格，所以我们去掉了句号后面的空格和感叹号后面的空格。</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="503f" class="nm la it ni b gy nn no l np nq">list_a = []<br/>for row in shops[‘English_Shop_Name’]:<br/> a = row.replace(‘. ‘,’’).replace(‘! ‘,’’).split(‘ ‘)[0] ## remove spaces follwing period or exclaimation point and split based on spaces. First word is city<br/> list_a.append(a)<br/>shops[‘City’] = list(list_a)<br/>## Lets check out the categories we have<br/>pd.DataFrame((shops[‘City’].unique()))</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/fe89e99df8841f7af27237402701da9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1288/format:webp/1*pdUmkF-djVswTzDgNkwtUw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="cf87" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">因为我们已经从中提取了城市信息，所以我们删除了商店名称，英文商店名称。</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="6b79" class="nm la it ni b gy nn no l np nq">shops = shops.drop([‘shop_name’,’English_Shop_Name’],axis = 1)<br/>shops.head()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/92555b736d836a75e5ae0fd70b7f6150.png" data-original-src="https://miro.medium.com/v2/resize:fit:1222/format:webp/1*uVTULj8Ia_NK3TVQ7I8SgQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><h1 id="4e95" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">汇总数据</h1><p id="35da" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">因为任务是进行每月预测，所以在进行任何编码之前，我们需要将数据聚集到每月级别。下面的代码单元正是为了这个目的。它还将item_cnt_day变量重命名为Target(一旦我们将它设为每月聚合)。</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="d08f" class="nm la it ni b gy nn no l np nq">gb = sales.groupby(index_cols,as_index=False).agg({'item_cnt_day':{target = 'sum'}})</span><span id="7563" class="nm la it ni b gy nr no l np nq">temp['total'] = pd.DataFrame(project_data.groupby(col1)[col2].agg({'total':'count'})).reset_index()['total']</span><span id="fc72" class="nm la it ni b gy nr no l np nq">index_cols = [‘shop_id’, ‘item_id’, ‘date_block_num’]</span><span id="bb4c" class="nm la it ni b gy nr no l np nq"># For every month we create a grid from all shops/items combinations from that month<br/>grid = [] <br/>for block_num in sales[‘date_block_num’].unique():<br/> cur_shops = sales[sales[‘date_block_num’]==block_num][‘shop_id’].unique()<br/> cur_items = sales[sales[‘date_block_num’]==block_num][‘item_id’].unique()<br/> grid.append(np.array(list(product(*[cur_shops, cur_items, [block_num]])),dtype=’int32'))</span><span id="e8a5" class="nm la it ni b gy nr no l np nq">#turn the grid into pandas dataframe<br/>grid = pd.DataFrame(np.vstack(grid), columns = index_cols,dtype=np.int32)</span><span id="f849" class="nm la it ni b gy nr no l np nq">#get aggregated values for (shop_id, item_id, month)<br/>gb = sales.groupby(index_cols,as_index=False).agg({‘item_cnt_day’: ‘sum’})</span><span id="b240" class="nm la it ni b gy nr no l np nq">gb.columns = [‘shop_id’, ‘item_id’, ‘date_block_num’, ‘target’]<br/># gb = sales.groupby(index_cols,as_index=False).agg({‘item_cnt_day’:{‘target’:’sum’}})</span><span id="add9" class="nm la it ni b gy nr no l np nq">#fix column names<br/># gb.columns = [col[0] if col[-1]==’’ else col[-1] for col in gb.columns.values]<br/>#join aggregated data to the grid<br/>all_data = pd.merge(grid,gb,how=’left’,on=index_cols).fillna(0)<br/>#sort the data<br/>all_data.sort_values([‘date_block_num’,’shop_id’,’item_id’],inplace=True)</span></pre><p id="9dc8" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">有时我们的训练数据中会有异常值。在这个特定的数据集中，我们知道如果我们的目标值为20或更大。这意味着，如果我们看到一个大于20的值，我们会自动将其称为20。这对我们的RMSE分数有重大的积极影响。这可能并不总是适用于所有的预测模型。</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="89b5" class="nm la it ni b gy nn no l np nq">all_data[‘target’]=all_data[‘target’].clip(0,20)</span></pre><h1 id="9c67" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">合并数据集</h1><p id="00c0" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">接下来，我们用训练集和测试集创建一个数据帧。我们将用item_categories、items和shops来加入它。我们将使用这个数据框架来创建我们的许多特征，并尽可能减少将它们应用于多个数据框架的需要。例如，当我们创建滞后变量时，我们需要为训练集、验证集和测试集创建它们。通过将所有数据合并到一个数据帧中，我们只需这样做一次。</p><p id="7017" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在现实世界中，我们将构建一个预处理管道，将训练中使用的相同特征工程应用于未标记数据。那是另一天的话题。</p><p id="0649" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们将联合训练和测试设备。正如我们从上面的代码中看到的，我们在测试集中缺少了两列。这些是日期块编号和目标。现在，我们将把目标设定为零。我们还会将数字34分配给日期块编号。date_block_num对应于数据集中的月份，因此由于我们需要预测下个月的item_counts，我们将简单地查找训练集的最大值并加1。(最大值为33)</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="c881" class="nm la it ni b gy nn no l np nq">## Assign 34 to date_block_num and 0.0 to target<br/>test[‘date_block_num’] = 34<br/>test[‘target’] = 0.0</span><span id="9f3e" class="nm la it ni b gy nr no l np nq">TEST_ID = test[‘ID’] ## in case we need this later</span><span id="c84a" class="nm la it ni b gy nr no l np nq">## Then we need to union them and save that back as our all_data dataframe<br/>all_data = pd.concat([all_data,test], axis =0, sort=True)<br/>all_data = all_data.drop(columns = [‘ID’])</span></pre><p id="ef23" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">接下来，我们将all_data数据框架与items、item_categories和shops数据框架合并。因为我们希望避免创建重复的行，所以我们将添加一些行计数检查器，以确保我们不会添加任何新行或删除任何行。</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="2b5f" class="nm la it ni b gy nn no l np nq">## Calculate number of rows prior to merge<br/>prior_rows = all_data.shape[0]</span><span id="c649" class="nm la it ni b gy nr no l np nq">## Merge the sales train data with the items, item categoris and shops datasets to get the names of items, their categories and the shop names<br/>all_data = pd.merge(all_data, items, on = “item_id”)<br/>all_data = pd.merge(all_data, item_categories, on = “item_category_id”)<br/>all_data = pd.merge(all_data, shops, on = “shop_id”)</span><span id="0de2" class="nm la it ni b gy nr no l np nq">## Calcualte number and print of rows dropped (should be zero)<br/>print(“Dropped {} rows”.format(prior_rows — all_data.shape[0]))</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/e5af1f541aab330d06e102b22bb72bc1.png" data-original-src="https://miro.medium.com/v2/resize:fit:284/format:webp/1*QQvT65L3ccuSorVdBFHPBA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><h1 id="3429" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">特征工程</h1><p id="8106" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">因为我们有大量可能具有预测性的数据，所以我们需要将其预处理成我们的模型可以使用的格式。这通常被称为特征工程。</p><h2 id="c6ff" class="nm la it bd lb ns nt dn lf nu nv dp lj ma nw nx ll me ny nz ln mi oa ob lp oc bi translated">处理日期、季节和日期</h2><p id="5d9e" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">日期可以告诉我们很多关于销售的事情。例如，二月份的销售额可能低于一月份，仅仅是因为二月份的天数比其他月份少。日子的类型也很重要。更多的周末可能意味着更多的人经常光顾商店。季节也很重要，六月的销售可能与十二月不同。我们将创建与所有这些项目相关的功能。</p><p id="527f" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">首先，我们需要提取每个日期块的月份和日期，并将其存储在一个数据帧中。</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="472a" class="nm la it ni b gy nn no l np nq">## Pull out the last date of each dateblock and append it to the <br/>from datetime import datetime<br/>list_a = []<br/>for dateblock in sales[‘date_block_num’].unique():<br/> a = sales[sales[‘date_block_num’] == dateblock]<br/> a = max(a[‘date’])<br/> list_a.append(a)<br/> <br/>list_a.append(datetime.strptime(‘2015–11–30’,’%Y-%m-%d’)) ## Manually adding the month for the test set<br/>## Transform it to dataframe so we can merge with all_data<br/>list_a = pd.DataFrame(list_a)<br/>## Give the data a descriptive column header<br/>list_a.columns = [‘Month_End_Date’]</span></pre><p id="cc34" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">现在已经提取了月份和日期，我们可以计算每个月中有多少个星期一、星期二等。</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="1929" class="nm la it ni b gy nn no l np nq">## Let’s calculate the number of specific days are in each month.<br/>import calendar<br/>## Create the empty lists<br/>mon_list = []<br/>tue_list = []<br/>wed_list = []<br/>thu_list = []<br/>fri_list = []<br/>sat_list = []<br/>sun_list = []</span><span id="11ba" class="nm la it ni b gy nr no l np nq">## Calculate the number of a specific day in a given month (for example, number of mondays in March of 2015)<br/>for date in list_a[‘Month_End_Date’]:<br/> mon_list.append((len([1 for i in calendar.monthcalendar(date.year,date.month) if i[0] != 0])))<br/> tue_list.append((len([1 for i in calendar.monthcalendar(date.year,date.month) if i[1] != 0])))<br/> wed_list.append((len([1 for i in calendar.monthcalendar(date.year,date.month) if i[2] != 0])))<br/> thu_list.append((len([1 for i in calendar.monthcalendar(date.year,date.month) if i[3] != 0])))<br/> fri_list.append((len([1 for i in calendar.monthcalendar(date.year,date.month) if i[4] != 0])))<br/> sat_list.append((len([1 for i in calendar.monthcalendar(date.year,date.month) if i[5] != 0])))<br/> sun_list.append((len([1 for i in calendar.monthcalendar(date.year,date.month) if i[6] != 0])))</span><span id="53cd" class="nm la it ni b gy nr no l np nq">## Add these to our list we created with the dates<br/>list_a[‘Number_of_Mondays’] = mon_list<br/>list_a[‘Number_of_Tuesdays’] = tue_list<br/>list_a[‘Number_of_Wednesdays’] = wed_list<br/>list_a[‘Number_of_Thursdays’] = thu_list<br/>list_a[‘Number_of_Fridays’] = fri_list<br/>list_a[‘Number_of_Saturdays’] = sat_list<br/>list_a[‘Number_of_Sundays’] = sun_list</span></pre><p id="f88c" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们还可以提取与年、月和月中天数相关的特征。</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="5348" class="nm la it ni b gy nn no l np nq">## Create the empty lists</span><span id="0ffd" class="nm la it ni b gy nr no l np nq">year_list = []<br/>month_list = []<br/>day_list = []</span><span id="b9ca" class="nm la it ni b gy nr no l np nq">## Next lets calculate strip out the number of days in a month, the number of the month and the number of the year<br/>for date in list_a['Month_End_Date']:<br/>    year_list.append(date.year)<br/>    month_list.append(date.month)<br/>    day_list.append(date.day)</span><span id="11f6" class="nm la it ni b gy nr no l np nq">## Add to our dataframe<br/>list_a['Year'] = year_list<br/>list_a['Month'] = month_list<br/>list_a['Days_in_Month'] = day_list</span></pre><p id="2bcf" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">list_a数据帧可以与all_data数据帧合并，我们还添加了一些日期特性。</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="32b4" class="nm la it ni b gy nn no l np nq">## Merge the new dataframe with the all_data, using the index and the date_block_num as keys<br/>all_data = pd.merge(all_data, list_a, left_on = ‘date_block_num’, right_index = True)</span></pre><h2 id="5d17" class="nm la it bd lb ns nt dn lf nu nv dp lj ma nw nx ll me ny nz ln mi oa ob lp oc bi translated">价格变量</h2><p id="85f2" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我们最初的方法是添加交易的计数，我们没有对项目的价格做任何事情。让我们计算每月价格的平均值，并将该特性与我们的all_data数据框架合并。</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="2b7f" class="nm la it ni b gy nn no l np nq">## adding the average monthly price within a monthly block for each item at each store to the dataset<br/>a = sales.groupby([‘date_block_num’,’shop_id’,’item_id’])[‘item_price’].mean()<br/>a = pd.DataFrame(a)<br/>all_data = pd.merge(all_data,a,how = “left”, left_on = [‘date_block_num’,’shop_id’,’item_id’], right_on = [‘date_block_num’,’shop_id’,’item_id’])</span></pre><h2 id="6b69" class="nm la it bd lb ns nt dn lf nu nv dp lj ma nw nx ll me ny nz ln mi oa ob lp oc bi translated">物品首次售出后的月数&amp;物品上次售出后的月数</h2><p id="fa37" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">这些特征显示了自第一次出售该物品和最后一次出售该物品以来的日期块(月)的数量。这将有助于我们了解该商品有多新，并可能告诉我们该商品已不再销售。</p><p id="3bc4" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们将计算每个项目的最小值。这将给出它售出的第一个月。然后，我们将计算该数字与当前日期块之间的差值，以查看该项目的“旧”程度。</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="5403" class="nm la it ni b gy nn no l np nq">a = all_data.groupby(‘item_id’)[‘date_block_num’].min()<br/>a = pd.DataFrame(a)<br/>a = a.reset_index()<br/>a.columns = [‘item_id’,’min_item_sale_date_block_num’]<br/>all_data = pd.merge(all_data,a, left_on = ‘item_id’, right_on = ‘item_id’)<br/>all_data[‘Months_Since_Item_First_Sold’] = all_data[‘date_block_num’]- all_data[‘min_item_sale_date_block_num’]</span></pre><p id="2b0d" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">测试集中的一些数据是针对我们从未见过的产品的。让我们创建一个特性，只计算特定商品在第一个月的平均月销售额。我们会让其余的人归零。</p><p id="6a71" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们还将把相同的逻辑应用于商品类别和商店id的组合。我们可以按类别计算第一个月的平均销售额</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="c05f" class="nm la it ni b gy nn no l np nq">a = all_data[all_data[‘Months_Since_Item_First_Sold’] == 0].groupby([‘item_category_id’,’Months_Since_Item_First_Sold’])[‘target’].mean()<br/>a = pd.DataFrame(a)<br/>a = a.reset_index()<br/>a.columns = [‘item_category_id’,’Months_Since_Item_First_Sold’,’avg_first_months_sales_by_item_category_id’]<br/>all_data = pd.merge(all_data,a, left_on = [‘item_category_id’,’Months_Since_Item_First_Sold’], right_on = [‘item_category_id’,’Months_Since_Item_First_Sold’], how = ‘left’)<br/>all_data[‘avg_first_months_sales_by_item_category_id’] = all_data[‘avg_first_months_sales_by_item_category_id’].fillna(0)</span></pre><p id="502e" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">按类别和店铺ID计算第一个月的平均销售额。</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="5d47" class="nm la it ni b gy nn no l np nq">a = all_data[all_data[‘Months_Since_Item_First_Sold’] == 0].groupby([‘item_category_id’, ‘Months_Since_Item_First_Sold’,’shop_id’])[‘target’].mean()<br/>a = pd.DataFrame(a)<br/>a = a.reset_index()<br/>a.columns = [‘item_category_id’,’Months_Since_Item_First_Sold’,’shop_id’,’avg_first_months_sales_by_item_category_and_shop’]<br/>all_data = pd.merge(all_data,a, left_on = [‘item_category_id’,’Months_Since_Item_First_Sold’,’shop_id’], right_on = [‘item_category_id’,’Months_Since_Item_First_Sold’, ‘shop_id’], how = ‘left’)<br/>all_data[‘avg_first_months_sales_by_item_category_and_shop’] = all_data[‘avg_first_months_sales_by_item_category_and_shop’].fillna(0)</span></pre><h2 id="b73e" class="nm la it bd lb ns nt dn lf nu nv dp lj ma nw nx ll me ny nz ln mi oa ob lp oc bi translated">滞后变量</h2><p id="371f" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">如果只允许我用一个数据点来预测下个月的销售额，我可能会用这个月的销售额。这个月的销售额是一个滞后变量。在时间序列分析中，目标变量的滞后是很常见的。我们将创建几个滞后变量(上个月的销售额)。我们将重复这一过程几个月。</p><p id="a925" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">为了创建一个滞后函数，熊猫图书馆有一个非常有用的函数叫做shift。我们将它包裹在一个循环中，以产生几个月的多重滞后。我们还使用内置的填充值函数使na值为零。</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="1b39" class="nm la it ni b gy nn no l np nq">## With pandas shift function<br/>for each in [1,2,3,4,5,6,12]:<br/>    all_data[str("target_lag_"+str(each))] = all_data.groupby(['date_block_num','shop_id','item_id'])['target'].shift(each, fill_value = 0)</span></pre><p id="c559" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">更多！滞后很有趣。让我们使用每个月的平均值以及类别、城市、商店或商品来创建特征。我们可以在模型中使用这些特征的滞后。</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="ad97" class="nm la it ni b gy nn no l np nq">## Average number of sales by month and by item<br/>all_data[‘avg_monthly_by_item’] = all_data.groupby([‘item_id’, ‘date_block_num’])[‘target’].transform(‘mean’)</span><span id="c6ab" class="nm la it ni b gy nr no l np nq">## Average number of sales by month and by shop<br/>all_data[‘avg_monthly_by_shop’] = all_data.groupby([‘shop_id’, ‘date_block_num’])[‘target’].transform(‘mean’)</span><span id="e444" class="nm la it ni b gy nr no l np nq">## Average number of sales by month and by category<br/>all_data[‘avg_monthly_by_category’] = all_data.groupby([‘Category_type’, ‘date_block_num’])[‘target’].transform(‘mean’)</span><span id="25ea" class="nm la it ni b gy nr no l np nq">## Average number of sales by month and by city<br/>all_data[‘avg_monthly_by_city’] = all_data.groupby([‘City’, ‘date_block_num’])[‘target’].transform(‘mean’)</span></pre><h2 id="9eaa" class="nm la it bd lb ns nt dn lf nu nv dp lj ma nw nx ll me ny nz ln mi oa ob lp oc bi translated"><strong class="ak">移动平均线</strong></h2><p id="b2c1" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">另一种为数据添加更多特征的方法是创建滚动或移动平均值。滚动平均具有很强的预测性，有助于确定目标的历史水平。让我们创建两个滚动平均值，3个月和6个月。</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="504c" class="nm la it ni b gy nn no l np nq">## 3-months rolling average<br/>all_data[‘target_3_month_avg’] = (all_data[‘target_lag_1’] + all_data[‘target_lag_2’] +all_data[‘target_lag_3’]) /3</span><span id="44a3" class="nm la it ni b gy nr no l np nq">## 6-months rolling average<br/>all_data[‘target_6_month_avg’] = (all_data[‘target_lag_1’] + all_data[‘target_lag_2’] +all_data[‘target_lag_3’] + all_data[‘target_lag_4’] + all_data[‘target_lag_5’] +all_data[‘target_lag_6’]) /6</span></pre><p id="0d34" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">请注意我们是如何明确计算这些平均值的。这也可以通过熊猫滚动和平均功能来实现。</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="1535" class="nm la it ni b gy nn no l np nq">## 3-months rolling average<br/>all_data['target_3_month_avg'] = all_data.groupby(['date_block_num','shop_id','item_id'])['target'].rolling(3, fill_value = 0).mean()</span><span id="6718" class="nm la it ni b gy nr no l np nq">## 6-months rolling average<br/>all_data['target_6_month_avg'] = all_data.groupby(['date_block_num','shop_id','item_id'])['target'].rolling(3, fill_value = 0).mean()</span></pre><h1 id="2bf0" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">提高内存使用率</h1><p id="7597" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">哇，我们创造了很多功能。因为我们只使用一台笔记本电脑，所以我们应该确保将它存储在尽可能小的数据帧中。让我们检查内存使用情况和数据帧的数据类型。</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="2cb6" class="nm la it ni b gy nn no l np nq">all_data.info(memory_usage = “deep”)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi om"><img src="../Images/b01e788664c2cdfac3702b6f1adfaee1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1198/format:webp/1*8BUYBF2XG9jFd3rYxqkUlQ.png"/></div></figure><p id="d371" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">运行info时，在输出的底部，您会看到数据框中不同数据类型的数量以及它们的总内存使用情况。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi on"><img src="../Images/9a9d88ae48ec34c0dd48d613d1fc3484.png" data-original-src="https://miro.medium.com/v2/resize:fit:1046/format:webp/1*-gvU0nMA7VnUpn_vMRcSyQ.png"/></div></div></figure><p id="f5f1" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">由于其中许多被列为int64或float64，我们可能会将它们减少到更小的空间数据类型，如int16或float8。向下转换意味着我们将每个特性的数据类型减少到最低可能的类型。</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="810f" class="nm la it ni b gy nn no l np nq">for column in all_data:<br/> if all_data[column].dtype == ‘float64’:<br/> all_data[column]=pd.to_numeric(all_data[column], downcast=’float’)<br/> if all_data[column].dtype == ‘int64’:<br/> all_data[column]=pd.to_numeric(all_data[column], downcast=’integer’)<br/>## Dropping Item name to free up memory<br/>all_data = all_data.drop(‘item_name’,axis =1)<br/>## Let’s check the size<br/>all_data.info(memory_usage = “deep”)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/fd490c371f6510115132edb2e114cb6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1310/format:webp/1*eMmFKOJO0JSkuf454zSEBA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="e56b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">使用向下转换，我们能够将数据集的大小减少到一半。</p><h1 id="498e" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">列车测试拆分</h1><p id="cf1f" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在更传统的最大似然模型中，我们会随机地将观测值分配给训练集、测试集和验证集。在预测情况下，我们需要考虑时间对数据集的影响，并相应地构建我们的训练和测试验证。既然我们的数据集已经向下转换，我们可以开始将数据分为训练(前32个月)、验证(第33个月)和返回到我们的测试集(第34个月)。</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="95d8" class="nm la it ni b gy nn no l np nq">X_train = all_data[all_data.date_block_num &lt; 33]<br/>Y_train = all_data[all_data.date_block_num &lt; 33][‘target’]<br/>X_valid = all_data[all_data.date_block_num == 33]<br/>Y_valid = all_data[all_data.date_block_num == 33][‘target’]<br/>X_test = all_data[all_data.date_block_num == 34]</span></pre><h1 id="e869" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">更多功能工程—目标编码</h1><h2 id="ee66" class="nm la it bd lb ns nt dn lf nu nv dp lj ma nw nx ll me ny nz ln mi oa ob lp oc bi translated">我们为什么以编码为目标？</h2><p id="a1e1" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">XGBoost和LightGBM等梯度增强的基于树的模型很难处理高基数的分类变量。目标编码通过用平均结果替换字符串或文本值，帮助将分类变量转换为数值。例如，如果一个<em class="op">【PS3】</em>的平均销售量是300，PS2是200，我们将用300替换<em class="op">【PS3】</em>的字符串，用200替换PS2。事实上，一个模特现在可以知道我们应该期待PS3的销量超过PS2的销量。这种类型的特征工程有助于提高模型性能。</p><h2 id="3d94" class="nm la it bd lb ns nt dn lf nu nv dp lj ma nw nx ll me ny nz ln mi oa ob lp oc bi translated">为什么要正规化？</h2><p id="d8f0" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">简单地计算目标变量的平均值会导致过度拟合，并且通常会降低模型推广到新数据的能力。所以我们需要规范</p><h2 id="c457" class="nm la it bd lb ns nt dn lf nu nv dp lj ma nw nx ll me ny nz ln mi oa ob lp oc bi translated">正则化技术:</h2><ul class=""><li id="e862" class="mt mu it lt b lu lv lx ly ma oq me or mi os mm my mz na nb bi translated">培训数据中的交叉验证循环</li><li id="0004" class="mt mu it lt b lu nc lx nd ma ne me nf mi ng mm my mz na nb bi translated">缓和</li><li id="2022" class="mt mu it lt b lu nc lx nd ma ne me nf mi ng mm my mz na nb bi translated">添加随机噪声</li><li id="5881" class="mt mu it lt b lu nc lx nd ma ne me nf mi ng mm my mz na nb bi translated">排序和计算扩展平均值</li></ul><p id="3f0d" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们将只在训练数据中进行交叉验证循环。首先，我们将定义两个助手函数，这是我从<a class="ae ky" href="https://medium.com/@pouryaayria/k-fold-target-encoding-dfe9a594874b" rel="noopener">https://medium . com/@ pouryayria/k-fold-target-encoding-dfe 9a 594874 b</a>中获得的</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="cc4e" class="nm la it ni b gy nn no l np nq">## Helpder Function to KFold Mean encoding<br/>class KFoldTargetEncoderTrain(base.BaseEstimator,<br/>                               base.TransformerMixin):<br/>    def __init__(self,colnames,targetName,<br/>                  n_fold=5, verbosity=True,<br/>                  discardOriginal_col=False):<br/>        self.colnames = colnames<br/>        self.targetName = targetName<br/>        self.n_fold = n_fold<br/>        self.verbosity = verbosity<br/>        self.discardOriginal_col = discardOriginal_col<br/>    def fit(self, X, y=None):<br/>        return self<br/>    def transform(self,X):<br/>        assert(type(self.targetName) == str)<br/>        assert(type(self.colnames) == str)<br/>        assert(self.colnames in X.columns)<br/>        assert(self.targetName in X.columns)<br/>        mean_of_target = X[self.targetName].mean()<br/>        kf = KFold(n_splits = self.n_fold,<br/>                   shuffle = False, random_state=2019)<br/>        col_mean_name = self.colnames + '_' + 'Kfold_Target_Enc'<br/>        X[col_mean_name] = np.nan<br/>        for tr_ind, val_ind in kf.split(X):<br/>            X_tr, X_val = X.iloc[tr_ind], X.iloc[val_ind]<br/>            X.loc[X.index[val_ind], col_mean_name] = X_val[self.colnames].map(X_tr.groupby(self.colnames)[self.targetName].mean())<br/>            X[col_mean_name].fillna(mean_of_target, inplace = True)<br/>        if self.verbosity:<br/>            encoded_feature = X[col_mean_name].values<br/>            print('Correlation between the new feature, {} and, {} is {}.'.format(col_mean_name,self.targetName,                    <br/>                   np.corrcoef(X[self.targetName].values,<br/>                               encoded_feature)[0][1]))<br/>        if self.discardOriginal_col:<br/>            X = X.drop(self.targetName, axis=1)<br/>        return X</span><span id="79a4" class="nm la it ni b gy nr no l np nq">## Helper function to get the Kfold Mean encoded on the test set</span><span id="79ed" class="nm la it ni b gy nr no l np nq">class KFoldTargetEncoderTest(base.BaseEstimator, base.TransformerMixin):<br/>    <br/>    def __init__(self,train,colNames,encodedName):<br/>        <br/>        self.train = train<br/>        self.colNames = colNames<br/>        self.encodedName = encodedName<br/>        <br/>    def fit(self, X, y=None):<br/>        return self<br/>    def transform(self,X):<br/>        mean =  self.train[[self.colNames,<br/>                self.encodedName]].groupby(<br/>                                self.colNames).mean().reset_index() <br/>        <br/>        dd = {}<br/>        for index, row in mean.iterrows():<br/>            dd[row[self.colNames]] = row[self.encodedName]<br/>        X[self.encodedName] = X[self.colNames]<br/>        X = X.replace({self.encodedName: dd})<br/>        return X</span></pre><p id="feb7" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">现在我们已经定义了两个助手函数，让我们用它们开始对变量进行均值编码:</p><ul class=""><li id="a730" class="mt mu it lt b lu mn lx mo ma mv me mw mi mx mm my mz na nb bi translated">项目标识</li><li id="5c90" class="mt mu it lt b lu nc lx nd ma ne me nf mi ng mm my mz na nb bi translated">商店标识</li><li id="e95b" class="mt mu it lt b lu nc lx nd ma ne me nf mi ng mm my mz na nb bi translated">城市</li><li id="f2cd" class="mt mu it lt b lu nc lx nd ma ne me nf mi ng mm my mz na nb bi translated">类别_类型</li><li id="5e3c" class="mt mu it lt b lu nc lx nd ma ne me nf mi ng mm my mz na nb bi translated">项目_类别_标识</li></ul><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="8f30" class="nm la it ni b gy nn no l np nq">## item_id mean encoding<br/>targetc = KFoldTargetEncoderTrain(‘item_id’,’target’,n_fold=5)<br/>X_train = targetc.fit_transform(X_train)</span><span id="1cc1" class="nm la it ni b gy nr no l np nq">## shop_id mean encoding<br/>targetc = KFoldTargetEncoderTrain(‘shop_id’,’target’,n_fold=5)<br/>X_train = targetc.fit_transform(X_train)</span><span id="eb46" class="nm la it ni b gy nr no l np nq">## City mean encoding<br/>targetc = KFoldTargetEncoderTrain(‘City’,’target’,n_fold=5)<br/>X_train = targetc.fit_transform(X_train)</span><span id="c3c5" class="nm la it ni b gy nr no l np nq">## Category_type mean encoding<br/>targetc = KFoldTargetEncoderTrain(‘Category_type’,’target’,n_fold=5)<br/>X_train = targetc.fit_transform(X_train)</span><span id="7f4b" class="nm la it ni b gy nr no l np nq">## Item_category_id mean encoding<br/>targetc = KFoldTargetEncoderTrain(‘item_category_id’,’target’,n_fold=5)<br/>X_train = targetc.fit_transform(X_train)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ot"><img src="../Images/bd4410cbe7095374663d7bc175cd18f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5wUuE_0-9w4XTZ34Ii5CoA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="d01c" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">对测试集应用类似的转换。</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="e7d2" class="nm la it ni b gy nn no l np nq">## Transform validation &amp; test set</span><span id="510e" class="nm la it ni b gy nr no l np nq">## Apply item id mean encoding to test set<br/>test_targetc = KFoldTargetEncoderTest(X_train,’item_id’,’item_id_Kfold_Target_Enc’)<br/>X_valid = test_targetc.fit_transform(X_valid)<br/>X_test = test_targetc.fit_transform(X_test)</span><span id="39ec" class="nm la it ni b gy nr no l np nq">## Apply shop id mean encoding to test set<br/>test_targetc = KFoldTargetEncoderTest(X_train,’shop_id’,’shop_id_Kfold_Target_Enc’)<br/>X_valid = test_targetc.fit_transform(X_valid)<br/>X_test = test_targetc.fit_transform(X_test)</span><span id="e41d" class="nm la it ni b gy nr no l np nq">## Apply city mean encoding to test set<br/>test_targetc = KFoldTargetEncoderTest(X_train,’City’,’City_Kfold_Target_Enc’)<br/>X_valid = test_targetc.fit_transform(X_valid)<br/>X_test = test_targetc.fit_transform(X_test)</span><span id="c611" class="nm la it ni b gy nr no l np nq">## Apply Category_type mean encoding to test set<br/>test_targetc = KFoldTargetEncoderTest(X_train,’Category_type’,’Category_type_Kfold_Target_Enc’)<br/>X_valid = test_targetc.fit_transform(X_valid)<br/>X_test = test_targetc.fit_transform(X_test)</span><span id="f8b6" class="nm la it ni b gy nr no l np nq">## Apply item_category_id mean encoding to test set<br/>test_targetc = KFoldTargetEncoderTest(X_train,’item_category_id’,’item_category_id_Kfold_Target_Enc’)<br/>X_valid = test_targetc.fit_transform(X_valid)<br/>X_test = test_targetc.fit_transform(X_test)</span></pre><h1 id="7e05" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">最终数据集</h1><p id="4135" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我们正在接近。我们的特写完成了。让我们做一些检查，以确保我们只有我们将使用的功能。</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="7527" class="nm la it ni b gy nn no l np nq">## drop first 12 months since we have lagged variables<br/>X_train = X_train[X_train.date_block_num &gt; 12]</span><span id="1268" class="nm la it ni b gy nr no l np nq">## Assign target variables to seperate variables<br/>y= X_train[‘target’]<br/>Y_valid = X_valid[‘target’]</span><span id="78db" class="nm la it ni b gy nr no l np nq">## Drop Categorical Variables that we mean encoded, the target and the item codes.<br/>columns_to_drop = [‘target’, ‘Category_type’,’City’,’Month_End_Date’, ‘item_category_id’]<br/>X_train= X_train.drop(columns_to_drop, axis = 1)<br/>X_valid = X_valid.drop(columns_to_drop, axis = 1)<br/>X_test = X_test.drop(columns_to_drop, axis = 1)</span></pre><h1 id="b66f" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">使用LightGBM建模</h1><p id="21bd" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">LightGBM是一个梯度推进框架，使用基于树的学习算法。它被设计为分布式和高效的，具有以下优点:</p><ul class=""><li id="09a3" class="mt mu it lt b lu mn lx mo ma mv me mw mi mx mm my mz na nb bi translated">训练速度更快，效率更高。</li><li id="9d89" class="mt mu it lt b lu nc lx nd ma ne me nf mi ng mm my mz na nb bi translated">更低的内存使用率。</li><li id="9810" class="mt mu it lt b lu nc lx nd ma ne me nf mi ng mm my mz na nb bi translated">精确度更高。</li><li id="e339" class="mt mu it lt b lu nc lx nd ma ne me nf mi ng mm my mz na nb bi translated">支持并行和GPU学习。</li><li id="7b8d" class="mt mu it lt b lu nc lx nd ma ne me nf mi ng mm my mz na nb bi translated">能够处理大规模数据。</li></ul><p id="abef" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">LightGBM非常擅长处理大于100K记录的数据集，并且与XGBoost相比速度相对较快。</p><p id="9835" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们需要将训练和验证转换成建模所需的lgb数据集结构。</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="14fb" class="nm la it ni b gy nn no l np nq">lgb_train = lgb.Dataset(X_train, y)<br/>lgb_eval = lgb.Dataset(X_valid, Y_valid, reference=lgb_train)</span></pre><p id="83af" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">像大多数增强模型一样，我们需要调整我们的超参数。这些是我最成功的，但这并不意味着它们是“终极”的。一般来说，当我调整参数时，我倾向于遵循文档提供的指导。</p><blockquote class="ou ov ow"><p id="0f98" class="lr ls op lt b lu mn ju lw lx mo jx lz ox mp mc md oy mq mg mh oz mr mk ml mm im bi translated">LightGBM使用逐叶树生长算法，而许多其他流行的工具使用逐深度树生长算法。与深度增长相比，叶子增长算法可以更快地收敛。然而，如果不使用合适的参数，叶向生长可能会过度拟合。</p><p id="34f2" class="lr ls op lt b lu mn ju lw lx mo jx lz ox mp mc md oy mq mg mh oz mr mk ml mm im bi translated">为了使用逐叶树获得良好的结果，以下是一些重要的参数:</p><p id="a3de" class="lr ls op lt b lu mn ju lw lx mo jx lz ox mp mc md oy mq mg mh oz mr mk ml mm im bi translated"><strong class="lt iu">叶子数。</strong>这是控制树形模型复杂度的主要参数。理论上，我们可以设置num_leaves = 2^(max_depth)来获得与深度方向树相同数量的叶子。然而，这种简单的转换在实践中并不好。原因是，对于固定数量的叶子，按叶排序的树通常比按深度排序的树更深。不受约束的深度会导致过度拟合。因此，在尝试调整num_leaves时，我们应该让它小于2^(max_depth).例如，当max_depth=7时，深度方向的树可以获得良好的准确性，但是将num_leaves设置为127可能会导致过度拟合，而将其设置为70或80可能会获得比深度方向更好的准确性。</p><p id="446f" class="lr ls op lt b lu mn ju lw lx mo jx lz ox mp mc md oy mq mg mh oz mr mk ml mm im bi translated"><strong class="lt iu">叶中最小数据。</strong>这是一个非常重要的参数，可以防止逐叶树中的过度拟合。它的最佳值取决于训练样本的数量和num_leaves。将其设置为较大的值可以避免树长得太深，但可能会导致欠拟合。实际上，对于大型数据集，将其设置为数百或数千就足够了。最大深度。您还可以使用max_depth来显式限制树深度。</p></blockquote><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="99a7" class="nm la it ni b gy nn no l np nq"># specify the configurations as a dict<br/>params = {<br/> ‘boosting_type’: ‘gbdt’,<br/> ‘objective’: ‘regression’,<br/> ‘metric’: ‘rmse’,<br/> ‘num_leaves’: 31,<br/> ‘learning_rate’: 0.05,<br/> ‘feature_fraction’: 0.9,<br/> ‘bagging_fraction’: 0.8,<br/> ‘bagging_freq’: 5,<br/> ‘verbose’: 0,<br/> ‘num_threads’ : 4<br/>}</span><span id="ccda" class="nm la it ni b gy nr no l np nq">print(‘Starting training…’)<br/># train<br/>gbm = lgb.train(params,<br/> lgb_train,<br/> num_boost_round=10000,<br/> valid_sets=lgb_eval,<br/> early_stopping_rounds=100)</span><span id="09df" class="nm la it ni b gy nr no l np nq">print(‘Saving model…’)<br/># save model to file<br/>gbm.save_model(‘model.txt’)</span><span id="4bd0" class="nm la it ni b gy nr no l np nq">print(‘Starting predicting…’)<br/># predict<br/>y_pred = gbm.predict(X_valid, num_iteration=gbm.best_iteration)<br/># eval<br/>print(‘The rmse of prediction is:’, mean_squared_error(Y_valid, y_pred) ** 0.5)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pa"><img src="../Images/9f9be0e20cc01aa890944f885d77a904.png" data-original-src="https://miro.medium.com/v2/resize:fit:1154/format:webp/1*1HfQc_mwS5hxyIcEJcucNw.png"/></div></figure><p id="12d4" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">让我们来看看特征重要性图。</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="cbad" class="nm la it ni b gy nn no l np nq">num_features = 50<br/>indxs = np.argsort(gbm.feature_importance())[:num_features]<br/> <br/>feature_imp = pd.DataFrame(sorted(zip(gbm.feature_importance()[indxs],X_train.columns[indxs])), columns=[‘Value’,’Feature’])</span><span id="ec9d" class="nm la it ni b gy nr no l np nq">plt.figure(figsize=(20, 20))<br/>sns.barplot(x=”Value”, y=”Feature”, data=feature_imp.sort_values(by=”Value”, ascending=False))<br/>plt.title(‘Top {} LightGBM Features accorss folds’.format(num_features))<br/>plt.tight_layout()<br/>plt.show()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pb"><img src="../Images/497a8c02dda448d08e8d5ba8c60742ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TYElCieCOsYIGFKDzZZ-dw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="d409" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">就是这样，我们成功地训练了一个LightGBM模型来预测下个月的销售额。</p><p id="4b81" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">如果你觉得这很有用，请为这个故事鼓掌。</p></div></div>    
</body>
</html>