<html>
<head>
<title>Automating Markup with Python and HTML5</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Python和HTML5自动化标记</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/automating-markup-with-python-and-html5-9054362e87ce?source=collection_archive---------32-----------------------#2021-04-02">https://towardsdatascience.com/automating-markup-with-python-and-html5-9054362e87ce?source=collection_archive---------32-----------------------#2021-04-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="624a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用原始Python处理HTML5非常容易，以便从字典数据创建web友好的表格。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/617141a0f15659d66841b13686be1636.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nnJ2wAc6OeQ4a5j1S7TBbA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(src =<a class="ae ky" href="https://unsplash.com/photos/0qE0qZ7_3eY" rel="noopener ugc nofollow" target="_blank">https://unsplash.com/photos/0qE0qZ7_3eY</a></p></figure><h1 id="0d14" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">介绍</h1><p id="84c6" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">IPython笔记本在Python的奇妙世界和超文本标记的世界之间建立了一座急需的桥梁。虽然在此之前，通过利用诸如网页之类的东西来利用Python的某些标记特性是完全可能的，但是随着IPython笔记本和IPython模块的普及，看到这两种语言一起工作来实现某个目标已经变得更加常见了。</p><p id="6edd" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">标记的伟大之处在于，在某种程度上，它只是一组被解析的表达式，用来指示解析器需要在屏幕上显示什么。这意味着基本上任何编程语言都可以创建它，并解码它。元编程是一个术语，主要用于做同样的事情，但是有表达式和求值，然而我认为在很多方面，将编程语言与标记结合起来的行为与元编程非常相似。</p><blockquote class="ms"><p id="52ad" class="mt mu it bd mv mw mx my mz na nb mm dk translated"><a class="ae ky" href="https://github.com/emmettgb/Emmetts-DS-NoteBooks/blob/master/Python3/Writing%20HTML%20from%20Python.ipynb" rel="noopener ugc nofollow" target="_blank">笔记本</a></p></blockquote></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><h1 id="9bf2" class="kz la it bd lb lc nj le lf lg nk li lj jz nl ka ll kc nm kd ln kf nn kg lp lq bi translated">数据表</h1><p id="266b" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在现代Python编程世界中，HTML5的一个非常常见的应用是IPython笔记本内部的显示。这通常是用HTML5或Javascript完成的。这两种方法都有各自的优点，比如交互性和简单性，但是不管怎样，能够做出一些非常有用的东西是非常好的，比如在Python笔记本中显示数据表的方法。</p><p id="1ab6" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">有趣的是，我最初在Julia语言中编写了这个算法，以便使用data frames . JL。data frames . JL有一个众所周知的可怕的显示输出，这是由它背后的大量软件包提供的，以便提供该功能。我决定用一个扩展来改变我自己安装的DataFrames.jl，这个扩展可以用更具表现力的HTML输出来显示数据帧。如果你想看看我在字典上的实现，你可以看看OddFrames.jl，这是一个在Julia中处理数据的包:</p><div class="no np gp gr nq nr"><a rel="noopener follow" target="_blank" href="/introducing-oddframes-jl-data-in-one-dimension-296e1389c27a"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd iu gy z fp nw fr fs nx fu fw is bi translated">OddFrames.jl简介:一维数据</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">我厌倦了DataFrames的工作方式，所以我自己做了一个。</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">towardsdatascience.com</p></div></div><div class="oa l"><div class="ob l oc od oe oa of ks nr"/></div></div></a></div><p id="9470" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">现在，我们将编写一个新的算法，将Python中的一些字典数据解析成HTML5表。</p><h1 id="9bda" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">编写我们的函数</h1><p id="7699" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在深入研究这个函数之前，我们首先需要评估的是输入和输出。首先，需要注意的是，我们很可能想要使用某种显示方法，而不是常规的返回。这是因为如果我们排除这个调用，HTML5可能会以字符串的形式返回，而不是显示出来。根据我的经验，我估计IPython的display()函数可能是最适合使用的解决方案。然而，在围绕一个函数构建某些东西之前测试它的功能总是很棒的，所以让我们尝试使用这种方法显示一些HTML，看看我们得到了什么:</p><pre class="kj kk kl km gt og oh oi oj aw ok bi"><span id="4e1f" class="ol la it oh b gy om on l oo op">from IPython.display import display</span></pre><p id="887a" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">注意，这个函数包含在同名的模块中。这一点很重要，因为很容易不小心说</p><pre class="kj kk kl km gt og oh oi oj aw ok bi"><span id="db4a" class="ol la it oh b gy om on l oo op">from IPython import display</span></pre><p id="be00" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">然后不小心调用了一个模块作为函数。现在让我们在一点HTML上试试这个函数:</p><pre class="kj kk kl km gt og oh oi oj aw ok bi"><span id="2ed1" class="ol la it oh b gy om on l oo op">display("&lt;h1&gt;Header&lt;/h1&gt;")</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/19c75c4997bb86ac1a76b841efa007c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:504/format:webp/1*mmYUOzb4NG7Uo8f0QGDNPA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="5363" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这正是为什么先测试一下是个好主意的原因。然而，在模块内部还有一个HTML类型，它在其构造函数中接受一个字符串。我猜display方法也可以接受这个HTML类型，以便实际返回HTML，因为现在它认为它只是在处理一个字符串。</p><pre class="kj kk kl km gt og oh oi oj aw ok bi"><span id="df2a" class="ol la it oh b gy om on l oo op">from IPython.display import display, HTML<br/>display(HTML("&lt;h1&gt;Header&lt;/h1&gt;"))</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi or"><img src="../Images/3d290bb4649e659692f13da7c1061942.png" data-original-src="https://miro.medium.com/v2/resize:fit:662/format:webp/1*9YCT8jLr_l3X1SRUL6ennw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="21eb" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">既然我们已经确定有一个可靠的方法来显示我们的HTML，我们可以假设函数的输出步骤已经完成。现在让我们考虑位置参数形式的输入。首先，当然，我们需要一本字典。对于本例，我将调用该查找。如果我们最终得到一个非常长的数据表，我们可能不希望显示所有的数据，所以我们应该添加另一个参数来决定我们的数据表要打印多少行。所有这些给了我们一个函数定义，看起来像这样:</p><pre class="kj kk kl km gt og oh oi oj aw ok bi"><span id="da10" class="ol la it oh b gy om on l oo op">def show_dict(lookup : dict, count : int = 5):</span></pre><p id="5385" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">由于这种情况下的大部分工作都是字符串连接，我们需要做的第一件事就是创建一个字符串。在这个特殊的例子中，我们将创建一个保存字典中的键的表头和一个保存字典中的值的表体。表头是用HTML5中的<thead>标签做的。我们还将添加一个<tr>标签，因为头部只有一行。对于表体，我们将把它作为一个字符串设置到</tr></thead><tbody>标签中。</tbody></p><pre class="kj kk kl km gt og oh oi oj aw ok bi"><span id="c955" class="ol la it oh b gy om on l oo op">def show_dict(lookup : dict, count : int = 5):<br/>    thead = "&lt;thead&gt;&lt;tr&gt;"<br/>    tbody = "&lt;tbody&gt;"</span></pre><p id="ee93" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">接下来，我们将使用dict.keys()函数遍历字典中的键。这将从我们的字典中返回一个有序的键列表。对于这个列表中的每个迭代，我们将使用表头标签<th>添加一个新的表头。在标签之间，我们将放入在这个迭代循环中循环的每个名字。我将把“str”类型转换到这些键上，以防它们被存储为不同的数据类型，以避免任何方法错误的问题。总结一下我的意思，如果我们不事先将这个类型转换成字符串，就有可能出现“没有方法匹配字符串(str，不支持的类型，str)”的错误。也就是说，如果字符串构造函数不能首先转换我们的类型，那么添加这个构造函数基本上是没有用的。</th></p><pre class="kj kk kl km gt og oh oi oj aw ok bi"><span id="cd28" class="ol la it oh b gy om on l oo op">for name in lookup.keys():<br/>        thead = str(thead, "&lt;th&gt;", str(name), "&lt;/th&gt;")</span></pre><p id="6b77" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">现在，我们将通过添加我们的<tr>和<thead>标签的结尾来结束我们的head标签，这两个标签是相同的，只是添加了一个斜杠，有点像正则表达式中的反斜杠:</thead></tr></p><pre class="kj kk kl km gt og oh oi oj aw ok bi"><span id="ef82" class="ol la it oh b gy om on l oo op">thead = string(thead, "&lt;/tr&gt;&lt;/thead&gt;")</span></pre><p id="ffd1" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">现在，我们实际上可以尝试一下这个功能，看看头部的显示器实际上是否工作。当然，我们首先需要添加IPython.display.display()调用。</p><pre class="kj kk kl km gt og oh oi oj aw ok bi"><span id="6ba2" class="ol la it oh b gy om on l oo op">def show_dict(lookup : dict, count : int = 5):<br/>    thead = "&lt;thead&gt;&lt;tr&gt;"<br/>    tbody = "&lt;tbody&gt;"<br/>    for name in lookup.keys():<br/>        thead = str(thead, "&lt;th&gt;", str(name), "&lt;/th&gt;")</span><span id="8ef9" class="ol la it oh b gy os on l oo op">thead = str(thead, "&lt;/tr&gt;&lt;/thead&gt;")<br/>    display(HTML(thead))</span></pre><p id="c3cc" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们来试试吧！</p><pre class="kj kk kl km gt og oh oi oj aw ok bi"><span id="26a8" class="ol la it oh b gy om on l oo op">lookup = dict({"A": [5, 10, 15, 20], "B": [5, 10, 15, 20]})<br/>show_dict(lookup)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ot"><img src="../Images/f19d928ec3ececeb86c360428f244d54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h0xhHigXiNhd1oWuQnCfsg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><blockquote class="ms"><p id="6192" class="mt mu it bd mv mw ou ov ow ox oy mm dk translated">使用多种语言的问题是。</p></blockquote><p id="71b4" class="pw-post-body-paragraph lr ls it lt b lu oz ju lw lx pa jx lz ma pb mc md me pc mg mh mi pd mk ml mm im bi translated">在Python中，我们实际上不需要强制转换这种类型，我们可以使用+运算符来连接字符串。我来自编程的函数世界，我认为这很有趣也很酷，因为这些字符串是完整的类，而不仅仅是保存数据的简单结构。让我们改用加法运算符:</p><pre class="kj kk kl km gt og oh oi oj aw ok bi"><span id="b8fa" class="ol la it oh b gy om on l oo op">def show_dict(lookup : dict, count : int = 5):<br/>    thead = "&lt;thead&gt;&lt;tr&gt;"<br/>    tbody = "&lt;tbody&gt;"<br/>    for name in lookup.keys():<br/>        thead = thead + "&lt;th&gt;" + str(name) + "&lt;/th&gt;"</span><span id="ca1a" class="ol la it oh b gy os on l oo op">    thead = thead + "&lt;/tr&gt;&lt;/thead&gt;"<br/>    display(HTML(thead))</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pe"><img src="../Images/f6feafee51d54d4e40994d3c286bf782.png" data-original-src="https://miro.medium.com/v2/resize:fit:410/format:webp/1*rze9fHGERLZ6MB2Mpz7adg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><h1 id="5c3b" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">添加正文</h1><p id="8318" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">至于表的主体，我们将从使用dict.values()函数提取值开始，就像我们使用dict.keys()函数一样。</p><pre class="kj kk kl km gt og oh oi oj aw ok bi"><span id="a57d" class="ol la it oh b gy om on l oo op">cols = lookup.values()</span></pre><p id="face" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">鉴于前面的操作，很容易想象我们下一步需要做什么。我们当然会迭代地创建新的表行。为了做到这一点，我们不打算像上次一样循环遍历我们的新值集。这是因为我们将按顺序创建每个<tr>标记，所以如果我们要遍历这些值，我们将遍历一个特征的所有观察值，而不是遍历行。换句话说，我们需要水平填充，而不是垂直填充。考虑到这一点，我们将在迭代中使用一个范围生成器。这将允许我们为每一行调用附加for循环中的每个观察。当然，我们不希望这调用特征的长度，而是我们希望调用第一个特征的长度，因为否则我们将得到特征计数而不是观察计数。</tr></p><pre class="kj kk kl km gt og oh oi oj aw ok bi"><span id="e342" class="ol la it oh b gy om on l oo op">for i in range(1, len(cols[0])):</span></pre><p id="f0a3" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">现在，我们将使用另一个迭代循环将我们的工作限制在我们的一行特征上:</p><pre class="kj kk kl km gt og oh oi oj aw ok bi"><span id="124c" class="ol la it oh b gy om on l oo op">for i in range(1, len(cols[0])):<br/>     obs = [row[i] for row in cols]</span></pre><p id="26d5" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">现在，我们将在for循环中为此行开始一个新的行标记:</p><pre class="kj kk kl km gt og oh oi oj aw ok bi"><span id="ce88" class="ol la it oh b gy om on l oo op">tbody = tbody + "&lt;tr&gt;"</span></pre><p id="4ee7" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">现在我们将遍历行内的值，并将它们添加到我们的tbody中的<td>标签之间:</td></p><pre class="kj kk kl km gt og oh oi oj aw ok bi"><span id="30a6" class="ol la it oh b gy om on l oo op">for observ in obs:<br/>            tbody = tbody + "&lt;td&gt;" + observ + "&lt;/td&gt;"</span></pre><p id="a9d3" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">最后，我们将使用之前开始的<tr>标记结束该行:</tr></p><pre class="kj kk kl km gt og oh oi oj aw ok bi"><span id="d988" class="ol la it oh b gy om on l oo op">tbody = tbody + "&lt;/tr&gt;"</span></pre><p id="40fb" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">现在，整个循环应该看起来像这样:</p><pre class="kj kk kl km gt og oh oi oj aw ok bi"><span id="4988" class="ol la it oh b gy om on l oo op">for i in range(1, len(cols[0])):<br/>        obs = [row[i] for row in cols]<br/>        tbody = tbody + "&lt;tr&gt;"<br/>        for observ in obs:<br/>            tbody = tbody + "&lt;td&gt;" + observ + "&lt;/td&gt;"<br/>        tbody = tbody + "&lt;/tr&gt;"</span></pre><p id="615f" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在这个循环之后，我们将关闭tbody标记:</p><pre class="kj kk kl km gt og oh oi oj aw ok bi"><span id="471c" class="ol la it oh b gy om on l oo op">tbody = tbody + "&lt;/tbody&gt;"</span></pre><p id="ba86" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">最后，我们将组合thead和tbody，然后使用display函数和HTML构造函数来显示结果:</p><pre class="kj kk kl km gt og oh oi oj aw ok bi"><span id="83a7" class="ol la it oh b gy om on l oo op">composition = str(thead + tbody)<br/>display(HTML(composition))</span></pre><p id="a1fc" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">现在我们的函数应该看起来有点像这样:</p><pre class="kj kk kl km gt og oh oi oj aw ok bi"><span id="b036" class="ol la it oh b gy om on l oo op">def show_dict(lookup : dict, count : int = 5):<br/>    thead = "&lt;thead&gt;&lt;tr&gt;"<br/>    tbody = "&lt;tbody&gt;"<br/>    for name in lookup.keys():<br/>        thead = thead + "&lt;th&gt;" + str(name) + "&lt;/th&gt;"<br/>    thead = thead + "&lt;/tr&gt;&lt;/thead&gt;"<br/>    cols = lookup.values()<br/>    for i in range(1, len(cols[0])):<br/>        obs = [row[i] for row in cols]<br/>        tbody = tbody + "&lt;tr&gt;"<br/>        for observ in obs:<br/>            tbody = tbody + "&lt;td&gt;" + observ + "&lt;/td&gt;"<br/>        tbody = tbody + "&lt;/tr&gt;"<br/>    tbody = tbody + "&lt;/tbody&gt;"<br/>    composition = str(thead + tbody)<br/>    display(HTML(composition))</span></pre><p id="4b3e" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">现在让我们试着在字典上使用这个函数:</p><pre class="kj kk kl km gt og oh oi oj aw ok bi"><span id="89d4" class="ol la it oh b gy om on l oo op">show_dict(lookup)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pf"><img src="../Images/2971877699f151292fe7373ccdc53635.png" data-original-src="https://miro.medium.com/v2/resize:fit:1378/format:webp/1*-5PCk5KZfEyva2Uo4-BEKA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><blockquote class="ms"><p id="e3ce" class="mt mu it bd mv mw ou ov ow ox oy mm dk translated">这是一个问题。</p></blockquote><p id="50a8" class="pw-post-body-paragraph lr ls it lt b lu oz ju lw lx pa jx lz ma pb mc md me pc mg mh mi pd mk ml mm im bi translated">奇怪的是，似乎字典键和值都有一个单独的类。为了避免遇到这个问题，我们需要创建一种新的方法来提取没有values()函数的值，或者找出一种方法来重新转换我们的类型。我选择了前者，因为我们已经将键放入了一个列表中，要创建这样一个列表，循环遍历这个列表是相当简单的。</p><pre class="kj kk kl km gt og oh oi oj aw ok bi"><span id="b646" class="ol la it oh b gy om on l oo op">cols = [lookup[name] for name in lookup.keys()]</span></pre><p id="4af6" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">现在我们的新函数看起来像这样:</p><pre class="kj kk kl km gt og oh oi oj aw ok bi"><span id="e59a" class="ol la it oh b gy om on l oo op">def show_dict(lookup : dict, count : int = 5):<br/>    thead = "&lt;thead&gt;&lt;tr&gt;"<br/>    tbody = "&lt;tbody&gt;"<br/>    for name in lookup.keys():<br/>        thead = thead + "&lt;th&gt;" + str(name) + "&lt;/th&gt;"<br/>    thead = thead + "&lt;/tr&gt;&lt;/thead&gt;"<br/>    cols = [lookup[name] for name in lookup.keys()]<br/>    for i in range(1, len(cols[0])):<br/>        obs = [row[i] for row in cols]<br/>        tbody = tbody + "&lt;tr&gt;"<br/>        for observ in obs:<br/>            tbody = tbody + "&lt;td&gt;" + observ + "&lt;/td&gt;"<br/>        tbody = tbody + "&lt;/tr&gt;"<br/>    tbody = tbody + "&lt;/tbody&gt;"<br/>    composition = str(thead + tbody)<br/>    display(HTML(composition))</span></pre><p id="0048" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">让我们看看这个解决方案是否可行！</p><pre class="kj kk kl km gt og oh oi oj aw ok bi"><span id="95c6" class="ol la it oh b gy om on l oo op">show_dict(lookup)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pg"><img src="../Images/b85b9e839710404787899c7181f48b8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1332/format:webp/1*PcJLR25WbMPlP8mqOTbvJw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="9d34" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">有趣的是，我可能已经做了我之前警告过的事情，但是这是一个类型错误而不是方法错误。这可能是Julia的一个方法错误，所以这就是错误的来源，你每天都会学到新的东西！</p><pre class="kj kk kl km gt og oh oi oj aw ok bi"><span id="b36b" class="ol la it oh b gy om on l oo op">def show_dict(lookup : dict, count : int = 5):<br/>    thead = "&lt;thead&gt;&lt;tr&gt;"<br/>    tbody = "&lt;tbody&gt;"<br/>    for name in lookup.keys():<br/>        thead = thead + "&lt;th&gt;" + str(name) + "&lt;/th&gt;"<br/>    thead = thead + "&lt;/tr&gt;&lt;/thead&gt;"<br/>    cols = [lookup[name] for name in lookup.keys()]<br/>    for i in range(1, len(cols[0])):<br/>        obs = [row[i] for row in cols]<br/>        tbody = tbody + "&lt;tr&gt;"<br/>        for observ in obs:<br/>            tbody = tbody + "&lt;td&gt;" + str(observ) + "&lt;/td&gt;"<br/>        tbody = tbody + "&lt;/tr&gt;"<br/>    tbody = tbody + "&lt;/tbody&gt;"<br/>    composition = str(thead + tbody)<br/>    display(HTML(composition))</span><span id="7284" class="ol la it oh b gy os on l oo op">show_dict(lookup)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ph"><img src="../Images/9941ded8044c3f2b1b23a527cbc740b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:562/format:webp/1*lW-ijuqRuth8U9eD3zIOZg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><blockquote class="ms"><p id="4034" class="mt mu it bd mv mw ou ov ow ox oy mm dk translated">成功了！</p></blockquote><p id="2a76" class="pw-post-body-paragraph lr ls it lt b lu oz ju lw lx pa jx lz ma pb mc md me pc mg mh mi pd mk ml mm im bi translated">您可能已经注意到列表是[5，10，15，20]，换句话说，第一个值从行中删除了。发生这种情况的原因是因为我使用1作为我们的范围生成器的开始，因为Python的索引从0开始。回到指责我的错误是因为习惯了Julia，Julia从1开始它的索引，就像Mathematica一样。如果我们将其更改为0，我们会看到现在所有的值都已填充:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pi"><img src="../Images/80bd41943395850d20decb31af8bb6a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:626/format:webp/1*9y8uUKgNGUri0we0S3Bm8w.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><h1 id="4bfe" class="kz la it bd lb lc nj le lf lg nk li lj jz nl ka ll kc nm kd ln kf nn kg lp lq bi translated">结论</h1><p id="eaa0" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在我看来，这是相当有趣的编程练习！将文本连接在一起制作一个微型网页不仅很酷，而且如果没有一千个更好的实现的话，这段代码可能会很有用。也就是说，不管它是否有用，我确实认为在这里检查代码，并在Python中使用这样的算法是有价值的！这是我们的最后一个函数，正如我之前讨论的那样，范围生成器发生了改变:</p><pre class="kj kk kl km gt og oh oi oj aw ok bi"><span id="d2d2" class="ol la it oh b gy om on l oo op">def show_dict(lookup : dict, count : int = 5):<br/>    thead = "&lt;thead&gt;&lt;tr&gt;"<br/>    tbody = "&lt;tbody&gt;"<br/>    for name in lookup.keys():<br/>        thead = thead + "&lt;th&gt;" + str(name) + "&lt;/th&gt;"<br/>    thead = thead + "&lt;/tr&gt;&lt;/thead&gt;"<br/>    cols = [lookup[name] for name in lookup.keys()]<br/>    for i in range(0, len(cols[0])):<br/>        obs = [row[i] for row in cols]<br/>        tbody = tbody + "&lt;tr&gt;"<br/>        for observ in obs:<br/>            tbody = tbody + "&lt;td&gt;" + str(observ) + "&lt;/td&gt;"<br/>        tbody = tbody + "&lt;/tr&gt;"<br/>    tbody = tbody + "&lt;/tbody&gt;"<br/>    composition = str(thead + tbody)<br/>    display(HTML(composition))</span></pre><p id="1585" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">希望这是一种有趣的方式来提高一些循环技巧，并发现一些关于Python编程语言的更有趣的事情。谢谢你的阅读，它对我来说意味着整个世界！</p></div></div>    
</body>
</html>