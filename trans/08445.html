<html>
<head>
<title>Why You Should Use Async In Python.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么应该在Python中使用异步？</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/why-you-should-use-async-in-python-6ab53740077e?source=collection_archive---------5-----------------------#2021-08-04">https://towardsdatascience.com/why-you-should-use-async-in-python-6ab53740077e?source=collection_archive---------5-----------------------#2021-08-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9b01" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">并提高您的I/O代码性能。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/814ade8b3b1f5ae3fea606af79bc0674.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*R1KEHiHMX4p2dXPM"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae ky" href="https://unsplash.com/@clemhlrdt?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Clément Hélardot </a>拍摄</p></figure><p id="f680" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi lv translated">从Python 3.5开始，可以在你的脚本中使用异步。这种发展允许使用新的关键字<code class="fe me mf mg mh b">async</code>和<code class="fe me mf mg mh b">await</code>以及新的模块asyncio。</p><p id="1875" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Async和Await最初是在C#中引入的，目的是以类似于编写阻塞代码的方式构造非阻塞代码。这些关键字随后被导出到几种编程语言中，因为它方便了异步代码的管理。</p><p id="17ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事实上，还有其他方式来编写异步代码，如果你知道Javascript/Nodejs，那么你可能已经使用过回调了:</p><pre class="kj kk kl km gt mi mh mj mk aw ml bi"><span id="84f6" class="mm mn it mh b gy mo mp l mq mr">fs = require('fs');<br/>fs.writeFile('hello.txt', 'call back exemple in nodejs', (err) =&gt; {<br/>  if (err) return console.log(err);<br/>  console.log('file writen');<br/>});</span></pre><p id="0e44" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦事件发生，在第二个位置传递的回调函数将被调用</p><p id="952b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，还有承诺，允许更好地管理具有表达性词语的异步调用:</p><pre class="kj kk kl km gt mi mh mj mk aw ml bi"><span id="255c" class="mm mn it mh b gy mo mp l mq mr">import axios from 'axios'</span><span id="f040" class="mm mn it mh b gy ms mp l mq mr">let data;<br/>axios.get("https://jsonplaceholder.typicode.com/posts")<br/>  .then(resp =&gt; {<br/>                data = resp.data <em class="mt">//do data processing as data is actually available<br/>                </em>})<br/>  .catch(err =&gt; { console.log(err) })</span><span id="bb37" class="mm mn it mh b gy ms mp l mq mr">console.log(data) <em class="mt">// undefined even if the instruction is after the API call</em></span></pre><p id="b834" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些技术的一个问题是，我们脱离了影响可读性的代码水平阅读流程。无论如何，让我们回到它如何影响你作为一个Python用户。</p></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h2 id="4893" class="mm mn it bd nb nc nd dn ne nf ng dp nh li ni nj nk lm nl nm nn lq no np nq nr bi translated">Python中标准IO代码的问题。</h2><p id="b6f8" class="pw-post-body-paragraph kz la it lb b lc ns ju le lf nt jx lh li nu lk ll lm nv lo lp lq nw ls lt lu im bi translated">IO代码是调用外部服务的指令。例如，这可以是HTTP请求或对数据库的调用。标准python代码的问题在于，如果你的代码只调用这些服务，那么在继续下一条指令之前，必须等待这些服务的响应。</p><pre class="kj kk kl km gt mi mh mj mk aw ml bi"><span id="44cc" class="mm mn it mh b gy mo mp l mq mr">import requests</span><span id="aeac" class="mm mn it mh b gy ms mp l mq mr">data = (requests<br/>       .get("https://jsonplaceholder.typicode.com/posts")<br/>       .json()<br/>) <em class="mt"># blocking code block, python waiting doing nothing</em></span><span id="df7f" class="mm mn it mh b gy ms mp l mq mr">for d in data: # executed once the API has return<br/>   print(d)</span></pre><p id="4cc5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的例子中，这不是很烦人，因为只有一个对外部服务的调用，但是让我们看看下面的代码。</p><pre class="kj kk kl km gt mi mh mj mk aw ml bi"><span id="4def" class="mm mn it mh b gy mo mp l mq mr">def fetch_comments():<br/>  data = []<br/>  for i in range(1, 500):<br/>    url = f"https://jsonplaceholder.typicode.com/comments/{i}"<br/>    resp = requests.get(url).json()<br/>    data.append(resp)</span><span id="218a" class="mm mn it mh b gy ms mp l mq mr">fetch_comments()</span></pre><p id="7be0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这段代码花了<strong class="lb iu"> 126.95秒在我的机器上完成</strong>。因此，我们可以看到它不是最佳的。我们需要引入并行性，即同时执行几个请求。</p></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h2 id="0615" class="mm mn it bd nb nc nd dn ne nf ng dp nh li ni nj nk lm nl nm nn lq no np nq nr bi translated">传统方式:线程</h2><p id="f9e5" class="pw-post-body-paragraph kz la it lb b lc ns ju le lf nt jx lh li nu lk ll lm nv lo lp lq nw ls lt lu im bi translated">在Python中出现asyncio之前，要处理这类问题，你必须使用线程。线程是进程的一个组成部分，可以被并发管理。然而，Python有一个全局解释器锁，它将线程的使用限制在不使用解释代码的指令上。这不是这里的情况，因为我们使用外部服务。事不宜迟，下面是调用API的代码的线程版本。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">API调用的线程版本来源:作者</p></figure><p id="c501" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可以看出，线程版本的代码比同步版本需要更多的工作。事实上，我们必须管理一个队列，允许线程选择不同的URL进行处理。</p><p id="87e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一方面，在我的机器上，执行这段包含5个线程的代码只花了<strong class="lb iu"> 7.05秒，与同步版本相比减少了94% </strong>。但是如果我告诉你我们可以做得更好。</p></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h2 id="f4ed" class="mm mn it bd nb nc nd dn ne nf ng dp nh li ni nj nk lm nl nm nn lq no np nq nr bi translated">现代方式:异步代码</h2><p id="a5e3" class="pw-post-body-paragraph kz la it lb b lc ns ju le lf nt jx lh li nu lk ll lm nv lo lp lq nw ls lt lu im bi translated">让我们看看如何用异步代码进行API调用。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">API调用的异步版本来源:作者</p></figure><p id="0ed4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里也一样，要获得与同步版本相同的结果需要付出更多的努力，而且至少要付出与线程版本一样多的努力，那么这样做值得吗？在我的机器上，这段代码花了<strong class="lb iu"> 0.4880秒</strong>完成，你告诉我。</p><p id="a113" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么，为什么与线程相比，异步版本的性能如此之好呢？因为生成和管理线程不是免费的，而异步版本不需要管理这些机制。</p></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h2 id="43e1" class="mm mn it bd nb nc nd dn ne nf ng dp nh li ni nj nk lm nl nm nn lq no np nq nr bi translated">结论</h2><p id="6551" class="pw-post-body-paragraph kz la it lb b lc ns ju le lf nt jx lh li nu lk ll lm nv lo lp lq nw ls lt lu im bi translated">本文旨在向您展示异步代码如何提高某些任务的性能。网上有很多教程可以学习如何在python中使用这种新范式。</p><p id="0652" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管Python支持异步已经有几年了，但你必须记住，并不是所有的旧库都支持异步，因为这意味着必须重写代码。例如，您一定已经注意到，我不能在异步示例中使用请求，而是使用aiohttp，它是等效的异步版本</p><p id="125a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您确信并希望切换到异步模式，<a class="ae ky" href="https://github.com/aio-libs" rel="noopener ugc nofollow" target="_blank"> aio-libs </a> repository提供了一套基于asyncio的库，他们可能有一个符合您的需求。</p></div></div>    
</body>
</html>