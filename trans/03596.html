<html>
<head>
<title>Optimise Deep Learning Workflow with Fast S3</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">利用快速S3优化深度学习工作流程</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/optimise-deep-learning-workflow-with-fast-s3-f706ad059039?source=collection_archive---------27-----------------------#2021-03-23">https://towardsdatascience.com/optimise-deep-learning-workflow-with-fast-s3-f706ad059039?source=collection_archive---------27-----------------------#2021-03-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="86c7" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">以快速S3为中心数据和模型库，构建可复制、可扩展的深度学习系统。</h2></div><p id="fc86" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我知道大多数数据科学家不关心存储，他们也不应该关心存储。然而，在系统中拥有快速S3对象存储肯定会有助于优化我们的深度学习工作流程。让我在这篇博客中解释一下为什么“存储在DL中非常重要”。</p><h1 id="bb47" class="le lf it bd lg lh li lj lk ll lm ln lo jz lp ka lq kc lr kd ls kf lt kg lu lv bi translated">快速NFS分布式培训</h1><p id="e9ff" class="pw-post-body-paragraph ki kj it kk b kl lw ju kn ko lx jx kq kr ly kt ku kv lz kx ky kz ma lb lc ld im bi translated">在我之前的博客中，我解释了为什么以及如何使用Kubernetes、Horovod和FlashBlade NFS这样的快速NFS存储从单节点扩展到分布式多节点训练。下面是我们在博客中讨论的架构:</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi mc"><img src="../Images/15cd3d5636cc4b02879031e4a3ea4740.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ISltfs-2iX2nBtnAC8OIrA.png"/></div></div><p class="mo mp gj gh gi mq mr bd b be z dk translated">在FlashBlade NFS上使用Kubernetes进行深度学习</p></figure><p id="5534" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是船上分布式培训的第一阶段。虽然存储可能很少出现在DL对话中，但构建可扩展的DL系统就像建造一座大房子，您需要在屋顶工作之前先构建一个坚实的基础。DL系统的基础是基础设施，不仅包括GPU服务器，还包括存储和网络。在上述体系结构中，如果我们只关注NFS存储部分，它带来的好处包括:</p><ul class=""><li id="9eff" class="ms mt it kk b kl km ko kp kr mu kv mv kz mw ld mx my mz na bi translated">允许在不适合单个主机的大型数据集上进行训练。</li><li id="7fae" class="ms mt it kk b kl nb ko nc kr nd kv ne kz nf ld mx my mz na bi translated">允许团队共享昂贵的GPU硬件和数据。</li><li id="043b" class="ms mt it kk b kl nb ko nc kr nd kv ne kz nf ld mx my mz na bi translated">让机器学习工程师更容易聚合日志、管理检查点和导出模型。</li></ul><p id="196c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，随着系统的升级和扩展以支持更多的机器学习工作和操作，挑战出现了。NFS对于主机或机架来说是静态的，但是DL工作流是非常动态的。因为所有主机/单元都需要装载一个NFS卷来访问其中的数据，所以这在大规模应用时会很有挑战性:</p><ul class=""><li id="c797" class="ms mt it kk b kl km ko kp kr mu kv mv kz mw ld mx my mz na bi translated">数据访问控制在主机级别。因此，存在数据集从装载该卷的任何主机上意外删除的风险。</li><li id="3920" class="ms mt it kk b kl nb ko nc kr nd kv ne kz nf ld mx my mz na bi translated">由于上述风险，数据集的主副本通常存储在远程存储器中，如HDFS或S3。将数据从HDFS或S3复制到NFS可能会很慢。</li><li id="89eb" class="ms mt it kk b kl nb ko nc kr nd kv ne kz nf ld mx my mz na bi translated">难以进行可重复的模型训练，这需要对代码和数据进行集中管理。</li><li id="4e06" class="ms mt it kk b kl nb ko nc kr nd kv ne kz nf ld mx my mz na bi translated">弹性模型服务困难。在大公司中，模型训练和服务通常在不同的环境中由不同的团队管理。特别是，模型服务系统可能会频繁地扩大和缩小，NFS根本不是最适合的。</li></ul><p id="7123" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里的解决方案是借用数据工程和devOps的最佳实践到我们的DL工作流中。我见过的最佳实践之一是使用像S3这样的对象存储作为中央数据存储库。</p><h1 id="1418" class="le lf it bd lg lh li lj lk ll lm ln lo jz lp ka lq kc lr kd ls kf lt kg lu lv bi translated">利用快速S3优化DL工作流程</h1><p id="87e7" class="pw-post-body-paragraph ki kj it kk b kl lw ju kn ko lx jx kq kr ly kt ku kv lz kx ky kz ma lb lc ld im bi translated">在机器学习和深度学习之前，我在大数据(Hadoop和Spark)和devOps(云，平台即服务)上花了10多年时间。我从自己的经历中学到的一件事是，S3对象存储在这些系统中起着至关重要的作用。这也适用于大规模的DL系统。</p><p id="24f9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">快速S3对象存储如何帮助优化我们的DL工作流程？好处来自于使用S3作为数据和模型的中央存储库。在以下修改后的体系结构中，我们使用S3闪存来存储训练数据集、日志和检查点，而不是NFS。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi ng"><img src="../Images/d8140e343fc0aaba3aedddf727ea627c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zqcJEXvib03pa6mkQb-U4Q.png"/></div></div><p class="mo mp gj gh gi mq mr bd b be z dk translated">利用快速S3优化DL工作流程</p></figure><p id="d49d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们仍然使用NFS，但仅用于工作区卷，它仅存储临时数据。我们将训练数据和模型管理集中在快速S3对象存储中，与NFS不同，它是在存储端而不是每个单独的主机上进行管理的，并且可以从系统中的任何位置进行访问。快速S3是动态DL工作流的理想选择。</p><h2 id="c619" class="nh lf it bd lg ni nj dn lk nk nl dp lo kr nm nn lq kv no np ls kz nq nr lu ns bi translated">在S3使用数据集</h2><p id="cb1b" class="pw-post-body-paragraph ki kj it kk b kl lw ju kn ko lx jx kq kr ly kt ku kv lz kx ky kz ma lb lc ld im bi translated">我们没有将数据集放在NFS，而是放在了S3桶中。这使得能够与数据工程工作流顺利集成。S3正在成为Apache Spark等许多大数据工具的标准存储。我们的数据工程团队可能使用Spark来完成繁重的ETL工作，并简单地将预处理的输出(例如，拼花文件)放入S3桶中。通过使用S3，我们避免了数据工程和数据科学团队之间额外的数据拷贝。看看我的博客关于如何在S3上使用Apache Spark和Kubernetes。一旦预处理完成，输出数据将立即出现在S3。我们可以使用JupyterLab的S3浏览器扩展来研究这些数据。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi nt"><img src="../Images/071636503529353a6473d5b832b84b91.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D0qYSTxOvNoKgCmueUBxKw.png"/></div></div><p class="mo mp gj gh gi mq mr bd b be z dk translated">JupyterLab S3浏览器</p></figure><p id="4f8a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后培训岗位可以选择将数据下载到其工作区NFS卷，或者直接在S3阅读，进行培训。由于FlashBlase S3非常快，因此将S3数据直接读入训练迭代是可行的。如果数据集太大而无法下载，这将非常有用。例如，我们可以像这样直接从TensorFlow中的S3读取数据，而不是下载20TB的数据:</p><pre class="md me mf mg gt nu nv nw nx aw ny bi"><span id="aba8" class="nh lf it nv b gy nz oa l ob oc">ds = tf.data.TFRecordDataset(<br/>               s3_filepaths, <br/>               num_parallel_reads=10, <br/>               buffer_size=100000000)</span></pre><p id="a81b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">与下载整个20TB数据集相比，上面的代码使用最少的临时存储和内存，可以立即开始，而不必等待下载完成。通过使用像FlashBlade S3这样的快速S3，并调整并行读取的数量和缓冲区大小，可以达到与从快速NFS读取相当的性能。</p><h2 id="52c4" class="nh lf it bd lg ni nj dn lk nk nl dp lo kr nm nn lq kv no np ls kz nq nr lu ns bi translated">使用S3进行模型跟踪和服务</h2><p id="c78c" class="pw-post-body-paragraph ki kj it kk b kl lw ju kn ko lx jx kq kr ly kt ku kv lz kx ky kz ma lb lc ld im bi translated">在上面的架构中，我们还使用S3来存储训练日志、检查点和模型。这使得我们可以很容易地将模型跟踪和服务从训练中分离出来，这对于构建一个可重复和可伸缩的DL管道是必不可少的。下面的例子启动了一个指向存储在S3的日志的TensorBoard pod。</p><pre class="md me mf mg gt nu nv nw nx aw ny bi"><span id="f1d1" class="nh lf it nv b gy nz oa l ob oc">tensorboard --logdir s3://deephub/models/lstm-sentiment/logs --host 0.0.0.0</span></pre><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi od"><img src="../Images/7a98ddec2eb9166c043c1110dec5f47d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DSUJbh0d3jtRk2thoUMfXg.png"/></div></div><p class="mo mp gj gh gi mq mr bd b be z dk translated">S3支持的TensorBoard</p></figure><p id="9771" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们还可以在Kubernetes上单独部署一个mlflow跟踪服务器，并将其指向S3桶进行高级模型跟踪。</p><pre class="md me mf mg gt nu nv nw nx aw ny bi"><span id="cf27" class="nh lf it nv b gy nz oa l ob oc">mlflow server \<br/> --backend-store-uri postgresql://user:password@mypostgres:5432/mlflow \<br/> --default-artifact-root s3://deephub/mlflow/ \<br/> --host 0.0.0.0</span></pre><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi oe"><img src="../Images/4b0bb94290e7a3e426f675f2c60b3cd6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U_YGM-ITugF4tahzwxh9sg.png"/></div></div><p class="mo mp gj gh gi mq mr bd b be z dk translated">使用S3后端进行物流跟踪</p></figure><p id="deb6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">同样，模特服务也可以得到S3的支持。</p><pre class="md me mf mg gt nu nv nw nx aw ny bi"><span id="6c16" class="nh lf it nv b gy nz oa l ob oc">MODEL_BASE_PATH=s3://bucket/models tensorflow/serving</span></pre><p id="76d0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">模型服务基本上是一个web应用程序，它将模型公开为web APIs。运营和扩展模型服务就像一个典型的devOps场景。将原始模型放在S3，所有的服务pods都可以从中读取和缓存，这就像是devOps中运行稳定且可伸缩的web应用程序的常见做法。</p><h1 id="830a" class="le lf it bd lg lh li lj lk ll lm ln lo jz lp ka lq kc lr kd ls kf lt kg lu lv bi translated">摘要</h1><p id="68e4" class="pw-post-body-paragraph ki kj it kk b kl lw ju kn ko lx jx kq kr ly kt ku kv lz kx ky kz ma lb lc ld im bi translated">由于所有重要的数据，包括数据集、训练日志、检查点和模型，都存储在S3，数据和模型管理变得更加容易。S3存储桶中的数据是黄金记录，被集中起来并受到保护。通过使用S3复制和版本控制，我们可以进一步增强我们的数据保护。高级用户还可以在S3数据的基础上构建数据治理、质量控制和模型版本控制。</p><p id="4a85" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">总而言之，使用S3作为中央数据存储库有助于从以下几点优化DL工作流程:</p><ul class=""><li id="3ab6" class="ms mt it kk b kl km ko kp kr mu kv mv kz mw ld mx my mz na bi translated">简化的工作流程。涉及的存储操作较少。数据科学家可以简单地下载或直接从S3的训练代码中读取数据。</li><li id="76cb" class="ms mt it kk b kl nb ko nc kr nd kv ne kz nf ld mx my mz na bi translated">简单的数据和模型管理。我们通过将数据放在S3作为数据和模型的黄金记录来避免数据孤岛。数据保护、版本控制和跟踪更加容易。所有这些都将有助于可重复的模型训练。</li><li id="9b8f" class="ms mt it kk b kl nb ko nc kr nd kv ne kz nf ld mx my mz na bi translated">易于弹性模型服务。通过分离模型训练、跟踪和服务，深度学习工作流中的每个阶段都可以独立、轻松、快速地扩大和缩小。</li></ul><p id="0423" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下一篇博客再见。</p></div></div>    
</body>
</html>