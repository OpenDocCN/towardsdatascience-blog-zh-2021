<html>
<head>
<title>Rational UI Design with Streamlit</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 Streamlit 的 Rational UI 设计</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/rational-ui-design-with-streamlit-61619f7a6ea4?source=collection_archive---------13-----------------------#2021-11-18">https://towardsdatascience.com/rational-ui-design-with-streamlit-61619f7a6ea4?source=collection_archive---------13-----------------------#2021-11-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="989b" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">数据可视化</h2><div class=""/><div class=""><h2 id="1738" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">从一个角度来看，Streamlit 是 web 开发中的一个倒退，因为它让你将应用程序的逻辑与它的呈现方式混合起来。但是从另一个角度来看，它大大简化了网页设计。</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/c65629f4a5d3bb0af011131272fa3860.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hjhCIWGgLzOznTFwDyeIeA.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">演示应用——作者图片</p></figure><p id="ff2c" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">当蒂姆·伯纳斯·李第一次发明网络时，网页只是文本。当像 Mosaic 这样的第一个图形浏览器出现时，网页也有了图片。</p><p id="a286" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">后来，它们变成了应用程序，服务器端程序提供数据来构建网页。这通常需要在 HTML 中用 PHP、Java 或 Visual Basic 编写代码，服务器执行这些代码来构造页面。</p><p id="7b36" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">结果往往是一顿真正的狗餐——分散在整个 HTML 中的代码并不清晰，因为它是支离破碎的，最重要的是，它还模糊了页面布局。</p><p id="c167" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">那些深入思考这些事情的人建议，我们应该将应用程序的逻辑与它的呈现方式分开。一个想法是模型、视图、控制器方法(MVC)。这里的模型是应用程序逻辑，通常是服务器上的一些数据和程序代码；视图是网页在浏览器中的外观，HTML 和 CSS 控制器是将模型连接到视图的代码，从 web 页面获取用户输入，将其提供给模型，并将结果返回到视图中显示。</p><p id="05ed" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">如果这听起来很复杂…嗯，我能说什么呢-是的，有点复杂。</p><p id="04ac" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">复杂是因为尽管 MVC 的想法足够简单，但是所需的技术和技巧意味着需要一大堆技能。对于视图，HTML 和 CSS 对于模型，像 Python、Java 或 C#这样的语言(可能还有一些 SQL)；对于控制器来说，可能是 Javascript，HTTP 的知识，现在还有 Ajax。</p><p id="8fc3" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">也许你从来没有听说过 MVC，但是许多 web 应用程序框架都是基于这个想法的。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi md"><img src="../Images/528a41aa7540fc8df099da319dfe9703.png" data-original-src="https://miro.medium.com/v2/resize:fit:1220/format:webp/1*8SaVHM_j8Y4L01hCS7jo6g.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">MVC——图片由注册公司提供，公共领域，通过维基共享</p></figure><p id="76a4" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">因此，Streamlit 将代码和布局混合在一个实体中，这是倒退。但是，虽然这是真的，但它也试图让生活变得更容易，因为我上面提到的所有技术都不再是必要的——您需要的只是 Python 和 Streamlit 库。</p><p id="bd8d" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">那么，我们如何获得简单 Pythonic 方法的好处，而不陷入混合应用程序逻辑和页面设计的复杂性呢？</p><p id="4feb" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">解决方案是牢记 MVC 方法，将程序逻辑从它的表现方式中分离出来。</p><p id="ae6c" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">Python 和 Streamlit 都可以帮助我们。</p><p id="634a" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们可以使用 Python 类和函数模块化应用程序，将视图从模型中分离出来，并且我们可以使用 Streamlit 函数构建视图。(Streamlit 最近增加了一个不错的功能:你可以将<code class="fe me mf mg mh b">with </code>语句用于像<code class="fe me mf mg mh b">st.container</code>或<code class="fe me mf mg mh b">st.columns</code>这样的容器对象，这允许你显示页面的结构。)</p><p id="e2d9" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">MVC 的控制器部分由 Streamlit 负责，并被合并到视图中。</p><p id="fcf9" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">让我告诉你我的意思。</p><h2 id="a6d0" class="mi mj it bd mk ml mm dn mn mo mp dp mq lq mr ms mt lu mu mv mw ly mx my mz iz bi translated">一个简单的模板</h2><p id="c64b" class="pw-post-body-paragraph lh li it lj b lk na kd lm ln nb kg lp lq nc ls lt lu nd lw lx ly ne ma mb mc im bi translated">这是一个简单的模板，我们可以用它在 Streamlit 中构建一个 MVC 风格的应用程序。</p><pre class="ks kt ku kv gt nf mh ng nh aw ni bi"><span id="3726" class="mi mj it mh b gy nj nk l nl nm">##############################################<br/># A simple model/view template for Streamlit #<br/>##############################################</span><span id="1371" class="mi mj it mh b gy nn nk l nl nm">import streamlit as st</span><span id="8ba1" class="mi mj it mh b gy nn nk l nl nm">################ Model ################<br/>class Model:<br/>   caption = "This is some text"</span><span id="161c" class="mi mj it mh b gy nn nk l nl nm">################ View  ################<br/>def view(model):<br/>   st.write(model.caption)</span><span id="f912" class="mi mj it mh b gy nn nk l nl nm">################ Start  ################<br/>view(Model())</span></pre><p id="3996" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">如你所见，这里有四个部分:导入，一个名为<code class="fe me mf mg mh b">Model</code>的类，一个名为<code class="fe me mf mg mh b">view </code>的函数，最后一行调用带有参数<code class="fe me mf mg mh b">Model </code>实例的<code class="fe me mf mg mh b">view </code>函数。</p><p id="c539" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这再简单不过了。<code class="fe me mf mg mh b">Model </code>类只有一个属性<code class="fe me mf mg mh b">caption</code>,<code class="fe me mf mg mh b">view </code>函数用它来写屏幕。</p><p id="d699" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">为了清楚起见，最后一行相当于创建一个类型为<code class="fe me mf mg mh b">Model</code>的对象，并将其传递给<code class="fe me mf mg mh b">view</code>函数。大概是这样的:</p><pre class="ks kt ku kv gt nf mh ng nh aw ni bi"><span id="7ff9" class="mi mj it mh b gy nj nk l nl nm">m = Model()<br/>view(m)</span></pre><h2 id="ef73" class="mi mj it bd mk ml mm dn mn mo mp dp mq lq mr ms mt lu mu mv mw ly mx my mz iz bi translated">真正的应用程序</h2><p id="a65b" class="pw-post-body-paragraph lh li it lj b lk na kd lm ln nb kg lp lq nc ls lt lu nd lw lx ly ne ma mb mc im bi translated">现在，让我们假设我们想要设计一个简单的应用程序，看起来像本文顶部的图像。这已经成为人均国内生产总值与预期寿命之间关系的经典例证，并基于 Gapminder 已故汉斯·罗斯林的工作(如果你不知道 Gapminder 或汉斯·罗斯林，一定要关注<a class="ae no" href="https://www.gapminder.org/" rel="noopener ugc nofollow" target="_blank">链接</a>)。</p><p id="ee92" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">应用程序的布局如下所示:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi np"><img src="../Images/479aa69d57520b6a0cfff519fc5ebcc8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yUe105nhHLIgQvZ8i4mFGQ.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">应用程序布局—按作者分类的图片</p></figure><p id="4535" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这是我们视图的基础:一个标题，下面是两列；右边的列包含我们想要显示的图表；左边一栏包含一些描述页面的文本，下面是一个滑块，允许用户选择要在图表上显示的年份。</p><p id="510c" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">下面是 Streamlit 视图的伪代码</p><pre class="ks kt ku kv gt nf mh ng nh aw ni bi"><span id="e1e6" class="mi mj it mh b gy nj nk l nl nm"># Header<br/>st.header(<em class="nq">caption</em>)</span><span id="69ee" class="mi mj it mh b gy nn nk l nl nm"># Two columns: <br/>#  <strong class="mh jd"> </strong>1. Commentary and slider<br/>#   2. Main chart<br/>commentaryCol, chartCol = st.columns(<em class="nq">dimensions</em>)</span><span id="d2bf" class="mi mj it mh b gy nn nk l nl nm">with commentaryCol:<br/>   # Show commentary text<br/>   # Show year Slider<br/>with chartCol:<br/>   # Display Main Chart</span></pre><p id="cfc8" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">你可以看到，我希望代码能够反映布局图——我们只需要填写详细的代码。</p><p id="6c40" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在此之前，我们还需要考虑视图需要什么数据。这是四件事:标题的标题，评论文本，滑块需要的参数，最后是要显示的图表。该数据将由模型提供。</p><p id="c7d1" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">让我们开始看代码。</p><h2 id="d90d" class="mi mj it bd mk ml mm dn mn mo mp dp mq lq mr ms mt lu mu mv mw ly mx my mz iz bi translated">进口</h2><p id="31df" class="pw-post-body-paragraph lh li it lj b lk na kd lm ln nb kg lp lq nc ls lt lu nd lw lx ly ne ma mb mc im bi translated">进口情况如下:</p><pre class="ks kt ku kv gt nf mh ng nh aw ni bi"><span id="7b48" class="mi mj it mh b gy nj nk l nl nm">import streamlit as st<br/>import pandas as pd<br/>import plotly.express as px</span></pre><p id="ff5d" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们需要 Streamlit(当然)，Pandas 来保存 Gapminder 数据，并 Plotly 来绘制图表。</p><p id="51d6" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">模型应该出现在程序文件的下一个位置，但是我们现在要把它放在这里，看看我们是如何开发视图的。</p><h2 id="5e83" class="mi mj it bd mk ml mm dn mn mo mp dp mq lq mr ms mt lu mu mv mw ly mx my mz iz bi translated">景色</h2><p id="8209" class="pw-post-body-paragraph lh li it lj b lk na kd lm ln nb kg lp lq nc ls lt lu nd lw lx ly ne ma mb mc im bi translated">视图是一个名为<code class="fe me mf mg mh b">view</code>的函数，它包含创建网页的所有 Streamlit 代码。我们将模型的一个实例传递给它，Streamlit 需要的所有数据都将来自那里。例如，标题标题保存在模型中一个名为<code class="fe me mf mg mh b">header</code>的属性中，因此编写标题的 Streamlit 代码将是<code class="fe me mf mg mh b">st.header(model.header)</code>。</p><p id="77ed" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这是完整的代码，是我们之前看到的伪代码的发展。</p><pre class="ks kt ku kv gt nf mh ng nh aw ni bi"><span id="0302" class="mi mj it mh b gy nj nk l nl nm">################ View  ################<br/>def view(model):<br/>   st.set_page_config(layout = 'wide')</span><span id="d178" class="mi mj it mh b gy nn nk l nl nm">   # Header<br/>   st.header(model.header)<br/>   <br/>   commentaryCol, spaceCol, chartCol=st.columns((2,1,6))</span><span id="187c" class="mi mj it mh b gy nn nk l nl nm">   # Description<br/>   with commentaryCol:<br/>      st.write(model.description)</span><span id="d255" class="mi mj it mh b gy nn nk l nl nm">   # Year Slider  <br/>   year=st.slider(model.sliderCaption,<br/>      model.yearStart, model.yearEnd,<br/>      model.yearStart, model.yearStep)</span><span id="0971" class="mi mj it mh b gy nn nk l nl nm">   #Chart<br/>   with chartCol:<br/>      st.plotly_chart(model.chart(year), <br/>         use_container_width = True)</span></pre><p id="6d47" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">注意，我使用了<code class="fe me mf mg mh b">with</code>语句来显示下面的代码是针对哪个 UI 元素的。这是最近发布的 Streamlit 库的一个很好的改进，使代码更容易阅读。</p><p id="8a0c" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">代码中的第一件事是将页面布局设置为<em class="nq">宽</em>。这不是必要的，但我认为最终结果看起来更好。</p><p id="0bd2" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">接下来是主要内容:</p><ul class=""><li id="7472" class="nr ns it lj b lk ll ln lo lq nt lu nu ly nv mc nw nx ny nz bi translated">页眉:这只是在页面顶部显示<code class="fe me mf mg mh b">model.header</code></li><li id="af7b" class="nr ns it lj b lk oa ln ob lq oc lu od ly oe mc nw nx ny nz bi translated">一组列:有三列，右边的一列保存图表，左边的一列保存描述和滑块，中间的一列在另外两列之间留出一点空间。</li><li id="2083" class="nr ns it lj b lk oa ln ob lq oc lu od ly oe mc nw nx ny nz bi translated">描述进入<code class="fe me mf mg mh b">commentaryCol</code>并写出<code class="fe me mf mg mh b">model.description</code></li><li id="f3f3" class="nr ns it lj b lk oa ln ob lq oc lu od ly oe mc nw nx ny nz bi translated">我们将用来选择年份的滑块也放在描述下方的<code class="fe me mf mg mh b">commentaryCol</code>中。滑块需要 5 个参数，一个标题，起点和终点，初始值和一个步长。这些由代码中所示的<code class="fe me mf mg mh b">model</code>属性提供。</li><li id="0104" class="nr ns it lj b lk oa ln ob lq oc lu od ly oe mc nw nx ny nz bi translated">图表放在<code class="fe me mf mg mh b">chartCol</code>中，是对<code class="fe me mf mg mh b">st.plotly_chart</code>的调用。要显示的实际图表是从名为<code class="fe me mf mg mh b">chart</code>的<code class="fe me mf mg mh b">model</code>中的方法返回的。该方法需要将年份作为参数传递。</li></ul><p id="d473" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">最终的代码和我们之前看到的一样:它调用了<code class="fe me mf mg mh b">view</code>，并将<code class="fe me mf mg mh b">Model</code>的实例化作为参数。</p><pre class="ks kt ku kv gt nf mh ng nh aw ni bi"><span id="aab9" class="mi mj it mh b gy nj nk l nl nm">################ Start  ################<br/>view(Model())</span></pre><h2 id="1d39" class="mi mj it bd mk ml mm dn mn mo mp dp mq lq mr ms mt lu mu mv mw ly mx my mz iz bi translated">模型</h2><p id="3fc0" class="pw-post-body-paragraph lh li it lj b lk na kd lm ln nb kg lp lq nc ls lt lu nd lw lx ly ne ma mb mc im bi translated">在模型中，我们需要提供视图需要的所有数据。大部分工作是在构造函数方法<code class="fe me mf mg mh b">__init__</code>中完成的。当从<code class="fe me mf mg mh b">Model</code>创建一个对象时，调用该方法。首先要做的是将 Gapminder 数据加载到 Pandas 数据框架中——Gapminder 数据包含在 Plotly 库中，因此我们正在使用它；在真正的应用程序中，这些数据可能是从数据库或 API 中加载的。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi of"><img src="../Images/74e1ac1ef6a19bd492d71fb592718ba2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EwvNYL6XiLDrKkR-W8JHag.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">作者的 Gapminder 数据图片片段</p></figure><p id="dcfe" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">从 Gapminder 数据中，我们设置了许多属性，一个独特年份的列表(我们将其从原始的 Numpy 类型转换为 Streamlit 似乎更喜欢的普通旧 Python <code class="fe me mf mg mh b">int</code>)。</p><p id="bfad" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">然后，我们设置滑块将使用的开始、结束和步长值。</p><p id="347e" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">接下来是<code class="fe me mf mg mh b">chart</code>方法，它可以绘制一个散点图。</p><p id="596a" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">最后，我们为视图将使用的各种字符串设置属性。</p><pre class="ks kt ku kv gt nf mh ng nh aw ni bi"><span id="f968" class="mi mj it mh b gy nj nk l nl nm">################ Model ################<br/>class Model:<br/>   def __init__(self):<br/>      self.df = pd.DataFrame(px.data.gapminder())<br/>      self.ylist = [int(i) for i in self.df['year'].unique()]<br/>      self.yearStart = self.ylist[0]<br/>      self.yearEnd = self.ylist[-1]<br/>      self.yearStep = self.ylist[1]-self.ylist[0]</span><span id="b30a" class="mi mj it mh b gy nn nk l nl nm">   def chart(self,year):<br/>      return px.scatter(self.df[self.df['year'] == year],<br/>         x = 'lifeExp', y = 'gdpPercap', <br/>         title = f'Year: {year}',<br/>         color='continent',size='pop')</span><span id="d7c4" class="mi mj it mh b gy nn nk l nl nm">   header = 'Global Statistics from Gapminder'</span><span id="95a0" class="mi mj it mh b gy nn nk l nl nm">   description ='''<br/>      See how life expectancy changes over time <br/>      and in relation to GDP.<br/>      Move the slider to change the year to display.<br/>   '''</span><span id="ec6d" class="mi mj it mh b gy nn nk l nl nm">   sliderCaption='Select the year for the chart'</span></pre><p id="423f" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">如果您现在将这些代码部分按照正确的顺序放在一起，您将拥有一个完整的 Streamlit 应用程序。</p><h2 id="6dea" class="mi mj it bd mk ml mm dn mn mo mp dp mq lq mr ms mt lu mu mv mw ly mx my mz iz bi translated">我们得到了什么</h2><p id="767c" class="pw-post-body-paragraph lh li it lj b lk na kd lm ln nb kg lp lq nc ls lt lu nd lw lx ly ne ma mb mc im bi translated">我们现在有了一个具有独立视图和模型的应用程序。如果我们想改变应用程序的外观，那么根本不需要修改模型代码，只需要修改<code class="fe me mf mg mh b">view</code>功能。</p><p id="319b" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这使得更新和维护代码更容易，也使得代码更容易阅读和理解。如果出于某种原因，我们决定从其他地方获取数据，那么需要改变的只是模型代码，而不是视图。</p><p id="13c0" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这是一个相当小的例子，但是我希望你能看到这个 rational 方法将扩展到更复杂的应用程序，并使它们更容易编写和维护。</p><p id="2068" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">对于我给出的例子，我有一个疑问:滑块需要的值应该在视图中计算，还是应该放在哪里？在模型里？我这样做是为了一个更清晰的视图，但有一个论点是，这些值只是因为我们使用滑块的方式而计算的，所以在那里推导它们可能更合适。</p><p id="4736" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我很高兴听到你对这种方法的看法，所以请在下面随意评论。</p></div><div class="ab cl og oh hx oi" role="separator"><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol"/></div><div class="im in io ip iq"><p id="6d0c" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">一如既往地感谢阅读，如果你想知道我什么时候发表新文章，请考虑在这里注册一个电子邮件提醒<a class="ae no" href="https://alan-jones.medium.com/subscribe" rel="noopener">。</a></p><p id="f9b8" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这篇文章的代码很容易从这里剪切和粘贴，但也可以在我的<a class="ae no" href="https://alanjones2.github.io/Alan-Jones-article-code/" rel="noopener ugc nofollow" target="_blank"> GitHub 页面</a>上找到。这里还有一个演示页面<a class="ae no" href="http://ajstreamlit.herokuapp.com/" rel="noopener ugc nofollow" target="_blank"/>——从下拉菜单中选择<em class="nq"> Rational UI 设计</em>。</p><p id="5cc0" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">如果你不是一个媒体订阅者，那就注册吧，这样你就可以每月花 5 美元阅读尽可能多的文章。在这里注册<a class="ae no" href="https://alan-jones.medium.com/membership" rel="noopener"/>我会赚一小笔佣金。</p><div class="on oo gp gr op oq"><a href="https://alanjones2.github.io" rel="noopener  ugc nofollow" target="_blank"><div class="or ab fo"><div class="os ab ot cl cj ou"><h2 class="bd jd gy z fp ov fr fs ow fu fw jc bi translated">AlanJones:编码、科学和技术</h2><div class="ox l"><h3 class="bd b gy z fp ov fr fs ow fu fw dk translated">我为数据可视化和类似的主题撰写文章、实践教程和应用程序——大部分是用 Python 写的(参见一些……</h3></div><div class="oy l"><p class="bd b dl z fp ov fr fs ow fu fw dk translated">alanjones2.github.io</p></div></div><div class="oz l"><div class="pa l pb pc pd oz pe lb oq"/></div></div></a></div></div></div>    
</body>
</html>