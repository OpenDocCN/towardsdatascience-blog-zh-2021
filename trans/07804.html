<html>
<head>
<title>Using Workflow Sets to Screen and Compare Model-Recipe Combinations for Bank Loan Classification</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用工作流集筛选和比较银行贷款分类的模型-方法组合</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/using-workflow-sets-to-screen-and-compare-model-recipe-combinations-for-bank-loan-classification-fcaad2853290?source=collection_archive---------14-----------------------#2021-07-17">https://towardsdatascience.com/using-workflow-sets-to-screen-and-compare-model-recipe-combinations-for-bank-loan-classification-fcaad2853290?source=collection_archive---------14-----------------------#2021-07-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="525c" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">为具有潮汐模型的分类问题筛选一系列模型类型和特征工程步骤</h2></div><p id="3c8c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">假设您是一家大型银行的数据科学家，您的CDO指示您开发一种自动化银行贷款决策的方法。您决定这应该是一个二元分类器，并继续收集数百个数据点。但是你应该从什么样的模型开始，你应该完成什么样的特征工程？为什么不筛选多个组合？</p><p id="9538" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该项目将使用贷款预测数据集来举例说明Tidymodels机器学习生态系统中workflow_sets()的使用。筛选一系列模型和特征工程管道对于避免对特定模型类型的任何内部偏见或“没有免费的午餐”定理非常重要。如果你有兴趣在阅读之前了解更多关于Tidymodels生态系统的信息，请查看我的<a class="ae lb" rel="noopener" target="_blank" href="/big-sales-mart-regression-revisited-enter-the-tidymodels-a6a432be58d4">前一篇文章</a>。</p><p id="49f0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">贷款预测数据摘自<a class="ae lb" href="https://datahack.analyticsvidhya.com/contest/practice-problem-loan-prediction-iii/" rel="noopener ugc nofollow" target="_blank">https://Data hack . analyticsvidhya . com/contest/practice-problem-loan-Prediction-iii/</a>。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi lc"><img src="../Images/7511384b843b4d943d849952470d2643.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*AMSJ6Ok1HOoVAy4b"/></div></div><p class="lo lp gj gh gi lq lr bd b be z dk translated">图片由<a class="ae lb" href="https://unsplash.com/@ssilver_?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Iro Klg </a>在<a class="ae lb" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><p id="1fd0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">加载包和数据</strong></p><pre class="ld le lf lg gt lz ma mb mc aw md bi"><span id="5ed6" class="me mf iq ma b gy mg mh l mi mj">library(tidymodels) <strong class="ma ir">#ML meta packages</strong><br/>library(themis) <strong class="ma ir">#Recipe functions to deal with class imbalances</strong><br/>library(discrim) <strong class="ma ir">#Naive Bayes Models</strong><br/>library(tidyposterior) <strong class="ma ir">#Bayesian Performance Comparison</strong><br/>library(corrr) <strong class="ma ir">#Correlation Viz</strong><br/>library(readr) <strong class="ma ir">#Read Tabular Data</strong><br/>library(magrittr) <strong class="ma ir">#Pipe Operators</strong><br/>library(stringr) <strong class="ma ir">#Work with Strings</strong><br/>library(forcats) <strong class="ma ir">#Work with Factors</strong><br/>library(skimr) <strong class="ma ir">#Data Summary</strong><br/>library(patchwork) <strong class="ma ir">#ggplot grids</strong><br/>library(GGally) <strong class="ma ir">#Scatterplot Matrices</strong></span><span id="4834" class="me mf iq ma b gy mk mh l mi mj">train &lt;- read_csv("train_ctrUa4K.csv")</span><span id="4dba" class="me mf iq ma b gy mk mh l mi mj">train %&lt;&gt;% rename(Applicant_Income = ApplicantIncome,<br/>                  CoApplicant_Income = CoapplicantIncome,<br/>                  Loan_Amount = LoanAmount) <br/></span></pre><p id="53eb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">探索性数据分析</strong></p><p id="20f5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们开始筛选模型之前，用一些基本的探索性数据分析来完成我们的尽职调查。</p><p id="83bb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们使用skimr包来产生下面的输出</p><pre class="ld le lf lg gt lz ma mb mc aw md bi"><span id="f20f" class="me mf iq ma b gy mg mh l mi mj">skim(train)</span></pre><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi ml"><img src="../Images/0b44cb8ef66017b3d8be8de65e46b49e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KtSLol2flMVoiI413DEt8Q.png"/></div></div><p class="lo lp gj gh gi lq lr bd b be z dk translated">skimr的输出(图片由作者提供)</p></figure><p id="f355" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们可以使用以下函数通过适当的可视化来可视化这些结果。</p><pre class="ld le lf lg gt lz ma mb mc aw md bi"><span id="5fe1" class="me mf iq ma b gy mg mh l mi mj"><strong class="ma ir">#Automated Exploratory Data Analysis</strong><br/>viz_by_dtype &lt;- function (x,y) {<br/>  title &lt;- str_replace_all(y,"_"," ") %&gt;% <br/>           str_to_title()<br/>  if ("factor" %in% class(x)) {<br/>    ggplot(train, aes(x, fill = x)) +<br/>      geom_bar() +<br/>      theme(legend.position = "none",<br/>            axis.text.x = element_text(angle = 45, hjust = 1),<br/>            axis.text = element_text(size = 8)) +<br/>      theme_minimal() +<br/>      scale_fill_viridis_c()+<br/>      labs(title = title, y = "", x = "")<br/>  }<br/>  else if ("numeric" %in% class(x)) {<br/>    ggplot(train, aes(x)) +<br/>      geom_histogram()  +<br/>      theme_minimal() +<br/>      scale_fill_viridis_c()+<br/>      labs(title = title, y = "", x = "")<br/>  } <br/>  else if ("integer" %in% class(x)) {<br/>    ggplot(train, aes(x)) +<br/>      geom_histogram() +<br/>      theme_minimal() +<br/>      scale_fill_viridis_c()+<br/>      labs(title = title, y = "", x = "")<br/>  }<br/>  else if ("character" %in% class(x)) {<br/>    ggplot(train, aes(x, fill = x)) +<br/>      geom_bar() +<br/>      theme_minimal() +<br/>      scale_fill_viridis_d()+<br/>      theme(legend.position = "none",<br/>            axis.text.x = element_text(angle = 45, hjust = 1),<br/>            axis.text = element_text(size = 8)) +<br/>      labs(title = title, y  ="", x= "")<br/>  }<br/>}</span><span id="8d89" class="me mf iq ma b gy mk mh l mi mj">variable_plot &lt;- map2(train, colnames(train), viz_by_dtype) %&gt;%<br/>  wrap_plots(ncol = 3,<br/>             nrow = 5)</span></pre><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi mm"><img src="../Images/c8166160d0fd0ba0b1fc9bb27eea29a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PNtqn_vB5QF22YVS-RN4pA.png"/></div></div><p class="lo lp gj gh gi lq lr bd b be z dk translated">贷款数据集的可视化EDA(图片由作者提供)</p></figure><ul class=""><li id="05ad" class="mn mo iq kh b ki kj kl km ko mp ks mq kw mr la ms mt mu mv bi translated">性别失衡，男性申请人比例高，有新来港定居人士</li><li id="0879" class="mn mo iq kh b ki mw kl mx ko my ks mz kw na la ms mt mu mv bi translated">婚姻状况，几乎3:2的已婚申请者对未婚者，有NAs在场</li><li id="c203" class="mn mo iq kh b ki mw kl mx ko my ks mz kw na la ms mt mu mv bi translated">大多数申请人没有孩子</li><li id="0fc5" class="mn mo iq kh b ki mw kl mx ko my ks mz kw na la ms mt mu mv bi translated">大多数申请人是大学毕业生</li><li id="36d5" class="mn mo iq kh b ki mw kl mx ko my ks mz kw na la ms mt mu mv bi translated">大多数人不是自营职业者</li><li id="5484" class="mn mo iq kh b ki mw kl mx ko my ks mz kw na la ms mt mu mv bi translated">申请人收入向右倾斜</li><li id="aa1b" class="mn mo iq kh b ki mw kl mx ko my ks mz kw na la ms mt mu mv bi translated">共同申请人的收入向右倾斜</li><li id="26fd" class="mn mo iq kh b ki mw kl mx ko my ks mz kw na la ms mt mu mv bi translated">贷款金额向右倾斜</li><li id="0469" class="mn mo iq kh b ki mw kl mx ko my ks mz kw na la ms mt mu mv bi translated">贷款额度期限一般为360天</li><li id="9ac4" class="mn mo iq kh b ki mw kl mx ko my ks mz kw na la ms mt mu mv bi translated">大部分申请人都有信用记录，包括NAs</li><li id="27b6" class="mn mo iq kh b ki mw kl mx ko my ks mz kw na la ms mt mu mv bi translated">混合物业区域类型</li><li id="3a6b" class="mn mo iq kh b ki mw kl mx ko my ks mz kw na la ms mt mu mv bi translated">大多数申请都获得批准，目标可变贷款状态不平衡，比例为3:2</li></ul><p id="9c81" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">双变量数据分析</strong></p><p id="13f7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">数量变量</strong></p><p id="4a22" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用GGally::ggpairs()，我们为所有数字变量生成一个变量矩阵图，并用Loan_Status着色。</p><pre class="ld le lf lg gt lz ma mb mc aw md bi"><span id="3b91" class="me mf iq ma b gy mg mh l mi mj"><strong class="ma ir">#Correlation Matrix Plot</strong><br/>ggpairs(train %&gt;% select(7:10,13), ggplot2::aes(color = Loan_Status, alpha = 0.3)) + <br/>  theme_minimal() + <br/>  scale_fill_viridis_d(aesthetics = c("color", "fill"), begin = 0.15, end = 0.85) +<br/>  labs(title = "Numeric Bivariate Analysis of Loan Data")</span></pre><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi nb"><img src="../Images/41b06700af1561402fc69e78a20476c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*74E6utGK8RGdh85-ZwGpRw.png"/></div></div><p class="lo lp gj gh gi lq lr bd b be z dk translated">数值预测和贷款状况的双变量分析(图片由作者提供)</p></figure><p id="1c59" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">定性变量</strong></p><p id="3798" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用如下生成的汇总数据帧，改变所需的字符变量，迭代生成以下可视化。</p><pre class="ld le lf lg gt lz ma mb mc aw md bi"><span id="f7e2" class="me mf iq ma b gy mg mh l mi mj"><strong class="ma ir">#Generate Summary Variables for Qualitative Variables</strong><br/>summary_train &lt;- <br/>  train %&gt;% <br/>  select(where(is.character),<br/>         -Loan_ID) %&gt;% <br/>  drop_na() %&gt;% <br/>  mutate(Loan_Status = if_else(Loan_Status == "Y",1,0)) %&gt;% <br/>  pivot_longer(1:6, names_to = "Variables", values_to = "Values") %&gt;% <br/>  group_by(Variables, Values) %&gt;% <br/>    summarise(mean = mean(Loan_Status),<br/>              conf_int = 1.96*sd(Loan_Status)/sqrt(n())) %&gt;% <br/>  pivot_wider(names_from = Variables, values_from = Values)</span><span id="b1cd" class="me mf iq ma b gy mk mh l mi mj">summary_train %&gt;% select(Married, mean, conf_int) %&gt;% <br/>  drop_na() %&gt;% <br/>  ggplot(aes(x=Married, y = mean, color = Married)) +<br/>  geom_point() +<br/>  geom_errorbar(aes(ymin = mean - conf_int, ymax = mean + conf_int), width = 0.1) +<br/>  theme_minimal() +<br/>  theme(legend.position = "none",<br/>        axis.title.x = element_blank(),<br/>        axis.title.y = element_blank()) +<br/>  scale_colour_viridis_d(aesthetics = c("color", "fill"), begin = 0.15, end = 0.85) +<br/>  labs(title="Married")</span></pre><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi nc"><img src="../Images/9c7e58df16edd78eb4bfb043801f407a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wCdiFE9SufxbJcTbikYCRw.png"/></div></div><p class="lo lp gj gh gi lq lr bd b be z dk translated">95%置信区间下每个分类变量的成功贷款申请比例(图片由作者提供)</p></figure><p id="4d41" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">完成上述可视化的好处是，它给出了贷款申请成功的差异大小以及不确定性的理解，通过每个分类变量的95%置信区间可视化。由此我们注意到以下几点:</p><ul class=""><li id="f4f8" class="mn mo iq kh b ki kj kl km ko mp ks mq kw mr la ms mt mu mv bi translated">已婚申请人的申请被批准的可能性更大。</li><li id="cf00" class="mn mo iq kh b ki mw kl mx ko my ks mz kw na la ms mt mu mv bi translated">研究生申请者成功的机会更大，可能是因为收入更稳定/更高。</li><li id="2f6a" class="mn mo iq kh b ki mw kl mx ko my ks mz kw na la ms mt mu mv bi translated">类似地，为自己工作的申请人的成功差异也大得多，可能是因为收入稳定性的差异</li><li id="14f7" class="mn mo iq kh b ki mw kl mx ko my ks mz kw na la ms mt mu mv bi translated">孩子的数量似乎对贷款状况没有太大影响</li><li id="ea80" class="mn mo iq kh b ki mw kl mx ko my ks mz kw na la ms mt mu mv bi translated">女性客户在申请成功上有更大的可变性，男性客户则更加离散。我们需要小心这一点，以免在算法中产生根深蒂固的偏见。</li><li id="b038" class="mn mo iq kh b ki mw kl mx ko my ks mz kw na la ms mt mu mv bi translated">半城市或郊区的成功率最高。</li><li id="e82b" class="mn mo iq kh b ki mw kl mx ko my ks mz kw na la ms mt mu mv bi translated">最后，有信用记录的客户和没有信用记录的客户在成功率上有显著差异。</li></ul><p id="688e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们愿意，我们可以用方差分析/卡方检验进一步探索这些关系。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><p id="9924" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">数据拆分— rsamples </strong></p><p id="8c5d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将数据按照Loan_Status进行了80:20的分层。可以通过调用mc_split对象上的training()或testing()来访问每个拆分表。</p><pre class="ld le lf lg gt lz ma mb mc aw md bi"><span id="1138" class="me mf iq ma b gy mg mh l mi mj"><strong class="ma ir">#Split Data for Testing and Training</strong><br/>set.seed(101)<br/>loan_split &lt;- initial_split(train, prop = 0.8, strata = Loan_Status)</span></pre><p id="2ddc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">模型开发——防风草。</strong></p><p id="7928" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如上所述，我们希望筛选一系列模型，并锁定几个合适的候选模型。下面我们已经初始化了一系列的标准分类模型。</p><pre class="ld le lf lg gt lz ma mb mc aw md bi"><span id="112b" class="me mf iq ma b gy mg mh l mi mj"><strong class="ma ir">#Initialise Seven Models for Screening</strong><br/>nb_loan &lt;- <br/>  naive_Bayes(smoothness = tune(), Laplace = tune()) %&gt;% <br/>  set_engine("klaR") %&gt;% <br/>  set_mode("classification")</span><span id="f8a1" class="me mf iq ma b gy mk mh l mi mj">logistic_loan &lt;- <br/>  logistic_reg(penalty = tune(), mixture = tune()) %&gt;% <br/>  set_engine("glmnet") %&gt;% <br/>  set_mode("classification")</span><span id="72d7" class="me mf iq ma b gy mk mh l mi mj">dt_loan &lt;- decision_tree(cost_complexity = tune(), tree_depth = tune(), min_n = tune()) %&gt;% <br/>  set_engine("rpart") %&gt;% <br/>  set_mode("classification")</span><span id="2874" class="me mf iq ma b gy mk mh l mi mj">rf_loan &lt;- <br/>  rand_forest(mtry = tune(), trees = tune(), min_n = tune()) %&gt;% <br/>  set_engine("ranger") %&gt;% <br/>  set_mode("classification")</span><span id="400f" class="me mf iq ma b gy mk mh l mi mj">knn_loan &lt;- nearest_neighbor(neighbors = tune(), weight_func = tune(), dist_power = tune()) %&gt;% <br/>  set_engine("kknn") %&gt;% <br/>  set_mode("classification")</span><span id="a81a" class="me mf iq ma b gy mk mh l mi mj">svm_loan &lt;- <br/>  svm_rbf(cost = tune(), rbf_sigma = tune(), margin = tune()) %&gt;% <br/>  set_engine("kernlab") %&gt;% <br/>  set_mode("classification")</span><span id="e929" class="me mf iq ma b gy mk mh l mi mj">xgboost_loan &lt;- boost_tree(mtry = tune(), trees = tune(), min_n = tune(), tree_depth = tune(), learn_rate = tune(), loss_reduction = tune(), sample_size = tune())  %&gt;% <br/>  set_engine("xgboost") %&gt;% <br/>  set_mode("classification")</span></pre><p id="75ab" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">特征工程—配方</strong></p><p id="ce8a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">以下是一系列配方配置。这两种不同的插补方法如何相互比较，在下面的注释中，我们使用了impute_mean(代表数字)、impute_mode(代表字符)或使用impute_bag(使用袋装树的插补),可以对数字和字符变量进行插补。</p><p id="27e7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意，对于Credit_History，我们选择不估算这个值，而是将三个结果分配给一个整数值，将未知实例设置为0。</p><p id="2231" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">由于Loan_Status不平衡，我们对配方2和4应用了SMOTE(合成少数过采样技术)。我们将完成工作流程比较，以了解插补策略之间的准确性差异。</p><pre class="ld le lf lg gt lz ma mb mc aw md bi"><span id="d7eb" class="me mf iq ma b gy mg mh l mi mj"><strong class="ma ir">#Initialise Four Recipes</strong><br/>recipe_1 &lt;- <br/>  recipe(Loan_Status ~., data = training(loan_split)) %&gt;% <br/>  step_rm(Loan_ID) %&gt;%<br/>  step_mutate(Credit_History = if_else(Credit_History == 1, 1, -1,0)) %&gt;% <br/>  step_scale(all_numeric_predictors(), -Credit_History) %&gt;% <br/>  step_impute_bag(Gender, <br/>                  Married, <br/>                  Dependents, <br/>                  Self_Employed, <br/>                  Loan_Amount, <br/>                  Loan_Amount_Term) %&gt;% <br/>  step_dummy(all_nominal_predictors())</span><span id="0759" class="me mf iq ma b gy mk mh l mi mj">recipe_2 &lt;- <br/>  recipe(Loan_Status ~., data = training(loan_split)) %&gt;% <br/>  step_rm(Loan_ID) %&gt;%<br/>  step_mutate(Credit_History = if_else(Credit_History == 1, 1, -1,0)) %&gt;% <br/>  step_scale(all_numeric_predictors(), -Credit_History) %&gt;% <br/>  step_impute_bag(Gender, <br/>                  Married, <br/>                  Dependents, <br/>                  Self_Employed, <br/>                  Loan_Amount, <br/>                  Loan_Amount_Term) %&gt;% <br/>  step_dummy(all_nominal_predictors()) %&gt;% <br/>  step_smote(Loan_Status)<br/>  <br/>recipe_3 &lt;- <br/>  recipe(Loan_Status ~., data = training(loan_split)) %&gt;% <br/>  step_rm(Loan_ID) %&gt;%<br/>  step_mutate(Credit_History = if_else(Credit_History == 1, 1, -1,0)) %&gt;%  <br/>  step_scale(all_numeric_predictors(), -Credit_History) %&gt;%  <br/>  step_impute_mean(all_numeric_predictors()) %&gt;%<br/>  step_impute_mode(all_nominal_predictors()) %&gt;% <br/>  step_dummy(all_nominal_predictors()) %&gt;% <br/>  step_zv(all_predictors())</span><span id="fdb0" class="me mf iq ma b gy mk mh l mi mj">recipe_4 &lt;- <br/>  recipe(Loan_Status ~., data = training(loan_split)) %&gt;% <br/>  step_rm(Loan_ID) %&gt;%<br/>  step_mutate(Credit_History = if_else(Credit_History == 1, 1, -1,0)) %&gt;% <br/>  step_scale(all_numeric_predictors(), -Credit_History) %&gt;%  <br/>  step_impute_mean(all_numeric_predictors()) %&gt;%<br/>  step_impute_mode(all_nominal_predictors()) %&gt;% <br/>  step_dummy(all_nominal_predictors()) %&gt;% <br/>  step_zv(all_predictors()) %&gt;% <br/>  step_smote(Loan_Status)</span></pre><p id="9f48" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">以recipe_1为例，我们可以为每个转换准备训练和测试数据集。</p><pre class="ld le lf lg gt lz ma mb mc aw md bi"><span id="0a0b" class="me mf iq ma b gy mg mh l mi mj"><strong class="ma ir">#Prep and Bake Training and Test Datasets</strong><br/>loan_train &lt;- recipe_1 %&gt;% prep() %&gt;% bake(new_data = NULL)<br/>loan_test &lt;- recipe_1 %&gt;% prep() %&gt;% bake(testing(loan_split))</span></pre><p id="11f0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后利用这些转换后的数据集，可视化变量相关性。</p><pre class="ld le lf lg gt lz ma mb mc aw md bi"><span id="2552" class="me mf iq ma b gy mg mh l mi mj"><strong class="ma ir">#Generate Correlation Visualisation</strong><br/>loan_train %&gt;% bind_rows(loan_test) %&gt;% <br/>  mutate(Loan_Status = if_else(Loan_Status == "Y",1,0)) %&gt;% <br/>              correlate() %&gt;%<br/>              rearrange() %&gt;% <br/>              shave() %&gt;% <br/>              rplot(print_cor = T,.order = "alphabet") +<br/>                theme_minimal() +<br/>                theme(axis.text.x = element_text(angle = 90)) +<br/>                scale_color_viridis_c() +<br/>                labs(title = "Correlation Plot for Trained Loan Dataset")</span></pre><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi nd"><img src="../Images/68eca0cfea6bbfc29d2e697708769fa7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yOmD4k1tUu8mz4_1U1_TzA.png"/></div></div><p class="lo lp gj gh gi lq lr bd b be z dk translated">已训练贷款数据集的相关图(图片由作者提供)</p></figure><p id="b16d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从上面我们注意到贷款状态和申请人是否有信用历史之间的密切关系。这是有道理的，银行更倾向于贷款给有信用记录的客户，证明客户有能力偿还贷款。</p><p id="092b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">迭代Parnsip和配方组合—工作流程集</strong></p><p id="4e09" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">工作流集合使我们能够筛选配方和parnsip模型规格的所有可能组合。如下，我们已经创建了两个命名列表，所有模型和配方。</p><pre class="ld le lf lg gt lz ma mb mc aw md bi"><span id="0dcc" class="me mf iq ma b gy mg mh l mi mj"><strong class="ma ir">#Generate List of Recipes</strong><br/>recipe_list &lt;- <br/>list(Recipe1 = recipe_1, Recipe2 = recipe_2, Recipe3 = recipe_3, Recipe4 = recipe_4)</span><span id="09c5" class="me mf iq ma b gy mk mh l mi mj"><strong class="ma ir">#Generate List of Model Types<br/></strong>model_list &lt;- <br/>list(Random_Forest = rf_loan, SVM = svm_loan, Naive_Bayes = nb_loan, Decision_Tree = dt_loan, Boosted_Trees = xgboost_loan, KNN = knn_loan, Logistic_Regression = logistic_loan)</span></pre><p id="1eb9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有趣的部分来了，使用workflow_sets()创建一系列工作流</p><pre class="ld le lf lg gt lz ma mb mc aw md bi"><span id="b6a4" class="me mf iq ma b gy mg mh l mi mj">model_set &lt;- workflow_set(preproc = recipe_list, models = model_list, cross = T)</span></pre><p id="b10b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">设置cross = T指示workflow_set创建parsnip模型和配方规格的所有可能组合。</p><pre class="ld le lf lg gt lz ma mb mc aw md bi"><span id="db24" class="me mf iq ma b gy mg mh l mi mj">set.seed(2)<br/>train_resamples &lt;- bootstraps(training(loan_split), strata = Loan_Status)</span><span id="94b2" class="me mf iq ma b gy mk mh l mi mj">doParallel::registerDoParallel(cores = 12)<br/>all_workflows &lt;- <br/>  model_set %&gt;% workflow_map(resamples = train_resamples, <br/>                             verbose = TRUE)</span></pre><p id="0a25" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们已经初始化了一个助推器重采样程序，这在计算上要求更高，但是总体误差更小。通过重采样过程将model_set对象传递给workflow_map，将启动一个所有防风草配方组合的屏幕，显示如下输出。这是一个要求很高的过程，因此我们启动了并行计算来简化这一过程。</p><p id="d76b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用重采样过程，workflow_map将使每个工作流符合训练数据，并计算每个重采样的精度，然后取平均值。此外，由于每个配方都指定应该调整超参数，workflow_map将执行一些调整以提供最佳结果。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/68f02923980a8f38e7f8192cd599cb74.png" data-original-src="https://miro.medium.com/v2/resize:fit:1098/format:webp/1*YRFDsAYbfhYM1NNlxHGCJw.png"/></div><p class="lo lp gj gh gi lq lr bd b be z dk translated">workflow_map的输出(图片由作者提供)</p></figure><p id="7bcb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">完成后，我们可以调用all_workflows对象，收集在此过程中计算的所有指标，并可视化结果。</p><p id="5252" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">名词（noun的缩写）b .对于workflow_set对象，有一个可用的autoplot()函数，但是我们希望能够比较配方和模型性能，因此必须重新设计以下可视化功能。</p><pre class="ld le lf lg gt lz ma mb mc aw md bi"><span id="b0a7" class="me mf iq ma b gy mg mh l mi mj"><strong class="ma ir">#Visualise Performance Comparison of Workflows</strong><br/>collect_metrics(all_workflows) %&gt;% <br/>  separate(wflow_id, into = c("Recipe", "Model_Type"), sep = "_", remove = F, extra = "merge") %&gt;% <br/>  filter(.metric == "accuracy") %&gt;% <br/>  group_by(wflow_id) %&gt;% <br/>  filter(mean == max(mean)) %&gt;% <br/>  group_by(model) %&gt;% <br/>  select(-.config) %&gt;% <br/>  distinct() %&gt;%<br/>  ungroup() %&gt;% <br/>  mutate(Workflow_Rank =  row_number(-mean),<br/>         .metric = str_to_upper(.metric)) %&gt;%<br/>  ggplot(aes(x=Workflow_Rank, y = mean, shape = Recipe, color = Model_Type)) +<br/>    geom_point() +<br/>    geom_errorbar(aes(ymin = mean-std_err, ymax = mean+std_err)) +<br/>    theme_minimal()+<br/>    scale_colour_viridis_d() +<br/>    labs(title = "Performance Comparison of Workflow Sets", x = "Workflow Rank", y = "Accuracy", color = "Model Types", shape = "Recipes")</span></pre><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi nf"><img src="../Images/1d5a2b899374605692640bf519765fff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fhnuXXe1zxs74st0bICJ7Q.png"/></div></div><p class="lo lp gj gh gi lq lr bd b be z dk translated">所有工作流的性能比较(图片由作者提供)</p></figure><p id="81e1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从上面我们可以观察到:</p><ul class=""><li id="e69c" class="mn mo iq kh b ki kj kl km ko mp ks mq kw mr la ms mt mu mv bi translated">朴素贝叶斯和KNN模型表现最差</li><li id="9401" class="mn mo iq kh b ki mw kl mx ko my ks mz kw na la ms mt mu mv bi translated">基于树的方法表现得非常好</li><li id="a96e" class="mn mo iq kh b ki mw kl mx ko my ks mz kw na la ms mt mu mv bi translated">SMOTE没有提高更复杂模型类型的性能，决策树模型的配方之间没有变化。</li></ul><p id="6897" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">虽然我们已经进行了非常一般的初步观察，但考虑到前8个工作流的平均准确性略有不同，我们如何辨别哪些是不同的，或者实际上是相同的？</p><p id="e24d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">重采样的事后分析—潮汐先验</strong></p><p id="a27c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">比较模型的一种方法是检查重采样结果，并询问模型实际上不同吗？<br/>tidyposterior::perf _ mod函数通过为给定指标生成一组后验分布来比较我们所有的工作流组合，然后可以将这些后验分布相互比较，以实现实际等效性。本质上，我们可以进行工作流之间的比较。</p><pre class="ld le lf lg gt lz ma mb mc aw md bi"><span id="3502" class="me mf iq ma b gy mg mh l mi mj">doParallel::registerDoParallel(cores = 12)<br/>set.seed(246)<br/>acc_model_eval &lt;- perf_mod(all_workflows, metric = "accuracy", iter = 5000)</span></pre><figure class="ld le lf lg gt lh gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/ef1d38f339fe4068220ba85d54a9ad54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1290/format:webp/1*I8EpnggdEy3A6VU6pt3UPw.png"/></div><p class="lo lp gj gh gi lq lr bd b be z dk translated">perf_mod的示例输出(图片由作者提供)</p></figure><p id="d838" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后将perf_mod的结果传递给tidy()以提取后验分析的基本发现。它们的分布如下图所示。</p><pre class="ld le lf lg gt lz ma mb mc aw md bi"><span id="eb98" class="me mf iq ma b gy mg mh l mi mj"><strong class="ma ir">#Extract Results from Posterior Analysis and Visualise Distributions<br/></strong>acc_model_eval %&gt;% <br/>  tidy() %&gt;% <br/>  mutate(model = fct_inorder(model)) %&gt;% <br/>  ggplot(aes(x=posterior)) +<br/>   geom_histogram(bins = 50) +<br/>   theme_minimal() +<br/>   facet_wrap(~model, nrow = 7, ncol = 6) +<br/>   labs(title = "Comparison of Posterior Distributions of Model Recipe Combinations", x = expression(paste("Posterior for Mean Accuracy")), y = "")</span></pre><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi nh"><img src="../Images/449b4108e86af80f715ab66e5af2cd32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GzG0apwLNZWUpeXH87tPdw.png"/></div></div><p class="lo lp gj gh gi lq lr bd b be z dk translated">所有工作流的平均准确度的后验分布(按作者分类的图片)</p></figure><p id="2de9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">回顾我们的性能比较，我们观察到两个最高等级的模型是提升树和具有Recipe1的决策树，这些模型处于基于树的模型的可解释性范围的极端。我们可以通过取它们各自后验分布的差异来寻求进一步的理解。</p><p id="8b88" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用contrast_models()我们可以进行这种分析。</p><pre class="ld le lf lg gt lz ma mb mc aw md bi"><span id="84c9" class="me mf iq ma b gy mg mh l mi mj"><strong class="ma ir">#Compare Two Models - Difference in Means</strong><br/>mod_compare &lt;- contrast_models(acc_model_eval,<br/>                            list_1 = "Recipe1_Decision_Tree",<br/>                            list_2 = "Recipe1_Boosted_Trees")</span><span id="09df" class="me mf iq ma b gy mk mh l mi mj">a1 &lt;- mod_compare %&gt;% <br/>  as_tibble() %&gt;% <br/>  ggplot(aes(x=difference)) +<br/>  geom_histogram(bins = 50, col = "white", fill = "#73D055FF")+<br/>  geom_vline(xintercept = 0, lty = 2) +<br/>  theme_minimal()+<br/>  scale_fill_viridis_b()+<br/>  labs(x= "Posterior for Mean Difference in Accuracy", y="", title = "Posterior Mean Difference Recipe1_Decision_Tree &amp; Recipe3_Boosted_Trees")</span><span id="92b9" class="me mf iq ma b gy mk mh l mi mj">a2 &lt;- acc_model_eval %&gt;% <br/>  tidy() %&gt;% mutate(model = fct_inorder(model)) %&gt;% <br/>  filter(model %in% c("Recipe1_Boosted_Trees", "Recipe1_Decision_Tree")) %&gt;% <br/>  ggplot(aes(x=posterior)) +<br/>  geom_histogram(bins = 50, col = "white", fill = "#73D055FF") +<br/>  theme_minimal()+<br/>  scale_colour_viridis_b() +<br/>  facet_wrap(~model, nrow = 2, ncol = 1) +<br/>  labs(title = "Comparison of Posterior Distributions of Model Recipe Combinations", x = expression(paste("Posterior for Mean Accuracy")), y = "")</span><span id="3727" class="me mf iq ma b gy mk mh l mi mj">a2/a1</span></pre><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi nf"><img src="../Images/470f8ac6c7d3ee2399975798fba2a3b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jIK5YQ4naT1FTarRBAJ53g.png"/></div></div><p class="lo lp gj gh gi lq lr bd b be z dk translated">个体平均准确性后验分布及其差异(图片由作者提供)</p></figure><p id="befa" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通过管道将mod_compare对象传递给summary会生成以下输出</p><pre class="ld le lf lg gt lz ma mb mc aw md bi"><span id="99b0" class="me mf iq ma b gy mg mh l mi mj">mod_compare %&gt;% summary()<br/>mean<br/>0.001371989 <strong class="ma ir">#Difference in means between posterior distributions</strong><br/>probability<br/>0.5842 <strong class="ma ir">#Proportion of Posterior of Mean Difference &gt; 0</strong></span></pre><p id="93c0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如平均差异的后验所证明的，平均准确度的各个工作流程后验分布之间的平均差异较小。均值分布的后验差有58.4%在0以上，所以我们可以推断正差是真实存在的(虽然很轻微)。</p><p id="c5c4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以用实际等价的概念做进一步的研究。</p><pre class="ld le lf lg gt lz ma mb mc aw md bi"><span id="a33e" class="me mf iq ma b gy mg mh l mi mj">summary(mod_compare, size = 0.02)<br/>pract_equiv<br/>0.9975</span></pre><p id="ac45" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">效应大小是均值后验分布差异两侧的阈值[-0.02，0.02]，pract_equiv测量差异的大小。in的意思是邮政。分布在这些阈值内。在我们的比较中，Boosted_Trees在决策树的后验分布中占99.75%。</p><p id="1aad" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以为以下所有工作流完成此练习。</p><pre class="ld le lf lg gt lz ma mb mc aw md bi"><span id="dbc1" class="me mf iq ma b gy mg mh l mi mj"><strong class="ma ir">#Pluck and modify underlying tibble from autoplot()</strong><br/>autoplot(acc_model_eval, type = "ROPE", size = 0.02) %&gt;% <br/>  pluck("data") %&gt;% <br/>  mutate(rank = row_number(-pract_equiv)) %&gt;% <br/>  arrange(rank) %&gt;% <br/>  separate(model, into = c("Recipe", "Model_Type"), sep = "_", remove = F, extra = "merge") %&gt;% <br/>  ggplot(aes(x=rank, y= pract_equiv, color = Model_Type, shape = Recipe)) +<br/>   geom_point(size = 5) +<br/>   theme_minimal() +<br/>   scale_colour_viridis_d() +<br/>   labs(y= "Practical Equivalance", x = "Workflow Rank", size = "Probability of Practical Equivalence", color = "Model Type", title = "Practical Equivalence of Workflow Sets", subtitle = "Calculated Using an Effect Size of 0.02")</span></pre><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi nf"><img src="../Images/e5d5cc63e7c35295eeaf16b566a1af35.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Xn9PgnPrBEqxGo5Ygln-Xw.png"/></div></div><p class="lo lp gj gh gi lq lr bd b be z dk translated">效果大小为0.02的工作流的实际等效性(图片由作者提供)</p></figure><p id="e790" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们已经获取了支持进行ROPE(实际等价区域)计算的autoplot对象的数据，以便我们可以设计和显示更多的功能。这样，我们可以使用Recipe1_Decision_Tree作为基准，轻松地比较每个工作流。有几个工作流的性能可能与Recipe1_Decision_Tree一样好。</p><p id="caf7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">前两个候选树Boosted_Trees和Decision_Tree位于可解释性光谱的两端。Boosted Trees在很大程度上是一种黑盒方法，相反决策树更容易理解，在这种情况下<strong class="kh ir">提供了最佳结果</strong>，因此我们将在使用Recipe1_Decision_Tree的基础上完成我们的工作流。</p><pre class="ld le lf lg gt lz ma mb mc aw md bi"><span id="f90e" class="me mf iq ma b gy mg mh l mi mj"><strong class="ma ir">#Pull Best Performing Hyperparameter Set From workflow_map Object</strong><br/>best_result &lt;- all_workflows %&gt;% <br/>  pull_workflow_set_result("Recipe1_Decision_Tree") %&gt;% <br/>  select_best(metric = "accuracy")</span><span id="93be" class="me mf iq ma b gy mk mh l mi mj"><strong class="ma ir">#Finalise Workflow Object With Best Parameters</strong><br/>dt_wf &lt;- all_workflows %&gt;% <br/>  pull_workflow("Recipe1_Decision_Tree") %&gt;% <br/>  finalize_workflow(best_result)</span><span id="d366" class="me mf iq ma b gy mk mh l mi mj"><strong class="ma ir">#Fit Workflow Object to Training Data and Predict Using Test Dataset</strong><br/>dt_res &lt;- <br/>  dt_wf %&gt;%<br/>  fit(training(loan_split)) %&gt;% <br/>  predict(new_data = testing(loan_split)) %&gt;% <br/>  bind_cols(loan_test) %&gt;% <br/>  mutate(.pred_class = fct_infreq(.pred_class),<br/>         Loan_Status = fct_infreq(Loan_Status))</span><span id="f80a" class="me mf iq ma b gy mk mh l mi mj"><strong class="ma ir">#Calculate Accuracy of Prediction<br/></strong>accuracy(dt_res, truth = Loan_Status, estimate = .pred_class)</span></pre><figure class="ld le lf lg gt lh gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/bc228817055aaade48581a5cf92c784f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1380/format:webp/1*_md-0Qn2F6Wxoqi_ep510A.png"/></div><p class="lo lp gj gh gi lq lr bd b be z dk translated">针对测试数据的模型准确性(图片由作者提供)</p></figure><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi nd"><img src="../Images/d75a9c72d3615f9875caad060b881ae7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G_1HEq6PuepWINLXqjP2IQ.png"/></div></div><p class="lo lp gj gh gi lq lr bd b be z dk translated">预测的混淆矩阵(图片由作者提供)</p></figure><p id="69f5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们的最终模型已经成功地生成了一个非常强的结果，在测试数据集上的准确率为84.68%。该模型在预测已批贷款的批准情况方面总体表现良好。然而，模型是批准贷款，由银行决定反对。这是一个奇怪的案例，显然，银行提供的贷款越多，收入潜力就越大，风险敞口也就越大。这表明数据集包含一些模型无法完全区分的不一致，并且根据训练集中的观察结果已经被“混淆”。</p><p id="3207" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这为模型的可解释性提供了一个论据，在这个例子中，我们不能产生更多的数据，那么我们如何知道预测的基础呢？</p><pre class="ld le lf lg gt lz ma mb mc aw md bi"><span id="0b91" class="me mf iq ma b gy mg mh l mi mj"><strong class="ma ir">#Fit and Extract Fit from Workflow Object</strong><br/>dt_wf_fit &lt;- <br/>  dt_wf %&gt;% <br/>  fit(training(loan_split))</span><span id="d64a" class="me mf iq ma b gy mk mh l mi mj">dt_fit &lt;- <br/>  dt_wf_fit %&gt;% <br/>  pull_workflow_fit()</span><span id="f92c" class="me mf iq ma b gy mk mh l mi mj"><strong class="ma ir">#Generate Decision Tree Plot Using rpart.plot package</strong><br/>rpart.plot::rpart.plot(dt_fit$fit)</span></pre><figure class="ld le lf lg gt lh gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/8fbaeec728ac598a4a0c108fedf577e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/format:webp/1*VzG7mtZD2kyAwQUrfCONWw.png"/></div><p class="lo lp gj gh gi lq lr bd b be z dk translated">模型决策的决策树图(图片由作者提供)</p></figure><p id="d95e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">由于我们的模型简单到足以可视化和理解，一个树状图就足够了。</p><p id="3bf5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们立即观察到，该决定完全基于信用历史的存在。该模型还错误地向申请人提供未知的信用历史(= 0)，并拒绝没有信用历史的申请人(信用历史= -1)。上面提到的不一致是显而易见的，并不是每个有信用记录的人都能获得贷款，但这肯定会有帮助。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><p id="69f1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">结论</strong></p><p id="8631" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你回到你的CDO，解释你的发现。他们对准确性结果印象深刻，但现在企业必须权衡允许信用历史未知的应用程序违约的风险，以及否则可能产生的潜在收入。</p><p id="c6fe" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">本文试图解释Tidymodels生态系统中workflow_sets的强大功能。此外，我们已经探索了“没有免费的午餐”定理，即没有一个模型可以说是更好或最好的，因此为什么筛选许多模型是最佳实践。响应良好的模型类型也取决于所执行的特征工程。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><p id="f466" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">感谢您阅读我的第二本出版物。如果你对Tidymodels感兴趣，我发布了一个介绍性项目，解释了构建<a class="ae lb" rel="noopener" target="_blank" href="/big-sales-mart-regression-revisited-enter-the-tidymodels-a6a432be58d4">回归模型</a>时的每个核心包。</p><p id="abc3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我要感谢Julie Slige和Max Kuhn在开发Tidymodels生态系统方面所做的出色工作。他们正在写的书可以在https://www.tmwr.org/<a class="ae lb" href="https://www.tmwr.org/" rel="noopener ugc nofollow" target="_blank">看到，这对我的理解很有帮助。</a></p></div></div>    
</body>
</html>